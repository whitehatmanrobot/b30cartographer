
				 0x01, 0x00, 0x00, 0x00, 0x00, 0x68};

BYTE t5464_Mode_1024x768x32_2[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x13, 0xF0, 0x00, 0x1E, 0x00, 0xFF, 0xEF, 0x00, 
				 0x00, 0x19, 0xF0, 0x00, 0x16, 0x05, 0x04, 0x00, 
				 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 0x00, 
				 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 0x00, 
				 0x1F, 0x01, 0x00, 0x18, 0x07, 0x04, 0x15, 0xA0, 
				 0x00, 0xFF, 0x00, 0x09, 0xCE, 0x03, 0x06, 0x05, 
				 0x16, 0x80, 0x00, 0xEF, 0x00, 0x16, 0x84, 0x00, 
				 0x1A, 0x00, 0x16, 0x88, 0x00, 0x3B, 0x00, 0x1D, 
				 0x19, 0x00, 0x00, 0x00, 0xA3, 0x00, 0x00, 0x00, 
				 0x7F, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 
				 0x83, 0x00, 0x00, 0x00, 0x84, 0x00, 0x00, 0x00, 
				 0x95, 0x00, 0x00, 0x00, 0x24, 0x00, 0x00, 0x00, 
				 0xFD, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 
				 0x88, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 
				 0xA0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x24, 0x00, 0x00, 0x00, 
				 0xE3, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 
				 0x1D, 0x06, 0x00, 0x64, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0xE0, 0x00, 0x00, 0x00, 0x22, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x13, 0xEA, 0x00, 
				 0x1E, 0x00, 0x00, 0xC0, 0x00, 0x00, 0x1E, 0x01, 
				 0xDE, 0x10, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 
				 0xEA, 0x00, 0x12, 0x07, 0x04, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x10, 0x00, 0x00, 
				 0x00, 0x18, 0x07, 0x04, 0x16, 0x02, 0x04, 0x00, 
				 0x68, 0x16, 0xC0, 0x00, 0x00, 0x34, 0x17, 0x4C, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x17, 0x74, 0x00, 
				 0x01, 0x00, 0x00, 0x00, 0x00, 0x68};

BYTE t5464_Mode_640x480x8_1[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x13, 0xF0, 0x00, 0x1E, 0x00, 0xFF, 0xEF, 0x00, 
				 0x00, 0x19, 0xF0, 0x00, 0x16, 0x05, 0x04, 0x00, 
				 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 0x00, 
				 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 0x00, 
				 0x1F, 0x01, 0x00, 0x18, 0x07, 0x04, 0x15, 0xA0, 
				 0x00, 0xFF, 0x00, 0x09, 0xCE, 0x03, 0x06, 0x05, 
				 0x16, 0x80, 0x00, 0xEF, 0x00, 0x16, 0x84, 0x00, 
				 0x3F, 0x00, 0x16, 0x88, 0x00, 0x6D, 0x00, 0x1D, 
				 0x19, 0x00, 0x00, 0x00, 0x5F, 0x00, 0x00, 0x00, 
				 0x4F, 0x00, 0x00, 0x00, 0x50, 0x00, 0x00, 0x00, 
				 0x9E, 0x00, 0x00, 0x00, 0x54, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x0B, 0x00, 0x00, 0x00, 
				 0x3E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0xE9, 0x00, 0x00, 0x00, 
				 0x8B, 0x00, 0x00, 0x00, 0xDF, 0x00, 0x00, 0x00, 
				 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0xE7, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 
				 0xE3, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 
				 0x1D, 0x06, 0x00, 0x64, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x90, 0x00, 0x00, 0x00, 0x22, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x13, 0xEA, 0x00, 
				 0x1E, 0x00, 0x00, 0xC0, 0x00, 0x00, 0x1E, 0x01, 
				 0x91, 0x08, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 
				 0xEA, 0x00, 0x12, 0x07, 0x04, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x08, 0x00, 0x00, 
				 0x00, 0x18, 0x07, 0x04, 0x16, 0x02, 0x04, 0x00, 
				 0x00, 0x16, 0xC0, 0x00, 0x00, 0x00, 0x00, 0x4C};

BYTE t5464_Mode_640x480x8_2[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x13, 0xF0, 0x00, 0x1E, 0x00, 0xFF, 0xEF, 0x00, 
				 0x00, 0x19, 0xF0, 0x00, 0x16, 0x05, 0x04, 0x00, 
				 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 0x00, 
				 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 0x00, 
				 0x1F, 0x01, 0x00, 0x18, 0x07, 0x04, 0x15, 0xA0, 
				 0x00, 0xFF, 0x00, 0x09, 0xCE, 0x03, 0x06, 0x05, 
				 0x16, 0x80, 0x00, 0xEF, 0x00, 0x16, 0x84, 0x00, 
				 0x0A, 0x00, 0x16, 0x88, 0x00, 0x0B, 0x00, 0x1D, 
				 0x19, 0x00, 0x00, 0x00, 0x63, 0x00, 0x00, 0x00, 
				 0x4F, 0x00, 0x00, 0x00, 0x50, 0x00, 0x00, 0x00, 
				 0x82, 0x00, 0x00, 0x00, 0x54, 0x00, 0x00, 0x00, 
				 0x99, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 
				 0x3E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0xE8, 0x00, 0x00, 0x00, 
				 0x8B, 0x00, 0x00, 0x00, 0xDF, 0x00, 0x00, 0x00, 
				 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0xE7, 0x00, 0x00, 0x00, 0xF3, 0x00, 0x00, 0x00, 
				 0xE3, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 
				 0x1D, 0x06, 0x00, 0x64, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x50, 0x00, 0x00, 0x00, 0x22, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x13, 0xEA, 0x00, 
				 0x1E, 0x00, 0x00, 0xC0, 0x00, 0x00, 0x1E, 0x01, 
				 0x91, 0x08, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 
				 0xEA, 0x00, 0x12, 0x07, 0x04, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x08, 0x00, 0x00, 
				 0x00, 0x18, 0x07, 0x04, 0x16, 0x02, 0x04, 0x00, 
				 0x00, 0x16, 0xC0, 0x00, 0x00, 0x00, 0x00, 0x4C};

BYTE t5464_Mode_640x480x8_3[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x13, 0xF0, 0x00, 0x1E, 0x00, 0xFF, 0xEF, 0x00, 
				 0x00, 0x19, 0xF0, 0x00, 0x16, 0x05, 0x04, 0x00, 
				 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 0x00, 
				 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 0x00, 
				 0x1F, 0x01, 0x00, 0x18, 0x07, 0x04, 0x15, 0xA0, 
				 0x00, 0xFF, 0x00, 0x09, 0xCE, 0x03, 0x06, 0x05, 
				 0x16, 0x80, 0x00, 0xEF, 0x00, 0x16, 0x84, 0x00, 
				 0x0A, 0x00, 0x16, 0x88, 0x00, 0x0B, 0x00, 0x1D, 
				 0x19, 0x00, 0x00, 0x00, 0x64, 0x00, 0x00, 0x00, 
				 0x4F, 0x00, 0x00, 0x00, 0x50, 0x00, 0x00, 0x00, 
				 0x82, 0x00, 0x00, 0x00, 0x54, 0x00, 0x00, 0x00, 
				 0x9C, 0x00, 0x00, 0x00, 0xF2, 0x00, 0x00, 0x00, 
				 0x1F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0xE0, 0x00, 0x00, 0x00, 
				 0x83, 0x00, 0x00, 0x00, 0xDF, 0x00, 0x00, 0x00, 
				 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0xDF, 0x00, 0x00, 0x00, 0xF2, 0x00, 0x00, 0x00, 
				 0xE3, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 
				 0x1D, 0x06, 0x00, 0x64, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x50, 0x00, 0x00, 0x00, 0x22, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x13, 0xEA, 0x00, 
				 0x1E, 0x00, 0x00, 0xC0, 0x00, 0x00, 0x1E, 0x01, 
				 0x91, 0x08, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 
				 0xEA, 0x00, 0x12, 0x07, 0x04, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x08, 0x00, 0x00, 
				 0x00, 0x18, 0x07, 0x04, 0x16, 0x02, 0x04, 0x00, 
				 0x00, 0x16, 0xC0, 0x00, 0x00, 0x00, 0x00, 0x4C};

BYTE t5464_Mode_640x480x8_4[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x13, 0xF0, 0x00, 0x1E, 0x00, 0xFF, 0xEF, 0x00, 
				 0x00, 0x19, 0xF0, 0x00, 0x16, 0x05, 0x04, 0x00, 
				 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 0x00, 
				 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 0x00, 
				 0x1F, 0x01, 0x00, 0x18, 0x07, 0x04, 0x15, 0xA0, 
				 0x00, 0xFF, 0x00, 0x09, 0xCE, 0x03, 0x06, 0x05, 
				 0x16, 0x80, 0x00, 0xEF, 0x00, 0x16, 0x84, 0x00, 
				 0x33, 0x00, 0x16, 0x88, 0x00, 0x7E, 0x00, 0x1D, 
				 0x19, 0x00, 0x00, 0x00, 0x63, 0x00, 0x00, 0x00, 
				 0x4F, 0x00, 0x00, 0x00, 0x50, 0x00, 0x00, 0x00, 
				 0x82, 0x00, 0x00, 0x00, 0x55, 0x00, 0x00, 0x00, 
				 0x9B, 0x00, 0x00, 0x00, 0xFB, 0x00, 0x00, 0x00, 
				 0x1F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0xE0, 0x00, 0x00, 0x00, 
				 0x83, 0x00, 0x00, 0x00, 0xDF, 0x00, 0x00, 0x00, 
				 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0xDF, 0x00, 0x00, 0x00, 0xF9, 0x00, 0x00, 0x00, 
				 0xE3, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 
				 0x1D, 0x06, 0x00, 0x64, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x50, 0x00, 0x00, 0x00, 0x22, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x13, 0xEA, 0x00, 
				 0x1E, 0x00, 0x00, 0xC0, 0x00, 0x00, 0x1E, 0x01, 
				 0x91, 0x08, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 
				 0xEA, 0x00, 0x12, 0x07, 0x04, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x08, 0x00, 0x00, 
				 0x00, 0x18, 0x07, 0x04, 0x16, 0x02, 0x04, 0x00, 
				 0x00, 0x16, 0xC0, 0x00, 0x00, 0x00, 0x00, 0x4C};

BYTE t5464_Mode_640x480x8_1a[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x13, 0xF0, 0x00, 0x1E, 0x00, 0xFF, 0xEF, 0x00, 
				 0x00, 0x19, 0xF0, 0x00, 0x16, 0x05, 0x04, 0x00, 
				 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 0x00, 
				 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 0x00, 
				 0x1F, 0x01, 0x00, 0x18, 0x07, 0x04, 0x15, 0xA0, 
				 0x00, 0xFF, 0x00, 0x09, 0xCE, 0x03, 0x06, 0x05, 
				 0x16, 0x80, 0x00, 0xEF, 0x00, 0x16, 0x84, 0x00, 
				 0x3F, 0x00, 0x16, 0x88, 0x00, 0x6D, 0x00, 0x1D, 
				 0x19, 0x00, 0x00, 0x00, 0x5F, 0x00, 0x00, 0x00, 
				 0x4F, 0x00, 0x00, 0x00, 0x50, 0x00, 0x00, 0x00, 
				 0x9E, 0x00, 0x00, 0x00, 0x54, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x0B, 0x00, 0x00, 0x00, 
				 0x3E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0xE9, 0x00, 0x00, 0x00, 
				 0x8B, 0x00, 0x00, 0x00, 0xDF, 0x00, 0x00, 0x00, 
				 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0xE7, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 
				 0xE3, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 
				 0x1D, 0x06, 0x00, 0x64, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x90, 0x00, 0x00, 0x00, 0x22, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x13, 0xEA, 0x00, 
				 0x1E, 0x00, 0x00, 0xC0, 0x00, 0x00, 0x1E, 0x01, 
				 0x91, 0x0A, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 
				 0xEA, 0x00, 0x12, 0x07, 0x04, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x0A, 0x00, 0x00, 
				 0x00, 0x18, 0x07, 0x04, 0x16, 0x02, 0x04, 0x00, 
				 0x00, 0x16, 0xC0, 0x00, 0x00, 0x00, 0x17, 0x4C, 
				 0x00, 0xA0, 0x00, 0x00, 0x00, 0x00, 0x74};

BYTE t5464_Mode_640x480x8_2a[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x13, 0xF0, 0x00, 0x1E, 0x00, 0xFF, 0xEF, 0x00, 
				 0x00, 0x19, 0xF0, 0x00, 0x16, 0x05, 0x04, 0x00, 
				 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 0x00, 
				 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 0x00, 
				 0x1F, 0x01, 0x00, 0x18, 0x07, 0x04, 0x15, 0xA0, 
				 0x00, 0xFF, 0x00, 0x09, 0xCE, 0x03, 0x06, 0x05, 
				 0x16, 0x80, 0x00, 0xEF, 0x00, 0x16, 0x84, 0x00, 
				 0x0A, 0x00, 0x16, 0x88, 0x00, 0x0B, 0x00, 0x1D, 
				 0x19, 0x00, 0x00, 0x00, 0x63, 0x00, 0x00, 0x00, 
				 0x4F, 0x00, 0x00, 0x00, 0x50, 0x00, 0x00, 0x00, 
				 0x82, 0x00, 0x00, 0x00, 0x54, 0x00, 0x00, 0x00, 
				 0x99, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 
				 0x3E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0xE8, 0x00, 0x00, 0x00, 
				 0x8B, 0x00, 0x00, 0x00, 0xDF, 0x00, 0x00, 0x00, 
				 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0xE7, 0x00, 0x00, 0x00, 0xF3, 0x00, 0x00, 0x00, 
				 0xE3, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 
				 0x1D, 0x06, 0x00, 0x64, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x50, 0x00, 0x00, 0x00, 0x22, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x13, 0xEA, 0x00, 
				 0x1E, 0x00, 0x00, 0xC0, 0x00, 0x00, 0x1E, 0x01, 
				 0x91, 0x0A, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 
				 0xEA, 0x00, 0x12, 0x07, 0x04, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x0A, 0x00, 0x00, 
				 0x00, 0x18, 0x07, 0x04, 0x16, 0x02, 0x04, 0x00, 
				 0x00, 0x16, 0xC0, 0x00, 0x00, 0x00, 0x17, 0x4C, 
				 0x00, 0xA0, 0x00, 0x00, 0x00, 0x00, 0x74};

BYTE t5464_Mode_640x480x8_3a[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x13, 0xF0, 0x00, 0x1E, 0x00, 0xFF, 0xEF, 0x00, 
				 0x00, 0x19, 0xF0, 0x00, 0x16, 0x05, 0x04, 0x00, 
				 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 0x00, 
				 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 0x00, 
				 0x1F, 0x01, 0x00, 0x18, 0x07, 0x04, 0x15, 0xA0, 
				 0x00, 0xFF, 0x00, 0x09, 0xCE, 0x03, 0x06, 0x05, 
				 0x16, 0x80, 0x00, 0xEF, 0x00, 0x16, 0x84, 0x00, 
				 0x0A, 0x00, 0x16, 0x88, 0x00, 0x0B, 0x00, 0x1D, 
				 0x19, 0x00, 0x00, 0x00, 0x64, 0x00, 0x00, 0x00, 
				 0x4F, 0x00, 0x00, 0x00, 0x50, 0x00, 0x00, 0x00, 
				 0x82, 0x00, 0x00, 0x00, 0x54, 0x00, 0x00, 0x00, 
				 0x9C, 0x00, 0x00, 0x00, 0xF2, 0x00, 0x00, 0x00, 
				 0x1F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0xE0, 0x00, 0x00, 0x00, 
				 0x83, 0x00, 0x00, 0x00, 0xDF, 0x00, 0x00, 0x00, 
				 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0xDF, 0x00, 0x00, 0x00, 0xF2, 0x00, 0x00, 0x00, 
				 0xE3, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 
				 0x1D, 0x06, 0x00, 0x64, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x50, 0x00, 0x00, 0x00, 0x22, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x13, 0xEA, 0x00, 
				 0x1E, 0x00, 0x00, 0xC0, 0x00, 0x00, 0x1E, 0x01, 
				 0x91, 0x0A, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 
				 0xEA, 0x00, 0x12, 0x07, 0x04, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x0A, 0x00, 0x00, 
				 0x00, 0x18, 0x07, 0x04, 0x16, 0x02, 0x04, 0x00, 
				 0x00, 0x16, 0xC0, 0x00, 0x00, 0x00, 0x17, 0x4C, 
				 0x00, 0xA0, 0x00, 0x00, 0x00, 0x00, 0x74};

BYTE t5464_Mode_640x480x8_4a[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x13, 0xF0, 0x00, 0x1E, 0x00, 0xFF, 0xEF, 0x00, 
				 0x00, 0x19, 0xF0, 0x00, 0x16, 0x05, 0x04, 0x00, 
				 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 0x00, 
				 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 0x00, 
				 0x1F, 0x01, 0x00, 0x18, 0x07, 0x04, 0x15, 0xA0, 
				 0x00, 0xFF, 0x00, 0x09, 0xCE, 0x03, 0x06, 0x05, 
				 0x16, 0x80, 0x00, 0xEF, 0x00, 0x16, 0x84, 0x00, 
				 0x33, 0x00, 0x16, 0x88, 0x00, 0x7E, 0x00, 0x1D, 
				 0x19, 0x00, 0x00, 0x00, 0x63, 0x00, 0x00, 0x00, 
				 0x4F, 0x00, 0x00, 0x00, 0x50, 0x00, 0x00, 0x00, 
				 0x82, 0x00, 0x00, 0x00, 0x55, 0x00, 0x00, 0x00, 
				 0x9B, 0x00, 0x00, 0x00, 0xFB, 0x00, 0x00, 0x00, 
				 0x1F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0xE0, 0x00, 0x00, 0x00, 
				 0x83, 0x00, 0x00, 0x00, 0xDF, 0x00, 0x00, 0x00, 
				 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0xDF, 0x00, 0x00, 0x00, 0xF9, 0x00, 0x00, 0x00, 
				 0xE3, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 
				 0x1D, 0x06, 0x00, 0x64, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x50, 0x00, 0x00, 0x00, 0x22, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x13, 0xEA, 0x00, 
				 0x1E, 0x00, 0x00, 0xC0, 0x00, 0x00, 0x1E, 0x01, 
				 0x91, 0x0A, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 
				 0xEA, 0x00, 0x12, 0x07, 0x04, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x0A, 0x00, 0x00, 
				 0x00, 0x18, 0x07, 0x04, 0x16, 0x02, 0x04, 0x00, 
				 0x00, 0x16, 0xC0, 0x00, 0x00, 0x00, 0x17, 0x4C, 
				 0x00, 0xA0, 0x00, 0x00, 0x00, 0x00, 0x74};

BYTE t5464_Mode_320x200x8_1[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x13, 0xF0, 0x00, 0x1E, 0x00, 0xFF, 0xEF, 0x00, 
				 0x00, 0x19, 0xF0, 0x00, 0x16, 0x05, 0x04, 0x00, 
				 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 0x00, 
				 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 0x00, 
				 0x1F, 0x01, 0x00, 0x18, 0x07, 0x04, 0x15, 0xA0, 
				 0x00, 0xFF, 0x00, 0x09, 0xCE, 0x03, 0x06, 0x05, 
				 0x16, 0x80, 0x00, 0x2F, 0x00, 0x16, 0x84, 0x00, 
				 0x42, 0x00, 0x16, 0x88, 0x00, 0x1D, 0x00, 0x1D, 
				 0x19, 0x00, 0x00, 0x00, 0x2D, 0x00, 0x00, 0x00, 
				 0x27, 0x00, 0x00, 0x00, 0x28, 0x00, 0x00, 0x00, 
				 0x8D, 0x00, 0x00, 0x00, 0x2A, 0x00, 0x00, 0x00, 
				 0x8B, 0x00, 0x00, 0x00, 0xA0, 0x00, 0x00, 0x00, 
				 0x1F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0xC0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x91, 0x00, 0x00, 0x00, 
				 0x84, 0x00, 0x00, 0x00, 0x8F, 0x00, 0x00, 0x00, 
				 0x50, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x90, 0x00, 0x00, 0x00, 0xA0, 0x00, 0x00, 0x00, 
				 0xE3, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 
				 0x1D, 0x06, 0x00, 0x64, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x40, 0x00, 0x00, 0x00, 0x22, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x13, 0xEA, 0x00, 
				 0x1E, 0x00, 0x00, 0xC0, 0x00, 0x00, 0x1E, 0x01, 
				 0x91, 0x05, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 
				 0xEA, 0x00, 0x12, 0x07, 0x04, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 
				 0x00, 0x18, 0x07, 0x04, 0x16, 0x02, 0x04, 0x00, 
				 0x00, 0x16, 0xC0, 0x00, 0x00, 0x00, 0x00, 0x4C};

BYTE t5464_Mode_320x240x8_1[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x13, 0xF0, 0x00, 0x1E, 0x00, 0xFF, 0xEF, 0x00, 
				 0x00, 0x19, 0xF0, 0x00, 0x16, 0x05, 0x04, 0x00, 
				 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 0x00, 
				 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 0x00, 
				 0x1F, 0x01, 0x00, 0x18, 0x07, 0x04, 0x15, 0xA0, 
				 0x00, 0xFF, 0x00, 0x09, 0xCE, 0x03, 0x06, 0x05, 
				 0x16, 0x80, 0x00, 0xEF, 0x00, 0x16, 0x84, 0x00, 
				 0x42, 0x00, 0x16, 0x88, 0x00, 0x1D, 0x00, 0x1D, 
				 0x19, 0x00, 0x00, 0x00, 0x2D, 0x00, 0x00, 0x00, 
				 0x27, 0x00, 0x00, 0x00, 0x27, 0x00, 0x00, 0x00, 
				 0x8C, 0x00, 0x00, 0x00, 0x2A, 0x00, 0x00, 0x00, 
				 0x8C, 0x00, 0x00, 0x00, 0x0B, 0x00, 0x00, 0x00, 
				 0x3E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0xC0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0xE1, 0x00, 0x00, 0x00, 
				 0x83, 0x00, 0x00, 0x00, 0xDF, 0x00, 0x00, 0x00, 
				 0x50, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0xDF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0xE3, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 
				 0x1D, 0x06, 0x00, 0x64, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x80, 0x00, 0x00, 0x00, 0x22, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x13, 0xEA, 0x00, 
				 0x1E, 0x00, 0x00, 0xC0, 0x00, 0x00, 0x1E, 0x01, 
				 0x91, 0x05, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 
				 0xEA, 0x00, 0x12, 0x07, 0x04, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 
				 0x00, 0x18, 0x07, 0x04, 0x16, 0x02, 0x04, 0x00, 
				 0x00, 0x16, 0xC0, 0x00, 0x00, 0x00, 0x00, 0x4C};

BYTE t5464_Mode_320x240x8_2[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x13, 0xF0, 0x00, 0x1E, 0x00, 0xFF, 0xEF, 0x00, 
				 0x00, 0x19, 0xF0, 0x00, 0x16, 0x05, 0x04, 0x00, 
				 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 0x00, 
				 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 0x00, 
				 0x1F, 0x01, 0x00, 0x18, 0x07, 0x04, 0x15, 0xA0, 
				 0x00, 0xFF, 0x00, 0x09, 0xCE, 0x03, 0x06, 0x05, 
				 0x16, 0x80, 0x00, 0xEF, 0x00, 0x16, 0x84, 0x00, 
				 0x14, 0x00, 0x16, 0x88, 0x00, 0x0B, 0x00, 0x1D, 
				 0x19, 0x00, 0x00, 0x00, 0x2F, 0x00, 0x00, 0x00, 
				 0x27, 0x00, 0x00, 0x00, 0x27, 0x00, 0x00, 0x00, 
				 0x8C, 0x00, 0x00, 0x00, 0x2A, 0x00, 0x00, 0x00, 
				 0x8C, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 
				 0x3E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0xC0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0xE0, 0x00, 0x00, 0x00, 
				 0x83, 0x00, 0x00, 0x00, 0xDF, 0x00, 0x00, 0x00, 
				 0x50, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0xDF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0xE3, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 
				 0x1D, 0x06, 0x00, 0x64, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x80, 0x00, 0x00, 0x00, 0x22, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x13, 0xEA, 0x00, 
				 0x1E, 0x00, 0x00, 0xC0, 0x00, 0x00, 0x1E, 0x01, 
				 0x91, 0x05, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 
				 0xEA, 0x00, 0x12, 0x07, 0x04, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 
				 0x00, 0x18, 0x07, 0x04, 0x16, 0x02, 0x04, 0x00, 
				 0x00, 0x16, 0xC0, 0x00, 0x00, 0x00, 0x00, 0x4C};

BYTE t5464_Mode_320x400x8_1[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x13, 0xF0, 0x00, 0x1E, 0x00, 0xFF, 0xEF, 0x00, 
				 0x00, 0x19, 0xF0, 0x00, 0x16, 0x05, 0x04, 0x00, 
				 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 0x00, 
				 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 0x00, 
				 0x1F, 0x01, 0x00, 0x18, 0x07, 0x04, 0x15, 0xA0, 
				 0x00, 0xFF, 0x00, 0x09, 0xCE, 0x03, 0x06, 0x05, 
				 0x16, 0x80, 0x00, 0x2F, 0x00, 0x16, 0x84, 0x00, 
				 0x42, 0x00, 0x16, 0x88, 0x00, 0x1D, 0x00, 0x1D, 
				 0x19, 0x00, 0x00, 0x00, 0x2D, 0x00, 0x00, 0x00, 
				 0x27, 0x00, 0x00, 0x00, 0x28, 0x00, 0x00, 0x00, 
				 0x8D, 0x00, 0x00, 0x00, 0x2A, 0x00, 0x00, 0x00, 
				 0x8B, 0x00, 0x00, 0x00, 0xA0, 0x00, 0x00, 0x00, 
				 0x1F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x91, 0x00, 0x00, 0x00, 
				 0x84, 0x00, 0x00, 0x00, 0x8F, 0x00, 0x00, 0x00, 
				 0x50, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x90, 0x00, 0x00, 0x00, 0xA0, 0x00, 0x00, 0x00, 
				 0xE3, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 
				 0x1D, 0x06, 0x00, 0x64, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x40, 0x00, 0x00, 0x00, 0x22, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x13, 0xEA, 0x00, 
				 0x1E, 0x00, 0x00, 0xC0, 0x00, 0x00, 0x1E, 0x01, 
				 0x91, 0x05, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 
				 0xEA, 0x00, 0x12, 0x07, 0x04, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 
				 0x00, 0x18, 0x07, 0x04, 0x16, 0x02, 0x04, 0x00, 
				 0x00, 0x16, 0xC0, 0x00, 0x00, 0x00, 0x00, 0x4C};

BYTE t5464_Mode_320x480x8_1[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x13, 0xF0, 0x00, 0x1E, 0x00, 0xFF, 0xEF, 0x00, 
				 0x00, 0x19, 0xF0, 0x00, 0x16, 0x05, 0x04, 0x00, 
				 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 0x00, 
				 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 0x00, 
				 0x1F, 0x01, 0x00, 0x18, 0x07, 0x04, 0x15, 0xA0, 
				 0x00, 0xFF, 0x00, 0x09, 0xCE, 0x03, 0x06, 0x05, 
				 0x16, 0x80, 0x00, 0xEF, 0x00, 0x16, 0x84, 0x00, 
				 0x42, 0x00, 0x16, 0x88, 0x00, 0x1D, 0x00, 0x1D, 
				 0x19, 0x00, 0x00, 0x00, 0x2D, 0x00, 0x00, 0x00, 
				 0x27, 0x00, 0x00, 0x00, 0x27, 0x00, 0x00, 0x00, 
				 0x8C, 0x00, 0x00, 0x00, 0x2A, 0x00, 0x00, 0x00, 
				 0x8C, 0x00, 0x00, 0x00, 0x0B, 0x00, 0x00, 0x00, 
				 0x3E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0xC0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0xE1, 0x00, 0x00, 0x00, 
				 0x83, 0x00, 0x00, 0x00, 0xDF, 0x00, 0x00, 0x00, 
				 0x50, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0xDF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0xE3, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 
				 0x1D, 0x06, 0x00, 0x64, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x80, 0x00, 0x00, 0x00, 0x22, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x17, 0x24, 0x00, 
				 0x40, 0x00, 0x00, 0x00, 0x13, 0xEA, 0x00, 0x1E, 
				 0x00, 0x00, 0xC0, 0x00, 0x00, 0x1E, 0x01, 0x91, 
				 0x05, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 0xEA, 
				 0x00, 0x12, 0x07, 0x04, 0x1E, 0x00, 0xC0, 0x00, 
				 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 0x00, 
				 0x18, 0x07, 0x04, 0x16, 0x02, 0x04, 0x00, 0x00, 
				 0x16, 0xC0, 0x00, 0x00, 0x00, 0x00, 0x74};

BYTE t5464_Mode_320x480x8_2[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x13, 0xF0, 0x00, 0x1E, 0x00, 0xFF, 0xEF, 0x00, 
				 0x00, 0x19, 0xF0, 0x00, 0x16, 0x05, 0x04, 0x00, 
				 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 0x00, 
				 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 0x00, 
				 0x1F, 0x01, 0x00, 0x18, 0x07, 0x04, 0x15, 0xA0, 
				 0x00, 0xFF, 0x00, 0x09, 0xCE, 0x03, 0x06, 0x05, 
				 0x16, 0x80, 0x00, 0xEF, 0x00, 0x16, 0x84, 0x00, 
				 0x14, 0x00, 0x16, 0x88, 0x00, 0x0B, 0x00, 0x1D, 
				 0x19, 0x00, 0x00, 0x00, 0x2F, 0x00, 0x00, 0x00, 
				 0x27, 0x00, 0x00, 0x00, 0x27, 0x00, 0x00, 0x00, 
				 0x8C, 0x00, 0x00, 0x00, 0x2A, 0x00, 0x00, 0x00, 
				 0x8C, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 
				 0x3E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0xC0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0xE0, 0x00, 0x00, 0x00, 
				 0x83, 0x00, 0x00, 0x00, 0xDF, 0x00, 0x00, 0x00, 
				 0x50, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0xDF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0xE3, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 
				 0x1D, 0x06, 0x00, 0x64, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x80, 0x00, 0x00, 0x00, 0x22, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x17, 0x24, 0x00, 
				 0x40, 0x00, 0x00, 0x00, 0x13, 0xEA, 0x00, 0x1E, 
				 0x00, 0x00, 0xC0, 0x00, 0x00, 0x1E, 0x01, 0x91, 
				 0x05, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 0xEA, 
				 0x00, 0x12, 0x07, 0x04, 0x1E, 0x00, 0xC0, 0x00, 
				 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 0x00, 
				 0x18, 0x07, 0x04, 0x16, 0x02, 0x04, 0x00, 0x00, 
				 0x16, 0xC0, 0x00, 0x00, 0x00, 0x00, 0x74};

BYTE t5464_Mode_360x400x8_1[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x13, 0xF0, 0x00, 0x1E, 0x00, 0xFF, 0xEF, 0x00, 
				 0x00, 0x19, 0xF0, 0x00, 0x16, 0x05, 0x04, 0x00, 
				 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 0x00, 
				 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 0x00, 
				 0x1F, 0x01, 0x00, 0x18, 0x07, 0x04, 0x15, 0xA0, 
				 0x00, 0xFF, 0x00, 0x09, 0xCE, 0x03, 0x06, 0x05, 
				 0x16, 0x80, 0x00, 0x2F, 0x00, 0x16, 0x84, 0x00, 
				 0x3C, 0x00, 0x16, 0x88, 0x00, 0x1E, 0x00, 0x1D, 
				 0x19, 0x00, 0x00, 0x00, 0x34, 0x00, 0x00, 0x00, 
				 0x2C, 0x00, 0x00, 0x00, 0x2D, 0x00, 0x00, 0x00, 
				 0x94, 0x00, 0x00, 0x00, 0x2E, 0x00, 0x00, 0x00, 
				 0x92, 0x00, 0x00, 0x00, 0xA0, 0x00, 0x00, 0x00, 
				 0x1F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x91, 0x00, 0x00, 0x00, 
				 0x84, 0x00, 0x00, 0x00, 0x8F, 0x00, 0x00, 0x00, 
				 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x90, 0x00, 0x00, 0x00, 0xA0, 0x00, 0x00, 0x00, 
				 0xE3, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 
				 0x1D, 0x06, 0x00, 0x64, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x40, 0x00, 0x00, 0x00, 0x22, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x13, 0xEA, 0x00, 
				 0x1E, 0x00, 0x00, 0xC0, 0x00, 0x00, 0x1E, 0x01, 
				 0x91, 0x08, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 
				 0xEA, 0x00, 0x12, 0x07, 0x04, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x08, 0x00, 0x00, 
				 0x00, 0x18, 0x07, 0x04, 0x16, 0x02, 0x04, 0x00, 
				 0x00, 0x16, 0xC0, 0x00, 0x00, 0x00, 0x00, 0x00};

BYTE t5464_Mode_360x400x8_2[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x13, 0xF0, 0x00, 0x1E, 0x00, 0xFF, 0xEF, 0x00, 
				 0x00, 0x19, 0xF0, 0x00, 0x16, 0x05, 0x04, 0x00, 
				 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 0x00, 
				 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 0x00, 
				 0x1F, 0x01, 0x00, 0x18, 0x07, 0x04, 0x15, 0xA0, 
				 0x00, 0xFF, 0x00, 0x09, 0xCE, 0x03, 0x06, 0x05, 
				 0x16, 0x80, 0x00, 0x6F, 0x00, 0x16, 0x84, 0x00, 
				 0x32, 0x00, 0x16, 0x88, 0x00, 0x1F, 0x00, 0x1D, 
				 0x19, 0x00, 0x00, 0x00, 0x35, 0x00, 0x00, 0x00, 
				 0x2C, 0x00, 0x00, 0x00, 0x2C, 0x00, 0x00, 0x00, 
				 0x93, 0x00, 0x00, 0x00, 0x2F, 0x00, 0x00, 0x00, 
				 0x90, 0x00, 0x00, 0x00, 0xBC, 0x00, 0x00, 0x00, 
				 0x1F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x90, 0x00, 0x00, 0x00, 
				 0x83, 0x00, 0x00, 0x00, 0x8F, 0x00, 0x00, 0x00, 
				 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x8F, 0x00, 0x00, 0x00, 0xBC, 0x00, 0x00, 0x00, 
				 0xE3, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 
				 0x1D, 0x06, 0x00, 0x64, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x40, 0x00, 0x00, 0x00, 0x22, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x13, 0xEA, 0x00, 
				 0x1E, 0x00, 0x00, 0xC0, 0x00, 0x00, 0x1E, 0x01, 
				 0x91, 0x08, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 
				 0xEA, 0x00, 0x12, 0x07, 0x04, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x08, 0x00, 0x00, 
				 0x00, 0x18, 0x07, 0x04, 0x16, 0x02, 0x04, 0x00, 
				 0x00, 0x16, 0xC0, 0x00, 0x00, 0x00, 0x00, 0x00};

BYTE t5464_Mode_400x300x8_1[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x13, 0xF0, 0x00, 0x1E, 0x00, 0xFF, 0xEF, 0x00, 
				 0x00, 0x19, 0xF0, 0x00, 0x16, 0x05, 0x04, 0x00, 
				 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 0x00, 
				 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 0x00, 
				 0x1F, 0x01, 0x00, 0x18, 0x07, 0x04, 0x15, 0xA0, 
				 0x00, 0xFF, 0x00, 0x09, 0xCE, 0x03, 0x06, 0x05, 
				 0x16, 0x80, 0x00, 0x2F, 0x00, 0x16, 0x84, 0x00, 
				 0x45, 0x00, 0x16, 0x88, 0x00, 0x5F, 0x00, 0x1D, 
				 0x19, 0x00, 0x00, 0x00, 0x3D, 0x00, 0x00, 0x00, 
				 0x31, 0x00, 0x00, 0x00, 0x31, 0x00, 0x00, 0x00, 
				 0x99, 0x00, 0x00, 0x00, 0x35, 0x00, 0x00, 0x00, 
				 0x96, 0x00, 0x00, 0x00, 0x72, 0x00, 0x00, 0x00, 
				 0xF0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0xE0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x58, 0x00, 0x00, 0x00, 
				 0x8C, 0x00, 0x00, 0x00, 0x57, 0x00, 0x00, 0x00, 
				 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x57, 0x00, 0x00, 0x00, 0x72, 0x00, 0x00, 0x00, 
				 0xE3, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 
				 0x1D, 0x06, 0x00, 0x64, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x80, 0x00, 0x00, 0x00, 0x22, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x13, 0xEA, 0x00, 
				 0x1E, 0x00, 0x00, 0xC0, 0x00, 0x00, 0x1E, 0x01, 
				 0x91, 0x08, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 
				 0xEA, 0x00, 0x12, 0x07, 0x04, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x08, 0x00, 0x00, 
				 0x00, 0x18, 0x07, 0x04, 0x16, 0x02, 0x04, 0x00, 
				 0x00, 0x16, 0xC0, 0x00, 0x00, 0x00, 0x00, 0x00};

BYTE t5464_Mode_400x300x8_2[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x13, 0xF0, 0x00, 0x1E, 0x00, 0xFF, 0xEF, 0x00, 
				 0x00, 0x19, 0xF0, 0x00, 0x16, 0x05, 0x04, 0x00, 
				 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 0x00, 
				 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 0x00, 
				 0x1F, 0x01, 0x00, 0x18, 0x07, 0x04, 0x15, 0xA0, 
				 0x00, 0xFF, 0x00, 0x09, 0xCE, 0x03, 0x06, 0x05, 
				 0x16, 0x80, 0x00, 0x2F, 0x00, 0x16, 0x84, 0x00, 
				 0x16, 0x00, 0x16, 0x88, 0x00, 0x13, 0x00, 0x1D, 
				 0x19, 0x00, 0x00, 0x00, 0x3D, 0x00, 0x00, 0x00, 
				 0x31, 0x00, 0x00, 0x00, 0x31, 0x00, 0x00, 0x00, 
				 0x99, 0x00, 0x00, 0x00, 0x34, 0x00, 0x00, 0x00, 
				 0x96, 0x00, 0x00, 0x00, 0x6F, 0x00, 0x00, 0x00, 
				 0xF0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0xE0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x58, 0x00, 0x00, 0x00, 
				 0x8B, 0x00, 0x00, 0x00, 0x57, 0x00, 0x00, 0x00, 
				 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x57, 0x00, 0x00, 0x00, 0x6F, 0x00, 0x00, 0x00, 
				 0xE3, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 
				 0x1D, 0x06, 0x00, 0x64, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x80, 0x00, 0x00, 0x00, 0x22, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x13, 0xEA, 0x00, 
				 0x1E, 0x00, 0x00, 0xC0, 0x00, 0x00, 0x1E, 0x01, 
				 0x91, 0x08, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 
				 0xEA, 0x00, 0x12, 0x07, 0x04, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x08, 0x00, 0x00, 
				 0x00, 0x18, 0x07, 0x04, 0x16, 0x02, 0x04, 0x00, 
				 0x00, 0x16, 0xC0, 0x00, 0x00, 0x00, 0x00, 0x00};

BYTE t5464_Mode_512x384x8_1[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x13, 0xF0, 0x00, 0x1E, 0x00, 0xFF, 0xEF, 0x00, 
				 0x00, 0x19, 0xF0, 0x00, 0x16, 0x05, 0x04, 0x00, 
				 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 0x00, 
				 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 0x00, 
				 0x1F, 0x01, 0x00, 0x18, 0x07, 0x04, 0x15, 0xA0, 
				 0x00, 0xFF, 0x00, 0x09, 0xCE, 0x03, 0x06, 0x05, 
				 0x16, 0x80, 0x00, 0xEF, 0x00, 0x16, 0x84, 0x00, 
				 0x1B, 0x00, 0x16, 0x88, 0x00, 0x3B, 0x00, 0x1D, 
				 0x19, 0x00, 0x00, 0x00, 0x4F, 0x00, 0x00, 0x00, 
				 0x3F, 0x00, 0x00, 0x00, 0x3F, 0x00, 0x00, 0x00, 
				 0x89, 0x00, 0x00, 0x00, 0x42, 0x00, 0x00, 0x00, 
				 0x06, 0x00, 0x00, 0x00, 0x24, 0x00, 0x00, 0x00, 
				 0xF5, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0xE0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 
				 0x88, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 
				 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0xFF, 0x00, 0x00, 0x00, 0x24, 0x00, 0x00, 0x00, 
				 0xE3, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 
				 0x1D, 0x06, 0x00, 0x64, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0xD0, 0x00, 0x00, 0x00, 0x22, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x13, 0xEA, 0x00, 
				 0x1E, 0x00, 0x00, 0xC0, 0x00, 0x00, 0x1E, 0x01, 
				 0x91, 0x08, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 
				 0xEA, 0x00, 0x12, 0x07, 0x04, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x08, 0x00, 0x00, 
				 0x00, 0x18, 0x07, 0x04, 0x16, 0x02, 0x04, 0x00, 
				 0x00, 0x16, 0xC0, 0x00, 0x00, 0x00, 0x00, 0x00};

BYTE t5464_Mode_512x384x8_2[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x13, 0xF0, 0x00, 0x1E, 0x00, 0xFF, 0xEF, 0x00, 
				 0x00, 0x19, 0xF0, 0x00, 0x16, 0x05, 0x04, 0x00, 
				 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 0x00, 
				 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 0x00, 
				 0x1F, 0x01, 0x00, 0x18, 0x07, 0x04, 0x15, 0xA0, 
				 0x00, 0xFF, 0x00, 0x09, 0xCE, 0x03, 0x06, 0x05, 
				 0x16, 0x80, 0x00, 0xEF, 0x00, 0x16, 0x84, 0x00, 
				 0x2A, 0x00, 0x16, 0x88, 0x00, 0x37, 0x00, 0x1D, 
				 0x19, 0x00, 0x00, 0x00, 0x4E, 0x00, 0x00, 0x00, 
				 0x3F, 0x00, 0x00, 0x00, 0x3F, 0x00, 0x00, 0x00, 
				 0x89, 0x00, 0x00, 0x00, 0x42, 0x00, 0x00, 0x00, 
				 0x06, 0x00, 0x00, 0x00, 0x24, 0x00, 0x00, 0x00, 
				 0xF5, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0xE0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 
				 0x88, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 
				 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0xFF, 0x00, 0x00, 0x00, 0x24, 0x00, 0x00, 0x00, 
				 0xE3, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 
				 0x1D, 0x06, 0x00, 0x64, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0xD0, 0x00, 0x00, 0x00, 0x22, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x13, 0xEA, 0x00, 
				 0x1E, 0x00, 0x00, 0xC0, 0x00, 0x00, 0x1E, 0x01, 
				 0x91, 0x08, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 
				 0xEA, 0x00, 0x12, 0x07, 0x04, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x08, 0x00, 0x00, 
				 0x00, 0x18, 0x07, 0x04, 0x16, 0x02, 0x04, 0x00, 
				 0x00, 0x16, 0xC0, 0x00, 0x00, 0x00, 0x00, 0x00};

BYTE t5464_Mode_512x480x8_1[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x13, 0xF0, 0x00, 0x1E, 0x00, 0xFF, 0xEF, 0x00, 
				 0x00, 0x19, 0xF0, 0x00, 0x16, 0x05, 0x04, 0x00, 
				 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 0x00, 
				 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 0x00, 
				 0x1F, 0x01, 0x00, 0x18, 0x07, 0x04, 0x15, 0xA0, 
				 0x00, 0xFF, 0x00, 0x09, 0xCE, 0x03, 0x06, 0x05, 
				 0x16, 0x80, 0x00, 0x2F, 0x00, 0x16, 0x84, 0x00, 
				 0x35, 0x00, 0x16, 0x88, 0x00, 0x49, 0x00, 0x1D, 
				 0x19, 0x00, 0x00, 0x00, 0x4B, 0x00, 0x00, 0x00, 
				 0x3F, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 
				 0x8B, 0x00, 0x00, 0x00, 0x42, 0x00, 0x00, 0x00, 
				 0x08, 0x00, 0x00, 0x00, 0xF0, 0x00, 0x00, 0x00, 
				 0x1F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0xE1, 0x00, 0x00, 0x00, 
				 0x84, 0x00, 0x00, 0x00, 0xDF, 0x00, 0x00, 0x00, 
				 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0xE0, 0x00, 0x00, 0x00, 0xF0, 0x00, 0x00, 0x00, 
				 0xE3, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 
				 0x1D, 0x06, 0x00, 0x64, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x50, 0x00, 0x00, 0x00, 0x22, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x13, 0xEA, 0x00, 
				 0x1E, 0x00, 0x00, 0xC0, 0x00, 0x00, 0x1E, 0x01, 
				 0x91, 0x08, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 
				 0xEA, 0x00, 0x12, 0x07, 0x04, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x08, 0x00, 0x00, 
				 0x00, 0x18, 0x07, 0x04, 0x16, 0x02, 0x04, 0x00, 
				 0x00, 0x16, 0xC0, 0x00, 0x00, 0x00, 0x00, 0x00};

BYTE t5464_Mode_512x480x8_2[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x13, 0xF0, 0x00, 0x1E, 0x00, 0xFF, 0xEF, 0x00, 
				 0x00, 0x19, 0xF0, 0x00, 0x16, 0x05, 0x04, 0x00, 
				 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 0x00, 
				 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 0x00, 
				 0x1F, 0x01, 0x00, 0x18, 0x07, 0x04, 0x15, 0xA0, 
				 0x00, 0xFF, 0x00, 0x09, 0xCE, 0x03, 0x06, 0x05, 
				 0x16, 0x80, 0x00, 0x2F, 0x00, 0x16, 0x84, 0x00, 
				 0x29, 0x00, 0x16, 0x88, 0x00, 0x45, 0x00, 0x1D, 
				 0x19, 0x00, 0x00, 0x00, 0x4D, 0x00, 0x00, 0x00, 
				 0x3F, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 
				 0x8D, 0x00, 0x00, 0x00, 0x42, 0x00, 0x00, 0x00, 
				 0x09, 0x00, 0x00, 0x00, 0xF4, 0x00, 0x00, 0x00, 
				 0x1F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0xE1, 0x00, 0x00, 0x00, 
				 0x84, 0x00, 0x00, 0x00, 0xDF, 0x00, 0x00, 0x00, 
				 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0xE0, 0x00, 0x00, 0x00, 0xF4, 0x00, 0x00, 0x00, 
				 0xE3, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 
				 0x1D, 0x06, 0x00, 0x64, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x50, 0x00, 0x00, 0x00, 0x22, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x13, 0xEA, 0x00, 
				 0x1E, 0x00, 0x00, 0xC0, 0x00, 0x00, 0x1E, 0x01, 
				 0x91, 0x08, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 
				 0xEA, 0x00, 0x12, 0x07, 0x04, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x08, 0x00, 0x00, 
				 0x00, 0x18, 0x07, 0x04, 0x16, 0x02, 0x04, 0x00, 
				 0x00, 0x16, 0xC0, 0x00, 0x00, 0x00, 0x00, 0x00};

BYTE t5464_Mode_640x350x8_1[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x13, 0xF0, 0x00, 0x1E, 0x00, 0xFF, 0xEF, 0x00, 
				 0x00, 0x19, 0xF0, 0x00, 0x16, 0x05, 0x04, 0x00, 
				 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 0x00, 
				 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 0x00, 
				 0x1F, 0x01, 0x00, 0x18, 0x07, 0x04, 0x15, 0xA0, 
				 0x00, 0xFF, 0x00, 0x09, 0xCE, 0x03, 0x06, 0x05, 
				 0x16, 0x80, 0x00, 0xAF, 0x00, 0x16, 0x84, 0x00, 
				 0x33, 0x00, 0x16, 0x88, 0x00, 0x58, 0x00, 0x1D, 
				 0x19, 0x00, 0x00, 0x00, 0x63, 0x00, 0x00, 0x00, 
				 0x4F, 0x00, 0x00, 0x00, 0x4F, 0x00, 0x00, 0x00, 
				 0x83, 0x00, 0x00, 0x00, 0x53, 0x00, 0x00, 0x00, 
				 0x97, 0x00, 0x00, 0x00, 0xBB, 0x00, 0x00, 0x00, 
				 0x1F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x7D, 0x00, 0x00, 0x00, 
				 0x80, 0x00, 0x00, 0x00, 0x5D, 0x00, 0x00, 0x00, 
				 0xA0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x5D, 0x00, 0x00, 0x00, 0xBB, 0x00, 0x00, 0x00, 
				 0xE3, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 
				 0x1D, 0x06, 0x00, 0x64, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x50, 0x00, 0x00, 0x00, 0x22, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x13, 0xEA, 0x00, 
				 0x1E, 0x00, 0x00, 0xC0, 0x00, 0x00, 0x1E, 0x01, 
				 0x91, 0x0A, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 
				 0xEA, 0x00, 0x12, 0x07, 0x04, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x0A, 0x00, 0x00, 
				 0x00, 0x18, 0x07, 0x04, 0x16, 0x02, 0x04, 0x00, 
				 0x00, 0x16, 0xC0, 0x00, 0x00, 0x00, 0x00, 0x00};

BYTE t5464_Mode_640x350x8_2[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x13, 0xF0, 0x00, 0x1E, 0x00, 0xFF, 0xEF, 0x00, 
				 0x00, 0x19, 0xF0, 0x00, 0x16, 0x05, 0x04, 0x00, 
				 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 0x00, 
				 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 0x00, 
				 0x1F, 0x01, 0x00, 0x18, 0x07, 0x04, 0x15, 0xA0, 
				 0x00, 0xFF, 0x00, 0x09, 0xCE, 0x03, 0x06, 0x05, 
				 0x16, 0x80, 0x00, 0xAF, 0x00, 0x16, 0x84, 0x00, 
				 0x0A, 0x00, 0x16, 0x88, 0x00, 0x0B, 0x00, 0x1D, 
				 0x19, 0x00, 0x00, 0x00, 0x63, 0x00, 0x00, 0x00, 
				 0x4F, 0x00, 0x00, 0x00, 0x4F, 0x00, 0x00, 0x00, 
				 0x83, 0x00, 0x00, 0x00, 0x53, 0x00, 0x00, 0x00, 
				 0x97, 0x00, 0x00, 0x00, 0xBB, 0x00, 0x00, 0x00, 
				 0x1F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x7D, 0x00, 0x00, 0x00, 
				 0x80, 0x00, 0x00, 0x00, 0x5D, 0x00, 0x00, 0x00, 
				 0xA0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x5D, 0x00, 0x00, 0x00, 0xBB, 0x00, 0x00, 0x00, 
				 0xE3, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 
				 0x1D, 0x06, 0x00, 0x64, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x50, 0x00, 0x00, 0x00, 0x22, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x13, 0xEA, 0x00, 
				 0x1E, 0x00, 0x00, 0xC0, 0x00, 0x00, 0x1E, 0x01, 
				 0x91, 0x0A, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 
				 0xEA, 0x00, 0x12, 0x07, 0x04, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x0A, 0x00, 0x00, 
				 0x00, 0x18, 0x07, 0x04, 0x16, 0x02, 0x04, 0x00, 
				 0x00, 0x16, 0xC0, 0x00, 0x00, 0x00, 0x00, 0x00};

BYTE t5464_Mode_640x400x8_1[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x13, 0xF0, 0x00, 0x1E, 0x00, 0xFF, 0xEF, 0x00, 
				 0x00, 0x19, 0xF0, 0x00, 0x16, 0x05, 0x04, 0x00, 
				 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 0x00, 
				 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 0x00, 
				 0x1F, 0x01, 0x00, 0x18, 0x07, 0x04, 0x15, 0xA0, 
				 0x00, 0xFF, 0x00, 0x09, 0xCE, 0x03, 0x06, 0x05, 
				 0x16, 0x80, 0x00, 0x6F, 0x00, 0x16, 0x84, 0x00, 
				 0x3F, 0x00, 0x16, 0x88, 0x00, 0x6D, 0x00, 0x1D, 
				 0x19, 0x00, 0x00, 0x00, 0x5F, 0x00, 0x00, 0x00, 
				 0x4F, 0x00, 0x00, 0x00, 0x50, 0x00, 0x00, 0x00, 
				 0x82, 0x00, 0x00, 0x00, 0x53, 0x00, 0x00, 0x00, 
				 0x9F, 0x00, 0x00, 0x00, 0xBF, 0x00, 0x00, 0x00, 
				 0x1F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0xA1, 0x00, 0x00, 0x00, 
				 0xA3, 0x00, 0x00, 0x00, 0x8F, 0x00, 0x00, 0x00, 
				 0x50, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x96, 0x00, 0x00, 0x00, 0xB9, 0x00, 0x00, 0x00, 
				 0xE3, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 
				 0x1D, 0x06, 0x00, 0x64, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x50, 0x00, 0x00, 0x00, 0x22, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x13, 0xEA, 0x00, 
				 0x1E, 0x00, 0x00, 0xC0, 0x00, 0x00, 0x1E, 0x01, 
				 0x91, 0x05, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 
				 0xEA, 0x00, 0x12, 0x07, 0x04, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 
				 0x00, 0x18, 0x07, 0x04, 0x16, 0x02, 0x04, 0x00, 
				 0x00, 0x16, 0xC0, 0x00, 0x00, 0x00, 0x00, 0x00};

BYTE t5464_Mode_640x400x8_1a[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x13, 0xF0, 0x00, 0x1E, 0x00, 0xFF, 0xEF, 0x00, 
				 0x00, 0x19, 0xF0, 0x00, 0x16, 0x05, 0x04, 0x00, 
				 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 0x00, 
				 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 0x00, 
				 0x1F, 0x01, 0x00, 0x18, 0x07, 0x04, 0x15, 0xA0, 
				 0x00, 0xFF, 0x00, 0x09, 0xCE, 0x03, 0x06, 0x05, 
				 0x16, 0x80, 0x00, 0x6F, 0x00, 0x16, 0x84, 0x00, 
				 0x3F, 0x00, 0x16, 0x88, 0x00, 0x6D, 0x00, 0x1D, 
				 0x19, 0x00, 0x00, 0x00, 0x5F, 0x00, 0x00, 0x00, 
				 0x4F, 0x00, 0x00, 0x00, 0x50, 0x00, 0x00, 0x00, 
				 0x82, 0x00, 0x00, 0x00, 0x53, 0x00, 0x00, 0x00, 
				 0x9F, 0x00, 0x00, 0x00, 0xBF, 0x00, 0x00, 0x00, 
				 0x1F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0xA1, 0x00, 0x00, 0x00, 
				 0xA3, 0x00, 0x00, 0x00, 0x8F, 0x00, 0x00, 0x00, 
				 0x50, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x96, 0x00, 0x00, 0x00, 0xB9, 0x00, 0x00, 0x00, 
				 0xE3, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 
				 0x1D, 0x06, 0x00, 0x64, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x50, 0x00, 0x00, 0x00, 0x22, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x13, 0xEA, 0x00, 
				 0x1E, 0x00, 0x00, 0xC0, 0x00, 0x00, 0x1E, 0x01, 
				 0xD1, 0x05, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 
				 0xEA, 0x00, 0x12, 0x07, 0x04, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 
				 0x00, 0x18, 0x07, 0x04, 0x16, 0x02, 0x04, 0x00, 
				 0x08, 0x16, 0xC0, 0x00, 0x00, 0x00, 0x17, 0x4C, 
				 0x00, 0xA0, 0x00, 0x00, 0x00, 0x00, 0x74};

BYTE t5464_Mode_640x400x8_2[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x13, 0xF0, 0x00, 0x1E, 0x00, 0xFF, 0xEF, 0x00, 
				 0x00, 0x19, 0xF0, 0x00, 0x16, 0x05, 0x04, 0x00, 
				 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 0x00, 
				 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 0x00, 
				 0x1F, 0x01, 0x00, 0x18, 0x07, 0x04, 0x15, 0xA0, 
				 0x00, 0xFF, 0x00, 0x09, 0xCE, 0x03, 0x06, 0x05, 
				 0x16, 0x80, 0x00, 0x6F, 0x00, 0x16, 0x84, 0x00, 
				 0x0B, 0x00, 0x16, 0x88, 0x00, 0x16, 0x00, 0x1D, 
				 0x19, 0x00, 0x00, 0x00, 0x63, 0x00, 0x00, 0x00, 
				 0x4F, 0x00, 0x00, 0x00, 0x4F, 0x00, 0x00, 0x00, 
				 0x83, 0x00, 0x00, 0x00, 0x53, 0x00, 0x00, 0x00, 
				 0x97, 0x00, 0x00, 0x00, 0xBB, 0x00, 0x00, 0x00, 
				 0x1F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x90, 0x00, 0x00, 0x00, 
				 0x83, 0x00, 0x00, 0x00, 0x8F, 0x00, 0x00, 0x00, 
				 0x50, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x8F, 0x00, 0x00, 0x00, 0xBB, 0x00, 0x00, 0x00, 
				 0xE3, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 
				 0x1D, 0x06, 0x00, 0x64, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x50, 0x00, 0x00, 0x00, 0x22, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x13, 0xEA, 0x00, 
				 0x1E, 0x00, 0x00, 0xC0, 0x00, 0x00, 0x1E, 0x01, 
				 0x91, 0x05, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 
				 0xEA, 0x00, 0x12, 0x07, 0x04, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 
				 0x00, 0x18, 0x07, 0x04, 0x16, 0x02, 0x04, 0x00, 
				 0x00, 0x16, 0xC0, 0x00, 0x00, 0x00, 0x00, 0x4C};

BYTE t5464_Mode_640x400x8_2a[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x13, 0xF0, 0x00, 0x1E, 0x00, 0xFF, 0xEF, 0x00, 
				 0x00, 0x19, 0xF0, 0x00, 0x16, 0x05, 0x04, 0x00, 
				 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 0x00, 
				 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 0x00, 
				 0x1F, 0x01, 0x00, 0x18, 0x07, 0x04, 0x15, 0xA0, 
				 0x00, 0xFF, 0x00, 0x09, 0xCE, 0x03, 0x06, 0x05, 
				 0x16, 0x80, 0x00, 0x6F, 0x00, 0x16, 0x84, 0x00, 
				 0x0B, 0x00, 0x16, 0x88, 0x00, 0x16, 0x00, 0x1D, 
				 0x19, 0x00, 0x00, 0x00, 0x63, 0x00, 0x00, 0x00, 
				 0x4F, 0x00, 0x00, 0x00, 0x4F, 0x00, 0x00, 0x00, 
				 0x83, 0x00, 0x00, 0x00, 0x53, 0x00, 0x00, 0x00, 
				 0x97, 0x00, 0x00, 0x00, 0xBB, 0x00, 0x00, 0x00, 
				 0x1F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x90, 0x00, 0x00, 0x00, 
				 0x83, 0x00, 0x00, 0x00, 0x8F, 0x00, 0x00, 0x00, 
				 0x50, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x8F, 0x00, 0x00, 0x00, 0xBB, 0x00, 0x00, 0x00, 
				 0xE3, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 
				 0x1D, 0x06, 0x00, 0x64, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x50, 0x00, 0x00, 0x00, 0x22, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x13, 0xEA, 0x00, 
				 0x1E, 0x00, 0x00, 0xC0, 0x00, 0x00, 0x1E, 0x01, 
				 0xD1, 0x05, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 
				 0xEA, 0x00, 0x12, 0x07, 0x04, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 
				 0x00, 0x18, 0x07, 0x04, 0x16, 0x02, 0x04, 0x00, 
				 0x08, 0x16, 0xC0, 0x00, 0x00, 0x00, 0x17, 0x4C, 
				 0x00, 0xA0, 0x00, 0x00, 0x00, 0x00, 0x74};

BYTE t5464_Mode_640x400x8_3[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x13, 0xF0, 0x00, 0x1E, 0x00, 0xFF, 0xEF, 0x00, 
				 0x00, 0x19, 0xF0, 0x00, 0x16, 0x05, 0x04, 0x00, 
				 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 0x00, 
				 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 0x00, 
				 0x1F, 0x01, 0x00, 0x18, 0x07, 0x04, 0x15, 0xA0, 
				 0x00, 0xFF, 0x00, 0x09, 0xCE, 0x03, 0x06, 0x05, 
				 0x16, 0x80, 0x00, 0x6F, 0x00, 0x16, 0x84, 0x00, 
				 0x0B, 0x00, 0x16, 0x88, 0x00, 0x16, 0x00, 0x1D, 
				 0x19, 0x00, 0x00, 0x00, 0x63, 0x00, 0x00, 0x00, 
				 0x4F, 0x00, 0x00, 0x00, 0x4F, 0x00, 0x00, 0x00, 
				 0x83, 0x00, 0x00, 0x00, 0x53, 0x00, 0x00, 0x00, 
				 0x97, 0x00, 0x00, 0x00, 0xBB, 0x00, 0x00, 0x00, 
				 0x1F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x90, 0x00, 0x00, 0x00, 
				 0x83, 0x00, 0x00, 0x00, 0x8F, 0x00, 0x00, 0x00, 
				 0x50, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x8F, 0x00, 0x00, 0x00, 0xBB, 0x00, 0x00, 0x00, 
				 0xE3, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 
				 0x1D, 0x06, 0x00, 0x64, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x50, 0x00, 0x00, 0x00, 0x22, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x16, 0x84, 0x00, 
				 0x32, 0x00, 0x16, 0x88, 0x00, 0x61, 0x00, 0x13, 
				 0xEA, 0x00, 0x1E, 0x00, 0x00, 0xC0, 0x00, 0x00, 
				 0x1E, 0x01, 0x91, 0x05, 0x00, 0x00, 0x1F, 0x01, 
				 0x00, 0x19, 0xEA, 0x00, 0x12, 0x07, 0x04, 0x1E, 
				 0x00, 0xC0, 0x00, 0x00, 0x00, 0x1E, 0x01, 0x05, 
				 0x00, 0x00, 0x00, 0x18, 0x07, 0x04, 0x16, 0x02, 
				 0x04, 0x00, 0x00, 0x16, 0xC0, 0x00, 0x00, 0x00, 
				 0x00, 0x00};

BYTE t5464_Mode_640x400x8_3a[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x13, 0xF0, 0x00, 0x1E, 0x00, 0xFF, 0xEF, 0x00, 
				 0x00, 0x19, 0xF0, 0x00, 0x16, 0x05, 0x04, 0x00, 
				 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 0x00, 
				 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 0x00, 
				 0x1F, 0x01, 0x00, 0x18, 0x07, 0x04, 0x15, 0xA0, 
				 0x00, 0xFF, 0x00, 0x09, 0xCE, 0x03, 0x06, 0x05, 
				 0x16, 0x80, 0x00, 0x6F, 0x00, 0x16, 0x84, 0x00, 
				 0x0B, 0x00, 0x16, 0x88, 0x00, 0x16, 0x00, 0x1D, 
				 0x19, 0x00, 0x00, 0x00, 0x63, 0x00, 0x00, 0x00, 
				 0x4F, 0x00, 0x00, 0x00, 0x4F, 0x00, 0x00, 0x00, 
				 0x83, 0x00, 0x00, 0x00, 0x53, 0x00, 0x00, 0x00, 
				 0x97, 0x00, 0x00, 0x00, 0xBB, 0x00, 0x00, 0x00, 
				 0x1F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x90, 0x00, 0x00, 0x00, 
				 0x83, 0x00, 0x00, 0x00, 0x8F, 0x00, 0x00, 0x00, 
				 0x50, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x8F, 0x00, 0x00, 0x00, 0xBB, 0x00, 0x00, 0x00, 
				 0xE3, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 
				 0x1D, 0x06, 0x00, 0x64, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x50, 0x00, 0x00, 0x00, 0x22, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x16, 0x84, 0x00, 
				 0x32, 0x00, 0x16, 0x88, 0x00, 0x61, 0x00, 0x13, 
				 0xEA, 0x00, 0x1E, 0x00, 0x00, 0xC0, 0x00, 0x00, 
				 0x1E, 0x01, 0xD1, 0x05, 0x00, 0x00, 0x1F, 0x01, 
				 0x00, 0x19, 0xEA, 0x00, 0x12, 0x07, 0x04, 0x1E, 
				 0x00, 0xC0, 0x00, 0x00, 0x00, 0x1E, 0x01, 0x05, 
				 0x00, 0x00, 0x00, 0x18, 0x07, 0x04, 0x16, 0x02, 
				 0x04, 0x00, 0x08, 0x16, 0xC0, 0x00, 0x00, 0x00, 
				 0x17, 0x4C, 0x00, 0xA0, 0x00, 0x00, 0x00, 0x00, 0x00};

BYTE t5464_Mode_800x600x8_1[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x13, 0xF0, 0x00, 0x1E, 0x00, 0xFF, 0xEF, 0x00, 
				 0x00, 0x19, 0xF0, 0x00, 0x16, 0x05, 0x04, 0x00, 
				 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 0x00, 
				 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 0x00, 
				 0x1F, 0x01, 0x00, 0x18, 0x07, 0x04, 0x15, 0xA0, 
				 0x00, 0xFF, 0x00, 0x09, 0xCE, 0x03, 0x06, 0x05, 
				 0x16, 0x80, 0x00, 0x2F, 0x00, 0x16, 0x84, 0x00, 
				 0x3E, 0x00, 0x16, 0x88, 0x00, 0x4E, 0x00, 0x1D, 
				 0x19, 0x00, 0x00, 0x00, 0x7B, 0x00, 0x00, 0x00, 
				 0x63, 0x00, 0x00, 0x00, 0x64, 0x00, 0x00, 0x00, 
				 0x9B, 0x00, 0x00, 0x00, 0x68, 0x00, 0x00, 0x00, 
				 0x91, 0x00, 0x00, 0x00, 0x6F, 0x00, 0x00, 0x00, 
				 0xF0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x58, 0x00, 0x00, 0x00, 
				 0x8A, 0x00, 0x00, 0x00, 0x57, 0x00, 0x00, 0x00, 
				 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x58, 0x00, 0x00, 0x00, 0x6F, 0x00, 0x00, 0x00, 
				 0xE3, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 
				 0x1D, 0x06, 0x00, 0x64, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x90, 0x00, 0x00, 0x00, 0x22, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x13, 0xEA, 0x00, 
				 0x1E, 0x00, 0x00, 0xC0, 0x00, 0x00, 0x1E, 0x01, 
				 0x91, 0x08, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 
				 0xEA, 0x00, 0x12, 0x07, 0x04, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x08, 0x00, 0x00, 
				 0x00, 0x18, 0x07, 0x04, 0x16, 0x02, 0x04, 0x00, 
				 0x00, 0x16, 0xC0, 0x00, 0x00, 0x00, 0x00, 0x02};

BYTE t5464_Mode_800x600x8_2[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x13, 0xF0, 0x00, 0x1E, 0x00, 0xFF, 0xEF, 0x00, 
				 0x00, 0x19, 0xF0, 0x00, 0x16, 0x05, 0x04, 0x00, 
				 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 0x00, 
				 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 0x00, 
				 0x1F, 0x01, 0x00, 0x18, 0x07, 0x04, 0x15, 0xA0, 
				 0x00, 0xFF, 0x00, 0x09, 0xCE, 0x03, 0x06, 0x05, 
				 0x16, 0x80, 0x00, 0x2F, 0x00, 0x16, 0x84, 0x00, 
				 0x3A, 0x00, 0x16, 0x88, 0x00, 0x51, 0x00, 0x1D, 
				 0x19, 0x00, 0x00, 0x00, 0x7F, 0x00, 0x00, 0x00, 
				 0x63, 0x00, 0x00, 0x00, 0x64, 0x00, 0x00, 0x00, 
				 0x9F, 0x00, 0x00, 0x00, 0x69, 0x00, 0x00, 0x00, 
				 0x99, 0x00, 0x00, 0x00, 0x72, 0x00, 0x00, 0x00, 
				 0xF0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x58, 0x00, 0x00, 0x00, 
				 0x8C, 0x00, 0x00, 0x00, 0x57, 0x00, 0x00, 0x00, 
				 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x58, 0x00, 0x00, 0x00, 0x72, 0x00, 0x00, 0x00, 
				 0xE3, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 
				 0x1D, 0x06, 0x00, 0x64, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x90, 0x00, 0x00, 0x00, 0x22, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x13, 0xEA, 0x00, 
				 0x1E, 0x00, 0x00, 0xC0, 0x00, 0x00, 0x1E, 0x01, 
				 0x91, 0x08, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 
				 0xEA, 0x00, 0x12, 0x07, 0x04, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x08, 0x00, 0x00, 
				 0x00, 0x18, 0x07, 0x04, 0x16, 0x02, 0x04, 0x00, 
				 0x00, 0x16, 0xC0, 0x00, 0x00, 0x00, 0x00, 0x02};

BYTE t5464_Mode_800x600x8_3[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x13, 0xF0, 0x00, 0x1E, 0x00, 0xFF, 0xEF, 0x00, 
				 0x00, 0x19, 0xF0, 0x00, 0x16, 0x05, 0x04, 0x00, 
				 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 0x00, 
				 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 0x00, 
				 0x1F, 0x01, 0x00, 0x18, 0x07, 0x04, 0x15, 0xA0, 
				 0x00, 0xFF, 0x00, 0x09, 0xCE, 0x03, 0x06, 0x05, 
				 0x16, 0x80, 0x00, 0x2F, 0x00, 0x16, 0x84, 0x00, 
				 0x3E, 0x00, 0x16, 0x88, 0x00, 0x6C, 0x00, 0x1D, 
				 0x19, 0x00, 0x00, 0x00, 0x7D, 0x00, 0x00, 0x00, 
				 0x63, 0x00, 0x00, 0x00, 0x64, 0x00, 0x00, 0x00, 
				 0x9D, 0x00, 0x00, 0x00, 0x6C, 0x00, 0x00, 0x00, 
				 0x9B, 0x00, 0x00, 0x00, 0x97, 0x00, 0x00, 0x00, 
				 0xF0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x7B, 0x00, 0x00, 0x00, 
				 0x81, 0x00, 0x00, 0x00, 0x57, 0x00, 0x00, 0x00, 
				 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x5F, 0x00, 0x00, 0x00, 0x97, 0x00, 0x00, 0x00, 
				 0xE3, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 
				 0x1D, 0x06, 0x00, 0x64, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x90, 0x00, 0x00, 0x00, 0x22, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x13, 0xEA, 0x00, 
				 0x1E, 0x00, 0x00, 0xC0, 0x00, 0x00, 0x1E, 0x01, 
				 0x91, 0x08, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 
				 0xEA, 0x00, 0x12, 0x07, 0x04, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x08, 0x00, 0x00, 
				 0x00, 0x18, 0x07, 0x04, 0x16, 0x02, 0x04, 0x00, 
				 0x00, 0x16, 0xC0, 0x00, 0x00, 0x00, 0x00, 0x02};

BYTE t5464_Mode_800x600x8_4[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x13, 0xF0, 0x00, 0x1E, 0x00, 0xFF, 0xEF, 0x00, 
				 0x00, 0x19, 0xF0, 0x00, 0x16, 0x05, 0x04, 0x00, 
				 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 0x00, 
				 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 0x00, 
				 0x1F, 0x01, 0x00, 0x18, 0x07, 0x04, 0x15, 0xA0, 
				 0x00, 0xFF, 0x00, 0x09, 0xCE, 0x03, 0x06, 0x05, 
				 0x16, 0x80, 0x00, 0x2F, 0x00, 0x16, 0x84, 0x00, 
				 0x30, 0x00, 0x16, 0x88, 0x00, 0x53, 0x00, 0x1D, 
				 0x19, 0x00, 0x00, 0x00, 0x7F, 0x00, 0x00, 0x00, 
				 0x63, 0x00, 0x00, 0x00, 0x64, 0x00, 0x00, 0x00, 
				 0x9F, 0x00, 0x00, 0x00, 0x67, 0x00, 0x00, 0x00, 
				 0x91, 0x00, 0x00, 0x00, 0x6F, 0x00, 0x00, 0x00, 
				 0xF0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x58, 0x00, 0x00, 0x00, 
				 0x8B, 0x00, 0x00, 0x00, 0x57, 0x00, 0x00, 0x00, 
				 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x57, 0x00, 0x00, 0x00, 0x6F, 0x00, 0x00, 0x00, 
				 0xE3, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 
				 0x1D, 0x06, 0x00, 0x64, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x90, 0x00, 0x00, 0x00, 0x22, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x13, 0xEA, 0x00, 
				 0x1E, 0x00, 0x00, 0xC0, 0x00, 0x00, 0x1E, 0x01, 
				 0x91, 0x08, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 
				 0xEA, 0x00, 0x12, 0x07, 0x04, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x08, 0x00, 0x00, 
				 0x00, 0x18, 0x07, 0x04, 0x16, 0x02, 0x04, 0x00, 
				 0x00, 0x16, 0xC0, 0x00, 0x00, 0x00, 0x00, 0x02};

BYTE t5464_Mode_800x600x8_5[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x13, 0xF0, 0x00, 0x1E, 0x00, 0xFF, 0xEF, 0x00, 
				 0x00, 0x19, 0xF0, 0x00, 0x16, 0x05, 0x04, 0x00, 
				 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 0x00, 
				 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 0x00, 
				 0x1F, 0x01, 0x00, 0x18, 0x07, 0x04, 0x15, 0xA0, 
				 0x00, 0xFF, 0x00, 0x09, 0xCE, 0x03, 0x06, 0x05, 
				 0x16, 0x80, 0x00, 0x2F, 0x00, 0x16, 0x84, 0x00, 
				 0x1C, 0x00, 0x16, 0x88, 0x00, 0x37, 0x00, 0x1D, 
				 0x19, 0x00, 0x00, 0x00, 0x7E, 0x00, 0x00, 0x00, 
				 0x63, 0x00, 0x00, 0x00, 0x64, 0x00, 0x00, 0x00, 
				 0x9E, 0x00, 0x00, 0x00, 0x69, 0x00, 0x00, 0x00, 
				 0x91, 0x00, 0x00, 0x00, 0x75, 0x00, 0x00, 0x00, 
				 0xF0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x58, 0x00, 0x00, 0x00, 
				 0x8B, 0x00, 0x00, 0x00, 0x57, 0x00, 0x00, 0x00, 
				 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x57, 0x00, 0x00, 0x00, 0x75, 0x00, 0x00, 0x00, 
				 0xE3, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 
				 0x1D, 0x06, 0x00, 0x64, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x90, 0x00, 0x00, 0x00, 0x22, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x13, 0xEA, 0x00, 
				 0x1E, 0x00, 0x00, 0xC0, 0x00, 0x00, 0x1E, 0x01, 
				 0x91, 0x08, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 
				 0xEA, 0x00, 0x12, 0x07, 0x04, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x08, 0x00, 0x00, 
				 0x00, 0x18, 0x07, 0x04, 0x16, 0x02, 0x04, 0x00, 
				 0x00, 0x16, 0xC0, 0x00, 0x00, 0x00, 0x00, 0x02};

BYTE t5464_Mode_800x600x8_1a[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x13, 0xF0, 0x00, 0x1E, 0x00, 0xFF, 0xEF, 0x00, 
				 0x00, 0x19, 0xF0, 0x00, 0x16, 0x05, 0x04, 0x00, 
				 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 0x00, 
				 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 0x00, 
				 0x1F, 0x01, 0x00, 0x18, 0x07, 0x04, 0x15, 0xA0, 
				 0x00, 0xFF, 0x00, 0x09, 0xCE, 0x03, 0x06, 0x05, 
				 0x16, 0x80, 0x00, 0x2F, 0x00, 0x16, 0x84, 0x00, 
				 0x3E, 0x00, 0x16, 0x88, 0x00, 0x4E, 0x00, 0x1D, 
				 0x19, 0x00, 0x00, 0x00, 0x7B, 0x00, 0x00, 0x00, 
				 0x63, 0x00, 0x00, 0x00, 0x64, 0x00, 0x00, 0x00, 
				 0x9B, 0x00, 0x00, 0x00, 0x68, 0x00, 0x00, 0x00, 
				 0x91, 0x00, 0x00, 0x00, 0x6F, 0x00, 0x00, 0x00, 
				 0xF0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x58, 0x00, 0x00, 0x00, 
				 0x8A, 0x00, 0x00, 0x00, 0x57, 0x00, 0x00, 0x00, 
				 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x58, 0x00, 0x00, 0x00, 0x6F, 0x00, 0x00, 0x00, 
				 0xE3, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 
				 0x1D, 0x06, 0x00, 0x64, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x90, 0x00, 0x00, 0x00, 0x22, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x13, 0xEA, 0x00, 
				 0x1E, 0x00, 0x00, 0xC0, 0x00, 0x00, 0x1E, 0x01, 
				 0x92, 0x0D, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 
				 0xEA, 0x00, 0x12, 0x07, 0x04, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x0D, 0x00, 0x00, 
				 0x00, 0x18, 0x07, 0x04, 0x16, 0x02, 0x04, 0x00, 
				 0x00, 0x16, 0xC0, 0x00, 0x00, 0x00, 0x17, 0x4C, 
				 0x00, 0xD0, 0x00, 0x00, 0x00, 0x00, 0x00};

BYTE t5464_Mode_800x600x8_2a[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x13, 0xF0, 0x00, 0x1E, 0x00, 0xFF, 0xEF, 0x00, 
				 0x00, 0x19, 0xF0, 0x00, 0x16, 0x05, 0x04, 0x00, 
				 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 0x00, 
				 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 0x00, 
				 0x1F, 0x01, 0x00, 0x18, 0x07, 0x04, 0x15, 0xA0, 
				 0x00, 0xFF, 0x00, 0x09, 0xCE, 0x03, 0x06, 0x05, 
				 0x16, 0x80, 0x00, 0x2F, 0x00, 0x16, 0x84, 0x00, 
				 0x3A, 0x00, 0x16, 0x88, 0x00, 0x51, 0x00, 0x1D, 
				 0x19, 0x00, 0x00, 0x00, 0x7F, 0x00, 0x00, 0x00, 
				 0x63, 0x00, 0x00, 0x00, 0x64, 0x00, 0x00, 0x00, 
				 0x9F, 0x00, 0x00, 0x00, 0x69, 0x00, 0x00, 0x00, 
				 0x99, 0x00, 0x00, 0x00, 0x72, 0x00, 0x00, 0x00, 
				 0xF0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x58, 0x00, 0x00, 0x00, 
				 0x8C, 0x00, 0x00, 0x00, 0x57, 0x00, 0x00, 0x00, 
				 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x58, 0x00, 0x00, 0x00, 0x72, 0x00, 0x00, 0x00, 
				 0xE3, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 
				 0x1D, 0x06, 0x00, 0x64, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x90, 0x00, 0x00, 0x00, 0x22, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x13, 0xEA, 0x00, 
				 0x1E, 0x00, 0x00, 0xC0, 0x00, 0x00, 0x1E, 0x01, 
				 0x92, 0x0D, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 
				 0xEA, 0x00, 0x12, 0x07, 0x04, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x0D, 0x00, 0x00, 
				 0x00, 0x18, 0x07, 0x04, 0x16, 0x02, 0x04, 0x00, 
				 0x00, 0x16, 0xC0, 0x00, 0x00, 0x00, 0x17, 0x4C, 
				 0x00, 0xD0, 0x00, 0x00, 0x00, 0x00, 0x00};

BYTE t5464_Mode_800x600x8_3a[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x13, 0xF0, 0x00, 0x1E, 0x00, 0xFF, 0xEF, 0x00, 
				 0x00, 0x19, 0xF0, 0x00, 0x16, 0x05, 0x04, 0x00, 
				 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 0x00, 
				 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 0x00, 
				 0x1F, 0x01, 0x00, 0x18, 0x07, 0x04, 0x15, 0xA0, 
				 0x00, 0xFF, 0x00, 0x09, 0xCE, 0x03, 0x06, 0x05, 
				 0x16, 0x80, 0x00, 0x2F, 0x00, 0x16, 0x84, 0x00, 
				 0x3E, 0x00, 0x16, 0x88, 0x00, 0x6C, 0x00, 0x1D, 
				 0x19, 0x00, 0x00, 0x00, 0x7D, 0x00, 0x00, 0x00, 
				 0x63, 0x00, 0x00, 0x00, 0x64, 0x00, 0x00, 0x00, 
				 0x9D, 0x00, 0x00, 0x00, 0x6C, 0x00, 0x00, 0x00, 
				 0x9B, 0x00, 0x00, 0x00, 0x97, 0x00, 0x00, 0x00, 
				 0xF0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x7B, 0x00, 0x00, 0x00, 
				 0x81, 0x00, 0x00, 0x00, 0x57, 0x00, 0x00, 0x00, 
				 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x5F, 0x00, 0x00, 0x00, 0x97, 0x00, 0x00, 0x00, 
				 0xE3, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 
				 0x1D, 0x06, 0x00, 0x64, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x90, 0x00, 0x00, 0x00, 0x22, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x13, 0xEA, 0x00, 
				 0x1E, 0x00, 0x00, 0xC0, 0x00, 0x00, 0x1E, 0x01, 
				 0x92, 0x0D, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 
				 0xEA, 0x00, 0x12, 0x07, 0x04, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x0D, 0x00, 0x00, 
				 0x00, 0x18, 0x07, 0x04, 0x16, 0x02, 0x04, 0x00, 
				 0x00, 0x16, 0xC0, 0x00, 0x00, 0x00, 0x17, 0x4C, 
				 0x00, 0xD0, 0x00, 0x00, 0x00, 0x00, 0x00};

BYTE t5464_Mode_800x600x8_4a[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x13, 0xF0, 0x00, 0x1E, 0x00, 0xFF, 0xEF, 0x00, 
				 0x00, 0x19, 0xF0, 0x00, 0x16, 0x05, 0x04, 0x00, 
				 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 0x00, 
				 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 0x00, 
				 0x1F, 0x01, 0x00, 0x18, 0x07, 0x04, 0x15, 0xA0, 
				 0x00, 0xFF, 0x00, 0x09, 0xCE, 0x03, 0x06, 0x05, 
				 0x16, 0x80, 0x00, 0x2F, 0x00, 0x16, 0x84, 0x00, 
				 0x30, 0x00, 0x16, 0x88, 0x00, 0x53, 0x00, 0x1D, 
				 0x19, 0x00, 0x00, 0x00, 0x7F, 0x00, 0x00, 0x00, 
				 0x63, 0x00, 0x00, 0x00, 0x64, 0x00, 0x00, 0x00, 
				 0x9F, 0x00, 0x00, 0x00, 0x67, 0x00, 0x00, 0x00, 
				 0x91, 0x00, 0x00, 0x00, 0x6F, 0x00, 0x00, 0x00, 
				 0xF0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x58, 0x00, 0x00, 0x00, 
				 0x8B, 0x00, 0x00, 0x00, 0x57, 0x00, 0x00, 0x00, 
				 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x57, 0x00, 0x00, 0x00, 0x6F, 0x00, 0x00, 0x00, 
				 0xE3, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 
				 0x1D, 0x06, 0x00, 0x64, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x90, 0x00, 0x00, 0x00, 0x22, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x13, 0xEA, 0x00, 
				 0x1E, 0x00, 0x00, 0xC0, 0x00, 0x00, 0x1E, 0x01, 
				 0x92, 0x0D, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 
				 0xEA, 0x00, 0x12, 0x07, 0x04, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x0D, 0x00, 0x00, 
				 0x00, 0x18, 0x07, 0x04, 0x16, 0x02, 0x04, 0x00, 
				 0x00, 0x16, 0xC0, 0x00, 0x00, 0x00, 0x17, 0x4C, 
				 0x00, 0xD0, 0x00, 0x00, 0x00, 0x00, 0x00};

BYTE t5464_Mode_800x600x8_5a[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x13, 0xF0, 0x00, 0x1E, 0x00, 0xFF, 0xEF, 0x00, 
				 0x00, 0x19, 0xF0, 0x00, 0x16, 0x05, 0x04, 0x00, 
				 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 0x00, 
				 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 0x00, 
				 0x1F, 0x01, 0x00, 0x18, 0x07, 0x04, 0x15, 0xA0, 
				 0x00, 0xFF, 0x00, 0x09, 0xCE, 0x03, 0x06, 0x05, 
				 0x16, 0x80, 0x00, 0x2F, 0x00, 0x16, 0x84, 0x00, 
				 0x1C, 0x00, 0x16, 0x88, 0x00, 0x37, 0x00, 0x1D, 
				 0x19, 0x00, 0x00, 0x00, 0x7E, 0x00, 0x00, 0x00, 
				 0x63, 0x00, 0x00, 0x00, 0x64, 0x00, 0x00, 0x00, 
				 0x9E, 0x00, 0x00, 0x00, 0x69, 0x00, 0x00, 0x00, 
				 0x91, 0x00, 0x00, 0x00, 0x75, 0x00, 0x00, 0x00, 
				 0xF0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x58, 0x00, 0x00, 0x00, 
				 0x8B, 0x00, 0x00, 0x00, 0x57, 0x00, 0x00, 0x00, 
				 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x57, 0x00, 0x00, 0x00, 0x75, 0x00, 0x00, 0x00, 
				 0xE3, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 
				 0x1D, 0x06, 0x00, 0x64, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x90, 0x00, 0x00, 0x00, 0x22, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x13, 0xEA, 0x00, 
				 0x1E, 0x00, 0x00, 0xC0, 0x00, 0x00, 0x1E, 0x01, 
				 0x92, 0x0D, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 
				 0xEA, 0x00, 0x12, 0x07, 0x04, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x0D, 0x00, 0x00, 
				 0x00, 0x18, 0x07, 0x04, 0x16, 0x02, 0x04, 0x00, 
				 0x00, 0x16, 0xC0, 0x00, 0x00, 0x00, 0x17, 0x4C, 
				 0x00, 0xD0, 0x00, 0x00, 0x00, 0x00, 0x00};

BYTE t5464_Mode_1024x768x8_1[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x13, 0xF0, 0x00, 0x1E, 0x00, 0xFF, 0xEF, 0x00, 
				 0x00, 0x19, 0xF0, 0x00, 0x16, 0x05, 0x04, 0x00, 
				 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 0x00, 
				 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 0x00, 
				 0x1F, 0x01, 0x00, 0x18, 0x07, 0x04, 0x15, 0xA0, 
				 0x00, 0xFF, 0x00, 0x09, 0xCE, 0x03, 0x06, 0x05, 
				 0x16, 0x80, 0x00, 0x2F, 0x00, 0x16, 0x84, 0x00, 
				 0x2C, 0x00, 0x16, 0x88, 0x00, 0x45, 0x00, 0x1D, 
				 0x19, 0x00, 0x00, 0x00, 0x99, 0x00, 0x00, 0x00, 
				 0x7F, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 
				 0x99, 0x00, 0x00, 0x00, 0x83, 0x00, 0x00, 0x00, 
				 0x19, 0x00, 0x00, 0x00, 0x96, 0x00, 0x00, 0x00, 
				 0x1F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x7F, 0x00, 0x00, 0x00, 
				 0x83, 0x00, 0x00, 0x00, 0x7F, 0x00, 0x00, 0x00, 
				 0xA0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x80, 0x00, 0x00, 0x00, 0x96, 0x00, 0x00, 0x00, 
				 0xE3, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 
				 0x1D, 0x06, 0x00, 0x64, 0x00, 0x48, 0x00, 0x00, 
				 0x00, 0x51, 0x00, 0x00, 0x00, 0x22, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x13, 0xEA, 0x00, 
				 0x1E, 0x00, 0x00, 0xC0, 0x00, 0x00, 0x1E, 0x01, 
				 0x91, 0x0A, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 
				 0xEA, 0x00, 0x12, 0x07, 0x04, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x0A, 0x00, 0x00, 
				 0x00, 0x18, 0x07, 0x04, 0x13, 0xEA, 0x00, 0x1E, 
				 0x00, 0xC0, 0xFF, 0x00, 0x00, 0x1E, 0x01, 0x12, 
				 0x00, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 0xEA, 
				 0x00, 0x16, 0x02, 0x04, 0x00, 0x00, 0x16, 0xC0, 
				 0x00, 0x00, 0x00, 0x00, 0x4C};

BYTE t5464_Mode_1024x768x8_2[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x13, 0xF0, 0x00, 0x1E, 0x00, 0xFF, 0xEF, 0x00, 
				 0x00, 0x19, 0xF0, 0x00, 0x16, 0x05, 0x04, 0x00, 
				 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 0x00, 
				 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 0x00, 
				 0x1F, 0x01, 0x00, 0x18, 0x07, 0x04, 0x15, 0xA0, 
				 0x00, 0xFF, 0x00, 0x09, 0xCE, 0x03, 0x06, 0x05, 
				 0x16, 0x80, 0x00, 0xEF, 0x00, 0x16, 0x84, 0x00, 
				 0x1A, 0x00, 0x16, 0x88, 0x00, 0x3B, 0x00, 0x1D, 
				 0x19, 0x00, 0x00, 0x00, 0xA3, 0x00, 0x00, 0x00, 
				 0x7F, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 
				 0x83, 0x00, 0x00, 0x00, 0x84, 0x00, 0x00, 0x00, 
				 0x95, 0x00, 0x00, 0x00, 0x24, 0x00, 0x00, 0x00, 
				 0xFD, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 
				 0x88, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 
				 0xA0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x24, 0x00, 0x00, 0x00, 
				 0xE3, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 
				 0x1D, 0x06, 0x00, 0x64, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0xE0, 0x00, 0x00, 0x00, 0x22, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x13, 0xEA, 0x00, 
				 0x1E, 0x00, 0x00, 0xC0, 0x00, 0x00, 0x1E, 0x01, 
				 0x91, 0x0A, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 
				 0xEA, 0x00, 0x12, 0x07, 0x04, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x0A, 0x00, 0x00, 
				 0x00, 0x18, 0x07, 0x04, 0x13, 0xEA, 0x00, 0x1E, 
				 0x00, 0xC0, 0xFF, 0x00, 0x00, 0x1E, 0x01, 0x12, 
				 0x00, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 0xEA, 
				 0x00, 0x16, 0x02, 0x04, 0x00, 0x00, 0x16, 0xC0, 
				 0x00, 0x00, 0x00, 0x00, 0x4C};

BYTE t5464_Mode_1024x768x8_3[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x13, 0xF0, 0x00, 0x1E, 0x00, 0xFF, 0xEF, 0x00, 
				 0x00, 0x19, 0xF0, 0x00, 0x16, 0x05, 0x04, 0x00, 
				 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 0x00, 
				 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 0x00, 
				 0x1F, 0x01, 0x00, 0x18, 0x07, 0x04, 0x15, 0xA0, 
				 0x00, 0xFF, 0x00, 0x09, 0xCE, 0x03, 0x06, 0x05, 
				 0x16, 0x80, 0x00, 0xEF, 0x00, 0x16, 0x84, 0x00, 
				 0x2A, 0x00, 0x16, 0x88, 0x00, 0x6E, 0x00, 0x1D, 
				 0x19, 0x00, 0x00, 0x00, 0xA1, 0x00, 0x00, 0x00, 
				 0x7F, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 
				 0x81, 0x00, 0x00, 0x00, 0x84, 0x00, 0x00, 0x00, 
				 0x95, 0x00, 0x00, 0x00, 0x24, 0x00, 0x00, 0x00, 
				 0xFD, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 
				 0x88, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 
				 0xA0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x24, 0x00, 0x00, 0x00, 
				 0xE3, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 
				 0x1D, 0x06, 0x00, 0x64, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0xE0, 0x00, 0x00, 0x00, 0x22, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x13, 0xEA, 0x00, 
				 0x1E, 0x00, 0x00, 0xC0, 0x00, 0x00, 0x1E, 0x01, 
				 0x91, 0x0A, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 
				 0xEA, 0x00, 0x12, 0x07, 0x04, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x0A, 0x00, 0x00, 
				 0x00, 0x18, 0x07, 0x04, 0x13, 0xEA, 0x00, 0x1E, 
				 0x00, 0xC0, 0xFF, 0x00, 0x00, 0x1E, 0x01, 0x12, 
				 0x00, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 0xEA, 
				 0x00, 0x16, 0x02, 0x04, 0x00, 0x00, 0x16, 0xC0, 
				 0x00, 0x00, 0x00, 0x00, 0x4C};

BYTE t5464_Mode_1024x768x8_4[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x13, 0xF0, 0x00, 0x1E, 0x00, 0xFF, 0xEF, 0x00, 
				 0x00, 0x19, 0xF0, 0x00, 0x16, 0x05, 0x04, 0x00, 
				 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 0x00, 
				 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 0x00, 
				 0x1F, 0x01, 0x00, 0x18, 0x07, 0x04, 0x15, 0xA0, 
				 0x00, 0xFF, 0x00, 0x09, 0xCE, 0x03, 0x06, 0x05, 
				 0x16, 0x80, 0x00, 0x2F, 0x00, 0x16, 0x84, 0x00, 
				 0x10, 0x00, 0x16, 0x88, 0x00, 0x2C, 0x00, 0x1D, 
				 0x19, 0x00, 0x00, 0x00, 0x9F, 0x00, 0x00, 0x00, 
				 0x7F, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 
				 0x9F, 0x00, 0x00, 0x00, 0x83, 0x00, 0x00, 0x00, 
				 0x0F, 0x00, 0x00, 0x00, 0x1E, 0x00, 0x00, 0x00, 
				 0xF5, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x83, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 
				 0xA0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0xFF, 0x00, 0x00, 0x00, 0x1E, 0x00, 0x00, 0x00, 
				 0xE3, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 
				 0x1D, 0x06, 0x00, 0x64, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0xE0, 0x00, 0x00, 0x00, 0x22, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x13, 0xEA, 0x00, 
				 0x1E, 0x00, 0x00, 0xC0, 0x00, 0x00, 0x1E, 0x01, 
				 0x91, 0x0A, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 
				 0xEA, 0x00, 0x12, 0x07, 0x04, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x0A, 0x00, 0x00, 
				 0x00, 0x18, 0x07, 0x04, 0x13, 0xEA, 0x00, 0x1E, 
				 0x00, 0xC0, 0xFF, 0x00, 0x00, 0x1E, 0x01, 0x12, 
				 0x00, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 0xEA, 
				 0x00, 0x16, 0x02, 0x04, 0x00, 0x00, 0x16, 0xC0, 
				 0x00, 0x00, 0x00, 0x00, 0x4C};

BYTE t5464_Mode_1024x768x8_5[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x13, 0xF0, 0x00, 0x1E, 0x00, 0xFF, 0xEF, 0x00, 
				 0x00, 0x19, 0xF0, 0x00, 0x16, 0x05, 0x04, 0x00, 
				 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 0x00, 
				 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 0x00, 
				 0x1F, 0x01, 0x00, 0x18, 0x07, 0x04, 0x15, 0xA0, 
				 0x00, 0xFF, 0x00, 0x09, 0xCE, 0x03, 0x06, 0x05, 
				 0x16, 0x80, 0x00, 0x2F, 0x00, 0x16, 0x84, 0x00, 
				 0x0A, 0x00, 0x16, 0x88, 0x00, 0x21, 0x00, 0x1D, 
				 0x19, 0x00, 0x00, 0x00, 0xA7, 0x00, 0x00, 0x00, 
				 0x7F, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 
				 0x87, 0x00, 0x00, 0x00, 0x87, 0x00, 0x00, 0x00, 
				 0x93, 0x00, 0x00, 0x00, 0x26, 0x00, 0x00, 0x00, 
				 0xF5, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x83, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 
				 0xA0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0xFF, 0x00, 0x00, 0x00, 0x26, 0x00, 0x00, 0x00, 
				 0xE3, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 
				 0x1D, 0x06, 0x00, 0x64, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0xE0, 0x00, 0x00, 0x00, 0x22, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x13, 0xEA, 0x00, 
				 0x1E, 0x00, 0x00, 0xC0, 0x00, 0x00, 0x1E, 0x01, 
				 0x91, 0x0A, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 
				 0xEA, 0x00, 0x12, 0x07, 0x04, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x0A, 0x00, 0x00, 
				 0x00, 0x18, 0x07, 0x04, 0x13, 0xEA, 0x00, 0x1E, 
				 0x00, 0xC0, 0xFF, 0x00, 0x00, 0x1E, 0x01, 0x12, 
				 0x00, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 0xEA, 
				 0x00, 0x16, 0x02, 0x04, 0x00, 0x00, 0x16, 0xC0, 
				 0x00, 0x00, 0x00, 0x00, 0x4C};

BYTE t5464_Mode_1024x768x8_1a[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x13, 0xF0, 0x00, 0x1E, 0x00, 0xFF, 0xEF, 0x00, 
				 0x00, 0x19, 0xF0, 0x00, 0x16, 0x05, 0x04, 0x00, 
				 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 0x00, 
				 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 0x00, 
				 0x1F, 0x01, 0x00, 0x18, 0x07, 0x04, 0x15, 0xA0, 
				 0x00, 0xFF, 0x00, 0x09, 0xCE, 0x03, 0x06, 0x05, 
				 0x16, 0x80, 0x00, 0x2F, 0x00, 0x16, 0x84, 0x00, 
				 0x2C, 0x00, 0x16, 0x88, 0x00, 0x45, 0x00, 0x1D, 
				 0x19, 0x00, 0x00, 0x00, 0x99, 0x00, 0x00, 0x00, 
				 0x7F, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 
				 0x99, 0x00, 0x00, 0x00, 0x83, 0x00, 0x00, 0x00, 
				 0x19, 0x00, 0x00, 0x00, 0x96, 0x00, 0x00, 0x00, 
				 0x1F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x7F, 0x00, 0x00, 0x00, 
				 0x83, 0x00, 0x00, 0x00, 0x7F, 0x00, 0x00, 0x00, 
				 0xA0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x80, 0x00, 0x00, 0x00, 0x96, 0x00, 0x00, 0x00, 
				 0xE3, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 
				 0x1D, 0x06, 0x00, 0x64, 0x00, 0x48, 0x00, 0x00, 
				 0x00, 0x51, 0x00, 0x00, 0x00, 0x22, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x13, 0xEA, 0x00, 
				 0x1E, 0x00, 0x00, 0xC0, 0x00, 0x00, 0x1E, 0x01, 
				 0xD2, 0x08, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 
				 0xEA, 0x00, 0x12, 0x07, 0x04, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x08, 0x00, 0x00, 
				 0x00, 0x18, 0x07, 0x04, 0x16, 0x02, 0x04, 0x00, 
				 0x08, 0x16, 0xC0, 0x00, 0x00, 0x00, 0x17, 0x4C, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x17, 0x6C, 0x00, 
				 0x32, 0x00, 0x00, 0x00, 0x00, 0x00};

BYTE t5464_Mode_1024x768x8_2a[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x13, 0xF0, 0x00, 0x1E, 0x00, 0xFF, 0xEF, 0x00, 
				 0x00, 0x19, 0xF0, 0x00, 0x16, 0x05, 0x04, 0x00, 
				 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 0x00, 
				 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 0x00, 
				 0x1F, 0x01, 0x00, 0x18, 0x07, 0x04, 0x15, 0xA0, 
				 0x00, 0xFF, 0x00, 0x09, 0xCE, 0x03, 0x06, 0x05, 
				 0x16, 0x80, 0x00, 0xEF, 0x00, 0x16, 0x84, 0x00, 
				 0x1A, 0x00, 0x16, 0x88, 0x00, 0x3B, 0x00, 0x1D, 
				 0x19, 0x00, 0x00, 0x00, 0xA3, 0x00, 0x00, 0x00, 
				 0x7F, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 
				 0x83, 0x00, 0x00, 0x00, 0x84, 0x00, 0x00, 0x00, 
				 0x95, 0x00, 0x00, 0x00, 0x24, 0x00, 0x00, 0x00, 
				 0xFD, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 
				 0x88, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 
				 0xA0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x24, 0x00, 0x00, 0x00, 
				 0xE3, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 
				 0x1D, 0x06, 0x00, 0x64, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0xE0, 0x00, 0x00, 0x00, 0x22, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x13, 0xEA, 0x00, 
				 0x1E, 0x00, 0x00, 0xC0, 0x00, 0x00, 0x1E, 0x01, 
				 0xD2, 0x08, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 
				 0xEA, 0x00, 0x12, 0x07, 0x04, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x08, 0x00, 0x00, 
				 0x00, 0x18, 0x07, 0x04, 0x16, 0x02, 0x04, 0x00, 
				 0x08, 0x16, 0xC0, 0x00, 0x00, 0x00, 0x17, 0x4C, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x17, 0x6C, 0x00, 
				 0x32, 0x00, 0x00, 0x00, 0x00, 0x00};

BYTE t5464_Mode_1024x768x8_3a[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x13, 0xF0, 0x00, 0x1E, 0x00, 0xFF, 0xEF, 0x00, 
				 0x00, 0x19, 0xF0, 0x00, 0x16, 0x05, 0x04, 0x00, 
				 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 0x00, 
				 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 0x00, 
				 0x1F, 0x01, 0x00, 0x18, 0x07, 0x04, 0x15, 0xA0, 
				 0x00, 0xFF, 0x00, 0x09, 0xCE, 0x03, 0x06, 0x05, 
				 0x16, 0x80, 0x00, 0xEF, 0x00, 0x16, 0x84, 0x00, 
				 0x2A, 0x00, 0x16, 0x88, 0x00, 0x6E, 0x00, 0x1D, 
				 0x19, 0x00, 0x00, 0x00, 0xA1, 0x00, 0x00, 0x00, 
				 0x7F, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 
				 0x81, 0x00, 0x00, 0x00, 0x84, 0x00, 0x00, 0x00, 
				 0x95, 0x00, 0x00, 0x00, 0x24, 0x00, 0x00, 0x00, 
				 0xFD, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 
				 0x88, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 
				 0xA0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x24, 0x00, 0x00, 0x00, 
				 0xE3, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 
				 0x1D, 0x06, 0x00, 0x64, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0xE0, 0x00, 0x00, 0x00, 0x22, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x13, 0xEA, 0x00, 
				 0x1E, 0x00, 0x00, 0xC0, 0x00, 0x00, 0x1E, 0x01, 
				 0xD2, 0x08, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 
				 0xEA, 0x00, 0x12, 0x07, 0x04, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x08, 0x00, 0x00, 
				 0x00, 0x18, 0x07, 0x04, 0x16, 0x02, 0x04, 0x00, 
				 0x08, 0x16, 0xC0, 0x00, 0x00, 0x00, 0x17, 0x4C, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x17, 0x6C, 0x00, 
				 0x32, 0x00, 0x00, 0x00, 0x00, 0x00};

BYTE t5464_Mode_1024x768x8_4a[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x13, 0xF0, 0x00, 0x1E, 0x00, 0xFF, 0xEF, 0x00, 
				 0x00, 0x19, 0xF0, 0x00, 0x16, 0x05, 0x04, 0x00, 
				 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 0x00, 
				 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 0x00, 
				 0x1F, 0x01, 0x00, 0x18, 0x07, 0x04, 0x15, 0xA0, 
				 0x00, 0xFF, 0x00, 0x09, 0xCE, 0x03, 0x06, 0x05, 
				 0x16, 0x80, 0x00, 0x2F, 0x00, 0x16, 0x84, 0x00, 
				 0x10, 0x00, 0x16, 0x88, 0x00, 0x2C, 0x00, 0x1D, 
				 0x19, 0x00, 0x00, 0x00, 0x9F, 0x00, 0x00, 0x00, 
				 0x7F, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 
				 0x9F, 0x00, 0x00, 0x00, 0x83, 0x00, 0x00, 0x00, 
				 0x0F, 0x00, 0x00, 0x00, 0x1E, 0x00, 0x00, 0x00, 
				 0xF5, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x83, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 
				 0xA0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0xFF, 0x00, 0x00, 0x00, 0x1E, 0x00, 0x00, 0x00, 
				 0xE3, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 
				 0x1D, 0x06, 0x00, 0x64, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0xE0, 0x00, 0x00, 0x00, 0x22, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x13, 0xEA, 0x00, 
				 0x1E, 0x00, 0x00, 0xC0, 0x00, 0x00, 0x1E, 0x01, 
				 0xD2, 0x08, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 
				 0xEA, 0x00, 0x12, 0x07, 0x04, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x08, 0x00, 0x00, 
				 0x00, 0x18, 0x07, 0x04, 0x16, 0x02, 0x04, 0x00, 
				 0x08, 0x16, 0xC0, 0x00, 0x00, 0x00, 0x17, 0x4C, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x17, 0x6C, 0x00, 
				 0x32, 0x00, 0x00, 0x00, 0x00, 0x00};

BYTE t5464_Mode_1024x768x8_5a[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x13, 0xF0, 0x00, 0x1E, 0x00, 0xFF, 0xEF, 0x00, 
				 0x00, 0x19, 0xF0, 0x00, 0x16, 0x05, 0x04, 0x00, 
				 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 0x00, 
				 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 0x00, 
				 0x1F, 0x01, 0x00, 0x18, 0x07, 0x04, 0x15, 0xA0, 
				 0x00, 0xFF, 0x00, 0x09, 0xCE, 0x03, 0x06, 0x05, 
				 0x16, 0x80, 0x00, 0x2F, 0x00, 0x16, 0x84, 0x00, 
				 0x0A, 0x00, 0x16, 0x88, 0x00, 0x21, 0x00, 0x1D, 
				 0x19, 0x00, 0x00, 0x00, 0xA7, 0x00, 0x00, 0x00, 
				 0x7F, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 
				 0x87, 0x00, 0x00, 0x00, 0x87, 0x00, 0x00, 0x00, 
				 0x93, 0x00, 0x00, 0x00, 0x26, 0x00, 0x00, 0x00, 
				 0xF5, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x83, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 
				 0xA0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0xFF, 0x00, 0x00, 0x00, 0x26, 0x00, 0x00, 0x00, 
				 0xE3, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 
				 0x1D, 0x06, 0x00, 0x64, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0xE0, 0x00, 0x00, 0x00, 0x22, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x13, 0xEA, 0x00, 
				 0x1E, 0x00, 0x00, 0xC0, 0x00, 0x00, 0x1E, 0x01, 
				 0xD2, 0x08, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 
				 0xEA, 0x00, 0x12, 0x07, 0x04, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x08, 0x00, 0x00, 
				 0x00, 0x18, 0x07, 0x04, 0x16, 0x02, 0x04, 0x00, 
				 0x08, 0x16, 0xC0, 0x00, 0x00, 0x00, 0x17, 0x4C, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x17, 0x6C, 0x00, 
				 0x32, 0x00, 0x00, 0x00, 0x00, 0x00};

BYTE t5464_Mode_1152x864x8_1[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x13, 0xF0, 0x00, 0x1E, 0x00, 0xFF, 0xEF, 0x00, 
				 0x00, 0x19, 0xF0, 0x00, 0x16, 0x05, 0x04, 0x00, 
				 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 0x00, 
				 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 0x00, 
				 0x1F, 0x01, 0x00, 0x18, 0x07, 0x04, 0x15, 0xA0, 
				 0x00, 0xFF, 0x00, 0x09, 0xCE, 0x03, 0x06, 0x05, 
				 0x16, 0x80, 0x00, 0x2F, 0x00, 0x16, 0x84, 0x00, 
				 0x0A, 0x00, 0x16, 0x88, 0x00, 0x21, 0x00, 0x1D, 
				 0x19, 0x00, 0x00, 0x00, 0xB4, 0x00, 0x00, 0x00, 
				 0x8F, 0x00, 0x00, 0x00, 0x8F, 0x00, 0x00, 0x00, 
				 0x94, 0x00, 0x00, 0x00, 0x93, 0x00, 0x00, 0x00, 
				 0x9F, 0x00, 0x00, 0x00, 0x8E, 0x00, 0x00, 0x00, 
				 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x60, 0x00, 0x00, 0x00, 
				 0x83, 0x00, 0x00, 0x00, 0x5F, 0x00, 0x00, 0x00, 
				 0xA0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x5F, 0x00, 0x00, 0x00, 0x8E, 0x00, 0x00, 0x00, 
				 0xE3, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 
				 0x1D, 0x06, 0x00, 0x64, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0xE0, 0x00, 0x00, 0x00, 0x22, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x13, 0xEA, 0x00, 
				 0x1E, 0x00, 0x00, 0xC0, 0x00, 0x00, 0x1E, 0x01, 
				 0xD1, 0x05, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 
				 0xEA, 0x00, 0x12, 0x07, 0x04, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 
				 0x00, 0x18, 0x07, 0x04, 0x13, 0xEA, 0x00, 0x1E, 
				 0x00, 0xC0, 0xFF, 0x00, 0x00, 0x1E, 0x01, 0x16, 
				 0x00, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 0xEA, 
				 0x00, 0x16, 0x02, 0x04, 0x00, 0x08, 0x16, 0xC0, 
				 0x00, 0x00, 0x00, 0x00, 0x4C};

BYTE t5464_Mode_1152x864x8_2[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x13, 0xF0, 0x00, 0x1E, 0x00, 0xFF, 0xEF, 0x00, 
				 0x00, 0x19, 0xF0, 0x00, 0x16, 0x05, 0x04, 0x00, 
				 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 0x00, 
				 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 0x00, 
				 0x1F, 0x01, 0x00, 0x18, 0x07, 0x04, 0x15, 0xA0, 
				 0x00, 0xFF, 0x00, 0x09, 0xCE, 0x03, 0x06, 0x05, 
				 0x16, 0x80, 0x00, 0x2F, 0x00, 0x16, 0x84, 0x00, 
				 0x16, 0x00, 0x16, 0x88, 0x00, 0x53, 0x00, 0x1D, 
				 0x19, 0x00, 0x00, 0x00, 0xC3, 0x00, 0x00, 0x00, 
				 0x8F, 0x00, 0x00, 0x00, 0x8F, 0x00, 0x00, 0x00, 
				 0x83, 0x00, 0x00, 0x00, 0x97, 0x00, 0x00, 0x00, 
				 0x07, 0x00, 0x00, 0x00, 0x82, 0x00, 0x00, 0x00, 
				 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x60, 0x00, 0x00, 0x00, 
				 0x83, 0x00, 0x00, 0x00, 0x5F, 0x00, 0x00, 0x00, 
				 0xA0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x5F, 0x00, 0x00, 0x00, 0x82, 0x00, 0x00, 0x00, 
				 0xE3, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 
				 0x1D, 0x06, 0x00, 0x64, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0xF0, 0x00, 0x00, 0x00, 0x22, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x13, 0xEA, 0x00, 
				 0x1E, 0x00, 0x00, 0xC0, 0x00, 0x00, 0x1E, 0x01, 
				 0xD1, 0x05, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 
				 0xEA, 0x00, 0x12, 0x07, 0x04, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 
				 0x00, 0x18, 0x07, 0x04, 0x13, 0xEA, 0x00, 0x1E, 
				 0x00, 0xC0, 0xFF, 0x00, 0x00, 0x1E, 0x01, 0x16, 
				 0x00, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 0xEA, 
				 0x00, 0x16, 0x02, 0x04, 0x00, 0x08, 0x16, 0xC0, 
				 0x00, 0x00, 0x00, 0x00, 0x4C};

BYTE t5464_Mode_1152x864x8_3[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x13, 0xF0, 0x00, 0x1E, 0x00, 0xFF, 0xEF, 0x00, 
				 0x00, 0x19, 0xF0, 0x00, 0x16, 0x05, 0x04, 0x00, 
				 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 0x00, 
				 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 0x00, 
				 0x1F, 0x01, 0x00, 0x18, 0x07, 0x04, 0x15, 0xA0, 
				 0x00, 0xFF, 0x00, 0x09, 0xCE, 0x03, 0x06, 0x05, 
				 0x16, 0x80, 0x00, 0x2F, 0x00, 0x16, 0x84, 0x00, 
				 0x04, 0x00, 0x16, 0x88, 0x00, 0x11, 0x00, 0x1D, 
				 0x19, 0x00, 0x00, 0x00, 0xC0, 0x00, 0x00, 0x00, 
				 0x8F, 0x00, 0x00, 0x00, 0x8F, 0x00, 0x00, 0x00, 
				 0x80, 0x00, 0x00, 0x00, 0x97, 0x00, 0x00, 0x00, 
				 0x07, 0x00, 0x00, 0x00, 0x89, 0x00, 0x00, 0x00, 
				 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x60, 0x00, 0x00, 0x00, 
				 0x83, 0x00, 0x00, 0x00, 0x5F, 0x00, 0x00, 0x00, 
				 0xA0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x5F, 0x00, 0x00, 0x00, 0x89, 0x00, 0x00, 0x00, 
				 0xE3, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 
				 0x1D, 0x06, 0x00, 0x64, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0xF0, 0x00, 0x00, 0x00, 0x22, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x13, 0xEA, 0x00, 
				 0x1E, 0x00, 0x00, 0xC0, 0x00, 0x00, 0x1E, 0x01, 
				 0xD1, 0x05, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 
				 0xEA, 0x00, 0x12, 0x07, 0x04, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 
				 0x00, 0x18, 0x07, 0x04, 0x13, 0xEA, 0x00, 0x1E, 
				 0x00, 0xC0, 0xFF, 0x00, 0x00, 0x1E, 0x01, 0x16, 
				 0x00, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 0xEA, 
				 0x00, 0x16, 0x02, 0x04, 0x00, 0x08, 0x16, 0xC0, 
				 0x00, 0x00, 0x00, 0x00, 0x4C};

BYTE t5464_Mode_1280x960x8_1[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x13, 0xF0, 0x00, 0x1E, 0x00, 0xFF, 0xEF, 0x00, 
				 0x00, 0x19, 0xF0, 0x00, 0x16, 0x05, 0x04, 0x00, 
				 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 0x00, 
				 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 0x00, 
				 0x1F, 0x01, 0x00, 0x18, 0x07, 0x04, 0x15, 0xA0, 
				 0x00, 0xFF, 0x00, 0x09, 0xCE, 0x03, 0x06, 0x05, 
				 0x16, 0x80, 0x00, 0x2F, 0x00, 0x16, 0x84, 0x00, 
				 0x16, 0x00, 0x16, 0x88, 0x00, 0x53, 0x00, 0x1D, 
				 0x19, 0x00, 0x00, 0x00, 0xDC, 0x00, 0x00, 0x00, 
				 0x9F, 0x00, 0x00, 0x00, 0x9F, 0x00, 0x00, 0x00, 
				 0x9C, 0x00, 0x00, 0x00, 0xAB, 0x00, 0x00, 0x00, 
				 0x19, 0x00, 0x00, 0x00, 0xE6, 0x00, 0x00, 0x00, 
				 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0xC0, 0x00, 0x00, 0x00, 
				 0x83, 0x00, 0x00, 0x00, 0xBF, 0x00, 0x00, 0x00, 
				 0xA0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0xBF, 0x00, 0x00, 0x00, 0xE6, 0x00, 0x00, 0x00, 
				 0xE3, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 
				 0x1D, 0x06, 0x00, 0x64, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0xF0, 0x00, 0x00, 0x00, 0x22, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x13, 0xEA, 0x00, 
				 0x1E, 0x00, 0x00, 0xC0, 0x00, 0x00, 0x1E, 0x01, 
				 0xD1, 0x05, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 
				 0xEA, 0x00, 0x12, 0x07, 0x04, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 
				 0x00, 0x18, 0x07, 0x04, 0x13, 0xEA, 0x00, 0x1E, 
				 0x00, 0xC0, 0xFF, 0x00, 0x00, 0x1E, 0x01, 0x16, 
				 0x00, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 0xEA, 
				 0x00, 0x16, 0x02, 0x04, 0x00, 0x08, 0x16, 0xC0, 
				 0x00, 0x00, 0x00, 0x00, 0x4C};

BYTE t5464_Mode_1280x960x8_2[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x13, 0xF0, 0x00, 0x1E, 0x00, 0xFF, 0xEF, 0x00, 
				 0x00, 0x19, 0xF0, 0x00, 0x16, 0x05, 0x04, 0x00, 
				 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 0x00, 
				 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 0x00, 
				 0x1F, 0x01, 0x00, 0x18, 0x07, 0x04, 0x15, 0xA0, 
				 0x00, 0xFF, 0x00, 0x09, 0xCE, 0x03, 0x06, 0x05, 
				 0x16, 0x80, 0x00, 0x2F, 0x00, 0x16, 0x84, 0x00, 
				 0x0A, 0x00, 0x16, 0x88, 0x00, 0x2C, 0x00, 0x1D, 
				 0x19, 0x00, 0x00, 0x00, 0xCD, 0x00, 0x00, 0x00, 
				 0x9F, 0x00, 0x00, 0x00, 0x9F, 0x00, 0x00, 0x00, 
				 0x8D, 0x00, 0x00, 0x00, 0xA3, 0x00, 0x00, 0x00, 
				 0x15, 0x00, 0x00, 0x00, 0xE6, 0x00, 0x00, 0x00, 
				 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0xC0, 0x00, 0x00, 0x00, 
				 0x83, 0x00, 0x00, 0x00, 0xBF, 0x00, 0x00, 0x00, 
				 0xA0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0xBF, 0x00, 0x00, 0x00, 0xE6, 0x00, 0x00, 0x00, 
				 0xE3, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 
				 0x1D, 0x06, 0x00, 0x64, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0xF0, 0x00, 0x00, 0x00, 0x22, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x13, 0xEA, 0x00, 
				 0x1E, 0x00, 0x00, 0xC0, 0x00, 0x00, 0x1E, 0x01, 
				 0xD1, 0x05, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 
				 0xEA, 0x00, 0x12, 0x07, 0x04, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 
				 0x00, 0x18, 0x07, 0x04, 0x13, 0xEA, 0x00, 0x1E, 
				 0x00, 0xC0, 0xFF, 0x00, 0x00, 0x1E, 0x01, 0x16, 
				 0x00, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 0xEA, 
				 0x00, 0x16, 0x02, 0x04, 0x00, 0x08, 0x16, 0xC0, 
				 0x00, 0x00, 0x00, 0x00, 0x4C};

BYTE t5464_Mode_1280x960x8_3[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x13, 0xF0, 0x00, 0x1E, 0x00, 0xFF, 0xEF, 0x00, 
				 0x00, 0x19, 0xF0, 0x00, 0x16, 0x05, 0x04, 0x00, 
				 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 0x00, 
				 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 0x00, 
				 0x1F, 0x01, 0x00, 0x18, 0x07, 0x04, 0x15, 0xA0, 
				 0x00, 0xFF, 0x00, 0x09, 0xCE, 0x03, 0x06, 0x05, 
				 0x16, 0x80, 0x00, 0x2F, 0x00, 0x16, 0x84, 0x00, 
				 0x10, 0x00, 0x16, 0x88, 0x00, 0x53, 0x00, 0x1D, 
				 0x19, 0x00, 0x00, 0x00, 0xD3, 0x00, 0x00, 0x00, 
				 0x9F, 0x00, 0x00, 0x00, 0x9F, 0x00, 0x00, 0x00, 
				 0x93, 0x00, 0x00, 0x00, 0xA5, 0x00, 0x00, 0x00, 
				 0x19, 0x00, 0x00, 0x00, 0xF1, 0x00, 0x00, 0x00, 
				 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0xC0, 0x00, 0x00, 0x00, 
				 0x83, 0x00, 0x00, 0x00, 0xBF, 0x00, 0x00, 0x00, 
				 0xA0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0xBF, 0x00, 0x00, 0x00, 0xF1, 0x00, 0x00, 0x00, 
				 0xE3, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 
				 0x1D, 0x06, 0x00, 0x64, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0xF0, 0x00, 0x00, 0x00, 0x22, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x13, 0xEA, 0x00, 
				 0x1E, 0x00, 0x00, 0xC0, 0x00, 0x00, 0x1E, 0x01, 
				 0xD1, 0x05, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 
				 0xEA, 0x00, 0x12, 0x07, 0x04, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 
				 0x00, 0x18, 0x07, 0x04, 0x13, 0xEA, 0x00, 0x1E, 
				 0x00, 0xC0, 0xFF, 0x00, 0x00, 0x1E, 0x01, 0x16, 
				 0x00, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 0xEA, 
				 0x00, 0x16, 0x02, 0x04, 0x00, 0x08, 0x16, 0xC0, 
				 0x00, 0x00, 0x00, 0x00, 0x4C};

BYTE t5464_Mode_1280x1024x8_1[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x13, 0xF0, 0x00, 0x1E, 0x00, 0xFF, 0xEF, 0x00, 
				 0x00, 0x19, 0xF0, 0x00, 0x16, 0x05, 0x04, 0x00, 
				 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 0x00, 
				 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 0x00, 
				 0x1F, 0x01, 0x00, 0x18, 0x07, 0x04, 0x15, 0xA0, 
				 0x00, 0xFF, 0x00, 0x09, 0xCE, 0x03, 0x06, 0x05, 
				 0x16, 0x80, 0x00, 0x2F, 0x00, 0x16, 0x84, 0x00, 
				 0x04, 0x00, 0x16, 0x88, 0x00, 0x0B, 0x00, 0x1D, 
				 0x19, 0x00, 0x00, 0x00, 0xCF, 0x00, 0x00, 0x00, 
				 0x9F, 0x00, 0x00, 0x00, 0x9F, 0x00, 0x00, 0x00, 
				 0x93, 0x00, 0x00, 0x00, 0xA9, 0x00, 0x00, 0x00, 
				 0x13, 0x00, 0x00, 0x00, 0x14, 0x00, 0x00, 0x00, 
				 0xB2, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x83, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 
				 0xA0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x14, 0x00, 0x00, 0x00, 
				 0xE3, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 
				 0x1D, 0x06, 0x00, 0x64, 0x00, 0x67, 0x00, 0x00, 
				 0x00, 0x81, 0x00, 0x00, 0x00, 0x22, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x13, 0xEA, 0x00, 
				 0x1E, 0x00, 0x00, 0xC0, 0x00, 0x00, 0x1E, 0x01, 
				 0xD1, 0x05, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 
				 0xEA, 0x00, 0x12, 0x07, 0x04, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 
				 0x00, 0x18, 0x07, 0x04, 0x13, 0xEA, 0x00, 0x1E, 
				 0x00, 0xC0, 0xFF, 0x00, 0x00, 0x1E, 0x01, 0x16, 
				 0x00, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 0xEA, 
				 0x00, 0x16, 0x02, 0x04, 0x00, 0x08, 0x16, 0xC0, 
				 0x00, 0x00, 0x00, 0x00, 0x4C};

BYTE t5464_Mode_1280x1024x8_2[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x13, 0xF0, 0x00, 0x1E, 0x00, 0xFF, 0xEF, 0x00, 
				 0x00, 0x19, 0xF0, 0x00, 0x16, 0x05, 0x04, 0x00, 
				 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 0x00, 
				 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 0x00, 
				 0x1F, 0x01, 0x00, 0x18, 0x07, 0x04, 0x15, 0xA0, 
				 0x00, 0xFF, 0x00, 0x09, 0xCE, 0x03, 0x06, 0x05, 
				 0x16, 0x80, 0x00, 0x2F, 0x00, 0x16, 0x84, 0x00, 
				 0x16, 0x00, 0x16, 0x88, 0x00, 0x53, 0x00, 0x1D, 
				 0x19, 0x00, 0x00, 0x00, 0xCE, 0x00, 0x00, 0x00, 
				 0x9F, 0x00, 0x00, 0x00, 0x9F, 0x00, 0x00, 0x00, 
				 0x91, 0x00, 0x00, 0x00, 0xA7, 0x00, 0x00, 0x00, 
				 0x15, 0x00, 0x00, 0x00, 0x28, 0x00, 0x00, 0x00, 
				 0x5A, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x83, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 
				 0xA0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0xFF, 0x00, 0x00, 0x00, 0x24, 0x00, 0x00, 0x00, 
				 0xE3, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 
				 0x1D, 0x06, 0x00, 0x64, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x30, 0x00, 0x00, 0x00, 0x22, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x09, 0x00, 0x00, 0x00, 0x13, 0xEA, 0x00, 
				 0x1E, 0x00, 0x00, 0xC0, 0x00, 0x00, 0x1E, 0x01, 
				 0xD1, 0x05, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 
				 0xEA, 0x00, 0x12, 0x07, 0x04, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 
				 0x00, 0x18, 0x07, 0x04, 0x13, 0xEA, 0x00, 0x1E, 
				 0x00, 0xC0, 0xFF, 0x00, 0x00, 0x1E, 0x01, 0x16, 
				 0x00, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 0xEA, 
				 0x00, 0x16, 0x02, 0x04, 0x00, 0x08, 0x16, 0xC0, 
				 0x00, 0x00, 0x00, 0x00, 0x4C};

BYTE t5464_Mode_1280x1024x8_3[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x13, 0xF0, 0x00, 0x1E, 0x00, 0xFF, 0xEF, 0x00, 
				 0x00, 0x19, 0xF0, 0x00, 0x16, 0x05, 0x04, 0x00, 
				 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 0x00, 
				 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 0x00, 
				 0x1F, 0x01, 0x00, 0x18, 0x07, 0x04, 0x15, 0xA0, 
				 0x00, 0xFF, 0x00, 0x09, 0xCE, 0x03, 0x06, 0x05, 
				 0x16, 0x80, 0x00, 0x2F, 0x00, 0x16, 0x84, 0x00, 
				 0x0C, 0x00, 0x16, 0x88, 0x00, 0x35, 0x00, 0x1D, 
				 0x19, 0x00, 0x00, 0x00, 0xCB, 0x00, 0x00, 0x00, 
				 0x9F, 0x00, 0x00, 0x00, 0x9F, 0x00, 0x00, 0x00, 
				 0x89, 0x00, 0x00, 0x00, 0xA6, 0x00, 0x00, 0x00, 
				 0x1C, 0x00, 0x00, 0x00, 0x2A, 0x00, 0x00, 0x00, 
				 0x5A, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00, 
				 0x8F, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 
				 0xA0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0xFF, 0x00, 0x00, 0x00, 0x24, 0x00, 0x00, 0x00, 
				 0xE3, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 
				 0x1D, 0x06, 0x00, 0x64, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x30, 0x00, 0x00, 0x00, 0x22, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x09, 0x00, 0x00, 0x00, 0x13, 0xEA, 0x00, 
				 0x1E, 0x00, 0x00, 0xC0, 0x00, 0x00, 0x1E, 0x01, 
				 0xD1, 0x05, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 
				 0xEA, 0x00, 0x12, 0x07, 0x04, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 
				 0x00, 0x18, 0x07, 0x04, 0x13, 0xEA, 0x00, 0x1E, 
				 0x00, 0xC0, 0xFF, 0x00, 0x00, 0x1E, 0x01, 0x16, 
				 0x00, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 0xEA, 
				 0x00, 0x16, 0x02, 0x04, 0x00, 0x08, 0x16, 0xC0, 
				 0x00, 0x00, 0x00, 0x00, 0x4C};

BYTE t5464_Mode_1280x1024x8_4[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x13, 0xF0, 0x00, 0x1E, 0x00, 0xFF, 0xEF, 0x00, 
				 0x00, 0x19, 0xF0, 0x00, 0x16, 0x05, 0x04, 0x00, 
				 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 0x00, 
				 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 0x00, 
				 0x1F, 0x01, 0x00, 0x18, 0x07, 0x04, 0x15, 0xA0, 
				 0x00, 0xFF, 0x00, 0x09, 0xCE, 0x03, 0x06, 0x05, 
				 0x16, 0x80, 0x00, 0x2F, 0x00, 0x16, 0x84, 0x00, 
				 0x0E, 0x00, 0x16, 0x88, 0x00, 0x42, 0x00, 0x1D, 
				 0x19, 0x00, 0x00, 0x00, 0xCE, 0x00, 0x00, 0x00, 
				 0x9F, 0x00, 0x00, 0x00, 0x9F, 0x00, 0x00, 0x00, 
				 0x91, 0x00, 0x00, 0x00, 0xA3, 0x00, 0x00, 0x00, 
				 0x15, 0x00, 0x00, 0x00, 0x28, 0x00, 0x00, 0x00, 
				 0x5A, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x83, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 
				 0xA0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0xFF, 0x00, 0x00, 0x00, 0x24, 0x00, 0x00, 0x00, 
				 0xE3, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 
				 0x1D, 0x06, 0x00, 0x64, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x30, 0x00, 0x00, 0x00, 0x22, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x09, 0x00, 0x00, 0x00, 0x13, 0xEA, 0x00, 
				 0x1E, 0x00, 0x00, 0xC0, 0x00, 0x00, 0x1E, 0x01, 
				 0xD1, 0x05, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 
				 0xEA, 0x00, 0x12, 0x07, 0x04, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 
				 0x00, 0x18, 0x07, 0x04, 0x13, 0xEA, 0x00, 0x1E, 
				 0x00, 0xC0, 0xFF, 0x00, 0x00, 0x1E, 0x01, 0x16, 
				 0x00, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 0xEA, 
				 0x00, 0x16, 0x02, 0x04, 0x00, 0x08, 0x16, 0xC0, 
				 0x00, 0x00, 0x00, 0x00, 0x4C};

BYTE t5464_Mode_1280x1024x8_5[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x13, 0xF0, 0x00, 0x1E, 0x00, 0xFF, 0xEF, 0x00, 
				 0x00, 0x19, 0xF0, 0x00, 0x16, 0x05, 0x04, 0x00, 
				 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 0x00, 
				 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 0x00, 
				 0x1F, 0x01, 0x00, 0x18, 0x07, 0x04, 0x15, 0xA0, 
				 0x00, 0xFF, 0x00, 0x09, 0xCE, 0x03, 0x06, 0x05, 
				 0x16, 0x80, 0x00, 0x2F, 0x00, 0x16, 0x84, 0x00, 
				 0x16, 0x00, 0x16, 0x88, 0x00, 0x79, 0x00, 0x1D, 
				 0x19, 0x00, 0x00, 0x00, 0xD3, 0x00, 0x00, 0x00, 
				 0x9F, 0x00, 0x00, 0x00, 0x9F, 0x00, 0x00, 0x00, 
				 0x91, 0x00, 0x00, 0x00, 0xA7, 0x00, 0x00, 0x00, 
				 0x1B, 0x00, 0x00, 0x00, 0x2E, 0x00, 0x00, 0x00, 
				 0x5A, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x83, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 
				 0xA0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0xFF, 0x00, 0x00, 0x00, 0x2A, 0x00, 0x00, 0x00, 
				 0xE3, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 
				 0x1D, 0x06, 0x00, 0x64, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x30, 0x00, 0x00, 0x00, 0x22, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x09, 0x00, 0x00, 0x00, 0x13, 0xEA, 0x00, 
				 0x1E, 0x00, 0x00, 0xC0, 0x00, 0x00, 0x1E, 0x01, 
				 0xD1, 0x05, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 
				 0xEA, 0x00, 0x12, 0x07, 0x04, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 
				 0x00, 0x18, 0x07, 0x04, 0x13, 0xEA, 0x00, 0x1E, 
				 0x00, 0xC0, 0xFF, 0x00, 0x00, 0x1E, 0x01, 0x16, 
				 0x00, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 0xEA, 
				 0x00, 0x16, 0x02, 0x04, 0x00, 0x08, 0x16, 0xC0, 
				 0x00, 0x00, 0x00, 0x00, 0x4C};

BYTE t5464_Mode_1280x1024x8_1a[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x13, 0xF0, 0x00, 0x1E, 0x00, 0xFF, 0xEF, 0x00, 
				 0x00, 0x19, 0xF0, 0x00, 0x16, 0x05, 0x04, 0x00, 
				 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 0x00, 
				 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 0x00, 
				 0x1F, 0x01, 0x00, 0x18, 0x07, 0x04, 0x15, 0xA0, 
				 0x00, 0xFF, 0x00, 0x09, 0xCE, 0x03, 0x06, 0x05, 
				 0x16, 0x80, 0x00, 0x2F, 0x00, 0x16, 0x84, 0x00, 
				 0x04, 0x00, 0x16, 0x88, 0x00, 0x0B, 0x00, 0x1D, 
				 0x19, 0x00, 0x00, 0x00, 0xCF, 0x00, 0x00, 0x00, 
				 0x9F, 0x00, 0x00, 0x00, 0x9F, 0x00, 0x00, 0x00, 
				 0x93, 0x00, 0x00, 0x00, 0xA9, 0x00, 0x00, 0x00, 
				 0x13, 0x00, 0x00, 0x00, 0x14, 0x00, 0x00, 0x00, 
				 0xB2, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x83, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 
				 0xA0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x14, 0x00, 0x00, 0x00, 
				 0xE3, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 
				 0x1D, 0x06, 0x00, 0x64, 0x00, 0x67, 0x00, 0x00, 
				 0x00, 0x81, 0x00, 0x00, 0x00, 0x22, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x13, 0xEA, 0x00, 
				 0x1E, 0x00, 0x00, 0xC0, 0x00, 0x00, 0x1E, 0x01, 
				 0xD6, 0x0A, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 
				 0xEA, 0x00, 0x12, 0x07, 0x04, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x0A, 0x00, 0x00, 
				 0x00, 0x18, 0x07, 0x04, 0x16, 0x02, 0x04, 0x00, 
				 0x08, 0x16, 0xC0, 0x00, 0x00, 0x00, 0x17, 0x4C, 
				 0x00, 0x40, 0x00, 0x00, 0x00, 0x17, 0x6C, 0x00, 
				 0x32, 0x00, 0x00, 0x00, 0x00, 0x08};

BYTE t5464_Mode_1280x1024x8_2a[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x13, 0xF0, 0x00, 0x1E, 0x00, 0xFF, 0xEF, 0x00, 
				 0x00, 0x19, 0xF0, 0x00, 0x16, 0x05, 0x04, 0x00, 
				 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 0x00, 
				 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 0x00, 
				 0x1F, 0x01, 0x00, 0x18, 0x07, 0x04, 0x15, 0xA0, 
				 0x00, 0xFF, 0x00, 0x09, 0xCE, 0x03, 0x06, 0x05, 
				 0x16, 0x80, 0x00, 0x2F, 0x00, 0x16, 0x84, 0x00, 
				 0x16, 0x00, 0x16, 0x88, 0x00, 0x53, 0x00, 0x1D, 
				 0x19, 0x00, 0x00, 0x00, 0xCE, 0x00, 0x00, 0x00, 
				 0x9F, 0x00, 0x00, 0x00, 0x9F, 0x00, 0x00, 0x00, 
				 0x91, 0x00, 0x00, 0x00, 0xA7, 0x00, 0x00, 0x00, 
				 0x15, 0x00, 0x00, 0x00, 0x28, 0x00, 0x00, 0x00, 
				 0x5A, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x83, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 
				 0xA0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0xFF, 0x00, 0x00, 0x00, 0x24, 0x00, 0x00, 0x00, 
				 0xE3, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 
				 0x1D, 0x06, 0x00, 0x64, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x30, 0x00, 0x00, 0x00, 0x22, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x09, 0x00, 0x00, 0x00, 0x13, 0xEA, 0x00, 
				 0x1E, 0x00, 0x00, 0xC0, 0x00, 0x00, 0x1E, 0x01, 
				 0xD6, 0x0A, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 
				 0xEA, 0x00, 0x12, 0x07, 0x04, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x0A, 0x00, 0x00, 
				 0x00, 0x18, 0x07, 0x04, 0x16, 0x02, 0x04, 0x00, 
				 0x08, 0x16, 0xC0, 0x00, 0x00, 0x00, 0x17, 0x4C, 
				 0x00, 0x40, 0x00, 0x00, 0x00, 0x17, 0x6C, 0x00, 
				 0x32, 0x00, 0x00, 0x00, 0x00, 0x08};

BYTE t5464_Mode_1280x1024x8_3a[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x13, 0xF0, 0x00, 0x1E, 0x00, 0xFF, 0xEF, 0x00, 
				 0x00, 0x19, 0xF0, 0x00, 0x16, 0x05, 0x04, 0x00, 
				 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 0x00, 
				 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 0x00, 
				 0x1F, 0x01, 0x00, 0x18, 0x07, 0x04, 0x15, 0xA0, 
				 0x00, 0xFF, 0x00, 0x09, 0xCE, 0x03, 0x06, 0x05, 
				 0x16, 0x80, 0x00, 0x2F, 0x00, 0x16, 0x84, 0x00, 
				 0x0C, 0x00, 0x16, 0x88, 0x00, 0x35, 0x00, 0x1D, 
				 0x19, 0x00, 0x00, 0x00, 0xCB, 0x00, 0x00, 0x00, 
				 0x9F, 0x00, 0x00, 0x00, 0x9F, 0x00, 0x00, 0x00, 
				 0x89, 0x00, 0x00, 0x00, 0xA6, 0x00, 0x00, 0x00, 
				 0x1C, 0x00, 0x00, 0x00, 0x2A, 0x00, 0x00, 0x00, 
				 0x5A, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00, 
				 0x8F, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 
				 0xA0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0xFF, 0x00, 0x00, 0x00, 0x24, 0x00, 0x00, 0x00, 
				 0xE3, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 
				 0x1D, 0x06, 0x00, 0x64, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x30, 0x00, 0x00, 0x00, 0x22, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x09, 0x00, 0x00, 0x00, 0x13, 0xEA, 0x00, 
				 0x1E, 0x00, 0x00, 0xC0, 0x00, 0x00, 0x1E, 0x01, 
				 0xD6, 0x0A, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 
				 0xEA, 0x00, 0x12, 0x07, 0x04, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x0A, 0x00, 0x00, 
				 0x00, 0x18, 0x07, 0x04, 0x16, 0x02, 0x04, 0x00, 
				 0x08, 0x16, 0xC0, 0x00, 0x00, 0x00, 0x17, 0x4C, 
				 0x00, 0x40, 0x00, 0x00, 0x00, 0x17, 0x6C, 0x00, 
				 0x32, 0x00, 0x00, 0x00, 0x00, 0x08};

BYTE t5464_Mode_1280x1024x8_4a[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x13, 0xF0, 0x00, 0x1E, 0x00, 0xFF, 0xEF, 0x00, 
				 0x00, 0x19, 0xF0, 0x00, 0x16, 0x05, 0x04, 0x00, 
				 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 0x00, 
				 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 0x00, 
				 0x1F, 0x01, 0x00, 0x18, 0x07, 0x04, 0x15, 0xA0, 
				 0x00, 0xFF, 0x00, 0x09, 0xCE, 0x03, 0x06, 0x05, 
				 0x16, 0x80, 0x00, 0x2F, 0x00, 0x16, 0x84, 0x00, 
				 0x0E, 0x00, 0x16, 0x88, 0x00, 0x42, 0x00, 0x1D, 
				 0x19, 0x00, 0x00, 0x00, 0xCE, 0x00, 0x00, 0x00, 
				 0x9F, 0x00, 0x00, 0x00, 0x9F, 0x00, 0x00, 0x00, 
				 0x91, 0x00, 0x00, 0x00, 0xA3, 0x00, 0x00, 0x00, 
				 0x15, 0x00, 0x00, 0x00, 0x28, 0x00, 0x00, 0x00, 
				 0x5A, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x83, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 
				 0xA0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0xFF, 0x00, 0x00, 0x00, 0x24, 0x00, 0x00, 0x00, 
				 0xE3, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 
				 0x1D, 0x06, 0x00, 0x64, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x30, 0x00, 0x00, 0x00, 0x22, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x09, 0x00, 0x00, 0x00, 0x13, 0xEA, 0x00, 
				 0x1E, 0x00, 0x00, 0xC0, 0x00, 0x00, 0x1E, 0x01, 
				 0xD6, 0x0A, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 
				 0xEA, 0x00, 0x12, 0x07, 0x04, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x0A, 0x00, 0x00, 
				 0x00, 0x18, 0x07, 0x04, 0x16, 0x02, 0x04, 0x00, 
				 0x08, 0x16, 0xC0, 0x00, 0x00, 0x00, 0x17, 0x4C, 
				 0x00, 0x40, 0x00, 0x00, 0x00, 0x17, 0x6C, 0x00, 
				 0x32, 0x00, 0x00, 0x00, 0x00, 0x08};

BYTE t5464_Mode_1280x1024x8_5a[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x13, 0xF0, 0x00, 0x1E, 0x00, 0xFF, 0xEF, 0x00, 
				 0x00, 0x19, 0xF0, 0x00, 0x16, 0x05, 0x04, 0x00, 
				 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 0x00, 
				 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 0x00, 
				 0x1F, 0x01, 0x00, 0x18, 0x07, 0x04, 0x15, 0xA0, 
				 0x00, 0xFF, 0x00, 0x09, 0xCE, 0x03, 0x06, 0x05, 
				 0x16, 0x80, 0x00, 0x2F, 0x00, 0x16, 0x84, 0x00, 
				 0x16, 0x00, 0x16, 0x88, 0x00, 0x79, 0x00, 0x1D, 
				 0x19, 0x00, 0x00, 0x00, 0xD3, 0x00, 0x00, 0x00, 
				 0x9F, 0x00, 0x00, 0x00, 0x9F, 0x00, 0x00, 0x00, 
				 0x91, 0x00, 0x00, 0x00, 0xA7, 0x00, 0x00, 0x00, 
				 0x1B, 0x00, 0x00, 0x00, 0x2E, 0x00, 0x00, 0x00, 
				 0x5A, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x83, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 
				 0xA0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0xFF, 0x00, 0x00, 0x00, 0x2A, 0x00, 0x00, 0x00, 
				 0xE3, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 
				 0x1D, 0x06, 0x00, 0x64, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x30, 0x00, 0x00, 0x00, 0x22, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x09, 0x00, 0x00, 0x00, 0x13, 0xEA, 0x00, 
				 0x1E, 0x00, 0x00, 0xC0, 0x00, 0x00, 0x1E, 0x01, 
				 0xD6, 0x0A, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 
				 0xEA, 0x00, 0x12, 0x07, 0x04, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x0A, 0x00, 0x00, 
				 0x00, 0x18, 0x07, 0x04, 0x16, 0x02, 0x04, 0x00, 
				 0x08, 0x16, 0xC0, 0x00, 0x00, 0x00, 0x17, 0x4C, 
				 0x00, 0x40, 0x00, 0x00, 0x00, 0x17, 0x6C, 0x00, 
				 0x32, 0x00, 0x00, 0x00, 0x00, 0x08};

BYTE t5464_Mode_1600x1200x8_1[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x13, 0xF0, 0x00, 0x1E, 0x00, 0xFF, 0xEF, 0x00, 
				 0x00, 0x19, 0xF0, 0x00, 0x16, 0x05, 0x04, 0x00, 
				 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 0x00, 
				 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 0x00, 
				 0x1F, 0x01, 0x00, 0x18, 0x07, 0x04, 0x15, 0xA0, 
				 0x00, 0xFF, 0x00, 0x09, 0xCE, 0x03, 0x06, 0x05, 
				 0x16, 0x80, 0x00, 0x2F, 0x00, 0x16, 0x84, 0x00, 
				 0x0F, 0x00, 0x16, 0x88, 0x00, 0x42, 0x00, 0x1D, 
				 0x19, 0x00, 0x00, 0x00, 0x09, 0x00, 0x00, 0x00, 
				 0xC7, 0x00, 0x00, 0x00, 0xC7, 0x00, 0x00, 0x00, 
				 0x8C, 0x00, 0x00, 0x00, 0xCE, 0x00, 0x00, 0x00, 
				 0x06, 0x00, 0x00, 0x00, 0x88, 0x00, 0x00, 0x00, 
				 0xE0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x58, 0x00, 0x00, 0x00, 
				 0x8B, 0x00, 0x00, 0x00, 0x57, 0x00, 0x00, 0x00, 
				 0xD0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x58, 0x00, 0x00, 0x00, 0x85, 0x00, 0x00, 0x00, 
				 0xE3, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 
				 0x1D, 0x06, 0x00, 0x64, 0x00, 0x84, 0x00, 0x00, 
				 0x00, 0x81, 0x00, 0x00, 0x00, 0x22, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x80, 0x00, 0x00, 0x00, 0x13, 0xEA, 0x00, 
				 0x1E, 0x00, 0x00, 0xC0, 0x00, 0x00, 0x1E, 0x01, 
				 0x92, 0x0D, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 
				 0xEA, 0x00, 0x12, 0x07, 0x04, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x0D, 0x00, 0x00, 
				 0x00, 0x18, 0x07, 0x04, 0x13, 0xEA, 0x00, 0x1E, 
				 0x00, 0xC0, 0xFF, 0x00, 0x00, 0x1E, 0x01, 0x1A, 
				 0x00, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 0xEA, 
				 0x00, 0x16, 0x02, 0x04, 0x00, 0x00, 0x16, 0xC0, 
				 0x00, 0x00, 0x00, 0x13, 0xC0, 0x00, 0x1E, 0x01, 
				 0x00, 0x40, 0x00, 0x00, 0x19, 0xC0, 0x00, 0x00, 0x00};

BYTE t5464_Mode_1600x1200x8_2[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x13, 0xF0, 0x00, 0x1E, 0x00, 0xFF, 0xEF, 0x00, 
				 0x00, 0x19, 0xF0, 0x00, 0x16, 0x05, 0x04, 0x00, 
				 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 0x00, 
				 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 0x00, 
				 0x1F, 0x01, 0x00, 0x18, 0x07, 0x04, 0x15, 0xA0, 
				 0x00, 0xFF, 0x00, 0x09, 0xCE, 0x03, 0x06, 0x05, 
				 0x16, 0x80, 0x00, 0x2F, 0x00, 0x16, 0x84, 0x00, 
				 0x14, 0x00, 0x16, 0x88, 0x00, 0x71, 0x00, 0x1D, 
				 0x19, 0x00, 0x00, 0x00, 0x09, 0x00, 0x00, 0x00, 
				 0xC7, 0x00, 0x00, 0x00, 0xC7, 0x00, 0x00, 0x00, 
				 0x89, 0x00, 0x00, 0x00, 0xD1, 0x00, 0x00, 0x00, 
				 0x09, 0x00, 0x00, 0x00, 0xDF, 0x00, 0x00, 0x00, 
				 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0xB0, 0x00, 0x00, 0x00, 
				 0x83, 0x00, 0x00, 0x00, 0xAF, 0x00, 0x00, 0x00, 
				 0xD0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0xAF, 0x00, 0x00, 0x00, 0xDF, 0x00, 0x00, 0x00, 
				 0xE3, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 
				 0x1D, 0x06, 0x00, 0x64, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x22, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x8F, 0x00, 0x00, 0x00, 0x13, 0xEA, 0x00, 
				 0x1E, 0x00, 0x00, 0xC0, 0x00, 0x00, 0x1E, 0x01, 
				 0x92, 0x0D, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 
				 0xEA, 0x00, 0x12, 0x07, 0x04, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x0D, 0x00, 0x00, 
				 0x00, 0x18, 0x07, 0x04, 0x13, 0xEA, 0x00, 0x1E, 
				 0x00, 0xC0, 0xFF, 0x00, 0x00, 0x1E, 0x01, 0x1A, 
				 0x00, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 0xEA, 
				 0x00, 0x16, 0x02, 0x04, 0x00, 0x00, 0x16, 0xC0, 
				 0x00, 0x00, 0x00, 0x00, 0xC0};

BYTE t5464_Mode_1600x1200x8_1a[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x13, 0xF0, 0x00, 0x1E, 0x00, 0xFF, 0xEF, 0x00, 
				 0x00, 0x19, 0xF0, 0x00, 0x16, 0x05, 0x04, 0x00, 
				 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 0x00, 
				 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 0x00, 
				 0x1F, 0x01, 0x00, 0x18, 0x07, 0x04, 0x15, 0xA0, 
				 0x00, 0xFF, 0x00, 0x09, 0xCE, 0x03, 0x06, 0x05, 
				 0x16, 0x80, 0x00, 0x2F, 0x00, 0x16, 0x84, 0x00, 
				 0x0F, 0x00, 0x16, 0x88, 0x00, 0x42, 0x00, 0x1D, 
				 0x19, 0x00, 0x00, 0x00, 0x09, 0x00, 0x00, 0x00, 
				 0xC7, 0x00, 0x00, 0x00, 0xC7, 0x00, 0x00, 0x00, 
				 0x8C, 0x00, 0x00, 0x00, 0xCE, 0x00, 0x00, 0x00, 
				 0x06, 0x00, 0x00, 0x00, 0x88, 0x00, 0x00, 0x00, 
				 0xE0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x58, 0x00, 0x00, 0x00, 
				 0x8B, 0x00, 0x00, 0x00, 0x57, 0x00, 0x00, 0x00, 
				 0xD0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x58, 0x00, 0x00, 0x00, 0x85, 0x00, 0x00, 0x00, 
				 0xE3, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 
				 0x1D, 0x06, 0x00, 0x64, 0x00, 0x84, 0x00, 0x00, 
				 0x00, 0x81, 0x00, 0x00, 0x00, 0x22, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x80, 0x00, 0x00, 0x00, 0x13, 0xEA, 0x00, 
				 0x1E, 0x00, 0x00, 0xC0, 0x00, 0x00, 0x1E, 0x01, 
				 0x9A, 0x1A, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 
				 0xEA, 0x00, 0x12, 0x07, 0x04, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x1A, 0x00, 0x00, 
				 0x00, 0x18, 0x07, 0x04, 0x16, 0x02, 0x04, 0x00, 
				 0x00, 0x16, 0xC0, 0x00, 0x00, 0x00, 0x17, 0x4C, 
				 0x00, 0xA0, 0x00, 0x00, 0x00, 0x17, 0x6C, 0x00, 
				 0x32, 0x00, 0x00, 0x00, 0x13, 0xC0, 0x00, 0x1E, 
				 0x01, 0x00, 0x40, 0x00, 0x00, 0x19, 0xC0, 0x00, 
				 0x00, 0x40};

BYTE t5464_Mode_1600x1200x8_2a[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x13, 0xF0, 0x00, 0x1E, 0x00, 0xFF, 0xEF, 0x00, 
				 0x00, 0x19, 0xF0, 0x00, 0x16, 0x05, 0x04, 0x00, 
				 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 0x00, 
				 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 0x00, 
				 0x1F, 0x01, 0x00, 0x18, 0x07, 0x04, 0x15, 0xA0, 
				 0x00, 0xFF, 0x00, 0x09, 0xCE, 0x03, 0x06, 0x05, 
				 0x16, 0x80, 0x00, 0x2F, 0x00, 0x16, 0x84, 0x00, 
				 0x14, 0x00, 0x16, 0x88, 0x00, 0x71, 0x00, 0x1D, 
				 0x19, 0x00, 0x00, 0x00, 0x09, 0x00, 0x00, 0x00, 
				 0xC7, 0x00, 0x00, 0x00, 0xC7, 0x00, 0x00, 0x00, 
				 0x89, 0x00, 0x00, 0x00, 0xD1, 0x00, 0x00, 0x00, 
				 0x09, 0x00, 0x00, 0x00, 0xDF, 0x00, 0x00, 0x00, 
				 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0xB0, 0x00, 0x00, 0x00, 
				 0x83, 0x00, 0x00, 0x00, 0xAF, 0x00, 0x00, 0x00, 
				 0xD0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0xAF, 0x00, 0x00, 0x00, 0xDF, 0x00, 0x00, 0x00, 
				 0xE3, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 
				 0x1D, 0x06, 0x00, 0x64, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x22, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x8F, 0x00, 0x00, 0x00, 0x13, 0xEA, 0x00, 
				 0x1E, 0x00, 0x00, 0xC0, 0x00, 0x00, 0x1E, 0x01, 
				 0x9A, 0x1A, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 
				 0xEA, 0x00, 0x12, 0x07, 0x04, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x1A, 0x00, 0x00, 
				 0x00, 0x18, 0x07, 0x04, 0x16, 0x02, 0x04, 0x00, 
				 0x00, 0x16, 0xC0, 0x00, 0x00, 0x00, 0x17, 0x4C, 
				 0x00, 0xA0, 0x00, 0x00, 0x00, 0x17, 0x6C, 0x00, 
				 0x32, 0x00, 0x00, 0x00, 0x00, 0xC0};

BYTE t5464_Mode_320x200x16_1[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x13, 0xF0, 0x00, 0x1E, 0x00, 0xFF, 0xEF, 0x00, 
				 0x00, 0x19, 0xF0, 0x00, 0x16, 0x05, 0x04, 0x00, 
				 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 0x00, 
				 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 0x00, 
				 0x1F, 0x01, 0x00, 0x18, 0x07, 0x04, 0x15, 0xA0, 
				 0x00, 0xFF, 0x00, 0x09, 0xCE, 0x03, 0x06, 0x05, 
				 0x16, 0x80, 0x00, 0x2F, 0x00, 0x16, 0x84, 0x00, 
				 0x42, 0x00, 0x16, 0x88, 0x00, 0x1D, 0x00, 0x1D, 
				 0x19, 0x00, 0x00, 0x00, 0x2D, 0x00, 0x00, 0x00, 
				 0x27, 0x00, 0x00, 0x00, 0x28, 0x00, 0x00, 0x00, 
				 0x8D, 0x00, 0x00, 0x00, 0x2A, 0x00, 0x00, 0x00, 
				 0x8B, 0x00, 0x00, 0x00, 0xA0, 0x00, 0x00, 0x00, 
				 0x1F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0xC0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x91, 0x00, 0x00, 0x00, 
				 0x84, 0x00, 0x00, 0x00, 0x8F, 0x00, 0x00, 0x00, 
				 0x50, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x90, 0x00, 0x00, 0x00, 0xA0, 0x00, 0x00, 0x00, 
				 0xE3, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 
				 0x1D, 0x06, 0x00, 0x64, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x40, 0x00, 0x00, 0x00, 0x22, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x13, 0xEA, 0x00, 
				 0x1E, 0x00, 0x00, 0xC0, 0x00, 0x00, 0x1E, 0x01, 
				 0x91, 0x0A, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 
				 0xEA, 0x00, 0x12, 0x07, 0x04, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x0A, 0x00, 0x00, 
				 0x00, 0x18, 0x07, 0x04, 0x16, 0x02, 0x04, 0x00, 
				 0x20, 0x16, 0xC0, 0x00, 0x00, 0x16, 0x17, 0x4C, 
				 0x00, 0xA0, 0x00, 0x00, 0x00, 0x16, 0xC0, 0x00, 
				 0x00, 0x14, 0x00, 0x00};

BYTE t5464_Mode_320x240x16_1[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x13, 0xF0, 0x00, 0x1E, 0x00, 0xFF, 0xEF, 0x00, 
				 0x00, 0x19, 0xF0, 0x00, 0x16, 0x05, 0x04, 0x00, 
				 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 0x00, 
				 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 0x00, 
				 0x1F, 0x01, 0x00, 0x18, 0x07, 0x04, 0x15, 0xA0, 
				 0x00, 0xFF, 0x00, 0x09, 0xCE, 0x03, 0x06, 0x05, 
				 0x16, 0x80, 0x00, 0xEF, 0x00, 0x16, 0x84, 0x00, 
				 0x42, 0x00, 0x16, 0x88, 0x00, 0x1D, 0x00, 0x1D, 
				 0x19, 0x00, 0x00, 0x00, 0x2D, 0x00, 0x00, 0x00, 
				 0x27, 0x00, 0x00, 0x00, 0x27, 0x00, 0x00, 0x00, 
				 0x8C, 0x00, 0x00, 0x00, 0x2A, 0x00, 0x00, 0x00, 
				 0x8C, 0x00, 0x00, 0x00, 0x0B, 0x00, 0x00, 0x00, 
				 0x3E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0xC0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0xE1, 0x00, 0x00, 0x00, 
				 0x83, 0x00, 0x00, 0x00, 0xDF, 0x00, 0x00, 0x00, 
				 0x50, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0xDF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0xE3, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 
				 0x1D, 0x06, 0x00, 0x64, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x80, 0x00, 0x00, 0x00, 0x22, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x13, 0xEA, 0x00, 
				 0x1E, 0x00, 0x00, 0xC0, 0x00, 0x00, 0x1E, 0x01, 
				 0x91, 0x08, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 
				 0xEA, 0x00, 0x12, 0x07, 0x04, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x08, 0x00, 0x00, 
				 0x00, 0x18, 0x07, 0x04, 0x16, 0x02, 0x04, 0x00, 
				 0x20, 0x16, 0xC0, 0x00, 0x00, 0x16, 0x17, 0x4C, 
				 0x00, 0x80, 0x00, 0x00, 0x00, 0x16, 0xC0, 0x00, 
				 0x00, 0x14, 0x00, 0x00};

BYTE t5464_Mode_320x240x16_2[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x13, 0xF0, 0x00, 0x1E, 0x00, 0xFF, 0xEF, 0x00, 
				 0x00, 0x19, 0xF0, 0x00, 0x16, 0x05, 0x04, 0x00, 
				 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 0x00, 
				 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 0x00, 
				 0x1F, 0x01, 0x00, 0x18, 0x07, 0x04, 0x15, 0xA0, 
				 0x00, 0xFF, 0x00, 0x09, 0xCE, 0x03, 0x06, 0x05, 
				 0x16, 0x80, 0x00, 0xEF, 0x00, 0x16, 0x84, 0x00, 
				 0x14, 0x00, 0x16, 0x88, 0x00, 0x0B, 0x00, 0x1D, 
				 0x19, 0x00, 0x00, 0x00, 0x2F, 0x00, 0x00, 0x00, 
				 0x27, 0x00, 0x00, 0x00, 0x27, 0x00, 0x00, 0x00, 
				 0x8C, 0x00, 0x00, 0x00, 0x2A, 0x00, 0x00, 0x00, 
				 0x8C, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 
				 0x3E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0xC0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0xE0, 0x00, 0x00, 0x00, 
				 0x83, 0x00, 0x00, 0x00, 0xDF, 0x00, 0x00, 0x00, 
				 0x50, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0xDF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0xE3, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 
				 0x1D, 0x06, 0x00, 0x64, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x80, 0x00, 0x00, 0x00, 0x22, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x13, 0xEA, 0x00, 
				 0x1E, 0x00, 0x00, 0xC0, 0x00, 0x00, 0x1E, 0x01, 
				 0x91, 0x08, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 
				 0xEA, 0x00, 0x12, 0x07, 0x04, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x08, 0x00, 0x00, 
				 0x00, 0x18, 0x07, 0x04, 0x13, 0xEA, 0x00, 0x1E, 
				 0x00, 0xC0, 0xFF, 0x00, 0x00, 0x1E, 0x01, 0x14, 
				 0x00, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 0xEA, 
				 0x00, 0x16, 0x02, 0x04, 0x00, 0x20, 0x16, 0xC0, 
				 0x00, 0x00, 0x16, 0x17, 0x4C, 0x00, 0x80, 0x00, 
				 0x00, 0x00, 0x16, 0xC0, 0x00, 0x00, 0x14, 0x00, 0x00};

BYTE t5464_Mode_320x400x16_1[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x13, 0xF0, 0x00, 0x1E, 0x00, 0xFF, 0xEF, 0x00, 
				 0x00, 0x19, 0xF0, 0x00, 0x16, 0x05, 0x04, 0x00, 
				 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 0x00, 
				 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 0x00, 
				 0x1F, 0x01, 0x00, 0x18, 0x07, 0x04, 0x15, 0xA0, 
				 0x00, 0xFF, 0x00, 0x09, 0xCE, 0x03, 0x06, 0x05, 
				 0x16, 0x80, 0x00, 0x2F, 0x00, 0x16, 0x84, 0x00, 
				 0x42, 0x00, 0x16, 0x88, 0x00, 0x1D, 0x00, 0x1D, 
				 0x19, 0x00, 0x00, 0x00, 0x2D, 0x00, 0x00, 0x00, 
				 0x27, 0x00, 0x00, 0x00, 0x28, 0x00, 0x00, 0x00, 
				 0x8D, 0x00, 0x00, 0x00, 0x2A, 0x00, 0x00, 0x00, 
				 0x8B, 0x00, 0x00, 0x00, 0xA0, 0x00, 0x00, 0x00, 
				 0x1F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x91, 0x00, 0x00, 0x00, 
				 0x84, 0x00, 0x00, 0x00, 0x8F, 0x00, 0x00, 0x00, 
				 0x50, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x90, 0x00, 0x00, 0x00, 0xA0, 0x00, 0x00, 0x00, 
				 0xE3, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 
				 0x1D, 0x06, 0x00, 0x64, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x40, 0x00, 0x00, 0x00, 0x22, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x13, 0xEA, 0x00, 
				 0x1E, 0x00, 0x00, 0xC0, 0x00, 0x00, 0x1E, 0x01, 
				 0x91, 0x0A, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 
				 0xEA, 0x00, 0x12, 0x07, 0x04, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x0A, 0x00, 0x00, 
				 0x00, 0x18, 0x07, 0x04, 0x13, 0xEA, 0x00, 0x1E, 
				 0x00, 0xC0, 0xFF, 0x00, 0x00, 0x1E, 0x01, 0x19, 
				 0x00, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 0xEA, 
				 0x00, 0x16, 0x02, 0x04, 0x00, 0x20, 0x16, 0xC0, 
				 0x00, 0x00, 0x16, 0x17, 0x4C, 0x00, 0xA0, 0x00, 
				 0x00, 0x00, 0x16, 0xC0, 0x00, 0x00, 0x14, 0x00, 0x00};

BYTE t5464_Mode_320x480x16_1[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x13, 0xF0, 0x00, 0x1E, 0x00, 0xFF, 0xEF, 0x00, 
				 0x00, 0x19, 0xF0, 0x00, 0x16, 0x05, 0x04, 0x00, 
				 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 0x00, 
				 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 0x00, 
				 0x1F, 0x01, 0x00, 0x18, 0x07, 0x04, 0x15, 0xA0, 
				 0x00, 0xFF, 0x00, 0x09, 0xCE, 0x03, 0x06, 0x05, 
				 0x16, 0x80, 0x00, 0xEF, 0x00, 0x16, 0x84, 0x00, 
				 0x42, 0x00, 0x16, 0x88, 0x00, 0x1D, 0x00, 0x1D, 
				 0x19, 0x00, 0x00, 0x00, 0x2D, 0x00, 0x00, 0x00, 
				 0x27, 0x00, 0x00, 0x00, 0x27, 0x00, 0x00, 0x00, 
				 0x8C, 0x00, 0x00, 0x00, 0x2A, 0x00, 0x00, 0x00, 
				 0x8C, 0x00, 0x00, 0x00, 0x0B, 0x00, 0x00, 0x00, 
				 0x3E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0xC0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0xE1, 0x00, 0x00, 0x00, 
				 0x83, 0x00, 0x00, 0x00, 0xDF, 0x00, 0x00, 0x00, 
				 0x50, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0xDF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0xE3, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 
				 0x1D, 0x06, 0x00, 0x64, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x80, 0x00, 0x00, 0x00, 0x22, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x17, 0x24, 0x00, 
				 0x40, 0x00, 0x00, 0x00, 0x13, 0xEA, 0x00, 0x1E, 
				 0x00, 0x00, 0xC0, 0x00, 0x00, 0x1E, 0x01, 0x91, 
				 0x0A, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 0xEA, 
				 0x00, 0x12, 0x07, 0x04, 0x1E, 0x00, 0xC0, 0x00, 
				 0x00, 0x00, 0x1E, 0x01, 0x0A, 0x00, 0x00, 0x00, 
				 0x18, 0x07, 0x04, 0x16, 0x02, 0x04, 0x00, 0x20, 
				 0x16, 0xC0, 0x00, 0x00, 0x16, 0x17, 0x4C, 0x00, 
				 0xA0, 0x00, 0x00, 0x00, 0x16, 0xC0, 0x00, 0x00, 
				 0x14, 0x00, 0x16};

BYTE t5464_Mode_320x480x16_2[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x13, 0xF0, 0x00, 0x1E, 0x00, 0xFF, 0xEF, 0x00, 
				 0x00, 0x19, 0xF0, 0x00, 0x16, 0x05, 0x04, 0x00, 
				 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 0x00, 
				 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 0x00, 
				 0x1F, 0x01, 0x00, 0x18, 0x07, 0x04, 0x15, 0xA0, 
				 0x00, 0xFF, 0x00, 0x09, 0xCE, 0x03, 0x06, 0x05, 
				 0x16, 0x80, 0x00, 0xEF, 0x00, 0x16, 0x84, 0x00, 
				 0x14, 0x00, 0x16, 0x88, 0x00, 0x0B, 0x00, 0x1D, 
				 0x19, 0x00, 0x00, 0x00, 0x2F, 0x00, 0x00, 0x00, 
				 0x27, 0x00, 0x00, 0x00, 0x27, 0x00, 0x00, 0x00, 
				 0x8C, 0x00, 0x00, 0x00, 0x2A, 0x00, 0x00, 0x00, 
				 0x8C, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 
				 0x3E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0xC0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0xE0, 0x00, 0x00, 0x00, 
				 0x83, 0x00, 0x00, 0x00, 0xDF, 0x00, 0x00, 0x00, 
				 0x50, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0xDF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0xE3, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 
				 0x1D, 0x06, 0x00, 0x64, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x80, 0x00, 0x00, 0x00, 0x22, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x17, 0x24, 0x00, 
				 0x40, 0x00, 0x00, 0x00, 0x13, 0xEA, 0x00, 0x1E, 
				 0x00, 0x00, 0xC0, 0x00, 0x00, 0x1E, 0x01, 0x91, 
				 0x0A, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 0xEA, 
				 0x00, 0x12, 0x07, 0x04, 0x1E, 0x00, 0xC0, 0x00, 
				 0x00, 0x00, 0x1E, 0x01, 0x0A, 0x00, 0x00, 0x00, 
				 0x18, 0x07, 0x04, 0x16, 0x02, 0x04, 0x00, 0x20, 
				 0x16, 0xC0, 0x00, 0x00, 0x16, 0x17, 0x4C, 0x00, 
				 0xA0, 0x00, 0x00, 0x00, 0x16, 0xC0, 0x00, 0x00, 
				 0x14, 0x00, 0x16};

BYTE t5464_Mode_360x400x16_1[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x13, 0xF0, 0x00, 0x1E, 0x00, 0xFF, 0xEF, 0x00, 
				 0x00, 0x19, 0xF0, 0x00, 0x16, 0x05, 0x04, 0x00, 
				 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 0x00, 
				 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 0x00, 
				 0x1F, 0x01, 0x00, 0x18, 0x07, 0x04, 0x15, 0xA0, 
				 0x00, 0xFF, 0x00, 0x09, 0xCE, 0x03, 0x06, 0x05, 
				 0x16, 0x80, 0x00, 0x2F, 0x00, 0x16, 0x84, 0x00, 
				 0x3C, 0x00, 0x16, 0x88, 0x00, 0x1E, 0x00, 0x1D, 
				 0x19, 0x00, 0x00, 0x00, 0x34, 0x00, 0x00, 0x00, 
				 0x2C, 0x00, 0x00, 0x00, 0x2D, 0x00, 0x00, 0x00, 
				 0x94, 0x00, 0x00, 0x00, 0x2E, 0x00, 0x00, 0x00, 
				 0x92, 0x00, 0x00, 0x00, 0xA0, 0x00, 0x00, 0x00, 
				 0x1F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x91, 0x00, 0x00, 0x00, 
				 0x84, 0x00, 0x00, 0x00, 0x8F, 0x00, 0x00, 0x00, 
				 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x90, 0x00, 0x00, 0x00, 0xA0, 0x00, 0x00, 0x00, 
				 0xE3, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 
				 0x1D, 0x06, 0x00, 0x64, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x40, 0x00, 0x00, 0x00, 0x22, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x13, 0xEA, 0x00, 
				 0x1E, 0x00, 0x00, 0xC0, 0x00, 0x00, 0x1E, 0x01, 
				 0x91, 0x08, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 
				 0xEA, 0x00, 0x12, 0x07, 0x04, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x08, 0x00, 0x00, 
				 0x00, 0x18, 0x07, 0x04, 0x16, 0x02, 0x04, 0x00, 
				 0x20, 0x16, 0xC0, 0x00, 0x00, 0x16, 0x17, 0x4C, 
				 0x00, 0x80, 0x00, 0x00, 0x00, 0x16, 0xC0, 0x00, 
				 0x00, 0x14, 0x00, 0x00};

BYTE t5464_Mode_360x400x16_2[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x13, 0xF0, 0x00, 0x1E, 0x00, 0xFF, 0xEF, 0x00, 
				 0x00, 0x19, 0xF0, 0x00, 0x16, 0x05, 0x04, 0x00, 
				 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 0x00, 
				 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 0x00, 
				 0x1F, 0x01, 0x00, 0x18, 0x07, 0x04, 0x15, 0xA0, 
				 0x00, 0xFF, 0x00, 0x09, 0xCE, 0x03, 0x06, 0x05, 
				 0x16, 0x80, 0x00, 0x6F, 0x00, 0x16, 0x84, 0x00, 
				 0x32, 0x00, 0x16, 0x88, 0x00, 0x1F, 0x00, 0x1D, 
				 0x19, 0x00, 0x00, 0x00, 0x35, 0x00, 0x00, 0x00, 
				 0x2C, 0x00, 0x00, 0x00, 0x2C, 0x00, 0x00, 0x00, 
				 0x93, 0x00, 0x00, 0x00, 0x2F, 0x00, 0x00, 0x00, 
				 0x90, 0x00, 0x00, 0x00, 0xBC, 0x00, 0x00, 0x00, 
				 0x1F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x90, 0x00, 0x00, 0x00, 
				 0x83, 0x00, 0x00, 0x00, 0x8F, 0x00, 0x00, 0x00, 
				 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x8F, 0x00, 0x00, 0x00, 0xBC, 0x00, 0x00, 0x00, 
				 0xE3, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 
				 0x1D, 0x06, 0x00, 0x64, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x40, 0x00, 0x00, 0x00, 0x22, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x13, 0xEA, 0x00, 
				 0x1E, 0x00, 0x00, 0xC0, 0x00, 0x00, 0x1E, 0x01, 
				 0x91, 0x08, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 
				 0xEA, 0x00, 0x12, 0x07, 0x04, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x08, 0x00, 0x00, 
				 0x00, 0x18, 0x07, 0x04, 0x16, 0x02, 0x04, 0x00, 
				 0x20, 0x16, 0xC0, 0x00, 0x00, 0x16, 0x17, 0x4C, 
				 0x00, 0x80, 0x00, 0x00, 0x00, 0x16, 0xC0, 0x00, 
				 0x00, 0x14, 0x00, 0x00};

BYTE t5464_Mode_400x300x16_1[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x13, 0xF0, 0x00, 0x1E, 0x00, 0xFF, 0xEF, 0x00, 
				 0x00, 0x19, 0xF0, 0x00, 0x16, 0x05, 0x04, 0x00, 
				 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 0x00, 
				 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 0x00, 
				 0x1F, 0x01, 0x00, 0x18, 0x07, 0x04, 0x15, 0xA0, 
				 0x00, 0xFF, 0x00, 0x09, 0xCE, 0x03, 0x06, 0x05, 
				 0x16, 0x80, 0x00, 0x2F, 0x00, 0x16, 0x84, 0x00, 
				 0x45, 0x00, 0x16, 0x88, 0x00, 0x5F, 0x00, 0x1D, 
				 0x19, 0x00, 0x00, 0x00, 0x3D, 0x00, 0x00, 0x00, 
				 0x31, 0x00, 0x00, 0x00, 0x31, 0x00, 0x00, 0x00, 
				 0x99, 0x00, 0x00, 0x00, 0x35, 0x00, 0x00, 0x00, 
				 0x96, 0x00, 0x00, 0x00, 0x72, 0x00, 0x00, 0x00, 
				 0xF0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0xE0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x58, 0x00, 0x00, 0x00, 
				 0x8C, 0x00, 0x00, 0x00, 0x57, 0x00, 0x00, 0x00, 
				 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x57, 0x00, 0x00, 0x00, 0x72, 0x00, 0x00, 0x00, 
				 0xE3, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 
				 0x1D, 0x06, 0x00, 0x64, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x80, 0x00, 0x00, 0x00, 0x22, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x13, 0xEA, 0x00, 
				 0x1E, 0x00, 0x00, 0xC0, 0x00, 0x00, 0x1E, 0x01, 
				 0x91, 0x08, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 
				 0xEA, 0x00, 0x12, 0x07, 0x04, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x08, 0x00, 0x00, 
				 0x00, 0x18, 0x07, 0x04, 0x16, 0x02, 0x04, 0x00, 
				 0x20, 0x16, 0xC0, 0x00, 0x00, 0x16, 0x17, 0x4C, 
				 0x00, 0x80, 0x00, 0x00, 0x00, 0x16, 0xC0, 0x00, 
				 0x00, 0x14, 0x00, 0x00};

BYTE t5464_Mode_400x300x16_2[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x13, 0xF0, 0x00, 0x1E, 0x00, 0xFF, 0xEF, 0x00, 
				 0x00, 0x19, 0xF0, 0x00, 0x16, 0x05, 0x04, 0x00, 
				 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 0x00, 
				 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 0x00, 
				 0x1F, 0x01, 0x00, 0x18, 0x07, 0x04, 0x15, 0xA0, 
				 0x00, 0xFF, 0x00, 0x09, 0xCE, 0x03, 0x06, 0x05, 
				 0x16, 0x80, 0x00, 0x2F, 0x00, 0x16, 0x84, 0x00, 
				 0x16, 0x00, 0x16, 0x88, 0x00, 0x13, 0x00, 0x1D, 
				 0x19, 0x00, 0x00, 0x00, 0x3D, 0x00, 0x00, 0x00, 
				 0x31, 0x00, 0x00, 0x00, 0x31, 0x00, 0x00, 0x00, 
				 0x99, 0x00, 0x00, 0x00, 0x34, 0x00, 0x00, 0x00, 
				 0x96, 0x00, 0x00, 0x00, 0x6F, 0x00, 0x00, 0x00, 
				 0xF0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0xE0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x58, 0x00, 0x00, 0x00, 
				 0x8B, 0x00, 0x00, 0x00, 0x57, 0x00, 0x00, 0x00, 
				 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x57, 0x00, 0x00, 0x00, 0x6F, 0x00, 0x00, 0x00, 
				 0xE3, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 
				 0x1D, 0x06, 0x00, 0x64, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x80, 0x00, 0x00, 0x00, 0x22, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x13, 0xEA, 0x00, 
				 0x1E, 0x00, 0x00, 0xC0, 0x00, 0x00, 0x1E, 0x01, 
				 0x91, 0x08, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 
				 0xEA, 0x00, 0x12, 0x07, 0x04, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x08, 0x00, 0x00, 
				 0x00, 0x18, 0x07, 0x04, 0x13, 0xEA, 0x00, 0x1E, 
				 0x00, 0xC0, 0xFF, 0x00, 0x00, 0x1E, 0x01, 0x12, 
				 0x00, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 0xEA, 
				 0x00, 0x16, 0x02, 0x04, 0x00, 0x20, 0x16, 0xC0, 
				 0x00, 0x00, 0x16, 0x17, 0x4C, 0x00, 0x80, 0x00, 
				 0x00, 0x00, 0x16, 0xC0, 0x00, 0x00, 0x14, 0x00, 0x00};

BYTE t5464_Mode_512x384x16_1[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x13, 0xF0, 0x00, 0x1E, 0x00, 0xFF, 0xEF, 0x00, 
				 0x00, 0x19, 0xF0, 0x00, 0x16, 0x05, 0x04, 0x00, 
				 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 0x00, 
				 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 0x00, 
				 0x1F, 0x01, 0x00, 0x18, 0x07, 0x04, 0x15, 0xA0, 
				 0x00, 0xFF, 0x00, 0x09, 0xCE, 0x03, 0x06, 0x05, 
				 0x16, 0x80, 0x00, 0xEF, 0x00, 0x16, 0x84, 0x00, 
				 0x1B, 0x00, 0x16, 0x88, 0x00, 0x3B, 0x00, 0x1D, 
				 0x19, 0x00, 0x00, 0x00, 0x4F, 0x00, 0x00, 0x00, 
				 0x3F, 0x00, 0x00, 0x00, 0x3F, 0x00, 0x00, 0x00, 
				 0x89, 0x00, 0x00, 0x00, 0x42, 0x00, 0x00, 0x00, 
				 0x06, 0x00, 0x00, 0x00, 0x24, 0x00, 0x00, 0x00, 
				 0xF5, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0xE0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 
				 0x88, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 
				 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0xFF, 0x00, 0x00, 0x00, 0x24, 0x00, 0x00, 0x00, 
				 0xE3, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 
				 0x1D, 0x06, 0x00, 0x64, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0xD0, 0x00, 0x00, 0x00, 0x22, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x13, 0xEA, 0x00, 
				 0x1E, 0x00, 0x00, 0xC0, 0x00, 0x00, 0x1E, 0x01, 
				 0x91, 0x08, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 
				 0xEA, 0x00, 0x12, 0x07, 0x04, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x08, 0x00, 0x00, 
				 0x00, 0x18, 0x07, 0x04, 0x13, 0xEA, 0x00, 0x1E, 
				 0x00, 0xC0, 0xFF, 0x00, 0x00, 0x1E, 0x01, 0x12, 
				 0x00, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 0xEA, 
				 0x00, 0x16, 0x02, 0x04, 0x00, 0x20, 0x16, 0xC0, 
				 0x00, 0x00, 0x16, 0x17, 0x4C, 0x00, 0x80, 0x00, 
				 0x00, 0x00, 0x16, 0xC0, 0x00, 0x00, 0x14, 0x00, 0x00};

BYTE t5464_Mode_512x384x16_2[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x13, 0xF0, 0x00, 0x1E, 0x00, 0xFF, 0xEF, 0x00, 
				 0x00, 0x19, 0xF0, 0x00, 0x16, 0x05, 0x04, 0x00, 
				 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 0x00, 
				 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 0x00, 
				 0x1F, 0x01, 0x00, 0x18, 0x07, 0x04, 0x15, 0xA0, 
				 0x00, 0xFF, 0x00, 0x09, 0xCE, 0x03, 0x06, 0x05, 
				 0x16, 0x80, 0x00, 0xEF, 0x00, 0x16, 0x84, 0x00, 
				 0x2A, 0x00, 0x16, 0x88, 0x00, 0x37, 0x00, 0x1D, 
				 0x19, 0x00, 0x00, 0x00, 0x4E, 0x00, 0x00, 0x00, 
				 0x3F, 0x00, 0x00, 0x00, 0x3F, 0x00, 0x00, 0x00, 
				 0x89, 0x00, 0x00, 0x00, 0x42, 0x00, 0x00, 0x00, 
				 0x06, 0x00, 0x00, 0x00, 0x24, 0x00, 0x00, 0x00, 
				 0xF5, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0xE0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 
				 0x88, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 
				 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0xFF, 0x00, 0x00, 0x00, 0x24, 0x00, 0x00, 0x00, 
				 0xE3, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 
				 0x1D, 0x06, 0x00, 0x64, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0xD0, 0x00, 0x00, 0x00, 0x22, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x13, 0xEA, 0x00, 
				 0x1E, 0x00, 0x00, 0xC0, 0x00, 0x00, 0x1E, 0x01, 
				 0x91, 0x08, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 
				 0xEA, 0x00, 0x12, 0x07, 0x04, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x08, 0x00, 0x00, 
				 0x00, 0x18, 0x07, 0x04, 0x13, 0xEA, 0x00, 0x1E, 
				 0x00, 0xC0, 0xFF, 0x00, 0x00, 0x1E, 0x01, 0x12, 
				 0x00, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 0xEA, 
				 0x00, 0x16, 0x02, 0x04, 0x00, 0x20, 0x16, 0xC0, 
				 0x00, 0x00, 0x16, 0x17, 0x4C, 0x00, 0x80, 0x00, 
				 0x00, 0x00, 0x16, 0xC0, 0x00, 0x00, 0x14, 0x00, 0x00};

BYTE t5464_Mode_512x480x16_1[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x13, 0xF0, 0x00, 0x1E, 0x00, 0xFF, 0xEF, 0x00, 
				 0x00, 0x19, 0xF0, 0x00, 0x16, 0x05, 0x04, 0x00, 
				 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 0x00, 
				 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 0x00, 
				 0x1F, 0x01, 0x00, 0x18, 0x07, 0x04, 0x15, 0xA0, 
				 0x00, 0xFF, 0x00, 0x09, 0xCE, 0x03, 0x06, 0x05, 
				 0x16, 0x80, 0x00, 0x2F, 0x00, 0x16, 0x84, 0x00, 
				 0x35, 0x00, 0x16, 0x88, 0x00, 0x49, 0x00, 0x1D, 
				 0x19, 0x00, 0x00, 0x00, 0x4B, 0x00, 0x00, 0x00, 
				 0x3F, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 
				 0x8B, 0x00, 0x00, 0x00, 0x42, 0x00, 0x00, 0x00, 
				 0x08, 0x00, 0x00, 0x00, 0xF0, 0x00, 0x00, 0x00, 
				 0x1F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0xE1, 0x00, 0x00, 0x00, 
				 0x84, 0x00, 0x00, 0x00, 0xDF, 0x00, 0x00, 0x00, 
				 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0xE0, 0x00, 0x00, 0x00, 0xF0, 0x00, 0x00, 0x00, 
				 0xE3, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 
				 0x1D, 0x06, 0x00, 0x64, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x50, 0x00, 0x00, 0x00, 0x22, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x13, 0xEA, 0x00, 
				 0x1E, 0x00, 0x00, 0xC0, 0x00, 0x00, 0x1E, 0x01, 
				 0x91, 0x08, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 
				 0xEA, 0x00, 0x12, 0x07, 0x04, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x08, 0x00, 0x00, 
				 0x00, 0x18, 0x07, 0x04, 0x13, 0xEA, 0x00, 0x1E, 
				 0x00, 0xC0, 0xFF, 0x00, 0x00, 0x1E, 0x01, 0x12, 
				 0x00, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 0xEA, 
				 0x00, 0x16, 0x02, 0x04, 0x00, 0x20, 0x16, 0xC0, 
				 0x00, 0x00, 0x16, 0x17, 0x4C, 0x00, 0x80, 0x00, 
				 0x00, 0x00, 0x16, 0xC0, 0x00, 0x00, 0x14, 0x00, 0x00};

BYTE t5464_Mode_512x480x16_2[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x13, 0xF0, 0x00, 0x1E, 0x00, 0xFF, 0xEF, 0x00, 
				 0x00, 0x19, 0xF0, 0x00, 0x16, 0x05, 0x04, 0x00, 
				 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 0x00, 
				 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 0x00, 
				 0x1F, 0x01, 0x00, 0x18, 0x07, 0x04, 0x15, 0xA0, 
				 0x00, 0xFF, 0x00, 0x09, 0xCE, 0x03, 0x06, 0x05, 
				 0x16, 0x80, 0x00, 0x2F, 0x00, 0x16, 0x84, 0x00, 
				 0x29, 0x00, 0x16, 0x88, 0x00, 0x45, 0x00, 0x1D, 
				 0x19, 0x00, 0x00, 0x00, 0x4D, 0x00, 0x00, 0x00, 
				 0x3F, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 
				 0x8D, 0x00, 0x00, 0x00, 0x42, 0x00, 0x00, 0x00, 
				 0x09, 0x00, 0x00, 0x00, 0xF4, 0x00, 0x00, 0x00, 
				 0x1F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0xE1, 0x00, 0x00, 0x00, 
				 0x84, 0x00, 0x00, 0x00, 0xDF, 0x00, 0x00, 0x00, 
				 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0xE0, 0x00, 0x00, 0x00, 0xF4, 0x00, 0x00, 0x00, 
				 0xE3, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 
				 0x1D, 0x06, 0x00, 0x64, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x50, 0x00, 0x00, 0x00, 0x22, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x13, 0xEA, 0x00, 
				 0x1E, 0x00, 0x00, 0xC0, 0x00, 0x00, 0x1E, 0x01, 
				 0x91, 0x08, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 
				 0xEA, 0x00, 0x12, 0x07, 0x04, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x08, 0x00, 0x00, 
				 0x00, 0x18, 0x07, 0x04, 0x13, 0xEA, 0x00, 0x1E, 
				 0x00, 0xC0, 0xFF, 0x00, 0x00, 0x1E, 0x01, 0x12, 
				 0x00, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 0xEA, 
				 0x00, 0x16, 0x02, 0x04, 0x00, 0x20, 0x16, 0xC0, 
				 0x00, 0x00, 0x16, 0x17, 0x4C, 0x00, 0x80, 0x00, 
				 0x00, 0x00, 0x16, 0xC0, 0x00, 0x00, 0x14, 0x00, 0x00};

BYTE t5464_Mode_640x350x16_1[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x13, 0xF0, 0x00, 0x1E, 0x00, 0xFF, 0xEF, 0x00, 
				 0x00, 0x19, 0xF0, 0x00, 0x16, 0x05, 0x04, 0x00, 
				 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 0x00, 
				 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 0x00, 
				 0x1F, 0x01, 0x00, 0x18, 0x07, 0x04, 0x15, 0xA0, 
				 0x00, 0xFF, 0x00, 0x09, 0xCE, 0x03, 0x06, 0x05, 
				 0x16, 0x80, 0x00, 0xAF, 0x00, 0x16, 0x84, 0x00, 
				 0x33, 0x00, 0x16, 0x88, 0x00, 0x58, 0x00, 0x1D, 
				 0x19, 0x00, 0x00, 0x00, 0x63, 0x00, 0x00, 0x00, 
				 0x4F, 0x00, 0x00, 0x00, 0x4F, 0x00, 0x00, 0x00, 
				 0x83, 0x00, 0x00, 0x00, 0x53, 0x00, 0x00, 0x00, 
				 0x97, 0x00, 0x00, 0x00, 0xBB, 0x00, 0x00, 0x00, 
				 0x1F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x7D, 0x00, 0x00, 0x00, 
				 0x80, 0x00, 0x00, 0x00, 0x5D, 0x00, 0x00, 0x00, 
				 0xA0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x5D, 0x00, 0x00, 0x00, 0xBB, 0x00, 0x00, 0x00, 
				 0xE3, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 
				 0x1D, 0x06, 0x00, 0x64, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x50, 0x00, 0x00, 0x00, 0x22, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x13, 0xEA, 0x00, 
				 0x1E, 0x00, 0x00, 0xC0, 0x00, 0x00, 0x1E, 0x01, 
				 0x91, 0x0A, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 
				 0xEA, 0x00, 0x12, 0x07, 0x04, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x0A, 0x00, 0x00, 
				 0x00, 0x18, 0x07, 0x04, 0x13, 0xEA, 0x00, 0x1E, 
				 0x00, 0xC0, 0xFF, 0x00, 0x00, 0x1E, 0x01, 0x12, 
				 0x00, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 0xEA, 
				 0x00, 0x16, 0x02, 0x04, 0x00, 0x20, 0x16, 0xC0, 
				 0x00, 0x00, 0x16, 0x17, 0x4C, 0x00, 0xA0, 0x00, 
				 0x00, 0x00, 0x16, 0xC0, 0x00, 0x00, 0x14, 0x00, 0x00};

BYTE t5464_Mode_640x350x16_2[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x13, 0xF0, 0x00, 0x1E, 0x00, 0xFF, 0xEF, 0x00, 
				 0x00, 0x19, 0xF0, 0x00, 0x16, 0x05, 0x04, 0x00, 
				 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 0x00, 
				 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 0x00, 
				 0x1F, 0x01, 0x00, 0x18, 0x07, 0x04, 0x15, 0xA0, 
				 0x00, 0xFF, 0x00, 0x09, 0xCE, 0x03, 0x06, 0x05, 
				 0x16, 0x80, 0x00, 0xAF, 0x00, 0x16, 0x84, 0x00, 
				 0x0A, 0x00, 0x16, 0x88, 0x00, 0x0B, 0x00, 0x1D, 
				 0x19, 0x00, 0x00, 0x00, 0x63, 0x00, 0x00, 0x00, 
				 0x4F, 0x00, 0x00, 0x00, 0x4F, 0x00, 0x00, 0x00, 
				 0x83, 0x00, 0x00, 0x00, 0x53, 0x00, 0x00, 0x00, 
				 0x97, 0x00, 0x00, 0x00, 0xBB, 0x00, 0x00, 0x00, 
				 0x1F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x7D, 0x00, 0x00, 0x00, 
				 0x80, 0x00, 0x00, 0x00, 0x5D, 0x00, 0x00, 0x00, 
				 0xA0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x5D, 0x00, 0x00, 0x00, 0xBB, 0x00, 0x00, 0x00, 
				 0xE3, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 
				 0x1D, 0x06, 0x00, 0x64, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x50, 0x00, 0x00, 0x00, 0x22, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x13, 0xEA, 0x00, 
				 0x1E, 0x00, 0x00, 0xC0, 0x00, 0x00, 0x1E, 0x01, 
				 0x91, 0x0A, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 
				 0xEA, 0x00, 0x12, 0x07, 0x04, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x0A, 0x00, 0x00, 
				 0x00, 0x18, 0x07, 0x04, 0x13, 0xEA, 0x00, 0x1E, 
				 0x00, 0xC0, 0xFF, 0x00, 0x00, 0x1E, 0x01, 0x12, 
				 0x00, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 0xEA, 
				 0x00, 0x16, 0x02, 0x04, 0x00, 0x20, 0x16, 0xC0, 
				 0x00, 0x00, 0x16, 0x17, 0x4C, 0x00, 0xA0, 0x00, 
				 0x00, 0x00, 0x16, 0xC0, 0x00, 0x00, 0x14, 0x00, 0x00};

BYTE t5464_Mode_640x400x16_1[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x13, 0xF0, 0x00, 0x1E, 0x00, 0xFF, 0xEF, 0x00, 
				 0x00, 0x19, 0xF0, 0x00, 0x16, 0x05, 0x04, 0x00, 
				 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 0x00, 
				 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 0x00, 
				 0x1F, 0x01, 0x00, 0x18, 0x07, 0x04, 0x15, 0xA0, 
				 0x00, 0xFF, 0x00, 0x09, 0xCE, 0x03, 0x06, 0x05, 
				 0x16, 0x80, 0x00, 0x6F, 0x00, 0x16, 0x84, 0x00, 
				 0x3F, 0x00, 0x16, 0x88, 0x00, 0x6D, 0x00, 0x1D, 
				 0x19, 0x00, 0x00, 0x00, 0x5F, 0x00, 0x00, 0x00, 
				 0x4F, 0x00, 0x00, 0x00, 0x50, 0x00, 0x00, 0x00, 
				 0x82, 0x00, 0x00, 0x00, 0x53, 0x00, 0x00, 0x00, 
				 0x9F, 0x00, 0x00, 0x00, 0xBF, 0x00, 0x00, 0x00, 
				 0x1F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0xA1, 0x00, 0x00, 0x00, 
				 0xA3, 0x00, 0x00, 0x00, 0x8F, 0x00, 0x00, 0x00, 
				 0x50, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x96, 0x00, 0x00, 0x00, 0xB9, 0x00, 0x00, 0x00, 
				 0xE3, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 
				 0x1D, 0x06, 0x00, 0x64, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x50, 0x00, 0x00, 0x00, 0x22, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x13, 0xEA, 0x00, 
				 0x1E, 0x00, 0x00, 0xC0, 0x00, 0x00, 0x1E, 0x01, 
				 0x91, 0x0A, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 
				 0xEA, 0x00, 0x12, 0x07, 0x04, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x0A, 0x00, 0x00, 
				 0x00, 0x18, 0x07, 0x04, 0x13, 0xEA, 0x00, 0x1E, 
				 0x00, 0xC0, 0xFF, 0x00, 0x00, 0x1E, 0x01, 0x12, 
				 0x00, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 0xEA, 
				 0x00, 0x16, 0x02, 0x04, 0x00, 0x20, 0x16, 0xC0, 
				 0x00, 0x00, 0x16, 0x17, 0x4C, 0x00, 0xA0, 0x00, 
				 0x00, 0x00, 0x16, 0xC0, 0x00, 0x00, 0x14, 0x00, 0x00};

BYTE t5464_Mode_640x480x16_1[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x13, 0xF0, 0x00, 0x1E, 0x00, 0xFF, 0xEF, 0x00, 
				 0x00, 0x19, 0xF0, 0x00, 0x16, 0x05, 0x04, 0x00, 
				 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 0x00, 
				 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 0x00, 
				 0x1F, 0x01, 0x00, 0x18, 0x07, 0x04, 0x15, 0xA0, 
				 0x00, 0xFF, 0x00, 0x09, 0xCE, 0x03, 0x06, 0x05, 
				 0x16, 0x80, 0x00, 0xEF, 0x00, 0x16, 0x84, 0x00, 
				 0x3F, 0x00, 0x16, 0x88, 0x00, 0x6D, 0x00, 0x1D, 
				 0x19, 0x00, 0x00, 0x00, 0x5F, 0x00, 0x00, 0x00, 
				 0x4F, 0x00, 0x00, 0x00, 0x50, 0x00, 0x00, 0x00, 
				 0x9E, 0x00, 0x00, 0x00, 0x54, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x0B, 0x00, 0x00, 0x00, 
				 0x3E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0xE9, 0x00, 0x00, 0x00, 
				 0x8B, 0x00, 0x00, 0x00, 0xDF, 0x00, 0x00, 0x00, 
				 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0xE7, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 
				 0xE3, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 
				 0x1D, 0x06, 0x00, 0x64, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x90, 0x00, 0x00, 0x00, 0x22, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x13, 0xEA, 0x00, 
				 0x1E, 0x00, 0x00, 0xC0, 0x00, 0x00, 0x1E, 0x01, 
				 0x91, 0x0A, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 
				 0xEA, 0x00, 0x12, 0x07, 0x04, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x0A, 0x00, 0x00, 
				 0x00, 0x18, 0x07, 0x04, 0x13, 0xEA, 0x00, 0x1E, 
				 0x00, 0xC0, 0xFF, 0x00, 0x00, 0x1E, 0x01, 0x12, 
				 0x00, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 0xEA, 
				 0x00, 0x16, 0x02, 0x04, 0x00, 0x20, 0x16, 0xC0, 
				 0x00, 0x00, 0x16, 0x17, 0x4C, 0x00, 0xA0, 0x00, 
				 0x00, 0x00, 0x16, 0xC0, 0x00, 0x00, 0x14, 0x00, 0x00};

BYTE t5464_Mode_640x480x16_2[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x13, 0xF0, 0x00, 0x1E, 0x00, 0xFF, 0xEF, 0x00, 
				 0x00, 0x19, 0xF0, 0x00, 0x16, 0x05, 0x04, 0x00, 
				 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 0x00, 
				 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 0x00, 
				 0x1F, 0x01, 0x00, 0x18, 0x07, 0x04, 0x15, 0xA0, 
				 0x00, 0xFF, 0x00, 0x09, 0xCE, 0x03, 0x06, 0x05, 
				 0x16, 0x80, 0x00, 0xEF, 0x00, 0x16, 0x84, 0x00, 
				 0x0A, 0x00, 0x16, 0x88, 0x00, 0x0B, 0x00, 0x1D, 
				 0x19, 0x00, 0x00, 0x00, 0x63, 0x00, 0x00, 0x00, 
				 0x4F, 0x00, 0x00, 0x00, 0x50, 0x00, 0x00, 0x00, 
				 0x82, 0x00, 0x00, 0x00, 0x54, 0x00, 0x00, 0x00, 
				 0x99, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 
				 0x3E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0xE8, 0x00, 0x00, 0x00, 
				 0x8B, 0x00, 0x00, 0x00, 0xDF, 0x00, 0x00, 0x00, 
				 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0xE7, 0x00, 0x00, 0x00, 0xF3, 0x00, 0x00, 0x00, 
				 0xE3, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 
				 0x1D, 0x06, 0x00, 0x64, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x50, 0x00, 0x00, 0x00, 0x22, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x13, 0xEA, 0x00, 
				 0x1E, 0x00, 0x00, 0xC0, 0x00, 0x00, 0x1E, 0x01, 
				 0x91, 0x0A, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 
				 0xEA, 0x00, 0x12, 0x07, 0x04, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x0A, 0x00, 0x00, 
				 0x00, 0x18, 0x07, 0x04, 0x13, 0xEA, 0x00, 0x1E, 
				 0x00, 0xC0, 0xFF, 0x00, 0x00, 0x1E, 0x01, 0x12, 
				 0x00, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 0xEA, 
				 0x00, 0x16, 0x02, 0x04, 0x00, 0x20, 0x16, 0xC0, 
				 0x00, 0x00, 0x16, 0x17, 0x4C, 0x00, 0xA0, 0x00, 
				 0x00, 0x00, 0x16, 0xC0, 0x00, 0x00, 0x14, 0x00, 0x00};

BYTE t5464_Mode_640x480x16_3[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x13, 0xF0, 0x00, 0x1E, 0x00, 0xFF, 0xEF, 0x00, 
				 0x00, 0x19, 0xF0, 0x00, 0x16, 0x05, 0x04, 0x00, 
				 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 0x00, 
				 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 0x00, 
				 0x1F, 0x01, 0x00, 0x18, 0x07, 0x04, 0x15, 0xA0, 
				 0x00, 0xFF, 0x00, 0x09, 0xCE, 0x03, 0x06, 0x05, 
				 0x16, 0x80, 0x00, 0xEF, 0x00, 0x16, 0x84, 0x00, 
				 0x0A, 0x00, 0x16, 0x88, 0x00, 0x0B, 0x00, 0x1D, 
				 0x19, 0x00, 0x00, 0x00, 0x64, 0x00, 0x00, 0x00, 
				 0x4F, 0x00, 0x00, 0x00, 0x50, 0x00, 0x00, 0x00, 
				 0x82, 0x00, 0x00, 0x00, 0x54, 0x00, 0x00, 0x00, 
				 0x9C, 0x00, 0x00, 0x00, 0xF2, 0x00, 0x00, 0x00, 
				 0x1F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0xE0, 0x00, 0x00, 0x00, 
				 0x83, 0x00, 0x00, 0x00, 0xDF, 0x00, 0x00, 0x00, 
				 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0xDF, 0x00, 0x00, 0x00, 0xF2, 0x00, 0x00, 0x00, 
				 0xE3, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 
				 0x1D, 0x06, 0x00, 0x64, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x50, 0x00, 0x00, 0x00, 0x22, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x13, 0xEA, 0x00, 
				 0x1E, 0x00, 0x00, 0xC0, 0x00, 0x00, 0x1E, 0x01, 
				 0x91, 0x0A, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 
				 0xEA, 0x00, 0x12, 0x07, 0x04, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x0A, 0x00, 0x00, 
				 0x00, 0x18, 0x07, 0x04, 0x13, 0xEA, 0x00, 0x1E, 
				 0x00, 0xC0, 0xFF, 0x00, 0x00, 0x1E, 0x01, 0x12, 
				 0x00, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 0xEA, 
				 0x00, 0x16, 0x02, 0x04, 0x00, 0x20, 0x16, 0xC0, 
				 0x00, 0x00, 0x16, 0x17, 0x4C, 0x00, 0xA0, 0x00, 
				 0x00, 0x00, 0x16, 0xC0, 0x00, 0x00, 0x14, 0x00, 0x00};

BYTE t5464_Mode_640x480x16_4[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x13, 0xF0, 0x00, 0x1E, 0x00, 0xFF, 0xEF, 0x00, 
				 0x00, 0x19, 0xF0, 0x00, 0x16, 0x05, 0x04, 0x00, 
				 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 0x00, 
				 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 0x00, 
				 0x1F, 0x01, 0x00, 0x18, 0x07, 0x04, 0x15, 0xA0, 
				 0x00, 0xFF, 0x00, 0x09, 0xCE, 0x03, 0x06, 0x05, 
				 0x16, 0x80, 0x00, 0xEF, 0x00, 0x16, 0x84, 0x00, 
				 0x33, 0x00, 0x16, 0x88, 0x00, 0x7E, 0x00, 0x1D, 
				 0x19, 0x00, 0x00, 0x00, 0x63, 0x00, 0x00, 0x00, 
				 0x4F, 0x00, 0x00, 0x00, 0x50, 0x00, 0x00, 0x00, 
				 0x82, 0x00, 0x00, 0x00, 0x55, 0x00, 0x00, 0x00, 
				 0x9B, 0x00, 0x00, 0x00, 0xFB, 0x00, 0x00, 0x00, 
				 0x1F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0xE0, 0x00, 0x00, 0x00, 
				 0x83, 0x00, 0x00, 0x00, 0xDF, 0x00, 0x00, 0x00, 
				 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0xDF, 0x00, 0x00, 0x00, 0xF9, 0x00, 0x00, 0x00, 
				 0xE3, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 
				 0x1D, 0x06, 0x00, 0x64, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x50, 0x00, 0x00, 0x00, 0x22, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x13, 0xEA, 0x00, 
				 0x1E, 0x00, 0x00, 0xC0, 0x00, 0x00, 0x1E, 0x01, 
				 0x91, 0x0A, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 
				 0xEA, 0x00, 0x12, 0x07, 0x04, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x0A, 0x00, 0x00, 
				 0x00, 0x18, 0x07, 0x04, 0x13, 0xEA, 0x00, 0x1E, 
				 0x00, 0xC0, 0xFF, 0x00, 0x00, 0x1E, 0x01, 0x12, 
				 0x00, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 0xEA, 
				 0x00, 0x16, 0x02, 0x04, 0x00, 0x20, 0x16, 0xC0, 
				 0x00, 0x00, 0x16, 0x17, 0x4C, 0x00, 0xA0, 0x00, 
				 0x00, 0x00, 0x16, 0xC0, 0x00, 0x00, 0x14, 0x00, 0x00};

BYTE t5464_Mode_800x600x16_1[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x13, 0xF0, 0x00, 0x1E, 0x00, 0xFF, 0xEF, 0x00, 
				 0x00, 0x19, 0xF0, 0x00, 0x16, 0x05, 0x04, 0x00, 
				 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 0x00, 
				 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 0x00, 
				 0x1F, 0x01, 0x00, 0x18, 0x07, 0x04, 0x15, 0xA0, 
				 0x00, 0xFF, 0x00, 0x09, 0xCE, 0x03, 0x06, 0x05, 
				 0x16, 0x80, 0x00, 0x2F, 0x00, 0x16, 0x84, 0x00, 
				 0x3E, 0x00, 0x16, 0x88, 0x00, 0x4E, 0x00, 0x1D, 
				 0x19, 0x00, 0x00, 0x00, 0x7B, 0x00, 0x00, 0x00, 
				 0x63, 0x00, 0x00, 0x00, 0x64, 0x00, 0x00, 0x00, 
				 0x9B, 0x00, 0x00, 0x00, 0x68, 0x00, 0x00, 0x00, 
				 0x91, 0x00, 0x00, 0x00, 0x6F, 0x00, 0x00, 0x00, 
				 0xF0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x58, 0x00, 0x00, 0x00, 
				 0x8A, 0x00, 0x00, 0x00, 0x57, 0x00, 0x00, 0x00, 
				 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x58, 0x00, 0x00, 0x00, 0x6F, 0x00, 0x00, 0x00, 
				 0xE3, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 
				 0x1D, 0x06, 0x00, 0x64, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x90, 0x00, 0x00, 0x00, 0x22, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x13, 0xEA, 0x00, 
				 0x1E, 0x00, 0x00, 0xC0, 0x00, 0x00, 0x1E, 0x01, 
				 0x92, 0x0D, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 
				 0xEA, 0x00, 0x12, 0x07, 0x04, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x0D, 0x00, 0x00, 
				 0x00, 0x18, 0x07, 0x04, 0x13, 0xEA, 0x00, 0x1E, 
				 0x00, 0xC0, 0xFF, 0x00, 0x00, 0x1E, 0x01, 0x13, 
				 0x00, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 0xEA, 
				 0x00, 0x16, 0x02, 0x04, 0x00, 0x20, 0x16, 0xC0, 
				 0x00, 0x00, 0x16, 0x17, 0x4C, 0x00, 0xD0, 0x00, 
				 0x00, 0x00, 0x16, 0xC0, 0x00, 0x00, 0x14, 0x00, 0x00};

BYTE t5464_Mode_800x600x16_2[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x13, 0xF0, 0x00, 0x1E, 0x00, 0xFF, 0xEF, 0x00, 
				 0x00, 0x19, 0xF0, 0x00, 0x16, 0x05, 0x04, 0x00, 
				 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 0x00, 
				 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 0x00, 
				 0x1F, 0x01, 0x00, 0x18, 0x07, 0x04, 0x15, 0xA0, 
				 0x00, 0xFF, 0x00, 0x09, 0xCE, 0x03, 0x06, 0x05, 
				 0x16, 0x80, 0x00, 0x2F, 0x00, 0x16, 0x84, 0x00, 
				 0x3A, 0x00, 0x16, 0x88, 0x00, 0x51, 0x00, 0x1D, 
				 0x19, 0x00, 0x00, 0x00, 0x7F, 0x00, 0x00, 0x00, 
				 0x63, 0x00, 0x00, 0x00, 0x64, 0x00, 0x00, 0x00, 
				 0x9F, 0x00, 0x00, 0x00, 0x69, 0x00, 0x00, 0x00, 
				 0x99, 0x00, 0x00, 0x00, 0x72, 0x00, 0x00, 0x00, 
				 0xF0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x58, 0x00, 0x00, 0x00, 
				 0x8C, 0x00, 0x00, 0x00, 0x57, 0x00, 0x00, 0x00, 
				 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x58, 0x00, 0x00, 0x00, 0x72, 0x00, 0x00, 0x00, 
				 0xE3, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 
				 0x1D, 0x06, 0x00, 0x64, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x90, 0x00, 0x00, 0x00, 0x22, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x13, 0xEA, 0x00, 
				 0x1E, 0x00, 0x00, 0xC0, 0x00, 0x00, 0x1E, 0x01, 
				 0x92, 0x0D, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 
				 0xEA, 0x00, 0x12, 0x07, 0x04, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x0D, 0x00, 0x00, 
				 0x00, 0x18, 0x07, 0x04, 0x13, 0xEA, 0x00, 0x1E, 
				 0x00, 0xC0, 0xFF, 0x00, 0x00, 0x1E, 0x01, 0x13, 
				 0x00, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 0xEA, 
				 0x00, 0x16, 0x02, 0x04, 0x00, 0x20, 0x16, 0xC0, 
				 0x00, 0x00, 0x16, 0x17, 0x4C, 0x00, 0xD0, 0x00, 
				 0x00, 0x00, 0x16, 0xC0, 0x00, 0x00, 0x14, 0x00, 0x00};

BYTE t5464_Mode_800x600x16_3[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x13, 0xF0, 0x00, 0x1E, 0x00, 0xFF, 0xEF, 0x00, 
				 0x00, 0x19, 0xF0, 0x00, 0x16, 0x05, 0x04, 0x00, 
				 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 0x00, 
				 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 0x00, 
				 0x1F, 0x01, 0x00, 0x18, 0x07, 0x04, 0x15, 0xA0, 
				 0x00, 0xFF, 0x00, 0x09, 0xCE, 0x03, 0x06, 0x05, 
				 0x16, 0x80, 0x00, 0x2F, 0x00, 0x16, 0x84, 0x00, 
				 0x3E, 0x00, 0x16, 0x88, 0x00, 0x6C, 0x00, 0x1D, 
				 0x19, 0x00, 0x00, 0x00, 0x7D, 0x00, 0x00, 0x00, 
				 0x63, 0x00, 0x00, 0x00, 0x64, 0x00, 0x00, 0x00, 
				 0x9D, 0x00, 0x00, 0x00, 0x6C, 0x00, 0x00, 0x00, 
				 0x9B, 0x00, 0x00, 0x00, 0x97, 0x00, 0x00, 0x00, 
				 0xF0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x7B, 0x00, 0x00, 0x00, 
				 0x81, 0x00, 0x00, 0x00, 0x57, 0x00, 0x00, 0x00, 
				 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x5F, 0x00, 0x00, 0x00, 0x97, 0x00, 0x00, 0x00, 
				 0xE3, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 
				 0x1D, 0x06, 0x00, 0x64, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x90, 0x00, 0x00, 0x00, 0x22, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x13, 0xEA, 0x00, 
				 0x1E, 0x00, 0x00, 0xC0, 0x00, 0x00, 0x1E, 0x01, 
				 0x92, 0x0D, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 
				 0xEA, 0x00, 0x12, 0x07, 0x04, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x0D, 0x00, 0x00, 
				 0x00, 0x18, 0x07, 0x04, 0x13, 0xEA, 0x00, 0x1E, 
				 0x00, 0xC0, 0xFF, 0x00, 0x00, 0x1E, 0x01, 0x13, 
				 0x00, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 0xEA, 
				 0x00, 0x16, 0x02, 0x04, 0x00, 0x20, 0x16, 0xC0, 
				 0x00, 0x00, 0x16, 0x17, 0x4C, 0x00, 0xD0, 0x00, 
				 0x00, 0x00, 0x16, 0xC0, 0x00, 0x00, 0x14, 0x00, 0x00};

BYTE t5464_Mode_800x600x16_4[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x13, 0xF0, 0x00, 0x1E, 0x00, 0xFF, 0xEF, 0x00, 
				 0x00, 0x19, 0xF0, 0x00, 0x16, 0x05, 0x04, 0x00, 
				 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 0x00, 
				 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 0x00, 
				 0x1F, 0x01, 0x00, 0x18, 0x07, 0x04, 0x15, 0xA0, 
				 0x00, 0xFF, 0x00, 0x09, 0xCE, 0x03, 0x06, 0x05, 
				 0x16, 0x80, 0x00, 0x2F, 0x00, 0x16, 0x84, 0x00, 
				 0x30, 0x00, 0x16, 0x88, 0x00, 0x53, 0x00, 0x1D, 
				 0x19, 0x00, 0x00, 0x00, 0x7F, 0x00, 0x00, 0x00, 
				 0x63, 0x00, 0x00, 0x00, 0x64, 0x00, 0x00, 0x00, 
				 0x9F, 0x00, 0x00, 0x00, 0x67, 0x00, 0x00, 0x00, 
				 0x91, 0x00, 0x00, 0x00, 0x6F, 0x00, 0x00, 0x00, 
				 0xF0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x58, 0x00, 0x00, 0x00, 
				 0x8B, 0x00, 0x00, 0x00, 0x57, 0x00, 0x00, 0x00, 
				 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x57, 0x00, 0x00, 0x00, 0x6F, 0x00, 0x00, 0x00, 
				 0xE3, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 
				 0x1D, 0x06, 0x00, 0x64, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x90, 0x00, 0x00, 0x00, 0x22, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x13, 0xEA, 0x00, 
				 0x1E, 0x00, 0x00, 0xC0, 0x00, 0x00, 0x1E, 0x01, 
				 0x92, 0x0D, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 
				 0xEA, 0x00, 0x12, 0x07, 0x04, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x0D, 0x00, 0x00, 
				 0x00, 0x18, 0x07, 0x04, 0x13, 0xEA, 0x00, 0x1E, 
				 0x00, 0xC0, 0xFF, 0x00, 0x00, 0x1E, 0x01, 0x13, 
				 0x00, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 0xEA, 
				 0x00, 0x16, 0x02, 0x04, 0x00, 0x20, 0x16, 0xC0, 
				 0x00, 0x00, 0x16, 0x17, 0x4C, 0x00, 0xD0, 0x00, 
				 0x00, 0x00, 0x16, 0xC0, 0x00, 0x00, 0x14, 0x00, 0x00};

BYTE t5464_Mode_800x600x16_5[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x13, 0xF0, 0x00, 0x1E, 0x00, 0xFF, 0xEF, 0x00, 
				 0x00, 0x19, 0xF0, 0x00, 0x16, 0x05, 0x04, 0x00, 
				 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 0x00, 
				 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 0x00, 
				 0x1F, 0x01, 0x00, 0x18, 0x07, 0x04, 0x15, 0xA0, 
				 0x00, 0xFF, 0x00, 0x09, 0xCE, 0x03, 0x06, 0x05, 
				 0x16, 0x80, 0x00, 0x2F, 0x00, 0x16, 0x84, 0x00, 
				 0x1C, 0x00, 0x16, 0x88, 0x00, 0x37, 0x00, 0x1D, 
				 0x19, 0x00, 0x00, 0x00, 0x7E, 0x00, 0x00, 0x00, 
				 0x63, 0x00, 0x00, 0x00, 0x64, 0x00, 0x00, 0x00, 
				 0x9E, 0x00, 0x00, 0x00, 0x69, 0x00, 0x00, 0x00, 
				 0x91, 0x00, 0x00, 0x00, 0x75, 0x00, 0x00, 0x00, 
				 0xF0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x58, 0x00, 0x00, 0x00, 
				 0x8B, 0x00, 0x00, 0x00, 0x57, 0x00, 0x00, 0x00, 
				 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x57, 0x00, 0x00, 0x00, 0x75, 0x00, 0x00, 0x00, 
				 0xE3, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 
				 0x1D, 0x06, 0x00, 0x64, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x90, 0x00, 0x00, 0x00, 0x22, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x13, 0xEA, 0x00, 
				 0x1E, 0x00, 0x00, 0xC0, 0x00, 0x00, 0x1E, 0x01, 
				 0x92, 0x0D, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 
				 0xEA, 0x00, 0x12, 0x07, 0x04, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x0D, 0x00, 0x00, 
				 0x00, 0x18, 0x07, 0x04, 0x13, 0xEA, 0x00, 0x1E, 
				 0x00, 0xC0, 0xFF, 0x00, 0x00, 0x1E, 0x01, 0x13, 
				 0x00, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 0xEA, 
				 0x00, 0x16, 0x02, 0x04, 0x00, 0x20, 0x16, 0xC0, 
				 0x00, 0x00, 0x16, 0x17, 0x4C, 0x00, 0xD0, 0x00, 
				 0x00, 0x00, 0x16, 0xC0, 0x00, 0x00, 0x14, 0x00, 0x00};

BYTE t5464_Mode_1024x768x16_1[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x13, 0xF0, 0x00, 0x1E, 0x00, 0xFF, 0xEF, 0x00, 
				 0x00, 0x19, 0xF0, 0x00, 0x16, 0x05, 0x04, 0x00, 
				 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 0x00, 
				 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 0x00, 
				 0x1F, 0x01, 0x00, 0x18, 0x07, 0x04, 0x15, 0xA0, 
				 0x00, 0xFF, 0x00, 0x09, 0xCE, 0x03, 0x06, 0x05, 
				 0x16, 0x80, 0x00, 0x2F, 0x00, 0x16, 0x84, 0x00, 
				 0x2C, 0x00, 0x16, 0x88, 0x00, 0x45, 0x00, 0x1D, 
				 0x19, 0x00, 0x00, 0x00, 0x99, 0x00, 0x00, 0x00, 
				 0x7F, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 
				 0x99, 0x00, 0x00, 0x00, 0x83, 0x00, 0x00, 0x00, 
				 0x19, 0x00, 0x00, 0x00, 0x96, 0x00, 0x00, 0x00, 
				 0x1F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x7F, 0x00, 0x00, 0x00, 
				 0x83, 0x00, 0x00, 0x00, 0x7F, 0x00, 0x00, 0x00, 
				 0xA0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x80, 0x00, 0x00, 0x00, 0x96, 0x00, 0x00, 0x00, 
				 0xE3, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 
				 0x1D, 0x06, 0x00, 0x64, 0x00, 0x48, 0x00, 0x00, 
				 0x00, 0x51, 0x00, 0x00, 0x00, 0x22, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x13, 0xEA, 0x00, 
				 0x1E, 0x00, 0x00, 0xC0, 0x00, 0x00, 0x1E, 0x01, 
				 0xD2, 0x08, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 
				 0xEA, 0x00, 0x12, 0x07, 0x04, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x08, 0x00, 0x00, 
				 0x00, 0x18, 0x07, 0x04, 0x13, 0xEA, 0x00, 0x1E, 
				 0x00, 0xC0, 0xFF, 0x00, 0x00, 0x1E, 0x01, 0x19, 
				 0x00, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 0xEA, 
				 0x00, 0x16, 0x02, 0x04, 0x00, 0x28, 0x16, 0xC0, 
				 0x00, 0x00, 0x16, 0x17, 0x4C, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x17, 0x6C, 0x00, 0x32, 0x00, 0x00, 
				 0x00, 0x16, 0xC0, 0x00, 0x00, 0x14, 0x00, 0x02};

BYTE t5464_Mode_1024x768x16_2[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x13, 0xF0, 0x00, 0x1E, 0x00, 0xFF, 0xEF, 0x00, 
				 0x00, 0x19, 0xF0, 0x00, 0x16, 0x05, 0x04, 0x00, 
				 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 0x00, 
				 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 0x00, 
				 0x1F, 0x01, 0x00, 0x18, 0x07, 0x04, 0x15, 0xA0, 
				 0x00, 0xFF, 0x00, 0x09, 0xCE, 0x03, 0x06, 0x05, 
				 0x16, 0x80, 0x00, 0xEF, 0x00, 0x16, 0x84, 0x00, 
				 0x1A, 0x00, 0x16, 0x88, 0x00, 0x3B, 0x00, 0x1D, 
				 0x19, 0x00, 0x00, 0x00, 0xA3, 0x00, 0x00, 0x00, 
				 0x7F, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 
				 0x83, 0x00, 0x00, 0x00, 0x84, 0x00, 0x00, 0x00, 
				 0x95, 0x00, 0x00, 0x00, 0x24, 0x00, 0x00, 0x00, 
				 0xFD, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 
				 0x88, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 
				 0xA0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x24, 0x00, 0x00, 0x00, 
				 0xE3, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 
				 0x1D, 0x06, 0x00, 0x64, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0xE0, 0x00, 0x00, 0x00, 0x22, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x13, 0xEA, 0x00, 
				 0x1E, 0x00, 0x00, 0xC0, 0x00, 0x00, 0x1E, 0x01, 
				 0xD2, 0x08, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 
				 0xEA, 0x00, 0x12, 0x07, 0x04, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x08, 0x00, 0x00, 
				 0x00, 0x18, 0x07, 0x04, 0x13, 0xEA, 0x00, 0x1E, 
				 0x00, 0xC0, 0xFF, 0x00, 0x00, 0x1E, 0x01, 0x19, 
				 0x00, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 0xEA, 
				 0x00, 0x16, 0x02, 0x04, 0x00, 0x28, 0x16, 0xC0, 
				 0x00, 0x00, 0x16, 0x17, 0x4C, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x17, 0x6C, 0x00, 0x32, 0x00, 0x00, 
				 0x00, 0x16, 0xC0, 0x00, 0x00, 0x14, 0x00, 0x02};

BYTE t5464_Mode_1024x768x16_3[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x13, 0xF0, 0x00, 0x1E, 0x00, 0xFF, 0xEF, 0x00, 
				 0x00, 0x19, 0xF0, 0x00, 0x16, 0x05, 0x04, 0x00, 
				 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 0x00, 
				 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 0x00, 
				 0x1F, 0x01, 0x00, 0x18, 0x07, 0x04, 0x15, 0xA0, 
				 0x00, 0xFF, 0x00, 0x09, 0xCE, 0x03, 0x06, 0x05, 
				 0x16, 0x80, 0x00, 0xEF, 0x00, 0x16, 0x84, 0x00, 
				 0x2A, 0x00, 0x16, 0x88, 0x00, 0x6E, 0x00, 0x1D, 
				 0x19, 0x00, 0x00, 0x00, 0xA1, 0x00, 0x00, 0x00, 
				 0x7F, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 
				 0x81, 0x00, 0x00, 0x00, 0x84, 0x00, 0x00, 0x00, 
				 0x95, 0x00, 0x00, 0x00, 0x24, 0x00, 0x00, 0x00, 
				 0xFD, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 
				 0x88, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 
				 0xA0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x24, 0x00, 0x00, 0x00, 
				 0xE3, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 
				 0x1D, 0x06, 0x00, 0x64, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0xE0, 0x00, 0x00, 0x00, 0x22, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x13, 0xEA, 0x00, 
				 0x1E, 0x00, 0x00, 0xC0, 0x00, 0x00, 0x1E, 0x01, 
				 0xD2, 0x08, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 
				 0xEA, 0x00, 0x12, 0x07, 0x04, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x08, 0x00, 0x00, 
				 0x00, 0x18, 0x07, 0x04, 0x13, 0xEA, 0x00, 0x1E, 
				 0x00, 0xC0, 0xFF, 0x00, 0x00, 0x1E, 0x01, 0x19, 
				 0x00, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 0xEA, 
				 0x00, 0x16, 0x02, 0x04, 0x00, 0x28, 0x16, 0xC0, 
				 0x00, 0x00, 0x16, 0x17, 0x4C, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x17, 0x6C, 0x00, 0x32, 0x00, 0x00, 
				 0x00, 0x16, 0xC0, 0x00, 0x00, 0x14, 0x00, 0x02};

BYTE t5464_Mode_1024x768x16_4[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x13, 0xF0, 0x00, 0x1E, 0x00, 0xFF, 0xEF, 0x00, 
				 0x00, 0x19, 0xF0, 0x00, 0x16, 0x05, 0x04, 0x00, 
				 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 0x00, 
				 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 0x00, 
				 0x1F, 0x01, 0x00, 0x18, 0x07, 0x04, 0x15, 0xA0, 
				 0x00, 0xFF, 0x00, 0x09, 0xCE, 0x03, 0x06, 0x05, 
				 0x16, 0x80, 0x00, 0x2F, 0x00, 0x16, 0x84, 0x00, 
				 0x10, 0x00, 0x16, 0x88, 0x00, 0x2C, 0x00, 0x1D, 
				 0x19, 0x00, 0x00, 0x00, 0x9F, 0x00, 0x00, 0x00, 
				 0x7F, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 
				 0x9F, 0x00, 0x00, 0x00, 0x83, 0x00, 0x00, 0x00, 
				 0x0F, 0x00, 0x00, 0x00, 0x1E, 0x00, 0x00, 0x00, 
				 0xF5, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x83, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 
				 0xA0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0xFF, 0x00, 0x00, 0x00, 0x1E, 0x00, 0x00, 0x00, 
				 0xE3, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 
				 0x1D, 0x06, 0x00, 0x64, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0xE0, 0x00, 0x00, 0x00, 0x22, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x13, 0xEA, 0x00, 
				 0x1E, 0x00, 0x00, 0xC0, 0x00, 0x00, 0x1E, 0x01, 
				 0xD2, 0x08, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 
				 0xEA, 0x00, 0x12, 0x07, 0x04, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x08, 0x00, 0x00, 
				 0x00, 0x18, 0x07, 0x04, 0x13, 0xEA, 0x00, 0x1E, 
				 0x00, 0xC0, 0xFF, 0x00, 0x00, 0x1E, 0x01, 0x19, 
				 0x00, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 0xEA, 
				 0x00, 0x16, 0x02, 0x04, 0x00, 0x28, 0x16, 0xC0, 
				 0x00, 0x00, 0x16, 0x17, 0x4C, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x17, 0x6C, 0x00, 0x32, 0x00, 0x00, 
				 0x00, 0x16, 0xC0, 0x00, 0x00, 0x14, 0x00, 0x02};

BYTE t5464_Mode_1024x768x16_5[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x13, 0xF0, 0x00, 0x1E, 0x00, 0xFF, 0xEF, 0x00, 
				 0x00, 0x19, 0xF0, 0x00, 0x16, 0x05, 0x04, 0x00, 
				 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 0x00, 
				 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 0x00, 
				 0x1F, 0x01, 0x00, 0x18, 0x07, 0x04, 0x15, 0xA0, 
				 0x00, 0xFF, 0x00, 0x09, 0xCE, 0x03, 0x06, 0x05, 
				 0x16, 0x80, 0x00, 0x2F, 0x00, 0x16, 0x84, 0x00, 
				 0x0A, 0x00, 0x16, 0x88, 0x00, 0x21, 0x00, 0x1D, 
				 0x19, 0x00, 0x00, 0x00, 0xA7, 0x00, 0x00, 0x00, 
				 0x7F, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 
				 0x87, 0x00, 0x00, 0x00, 0x87, 0x00, 0x00, 0x00, 
				 0x93, 0x00, 0x00, 0x00, 0x26, 0x00, 0x00, 0x00, 
				 0xF5, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x83, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 
				 0xA0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0xFF, 0x00, 0x00, 0x00, 0x26, 0x00, 0x00, 0x00, 
				 0xE3, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 
				 0x1D, 0x06, 0x00, 0x64, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0xE0, 0x00, 0x00, 0x00, 0x22, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x13, 0xEA, 0x00, 
				 0x1E, 0x00, 0x00, 0xC0, 0x00, 0x00, 0x1E, 0x01, 
				 0xD2, 0x08, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 
				 0xEA, 0x00, 0x12, 0x07, 0x04, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x08, 0x00, 0x00, 
				 0x00, 0x18, 0x07, 0x04, 0x13, 0xEA, 0x00, 0x1E, 
				 0x00, 0xC0, 0xFF, 0x00, 0x00, 0x1E, 0x01, 0x19, 
				 0x00, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 0xEA, 
				 0x00, 0x16, 0x02, 0x04, 0x00, 0x28, 0x16, 0xC0, 
				 0x00, 0x00, 0x16, 0x17, 0x4C, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x17, 0x6C, 0x00, 0x32, 0x00, 0x00, 
				 0x00, 0x16, 0xC0, 0x00, 0x00, 0x14, 0x00, 0x02};

BYTE t5464_Mode_1152x864x16_1[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x13, 0xF0, 0x00, 0x1E, 0x00, 0xFF, 0xEF, 0x00, 
				 0x00, 0x19, 0xF0, 0x00, 0x16, 0x05, 0x04, 0x00, 
				 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 0x00, 
				 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 0x00, 
				 0x1F, 0x01, 0x00, 0x18, 0x07, 0x04, 0x15, 0xA0, 
				 0x00, 0xFF, 0x00, 0x09, 0xCE, 0x03, 0x06, 0x05, 
				 0x16, 0x80, 0x00, 0x2F, 0x00, 0x16, 0x84, 0x00, 
				 0x0A, 0x00, 0x16, 0x88, 0x00, 0x21, 0x00, 0x1D, 
				 0x19, 0x00, 0x00, 0x00, 0xB4, 0x00, 0x00, 0x00, 
				 0x8F, 0x00, 0x00, 0x00, 0x8F, 0x00, 0x00, 0x00, 
				 0x94, 0x00, 0x00, 0x00, 0x93, 0x00, 0x00, 0x00, 
				 0x9F, 0x00, 0x00, 0x00, 0x8E, 0x00, 0x00, 0x00, 
				 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x60, 0x00, 0x00, 0x00, 
				 0x83, 0x00, 0x00, 0x00, 0x5F, 0x00, 0x00, 0x00, 
				 0xA0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x5F, 0x00, 0x00, 0x00, 0x8E, 0x00, 0x00, 0x00, 
				 0xE3, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 
				 0x1D, 0x06, 0x00, 0x64, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0xE0, 0x00, 0x00, 0x00, 0x22, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x13, 0xEA, 0x00, 
				 0x1E, 0x00, 0x00, 0xC0, 0x00, 0x00, 0x1E, 0x01, 
				 0xA2, 0x14, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 
				 0xEA, 0x00, 0x12, 0x07, 0x04, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x14, 0x00, 0x00, 
				 0x00, 0x18, 0x07, 0x04, 0x16, 0x02, 0x04, 0x00, 
				 0x20, 0x16, 0xC0, 0x00, 0x00, 0x16, 0x17, 0x4C, 
				 0x00, 0x40, 0x00, 0x00, 0x00, 0x17, 0x6C, 0x00, 
				 0x32, 0x00, 0x00, 0x00, 0x16, 0xC0, 0x00, 0x00, 
				 0x14, 0x00, 0x16};

BYTE t5464_Mode_1152x864x16_2[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x13, 0xF0, 0x00, 0x1E, 0x00, 0xFF, 0xEF, 0x00, 
				 0x00, 0x19, 0xF0, 0x00, 0x16, 0x05, 0x04, 0x00, 
				 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 0x00, 
				 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 0x00, 
				 0x1F, 0x01, 0x00, 0x18, 0x07, 0x04, 0x15, 0xA0, 
				 0x00, 0xFF, 0x00, 0x09, 0xCE, 0x03, 0x06, 0x05, 
				 0x16, 0x80, 0x00, 0x2F, 0x00, 0x16, 0x84, 0x00, 
				 0x16, 0x00, 0x16, 0x88, 0x00, 0x53, 0x00, 0x1D, 
				 0x19, 0x00, 0x00, 0x00, 0xC3, 0x00, 0x00, 0x00, 
				 0x8F, 0x00, 0x00, 0x00, 0x8F, 0x00, 0x00, 0x00, 
				 0x83, 0x00, 0x00, 0x00, 0x97, 0x00, 0x00, 0x00, 
				 0x07, 0x00, 0x00, 0x00, 0x82, 0x00, 0x00, 0x00, 
				 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x60, 0x00, 0x00, 0x00, 
				 0x83, 0x00, 0x00, 0x00, 0x5F, 0x00, 0x00, 0x00, 
				 0xA0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x5F, 0x00, 0x00, 0x00, 0x82, 0x00, 0x00, 0x00, 
				 0xE3, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 
				 0x1D, 0x06, 0x00, 0x64, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0xF0, 0x00, 0x00, 0x00, 0x22, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x13, 0xEA, 0x00, 
				 0x1E, 0x00, 0x00, 0xC0, 0x00, 0x00, 0x1E, 0x01, 
				 0xA2, 0x14, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 
				 0xEA, 0x00, 0x12, 0x07, 0x04, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x14, 0x00, 0x00, 
				 0x00, 0x18, 0x07, 0x04, 0x16, 0x02, 0x04, 0x00, 
				 0x20, 0x16, 0xC0, 0x00, 0x00, 0x16, 0x17, 0x4C, 
				 0x00, 0x40, 0x00, 0x00, 0x00, 0x17, 0x6C, 0x00, 
				 0x32, 0x00, 0x00, 0x00, 0x16, 0xC0, 0x00, 0x00, 
				 0x14, 0x00, 0x16};

BYTE t5464_Mode_1152x864x16_3[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x13, 0xF0, 0x00, 0x1E, 0x00, 0xFF, 0xEF, 0x00, 
				 0x00, 0x19, 0xF0, 0x00, 0x16, 0x05, 0x04, 0x00, 
				 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 0x00, 
				 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 0x00, 
				 0x1F, 0x01, 0x00, 0x18, 0x07, 0x04, 0x15, 0xA0, 
				 0x00, 0xFF, 0x00, 0x09, 0xCE, 0x03, 0x06, 0x05, 
				 0x16, 0x80, 0x00, 0x2F, 0x00, 0x16, 0x84, 0x00, 
				 0x04, 0x00, 0x16, 0x88, 0x00, 0x11, 0x00, 0x1D, 
				 0x19, 0x00, 0x00, 0x00, 0xC0, 0x00, 0x00, 0x00, 
				 0x8F, 0x00, 0x00, 0x00, 0x8F, 0x00, 0x00, 0x00, 
				 0x80, 0x00, 0x00, 0x00, 0x97, 0x00, 0x00, 0x00, 
				 0x07, 0x00, 0x00, 0x00, 0x89, 0x00, 0x00, 0x00, 
				 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x60, 0x00, 0x00, 0x00, 
				 0x83, 0x00, 0x00, 0x00, 0x5F, 0x00, 0x00, 0x00, 
				 0xA0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x5F, 0x00, 0x00, 0x00, 0x89, 0x00, 0x00, 0x00, 
				 0xE3, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 
				 0x1D, 0x06, 0x00, 0x64, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0xF0, 0x00, 0x00, 0x00, 0x22, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x13, 0xEA, 0x00, 
				 0x1E, 0x00, 0x00, 0xC0, 0x00, 0x00, 0x1E, 0x01, 
				 0xA2, 0x14, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 
				 0xEA, 0x00, 0x12, 0x07, 0x04, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x14, 0x00, 0x00, 
				 0x00, 0x18, 0x07, 0x04, 0x16, 0x02, 0x04, 0x00, 
				 0x20, 0x16, 0xC0, 0x00, 0x00, 0x16, 0x17, 0x4C, 
				 0x00, 0x40, 0x00, 0x00, 0x00, 0x17, 0x6C, 0x00, 
				 0x32, 0x00, 0x00, 0x00, 0x16, 0xC0, 0x00, 0x00, 
				 0x14, 0x00, 0x16};

BYTE t5464_Mode_1280x960x16_1[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x13, 0xF0, 0x00, 0x1E, 0x00, 0xFF, 0xEF, 0x00, 
				 0x00, 0x19, 0xF0, 0x00, 0x16, 0x05, 0x04, 0x00, 
				 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 0x00, 
				 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 0x00, 
				 0x1F, 0x01, 0x00, 0x18, 0x07, 0x04, 0x15, 0xA0, 
				 0x00, 0xFF, 0x00, 0x09, 0xCE, 0x03, 0x06, 0x05, 
				 0x16, 0x80, 0x00, 0x2F, 0x00, 0x16, 0x84, 0x00, 
				 0x16, 0x00, 0x16, 0x88, 0x00, 0x53, 0x00, 0x1D, 
				 0x19, 0x00, 0x00, 0x00, 0xDC, 0x00, 0x00, 0x00, 
				 0x9F, 0x00, 0x00, 0x00, 0x9F, 0x00, 0x00, 0x00, 
				 0x9C, 0x00, 0x00, 0x00, 0xAB, 0x00, 0x00, 0x00, 
				 0x19, 0x00, 0x00, 0x00, 0xE6, 0x00, 0x00, 0x00, 
				 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0xC0, 0x00, 0x00, 0x00, 
				 0x83, 0x00, 0x00, 0x00, 0xBF, 0x00, 0x00, 0x00, 
				 0xA0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0xBF, 0x00, 0x00, 0x00, 0xE6, 0x00, 0x00, 0x00, 
				 0xE3, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 
				 0x1D, 0x06, 0x00, 0x64, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0xF0, 0x00, 0x00, 0x00, 0x22, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x13, 0xEA, 0x00, 
				 0x1E, 0x00, 0x00, 0xC0, 0x00, 0x00, 0x1E, 0x01, 
				 0xA2, 0x14, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 
				 0xEA, 0x00, 0x12, 0x07, 0x04, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x14, 0x00, 0x00, 
				 0x00, 0x18, 0x07, 0x04, 0x16, 0x02, 0x04, 0x00, 
				 0x20, 0x16, 0xC0, 0x00, 0x00, 0x16, 0x17, 0x4C, 
				 0x00, 0x40, 0x00, 0x00, 0x00, 0x17, 0x6C, 0x00, 
				 0x32, 0x00, 0x00, 0x00, 0x16, 0xC0, 0x00, 0x00, 
				 0x14, 0x00, 0x16};

BYTE t5464_Mode_1280x960x16_2[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x13, 0xF0, 0x00, 0x1E, 0x00, 0xFF, 0xEF, 0x00, 
				 0x00, 0x19, 0xF0, 0x00, 0x16, 0x05, 0x04, 0x00, 
				 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 0x00, 
				 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 0x00, 
				 0x1F, 0x01, 0x00, 0x18, 0x07, 0x04, 0x15, 0xA0, 
				 0x00, 0xFF, 0x00, 0x09, 0xCE, 0x03, 0x06, 0x05, 
				 0x16, 0x80, 0x00, 0x2F, 0x00, 0x16, 0x84, 0x00, 
				 0x0A, 0x00, 0x16, 0x88, 0x00, 0x2C, 0x00, 0x1D, 
				 0x19, 0x00, 0x00, 0x00, 0xCD, 0x00, 0x00, 0x00, 
				 0x9F, 0x00, 0x00, 0x00, 0x9F, 0x00, 0x00, 0x00, 
				 0x8D, 0x00, 0x00, 0x00, 0xA3, 0x00, 0x00, 0x00, 
				 0x15, 0x00, 0x00, 0x00, 0xE6, 0x00, 0x00, 0x00, 
				 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0xC0, 0x00, 0x00, 0x00, 
				 0x83, 0x00, 0x00, 0x00, 0xBF, 0x00, 0x00, 0x00, 
				 0xA0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0xBF, 0x00, 0x00, 0x00, 0xE6, 0x00, 0x00, 0x00, 
				 0xE3, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 
				 0x1D, 0x06, 0x00, 0x64, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0xF0, 0x00, 0x00, 0x00, 0x22, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x13, 0xEA, 0x00, 
				 0x1E, 0x00, 0x00, 0xC0, 0x00, 0x00, 0x1E, 0x01, 
				 0xA2, 0x14, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 
				 0xEA, 0x00, 0x12, 0x07, 0x04, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x14, 0x00, 0x00, 
				 0x00, 0x18, 0x07, 0x04, 0x16, 0x02, 0x04, 0x00, 
				 0x20, 0x16, 0xC0, 0x00, 0x00, 0x16, 0x17, 0x4C, 
				 0x00, 0x40, 0x00, 0x00, 0x00, 0x17, 0x6C, 0x00, 
				 0x32, 0x00, 0x00, 0x00, 0x16, 0xC0, 0x00, 0x00, 
				 0x14, 0x00, 0x16};

BYTE t5464_Mode_1280x960x16_3[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x13, 0xF0, 0x00, 0x1E, 0x00, 0xFF, 0xEF, 0x00, 
				 0x00, 0x19, 0xF0, 0x00, 0x16, 0x05, 0x04, 0x00, 
				 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 0x00, 
				 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 0x00, 
				 0x1F, 0x01, 0x00, 0x18, 0x07, 0x04, 0x15, 0xA0, 
				 0x00, 0xFF, 0x00, 0x09, 0xCE, 0x03, 0x06, 0x05, 
				 0x16, 0x80, 0x00, 0x2F, 0x00, 0x16, 0x84, 0x00, 
				 0x10, 0x00, 0x16, 0x88, 0x00, 0x53, 0x00, 0x1D, 
				 0x19, 0x00, 0x00, 0x00, 0xD3, 0x00, 0x00, 0x00, 
				 0x9F, 0x00, 0x00, 0x00, 0x9F, 0x00, 0x00, 0x00, 
				 0x93, 0x00, 0x00, 0x00, 0xA5, 0x00, 0x00, 0x00, 
				 0x19, 0x00, 0x00, 0x00, 0xF1, 0x00, 0x00, 0x00, 
				 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0xC0, 0x00, 0x00, 0x00, 
				 0x83, 0x00, 0x00, 0x00, 0xBF, 0x00, 0x00, 0x00, 
				 0xA0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0xBF, 0x00, 0x00, 0x00, 0xF1, 0x00, 0x00, 0x00, 
				 0xE3, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 
				 0x1D, 0x06, 0x00, 0x64, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0xF0, 0x00, 0x00, 0x00, 0x22, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x13, 0xEA, 0x00, 
				 0x1E, 0x00, 0x00, 0xC0, 0x00, 0x00, 0x1E, 0x01, 
				 0xA2, 0x14, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 
				 0xEA, 0x00, 0x12, 0x07, 0x04, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x14, 0x00, 0x00, 
				 0x00, 0x18, 0x07, 0x04, 0x13, 0xEA, 0x00, 0x1E, 
				 0x00, 0xC0, 0xFF, 0x00, 0x00, 0x1E, 0x01, 0x29, 
				 0x00, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 0xEA, 
				 0x00, 0x16, 0x02, 0x04, 0x00, 0x20, 0x16, 0xC0, 
				 0x00, 0x00, 0x16, 0x17, 0x4C, 0x00, 0x40, 0x00, 
				 0x00, 0x00, 0x17, 0x6C, 0x00, 0x32, 0x00, 0x00, 
				 0x00, 0x16, 0xC0, 0x00, 0x00, 0x14, 0x00, 0x02};

BYTE t5464_Mode_1280x1024x16_1[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x13, 0xF0, 0x00, 0x1E, 0x00, 0xFF, 0xEF, 0x00, 
				 0x00, 0x19, 0xF0, 0x00, 0x16, 0x05, 0x04, 0x00, 
				 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 0x00, 
				 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 0x00, 
				 0x1F, 0x01, 0x00, 0x18, 0x07, 0x04, 0x15, 0xA0, 
				 0x00, 0xFF, 0x00, 0x09, 0xCE, 0x03, 0x06, 0x05, 
				 0x16, 0x80, 0x00, 0x2F, 0x00, 0x16, 0x84, 0x00, 
				 0x04, 0x00, 0x16, 0x88, 0x00, 0x0B, 0x00, 0x1D, 
				 0x19, 0x00, 0x00, 0x00, 0xCF, 0x00, 0x00, 0x00, 
				 0x9F, 0x00, 0x00, 0x00, 0x9F, 0x00, 0x00, 0x00, 
				 0x93, 0x00, 0x00, 0x00, 0xA9, 0x00, 0x00, 0x00, 
				 0x13, 0x00, 0x00, 0x00, 0x14, 0x00, 0x00, 0x00, 
				 0xB2, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x83, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 
				 0xA0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x14, 0x00, 0x00, 0x00, 
				 0xE3, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 
				 0x1D, 0x06, 0x00, 0x64, 0x00, 0x67, 0x00, 0x00, 
				 0x00, 0x81, 0x00, 0x00, 0x00, 0x22, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x13, 0xEA, 0x00, 
				 0x1E, 0x00, 0x00, 0xC0, 0x00, 0x00, 0x1E, 0x01, 
				 0xA2, 0x14, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 
				 0xEA, 0x00, 0x12, 0x07, 0x04, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x14, 0x00, 0x00, 
				 0x00, 0x18, 0x07, 0x04, 0x16, 0x02, 0x04, 0x00, 
				 0x20, 0x16, 0xC0, 0x00, 0x00, 0x16, 0x17, 0x4C, 
				 0x00, 0x40, 0x00, 0x00, 0x00, 0x17, 0x6C, 0x00, 
				 0x32, 0x00, 0x00, 0x00, 0x16, 0xC0, 0x00, 0x00, 
				 0x14, 0x00, 0x16};

BYTE t5464_Mode_1280x1024x16_2[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x13, 0xF0, 0x00, 0x1E, 0x00, 0xFF, 0xEF, 0x00, 
				 0x00, 0x19, 0xF0, 0x00, 0x16, 0x05, 0x04, 0x00, 
				 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 0x00, 
				 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 0x00, 
				 0x1F, 0x01, 0x00, 0x18, 0x07, 0x04, 0x15, 0xA0, 
				 0x00, 0xFF, 0x00, 0x09, 0xCE, 0x03, 0x06, 0x05, 
				 0x16, 0x80, 0x00, 0x2F, 0x00, 0x16, 0x84, 0x00, 
				 0x16, 0x00, 0x16, 0x88, 0x00, 0x53, 0x00, 0x1D, 
				 0x19, 0x00, 0x00, 0x00, 0xCE, 0x00, 0x00, 0x00, 
				 0x9F, 0x00, 0x00, 0x00, 0x9F, 0x00, 0x00, 0x00, 
				 0x91, 0x00, 0x00, 0x00, 0xA7, 0x00, 0x00, 0x00, 
				 0x15, 0x00, 0x00, 0x00, 0x28, 0x00, 0x00, 0x00, 
				 0x5A, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x83, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 
				 0xA0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0xFF, 0x00, 0x00, 0x00, 0x24, 0x00, 0x00, 0x00, 
				 0xE3, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 
				 0x1D, 0x06, 0x00, 0x64, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x30, 0x00, 0x00, 0x00, 0x22, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x09, 0x00, 0x00, 0x00, 0x13, 0xEA, 0x00, 
				 0x1E, 0x00, 0x00, 0xC0, 0x00, 0x00, 0x1E, 0x01, 
				 0xA2, 0x14, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 
				 0xEA, 0x00, 0x12, 0x07, 0x04, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x14, 0x00, 0x00, 
				 0x00, 0x18, 0x07, 0x04, 0x16, 0x02, 0x04, 0x00, 
				 0x20, 0x16, 0xC0, 0x00, 0x00, 0x16, 0x17, 0x4C, 
				 0x00, 0x40, 0x00, 0x00, 0x00, 0x17, 0x6C, 0x00, 
				 0x32, 0x00, 0x00, 0x00, 0x16, 0xC0, 0x00, 0x00, 
				 0x14, 0x00, 0x16};

BYTE t5464_Mode_1280x1024x16_3[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x13, 0xF0, 0x00, 0x1E, 0x00, 0xFF, 0xEF, 0x00, 
				 0x00, 0x19, 0xF0, 0x00, 0x16, 0x05, 0x04, 0x00, 
				 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 0x00, 
				 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 0x00, 
				 0x1F, 0x01, 0x00, 0x18, 0x07, 0x04, 0x15, 0xA0, 
				 0x00, 0xFF, 0x00, 0x09, 0xCE, 0x03, 0x06, 0x05, 
				 0x16, 0x80, 0x00, 0x2F, 0x00, 0x16, 0x84, 0x00, 
				 0x0C, 0x00, 0x16, 0x88, 0x00, 0x35, 0x00, 0x1D, 
				 0x19, 0x00, 0x00, 0x00, 0xCB, 0x00, 0x00, 0x00, 
				 0x9F, 0x00, 0x00, 0x00, 0x9F, 0x00, 0x00, 0x00, 
				 0x89, 0x00, 0x00, 0x00, 0xA6, 0x00, 0x00, 0x00, 
				 0x1C, 0x00, 0x00, 0x00, 0x2A, 0x00, 0x00, 0x00, 
				 0x5A, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00, 
				 0x8F, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 
				 0xA0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0xFF, 0x00, 0x00, 0x00, 0x24, 0x00, 0x00, 0x00, 
				 0xE3, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 
				 0x1D, 0x06, 0x00, 0x64, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x30, 0x00, 0x00, 0x00, 0x22, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x09, 0x00, 0x00, 0x00, 0x13, 0xEA, 0x00, 
				 0x1E, 0x00, 0x00, 0xC0, 0x00, 0x00, 0x1E, 0x01, 
				 0xA2, 0x14, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 
				 0xEA, 0x00, 0x12, 0x07, 0x04, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x14, 0x00, 0x00, 
				 0x00, 0x18, 0x07, 0x04, 0x16, 0x02, 0x04, 0x00, 
				 0x20, 0x16, 0xC0, 0x00, 0x00, 0x16, 0x17, 0x4C, 
				 0x00, 0x40, 0x00, 0x00, 0x00, 0x17, 0x6C, 0x00, 
				 0x32, 0x00, 0x00, 0x00, 0x16, 0xC0, 0x00, 0x00, 
				 0x14, 0x00, 0x16};

BYTE t5464_Mode_1280x1024x16_4[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x13, 0xF0, 0x00, 0x1E, 0x00, 0xFF, 0xEF, 0x00, 
				 0x00, 0x19, 0xF0, 0x00, 0x16, 0x05, 0x04, 0x00, 
				 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 0x00, 
				 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 0x00, 
				 0x1F, 0x01, 0x00, 0x18, 0x07, 0x04, 0x15, 0xA0, 
				 0x00, 0xFF, 0x00, 0x09, 0xCE, 0x03, 0x06, 0x05, 
				 0x16, 0x80, 0x00, 0x2F, 0x00, 0x16, 0x84, 0x00, 
				 0x0E, 0x00, 0x16, 0x88, 0x00, 0x42, 0x00, 0x1D, 
				 0x19, 0x00, 0x00, 0x00, 0xCE, 0x00, 0x00, 0x00, 
				 0x9F, 0x00, 0x00, 0x00, 0x9F, 0x00, 0x00, 0x00, 
				 0x91, 0x00, 0x00, 0x00, 0xA3, 0x00, 0x00, 0x00, 
				 0x15, 0x00, 0x00, 0x00, 0x28, 0x00, 0x00, 0x00, 
				 0x5A, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x83, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 
				 0xA0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0xFF, 0x00, 0x00, 0x00, 0x24, 0x00, 0x00, 0x00, 
				 0xE3, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 
				 0x1D, 0x06, 0x00, 0x64, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x30, 0x00, 0x00, 0x00, 0x22, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x09, 0x00, 0x00, 0x00, 0x13, 0xEA, 0x00, 
				 0x1E, 0x00, 0x00, 0xC0, 0x00, 0x00, 0x1E, 0x01, 
				 0xA2, 0x14, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 
				 0xEA, 0x00, 0x12, 0x07, 0x04, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x14, 0x00, 0x00, 
				 0x00, 0x18, 0x07, 0x04, 0x16, 0x02, 0x04, 0x00, 
				 0x20, 0x16, 0xC0, 0x00, 0x00, 0x16, 0x17, 0x4C, 
				 0x00, 0x40, 0x00, 0x00, 0x00, 0x17, 0x6C, 0x00, 
				 0x32, 0x00, 0x00, 0x00, 0x16, 0xC0, 0x00, 0x00, 
				 0x14, 0x00, 0x16};

BYTE t5464_Mode_640x400x24_1[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x13, 0xF0, 0x00, 0x1E, 0x00, 0xFF, 0xEF, 0x00, 
				 0x00, 0x19, 0xF0, 0x00, 0x16, 0x05, 0x04, 0x00, 
				 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 0x00, 
				 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 0x00, 
				 0x1F, 0x01, 0x00, 0x18, 0x07, 0x04, 0x15, 0xA0, 
				 0x00, 0xFF, 0x00, 0x09, 0xCE, 0x03, 0x06, 0x05, 
				 0x16, 0x80, 0x00, 0x6F, 0x00, 0x16, 0x84, 0x00, 
				 0x3F, 0x00, 0x16, 0x88, 0x00, 0x6D, 0x00, 0x1D, 
				 0x19, 0x00, 0x00, 0x00, 0x5F, 0x00, 0x00, 0x00, 
				 0x4F, 0x00, 0x00, 0x00, 0x50, 0x00, 0x00, 0x00, 
				 0x82, 0x00, 0x00, 0x00, 0x53, 0x00, 0x00, 0x00, 
				 0x9F, 0x00, 0x00, 0x00, 0xBF, 0x00, 0x00, 0x00, 
				 0x1F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0xA1, 0x00, 0x00, 0x00, 
				 0xA3, 0x00, 0x00, 0x00, 0x8F, 0x00, 0x00, 0x00, 
				 0x50, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x96, 0x00, 0x00, 0x00, 0xB9, 0x00, 0x00, 0x00, 
				 0xE3, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 
				 0x1D, 0x06, 0x00, 0x64, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x50, 0x00, 0x00, 0x00, 0x22, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x13, 0xEA, 0x00, 
				 0x1E, 0x00, 0x00, 0xC0, 0x00, 0x00, 0x1E, 0x01, 
				 0xD2, 0x08, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 
				 0xEA, 0x00, 0x12, 0x07, 0x04, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x08, 0x00, 0x00, 
				 0x00, 0x18, 0x07, 0x04, 0x13, 0xEA, 0x00, 0x1E, 
				 0x00, 0xC0, 0xFF, 0x00, 0x00, 0x1E, 0x01, 0x0D, 
				 0x00, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 0xEA, 
				 0x00, 0x16, 0x02, 0x04, 0x00, 0x48, 0x16, 0xC0, 
				 0x00, 0x00, 0x24, 0x17, 0x4C, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x17, 0x6C, 0x00, 0x32, 0x00, 0x00, 
				 0x00, 0x00, 0xC0};

BYTE t5464_Mode_640x400x24_2[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x13, 0xF0, 0x00, 0x1E, 0x00, 0xFF, 0xEF, 0x00, 
				 0x00, 0x19, 0xF0, 0x00, 0x16, 0x05, 0x04, 0x00, 
				 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 0x00, 
				 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 0x00, 
				 0x1F, 0x01, 0x00, 0x18, 0x07, 0x04, 0x15, 0xA0, 
				 0x00, 0xFF, 0x00, 0x09, 0xCE, 0x03, 0x06, 0x05, 
				 0x16, 0x80, 0x00, 0x6F, 0x00, 0x16, 0x84, 0x00, 
				 0x0B, 0x00, 0x16, 0x88, 0x00, 0x16, 0x00, 0x1D, 
				 0x19, 0x00, 0x00, 0x00, 0x63, 0x00, 0x00, 0x00, 
				 0x4F, 0x00, 0x00, 0x00, 0x4F, 0x00, 0x00, 0x00, 
				 0x83, 0x00, 0x00, 0x00, 0x53, 0x00, 0x00, 0x00, 
				 0x97, 0x00, 0x00, 0x00, 0xBB, 0x00, 0x00, 0x00, 
				 0x1F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x90, 0x00, 0x00, 0x00, 
				 0x83, 0x00, 0x00, 0x00, 0x8F, 0x00, 0x00, 0x00, 
				 0x50, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x8F, 0x00, 0x00, 0x00, 0xBB, 0x00, 0x00, 0x00, 
				 0xE3, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 
				 0x1D, 0x06, 0x00, 0x64, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x50, 0x00, 0x00, 0x00, 0x22, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x13, 0xEA, 0x00, 
				 0x1E, 0x00, 0x00, 0xC0, 0x00, 0x00, 0x1E, 0x01, 
				 0xD2, 0x08, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 
				 0xEA, 0x00, 0x12, 0x07, 0x04, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x08, 0x00, 0x00, 
				 0x00, 0x18, 0x07, 0x04, 0x13, 0xEA, 0x00, 0x1E, 
				 0x00, 0xC0, 0xFF, 0x00, 0x00, 0x1E, 0x01, 0x0D, 
				 0x00, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 0xEA, 
				 0x00, 0x16, 0x02, 0x04, 0x00, 0x48, 0x16, 0xC0, 
				 0x00, 0x00, 0x24, 0x17, 0x4C, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x17, 0x6C, 0x00, 0x32, 0x00, 0x00, 
				 0x00, 0x00, 0xC0};

BYTE t5464_Mode_640x400x24_3[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x13, 0xF0, 0x00, 0x1E, 0x00, 0xFF, 0xEF, 0x00, 
				 0x00, 0x19, 0xF0, 0x00, 0x16, 0x05, 0x04, 0x00, 
				 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 0x00, 
				 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 0x00, 
				 0x1F, 0x01, 0x00, 0x18, 0x07, 0x04, 0x15, 0xA0, 
				 0x00, 0xFF, 0x00, 0x09, 0xCE, 0x03, 0x06, 0x05, 
				 0x16, 0x80, 0x00, 0x6F, 0x00, 0x16, 0x84, 0x00, 
				 0x0B, 0x00, 0x16, 0x88, 0x00, 0x16, 0x00, 0x1D, 
				 0x19, 0x00, 0x00, 0x00, 0x63, 0x00, 0x00, 0x00, 
				 0x4F, 0x00, 0x00, 0x00, 0x4F, 0x00, 0x00, 0x00, 
				 0x83, 0x00, 0x00, 0x00, 0x53, 0x00, 0x00, 0x00, 
				 0x97, 0x00, 0x00, 0x00, 0xBB, 0x00, 0x00, 0x00, 
				 0x1F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x90, 0x00, 0x00, 0x00, 
				 0x83, 0x00, 0x00, 0x00, 0x8F, 0x00, 0x00, 0x00, 
				 0x50, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x8F, 0x00, 0x00, 0x00, 0xBB, 0x00, 0x00, 0x00, 
				 0xE3, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 
				 0x1D, 0x06, 0x00, 0x64, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x50, 0x00, 0x00, 0x00, 0x22, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x16, 0x84, 0x00, 
				 0x32, 0x00, 0x16, 0x88, 0x00, 0x61, 0x00, 0x13, 
				 0xEA, 0x00, 0x1E, 0x00, 0x00, 0xC0, 0x00, 0x00, 
				 0x1E, 0x01, 0xD2, 0x08, 0x00, 0x00, 0x1F, 0x01, 
				 0x00, 0x19, 0xEA, 0x00, 0x12, 0x07, 0x04, 0x1E, 
				 0x00, 0xC0, 0x00, 0x00, 0x00, 0x1E, 0x01, 0x08, 
				 0x00, 0x00, 0x00, 0x18, 0x07, 0x04, 0x13, 0xEA, 
				 0x00, 0x1E, 0x00, 0xC0, 0xFF, 0x00, 0x00, 0x1E, 
				 0x01, 0x1E, 0x00, 0x00, 0x00, 0x1F, 0x01, 0x00, 
				 0x19, 0xEA, 0x00, 0x16, 0x02, 0x04, 0x00, 0x48, 
				 0x16, 0xC0, 0x00, 0x00, 0x24, 0x17, 0x4C, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x17, 0x6C, 0x00, 0x32, 
				 0x00, 0x00, 0x00, 0x00, 0xC0};

BYTE t5464_Mode_640x480x24_1[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x13, 0xF0, 0x00, 0x1E, 0x00, 0xFF, 0xEF, 0x00, 
				 0x00, 0x19, 0xF0, 0x00, 0x16, 0x05, 0x04, 0x00, 
				 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 0x00, 
				 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 0x00, 
				 0x1F, 0x01, 0x00, 0x18, 0x07, 0x04, 0x15, 0xA0, 
				 0x00, 0xFF, 0x00, 0x09, 0xCE, 0x03, 0x06, 0x05, 
				 0x16, 0x80, 0x00, 0xEF, 0x00, 0x16, 0x84, 0x00, 
				 0x3F, 0x00, 0x16, 0x88, 0x00, 0x6D, 0x00, 0x1D, 
				 0x19, 0x00, 0x00, 0x00, 0x5F, 0x00, 0x00, 0x00, 
				 0x4F, 0x00, 0x00, 0x00, 0x50, 0x00, 0x00, 0x00, 
				 0x9E, 0x00, 0x00, 0x00, 0x54, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x0B, 0x00, 0x00, 0x00, 
				 0x3E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0xE9, 0x00, 0x00, 0x00, 
				 0x8B, 0x00, 0x00, 0x00, 0xDF, 0x00, 0x00, 0x00, 
				 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0xE7, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 
				 0xE3, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 
				 0x1D, 0x06, 0x00, 0x64, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x90, 0x00, 0x00, 0x00, 0x22, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x13, 0xEA, 0x00, 
				 0x1E, 0x00, 0x00, 0xC0, 0x00, 0x00, 0x1E, 0x01, 
				 0xD2, 0x08, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 
				 0xEA, 0x00, 0x12, 0x07, 0x04, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x08, 0x00, 0x00, 
				 0x00, 0x18, 0x07, 0x04, 0x13, 0xEA, 0x00, 0x1E, 
				 0x00, 0xC0, 0xFF, 0x00, 0x00, 0x1E, 0x01, 0x0D, 
				 0x00, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 0xEA, 
				 0x00, 0x16, 0x02, 0x04, 0x00, 0x48, 0x16, 0xC0, 
				 0x00, 0x00, 0x24, 0x17, 0x4C, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x17, 0x6C, 0x00, 0x32, 0x00, 0x00, 
				 0x00, 0x00, 0x00};

BYTE t5464_Mode_640x480x24_2[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x13, 0xF0, 0x00, 0x1E, 0x00, 0xFF, 0xEF, 0x00, 
				 0x00, 0x19, 0xF0, 0x00, 0x16, 0x05, 0x04, 0x00, 
				 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 0x00, 
				 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 0x00, 
				 0x1F, 0x01, 0x00, 0x18, 0x07, 0x04, 0x15, 0xA0, 
				 0x00, 0xFF, 0x00, 0x09, 0xCE, 0x03, 0x06, 0x05, 
				 0x16, 0x80, 0x00, 0xEF, 0x00, 0x16, 0x84, 0x00, 
				 0x0A, 0x00, 0x16, 0x88, 0x00, 0x0B, 0x00, 0x1D, 
				 0x19, 0x00, 0x00, 0x00, 0x63, 0x00, 0x00, 0x00, 
				 0x4F, 0x00, 0x00, 0x00, 0x50, 0x00, 0x00, 0x00, 
				 0x82, 0x00, 0x00, 0x00, 0x54, 0x00, 0x00, 0x00, 
				 0x99, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 
				 0x3E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0xE8, 0x00, 0x00, 0x00, 
				 0x8B, 0x00, 0x00, 0x00, 0xDF, 0x00, 0x00, 0x00, 
				 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0xE7, 0x00, 0x00, 0x00, 0xF3, 0x00, 0x00, 0x00, 
				 0xE3, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 
				 0x1D, 0x06, 0x00, 0x64, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x50, 0x00, 0x00, 0x00, 0x22, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x13, 0xEA, 0x00, 
				 0x1E, 0x00, 0x00, 0xC0, 0x00, 0x00, 0x1E, 0x01, 
				 0xD2, 0x08, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 
				 0xEA, 0x00, 0x12, 0x07, 0x04, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x08, 0x00, 0x00, 
				 0x00, 0x18, 0x07, 0x04, 0x13, 0xEA, 0x00, 0x1E, 
				 0x00, 0xC0, 0xFF, 0x00, 0x00, 0x1E, 0x01, 0x0D, 
				 0x00, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 0xEA, 
				 0x00, 0x16, 0x02, 0x04, 0x00, 0x48, 0x16, 0xC0, 
				 0x00, 0x00, 0x24, 0x17, 0x4C, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x17, 0x6C, 0x00, 0x32, 0x00, 0x00, 
				 0x00, 0x00, 0x00};

BYTE t5464_Mode_640x480x24_3[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x13, 0xF0, 0x00, 0x1E, 0x00, 0xFF, 0xEF, 0x00, 
				 0x00, 0x19, 0xF0, 0x00, 0x16, 0x05, 0x04, 0x00, 
				 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 0x00, 
				 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 0x00, 
				 0x1F, 0x01, 0x00, 0x18, 0x07, 0x04, 0x15, 0xA0, 
				 0x00, 0xFF, 0x00, 0x09, 0xCE, 0x03, 0x06, 0x05, 
				 0x16, 0x80, 0x00, 0xEF, 0x00, 0x16, 0x84, 0x00, 
				 0x0A, 0x00, 0x16, 0x88, 0x00, 0x0B, 0x00, 0x1D, 
				 0x19, 0x00, 0x00, 0x00, 0x64, 0x00, 0x00, 0x00, 
				 0x4F, 0x00, 0x00, 0x00, 0x50, 0x00, 0x00, 0x00, 
				 0x82, 0x00, 0x00, 0x00, 0x54, 0x00, 0x00, 0x00, 
				 0x9C, 0x00, 0x00, 0x00, 0xF2, 0x00, 0x00, 0x00, 
				 0x1F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0xE0, 0x00, 0x00, 0x00, 
				 0x83, 0x00, 0x00, 0x00, 0xDF, 0x00, 0x00, 0x00, 
				 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0xDF, 0x00, 0x00, 0x00, 0xF2, 0x00, 0x00, 0x00, 
				 0xE3, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 
				 0x1D, 0x06, 0x00, 0x64, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x50, 0x00, 0x00, 0x00, 0x22, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x13, 0xEA, 0x00, 
				 0x1E, 0x00, 0x00, 0xC0, 0x00, 0x00, 0x1E, 0x01, 
				 0xD2, 0x08, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 
				 0xEA, 0x00, 0x12, 0x07, 0x04, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x08, 0x00, 0x00, 
				 0x00, 0x18, 0x07, 0x04, 0x13, 0xEA, 0x00, 0x1E, 
				 0x00, 0xC0, 0xFF, 0x00, 0x00, 0x1E, 0x01, 0x0D, 
				 0x00, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 0xEA, 
				 0x00, 0x16, 0x02, 0x04, 0x00, 0x48, 0x16, 0xC0, 
				 0x00, 0x00, 0x24, 0x17, 0x4C, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x17, 0x6C, 0x00, 0x32, 0x00, 0x00, 
				 0x00, 0x00, 0x00};

BYTE t5464_Mode_640x480x24_4[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x13, 0xF0, 0x00, 0x1E, 0x00, 0xFF, 0xEF, 0x00, 
				 0x00, 0x19, 0xF0, 0x00, 0x16, 0x05, 0x04, 0x00, 
				 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 0x00, 
				 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 0x00, 
				 0x1F, 0x01, 0x00, 0x18, 0x07, 0x04, 0x15, 0xA0, 
				 0x00, 0xFF, 0x00, 0x09, 0xCE, 0x03, 0x06, 0x05, 
				 0x16, 0x80, 0x00, 0xEF, 0x00, 0x16, 0x84, 0x00, 
				 0x33, 0x00, 0x16, 0x88, 0x00, 0x7E, 0x00, 0x1D, 
				 0x19, 0x00, 0x00, 0x00, 0x63, 0x00, 0x00, 0x00, 
				 0x4F, 0x00, 0x00, 0x00, 0x50, 0x00, 0x00, 0x00, 
				 0x82, 0x00, 0x00, 0x00, 0x55, 0x00, 0x00, 0x00, 
				 0x9B, 0x00, 0x00, 0x00, 0xFB, 0x00, 0x00, 0x00, 
				 0x1F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0xE0, 0x00, 0x00, 0x00, 
				 0x83, 0x00, 0x00, 0x00, 0xDF, 0x00, 0x00, 0x00, 
				 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0xDF, 0x00, 0x00, 0x00, 0xF9, 0x00, 0x00, 0x00, 
				 0xE3, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 
				 0x1D, 0x06, 0x00, 0x64, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x50, 0x00, 0x00, 0x00, 0x22, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x13, 0xEA, 0x00, 
				 0x1E, 0x00, 0x00, 0xC0, 0x00, 0x00, 0x1E, 0x01, 
				 0xD2, 0x08, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 
				 0xEA, 0x00, 0x12, 0x07, 0x04, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x08, 0x00, 0x00, 
				 0x00, 0x18, 0x07, 0x04, 0x13, 0xEA, 0x00, 0x1E, 
				 0x00, 0xC0, 0xFF, 0x00, 0x00, 0x1E, 0x01, 0x0D, 
				 0x00, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 0xEA, 
				 0x00, 0x16, 0x02, 0x04, 0x00, 0x48, 0x16, 0xC0, 
				 0x00, 0x00, 0x24, 0x17, 0x4C, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x17, 0x6C, 0x00, 0x32, 0x00, 0x00, 
				 0x00, 0x00, 0x00};

BYTE t5464_Mode_800x600x24_1[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x13, 0xF0, 0x00, 0x1E, 0x00, 0xFF, 0xEF, 0x00, 
				 0x00, 0x19, 0xF0, 0x00, 0x16, 0x05, 0x04, 0x00, 
				 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 0x00, 
				 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 0x00, 
				 0x1F, 0x01, 0x00, 0x18, 0x07, 0x04, 0x15, 0xA0, 
				 0x00, 0xFF, 0x00, 0x09, 0xCE, 0x03, 0x06, 0x05, 
				 0x16, 0x80, 0x00, 0x2F, 0x00, 0x16, 0x84, 0x00, 
				 0x3E, 0x00, 0x16, 0x88, 0x00, 0x4E, 0x00, 0x1D, 
				 0x19, 0x00, 0x00, 0x00, 0x7B, 0x00, 0x00, 0x00, 
				 0x63, 0x00, 0x00, 0x00, 0x64, 0x00, 0x00, 0x00, 
				 0x9B, 0x00, 0x00, 0x00, 0x68, 0x00, 0x00, 0x00, 
				 0x91, 0x00, 0x00, 0x00, 0x6F, 0x00, 0x00, 0x00, 
				 0xF0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x58, 0x00, 0x00, 0x00, 
				 0x8A, 0x00, 0x00, 0x00, 0x57, 0x00, 0x00, 0x00, 
				 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x58, 0x00, 0x00, 0x00, 0x6F, 0x00, 0x00, 0x00, 
				 0xE3, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 
				 0x1D, 0x06, 0x00, 0x64, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x90, 0x00, 0x00, 0x00, 0x22, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x13, 0xEA, 0x00, 
				 0x1E, 0x00, 0x00, 0xC0, 0x00, 0x00, 0x1E, 0x01, 
				 0xD6, 0x0A, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 
				 0xEA, 0x00, 0x12, 0x07, 0x04, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x0A, 0x00, 0x00, 
				 0x00, 0x18, 0x07, 0x04, 0x13, 0xEA, 0x00, 0x1E, 
				 0x00, 0xC0, 0xFF, 0x00, 0x00, 0x1E, 0x01, 0x19, 
				 0x00, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 0xEA, 
				 0x00, 0x16, 0x02, 0x04, 0x00, 0x48, 0x16, 0xC0, 
				 0x00, 0x00, 0x24, 0x17, 0x4C, 0x00, 0x40, 0x00, 
				 0x00, 0x00, 0x17, 0x6C, 0x00, 0x32, 0x00, 0x00, 
				 0x00, 0x00, 0x00};

BYTE t5464_Mode_800x600x24_2[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x13, 0xF0, 0x00, 0x1E, 0x00, 0xFF, 0xEF, 0x00, 
				 0x00, 0x19, 0xF0, 0x00, 0x16, 0x05, 0x04, 0x00, 
				 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 0x00, 
				 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 0x00, 
				 0x1F, 0x01, 0x00, 0x18, 0x07, 0x04, 0x15, 0xA0, 
				 0x00, 0xFF, 0x00, 0x09, 0xCE, 0x03, 0x06, 0x05, 
				 0x16, 0x80, 0x00, 0x2F, 0x00, 0x16, 0x84, 0x00, 
				 0x3A, 0x00, 0x16, 0x88, 0x00, 0x51, 0x00, 0x1D, 
				 0x19, 0x00, 0x00, 0x00, 0x7F, 0x00, 0x00, 0x00, 
				 0x63, 0x00, 0x00, 0x00, 0x64, 0x00, 0x00, 0x00, 
				 0x9F, 0x00, 0x00, 0x00, 0x69, 0x00, 0x00, 0x00, 
				 0x99, 0x00, 0x00, 0x00, 0x72, 0x00, 0x00, 0x00, 
				 0xF0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x58, 0x00, 0x00, 0x00, 
				 0x8C, 0x00, 0x00, 0x00, 0x57, 0x00, 0x00, 0x00, 
				 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x58, 0x00, 0x00, 0x00, 0x72, 0x00, 0x00, 0x00, 
				 0xE3, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 
				 0x1D, 0x06, 0x00, 0x64, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x90, 0x00, 0x00, 0x00, 0x22, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x13, 0xEA, 0x00, 
				 0x1E, 0x00, 0x00, 0xC0, 0x00, 0x00, 0x1E, 0x01, 
				 0xD6, 0x0A, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 
				 0xEA, 0x00, 0x12, 0x07, 0x04, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x0A, 0x00, 0x00, 
				 0x00, 0x18, 0x07, 0x04, 0x13, 0xEA, 0x00, 0x1E, 
				 0x00, 0xC0, 0xFF, 0x00, 0x00, 0x1E, 0x01, 0x19, 
				 0x00, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 0xEA, 
				 0x00, 0x16, 0x02, 0x04, 0x00, 0x48, 0x16, 0xC0, 
				 0x00, 0x00, 0x24, 0x17, 0x4C, 0x00, 0x40, 0x00, 
				 0x00, 0x00, 0x17, 0x6C, 0x00, 0x32, 0x00, 0x00, 
				 0x00, 0x00, 0x00};

BYTE t5464_Mode_800x600x24_3[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x13, 0xF0, 0x00, 0x1E, 0x00, 0xFF, 0xEF, 0x00, 
				 0x00, 0x19, 0xF0, 0x00, 0x16, 0x05, 0x04, 0x00, 
				 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 0x00, 
				 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 0x00, 
				 0x1F, 0x01, 0x00, 0x18, 0x07, 0x04, 0x15, 0xA0, 
				 0x00, 0xFF, 0x00, 0x09, 0xCE, 0x03, 0x06, 0x05, 
				 0x16, 0x80, 0x00, 0x2F, 0x00, 0x16, 0x84, 0x00, 
				 0x3E, 0x00, 0x16, 0x88, 0x00, 0x6C, 0x00, 0x1D, 
				 0x19, 0x00, 0x00, 0x00, 0x7D, 0x00, 0x00, 0x00, 
				 0x63, 0x00, 0x00, 0x00, 0x64, 0x00, 0x00, 0x00, 
				 0x9D, 0x00, 0x00, 0x00, 0x6C, 0x00, 0x00, 0x00, 
				 0x9B, 0x00, 0x00, 0x00, 0x97, 0x00, 0x00, 0x00, 
				 0xF0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x7B, 0x00, 0x00, 0x00, 
				 0x81, 0x00, 0x00, 0x00, 0x57, 0x00, 0x00, 0x00, 
				 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x5F, 0x00, 0x00, 0x00, 0x97, 0x00, 0x00, 0x00, 
				 0xE3, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 
				 0x1D, 0x06, 0x00, 0x64, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x90, 0x00, 0x00, 0x00, 0x22, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x13, 0xEA, 0x00, 
				 0x1E, 0x00, 0x00, 0xC0, 0x00, 0x00, 0x1E, 0x01, 
				 0xD6, 0x0A, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 
				 0xEA, 0x00, 0x12, 0x07, 0x04, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x0A, 0x00, 0x00, 
				 0x00, 0x18, 0x07, 0x04, 0x13, 0xEA, 0x00, 0x1E, 
				 0x00, 0xC0, 0xFF, 0x00, 0x00, 0x1E, 0x01, 0x19, 
				 0x00, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 0xEA, 
				 0x00, 0x16, 0x02, 0x04, 0x00, 0x48, 0x16, 0xC0, 
				 0x00, 0x00, 0x24, 0x17, 0x4C, 0x00, 0x40, 0x00, 
				 0x00, 0x00, 0x17, 0x6C, 0x00, 0x32, 0x00, 0x00, 
				 0x00, 0x00, 0x00};

BYTE t5464_Mode_800x600x24_4[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x13, 0xF0, 0x00, 0x1E, 0x00, 0xFF, 0xEF, 0x00, 
				 0x00, 0x19, 0xF0, 0x00, 0x16, 0x05, 0x04, 0x00, 
				 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 0x00, 
				 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 0x00, 
				 0x1F, 0x01, 0x00, 0x18, 0x07, 0x04, 0x15, 0xA0, 
				 0x00, 0xFF, 0x00, 0x09, 0xCE, 0x03, 0x06, 0x05, 
				 0x16, 0x80, 0x00, 0x2F, 0x00, 0x16, 0x84, 0x00, 
				 0x30, 0x00, 0x16, 0x88, 0x00, 0x53, 0x00, 0x1D, 
				 0x19, 0x00, 0x00, 0x00, 0x7F, 0x00, 0x00, 0x00, 
				 0x63, 0x00, 0x00, 0x00, 0x64, 0x00, 0x00, 0x00, 
				 0x9F, 0x00, 0x00, 0x00, 0x67, 0x00, 0x00, 0x00, 
				 0x91, 0x00, 0x00, 0x00, 0x6F, 0x00, 0x00, 0x00, 
				 0xF0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x58, 0x00, 0x00, 0x00, 
				 0x8B, 0x00, 0x00, 0x00, 0x57, 0x00, 0x00, 0x00, 
				 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x57, 0x00, 0x00, 0x00, 0x6F, 0x00, 0x00, 0x00, 
				 0xE3, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 
				 0x1D, 0x06, 0x00, 0x64, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x90, 0x00, 0x00, 0x00, 0x22, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x13, 0xEA, 0x00, 
				 0x1E, 0x00, 0x00, 0xC0, 0x00, 0x00, 0x1E, 0x01, 
				 0xD6, 0x0A, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 
				 0xEA, 0x00, 0x12, 0x07, 0x04, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x0A, 0x00, 0x00, 
				 0x00, 0x18, 0x07, 0x04, 0x13, 0xEA, 0x00, 0x1E, 
				 0x00, 0xC0, 0xFF, 0x00, 0x00, 0x1E, 0x01, 0x19, 
				 0x00, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 0xEA, 
				 0x00, 0x16, 0x02, 0x04, 0x00, 0x48, 0x16, 0xC0, 
				 0x00, 0x00, 0x24, 0x17, 0x4C, 0x00, 0x40, 0x00, 
				 0x00, 0x00, 0x17, 0x6C, 0x00, 0x32, 0x00, 0x00, 
				 0x00, 0x00, 0x00};

BYTE t5464_Mode_800x600x24_5[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x13, 0xF0, 0x00, 0x1E, 0x00, 0xFF, 0xEF, 0x00, 
				 0x00, 0x19, 0xF0, 0x00, 0x16, 0x05, 0x04, 0x00, 
				 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 0x00, 
				 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 0x00, 
				 0x1F, 0x01, 0x00, 0x18, 0x07, 0x04, 0x15, 0xA0, 
				 0x00, 0xFF, 0x00, 0x09, 0xCE, 0x03, 0x06, 0x05, 
				 0x16, 0x80, 0x00, 0x2F, 0x00, 0x16, 0x84, 0x00, 
				 0x1C, 0x00, 0x16, 0x88, 0x00, 0x37, 0x00, 0x1D, 
				 0x19, 0x00, 0x00, 0x00, 0x7E, 0x00, 0x00, 0x00, 
				 0x63, 0x00, 0x00, 0x00, 0x64, 0x00, 0x00, 0x00, 
				 0x9E, 0x00, 0x00, 0x00, 0x69, 0x00, 0x00, 0x00, 
				 0x91, 0x00, 0x00, 0x00, 0x75, 0x00, 0x00, 0x00, 
				 0xF0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x58, 0x00, 0x00, 0x00, 
				 0x8B, 0x00, 0x00, 0x00, 0x57, 0x00, 0x00, 0x00, 
				 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x57, 0x00, 0x00, 0x00, 0x75, 0x00, 0x00, 0x00, 
				 0xE3, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 
				 0x1D, 0x06, 0x00, 0x64, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x90, 0x00, 0x00, 0x00, 0x22, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x13, 0xEA, 0x00, 
				 0x1E, 0x00, 0x00, 0xC0, 0x00, 0x00, 0x1E, 0x01, 
				 0xD6, 0x0A, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 
				 0xEA, 0x00, 0x12, 0x07, 0x04, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x0A, 0x00, 0x00, 
				 0x00, 0x18, 0x07, 0x04, 0x13, 0xEA, 0x00, 0x1E, 
				 0x00, 0xC0, 0xFF, 0x00, 0x00, 0x1E, 0x01, 0x19, 
				 0x00, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 0xEA, 
				 0x00, 0x16, 0x02, 0x04, 0x00, 0x48, 0x16, 0xC0, 
				 0x00, 0x00, 0x24, 0x17, 0x4C, 0x00, 0x40, 0x00, 
				 0x00, 0x00, 0x17, 0x6C, 0x00, 0x32, 0x00, 0x00, 
				 0x00, 0x00, 0x00};

BYTE t5464_Mode_1024x768x24_1[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x13, 0xF0, 0x00, 0x1E, 0x00, 0xFF, 0xEF, 0x00, 
				 0x00, 0x19, 0xF0, 0x00, 0x16, 0x05, 0x04, 0x00, 
				 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 0x00, 
				 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 0x00, 
				 0x1F, 0x01, 0x00, 0x18, 0x07, 0x04, 0x15, 0xA0, 
				 0x00, 0xFF, 0x00, 0x09, 0xCE, 0x03, 0x06, 0x05, 
				 0x16, 0x80, 0x00, 0x2F, 0x00, 0x16, 0x84, 0x00, 
				 0x2C, 0x00, 0x16, 0x88, 0x00, 0x45, 0x00, 0x1D, 
				 0x19, 0x00, 0x00, 0x00, 0x99, 0x00, 0x00, 0x00, 
				 0x7F, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 
				 0x99, 0x00, 0x00, 0x00, 0x83, 0x00, 0x00, 0x00, 
				 0x19, 0x00, 0x00, 0x00, 0x96, 0x00, 0x00, 0x00, 
				 0x1F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x7F, 0x00, 0x00, 0x00, 
				 0x83, 0x00, 0x00, 0x00, 0x7F, 0x00, 0x00, 0x00, 
				 0xA0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x80, 0x00, 0x00, 0x00, 0x96, 0x00, 0x00, 0x00, 
				 0xE3, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 
				 0x1D, 0x06, 0x00, 0x64, 0x00, 0x48, 0x00, 0x00, 
				 0x00, 0x51, 0x00, 0x00, 0x00, 0x22, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x13, 0xEA, 0x00, 
				 0x1E, 0x00, 0x00, 0xC0, 0x00, 0x00, 0x1E, 0x01, 
				 0xD9, 0x0D, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 
				 0xEA, 0x00, 0x12, 0x07, 0x04, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x0D, 0x00, 0x00, 
				 0x00, 0x18, 0x07, 0x04, 0x13, 0xEA, 0x00, 0x1E, 
				 0x00, 0xC0, 0xFF, 0x00, 0x00, 0x1E, 0x01, 0x1D, 
				 0x00, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 0xEA, 
				 0x00, 0x16, 0x02, 0x04, 0x00, 0x48, 0x16, 0xC0, 
				 0x00, 0x00, 0x24, 0x17, 0x4C, 0x00, 0xA0, 0x00, 
				 0x00, 0x00, 0x17, 0x6C, 0x00, 0x32, 0x00, 0x00, 
				 0x00, 0x00, 0x00};

BYTE t5464_Mode_1024x768x24_2[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x13, 0xF0, 0x00, 0x1E, 0x00, 0xFF, 0xEF, 0x00, 
				 0x00, 0x19, 0xF0, 0x00, 0x16, 0x05, 0x04, 0x00, 
				 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 0x00, 
				 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 0x00, 
				 0x1F, 0x01, 0x00, 0x18, 0x07, 0x04, 0x15, 0xA0, 
				 0x00, 0xFF, 0x00, 0x09, 0xCE, 0x03, 0x06, 0x05, 
				 0x16, 0x80, 0x00, 0xEF, 0x00, 0x16, 0x84, 0x00, 
				 0x1A, 0x00, 0x16, 0x88, 0x00, 0x3B, 0x00, 0x1D, 
				 0x19, 0x00, 0x00, 0x00, 0xA3, 0x00, 0x00, 0x00, 
				 0x7F, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 
				 0x83, 0x00, 0x00, 0x00, 0x84, 0x00, 0x00, 0x00, 
				 0x95, 0x00, 0x00, 0x00, 0x24, 0x00, 0x00, 0x00, 
				 0xFD, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 
				 0x88, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 
				 0xA0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x24, 0x00, 0x00, 0x00, 
				 0xE3, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 
				 0x1D, 0x06, 0x00, 0x64, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0xE0, 0x00, 0x00, 0x00, 0x22, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x13, 0xEA, 0x00, 
				 0x1E, 0x00, 0x00, 0xC0, 0x00, 0x00, 0x1E, 0x01, 
				 0xD9, 0x0D, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 
				 0xEA, 0x00, 0x12, 0x07, 0x04, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x0D, 0x00, 0x00, 
				 0x00, 0x18, 0x07, 0x04, 0x13, 0xEA, 0x00, 0x1E, 
				 0x00, 0xC0, 0xFF, 0x00, 0x00, 0x1E, 0x01, 0x1D, 
				 0x00, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 0xEA, 
				 0x00, 0x16, 0x02, 0x04, 0x00, 0x48, 0x16, 0xC0, 
				 0x00, 0x00, 0x24, 0x17, 0x4C, 0x00, 0xA0, 0x00, 
				 0x00, 0x00, 0x17, 0x6C, 0x00, 0x32, 0x00, 0x00, 
				 0x00, 0x00, 0x00};

BYTE t5464_Mode_1024x768x24_3[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x13, 0xF0, 0x00, 0x1E, 0x00, 0xFF, 0xEF, 0x00, 
				 0x00, 0x19, 0xF0, 0x00, 0x16, 0x05, 0x04, 0x00, 
				 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 0x00, 
				 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 0x00, 
				 0x1F, 0x01, 0x00, 0x18, 0x07, 0x04, 0x15, 0xA0, 
				 0x00, 0xFF, 0x00, 0x09, 0xCE, 0x03, 0x06, 0x05, 
				 0x16, 0x80, 0x00, 0xEF, 0x00, 0x16, 0x84, 0x00, 
				 0x2A, 0x00, 0x16, 0x88, 0x00, 0x6E, 0x00, 0x1D, 
				 0x19, 0x00, 0x00, 0x00, 0xA1, 0x00, 0x00, 0x00, 
				 0x7F, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 
				 0x81, 0x00, 0x00, 0x00, 0x84, 0x00, 0x00, 0x00, 
				 0x95, 0x00, 0x00, 0x00, 0x24, 0x00, 0x00, 0x00, 
				 0xFD, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 
				 0x88, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 
				 0xA0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x24, 0x00, 0x00, 0x00, 
				 0xE3, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 
				 0x1D, 0x06, 0x00, 0x64, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0xE0, 0x00, 0x00, 0x00, 0x22, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x13, 0xEA, 0x00, 
				 0x1E, 0x00, 0x00, 0xC0, 0x00, 0x00, 0x1E, 0x01, 
				 0xD9, 0x0D, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 
				 0xEA, 0x00, 0x12, 0x07, 0x04, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x0D, 0x00, 0x00, 
				 0x00, 0x18, 0x07, 0x04, 0x13, 0xEA, 0x00, 0x1E, 
				 0x00, 0xC0, 0xFF, 0x00, 0x00, 0x1E, 0x01, 0x1D, 
				 0x00, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 0xEA, 
				 0x00, 0x16, 0x02, 0x04, 0x00, 0x48, 0x16, 0xC0, 
				 0x00, 0x00, 0x24, 0x17, 0x4C, 0x00, 0xA0, 0x00, 
				 0x00, 0x00, 0x17, 0x6C, 0x00, 0x32, 0x00, 0x00, 
				 0x00, 0x00, 0x00};

BYTE t5464_Mode_1024x768x24_4[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x13, 0xF0, 0x00, 0x1E, 0x00, 0xFF, 0xEF, 0x00, 
				 0x00, 0x19, 0xF0, 0x00, 0x16, 0x05, 0x04, 0x00, 
				 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 0x00, 
				 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 0x00, 
				 0x1F, 0x01, 0x00, 0x18, 0x07, 0x04, 0x15, 0xA0, 
				 0x00, 0xFF, 0x00, 0x09, 0xCE, 0x03, 0x06, 0x05, 
				 0x16, 0x80, 0x00, 0x2F, 0x00, 0x16, 0x84, 0x00, 
				 0x10, 0x00, 0x16, 0x88, 0x00, 0x2C, 0x00, 0x1D, 
				 0x19, 0x00, 0x00, 0x00, 0x9F, 0x00, 0x00, 0x00, 
				 0x7F, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 
				 0x9F, 0x00, 0x00, 0x00, 0x83, 0x00, 0x00, 0x00, 
				 0x0F, 0x00, 0x00, 0x00, 0x1E, 0x00, 0x00, 0x00, 
				 0xF5, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x83, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 
				 0xA0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0xFF, 0x00, 0x00, 0x00, 0x1E, 0x00, 0x00, 0x00, 
				 0xE3, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 
				 0x1D, 0x06, 0x00, 0x64, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0xE0, 0x00, 0x00, 0x00, 0x22, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x13, 0xEA, 0x00, 
				 0x1E, 0x00, 0x00, 0xC0, 0x00, 0x00, 0x1E, 0x01, 
				 0xD9, 0x0D, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 
				 0xEA, 0x00, 0x12, 0x07, 0x04, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x0D, 0x00, 0x00, 
				 0x00, 0x18, 0x07, 0x04, 0x13, 0xEA, 0x00, 0x1E, 
				 0x00, 0xC0, 0xFF, 0x00, 0x00, 0x1E, 0x01, 0x1D, 
				 0x00, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 0xEA, 
				 0x00, 0x16, 0x02, 0x04, 0x00, 0x48, 0x16, 0xC0, 
				 0x00, 0x00, 0x24, 0x17, 0x4C, 0x00, 0xA0, 0x00, 
				 0x00, 0x00, 0x17, 0x6C, 0x00, 0x32, 0x00, 0x00, 
				 0x00, 0x00, 0x00};

BYTE t5464_Mode_1024x768x24_5[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x13, 0xF0, 0x00, 0x1E, 0x00, 0xFF, 0xEF, 0x00, 
				 0x00, 0x19, 0xF0, 0x00, 0x16, 0x05, 0x04, 0x00, 
				 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 0x00, 
				 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 0x00, 
				 0x1F, 0x01, 0x00, 0x18, 0x07, 0x04, 0x15, 0xA0, 
				 0x00, 0xFF, 0x00, 0x09, 0xCE, 0x03, 0x06, 0x05, 
				 0x16, 0x80, 0x00, 0x2F, 0x00, 0x16, 0x84, 0x00, 
				 0x0A, 0x00, 0x16, 0x88, 0x00, 0x21, 0x00, 0x1D, 
				 0x19, 0x00, 0x00, 0x00, 0xA7, 0x00, 0x00, 0x00, 
				 0x7F, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 
				 0x87, 0x00, 0x00, 0x00, 0x87, 0x00, 0x00, 0x00, 
				 0x93, 0x00, 0x00, 0x00, 0x26, 0x00, 0x00, 0x00, 
				 0xF5, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x83, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 
				 0xA0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0xFF, 0x00, 0x00, 0x00, 0x26, 0x00, 0x00, 0x00, 
				 0xE3, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 
				 0x1D, 0x06, 0x00, 0x64, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0xE0, 0x00, 0x00, 0x00, 0x22, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x13, 0xEA, 0x00, 
				 0x1E, 0x00, 0x00, 0xC0, 0x00, 0x00, 0x1E, 0x01, 
				 0xD9, 0x0D, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 
				 0xEA, 0x00, 0x12, 0x07, 0x04, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x0D, 0x00, 0x00, 
				 0x00, 0x18, 0x07, 0x04, 0x13, 0xEA, 0x00, 0x1E, 
				 0x00, 0xC0, 0xFF, 0x00, 0x00, 0x1E, 0x01, 0x1E, 
				 0x00, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 0xEA, 
				 0x00, 0x16, 0x02, 0x04, 0x00, 0x48, 0x16, 0xC0, 
				 0x00, 0x00, 0x24, 0x17, 0x4C, 0x00, 0xA0, 0x00, 
				 0x00, 0x00, 0x17, 0x6C, 0x00, 0x32, 0x00, 0x00, 
				 0x00, 0x00, 0x00};

BYTE t5464_Mode_Reset[] =
				{0x14, 0xFC, 0x03, 0x1E, 0x00, 0xFF, 0xFF, 0xFF, 
				 0xEF, 0x1A, 0xFC, 0x03, 0x13, 0xEA, 0x00, 0x1E, 
				 0x00, 0x00, 0xC0, 0x00, 0x00, 0x1E, 0x01, 0x08, 
				 0x1F, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 0xEA, 
				 0x00, 0x00, 0x00};

BYTE t5465_Mode_640x480x8_1[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x16, 0x05, 0x04, 0x00, 0x00, 0x16, 0xC0, 0x00, 
				 0x00, 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 
				 0x00, 0x1F, 0x01, 0x00, 0x18, 0xC5, 0x02, 0x18, 
				 0x07, 0x04, 0x15, 0xA0, 0x00, 0xFF, 0x00, 0x09, 
				 0xCE, 0x03, 0x06, 0x05, 0x09, 0xCE, 0x03, 0x09, 
				 0x00, 0x09, 0xCE, 0x03, 0x0A, 0x00, 0x09, 0xCE, 
				 0x03, 0x0B, 0x00, 0x16, 0x80, 0x00, 0xEF, 0x00, 
				 0x16, 0x84, 0x00, 0x3F, 0x00, 0x16, 0x88, 0x00, 
				 0x6D, 0x00, 0x1D, 0x19, 0x00, 0x00, 0x00, 0x5F, 
				 0x00, 0x00, 0x00, 0x4F, 0x00, 0x00, 0x00, 0x50, 
				 0x00, 0x00, 0x00, 0x9F, 0x00, 0x00, 0x00, 0x54, 
				 0x00, 0x00, 0x00, 0x1F, 0x00, 0x00, 0x00, 0x0B, 
				 0x00, 0x00, 0x00, 0x3E, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xE9, 
				 0x00, 0x00, 0x00, 0x8B, 0x00, 0x00, 0x00, 0xDF, 
				 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0xE7, 0x00, 0x00, 0x00, 0x04, 
				 0x00, 0x00, 0x00, 0xE3, 0x00, 0x00, 0x00, 0xFF, 
				 0x00, 0x00, 0x00, 0x1D, 0x06, 0x00, 0x64, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x90, 0x00, 0x00, 0x00, 
				 0x22, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x13, 0xEA, 0x00, 0x1E, 0x00, 0x00, 0xC0, 0x00, 
				 0x00, 0x1E, 0x01, 0x11, 0x08, 0x00, 0x00, 0x1F, 
				 0x01, 0x00, 0x19, 0xEA, 0x00, 0x12, 0x07, 0x04, 
				 0x1E, 0x00, 0xC0, 0x00, 0x00, 0x00, 0x1E, 0x01, 
				 0x08, 0x00, 0x00, 0x00, 0x18, 0x07, 0x04, 0x13, 
				 0xC4, 0x02, 0x1E, 0x00, 0x3F, 0xC0, 0x00, 0x00, 
				 0x1E, 0x01, 0x80, 0x08, 0x00, 0x00, 0x1F, 0x01, 
				 0x00, 0x19, 0xC4, 0x02, 0x16, 0x02, 0x04, 0x00, 
				 0x00, 0x13, 0xC0, 0x00, 0x1E, 0x01, 0x00, 0x00, 
				 0x00, 0x00, 0x19, 0xC0, 0x00, 0x13, 0xEA, 0x00, 
				 0x1E, 0x00, 0xFF, 0xC0, 0x00, 0x00, 0x1E, 0x01, 
				 0x00, 0x05, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 
				 0xEA, 0x00, 0x00, 0x00};

BYTE t5465_Mode_640x480x8_2[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x16, 0x05, 0x04, 0x00, 0x00, 0x16, 0xC0, 0x00, 
				 0x00, 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 
				 0x00, 0x1F, 0x01, 0x00, 0x18, 0xC5, 0x02, 0x18, 
				 0x07, 0x04, 0x15, 0xA0, 0x00, 0xFF, 0x00, 0x09, 
				 0xCE, 0x03, 0x06, 0x05, 0x09, 0xCE, 0x03, 0x09, 
				 0x00, 0x09, 0xCE, 0x03, 0x0A, 0x00, 0x09, 0xCE, 
				 0x03, 0x0B, 0x00, 0x16, 0x80, 0x00, 0xEF, 0x00, 
				 0x16, 0x84, 0x00, 0x0B, 0x00, 0x16, 0x88, 0x00, 
				 0x16, 0x00, 0x1D, 0x19, 0x00, 0x00, 0x00, 0x63, 
				 0x00, 0x00, 0x00, 0x4F, 0x00, 0x00, 0x00, 0x50, 
				 0x00, 0x00, 0x00, 0x82, 0x00, 0x00, 0x00, 0x54, 
				 0x00, 0x00, 0x00, 0x99, 0x00, 0x00, 0x00, 0x06, 
				 0x00, 0x00, 0x00, 0x3E, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xE8, 
				 0x00, 0x00, 0x00, 0x8B, 0x00, 0x00, 0x00, 0xDF, 
				 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0xE7, 0x00, 0x00, 0x00, 0xF3, 
				 0x00, 0x00, 0x00, 0xE3, 0x00, 0x00, 0x00, 0xFF, 
				 0x00, 0x00, 0x00, 0x1D, 0x06, 0x00, 0x64, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x50, 0x00, 0x00, 0x00, 
				 0x22, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x13, 0xEA, 0x00, 0x1E, 0x00, 0x00, 0xC0, 0x00, 
				 0x00, 0x1E, 0x01, 0x11, 0x08, 0x00, 0x00, 0x1F, 
				 0x01, 0x00, 0x19, 0xEA, 0x00, 0x12, 0x07, 0x04, 
				 0x1E, 0x00, 0xC0, 0x00, 0x00, 0x00, 0x1E, 0x01, 
				 0x08, 0x00, 0x00, 0x00, 0x18, 0x07, 0x04, 0x13, 
				 0xC4, 0x02, 0x1E, 0x00, 0x3F, 0xC0, 0x00, 0x00, 
				 0x1E, 0x01, 0x80, 0x08, 0x00, 0x00, 0x1F, 0x01, 
				 0x00, 0x19, 0xC4, 0x02, 0x16, 0x02, 0x04, 0x00, 
				 0x00, 0x13, 0xC0, 0x00, 0x1E, 0x01, 0x00, 0x00, 
				 0x00, 0x00, 0x19, 0xC0, 0x00, 0x13, 0xEA, 0x00, 
				 0x1E, 0x00, 0xFF, 0xC0, 0x00, 0x00, 0x1E, 0x01, 
				 0x00, 0x05, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 
				 0xEA, 0x00, 0x00, 0x00};

BYTE t5465_Mode_640x480x8_3[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x16, 0x05, 0x04, 0x00, 0x00, 0x16, 0xC0, 0x00, 
				 0x00, 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 
				 0x00, 0x1F, 0x01, 0x00, 0x18, 0xC5, 0x02, 0x18, 
				 0x07, 0x04, 0x15, 0xA0, 0x00, 0xFF, 0x00, 0x09, 
				 0xCE, 0x03, 0x06, 0x05, 0x09, 0xCE, 0x03, 0x09, 
				 0x00, 0x09, 0xCE, 0x03, 0x0A, 0x00, 0x09, 0xCE, 
				 0x03, 0x0B, 0x00, 0x16, 0x80, 0x00, 0xEF, 0x00, 
				 0x16, 0x84, 0x00, 0x0B, 0x00, 0x16, 0x88, 0x00, 
				 0x16, 0x00, 0x1D, 0x19, 0x00, 0x00, 0x00, 0x64, 
				 0x00, 0x00, 0x00, 0x4F, 0x00, 0x00, 0x00, 0x50, 
				 0x00, 0x00, 0x00, 0x82, 0x00, 0x00, 0x00, 0x54, 
				 0x00, 0x00, 0x00, 0x9B, 0x00, 0x00, 0x00, 0xF2, 
				 0x00, 0x00, 0x00, 0x1F, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xE0, 
				 0x00, 0x00, 0x00, 0x83, 0x00, 0x00, 0x00, 0xDF, 
				 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0xDF, 0x00, 0x00, 0x00, 0xF2, 
				 0x00, 0x00, 0x00, 0xE3, 0x00, 0x00, 0x00, 0xFF, 
				 0x00, 0x00, 0x00, 0x1D, 0x06, 0x00, 0x64, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x50, 0x00, 0x00, 0x00, 
				 0x22, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x13, 0xEA, 0x00, 0x1E, 0x00, 0x00, 0xC0, 0x00, 
				 0x00, 0x1E, 0x01, 0x11, 0x08, 0x00, 0x00, 0x1F, 
				 0x01, 0x00, 0x19, 0xEA, 0x00, 0x12, 0x07, 0x04, 
				 0x1E, 0x00, 0xC0, 0x00, 0x00, 0x00, 0x1E, 0x01, 
				 0x08, 0x00, 0x00, 0x00, 0x18, 0x07, 0x04, 0x13, 
				 0xC4, 0x02, 0x1E, 0x00, 0x3F, 0xC0, 0x00, 0x00, 
				 0x1E, 0x01, 0x80, 0x08, 0x00, 0x00, 0x1F, 0x01, 
				 0x00, 0x19, 0xC4, 0x02, 0x16, 0x02, 0x04, 0x00, 
				 0x00, 0x13, 0xC0, 0x00, 0x1E, 0x01, 0x00, 0x00, 
				 0x00, 0x00, 0x19, 0xC0, 0x00, 0x13, 0xEA, 0x00, 
				 0x1E, 0x00, 0xFF, 0xC0, 0x00, 0x00, 0x1E, 0x01, 
				 0x00, 0x05, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 
				 0xEA, 0x00, 0x00, 0x00};

BYTE t5465_Mode_640x480x8_4[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x16, 0x05, 0x04, 0x00, 0x00, 0x16, 0xC0, 0x00, 
				 0x00, 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 
				 0x00, 0x1F, 0x01, 0x00, 0x18, 0xC5, 0x02, 0x18, 
				 0x07, 0x04, 0x15, 0xA0, 0x00, 0xFF, 0x00, 0x09, 
				 0xCE, 0x03, 0x06, 0x05, 0x09, 0xCE, 0x03, 0x09, 
				 0x00, 0x09, 0xCE, 0x03, 0x0A, 0x00, 0x09, 0xCE, 
				 0x03, 0x0B, 0x00, 0x16, 0x80, 0x00, 0xEF, 0x00, 
				 0x16, 0x84, 0x00, 0x33, 0x00, 0x16, 0x88, 0x00, 
				 0x7E, 0x00, 0x1D, 0x19, 0x00, 0x00, 0x00, 0x63, 
				 0x00, 0x00, 0x00, 0x4F, 0x00, 0x00, 0x00, 0x50, 
				 0x00, 0x00, 0x00, 0x82, 0x00, 0x00, 0x00, 0x55, 
				 0x00, 0x00, 0x00, 0x9B, 0x00, 0x00, 0x00, 0xFB, 
				 0x00, 0x00, 0x00, 0x1F, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xE0, 
				 0x00, 0x00, 0x00, 0x83, 0x00, 0x00, 0x00, 0xDF, 
				 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0xDF, 0x00, 0x00, 0x00, 0xF9, 
				 0x00, 0x00, 0x00, 0xE3, 0x00, 0x00, 0x00, 0xFF, 
				 0x00, 0x00, 0x00, 0x1D, 0x06, 0x00, 0x64, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x50, 0x00, 0x00, 0x00, 
				 0x22, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x13, 0xEA, 0x00, 0x1E, 0x00, 0x00, 0xC0, 0x00, 
				 0x00, 0x1E, 0x01, 0x11, 0x08, 0x00, 0x00, 0x1F, 
				 0x01, 0x00, 0x19, 0xEA, 0x00, 0x12, 0x07, 0x04, 
				 0x1E, 0x00, 0xC0, 0x00, 0x00, 0x00, 0x1E, 0x01, 
				 0x08, 0x00, 0x00, 0x00, 0x18, 0x07, 0x04, 0x13, 
				 0xC4, 0x02, 0x1E, 0x00, 0x3F, 0xC0, 0x00, 0x00, 
				 0x1E, 0x01, 0x80, 0x08, 0x00, 0x00, 0x1F, 0x01, 
				 0x00, 0x19, 0xC4, 0x02, 0x16, 0x02, 0x04, 0x00, 
				 0x00, 0x13, 0xC0, 0x00, 0x1E, 0x01, 0x00, 0x00, 
				 0x00, 0x00, 0x19, 0xC0, 0x00, 0x13, 0xEA, 0x00, 
				 0x1E, 0x00, 0xFF, 0xC0, 0x00, 0x00, 0x1E, 0x01, 
				 0x00, 0x05, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 
				 0xEA, 0x00, 0x00, 0x00};

BYTE t5465_Mode_640x480x8_1a[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x16, 0x05, 0x04, 0x00, 0x00, 0x16, 0xC0, 0x00, 
				 0x00, 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 
				 0x00, 0x1F, 0x01, 0x00, 0x18, 0xC5, 0x02, 0x18, 
				 0x07, 0x04, 0x15, 0xA0, 0x00, 0xFF, 0x00, 0x09, 
				 0xCE, 0x03, 0x06, 0x05, 0x09, 0xCE, 0x03, 0x09, 
				 0x00, 0x09, 0xCE, 0x03, 0x0A, 0x00, 0x09, 0xCE, 
				 0x03, 0x0B, 0x00, 0x16, 0x80, 0x00, 0xEF, 0x00, 
				 0x16, 0x84, 0x00, 0x3F, 0x00, 0x16, 0x88, 0x00, 
				 0x6D, 0x00, 0x1D, 0x19, 0x00, 0x00, 0x00, 0x5F, 
				 0x00, 0x00, 0x00, 0x4F, 0x00, 0x00, 0x00, 0x50, 
				 0x00, 0x00, 0x00, 0x9F, 0x00, 0x00, 0x00, 0x54, 
				 0x00, 0x00, 0x00, 0x1F, 0x00, 0x00, 0x00, 0x0B, 
				 0x00, 0x00, 0x00, 0x3E, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xE9, 
				 0x00, 0x00, 0x00, 0x8B, 0x00, 0x00, 0x00, 0xDF, 
				 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0xE7, 0x00, 0x00, 0x00, 0x04, 
				 0x00, 0x00, 0x00, 0xE3, 0x00, 0x00, 0x00, 0xFF, 
				 0x00, 0x00, 0x00, 0x1D, 0x06, 0x00, 0x64, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x90, 0x00, 0x00, 0x00, 
				 0x22, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x13, 0xEA, 0x00, 0x1E, 0x00, 0x00, 0xC0, 0x00, 
				 0x00, 0x1E, 0x01, 0x11, 0x0A, 0x00, 0x00, 0x1F, 
				 0x01, 0x00, 0x19, 0xEA, 0x00, 0x12, 0x07, 0x04, 
				 0x1E, 0x00, 0xC0, 0x00, 0x00, 0x00, 0x1E, 0x01, 
				 0x0A, 0x00, 0x00, 0x00, 0x18, 0x07, 0x04, 0x13, 
				 0xC4, 0x02, 0x1E, 0x00, 0x3F, 0xC0, 0x00, 0x00, 
				 0x1E, 0x01, 0x80, 0x0A, 0x00, 0x00, 0x1F, 0x01, 
				 0x00, 0x19, 0xC4, 0x02, 0x16, 0x02, 0x04, 0x00, 
				 0x00, 0x13, 0xC0, 0x00, 0x1E, 0x01, 0x00, 0x00, 
				 0x00, 0x00, 0x19, 0xC0, 0x00, 0x17, 0x4C, 0x00, 
				 0xA0, 0x00, 0x00, 0x00, 0x13, 0xEA, 0x00, 0x1E, 
				 0x00, 0xFF, 0xC0, 0x00, 0x00, 0x1E, 0x01, 0x00, 
				 0x05, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 0xEA, 
				 0x00, 0x00, 0x00};

BYTE t5465_Mode_640x480x8_2a[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x16, 0x05, 0x04, 0x00, 0x00, 0x16, 0xC0, 0x00, 
				 0x00, 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 
				 0x00, 0x1F, 0x01, 0x00, 0x18, 0xC5, 0x02, 0x18, 
				 0x07, 0x04, 0x15, 0xA0, 0x00, 0xFF, 0x00, 0x09, 
				 0xCE, 0x03, 0x06, 0x05, 0x09, 0xCE, 0x03, 0x09, 
				 0x00, 0x09, 0xCE, 0x03, 0x0A, 0x00, 0x09, 0xCE, 
				 0x03, 0x0B, 0x00, 0x16, 0x80, 0x00, 0xEF, 0x00, 
				 0x16, 0x84, 0x00, 0x0B, 0x00, 0x16, 0x88, 0x00, 
				 0x16, 0x00, 0x1D, 0x19, 0x00, 0x00, 0x00, 0x63, 
				 0x00, 0x00, 0x00, 0x4F, 0x00, 0x00, 0x00, 0x50, 
				 0x00, 0x00, 0x00, 0x82, 0x00, 0x00, 0x00, 0x54, 
				 0x00, 0x00, 0x00, 0x99, 0x00, 0x00, 0x00, 0x06, 
				 0x00, 0x00, 0x00, 0x3E, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xE8, 
				 0x00, 0x00, 0x00, 0x8B, 0x00, 0x00, 0x00, 0xDF, 
				 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0xE7, 0x00, 0x00, 0x00, 0xF3, 
				 0x00, 0x00, 0x00, 0xE3, 0x00, 0x00, 0x00, 0xFF, 
				 0x00, 0x00, 0x00, 0x1D, 0x06, 0x00, 0x64, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x50, 0x00, 0x00, 0x00, 
				 0x22, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x13, 0xEA, 0x00, 0x1E, 0x00, 0x00, 0xC0, 0x00, 
				 0x00, 0x1E, 0x01, 0x11, 0x0A, 0x00, 0x00, 0x1F, 
				 0x01, 0x00, 0x19, 0xEA, 0x00, 0x12, 0x07, 0x04, 
				 0x1E, 0x00, 0xC0, 0x00, 0x00, 0x00, 0x1E, 0x01, 
				 0x0A, 0x00, 0x00, 0x00, 0x18, 0x07, 0x04, 0x13, 
				 0xC4, 0x02, 0x1E, 0x00, 0x3F, 0xC0, 0x00, 0x00, 
				 0x1E, 0x01, 0x80, 0x0A, 0x00, 0x00, 0x1F, 0x01, 
				 0x00, 0x19, 0xC4, 0x02, 0x16, 0x02, 0x04, 0x00, 
				 0x00, 0x13, 0xC0, 0x00, 0x1E, 0x01, 0x00, 0x00, 
				 0x00, 0x00, 0x19, 0xC0, 0x00, 0x17, 0x4C, 0x00, 
				 0xA0, 0x00, 0x00, 0x00, 0x13, 0xEA, 0x00, 0x1E, 
				 0x00, 0xFF, 0xC0, 0x00, 0x00, 0x1E, 0x01, 0x00, 
				 0x05, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 0xEA, 
				 0x00, 0x00, 0x00};

BYTE t5465_Mode_640x480x8_3a[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x16, 0x05, 0x04, 0x00, 0x00, 0x16, 0xC0, 0x00, 
				 0x00, 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 
				 0x00, 0x1F, 0x01, 0x00, 0x18, 0xC5, 0x02, 0x18, 
				 0x07, 0x04, 0x15, 0xA0, 0x00, 0xFF, 0x00, 0x09, 
				 0xCE, 0x03, 0x06, 0x05, 0x09, 0xCE, 0x03, 0x09, 
				 0x00, 0x09, 0xCE, 0x03, 0x0A, 0x00, 0x09, 0xCE, 
				 0x03, 0x0B, 0x00, 0x16, 0x80, 0x00, 0xEF, 0x00, 
				 0x16, 0x84, 0x00, 0x0B, 0x00, 0x16, 0x88, 0x00, 
				 0x16, 0x00, 0x1D, 0x19, 0x00, 0x00, 0x00, 0x64, 
				 0x00, 0x00, 0x00, 0x4F, 0x00, 0x00, 0x00, 0x50, 
				 0x00, 0x00, 0x00, 0x82, 0x00, 0x00, 0x00, 0x54, 
				 0x00, 0x00, 0x00, 0x9B, 0x00, 0x00, 0x00, 0xF2, 
				 0x00, 0x00, 0x00, 0x1F, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xE0, 
				 0x00, 0x00, 0x00, 0x83, 0x00, 0x00, 0x00, 0xDF, 
				 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0xDF, 0x00, 0x00, 0x00, 0xF2, 
				 0x00, 0x00, 0x00, 0xE3, 0x00, 0x00, 0x00, 0xFF, 
				 0x00, 0x00, 0x00, 0x1D, 0x06, 0x00, 0x64, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x50, 0x00, 0x00, 0x00, 
				 0x22, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x13, 0xEA, 0x00, 0x1E, 0x00, 0x00, 0xC0, 0x00, 
				 0x00, 0x1E, 0x01, 0x11, 0x0A, 0x00, 0x00, 0x1F, 
				 0x01, 0x00, 0x19, 0xEA, 0x00, 0x12, 0x07, 0x04, 
				 0x1E, 0x00, 0xC0, 0x00, 0x00, 0x00, 0x1E, 0x01, 
				 0x0A, 0x00, 0x00, 0x00, 0x18, 0x07, 0x04, 0x13, 
				 0xC4, 0x02, 0x1E, 0x00, 0x3F, 0xC0, 0x00, 0x00, 
				 0x1E, 0x01, 0x80, 0x0A, 0x00, 0x00, 0x1F, 0x01, 
				 0x00, 0x19, 0xC4, 0x02, 0x16, 0x02, 0x04, 0x00, 
				 0x00, 0x13, 0xC0, 0x00, 0x1E, 0x01, 0x00, 0x00, 
				 0x00, 0x00, 0x19, 0xC0, 0x00, 0x17, 0x4C, 0x00, 
				 0xA0, 0x00, 0x00, 0x00, 0x13, 0xEA, 0x00, 0x1E, 
				 0x00, 0xFF, 0xC0, 0x00, 0x00, 0x1E, 0x01, 0x00, 
				 0x05, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 0xEA, 
				 0x00, 0x00, 0x00};

BYTE t5465_Mode_640x480x8_4a[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x16, 0x05, 0x04, 0x00, 0x00, 0x16, 0xC0, 0x00, 
				 0x00, 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 
				 0x00, 0x1F, 0x01, 0x00, 0x18, 0xC5, 0x02, 0x18, 
				 0x07, 0x04, 0x15, 0xA0, 0x00, 0xFF, 0x00, 0x09, 
				 0xCE, 0x03, 0x06, 0x05, 0x09, 0xCE, 0x03, 0x09, 
				 0x00, 0x09, 0xCE, 0x03, 0x0A, 0x00, 0x09, 0xCE, 
				 0x03, 0x0B, 0x00, 0x16, 0x80, 0x00, 0xEF, 0x00, 
				 0x16, 0x84, 0x00, 0x33, 0x00, 0x16, 0x88, 0x00, 
				 0x7E, 0x00, 0x1D, 0x19, 0x00, 0x00, 0x00, 0x63, 
				 0x00, 0x00, 0x00, 0x4F, 0x00, 0x00, 0x00, 0x50, 
				 0x00, 0x00, 0x00, 0x82, 0x00, 0x00, 0x00, 0x55, 
				 0x00, 0x00, 0x00, 0x9B, 0x00, 0x00, 0x00, 0xFB, 
				 0x00, 0x00, 0x00, 0x1F, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xE0, 
				 0x00, 0x00, 0x00, 0x83, 0x00, 0x00, 0x00, 0xDF, 
				 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0xDF, 0x00, 0x00, 0x00, 0xF9, 
				 0x00, 0x00, 0x00, 0xE3, 0x00, 0x00, 0x00, 0xFF, 
				 0x00, 0x00, 0x00, 0x1D, 0x06, 0x00, 0x64, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x50, 0x00, 0x00, 0x00, 
				 0x22, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x13, 0xEA, 0x00, 0x1E, 0x00, 0x00, 0xC0, 0x00, 
				 0x00, 0x1E, 0x01, 0x11, 0x0A, 0x00, 0x00, 0x1F, 
				 0x01, 0x00, 0x19, 0xEA, 0x00, 0x12, 0x07, 0x04, 
				 0x1E, 0x00, 0xC0, 0x00, 0x00, 0x00, 0x1E, 0x01, 
				 0x0A, 0x00, 0x00, 0x00, 0x18, 0x07, 0x04, 0x13, 
				 0xC4, 0x02, 0x1E, 0x00, 0x3F, 0xC0, 0x00, 0x00, 
				 0x1E, 0x01, 0x80, 0x0A, 0x00, 0x00, 0x1F, 0x01, 
				 0x00, 0x19, 0xC4, 0x02, 0x16, 0x02, 0x04, 0x00, 
				 0x00, 0x13, 0xC0, 0x00, 0x1E, 0x01, 0x00, 0x00, 
				 0x00, 0x00, 0x19, 0xC0, 0x00, 0x17, 0x4C, 0x00, 
				 0xA0, 0x00, 0x00, 0x00, 0x13, 0xEA, 0x00, 0x1E, 
				 0x00, 0xFF, 0xC0, 0x00, 0x00, 0x1E, 0x01, 0x00, 
				 0x05, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 0xEA, 
				 0x00, 0x00, 0x00};

BYTE t5465_Mode_320x200x8_1[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x16, 0x05, 0x04, 0x00, 0x00, 0x16, 0xC0, 0x00, 
				 0x00, 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 
				 0x00, 0x1F, 0x01, 0x00, 0x18, 0xC5, 0x02, 0x18, 
				 0x07, 0x04, 0x15, 0xA0, 0x00, 0xFF, 0x00, 0x09, 
				 0xCE, 0x03, 0x06, 0x05, 0x09, 0xCE, 0x03, 0x09, 
				 0x00, 0x09, 0xCE, 0x03, 0x0A, 0x00, 0x09, 0xCE, 
				 0x03, 0x0B, 0x00, 0x16, 0x80, 0x00, 0x2F, 0x00, 
				 0x16, 0x84, 0x00, 0x42, 0x00, 0x16, 0x88, 0x00, 
				 0x74, 0x00, 0x16, 0xC0, 0x00, 0x00, 0x80, 0x1D, 
				 0x19, 0x00, 0x00, 0x00, 0x2D, 0x00, 0x00, 0x00, 
				 0x27, 0x00, 0x00, 0x00, 0x28, 0x00, 0x00, 0x00, 
				 0x8D, 0x00, 0x00, 0x00, 0x2A, 0x00, 0x00, 0x00, 
				 0x8B, 0x00, 0x00, 0x00, 0xA0, 0x00, 0x00, 0x00, 
				 0x1F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0xC0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x91, 0x00, 0x00, 0x00, 
				 0x84, 0x00, 0x00, 0x00, 0x8F, 0x00, 0x00, 0x00, 
				 0x50, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x90, 0x00, 0x00, 0x00, 0xA0, 0x00, 0x00, 0x00, 
				 0xE3, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 
				 0x1D, 0x06, 0x00, 0x64, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x40, 0x00, 0x00, 0x00, 0x22, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x13, 0xEA, 0x00, 
				 0x1E, 0x00, 0x00, 0xC0, 0x00, 0x00, 0x1E, 0x01, 
				 0x11, 0x05, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 
				 0xEA, 0x00, 0x12, 0x07, 0x04, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 
				 0x00, 0x18, 0x07, 0x04, 0x13, 0xC4, 0x02, 0x1E, 
				 0x00, 0x3F, 0xC0, 0x00, 0x00, 0x1E, 0x01, 0x80, 
				 0x05, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 0xC4, 
				 0x02, 0x16, 0x02, 0x04, 0x00, 0x00, 0x13, 0xC0, 
				 0x00, 0x1E, 0x01, 0x00, 0x00, 0x00, 0x00, 0x19, 
				 0xC0, 0x00, 0x13, 0xEA, 0x00, 0x1E, 0x00, 0xFF, 
				 0xC0, 0x00, 0x00, 0x1E, 0x01, 0x00, 0x03, 0x00, 
				 0x00, 0x1F, 0x01, 0x00, 0x19, 0xEA, 0x00, 0x00, 0x00};

BYTE t5465_Mode_320x240x8_1[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x16, 0x05, 0x04, 0x00, 0x00, 0x16, 0xC0, 0x00, 
				 0x00, 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 
				 0x00, 0x1F, 0x01, 0x00, 0x18, 0xC5, 0x02, 0x18, 
				 0x07, 0x04, 0x15, 0xA0, 0x00, 0xFF, 0x00, 0x09, 
				 0xCE, 0x03, 0x06, 0x05, 0x09, 0xCE, 0x03, 0x09, 
				 0x00, 0x09, 0xCE, 0x03, 0x0A, 0x00, 0x09, 0xCE, 
				 0x03, 0x0B, 0x00, 0x16, 0x80, 0x00, 0xEF, 0x00, 
				 0x16, 0x84, 0x00, 0x42, 0x00, 0x16, 0x88, 0x00, 
				 0x74, 0x00, 0x16, 0xC0, 0x00, 0x00, 0x80, 0x1D, 
				 0x19, 0x00, 0x00, 0x00, 0x2D, 0x00, 0x00, 0x00, 
				 0x27, 0x00, 0x00, 0x00, 0x27, 0x00, 0x00, 0x00, 
				 0x8C, 0x00, 0x00, 0x00, 0x2A, 0x00, 0x00, 0x00, 
				 0x8B, 0x00, 0x00, 0x00, 0x0B, 0x00, 0x00, 0x00, 
				 0x3E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0xC0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0xE1, 0x00, 0x00, 0x00, 
				 0x83, 0x00, 0x00, 0x00, 0xDF, 0x00, 0x00, 0x00, 
				 0x50, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0xDF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0xE3, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 
				 0x1D, 0x06, 0x00, 0x64, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x80, 0x00, 0x00, 0x00, 0x22, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x13, 0xEA, 0x00, 
				 0x1E, 0x00, 0x00, 0xC0, 0x00, 0x00, 0x1E, 0x01, 
				 0x11, 0x05, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 
				 0xEA, 0x00, 0x12, 0x07, 0x04, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 
				 0x00, 0x18, 0x07, 0x04, 0x13, 0xC4, 0x02, 0x1E, 
				 0x00, 0x3F, 0xC0, 0x00, 0x00, 0x1E, 0x01, 0x80, 
				 0x05, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 0xC4, 
				 0x02, 0x16, 0x02, 0x04, 0x00, 0x00, 0x13, 0xC0, 
				 0x00, 0x1E, 0x01, 0x00, 0x00, 0x00, 0x00, 0x19, 
				 0xC0, 0x00, 0x13, 0xEA, 0x00, 0x1E, 0x00, 0xFF, 
				 0xC0, 0x00, 0x00, 0x1E, 0x01, 0x00, 0x03, 0x00, 
				 0x00, 0x1F, 0x01, 0x00, 0x19, 0xEA, 0x00, 0x00, 0x00};

BYTE t5465_Mode_320x240x8_2[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x16, 0x05, 0x04, 0x00, 0x00, 0x16, 0xC0, 0x00, 
				 0x00, 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 
				 0x00, 0x1F, 0x01, 0x00, 0x18, 0xC5, 0x02, 0x18, 
				 0x07, 0x04, 0x15, 0xA0, 0x00, 0xFF, 0x00, 0x09, 
				 0xCE, 0x03, 0x06, 0x05, 0x09, 0xCE, 0x03, 0x09, 
				 0x00, 0x09, 0xCE, 0x03, 0x0A, 0x00, 0x09, 0xCE, 
				 0x03, 0x0B, 0x00, 0x16, 0x80, 0x00, 0xEF, 0x00, 
				 0x16, 0x84, 0x00, 0x0A, 0x00, 0x16, 0x88, 0x00, 
				 0x16, 0x00, 0x16, 0xC0, 0x00, 0x00, 0x80, 0x1D, 
				 0x19, 0x00, 0x00, 0x00, 0x2F, 0x00, 0x00, 0x00, 
				 0x27, 0x00, 0x00, 0x00, 0x27, 0x00, 0x00, 0x00, 
				 0x8C, 0x00, 0x00, 0x00, 0x2A, 0x00, 0x00, 0x00, 
				 0x8B, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 
				 0x3E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0xC0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0xE0, 0x00, 0x00, 0x00, 
				 0x83, 0x00, 0x00, 0x00, 0xDF, 0x00, 0x00, 0x00, 
				 0x50, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0xDF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0xE3, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 
				 0x1D, 0x06, 0x00, 0x64, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x80, 0x00, 0x00, 0x00, 0x22, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x13, 0xEA, 0x00, 
				 0x1E, 0x00, 0x00, 0xC0, 0x00, 0x00, 0x1E, 0x01, 
				 0x11, 0x05, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 
				 0xEA, 0x00, 0x12, 0x07, 0x04, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 
				 0x00, 0x18, 0x07, 0x04, 0x13, 0xC4, 0x02, 0x1E, 
				 0x00, 0x3F, 0xC0, 0x00, 0x00, 0x1E, 0x01, 0x80, 
				 0x05, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 0xC4, 
				 0x02, 0x16, 0x02, 0x04, 0x00, 0x00, 0x13, 0xC0, 
				 0x00, 0x1E, 0x01, 0x00, 0x00, 0x00, 0x00, 0x19, 
				 0xC0, 0x00, 0x13, 0xEA, 0x00, 0x1E, 0x00, 0xFF, 
				 0xC0, 0x00, 0x00, 0x1E, 0x01, 0x00, 0x03, 0x00, 
				 0x00, 0x1F, 0x01, 0x00, 0x19, 0xEA, 0x00, 0x00, 0x00};

BYTE t5465_Mode_320x400x8_1[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x16, 0x05, 0x04, 0x00, 0x00, 0x16, 0xC0, 0x00, 
				 0x00, 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 
				 0x00, 0x1F, 0x01, 0x00, 0x18, 0xC5, 0x02, 0x18, 
				 0x07, 0x04, 0x15, 0xA0, 0x00, 0xFF, 0x00, 0x09, 
				 0xCE, 0x03, 0x06, 0x05, 0x09, 0xCE, 0x03, 0x09, 
				 0x00, 0x09, 0xCE, 0x03, 0x0A, 0x00, 0x09, 0xCE, 
				 0x03, 0x0B, 0x00, 0x16, 0x80, 0x00, 0x2F, 0x00, 
				 0x16, 0x84, 0x00, 0x42, 0x00, 0x16, 0x88, 0x00, 
				 0x74, 0x00, 0x16, 0xC0, 0x00, 0x00, 0x80, 0x1D, 
				 0x19, 0x00, 0x00, 0x00, 0x2D, 0x00, 0x00, 0x00, 
				 0x27, 0x00, 0x00, 0x00, 0x28, 0x00, 0x00, 0x00, 
				 0x8D, 0x00, 0x00, 0x00, 0x2A, 0x00, 0x00, 0x00, 
				 0x8B, 0x00, 0x00, 0x00, 0xA0, 0x00, 0x00, 0x00, 
				 0x1F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x91, 0x00, 0x00, 0x00, 
				 0x84, 0x00, 0x00, 0x00, 0x8F, 0x00, 0x00, 0x00, 
				 0x50, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x90, 0x00, 0x00, 0x00, 0xA0, 0x00, 0x00, 0x00, 
				 0xE3, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 
				 0x1D, 0x06, 0x00, 0x64, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x40, 0x00, 0x00, 0x00, 0x22, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x13, 0xEA, 0x00, 
				 0x1E, 0x00, 0x00, 0xC0, 0x00, 0x00, 0x1E, 0x01, 
				 0x11, 0x05, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 
				 0xEA, 0x00, 0x12, 0x07, 0x04, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 
				 0x00, 0x18, 0x07, 0x04, 0x13, 0xC4, 0x02, 0x1E, 
				 0x00, 0x3F, 0xC0, 0x00, 0x00, 0x1E, 0x01, 0x80, 
				 0x05, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 0xC4, 
				 0x02, 0x16, 0x02, 0x04, 0x00, 0x00, 0x13, 0xC0, 
				 0x00, 0x1E, 0x01, 0x00, 0x00, 0x00, 0x00, 0x19, 
				 0xC0, 0x00, 0x13, 0xEA, 0x00, 0x1E, 0x00, 0xFF, 
				 0xC0, 0x00, 0x00, 0x1E, 0x01, 0x00, 0x03, 0x00, 
				 0x00, 0x1F, 0x01, 0x00, 0x19, 0xEA, 0x00, 0x00, 0x00};

BYTE t5465_Mode_320x480x8_1[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x16, 0x05, 0x04, 0x00, 0x00, 0x16, 0xC0, 0x00, 
				 0x00, 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 
				 0x00, 0x1F, 0x01, 0x00, 0x18, 0xC5, 0x02, 0x18, 
				 0x07, 0x04, 0x15, 0xA0, 0x00, 0xFF, 0x00, 0x09, 
				 0xCE, 0x03, 0x06, 0x05, 0x09, 0xCE, 0x03, 0x09, 
				 0x00, 0x09, 0xCE, 0x03, 0x0A, 0x00, 0x09, 0xCE, 
				 0x03, 0x0B, 0x00, 0x16, 0x80, 0x00, 0xEF, 0x00, 
				 0x16, 0x84, 0x00, 0x42, 0x00, 0x16, 0x88, 0x00, 
				 0x74, 0x00, 0x16, 0xC0, 0x00, 0x00, 0x80, 0x1D, 
				 0x19, 0x00, 0x00, 0x00, 0x2D, 0x00, 0x00, 0x00, 
				 0x27, 0x00, 0x00, 0x00, 0x27, 0x00, 0x00, 0x00, 
				 0x8C, 0x00, 0x00, 0x00, 0x2A, 0x00, 0x00, 0x00, 
				 0x8B, 0x00, 0x00, 0x00, 0x0B, 0x00, 0x00, 0x00, 
				 0x3E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0xC0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0xE1, 0x00, 0x00, 0x00, 
				 0x83, 0x00, 0x00, 0x00, 0xDF, 0x00, 0x00, 0x00, 
				 0x50, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0xDF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0xE3, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 
				 0x1D, 0x06, 0x00, 0x64, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x80, 0x00, 0x00, 0x00, 0x22, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x17, 0x24, 0x00, 
				 0x40, 0x00, 0x00, 0x00, 0x13, 0xEA, 0x00, 0x1E, 
				 0x00, 0xFF, 0xC0, 0x00, 0x00, 0x1E, 0x01, 0x00, 
				 0x03, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 0xEA, 
				 0x00, 0x13, 0xEA, 0x00, 0x1E, 0x00, 0x00, 0xC0, 
				 0x00, 0x00, 0x1E, 0x01, 0x11, 0x05, 0x00, 0x00, 
				 0x1F, 0x01, 0x00, 0x19, 0xEA, 0x00, 0x12, 0x07, 
				 0x04, 0x1E, 0x00, 0xC0, 0x00, 0x00, 0x00, 0x1E, 
				 0x01, 0x05, 0x00, 0x00, 0x00, 0x18, 0x07, 0x04, 
				 0x13, 0xC4, 0x02, 0x1E, 0x00, 0x3F, 0xC0, 0x00, 
				 0x00, 0x1E, 0x01, 0x80, 0x05, 0x00, 0x00, 0x1F, 
				 0x01, 0x00, 0x19, 0xC4, 0x02, 0x16, 0x02, 0x04, 
				 0x00, 0x00, 0x13, 0xC0, 0x00, 0x1E, 0x01, 0x00, 
				 0x00, 0x00, 0x00, 0x19, 0xC0, 0x00, 0x13, 0xEA, 
				 0x00, 0x1E, 0x00, 0xFF, 0xC0, 0x00, 0x00, 0x1E, 
				 0x01, 0x00, 0x03, 0x00, 0x00, 0x1F, 0x01, 0x00, 
				 0x19, 0xEA, 0x00, 0x00, 0x00};

BYTE t5465_Mode_320x480x8_2[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x16, 0x05, 0x04, 0x00, 0x00, 0x16, 0xC0, 0x00, 
				 0x00, 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 
				 0x00, 0x1F, 0x01, 0x00, 0x18, 0xC5, 0x02, 0x18, 
				 0x07, 0x04, 0x15, 0xA0, 0x00, 0xFF, 0x00, 0x09, 
				 0xCE, 0x03, 0x06, 0x05, 0x09, 0xCE, 0x03, 0x09, 
				 0x00, 0x09, 0xCE, 0x03, 0x0A, 0x00, 0x09, 0xCE, 
				 0x03, 0x0B, 0x00, 0x16, 0x80, 0x00, 0xEF, 0x00, 
				 0x16, 0x84, 0x00, 0x0A, 0x00, 0x16, 0x88, 0x00, 
				 0x16, 0x00, 0x16, 0xC0, 0x00, 0x00, 0x80, 0x1D, 
				 0x19, 0x00, 0x00, 0x00, 0x2F, 0x00, 0x00, 0x00, 
				 0x27, 0x00, 0x00, 0x00, 0x27, 0x00, 0x00, 0x00, 
				 0x8C, 0x00, 0x00, 0x00, 0x2A, 0x00, 0x00, 0x00, 
				 0x8B, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 
				 0x3E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0xC0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0xE0, 0x00, 0x00, 0x00, 
				 0x83, 0x00, 0x00, 0x00, 0xDF, 0x00, 0x00, 0x00, 
				 0x50, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0xDF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0xE3, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 
				 0x1D, 0x06, 0x00, 0x64, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x80, 0x00, 0x00, 0x00, 0x22, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x17, 0x24, 0x00, 
				 0x40, 0x00, 0x00, 0x00, 0x13, 0xEA, 0x00, 0x1E, 
				 0x00, 0xFF, 0xC0, 0x00, 0x00, 0x1E, 0x01, 0x00, 
				 0x03, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 0xEA, 
				 0x00, 0x13, 0xEA, 0x00, 0x1E, 0x00, 0x00, 0xC0, 
				 0x00, 0x00, 0x1E, 0x01, 0x11, 0x05, 0x00, 0x00, 
				 0x1F, 0x01, 0x00, 0x19, 0xEA, 0x00, 0x12, 0x07, 
				 0x04, 0x1E, 0x00, 0xC0, 0x00, 0x00, 0x00, 0x1E, 
				 0x01, 0x05, 0x00, 0x00, 0x00, 0x18, 0x07, 0x04, 
				 0x13, 0xC4, 0x02, 0x1E, 0x00, 0x3F, 0xC0, 0x00, 
				 0x00, 0x1E, 0x01, 0x80, 0x05, 0x00, 0x00, 0x1F, 
				 0x01, 0x00, 0x19, 0xC4, 0x02, 0x16, 0x02, 0x04, 
				 0x00, 0x00, 0x13, 0xC0, 0x00, 0x1E, 0x01, 0x00, 
				 0x00, 0x00, 0x00, 0x19, 0xC0, 0x00, 0x13, 0xEA, 
				 0x00, 0x1E, 0x00, 0xFF, 0xC0, 0x00, 0x00, 0x1E, 
				 0x01, 0x00, 0x03, 0x00, 0x00, 0x1F, 0x01, 0x00, 
				 0x19, 0xEA, 0x00, 0x00, 0x00};

BYTE t5465_Mode_360x400x8_1[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x16, 0x05, 0x04, 0x00, 0x00, 0x16, 0xC0, 0x00, 
				 0x00, 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 
				 0x00, 0x1F, 0x01, 0x00, 0x18, 0xC5, 0x02, 0x18, 
				 0x07, 0x04, 0x15, 0xA0, 0x00, 0xFF, 0x00, 0x09, 
				 0xCE, 0x03, 0x06, 0x05, 0x09, 0xCE, 0x03, 0x09, 
				 0x00, 0x09, 0xCE, 0x03, 0x0A, 0x00, 0x09, 0xCE, 
				 0x03, 0x0B, 0x00, 0x16, 0x80, 0x00, 0x2F, 0x00, 
				 0x16, 0x84, 0x00, 0x04, 0x00, 0x16, 0x88, 0x00, 
				 0x08, 0x00, 0x16, 0xC0, 0x00, 0x00, 0x80, 0x1D, 
				 0x19, 0x00, 0x00, 0x00, 0x34, 0x00, 0x00, 0x00, 
				 0x2C, 0x00, 0x00, 0x00, 0x2D, 0x00, 0x00, 0x00, 
				 0x94, 0x00, 0x00, 0x00, 0x2F, 0x00, 0x00, 0x00, 
				 0x92, 0x00, 0x00, 0x00, 0xA0, 0x00, 0x00, 0x00, 
				 0x1F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x91, 0x00, 0x00, 0x00, 
				 0x84, 0x00, 0x00, 0x00, 0x8F, 0x00, 0x00, 0x00, 
				 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x90, 0x00, 0x00, 0x00, 0xA0, 0x00, 0x00, 0x00, 
				 0xE3, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 
				 0x1D, 0x06, 0x00, 0x64, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x40, 0x00, 0x00, 0x00, 0x22, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x13, 0xEA, 0x00, 
				 0x1E, 0x00, 0x00, 0xC0, 0x00, 0x00, 0x1E, 0x01, 
				 0x11, 0x08, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 
				 0xEA, 0x00, 0x12, 0x07, 0x04, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x08, 0x00, 0x00, 
				 0x00, 0x18, 0x07, 0x04, 0x13, 0xC4, 0x02, 0x1E, 
				 0x00, 0x3F, 0xC0, 0x00, 0x00, 0x1E, 0x01, 0x80, 
				 0x08, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 0xC4, 
				 0x02, 0x16, 0x02, 0x04, 0x00, 0x00, 0x13, 0xC0, 
				 0x00, 0x1E, 0x01, 0x00, 0x00, 0x00, 0x00, 0x19, 
				 0xC0, 0x00, 0x13, 0xEA, 0x00, 0x1E, 0x00, 0xFF, 
				 0xC0, 0x00, 0x00, 0x1E, 0x01, 0x00, 0x03, 0x00, 
				 0x00, 0x1F, 0x01, 0x00, 0x19, 0xEA, 0x00, 0x00, 0x00};

BYTE t5465_Mode_360x400x8_2[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x16, 0x05, 0x04, 0x00, 0x00, 0x16, 0xC0, 0x00, 
				 0x00, 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 
				 0x00, 0x1F, 0x01, 0x00, 0x18, 0xC5, 0x02, 0x18, 
				 0x07, 0x04, 0x15, 0xA0, 0x00, 0xFF, 0x00, 0x09, 
				 0xCE, 0x03, 0x06, 0x05, 0x09, 0xCE, 0x03, 0x09, 
				 0x00, 0x09, 0xCE, 0x03, 0x0A, 0x00, 0x09, 0xCE, 
				 0x03, 0x0B, 0x00, 0x16, 0x80, 0x00, 0x6F, 0x00, 
				 0x16, 0x84, 0x00, 0x32, 0x00, 0x16, 0x88, 0x00, 
				 0x7C, 0x00, 0x16, 0xC0, 0x00, 0x00, 0x80, 0x1D, 
				 0x19, 0x00, 0x00, 0x00, 0x35, 0x00, 0x00, 0x00, 
				 0x2C, 0x00, 0x00, 0x00, 0x2C, 0x00, 0x00, 0x00, 
				 0x93, 0x00, 0x00, 0x00, 0x2F, 0x00, 0x00, 0x00, 
				 0x90, 0x00, 0x00, 0x00, 0xBC, 0x00, 0x00, 0x00, 
				 0x1F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x90, 0x00, 0x00, 0x00, 
				 0x83, 0x00, 0x00, 0x00, 0x8F, 0x00, 0x00, 0x00, 
				 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x8F, 0x00, 0x00, 0x00, 0xBC, 0x00, 0x00, 0x00, 
				 0xE3, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 
				 0x1D, 0x06, 0x00, 0x64, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x40, 0x00, 0x00, 0x00, 0x22, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x13, 0xEA, 0x00, 
				 0x1E, 0x00, 0x00, 0xC0, 0x00, 0x00, 0x1E, 0x01, 
				 0x11, 0x08, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 
				 0xEA, 0x00, 0x12, 0x07, 0x04, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x08, 0x00, 0x00, 
				 0x00, 0x18, 0x07, 0x04, 0x13, 0xC4, 0x02, 0x1E, 
				 0x00, 0x3F, 0xC0, 0x00, 0x00, 0x1E, 0x01, 0x80, 
				 0x08, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 0xC4, 
				 0x02, 0x16, 0x02, 0x04, 0x00, 0x00, 0x13, 0xC0, 
				 0x00, 0x1E, 0x01, 0x00, 0x00, 0x00, 0x00, 0x19, 
				 0xC0, 0x00, 0x13, 0xEA, 0x00, 0x1E, 0x00, 0xFF, 
				 0xC0, 0x00, 0x00, 0x1E, 0x01, 0x00, 0x03, 0x00, 
				 0x00, 0x1F, 0x01, 0x00, 0x19, 0xEA, 0x00, 0x00, 0x00};

BYTE t5465_Mode_400x300x8_1[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x16, 0x05, 0x04, 0x00, 0x00, 0x16, 0xC0, 0x00, 
				 0x00, 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 
				 0x00, 0x1F, 0x01, 0x00, 0x18, 0xC5, 0x02, 0x18, 
				 0x07, 0x04, 0x15, 0xA0, 0x00, 0xFF, 0x00, 0x09, 
				 0xCE, 0x03, 0x06, 0x05, 0x09, 0xCE, 0x03, 0x09, 
				 0x00, 0x09, 0xCE, 0x03, 0x0A, 0x00, 0x09, 0xCE, 
				 0x03, 0x0B, 0x00, 0x16, 0x80, 0x00, 0x2F, 0x00, 
				 0x16, 0x84, 0x00, 0x18, 0x00, 0x16, 0x88, 0x00, 
				 0x43, 0x00, 0x16, 0xC0, 0x00, 0x00, 0x80, 0x1D, 
				 0x19, 0x00, 0x00, 0x00, 0x3D, 0x00, 0x00, 0x00, 
				 0x31, 0x00, 0x00, 0x00, 0x31, 0x00, 0x00, 0x00, 
				 0x99, 0x00, 0x00, 0x00, 0x35, 0x00, 0x00, 0x00, 
				 0x96, 0x00, 0x00, 0x00, 0x72, 0x00, 0x00, 0x00, 
				 0xF0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0xE0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x58, 0x00, 0x00, 0x00, 
				 0x8C, 0x00, 0x00, 0x00, 0x57, 0x00, 0x00, 0x00, 
				 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x57, 0x00, 0x00, 0x00, 0x72, 0x00, 0x00, 0x00, 
				 0xE3, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 
				 0x1D, 0x06, 0x00, 0x64, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x80, 0x00, 0x00, 0x00, 0x22, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x13, 0xEA, 0x00, 
				 0x1E, 0x00, 0x00, 0xC0, 0x00, 0x00, 0x1E, 0x01, 
				 0x11, 0x08, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 
				 0xEA, 0x00, 0x12, 0x07, 0x04, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x08, 0x00, 0x00, 
				 0x00, 0x18, 0x07, 0x04, 0x13, 0xC4, 0x02, 0x1E, 
				 0x00, 0x3F, 0xC0, 0x00, 0x00, 0x1E, 0x01, 0x80, 
				 0x08, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 0xC4, 
				 0x02, 0x16, 0x02, 0x04, 0x00, 0x00, 0x13, 0xC0, 
				 0x00, 0x1E, 0x01, 0x00, 0x00, 0x00, 0x00, 0x19, 
				 0xC0, 0x00, 0x13, 0xEA, 0x00, 0x1E, 0x00, 0xFF, 
				 0xC0, 0x00, 0x00, 0x1E, 0x01, 0x00, 0x04, 0x00, 
				 0x00, 0x1F, 0x01, 0x00, 0x19, 0xEA, 0x00, 0x00, 0x00};

BYTE t5465_Mode_400x300x8_2[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x16, 0x05, 0x04, 0x00, 0x00, 0x16, 0xC0, 0x00, 
				 0x00, 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 
				 0x00, 0x1F, 0x01, 0x00, 0x18, 0xC5, 0x02, 0x18, 
				 0x07, 0x04, 0x15, 0xA0, 0x00, 0xFF, 0x00, 0x09, 
				 0xCE, 0x03, 0x06, 0x05, 0x09, 0xCE, 0x03, 0x09, 
				 0x00, 0x09, 0xCE, 0x03, 0x0A, 0x00, 0x09, 0xCE, 
				 0x03, 0x0B, 0x00, 0x16, 0x80, 0x00, 0x2F, 0x00, 
				 0x16, 0x84, 0x00, 0x16, 0x00, 0x16, 0x88, 0x00, 
				 0x4C, 0x00, 0x16, 0xC0, 0x00, 0x00, 0x80, 0x1D, 
				 0x19, 0x00, 0x00, 0x00, 0x3D, 0x00, 0x00, 0x00, 
				 0x31, 0x00, 0x00, 0x00, 0x31, 0x00, 0x00, 0x00, 
				 0x99, 0x00, 0x00, 0x00, 0x34, 0x00, 0x00, 0x00, 
				 0x96, 0x00, 0x00, 0x00, 0x6F, 0x00, 0x00, 0x00, 
				 0xF0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0xE0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x58, 0x00, 0x00, 0x00, 
				 0x8B, 0x00, 0x00, 0x00, 0x57, 0x00, 0x00, 0x00, 
				 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x57, 0x00, 0x00, 0x00, 0x6F, 0x00, 0x00, 0x00, 
				 0xE3, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 
				 0x1D, 0x06, 0x00, 0x64, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x80, 0x00, 0x00, 0x00, 0x22, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x13, 0xEA, 0x00, 
				 0x1E, 0x00, 0x00, 0xC0, 0x00, 0x00, 0x1E, 0x01, 
				 0x11, 0x08, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 
				 0xEA, 0x00, 0x12, 0x07, 0x04, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x08, 0x00, 0x00, 
				 0x00, 0x18, 0x07, 0x04, 0x13, 0xC4, 0x02, 0x1E, 
				 0x00, 0x3F, 0xC0, 0x00, 0x00, 0x1E, 0x01, 0x80, 
				 0x08, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 0xC4, 
				 0x02, 0x16, 0x02, 0x04, 0x00, 0x00, 0x13, 0xC0, 
				 0x00, 0x1E, 0x01, 0x00, 0x00, 0x00, 0x00, 0x19, 
				 0xC0, 0x00, 0x13, 0xEA, 0x00, 0x1E, 0x00, 0xFF, 
				 0xC0, 0x00, 0x00, 0x1E, 0x01, 0x00, 0x04, 0x00, 
				 0x00, 0x1F, 0x01, 0x00, 0x19, 0xEA, 0x00, 0x00, 0x00};

BYTE t5465_Mode_512x384x8_1[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x16, 0x05, 0x04, 0x00, 0x00, 0x16, 0xC0, 0x00, 
				 0x00, 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 
				 0x00, 0x1F, 0x01, 0x00, 0x18, 0xC5, 0x02, 0x18, 
				 0x07, 0x04, 0x15, 0xA0, 0x00, 0xFF, 0x00, 0x09, 
				 0xCE, 0x03, 0x06, 0x05, 0x09, 0xCE, 0x03, 0x09, 
				 0x00, 0x09, 0xCE, 0x03, 0x0A, 0x00, 0x09, 0xCE, 
				 0x03, 0x0B, 0x00, 0x16, 0x80, 0x00, 0xEF, 0x00, 
				 0x16, 0x84, 0x00, 0x31, 0x00, 0x16, 0x88, 0x00, 
				 0x6D, 0x00, 0x1D, 0x19, 0x00, 0x00, 0x00, 0x4F, 
				 0x00, 0x00, 0x00, 0x3F, 0x00, 0x00, 0x00, 0x3F, 
				 0x00, 0x00, 0x00, 0x89, 0x00, 0x00, 0x00, 0x42, 
				 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x24, 
				 0x00, 0x00, 0x00, 0xF5, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0xE0, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 
				 0x00, 0x00, 0x00, 0x88, 0x00, 0x00, 0x00, 0xFF, 
				 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 0x24, 
				 0x00, 0x00, 0x00, 0xE3, 0x00, 0x00, 0x00, 0xFF, 
				 0x00, 0x00, 0x00, 0x1D, 0x06, 0x00, 0x64, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0xD0, 0x00, 0x00, 0x00, 
				 0x22, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x13, 0xEA, 0x00, 0x1E, 0x00, 0x00, 0xC0, 0x00, 
				 0x00, 0x1E, 0x01, 0x11, 0x08, 0x00, 0x00, 0x1F, 
				 0x01, 0x00, 0x19, 0xEA, 0x00, 0x12, 0x07, 0x04, 
				 0x1E, 0x00, 0xC0, 0x00, 0x00, 0x00, 0x1E, 0x01, 
				 0x08, 0x00, 0x00, 0x00, 0x18, 0x07, 0x04, 0x13, 
				 0xC4, 0x02, 0x1E, 0x00, 0x3F, 0xC0, 0x00, 0x00, 
				 0x1E, 0x01, 0x80, 0x08, 0x00, 0x00, 0x1F, 0x01, 
				 0x00, 0x19, 0xC4, 0x02, 0x16, 0x02, 0x04, 0x00, 
				 0x00, 0x13, 0xC0, 0x00, 0x1E, 0x01, 0x00, 0x00, 
				 0x00, 0x00, 0x19, 0xC0, 0x00, 0x13, 0xEA, 0x00, 
				 0x1E, 0x00, 0xFF, 0xC0, 0x00, 0x00, 0x1E, 0x01, 
				 0x00, 0x04, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 
				 0xEA, 0x00, 0x00, 0x00};

BYTE t5465_Mode_512x384x8_2[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x16, 0x05, 0x04, 0x00, 0x00, 0x16, 0xC0, 0x00, 
				 0x00, 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 
				 0x00, 0x1F, 0x01, 0x00, 0x18, 0xC5, 0x02, 0x18, 
				 0x07, 0x04, 0x15, 0xA0, 0x00, 0xFF, 0x00, 0x09, 
				 0xCE, 0x03, 0x06, 0x05, 0x09, 0xCE, 0x03, 0x09, 
				 0x00, 0x09, 0xCE, 0x03, 0x0A, 0x00, 0x09, 0xCE, 
				 0x03, 0x0B, 0x00, 0x16, 0x80, 0x00, 0xEF, 0x00, 
				 0x16, 0x84, 0x00, 0x2B, 0x00, 0x16, 0x88, 0x00, 
				 0x6E, 0x00, 0x1D, 0x19, 0x00, 0x00, 0x00, 0x4E, 
				 0x00, 0x00, 0x00, 0x3F, 0x00, 0x00, 0x00, 0x3F, 
				 0x00, 0x00, 0x00, 0x88, 0x00, 0x00, 0x00, 0x42, 
				 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x24, 
				 0x00, 0x00, 0x00, 0xF5, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0xE0, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 
				 0x00, 0x00, 0x00, 0x88, 0x00, 0x00, 0x00, 0xFF, 
				 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 0x23, 
				 0x00, 0x00, 0x00, 0xE3, 0x00, 0x00, 0x00, 0xFF, 
				 0x00, 0x00, 0x00, 0x1D, 0x06, 0x00, 0x64, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0xD0, 0x00, 0x00, 0x00, 
				 0x22, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x13, 0xEA, 0x00, 0x1E, 0x00, 0x00, 0xC0, 0x00, 
				 0x00, 0x1E, 0x01, 0x11, 0x08, 0x00, 0x00, 0x1F, 
				 0x01, 0x00, 0x19, 0xEA, 0x00, 0x12, 0x07, 0x04, 
				 0x1E, 0x00, 0xC0, 0x00, 0x00, 0x00, 0x1E, 0x01, 
				 0x08, 0x00, 0x00, 0x00, 0x18, 0x07, 0x04, 0x13, 
				 0xC4, 0x02, 0x1E, 0x00, 0x3F, 0xC0, 0x00, 0x00, 
				 0x1E, 0x01, 0x80, 0x08, 0x00, 0x00, 0x1F, 0x01, 
				 0x00, 0x19, 0xC4, 0x02, 0x16, 0x02, 0x04, 0x00, 
				 0x00, 0x13, 0xC0, 0x00, 0x1E, 0x01, 0x00, 0x00, 
				 0x00, 0x00, 0x19, 0xC0, 0x00, 0x13, 0xEA, 0x00, 
				 0x1E, 0x00, 0xFF, 0xC0, 0x00, 0x00, 0x1E, 0x01, 
				 0x00, 0x04, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 
				 0xEA, 0x00, 0x00, 0x00};

BYTE t5465_Mode_512x480x8_1[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x16, 0x05, 0x04, 0x00, 0x00, 0x16, 0xC0, 0x00, 
				 0x00, 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 
				 0x00, 0x1F, 0x01, 0x00, 0x18, 0xC5, 0x02, 0x18, 
				 0x07, 0x04, 0x15, 0xA0, 0x00, 0xFF, 0x00, 0x09, 
				 0xCE, 0x03, 0x06, 0x05, 0x09, 0xCE, 0x03, 0x09, 
				 0x00, 0x09, 0xCE, 0x03, 0x0A, 0x00, 0x09, 0xCE, 
				 0x03, 0x0B, 0x00, 0x16, 0x80, 0x00, 0x2F, 0x00, 
				 0x16, 0x84, 0x00, 0x10, 0x00, 0x16, 0x88, 0x00, 
				 0x2D, 0x00, 0x16, 0xC0, 0x00, 0x00, 0x80, 0x1D, 
				 0x19, 0x00, 0x00, 0x00, 0x4B, 0x00, 0x00, 0x00, 
				 0x3F, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 
				 0x4B, 0x00, 0x00, 0x00, 0x44, 0x00, 0x00, 0x00, 
				 0x08, 0x00, 0x00, 0x00, 0xF0, 0x00, 0x00, 0x00, 
				 0x1F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0xE1, 0x00, 0x00, 0x00, 
				 0x84, 0x00, 0x00, 0x00, 0xDF, 0x00, 0x00, 0x00, 
				 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0xE0, 0x00, 0x00, 0x00, 0xF0, 0x00, 0x00, 0x00, 
				 0xE3, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 
				 0x1D, 0x06, 0x00, 0x64, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x50, 0x00, 0x00, 0x00, 0x22, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x13, 0xEA, 0x00, 
				 0x1E, 0x00, 0x00, 0xC0, 0x00, 0x00, 0x1E, 0x01, 
				 0x11, 0x08, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 
				 0xEA, 0x00, 0x12, 0x07, 0x04, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x08, 0x00, 0x00, 
				 0x00, 0x18, 0x07, 0x04, 0x13, 0xC4, 0x02, 0x1E, 
				 0x00, 0x3F, 0xC0, 0x00, 0x00, 0x1E, 0x01, 0x80, 
				 0x08, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 0xC4, 
				 0x02, 0x16, 0x02, 0x04, 0x00, 0x00, 0x13, 0xC0, 
				 0x00, 0x1E, 0x01, 0x00, 0x00, 0x00, 0x00, 0x19, 
				 0xC0, 0x00, 0x13, 0xEA, 0x00, 0x1E, 0x00, 0xFF, 
				 0xC0, 0x00, 0x00, 0x1E, 0x01, 0x00, 0x04, 0x00, 
				 0x00, 0x1F, 0x01, 0x00, 0x19, 0xEA, 0x00, 0x00, 0x00};

BYTE t5465_Mode_512x480x8_2[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x16, 0x05, 0x04, 0x00, 0x00, 0x16, 0xC0, 0x00, 
				 0x00, 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 
				 0x00, 0x1F, 0x01, 0x00, 0x18, 0xC5, 0x02, 0x18, 
				 0x07, 0x04, 0x15, 0xA0, 0x00, 0xFF, 0x00, 0x09, 
				 0xCE, 0x03, 0x06, 0x05, 0x09, 0xCE, 0x03, 0x09, 
				 0x00, 0x09, 0xCE, 0x03, 0x0A, 0x00, 0x09, 0xCE, 
				 0x03, 0x0B, 0x00, 0x16, 0x80, 0x00, 0x2F, 0x00, 
				 0x16, 0x84, 0x00, 0x12, 0x00, 0x16, 0x88, 0x00, 
				 0x3E, 0x00, 0x16, 0xC0, 0x00, 0x00, 0x80, 0x1D, 
				 0x19, 0x00, 0x00, 0x00, 0x4D, 0x00, 0x00, 0x00, 
				 0x3F, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 
				 0x8D, 0x00, 0x00, 0x00, 0x44, 0x00, 0x00, 0x00, 
				 0x09, 0x00, 0x00, 0x00, 0xF4, 0x00, 0x00, 0x00, 
				 0x1F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0xE1, 0x00, 0x00, 0x00, 
				 0x84, 0x00, 0x00, 0x00, 0xDF, 0x00, 0x00, 0x00, 
				 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0xE0, 0x00, 0x00, 0x00, 0xF4, 0x00, 0x00, 0x00, 
				 0xE3, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 
				 0x1D, 0x06, 0x00, 0x64, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x50, 0x00, 0x00, 0x00, 0x22, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x13, 0xEA, 0x00, 
				 0x1E, 0x00, 0x00, 0xC0, 0x00, 0x00, 0x1E, 0x01, 
				 0x11, 0x08, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 
				 0xEA, 0x00, 0x12, 0x07, 0x04, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x08, 0x00, 0x00, 
				 0x00, 0x18, 0x07, 0x04, 0x13, 0xC4, 0x02, 0x1E, 
				 0x00, 0x3F, 0xC0, 0x00, 0x00, 0x1E, 0x01, 0x80, 
				 0x08, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 0xC4, 
				 0x02, 0x16, 0x02, 0x04, 0x00, 0x00, 0x13, 0xC0, 
				 0x00, 0x1E, 0x01, 0x00, 0x00, 0x00, 0x00, 0x19, 
				 0xC0, 0x00, 0x13, 0xEA, 0x00, 0x1E, 0x00, 0xFF, 
				 0xC0, 0x00, 0x00, 0x1E, 0x01, 0x00, 0x04, 0x00, 
				 0x00, 0x1F, 0x01, 0x00, 0x19, 0xEA, 0x00, 0x00, 0x00};

BYTE t5465_Mode_640x350x8_1[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x16, 0x05, 0x04, 0x00, 0x00, 0x16, 0xC0, 0x00, 
				 0x00, 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 
				 0x00, 0x1F, 0x01, 0x00, 0x18, 0xC5, 0x02, 0x18, 
				 0x07, 0x04, 0x15, 0xA0, 0x00, 0xFF, 0x00, 0x09, 
				 0xCE, 0x03, 0x06, 0x05, 0x09, 0xCE, 0x03, 0x09, 
				 0x00, 0x09, 0xCE, 0x03, 0x0A, 0x00, 0x09, 0xCE, 
				 0x03, 0x0B, 0x00, 0x16, 0x80, 0x00, 0xAF, 0x00, 
				 0x16, 0x84, 0x00, 0x3B, 0x00, 0x16, 0x88, 0x00, 
				 0x69, 0x00, 0x1D, 0x19, 0x00, 0x00, 0x00, 0x63, 
				 0x00, 0x00, 0x00, 0x4F, 0x00, 0x00, 0x00, 0x4F, 
				 0x00, 0x00, 0x00, 0x83, 0x00, 0x00, 0x00, 0x53, 
				 0x00, 0x00, 0x00, 0x97, 0x00, 0x00, 0x00, 0xBB, 
				 0x00, 0x00, 0x00, 0x1F, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7D, 
				 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x5D, 
				 0x00, 0x00, 0x00, 0xA0, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x5D, 0x00, 0x00, 0x00, 0xBB, 
				 0x00, 0x00, 0x00, 0xE3, 0x00, 0x00, 0x00, 0xFF, 
				 0x00, 0x00, 0x00, 0x1D, 0x06, 0x00, 0x64, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x50, 0x00, 0x00, 0x00, 
				 0x22, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x13, 0xEA, 0x00, 0x1E, 0x00, 0x00, 0xC0, 0x00, 
				 0x00, 0x1E, 0x01, 0x11, 0x0A, 0x00, 0x00, 0x1F, 
				 0x01, 0x00, 0x19, 0xEA, 0x00, 0x12, 0x07, 0x04, 
				 0x1E, 0x00, 0xC0, 0x00, 0x00, 0x00, 0x1E, 0x01, 
				 0x0A, 0x00, 0x00, 0x00, 0x18, 0x07, 0x04, 0x13, 
				 0xC4, 0x02, 0x1E, 0x00, 0x3F, 0xC0, 0x00, 0x00, 
				 0x1E, 0x01, 0x80, 0x0A, 0x00, 0x00, 0x1F, 0x01, 
				 0x00, 0x19, 0xC4, 0x02, 0x16, 0x02, 0x04, 0x00, 
				 0x00, 0x13, 0xC0, 0x00, 0x1E, 0x01, 0x00, 0x00, 
				 0x00, 0x00, 0x19, 0xC0, 0x00, 0x13, 0xEA, 0x00, 
				 0x1E, 0x00, 0xFF, 0xC0, 0x00, 0x00, 0x1E, 0x01, 
				 0x00, 0x05, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 
				 0xEA, 0x00, 0x00, 0x00};

BYTE t5465_Mode_640x350x8_2[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x16, 0x05, 0x04, 0x00, 0x00, 0x16, 0xC0, 0x00, 
				 0x00, 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 
				 0x00, 0x1F, 0x01, 0x00, 0x18, 0xC5, 0x02, 0x18, 
				 0x07, 0x04, 0x15, 0xA0, 0x00, 0xFF, 0x00, 0x09, 
				 0xCE, 0x03, 0x06, 0x05, 0x09, 0xCE, 0x03, 0x09, 
				 0x00, 0x09, 0xCE, 0x03, 0x0A, 0x00, 0x09, 0xCE, 
				 0x03, 0x0B, 0x00, 0x16, 0x80, 0x00, 0xAF, 0x00, 
				 0x16, 0x84, 0x00, 0x0B, 0x00, 0x16, 0x88, 0x00, 
				 0x16, 0x00, 0x1D, 0x19, 0x00, 0x00, 0x00, 0x63, 
				 0x00, 0x00, 0x00, 0x4F, 0x00, 0x00, 0x00, 0x4F, 
				 0x00, 0x00, 0x00, 0x83, 0x00, 0x00, 0x00, 0x55, 
				 0x00, 0x00, 0x00, 0x99, 0x00, 0x00, 0x00, 0xBB, 
				 0x00, 0x00, 0x00, 0x1F, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7D, 
				 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x5D, 
				 0x00, 0x00, 0x00, 0xA0, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x5D, 0x00, 0x00, 0x00, 0xBB, 
				 0x00, 0x00, 0x00, 0xE3, 0x00, 0x00, 0x00, 0xFF, 
				 0x00, 0x00, 0x00, 0x1D, 0x06, 0x00, 0x64, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x50, 0x00, 0x00, 0x00, 
				 0x22, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x13, 0xEA, 0x00, 0x1E, 0x00, 0x00, 0xC0, 0x00, 
				 0x00, 0x1E, 0x01, 0x11, 0x0A, 0x00, 0x00, 0x1F, 
				 0x01, 0x00, 0x19, 0xEA, 0x00, 0x12, 0x07, 0x04, 
				 0x1E, 0x00, 0xC0, 0x00, 0x00, 0x00, 0x1E, 0x01, 
				 0x0A, 0x00, 0x00, 0x00, 0x18, 0x07, 0x04, 0x13, 
				 0xC4, 0x02, 0x1E, 0x00, 0x3F, 0xC0, 0x00, 0x00, 
				 0x1E, 0x01, 0x80, 0x0A, 0x00, 0x00, 0x1F, 0x01, 
				 0x00, 0x19, 0xC4, 0x02, 0x16, 0x02, 0x04, 0x00, 
				 0x00, 0x13, 0xC0, 0x00, 0x1E, 0x01, 0x00, 0x00, 
				 0x00, 0x00, 0x19, 0xC0, 0x00, 0x13, 0xEA, 0x00, 
				 0x1E, 0x00, 0xFF, 0xC0, 0x00, 0x00, 0x1E, 0x01, 
				 0x00, 0x05, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 
				 0xEA, 0x00, 0x00, 0x00};

BYTE t5465_Mode_640x400x8_1[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x16, 0x05, 0x04, 0x00, 0x00, 0x16, 0xC0, 0x00, 
				 0x00, 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 
				 0x00, 0x1F, 0x01, 0x00, 0x18, 0xC5, 0x02, 0x18, 
				 0x07, 0x04, 0x15, 0xA0, 0x00, 0xFF, 0x00, 0x09, 
				 0xCE, 0x03, 0x06, 0x05, 0x09, 0xCE, 0x03, 0x09, 
				 0x00, 0x09, 0xCE, 0x03, 0x0A, 0x00, 0x09, 0xCE, 
				 0x03, 0x0B, 0x00, 0x16, 0x80, 0x00, 0x6F, 0x00, 
				 0x16, 0x84, 0x00, 0x3F, 0x00, 0x16, 0x88, 0x00, 
				 0x6D, 0x00, 0x1D, 0x19, 0x00, 0x00, 0x00, 0x5F, 
				 0x00, 0x00, 0x00, 0x4F, 0x00, 0x00, 0x00, 0x50, 
				 0x00, 0x00, 0x00, 0x82, 0x00, 0x00, 0x00, 0x53, 
				 0x00, 0x00, 0x00, 0x9F, 0x00, 0x00, 0x00, 0xBF, 
				 0x00, 0x00, 0x00, 0x1F, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xA1, 
				 0x00, 0x00, 0x00, 0xA3, 0x00, 0x00, 0x00, 0x8F, 
				 0x00, 0x00, 0x00, 0x50, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x96, 0x00, 0x00, 0x00, 0xB9, 
				 0x00, 0x00, 0x00, 0xE3, 0x00, 0x00, 0x00, 0xFF, 
				 0x00, 0x00, 0x00, 0x1D, 0x06, 0x00, 0x64, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x50, 0x00, 0x00, 0x00, 
				 0x22, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x13, 0xEA, 0x00, 0x1E, 0x00, 0x00, 0xC0, 0x00, 
				 0x00, 0x1E, 0x01, 0x11, 0x05, 0x00, 0x00, 0x1F, 
				 0x01, 0x00, 0x19, 0xEA, 0x00, 0x12, 0x07, 0x04, 
				 0x1E, 0x00, 0xC0, 0x00, 0x00, 0x00, 0x1E, 0x01, 
				 0x05, 0x00, 0x00, 0x00, 0x18, 0x07, 0x04, 0x13, 
				 0xC4, 0x02, 0x1E, 0x00, 0x3F, 0xC0, 0x00, 0x00, 
				 0x1E, 0x01, 0x80, 0x05, 0x00, 0x00, 0x1F, 0x01, 
				 0x00, 0x19, 0xC4, 0x02, 0x16, 0x02, 0x04, 0x00, 
				 0x00, 0x13, 0xC0, 0x00, 0x1E, 0x01, 0x00, 0x00, 
				 0x00, 0x00, 0x19, 0xC0, 0x00, 0x13, 0xEA, 0x00, 
				 0x1E, 0x00, 0xFF, 0xC0, 0x00, 0x00, 0x1E, 0x01, 
				 0x00, 0x05, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 
				 0xEA, 0x00, 0x00, 0x00};

BYTE t5465_Mode_640x400x8_1a[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x16, 0x05, 0x04, 0x00, 0x00, 0x16, 0xC0, 0x00, 
				 0x00, 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 
				 0x00, 0x1F, 0x01, 0x00, 0x18, 0xC5, 0x02, 0x18, 
				 0x07, 0x04, 0x15, 0xA0, 0x00, 0xFF, 0x00, 0x09, 
				 0xCE, 0x03, 0x06, 0x05, 0x09, 0xCE, 0x03, 0x09, 
				 0x00, 0x09, 0xCE, 0x03, 0x0A, 0x00, 0x09, 0xCE, 
				 0x03, 0x0B, 0x00, 0x16, 0x80, 0x00, 0x6F, 0x00, 
				 0x16, 0x84, 0x00, 0x3F, 0x00, 0x16, 0x88, 0x00, 
				 0x6D, 0x00, 0x1D, 0x19, 0x00, 0x00, 0x00, 0x5F, 
				 0x00, 0x00, 0x00, 0x4F, 0x00, 0x00, 0x00, 0x50, 
				 0x00, 0x00, 0x00, 0x82, 0x00, 0x00, 0x00, 0x53, 
				 0x00, 0x00, 0x00, 0x9F, 0x00, 0x00, 0x00, 0xBF, 
				 0x00, 0x00, 0x00, 0x1F, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xA1, 
				 0x00, 0x00, 0x00, 0xA3, 0x00, 0x00, 0x00, 0x8F, 
				 0x00, 0x00, 0x00, 0x50, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x96, 0x00, 0x00, 0x00, 0xB9, 
				 0x00, 0x00, 0x00, 0xE3, 0x00, 0x00, 0x00, 0xFF, 
				 0x00, 0x00, 0x00, 0x1D, 0x06, 0x00, 0x64, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x50, 0x00, 0x00, 0x00, 
				 0x22, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x13, 0xEA, 0x00, 0x1E, 0x00, 0x00, 0xC0, 0x00, 
				 0x00, 0x1E, 0x01, 0xD1, 0x0A, 0x00, 0x00, 0x1F, 
				 0x01, 0x00, 0x19, 0xEA, 0x00, 0x12, 0x07, 0x04, 
				 0x1E, 0x00, 0xC0, 0x00, 0x00, 0x00, 0x1E, 0x01, 
				 0x05, 0x00, 0x00, 0x00, 0x18, 0x07, 0x04, 0x13, 
				 0xC4, 0x02, 0x1E, 0x00, 0x3F, 0xC0, 0x00, 0x00, 
				 0x1E, 0x01, 0xC0, 0x05, 0x00, 0x00, 0x1F, 0x01, 
				 0x00, 0x19, 0xC4, 0x02, 0x16, 0x02, 0x04, 0x00, 
				 0x08, 0x13, 0xC0, 0x00, 0x1E, 0x01, 0x00, 0x00, 
				 0x00, 0x00, 0x19, 0xC0, 0x00, 0x17, 0x4C, 0x00, 
				 0xA0, 0x00, 0x00, 0x00, 0x13, 0xEA, 0x00, 0x1E, 
				 0x00, 0xFF, 0xC0, 0x00, 0x00, 0x1E, 0x01, 0x00, 
				 0x05, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 0xEA, 
				 0x00, 0x00, 0x00};

BYTE t5465_Mode_640x400x8_2[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x16, 0x05, 0x04, 0x00, 0x00, 0x16, 0xC0, 0x00, 
				 0x00, 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 
				 0x00, 0x1F, 0x01, 0x00, 0x18, 0xC5, 0x02, 0x18, 
				 0x07, 0x04, 0x15, 0xA0, 0x00, 0xFF, 0x00, 0x09, 
				 0xCE, 0x03, 0x06, 0x05, 0x09, 0xCE, 0x03, 0x09, 
				 0x00, 0x09, 0xCE, 0x03, 0x0A, 0x00, 0x09, 0xCE, 
				 0x03, 0x0B, 0x00, 0x16, 0x80, 0x00, 0x6F, 0x00, 
				 0x16, 0x84, 0x00, 0x0B, 0x00, 0x16, 0x88, 0x00, 
				 0x16, 0x00, 0x1D, 0x19, 0x00, 0x00, 0x00, 0x63, 
				 0x00, 0x00, 0x00, 0x4F, 0x00, 0x00, 0x00, 0x4F, 
				 0x00, 0x00, 0x00, 0x83, 0x00, 0x00, 0x00, 0x55, 
				 0x00, 0x00, 0x00, 0x99, 0x00, 0x00, 0x00, 0xBB, 
				 0x00, 0x00, 0x00, 0x1F, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x90, 
				 0x00, 0x00, 0x00, 0x83, 0x00, 0x00, 0x00, 0x8F, 
				 0x00, 0x00, 0x00, 0x50, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x8F, 0x00, 0x00, 0x00, 0xBB, 
				 0x00, 0x00, 0x00, 0xE3, 0x00, 0x00, 0x00, 0xFF, 
				 0x00, 0x00, 0x00, 0x1D, 0x06, 0x00, 0x64, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x50, 0x00, 0x00, 0x00, 
				 0x22, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x13, 0xEA, 0x00, 0x1E, 0x00, 0x00, 0xC0, 0x00, 
				 0x00, 0x1E, 0x01, 0x11, 0x05, 0x00, 0x00, 0x1F, 
				 0x01, 0x00, 0x19, 0xEA, 0x00, 0x12, 0x07, 0x04, 
				 0x1E, 0x00, 0xC0, 0x00, 0x00, 0x00, 0x1E, 0x01, 
				 0x05, 0x00, 0x00, 0x00, 0x18, 0x07, 0x04, 0x13, 
				 0xC4, 0x02, 0x1E, 0x00, 0x3F, 0xC0, 0x00, 0x00, 
				 0x1E, 0x01, 0x80, 0x05, 0x00, 0x00, 0x1F, 0x01, 
				 0x00, 0x19, 0xC4, 0x02, 0x16, 0x02, 0x04, 0x00, 
				 0x00, 0x13, 0xC0, 0x00, 0x1E, 0x01, 0x00, 0x00, 
				 0x00, 0x00, 0x19, 0xC0, 0x00, 0x13, 0xEA, 0x00, 
				 0x1E, 0x00, 0xFF, 0xC0, 0x00, 0x00, 0x1E, 0x01, 
				 0x00, 0x05, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 
				 0xEA, 0x00, 0x00, 0x1F};

BYTE t5465_Mode_640x400x8_2a[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x16, 0x05, 0x04, 0x00, 0x00, 0x16, 0xC0, 0x00, 
				 0x00, 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 
				 0x00, 0x1F, 0x01, 0x00, 0x18, 0xC5, 0x02, 0x18, 
				 0x07, 0x04, 0x15, 0xA0, 0x00, 0xFF, 0x00, 0x09, 
				 0xCE, 0x03, 0x06, 0x05, 0x09, 0xCE, 0x03, 0x09, 
				 0x00, 0x09, 0xCE, 0x03, 0x0A, 0x00, 0x09, 0xCE, 
				 0x03, 0x0B, 0x00, 0x16, 0x80, 0x00, 0x6F, 0x00, 
				 0x16, 0x84, 0x00, 0x0B, 0x00, 0x16, 0x88, 0x00, 
				 0x16, 0x00, 0x1D, 0x19, 0x00, 0x00, 0x00, 0x63, 
				 0x00, 0x00, 0x00, 0x4F, 0x00, 0x00, 0x00, 0x4F, 
				 0x00, 0x00, 0x00, 0x83, 0x00, 0x00, 0x00, 0x55, 
				 0x00, 0x00, 0x00, 0x99, 0x00, 0x00, 0x00, 0xBB, 
				 0x00, 0x00, 0x00, 0x1F, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x90, 
				 0x00, 0x00, 0x00, 0x83, 0x00, 0x00, 0x00, 0x8F, 
				 0x00, 0x00, 0x00, 0x50, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x8F, 0x00, 0x00, 0x00, 0xBB, 
				 0x00, 0x00, 0x00, 0xE3, 0x00, 0x00, 0x00, 0xFF, 
				 0x00, 0x00, 0x00, 0x1D, 0x06, 0x00, 0x64, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x50, 0x00, 0x00, 0x00, 
				 0x22, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x13, 0xEA, 0x00, 0x1E, 0x00, 0x00, 0xC0, 0x00, 
				 0x00, 0x1E, 0x01, 0xD1, 0x0A, 0x00, 0x00, 0x1F, 
				 0x01, 0x00, 0x19, 0xEA, 0x00, 0x12, 0x07, 0x04, 
				 0x1E, 0x00, 0xC0, 0x00, 0x00, 0x00, 0x1E, 0x01, 
				 0x05, 0x00, 0x00, 0x00, 0x18, 0x07, 0x04, 0x13, 
				 0xC4, 0x02, 0x1E, 0x00, 0x3F, 0xC0, 0x00, 0x00, 
				 0x1E, 0x01, 0xC0, 0x05, 0x00, 0x00, 0x1F, 0x01, 
				 0x00, 0x19, 0xC4, 0x02, 0x16, 0x02, 0x04, 0x00, 
				 0x08, 0x13, 0xC0, 0x00, 0x1E, 0x01, 0x00, 0x00, 
				 0x00, 0x00, 0x19, 0xC0, 0x00, 0x17, 0x4C, 0x00, 
				 0xA0, 0x00, 0x00, 0x00, 0x13, 0xEA, 0x00, 0x1E, 
				 0x00, 0xFF, 0xC0, 0x00, 0x00, 0x1E, 0x01, 0x00, 
				 0x05, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 0xEA, 
				 0x00, 0x00, 0x00};

BYTE t5465_Mode_640x400x8_3[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x16, 0x05, 0x04, 0x00, 0x00, 0x16, 0xC0, 0x00, 
				 0x00, 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 
				 0x00, 0x1F, 0x01, 0x00, 0x18, 0xC5, 0x02, 0x18, 
				 0x07, 0x04, 0x15, 0xA0, 0x00, 0xFF, 0x00, 0x09, 
				 0xCE, 0x03, 0x06, 0x05, 0x09, 0xCE, 0x03, 0x09, 
				 0x00, 0x09, 0xCE, 0x03, 0x0A, 0x00, 0x09, 0xCE, 
				 0x03, 0x0B, 0x00, 0x16, 0x80, 0x00, 0x6F, 0x00, 
				 0x16, 0x84, 0x00, 0x0B, 0x00, 0x16, 0x88, 0x00, 
				 0x16, 0x00, 0x1D, 0x19, 0x00, 0x00, 0x00, 0x63, 
				 0x00, 0x00, 0x00, 0x4F, 0x00, 0x00, 0x00, 0x4F, 
				 0x00, 0x00, 0x00, 0x83, 0x00, 0x00, 0x00, 0x55, 
				 0x00, 0x00, 0x00, 0x99, 0x00, 0x00, 0x00, 0xBB, 
				 0x00, 0x00, 0x00, 0x1F, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x90, 
				 0x00, 0x00, 0x00, 0x83, 0x00, 0x00, 0x00, 0x8F, 
				 0x00, 0x00, 0x00, 0x50, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x8F, 0x00, 0x00, 0x00, 0xBB, 
				 0x00, 0x00, 0x00, 0xE3, 0x00, 0x00, 0x00, 0xFF, 
				 0x00, 0x00, 0x00, 0x1D, 0x06, 0x00, 0x64, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x50, 0x00, 0x00, 0x00, 
				 0x22, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x16, 0x84, 0x00, 0x32, 0x00, 0x16, 0x88, 0x00, 
				 0x61, 0x00, 0x13, 0xEA, 0x00, 0x1E, 0x00, 0x00, 
				 0xC0, 0x00, 0x00, 0x1E, 0x01, 0x11, 0x05, 0x00, 
				 0x00, 0x1F, 0x01, 0x00, 0x19, 0xEA, 0x00, 0x12, 
				 0x07, 0x04, 0x1E, 0x00, 0xC0, 0x00, 0x00, 0x00, 
				 0x1E, 0x01, 0x05, 0x00, 0x00, 0x00, 0x18, 0x07, 
				 0x04, 0x13, 0xC4, 0x02, 0x1E, 0x00, 0x3F, 0xC0, 
				 0x00, 0x00, 0x1E, 0x01, 0x80, 0x05, 0x00, 0x00, 
				 0x1F, 0x01, 0x00, 0x19, 0xC4, 0x02, 0x16, 0x02, 
				 0x04, 0x00, 0x00, 0x13, 0xC0, 0x00, 0x1E, 0x01, 
				 0x00, 0x00, 0x00, 0x00, 0x19, 0xC0, 0x00, 0x13, 
				 0xEA, 0x00, 0x1E, 0x00, 0xFF, 0xC0, 0x00, 0x00, 
				 0x1E, 0x01, 0x00, 0x05, 0x00, 0x00, 0x1F, 0x01, 
				 0x00, 0x19, 0xEA, 0x00, 0x00, 0x00};

BYTE t5465_Mode_640x400x8_3a[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x16, 0x05, 0x04, 0x00, 0x00, 0x16, 0xC0, 0x00, 
				 0x00, 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 
				 0x00, 0x1F, 0x01, 0x00, 0x18, 0xC5, 0x02, 0x18, 
				 0x07, 0x04, 0x15, 0xA0, 0x00, 0xFF, 0x00, 0x09, 
				 0xCE, 0x03, 0x06, 0x05, 0x09, 0xCE, 0x03, 0x09, 
				 0x00, 0x09, 0xCE, 0x03, 0x0A, 0x00, 0x09, 0xCE, 
				 0x03, 0x0B, 0x00, 0x16, 0x80, 0x00, 0x6F, 0x00, 
				 0x16, 0x84, 0x00, 0x0B, 0x00, 0x16, 0x88, 0x00, 
				 0x16, 0x00, 0x1D, 0x19, 0x00, 0x00, 0x00, 0x63, 
				 0x00, 0x00, 0x00, 0x4F, 0x00, 0x00, 0x00, 0x4F, 
				 0x00, 0x00, 0x00, 0x83, 0x00, 0x00, 0x00, 0x55, 
				 0x00, 0x00, 0x00, 0x99, 0x00, 0x00, 0x00, 0xBB, 
				 0x00, 0x00, 0x00, 0x1F, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x90, 
				 0x00, 0x00, 0x00, 0x83, 0x00, 0x00, 0x00, 0x8F, 
				 0x00, 0x00, 0x00, 0x50, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x8F, 0x00, 0x00, 0x00, 0xBB, 
				 0x00, 0x00, 0x00, 0xE3, 0x00, 0x00, 0x00, 0xFF, 
				 0x00, 0x00, 0x00, 0x1D, 0x06, 0x00, 0x64, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x50, 0x00, 0x00, 0x00, 
				 0x22, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x16, 0x84, 0x00, 0x32, 0x00, 0x16, 0x88, 0x00, 
				 0x61, 0x00, 0x13, 0xEA, 0x00, 0x1E, 0x00, 0x00, 
				 0xC0, 0x00, 0x00, 0x1E, 0x01, 0xD1, 0x0A, 0x00, 
				 0x00, 0x1F, 0x01, 0x00, 0x19, 0xEA, 0x00, 0x12, 
				 0x07, 0x04, 0x1E, 0x00, 0xC0, 0x00, 0x00, 0x00, 
				 0x1E, 0x01, 0x05, 0x00, 0x00, 0x00, 0x18, 0x07, 
				 0x04, 0x13, 0xC4, 0x02, 0x1E, 0x00, 0x3F, 0xC0, 
				 0x00, 0x00, 0x1E, 0x01, 0xC0, 0x05, 0x00, 0x00, 
				 0x1F, 0x01, 0x00, 0x19, 0xC4, 0x02, 0x16, 0x02, 
				 0x04, 0x00, 0x08, 0x13, 0xC0, 0x00, 0x1E, 0x01, 
				 0x00, 0x00, 0x00, 0x00, 0x19, 0xC0, 0x00, 0x17, 
				 0x4C, 0x00, 0xA0, 0x00, 0x00, 0x00, 0x13, 0xEA, 
				 0x00, 0x1E, 0x00, 0xFF, 0xC0, 0x00, 0x00, 0x1E, 
				 0x01, 0x00, 0x05, 0x00, 0x00, 0x1F, 0x01, 0x00, 
				 0x19, 0xEA, 0x00, 0x00, 0xC0};

BYTE t5465_Mode_800x600x8_1[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x16, 0x05, 0x04, 0x00, 0x00, 0x16, 0xC0, 0x00, 
				 0x00, 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 
				 0x00, 0x1F, 0x01, 0x00, 0x18, 0xC5, 0x02, 0x18, 
				 0x07, 0x04, 0x15, 0xA0, 0x00, 0xFF, 0x00, 0x09, 
				 0xCE, 0x03, 0x06, 0x05, 0x09, 0xCE, 0x03, 0x09, 
				 0x00, 0x09, 0xCE, 0x03, 0x0A, 0x00, 0x09, 0xCE, 
				 0x03, 0x0B, 0x00, 0x16, 0x80, 0x00, 0x2F, 0x00, 
				 0x16, 0x84, 0x00, 0x33, 0x00, 0x16, 0x88, 0x00, 
				 0x7E, 0x00, 0x1D, 0x19, 0x00, 0x00, 0x00, 0x7B, 
				 0x00, 0x00, 0x00, 0x63, 0x00, 0x00, 0x00, 0x64, 
				 0x00, 0x00, 0x00, 0x9B, 0x00, 0x00, 0x00, 0x68, 
				 0x00, 0x00, 0x00, 0x91, 0x00, 0x00, 0x00, 0x6F, 
				 0x00, 0x00, 0x00, 0xF0, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x60, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x58, 
				 0x00, 0x00, 0x00, 0x8A, 0x00, 0x00, 0x00, 0x57, 
				 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x58, 0x00, 0x00, 0x00, 0x6F, 
				 0x00, 0x00, 0x00, 0xE3, 0x00, 0x00, 0x00, 0xFF, 
				 0x00, 0x00, 0x00, 0x1D, 0x06, 0x00, 0x64, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x90, 0x00, 0x00, 0x00, 
				 0x22, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x13, 0xEA, 0x00, 0x1E, 0x00, 0x00, 0xC0, 0x00, 
				 0x00, 0x1E, 0x01, 0x11, 0x08, 0x00, 0x00, 0x1F, 
				 0x01, 0x00, 0x19, 0xEA, 0x00, 0x12, 0x07, 0x04, 
				 0x1E, 0x00, 0xC0, 0x00, 0x00, 0x00, 0x1E, 0x01, 
				 0x08, 0x00, 0x00, 0x00, 0x18, 0x07, 0x04, 0x13, 
				 0xC4, 0x02, 0x1E, 0x00, 0x3F, 0xC0, 0x00, 0x00, 
				 0x1E, 0x01, 0x80, 0x08, 0x00, 0x00, 0x1F, 0x01, 
				 0x00, 0x19, 0xC4, 0x02, 0x16, 0x02, 0x04, 0x00, 
				 0x00, 0x13, 0xC0, 0x00, 0x1E, 0x01, 0x00, 0x00, 
				 0x00, 0x00, 0x19, 0xC0, 0x00, 0x13, 0xEA, 0x00, 
				 0x1E, 0x00, 0xFF, 0xC0, 0x00, 0x00, 0x1E, 0x01, 
				 0x00, 0x07, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 
				 0xEA, 0x00, 0x00, 0xFF};

BYTE t5465_Mode_800x600x8_2[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x16, 0x05, 0x04, 0x00, 0x00, 0x16, 0xC0, 0x00, 
				 0x00, 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 
				 0x00, 0x1F, 0x01, 0x00, 0x18, 0xC5, 0x02, 0x18, 
				 0x07, 0x04, 0x15, 0xA0, 0x00, 0xFF, 0x00, 0x09, 
				 0xCE, 0x03, 0x06, 0x05, 0x09, 0xCE, 0x03, 0x09, 
				 0x00, 0x09, 0xCE, 0x03, 0x0A, 0x00, 0x09, 0xCE, 
				 0x03, 0x0B, 0x00, 0x16, 0x80, 0x00, 0x2F, 0x00, 
				 0x16, 0x84, 0x00, 0x23, 0x00, 0x16, 0x88, 0x00, 
				 0x5F, 0x00, 0x1D, 0x19, 0x00, 0x00, 0x00, 0x7F, 
				 0x00, 0x00, 0x00, 0x63, 0x00, 0x00, 0x00, 0x64, 
				 0x00, 0x00, 0x00, 0x9F, 0x00, 0x00, 0x00, 0x6A, 
				 0x00, 0x00, 0x00, 0x9A, 0x00, 0x00, 0x00, 0x72, 
				 0x00, 0x00, 0x00, 0xF0, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x60, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x58, 
				 0x00, 0x00, 0x00, 0x8C, 0x00, 0x00, 0x00, 0x57, 
				 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x58, 0x00, 0x00, 0x00, 0x70, 
				 0x00, 0x00, 0x00, 0xE3, 0x00, 0x00, 0x00, 0xFF, 
				 0x00, 0x00, 0x00, 0x1D, 0x06, 0x00, 0x64, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x90, 0x00, 0x00, 0x00, 
				 0x22, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x13, 0xEA, 0x00, 0x1E, 0x00, 0x00, 0xC0, 0x00, 
				 0x00, 0x1E, 0x01, 0x11, 0x08, 0x00, 0x00, 0x1F, 
				 0x01, 0x00, 0x19, 0xEA, 0x00, 0x12, 0x07, 0x04, 
				 0x1E, 0x00, 0xC0, 0x00, 0x00, 0x00, 0x1E, 0x01, 
				 0x08, 0x00, 0x00, 0x00, 0x18, 0x07, 0x04, 0x13, 
				 0xC4, 0x02, 0x1E, 0x00, 0x3F, 0xC0, 0x00, 0x00, 
				 0x1E, 0x01, 0x80, 0x08, 0x00, 0x00, 0x1F, 0x01, 
				 0x00, 0x19, 0xC4, 0x02, 0x16, 0x02, 0x04, 0x00, 
				 0x00, 0x13, 0xC0, 0x00, 0x1E, 0x01, 0x00, 0x00, 
				 0x00, 0x00, 0x19, 0xC0, 0x00, 0x13, 0xEA, 0x00, 
				 0x1E, 0x00, 0xFF, 0xC0, 0x00, 0x00, 0x1E, 0x01, 
				 0x00, 0x07, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 
				 0xEA, 0x00, 0x00, 0xFF};

BYTE t5465_Mode_800x600x8_3[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x16, 0x05, 0x04, 0x00, 0x00, 0x16, 0xC0, 0x00, 
				 0x00, 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 
				 0x00, 0x1F, 0x01, 0x00, 0x18, 0xC5, 0x02, 0x18, 
				 0x07, 0x04, 0x15, 0xA0, 0x00, 0xFF, 0x00, 0x09, 
				 0xCE, 0x03, 0x06, 0x05, 0x09, 0xCE, 0x03, 0x09, 
				 0x00, 0x09, 0xCE, 0x03, 0x0A, 0x00, 0x09, 0xCE, 
				 0x03, 0x0B, 0x00, 0x16, 0x80, 0x00, 0x2F, 0x00, 
				 0x16, 0x84, 0x00, 0x25, 0x00, 0x16, 0x88, 0x00, 
				 0x7D, 0x00, 0x1D, 0x19, 0x00, 0x00, 0x00, 0x7D, 
				 0x00, 0x00, 0x00, 0x63, 0x00, 0x00, 0x00, 0x64, 
				 0x00, 0x00, 0x00, 0x9D, 0x00, 0x00, 0x00, 0x6C, 
				 0x00, 0x00, 0x00, 0x9B, 0x00, 0x00, 0x00, 0x97, 
				 0x00, 0x00, 0x00, 0xF0, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x60, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7C, 
				 0x00, 0x00, 0x00, 0x82, 0x00, 0x00, 0x00, 0x57, 
				 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x5F, 0x00, 0x00, 0x00, 0x97, 
				 0x00, 0x00, 0x00, 0xE3, 0x00, 0x00, 0x00, 0xFF, 
				 0x00, 0x00, 0x00, 0x1D, 0x06, 0x00, 0x64, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x90, 0x00, 0x00, 0x00, 
				 0x22, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x13, 0xEA, 0x00, 0x1E, 0x00, 0x00, 0xC0, 0x00, 
				 0x00, 0x1E, 0x01, 0x11, 0x08, 0x00, 0x00, 0x1F, 
				 0x01, 0x00, 0x19, 0xEA, 0x00, 0x12, 0x07, 0x04, 
				 0x1E, 0x00, 0xC0, 0x00, 0x00, 0x00, 0x1E, 0x01, 
				 0x08, 0x00, 0x00, 0x00, 0x18, 0x07, 0x04, 0x13, 
				 0xC4, 0x02, 0x1E, 0x00, 0x3F, 0xC0, 0x00, 0x00, 
				 0x1E, 0x01, 0x80, 0x08, 0x00, 0x00, 0x1F, 0x01, 
				 0x00, 0x19, 0xC4, 0x02, 0x16, 0x02, 0x04, 0x00, 
				 0x00, 0x13, 0xC0, 0x00, 0x1E, 0x01, 0x00, 0x00, 
				 0x00, 0x00, 0x19, 0xC0, 0x00, 0x13, 0xEA, 0x00, 
				 0x1E, 0x00, 0xFF, 0xC0, 0x00, 0x00, 0x1E, 0x01, 
				 0x00, 0x07, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 
				 0xEA, 0x00, 0x00, 0xFF};

BYTE t5465_Mode_800x600x8_4[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x16, 0x05, 0x04, 0x00, 0x00, 0x16, 0xC0, 0x00, 
				 0x00, 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 
				 0x00, 0x1F, 0x01, 0x00, 0x18, 0xC5, 0x02, 0x18, 
				 0x07, 0x04, 0x15, 0xA0, 0x00, 0xFF, 0x00, 0x09, 
				 0xCE, 0x03, 0x06, 0x05, 0x09, 0xCE, 0x03, 0x09, 
				 0x00, 0x09, 0xCE, 0x03, 0x0A, 0x00, 0x09, 0xCE, 
				 0x03, 0x0B, 0x00, 0x16, 0x80, 0x00, 0x2F, 0x00, 
				 0x16, 0x84, 0x00, 0x19, 0x00, 0x16, 0x88, 0x00, 
				 0x53, 0x00, 0x1D, 0x19, 0x00, 0x00, 0x00, 0x7F, 
				 0x00, 0x00, 0x00, 0x63, 0x00, 0x00, 0x00, 0x64, 
				 0x00, 0x00, 0x00, 0x9F, 0x00, 0x00, 0x00, 0x67, 
				 0x00, 0x00, 0x00, 0x91, 0x00, 0x00, 0x00, 0x6F, 
				 0x00, 0x00, 0x00, 0xF0, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x60, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x58, 
				 0x00, 0x00, 0x00, 0x8B, 0x00, 0x00, 0x00, 0x57, 
				 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x57, 0x00, 0x00, 0x00, 0x6F, 
				 0x00, 0x00, 0x00, 0xE3, 0x00, 0x00, 0x00, 0xFF, 
				 0x00, 0x00, 0x00, 0x1D, 0x06, 0x00, 0x64, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x90, 0x00, 0x00, 0x00, 
				 0x22, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x13, 0xEA, 0x00, 0x1E, 0x00, 0x00, 0xC0, 0x00, 
				 0x00, 0x1E, 0x01, 0x11, 0x08, 0x00, 0x00, 0x1F, 
				 0x01, 0x00, 0x19, 0xEA, 0x00, 0x12, 0x07, 0x04, 
				 0x1E, 0x00, 0xC0, 0x00, 0x00, 0x00, 0x1E, 0x01, 
				 0x08, 0x00, 0x00, 0x00, 0x18, 0x07, 0x04, 0x13, 
				 0xC4, 0x02, 0x1E, 0x00, 0x3F, 0xC0, 0x00, 0x00, 
				 0x1E, 0x01, 0x80, 0x08, 0x00, 0x00, 0x1F, 0x01, 
				 0x00, 0x19, 0xC4, 0x02, 0x16, 0x02, 0x04, 0x00, 
				 0x00, 0x13, 0xC0, 0x00, 0x1E, 0x01, 0x00, 0x00, 
				 0x00, 0x00, 0x19, 0xC0, 0x00, 0x13, 0xEA, 0x00, 
				 0x1E, 0x00, 0xFF, 0xC0, 0x00, 0x00, 0x1E, 0x01, 
				 0x00, 0x07, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 
				 0xEA, 0x00, 0x00, 0xFF};

BYTE t5465_Mode_800x600x8_5[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x16, 0x05, 0x04, 0x00, 0x00, 0x16, 0xC0, 0x00, 
				 0x00, 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 
				 0x00, 0x1F, 0x01, 0x00, 0x18, 0xC5, 0x02, 0x18, 
				 0x07, 0x04, 0x15, 0xA0, 0x00, 0xFF, 0x00, 0x09, 
				 0xCE, 0x03, 0x06, 0x05, 0x09, 0xCE, 0x03, 0x09, 
				 0x00, 0x09, 0xCE, 0x03, 0x0A, 0x00, 0x09, 0xCE, 
				 0x03, 0x0B, 0x00, 0x16, 0x80, 0x00, 0x2F, 0x00, 
				 0x16, 0x84, 0x00, 0x1C, 0x00, 0x16, 0x88, 0x00, 
				 0x37, 0x00, 0x1D, 0x19, 0x00, 0x00, 0x00, 0x7E, 
				 0x00, 0x00, 0x00, 0x63, 0x00, 0x00, 0x00, 0x64, 
				 0x00, 0x00, 0x00, 0x9E, 0x00, 0x00, 0x00, 0x69, 
				 0x00, 0x00, 0x00, 0x91, 0x00, 0x00, 0x00, 0x75, 
				 0x00, 0x00, 0x00, 0xF0, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x60, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x58, 
				 0x00, 0x00, 0x00, 0x8B, 0x00, 0x00, 0x00, 0x57, 
				 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x57, 0x00, 0x00, 0x00, 0x75, 
				 0x00, 0x00, 0x00, 0xE3, 0x00, 0x00, 0x00, 0xFF, 
				 0x00, 0x00, 0x00, 0x1D, 0x06, 0x00, 0x64, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x90, 0x00, 0x00, 0x00, 
				 0x22, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x13, 0xEA, 0x00, 0x1E, 0x00, 0x00, 0xC0, 0x00, 
				 0x00, 0x1E, 0x01, 0x11, 0x08, 0x00, 0x00, 0x1F, 
				 0x01, 0x00, 0x19, 0xEA, 0x00, 0x12, 0x07, 0x04, 
				 0x1E, 0x00, 0xC0, 0x00, 0x00, 0x00, 0x1E, 0x01, 
				 0x08, 0x00, 0x00, 0x00, 0x18, 0x07, 0x04, 0x13, 
				 0xC4, 0x02, 0x1E, 0x00, 0x3F, 0xC0, 0x00, 0x00, 
				 0x1E, 0x01, 0x80, 0x08, 0x00, 0x00, 0x1F, 0x01, 
				 0x00, 0x19, 0xC4, 0x02, 0x16, 0x02, 0x04, 0x00, 
				 0x00, 0x13, 0xC0, 0x00, 0x1E, 0x01, 0x00, 0x00, 
				 0x00, 0x00, 0x19, 0xC0, 0x00, 0x13, 0xEA, 0x00, 
				 0x1E, 0x00, 0xFF, 0xC0, 0x00, 0x00, 0x1E, 0x01, 
				 0x00, 0x07, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 
				 0xEA, 0x00, 0x00, 0xFF};

BYTE t5465_Mode_800x600x8_1a[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x16, 0x05, 0x04, 0x00, 0x00, 0x16, 0xC0, 0x00, 
				 0x00, 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 
				 0x00, 0x1F, 0x01, 0x00, 0x18, 0xC5, 0x02, 0x18, 
				 0x07, 0x04, 0x15, 0xA0, 0x00, 0xFF, 0x00, 0x09, 
				 0xCE, 0x03, 0x06, 0x05, 0x09, 0xCE, 0x03, 0x09, 
				 0x00, 0x09, 0xCE, 0x03, 0x0A, 0x00, 0x09, 0xCE, 
				 0x03, 0x0B, 0x00, 0x16, 0x80, 0x00, 0x2F, 0x00, 
				 0x16, 0x84, 0x00, 0x33, 0x00, 0x16, 0x88, 0x00, 
				 0x7E, 0x00, 0x1D, 0x19, 0x00, 0x00, 0x00, 0x7B, 
				 0x00, 0x00, 0x00, 0x63, 0x00, 0x00, 0x00, 0x64, 
				 0x00, 0x00, 0x00, 0x9B, 0x00, 0x00, 0x00, 0x68, 
				 0x00, 0x00, 0x00, 0x91, 0x00, 0x00, 0x00, 0x6F, 
				 0x00, 0x00, 0x00, 0xF0, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x60, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x58, 
				 0x00, 0x00, 0x00, 0x8A, 0x00, 0x00, 0x00, 0x57, 
				 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x58, 0x00, 0x00, 0x00, 0x6F, 
				 0x00, 0x00, 0x00, 0xE3, 0x00, 0x00, 0x00, 0xFF, 
				 0x00, 0x00, 0x00, 0x1D, 0x06, 0x00, 0x64, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x90, 0x00, 0x00, 0x00, 
				 0x22, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x13, 0xEA, 0x00, 0x1E, 0x00, 0x00, 0xC0, 0x00, 
				 0x00, 0x1E, 0x01, 0x12, 0x0D, 0x00, 0x00, 0x1F, 
				 0x01, 0x00, 0x19, 0xEA, 0x00, 0x12, 0x07, 0x04, 
				 0x1E, 0x00, 0xC0, 0x00, 0x00, 0x00, 0x1E, 0x01, 
				 0x0D, 0x00, 0x00, 0x00, 0x18, 0x07, 0x04, 0x13, 
				 0xC4, 0x02, 0x1E, 0x00, 0x3F, 0xC0, 0x00, 0x00, 
				 0x1E, 0x01, 0x80, 0x0D, 0x00, 0x00, 0x1F, 0x01, 
				 0x00, 0x19, 0xC4, 0x02, 0x16, 0x02, 0x04, 0x00, 
				 0x00, 0x13, 0xC0, 0x00, 0x1E, 0x01, 0x00, 0x00, 
				 0x00, 0x00, 0x19, 0xC0, 0x00, 0x17, 0x4C, 0x00, 
				 0xD0, 0x00, 0x00, 0x00, 0x13, 0xEA, 0x00, 0x1E, 
				 0x00, 0xFF, 0xC0, 0x00, 0x00, 0x1E, 0x01, 0x00, 
				 0x07, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 0xEA, 
				 0x00, 0x00, 0x05};

BYTE t5465_Mode_800x600x8_2a[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x16, 0x05, 0x04, 0x00, 0x00, 0x16, 0xC0, 0x00, 
				 0x00, 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 
				 0x00, 0x1F, 0x01, 0x00, 0x18, 0xC5, 0x02, 0x18, 
				 0x07, 0x04, 0x15, 0xA0, 0x00, 0xFF, 0x00, 0x09, 
				 0xCE, 0x03, 0x06, 0x05, 0x09, 0xCE, 0x03, 0x09, 
				 0x00, 0x09, 0xCE, 0x03, 0x0A, 0x00, 0x09, 0xCE, 
				 0x03, 0x0B, 0x00, 0x16, 0x80, 0x00, 0x2F, 0x00, 
				 0x16, 0x84, 0x00, 0x23, 0x00, 0x16, 0x88, 0x00, 
				 0x5F, 0x00, 0x1D, 0x19, 0x00, 0x00, 0x00, 0x7F, 
				 0x00, 0x00, 0x00, 0x63, 0x00, 0x00, 0x00, 0x64, 
				 0x00, 0x00, 0x00, 0x9F, 0x00, 0x00, 0x00, 0x6A, 
				 0x00, 0x00, 0x00, 0x9A, 0x00, 0x00, 0x00, 0x72, 
				 0x00, 0x00, 0x00, 0xF0, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x60, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x58, 
				 0x00, 0x00, 0x00, 0x8C, 0x00, 0x00, 0x00, 0x57, 
				 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x58, 0x00, 0x00, 0x00, 0x70, 
				 0x00, 0x00, 0x00, 0xE3, 0x00, 0x00, 0x00, 0xFF, 
				 0x00, 0x00, 0x00, 0x1D, 0x06, 0x00, 0x64, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x90, 0x00, 0x00, 0x00, 
				 0x22, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x13, 0xEA, 0x00, 0x1E, 0x00, 0x00, 0xC0, 0x00, 
				 0x00, 0x1E, 0x01, 0x12, 0x0D, 0x00, 0x00, 0x1F, 
				 0x01, 0x00, 0x19, 0xEA, 0x00, 0x12, 0x07, 0x04, 
				 0x1E, 0x00, 0xC0, 0x00, 0x00, 0x00, 0x1E, 0x01, 
				 0x0D, 0x00, 0x00, 0x00, 0x18, 0x07, 0x04, 0x13, 
				 0xC4, 0x02, 0x1E, 0x00, 0x3F, 0xC0, 0x00, 0x00, 
				 0x1E, 0x01, 0x80, 0x0D, 0x00, 0x00, 0x1F, 0x01, 
				 0x00, 0x19, 0xC4, 0x02, 0x16, 0x02, 0x04, 0x00, 
				 0x00, 0x13, 0xC0, 0x00, 0x1E, 0x01, 0x00, 0x00, 
				 0x00, 0x00, 0x19, 0xC0, 0x00, 0x17, 0x4C, 0x00, 
				 0xD0, 0x00, 0x00, 0x00, 0x13, 0xEA, 0x00, 0x1E, 
				 0x00, 0xFF, 0xC0, 0x00, 0x00, 0x1E, 0x01, 0x00, 
				 0x07, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 0xEA, 
				 0x00, 0x00, 0x05};

BYTE t5465_Mode_800x600x8_3a[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x16, 0x05, 0x04, 0x00, 0x00, 0x16, 0xC0, 0x00, 
				 0x00, 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 
				 0x00, 0x1F, 0x01, 0x00, 0x18, 0xC5, 0x02, 0x18, 
				 0x07, 0x04, 0x15, 0xA0, 0x00, 0xFF, 0x00, 0x09, 
				 0xCE, 0x03, 0x06, 0x05, 0x09, 0xCE, 0x03, 0x09, 
				 0x00, 0x09, 0xCE, 0x03, 0x0A, 0x00, 0x09, 0xCE, 
				 0x03, 0x0B, 0x00, 0x16, 0x80, 0x00, 0x2F, 0x00, 
				 0x16, 0x84, 0x00, 0x25, 0x00, 0x16, 0x88, 0x00, 
				 0x7D, 0x00, 0x1D, 0x19, 0x00, 0x00, 0x00, 0x7D, 
				 0x00, 0x00, 0x00, 0x63, 0x00, 0x00, 0x00, 0x64, 
				 0x00, 0x00, 0x00, 0x9D, 0x00, 0x00, 0x00, 0x6C, 
				 0x00, 0x00, 0x00, 0x9B, 0x00, 0x00, 0x00, 0x97, 
				 0x00, 0x00, 0x00, 0xF0, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x60, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7C, 
				 0x00, 0x00, 0x00, 0x82, 0x00, 0x00, 0x00, 0x57, 
				 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x5F, 0x00, 0x00, 0x00, 0x97, 
				 0x00, 0x00, 0x00, 0xE3, 0x00, 0x00, 0x00, 0xFF, 
				 0x00, 0x00, 0x00, 0x1D, 0x06, 0x00, 0x64, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x90, 0x00, 0x00, 0x00, 
				 0x22, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x13, 0xEA, 0x00, 0x1E, 0x00, 0x00, 0xC0, 0x00, 
				 0x00, 0x1E, 0x01, 0x12, 0x0D, 0x00, 0x00, 0x1F, 
				 0x01, 0x00, 0x19, 0xEA, 0x00, 0x12, 0x07, 0x04, 
				 0x1E, 0x00, 0xC0, 0x00, 0x00, 0x00, 0x1E, 0x01, 
				 0x0D, 0x00, 0x00, 0x00, 0x18, 0x07, 0x04, 0x13, 
				 0xC4, 0x02, 0x1E, 0x00, 0x3F, 0xC0, 0x00, 0x00, 
				 0x1E, 0x01, 0x80, 0x0D, 0x00, 0x00, 0x1F, 0x01, 
				 0x00, 0x19, 0xC4, 0x02, 0x16, 0x02, 0x04, 0x00, 
				 0x00, 0x13, 0xC0, 0x00, 0x1E, 0x01, 0x00, 0x00, 
				 0x00, 0x00, 0x19, 0xC0, 0x00, 0x17, 0x4C, 0x00, 
				 0xD0, 0x00, 0x00, 0x00, 0x13, 0xEA, 0x00, 0x1E, 
				 0x00, 0xFF, 0xC0, 0x00, 0x00, 0x1E, 0x01, 0x00, 
				 0x07, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 0xEA, 
				 0x00, 0x00, 0x05};

BYTE t5465_Mode_800x600x8_4a[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x16, 0x05, 0x04, 0x00, 0x00, 0x16, 0xC0, 0x00, 
				 0x00, 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 
				 0x00, 0x1F, 0x01, 0x00, 0x18, 0xC5, 0x02, 0x18, 
				 0x07, 0x04, 0x15, 0xA0, 0x00, 0xFF, 0x00, 0x09, 
				 0xCE, 0x03, 0x06, 0x05, 0x09, 0xCE, 0x03, 0x09, 
				 0x00, 0x09, 0xCE, 0x03, 0x0A, 0x00, 0x09, 0xCE, 
				 0x03, 0x0B, 0x00, 0x16, 0x80, 0x00, 0x2F, 0x00, 
				 0x16, 0x84, 0x00, 0x19, 0x00, 0x16, 0x88, 0x00, 
				 0x53, 0x00, 0x1D, 0x19, 0x00, 0x00, 0x00, 0x7F, 
				 0x00, 0x00, 0x00, 0x63, 0x00, 0x00, 0x00, 0x64, 
				 0x00, 0x00, 0x00, 0x9F, 0x00, 0x00, 0x00, 0x67, 
				 0x00, 0x00, 0x00, 0x91, 0x00, 0x00, 0x00, 0x6F, 
				 0x00, 0x00, 0x00, 0xF0, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x60, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x58, 
				 0x00, 0x00, 0x00, 0x8B, 0x00, 0x00, 0x00, 0x57, 
				 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x57, 0x00, 0x00, 0x00, 0x6F, 
				 0x00, 0x00, 0x00, 0xE3, 0x00, 0x00, 0x00, 0xFF, 
				 0x00, 0x00, 0x00, 0x1D, 0x06, 0x00, 0x64, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x90, 0x00, 0x00, 0x00, 
				 0x22, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x13, 0xEA, 0x00, 0x1E, 0x00, 0x00, 0xC0, 0x00, 
				 0x00, 0x1E, 0x01, 0x12, 0x0D, 0x00, 0x00, 0x1F, 
				 0x01, 0x00, 0x19, 0xEA, 0x00, 0x12, 0x07, 0x04, 
				 0x1E, 0x00, 0xC0, 0x00, 0x00, 0x00, 0x1E, 0x01, 
				 0x0D, 0x00, 0x00, 0x00, 0x18, 0x07, 0x04, 0x13, 
				 0xC4, 0x02, 0x1E, 0x00, 0x3F, 0xC0, 0x00, 0x00, 
				 0x1E, 0x01, 0x80, 0x0D, 0x00, 0x00, 0x1F, 0x01, 
				 0x00, 0x19, 0xC4, 0x02, 0x16, 0x02, 0x04, 0x00, 
				 0x00, 0x13, 0xC0, 0x00, 0x1E, 0x01, 0x00, 0x00, 
				 0x00, 0x00, 0x19, 0xC0, 0x00, 0x17, 0x4C, 0x00, 
				 0xD0, 0x00, 0x00, 0x00, 0x13, 0xEA, 0x00, 0x1E, 
				 0x00, 0xFF, 0xC0, 0x00, 0x00, 0x1E, 0x01, 0x00, 
				 0x07, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 0xEA, 
				 0x00, 0x00, 0x05};

BYTE t5465_Mode_800x600x8_5a[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x16, 0x05, 0x04, 0x00, 0x00, 0x16, 0xC0, 0x00, 
				 0x00, 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 
				 0x00, 0x1F, 0x01, 0x00, 0x18, 0xC5, 0x02, 0x18, 
				 0x07, 0x04, 0x15, 0xA0, 0x00, 0xFF, 0x00, 0x09, 
				 0xCE, 0x03, 0x06, 0x05, 0x09, 0xCE, 0x03, 0x09, 
				 0x00, 0x09, 0xCE, 0x03, 0x0A, 0x00, 0x09, 0xCE, 
				 0x03, 0x0B, 0x00, 0x16, 0x80, 0x00, 0x2F, 0x00, 
				 0x16, 0x84, 0x00, 0x1C, 0x00, 0x16, 0x88, 0x00, 
				 0x37, 0x00, 0x1D, 0x19, 0x00, 0x00, 0x00, 0x7E, 
				 0x00, 0x00, 0x00, 0x63, 0x00, 0x00, 0x00, 0x64, 
				 0x00, 0x00, 0x00, 0x9E, 0x00, 0x00, 0x00, 0x69, 
				 0x00, 0x00, 0x00, 0x91, 0x00, 0x00, 0x00, 0x75, 
				 0x00, 0x00, 0x00, 0xF0, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x60, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x58, 
				 0x00, 0x00, 0x00, 0x8B, 0x00, 0x00, 0x00, 0x57, 
				 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x57, 0x00, 0x00, 0x00, 0x75, 
				 0x00, 0x00, 0x00, 0xE3, 0x00, 0x00, 0x00, 0xFF, 
				 0x00, 0x00, 0x00, 0x1D, 0x06, 0x00, 0x64, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x90, 0x00, 0x00, 0x00, 
				 0x22, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x13, 0xEA, 0x00, 0x1E, 0x00, 0x00, 0xC0, 0x00, 
				 0x00, 0x1E, 0x01, 0x12, 0x0D, 0x00, 0x00, 0x1F, 
				 0x01, 0x00, 0x19, 0xEA, 0x00, 0x12, 0x07, 0x04, 
				 0x1E, 0x00, 0xC0, 0x00, 0x00, 0x00, 0x1E, 0x01, 
				 0x0D, 0x00, 0x00, 0x00, 0x18, 0x07, 0x04, 0x13, 
				 0xC4, 0x02, 0x1E, 0x00, 0x3F, 0xC0, 0x00, 0x00, 
				 0x1E, 0x01, 0x80, 0x0D, 0x00, 0x00, 0x1F, 0x01, 
				 0x00, 0x19, 0xC4, 0x02, 0x16, 0x02, 0x04, 0x00, 
				 0x00, 0x13, 0xC0, 0x00, 0x1E, 0x01, 0x00, 0x00, 
				 0x00, 0x00, 0x19, 0xC0, 0x00, 0x17, 0x4C, 0x00, 
				 0xD0, 0x00, 0x00, 0x00, 0x13, 0xEA, 0x00, 0x1E, 
				 0x00, 0xFF, 0xC0, 0x00, 0x00, 0x1E, 0x01, 0x00, 
				 0x07, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 0xEA, 
				 0x00, 0x00, 0x05};

BYTE t5465_Mode_1024x768x8_1[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x16, 0x05, 0x04, 0x00, 0x00, 0x16, 0xC0, 0x00, 
				 0x00, 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 
				 0x00, 0x1F, 0x01, 0x00, 0x18, 0xC5, 0x02, 0x18, 
				 0x07, 0x04, 0x15, 0xA0, 0x00, 0xFF, 0x00, 0x09, 
				 0xCE, 0x03, 0x06, 0x05, 0x09, 0xCE, 0x03, 0x09, 
				 0x00, 0x09, 0xCE, 0x03, 0x0A, 0x00, 0x09, 0xCE, 
				 0x03, 0x0B, 0x00, 0x16, 0x80, 0x00, 0x2F, 0x00, 
				 0x16, 0x84, 0x00, 0x17, 0x00, 0x16, 0x88, 0x00, 
				 0x45, 0x00, 0x1D, 0x19, 0x00, 0x00, 0x00, 0x99, 
				 0x00, 0x00, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x80, 
				 0x00, 0x00, 0x00, 0x99, 0x00, 0x00, 0x00, 0x82, 
				 0x00, 0x00, 0x00, 0x18, 0x00, 0x00, 0x00, 0x96, 
				 0x00, 0x00, 0x00, 0x1F, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7F, 
				 0x00, 0x00, 0x00, 0x83, 0x00, 0x00, 0x00, 0x7F, 
				 0x00, 0x00, 0x00, 0xA0, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x96, 
				 0x00, 0x00, 0x00, 0xE3, 0x00, 0x00, 0x00, 0xFF, 
				 0x00, 0x00, 0x00, 0x1D, 0x06, 0x00, 0x64, 0x00, 
				 0x48, 0x00, 0x00, 0x00, 0x51, 0x00, 0x00, 0x00, 
				 0x22, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x13, 0xEA, 0x00, 0x1E, 0x00, 0x00, 0xC0, 0x00, 
				 0x00, 0x1E, 0x01, 0xD1, 0x0A, 0x00, 0x00, 0x1F, 
				 0x01, 0x00, 0x19, 0xEA, 0x00, 0x12, 0x07, 0x04, 
				 0x1E, 0x00, 0xC0, 0x00, 0x00, 0x00, 0x1E, 0x01, 
				 0x05, 0x00, 0x00, 0x00, 0x18, 0x07, 0x04, 0x13, 
				 0xC4, 0x02, 0x1E, 0x00, 0x3F, 0xC0, 0x00, 0x00, 
				 0x1E, 0x01, 0xC0, 0x05, 0x00, 0x00, 0x1F, 0x01, 
				 0x00, 0x19, 0xC4, 0x02, 0x13, 0xEA, 0x00, 0x1E, 
				 0x00, 0xC0, 0xFF, 0x00, 0x00, 0x1E, 0x01, 0x12, 
				 0x00, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 0xEA, 
				 0x00, 0x16, 0x02, 0x04, 0x00, 0x08, 0x13, 0xC0, 
				 0x00, 0x1E, 0x01, 0x00, 0x00, 0x00, 0x00, 0x19, 
				 0xC0, 0x00, 0x13, 0xEA, 0x00, 0x1E, 0x00, 0xFF, 
				 0xC0, 0x00, 0x00, 0x1E, 0x01, 0x00, 0x08, 0x00, 
				 0x00, 0x1F, 0x01, 0x00, 0x19, 0xEA, 0x00, 0x00, 0x01};

BYTE t5465_Mode_1024x768x8_2[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x16, 0x05, 0x04, 0x00, 0x00, 0x16, 0xC0, 0x00, 
				 0x00, 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 
				 0x00, 0x1F, 0x01, 0x00, 0x18, 0xC5, 0x02, 0x18, 
				 0x07, 0x04, 0x15, 0xA0, 0x00, 0xFF, 0x00, 0x09, 
				 0xCE, 0x03, 0x06, 0x05, 0x09, 0xCE, 0x03, 0x09, 
				 0x00, 0x09, 0xCE, 0x03, 0x0A, 0x00, 0x09, 0xCE, 
				 0x03, 0x0B, 0x00, 0x16, 0x80, 0x00, 0xEF, 0x00, 
				 0x16, 0x84, 0x00, 0x1A, 0x00, 0x16, 0x88, 0x00, 
				 0x3B, 0x00, 0x1D, 0x19, 0x00, 0x00, 0x00, 0xA3, 
				 0x00, 0x00, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x80, 
				 0x00, 0x00, 0x00, 0x83, 0x00, 0x00, 0x00, 0x84, 
				 0x00, 0x00, 0x00, 0x95, 0x00, 0x00, 0x00, 0x24, 
				 0x00, 0x00, 0x00, 0xFD, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x60, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 
				 0x00, 0x00, 0x00, 0x88, 0x00, 0x00, 0x00, 0xFF, 
				 0x00, 0x00, 0x00, 0xA0, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x24, 
				 0x00, 0x00, 0x00, 0xE3, 0x00, 0x00, 0x00, 0xFF, 
				 0x00, 0x00, 0x00, 0x1D, 0x06, 0x00, 0x64, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0xE0, 0x00, 0x00, 0x00, 
				 0x22, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x13, 0xEA, 0x00, 0x1E, 0x00, 0x00, 0xC0, 0x00, 
				 0x00, 0x1E, 0x01, 0xD1, 0x0A, 0x00, 0x00, 0x1F, 
				 0x01, 0x00, 0x19, 0xEA, 0x00, 0x12, 0x07, 0x04, 
				 0x1E, 0x00, 0xC0, 0x00, 0x00, 0x00, 0x1E, 0x01, 
				 0x05, 0x00, 0x00, 0x00, 0x18, 0x07, 0x04, 0x13, 
				 0xC4, 0x02, 0x1E, 0x00, 0x3F, 0xC0, 0x00, 0x00, 
				 0x1E, 0x01, 0xC0, 0x05, 0x00, 0x00, 0x1F, 0x01, 
				 0x00, 0x19, 0xC4, 0x02, 0x13, 0xEA, 0x00, 0x1E, 
				 0x00, 0xC0, 0xFF, 0x00, 0x00, 0x1E, 0x01, 0x12, 
				 0x00, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 0xEA, 
				 0x00, 0x16, 0x02, 0x04, 0x00, 0x08, 0x13, 0xC0, 
				 0x00, 0x1E, 0x01, 0x00, 0x00, 0x00, 0x00, 0x19, 
				 0xC0, 0x00, 0x13, 0xEA, 0x00, 0x1E, 0x00, 0xFF, 
				 0xC0, 0x00, 0x00, 0x1E, 0x01, 0x00, 0x08, 0x00, 
				 0x00, 0x1F, 0x01, 0x00, 0x19, 0xEA, 0x00, 0x00, 0x01};

BYTE t5465_Mode_1024x768x8_3[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x16, 0x05, 0x04, 0x00, 0x00, 0x16, 0xC0, 0x00, 
				 0x00, 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 
				 0x00, 0x1F, 0x01, 0x00, 0x18, 0xC5, 0x02, 0x18, 
				 0x07, 0x04, 0x15, 0xA0, 0x00, 0xFF, 0x00, 0x09, 
				 0xCE, 0x03, 0x06, 0x05, 0x09, 0xCE, 0x03, 0x09, 
				 0x00, 0x09, 0xCE, 0x03, 0x0A, 0x00, 0x09, 0xCE, 
				 0x03, 0x0B, 0x00, 0x16, 0x80, 0x00, 0xEF, 0x00, 
				 0x16, 0x84, 0x00, 0x2A, 0x00, 0x16, 0x88, 0x00, 
				 0x6E, 0x00, 0x1D, 0x19, 0x00, 0x00, 0x00, 0xA1, 
				 0x00, 0x00, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x80, 
				 0x00, 0x00, 0x00, 0x81, 0x00, 0x00, 0x00, 0x84, 
				 0x00, 0x00, 0x00, 0x95, 0x00, 0x00, 0x00, 0x24, 
				 0x00, 0x00, 0x00, 0xFD, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x60, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 
				 0x00, 0x00, 0x00, 0x88, 0x00, 0x00, 0x00, 0xFF, 
				 0x00, 0x00, 0x00, 0xA0, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x24, 
				 0x00, 0x00, 0x00, 0xE3, 0x00, 0x00, 0x00, 0xFF, 
				 0x00, 0x00, 0x00, 0x1D, 0x06, 0x00, 0x64, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0xE0, 0x00, 0x00, 0x00, 
				 0x22, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x13, 0xEA, 0x00, 0x1E, 0x00, 0x00, 0xC0, 0x00, 
				 0x00, 0x1E, 0x01, 0xD1, 0x0A, 0x00, 0x00, 0x1F, 
				 0x01, 0x00, 0x19, 0xEA, 0x00, 0x12, 0x07, 0x04, 
				 0x1E, 0x00, 0xC0, 0x00, 0x00, 0x00, 0x1E, 0x01, 
				 0x05, 0x00, 0x00, 0x00, 0x18, 0x07, 0x04, 0x13, 
				 0xC4, 0x02, 0x1E, 0x00, 0x3F, 0xC0, 0x00, 0x00, 
				 0x1E, 0x01, 0xC0, 0x05, 0x00, 0x00, 0x1F, 0x01, 
				 0x00, 0x19, 0xC4, 0x02, 0x13, 0xEA, 0x00, 0x1E, 
				 0x00, 0xC0, 0xFF, 0x00, 0x00, 0x1E, 0x01, 0x12, 
				 0x00, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 0xEA, 
				 0x00, 0x16, 0x02, 0x04, 0x00, 0x08, 0x13, 0xC0, 
				 0x00, 0x1E, 0x01, 0x00, 0x00, 0x00, 0x00, 0x19, 
				 0xC0, 0x00, 0x13, 0xEA, 0x00, 0x1E, 0x00, 0xFF, 
				 0xC0, 0x00, 0x00, 0x1E, 0x01, 0x00, 0x08, 0x00, 
				 0x00, 0x1F, 0x01, 0x00, 0x19, 0xEA, 0x00, 0x00, 0x01};

BYTE t5465_Mode_1024x768x8_4[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x16, 0x05, 0x04, 0x00, 0x00, 0x16, 0xC0, 0x00, 
				 0x00, 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 
				 0x00, 0x1F, 0x01, 0x00, 0x18, 0xC5, 0x02, 0x18, 
				 0x07, 0x04, 0x15, 0xA0, 0x00, 0xFF, 0x00, 0x09, 
				 0xCE, 0x03, 0x06, 0x05, 0x09, 0xCE, 0x03, 0x09, 
				 0x00, 0x09, 0xCE, 0x03, 0x0A, 0x00, 0x09, 0xCE, 
				 0x03, 0x0B, 0x00, 0x16, 0x80, 0x00, 0x2F, 0x00, 
				 0x16, 0x84, 0x00, 0x10, 0x00, 0x16, 0x88, 0x00, 
				 0x2C, 0x00, 0x1D, 0x19, 0x00, 0x00, 0x00, 0x9F, 
				 0x00, 0x00, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x80, 
				 0x00, 0x00, 0x00, 0x9F, 0x00, 0x00, 0x00, 0x83, 
				 0x00, 0x00, 0x00, 0x0F, 0x00, 0x00, 0x00, 0x1E, 
				 0x00, 0x00, 0x00, 0xF5, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x60, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x83, 0x00, 0x00, 0x00, 0xFF, 
				 0x00, 0x00, 0x00, 0xA0, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 0x1E, 
				 0x00, 0x00, 0x00, 0xE3, 0x00, 0x00, 0x00, 0xFF, 
				 0x00, 0x00, 0x00, 0x1D, 0x06, 0x00, 0x64, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0xE0, 0x00, 0x00, 0x00, 
				 0x22, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x13, 0xEA, 0x00, 0x1E, 0x00, 0x00, 0xC0, 0x00, 
				 0x00, 0x1E, 0x01, 0xD1, 0x0A, 0x00, 0x00, 0x1F, 
				 0x01, 0x00, 0x19, 0xEA, 0x00, 0x12, 0x07, 0x04, 
				 0x1E, 0x00, 0xC0, 0x00, 0x00, 0x00, 0x1E, 0x01, 
				 0x05, 0x00, 0x00, 0x00, 0x18, 0x07, 0x04, 0x13, 
				 0xC4, 0x02, 0x1E, 0x00, 0x3F, 0xC0, 0x00, 0x00, 
				 0x1E, 0x01, 0xC0, 0x05, 0x00, 0x00, 0x1F, 0x01, 
				 0x00, 0x19, 0xC4, 0x02, 0x13, 0xEA, 0x00, 0x1E, 
				 0x00, 0xC0, 0xFF, 0x00, 0x00, 0x1E, 0x01, 0x12, 
				 0x00, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 0xEA, 
				 0x00, 0x16, 0x02, 0x04, 0x00, 0x08, 0x13, 0xC0, 
				 0x00, 0x1E, 0x01, 0x00, 0x00, 0x00, 0x00, 0x19, 
				 0xC0, 0x00, 0x13, 0xEA, 0x00, 0x1E, 0x00, 0xFF, 
				 0xC0, 0x00, 0x00, 0x1E, 0x01, 0x00, 0x08, 0x00, 
				 0x00, 0x1F, 0x01, 0x00, 0x19, 0xEA, 0x00, 0x00, 0x01};

BYTE t5465_Mode_1024x768x8_5[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x16, 0x05, 0x04, 0x00, 0x00, 0x16, 0xC0, 0x00, 
				 0x00, 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 
				 0x00, 0x1F, 0x01, 0x00, 0x18, 0xC5, 0x02, 0x18, 
				 0x07, 0x04, 0x15, 0xA0, 0x00, 0xFF, 0x00, 0x09, 
				 0xCE, 0x03, 0x06, 0x05, 0x09, 0xCE, 0x03, 0x09, 
				 0x00, 0x09, 0xCE, 0x03, 0x0A, 0x00, 0x09, 0xCE, 
				 0x03, 0x0B, 0x00, 0x16, 0x80, 0x00, 0x2F, 0x00, 
				 0x16, 0x84, 0x00, 0x0A, 0x00, 0x16, 0x88, 0x00, 
				 0x21, 0x00, 0x1D, 0x19, 0x00, 0x00, 0x00, 0xA7, 
				 0x00, 0x00, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x80, 
				 0x00, 0x00, 0x00, 0x87, 0x00, 0x00, 0x00, 0x87, 
				 0x00, 0x00, 0x00, 0x93, 0x00, 0x00, 0x00, 0x26, 
				 0x00, 0x00, 0x00, 0xF5, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x60, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x83, 0x00, 0x00, 0x00, 0xFF, 
				 0x00, 0x00, 0x00, 0xA0, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 0x26, 
				 0x00, 0x00, 0x00, 0xE3, 0x00, 0x00, 0x00, 0xFF, 
				 0x00, 0x00, 0x00, 0x1D, 0x06, 0x00, 0x64, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0xE0, 0x00, 0x00, 0x00, 
				 0x22, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x13, 0xEA, 0x00, 0x1E, 0x00, 0x00, 0xC0, 0x00, 
				 0x00, 0x1E, 0x01, 0xD1, 0x0A, 0x00, 0x00, 0x1F, 
				 0x01, 0x00, 0x19, 0xEA, 0x00, 0x12, 0x07, 0x04, 
				 0x1E, 0x00, 0xC0, 0x00, 0x00, 0x00, 0x1E, 0x01, 
				 0x05, 0x00, 0x00, 0x00, 0x18, 0x07, 0x04, 0x13, 
				 0xC4, 0x02, 0x1E, 0x00, 0x3F, 0xC0, 0x00, 0x00, 
				 0x1E, 0x01, 0xC0, 0x05, 0x00, 0x00, 0x1F, 0x01, 
				 0x00, 0x19, 0xC4, 0x02, 0x13, 0xEA, 0x00, 0x1E, 
				 0x00, 0xC0, 0xFF, 0x00, 0x00, 0x1E, 0x01, 0x12, 
				 0x00, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 0xEA, 
				 0x00, 0x16, 0x02, 0x04, 0x00, 0x08, 0x13, 0xC0, 
				 0x00, 0x1E, 0x01, 0x00, 0x00, 0x00, 0x00, 0x19, 
				 0xC0, 0x00, 0x13, 0xEA, 0x00, 0x1E, 0x00, 0xFF, 
				 0xC0, 0x00, 0x00, 0x1E, 0x01, 0x00, 0x08, 0x00, 
				 0x00, 0x1F, 0x01, 0x00, 0x19, 0xEA, 0x00, 0x00, 0x01};

BYTE t5465_Mode_1024x768x8_1a[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x16, 0x05, 0x04, 0x00, 0x00, 0x16, 0xC0, 0x00, 
				 0x00, 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 
				 0x00, 0x1F, 0x01, 0x00, 0x18, 0xC5, 0x02, 0x18, 
				 0x07, 0x04, 0x15, 0xA0, 0x00, 0xFF, 0x00, 0x09, 
				 0xCE, 0x03, 0x06, 0x05, 0x09, 0xCE, 0x03, 0x09, 
				 0x00, 0x09, 0xCE, 0x03, 0x0A, 0x00, 0x09, 0xCE, 
				 0x03, 0x0B, 0x00, 0x16, 0x80, 0x00, 0x2F, 0x00, 
				 0x16, 0x84, 0x00, 0x17, 0x00, 0x16, 0x88, 0x00, 
				 0x45, 0x00, 0x1D, 0x19, 0x00, 0x00, 0x00, 0x99, 
				 0x00, 0x00, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x80, 
				 0x00, 0x00, 0x00, 0x99, 0x00, 0x00, 0x00, 0x82, 
				 0x00, 0x00, 0x00, 0x18, 0x00, 0x00, 0x00, 0x96, 
				 0x00, 0x00, 0x00, 0x1F, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7F, 
				 0x00, 0x00, 0x00, 0x83, 0x00, 0x00, 0x00, 0x7F, 
				 0x00, 0x00, 0x00, 0xA0, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x96, 
				 0x00, 0x00, 0x00, 0xE3, 0x00, 0x00, 0x00, 0xFF, 
				 0x00, 0x00, 0x00, 0x1D, 0x06, 0x00, 0x64, 0x00, 
				 0x48, 0x00, 0x00, 0x00, 0x51, 0x00, 0x00, 0x00, 
				 0x22, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x13, 0xEA, 0x00, 0x1E, 0x00, 0x00, 0xC0, 0x00, 
				 0x00, 0x1E, 0x01, 0x52, 0x10, 0x00, 0x00, 0x1F, 
				 0x01, 0x00, 0x19, 0xEA, 0x00, 0x12, 0x07, 0x04, 
				 0x1E, 0x00, 0xC0, 0x00, 0x00, 0x00, 0x1E, 0x01, 
				 0x08, 0x00, 0x00, 0x00, 0x18, 0x07, 0x04, 0x13, 
				 0xC4, 0x02, 0x1E, 0x00, 0x3F, 0xC0, 0x00, 0x00, 
				 0x1E, 0x01, 0xC0, 0x08, 0x00, 0x00, 0x1F, 0x01, 
				 0x00, 0x19, 0xC4, 0x02, 0x16, 0x02, 0x04, 0x00, 
				 0x08, 0x13, 0xC0, 0x00, 0x1E, 0x01, 0x00, 0x00, 
				 0x00, 0x00, 0x19, 0xC0, 0x00, 0x17, 0x4C, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x17, 0x6C, 0x00, 0x32, 
				 0x00, 0x00, 0x00, 0x13, 0xEA, 0x00, 0x1E, 0x00, 
				 0xFF, 0xC0, 0x00, 0x00, 0x1E, 0x01, 0x00, 0x08, 
				 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 0xEA, 0x00, 
				 0x00, 0x1F};

BYTE t5465_Mode_1024x768x8_2a[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x16, 0x05, 0x04, 0x00, 0x00, 0x16, 0xC0, 0x00, 
				 0x00, 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 
				 0x00, 0x1F, 0x01, 0x00, 0x18, 0xC5, 0x02, 0x18, 
				 0x07, 0x04, 0x15, 0xA0, 0x00, 0xFF, 0x00, 0x09, 
				 0xCE, 0x03, 0x06, 0x05, 0x09, 0xCE, 0x03, 0x09, 
				 0x00, 0x09, 0xCE, 0x03, 0x0A, 0x00, 0x09, 0xCE, 
				 0x03, 0x0B, 0x00, 0x16, 0x80, 0x00, 0xEF, 0x00, 
				 0x16, 0x84, 0x00, 0x1A, 0x00, 0x16, 0x88, 0x00, 
				 0x3B, 0x00, 0x1D, 0x19, 0x00, 0x00, 0x00, 0xA3, 
				 0x00, 0x00, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x80, 
				 0x00, 0x00, 0x00, 0x83, 0x00, 0x00, 0x00, 0x84, 
				 0x00, 0x00, 0x00, 0x95, 0x00, 0x00, 0x00, 0x24, 
				 0x00, 0x00, 0x00, 0xFD, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x60, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 
				 0x00, 0x00, 0x00, 0x88, 0x00, 0x00, 0x00, 0xFF, 
				 0x00, 0x00, 0x00, 0xA0, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x24, 
				 0x00, 0x00, 0x00, 0xE3, 0x00, 0x00, 0x00, 0xFF, 
				 0x00, 0x00, 0x00, 0x1D, 0x06, 0x00, 0x64, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0xE0, 0x00, 0x00, 0x00, 
				 0x22, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x13, 0xEA, 0x00, 0x1E, 0x00, 0x00, 0xC0, 0x00, 
				 0x00, 0x1E, 0x01, 0x52, 0x10, 0x00, 0x00, 0x1F, 
				 0x01, 0x00, 0x19, 0xEA, 0x00, 0x12, 0x07, 0x04, 
				 0x1E, 0x00, 0xC0, 0x00, 0x00, 0x00, 0x1E, 0x01, 
				 0x08, 0x00, 0x00, 0x00, 0x18, 0x07, 0x04, 0x13, 
				 0xC4, 0x02, 0x1E, 0x00, 0x3F, 0xC0, 0x00, 0x00, 
				 0x1E, 0x01, 0xC0, 0x08, 0x00, 0x00, 0x1F, 0x01, 
				 0x00, 0x19, 0xC4, 0x02, 0x16, 0x02, 0x04, 0x00, 
				 0x08, 0x13, 0xC0, 0x00, 0x1E, 0x01, 0x00, 0x00, 
				 0x00, 0x00, 0x19, 0xC0, 0x00, 0x17, 0x4C, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x17, 0x6C, 0x00, 0x32, 
				 0x00, 0x00, 0x00, 0x13, 0xEA, 0x00, 0x1E, 0x00, 
				 0xFF, 0xC0, 0x00, 0x00, 0x1E, 0x01, 0x00, 0x08, 
				 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 0xEA, 0x00, 
				 0x00, 0x1F};

BYTE t5465_Mode_1024x768x8_3a[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x16, 0x05, 0x04, 0x00, 0x00, 0x16, 0xC0, 0x00, 
				 0x00, 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 
				 0x00, 0x1F, 0x01, 0x00, 0x18, 0xC5, 0x02, 0x18, 
				 0x07, 0x04, 0x15, 0xA0, 0x00, 0xFF, 0x00, 0x09, 
				 0xCE, 0x03, 0x06, 0x05, 0x09, 0xCE, 0x03, 0x09, 
				 0x00, 0x09, 0xCE, 0x03, 0x0A, 0x00, 0x09, 0xCE, 
				 0x03, 0x0B, 0x00, 0x16, 0x80, 0x00, 0xEF, 0x00, 
				 0x16, 0x84, 0x00, 0x2A, 0x00, 0x16, 0x88, 0x00, 
				 0x6E, 0x00, 0x1D, 0x19, 0x00, 0x00, 0x00, 0xA1, 
				 0x00, 0x00, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x80, 
				 0x00, 0x00, 0x00, 0x81, 0x00, 0x00, 0x00, 0x84, 
				 0x00, 0x00, 0x00, 0x95, 0x00, 0x00, 0x00, 0x24, 
				 0x00, 0x00, 0x00, 0xFD, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x60, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 
				 0x00, 0x00, 0x00, 0x88, 0x00, 0x00, 0x00, 0xFF, 
				 0x00, 0x00, 0x00, 0xA0, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x24, 
				 0x00, 0x00, 0x00, 0xE3, 0x00, 0x00, 0x00, 0xFF, 
				 0x00, 0x00, 0x00, 0x1D, 0x06, 0x00, 0x64, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0xE0, 0x00, 0x00, 0x00, 
				 0x22, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x13, 0xEA, 0x00, 0x1E, 0x00, 0x00, 0xC0, 0x00, 
				 0x00, 0x1E, 0x01, 0x52, 0x10, 0x00, 0x00, 0x1F, 
				 0x01, 0x00, 0x19, 0xEA, 0x00, 0x12, 0x07, 0x04, 
				 0x1E, 0x00, 0xC0, 0x00, 0x00, 0x00, 0x1E, 0x01, 
				 0x08, 0x00, 0x00, 0x00, 0x18, 0x07, 0x04, 0x13, 
				 0xC4, 0x02, 0x1E, 0x00, 0x3F, 0xC0, 0x00, 0x00, 
				 0x1E, 0x01, 0xC0, 0x08, 0x00, 0x00, 0x1F, 0x01, 
				 0x00, 0x19, 0xC4, 0x02, 0x16, 0x02, 0x04, 0x00, 
				 0x08, 0x13, 0xC0, 0x00, 0x1E, 0x01, 0x00, 0x00, 
				 0x00, 0x00, 0x19, 0xC0, 0x00, 0x17, 0x4C, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x17, 0x6C, 0x00, 0x32, 
				 0x00, 0x00, 0x00, 0x13, 0xEA, 0x00, 0x1E, 0x00, 
				 0xFF, 0xC0, 0x00, 0x00, 0x1E, 0x01, 0x00, 0x08, 
				 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 0xEA, 0x00, 
				 0x00, 0x1F};

BYTE t5465_Mode_1024x768x8_4a[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x16, 0x05, 0x04, 0x00, 0x00, 0x16, 0xC0, 0x00, 
				 0x00, 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 
				 0x00, 0x1F, 0x01, 0x00, 0x18, 0xC5, 0x02, 0x18, 
				 0x07, 0x04, 0x15, 0xA0, 0x00, 0xFF, 0x00, 0x09, 
				 0xCE, 0x03, 0x06, 0x05, 0x09, 0xCE, 0x03, 0x09, 
				 0x00, 0x09, 0xCE, 0x03, 0x0A, 0x00, 0x09, 0xCE, 
				 0x03, 0x0B, 0x00, 0x16, 0x80, 0x00, 0x2F, 0x00, 
				 0x16, 0x84, 0x00, 0x10, 0x00, 0x16, 0x88, 0x00, 
				 0x2C, 0x00, 0x1D, 0x19, 0x00, 0x00, 0x00, 0x9F, 
				 0x00, 0x00, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x80, 
				 0x00, 0x00, 0x00, 0x9F, 0x00, 0x00, 0x00, 0x83, 
				 0x00, 0x00, 0x00, 0x0F, 0x00, 0x00, 0x00, 0x1E, 
				 0x00, 0x00, 0x00, 0xF5, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x60, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x83, 0x00, 0x00, 0x00, 0xFF, 
				 0x00, 0x00, 0x00, 0xA0, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 0x1E, 
				 0x00, 0x00, 0x00, 0xE3, 0x00, 0x00, 0x00, 0xFF, 
				 0x00, 0x00, 0x00, 0x1D, 0x06, 0x00, 0x64, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0xE0, 0x00, 0x00, 0x00, 
				 0x22, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x13, 0xEA, 0x00, 0x1E, 0x00, 0x00, 0xC0, 0x00, 
				 0x00, 0x1E, 0x01, 0x52, 0x10, 0x00, 0x00, 0x1F, 
				 0x01, 0x00, 0x19, 0xEA, 0x00, 0x12, 0x07, 0x04, 
				 0x1E, 0x00, 0xC0, 0x00, 0x00, 0x00, 0x1E, 0x01, 
				 0x08, 0x00, 0x00, 0x00, 0x18, 0x07, 0x04, 0x13, 
				 0xC4, 0x02, 0x1E, 0x00, 0x3F, 0xC0, 0x00, 0x00, 
				 0x1E, 0x01, 0xC0, 0x08, 0x00, 0x00, 0x1F, 0x01, 
				 0x00, 0x19, 0xC4, 0x02, 0x16, 0x02, 0x04, 0x00, 
				 0x08, 0x13, 0xC0, 0x00, 0x1E, 0x01, 0x00, 0x00, 
				 0x00, 0x00, 0x19, 0xC0, 0x00, 0x17, 0x4C, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x17, 0x6C, 0x00, 0x32, 
				 0x00, 0x00, 0x00, 0x13, 0xEA, 0x00, 0x1E, 0x00, 
				 0xFF, 0xC0, 0x00, 0x00, 0x1E, 0x01, 0x00, 0x08, 
				 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 0xEA, 0x00, 
				 0x00, 0x1F};

BYTE t5465_Mode_1024x768x8_5a[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x16, 0x05, 0x04, 0x00, 0x00, 0x16, 0xC0, 0x00, 
				 0x00, 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 
				 0x00, 0x1F, 0x01, 0x00, 0x18, 0xC5, 0x02, 0x18, 
				 0x07, 0x04, 0x15, 0xA0, 0x00, 0xFF, 0x00, 0x09, 
				 0xCE, 0x03, 0x06, 0x05, 0x09, 0xCE, 0x03, 0x09, 
				 0x00, 0x09, 0xCE, 0x03, 0x0A, 0x00, 0x09, 0xCE, 
				 0x03, 0x0B, 0x00, 0x16, 0x80, 0x00, 0x2F, 0x00, 
				 0x16, 0x84, 0x00, 0x0A, 0x00, 0x16, 0x88, 0x00, 
				 0x21, 0x00, 0x1D, 0x19, 0x00, 0x00, 0x00, 0xA7, 
				 0x00, 0x00, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x80, 
				 0x00, 0x00, 0x00, 0x87, 0x00, 0x00, 0x00, 0x87, 
				 0x00, 0x00, 0x00, 0x93, 0x00, 0x00, 0x00, 0x26, 
				 0x00, 0x00, 0x00, 0xF5, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x60, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x83, 0x00, 0x00, 0x00, 0xFF, 
				 0x00, 0x00, 0x00, 0xA0, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 0x26, 
				 0x00, 0x00, 0x00, 0xE3, 0x00, 0x00, 0x00, 0xFF, 
				 0x00, 0x00, 0x00, 0x1D, 0x06, 0x00, 0x64, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0xE0, 0x00, 0x00, 0x00, 
				 0x22, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x13, 0xEA, 0x00, 0x1E, 0x00, 0x00, 0xC0, 0x00, 
				 0x00, 0x1E, 0x01, 0x52, 0x10, 0x00, 0x00, 0x1F, 
				 0x01, 0x00, 0x19, 0xEA, 0x00, 0x12, 0x07, 0x04, 
				 0x1E, 0x00, 0xC0, 0x00, 0x00, 0x00, 0x1E, 0x01, 
				 0x08, 0x00, 0x00, 0x00, 0x18, 0x07, 0x04, 0x13, 
				 0xC4, 0x02, 0x1E, 0x00, 0x3F, 0xC0, 0x00, 0x00, 
				 0x1E, 0x01, 0xC0, 0x08, 0x00, 0x00, 0x1F, 0x01, 
				 0x00, 0x19, 0xC4, 0x02, 0x16, 0x02, 0x04, 0x00, 
				 0x08, 0x13, 0xC0, 0x00, 0x1E, 0x01, 0x00, 0x00, 
				 0x00, 0x00, 0x19, 0xC0, 0x00, 0x17, 0x4C, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x17, 0x6C, 0x00, 0x32, 
				 0x00, 0x00, 0x00, 0x13, 0xEA, 0x00, 0x1E, 0x00, 
				 0xFF, 0xC0, 0x00, 0x00, 0x1E, 0x01, 0x00, 0x08, 
				 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 0xEA, 0x00, 
				 0x00, 0x1F};

BYTE t5465_Mode_1152x864x8_1[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x16, 0x05, 0x04, 0x00, 0x00, 0x16, 0xC0, 0x00, 
				 0x00, 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 
				 0x00, 0x1F, 0x01, 0x00, 0x18, 0xC5, 0x02, 0x18, 
				 0x07, 0x04, 0x15, 0xA0, 0x00, 0xFF, 0x00, 0x09, 
				 0xCE, 0x03, 0x06, 0x05, 0x09, 0xCE, 0x03, 0x09, 
				 0x00, 0x09, 0xCE, 0x03, 0x0A, 0x00, 0x09, 0xCE, 
				 0x03, 0x0B, 0x00, 0x16, 0x80, 0x00, 0x2F, 0x00, 
				 0x16, 0x84, 0x00, 0x0A, 0x00, 0x16, 0x88, 0x00, 
				 0x21, 0x00, 0x1D, 0x19, 0x00, 0x00, 0x00, 0xB4, 
				 0x00, 0x00, 0x00, 0x8F, 0x00, 0x00, 0x00, 0x8F, 
				 0x00, 0x00, 0x00, 0x94, 0x00, 0x00, 0x00, 0x95, 
				 0x00, 0x00, 0x00, 0x81, 0x00, 0x00, 0x00, 0x8E, 
				 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x60, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x60, 
				 0x00, 0x00, 0x00, 0x83, 0x00, 0x00, 0x00, 0x5F, 
				 0x00, 0x00, 0x00, 0xA0, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x5F, 0x00, 0x00, 0x00, 0x8E, 
				 0x00, 0x00, 0x00, 0xE3, 0x00, 0x00, 0x00, 0xFF, 
				 0x00, 0x00, 0x00, 0x1D, 0x06, 0x00, 0x64, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0xE0, 0x00, 0x00, 0x00, 
				 0x22, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x13, 0xEA, 0x00, 0x1E, 0x00, 0x00, 0xC0, 0x00, 
				 0x00, 0x1E, 0x01, 0xD1, 0x0A, 0x00, 0x00, 0x1F, 
				 0x01, 0x00, 0x19, 0xEA, 0x00, 0x12, 0x07, 0x04, 
				 0x1E, 0x00, 0xC0, 0x00, 0x00, 0x00, 0x1E, 0x01, 
				 0x05, 0x00, 0x00, 0x00, 0x18, 0x07, 0x04, 0x13, 
				 0xC4, 0x02, 0x1E, 0x00, 0x3F, 0xC0, 0x00, 0x00, 
				 0x1E, 0x01, 0xC0, 0x05, 0x00, 0x00, 0x1F, 0x01, 
				 0x00, 0x19, 0xC4, 0x02, 0x13, 0xEA, 0x00, 0x1E, 
				 0x00, 0xC0, 0xFF, 0x00, 0x00, 0x1E, 0x01, 0x16, 
				 0x00, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 0xEA, 
				 0x00, 0x16, 0x02, 0x04, 0x00, 0x08, 0x13, 0xC0, 
				 0x00, 0x1E, 0x01, 0x00, 0x00, 0x00, 0x00, 0x19, 
				 0xC0, 0x00, 0x13, 0xEA, 0x00, 0x1E, 0x00, 0xFF, 
				 0xC0, 0x00, 0x00, 0x1E, 0x01, 0x00, 0x09, 0x00, 
				 0x00, 0x1F, 0x01, 0x00, 0x19, 0xEA, 0x00, 0x00, 0x01};

BYTE t5465_Mode_1152x864x8_2[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x16, 0x05, 0x04, 0x00, 0x00, 0x16, 0xC0, 0x00, 
				 0x00, 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 
				 0x00, 0x1F, 0x01, 0x00, 0x18, 0xC5, 0x02, 0x18, 
				 0x07, 0x04, 0x15, 0xA0, 0x00, 0xFF, 0x00, 0x09, 
				 0xCE, 0x03, 0x06, 0x05, 0x09, 0xCE, 0x03, 0x09, 
				 0x00, 0x09, 0xCE, 0x03, 0x0A, 0x00, 0x09, 0xCE, 
				 0x03, 0x0B, 0x00, 0x16, 0x80, 0x00, 0x2F, 0x00, 
				 0x16, 0x84, 0x00, 0x16, 0x00, 0x16, 0x88, 0x00, 
				 0x53, 0x00, 0x1D, 0x19, 0x00, 0x00, 0x00, 0xC3, 
				 0x00, 0x00, 0x00, 0x8F, 0x00, 0x00, 0x00, 0x8F, 
				 0x00, 0x00, 0x00, 0x83, 0x00, 0x00, 0x00, 0x99, 
				 0x00, 0x00, 0x00, 0x09, 0x00, 0x00, 0x00, 0x82, 
				 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x60, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x60, 
				 0x00, 0x00, 0x00, 0x83, 0x00, 0x00, 0x00, 0x5F, 
				 0x00, 0x00, 0x00, 0xA0, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x5F, 0x00, 0x00, 0x00, 0x82, 
				 0x00, 0x00, 0x00, 0xE3, 0x00, 0x00, 0x00, 0xFF, 
				 0x00, 0x00, 0x00, 0x1D, 0x06, 0x00, 0x64, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0xF0, 0x00, 0x00, 0x00, 
				 0x22, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x13, 0xEA, 0x00, 0x1E, 0x00, 0x00, 0xC0, 0x00, 
				 0x00, 0x1E, 0x01, 0xD1, 0x0A, 0x00, 0x00, 0x1F, 
				 0x01, 0x00, 0x19, 0xEA, 0x00, 0x12, 0x07, 0x04, 
				 0x1E, 0x00, 0xC0, 0x00, 0x00, 0x00, 0x1E, 0x01, 
				 0x05, 0x00, 0x00, 0x00, 0x18, 0x07, 0x04, 0x13, 
				 0xC4, 0x02, 0x1E, 0x00, 0x3F, 0xC0, 0x00, 0x00, 
				 0x1E, 0x01, 0xC0, 0x05, 0x00, 0x00, 0x1F, 0x01, 
				 0x00, 0x19, 0xC4, 0x02, 0x13, 0xEA, 0x00, 0x1E, 
				 0x00, 0xC0, 0xFF, 0x00, 0x00, 0x1E, 0x01, 0x16, 
				 0x00, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 0xEA, 
				 0x00, 0x16, 0x02, 0x04, 0x00, 0x08, 0x13, 0xC0, 
				 0x00, 0x1E, 0x01, 0x00, 0x00, 0x00, 0x00, 0x19, 
				 0xC0, 0x00, 0x13, 0xEA, 0x00, 0x1E, 0x00, 0xFF, 
				 0xC0, 0x00, 0x00, 0x1E, 0x01, 0x00, 0x09, 0x00, 
				 0x00, 0x1F, 0x01, 0x00, 0x19, 0xEA, 0x00, 0x00, 0x01};

BYTE t5465_Mode_1152x864x8_3[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x16, 0x05, 0x04, 0x00, 0x00, 0x16, 0xC0, 0x00, 
				 0x00, 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 
				 0x00, 0x1F, 0x01, 0x00, 0x18, 0xC5, 0x02, 0x18, 
				 0x07, 0x04, 0x15, 0xA0, 0x00, 0xFF, 0x00, 0x09, 
				 0xCE, 0x03, 0x06, 0x05, 0x09, 0xCE, 0x03, 0x09, 
				 0x00, 0x09, 0xCE, 0x03, 0x0A, 0x00, 0x09, 0xCE, 
				 0x03, 0x0B, 0x00, 0x16, 0x80, 0x00, 0x2F, 0x00, 
				 0x16, 0x84, 0x00, 0x04, 0x00, 0x16, 0x88, 0x00, 
				 0x11, 0x00, 0x1D, 0x19, 0x00, 0x00, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x8F, 0x00, 0x00, 0x00, 0x8F, 
				 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x99, 
				 0x00, 0x00, 0x00, 0x09, 0x00, 0x00, 0x00, 0x89, 
				 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x60, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x60, 
				 0x00, 0x00, 0x00, 0x83, 0x00, 0x00, 0x00, 0x5F, 
				 0x00, 0x00, 0x00, 0xA0, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x5F, 0x00, 0x00, 0x00, 0x89, 
				 0x00, 0x00, 0x00, 0xE3, 0x00, 0x00, 0x00, 0xFF, 
				 0x00, 0x00, 0x00, 0x1D, 0x06, 0x00, 0x64, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0xF0, 0x00, 0x00, 0x00, 
				 0x22, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x13, 0xEA, 0x00, 0x1E, 0x00, 0x00, 0xC0, 0x00, 
				 0x00, 0x1E, 0x01, 0xD1, 0x0A, 0x00, 0x00, 0x1F, 
				 0x01, 0x00, 0x19, 0xEA, 0x00, 0x12, 0x07, 0x04, 
				 0x1E, 0x00, 0xC0, 0x00, 0x00, 0x00, 0x1E, 0x01, 
				 0x05, 0x00, 0x00, 0x00, 0x18, 0x07, 0x04, 0x13, 
				 0xC4, 0x02, 0x1E, 0x00, 0x3F, 0xC0, 0x00, 0x00, 
				 0x1E, 0x01, 0xC0, 0x05, 0x00, 0x00, 0x1F, 0x01, 
				 0x00, 0x19, 0xC4, 0x02, 0x13, 0xEA, 0x00, 0x1E, 
				 0x00, 0xC0, 0xFF, 0x00, 0x00, 0x1E, 0x01, 0x16, 
				 0x00, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 0xEA, 
				 0x00, 0x16, 0x02, 0x04, 0x00, 0x08, 0x13, 0xC0, 
				 0x00, 0x1E, 0x01, 0x00, 0x00, 0x00, 0x00, 0x19, 
				 0xC0, 0x00, 0x13, 0xEA, 0x00, 0x1E, 0x00, 0xFF, 
				 0xC0, 0x00, 0x00, 0x1E, 0x01, 0x00, 0x09, 0x00, 
				 0x00, 0x1F, 0x01, 0x00, 0x19, 0xEA, 0x00, 0x00, 0x01};

BYTE t5465_Mode_1280x960x8_1[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x16, 0x05, 0x04, 0x00, 0x00, 0x16, 0xC0, 0x00, 
				 0x00, 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 
				 0x00, 0x1F, 0x01, 0x00, 0x18, 0xC5, 0x02, 0x18, 
				 0x07, 0x04, 0x15, 0xA0, 0x00, 0xFF, 0x00, 0x09, 
				 0xCE, 0x03, 0x06, 0x05, 0x09, 0xCE, 0x03, 0x09, 
				 0x00, 0x09, 0xCE, 0x03, 0x0A, 0x00, 0x09, 0xCE, 
				 0x03, 0x0B, 0x00, 0x16, 0x80, 0x00, 0x2F, 0x00, 
				 0x16, 0x84, 0x00, 0x16, 0x00, 0x16, 0x88, 0x00, 
				 0x53, 0x00, 0x1D, 0x19, 0x00, 0x00, 0x00, 0xDC, 
				 0x00, 0x00, 0x00, 0x9F, 0x00, 0x00, 0x00, 0x9F, 
				 0x00, 0x00, 0x00, 0x9C, 0x00, 0x00, 0x00, 0xAD, 
				 0x00, 0x00, 0x00, 0x1B, 0x00, 0x00, 0x00, 0xE6, 
				 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x60, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x83, 0x00, 0x00, 0x00, 0xBF, 
				 0x00, 0x00, 0x00, 0xA0, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0xBF, 0x00, 0x00, 0x00, 0xE6, 
				 0x00, 0x00, 0x00, 0xE3, 0x00, 0x00, 0x00, 0xFF, 
				 0x00, 0x00, 0x00, 0x1D, 0x06, 0x00, 0x64, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0xF0, 0x00, 0x00, 0x00, 
				 0x22, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x13, 0xEA, 0x00, 0x1E, 0x00, 0x00, 0xC0, 0x00, 
				 0x00, 0x1E, 0x01, 0xD1, 0x0A, 0x00, 0x00, 0x1F, 
				 0x01, 0x00, 0x19, 0xEA, 0x00, 0x12, 0x07, 0x04, 
				 0x1E, 0x00, 0xC0, 0x00, 0x00, 0x00, 0x1E, 0x01, 
				 0x05, 0x00, 0x00, 0x00, 0x18, 0x07, 0x04, 0x13, 
				 0xC4, 0x02, 0x1E, 0x00, 0x3F, 0xC0, 0x00, 0x00, 
				 0x1E, 0x01, 0xC0, 0x05, 0x00, 0x00, 0x1F, 0x01, 
				 0x00, 0x19, 0xC4, 0x02, 0x13, 0xEA, 0x00, 0x1E, 
				 0x00, 0xC0, 0xFF, 0x00, 0x00, 0x1E, 0x01, 0x16, 
				 0x00, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 0xEA, 
				 0x00, 0x16, 0x02, 0x04, 0x00, 0x08, 0x13, 0xC0, 
				 0x00, 0x1E, 0x01, 0x00, 0x00, 0x00, 0x00, 0x19, 
				 0xC0, 0x00, 0x13, 0xEA, 0x00, 0x1E, 0x00, 0xFF, 
				 0xC0, 0x00, 0x00, 0x1E, 0x01, 0x00, 0x0A, 0x00, 
				 0x00, 0x1F, 0x01, 0x00, 0x19, 0xEA, 0x00, 0x00, 0x01};

BYTE t5465_Mode_1280x960x8_2[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x16, 0x05, 0x04, 0x00, 0x00, 0x16, 0xC0, 0x00, 
				 0x00, 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 
				 0x00, 0x1F, 0x01, 0x00, 0x18, 0xC5, 0x02, 0x18, 
				 0x07, 0x04, 0x15, 0xA0, 0x00, 0xFF, 0x00, 0x09, 
				 0xCE, 0x03, 0x06, 0x05, 0x09, 0xCE, 0x03, 0x09, 
				 0x00, 0x09, 0xCE, 0x03, 0x0A, 0x00, 0x09, 0xCE, 
				 0x03, 0x0B, 0x00, 0x16, 0x80, 0x00, 0x2F, 0x00, 
				 0x16, 0x84, 0x00, 0x0A, 0x00, 0x16, 0x88, 0x00, 
				 0x2C, 0x00, 0x1D, 0x19, 0x00, 0x00, 0x00, 0xCD, 
				 0x00, 0x00, 0x00, 0x9F, 0x00, 0x00, 0x00, 0x9F, 
				 0x00, 0x00, 0x00, 0x8D, 0x00, 0x00, 0x00, 0xA5, 
				 0x00, 0x00, 0x00, 0x17, 0x00, 0x00, 0x00, 0xE6, 
				 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x60, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x83, 0x00, 0x00, 0x00, 0xBF, 
				 0x00, 0x00, 0x00, 0xA0, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0xBF, 0x00, 0x00, 0x00, 0xE6, 
				 0x00, 0x00, 0x00, 0xE3, 0x00, 0x00, 0x00, 0xFF, 
				 0x00, 0x00, 0x00, 0x1D, 0x06, 0x00, 0x64, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0xF0, 0x00, 0x00, 0x00, 
				 0x22, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x13, 0xEA, 0x00, 0x1E, 0x00, 0x00, 0xC0, 0x00, 
				 0x00, 0x1E, 0x01, 0xD1, 0x0A, 0x00, 0x00, 0x1F, 
				 0x01, 0x00, 0x19, 0xEA, 0x00, 0x12, 0x07, 0x04, 
				 0x1E, 0x00, 0xC0, 0x00, 0x00, 0x00, 0x1E, 0x01, 
				 0x05, 0x00, 0x00, 0x00, 0x18, 0x07, 0x04, 0x13, 
				 0xC4, 0x02, 0x1E, 0x00, 0x3F, 0xC0, 0x00, 0x00, 
				 0x1E, 0x01, 0xC0, 0x05, 0x00, 0x00, 0x1F, 0x01, 
				 0x00, 0x19, 0xC4, 0x02, 0x13, 0xEA, 0x00, 0x1E, 
				 0x00, 0xC0, 0xFF, 0x00, 0x00, 0x1E, 0x01, 0x16, 
				 0x00, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 0xEA, 
				 0x00, 0x16, 0x02, 0x04, 0x00, 0x08, 0x13, 0xC0, 
				 0x00, 0x1E, 0x01, 0x00, 0x00, 0x00, 0x00, 0x19, 
				 0xC0, 0x00, 0x13, 0xEA, 0x00, 0x1E, 0x00, 0xFF, 
				 0xC0, 0x00, 0x00, 0x1E, 0x01, 0x00, 0x0A, 0x00, 
				 0x00, 0x1F, 0x01, 0x00, 0x19, 0xEA, 0x00, 0x00, 0x01};

BYTE t5465_Mode_1280x960x8_3[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x16, 0x05, 0x04, 0x00, 0x00, 0x16, 0xC0, 0x00, 
				 0x00, 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 
				 0x00, 0x1F, 0x01, 0x00, 0x18, 0xC5, 0x02, 0x18, 
				 0x07, 0x04, 0x15, 0xA0, 0x00, 0xFF, 0x00, 0x09, 
				 0xCE, 0x03, 0x06, 0x05, 0x09, 0xCE, 0x03, 0x09, 
				 0x00, 0x09, 0xCE, 0x03, 0x0A, 0x00, 0x09, 0xCE, 
				 0x03, 0x0B, 0x00, 0x16, 0x80, 0x00, 0x2F, 0x00, 
				 0x16, 0x84, 0x00, 0x10, 0x00, 0x16, 0x88, 0x00, 
				 0x53, 0x00, 0x1D, 0x19, 0x00, 0x00, 0x00, 0xD3, 
				 0x00, 0x00, 0x00, 0x9F, 0x00, 0x00, 0x00, 0x9F, 
				 0x00, 0x00, 0x00, 0x93, 0x00, 0x00, 0x00, 0xA6, 
				 0x00, 0x00, 0x00, 0x1B, 0x00, 0x00, 0x00, 0xF1, 
				 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x60, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x83, 0x00, 0x00, 0x00, 0xBF, 
				 0x00, 0x00, 0x00, 0xA0, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0xBF, 0x00, 0x00, 0x00, 0xF1, 
				 0x00, 0x00, 0x00, 0xE3, 0x00, 0x00, 0x00, 0xFF, 
				 0x00, 0x00, 0x00, 0x1D, 0x06, 0x00, 0x64, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0xF0, 0x00, 0x00, 0x00, 
				 0x22, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x13, 0xEA, 0x00, 0x1E, 0x00, 0x00, 0xC0, 0x00, 
				 0x00, 0x1E, 0x01, 0xD1, 0x0A, 0x00, 0x00, 0x1F, 
				 0x01, 0x00, 0x19, 0xEA, 0x00, 0x12, 0x07, 0x04, 
				 0x1E, 0x00, 0xC0, 0x00, 0x00, 0x00, 0x1E, 0x01, 
				 0x05, 0x00, 0x00, 0x00, 0x18, 0x07, 0x04, 0x13, 
				 0xC4, 0x02, 0x1E, 0x00, 0x3F, 0xC0, 0x00, 0x00, 
				 0x1E, 0x01, 0xC0, 0x05, 0x00, 0x00, 0x1F, 0x01, 
				 0x00, 0x19, 0xC4, 0x02, 0x13, 0xEA, 0x00, 0x1E, 
				 0x00, 0xC0, 0xFF, 0x00, 0x00, 0x1E, 0x01, 0x16, 
				 0x00, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 0xEA, 
				 0x00, 0x16, 0x02, 0x04, 0x00, 0x08, 0x13, 0xC0, 
				 0x00, 0x1E, 0x01, 0x00, 0x00, 0x00, 0x00, 0x19, 
				 0xC0, 0x00, 0x13, 0xEA, 0x00, 0x1E, 0x00, 0xFF, 
				 0xC0, 0x00, 0x00, 0x1E, 0x01, 0x00, 0x0A, 0x00, 
				 0x00, 0x1F, 0x01, 0x00, 0x19, 0xEA, 0x00, 0x00, 0x01};

BYTE t5465_Mode_1280x1024x8_1[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x16, 0x05, 0x04, 0x00, 0x00, 0x16, 0xC0, 0x00, 
				 0x00, 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 
				 0x00, 0x1F, 0x01, 0x00, 0x18, 0xC5, 0x02, 0x18, 
				 0x07, 0x04, 0x15, 0xA0, 0x00, 0xFF, 0x00, 0x09, 
				 0xCE, 0x03, 0x06, 0x05, 0x09, 0xCE, 0x03, 0x09, 
				 0x00, 0x09, 0xCE, 0x03, 0x0A, 0x00, 0x09, 0xCE, 
				 0x03, 0x0B, 0x00, 0x16, 0x80, 0x00, 0x2F, 0x00, 
				 0x16, 0x84, 0x00, 0x04, 0x00, 0x16, 0x88, 0x00, 
				 0x0B, 0x00, 0x1D, 0x19, 0x00, 0x00, 0x00, 0xCF, 
				 0x00, 0x00, 0x00, 0x9F, 0x00, 0x00, 0x00, 0x9F, 
				 0x00, 0x00, 0x00, 0x93, 0x00, 0x00, 0x00, 0xA9, 
				 0x00, 0x00, 0x00, 0x13, 0x00, 0x00, 0x00, 0x14, 
				 0x00, 0x00, 0x00, 0xB2, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x60, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x82, 0x00, 0x00, 0x00, 0xFF, 
				 0x00, 0x00, 0x00, 0xA0, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x14, 
				 0x00, 0x00, 0x00, 0xE3, 0x00, 0x00, 0x00, 0xFF, 
				 0x00, 0x00, 0x00, 0x1D, 0x06, 0x00, 0x64, 0x00, 
				 0x67, 0x00, 0x00, 0x00, 0x81, 0x00, 0x00, 0x00, 
				 0x22, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x13, 0xEA, 0x00, 0x1E, 0x00, 0x00, 0xC0, 0x00, 
				 0x00, 0x1E, 0x01, 0xD1, 0x0A, 0x00, 0x00, 0x1F, 
				 0x01, 0x00, 0x19, 0xEA, 0x00, 0x12, 0x07, 0x04, 
				 0x1E, 0x00, 0xC0, 0x00, 0x00, 0x00, 0x1E, 0x01, 
				 0x05, 0x00, 0x00, 0x00, 0x18, 0x07, 0x04, 0x13, 
				 0xC4, 0x02, 0x1E, 0x00, 0x3F, 0xC0, 0x00, 0x00, 
				 0x1E, 0x01, 0xC0, 0x05, 0x00, 0x00, 0x1F, 0x01, 
				 0x00, 0x19, 0xC4, 0x02, 0x13, 0xEA, 0x00, 0x1E, 
				 0x00, 0xC0, 0xFF, 0x00, 0x00, 0x1E, 0x01, 0x16, 
				 0x00, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 0xEA, 
				 0x00, 0x16, 0x02, 0x04, 0x00, 0x08, 0x13, 0xC0, 
				 0x00, 0x1E, 0x01, 0x00, 0x00, 0x00, 0x00, 0x19, 
				 0xC0, 0x00, 0x13, 0xEA, 0x00, 0x1E, 0x00, 0xFF, 
				 0xC0, 0x00, 0x00, 0x1E, 0x01, 0x00, 0x0A, 0x00, 
				 0x00, 0x1F, 0x01, 0x00, 0x19, 0xEA, 0x00, 0x00, 0x01};

BYTE t5465_Mode_1280x1024x8_2[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x16, 0x05, 0x04, 0x00, 0x00, 0x16, 0xC0, 0x00, 
				 0x00, 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 
				 0x00, 0x1F, 0x01, 0x00, 0x18, 0xC5, 0x02, 0x18, 
				 0x07, 0x04, 0x15, 0xA0, 0x00, 0xFF, 0x00, 0x09, 
				 0xCE, 0x03, 0x06, 0x05, 0x09, 0xCE, 0x03, 0x09, 
				 0x00, 0x09, 0xCE, 0x03, 0x0A, 0x00, 0x09, 0xCE, 
				 0x03, 0x0B, 0x00, 0x16, 0x80, 0x00, 0x2F, 0x00, 
				 0x16, 0x84, 0x00, 0x16, 0x00, 0x16, 0x88, 0x00, 
				 0x53, 0x00, 0x1D, 0x19, 0x00, 0x00, 0x00, 0xCE, 
				 0x00, 0x00, 0x00, 0x9F, 0x00, 0x00, 0x00, 0x9F, 
				 0x00, 0x00, 0x00, 0x91, 0x00, 0x00, 0x00, 0xA7, 
				 0x00, 0x00, 0x00, 0x15, 0x00, 0x00, 0x00, 0x28, 
				 0x00, 0x00, 0x00, 0x5A, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x60, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x83, 0x00, 0x00, 0x00, 0xFF, 
				 0x00, 0x00, 0x00, 0xA0, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 0x24, 
				 0x00, 0x00, 0x00, 0xE3, 0x00, 0x00, 0x00, 0xFF, 
				 0x00, 0x00, 0x00, 0x1D, 0x06, 0x00, 0x64, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x30, 0x00, 0x00, 0x00, 
				 0x22, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x09, 0x00, 0x00, 0x00, 
				 0x13, 0xEA, 0x00, 0x1E, 0x00, 0x00, 0xC0, 0x00, 
				 0x00, 0x1E, 0x01, 0xD1, 0x0A, 0x00, 0x00, 0x1F, 
				 0x01, 0x00, 0x19, 0xEA, 0x00, 0x12, 0x07, 0x04, 
				 0x1E, 0x00, 0xC0, 0x00, 0x00, 0x00, 0x1E, 0x01, 
				 0x05, 0x00, 0x00, 0x00, 0x18, 0x07, 0x04, 0x13, 
				 0xC4, 0x02, 0x1E, 0x00, 0x3F, 0xC0, 0x00, 0x00, 
				 0x1E, 0x01, 0xC0, 0x05, 0x00, 0x00, 0x1F, 0x01, 
				 0x00, 0x19, 0xC4, 0x02, 0x13, 0xEA, 0x00, 0x1E, 
				 0x00, 0xC0, 0xFF, 0x00, 0x00, 0x1E, 0x01, 0x16, 
				 0x00, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 0xEA, 
				 0x00, 0x16, 0x02, 0x04, 0x00, 0x08, 0x13, 0xC0, 
				 0x00, 0x1E, 0x01, 0x00, 0x00, 0x00, 0x00, 0x19, 
				 0xC0, 0x00, 0x13, 0xEA, 0x00, 0x1E, 0x00, 0xFF, 
				 0xC0, 0x00, 0x00, 0x1E, 0x01, 0x00, 0x0A, 0x00, 
				 0x00, 0x1F, 0x01, 0x00, 0x19, 0xEA, 0x00, 0x00, 0x01};

BYTE t5465_Mode_1280x1024x8_3[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x16, 0x05, 0x04, 0x00, 0x00, 0x16, 0xC0, 0x00, 
				 0x00, 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 
				 0x00, 0x1F, 0x01, 0x00, 0x18, 0xC5, 0x02, 0x18, 
				 0x07, 0x04, 0x15, 0xA0, 0x00, 0xFF, 0x00, 0x09, 
				 0xCE, 0x03, 0x06, 0x05, 0x09, 0xCE, 0x03, 0x09, 
				 0x00, 0x09, 0xCE, 0x03, 0x0A, 0x00, 0x09, 0xCE, 
				 0x03, 0x0B, 0x00, 0x16, 0x80, 0x00, 0x2F, 0x00, 
				 0x16, 0x84, 0x00, 0x1A, 0x00, 0x16, 0x88, 0x00, 
				 0x76, 0x00, 0x1D, 0x19, 0x00, 0x00, 0x00, 0xCE, 
				 0x00, 0x00, 0x00, 0x9F, 0x00, 0x00, 0x00, 0x9F, 
				 0x00, 0x00, 0x00, 0x91, 0x00, 0x00, 0x00, 0xA3, 
				 0x00, 0x00, 0x00, 0x15, 0x00, 0x00, 0x00, 0x28, 
				 0x00, 0x00, 0x00, 0x5A, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x60, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x83, 0x00, 0x00, 0x00, 0xFF, 
				 0x00, 0x00, 0x00, 0xA0, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 0x24, 
				 0x00, 0x00, 0x00, 0xE3, 0x00, 0x00, 0x00, 0xFF, 
				 0x00, 0x00, 0x00, 0x1D, 0x06, 0x00, 0x64, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x30, 0x00, 0x00, 0x00, 
				 0x22, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x09, 0x00, 0x00, 0x00, 
				 0x13, 0xEA, 0x00, 0x1E, 0x00, 0x00, 0xC0, 0x00, 
				 0x00, 0x1E, 0x01, 0xD1, 0x0A, 0x00, 0x00, 0x1F, 
				 0x01, 0x00, 0x19, 0xEA, 0x00, 0x12, 0x07, 0x04, 
				 0x1E, 0x00, 0xC0, 0x00, 0x00, 0x00, 0x1E, 0x01, 
				 0x05, 0x00, 0x00, 0x00, 0x18, 0x07, 0x04, 0x13, 
				 0xC4, 0x02, 0x1E, 0x00, 0x3F, 0xC0, 0x00, 0x00, 
				 0x1E, 0x01, 0xC0, 0x05, 0x00, 0x00, 0x1F, 0x01, 
				 0x00, 0x19, 0xC4, 0x02, 0x13, 0xEA, 0x00, 0x1E, 
				 0x00, 0xC0, 0xFF, 0x00, 0x00, 0x1E, 0x01, 0x16, 
				 0x00, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 0xEA, 
				 0x00, 0x16, 0x02, 0x04, 0x00, 0x08, 0x13, 0xC0, 
				 0x00, 0x1E, 0x01, 0x00, 0x00, 0x00, 0x00, 0x19, 
				 0xC0, 0x00, 0x13, 0xEA, 0x00, 0x1E, 0x00, 0xFF, 
				 0xC0, 0x00, 0x00, 0x1E, 0x01, 0x00, 0x0A, 0x00, 
				 0x00, 0x1F, 0x01, 0x00, 0x19, 0xEA, 0x00, 0x00, 0x01};

BYTE t5465_Mode_1280x1024x8_4[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x16, 0x05, 0x04, 0x00, 0x00, 0x16, 0xC0, 0x00, 
				 0x00, 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 
				 0x00, 0x1F, 0x01, 0x00, 0x18, 0xC5, 0x02, 0x18, 
				 0x07, 0x04, 0x15, 0xA0, 0x00, 0xFF, 0x00, 0x09, 
				 0xCE, 0x03, 0x06, 0x05, 0x09, 0xCE, 0x03, 0x09, 
				 0x00, 0x09, 0xCE, 0x03, 0x0A, 0x00, 0x09, 0xCE, 
				 0x03, 0x0B, 0x00, 0x16, 0x80, 0x00, 0x2F, 0x00, 
				 0x16, 0x84, 0x00, 0x0E, 0x00, 0x16, 0x88, 0x00, 
				 0x42, 0x00, 0x1D, 0x19, 0x00, 0x00, 0x00, 0xCE, 
				 0x00, 0x00, 0x00, 0x9F, 0x00, 0x00, 0x00, 0x9F, 
				 0x00, 0x00, 0x00, 0x91, 0x00, 0x00, 0x00, 0xA3, 
				 0x00, 0x00, 0x00, 0x15, 0x00, 0x00, 0x00, 0x28, 
				 0x00, 0x00, 0x00, 0x5A, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x60, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x83, 0x00, 0x00, 0x00, 0xFF, 
				 0x00, 0x00, 0x00, 0xA0, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 0x24, 
				 0x00, 0x00, 0x00, 0xE3, 0x00, 0x00, 0x00, 0xFF, 
				 0x00, 0x00, 0x00, 0x1D, 0x06, 0x00, 0x64, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x30, 0x00, 0x00, 0x00, 
				 0x22, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x09, 0x00, 0x00, 0x00, 
				 0x13, 0xEA, 0x00, 0x1E, 0x00, 0x00, 0xC0, 0x00, 
				 0x00, 0x1E, 0x01, 0xD1, 0x0A, 0x00, 0x00, 0x1F, 
				 0x01, 0x00, 0x19, 0xEA, 0x00, 0x12, 0x07, 0x04, 
				 0x1E, 0x00, 0xC0, 0x00, 0x00, 0x00, 0x1E, 0x01, 
				 0x05, 0x00, 0x00, 0x00, 0x18, 0x07, 0x04, 0x13, 
				 0xC4, 0x02, 0x1E, 0x00, 0x3F, 0xC0, 0x00, 0x00, 
				 0x1E, 0x01, 0xC0, 0x05, 0x00, 0x00, 0x1F, 0x01, 
				 0x00, 0x19, 0xC4, 0x02, 0x13, 0xEA, 0x00, 0x1E, 
				 0x00, 0xC0, 0xFF, 0x00, 0x00, 0x1E, 0x01, 0x16, 
				 0x00, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 0xEA, 
				 0x00, 0x16, 0x02, 0x04, 0x00, 0x08, 0x13, 0xC0, 
				 0x00, 0x1E, 0x01, 0x00, 0x00, 0x00, 0x00, 0x19, 
				 0xC0, 0x00, 0x13, 0xEA, 0x00, 0x1E, 0x00, 0xFF, 
				 0xC0, 0x00, 0x00, 0x1E, 0x01, 0x00, 0x0A, 0x00, 
				 0x00, 0x1F, 0x01, 0x00, 0x19, 0xEA, 0x00, 0x00, 0x01};

BYTE t5465_Mode_1280x1024x8_5[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x16, 0x05, 0x04, 0x00, 0x00, 0x16, 0xC0, 0x00, 
				 0x00, 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 
				 0x00, 0x1F, 0x01, 0x00, 0x18, 0xC5, 0x02, 0x18, 
				 0x07, 0x04, 0x15, 0xA0, 0x00, 0xFF, 0x00, 0x09, 
				 0xCE, 0x03, 0x06, 0x05, 0x09, 0xCE, 0x03, 0x09, 
				 0x00, 0x09, 0xCE, 0x03, 0x0A, 0x00, 0x09, 0xCE, 
				 0x03, 0x0B, 0x00, 0x16, 0x80, 0x00, 0x2F, 0x00, 
				 0x16, 0x84, 0x00, 0x16, 0x00, 0x16, 0x88, 0x00, 
				 0x79, 0x00, 0x1D, 0x19, 0x00, 0x00, 0x00, 0xD3, 
				 0x00, 0x00, 0x00, 0x9F, 0x00, 0x00, 0x00, 0x9F, 
				 0x00, 0x00, 0x00, 0x91, 0x00, 0x00, 0x00, 0xA7, 
				 0x00, 0x00, 0x00, 0x1B, 0x00, 0x00, 0x00, 0x2E, 
				 0x00, 0x00, 0x00, 0x5A, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x60, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x83, 0x00, 0x00, 0x00, 0xFF, 
				 0x00, 0x00, 0x00, 0xA0, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 0x2A, 
				 0x00, 0x00, 0x00, 0xE3, 0x00, 0x00, 0x00, 0xFF, 
				 0x00, 0x00, 0x00, 0x1D, 0x06, 0x00, 0x64, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x30, 0x00, 0x00, 0x00, 
				 0x22, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x09, 0x00, 0x00, 0x00, 
				 0x13, 0xEA, 0x00, 0x1E, 0x00, 0x00, 0xC0, 0x00, 
				 0x00, 0x1E, 0x01, 0xD1, 0x0A, 0x00, 0x00, 0x1F, 
				 0x01, 0x00, 0x19, 0xEA, 0x00, 0x12, 0x07, 0x04, 
				 0x1E, 0x00, 0xC0, 0x00, 0x00, 0x00, 0x1E, 0x01, 
				 0x05, 0x00, 0x00, 0x00, 0x18, 0x07, 0x04, 0x13, 
				 0xC4, 0x02, 0x1E, 0x00, 0x3F, 0xC0, 0x00, 0x00, 
				 0x1E, 0x01, 0xC0, 0x05, 0x00, 0x00, 0x1F, 0x01, 
				 0x00, 0x19, 0xC4, 0x02, 0x13, 0xEA, 0x00, 0x1E, 
				 0x00, 0xC0, 0xFF, 0x00, 0x00, 0x1E, 0x01, 0x16, 
				 0x00, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 0xEA, 
				 0x00, 0x16, 0x02, 0x04, 0x00, 0x08, 0x13, 0xC0, 
				 0x00, 0x1E, 0x01, 0x00, 0x00, 0x00, 0x00, 0x19, 
				 0xC0, 0x00, 0x13, 0xEA, 0x00, 0x1E, 0x00, 0xFF, 
				 0xC0, 0x00, 0x00, 0x1E, 0x01, 0x00, 0x0A, 0x00, 
				 0x00, 0x1F, 0x01, 0x00, 0x19, 0xEA, 0x00, 0x00, 0x01};

BYTE t5465_Mode_1280x1024x8_1a[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x16, 0x05, 0x04, 0x00, 0x00, 0x16, 0xC0, 0x00, 
				 0x00, 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 
				 0x00, 0x1F, 0x01, 0x00, 0x18, 0xC5, 0x02, 0x18, 
				 0x07, 0x04, 0x15, 0xA0, 0x00, 0xFF, 0x00, 0x09, 
				 0xCE, 0x03, 0x06, 0x05, 0x09, 0xCE, 0x03, 0x09, 
				 0x00, 0x09, 0xCE, 0x03, 0x0A, 0x00, 0x09, 0xCE, 
				 0x03, 0x0B, 0x00, 0x16, 0x80, 0x00, 0x2F, 0x00, 
				 0x16, 0x84, 0x00, 0x04, 0x00, 0x16, 0x88, 0x00, 
				 0x0B, 0x00, 0x1D, 0x19, 0x00, 0x00, 0x00, 0xCF, 
				 0x00, 0x00, 0x00, 0x9F, 0x00, 0x00, 0x00, 0x9F, 
				 0x00, 0x00, 0x00, 0x93, 0x00, 0x00, 0x00, 0xA9, 
				 0x00, 0x00, 0x00, 0x13, 0x00, 0x00, 0x00, 0x14, 
				 0x00, 0x00, 0x00, 0xB2, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x60, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x82, 0x00, 0x00, 0x00, 0xFF, 
				 0x00, 0x00, 0x00, 0xA0, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x14, 
				 0x00, 0x00, 0x00, 0xE3, 0x00, 0x00, 0x00, 0xFF, 
				 0x00, 0x00, 0x00, 0x1D, 0x06, 0x00, 0x64, 0x00, 
				 0x67, 0x00, 0x00, 0x00, 0x81, 0x00, 0x00, 0x00, 
				 0x22, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x13, 0xEA, 0x00, 0x1E, 0x00, 0x00, 0xC0, 0x00, 
				 0x00, 0x1E, 0x01, 0x56, 0x14, 0x00, 0x00, 0x1F, 
				 0x01, 0x00, 0x19, 0xEA, 0x00, 0x12, 0x07, 0x04, 
				 0x1E, 0x00, 0xC0, 0x00, 0x00, 0x00, 0x1E, 0x01, 
				 0x0A, 0x00, 0x00, 0x00, 0x18, 0x07, 0x04, 0x13, 
				 0xC4, 0x02, 0x1E, 0x00, 0x3F, 0xC0, 0x00, 0x00, 
				 0x1E, 0x01, 0xC0, 0x0A, 0x00, 0x00, 0x1F, 0x01, 
				 0x00, 0x19, 0xC4, 0x02, 0x16, 0x02, 0x04, 0x00, 
				 0x08, 0x13, 0xC0, 0x00, 0x1E, 0x01, 0x00, 0x00, 
				 0x00, 0x00, 0x19, 0xC0, 0x00, 0x17, 0x4C, 0x00, 
				 0x40, 0x00, 0x00, 0x00, 0x17, 0x6C, 0x00, 0x32, 
				 0x00, 0x00, 0x00, 0x13, 0xEA, 0x00, 0x1E, 0x00, 
				 0xFF, 0xC0, 0x00, 0x00, 0x1E, 0x01, 0x00, 0x0A, 
				 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 0xEA, 0x00, 
				 0x00, 0x1F};

BYTE t5465_Mode_1280x1024x8_2a[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x16, 0x05, 0x04, 0x00, 0x00, 0x16, 0xC0, 0x00, 
				 0x00, 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 
				 0x00, 0x1F, 0x01, 0x00, 0x18, 0xC5, 0x02, 0x18, 
				 0x07, 0x04, 0x15, 0xA0, 0x00, 0xFF, 0x00, 0x09, 
				 0xCE, 0x03, 0x06, 0x05, 0x09, 0xCE, 0x03, 0x09, 
				 0x00, 0x09, 0xCE, 0x03, 0x0A, 0x00, 0x09, 0xCE, 
				 0x03, 0x0B, 0x00, 0x16, 0x80, 0x00, 0x2F, 0x00, 
				 0x16, 0x84, 0x00, 0x16, 0x00, 0x16, 0x88, 0x00, 
				 0x53, 0x00, 0x1D, 0x19, 0x00, 0x00, 0x00, 0xCE, 
				 0x00, 0x00, 0x00, 0x9F, 0x00, 0x00, 0x00, 0x9F, 
				 0x00, 0x00, 0x00, 0x91, 0x00, 0x00, 0x00, 0xA7, 
				 0x00, 0x00, 0x00, 0x15, 0x00, 0x00, 0x00, 0x28, 
				 0x00, 0x00, 0x00, 0x5A, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x60, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x83, 0x00, 0x00, 0x00, 0xFF, 
				 0x00, 0x00, 0x00, 0xA0, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 0x24, 
				 0x00, 0x00, 0x00, 0xE3, 0x00, 0x00, 0x00, 0xFF, 
				 0x00, 0x00, 0x00, 0x1D, 0x06, 0x00, 0x64, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x30, 0x00, 0x00, 0x00, 
				 0x22, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x09, 0x00, 0x00, 0x00, 
				 0x13, 0xEA, 0x00, 0x1E, 0x00, 0x00, 0xC0, 0x00, 
				 0x00, 0x1E, 0x01, 0x56, 0x14, 0x00, 0x00, 0x1F, 
				 0x01, 0x00, 0x19, 0xEA, 0x00, 0x12, 0x07, 0x04, 
				 0x1E, 0x00, 0xC0, 0x00, 0x00, 0x00, 0x1E, 0x01, 
				 0x0A, 0x00, 0x00, 0x00, 0x18, 0x07, 0x04, 0x13, 
				 0xC4, 0x02, 0x1E, 0x00, 0x3F, 0xC0, 0x00, 0x00, 
				 0x1E, 0x01, 0xC0, 0x0A, 0x00, 0x00, 0x1F, 0x01, 
				 0x00, 0x19, 0xC4, 0x02, 0x16, 0x02, 0x04, 0x00, 
				 0x08, 0x13, 0xC0, 0x00, 0x1E, 0x01, 0x00, 0x00, 
				 0x00, 0x00, 0x19, 0xC0, 0x00, 0x17, 0x4C, 0x00, 
				 0x40, 0x00, 0x00, 0x00, 0x17, 0x6C, 0x00, 0x32, 
				 0x00, 0x00, 0x00, 0x13, 0xEA, 0x00, 0x1E, 0x00, 
				 0xFF, 0xC0, 0x00, 0x00, 0x1E, 0x01, 0x00, 0x0A, 
				 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 0xEA, 0x00, 
				 0x00, 0x1F};

BYTE t5465_Mode_1280x1024x8_3a[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x16, 0x05, 0x04, 0x00, 0x00, 0x16, 0xC0, 0x00, 
				 0x00, 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 
				 0x00, 0x1F, 0x01, 0x00, 0x18, 0xC5, 0x02, 0x18, 
				 0x07, 0x04, 0x15, 0xA0, 0x00, 0xFF, 0x00, 0x09, 
				 0xCE, 0x03, 0x06, 0x05, 0x09, 0xCE, 0x03, 0x09, 
				 0x00, 0x09, 0xCE, 0x03, 0x0A, 0x00, 0x09, 0xCE, 
				 0x03, 0x0B, 0x00, 0x16, 0x80, 0x00, 0x2F, 0x00, 
				 0x16, 0x84, 0x00, 0x1A, 0x00, 0x16, 0x88, 0x00, 
				 0x76, 0x00, 0x1D, 0x19, 0x00, 0x00, 0x00, 0xCE, 
				 0x00, 0x00, 0x00, 0x9F, 0x00, 0x00, 0x00, 0x9F, 
				 0x00, 0x00, 0x00, 0x91, 0x00, 0x00, 0x00, 0xA3, 
				 0x00, 0x00, 0x00, 0x15, 0x00, 0x00, 0x00, 0x28, 
				 0x00, 0x00, 0x00, 0x5A, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x60, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x83, 0x00, 0x00, 0x00, 0xFF, 
				 0x00, 0x00, 0x00, 0xA0, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 0x24, 
				 0x00, 0x00, 0x00, 0xE3, 0x00, 0x00, 0x00, 0xFF, 
				 0x00, 0x00, 0x00, 0x1D, 0x06, 0x00, 0x64, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x30, 0x00, 0x00, 0x00, 
				 0x22, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x09, 0x00, 0x00, 0x00, 
				 0x13, 0xEA, 0x00, 0x1E, 0x00, 0x00, 0xC0, 0x00, 
				 0x00, 0x1E, 0x01, 0x56, 0x14, 0x00, 0x00, 0x1F, 
				 0x01, 0x00, 0x19, 0xEA, 0x00, 0x12, 0x07, 0x04, 
				 0x1E, 0x00, 0xC0, 0x00, 0x00, 0x00, 0x1E, 0x01, 
				 0x0A, 0x00, 0x00, 0x00, 0x18, 0x07, 0x04, 0x13, 
				 0xC4, 0x02, 0x1E, 0x00, 0x3F, 0xC0, 0x00, 0x00, 
				 0x1E, 0x01, 0xC0, 0x0A, 0x00, 0x00, 0x1F, 0x01, 
				 0x00, 0x19, 0xC4, 0x02, 0x16, 0x02, 0x04, 0x00, 
				 0x08, 0x13, 0xC0, 0x00, 0x1E, 0x01, 0x00, 0x00, 
				 0x00, 0x00, 0x19, 0xC0, 0x00, 0x17, 0x4C, 0x00, 
				 0x40, 0x00, 0x00, 0x00, 0x17, 0x6C, 0x00, 0x32, 
				 0x00, 0x00, 0x00, 0x13, 0xEA, 0x00, 0x1E, 0x00, 
				 0xFF, 0xC0, 0x00, 0x00, 0x1E, 0x01, 0x00, 0x0A, 
				 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 0xEA, 0x00, 
				 0x00, 0x1F};

BYTE t5465_Mode_1280x1024x8_4a[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x16, 0x05, 0x04, 0x00, 0x00, 0x16, 0xC0, 0x00, 
				 0x00, 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 
				 0x00, 0x1F, 0x01, 0x00, 0x18, 0xC5, 0x02, 0x18, 
				 0x07, 0x04, 0x15, 0xA0, 0x00, 0xFF, 0x00, 0x09, 
				 0xCE, 0x03, 0x06, 0x05, 0x09, 0xCE, 0x03, 0x09, 
				 0x00, 0x09, 0xCE, 0x03, 0x0A, 0x00, 0x09, 0xCE, 
				 0x03, 0x0B, 0x00, 0x16, 0x80, 0x00, 0x2F, 0x00, 
				 0x16, 0x84, 0x00, 0x0E, 0x00, 0x16, 0x88, 0x00, 
				 0x42, 0x00, 0x1D, 0x19, 0x00, 0x00, 0x00, 0xCE, 
				 0x00, 0x00, 0x00, 0x9F, 0x00, 0x00, 0x00, 0x9F, 
				 0x00, 0x00, 0x00, 0x91, 0x00, 0x00, 0x00, 0xA3, 
				 0x00, 0x00, 0x00, 0x15, 0x00, 0x00, 0x00, 0x28, 
				 0x00, 0x00, 0x00, 0x5A, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x60, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x83, 0x00, 0x00, 0x00, 0xFF, 
				 0x00, 0x00, 0x00, 0xA0, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 0x24, 
				 0x00, 0x00, 0x00, 0xE3, 0x00, 0x00, 0x00, 0xFF, 
				 0x00, 0x00, 0x00, 0x1D, 0x06, 0x00, 0x64, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x30, 0x00, 0x00, 0x00, 
				 0x22, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x09, 0x00, 0x00, 0x00, 
				 0x13, 0xEA, 0x00, 0x1E, 0x00, 0x00, 0xC0, 0x00, 
				 0x00, 0x1E, 0x01, 0x56, 0x14, 0x00, 0x00, 0x1F, 
				 0x01, 0x00, 0x19, 0xEA, 0x00, 0x12, 0x07, 0x04, 
				 0x1E, 0x00, 0xC0, 0x00, 0x00, 0x00, 0x1E, 0x01, 
				 0x0A, 0x00, 0x00, 0x00, 0x18, 0x07, 0x04, 0x13, 
				 0xC4, 0x02, 0x1E, 0x00, 0x3F, 0xC0, 0x00, 0x00, 
				 0x1E, 0x01, 0xC0, 0x0A, 0x00, 0x00, 0x1F, 0x01, 
				 0x00, 0x19, 0xC4, 0x02, 0x16, 0x02, 0x04, 0x00, 
				 0x08, 0x13, 0xC0, 0x00, 0x1E, 0x01, 0x00, 0x00, 
				 0x00, 0x00, 0x19, 0xC0, 0x00, 0x17, 0x4C, 0x00, 
				 0x40, 0x00, 0x00, 0x00, 0x17, 0x6C, 0x00, 0x32, 
				 0x00, 0x00, 0x00, 0x13, 0xEA, 0x00, 0x1E, 0x00, 
				 0xFF, 0xC0, 0x00, 0x00, 0x1E, 0x01, 0x00, 0x0A, 
				 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 0xEA, 0x00, 
				 0x00, 0x1F};

BYTE t5465_Mode_1280x1024x8_5a[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x16, 0x05, 0x04, 0x00, 0x00, 0x16, 0xC0, 0x00, 
				 0x00, 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 
				 0x00, 0x1F, 0x01, 0x00, 0x18, 0xC5, 0x02, 0x18, 
				 0x07, 0x04, 0x15, 0xA0, 0x00, 0xFF, 0x00, 0x09, 
				 0xCE, 0x03, 0x06, 0x05, 0x09, 0xCE, 0x03, 0x09, 
				 0x00, 0x09, 0xCE, 0x03, 0x0A, 0x00, 0x09, 0xCE, 
				 0x03, 0x0B, 0x00, 0x16, 0x80, 0x00, 0x2F, 0x00, 
				 0x16, 0x84, 0x00, 0x16, 0x00, 0x16, 0x88, 0x00, 
				 0x79, 0x00, 0x1D, 0x19, 0x00, 0x00, 0x00, 0xD3, 
				 0x00, 0x00, 0x00, 0x9F, 0x00, 0x00, 0x00, 0x9F, 
				 0x00, 0x00, 0x00, 0x91, 0x00, 0x00, 0x00, 0xA7, 
				 0x00, 0x00, 0x00, 0x1B, 0x00, 0x00, 0x00, 0x2E, 
				 0x00, 0x00, 0x00, 0x5A, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x60, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x83, 0x00, 0x00, 0x00, 0xFF, 
				 0x00, 0x00, 0x00, 0xA0, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 0x2A, 
				 0x00, 0x00, 0x00, 0xE3, 0x00, 0x00, 0x00, 0xFF, 
				 0x00, 0x00, 0x00, 0x1D, 0x06, 0x00, 0x64, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x30, 0x00, 0x00, 0x00, 
				 0x22, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x09, 0x00, 0x00, 0x00, 
				 0x13, 0xEA, 0x00, 0x1E, 0x00, 0x00, 0xC0, 0x00, 
				 0x00, 0x1E, 0x01, 0x56, 0x14, 0x00, 0x00, 0x1F, 
				 0x01, 0x00, 0x19, 0xEA, 0x00, 0x12, 0x07, 0x04, 
				 0x1E, 0x00, 0xC0, 0x00, 0x00, 0x00, 0x1E, 0x01, 
				 0x0A, 0x00, 0x00, 0x00, 0x18, 0x07, 0x04, 0x13, 
				 0xC4, 0x02, 0x1E, 0x00, 0x3F, 0xC0, 0x00, 0x00, 
				 0x1E, 0x01, 0xC0, 0x0A, 0x00, 0x00, 0x1F, 0x01, 
				 0x00, 0x19, 0xC4, 0x02, 0x16, 0x02, 0x04, 0x00, 
				 0x08, 0x13, 0xC0, 0x00, 0x1E, 0x01, 0x00, 0x00, 
				 0x00, 0x00, 0x19, 0xC0, 0x00, 0x17, 0x4C, 0x00, 
				 0x40, 0x00, 0x00, 0x00, 0x17, 0x6C, 0x00, 0x32, 
				 0x00, 0x00, 0x00, 0x13, 0xEA, 0x00, 0x1E, 0x00, 
				 0xFF, 0xC0, 0x00, 0x00, 0x1E, 0x01, 0x00, 0x0A, 
				 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 0xEA, 0x00, 
				 0x00, 0x1F};

BYTE t5465_Mode_1600x1200x8_1[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x16, 0x05, 0x04, 0x00, 0x00, 0x16, 0xC0, 0x00, 
				 0x00, 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 
				 0x00, 0x1F, 0x01, 0x00, 0x18, 0xC5, 0x02, 0x18, 
				 0x07, 0x04, 0x15, 0xA0, 0x00, 0xFF, 0x00, 0x09, 
				 0xCE, 0x03, 0x06, 0x05, 0x09, 0xCE, 0x03, 0x09, 
				 0x00, 0x09, 0xCE, 0x03, 0x0A, 0x00, 0x09, 0xCE, 
				 0x03, 0x0B, 0x00, 0x16, 0x80, 0x00, 0x2F, 0x00, 
				 0x16, 0x84, 0x00, 0x0E, 0x00, 0x16, 0x88, 0x00, 
				 0x42, 0x00, 0x1D, 0x19, 0x00, 0x00, 0x00, 0x09, 
				 0x00, 0x00, 0x00, 0xC7, 0x00, 0x00, 0x00, 0xC7, 
				 0x00, 0x00, 0x00, 0x8C, 0x00, 0x00, 0x00, 0xCF, 
				 0x00, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00, 0x88, 
				 0x00, 0x00, 0x00, 0xE0, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x60, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x58, 
				 0x00, 0x00, 0x00, 0x8B, 0x00, 0x00, 0x00, 0x57, 
				 0x00, 0x00, 0x00, 0xD0, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x58, 0x00, 0x00, 0x00, 0x85, 
				 0x00, 0x00, 0x00, 0xE3, 0x00, 0x00, 0x00, 0xFF, 
				 0x00, 0x00, 0x00, 0x1D, 0x06, 0x00, 0x64, 0x00, 
				 0x84, 0x00, 0x00, 0x00, 0x81, 0x00, 0x00, 0x00, 
				 0x22, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 
				 0x13, 0xEA, 0x00, 0x1E, 0x00, 0x00, 0xC0, 0x00, 
				 0x00, 0x1E, 0x01, 0x12, 0x0D, 0x00, 0x00, 0x1F, 
				 0x01, 0x00, 0x19, 0xEA, 0x00, 0x12, 0x07, 0x04, 
				 0x1E, 0x00, 0xC0, 0x00, 0x00, 0x00, 0x1E, 0x01, 
				 0x0D, 0x00, 0x00, 0x00, 0x18, 0x07, 0x04, 0x13, 
				 0xC4, 0x02, 0x1E, 0x00, 0x3F, 0xC0, 0x00, 0x00, 
				 0x1E, 0x01, 0x80, 0x0D, 0x00, 0x00, 0x1F, 0x01, 
				 0x00, 0x19, 0xC4, 0x02, 0x13, 0xEA, 0x00, 0x1E, 
				 0x00, 0xC0, 0xFF, 0x00, 0x00, 0x1E, 0x01, 0x1A, 
				 0x00, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 0xEA, 
				 0x00, 0x16, 0x02, 0x04, 0x00, 0x00, 0x13, 0xC0, 
				 0x00, 0x1E, 0x01, 0x00, 0x00, 0x00, 0x00, 0x19, 
				 0xC0, 0x00, 0x13, 0xEA, 0x00, 0x1E, 0x00, 0xFF, 
				 0xC0, 0x00, 0x00, 0x1E, 0x01, 0x00, 0x0D, 0x00, 
				 0x00, 0x1F, 0x01, 0x00, 0x19, 0xEA, 0x00, 0x00, 0x01};

BYTE t5465_Mode_1600x1200x8_2[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x16, 0x05, 0x04, 0x00, 0x00, 0x16, 0xC0, 0x00, 
				 0x00, 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 
				 0x00, 0x1F, 0x01, 0x00, 0x18, 0xC5, 0x02, 0x18, 
				 0x07, 0x04, 0x15, 0xA0, 0x00, 0xFF, 0x00, 0x09, 
				 0xCE, 0x03, 0x06, 0x05, 0x09, 0xCE, 0x03, 0x09, 
				 0x00, 0x09, 0xCE, 0x03, 0x0A, 0x00, 0x09, 0xCE, 
				 0x03, 0x0B, 0x00, 0x16, 0x80, 0x00, 0x2F, 0x00, 
				 0x16, 0x84, 0x00, 0x14, 0x00, 0x16, 0x88, 0x00, 
				 0x71, 0x00, 0x1D, 0x19, 0x00, 0x00, 0x00, 0x09, 
				 0x00, 0x00, 0x00, 0xC7, 0x00, 0x00, 0x00, 0xC7, 
				 0x00, 0x00, 0x00, 0x89, 0x00, 0x00, 0x00, 0xD1, 
				 0x00, 0x00, 0x00, 0x09, 0x00, 0x00, 0x00, 0xDF, 
				 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xB0, 
				 0x00, 0x00, 0x00, 0x83, 0x00, 0x00, 0x00, 0xAF, 
				 0x00, 0x00, 0x00, 0xD0, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0xAF, 0x00, 0x00, 0x00, 0xDF, 
				 0x00, 0x00, 0x00, 0xE3, 0x00, 0x00, 0x00, 0xFF, 
				 0x00, 0x00, 0x00, 0x1D, 0x06, 0x00, 0x64, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x22, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x8F, 0x00, 0x00, 0x00, 
				 0x13, 0xEA, 0x00, 0x1E, 0x00, 0x00, 0xC0, 0x00, 
				 0x00, 0x1E, 0x01, 0x12, 0x0D, 0x00, 0x00, 0x1F, 
				 0x01, 0x00, 0x19, 0xEA, 0x00, 0x12, 0x07, 0x04, 
				 0x1E, 0x00, 0xC0, 0x00, 0x00, 0x00, 0x1E, 0x01, 
				 0x0D, 0x00, 0x00, 0x00, 0x18, 0x07, 0x04, 0x13, 
				 0xC4, 0x02, 0x1E, 0x00, 0x3F, 0xC0, 0x00, 0x00, 
				 0x1E, 0x01, 0x80, 0x0D, 0x00, 0x00, 0x1F, 0x01, 
				 0x00, 0x19, 0xC4, 0x02, 0x13, 0xEA, 0x00, 0x1E, 
				 0x00, 0xC0, 0xFF, 0x00, 0x00, 0x1E, 0x01, 0x1A, 
				 0x00, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 0xEA, 
				 0x00, 0x16, 0x02, 0x04, 0x00, 0x00, 0x13, 0xC0, 
				 0x00, 0x1E, 0x01, 0x00, 0x00, 0x00, 0x00, 0x19, 
				 0xC0, 0x00, 0x13, 0xEA, 0x00, 0x1E, 0x00, 0xFF, 
				 0xC0, 0x00, 0x00, 0x1E, 0x01, 0x00, 0x0D, 0x00, 
				 0x00, 0x1F, 0x01, 0x00, 0x19, 0xEA, 0x00, 0x00, 0x01};

BYTE t5465_Mode_1600x1200x8_1a[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x16, 0x05, 0x04, 0x00, 0x00, 0x16, 0xC0, 0x00, 
				 0x00, 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 
				 0x00, 0x1F, 0x01, 0x00, 0x18, 0xC5, 0x02, 0x18, 
				 0x07, 0x04, 0x15, 0xA0, 0x00, 0xFF, 0x00, 0x09, 
				 0xCE, 0x03, 0x06, 0x05, 0x09, 0xCE, 0x03, 0x09, 
				 0x00, 0x09, 0xCE, 0x03, 0x0A, 0x00, 0x09, 0xCE, 
				 0x03, 0x0B, 0x00, 0x16, 0x80, 0x00, 0x2F, 0x00, 
				 0x16, 0x84, 0x00, 0x0E, 0x00, 0x16, 0x88, 0x00, 
				 0x42, 0x00, 0x1D, 0x19, 0x00, 0x00, 0x00, 0x09, 
				 0x00, 0x00, 0x00, 0xC7, 0x00, 0x00, 0x00, 0xC7, 
				 0x00, 0x00, 0x00, 0x8C, 0x00, 0x00, 0x00, 0xCF, 
				 0x00, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00, 0x88, 
				 0x00, 0x00, 0x00, 0xE0, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x60, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x58, 
				 0x00, 0x00, 0x00, 0x8B, 0x00, 0x00, 0x00, 0x57, 
				 0x00, 0x00, 0x00, 0xD0, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x58, 0x00, 0x00, 0x00, 0x85, 
				 0x00, 0x00, 0x00, 0xE3, 0x00, 0x00, 0x00, 0xFF, 
				 0x00, 0x00, 0x00, 0x1D, 0x06, 0x00, 0x64, 0x00, 
				 0x84, 0x00, 0x00, 0x00, 0x81, 0x00, 0x00, 0x00, 
				 0x22, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 
				 0x13, 0xEA, 0x00, 0x1E, 0x00, 0x00, 0xC0, 0x00, 
				 0x00, 0x1E, 0x01, 0x1A, 0x1A, 0x00, 0x00, 0x1F, 
				 0x01, 0x00, 0x19, 0xEA, 0x00, 0x12, 0x07, 0x04, 
				 0x1E, 0x00, 0xC0, 0x00, 0x00, 0x00, 0x1E, 0x01, 
				 0x1A, 0x00, 0x00, 0x00, 0x18, 0x07, 0x04, 0x13, 
				 0xC4, 0x02, 0x1E, 0x00, 0x3F, 0xC0, 0x00, 0x00, 
				 0x1E, 0x01, 0x80, 0x1A, 0x00, 0x00, 0x1F, 0x01, 
				 0x00, 0x19, 0xC4, 0x02, 0x16, 0x02, 0x04, 0x00, 
				 0x00, 0x13, 0xC0, 0x00, 0x1E, 0x01, 0x00, 0x00, 
				 0x00, 0x00, 0x19, 0xC0, 0x00, 0x17, 0x4C, 0x00, 
				 0xA0, 0x00, 0x00, 0x00, 0x17, 0x6C, 0x00, 0x32, 
				 0x00, 0x00, 0x00, 0x13, 0xEA, 0x00, 0x1E, 0x00, 
				 0xFF, 0xC0, 0x00, 0x00, 0x1E, 0x01, 0x00, 0x0D, 
				 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 0xEA, 0x00, 
				 0x00, 0x1F};

BYTE t5465_Mode_1600x1200x8_2a[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x16, 0x05, 0x04, 0x00, 0x00, 0x16, 0xC0, 0x00, 
				 0x00, 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 
				 0x00, 0x1F, 0x01, 0x00, 0x18, 0xC5, 0x02, 0x18, 
				 0x07, 0x04, 0x15, 0xA0, 0x00, 0xFF, 0x00, 0x09, 
				 0xCE, 0x03, 0x06, 0x05, 0x09, 0xCE, 0x03, 0x09, 
				 0x00, 0x09, 0xCE, 0x03, 0x0A, 0x00, 0x09, 0xCE, 
				 0x03, 0x0B, 0x00, 0x16, 0x80, 0x00, 0x2F, 0x00, 
				 0x16, 0x84, 0x00, 0x14, 0x00, 0x16, 0x88, 0x00, 
				 0x71, 0x00, 0x1D, 0x19, 0x00, 0x00, 0x00, 0x09, 
				 0x00, 0x00, 0x00, 0xC7, 0x00, 0x00, 0x00, 0xC7, 
				 0x00, 0x00, 0x00, 0x89, 0x00, 0x00, 0x00, 0xD1, 
				 0x00, 0x00, 0x00, 0x09, 0x00, 0x00, 0x00, 0xDF, 
				 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xB0, 
				 0x00, 0x00, 0x00, 0x83, 0x00, 0x00, 0x00, 0xAF, 
				 0x00, 0x00, 0x00, 0xD0, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0xAF, 0x00, 0x00, 0x00, 0xDF, 
				 0x00, 0x00, 0x00, 0xE3, 0x00, 0x00, 0x00, 0xFF, 
				 0x00, 0x00, 0x00, 0x1D, 0x06, 0x00, 0x64, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x22, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x8F, 0x00, 0x00, 0x00, 
				 0x13, 0xEA, 0x00, 0x1E, 0x00, 0x00, 0xC0, 0x00, 
				 0x00, 0x1E, 0x01, 0x1A, 0x1A, 0x00, 0x00, 0x1F, 
				 0x01, 0x00, 0x19, 0xEA, 0x00, 0x12, 0x07, 0x04, 
				 0x1E, 0x00, 0xC0, 0x00, 0x00, 0x00, 0x1E, 0x01, 
				 0x1A, 0x00, 0x00, 0x00, 0x18, 0x07, 0x04, 0x13, 
				 0xC4, 0x02, 0x1E, 0x00, 0x3F, 0xC0, 0x00, 0x00, 
				 0x1E, 0x01, 0x80, 0x1A, 0x00, 0x00, 0x1F, 0x01, 
				 0x00, 0x19, 0xC4, 0x02, 0x16, 0x02, 0x04, 0x00, 
				 0x00, 0x13, 0xC0, 0x00, 0x1E, 0x01, 0x00, 0x00, 
				 0x00, 0x00, 0x19, 0xC0, 0x00, 0x17, 0x4C, 0x00, 
				 0xA0, 0x00, 0x00, 0x00, 0x17, 0x6C, 0x00, 0x32, 
				 0x00, 0x00, 0x00, 0x13, 0xEA, 0x00, 0x1E, 0x00, 
				 0xFF, 0xC0, 0x00, 0x00, 0x1E, 0x01, 0x00, 0x0D, 
				 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 0xEA, 0x00, 
				 0x00, 0x1F};

BYTE t5465_Mode_320x200x16_1[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x16, 0x05, 0x04, 0x00, 0x00, 0x16, 0xC0, 0x00, 
				 0x00, 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 
				 0x00, 0x1F, 0x01, 0x00, 0x18, 0xC5, 0x02, 0x18, 
				 0x07, 0x04, 0x15, 0xA0, 0x00, 0xFF, 0x00, 0x09, 
				 0xCE, 0x03, 0x06, 0x05, 0x09, 0xCE, 0x03, 0x09, 
				 0x00, 0x09, 0xCE, 0x03, 0x0A, 0x00, 0x09, 0xCE, 
				 0x03, 0x0B, 0x00, 0x16, 0x80, 0x00, 0x2F, 0x00, 
				 0x16, 0x84, 0x00, 0x42, 0x00, 0x16, 0x88, 0x00, 
				 0x74, 0x00, 0x16, 0xC0, 0x00, 0x00, 0x80, 0x1D, 
				 0x19, 0x00, 0x00, 0x00, 0x2D, 0x00, 0x00, 0x00, 
				 0x27, 0x00, 0x00, 0x00, 0x28, 0x00, 0x00, 0x00, 
				 0x8D, 0x00, 0x00, 0x00, 0x2A, 0x00, 0x00, 0x00, 
				 0x8B, 0x00, 0x00, 0x00, 0xA0, 0x00, 0x00, 0x00, 
				 0x1F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0xC0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x91, 0x00, 0x00, 0x00, 
				 0x84, 0x00, 0x00, 0x00, 0x8F, 0x00, 0x00, 0x00, 
				 0x50, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x90, 0x00, 0x00, 0x00, 0xA0, 0x00, 0x00, 0x00, 
				 0xE3, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 
				 0x1D, 0x06, 0x00, 0x64, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x40, 0x00, 0x00, 0x00, 0x22, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x13, 0xEA, 0x00, 
				 0x1E, 0x00, 0x00, 0xC0, 0x00, 0x00, 0x1E, 0x01, 
				 0x11, 0x0A, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 
				 0xEA, 0x00, 0x12, 0x07, 0x04, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x0A, 0x00, 0x00, 
				 0x00, 0x18, 0x07, 0x04, 0x13, 0xC4, 0x02, 0x1E, 
				 0x00, 0x3F, 0xC0, 0x00, 0x00, 0x1E, 0x01, 0x80, 
				 0x0A, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 0xC4, 
				 0x02, 0x16, 0x02, 0x04, 0x00, 0x20, 0x13, 0xC0, 
				 0x00, 0x1E, 0x01, 0x00, 0x16, 0x00, 0x00, 0x19, 
				 0xC0, 0x00, 0x17, 0x4C, 0x00, 0xA0, 0x00, 0x00, 
				 0x00, 0x13, 0xEA, 0x00, 0x1E, 0x00, 0xFF, 0xC0, 
				 0x00, 0x00, 0x1E, 0x01, 0x00, 0x05, 0x00, 0x00, 
				 0x1F, 0x01, 0x00, 0x19, 0xEA, 0x00, 0x13, 0xC0, 
				 0x00, 0x1E, 0x00, 0x00, 0xC0, 0x00, 0x00, 0x1E, 
				 0x01, 0x00, 0x14, 0x00, 0x00, 0x19, 0xC0, 0x00, 
				 0x13, 0xEA, 0x00, 0x1E, 0x00, 0xFF, 0xC0, 0x00, 
				 0x00, 0x1E, 0x01, 0x00, 0x05, 0x00, 0x00, 0x1F, 
				 0x01, 0x00, 0x19, 0xEA, 0x00, 0x00, 0x00};

BYTE t5465_Mode_320x240x16_1[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x16, 0x05, 0x04, 0x00, 0x00, 0x16, 0xC0, 0x00, 
				 0x00, 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 
				 0x00, 0x1F, 0x01, 0x00, 0x18, 0xC5, 0x02, 0x18, 
				 0x07, 0x04, 0x15, 0xA0, 0x00, 0xFF, 0x00, 0x09, 
				 0xCE, 0x03, 0x06, 0x05, 0x09, 0xCE, 0x03, 0x09, 
				 0x00, 0x09, 0xCE, 0x03, 0x0A, 0x00, 0x09, 0xCE, 
				 0x03, 0x0B, 0x00, 0x16, 0x80, 0x00, 0xEF, 0x00, 
				 0x16, 0x84, 0x00, 0x42, 0x00, 0x16, 0x88, 0x00, 
				 0x74, 0x00, 0x16, 0xC0, 0x00, 0x00, 0x80, 0x1D, 
				 0x19, 0x00, 0x00, 0x00, 0x2D, 0x00, 0x00, 0x00, 
				 0x27, 0x00, 0x00, 0x00, 0x27, 0x00, 0x00, 0x00, 
				 0x8C, 0x00, 0x00, 0x00, 0x2A, 0x00, 0x00, 0x00, 
				 0x8B, 0x00, 0x00, 0x00, 0x0B, 0x00, 0x00, 0x00, 
				 0x3E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0xC0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0xE1, 0x00, 0x00, 0x00, 
				 0x83, 0x00, 0x00, 0x00, 0xDF, 0x00, 0x00, 0x00, 
				 0x50, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0xDF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0xE3, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 
				 0x1D, 0x06, 0x00, 0x64, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x80, 0x00, 0x00, 0x00, 0x22, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x13, 0xEA, 0x00, 
				 0x1E, 0x00, 0x00, 0xC0, 0x00, 0x00, 0x1E, 0x01, 
				 0x11, 0x08, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 
				 0xEA, 0x00, 0x12, 0x07, 0x04, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x08, 0x00, 0x00, 
				 0x00, 0x18, 0x07, 0x04, 0x13, 0xC4, 0x02, 0x1E, 
				 0x00, 0x3F, 0xC0, 0x00, 0x00, 0x1E, 0x01, 0x80, 
				 0x08, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 0xC4, 
				 0x02, 0x16, 0x02, 0x04, 0x00, 0x20, 0x13, 0xC0, 
				 0x00, 0x1E, 0x01, 0x00, 0x16, 0x00, 0x00, 0x19, 
				 0xC0, 0x00, 0x17, 0x4C, 0x00, 0x80, 0x00, 0x00, 
				 0x00, 0x13, 0xEA, 0x00, 0x1E, 0x00, 0xFF, 0xC0, 
				 0x00, 0x00, 0x1E, 0x01, 0x00, 0x05, 0x00, 0x00, 
				 0x1F, 0x01, 0x00, 0x19, 0xEA, 0x00, 0x13, 0xC0, 
				 0x00, 0x1E, 0x00, 0x00, 0xC0, 0x00, 0x00, 0x1E, 
				 0x01, 0x00, 0x14, 0x00, 0x00, 0x19, 0xC0, 0x00, 
				 0x13, 0xEA, 0x00, 0x1E, 0x00, 0xFF, 0xC0, 0x00, 
				 0x00, 0x1E, 0x01, 0x00, 0x05, 0x00, 0x00, 0x1F, 
				 0x01, 0x00, 0x19, 0xEA, 0x00, 0x00, 0x00};

BYTE t5465_Mode_320x240x16_2[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x16, 0x05, 0x04, 0x00, 0x00, 0x16, 0xC0, 0x00, 
				 0x00, 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 
				 0x00, 0x1F, 0x01, 0x00, 0x18, 0xC5, 0x02, 0x18, 
				 0x07, 0x04, 0x15, 0xA0, 0x00, 0xFF, 0x00, 0x09, 
				 0xCE, 0x03, 0x06, 0x05, 0x09, 0xCE, 0x03, 0x09, 
				 0x00, 0x09, 0xCE, 0x03, 0x0A, 0x00, 0x09, 0xCE, 
				 0x03, 0x0B, 0x00, 0x16, 0x80, 0x00, 0xEF, 0x00, 
				 0x16, 0x84, 0x00, 0x0A, 0x00, 0x16, 0x88, 0x00, 
				 0x16, 0x00, 0x16, 0xC0, 0x00, 0x00, 0x80, 0x1D, 
				 0x19, 0x00, 0x00, 0x00, 0x2F, 0x00, 0x00, 0x00, 
				 0x27, 0x00, 0x00, 0x00, 0x27, 0x00, 0x00, 0x00, 
				 0x8C, 0x00, 0x00, 0x00, 0x2A, 0x00, 0x00, 0x00, 
				 0x8B, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 
				 0x3E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0xC0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0xE0, 0x00, 0x00, 0x00, 
				 0x83, 0x00, 0x00, 0x00, 0xDF, 0x00, 0x00, 0x00, 
				 0x50, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0xDF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0xE3, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 
				 0x1D, 0x06, 0x00, 0x64, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x80, 0x00, 0x00, 0x00, 0x22, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x13, 0xEA, 0x00, 
				 0x1E, 0x00, 0x00, 0xC0, 0x00, 0x00, 0x1E, 0x01, 
				 0x11, 0x08, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 
				 0xEA, 0x00, 0x12, 0x07, 0x04, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x08, 0x00, 0x00, 
				 0x00, 0x18, 0x07, 0x04, 0x13, 0xC4, 0x02, 0x1E, 
				 0x00, 0x3F, 0xC0, 0x00, 0x00, 0x1E, 0x01, 0x80, 
				 0x08, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 0xC4, 
				 0x02, 0x13, 0xEA, 0x00, 0x1E, 0x00, 0xC0, 0xFF, 
				 0x00, 0x00, 0x1E, 0x01, 0x14, 0x00, 0x00, 0x00, 
				 0x1F, 0x01, 0x00, 0x19, 0xEA, 0x00, 0x16, 0x02, 
				 0x04, 0x00, 0x20, 0x13, 0xC0, 0x00, 0x1E, 0x01, 
				 0x00, 0x16, 0x00, 0x00, 0x19, 0xC0, 0x00, 0x17, 
				 0x4C, 0x00, 0x80, 0x00, 0x00, 0x00, 0x13, 0xEA, 
				 0x00, 0x1E, 0x00, 0xFF, 0xC0, 0x00, 0x00, 0x1E, 
				 0x01, 0x00, 0x05, 0x00, 0x00, 0x1F, 0x01, 0x00, 
				 0x19, 0xEA, 0x00, 0x13, 0xC0, 0x00, 0x1E, 0x00, 
				 0x00, 0xC0, 0x00, 0x00, 0x1E, 0x01, 0x00, 0x14, 
				 0x00, 0x00, 0x19, 0xC0, 0x00, 0x13, 0xEA, 0x00, 
				 0x1E, 0x00, 0xFF, 0xC0, 0x00, 0x00, 0x1E, 0x01, 
				 0x00, 0x05, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 
				 0xEA, 0x00, 0x00, 0x00};

BYTE t5465_Mode_320x400x16_1[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x16, 0x05, 0x04, 0x00, 0x00, 0x16, 0xC0, 0x00, 
				 0x00, 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 
				 0x00, 0x1F, 0x01, 0x00, 0x18, 0xC5, 0x02, 0x18, 
				 0x07, 0x04, 0x15, 0xA0, 0x00, 0xFF, 0x00, 0x09, 
				 0xCE, 0x03, 0x06, 0x05, 0x09, 0xCE, 0x03, 0x09, 
				 0x00, 0x09, 0xCE, 0x03, 0x0A, 0x00, 0x09, 0xCE, 
				 0x03, 0x0B, 0x00, 0x16, 0x80, 0x00, 0x2F, 0x00, 
				 0x16, 0x84, 0x00, 0x42, 0x00, 0x16, 0x88, 0x00, 
				 0x74, 0x00, 0x16, 0xC0, 0x00, 0x00, 0x80, 0x1D, 
				 0x19, 0x00, 0x00, 0x00, 0x2D, 0x00, 0x00, 0x00, 
				 0x27, 0x00, 0x00, 0x00, 0x28, 0x00, 0x00, 0x00, 
				 0x8D, 0x00, 0x00, 0x00, 0x2A, 0x00, 0x00, 0x00, 
				 0x8B, 0x00, 0x00, 0x00, 0xA0, 0x00, 0x00, 0x00, 
				 0x1F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x91, 0x00, 0x00, 0x00, 
				 0x84, 0x00, 0x00, 0x00, 0x8F, 0x00, 0x00, 0x00, 
				 0x50, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x90, 0x00, 0x00, 0x00, 0xA0, 0x00, 0x00, 0x00, 
				 0xE3, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 
				 0x1D, 0x06, 0x00, 0x64, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x40, 0x00, 0x00, 0x00, 0x22, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x13, 0xEA, 0x00, 
				 0x1E, 0x00, 0x00, 0xC0, 0x00, 0x00, 0x1E, 0x01, 
				 0x11, 0x0A, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 
				 0xEA, 0x00, 0x12, 0x07, 0x04, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x0A, 0x00, 0x00, 
				 0x00, 0x18, 0x07, 0x04, 0x13, 0xC4, 0x02, 0x1E, 
				 0x00, 0x3F, 0xC0, 0x00, 0x00, 0x1E, 0x01, 0x80, 
				 0x0A, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 0xC4, 
				 0x02, 0x13, 0xEA, 0x00, 0x1E, 0x00, 0xC0, 0xFF, 
				 0x00, 0x00, 0x1E, 0x01, 0x19, 0x00, 0x00, 0x00, 
				 0x1F, 0x01, 0x00, 0x19, 0xEA, 0x00, 0x16, 0x02, 
				 0x04, 0x00, 0x20, 0x13, 0xC0, 0x00, 0x1E, 0x01, 
				 0x00, 0x16, 0x00, 0x00, 0x19, 0xC0, 0x00, 0x17, 
				 0x4C, 0x00, 0xA0, 0x00, 0x00, 0x00, 0x13, 0xEA, 
				 0x00, 0x1E, 0x00, 0xFF, 0xC0, 0x00, 0x00, 0x1E, 
				 0x01, 0x00, 0x05, 0x00, 0x00, 0x1F, 0x01, 0x00, 
				 0x19, 0xEA, 0x00, 0x13, 0xC0, 0x00, 0x1E, 0x00, 
				 0x00, 0xC0, 0x00, 0x00, 0x1E, 0x01, 0x00, 0x14, 
				 0x00, 0x00, 0x19, 0xC0, 0x00, 0x13, 0xEA, 0x00, 
				 0x1E, 0x00, 0xFF, 0xC0, 0x00, 0x00, 0x1E, 0x01, 
				 0x00, 0x05, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 
				 0xEA, 0x00, 0x00, 0x00};

BYTE t5465_Mode_320x480x16_1[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x16, 0x05, 0x04, 0x00, 0x00, 0x16, 0xC0, 0x00, 
				 0x00, 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 
				 0x00, 0x1F, 0x01, 0x00, 0x18, 0xC5, 0x02, 0x18, 
				 0x07, 0x04, 0x15, 0xA0, 0x00, 0xFF, 0x00, 0x09, 
				 0xCE, 0x03, 0x06, 0x05, 0x09, 0xCE, 0x03, 0x09, 
				 0x00, 0x09, 0xCE, 0x03, 0x0A, 0x00, 0x09, 0xCE, 
				 0x03, 0x0B, 0x00, 0x16, 0x80, 0x00, 0xEF, 0x00, 
				 0x16, 0x84, 0x00, 0x42, 0x00, 0x16, 0x88, 0x00, 
				 0x74, 0x00, 0x16, 0xC0, 0x00, 0x00, 0x80, 0x1D, 
				 0x19, 0x00, 0x00, 0x00, 0x2D, 0x00, 0x00, 0x00, 
				 0x27, 0x00, 0x00, 0x00, 0x27, 0x00, 0x00, 0x00, 
				 0x8C, 0x00, 0x00, 0x00, 0x2A, 0x00, 0x00, 0x00, 
				 0x8B, 0x00, 0x00, 0x00, 0x0B, 0x00, 0x00, 0x00, 
				 0x3E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0xC0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0xE1, 0x00, 0x00, 0x00, 
				 0x83, 0x00, 0x00, 0x00, 0xDF, 0x00, 0x00, 0x00, 
				 0x50, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0xDF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0xE3, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 
				 0x1D, 0x06, 0x00, 0x64, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x80, 0x00, 0x00, 0x00, 0x22, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x17, 0x24, 0x00, 
				 0x40, 0x00, 0x00, 0x00, 0x13, 0xEA, 0x00, 0x1E, 
				 0x00, 0xFF, 0xC0, 0x00, 0x00, 0x1E, 0x01, 0x00, 
				 0x03, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 0xEA, 
				 0x00, 0x13, 0xEA, 0x00, 0x1E, 0x00, 0x00, 0xC0, 
				 0x00, 0x00, 0x1E, 0x01, 0x11, 0x0A, 0x00, 0x00, 
				 0x1F, 0x01, 0x00, 0x19, 0xEA, 0x00, 0x12, 0x07, 
				 0x04, 0x1E, 0x00, 0xC0, 0x00, 0x00, 0x00, 0x1E, 
				 0x01, 0x0A, 0x00, 0x00, 0x00, 0x18, 0x07, 0x04, 
				 0x13, 0xC4, 0x02, 0x1E, 0x00, 0x3F, 0xC0, 0x00, 
				 0x00, 0x1E, 0x01, 0x80, 0x0A, 0x00, 0x00, 0x1F, 
				 0x01, 0x00, 0x19, 0xC4, 0x02, 0x16, 0x02, 0x04, 
				 0x00, 0x20, 0x13, 0xC0, 0x00, 0x1E, 0x01, 0x00, 
				 0x16, 0x00, 0x00, 0x19, 0xC0, 0x00, 0x17, 0x4C, 
				 0x00, 0xA0, 0x00, 0x00, 0x00, 0x13, 0xEA, 0x00, 
				 0x1E, 0x00, 0xFF, 0xC0, 0x00, 0x00, 0x1E, 0x01, 
				 0x00, 0x05, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 
				 0xEA, 0x00, 0x13, 0xC0, 0x00, 0x1E, 0x00, 0x00, 
				 0xC0, 0x00, 0x00, 0x1E, 0x01, 0x00, 0x14, 0x00, 
				 0x00, 0x19, 0xC0, 0x00, 0x13, 0xEA, 0x00, 0x1E, 
				 0x00, 0xFF, 0xC0, 0x00, 0x00, 0x1E, 0x01, 0x00, 
				 0x05, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 0xEA, 
				 0x00, 0x00, 0x00};

BYTE t5465_Mode_320x480x16_2[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x16, 0x05, 0x04, 0x00, 0x00, 0x16, 0xC0, 0x00, 
				 0x00, 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 
				 0x00, 0x1F, 0x01, 0x00, 0x18, 0xC5, 0x02, 0x18, 
				 0x07, 0x04, 0x15, 0xA0, 0x00, 0xFF, 0x00, 0x09, 
				 0xCE, 0x03, 0x06, 0x05, 0x09, 0xCE, 0x03, 0x09, 
				 0x00, 0x09, 0xCE, 0x03, 0x0A, 0x00, 0x09, 0xCE, 
				 0x03, 0x0B, 0x00, 0x16, 0x80, 0x00, 0xEF, 0x00, 
				 0x16, 0x84, 0x00, 0x0A, 0x00, 0x16, 0x88, 0x00, 
				 0x16, 0x00, 0x16, 0xC0, 0x00, 0x00, 0x80, 0x1D, 
				 0x19, 0x00, 0x00, 0x00, 0x2F, 0x00, 0x00, 0x00, 
				 0x27, 0x00, 0x00, 0x00, 0x27, 0x00, 0x00, 0x00, 
				 0x8C, 0x00, 0x00, 0x00, 0x2A, 0x00, 0x00, 0x00, 
				 0x8B, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 
				 0x3E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0xC0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0xE0, 0x00, 0x00, 0x00, 
				 0x83, 0x00, 0x00, 0x00, 0xDF, 0x00, 0x00, 0x00, 
				 0x50, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0xDF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0xE3, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 
				 0x1D, 0x06, 0x00, 0x64, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x80, 0x00, 0x00, 0x00, 0x22, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x17, 0x24, 0x00, 
				 0x40, 0x00, 0x00, 0x00, 0x13, 0xEA, 0x00, 0x1E, 
				 0x00, 0xFF, 0xC0, 0x00, 0x00, 0x1E, 0x01, 0x00, 
				 0x03, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 0xEA, 
				 0x00, 0x13, 0xEA, 0x00, 0x1E, 0x00, 0x00, 0xC0, 
				 0x00, 0x00, 0x1E, 0x01, 0x11, 0x0A, 0x00, 0x00, 
				 0x1F, 0x01, 0x00, 0x19, 0xEA, 0x00, 0x12, 0x07, 
				 0x04, 0x1E, 0x00, 0xC0, 0x00, 0x00, 0x00, 0x1E, 
				 0x01, 0x0A, 0x00, 0x00, 0x00, 0x18, 0x07, 0x04, 
				 0x13, 0xC4, 0x02, 0x1E, 0x00, 0x3F, 0xC0, 0x00, 
				 0x00, 0x1E, 0x01, 0x80, 0x0A, 0x00, 0x00, 0x1F, 
				 0x01, 0x00, 0x19, 0xC4, 0x02, 0x16, 0x02, 0x04, 
				 0x00, 0x20, 0x13, 0xC0, 0x00, 0x1E, 0x01, 0x00, 
				 0x16, 0x00, 0x00, 0x19, 0xC0, 0x00, 0x17, 0x4C, 
				 0x00, 0xA0, 0x00, 0x00, 0x00, 0x13, 0xEA, 0x00, 
				 0x1E, 0x00, 0xFF, 0xC0, 0x00, 0x00, 0x1E, 0x01, 
				 0x00, 0x05, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 
				 0xEA, 0x00, 0x13, 0xC0, 0x00, 0x1E, 0x00, 0x00, 
				 0xC0, 0x00, 0x00, 0x1E, 0x01, 0x00, 0x14, 0x00, 
				 0x00, 0x19, 0xC0, 0x00, 0x13, 0xEA, 0x00, 0x1E, 
				 0x00, 0xFF, 0xC0, 0x00, 0x00, 0x1E, 0x01, 0x00, 
				 0x05, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 0xEA, 
				 0x00, 0x00, 0x00};

BYTE t5465_Mode_360x400x16_1[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x16, 0x05, 0x04, 0x00, 0x00, 0x16, 0xC0, 0x00, 
				 0x00, 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 
				 0x00, 0x1F, 0x01, 0x00, 0x18, 0xC5, 0x02, 0x18, 
				 0x07, 0x04, 0x15, 0xA0, 0x00, 0xFF, 0x00, 0x09, 
				 0xCE, 0x03, 0x06, 0x05, 0x09, 0xCE, 0x03, 0x09, 
				 0x00, 0x09, 0xCE, 0x03, 0x0A, 0x00, 0x09, 0xCE, 
				 0x03, 0x0B, 0x00, 0x16, 0x80, 0x00, 0x2F, 0x00, 
				 0x16, 0x84, 0x00, 0x04, 0x00, 0x16, 0x88, 0x00, 
				 0x08, 0x00, 0x16, 0xC0, 0x00, 0x00, 0x80, 0x1D, 
				 0x19, 0x00, 0x00, 0x00, 0x34, 0x00, 0x00, 0x00, 
				 0x2C, 0x00, 0x00, 0x00, 0x2D, 0x00, 0x00, 0x00, 
				 0x94, 0x00, 0x00, 0x00, 0x2F, 0x00, 0x00, 0x00, 
				 0x92, 0x00, 0x00, 0x00, 0xA0, 0x00, 0x00, 0x00, 
				 0x1F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x91, 0x00, 0x00, 0x00, 
				 0x84, 0x00, 0x00, 0x00, 0x8F, 0x00, 0x00, 0x00, 
				 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x90, 0x00, 0x00, 0x00, 0xA0, 0x00, 0x00, 0x00, 
				 0xE3, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 
				 0x1D, 0x06, 0x00, 0x64, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x40, 0x00, 0x00, 0x00, 0x22, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x13, 0xEA, 0x00, 
				 0x1E, 0x00, 0x00, 0xC0, 0x00, 0x00, 0x1E, 0x01, 
				 0x11, 0x08, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 
				 0xEA, 0x00, 0x12, 0x07, 0x04, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x08, 0x00, 0x00, 
				 0x00, 0x18, 0x07, 0x04, 0x13, 0xC4, 0x02, 0x1E, 
				 0x00, 0x3F, 0xC0, 0x00, 0x00, 0x1E, 0x01, 0x80, 
				 0x08, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 0xC4, 
				 0x02, 0x16, 0x02, 0x04, 0x00, 0x20, 0x13, 0xC0, 
				 0x00, 0x1E, 0x01, 0x00, 0x16, 0x00, 0x00, 0x19, 
				 0xC0, 0x00, 0x17, 0x4C, 0x00, 0x80, 0x00, 0x00, 
				 0x00, 0x13, 0xEA, 0x00, 0x1E, 0x00, 0xFF, 0xC0, 
				 0x00, 0x00, 0x1E, 0x01, 0x00, 0x06, 0x00, 0x00, 
				 0x1F, 0x01, 0x00, 0x19, 0xEA, 0x00, 0x13, 0xC0, 
				 0x00, 0x1E, 0x00, 0x00, 0xC0, 0x00, 0x00, 0x1E, 
				 0x01, 0x00, 0x14, 0x00, 0x00, 0x19, 0xC0, 0x00, 
				 0x13, 0xEA, 0x00, 0x1E, 0x00, 0xFF, 0xC0, 0x00, 
				 0x00, 0x1E, 0x01, 0x00, 0x06, 0x00, 0x00, 0x1F, 
				 0x01, 0x00, 0x19, 0xEA, 0x00, 0x00, 0x14};

BYTE t5465_Mode_360x400x16_2[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x16, 0x05, 0x04, 0x00, 0x00, 0x16, 0xC0, 0x00, 
				 0x00, 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 
				 0x00, 0x1F, 0x01, 0x00, 0x18, 0xC5, 0x02, 0x18, 
				 0x07, 0x04, 0x15, 0xA0, 0x00, 0xFF, 0x00, 0x09, 
				 0xCE, 0x03, 0x06, 0x05, 0x09, 0xCE, 0x03, 0x09, 
				 0x00, 0x09, 0xCE, 0x03, 0x0A, 0x00, 0x09, 0xCE, 
				 0x03, 0x0B, 0x00, 0x16, 0x80, 0x00, 0x6F, 0x00, 
				 0x16, 0x84, 0x00, 0x32, 0x00, 0x16, 0x88, 0x00, 
				 0x7C, 0x00, 0x16, 0xC0, 0x00, 0x00, 0x80, 0x1D, 
				 0x19, 0x00, 0x00, 0x00, 0x35, 0x00, 0x00, 0x00, 
				 0x2C, 0x00, 0x00, 0x00, 0x2C, 0x00, 0x00, 0x00, 
				 0x93, 0x00, 0x00, 0x00, 0x2F, 0x00, 0x00, 0x00, 
				 0x90, 0x00, 0x00, 0x00, 0xBC, 0x00, 0x00, 0x00, 
				 0x1F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x90, 0x00, 0x00, 0x00, 
				 0x83, 0x00, 0x00, 0x00, 0x8F, 0x00, 0x00, 0x00, 
				 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x8F, 0x00, 0x00, 0x00, 0xBC, 0x00, 0x00, 0x00, 
				 0xE3, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 
				 0x1D, 0x06, 0x00, 0x64, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x40, 0x00, 0x00, 0x00, 0x22, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x13, 0xEA, 0x00, 
				 0x1E, 0x00, 0x00, 0xC0, 0x00, 0x00, 0x1E, 0x01, 
				 0x11, 0x08, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 
				 0xEA, 0x00, 0x12, 0x07, 0x04, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x08, 0x00, 0x00, 
				 0x00, 0x18, 0x07, 0x04, 0x13, 0xC4, 0x02, 0x1E, 
				 0x00, 0x3F, 0xC0, 0x00, 0x00, 0x1E, 0x01, 0x80, 
				 0x08, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 0xC4, 
				 0x02, 0x16, 0x02, 0x04, 0x00, 0x20, 0x13, 0xC0, 
				 0x00, 0x1E, 0x01, 0x00, 0x16, 0x00, 0x00, 0x19, 
				 0xC0, 0x00, 0x17, 0x4C, 0x00, 0x80, 0x00, 0x00, 
				 0x00, 0x13, 0xEA, 0x00, 0x1E, 0x00, 0xFF, 0xC0, 
				 0x00, 0x00, 0x1E, 0x01, 0x00, 0x06, 0x00, 0x00, 
				 0x1F, 0x01, 0x00, 0x19, 0xEA, 0x00, 0x13, 0xC0, 
				 0x00, 0x1E, 0x00, 0x00, 0xC0, 0x00, 0x00, 0x1E, 
				 0x01, 0x00, 0x14, 0x00, 0x00, 0x19, 0xC0, 0x00, 
				 0x13, 0xEA, 0x00, 0x1E, 0x00, 0xFF, 0xC0, 0x00, 
				 0x00, 0x1E, 0x01, 0x00, 0x06, 0x00, 0x00, 0x1F, 
				 0x01, 0x00, 0x19, 0xEA, 0x00, 0x00, 0x14};

BYTE t5465_Mode_400x300x16_1[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x16, 0x05, 0x04, 0x00, 0x00, 0x16, 0xC0, 0x00, 
				 0x00, 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 
				 0x00, 0x1F, 0x01, 0x00, 0x18, 0xC5, 0x02, 0x18, 
				 0x07, 0x04, 0x15, 0xA0, 0x00, 0xFF, 0x00, 0x09, 
				 0xCE, 0x03, 0x06, 0x05, 0x09, 0xCE, 0x03, 0x09, 
				 0x00, 0x09, 0xCE, 0x03, 0x0A, 0x00, 0x09, 0xCE, 
				 0x03, 0x0B, 0x00, 0x16, 0x80, 0x00, 0x2F, 0x00, 
				 0x16, 0x84, 0x00, 0x18, 0x00, 0x16, 0x88, 0x00, 
				 0x43, 0x00, 0x16, 0xC0, 0x00, 0x00, 0x80, 0x1D, 
				 0x19, 0x00, 0x00, 0x00, 0x3D, 0x00, 0x00, 0x00, 
				 0x31, 0x00, 0x00, 0x00, 0x31, 0x00, 0x00, 0x00, 
				 0x99, 0x00, 0x00, 0x00, 0x35, 0x00, 0x00, 0x00, 
				 0x96, 0x00, 0x00, 0x00, 0x72, 0x00, 0x00, 0x00, 
				 0xF0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0xE0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x58, 0x00, 0x00, 0x00, 
				 0x8C, 0x00, 0x00, 0x00, 0x57, 0x00, 0x00, 0x00, 
				 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x57, 0x00, 0x00, 0x00, 0x72, 0x00, 0x00, 0x00, 
				 0xE3, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 
				 0x1D, 0x06, 0x00, 0x64, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x80, 0x00, 0x00, 0x00, 0x22, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x13, 0xEA, 0x00, 
				 0x1E, 0x00, 0x00, 0xC0, 0x00, 0x00, 0x1E, 0x01, 
				 0x11, 0x08, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 
				 0xEA, 0x00, 0x12, 0x07, 0x04, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x08, 0x00, 0x00, 
				 0x00, 0x18, 0x07, 0x04, 0x13, 0xC4, 0x02, 0x1E, 
				 0x00, 0x3F, 0xC0, 0x00, 0x00, 0x1E, 0x01, 0x80, 
				 0x08, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 0xC4, 
				 0x02, 0x16, 0x02, 0x04, 0x00, 0x20, 0x13, 0xC0, 
				 0x00, 0x1E, 0x01, 0x00, 0x16, 0x00, 0x00, 0x19, 
				 0xC0, 0x00, 0x17, 0x4C, 0x00, 0x80, 0x00, 0x00, 
				 0x00, 0x13, 0xEA, 0x00, 0x1E, 0x00, 0xFF, 0xC0, 
				 0x00, 0x00, 0x1E, 0x01, 0x00, 0x07, 0x00, 0x00, 
				 0x1F, 0x01, 0x00, 0x19, 0xEA, 0x00, 0x13, 0xC0, 
				 0x00, 0x1E, 0x00, 0x00, 0xC0, 0x00, 0x00, 0x1E, 
				 0x01, 0x00, 0x14, 0x00, 0x00, 0x19, 0xC0, 0x00, 
				 0x13, 0xEA, 0x00, 0x1E, 0x00, 0xFF, 0xC0, 0x00, 
				 0x00, 0x1E, 0x01, 0x00, 0x07, 0x00, 0x00, 0x1F, 
				 0x01, 0x00, 0x19, 0xEA, 0x00, 0x00, 0x14};

BYTE t5465_Mode_400x300x16_2[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x16, 0x05, 0x04, 0x00, 0x00, 0x16, 0xC0, 0x00, 
				 0x00, 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 
				 0x00, 0x1F, 0x01, 0x00, 0x18, 0xC5, 0x02, 0x18, 
				 0x07, 0x04, 0x15, 0xA0, 0x00, 0xFF, 0x00, 0x09, 
				 0xCE, 0x03, 0x06, 0x05, 0x09, 0xCE, 0x03, 0x09, 
				 0x00, 0x09, 0xCE, 0x03, 0x0A, 0x00, 0x09, 0xCE, 
				 0x03, 0x0B, 0x00, 0x16, 0x80, 0x00, 0x2F, 0x00, 
				 0x16, 0x84, 0x00, 0x16, 0x00, 0x16, 0x88, 0x00, 
				 0x4C, 0x00, 0x16, 0xC0, 0x00, 0x00, 0x80, 0x1D, 
				 0x19, 0x00, 0x00, 0x00, 0x3D, 0x00, 0x00, 0x00, 
				 0x31, 0x00, 0x00, 0x00, 0x31, 0x00, 0x00, 0x00, 
				 0x99, 0x00, 0x00, 0x00, 0x34, 0x00, 0x00, 0x00, 
				 0x96, 0x00, 0x00, 0x00, 0x6F, 0x00, 0x00, 0x00, 
				 0xF0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0xE0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x58, 0x00, 0x00, 0x00, 
				 0x8B, 0x00, 0x00, 0x00, 0x57, 0x00, 0x00, 0x00, 
				 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x57, 0x00, 0x00, 0x00, 0x6F, 0x00, 0x00, 0x00, 
				 0xE3, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 
				 0x1D, 0x06, 0x00, 0x64, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x80, 0x00, 0x00, 0x00, 0x22, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x13, 0xEA, 0x00, 
				 0x1E, 0x00, 0x00, 0xC0, 0x00, 0x00, 0x1E, 0x01, 
				 0x11, 0x08, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 
				 0xEA, 0x00, 0x12, 0x07, 0x04, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x08, 0x00, 0x00, 
				 0x00, 0x18, 0x07, 0x04, 0x13, 0xC4, 0x02, 0x1E, 
				 0x00, 0x3F, 0xC0, 0x00, 0x00, 0x1E, 0x01, 0x80, 
				 0x08, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 0xC4, 
				 0x02, 0x13, 0xEA, 0x00, 0x1E, 0x00, 0xC0, 0xFF, 
				 0x00, 0x00, 0x1E, 0x01, 0x12, 0x00, 0x00, 0x00, 
				 0x1F, 0x01, 0x00, 0x19, 0xEA, 0x00, 0x16, 0x02, 
				 0x04, 0x00, 0x20, 0x13, 0xC0, 0x00, 0x1E, 0x01, 
				 0x00, 0x16, 0x00, 0x00, 0x19, 0xC0, 0x00, 0x17, 
				 0x4C, 0x00, 0x80, 0x00, 0x00, 0x00, 0x13, 0xEA, 
				 0x00, 0x1E, 0x00, 0xFF, 0xC0, 0x00, 0x00, 0x1E, 
				 0x01, 0x00, 0x07, 0x00, 0x00, 0x1F, 0x01, 0x00, 
				 0x19, 0xEA, 0x00, 0x13, 0xC0, 0x00, 0x1E, 0x00, 
				 0x00, 0xC0, 0x00, 0x00, 0x1E, 0x01, 0x00, 0x14, 
				 0x00, 0x00, 0x19, 0xC0, 0x00, 0x13, 0xEA, 0x00, 
				 0x1E, 0x00, 0xFF, 0xC0, 0x00, 0x00, 0x1E, 0x01, 
				 0x00, 0x07, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 
				 0xEA, 0x00, 0x00, 0x1F};

BYTE t5465_Mode_512x384x16_1[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x16, 0x05, 0x04, 0x00, 0x00, 0x16, 0xC0, 0x00, 
				 0x00, 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 
				 0x00, 0x1F, 0x01, 0x00, 0x18, 0xC5, 0x02, 0x18, 
				 0x07, 0x04, 0x15, 0xA0, 0x00, 0xFF, 0x00, 0x09, 
				 0xCE, 0x03, 0x06, 0x05, 0x09, 0xCE, 0x03, 0x09, 
				 0x00, 0x09, 0xCE, 0x03, 0x0A, 0x00, 0x09, 0xCE, 
				 0x03, 0x0B, 0x00, 0x16, 0x80, 0x00, 0xEF, 0x00, 
				 0x16, 0x84, 0x00, 0x31, 0x00, 0x16, 0x88, 0x00, 
				 0x6D, 0x00, 0x1D, 0x19, 0x00, 0x00, 0x00, 0x4F, 
				 0x00, 0x00, 0x00, 0x3F, 0x00, 0x00, 0x00, 0x3F, 
				 0x00, 0x00, 0x00, 0x89, 0x00, 0x00, 0x00, 0x42, 
				 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x24, 
				 0x00, 0x00, 0x00, 0xF5, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0xE0, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 
				 0x00, 0x00, 0x00, 0x88, 0x00, 0x00, 0x00, 0xFF, 
				 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 0x24, 
				 0x00, 0x00, 0x00, 0xE3, 0x00, 0x00, 0x00, 0xFF, 
				 0x00, 0x00, 0x00, 0x1D, 0x06, 0x00, 0x64, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0xD0, 0x00, 0x00, 0x00, 
				 0x22, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x13, 0xEA, 0x00, 0x1E, 0x00, 0x00, 0xC0, 0x00, 
				 0x00, 0x1E, 0x01, 0x11, 0x08, 0x00, 0x00, 0x1F, 
				 0x01, 0x00, 0x19, 0xEA, 0x00, 0x12, 0x07, 0x04, 
				 0x1E, 0x00, 0xC0, 0x00, 0x00, 0x00, 0x1E, 0x01, 
				 0x08, 0x00, 0x00, 0x00, 0x18, 0x07, 0x04, 0x13, 
				 0xC4, 0x02, 0x1E, 0x00, 0x3F, 0xC0, 0x00, 0x00, 
				 0x1E, 0x01, 0x80, 0x08, 0x00, 0x00, 0x1F, 0x01, 
				 0x00, 0x19, 0xC4, 0x02, 0x13, 0xEA, 0x00, 0x1E, 
				 0x00, 0xC0, 0xFF, 0x00, 0x00, 0x1E, 0x01, 0x12, 
				 0x00, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 0xEA, 
				 0x00, 0x16, 0x02, 0x04, 0x00, 0x20, 0x13, 0xC0, 
				 0x00, 0x1E, 0x01, 0x00, 0x16, 0x00, 0x00, 0x19, 
				 0xC0, 0x00, 0x17, 0x4C, 0x00, 0x80, 0x00, 0x00, 
				 0x00, 0x13, 0xEA, 0x00, 0x1E, 0x00, 0xFF, 0xC0, 
				 0x00, 0x00, 0x1E, 0x01, 0x00, 0x08, 0x00, 0x00, 
				 0x1F, 0x01, 0x00, 0x19, 0xEA, 0x00, 0x13, 0xC0, 
				 0x00, 0x1E, 0x00, 0x00, 0xC0, 0x00, 0x00, 0x1E, 
				 0x01, 0x00, 0x14, 0x00, 0x00, 0x19, 0xC0, 0x00, 
				 0x13, 0xEA, 0x00, 0x1E, 0x00, 0xFF, 0xC0, 0x00, 
				 0x00, 0x1E, 0x01, 0x00, 0x08, 0x00, 0x00, 0x1F, 
				 0x01, 0x00, 0x19, 0xEA, 0x00, 0x00, 0x00};

BYTE t5465_Mode_512x384x16_2[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x16, 0x05, 0x04, 0x00, 0x00, 0x16, 0xC0, 0x00, 
				 0x00, 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 
				 0x00, 0x1F, 0x01, 0x00, 0x18, 0xC5, 0x02, 0x18, 
				 0x07, 0x04, 0x15, 0xA0, 0x00, 0xFF, 0x00, 0x09, 
				 0xCE, 0x03, 0x06, 0x05, 0x09, 0xCE, 0x03, 0x09, 
				 0x00, 0x09, 0xCE, 0x03, 0x0A, 0x00, 0x09, 0xCE, 
				 0x03, 0x0B, 0x00, 0x16, 0x80, 0x00, 0xEF, 0x00, 
				 0x16, 0x84, 0x00, 0x2B, 0x00, 0x16, 0x88, 0x00, 
				 0x6E, 0x00, 0x1D, 0x19, 0x00, 0x00, 0x00, 0x4E, 
				 0x00, 0x00, 0x00, 0x3F, 0x00, 0x00, 0x00, 0x3F, 
				 0x00, 0x00, 0x00, 0x88, 0x00, 0x00, 0x00, 0x42, 
				 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x24, 
				 0x00, 0x00, 0x00, 0xF5, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0xE0, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 
				 0x00, 0x00, 0x00, 0x88, 0x00, 0x00, 0x00, 0xFF, 
				 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 0x23, 
				 0x00, 0x00, 0x00, 0xE3, 0x00, 0x00, 0x00, 0xFF, 
				 0x00, 0x00, 0x00, 0x1D, 0x06, 0x00, 0x64, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0xD0, 0x00, 0x00, 0x00, 
				 0x22, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x13, 0xEA, 0x00, 0x1E, 0x00, 0x00, 0xC0, 0x00, 
				 0x00, 0x1E, 0x01, 0x11, 0x08, 0x00, 0x00, 0x1F, 
				 0x01, 0x00, 0x19, 0xEA, 0x00, 0x12, 0x07, 0x04, 
				 0x1E, 0x00, 0xC0, 0x00, 0x00, 0x00, 0x1E, 0x01, 
				 0x08, 0x00, 0x00, 0x00, 0x18, 0x07, 0x04, 0x13, 
				 0xC4, 0x02, 0x1E, 0x00, 0x3F, 0xC0, 0x00, 0x00, 
				 0x1E, 0x01, 0x80, 0x08, 0x00, 0x00, 0x1F, 0x01, 
				 0x00, 0x19, 0xC4, 0x02, 0x13, 0xEA, 0x00, 0x1E, 
				 0x00, 0xC0, 0xFF, 0x00, 0x00, 0x1E, 0x01, 0x12, 
				 0x00, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 0xEA, 
				 0x00, 0x16, 0x02, 0x04, 0x00, 0x20, 0x13, 0xC0, 
				 0x00, 0x1E, 0x01, 0x00, 0x16, 0x00, 0x00, 0x19, 
				 0xC0, 0x00, 0x17, 0x4C, 0x00, 0x80, 0x00, 0x00, 
				 0x00, 0x13, 0xEA, 0x00, 0x1E, 0x00, 0xFF, 0xC0, 
				 0x00, 0x00, 0x1E, 0x01, 0x00, 0x08, 0x00, 0x00, 
				 0x1F, 0x01, 0x00, 0x19, 0xEA, 0x00, 0x13, 0xC0, 
				 0x00, 0x1E, 0x00, 0x00, 0xC0, 0x00, 0x00, 0x1E, 
				 0x01, 0x00, 0x14, 0x00, 0x00, 0x19, 0xC0, 0x00, 
				 0x13, 0xEA, 0x00, 0x1E, 0x00, 0xFF, 0xC0, 0x00, 
				 0x00, 0x1E, 0x01, 0x00, 0x08, 0x00, 0x00, 0x1F, 
				 0x01, 0x00, 0x19, 0xEA, 0x00, 0x00, 0x00};

BYTE t5465_Mode_512x480x16_1[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x16, 0x05, 0x04, 0x00, 0x00, 0x16, 0xC0, 0x00, 
				 0x00, 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 
				 0x00, 0x1F, 0x01, 0x00, 0x18, 0xC5, 0x02, 0x18, 
				 0x07, 0x04, 0x15, 0xA0, 0x00, 0xFF, 0x00, 0x09, 
				 0xCE, 0x03, 0x06, 0x05, 0x09, 0xCE, 0x03, 0x09, 
				 0x00, 0x09, 0xCE, 0x03, 0x0A, 0x00, 0x09, 0xCE, 
				 0x03, 0x0B, 0x00, 0x16, 0x80, 0x00, 0x2F, 0x00, 
				 0x16, 0x84, 0x00, 0x10, 0x00, 0x16, 0x88, 0x00, 
				 0x2D, 0x00, 0x16, 0xC0, 0x00, 0x00, 0x80, 0x1D, 
				 0x19, 0x00, 0x00, 0x00, 0x4B, 0x00, 0x00, 0x00, 
				 0x3F, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 
				 0x4B, 0x00, 0x00, 0x00, 0x44, 0x00, 0x00, 0x00, 
				 0x08, 0x00, 0x00, 0x00, 0xF0, 0x00, 0x00, 0x00, 
				 0x1F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0xE1, 0x00, 0x00, 0x00, 
				 0x84, 0x00, 0x00, 0x00, 0xDF, 0x00, 0x00, 0x00, 
				 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0xE0, 0x00, 0x00, 0x00, 0xF0, 0x00, 0x00, 0x00, 
				 0xE3, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 
				 0x1D, 0x06, 0x00, 0x64, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x50, 0x00, 0x00, 0x00, 0x22, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x13, 0xEA, 0x00, 
				 0x1E, 0x00, 0x00, 0xC0, 0x00, 0x00, 0x1E, 0x01, 
				 0x11, 0x08, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 
				 0xEA, 0x00, 0x12, 0x07, 0x04, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x08, 0x00, 0x00, 
				 0x00, 0x18, 0x07, 0x04, 0x13, 0xC4, 0x02, 0x1E, 
				 0x00, 0x3F, 0xC0, 0x00, 0x00, 0x1E, 0x01, 0x80, 
				 0x08, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 0xC4, 
				 0x02, 0x13, 0xEA, 0x00, 0x1E, 0x00, 0xC0, 0xFF, 
				 0x00, 0x00, 0x1E, 0x01, 0x12, 0x00, 0x00, 0x00, 
				 0x1F, 0x01, 0x00, 0x19, 0xEA, 0x00, 0x16, 0x02, 
				 0x04, 0x00, 0x20, 0x13, 0xC0, 0x00, 0x1E, 0x01, 
				 0x00, 0x16, 0x00, 0x00, 0x19, 0xC0, 0x00, 0x17, 
				 0x4C, 0x00, 0x80, 0x00, 0x00, 0x00, 0x13, 0xEA, 
				 0x00, 0x1E, 0x00, 0xFF, 0xC0, 0x00, 0x00, 0x1E, 
				 0x01, 0x00, 0x08, 0x00, 0x00, 0x1F, 0x01, 0x00, 
				 0x19, 0xEA, 0x00, 0x13, 0xC0, 0x00, 0x1E, 0x00, 
				 0x00, 0xC0, 0x00, 0x00, 0x1E, 0x01, 0x00, 0x14, 
				 0x00, 0x00, 0x19, 0xC0, 0x00, 0x13, 0xEA, 0x00, 
				 0x1E, 0x00, 0xFF, 0xC0, 0x00, 0x00, 0x1E, 0x01, 
				 0x00, 0x08, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 
				 0xEA, 0x00, 0x00, 0x1F};

BYTE t5465_Mode_512x480x16_2[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x16, 0x05, 0x04, 0x00, 0x00, 0x16, 0xC0, 0x00, 
				 0x00, 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 
				 0x00, 0x1F, 0x01, 0x00, 0x18, 0xC5, 0x02, 0x18, 
				 0x07, 0x04, 0x15, 0xA0, 0x00, 0xFF, 0x00, 0x09, 
				 0xCE, 0x03, 0x06, 0x05, 0x09, 0xCE, 0x03, 0x09, 
				 0x00, 0x09, 0xCE, 0x03, 0x0A, 0x00, 0x09, 0xCE, 
				 0x03, 0x0B, 0x00, 0x16, 0x80, 0x00, 0x2F, 0x00, 
				 0x16, 0x84, 0x00, 0x12, 0x00, 0x16, 0x88, 0x00, 
				 0x3E, 0x00, 0x16, 0xC0, 0x00, 0x00, 0x80, 0x1D, 
				 0x19, 0x00, 0x00, 0x00, 0x4D, 0x00, 0x00, 0x00, 
				 0x3F, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 
				 0x8D, 0x00, 0x00, 0x00, 0x44, 0x00, 0x00, 0x00, 
				 0x09, 0x00, 0x00, 0x00, 0xF4, 0x00, 0x00, 0x00, 
				 0x1F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0xE1, 0x00, 0x00, 0x00, 
				 0x84, 0x00, 0x00, 0x00, 0xDF, 0x00, 0x00, 0x00, 
				 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0xE0, 0x00, 0x00, 0x00, 0xF4, 0x00, 0x00, 0x00, 
				 0xE3, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 
				 0x1D, 0x06, 0x00, 0x64, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x50, 0x00, 0x00, 0x00, 0x22, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x13, 0xEA, 0x00, 
				 0x1E, 0x00, 0x00, 0xC0, 0x00, 0x00, 0x1E, 0x01, 
				 0x11, 0x08, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 
				 0xEA, 0x00, 0x12, 0x07, 0x04, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x08, 0x00, 0x00, 
				 0x00, 0x18, 0x07, 0x04, 0x13, 0xC4, 0x02, 0x1E, 
				 0x00, 0x3F, 0xC0, 0x00, 0x00, 0x1E, 0x01, 0x80, 
				 0x08, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 0xC4, 
				 0x02, 0x13, 0xEA, 0x00, 0x1E, 0x00, 0xC0, 0xFF, 
				 0x00, 0x00, 0x1E, 0x01, 0x12, 0x00, 0x00, 0x00, 
				 0x1F, 0x01, 0x00, 0x19, 0xEA, 0x00, 0x16, 0x02, 
				 0x04, 0x00, 0x20, 0x13, 0xC0, 0x00, 0x1E, 0x01, 
				 0x00, 0x16, 0x00, 0x00, 0x19, 0xC0, 0x00, 0x17, 
				 0x4C, 0x00, 0x80, 0x00, 0x00, 0x00, 0x13, 0xEA, 
				 0x00, 0x1E, 0x00, 0xFF, 0xC0, 0x00, 0x00, 0x1E, 
				 0x01, 0x00, 0x08, 0x00, 0x00, 0x1F, 0x01, 0x00, 
				 0x19, 0xEA, 0x00, 0x13, 0xC0, 0x00, 0x1E, 0x00, 
				 0x00, 0xC0, 0x00, 0x00, 0x1E, 0x01, 0x00, 0x14, 
				 0x00, 0x00, 0x19, 0xC0, 0x00, 0x13, 0xEA, 0x00, 
				 0x1E, 0x00, 0xFF, 0xC0, 0x00, 0x00, 0x1E, 0x01, 
				 0x00, 0x08, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 
				 0xEA, 0x00, 0x00, 0x1F};

BYTE t5465_Mode_640x350x16_1[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x16, 0x05, 0x04, 0x00, 0x00, 0x16, 0xC0, 0x00, 
				 0x00, 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 
				 0x00, 0x1F, 0x01, 0x00, 0x18, 0xC5, 0x02, 0x18, 
				 0x07, 0x04, 0x15, 0xA0, 0x00, 0xFF, 0x00, 0x09, 
				 0xCE, 0x03, 0x06, 0x05, 0x09, 0xCE, 0x03, 0x09, 
				 0x00, 0x09, 0xCE, 0x03, 0x0A, 0x00, 0x09, 0xCE, 
				 0x03, 0x0B, 0x00, 0x16, 0x80, 0x00, 0xAF, 0x00, 
				 0x16, 0x84, 0x00, 0x3B, 0x00, 0x16, 0x88, 0x00, 
				 0x69, 0x00, 0x1D, 0x19, 0x00, 0x00, 0x00, 0x63, 
				 0x00, 0x00, 0x00, 0x4F, 0x00, 0x00, 0x00, 0x4F, 
				 0x00, 0x00, 0x00, 0x83, 0x00, 0x00, 0x00, 0x53, 
				 0x00, 0x00, 0x00, 0x97, 0x00, 0x00, 0x00, 0xBB, 
				 0x00, 0x00, 0x00, 0x1F, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7D, 
				 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x5D, 
				 0x00, 0x00, 0x00, 0xA0, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x5D, 0x00, 0x00, 0x00, 0xBB, 
				 0x00, 0x00, 0x00, 0xE3, 0x00, 0x00, 0x00, 0xFF, 
				 0x00, 0x00, 0x00, 0x1D, 0x06, 0x00, 0x64, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x50, 0x00, 0x00, 0x00, 
				 0x22, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x13, 0xEA, 0x00, 0x1E, 0x00, 0x00, 0xC0, 0x00, 
				 0x00, 0x1E, 0x01, 0x11, 0x0A, 0x00, 0x00, 0x1F, 
				 0x01, 0x00, 0x19, 0xEA, 0x00, 0x12, 0x07, 0x04, 
				 0x1E, 0x00, 0xC0, 0x00, 0x00, 0x00, 0x1E, 0x01, 
				 0x0A, 0x00, 0x00, 0x00, 0x18, 0x07, 0x04, 0x13, 
				 0xC4, 0x02, 0x1E, 0x00, 0x3F, 0xC0, 0x00, 0x00, 
				 0x1E, 0x01, 0x80, 0x0A, 0x00, 0x00, 0x1F, 0x01, 
				 0x00, 0x19, 0xC4, 0x02, 0x13, 0xEA, 0x00, 0x1E, 
				 0x00, 0xC0, 0xFF, 0x00, 0x00, 0x1E, 0x01, 0x12, 
				 0x00, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 0xEA, 
				 0x00, 0x16, 0x02, 0x04, 0x00, 0x20, 0x13, 0xC0, 
				 0x00, 0x1E, 0x01, 0x00, 0x16, 0x00, 0x00, 0x19, 
				 0xC0, 0x00, 0x17, 0x4C, 0x00, 0xA0, 0x00, 0x00, 
				 0x00, 0x13, 0xEA, 0x00, 0x1E, 0x00, 0xFF, 0xC0, 
				 0x00, 0x00, 0x1E, 0x01, 0x00, 0x0A, 0x00, 0x00, 
				 0x1F, 0x01, 0x00, 0x19, 0xEA, 0x00, 0x13, 0xC0, 
				 0x00, 0x1E, 0x00, 0x00, 0xC0, 0x00, 0x00, 0x1E, 
				 0x01, 0x00, 0x14, 0x00, 0x00, 0x19, 0xC0, 0x00, 
				 0x13, 0xEA, 0x00, 0x1E, 0x00, 0xFF, 0xC0, 0x00, 
				 0x00, 0x1E, 0x01, 0x00, 0x0A, 0x00, 0x00, 0x1F, 
				 0x01, 0x00, 0x19, 0xEA, 0x00, 0x00, 0x00};

BYTE t5465_Mode_640x350x16_2[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x16, 0x05, 0x04, 0x00, 0x00, 0x16, 0xC0, 0x00, 
				 0x00, 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 
				 0x00, 0x1F, 0x01, 0x00, 0x18, 0xC5, 0x02, 0x18, 
				 0x07, 0x04, 0x15, 0xA0, 0x00, 0xFF, 0x00, 0x09, 
				 0xCE, 0x03, 0x06, 0x05, 0x09, 0xCE, 0x03, 0x09, 
				 0x00, 0x09, 0xCE, 0x03, 0x0A, 0x00, 0x09, 0xCE, 
				 0x03, 0x0B, 0x00, 0x16, 0x80, 0x00, 0xAF, 0x00, 
				 0x16, 0x84, 0x00, 0x0B, 0x00, 0x16, 0x88, 0x00, 
				 0x16, 0x00, 0x1D, 0x19, 0x00, 0x00, 0x00, 0x63, 
				 0x00, 0x00, 0x00, 0x4F, 0x00, 0x00, 0x00, 0x4F, 
				 0x00, 0x00, 0x00, 0x83, 0x00, 0x00, 0x00, 0x55, 
				 0x00, 0x00, 0x00, 0x99, 0x00, 0x00, 0x00, 0xBB, 
				 0x00, 0x00, 0x00, 0x1F, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7D, 
				 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x5D, 
				 0x00, 0x00, 0x00, 0xA0, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x5D, 0x00, 0x00, 0x00, 0xBB, 
				 0x00, 0x00, 0x00, 0xE3, 0x00, 0x00, 0x00, 0xFF, 
				 0x00, 0x00, 0x00, 0x1D, 0x06, 0x00, 0x64, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x50, 0x00, 0x00, 0x00, 
				 0x22, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x13, 0xEA, 0x00, 0x1E, 0x00, 0x00, 0xC0, 0x00, 
				 0x00, 0x1E, 0x01, 0x11, 0x0A, 0x00, 0x00, 0x1F, 
				 0x01, 0x00, 0x19, 0xEA, 0x00, 0x12, 0x07, 0x04, 
				 0x1E, 0x00, 0xC0, 0x00, 0x00, 0x00, 0x1E, 0x01, 
				 0x0A, 0x00, 0x00, 0x00, 0x18, 0x07, 0x04, 0x13, 
				 0xC4, 0x02, 0x1E, 0x00, 0x3F, 0xC0, 0x00, 0x00, 
				 0x1E, 0x01, 0x80, 0x0A, 0x00, 0x00, 0x1F, 0x01, 
				 0x00, 0x19, 0xC4, 0x02, 0x13, 0xEA, 0x00, 0x1E, 
				 0x00, 0xC0, 0xFF, 0x00, 0x00, 0x1E, 0x01, 0x12, 
				 0x00, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 0xEA, 
				 0x00, 0x16, 0x02, 0x04, 0x00, 0x20, 0x13, 0xC0, 
				 0x00, 0x1E, 0x01, 0x00, 0x16, 0x00, 0x00, 0x19, 
				 0xC0, 0x00, 0x17, 0x4C, 0x00, 0xA0, 0x00, 0x00, 
				 0x00, 0x13, 0xEA, 0x00, 0x1E, 0x00, 0xFF, 0xC0, 
				 0x00, 0x00, 0x1E, 0x01, 0x00, 0x0A, 0x00, 0x00, 
				 0x1F, 0x01, 0x00, 0x19, 0xEA, 0x00, 0x13, 0xC0, 
				 0x00, 0x1E, 0x00, 0x00, 0xC0, 0x00, 0x00, 0x1E, 
				 0x01, 0x00, 0x14, 0x00, 0x00, 0x19, 0xC0, 0x00, 
				 0x13, 0xEA, 0x00, 0x1E, 0x00, 0xFF, 0xC0, 0x00, 
				 0x00, 0x1E, 0x01, 0x00, 0x0A, 0x00, 0x00, 0x1F, 
				 0x01, 0x00, 0x19, 0xEA, 0x00, 0x00, 0x00};

BYTE t5465_Mode_640x400x16_1[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x16, 0x05, 0x04, 0x00, 0x00, 0x16, 0xC0, 0x00, 
				 0x00, 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 
				 0x00, 0x1F, 0x01, 0x00, 0x18, 0xC5, 0x02, 0x18, 
				 0x07, 0x04, 0x15, 0xA0, 0x00, 0xFF, 0x00, 0x09, 
				 0xCE, 0x03, 0x06, 0x05, 0x09, 0xCE, 0x03, 0x09, 
				 0x00, 0x09, 0xCE, 0x03, 0x0A, 0x00, 0x09, 0xCE, 
				 0x03, 0x0B, 0x00, 0x16, 0x80, 0x00, 0x6F, 0x00, 
				 0x16, 0x84, 0x00, 0x3F, 0x00, 0x16, 0x88, 0x00, 
				 0x6D, 0x00, 0x1D, 0x19, 0x00, 0x00, 0x00, 0x5F, 
				 0x00, 0x00, 0x00, 0x4F, 0x00, 0x00, 0x00, 0x50, 
				 0x00, 0x00, 0x00, 0x82, 0x00, 0x00, 0x00, 0x53, 
				 0x00, 0x00, 0x00, 0x9F, 0x00, 0x00, 0x00, 0xBF, 
				 0x00, 0x00, 0x00, 0x1F, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xA1, 
				 0x00, 0x00, 0x00, 0xA3, 0x00, 0x00, 0x00, 0x8F, 
				 0x00, 0x00, 0x00, 0x50, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x96, 0x00, 0x00, 0x00, 0xB9, 
				 0x00, 0x00, 0x00, 0xE3, 0x00, 0x00, 0x00, 0xFF, 
				 0x00, 0x00, 0x00, 0x1D, 0x06, 0x00, 0x64, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x50, 0x00, 0x00, 0x00, 
				 0x22, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x13, 0xEA, 0x00, 0x1E, 0x00, 0x00, 0xC0, 0x00, 
				 0x00, 0x1E, 0x01, 0x11, 0x0A, 0x00, 0x00, 0x1F, 
				 0x01, 0x00, 0x19, 0xEA, 0x00, 0x12, 0x07, 0x04, 
				 0x1E, 0x00, 0xC0, 0x00, 0x00, 0x00, 0x1E, 0x01, 
				 0x0A, 0x00, 0x00, 0x00, 0x18, 0x07, 0x04, 0x13, 
				 0xC4, 0x02, 0x1E, 0x00, 0x3F, 0xC0, 0x00, 0x00, 
				 0x1E, 0x01, 0x80, 0x0A, 0x00, 0x00, 0x1F, 0x01, 
				 0x00, 0x19, 0xC4, 0x02, 0x13, 0xEA, 0x00, 0x1E, 
				 0x00, 0xC0, 0xFF, 0x00, 0x00, 0x1E, 0x01, 0x12, 
				 0x00, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 0xEA, 
				 0x00, 0x16, 0x02, 0x04, 0x00, 0x20, 0x13, 0xC0, 
				 0x00, 0x1E, 0x01, 0x00, 0x16, 0x00, 0x00, 0x19, 
				 0xC0, 0x00, 0x17, 0x4C, 0x00, 0xA0, 0x00, 0x00, 
				 0x00, 0x13, 0xEA, 0x00, 0x1E, 0x00, 0xFF, 0xC0, 
				 0x00, 0x00, 0x1E, 0x01, 0x00, 0x0A, 0x00, 0x00, 
				 0x1F, 0x01, 0x00, 0x19, 0xEA, 0x00, 0x13, 0xC0, 
				 0x00, 0x1E, 0x00, 0x00, 0xC0, 0x00, 0x00, 0x1E, 
				 0x01, 0x00, 0x14, 0x00, 0x00, 0x19, 0xC0, 0x00, 
				 0x13, 0xEA, 0x00, 0x1E, 0x00, 0xFF, 0xC0, 0x00, 
				 0x00, 0x1E, 0x01, 0x00, 0x0A, 0x00, 0x00, 0x1F, 
				 0x01, 0x00, 0x19, 0xEA, 0x00, 0x00, 0x00};

BYTE t5465_Mode_640x400x16_2[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x16, 0x05, 0x04, 0x00, 0x00, 0x16, 0xC0, 0x00, 
				 0x00, 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 
				 0x00, 0x1F, 0x01, 0x00, 0x18, 0xC5, 0x02, 0x18, 
				 0x07, 0x04, 0x15, 0xA0, 0x00, 0xFF, 0x00, 0x09, 
				 0xCE, 0x03, 0x06, 0x05, 0x09, 0xCE, 0x03, 0x09, 
				 0x00, 0x09, 0xCE, 0x03, 0x0A, 0x00, 0x09, 0xCE, 
				 0x03, 0x0B, 0x00, 0x16, 0x80, 0x00, 0x6F, 0x00, 
				 0x16, 0x84, 0x00, 0x0B, 0x00, 0x16, 0x88, 0x00, 
				 0x16, 0x00, 0x1D, 0x19, 0x00, 0x00, 0x00, 0x63, 
				 0x00, 0x00, 0x00, 0x4F, 0x00, 0x00, 0x00, 0x4F, 
				 0x00, 0x00, 0x00, 0x83, 0x00, 0x00, 0x00, 0x55, 
				 0x00, 0x00, 0x00, 0x99, 0x00, 0x00, 0x00, 0xBB, 
				 0x00, 0x00, 0x00, 0x1F, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x90, 
				 0x00, 0x00, 0x00, 0x83, 0x00, 0x00, 0x00, 0x8F, 
				 0x00, 0x00, 0x00, 0x50, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x8F, 0x00, 0x00, 0x00, 0xBB, 
				 0x00, 0x00, 0x00, 0xE3, 0x00, 0x00, 0x00, 0xFF, 
				 0x00, 0x00, 0x00, 0x1D, 0x06, 0x00, 0x64, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x50, 0x00, 0x00, 0x00, 
				 0x22, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x13, 0xEA, 0x00, 0x1E, 0x00, 0x00, 0xC0, 0x00, 
				 0x00, 0x1E, 0x01, 0x11, 0x0A, 0x00, 0x00, 0x1F, 
				 0x01, 0x00, 0x19, 0xEA, 0x00, 0x12, 0x07, 0x04, 
				 0x1E, 0x00, 0xC0, 0x00, 0x00, 0x00, 0x1E, 0x01, 
				 0x0A, 0x00, 0x00, 0x00, 0x18, 0x07, 0x04, 0x13, 
				 0xC4, 0x02, 0x1E, 0x00, 0x3F, 0xC0, 0x00, 0x00, 
				 0x1E, 0x01, 0x80, 0x0A, 0x00, 0x00, 0x1F, 0x01, 
				 0x00, 0x19, 0xC4, 0x02, 0x13, 0xEA, 0x00, 0x1E, 
				 0x00, 0xC0, 0xFF, 0x00, 0x00, 0x1E, 0x01, 0x12, 
				 0x00, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 0xEA, 
				 0x00, 0x16, 0x02, 0x04, 0x00, 0x20, 0x13, 0xC0, 
				 0x00, 0x1E, 0x01, 0x00, 0x16, 0x00, 0x00, 0x19, 
				 0xC0, 0x00, 0x17, 0x4C, 0x00, 0xA0, 0x00, 0x00, 
				 0x00, 0x13, 0xEA, 0x00, 0x1E, 0x00, 0xFF, 0xC0, 
				 0x00, 0x00, 0x1E, 0x01, 0x00, 0x0A, 0x00, 0x00, 
				 0x1F, 0x01, 0x00, 0x19, 0xEA, 0x00, 0x13, 0xC0, 
				 0x00, 0x1E, 0x00, 0x00, 0xC0, 0x00, 0x00, 0x1E, 
				 0x01, 0x00, 0x14, 0x00, 0x00, 0x19, 0xC0, 0x00, 
				 0x13, 0xEA, 0x00, 0x1E, 0x00, 0xFF, 0xC0, 0x00, 
				 0x00, 0x1E, 0x01, 0x00, 0x0A, 0x00, 0x00, 0x1F, 
				 0x01, 0x00, 0x19, 0xEA, 0x00, 0x00, 0x00};

BYTE t5465_Mode_640x400x16_3[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x16, 0x05, 0x04, 0x00, 0x00, 0x16, 0xC0, 0x00, 
				 0x00, 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 
				 0x00, 0x1F, 0x01, 0x00, 0x18, 0xC5, 0x02, 0x18, 
				 0x07, 0x04, 0x15, 0xA0, 0x00, 0xFF, 0x00, 0x09, 
				 0xCE, 0x03, 0x06, 0x05, 0x09, 0xCE, 0x03, 0x09, 
				 0x00, 0x09, 0xCE, 0x03, 0x0A, 0x00, 0x09, 0xCE, 
				 0x03, 0x0B, 0x00, 0x16, 0x80, 0x00, 0x6F, 0x00, 
				 0x16, 0x84, 0x00, 0x0B, 0x00, 0x16, 0x88, 0x00, 
				 0x16, 0x00, 0x1D, 0x19, 0x00, 0x00, 0x00, 0x63, 
				 0x00, 0x00, 0x00, 0x4F, 0x00, 0x00, 0x00, 0x4F, 
				 0x00, 0x00, 0x00, 0x83, 0x00, 0x00, 0x00, 0x55, 
				 0x00, 0x00, 0x00, 0x99, 0x00, 0x00, 0x00, 0xBB, 
				 0x00, 0x00, 0x00, 0x1F, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x90, 
				 0x00, 0x00, 0x00, 0x83, 0x00, 0x00, 0x00, 0x8F, 
				 0x00, 0x00, 0x00, 0x50, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x8F, 0x00, 0x00, 0x00, 0xBB, 
				 0x00, 0x00, 0x00, 0xE3, 0x00, 0x00, 0x00, 0xFF, 
				 0x00, 0x00, 0x00, 0x1D, 0x06, 0x00, 0x64, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x50, 0x00, 0x00, 0x00, 
				 0x22, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x16, 0x84, 0x00, 0x32, 0x00, 0x16, 0x88, 0x00, 
				 0x61, 0x00, 0x13, 0xEA, 0x00, 0x1E, 0x00, 0x00, 
				 0xC0, 0x00, 0x00, 0x1E, 0x01, 0x11, 0x0A, 0x00, 
				 0x00, 0x1F, 0x01, 0x00, 0x19, 0xEA, 0x00, 0x12, 
				 0x07, 0x04, 0x1E, 0x00, 0xC0, 0x00, 0x00, 0x00, 
				 0x1E, 0x01, 0x0A, 0x00, 0x00, 0x00, 0x18, 0x07, 
				 0x04, 0x13, 0xC4, 0x02, 0x1E, 0x00, 0x3F, 0xC0, 
				 0x00, 0x00, 0x1E, 0x01, 0x80, 0x0A, 0x00, 0x00, 
				 0x1F, 0x01, 0x00, 0x19, 0xC4, 0x02, 0x13, 0xEA, 
				 0x00, 0x1E, 0x00, 0xC0, 0xFF, 0x00, 0x00, 0x1E, 
				 0x01, 0x12, 0x00, 0x00, 0x00, 0x1F, 0x01, 0x00, 
				 0x19, 0xEA, 0x00, 0x16, 0x02, 0x04, 0x00, 0x20, 
				 0x13, 0xC0, 0x00, 0x1E, 0x01, 0x00, 0x16, 0x00, 
				 0x00, 0x19, 0xC0, 0x00, 0x17, 0x4C, 0x00, 0xA0, 
				 0x00, 0x00, 0x00, 0x13, 0xEA, 0x00, 0x1E, 0x00, 
				 0xFF, 0xC0, 0x00, 0x00, 0x1E, 0x01, 0x00, 0x0A, 
				 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 0xEA, 0x00, 
				 0x13, 0xC0, 0x00, 0x1E, 0x00, 0x00, 0xC0, 0x00, 
				 0x00, 0x1E, 0x01, 0x00, 0x14, 0x00, 0x00, 0x19, 
				 0xC0, 0x00, 0x13, 0xEA, 0x00, 0x1E, 0x00, 0xFF, 
				 0xC0, 0x00, 0x00, 0x1E, 0x01, 0x00, 0x0A, 0x00, 
				 0x00, 0x1F, 0x01, 0x00, 0x19, 0xEA, 0x00, 0x00, 0x00};

BYTE t5465_Mode_640x480x16_1[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x16, 0x05, 0x04, 0x00, 0x00, 0x16, 0xC0, 0x00, 
				 0x00, 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 
				 0x00, 0x1F, 0x01, 0x00, 0x18, 0xC5, 0x02, 0x18, 
				 0x07, 0x04, 0x15, 0xA0, 0x00, 0xFF, 0x00, 0x09, 
				 0xCE, 0x03, 0x06, 0x05, 0x09, 0xCE, 0x03, 0x09, 
				 0x00, 0x09, 0xCE, 0x03, 0x0A, 0x00, 0x09, 0xCE, 
				 0x03, 0x0B, 0x00, 0x16, 0x80, 0x00, 0xEF, 0x00, 
				 0x16, 0x84, 0x00, 0x3F, 0x00, 0x16, 0x88, 0x00, 
				 0x6D, 0x00, 0x1D, 0x19, 0x00, 0x00, 0x00, 0x5F, 
				 0x00, 0x00, 0x00, 0x4F, 0x00, 0x00, 0x00, 0x50, 
				 0x00, 0x00, 0x00, 0x9F, 0x00, 0x00, 0x00, 0x54, 
				 0x00, 0x00, 0x00, 0x1F, 0x00, 0x00, 0x00, 0x0B, 
				 0x00, 0x00, 0x00, 0x3E, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xE9, 
				 0x00, 0x00, 0x00, 0x8B, 0x00, 0x00, 0x00, 0xDF, 
				 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0xE7, 0x00, 0x00, 0x00, 0x04, 
				 0x00, 0x00, 0x00, 0xE3, 0x00, 0x00, 0x00, 0xFF, 
				 0x00, 0x00, 0x00, 0x1D, 0x06, 0x00, 0x64, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x90, 0x00, 0x00, 0x00, 
				 0x22, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x13, 0xEA, 0x00, 0x1E, 0x00, 0x00, 0xC0, 0x00, 
				 0x00, 0x1E, 0x01, 0x11, 0x0A, 0x00, 0x00, 0x1F, 
				 0x01, 0x00, 0x19, 0xEA, 0x00, 0x12, 0x07, 0x04, 
				 0x1E, 0x00, 0xC0, 0x00, 0x00, 0x00, 0x1E, 0x01, 
				 0x0A, 0x00, 0x00, 0x00, 0x18, 0x07, 0x04, 0x13, 
				 0xC4, 0x02, 0x1E, 0x00, 0x3F, 0xC0, 0x00, 0x00, 
				 0x1E, 0x01, 0x80, 0x0A, 0x00, 0x00, 0x1F, 0x01, 
				 0x00, 0x19, 0xC4, 0x02, 0x13, 0xEA, 0x00, 0x1E, 
				 0x00, 0xC0, 0xFF, 0x00, 0x00, 0x1E, 0x01, 0x12, 
				 0x00, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 0xEA, 
				 0x00, 0x16, 0x02, 0x04, 0x00, 0x20, 0x13, 0xC0, 
				 0x00, 0x1E, 0x01, 0x00, 0x16, 0x00, 0x00, 0x19, 
				 0xC0, 0x00, 0x17, 0x4C, 0x00, 0xA0, 0x00, 0x00, 
				 0x00, 0x13, 0xEA, 0x00, 0x1E, 0x00, 0xFF, 0xC0, 
				 0x00, 0x00, 0x1E, 0x01, 0x00, 0x0A, 0x00, 0x00, 
				 0x1F, 0x01, 0x00, 0x19, 0xEA, 0x00, 0x13, 0xC0, 
				 0x00, 0x1E, 0x00, 0x00, 0xC0, 0x00, 0x00, 0x1E, 
				 0x01, 0x00, 0x14, 0x00, 0x00, 0x19, 0xC0, 0x00, 
				 0x13, 0xEA, 0x00, 0x1E, 0x00, 0xFF, 0xC0, 0x00, 
				 0x00, 0x1E, 0x01, 0x00, 0x0A, 0x00, 0x00, 0x1F, 
				 0x01, 0x00, 0x19, 0xEA, 0x00, 0x00, 0x0A};

BYTE t5465_Mode_640x480x16_2[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x16, 0x05, 0x04, 0x00, 0x00, 0x16, 0xC0, 0x00, 
				 0x00, 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 
				 0x00, 0x1F, 0x01, 0x00, 0x18, 0xC5, 0x02, 0x18, 
				 0x07, 0x04, 0x15, 0xA0, 0x00, 0xFF, 0x00, 0x09, 
				 0xCE, 0x03, 0x06, 0x05, 0x09, 0xCE, 0x03, 0x09, 
				 0x00, 0x09, 0xCE, 0x03, 0x0A, 0x00, 0x09, 0xCE, 
				 0x03, 0x0B, 0x00, 0x16, 0x80, 0x00, 0xEF, 0x00, 
				 0x16, 0x84, 0x00, 0x0B, 0x00, 0x16, 0x88, 0x00, 
				 0x16, 0x00, 0x1D, 0x19, 0x00, 0x00, 0x00, 0x63, 
				 0x00, 0x00, 0x00, 0x4F, 0x00, 0x00, 0x00, 0x50, 
				 0x00, 0x00, 0x00, 0x82, 0x00, 0x00, 0x00, 0x54, 
				 0x00, 0x00, 0x00, 0x99, 0x00, 0x00, 0x00, 0x06, 
				 0x00, 0x00, 0x00, 0x3E, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xE8, 
				 0x00, 0x00, 0x00, 0x8B, 0x00, 0x00, 0x00, 0xDF, 
				 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0xE7, 0x00, 0x00, 0x00, 0xF3, 
				 0x00, 0x00, 0x00, 0xE3, 0x00, 0x00, 0x00, 0xFF, 
				 0x00, 0x00, 0x00, 0x1D, 0x06, 0x00, 0x64, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x50, 0x00, 0x00, 0x00, 
				 0x22, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x13, 0xEA, 0x00, 0x1E, 0x00, 0x00, 0xC0, 0x00, 
				 0x00, 0x1E, 0x01, 0x11, 0x0A, 0x00, 0x00, 0x1F, 
				 0x01, 0x00, 0x19, 0xEA, 0x00, 0x12, 0x07, 0x04, 
				 0x1E, 0x00, 0xC0, 0x00, 0x00, 0x00, 0x1E, 0x01, 
				 0x0A, 0x00, 0x00, 0x00, 0x18, 0x07, 0x04, 0x13, 
				 0xC4, 0x02, 0x1E, 0x00, 0x3F, 0xC0, 0x00, 0x00, 
				 0x1E, 0x01, 0x80, 0x0A, 0x00, 0x00, 0x1F, 0x01, 
				 0x00, 0x19, 0xC4, 0x02, 0x13, 0xEA, 0x00, 0x1E, 
				 0x00, 0xC0, 0xFF, 0x00, 0x00, 0x1E, 0x01, 0x12, 
				 0x00, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 0xEA, 
				 0x00, 0x16, 0x02, 0x04, 0x00, 0x20, 0x13, 0xC0, 
				 0x00, 0x1E, 0x01, 0x00, 0x16, 0x00, 0x00, 0x19, 
				 0xC0, 0x00, 0x17, 0x4C, 0x00, 0xA0, 0x00, 0x00, 
				 0x00, 0x13, 0xEA, 0x00, 0x1E, 0x00, 0xFF, 0xC0, 
				 0x00, 0x00, 0x1E, 0x01, 0x00, 0x0A, 0x00, 0x00, 
				 0x1F, 0x01, 0x00, 0x19, 0xEA, 0x00, 0x13, 0xC0, 
				 0x00, 0x1E, 0x00, 0x00, 0xC0, 0x00, 0x00, 0x1E, 
				 0x01, 0x00, 0x14, 0x00, 0x00, 0x19, 0xC0, 0x00, 
				 0x13, 0xEA, 0x00, 0x1E, 0x00, 0xFF, 0xC0, 0x00, 
				 0x00, 0x1E, 0x01, 0x00, 0x0A, 0x00, 0x00, 0x1F, 
				 0x01, 0x00, 0x19, 0xEA, 0x00, 0x00, 0x0A};

BYTE t5465_Mode_640x480x16_3[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x16, 0x05, 0x04, 0x00, 0x00, 0x16, 0xC0, 0x00, 
				 0x00, 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 
				 0x00, 0x1F, 0x01, 0x00, 0x18, 0xC5, 0x02, 0x18, 
				 0x07, 0x04, 0x15, 0xA0, 0x00, 0xFF, 0x00, 0x09, 
				 0xCE, 0x03, 0x06, 0x05, 0x09, 0xCE, 0x03, 0x09, 
				 0x00, 0x09, 0xCE, 0x03, 0x0A, 0x00, 0x09, 0xCE, 
				 0x03, 0x0B, 0x00, 0x16, 0x80, 0x00, 0xEF, 0x00, 
				 0x16, 0x84, 0x00, 0x0B, 0x00, 0x16, 0x88, 0x00, 
				 0x16, 0x00, 0x1D, 0x19, 0x00, 0x00, 0x00, 0x64, 
				 0x00, 0x00, 0x00, 0x4F, 0x00, 0x00, 0x00, 0x50, 
				 0x00, 0x00, 0x00, 0x82, 0x00, 0x00, 0x00, 0x54, 
				 0x00, 0x00, 0x00, 0x9B, 0x00, 0x00, 0x00, 0xF2, 
				 0x00, 0x00, 0x00, 0x1F, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xE0, 
				 0x00, 0x00, 0x00, 0x83, 0x00, 0x00, 0x00, 0xDF, 
				 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0xDF, 0x00, 0x00, 0x00, 0xF2, 
				 0x00, 0x00, 0x00, 0xE3, 0x00, 0x00, 0x00, 0xFF, 
				 0x00, 0x00, 0x00, 0x1D, 0x06, 0x00, 0x64, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x50, 0x00, 0x00, 0x00, 
				 0x22, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x13, 0xEA, 0x00, 0x1E, 0x00, 0x00, 0xC0, 0x00, 
				 0x00, 0x1E, 0x01, 0x11, 0x0A, 0x00, 0x00, 0x1F, 
				 0x01, 0x00, 0x19, 0xEA, 0x00, 0x12, 0x07, 0x04, 
				 0x1E, 0x00, 0xC0, 0x00, 0x00, 0x00, 0x1E, 0x01, 
				 0x0A, 0x00, 0x00, 0x00, 0x18, 0x07, 0x04, 0x13, 
				 0xC4, 0x02, 0x1E, 0x00, 0x3F, 0xC0, 0x00, 0x00, 
				 0x1E, 0x01, 0x80, 0x0A, 0x00, 0x00, 0x1F, 0x01, 
				 0x00, 0x19, 0xC4, 0x02, 0x13, 0xEA, 0x00, 0x1E, 
				 0x00, 0xC0, 0xFF, 0x00, 0x00, 0x1E, 0x01, 0x12, 
				 0x00, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 0xEA, 
				 0x00, 0x16, 0x02, 0x04, 0x00, 0x20, 0x13, 0xC0, 
				 0x00, 0x1E, 0x01, 0x00, 0x16, 0x00, 0x00, 0x19, 
				 0xC0, 0x00, 0x17, 0x4C, 0x00, 0xA0, 0x00, 0x00, 
				 0x00, 0x13, 0xEA, 0x00, 0x1E, 0x00, 0xFF, 0xC0, 
				 0x00, 0x00, 0x1E, 0x01, 0x00, 0x0A, 0x00, 0x00, 
				 0x1F, 0x01, 0x00, 0x19, 0xEA, 0x00, 0x13, 0xC0, 
				 0x00, 0x1E, 0x00, 0x00, 0xC0, 0x00, 0x00, 0x1E, 
				 0x01, 0x00, 0x14, 0x00, 0x00, 0x19, 0xC0, 0x00, 
				 0x13, 0xEA, 0x00, 0x1E, 0x00, 0xFF, 0xC0, 0x00, 
				 0x00, 0x1E, 0x01, 0x00, 0x0A, 0x00, 0x00, 0x1F, 
				 0x01, 0x00, 0x19, 0xEA, 0x00, 0x00, 0x0A};

BYTE t5465_Mode_640x480x16_4[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x16, 0x05, 0x04, 0x00, 0x00, 0x16, 0xC0, 0x00, 
				 0x00, 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 
				 0x00, 0x1F, 0x01, 0x00, 0x18, 0xC5, 0x02, 0x18, 
				 0x07, 0x04, 0x15, 0xA0, 0x00, 0xFF, 0x00, 0x09, 
				 0xCE, 0x03, 0x06, 0x05, 0x09, 0xCE, 0x03, 0x09, 
				 0x00, 0x09, 0xCE, 0x03, 0x0A, 0x00, 0x09, 0xCE, 
				 0x03, 0x0B, 0x00, 0x16, 0x80, 0x00, 0xEF, 0x00, 
				 0x16, 0x84, 0x00, 0x33, 0x00, 0x16, 0x88, 0x00, 
				 0x7E, 0x00, 0x1D, 0x19, 0x00, 0x00, 0x00, 0x63, 
				 0x00, 0x00, 0x00, 0x4F, 0x00, 0x00, 0x00, 0x50, 
				 0x00, 0x00, 0x00, 0x82, 0x00, 0x00, 0x00, 0x55, 
				 0x00, 0x00, 0x00, 0x9B, 0x00, 0x00, 0x00, 0xFB, 
				 0x00, 0x00, 0x00, 0x1F, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xE0, 
				 0x00, 0x00, 0x00, 0x83, 0x00, 0x00, 0x00, 0xDF, 
				 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0xDF, 0x00, 0x00, 0x00, 0xF9, 
				 0x00, 0x00, 0x00, 0xE3, 0x00, 0x00, 0x00, 0xFF, 
				 0x00, 0x00, 0x00, 0x1D, 0x06, 0x00, 0x64, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x50, 0x00, 0x00, 0x00, 
				 0x22, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x13, 0xEA, 0x00, 0x1E, 0x00, 0x00, 0xC0, 0x00, 
				 0x00, 0x1E, 0x01, 0x11, 0x0A, 0x00, 0x00, 0x1F, 
				 0x01, 0x00, 0x19, 0xEA, 0x00, 0x12, 0x07, 0x04, 
				 0x1E, 0x00, 0xC0, 0x00, 0x00, 0x00, 0x1E, 0x01, 
				 0x0A, 0x00, 0x00, 0x00, 0x18, 0x07, 0x04, 0x13, 
				 0xC4, 0x02, 0x1E, 0x00, 0x3F, 0xC0, 0x00, 0x00, 
				 0x1E, 0x01, 0x80, 0x0A, 0x00, 0x00, 0x1F, 0x01, 
				 0x00, 0x19, 0xC4, 0x02, 0x13, 0xEA, 0x00, 0x1E, 
				 0x00, 0xC0, 0xFF, 0x00, 0x00, 0x1E, 0x01, 0x12, 
				 0x00, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 0xEA, 
				 0x00, 0x16, 0x02, 0x04, 0x00, 0x20, 0x13, 0xC0, 
				 0x00, 0x1E, 0x01, 0x00, 0x16, 0x00, 0x00, 0x19, 
				 0xC0, 0x00, 0x17, 0x4C, 0x00, 0xA0, 0x00, 0x00, 
				 0x00, 0x13, 0xEA, 0x00, 0x1E, 0x00, 0xFF, 0xC0, 
				 0x00, 0x00, 0x1E, 0x01, 0x00, 0x0A, 0x00, 0x00, 
				 0x1F, 0x01, 0x00, 0x19, 0xEA, 0x00, 0x13, 0xC0, 
				 0x00, 0x1E, 0x00, 0x00, 0xC0, 0x00, 0x00, 0x1E, 
				 0x01, 0x00, 0x14, 0x00, 0x00, 0x19, 0xC0, 0x00, 
				 0x13, 0xEA, 0x00, 0x1E, 0x00, 0xFF, 0xC0, 0x00, 
				 0x00, 0x1E, 0x01, 0x00, 0x0A, 0x00, 0x00, 0x1F, 
				 0x01, 0x00, 0x19, 0xEA, 0x00, 0x00, 0x0A};

BYTE t5465_Mode_800x600x16_1[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x16, 0x05, 0x04, 0x00, 0x00, 0x16, 0xC0, 0x00, 
				 0x00, 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 
				 0x00, 0x1F, 0x01, 0x00, 0x18, 0xC5, 0x02, 0x18, 
				 0x07, 0x04, 0x15, 0xA0, 0x00, 0xFF, 0x00, 0x09, 
				 0xCE, 0x03, 0x06, 0x05, 0x09, 0xCE, 0x03, 0x09, 
				 0x00, 0x09, 0xCE, 0x03, 0x0A, 0x00, 0x09, 0xCE, 
				 0x03, 0x0B, 0x00, 0x16, 0x80, 0x00, 0x2F, 0x00, 
				 0x16, 0x84, 0x00, 0x33, 0x00, 0x16, 0x88, 0x00, 
				 0x7E, 0x00, 0x1D, 0x19, 0x00, 0x00, 0x00, 0x7B, 
				 0x00, 0x00, 0x00, 0x63, 0x00, 0x00, 0x00, 0x64, 
				 0x00, 0x00, 0x00, 0x9B, 0x00, 0x00, 0x00, 0x68, 
				 0x00, 0x00, 0x00, 0x91, 0x00, 0x00, 0x00, 0x6F, 
				 0x00, 0x00, 0x00, 0xF0, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x60, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x58, 
				 0x00, 0x00, 0x00, 0x8A, 0x00, 0x00, 0x00, 0x57, 
				 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x58, 0x00, 0x00, 0x00, 0x6F, 
				 0x00, 0x00, 0x00, 0xE3, 0x00, 0x00, 0x00, 0xFF, 
				 0x00, 0x00, 0x00, 0x1D, 0x06, 0x00, 0x64, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x90, 0x00, 0x00, 0x00, 
				 0x22, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x13, 0xEA, 0x00, 0x1E, 0x00, 0x00, 0xC0, 0x00, 
				 0x00, 0x1E, 0x01, 0x12, 0x0D, 0x00, 0x00, 0x1F, 
				 0x01, 0x00, 0x19, 0xEA, 0x00, 0x12, 0x07, 0x04, 
				 0x1E, 0x00, 0xC0, 0x00, 0x00, 0x00, 0x1E, 0x01, 
				 0x0D, 0x00, 0x00, 0x00, 0x18, 0x07, 0x04, 0x13, 
				 0xC4, 0x02, 0x1E, 0x00, 0x3F, 0xC0, 0x00, 0x00, 
				 0x1E, 0x01, 0x80, 0x0D, 0x00, 0x00, 0x1F, 0x01, 
				 0x00, 0x19, 0xC4, 0x02, 0x13, 0xEA, 0x00, 0x1E, 
				 0x00, 0xC0, 0xFF, 0x00, 0x00, 0x1E, 0x01, 0x13, 
				 0x00, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 0xEA, 
				 0x00, 0x16, 0x02, 0x04, 0x00, 0x20, 0x13, 0xC0, 
				 0x00, 0x1E, 0x01, 0x00, 0x16, 0x00, 0x00, 0x19, 
				 0xC0, 0x00, 0x17, 0x4C, 0x00, 0xD0, 0x00, 0x00, 
				 0x00, 0x13, 0xEA, 0x00, 0x1E, 0x00, 0xFF, 0xC0, 
				 0x00, 0x00, 0x1E, 0x01, 0x00, 0x0D, 0x00, 0x00, 
				 0x1F, 0x01, 0x00, 0x19, 0xEA, 0x00, 0x13, 0xC0, 
				 0x00, 0x1E, 0x00, 0x00, 0xC0, 0x00, 0x00, 0x1E, 
				 0x01, 0x00, 0x14, 0x00, 0x00, 0x19, 0xC0, 0x00, 
				 0x13, 0xEA, 0x00, 0x1E, 0x00, 0xFF, 0xC0, 0x00, 
				 0x00, 0x1E, 0x01, 0x00, 0x0D, 0x00, 0x00, 0x1F, 
				 0x01, 0x00, 0x19, 0xEA, 0x00, 0x00, 0x0A};

BYTE t5465_Mode_800x600x16_2[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x16, 0x05, 0x04, 0x00, 0x00, 0x16, 0xC0, 0x00, 
				 0x00, 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 
				 0x00, 0x1F, 0x01, 0x00, 0x18, 0xC5, 0x02, 0x18, 
				 0x07, 0x04, 0x15, 0xA0, 0x00, 0xFF, 0x00, 0x09, 
				 0xCE, 0x03, 0x06, 0x05, 0x09, 0xCE, 0x03, 0x09, 
				 0x00, 0x09, 0xCE, 0x03, 0x0A, 0x00, 0x09, 0xCE, 
				 0x03, 0x0B, 0x00, 0x16, 0x80, 0x00, 0x2F, 0x00, 
				 0x16, 0x84, 0x00, 0x23, 0x00, 0x16, 0x88, 0x00, 
				 0x5F, 0x00, 0x1D, 0x19, 0x00, 0x00, 0x00, 0x7F, 
				 0x00, 0x00, 0x00, 0x63, 0x00, 0x00, 0x00, 0x64, 
				 0x00, 0x00, 0x00, 0x9F, 0x00, 0x00, 0x00, 0x6A, 
				 0x00, 0x00, 0x00, 0x9A, 0x00, 0x00, 0x00, 0x72, 
				 0x00, 0x00, 0x00, 0xF0, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x60, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x58, 
				 0x00, 0x00, 0x00, 0x8C, 0x00, 0x00, 0x00, 0x57, 
				 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x58, 0x00, 0x00, 0x00, 0x70, 
				 0x00, 0x00, 0x00, 0xE3, 0x00, 0x00, 0x00, 0xFF, 
				 0x00, 0x00, 0x00, 0x1D, 0x06, 0x00, 0x64, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x90, 0x00, 0x00, 0x00, 
				 0x22, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x13, 0xEA, 0x00, 0x1E, 0x00, 0x00, 0xC0, 0x00, 
				 0x00, 0x1E, 0x01, 0x12, 0x0D, 0x00, 0x00, 0x1F, 
				 0x01, 0x00, 0x19, 0xEA, 0x00, 0x12, 0x07, 0x04, 
				 0x1E, 0x00, 0xC0, 0x00, 0x00, 0x00, 0x1E, 0x01, 
				 0x0D, 0x00, 0x00, 0x00, 0x18, 0x07, 0x04, 0x13, 
				 0xC4, 0x02, 0x1E, 0x00, 0x3F, 0xC0, 0x00, 0x00, 
				 0x1E, 0x01, 0x80, 0x0D, 0x00, 0x00, 0x1F, 0x01, 
				 0x00, 0x19, 0xC4, 0x02, 0x13, 0xEA, 0x00, 0x1E, 
				 0x00, 0xC0, 0xFF, 0x00, 0x00, 0x1E, 0x01, 0x13, 
				 0x00, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 0xEA, 
				 0x00, 0x16, 0x02, 0x04, 0x00, 0x20, 0x13, 0xC0, 
				 0x00, 0x1E, 0x01, 0x00, 0x16, 0x00, 0x00, 0x19, 
				 0xC0, 0x00, 0x17, 0x4C, 0x00, 0xD0, 0x00, 0x00, 
				 0x00, 0x13, 0xEA, 0x00, 0x1E, 0x00, 0xFF, 0xC0, 
				 0x00, 0x00, 0x1E, 0x01, 0x00, 0x0D, 0x00, 0x00, 
				 0x1F, 0x01, 0x00, 0x19, 0xEA, 0x00, 0x13, 0xC0, 
				 0x00, 0x1E, 0x00, 0x00, 0xC0, 0x00, 0x00, 0x1E, 
				 0x01, 0x00, 0x14, 0x00, 0x00, 0x19, 0xC0, 0x00, 
				 0x13, 0xEA, 0x00, 0x1E, 0x00, 0xFF, 0xC0, 0x00, 
				 0x00, 0x1E, 0x01, 0x00, 0x0D, 0x00, 0x00, 0x1F, 
				 0x01, 0x00, 0x19, 0xEA, 0x00, 0x00, 0x0A};

BYTE t5465_Mode_800x600x16_3[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x16, 0x05, 0x04, 0x00, 0x00, 0x16, 0xC0, 0x00, 
				 0x00, 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 
				 0x00, 0x1F, 0x01, 0x00, 0x18, 0xC5, 0x02, 0x18, 
				 0x07, 0x04, 0x15, 0xA0, 0x00, 0xFF, 0x00, 0x09, 
				 0xCE, 0x03, 0x06, 0x05, 0x09, 0xCE, 0x03, 0x09, 
				 0x00, 0x09, 0xCE, 0x03, 0x0A, 0x00, 0x09, 0xCE, 
				 0x03, 0x0B, 0x00, 0x16, 0x80, 0x00, 0x2F, 0x00, 
				 0x16, 0x84, 0x00, 0x25, 0x00, 0x16, 0x88, 0x00, 
				 0x7D, 0x00, 0x1D, 0x19, 0x00, 0x00, 0x00, 0x7D, 
				 0x00, 0x00, 0x00, 0x63, 0x00, 0x00, 0x00, 0x64, 
				 0x00, 0x00, 0x00, 0x9D, 0x00, 0x00, 0x00, 0x6C, 
				 0x00, 0x00, 0x00, 0x9B, 0x00, 0x00, 0x00, 0x97, 
				 0x00, 0x00, 0x00, 0xF0, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x60, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7C, 
				 0x00, 0x00, 0x00, 0x82, 0x00, 0x00, 0x00, 0x57, 
				 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x5F, 0x00, 0x00, 0x00, 0x97, 
				 0x00, 0x00, 0x00, 0xE3, 0x00, 0x00, 0x00, 0xFF, 
				 0x00, 0x00, 0x00, 0x1D, 0x06, 0x00, 0x64, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x90, 0x00, 0x00, 0x00, 
				 0x22, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x13, 0xEA, 0x00, 0x1E, 0x00, 0x00, 0xC0, 0x00, 
				 0x00, 0x1E, 0x01, 0x12, 0x0D, 0x00, 0x00, 0x1F, 
				 0x01, 0x00, 0x19, 0xEA, 0x00, 0x12, 0x07, 0x04, 
				 0x1E, 0x00, 0xC0, 0x00, 0x00, 0x00, 0x1E, 0x01, 
				 0x0D, 0x00, 0x00, 0x00, 0x18, 0x07, 0x04, 0x13, 
				 0xC4, 0x02, 0x1E, 0x00, 0x3F, 0xC0, 0x00, 0x00, 
				 0x1E, 0x01, 0x80, 0x0D, 0x00, 0x00, 0x1F, 0x01, 
				 0x00, 0x19, 0xC4, 0x02, 0x13, 0xEA, 0x00, 0x1E, 
				 0x00, 0xC0, 0xFF, 0x00, 0x00, 0x1E, 0x01, 0x13, 
				 0x00, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 0xEA, 
				 0x00, 0x16, 0x02, 0x04, 0x00, 0x20, 0x13, 0xC0, 
				 0x00, 0x1E, 0x01, 0x00, 0x16, 0x00, 0x00, 0x19, 
				 0xC0, 0x00, 0x17, 0x4C, 0x00, 0xD0, 0x00, 0x00, 
				 0x00, 0x13, 0xEA, 0x00, 0x1E, 0x00, 0xFF, 0xC0, 
				 0x00, 0x00, 0x1E, 0x01, 0x00, 0x0D, 0x00, 0x00, 
				 0x1F, 0x01, 0x00, 0x19, 0xEA, 0x00, 0x13, 0xC0, 
				 0x00, 0x1E, 0x00, 0x00, 0xC0, 0x00, 0x00, 0x1E, 
				 0x01, 0x00, 0x14, 0x00, 0x00, 0x19, 0xC0, 0x00, 
				 0x13, 0xEA, 0x00, 0x1E, 0x00, 0xFF, 0xC0, 0x00, 
				 0x00, 0x1E, 0x01, 0x00, 0x0D, 0x00, 0x00, 0x1F, 
				 0x01, 0x00, 0x19, 0xEA, 0x00, 0x00, 0x0A};

BYTE t5465_Mode_800x600x16_4[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x16, 0x05, 0x04, 0x00, 0x00, 0x16, 0xC0, 0x00, 
				 0x00, 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 
				 0x00, 0x1F, 0x01, 0x00, 0x18, 0xC5, 0x02, 0x18, 
				 0x07, 0x04, 0x15, 0xA0, 0x00, 0xFF, 0x00, 0x09, 
				 0xCE, 0x03, 0x06, 0x05, 0x09, 0xCE, 0x03, 0x09, 
				 0x00, 0x09, 0xCE, 0x03, 0x0A, 0x00, 0x09, 0xCE, 
				 0x03, 0x0B, 0x00, 0x16, 0x80, 0x00, 0x2F, 0x00, 
				 0x16, 0x84, 0x00, 0x19, 0x00, 0x16, 0x88, 0x00, 
				 0x53, 0x00, 0x1D, 0x19, 0x00, 0x00, 0x00, 0x7F, 
				 0x00, 0x00, 0x00, 0x63, 0x00, 0x00, 0x00, 0x64, 
				 0x00, 0x00, 0x00, 0x9F, 0x00, 0x00, 0x00, 0x67, 
				 0x00, 0x00, 0x00, 0x91, 0x00, 0x00, 0x00, 0x6F, 
				 0x00, 0x00, 0x00, 0xF0, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x60, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x58, 
				 0x00, 0x00, 0x00, 0x8B, 0x00, 0x00, 0x00, 0x57, 
				 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x57, 0x00, 0x00, 0x00, 0x6F, 
				 0x00, 0x00, 0x00, 0xE3, 0x00, 0x00, 0x00, 0xFF, 
				 0x00, 0x00, 0x00, 0x1D, 0x06, 0x00, 0x64, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x90, 0x00, 0x00, 0x00, 
				 0x22, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x13, 0xEA, 0x00, 0x1E, 0x00, 0x00, 0xC0, 0x00, 
				 0x00, 0x1E, 0x01, 0x12, 0x0D, 0x00, 0x00, 0x1F, 
				 0x01, 0x00, 0x19, 0xEA, 0x00, 0x12, 0x07, 0x04, 
				 0x1E, 0x00, 0xC0, 0x00, 0x00, 0x00, 0x1E, 0x01, 
				 0x0D, 0x00, 0x00, 0x00, 0x18, 0x07, 0x04, 0x13, 
				 0xC4, 0x02, 0x1E, 0x00, 0x3F, 0xC0, 0x00, 0x00, 
				 0x1E, 0x01, 0x80, 0x0D, 0x00, 0x00, 0x1F, 0x01, 
				 0x00, 0x19, 0xC4, 0x02, 0x13, 0xEA, 0x00, 0x1E, 
				 0x00, 0xC0, 0xFF, 0x00, 0x00, 0x1E, 0x01, 0x13, 
				 0x00, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 0xEA, 
				 0x00, 0x16, 0x02, 0x04, 0x00, 0x20, 0x13, 0xC0, 
				 0x00, 0x1E, 0x01, 0x00, 0x16, 0x00, 0x00, 0x19, 
				 0xC0, 0x00, 0x17, 0x4C, 0x00, 0xD0, 0x00, 0x00, 
				 0x00, 0x13, 0xEA, 0x00, 0x1E, 0x00, 0xFF, 0xC0, 
				 0x00, 0x00, 0x1E, 0x01, 0x00, 0x0D, 0x00, 0x00, 
				 0x1F, 0x01, 0x00, 0x19, 0xEA, 0x00, 0x13, 0xC0, 
				 0x00, 0x1E, 0x00, 0x00, 0xC0, 0x00, 0x00, 0x1E, 
				 0x01, 0x00, 0x14, 0x00, 0x00, 0x19, 0xC0, 0x00, 
				 0x13, 0xEA, 0x00, 0x1E, 0x00, 0xFF, 0xC0, 0x00, 
				 0x00, 0x1E, 0x01, 0x00, 0x0D, 0x00, 0x00, 0x1F, 
				 0x01, 0x00, 0x19, 0xEA, 0x00, 0x00, 0x0A};

BYTE t5465_Mode_800x600x16_5[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x16, 0x05, 0x04, 0x00, 0x00, 0x16, 0xC0, 0x00, 
				 0x00, 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 
				 0x00, 0x1F, 0x01, 0x00, 0x18, 0xC5, 0x02, 0x18, 
				 0x07, 0x04, 0x15, 0xA0, 0x00, 0xFF, 0x00, 0x09, 
				 0xCE, 0x03, 0x06, 0x05, 0x09, 0xCE, 0x03, 0x09, 
				 0x00, 0x09, 0xCE, 0x03, 0x0A, 0x00, 0x09, 0xCE, 
				 0x03, 0x0B, 0x00, 0x16, 0x80, 0x00, 0x2F, 0x00, 
				 0x16, 0x84, 0x00, 0x1C, 0x00, 0x16, 0x88, 0x00, 
				 0x37, 0x00, 0x1D, 0x19, 0x00, 0x00, 0x00, 0x7E, 
				 0x00, 0x00, 0x00, 0x63, 0x00, 0x00, 0x00, 0x64, 
				 0x00, 0x00, 0x00, 0x9E, 0x00, 0x00, 0x00, 0x69, 
				 0x00, 0x00, 0x00, 0x91, 0x00, 0x00, 0x00, 0x75, 
				 0x00, 0x00, 0x00, 0xF0, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x60, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x58, 
				 0x00, 0x00, 0x00, 0x8B, 0x00, 0x00, 0x00, 0x57, 
				 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x57, 0x00, 0x00, 0x00, 0x75, 
				 0x00, 0x00, 0x00, 0xE3, 0x00, 0x00, 0x00, 0xFF, 
				 0x00, 0x00, 0x00, 0x1D, 0x06, 0x00, 0x64, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x90, 0x00, 0x00, 0x00, 
				 0x22, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x13, 0xEA, 0x00, 0x1E, 0x00, 0x00, 0xC0, 0x00, 
				 0x00, 0x1E, 0x01, 0x12, 0x0D, 0x00, 0x00, 0x1F, 
				 0x01, 0x00, 0x19, 0xEA, 0x00, 0x12, 0x07, 0x04, 
				 0x1E, 0x00, 0xC0, 0x00, 0x00, 0x00, 0x1E, 0x01, 
				 0x0D, 0x00, 0x00, 0x00, 0x18, 0x07, 0x04, 0x13, 
				 0xC4, 0x02, 0x1E, 0x00, 0x3F, 0xC0, 0x00, 0x00, 
				 0x1E, 0x01, 0x80, 0x0D, 0x00, 0x00, 0x1F, 0x01, 
				 0x00, 0x19, 0xC4, 0x02, 0x13, 0xEA, 0x00, 0x1E, 
				 0x00, 0xC0, 0xFF, 0x00, 0x00, 0x1E, 0x01, 0x13, 
				 0x00, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 0xEA, 
				 0x00, 0x16, 0x02, 0x04, 0x00, 0x20, 0x13, 0xC0, 
				 0x00, 0x1E, 0x01, 0x00, 0x16, 0x00, 0x00, 0x19, 
				 0xC0, 0x00, 0x17, 0x4C, 0x00, 0xD0, 0x00, 0x00, 
				 0x00, 0x13, 0xEA, 0x00, 0x1E, 0x00, 0xFF, 0xC0, 
				 0x00, 0x00, 0x1E, 0x01, 0x00, 0x0D, 0x00, 0x00, 
				 0x1F, 0x01, 0x00, 0x19, 0xEA, 0x00, 0x13, 0xC0, 
				 0x00, 0x1E, 0x00, 0x00, 0xC0, 0x00, 0x00, 0x1E, 
				 0x01, 0x00, 0x14, 0x00, 0x00, 0x19, 0xC0, 0x00, 
				 0x13, 0xEA, 0x00, 0x1E, 0x00, 0xFF, 0xC0, 0x00, 
				 0x00, 0x1E, 0x01, 0x00, 0x0D, 0x00, 0x00, 0x1F, 
				 0x01, 0x00, 0x19, 0xEA, 0x00, 0x00, 0x0A};

BYTE t5465_Mode_1024x768x16_1[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x16, 0x05, 0x04, 0x00, 0x00, 0x16, 0xC0, 0x00, 
				 0x00, 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 
				 0x00, 0x1F, 0x01, 0x00, 0x18, 0xC5, 0x02, 0x18, 
				 0x07, 0x04, 0x15, 0xA0, 0x00, 0xFF, 0x00, 0x09, 
				 0xCE, 0x03, 0x06, 0x05, 0x09, 0xCE, 0x03, 0x09, 
				 0x00, 0x09, 0xCE, 0x03, 0x0A, 0x00, 0x09, 0xCE, 
				 0x03, 0x0B, 0x00, 0x16, 0x80, 0x00, 0x2F, 0x00, 
				 0x16, 0x84, 0x00, 0x17, 0x00, 0x16, 0x88, 0x00, 
				 0x45, 0x00, 0x1D, 0x19, 0x00, 0x00, 0x00, 0x99, 
				 0x00, 0x00, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x80, 
				 0x00, 0x00, 0x00, 0x99, 0x00, 0x00, 0x00, 0x82, 
				 0x00, 0x00, 0x00, 0x18, 0x00, 0x00, 0x00, 0x96, 
				 0x00, 0x00, 0x00, 0x1F, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7F, 
				 0x00, 0x00, 0x00, 0x83, 0x00, 0x00, 0x00, 0x7F, 
				 0x00, 0x00, 0x00, 0xA0, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x96, 
				 0x00, 0x00, 0x00, 0xE3, 0x00, 0x00, 0x00, 0xFF, 
				 0x00, 0x00, 0x00, 0x1D, 0x06, 0x00, 0x64, 0x00, 
				 0x48, 0x00, 0x00, 0x00, 0x51, 0x00, 0x00, 0x00, 
				 0x22, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x13, 0xEA, 0x00, 0x1E, 0x00, 0x00, 0xC0, 0x00, 
				 0x00, 0x1E, 0x01, 0x52, 0x10, 0x00, 0x00, 0x1F, 
				 0x01, 0x00, 0x19, 0xEA, 0x00, 0x12, 0x07, 0x04, 
				 0x1E, 0x00, 0xC0, 0x00, 0x00, 0x00, 0x1E, 0x01, 
				 0x08, 0x00, 0x00, 0x00, 0x18, 0x07, 0x04, 0x13, 
				 0xC4, 0x02, 0x1E, 0x00, 0x3F, 0xC0, 0x00, 0x00, 
				 0x1E, 0x01, 0xC0, 0x08, 0x00, 0x00, 0x1F, 0x01, 
				 0x00, 0x19, 0xC4, 0x02, 0x13, 0xEA, 0x00, 0x1E, 
				 0x00, 0xC0, 0xFF, 0x00, 0x00, 0x1E, 0x01, 0x19, 
				 0x00, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 0xEA, 
				 0x00, 0x16, 0x02, 0x04, 0x00, 0x28, 0x13, 0xC0, 
				 0x00, 0x1E, 0x01, 0x00, 0x16, 0x00, 0x00, 0x19, 
				 0xC0, 0x00, 0x17, 0x4C, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x17, 0x6C, 0x00, 0x32, 0x00, 0x00, 0x00, 
				 0x13, 0xEA, 0x00, 0x1E, 0x00, 0xFF, 0xC0, 0x00, 
				 0x00, 0x1E, 0x01, 0x00, 0x10, 0x00, 0x00, 0x1F, 
				 0x01, 0x00, 0x19, 0xEA, 0x00, 0x13, 0xC0, 0x00, 
				 0x1E, 0x00, 0x00, 0xC0, 0x00, 0x00, 0x1E, 0x01, 
				 0x00, 0x14, 0x00, 0x00, 0x19, 0xC0, 0x00, 0x13, 
				 0xEA, 0x00, 0x1E, 0x00, 0xFF, 0xC0, 0x00, 0x00, 
				 0x1E, 0x01, 0x00, 0x10, 0x00, 0x00, 0x1F, 0x01, 
				 0x00, 0x19, 0xEA, 0x00, 0x00, 0xEA};

BYTE t5465_Mode_1024x768x16_2[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x16, 0x05, 0x04, 0x00, 0x00, 0x16, 0xC0, 0x00, 
				 0x00, 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 
				 0x00, 0x1F, 0x01, 0x00, 0x18, 0xC5, 0x02, 0x18, 
				 0x07, 0x04, 0x15, 0xA0, 0x00, 0xFF, 0x00, 0x09, 
				 0xCE, 0x03, 0x06, 0x05, 0x09, 0xCE, 0x03, 0x09, 
				 0x00, 0x09, 0xCE, 0x03, 0x0A, 0x00, 0x09, 0xCE, 
				 0x03, 0x0B, 0x00, 0x16, 0x80, 0x00, 0xEF, 0x00, 
				 0x16, 0x84, 0x00, 0x1A, 0x00, 0x16, 0x88, 0x00, 
				 0x3B, 0x00, 0x1D, 0x19, 0x00, 0x00, 0x00, 0xA3, 
				 0x00, 0x00, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x80, 
				 0x00, 0x00, 0x00, 0x83, 0x00, 0x00, 0x00, 0x84, 
				 0x00, 0x00, 0x00, 0x95, 0x00, 0x00, 0x00, 0x24, 
				 0x00, 0x00, 0x00, 0xFD, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x60, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 
				 0x00, 0x00, 0x00, 0x88, 0x00, 0x00, 0x00, 0xFF, 
				 0x00, 0x00, 0x00, 0xA0, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x24, 
				 0x00, 0x00, 0x00, 0xE3, 0x00, 0x00, 0x00, 0xFF, 
				 0x00, 0x00, 0x00, 0x1D, 0x06, 0x00, 0x64, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0xE0, 0x00, 0x00, 0x00, 
				 0x22, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x13, 0xEA, 0x00, 0x1E, 0x00, 0x00, 0xC0, 0x00, 
				 0x00, 0x1E, 0x01, 0x52, 0x10, 0x00, 0x00, 0x1F, 
				 0x01, 0x00, 0x19, 0xEA, 0x00, 0x12, 0x07, 0x04, 
				 0x1E, 0x00, 0xC0, 0x00, 0x00, 0x00, 0x1E, 0x01, 
				 0x08, 0x00, 0x00, 0x00, 0x18, 0x07, 0x04, 0x13, 
				 0xC4, 0x02, 0x1E, 0x00, 0x3F, 0xC0, 0x00, 0x00, 
				 0x1E, 0x01, 0xC0, 0x08, 0x00, 0x00, 0x1F, 0x01, 
				 0x00, 0x19, 0xC4, 0x02, 0x13, 0xEA, 0x00, 0x1E, 
				 0x00, 0xC0, 0xFF, 0x00, 0x00, 0x1E, 0x01, 0x19, 
				 0x00, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 0xEA, 
				 0x00, 0x16, 0x02, 0x04, 0x00, 0x28, 0x13, 0xC0, 
				 0x00, 0x1E, 0x01, 0x00, 0x16, 0x00, 0x00, 0x19, 
				 0xC0, 0x00, 0x17, 0x4C, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x17, 0x6C, 0x00, 0x32, 0x00, 0x00, 0x00, 
				 0x13, 0xEA, 0x00, 0x1E, 0x00, 0xFF, 0xC0, 0x00, 
				 0x00, 0x1E, 0x01, 0x00, 0x10, 0x00, 0x00, 0x1F, 
				 0x01, 0x00, 0x19, 0xEA, 0x00, 0x13, 0xC0, 0x00, 
				 0x1E, 0x00, 0x00, 0xC0, 0x00, 0x00, 0x1E, 0x01, 
				 0x00, 0x14, 0x00, 0x00, 0x19, 0xC0, 0x00, 0x13, 
				 0xEA, 0x00, 0x1E, 0x00, 0xFF, 0xC0, 0x00, 0x00, 
				 0x1E, 0x01, 0x00, 0x10, 0x00, 0x00, 0x1F, 0x01, 
				 0x00, 0x19, 0xEA, 0x00, 0x00, 0xEA};

BYTE t5465_Mode_1024x768x16_3[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x16, 0x05, 0x04, 0x00, 0x00, 0x16, 0xC0, 0x00, 
				 0x00, 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 
				 0x00, 0x1F, 0x01, 0x00, 0x18, 0xC5, 0x02, 0x18, 
				 0x07, 0x04, 0x15, 0xA0, 0x00, 0xFF, 0x00, 0x09, 
				 0xCE, 0x03, 0x06, 0x05, 0x09, 0xCE, 0x03, 0x09, 
				 0x00, 0x09, 0xCE, 0x03, 0x0A, 0x00, 0x09, 0xCE, 
				 0x03, 0x0B, 0x00, 0x16, 0x80, 0x00, 0xEF, 0x00, 
				 0x16, 0x84, 0x00, 0x2A, 0x00, 0x16, 0x88, 0x00, 
				 0x6E, 0x00, 0x1D, 0x19, 0x00, 0x00, 0x00, 0xA1, 
				 0x00, 0x00, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x80, 
				 0x00, 0x00, 0x00, 0x81, 0x00, 0x00, 0x00, 0x84, 
				 0x00, 0x00, 0x00, 0x95, 0x00, 0x00, 0x00, 0x24, 
				 0x00, 0x00, 0x00, 0xFD, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x60, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 
				 0x00, 0x00, 0x00, 0x88, 0x00, 0x00, 0x00, 0xFF, 
				 0x00, 0x00, 0x00, 0xA0, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x24, 
				 0x00, 0x00, 0x00, 0xE3, 0x00, 0x00, 0x00, 0xFF, 
				 0x00, 0x00, 0x00, 0x1D, 0x06, 0x00, 0x64, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0xE0, 0x00, 0x00, 0x00, 
				 0x22, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x13, 0xEA, 0x00, 0x1E, 0x00, 0x00, 0xC0, 0x00, 
				 0x00, 0x1E, 0x01, 0x52, 0x10, 0x00, 0x00, 0x1F, 
				 0x01, 0x00, 0x19, 0xEA, 0x00, 0x12, 0x07, 0x04, 
				 0x1E, 0x00, 0xC0, 0x00, 0x00, 0x00, 0x1E, 0x01, 
				 0x08, 0x00, 0x00, 0x00, 0x18, 0x07, 0x04, 0x13, 
				 0xC4, 0x02, 0x1E, 0x00, 0x3F, 0xC0, 0x00, 0x00, 
				 0x1E, 0x01, 0xC0, 0x08, 0x00, 0x00, 0x1F, 0x01, 
				 0x00, 0x19, 0xC4, 0x02, 0x13, 0xEA, 0x00, 0x1E, 
				 0x00, 0xC0, 0xFF, 0x00, 0x00, 0x1E, 0x01, 0x19, 
				 0x00, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 0xEA, 
				 0x00, 0x16, 0x02, 0x04, 0x00, 0x28, 0x13, 0xC0, 
				 0x00, 0x1E, 0x01, 0x00, 0x16, 0x00, 0x00, 0x19, 
				 0xC0, 0x00, 0x17, 0x4C, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x17, 0x6C, 0x00, 0x32, 0x00, 0x00, 0x00, 
				 0x13, 0xEA, 0x00, 0x1E, 0x00, 0xFF, 0xC0, 0x00, 
				 0x00, 0x1E, 0x01, 0x00, 0x10, 0x00, 0x00, 0x1F, 
				 0x01, 0x00, 0x19, 0xEA, 0x00, 0x13, 0xC0, 0x00, 
				 0x1E, 0x00, 0x00, 0xC0, 0x00, 0x00, 0x1E, 0x01, 
				 0x00, 0x14, 0x00, 0x00, 0x19, 0xC0, 0x00, 0x13, 
				 0xEA, 0x00, 0x1E, 0x00, 0xFF, 0xC0, 0x00, 0x00, 
				 0x1E, 0x01, 0x00, 0x10, 0x00, 0x00, 0x1F, 0x01, 
				 0x00, 0x19, 0xEA, 0x00, 0x00, 0xEA};

BYTE t5465_Mode_1024x768x16_4[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x16, 0x05, 0x04, 0x00, 0x00, 0x16, 0xC0, 0x00, 
				 0x00, 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 
				 0x00, 0x1F, 0x01, 0x00, 0x18, 0xC5, 0x02, 0x18, 
				 0x07, 0x04, 0x15, 0xA0, 0x00, 0xFF, 0x00, 0x09, 
				 0xCE, 0x03, 0x06, 0x05, 0x09, 0xCE, 0x03, 0x09, 
				 0x00, 0x09, 0xCE, 0x03, 0x0A, 0x00, 0x09, 0xCE, 
				 0x03, 0x0B, 0x00, 0x16, 0x80, 0x00, 0x2F, 0x00, 
				 0x16, 0x84, 0x00, 0x10, 0x00, 0x16, 0x88, 0x00, 
				 0x2C, 0x00, 0x1D, 0x19, 0x00, 0x00, 0x00, 0x9F, 
				 0x00, 0x00, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x80, 
				 0x00, 0x00, 0x00, 0x9F, 0x00, 0x00, 0x00, 0x83, 
				 0x00, 0x00, 0x00, 0x0F, 0x00, 0x00, 0x00, 0x1E, 
				 0x00, 0x00, 0x00, 0xF5, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x60, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x83, 0x00, 0x00, 0x00, 0xFF, 
				 0x00, 0x00, 0x00, 0xA0, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 0x1E, 
				 0x00, 0x00, 0x00, 0xE3, 0x00, 0x00, 0x00, 0xFF, 
				 0x00, 0x00, 0x00, 0x1D, 0x06, 0x00, 0x64, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0xE0, 0x00, 0x00, 0x00, 
				 0x22, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x13, 0xEA, 0x00, 0x1E, 0x00, 0x00, 0xC0, 0x00, 
				 0x00, 0x1E, 0x01, 0x52, 0x10, 0x00, 0x00, 0x1F, 
				 0x01, 0x00, 0x19, 0xEA, 0x00, 0x12, 0x07, 0x04, 
				 0x1E, 0x00, 0xC0, 0x00, 0x00, 0x00, 0x1E, 0x01, 
				 0x08, 0x00, 0x00, 0x00, 0x18, 0x07, 0x04, 0x13, 
				 0xC4, 0x02, 0x1E, 0x00, 0x3F, 0xC0, 0x00, 0x00, 
				 0x1E, 0x01, 0xC0, 0x08, 0x00, 0x00, 0x1F, 0x01, 
				 0x00, 0x19, 0xC4, 0x02, 0x13, 0xEA, 0x00, 0x1E, 
				 0x00, 0xC0, 0xFF, 0x00, 0x00, 0x1E, 0x01, 0x19, 
				 0x00, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 0xEA, 
				 0x00, 0x16, 0x02, 0x04, 0x00, 0x28, 0x13, 0xC0, 
				 0x00, 0x1E, 0x01, 0x00, 0x16, 0x00, 0x00, 0x19, 
				 0xC0, 0x00, 0x17, 0x4C, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x17, 0x6C, 0x00, 0x32, 0x00, 0x00, 0x00, 
				 0x13, 0xEA, 0x00, 0x1E, 0x00, 0xFF, 0xC0, 0x00, 
				 0x00, 0x1E, 0x01, 0x00, 0x10, 0x00, 0x00, 0x1F, 
				 0x01, 0x00, 0x19, 0xEA, 0x00, 0x13, 0xC0, 0x00, 
				 0x1E, 0x00, 0x00, 0xC0, 0x00, 0x00, 0x1E, 0x01, 
				 0x00, 0x14, 0x00, 0x00, 0x19, 0xC0, 0x00, 0x13, 
				 0xEA, 0x00, 0x1E, 0x00, 0xFF, 0xC0, 0x00, 0x00, 
				 0x1E, 0x01, 0x00, 0x10, 0x00, 0x00, 0x1F, 0x01, 
				 0x00, 0x19, 0xEA, 0x00, 0x00, 0xEA};

BYTE t5465_Mode_1024x768x16_5[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x16, 0x05, 0x04, 0x00, 0x00, 0x16, 0xC0, 0x00, 
				 0x00, 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 
				 0x00, 0x1F, 0x01, 0x00, 0x18, 0xC5, 0x02, 0x18, 
				 0x07, 0x04, 0x15, 0xA0, 0x00, 0xFF, 0x00, 0x09, 
				 0xCE, 0x03, 0x06, 0x05, 0x09, 0xCE, 0x03, 0x09, 
				 0x00, 0x09, 0xCE, 0x03, 0x0A, 0x00, 0x09, 0xCE, 
				 0x03, 0x0B, 0x00, 0x16, 0x80, 0x00, 0x2F, 0x00, 
				 0x16, 0x84, 0x00, 0x0A, 0x00, 0x16, 0x88, 0x00, 
				 0x21, 0x00, 0x1D, 0x19, 0x00, 0x00, 0x00, 0xA7, 
				 0x00, 0x00, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x80, 
				 0x00, 0x00, 0x00, 0x87, 0x00, 0x00, 0x00, 0x87, 
				 0x00, 0x00, 0x00, 0x93, 0x00, 0x00, 0x00, 0x26, 
				 0x00, 0x00, 0x00, 0xF5, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x60, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x83, 0x00, 0x00, 0x00, 0xFF, 
				 0x00, 0x00, 0x00, 0xA0, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 0x26, 
				 0x00, 0x00, 0x00, 0xE3, 0x00, 0x00, 0x00, 0xFF, 
				 0x00, 0x00, 0x00, 0x1D, 0x06, 0x00, 0x64, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0xE0, 0x00, 0x00, 0x00, 
				 0x22, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x13, 0xEA, 0x00, 0x1E, 0x00, 0x00, 0xC0, 0x00, 
				 0x00, 0x1E, 0x01, 0x52, 0x10, 0x00, 0x00, 0x1F, 
				 0x01, 0x00, 0x19, 0xEA, 0x00, 0x12, 0x07, 0x04, 
				 0x1E, 0x00, 0xC0, 0x00, 0x00, 0x00, 0x1E, 0x01, 
				 0x08, 0x00, 0x00, 0x00, 0x18, 0x07, 0x04, 0x13, 
				 0xC4, 0x02, 0x1E, 0x00, 0x3F, 0xC0, 0x00, 0x00, 
				 0x1E, 0x01, 0xC0, 0x08, 0x00, 0x00, 0x1F, 0x01, 
				 0x00, 0x19, 0xC4, 0x02, 0x13, 0xEA, 0x00, 0x1E, 
				 0x00, 0xC0, 0xFF, 0x00, 0x00, 0x1E, 0x01, 0x19, 
				 0x00, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 0xEA, 
				 0x00, 0x16, 0x02, 0x04, 0x00, 0x28, 0x13, 0xC0, 
				 0x00, 0x1E, 0x01, 0x00, 0x16, 0x00, 0x00, 0x19, 
				 0xC0, 0x00, 0x17, 0x4C, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x17, 0x6C, 0x00, 0x32, 0x00, 0x00, 0x00, 
				 0x13, 0xEA, 0x00, 0x1E, 0x00, 0xFF, 0xC0, 0x00, 
				 0x00, 0x1E, 0x01, 0x00, 0x10, 0x00, 0x00, 0x1F, 
				 0x01, 0x00, 0x19, 0xEA, 0x00, 0x13, 0xC0, 0x00, 
				 0x1E, 0x00, 0x00, 0xC0, 0x00, 0x00, 0x1E, 0x01, 
				 0x00, 0x14, 0x00, 0x00, 0x19, 0xC0, 0x00, 0x13, 
				 0xEA, 0x00, 0x1E, 0x00, 0xFF, 0xC0, 0x00, 0x00, 
				 0x1E, 0x01, 0x00, 0x10, 0x00, 0x00, 0x1F, 0x01, 
				 0x00, 0x19, 0xEA, 0x00, 0x00, 0xEA};

BYTE t5465_Mode_1152x864x16_1[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x16, 0x05, 0x04, 0x00, 0x00, 0x16, 0xC0, 0x00, 
				 0x00, 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 
				 0x00, 0x1F, 0x01, 0x00, 0x18, 0xC5, 0x02, 0x18, 
				 0x07, 0x04, 0x15, 0xA0, 0x00, 0xFF, 0x00, 0x09, 
				 0xCE, 0x03, 0x06, 0x05, 0x09, 0xCE, 0x03, 0x09, 
				 0x00, 0x09, 0xCE, 0x03, 0x0A, 0x00, 0x09, 0xCE, 
				 0x03, 0x0B, 0x00, 0x16, 0x80, 0x00, 0x2F, 0x00, 
				 0x16, 0x84, 0x00, 0x0A, 0x00, 0x16, 0x88, 0x00, 
				 0x21, 0x00, 0x1D, 0x19, 0x00, 0x00, 0x00, 0xB4, 
				 0x00, 0x00, 0x00, 0x8F, 0x00, 0x00, 0x00, 0x8F, 
				 0x00, 0x00, 0x00, 0x94, 0x00, 0x00, 0x00, 0x95, 
				 0x00, 0x00, 0x00, 0x81, 0x00, 0x00, 0x00, 0x8E, 
				 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x60, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x60, 
				 0x00, 0x00, 0x00, 0x83, 0x00, 0x00, 0x00, 0x5F, 
				 0x00, 0x00, 0x00, 0xA0, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x5F, 0x00, 0x00, 0x00, 0x8E, 
				 0x00, 0x00, 0x00, 0xE3, 0x00, 0x00, 0x00, 0xFF, 
				 0x00, 0x00, 0x00, 0x1D, 0x06, 0x00, 0x64, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0xE0, 0x00, 0x00, 0x00, 
				 0x22, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x13, 0xEA, 0x00, 0x1E, 0x00, 0x00, 0xC0, 0x00, 
				 0x00, 0x1E, 0x01, 0x22, 0x14, 0x00, 0x00, 0x1F, 
				 0x01, 0x00, 0x19, 0xEA, 0x00, 0x12, 0x07, 0x04, 
				 0x1E, 0x00, 0xC0, 0x00, 0x00, 0x00, 0x1E, 0x01, 
				 0x14, 0x00, 0x00, 0x00, 0x18, 0x07, 0x04, 0x13, 
				 0xC4, 0x02, 0x1E, 0x00, 0x3F, 0xC0, 0x00, 0x00, 
				 0x1E, 0x01, 0x80, 0x14, 0x00, 0x00, 0x1F, 0x01, 
				 0x00, 0x19, 0xC4, 0x02, 0x16, 0x02, 0x04, 0x00, 
				 0x20, 0x13, 0xC0, 0x00, 0x1E, 0x01, 0x00, 0x16, 
				 0x00, 0x00, 0x19, 0xC0, 0x00, 0x17, 0x4C, 0x00, 
				 0x40, 0x00, 0x00, 0x00, 0x17, 0x6C, 0x00, 0x32, 
				 0x00, 0x00, 0x00, 0x13, 0xEA, 0x00, 0x1E, 0x00, 
				 0xFF, 0xC0, 0x00, 0x00, 0x1E, 0x01, 0x00, 0x12, 
				 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 0xEA, 0x00, 
				 0x13, 0xC0, 0x00, 0x1E, 0x00, 0x00, 0xC0, 0x00, 
				 0x00, 0x1E, 0x01, 0x00, 0x14, 0x00, 0x00, 0x19, 
				 0xC0, 0x00, 0x13, 0xEA, 0x00, 0x1E, 0x00, 0xFF, 
				 0xC0, 0x00, 0x00, 0x1E, 0x01, 0x00, 0x12, 0x00, 
				 0x00, 0x1F, 0x01, 0x00, 0x19, 0xEA, 0x00, 0x00, 0xEA};

BYTE t5465_Mode_1152x864x16_2[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x16, 0x05, 0x04, 0x00, 0x00, 0x16, 0xC0, 0x00, 
				 0x00, 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 
				 0x00, 0x1F, 0x01, 0x00, 0x18, 0xC5, 0x02, 0x18, 
				 0x07, 0x04, 0x15, 0xA0, 0x00, 0xFF, 0x00, 0x09, 
				 0xCE, 0x03, 0x06, 0x05, 0x09, 0xCE, 0x03, 0x09, 
				 0x00, 0x09, 0xCE, 0x03, 0x0A, 0x00, 0x09, 0xCE, 
				 0x03, 0x0B, 0x00, 0x16, 0x80, 0x00, 0x2F, 0x00, 
				 0x16, 0x84, 0x00, 0x16, 0x00, 0x16, 0x88, 0x00, 
				 0x53, 0x00, 0x1D, 0x19, 0x00, 0x00, 0x00, 0xC3, 
				 0x00, 0x00, 0x00, 0x8F, 0x00, 0x00, 0x00, 0x8F, 
				 0x00, 0x00, 0x00, 0x83, 0x00, 0x00, 0x00, 0x99, 
				 0x00, 0x00, 0x00, 0x09, 0x00, 0x00, 0x00, 0x82, 
				 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x60, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x60, 
				 0x00, 0x00, 0x00, 0x83, 0x00, 0x00, 0x00, 0x5F, 
				 0x00, 0x00, 0x00, 0xA0, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x5F, 0x00, 0x00, 0x00, 0x82, 
				 0x00, 0x00, 0x00, 0xE3, 0x00, 0x00, 0x00, 0xFF, 
				 0x00, 0x00, 0x00, 0x1D, 0x06, 0x00, 0x64, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0xF0, 0x00, 0x00, 0x00, 
				 0x22, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x13, 0xEA, 0x00, 0x1E, 0x00, 0x00, 0xC0, 0x00, 
				 0x00, 0x1E, 0x01, 0x22, 0x14, 0x00, 0x00, 0x1F, 
				 0x01, 0x00, 0x19, 0xEA, 0x00, 0x12, 0x07, 0x04, 
				 0x1E, 0x00, 0xC0, 0x00, 0x00, 0x00, 0x1E, 0x01, 
				 0x14, 0x00, 0x00, 0x00, 0x18, 0x07, 0x04, 0x13, 
				 0xC4, 0x02, 0x1E, 0x00, 0x3F, 0xC0, 0x00, 0x00, 
				 0x1E, 0x01, 0x80, 0x14, 0x00, 0x00, 0x1F, 0x01, 
				 0x00, 0x19, 0xC4, 0x02, 0x16, 0x02, 0x04, 0x00, 
				 0x20, 0x13, 0xC0, 0x00, 0x1E, 0x01, 0x00, 0x16, 
				 0x00, 0x00, 0x19, 0xC0, 0x00, 0x17, 0x4C, 0x00, 
				 0x40, 0x00, 0x00, 0x00, 0x17, 0x6C, 0x00, 0x32, 
				 0x00, 0x00, 0x00, 0x13, 0xEA, 0x00, 0x1E, 0x00, 
				 0xFF, 0xC0, 0x00, 0x00, 0x1E, 0x01, 0x00, 0x12, 
				 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 0xEA, 0x00, 
				 0x13, 0xC0, 0x00, 0x1E, 0x00, 0x00, 0xC0, 0x00, 
				 0x00, 0x1E, 0x01, 0x00, 0x14, 0x00, 0x00, 0x19, 
				 0xC0, 0x00, 0x13, 0xEA, 0x00, 0x1E, 0x00, 0xFF, 
				 0xC0, 0x00, 0x00, 0x1E, 0x01, 0x00, 0x12, 0x00, 
				 0x00, 0x1F, 0x01, 0x00, 0x19, 0xEA, 0x00, 0x00, 0xEA};

BYTE t5465_Mode_1152x864x16_3[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x16, 0x05, 0x04, 0x00, 0x00, 0x16, 0xC0, 0x00, 
				 0x00, 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 
				 0x00, 0x1F, 0x01, 0x00, 0x18, 0xC5, 0x02, 0x18, 
				 0x07, 0x04, 0x15, 0xA0, 0x00, 0xFF, 0x00, 0x09, 
				 0xCE, 0x03, 0x06, 0x05, 0x09, 0xCE, 0x03, 0x09, 
				 0x00, 0x09, 0xCE, 0x03, 0x0A, 0x00, 0x09, 0xCE, 
				 0x03, 0x0B, 0x00, 0x16, 0x80, 0x00, 0x2F, 0x00, 
				 0x16, 0x84, 0x00, 0x04, 0x00, 0x16, 0x88, 0x00, 
				 0x11, 0x00, 0x1D, 0x19, 0x00, 0x00, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x8F, 0x00, 0x00, 0x00, 0x8F, 
				 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x99, 
				 0x00, 0x00, 0x00, 0x09, 0x00, 0x00, 0x00, 0x89, 
				 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x60, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x60, 
				 0x00, 0x00, 0x00, 0x83, 0x00, 0x00, 0x00, 0x5F, 
				 0x00, 0x00, 0x00, 0xA0, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x5F, 0x00, 0x00, 0x00, 0x89, 
				 0x00, 0x00, 0x00, 0xE3, 0x00, 0x00, 0x00, 0xFF, 
				 0x00, 0x00, 0x00, 0x1D, 0x06, 0x00, 0x64, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0xF0, 0x00, 0x00, 0x00, 
				 0x22, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x13, 0xEA, 0x00, 0x1E, 0x00, 0x00, 0xC0, 0x00, 
				 0x00, 0x1E, 0x01, 0x22, 0x14, 0x00, 0x00, 0x1F, 
				 0x01, 0x00, 0x19, 0xEA, 0x00, 0x12, 0x07, 0x04, 
				 0x1E, 0x00, 0xC0, 0x00, 0x00, 0x00, 0x1E, 0x01, 
				 0x14, 0x00, 0x00, 0x00, 0x18, 0x07, 0x04, 0x13, 
				 0xC4, 0x02, 0x1E, 0x00, 0x3F, 0xC0, 0x00, 0x00, 
				 0x1E, 0x01, 0x80, 0x14, 0x00, 0x00, 0x1F, 0x01, 
				 0x00, 0x19, 0xC4, 0x02, 0x16, 0x02, 0x04, 0x00, 
				 0x20, 0x13, 0xC0, 0x00, 0x1E, 0x01, 0x00, 0x16, 
				 0x00, 0x00, 0x19, 0xC0, 0x00, 0x17, 0x4C, 0x00, 
				 0x40, 0x00, 0x00, 0x00, 0x17, 0x6C, 0x00, 0x32, 
				 0x00, 0x00, 0x00, 0x13, 0xEA, 0x00, 0x1E, 0x00, 
				 0xFF, 0xC0, 0x00, 0x00, 0x1E, 0x01, 0x00, 0x12, 
				 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 0xEA, 0x00, 
				 0x13, 0xC0, 0x00, 0x1E, 0x00, 0x00, 0xC0, 0x00, 
				 0x00, 0x1E, 0x01, 0x00, 0x14, 0x00, 0x00, 0x19, 
				 0xC0, 0x00, 0x13, 0xEA, 0x00, 0x1E, 0x00, 0xFF, 
				 0xC0, 0x00, 0x00, 0x1E, 0x01, 0x00, 0x12, 0x00, 
				 0x00, 0x1F, 0x01, 0x00, 0x19, 0xEA, 0x00, 0x00, 0xEA};

BYTE t5465_Mode_1280x960x16_1[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x16, 0x05, 0x04, 0x00, 0x00, 0x16, 0xC0, 0x00, 
				 0x00, 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 
				 0x00, 0x1F, 0x01, 0x00, 0x18, 0xC5, 0x02, 0x18, 
				 0x07, 0x04, 0x15, 0xA0, 0x00, 0xFF, 0x00, 0x09, 
				 0xCE, 0x03, 0x06, 0x05, 0x09, 0xCE, 0x03, 0x09, 
				 0x00, 0x09, 0xCE, 0x03, 0x0A, 0x00, 0x09, 0xCE, 
				 0x03, 0x0B, 0x00, 0x16, 0x80, 0x00, 0x2F, 0x00, 
				 0x16, 0x84, 0x00, 0x16, 0x00, 0x16, 0x88, 0x00, 
				 0x53, 0x00, 0x1D, 0x19, 0x00, 0x00, 0x00, 0xDC, 
				 0x00, 0x00, 0x00, 0x9F, 0x00, 0x00, 0x00, 0x9F, 
				 0x00, 0x00, 0x00, 0x9C, 0x00, 0x00, 0x00, 0xAD, 
				 0x00, 0x00, 0x00, 0x1B, 0x00, 0x00, 0x00, 0xE6, 
				 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x60, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x83, 0x00, 0x00, 0x00, 0xBF, 
				 0x00, 0x00, 0x00, 0xA0, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0xBF, 0x00, 0x00, 0x00, 0xE6, 
				 0x00, 0x00, 0x00, 0xE3, 0x00, 0x00, 0x00, 0xFF, 
				 0x00, 0x00, 0x00, 0x1D, 0x06, 0x00, 0x64, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0xF0, 0x00, 0x00, 0x00, 
				 0x22, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x13, 0xEA, 0x00, 0x1E, 0x00, 0x00, 0xC0, 0x00, 
				 0x00, 0x1E, 0x01, 0x22, 0x14, 0x00, 0x00, 0x1F, 
				 0x01, 0x00, 0x19, 0xEA, 0x00, 0x12, 0x07, 0x04, 
				 0x1E, 0x00, 0xC0, 0x00, 0x00, 0x00, 0x1E, 0x01, 
				 0x14, 0x00, 0x00, 0x00, 0x18, 0x07, 0x04, 0x13, 
				 0xC4, 0x02, 0x1E, 0x00, 0x3F, 0xC0, 0x00, 0x00, 
				 0x1E, 0x01, 0x80, 0x14, 0x00, 0x00, 0x1F, 0x01, 
				 0x00, 0x19, 0xC4, 0x02, 0x16, 0x02, 0x04, 0x00, 
				 0x20, 0x13, 0xC0, 0x00, 0x1E, 0x01, 0x00, 0x16, 
				 0x00, 0x00, 0x19, 0xC0, 0x00, 0x17, 0x4C, 0x00, 
				 0x40, 0x00, 0x00, 0x00, 0x17, 0x6C, 0x00, 0x32, 
				 0x00, 0x00, 0x00, 0x13, 0xEA, 0x00, 0x1E, 0x00, 
				 0xFF, 0xC0, 0x00, 0x00, 0x1E, 0x01, 0x00, 0x14, 
				 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 0xEA, 0x00, 
				 0x13, 0xC0, 0x00, 0x1E, 0x00, 0x00, 0xC0, 0x00, 
				 0x00, 0x1E, 0x01, 0x00, 0x14, 0x00, 0x00, 0x19, 
				 0xC0, 0x00, 0x13, 0xEA, 0x00, 0x1E, 0x00, 0xFF, 
				 0xC0, 0x00, 0x00, 0x1E, 0x01, 0x00, 0x14, 0x00, 
				 0x00, 0x1F, 0x01, 0x00, 0x19, 0xEA, 0x00, 0x00, 0xEA};

BYTE t5465_Mode_1280x960x16_2[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x16, 0x05, 0x04, 0x00, 0x00, 0x16, 0xC0, 0x00, 
				 0x00, 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 
				 0x00, 0x1F, 0x01, 0x00, 0x18, 0xC5, 0x02, 0x18, 
				 0x07, 0x04, 0x15, 0xA0, 0x00, 0xFF, 0x00, 0x09, 
				 0xCE, 0x03, 0x06, 0x05, 0x09, 0xCE, 0x03, 0x09, 
				 0x00, 0x09, 0xCE, 0x03, 0x0A, 0x00, 0x09, 0xCE, 
				 0x03, 0x0B, 0x00, 0x16, 0x80, 0x00, 0x2F, 0x00, 
				 0x16, 0x84, 0x00, 0x0A, 0x00, 0x16, 0x88, 0x00, 
				 0x2C, 0x00, 0x1D, 0x19, 0x00, 0x00, 0x00, 0xCD, 
				 0x00, 0x00, 0x00, 0x9F, 0x00, 0x00, 0x00, 0x9F, 
				 0x00, 0x00, 0x00, 0x8D, 0x00, 0x00, 0x00, 0xA5, 
				 0x00, 0x00, 0x00, 0x17, 0x00, 0x00, 0x00, 0xE6, 
				 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x60, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x83, 0x00, 0x00, 0x00, 0xBF, 
				 0x00, 0x00, 0x00, 0xA0, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0xBF, 0x00, 0x00, 0x00, 0xE6, 
				 0x00, 0x00, 0x00, 0xE3, 0x00, 0x00, 0x00, 0xFF, 
				 0x00, 0x00, 0x00, 0x1D, 0x06, 0x00, 0x64, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0xF0, 0x00, 0x00, 0x00, 
				 0x22, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x13, 0xEA, 0x00, 0x1E, 0x00, 0x00, 0xC0, 0x00, 
				 0x00, 0x1E, 0x01, 0x22, 0x14, 0x00, 0x00, 0x1F, 
				 0x01, 0x00, 0x19, 0xEA, 0x00, 0x12, 0x07, 0x04, 
				 0x1E, 0x00, 0xC0, 0x00, 0x00, 0x00, 0x1E, 0x01, 
				 0x14, 0x00, 0x00, 0x00, 0x18, 0x07, 0x04, 0x13, 
				 0xC4, 0x02, 0x1E, 0x00, 0x3F, 0xC0, 0x00, 0x00, 
				 0x1E, 0x01, 0x80, 0x14, 0x00, 0x00, 0x1F, 0x01, 
				 0x00, 0x19, 0xC4, 0x02, 0x16, 0x02, 0x04, 0x00, 
				 0x20, 0x13, 0xC0, 0x00, 0x1E, 0x01, 0x00, 0x16, 
				 0x00, 0x00, 0x19, 0xC0, 0x00, 0x17, 0x4C, 0x00, 
				 0x40, 0x00, 0x00, 0x00, 0x17, 0x6C, 0x00, 0x32, 
				 0x00, 0x00, 0x00, 0x13, 0xEA, 0x00, 0x1E, 0x00, 
				 0xFF, 0xC0, 0x00, 0x00, 0x1E, 0x01, 0x00, 0x14, 
				 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 0xEA, 0x00, 
				 0x13, 0xC0, 0x00, 0x1E, 0x00, 0x00, 0xC0, 0x00, 
				 0x00, 0x1E, 0x01, 0x00, 0x14, 0x00, 0x00, 0x19, 
				 0xC0, 0x00, 0x13, 0xEA, 0x00, 0x1E, 0x00, 0xFF, 
				 0xC0, 0x00, 0x00, 0x1E, 0x01, 0x00, 0x14, 0x00, 
				 0x00, 0x1F, 0x01, 0x00, 0x19, 0xEA, 0x00, 0x00, 0xEA};

BYTE t5465_Mode_1280x960x16_3[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x16, 0x05, 0x04, 0x00, 0x00, 0x16, 0xC0, 0x00, 
				 0x00, 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 
				 0x00, 0x1F, 0x01, 0x00, 0x18, 0xC5, 0x02, 0x18, 
				 0x07, 0x04, 0x15, 0xA0, 0x00, 0xFF, 0x00, 0x09, 
				 0xCE, 0x03, 0x06, 0x05, 0x09, 0xCE, 0x03, 0x09, 
				 0x00, 0x09, 0xCE, 0x03, 0x0A, 0x00, 0x09, 0xCE, 
				 0x03, 0x0B, 0x00, 0x16, 0x80, 0x00, 0x2F, 0x00, 
				 0x16, 0x84, 0x00, 0x10, 0x00, 0x16, 0x88, 0x00, 
				 0x53, 0x00, 0x1D, 0x19, 0x00, 0x00, 0x00, 0xD3, 
				 0x00, 0x00, 0x00, 0x9F, 0x00, 0x00, 0x00, 0x9F, 
				 0x00, 0x00, 0x00, 0x93, 0x00, 0x00, 0x00, 0xA6, 
				 0x00, 0x00, 0x00, 0x1B, 0x00, 0x00, 0x00, 0xF1, 
				 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x60, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x83, 0x00, 0x00, 0x00, 0xBF, 
				 0x00, 0x00, 0x00, 0xA0, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0xBF, 0x00, 0x00, 0x00, 0xF1, 
				 0x00, 0x00, 0x00, 0xE3, 0x00, 0x00, 0x00, 0xFF, 
				 0x00, 0x00, 0x00, 0x1D, 0x06, 0x00, 0x64, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0xF0, 0x00, 0x00, 0x00, 
				 0x22, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x13, 0xEA, 0x00, 0x1E, 0x00, 0x00, 0xC0, 0x00, 
				 0x00, 0x1E, 0x01, 0x22, 0x14, 0x00, 0x00, 0x1F, 
				 0x01, 0x00, 0x19, 0xEA, 0x00, 0x12, 0x07, 0x04, 
				 0x1E, 0x00, 0xC0, 0x00, 0x00, 0x00, 0x1E, 0x01, 
				 0x14, 0x00, 0x00, 0x00, 0x18, 0x07, 0x04, 0x13, 
				 0xC4, 0x02, 0x1E, 0x00, 0x3F, 0xC0, 0x00, 0x00, 
				 0x1E, 0x01, 0x80, 0x14, 0x00, 0x00, 0x1F, 0x01, 
				 0x00, 0x19, 0xC4, 0x02, 0x13, 0xEA, 0x00, 0x1E, 
				 0x00, 0xC0, 0xFF, 0x00, 0x00, 0x1E, 0x01, 0x29, 
				 0x00, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 0xEA, 
				 0x00, 0x16, 0x02, 0x04, 0x00, 0x20, 0x13, 0xC0, 
				 0x00, 0x1E, 0x01, 0x00, 0x16, 0x00, 0x00, 0x19, 
				 0xC0, 0x00, 0x17, 0x4C, 0x00, 0x40, 0x00, 0x00, 
				 0x00, 0x17, 0x6C, 0x00, 0x32, 0x00, 0x00, 0x00, 
				 0x13, 0xEA, 0x00, 0x1E, 0x00, 0xFF, 0xC0, 0x00, 
				 0x00, 0x1E, 0x01, 0x00, 0x14, 0x00, 0x00, 0x1F, 
				 0x01, 0x00, 0x19, 0xEA, 0x00, 0x13, 0xC0, 0x00, 
				 0x1E, 0x00, 0x00, 0xC0, 0x00, 0x00, 0x1E, 0x01, 
				 0x00, 0x14, 0x00, 0x00, 0x19, 0xC0, 0x00, 0x13, 
				 0xEA, 0x00, 0x1E, 0x00, 0xFF, 0xC0, 0x00, 0x00, 
				 0x1E, 0x01, 0x00, 0x14, 0x00, 0x00, 0x1F, 0x01, 
				 0x00, 0x19, 0xEA, 0x00, 0x00, 0xEA};

BYTE t5465_Mode_1280x1024x16_1[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x16, 0x05, 0x04, 0x00, 0x00, 0x16, 0xC0, 0x00, 
				 0x00, 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 
				 0x00, 0x1F, 0x01, 0x00, 0x18, 0xC5, 0x02, 0x18, 
				 0x07, 0x04, 0x15, 0xA0, 0x00, 0xFF, 0x00, 0x09, 
				 0xCE, 0x03, 0x06, 0x05, 0x09, 0xCE, 0x03, 0x09, 
				 0x00, 0x09, 0xCE, 0x03, 0x0A, 0x00, 0x09, 0xCE, 
				 0x03, 0x0B, 0x00, 0x16, 0x80, 0x00, 0x2F, 0x00, 
				 0x16, 0x84, 0x00, 0x04, 0x00, 0x16, 0x88, 0x00, 
				 0x0B, 0x00, 0x1D, 0x19, 0x00, 0x00, 0x00, 0xCF, 
				 0x00, 0x00, 0x00, 0x9F, 0x00, 0x00, 0x00, 0x9F, 
				 0x00, 0x00, 0x00, 0x93, 0x00, 0x00, 0x00, 0xA9, 
				 0x00, 0x00, 0x00, 0x13, 0x00, 0x00, 0x00, 0x14, 
				 0x00, 0x00, 0x00, 0xB2, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x60, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x82, 0x00, 0x00, 0x00, 0xFF, 
				 0x00, 0x00, 0x00, 0xA0, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x14, 
				 0x00, 0x00, 0x00, 0xE3, 0x00, 0x00, 0x00, 0xFF, 
				 0x00, 0x00, 0x00, 0x1D, 0x06, 0x00, 0x64, 0x00, 
				 0x67, 0x00, 0x00, 0x00, 0x81, 0x00, 0x00, 0x00, 
				 0x22, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x13, 0xEA, 0x00, 0x1E, 0x00, 0x00, 0xC0, 0x00, 
				 0x00, 0x1E, 0x01, 0x22, 0x14, 0x00, 0x00, 0x1F, 
				 0x01, 0x00, 0x19, 0xEA, 0x00, 0x12, 0x07, 0x04, 
				 0x1E, 0x00, 0xC0, 0x00, 0x00, 0x00, 0x1E, 0x01, 
				 0x14, 0x00, 0x00, 0x00, 0x18, 0x07, 0x04, 0x13, 
				 0xC4, 0x02, 0x1E, 0x00, 0x3F, 0xC0, 0x00, 0x00, 
				 0x1E, 0x01, 0x80, 0x14, 0x00, 0x00, 0x1F, 0x01, 
				 0x00, 0x19, 0xC4, 0x02, 0x16, 0x02, 0x04, 0x00, 
				 0x20, 0x13, 0xC0, 0x00, 0x1E, 0x01, 0x00, 0x16, 
				 0x00, 0x00, 0x19, 0xC0, 0x00, 0x17, 0x4C, 0x00, 
				 0x40, 0x00, 0x00, 0x00, 0x17, 0x6C, 0x00, 0x32, 
				 0x00, 0x00, 0x00, 0x13, 0xEA, 0x00, 0x1E, 0x00, 
				 0xFF, 0xC0, 0x00, 0x00, 0x1E, 0x01, 0x00, 0x14, 
				 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 0xEA, 0x00, 
				 0x13, 0xC0, 0x00, 0x1E, 0x00, 0x00, 0xC0, 0x00, 
				 0x00, 0x1E, 0x01, 0x00, 0x14, 0x00, 0x00, 0x19, 
				 0xC0, 0x00, 0x13, 0xEA, 0x00, 0x1E, 0x00, 0xFF, 
				 0xC0, 0x00, 0x00, 0x1E, 0x01, 0x00, 0x14, 0x00, 
				 0x00, 0x1F, 0x01, 0x00, 0x19, 0xEA, 0x00, 0x00, 0xEA};

BYTE t5465_Mode_1280x1024x16_2[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x16, 0x05, 0x04, 0x00, 0x00, 0x16, 0xC0, 0x00, 
				 0x00, 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 
				 0x00, 0x1F, 0x01, 0x00, 0x18, 0xC5, 0x02, 0x18, 
				 0x07, 0x04, 0x15, 0xA0, 0x00, 0xFF, 0x00, 0x09, 
				 0xCE, 0x03, 0x06, 0x05, 0x09, 0xCE, 0x03, 0x09, 
				 0x00, 0x09, 0xCE, 0x03, 0x0A, 0x00, 0x09, 0xCE, 
				 0x03, 0x0B, 0x00, 0x16, 0x80, 0x00, 0x2F, 0x00, 
				 0x16, 0x84, 0x00, 0x16, 0x00, 0x16, 0x88, 0x00, 
				 0x53, 0x00, 0x1D, 0x19, 0x00, 0x00, 0x00, 0xCE, 
				 0x00, 0x00, 0x00, 0x9F, 0x00, 0x00, 0x00, 0x9F, 
				 0x00, 0x00, 0x00, 0x91, 0x00, 0x00, 0x00, 0xA7, 
				 0x00, 0x00, 0x00, 0x15, 0x00, 0x00, 0x00, 0x28, 
				 0x00, 0x00, 0x00, 0x5A, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x60, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x83, 0x00, 0x00, 0x00, 0xFF, 
				 0x00, 0x00, 0x00, 0xA0, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 0x24, 
				 0x00, 0x00, 0x00, 0xE3, 0x00, 0x00, 0x00, 0xFF, 
				 0x00, 0x00, 0x00, 0x1D, 0x06, 0x00, 0x64, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x30, 0x00, 0x00, 0x00, 
				 0x22, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x09, 0x00, 0x00, 0x00, 
				 0x13, 0xEA, 0x00, 0x1E, 0x00, 0x00, 0xC0, 0x00, 
				 0x00, 0x1E, 0x01, 0x22, 0x14, 0x00, 0x00, 0x1F, 
				 0x01, 0x00, 0x19, 0xEA, 0x00, 0x12, 0x07, 0x04, 
				 0x1E, 0x00, 0xC0, 0x00, 0x00, 0x00, 0x1E, 0x01, 
				 0x14, 0x00, 0x00, 0x00, 0x18, 0x07, 0x04, 0x13, 
				 0xC4, 0x02, 0x1E, 0x00, 0x3F, 0xC0, 0x00, 0x00, 
				 0x1E, 0x01, 0x80, 0x14, 0x00, 0x00, 0x1F, 0x01, 
				 0x00, 0x19, 0xC4, 0x02, 0x16, 0x02, 0x04, 0x00, 
				 0x20, 0x13, 0xC0, 0x00, 0x1E, 0x01, 0x00, 0x16, 
				 0x00, 0x00, 0x19, 0xC0, 0x00, 0x17, 0x4C, 0x00, 
				 0x40, 0x00, 0x00, 0x00, 0x17, 0x6C, 0x00, 0x32, 
				 0x00, 0x00, 0x00, 0x13, 0xEA, 0x00, 0x1E, 0x00, 
				 0xFF, 0xC0, 0x00, 0x00, 0x1E, 0x01, 0x00, 0x14, 
				 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 0xEA, 0x00, 
				 0x13, 0xC0, 0x00, 0x1E, 0x00, 0x00, 0xC0, 0x00, 
				 0x00, 0x1E, 0x01, 0x00, 0x14, 0x00, 0x00, 0x19, 
				 0xC0, 0x00, 0x13, 0xEA, 0x00, 0x1E, 0x00, 0xFF, 
				 0xC0, 0x00, 0x00, 0x1E, 0x01, 0x00, 0x14, 0x00, 
				 0x00, 0x1F, 0x01, 0x00, 0x19, 0xEA, 0x00, 0x00, 0xEA};

BYTE t5465_Mode_1280x1024x16_3[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x16, 0x05, 0x04, 0x00, 0x00, 0x16, 0xC0, 0x00, 
				 0x00, 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 
				 0x00, 0x1F, 0x01, 0x00, 0x18, 0xC5, 0x02, 0x18, 
				 0x07, 0x04, 0x15, 0xA0, 0x00, 0xFF, 0x00, 0x09, 
				 0xCE, 0x03, 0x06, 0x05, 0x09, 0xCE, 0x03, 0x09, 
				 0x00, 0x09, 0xCE, 0x03, 0x0A, 0x00, 0x09, 0xCE, 
				 0x03, 0x0B, 0x00, 0x16, 0x80, 0x00, 0x2F, 0x00, 
				 0x16, 0x84, 0x00, 0x1A, 0x00, 0x16, 0x88, 0x00, 
				 0x76, 0x00, 0x1D, 0x19, 0x00, 0x00, 0x00, 0xCE, 
				 0x00, 0x00, 0x00, 0x9F, 0x00, 0x00, 0x00, 0x9F, 
				 0x00, 0x00, 0x00, 0x91, 0x00, 0x00, 0x00, 0xA3, 
				 0x00, 0x00, 0x00, 0x15, 0x00, 0x00, 0x00, 0x28, 
				 0x00, 0x00, 0x00, 0x5A, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x60, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x83, 0x00, 0x00, 0x00, 0xFF, 
				 0x00, 0x00, 0x00, 0xA0, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 0x24, 
				 0x00, 0x00, 0x00, 0xE3, 0x00, 0x00, 0x00, 0xFF, 
				 0x00, 0x00, 0x00, 0x1D, 0x06, 0x00, 0x64, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x30, 0x00, 0x00, 0x00, 
				 0x22, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x09, 0x00, 0x00, 0x00, 
				 0x13, 0xEA, 0x00, 0x1E, 0x00, 0x00, 0xC0, 0x00, 
				 0x00, 0x1E, 0x01, 0x22, 0x14, 0x00, 0x00, 0x1F, 
				 0x01, 0x00, 0x19, 0xEA, 0x00, 0x12, 0x07, 0x04, 
				 0x1E, 0x00, 0xC0, 0x00, 0x00, 0x00, 0x1E, 0x01, 
				 0x14, 0x00, 0x00, 0x00, 0x18, 0x07, 0x04, 0x13, 
				 0xC4, 0x02, 0x1E, 0x00, 0x3F, 0xC0, 0x00, 0x00, 
				 0x1E, 0x01, 0x80, 0x14, 0x00, 0x00, 0x1F, 0x01, 
				 0x00, 0x19, 0xC4, 0x02, 0x13, 0xEA, 0x00, 0x1E, 
				 0x00, 0xC0, 0xFF, 0x00, 0x00, 0x1E, 0x01, 0x23, 
				 0x00, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 0xEA, 
				 0x00, 0x16, 0x02, 0x04, 0x00, 0x20, 0x13, 0xC0, 
				 0x00, 0x1E, 0x01, 0x00, 0x16, 0x00, 0x00, 0x19, 
				 0xC0, 0x00, 0x17, 0x4C, 0x00, 0x40, 0x00, 0x00, 
				 0x00, 0x17, 0x6C, 0x00, 0x32, 0x00, 0x00, 0x00, 
				 0x13, 0xEA, 0x00, 0x1E, 0x00, 0xFF, 0xC0, 0x00, 
				 0x00, 0x1E, 0x01, 0x00, 0x14, 0x00, 0x00, 0x1F, 
				 0x01, 0x00, 0x19, 0xEA, 0x00, 0x13, 0xC0, 0x00, 
				 0x1E, 0x00, 0x00, 0xC0, 0x00, 0x00, 0x1E, 0x01, 
				 0x00, 0x14, 0x00, 0x00, 0x19, 0xC0, 0x00, 0x13, 
				 0xEA, 0x00, 0x1E, 0x00, 0xFF, 0xC0, 0x00, 0x00, 
				 0x1E, 0x01, 0x00, 0x14, 0x00, 0x00, 0x1F, 0x01, 
				 0x00, 0x19, 0xEA, 0x00, 0x00, 0xEA};

BYTE t5465_Mode_1280x1024x16_4[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x16, 0x05, 0x04, 0x00, 0x00, 0x16, 0xC0, 0x00, 
				 0x00, 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 
				 0x00, 0x1F, 0x01, 0x00, 0x18, 0xC5, 0x02, 0x18, 
				 0x07, 0x04, 0x15, 0xA0, 0x00, 0xFF, 0x00, 0x09, 
				 0xCE, 0x03, 0x06, 0x05, 0x09, 0xCE, 0x03, 0x09, 
				 0x00, 0x09, 0xCE, 0x03, 0x0A, 0x00, 0x09, 0xCE, 
				 0x03, 0x0B, 0x00, 0x16, 0x80, 0x00, 0x2F, 0x00, 
				 0x16, 0x84, 0x00, 0x0E, 0x00, 0x16, 0x88, 0x00, 
				 0x42, 0x00, 0x1D, 0x19, 0x00, 0x00, 0x00, 0xCE, 
				 0x00, 0x00, 0x00, 0x9F, 0x00, 0x00, 0x00, 0x9F, 
				 0x00, 0x00, 0x00, 0x91, 0x00, 0x00, 0x00, 0xA3, 
				 0x00, 0x00, 0x00, 0x15, 0x00, 0x00, 0x00, 0x28, 
				 0x00, 0x00, 0x00, 0x5A, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x60, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x83, 0x00, 0x00, 0x00, 0xFF, 
				 0x00, 0x00, 0x00, 0xA0, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 0x24, 
				 0x00, 0x00, 0x00, 0xE3, 0x00, 0x00, 0x00, 0xFF, 
				 0x00, 0x00, 0x00, 0x1D, 0x06, 0x00, 0x64, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x30, 0x00, 0x00, 0x00, 
				 0x22, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x09, 0x00, 0x00, 0x00, 
				 0x13, 0xEA, 0x00, 0x1E, 0x00, 0x00, 0xC0, 0x00, 
				 0x00, 0x1E, 0x01, 0x22, 0x14, 0x00, 0x00, 0x1F, 
				 0x01, 0x00, 0x19, 0xEA, 0x00, 0x12, 0x07, 0x04, 
				 0x1E, 0x00, 0xC0, 0x00, 0x00, 0x00, 0x1E, 0x01, 
				 0x14, 0x00, 0x00, 0x00, 0x18, 0x07, 0x04, 0x13, 
				 0xC4, 0x02, 0x1E, 0x00, 0x3F, 0xC0, 0x00, 0x00, 
				 0x1E, 0x01, 0x80, 0x14, 0x00, 0x00, 0x1F, 0x01, 
				 0x00, 0x19, 0xC4, 0x02, 0x13, 0xEA, 0x00, 0x1E, 
				 0x00, 0xC0, 0xFF, 0x00, 0x00, 0x1E, 0x01, 0x25, 
				 0x00, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 0xEA, 
				 0x00, 0x16, 0x02, 0x04, 0x00, 0x20, 0x13, 0xC0, 
				 0x00, 0x1E, 0x01, 0x00, 0x16, 0x00, 0x00, 0x19, 
				 0xC0, 0x00, 0x17, 0x4C, 0x00, 0x40, 0x00, 0x00, 
				 0x00, 0x17, 0x6C, 0x00, 0x32, 0x00, 0x00, 0x00, 
				 0x13, 0xEA, 0x00, 0x1E, 0x00, 0xFF, 0xC0, 0x00, 
				 0x00, 0x1E, 0x01, 0x00, 0x14, 0x00, 0x00, 0x1F, 
				 0x01, 0x00, 0x19, 0xEA, 0x00, 0x13, 0xC0, 0x00, 
				 0x1E, 0x00, 0x00, 0xC0, 0x00, 0x00, 0x1E, 0x01, 
				 0x00, 0x14, 0x00, 0x00, 0x19, 0xC0, 0x00, 0x13, 
				 0xEA, 0x00, 0x1E, 0x00, 0xFF, 0xC0, 0x00, 0x00, 
				 0x1E, 0x01, 0x00, 0x14, 0x00, 0x00, 0x1F, 0x01, 
				 0x00, 0x19, 0xEA, 0x00, 0x00, 0xEA};

BYTE t5465_Mode_1280x1024x16_5[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x16, 0x05, 0x04, 0x00, 0x00, 0x16, 0xC0, 0x00, 
				 0x00, 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 
				 0x00, 0x1F, 0x01, 0x00, 0x18, 0xC5, 0x02, 0x18, 
				 0x07, 0x04, 0x15, 0xA0, 0x00, 0xFF, 0x00, 0x09, 
				 0xCE, 0x03, 0x06, 0x05, 0x09, 0xCE, 0x03, 0x09, 
				 0x00, 0x09, 0xCE, 0x03, 0x0A, 0x00, 0x09, 0xCE, 
				 0x03, 0x0B, 0x00, 0x16, 0x80, 0x00, 0x2F, 0x00, 
				 0x16, 0x84, 0x00, 0x16, 0x00, 0x16, 0x88, 0x00, 
				 0x79, 0x00, 0x1D, 0x19, 0x00, 0x00, 0x00, 0xD3, 
				 0x00, 0x00, 0x00, 0x9F, 0x00, 0x00, 0x00, 0x9F, 
				 0x00, 0x00, 0x00, 0x91, 0x00, 0x00, 0x00, 0xA7, 
				 0x00, 0x00, 0x00, 0x1B, 0x00, 0x00, 0x00, 0x2E, 
				 0x00, 0x00, 0x00, 0x5A, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x60, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x83, 0x00, 0x00, 0x00, 0xFF, 
				 0x00, 0x00, 0x00, 0xA0, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 0x2A, 
				 0x00, 0x00, 0x00, 0xE3, 0x00, 0x00, 0x00, 0xFF, 
				 0x00, 0x00, 0x00, 0x1D, 0x06, 0x00, 0x64, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x30, 0x00, 0x00, 0x00, 
				 0x22, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x09, 0x00, 0x00, 0x00, 
				 0x13, 0xEA, 0x00, 0x1E, 0x00, 0x00, 0xC0, 0x00, 
				 0x00, 0x1E, 0x01, 0x22, 0x14, 0x00, 0x00, 0x1F, 
				 0x01, 0x00, 0x19, 0xEA, 0x00, 0x12, 0x07, 0x04, 
				 0x1E, 0x00, 0xC0, 0x00, 0x00, 0x00, 0x1E, 0x01, 
				 0x14, 0x00, 0x00, 0x00, 0x18, 0x07, 0x04, 0x13, 
				 0xC4, 0x02, 0x1E, 0x00, 0x3F, 0xC0, 0x00, 0x00, 
				 0x1E, 0x01, 0x80, 0x14, 0x00, 0x00, 0x1F, 0x01, 
				 0x00, 0x19, 0xC4, 0x02, 0x13, 0xEA, 0x00, 0x1E, 
				 0x00, 0xC0, 0xFF, 0x00, 0x00, 0x1E, 0x01, 0x33, 
				 0x00, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 0xEA, 
				 0x00, 0x16, 0x02, 0x04, 0x00, 0x20, 0x13, 0xC0, 
				 0x00, 0x1E, 0x01, 0x00, 0x16, 0x00, 0x00, 0x19, 
				 0xC0, 0x00, 0x17, 0x4C, 0x00, 0x40, 0x00, 0x00, 
				 0x00, 0x17, 0x6C, 0x00, 0x32, 0x00, 0x00, 0x00, 
				 0x13, 0xEA, 0x00, 0x1E, 0x00, 0xFF, 0xC0, 0x00, 
				 0x00, 0x1E, 0x01, 0x00, 0x14, 0x00, 0x00, 0x1F, 
				 0x01, 0x00, 0x19, 0xEA, 0x00, 0x13, 0xC0, 0x00, 
				 0x1E, 0x00, 0x00, 0xC0, 0x00, 0x00, 0x1E, 0x01, 
				 0x00, 0x14, 0x00, 0x00, 0x19, 0xC0, 0x00, 0x13, 
				 0xEA, 0x00, 0x1E, 0x00, 0xFF, 0xC0, 0x00, 0x00, 
				 0x1E, 0x01, 0x00, 0x14, 0x00, 0x00, 0x1F, 0x01, 
				 0x00, 0x19, 0xEA, 0x00, 0x00, 0xEA};

BYTE t5465_Mode_640x400x24_1[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x16, 0x05, 0x04, 0x00, 0x00, 0x16, 0xC0, 0x00, 
				 0x00, 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 
				 0x00, 0x1F, 0x01, 0x00, 0x18, 0xC5, 0x02, 0x18, 
				 0x07, 0x04, 0x15, 0xA0, 0x00, 0xFF, 0x00, 0x09, 
				 0xCE, 0x03, 0x06, 0x05, 0x09, 0xCE, 0x03, 0x09, 
				 0x00, 0x09, 0xCE, 0x03, 0x0A, 0x00, 0x09, 0xCE, 
				 0x03, 0x0B, 0x00, 0x16, 0x80, 0x00, 0x6F, 0x00, 
				 0x16, 0x84, 0x00, 0x3F, 0x00, 0x16, 0x88, 0x00, 
				 0x6D, 0x00, 0x1D, 0x19, 0x00, 0x00, 0x00, 0x5F, 
				 0x00, 0x00, 0x00, 0x4F, 0x00, 0x00, 0x00, 0x50, 
				 0x00, 0x00, 0x00, 0x82, 0x00, 0x00, 0x00, 0x53, 
				 0x00, 0x00, 0x00, 0x9F, 0x00, 0x00, 0x00, 0xBF, 
				 0x00, 0x00, 0x00, 0x1F, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xA1, 
				 0x00, 0x00, 0x00, 0xA3, 0x00, 0x00, 0x00, 0x8F, 
				 0x00, 0x00, 0x00, 0x50, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x96, 0x00, 0x00, 0x00, 0xB9, 
				 0x00, 0x00, 0x00, 0xE3, 0x00, 0x00, 0x00, 0xFF, 
				 0x00, 0x00, 0x00, 0x1D, 0x06, 0x00, 0x64, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x50, 0x00, 0x00, 0x00, 
				 0x22, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x13, 0xEA, 0x00, 0x1E, 0x00, 0x00, 0xC0, 0x00, 
				 0x00, 0x1E, 0x01, 0x52, 0x10, 0x00, 0x00, 0x1F, 
				 0x01, 0x00, 0x19, 0xEA, 0x00, 0x12, 0x07, 0x04, 
				 0x1E, 0x00, 0xC0, 0x00, 0x00, 0x00, 0x1E, 0x01, 
				 0x08, 0x00, 0x00, 0x00, 0x18, 0x07, 0x04, 0x13, 
				 0xC4, 0x02, 0x1E, 0x00, 0x3F, 0xC0, 0x00, 0x00, 
				 0x1E, 0x01, 0xC0, 0x08, 0x00, 0x00, 0x1F, 0x01, 
				 0x00, 0x19, 0xC4, 0x02, 0x13, 0xEA, 0x00, 0x1E, 
				 0x00, 0xC0, 0xFF, 0x00, 0x00, 0x1E, 0x01, 0x0D, 
				 0x00, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 0xEA, 
				 0x00, 0x16, 0x02, 0x04, 0x00, 0x48, 0x13, 0xC0, 
				 0x00, 0x1E, 0x01, 0x00, 0x24, 0x00, 0x00, 0x19, 
				 0xC0, 0x00, 0x17, 0x4C, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x17, 0x6C, 0x00, 0x32, 0x00, 0x00, 0x00, 
				 0x13, 0xEA, 0x00, 0x1E, 0x00, 0xFF, 0xC0, 0x00, 
				 0x00, 0x1E, 0x01, 0x00, 0x0F, 0x00, 0x00, 0x1F, 
				 0x01, 0x00, 0x19, 0xEA, 0x00, 0x00, 0xC0};

BYTE t5465_Mode_640x400x24_2[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x16, 0x05, 0x04, 0x00, 0x00, 0x16, 0xC0, 0x00, 
				 0x00, 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 
				 0x00, 0x1F, 0x01, 0x00, 0x18, 0xC5, 0x02, 0x18, 
				 0x07, 0x04, 0x15, 0xA0, 0x00, 0xFF, 0x00, 0x09, 
				 0xCE, 0x03, 0x06, 0x05, 0x09, 0xCE, 0x03, 0x09, 
				 0x00, 0x09, 0xCE, 0x03, 0x0A, 0x00, 0x09, 0xCE, 
				 0x03, 0x0B, 0x00, 0x16, 0x80, 0x00, 0x6F, 0x00, 
				 0x16, 0x84, 0x00, 0x0B, 0x00, 0x16, 0x88, 0x00, 
				 0x16, 0x00, 0x1D, 0x19, 0x00, 0x00, 0x00, 0x63, 
				 0x00, 0x00, 0x00, 0x4F, 0x00, 0x00, 0x00, 0x4F, 
				 0x00, 0x00, 0x00, 0x83, 0x00, 0x00, 0x00, 0x55, 
				 0x00, 0x00, 0x00, 0x99, 0x00, 0x00, 0x00, 0xBB, 
				 0x00, 0x00, 0x00, 0x1F, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x90, 
				 0x00, 0x00, 0x00, 0x83, 0x00, 0x00, 0x00, 0x8F, 
				 0x00, 0x00, 0x00, 0x50, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x8F, 0x00, 0x00, 0x00, 0xBB, 
				 0x00, 0x00, 0x00, 0xE3, 0x00, 0x00, 0x00, 0xFF, 
				 0x00, 0x00, 0x00, 0x1D, 0x06, 0x00, 0x64, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x50, 0x00, 0x00, 0x00, 
				 0x22, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x13, 0xEA, 0x00, 0x1E, 0x00, 0x00, 0xC0, 0x00, 
				 0x00, 0x1E, 0x01, 0x52, 0x10, 0x00, 0x00, 0x1F, 
				 0x01, 0x00, 0x19, 0xEA, 0x00, 0x12, 0x07, 0x04, 
				 0x1E, 0x00, 0xC0, 0x00, 0x00, 0x00, 0x1E, 0x01, 
				 0x08, 0x00, 0x00, 0x00, 0x18, 0x07, 0x04, 0x13, 
				 0xC4, 0x02, 0x1E, 0x00, 0x3F, 0xC0, 0x00, 0x00, 
				 0x1E, 0x01, 0xC0, 0x08, 0x00, 0x00, 0x1F, 0x01, 
				 0x00, 0x19, 0xC4, 0x02, 0x13, 0xEA, 0x00, 0x1E, 
				 0x00, 0xC0, 0xFF, 0x00, 0x00, 0x1E, 0x01, 0x0D, 
				 0x00, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 0xEA, 
				 0x00, 0x16, 0x02, 0x04, 0x00, 0x48, 0x13, 0xC0, 
				 0x00, 0x1E, 0x01, 0x00, 0x24, 0x00, 0x00, 0x19, 
				 0xC0, 0x00, 0x17, 0x4C, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x17, 0x6C, 0x00, 0x32, 0x00, 0x00, 0x00, 
				 0x13, 0xEA, 0x00, 0x1E, 0x00, 0xFF, 0xC0, 0x00, 
				 0x00, 0x1E, 0x01, 0x00, 0x0F, 0x00, 0x00, 0x1F, 
				 0x01, 0x00, 0x19, 0xEA, 0x00, 0x00, 0xC0};

BYTE t5465_Mode_640x400x24_3[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x16, 0x05, 0x04, 0x00, 0x00, 0x16, 0xC0, 0x00, 
				 0x00, 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 
				 0x00, 0x1F, 0x01, 0x00, 0x18, 0xC5, 0x02, 0x18, 
				 0x07, 0x04, 0x15, 0xA0, 0x00, 0xFF, 0x00, 0x09, 
				 0xCE, 0x03, 0x06, 0x05, 0x09, 0xCE, 0x03, 0x09, 
				 0x00, 0x09, 0xCE, 0x03, 0x0A, 0x00, 0x09, 0xCE, 
				 0x03, 0x0B, 0x00, 0x16, 0x80, 0x00, 0x6F, 0x00, 
				 0x16, 0x84, 0x00, 0x0B, 0x00, 0x16, 0x88, 0x00, 
				 0x16, 0x00, 0x1D, 0x19, 0x00, 0x00, 0x00, 0x63, 
				 0x00, 0x00, 0x00, 0x4F, 0x00, 0x00, 0x00, 0x4F, 
				 0x00, 0x00, 0x00, 0x83, 0x00, 0x00, 0x00, 0x55, 
				 0x00, 0x00, 0x00, 0x99, 0x00, 0x00, 0x00, 0xBB, 
				 0x00, 0x00, 0x00, 0x1F, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x90, 
				 0x00, 0x00, 0x00, 0x83, 0x00, 0x00, 0x00, 0x8F, 
				 0x00, 0x00, 0x00, 0x50, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x8F, 0x00, 0x00, 0x00, 0xBB, 
				 0x00, 0x00, 0x00, 0xE3, 0x00, 0x00, 0x00, 0xFF, 
				 0x00, 0x00, 0x00, 0x1D, 0x06, 0x00, 0x64, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x50, 0x00, 0x00, 0x00, 
				 0x22, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x16, 0x84, 0x00, 0x32, 0x00, 0x16, 0x88, 0x00, 
				 0x61, 0x00, 0x13, 0xEA, 0x00, 0x1E, 0x00, 0x00, 
				 0xC0, 0x00, 0x00, 0x1E, 0x01, 0x52, 0x10, 0x00, 
				 0x00, 0x1F, 0x01, 0x00, 0x19, 0xEA, 0x00, 0x12, 
				 0x07, 0x04, 0x1E, 0x00, 0xC0, 0x00, 0x00, 0x00, 
				 0x1E, 0x01, 0x08, 0x00, 0x00, 0x00, 0x18, 0x07, 
				 0x04, 0x13, 0xC4, 0x02, 0x1E, 0x00, 0x3F, 0xC0, 
				 0x00, 0x00, 0x1E, 0x01, 0xC0, 0x08, 0x00, 0x00, 
				 0x1F, 0x01, 0x00, 0x19, 0xC4, 0x02, 0x13, 0xEA, 
				 0x00, 0x1E, 0x00, 0xC0, 0xFF, 0x00, 0x00, 0x1E, 
				 0x01, 0x1E, 0x00, 0x00, 0x00, 0x1F, 0x01, 0x00, 
				 0x19, 0xEA, 0x00, 0x16, 0x02, 0x04, 0x00, 0x48, 
				 0x13, 0xC0, 0x00, 0x1E, 0x01, 0x00, 0x24, 0x00, 
				 0x00, 0x19, 0xC0, 0x00, 0x17, 0x4C, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x17, 0x6C, 0x00, 0x32, 0x00, 
				 0x00, 0x00, 0x13, 0xEA, 0x00, 0x1E, 0x00, 0xFF, 
				 0xC0, 0x00, 0x00, 0x1E, 0x01, 0x00, 0x0F, 0x00, 
				 0x00, 0x1F, 0x01, 0x00, 0x19, 0xEA, 0x00, 0x00, 0x00};

BYTE t5465_Mode_640x480x24_1[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x16, 0x05, 0x04, 0x00, 0x00, 0x16, 0xC0, 0x00, 
				 0x00, 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 
				 0x00, 0x1F, 0x01, 0x00, 0x18, 0xC5, 0x02, 0x18, 
				 0x07, 0x04, 0x15, 0xA0, 0x00, 0xFF, 0x00, 0x09, 
				 0xCE, 0x03, 0x06, 0x05, 0x09, 0xCE, 0x03, 0x09, 
				 0x00, 0x09, 0xCE, 0x03, 0x0A, 0x00, 0x09, 0xCE, 
				 0x03, 0x0B, 0x00, 0x16, 0x80, 0x00, 0xEF, 0x00, 
				 0x16, 0x84, 0x00, 0x3F, 0x00, 0x16, 0x88, 0x00, 
				 0x6D, 0x00, 0x1D, 0x19, 0x00, 0x00, 0x00, 0x5F, 
				 0x00, 0x00, 0x00, 0x4F, 0x00, 0x00, 0x00, 0x50, 
				 0x00, 0x00, 0x00, 0x9F, 0x00, 0x00, 0x00, 0x54, 
				 0x00, 0x00, 0x00, 0x1F, 0x00, 0x00, 0x00, 0x0B, 
				 0x00, 0x00, 0x00, 0x3E, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xE9, 
				 0x00, 0x00, 0x00, 0x8B, 0x00, 0x00, 0x00, 0xDF, 
				 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0xE7, 0x00, 0x00, 0x00, 0x04, 
				 0x00, 0x00, 0x00, 0xE3, 0x00, 0x00, 0x00, 0xFF, 
				 0x00, 0x00, 0x00, 0x1D, 0x06, 0x00, 0x64, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x90, 0x00, 0x00, 0x00, 
				 0x22, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x13, 0xEA, 0x00, 0x1E, 0x00, 0x00, 0xC0, 0x00, 
				 0x00, 0x1E, 0x01, 0x52, 0x10, 0x00, 0x00, 0x1F, 
				 0x01, 0x00, 0x19, 0xEA, 0x00, 0x12, 0x07, 0x04, 
				 0x1E, 0x00, 0xC0, 0x00, 0x00, 0x00, 0x1E, 0x01, 
				 0x08, 0x00, 0x00, 0x00, 0x18, 0x07, 0x04, 0x13, 
				 0xC4, 0x02, 0x1E, 0x00, 0x3F, 0xC0, 0x00, 0x00, 
				 0x1E, 0x01, 0xC0, 0x08, 0x00, 0x00, 0x1F, 0x01, 
				 0x00, 0x19, 0xC4, 0x02, 0x13, 0xEA, 0x00, 0x1E, 
				 0x00, 0xC0, 0xFF, 0x00, 0x00, 0x1E, 0x01, 0x11, 
				 0x00, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 0xEA, 
				 0x00, 0x16, 0x02, 0x04, 0x00, 0x48, 0x13, 0xC0, 
				 0x00, 0x1E, 0x01, 0x00, 0x24, 0x00, 0x00, 0x19, 
				 0xC0, 0x00, 0x17, 0x4C, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x17, 0x6C, 0x00, 0x32, 0x00, 0x00, 0x00, 
				 0x13, 0xEA, 0x00, 0x1E, 0x00, 0xFF, 0xC0, 0x00, 
				 0x00, 0x1E, 0x01, 0x00, 0x0F, 0x00, 0x00, 0x1F, 
				 0x01, 0x00, 0x19, 0xEA, 0x00, 0x00, 0x0F};

BYTE t5465_Mode_640x480x24_2[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x16, 0x05, 0x04, 0x00, 0x00, 0x16, 0xC0, 0x00, 
				 0x00, 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 
				 0x00, 0x1F, 0x01, 0x00, 0x18, 0xC5, 0x02, 0x18, 
				 0x07, 0x04, 0x15, 0xA0, 0x00, 0xFF, 0x00, 0x09, 
				 0xCE, 0x03, 0x06, 0x05, 0x09, 0xCE, 0x03, 0x09, 
				 0x00, 0x09, 0xCE, 0x03, 0x0A, 0x00, 0x09, 0xCE, 
				 0x03, 0x0B, 0x00, 0x16, 0x80, 0x00, 0xEF, 0x00, 
				 0x16, 0x84, 0x00, 0x0B, 0x00, 0x16, 0x88, 0x00, 
				 0x16, 0x00, 0x1D, 0x19, 0x00, 0x00, 0x00, 0x63, 
				 0x00, 0x00, 0x00, 0x4F, 0x00, 0x00, 0x00, 0x50, 
				 0x00, 0x00, 0x00, 0x82, 0x00, 0x00, 0x00, 0x54, 
				 0x00, 0x00, 0x00, 0x99, 0x00, 0x00, 0x00, 0x06, 
				 0x00, 0x00, 0x00, 0x3E, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xE8, 
				 0x00, 0x00, 0x00, 0x8B, 0x00, 0x00, 0x00, 0xDF, 
				 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0xE7, 0x00, 0x00, 0x00, 0xF3, 
				 0x00, 0x00, 0x00, 0xE3, 0x00, 0x00, 0x00, 0xFF, 
				 0x00, 0x00, 0x00, 0x1D, 0x06, 0x00, 0x64, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x50, 0x00, 0x00, 0x00, 
				 0x22, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x13, 0xEA, 0x00, 0x1E, 0x00, 0x00, 0xC0, 0x00, 
				 0x00, 0x1E, 0x01, 0x52, 0x10, 0x00, 0x00, 0x1F, 
				 0x01, 0x00, 0x19, 0xEA, 0x00, 0x12, 0x07, 0x04, 
				 0x1E, 0x00, 0xC0, 0x00, 0x00, 0x00, 0x1E, 0x01, 
				 0x08, 0x00, 0x00, 0x00, 0x18, 0x07, 0x04, 0x13, 
				 0xC4, 0x02, 0x1E, 0x00, 0x3F, 0xC0, 0x00, 0x00, 
				 0x1E, 0x01, 0xC0, 0x08, 0x00, 0x00, 0x1F, 0x01, 
				 0x00, 0x19, 0xC4, 0x02, 0x13, 0xEA, 0x00, 0x1E, 
				 0x00, 0xC0, 0xFF, 0x00, 0x00, 0x1E, 0x01, 0x11, 
				 0x00, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 0xEA, 
				 0x00, 0x16, 0x02, 0x04, 0x00, 0x48, 0x13, 0xC0, 
				 0x00, 0x1E, 0x01, 0x00, 0x24, 0x00, 0x00, 0x19, 
				 0xC0, 0x00, 0x17, 0x4C, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x17, 0x6C, 0x00, 0x32, 0x00, 0x00, 0x00, 
				 0x13, 0xEA, 0x00, 0x1E, 0x00, 0xFF, 0xC0, 0x00, 
				 0x00, 0x1E, 0x01, 0x00, 0x0F, 0x00, 0x00, 0x1F, 
				 0x01, 0x00, 0x19, 0xEA, 0x00, 0x00, 0x0F};

BYTE t5465_Mode_640x480x24_3[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x16, 0x05, 0x04, 0x00, 0x00, 0x16, 0xC0, 0x00, 
				 0x00, 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 
				 0x00, 0x1F, 0x01, 0x00, 0x18, 0xC5, 0x02, 0x18, 
				 0x07, 0x04, 0x15, 0xA0, 0x00, 0xFF, 0x00, 0x09, 
				 0xCE, 0x03, 0x06, 0x05, 0x09, 0xCE, 0x03, 0x09, 
				 0x00, 0x09, 0xCE, 0x03, 0x0A, 0x00, 0x09, 0xCE, 
				 0x03, 0x0B, 0x00, 0x16, 0x80, 0x00, 0xEF, 0x00, 
				 0x16, 0x84, 0x00, 0x0B, 0x00, 0x16, 0x88, 0x00, 
				 0x16, 0x00, 0x1D, 0x19, 0x00, 0x00, 0x00, 0x64, 
				 0x00, 0x00, 0x00, 0x4F, 0x00, 0x00, 0x00, 0x50, 
				 0x00, 0x00, 0x00, 0x82, 0x00, 0x00, 0x00, 0x54, 
				 0x00, 0x00, 0x00, 0x9B, 0x00, 0x00, 0x00, 0xF2, 
				 0x00, 0x00, 0x00, 0x1F, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xE0, 
				 0x00, 0x00, 0x00, 0x83, 0x00, 0x00, 0x00, 0xDF, 
				 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0xDF, 0x00, 0x00, 0x00, 0xF2, 
				 0x00, 0x00, 0x00, 0xE3, 0x00, 0x00, 0x00, 0xFF, 
				 0x00, 0x00, 0x00, 0x1D, 0x06, 0x00, 0x64, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x50, 0x00, 0x00, 0x00, 
				 0x22, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x13, 0xEA, 0x00, 0x1E, 0x00, 0x00, 0xC0, 0x00, 
				 0x00, 0x1E, 0x01, 0x52, 0x10, 0x00, 0x00, 0x1F, 
				 0x01, 0x00, 0x19, 0xEA, 0x00, 0x12, 0x07, 0x04, 
				 0x1E, 0x00, 0xC0, 0x00, 0x00, 0x00, 0x1E, 0x01, 
				 0x08, 0x00, 0x00, 0x00, 0x18, 0x07, 0x04, 0x13, 
				 0xC4, 0x02, 0x1E, 0x00, 0x3F, 0xC0, 0x00, 0x00, 
				 0x1E, 0x01, 0xC0, 0x08, 0x00, 0x00, 0x1F, 0x01, 
				 0x00, 0x19, 0xC4, 0x02, 0x13, 0xEA, 0x00, 0x1E, 
				 0x00, 0xC0, 0xFF, 0x00, 0x00, 0x1E, 0x01, 0x11, 
				 0x00, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 0xEA, 
				 0x00, 0x16, 0x02, 0x04, 0x00, 0x48, 0x13, 0xC0, 
				 0x00, 0x1E, 0x01, 0x00, 0x24, 0x00, 0x00, 0x19, 
				 0xC0, 0x00, 0x17, 0x4C, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x17, 0x6C, 0x00, 0x32, 0x00, 0x00, 0x00, 
				 0x13, 0xEA, 0x00, 0x1E, 0x00, 0xFF, 0xC0, 0x00, 
				 0x00, 0x1E, 0x01, 0x00, 0x0F, 0x00, 0x00, 0x1F, 
				 0x01, 0x00, 0x19, 0xEA, 0x00, 0x00, 0x0F};

BYTE t5465_Mode_640x480x24_4[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x16, 0x05, 0x04, 0x00, 0x00, 0x16, 0xC0, 0x00, 
				 0x00, 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 
				 0x00, 0x1F, 0x01, 0x00, 0x18, 0xC5, 0x02, 0x18, 
				 0x07, 0x04, 0x15, 0xA0, 0x00, 0xFF, 0x00, 0x09, 
				 0xCE, 0x03, 0x06, 0x05, 0x09, 0xCE, 0x03, 0x09, 
				 0x00, 0x09, 0xCE, 0x03, 0x0A, 0x00, 0x09, 0xCE, 
				 0x03, 0x0B, 0x00, 0x16, 0x80, 0x00, 0xEF, 0x00, 
				 0x16, 0x84, 0x00, 0x33, 0x00, 0x16, 0x88, 0x00, 
				 0x7E, 0x00, 0x1D, 0x19, 0x00, 0x00, 0x00, 0x63, 
				 0x00, 0x00, 0x00, 0x4F, 0x00, 0x00, 0x00, 0x50, 
				 0x00, 0x00, 0x00, 0x82, 0x00, 0x00, 0x00, 0x55, 
				 0x00, 0x00, 0x00, 0x9B, 0x00, 0x00, 0x00, 0xFB, 
				 0x00, 0x00, 0x00, 0x1F, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xE0, 
				 0x00, 0x00, 0x00, 0x83, 0x00, 0x00, 0x00, 0xDF, 
				 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0xDF, 0x00, 0x00, 0x00, 0xF9, 
				 0x00, 0x00, 0x00, 0xE3, 0x00, 0x00, 0x00, 0xFF, 
				 0x00, 0x00, 0x00, 0x1D, 0x06, 0x00, 0x64, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x50, 0x00, 0x00, 0x00, 
				 0x22, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x13, 0xEA, 0x00, 0x1E, 0x00, 0x00, 0xC0, 0x00, 
				 0x00, 0x1E, 0x01, 0x52, 0x10, 0x00, 0x00, 0x1F, 
				 0x01, 0x00, 0x19, 0xEA, 0x00, 0x12, 0x07, 0x04, 
				 0x1E, 0x00, 0xC0, 0x00, 0x00, 0x00, 0x1E, 0x01, 
				 0x08, 0x00, 0x00, 0x00, 0x18, 0x07, 0x04, 0x13, 
				 0xC4, 0x02, 0x1E, 0x00, 0x3F, 0xC0, 0x00, 0x00, 
				 0x1E, 0x01, 0xC0, 0x08, 0x00, 0x00, 0x1F, 0x01, 
				 0x00, 0x19, 0xC4, 0x02, 0x13, 0xEA, 0x00, 0x1E, 
				 0x00, 0xC0, 0xFF, 0x00, 0x00, 0x1E, 0x01, 0x11, 
				 0x00, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 0xEA, 
				 0x00, 0x16, 0x02, 0x04, 0x00, 0x48, 0x13, 0xC0, 
				 0x00, 0x1E, 0x01, 0x00, 0x24, 0x00, 0x00, 0x19, 
				 0xC0, 0x00, 0x17, 0x4C, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x17, 0x6C, 0x00, 0x32, 0x00, 0x00, 0x00, 
				 0x13, 0xEA, 0x00, 0x1E, 0x00, 0xFF, 0xC0, 0x00, 
				 0x00, 0x1E, 0x01, 0x00, 0x0F, 0x00, 0x00, 0x1F, 
				 0x01, 0x00, 0x19, 0xEA, 0x00, 0x00, 0x0F};

BYTE t5465_Mode_800x600x24_1[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x16, 0x05, 0x04, 0x00, 0x00, 0x16, 0xC0, 0x00, 
				 0x00, 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 
				 0x00, 0x1F, 0x01, 0x00, 0x18, 0xC5, 0x02, 0x18, 
				 0x07, 0x04, 0x15, 0xA0, 0x00, 0xFF, 0x00, 0x09, 
				 0xCE, 0x03, 0x06, 0x05, 0x09, 0xCE, 0x03, 0x09, 
				 0x00, 0x09, 0xCE, 0x03, 0x0A, 0x00, 0x09, 0xCE, 
				 0x03, 0x0B, 0x00, 0x16, 0x80, 0x00, 0x2F, 0x00, 
				 0x16, 0x84, 0x00, 0x33, 0x00, 0x16, 0x88, 0x00, 
				 0x7E, 0x00, 0x1D, 0x19, 0x00, 0x00, 0x00, 0x7B, 
				 0x00, 0x00, 0x00, 0x63, 0x00, 0x00, 0x00, 0x64, 
				 0x00, 0x00, 0x00, 0x9B, 0x00, 0x00, 0x00, 0x68, 
				 0x00, 0x00, 0x00, 0x91, 0x00, 0x00, 0x00, 0x6F, 
				 0x00, 0x00, 0x00, 0xF0, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x60, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x58, 
				 0x00, 0x00, 0x00, 0x8A, 0x00, 0x00, 0x00, 0x57, 
				 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x58, 0x00, 0x00, 0x00, 0x6F, 
				 0x00, 0x00, 0x00, 0xE3, 0x00, 0x00, 0x00, 0xFF, 
				 0x00, 0x00, 0x00, 0x1D, 0x06, 0x00, 0x64, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x90, 0x00, 0x00, 0x00, 
				 0x22, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x13, 0xEA, 0x00, 0x1E, 0x00, 0x00, 0xC0, 0x00, 
				 0x00, 0x1E, 0x01, 0x56, 0x14, 0x00, 0x00, 0x1F, 
				 0x01, 0x00, 0x19, 0xEA, 0x00, 0x12, 0x07, 0x04, 
				 0x1E, 0x00, 0xC0, 0x00, 0x00, 0x00, 0x1E, 0x01, 
				 0x0A, 0x00, 0x00, 0x00, 0x18, 0x07, 0x04, 0x13, 
				 0xC4, 0x02, 0x1E, 0x00, 0x3F, 0xC0, 0x00, 0x00, 
				 0x1E, 0x01, 0xC0, 0x0A, 0x00, 0x00, 0x1F, 0x01, 
				 0x00, 0x19, 0xC4, 0x02, 0x13, 0xEA, 0x00, 0x1E, 
				 0x00, 0xC0, 0xFF, 0x00, 0x00, 0x1E, 0x01, 0x19, 
				 0x00, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 0xEA, 
				 0x00, 0x16, 0x02, 0x04, 0x00, 0x48, 0x13, 0xC0, 
				 0x00, 0x1E, 0x01, 0x00, 0x24, 0x00, 0x00, 0x19, 
				 0xC0, 0x00, 0x17, 0x4C, 0x00, 0x40, 0x00, 0x00, 
				 0x00, 0x17, 0x6C, 0x00, 0x32, 0x00, 0x00, 0x00, 
				 0x13, 0xEA, 0x00, 0x1E, 0x00, 0xFF, 0xC0, 0x00, 
				 0x00, 0x1E, 0x01, 0x00, 0x13, 0x00, 0x00, 0x1F, 
				 0x01, 0x00, 0x19, 0xEA, 0x00, 0x00, 0x0F};

BYTE t5465_Mode_800x600x24_2[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x16, 0x05, 0x04, 0x00, 0x00, 0x16, 0xC0, 0x00, 
				 0x00, 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 
				 0x00, 0x1F, 0x01, 0x00, 0x18, 0xC5, 0x02, 0x18, 
				 0x07, 0x04, 0x15, 0xA0, 0x00, 0xFF, 0x00, 0x09, 
				 0xCE, 0x03, 0x06, 0x05, 0x09, 0xCE, 0x03, 0x09, 
				 0x00, 0x09, 0xCE, 0x03, 0x0A, 0x00, 0x09, 0xCE, 
				 0x03, 0x0B, 0x00, 0x16, 0x80, 0x00, 0x2F, 0x00, 
				 0x16, 0x84, 0x00, 0x23, 0x00, 0x16, 0x88, 0x00, 
				 0x5F, 0x00, 0x1D, 0x19, 0x00, 0x00, 0x00, 0x7F, 
				 0x00, 0x00, 0x00, 0x63, 0x00, 0x00, 0x00, 0x64, 
				 0x00, 0x00, 0x00, 0x9F, 0x00, 0x00, 0x00, 0x6A, 
				 0x00, 0x00, 0x00, 0x9A, 0x00, 0x00, 0x00, 0x72, 
				 0x00, 0x00, 0x00, 0xF0, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x60, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x58, 
				 0x00, 0x00, 0x00, 0x8C, 0x00, 0x00, 0x00, 0x57, 
				 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x58, 0x00, 0x00, 0x00, 0x70, 
				 0x00, 0x00, 0x00, 0xE3, 0x00, 0x00, 0x00, 0xFF, 
				 0x00, 0x00, 0x00, 0x1D, 0x06, 0x00, 0x64, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x90, 0x00, 0x00, 0x00, 
				 0x22, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x13, 0xEA, 0x00, 0x1E, 0x00, 0x00, 0xC0, 0x00, 
				 0x00, 0x1E, 0x01, 0x56, 0x14, 0x00, 0x00, 0x1F, 
				 0x01, 0x00, 0x19, 0xEA, 0x00, 0x12, 0x07, 0x04, 
				 0x1E, 0x00, 0xC0, 0x00, 0x00, 0x00, 0x1E, 0x01, 
				 0x0A, 0x00, 0x00, 0x00, 0x18, 0x07, 0x04, 0x13, 
				 0xC4, 0x02, 0x1E, 0x00, 0x3F, 0xC0, 0x00, 0x00, 
				 0x1E, 0x01, 0xC0, 0x0A, 0x00, 0x00, 0x1F, 0x01, 
				 0x00, 0x19, 0xC4, 0x02, 0x13, 0xEA, 0x00, 0x1E, 
				 0x00, 0xC0, 0xFF, 0x00, 0x00, 0x1E, 0x01, 0x19, 
				 0x00, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 0xEA, 
				 0x00, 0x16, 0x02, 0x04, 0x00, 0x48, 0x13, 0xC0, 
				 0x00, 0x1E, 0x01, 0x00, 0x24, 0x00, 0x00, 0x19, 
				 0xC0, 0x00, 0x17, 0x4C, 0x00, 0x40, 0x00, 0x00, 
				 0x00, 0x17, 0x6C, 0x00, 0x32, 0x00, 0x00, 0x00, 
				 0x13, 0xEA, 0x00, 0x1E, 0x00, 0xFF, 0xC0, 0x00, 
				 0x00, 0x1E, 0x01, 0x00, 0x13, 0x00, 0x00, 0x1F, 
				 0x01, 0x00, 0x19, 0xEA, 0x00, 0x00, 0x0F};

BYTE t5465_Mode_800x600x24_3[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x16, 0x05, 0x04, 0x00, 0x00, 0x16, 0xC0, 0x00, 
				 0x00, 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 
				 0x00, 0x1F, 0x01, 0x00, 0x18, 0xC5, 0x02, 0x18, 
				 0x07, 0x04, 0x15, 0xA0, 0x00, 0xFF, 0x00, 0x09, 
				 0xCE, 0x03, 0x06, 0x05, 0x09, 0xCE, 0x03, 0x09, 
				 0x00, 0x09, 0xCE, 0x03, 0x0A, 0x00, 0x09, 0xCE, 
				 0x03, 0x0B, 0x00, 0x16, 0x80, 0x00, 0x2F, 0x00, 
				 0x16, 0x84, 0x00, 0x25, 0x00, 0x16, 0x88, 0x00, 
				 0x7D, 0x00, 0x1D, 0x19, 0x00, 0x00, 0x00, 0x7D, 
				 0x00, 0x00, 0x00, 0x63, 0x00, 0x00, 0x00, 0x64, 
				 0x00, 0x00, 0x00, 0x9D, 0x00, 0x00, 0x00, 0x6C, 
				 0x00, 0x00, 0x00, 0x9B, 0x00, 0x00, 0x00, 0x97, 
				 0x00, 0x00, 0x00, 0xF0, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x60, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7C, 
				 0x00, 0x00, 0x00, 0x82, 0x00, 0x00, 0x00, 0x57, 
				 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x5F, 0x00, 0x00, 0x00, 0x97, 
				 0x00, 0x00, 0x00, 0xE3, 0x00, 0x00, 0x00, 0xFF, 
				 0x00, 0x00, 0x00, 0x1D, 0x06, 0x00, 0x64, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x90, 0x00, 0x00, 0x00, 
				 0x22, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x13, 0xEA, 0x00, 0x1E, 0x00, 0x00, 0xC0, 0x00, 
				 0x00, 0x1E, 0x01, 0x56, 0x14, 0x00, 0x00, 0x1F, 
				 0x01, 0x00, 0x19, 0xEA, 0x00, 0x12, 0x07, 0x04, 
				 0x1E, 0x00, 0xC0, 0x00, 0x00, 0x00, 0x1E, 0x01, 
				 0x0A, 0x00, 0x00, 0x00, 0x18, 0x07, 0x04, 0x13, 
				 0xC4, 0x02, 0x1E, 0x00, 0x3F, 0xC0, 0x00, 0x00, 
				 0x1E, 0x01, 0xC0, 0x0A, 0x00, 0x00, 0x1F, 0x01, 
				 0x00, 0x19, 0xC4, 0x02, 0x13, 0xEA, 0x00, 0x1E, 
				 0x00, 0xC0, 0xFF, 0x00, 0x00, 0x1E, 0x01, 0x19, 
				 0x00, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 0xEA, 
				 0x00, 0x16, 0x02, 0x04, 0x00, 0x48, 0x13, 0xC0, 
				 0x00, 0x1E, 0x01, 0x00, 0x24, 0x00, 0x00, 0x19, 
				 0xC0, 0x00, 0x17, 0x4C, 0x00, 0x40, 0x00, 0x00, 
				 0x00, 0x17, 0x6C, 0x00, 0x32, 0x00, 0x00, 0x00, 
				 0x13, 0xEA, 0x00, 0x1E, 0x00, 0xFF, 0xC0, 0x00, 
				 0x00, 0x1E, 0x01, 0x00, 0x13, 0x00, 0x00, 0x1F, 
				 0x01, 0x00, 0x19, 0xEA, 0x00, 0x00, 0x0F};

BYTE t5465_Mode_800x600x24_4[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x16, 0x05, 0x04, 0x00, 0x00, 0x16, 0xC0, 0x00, 
				 0x00, 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 
				 0x00, 0x1F, 0x01, 0x00, 0x18, 0xC5, 0x02, 0x18, 
				 0x07, 0x04, 0x15, 0xA0, 0x00, 0xFF, 0x00, 0x09, 
				 0xCE, 0x03, 0x06, 0x05, 0x09, 0xCE, 0x03, 0x09, 
				 0x00, 0x09, 0xCE, 0x03, 0x0A, 0x00, 0x09, 0xCE, 
				 0x03, 0x0B, 0x00, 0x16, 0x80, 0x00, 0x2F, 0x00, 
				 0x16, 0x84, 0x00, 0x19, 0x00, 0x16, 0x88, 0x00, 
				 0x53, 0x00, 0x1D, 0x19, 0x00, 0x00, 0x00, 0x7F, 
				 0x00, 0x00, 0x00, 0x63, 0x00, 0x00, 0x00, 0x64, 
				 0x00, 0x00, 0x00, 0x9F, 0x00, 0x00, 0x00, 0x67, 
				 0x00, 0x00, 0x00, 0x91, 0x00, 0x00, 0x00, 0x6F, 
				 0x00, 0x00, 0x00, 0xF0, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x60, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x58, 
				 0x00, 0x00, 0x00, 0x8B, 0x00, 0x00, 0x00, 0x57, 
				 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x57, 0x00, 0x00, 0x00, 0x6F, 
				 0x00, 0x00, 0x00, 0xE3, 0x00, 0x00, 0x00, 0xFF, 
				 0x00, 0x00, 0x00, 0x1D, 0x06, 0x00, 0x64, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x90, 0x00, 0x00, 0x00, 
				 0x22, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x13, 0xEA, 0x00, 0x1E, 0x00, 0x00, 0xC0, 0x00, 
				 0x00, 0x1E, 0x01, 0x56, 0x14, 0x00, 0x00, 0x1F, 
				 0x01, 0x00, 0x19, 0xEA, 0x00, 0x12, 0x07, 0x04, 
				 0x1E, 0x00, 0xC0, 0x00, 0x00, 0x00, 0x1E, 0x01, 
				 0x0A, 0x00, 0x00, 0x00, 0x18, 0x07, 0x04, 0x13, 
				 0xC4, 0x02, 0x1E, 0x00, 0x3F, 0xC0, 0x00, 0x00, 
				 0x1E, 0x01, 0xC0, 0x0A, 0x00, 0x00, 0x1F, 0x01, 
				 0x00, 0x19, 0xC4, 0x02, 0x13, 0xEA, 0x00, 0x1E, 
				 0x00, 0xC0, 0xFF, 0x00, 0x00, 0x1E, 0x01, 0x19, 
				 0x00, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 0xEA, 
				 0x00, 0x16, 0x02, 0x04, 0x00, 0x48, 0x13, 0xC0, 
				 0x00, 0x1E, 0x01, 0x00, 0x24, 0x00, 0x00, 0x19, 
				 0xC0, 0x00, 0x17, 0x4C, 0x00, 0x40, 0x00, 0x00, 
				 0x00, 0x17, 0x6C, 0x00, 0x32, 0x00, 0x00, 0x00, 
				 0x13, 0xEA, 0x00, 0x1E, 0x00, 0xFF, 0xC0, 0x00, 
				 0x00, 0x1E, 0x01, 0x00, 0x13, 0x00, 0x00, 0x1F, 
				 0x01, 0x00, 0x19, 0xEA, 0x00, 0x00, 0x0F};

BYTE t5465_Mode_800x600x24_5[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x16, 0x05, 0x04, 0x00, 0x00, 0x16, 0xC0, 0x00, 
				 0x00, 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 
				 0x00, 0x1F, 0x01, 0x00, 0x18, 0xC5, 0x02, 0x18, 
				 0x07, 0x04, 0x15, 0xA0, 0x00, 0xFF, 0x00, 0x09, 
				 0xCE, 0x03, 0x06, 0x05, 0x09, 0xCE, 0x03, 0x09, 
				 0x00, 0x09, 0xCE, 0x03, 0x0A, 0x00, 0x09, 0xCE, 
				 0x03, 0x0B, 0x00, 0x16, 0x80, 0x00, 0x2F, 0x00, 
				 0x16, 0x84, 0x00, 0x1C, 0x00, 0x16, 0x88, 0x00, 
				 0x37, 0x00, 0x1D, 0x19, 0x00, 0x00, 0x00, 0x7E, 
				 0x00, 0x00, 0x00, 0x63, 0x00, 0x00, 0x00, 0x64, 
				 0x00, 0x00, 0x00, 0x9E, 0x00, 0x00, 0x00, 0x69, 
				 0x00, 0x00, 0x00, 0x91, 0x00, 0x00, 0x00, 0x75, 
				 0x00, 0x00, 0x00, 0xF0, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x60, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x58, 
				 0x00, 0x00, 0x00, 0x8B, 0x00, 0x00, 0x00, 0x57, 
				 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x57, 0x00, 0x00, 0x00, 0x75, 
				 0x00, 0x00, 0x00, 0xE3, 0x00, 0x00, 0x00, 0xFF, 
				 0x00, 0x00, 0x00, 0x1D, 0x06, 0x00, 0x64, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x90, 0x00, 0x00, 0x00, 
				 0x22, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x13, 0xEA, 0x00, 0x1E, 0x00, 0x00, 0xC0, 0x00, 
				 0x00, 0x1E, 0x01, 0x56, 0x14, 0x00, 0x00, 0x1F, 
				 0x01, 0x00, 0x19, 0xEA, 0x00, 0x12, 0x07, 0x04, 
				 0x1E, 0x00, 0xC0, 0x00, 0x00, 0x00, 0x1E, 0x01, 
				 0x0A, 0x00, 0x00, 0x00, 0x18, 0x07, 0x04, 0x13, 
				 0xC4, 0x02, 0x1E, 0x00, 0x3F, 0xC0, 0x00, 0x00, 
				 0x1E, 0x01, 0xC0, 0x0A, 0x00, 0x00, 0x1F, 0x01, 
				 0x00, 0x19, 0xC4, 0x02, 0x13, 0xEA, 0x00, 0x1E, 
				 0x00, 0xC0, 0xFF, 0x00, 0x00, 0x1E, 0x01, 0x19, 
				 0x00, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 0xEA, 
				 0x00, 0x16, 0x02, 0x04, 0x00, 0x48, 0x13, 0xC0, 
				 0x00, 0x1E, 0x01, 0x00, 0x24, 0x00, 0x00, 0x19, 
				 0xC0, 0x00, 0x17, 0x4C, 0x00, 0x40, 0x00, 0x00, 
				 0x00, 0x17, 0x6C, 0x00, 0x32, 0x00, 0x00, 0x00, 
				 0x13, 0xEA, 0x00, 0x1E, 0x00, 0xFF, 0xC0, 0x00, 
				 0x00, 0x1E, 0x01, 0x00, 0x13, 0x00, 0x00, 0x1F, 
				 0x01, 0x00, 0x19, 0xEA, 0x00, 0x00, 0x0F};

BYTE t5465_Mode_1024x768x24_1[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x16, 0x05, 0x04, 0x00, 0x00, 0x16, 0xC0, 0x00, 
				 0x00, 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 
				 0x00, 0x1F, 0x01, 0x00, 0x18, 0xC5, 0x02, 0x18, 
				 0x07, 0x04, 0x15, 0xA0, 0x00, 0xFF, 0x00, 0x09, 
				 0xCE, 0x03, 0x06, 0x05, 0x09, 0xCE, 0x03, 0x09, 
				 0x00, 0x09, 0xCE, 0x03, 0x0A, 0x00, 0x09, 0xCE, 
				 0x03, 0x0B, 0x00, 0x16, 0x80, 0x00, 0x2F, 0x00, 
				 0x16, 0x84, 0x00, 0x17, 0x00, 0x16, 0x88, 0x00, 
				 0x45, 0x00, 0x1D, 0x19, 0x00, 0x00, 0x00, 0x99, 
				 0x00, 0x00, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x80, 
				 0x00, 0x00, 0x00, 0x99, 0x00, 0x00, 0x00, 0x82, 
				 0x00, 0x00, 0x00, 0x18, 0x00, 0x00, 0x00, 0x96, 
				 0x00, 0x00, 0x00, 0x1F, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7F, 
				 0x00, 0x00, 0x00, 0x83, 0x00, 0x00, 0x00, 0x7F, 
				 0x00, 0x00, 0x00, 0xA0, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x96, 
				 0x00, 0x00, 0x00, 0xE3, 0x00, 0x00, 0x00, 0xFF, 
				 0x00, 0x00, 0x00, 0x1D, 0x06, 0x00, 0x64, 0x00, 
				 0x48, 0x00, 0x00, 0x00, 0x51, 0x00, 0x00, 0x00, 
				 0x22, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x13, 0xEA, 0x00, 0x1E, 0x00, 0x00, 0xC0, 0x00, 
				 0x00, 0x1E, 0x01, 0x59, 0x1A, 0x00, 0x00, 0x1F, 
				 0x01, 0x00, 0x19, 0xEA, 0x00, 0x12, 0x07, 0x04, 
				 0x1E, 0x00, 0xC0, 0x00, 0x00, 0x00, 0x1E, 0x01, 
				 0x0D, 0x00, 0x00, 0x00, 0x18, 0x07, 0x04, 0x13, 
				 0xC4, 0x02, 0x1E, 0x00, 0x3F, 0xC0, 0x00, 0x00, 
				 0x1E, 0x01, 0xC0, 0x0D, 0x00, 0x00, 0x1F, 0x01, 
				 0x00, 0x19, 0xC4, 0x02, 0x13, 0xEA, 0x00, 0x1E, 
				 0x00, 0xC0, 0xFF, 0x00, 0x00, 0x1E, 0x01, 0x1D, 
				 0x00, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 0xEA, 
				 0x00, 0x16, 0x02, 0x04, 0x00, 0x48, 0x13, 0xC0, 
				 0x00, 0x1E, 0x01, 0x00, 0x24, 0x00, 0x00, 0x19, 
				 0xC0, 0x00, 0x17, 0x4C, 0x00, 0xA0, 0x00, 0x00, 
				 0x00, 0x17, 0x6C, 0x00, 0x32, 0x00, 0x00, 0x00, 
				 0x13, 0xEA, 0x00, 0x1E, 0x00, 0xFF, 0xC0, 0x00, 
				 0x00, 0x1E, 0x01, 0x00, 0x18, 0x00, 0x00, 0x1F, 
				 0x01, 0x00, 0x19, 0xEA, 0x00, 0x00, 0x0F};

BYTE t5465_Mode_1024x768x24_2[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x16, 0x05, 0x04, 0x00, 0x00, 0x16, 0xC0, 0x00, 
				 0x00, 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 
				 0x00, 0x1F, 0x01, 0x00, 0x18, 0xC5, 0x02, 0x18, 
				 0x07, 0x04, 0x15, 0xA0, 0x00, 0xFF, 0x00, 0x09, 
				 0xCE, 0x03, 0x06, 0x05, 0x09, 0xCE, 0x03, 0x09, 
				 0x00, 0x09, 0xCE, 0x03, 0x0A, 0x00, 0x09, 0xCE, 
				 0x03, 0x0B, 0x00, 0x16, 0x80, 0x00, 0xEF, 0x00, 
				 0x16, 0x84, 0x00, 0x1A, 0x00, 0x16, 0x88, 0x00, 
				 0x3B, 0x00, 0x1D, 0x19, 0x00, 0x00, 0x00, 0xA3, 
				 0x00, 0x00, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x80, 
				 0x00, 0x00, 0x00, 0x83, 0x00, 0x00, 0x00, 0x84, 
				 0x00, 0x00, 0x00, 0x95, 0x00, 0x00, 0x00, 0x24, 
				 0x00, 0x00, 0x00, 0xFD, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x60, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 
				 0x00, 0x00, 0x00, 0x88, 0x00, 0x00, 0x00, 0xFF, 
				 0x00, 0x00, 0x00, 0xA0, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x24, 
				 0x00, 0x00, 0x00, 0xE3, 0x00, 0x00, 0x00, 0xFF, 
				 0x00, 0x00, 0x00, 0x1D, 0x06, 0x00, 0x64, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0xE0, 0x00, 0x00, 0x00, 
				 0x22, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x13, 0xEA, 0x00, 0x1E, 0x00, 0x00, 0xC0, 0x00, 
				 0x00, 0x1E, 0x01, 0x59, 0x1A, 0x00, 0x00, 0x1F, 
				 0x01, 0x00, 0x19, 0xEA, 0x00, 0x12, 0x07, 0x04, 
				 0x1E, 0x00, 0xC0, 0x00, 0x00, 0x00, 0x1E, 0x01, 
				 0x0D, 0x00, 0x00, 0x00, 0x18, 0x07, 0x04, 0x13, 
				 0xC4, 0x02, 0x1E, 0x00, 0x3F, 0xC0, 0x00, 0x00, 
				 0x1E, 0x01, 0xC0, 0x0D, 0x00, 0x00, 0x1F, 0x01, 
				 0x00, 0x19, 0xC4, 0x02, 0x13, 0xEA, 0x00, 0x1E, 
				 0x00, 0xC0, 0xFF, 0x00, 0x00, 0x1E, 0x01, 0x1D, 
				 0x00, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 0xEA, 
				 0x00, 0x16, 0x02, 0x04, 0x00, 0x48, 0x13, 0xC0, 
				 0x00, 0x1E, 0x01, 0x00, 0x24, 0x00, 0x00, 0x19, 
				 0xC0, 0x00, 0x17, 0x4C, 0x00, 0xA0, 0x00, 0x00, 
				 0x00, 0x17, 0x6C, 0x00, 0x32, 0x00, 0x00, 0x00, 
				 0x13, 0xEA, 0x00, 0x1E, 0x00, 0xFF, 0xC0, 0x00, 
				 0x00, 0x1E, 0x01, 0x00, 0x18, 0x00, 0x00, 0x1F, 
				 0x01, 0x00, 0x19, 0xEA, 0x00, 0x00, 0x0F};

BYTE t5465_Mode_1024x768x24_3[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x16, 0x05, 0x04, 0x00, 0x00, 0x16, 0xC0, 0x00, 
				 0x00, 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 
				 0x00, 0x1F, 0x01, 0x00, 0x18, 0xC5, 0x02, 0x18, 
				 0x07, 0x04, 0x15, 0xA0, 0x00, 0xFF, 0x00, 0x09, 
				 0xCE, 0x03, 0x06, 0x05, 0x09, 0xCE, 0x03, 0x09, 
				 0x00, 0x09, 0xCE, 0x03, 0x0A, 0x00, 0x09, 0xCE, 
				 0x03, 0x0B, 0x00, 0x16, 0x80, 0x00, 0xEF, 0x00, 
				 0x16, 0x84, 0x00, 0x2A, 0x00, 0x16, 0x88, 0x00, 
				 0x6E, 0x00, 0x1D, 0x19, 0x00, 0x00, 0x00, 0xA1, 
				 0x00, 0x00, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x80, 
				 0x00, 0x00, 0x00, 0x81, 0x00, 0x00, 0x00, 0x84, 
				 0x00, 0x00, 0x00, 0x95, 0x00, 0x00, 0x00, 0x24, 
				 0x00, 0x00, 0x00, 0xFD, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x60, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 
				 0x00, 0x00, 0x00, 0x88, 0x00, 0x00, 0x00, 0xFF, 
				 0x00, 0x00, 0x00, 0xA0, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x24, 
				 0x00, 0x00, 0x00, 0xE3, 0x00, 0x00, 0x00, 0xFF, 
				 0x00, 0x00, 0x00, 0x1D, 0x06, 0x00, 0x64, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0xE0, 0x00, 0x00, 0x00, 
				 0x22, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x13, 0xEA, 0x00, 0x1E, 0x00, 0x00, 0xC0, 0x00, 
				 0x00, 0x1E, 0x01, 0x59, 0x1A, 0x00, 0x00, 0x1F, 
				 0x01, 0x00, 0x19, 0xEA, 0x00, 0x12, 0x07, 0x04, 
				 0x1E, 0x00, 0xC0, 0x00, 0x00, 0x00, 0x1E, 0x01, 
				 0x0D, 0x00, 0x00, 0x00, 0x18, 0x07, 0x04, 0x13, 
				 0xC4, 0x02, 0x1E, 0x00, 0x3F, 0xC0, 0x00, 0x00, 
				 0x1E, 0x01, 0xC0, 0x0D, 0x00, 0x00, 0x1F, 0x01, 
				 0x00, 0x19, 0xC4, 0x02, 0x13, 0xEA, 0x00, 0x1E, 
				 0x00, 0xC0, 0xFF, 0x00, 0x00, 0x1E, 0x01, 0x1F, 
				 0x00, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 0xEA, 
				 0x00, 0x16, 0x02, 0x04, 0x00, 0x48, 0x13, 0xC0, 
				 0x00, 0x1E, 0x01, 0x00, 0x24, 0x00, 0x00, 0x19, 
				 0xC0, 0x00, 0x17, 0x4C, 0x00, 0xA0, 0x00, 0x00, 
				 0x00, 0x17, 0x6C, 0x00, 0x32, 0x00, 0x00, 0x00, 
				 0x13, 0xEA, 0x00, 0x1E, 0x00, 0xFF, 0xC0, 0x00, 
				 0x00, 0x1E, 0x01, 0x00, 0x18, 0x00, 0x00, 0x1F, 
				 0x01, 0x00, 0x19, 0xEA, 0x00, 0x00, 0x0F};

BYTE t5465_Mode_1024x768x24_4[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x16, 0x05, 0x04, 0x00, 0x00, 0x16, 0xC0, 0x00, 
				 0x00, 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 
				 0x00, 0x1F, 0x01, 0x00, 0x18, 0xC5, 0x02, 0x18, 
				 0x07, 0x04, 0x15, 0xA0, 0x00, 0xFF, 0x00, 0x09, 
				 0xCE, 0x03, 0x06, 0x05, 0x09, 0xCE, 0x03, 0x09, 
				 0x00, 0x09, 0xCE, 0x03, 0x0A, 0x00, 0x09, 0xCE, 
				 0x03, 0x0B, 0x00, 0x16, 0x80, 0x00, 0x2F, 0x00, 
				 0x16, 0x84, 0x00, 0x10, 0x00, 0x16, 0x88, 0x00, 
				 0x2C, 0x00, 0x1D, 0x19, 0x00, 0x00, 0x00, 0x9F, 
				 0x00, 0x00, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x80, 
				 0x00, 0x00, 0x00, 0x9F, 0x00, 0x00, 0x00, 0x83, 
				 0x00, 0x00, 0x00, 0x0F, 0x00, 0x00, 0x00, 0x1E, 
				 0x00, 0x00, 0x00, 0xF5, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x60, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x83, 0x00, 0x00, 0x00, 0xFF, 
				 0x00, 0x00, 0x00, 0xA0, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 0x1E, 
				 0x00, 0x00, 0x00, 0xE3, 0x00, 0x00, 0x00, 0xFF, 
				 0x00, 0x00, 0x00, 0x1D, 0x06, 0x00, 0x64, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0xE0, 0x00, 0x00, 0x00, 
				 0x22, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x13, 0xEA, 0x00, 0x1E, 0x00, 0x00, 0xC0, 0x00, 
				 0x00, 0x1E, 0x01, 0x59, 0x1A, 0x00, 0x00, 0x1F, 
				 0x01, 0x00, 0x19, 0xEA, 0x00, 0x12, 0x07, 0x04, 
				 0x1E, 0x00, 0xC0, 0x00, 0x00, 0x00, 0x1E, 0x01, 
				 0x0D, 0x00, 0x00, 0x00, 0x18, 0x07, 0x04, 0x13, 
				 0xC4, 0x02, 0x1E, 0x00, 0x3F, 0xC0, 0x00, 0x00, 
				 0x1E, 0x01, 0xC0, 0x0D, 0x00, 0x00, 0x1F, 0x01, 
				 0x00, 0x19, 0xC4, 0x02, 0x13, 0xEA, 0x00, 0x1E, 
				 0x00, 0xC0, 0xFF, 0x00, 0x00, 0x1E, 0x01, 0x27, 
				 0x00, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 0xEA, 
				 0x00, 0x16, 0x02, 0x04, 0x00, 0x48, 0x13, 0xC0, 
				 0x00, 0x1E, 0x01, 0x00, 0x24, 0x00, 0x00, 0x19, 
				 0xC0, 0x00, 0x17, 0x4C, 0x00, 0xA0, 0x00, 0x00, 
				 0x00, 0x17, 0x6C, 0x00, 0x32, 0x00, 0x00, 0x00, 
				 0x13, 0xEA, 0x00, 0x1E, 0x00, 0xFF, 0xC0, 0x00, 
				 0x00, 0x1E, 0x01, 0x00, 0x18, 0x00, 0x00, 0x1F, 
				 0x01, 0x00, 0x19, 0xEA, 0x00, 0x00, 0x0F};

BYTE t5465_Mode_1024x768x24_5[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x16, 0x05, 0x04, 0x00, 0x00, 0x16, 0xC0, 0x00, 
				 0x00, 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 
				 0x00, 0x1F, 0x01, 0x00, 0x18, 0xC5, 0x02, 0x18, 
				 0x07, 0x04, 0x15, 0xA0, 0x00, 0xFF, 0x00, 0x09, 
				 0xCE, 0x03, 0x06, 0x05, 0x09, 0xCE, 0x03, 0x09, 
				 0x00, 0x09, 0xCE, 0x03, 0x0A, 0x00, 0x09, 0xCE, 
				 0x03, 0x0B, 0x00, 0x16, 0x80, 0x00, 0x2F, 0x00, 
				 0x16, 0x84, 0x00, 0x0A, 0x00, 0x16, 0x88, 0x00, 
				 0x21, 0x00, 0x1D, 0x19, 0x00, 0x00, 0x00, 0xA7, 
				 0x00, 0x00, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x80, 
				 0x00, 0x00, 0x00, 0x87, 0x00, 0x00, 0x00, 0x87, 
				 0x00, 0x00, 0x00, 0x93, 0x00, 0x00, 0x00, 0x26, 
				 0x00, 0x00, 0x00, 0xF5, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x60, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x83, 0x00, 0x00, 0x00, 0xFF, 
				 0x00, 0x00, 0x00, 0xA0, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 0x26, 
				 0x00, 0x00, 0x00, 0xE3, 0x00, 0x00, 0x00, 0xFF, 
				 0x00, 0x00, 0x00, 0x1D, 0x06, 0x00, 0x64, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0xE0, 0x00, 0x00, 0x00, 
				 0x22, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x13, 0xEA, 0x00, 0x1E, 0x00, 0x00, 0xC0, 0x00, 
				 0x00, 0x1E, 0x01, 0x59, 0x1A, 0x00, 0x00, 0x1F, 
				 0x01, 0x00, 0x19, 0xEA, 0x00, 0x12, 0x07, 0x04, 
				 0x1E, 0x00, 0xC0, 0x00, 0x00, 0x00, 0x1E, 0x01, 
				 0x0D, 0x00, 0x00, 0x00, 0x18, 0x07, 0x04, 0x13, 
				 0xC4, 0x02, 0x1E, 0x00, 0x3F, 0xC0, 0x00, 0x00, 
				 0x1E, 0x01, 0xC0, 0x0D, 0x00, 0x00, 0x1F, 0x01, 
				 0x00, 0x19, 0xC4, 0x02, 0x13, 0xEA, 0x00, 0x1E, 
				 0x00, 0xC0, 0xFF, 0x00, 0x00, 0x1E, 0x01, 0x27, 
				 0x00, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 0xEA, 
				 0x00, 0x16, 0x02, 0x04, 0x00, 0x48, 0x13, 0xC0, 
				 0x00, 0x1E, 0x01, 0x00, 0x24, 0x00, 0x00, 0x19, 
				 0xC0, 0x00, 0x17, 0x4C, 0x00, 0xA0, 0x00, 0x00, 
				 0x00, 0x17, 0x6C, 0x00, 0x32, 0x00, 0x00, 0x00, 
				 0x13, 0xEA, 0x00, 0x1E, 0x00, 0xFF, 0xC0, 0x00, 
				 0x00, 0x1E, 0x01, 0x00, 0x18, 0x00, 0x00, 0x1F, 
				 0x01, 0x00, 0x19, 0xEA, 0x00, 0x00, 0x0F};

BYTE t5465_Mode_1152x864x24_1[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x16, 0x05, 0x04, 0x00, 0x00, 0x16, 0xC0, 0x00, 
				 0x00, 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 
				 0x00, 0x1F, 0x01, 0x00, 0x18, 0xC5, 0x02, 0x18, 
				 0x07, 0x04, 0x15, 0xA0, 0x00, 0xFF, 0x00, 0x09, 
				 0xCE, 0x03, 0x06, 0x05, 0x09, 0xCE, 0x03, 0x09, 
				 0x00, 0x09, 0xCE, 0x03, 0x0A, 0x00, 0x09, 0xCE, 
				 0x03, 0x0B, 0x00, 0x16, 0x80, 0x00, 0x2F, 0x00, 
				 0x16, 0x84, 0x00, 0x0A, 0x00, 0x16, 0x88, 0x00, 
				 0x21, 0x00, 0x1D, 0x19, 0x00, 0x00, 0x00, 0xB4, 
				 0x00, 0x00, 0x00, 0x8F, 0x00, 0x00, 0x00, 0x8F, 
				 0x00, 0x00, 0x00, 0x94, 0x00, 0x00, 0x00, 0x95, 
				 0x00, 0x00, 0x00, 0x81, 0x00, 0x00, 0x00, 0x8E, 
				 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x60, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x60, 
				 0x00, 0x00, 0x00, 0x83, 0x00, 0x00, 0x00, 0x5F, 
				 0x00, 0x00, 0x00, 0xA0, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x5F, 0x00, 0x00, 0x00, 0x8E, 
				 0x00, 0x00, 0x00, 0xE3, 0x00, 0x00, 0x00, 0xFF, 
				 0x00, 0x00, 0x00, 0x1D, 0x06, 0x00, 0x64, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0xE0, 0x00, 0x00, 0x00, 
				 0x22, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x13, 0xEA, 0x00, 0x1E, 0x00, 0x00, 0xC0, 0x00, 
				 0x00, 0x1E, 0x01, 0x21, 0x20, 0x00, 0x00, 0x1F, 
				 0x01, 0x00, 0x19, 0xEA, 0x00, 0x12, 0x07, 0x04, 
				 0x1E, 0x00, 0xC0, 0x00, 0x00, 0x00, 0x1E, 0x01, 
				 0x10, 0x00, 0x00, 0x00, 0x18, 0x07, 0x04, 0x13, 
				 0xC4, 0x02, 0x1E, 0x00, 0x3F, 0xC0, 0x00, 0x00, 
				 0x1E, 0x01, 0xC0, 0x10, 0x00, 0x00, 0x1F, 0x01, 
				 0x00, 0x19, 0xC4, 0x02, 0x13, 0xEA, 0x00, 0x1E, 
				 0x00, 0xC0, 0xFF, 0x00, 0x00, 0x1E, 0x01, 0x29, 
				 0x00, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 0xEA, 
				 0x00, 0x16, 0x02, 0x04, 0x00, 0x48, 0x13, 0xC0, 
				 0x00, 0x1E, 0x01, 0x00, 0x24, 0x00, 0x00, 0x19, 
				 0xC0, 0x00, 0x17, 0x4C, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x17, 0x74, 0x00, 0x01, 0x00, 0x00, 0x00, 
				 0x13, 0xEA, 0x00, 0x1E, 0x00, 0xFF, 0xC0, 0x00, 
				 0x00, 0x1E, 0x01, 0x00, 0x1B, 0x00, 0x00, 0x1F, 
				 0x01, 0x00, 0x19, 0xEA, 0x00, 0x00, 0x0F};

BYTE t5465_Mode_1152x864x24_2[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x16, 0x05, 0x04, 0x00, 0x00, 0x16, 0xC0, 0x00, 
				 0x00, 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 
				 0x00, 0x1F, 0x01, 0x00, 0x18, 0xC5, 0x02, 0x18, 
				 0x07, 0x04, 0x15, 0xA0, 0x00, 0xFF, 0x00, 0x09, 
				 0xCE, 0x03, 0x06, 0x05, 0x09, 0xCE, 0x03, 0x09, 
				 0x00, 0x09, 0xCE, 0x03, 0x0A, 0x00, 0x09, 0xCE, 
				 0x03, 0x0B, 0x00, 0x16, 0x80, 0x00, 0x2F, 0x00, 
				 0x16, 0x84, 0x00, 0x16, 0x00, 0x16, 0x88, 0x00, 
				 0x53, 0x00, 0x1D, 0x19, 0x00, 0x00, 0x00, 0xC3, 
				 0x00, 0x00, 0x00, 0x8F, 0x00, 0x00, 0x00, 0x8F, 
				 0x00, 0x00, 0x00, 0x83, 0x00, 0x00, 0x00, 0x99, 
				 0x00, 0x00, 0x00, 0x09, 0x00, 0x00, 0x00, 0x82, 
				 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x60, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x60, 
				 0x00, 0x00, 0x00, 0x83, 0x00, 0x00, 0x00, 0x5F, 
				 0x00, 0x00, 0x00, 0xA0, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x5F, 0x00, 0x00, 0x00, 0x82, 
				 0x00, 0x00, 0x00, 0xE3, 0x00, 0x00, 0x00, 0xFF, 
				 0x00, 0x00, 0x00, 0x1D, 0x06, 0x00, 0x64, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0xF0, 0x00, 0x00, 0x00, 
				 0x22, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x13, 0xEA, 0x00, 0x1E, 0x00, 0x00, 0xC0, 0x00, 
				 0x00, 0x1E, 0x01, 0x21, 0x20, 0x00, 0x00, 0x1F, 
				 0x01, 0x00, 0x19, 0xEA, 0x00, 0x12, 0x07, 0x04, 
				 0x1E, 0x00, 0xC0, 0x00, 0x00, 0x00, 0x1E, 0x01, 
				 0x10, 0x00, 0x00, 0x00, 0x18, 0x07, 0x04, 0x13, 
				 0xC4, 0x02, 0x1E, 0x00, 0x3F, 0xC0, 0x00, 0x00, 
				 0x1E, 0x01, 0xC0, 0x10, 0x00, 0x00, 0x1F, 0x01, 
				 0x00, 0x19, 0xC4, 0x02, 0x13, 0xEA, 0x00, 0x1E, 
				 0x00, 0xC0, 0xFF, 0x00, 0x00, 0x1E, 0x01, 0x2B, 
				 0x00, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 0xEA, 
				 0x00, 0x16, 0x02, 0x04, 0x00, 0x48, 0x13, 0xC0, 
				 0x00, 0x1E, 0x01, 0x00, 0x24, 0x00, 0x00, 0x19, 
				 0xC0, 0x00, 0x17, 0x4C, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x17, 0x74, 0x00, 0x01, 0x00, 0x00, 0x00, 
				 0x13, 0xEA, 0x00, 0x1E, 0x00, 0xFF, 0xC0, 0x00, 
				 0x00, 0x1E, 0x01, 0x00, 0x1B, 0x00, 0x00, 0x1F, 
				 0x01, 0x00, 0x19, 0xEA, 0x00, 0x00, 0x0F};

BYTE t5465_Mode_1152x864x24_3[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x16, 0x05, 0x04, 0x00, 0x00, 0x16, 0xC0, 0x00, 
				 0x00, 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 
				 0x00, 0x1F, 0x01, 0x00, 0x18, 0xC5, 0x02, 0x18, 
				 0x07, 0x04, 0x15, 0xA0, 0x00, 0xFF, 0x00, 0x09, 
				 0xCE, 0x03, 0x06, 0x05, 0x09, 0xCE, 0x03, 0x09, 
				 0x00, 0x09, 0xCE, 0x03, 0x0A, 0x00, 0x09, 0xCE, 
				 0x03, 0x0B, 0x00, 0x16, 0x80, 0x00, 0x2F, 0x00, 
				 0x16, 0x84, 0x00, 0x04, 0x00, 0x16, 0x88, 0x00, 
				 0x11, 0x00, 0x1D, 0x19, 0x00, 0x00, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x8F, 0x00, 0x00, 0x00, 0x8F, 
				 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x99, 
				 0x00, 0x00, 0x00, 0x09, 0x00, 0x00, 0x00, 0x89, 
				 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x60, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x60, 
				 0x00, 0x00, 0x00, 0x83, 0x00, 0x00, 0x00, 0x5F, 
				 0x00, 0x00, 0x00, 0xA0, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x5F, 0x00, 0x00, 0x00, 0x89, 
				 0x00, 0x00, 0x00, 0xE3, 0x00, 0x00, 0x00, 0xFF, 
				 0x00, 0x00, 0x00, 0x1D, 0x06, 0x00, 0x64, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0xF0, 0x00, 0x00, 0x00, 
				 0x22, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x13, 0xEA, 0x00, 0x1E, 0x00, 0x00, 0xC0, 0x00, 
				 0x00, 0x1E, 0x01, 0x21, 0x20, 0x00, 0x00, 0x1F, 
				 0x01, 0x00, 0x19, 0xEA, 0x00, 0x12, 0x07, 0x04, 
				 0x1E, 0x00, 0xC0, 0x00, 0x00, 0x00, 0x1E, 0x01, 
				 0x10, 0x00, 0x00, 0x00, 0x18, 0x07, 0x04, 0x13, 
				 0xC4, 0x02, 0x1E, 0x00, 0x3F, 0xC0, 0x00, 0x00, 
				 0x1E, 0x01, 0xC0, 0x10, 0x00, 0x00, 0x1F, 0x01, 
				 0x00, 0x19, 0xC4, 0x02, 0x13, 0xEA, 0x00, 0x1E, 
				 0x00, 0x00, 0xC0, 0x00, 0x00, 0x1E, 0x01, 0x72, 
				 0x20, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 0xEA, 
				 0x00, 0x16, 0x02, 0x04, 0x00, 0x48, 0x13, 0xC0, 
				 0x00, 0x1E, 0x01, 0x00, 0x24, 0x00, 0x00, 0x19, 
				 0xC0, 0x00, 0x17, 0x4C, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x17, 0x74, 0x00, 0x01, 0x00, 0x00, 0x00, 
				 0x13, 0xEA, 0x00, 0x1E, 0x00, 0xFF, 0xC0, 0x00, 
				 0x00, 0x1E, 0x01, 0x00, 0x1B, 0x00, 0x00, 0x1F, 
				 0x01, 0x00, 0x19, 0xEA, 0x00, 0x00, 0x0F};

BYTE t5465_Mode_1280x960x24_1[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x16, 0x05, 0x04, 0x00, 0x00, 0x16, 0xC0, 0x00, 
				 0x00, 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 
				 0x00, 0x1F, 0x01, 0x00, 0x18, 0xC5, 0x02, 0x18, 
				 0x07, 0x04, 0x15, 0xA0, 0x00, 0xFF, 0x00, 0x09, 
				 0xCE, 0x03, 0x06, 0x05, 0x09, 0xCE, 0x03, 0x09, 
				 0x00, 0x09, 0xCE, 0x03, 0x0A, 0x00, 0x09, 0xCE, 
				 0x03, 0x0B, 0x00, 0x16, 0x80, 0x00, 0x2F, 0x00, 
				 0x16, 0x84, 0x00, 0x16, 0x00, 0x16, 0x88, 0x00, 
				 0x53, 0x00, 0x1D, 0x19, 0x00, 0x00, 0x00, 0xDC, 
				 0x00, 0x00, 0x00, 0x9F, 0x00, 0x00, 0x00, 0x9F, 
				 0x00, 0x00, 0x00, 0x9C, 0x00, 0x00, 0x00, 0xAD, 
				 0x00, 0x00, 0x00, 0x1B, 0x00, 0x00, 0x00, 0xE6, 
				 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x60, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x83, 0x00, 0x00, 0x00, 0xBF, 
				 0x00, 0x00, 0x00, 0xA0, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0xBF, 0x00, 0x00, 0x00, 0xE6, 
				 0x00, 0x00, 0x00, 0xE3, 0x00, 0x00, 0x00, 0xFF, 
				 0x00, 0x00, 0x00, 0x1D, 0x06, 0x00, 0x64, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0xF0, 0x00, 0x00, 0x00, 
				 0x22, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x13, 0xEA, 0x00, 0x1E, 0x00, 0x00, 0xC0, 0x00, 
				 0x00, 0x1E, 0x01, 0x21, 0x20, 0x00, 0x00, 0x1F, 
				 0x01, 0x00, 0x19, 0xEA, 0x00, 0x12, 0x07, 0x04, 
				 0x1E, 0x00, 0xC0, 0x00, 0x00, 0x00, 0x1E, 0x01, 
				 0x10, 0x00, 0x00, 0x00, 0x18, 0x07, 0x04, 0x13, 
				 0xC4, 0x02, 0x1E, 0x00, 0x3F, 0xC0, 0x00, 0x00, 
				 0x1E, 0x01, 0xC0, 0x10, 0x00, 0x00, 0x1F, 0x01, 
				 0x00, 0x19, 0xC4, 0x02, 0x13, 0xEA, 0x00, 0x1E, 
				 0x00, 0x00, 0xC0, 0x00, 0x00, 0x1E, 0x01, 0x6E, 
				 0x20, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 0xEA, 
				 0x00, 0x16, 0x02, 0x04, 0x00, 0x48, 0x13, 0xC0, 
				 0x00, 0x1E, 0x01, 0x00, 0x24, 0x00, 0x00, 0x19, 
				 0xC0, 0x00, 0x17, 0x4C, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x17, 0x74, 0x00, 0x01, 0x00, 0x00, 0x00, 
				 0x13, 0xEA, 0x00, 0x1E, 0x00, 0xFF, 0xC0, 0x00, 
				 0x00, 0x1E, 0x01, 0x00, 0x1E, 0x00, 0x00, 0x1F, 
				 0x01, 0x00, 0x19, 0xEA, 0x00, 0x00, 0x0F};

BYTE t5465_Mode_1280x960x24_2[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x16, 0x05, 0x04, 0x00, 0x00, 0x16, 0xC0, 0x00, 
				 0x00, 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 
				 0x00, 0x1F, 0x01, 0x00, 0x18, 0xC5, 0x02, 0x18, 
				 0x07, 0x04, 0x15, 0xA0, 0x00, 0xFF, 0x00, 0x09, 
				 0xCE, 0x03, 0x06, 0x05, 0x09, 0xCE, 0x03, 0x09, 
				 0x00, 0x09, 0xCE, 0x03, 0x0A, 0x00, 0x09, 0xCE, 
				 0x03, 0x0B, 0x00, 0x16, 0x80, 0x00, 0x2F, 0x00, 
				 0x16, 0x84, 0x00, 0x0A, 0x00, 0x16, 0x88, 0x00, 
				 0x2C, 0x00, 0x1D, 0x19, 0x00, 0x00, 0x00, 0xCD, 
				 0x00, 0x00, 0x00, 0x9F, 0x00, 0x00, 0x00, 0x9F, 
				 0x00, 0x00, 0x00, 0x8D, 0x00, 0x00, 0x00, 0xA5, 
				 0x00, 0x00, 0x00, 0x17, 0x00, 0x00, 0x00, 0xE6, 
				 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x60, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x83, 0x00, 0x00, 0x00, 0xBF, 
				 0x00, 0x00, 0x00, 0xA0, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0xBF, 0x00, 0x00, 0x00, 0xE6, 
				 0x00, 0x00, 0x00, 0xE3, 0x00, 0x00, 0x00, 0xFF, 
				 0x00, 0x00, 0x00, 0x1D, 0x06, 0x00, 0x64, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0xF0, 0x00, 0x00, 0x00, 
				 0x22, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x13, 0xEA, 0x00, 0x1E, 0x00, 0x00, 0xC0, 0x00, 
				 0x00, 0x1E, 0x01, 0x21, 0x20, 0x00, 0x00, 0x1F, 
				 0x01, 0x00, 0x19, 0xEA, 0x00, 0x12, 0x07, 0x04, 
				 0x1E, 0x00, 0xC0, 0x00, 0x00, 0x00, 0x1E, 0x01, 
				 0x10, 0x00, 0x00, 0x00, 0x18, 0x07, 0x04, 0x13, 
				 0xC4, 0x02, 0x1E, 0x00, 0x3F, 0xC0, 0x00, 0x00, 
				 0x1E, 0x01, 0xC0, 0x10, 0x00, 0x00, 0x1F, 0x01, 
				 0x00, 0x19, 0xC4, 0x02, 0x13, 0xEA, 0x00, 0x1E, 
				 0x00, 0x00, 0xC0, 0x00, 0x00, 0x1E, 0x01, 0x76, 
				 0x20, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 0xEA, 
				 0x00, 0x16, 0x02, 0x04, 0x00, 0x48, 0x13, 0xC0, 
				 0x00, 0x1E, 0x01, 0x00, 0x24, 0x00, 0x00, 0x19, 
				 0xC0, 0x00, 0x17, 0x4C, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x17, 0x74, 0x00, 0x01, 0x00, 0x00, 0x00, 
				 0x13, 0xEA, 0x00, 0x1E, 0x00, 0xFF, 0xC0, 0x00, 
				 0x00, 0x1E, 0x01, 0x00, 0x1E, 0x00, 0x00, 0x1F, 
				 0x01, 0x00, 0x19, 0xEA, 0x00, 0x00, 0x0F};

BYTE t5465_Mode_1280x1024x24_1[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x16, 0x05, 0x04, 0x00, 0x00, 0x16, 0xC0, 0x00, 
				 0x00, 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 
				 0x00, 0x1F, 0x01, 0x00, 0x18, 0xC5, 0x02, 0x18, 
				 0x07, 0x04, 0x15, 0xA0, 0x00, 0xFF, 0x00, 0x09, 
				 0xCE, 0x03, 0x06, 0x05, 0x09, 0xCE, 0x03, 0x09, 
				 0x00, 0x09, 0xCE, 0x03, 0x0A, 0x00, 0x09, 0xCE, 
				 0x03, 0x0B, 0x00, 0x16, 0x80, 0x00, 0x2F, 0x00, 
				 0x16, 0x84, 0x00, 0x04, 0x00, 0x16, 0x88, 0x00, 
				 0x0B, 0x00, 0x1D, 0x19, 0x00, 0x00, 0x00, 0xCF, 
				 0x00, 0x00, 0x00, 0x9F, 0x00, 0x00, 0x00, 0x9F, 
				 0x00, 0x00, 0x00, 0x93, 0x00, 0x00, 0x00, 0xA9, 
				 0x00, 0x00, 0x00, 0x13, 0x00, 0x00, 0x00, 0x14, 
				 0x00, 0x00, 0x00, 0xB2, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x60, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x82, 0x00, 0x00, 0x00, 0xFF, 
				 0x00, 0x00, 0x00, 0xA0, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x14, 
				 0x00, 0x00, 0x00, 0xE3, 0x00, 0x00, 0x00, 0xFF, 
				 0x00, 0x00, 0x00, 0x1D, 0x06, 0x00, 0x64, 0x00, 
				 0x67, 0x00, 0x00, 0x00, 0x81, 0x00, 0x00, 0x00, 
				 0x22, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x13, 0xEA, 0x00, 0x1E, 0x00, 0x00, 0xC0, 0x00, 
				 0x00, 0x1E, 0x01, 0x21, 0x20, 0x00, 0x00, 0x1F, 
				 0x01, 0x00, 0x19, 0xEA, 0x00, 0x12, 0x07, 0x04, 
				 0x1E, 0x00, 0xC0, 0x00, 0x00, 0x00, 0x1E, 0x01, 
				 0x10, 0x00, 0x00, 0x00, 0x18, 0x07, 0x04, 0x13, 
				 0xC4, 0x02, 0x1E, 0x00, 0x3F, 0xC0, 0x00, 0x00, 
				 0x1E, 0x01, 0xC0, 0x10, 0x00, 0x00, 0x1F, 0x01, 
				 0x00, 0x19, 0xC4, 0x02, 0x16, 0x02, 0x04, 0x00, 
				 0x48, 0x13, 0xC0, 0x00, 0x1E, 0x01, 0x00, 0x24, 
				 0x00, 0x00, 0x19, 0xC0, 0x00, 0x17, 0x4C, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x17, 0x74, 0x00, 0x01, 
				 0x00, 0x00, 0x00, 0x13, 0xEA, 0x00, 0x1E, 0x00, 
				 0xFF, 0xC0, 0x00, 0x00, 0x1E, 0x01, 0x00, 0x1E, 
				 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 0xEA, 0x00, 
				 0x00, 0xEA};

BYTE t5465_Mode_1280x1024x24_2[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x16, 0x05, 0x04, 0x00, 0x00, 0x16, 0xC0, 0x00, 
				 0x00, 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 
				 0x00, 0x1F, 0x01, 0x00, 0x18, 0xC5, 0x02, 0x18, 
				 0x07, 0x04, 0x15, 0xA0, 0x00, 0xFF, 0x00, 0x09, 
				 0xCE, 0x03, 0x06, 0x05, 0x09, 0xCE, 0x03, 0x09, 
				 0x00, 0x09, 0xCE, 0x03, 0x0A, 0x00, 0x09, 0xCE, 
				 0x03, 0x0B, 0x00, 0x16, 0x80, 0x00, 0x2F, 0x00, 
				 0x16, 0x84, 0x00, 0x16, 0x00, 0x16, 0x88, 0x00, 
				 0x53, 0x00, 0x1D, 0x19, 0x00, 0x00, 0x00, 0xCE, 
				 0x00, 0x00, 0x00, 0x9F, 0x00, 0x00, 0x00, 0x9F, 
				 0x00, 0x00, 0x00, 0x91, 0x00, 0x00, 0x00, 0xA7, 
				 0x00, 0x00, 0x00, 0x15, 0x00, 0x00, 0x00, 0x28, 
				 0x00, 0x00, 0x00, 0x5A, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x60, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x83, 0x00, 0x00, 0x00, 0xFF, 
				 0x00, 0x00, 0x00, 0xA0, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 0x24, 
				 0x00, 0x00, 0x00, 0xE3, 0x00, 0x00, 0x00, 0xFF, 
				 0x00, 0x00, 0x00, 0x1D, 0x06, 0x00, 0x64, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x30, 0x00, 0x00, 0x00, 
				 0x22, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x09, 0x00, 0x00, 0x00, 
				 0x13, 0xEA, 0x00, 0x1E, 0x00, 0x00, 0xC0, 0x00, 
				 0x00, 0x1E, 0x01, 0x21, 0x20, 0x00, 0x00, 0x1F, 
				 0x01, 0x00, 0x19, 0xEA, 0x00, 0x12, 0x07, 0x04, 
				 0x1E, 0x00, 0xC0, 0x00, 0x00, 0x00, 0x1E, 0x01, 
				 0x10, 0x00, 0x00, 0x00, 0x18, 0x07, 0x04, 0x13, 
				 0xC4, 0x02, 0x1E, 0x00, 0x3F, 0xC0, 0x00, 0x00, 
				 0x1E, 0x01, 0xC0, 0x10, 0x00, 0x00, 0x1F, 0x01, 
				 0x00, 0x19, 0xC4, 0x02, 0x13, 0xEA, 0x00, 0x1E, 
				 0x00, 0xC0, 0xFF, 0x00, 0x00, 0x1E, 0x01, 0x2B, 
				 0x00, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 0xEA, 
				 0x00, 0x16, 0x02, 0x04, 0x00, 0x48, 0x13, 0xC0, 
				 0x00, 0x1E, 0x01, 0x00, 0x24, 0x00, 0x00, 0x19, 
				 0xC0, 0x00, 0x17, 0x4C, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x17, 0x74, 0x00, 0x01, 0x00, 0x00, 0x00, 
				 0x13, 0xEA, 0x00, 0x1E, 0x00, 0xFF, 0xC0, 0x00, 
				 0x00, 0x1E, 0x01, 0x00, 0x1E, 0x00, 0x00, 0x1F, 
				 0x01, 0x00, 0x19, 0xEA, 0x00, 0x00, 0x0F};

BYTE t5465_Mode_Reset[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x16, 0x05, 0x04, 0x00, 0x00, 0x16, 0xC0, 0x00, 
				 0x00, 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 
				 0x00, 0x1F, 0x01, 0x00, 0x18, 0xC5, 0x02, 0x18, 
				 0x07, 0x04, 0x15, 0xA0, 0x00, 0xFF, 0x00, 0x09, 
				 0xCE, 0x03, 0x06, 0x05, 0x09, 0xCE, 0x03, 0x09, 
				 0x00, 0x09, 0xCE, 0x03, 0x0A, 0x00, 0x09, 0xCE, 
				 0x03, 0x0B, 0x00, 0x16, 0x80, 0x00, 0xEF, 0x00, 
				 0x16, 0x84, 0x00, 0x3F, 0x00, 0x16, 0x88, 0x00, 
				 0x6D, 0x00, 0x1D, 0x19, 0x00, 0x00, 0x00, 0x5F, 
				 0x00, 0x00, 0x00, 0x4F, 0x00, 0x00, 0x00, 0x50, 
				 0x00, 0x00, 0x00, 0x9F, 0x00, 0x00, 0x00, 0x54, 
				 0x00, 0x00, 0x00, 0x1F, 0x00, 0x00, 0x00, 0x0B, 
				 0x00, 0x00, 0x00, 0x3E, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xE9, 
				 0x00, 0x00, 0x00, 0x8B, 0x00, 0x00, 0x00, 0xDF, 
				 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0xE7, 0x00, 0x00, 0x00, 0x04, 
				 0x00, 0x00, 0x00, 0xE3, 0x00, 0x00, 0x00, 0xFF, 
				 0x00, 0x00, 0x00, 0x1D, 0x06, 0x00, 0x64, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x90, 0x00, 0x00, 0x00, 
				 0x22, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x13, 0xEA, 0x00, 0x1E, 0x00, 0x00, 0xC0, 0x00, 
				 0x00, 0x1E, 0x01, 0x11, 0x08, 0x00, 0x00, 0x1F, 
				 0x01, 0x00, 0x19, 0xEA, 0x00, 0x12, 0x07, 0x04, 
				 0x1E, 0x00, 0xC0, 0x00, 0x00, 0x00, 0x1E, 0x01, 
				 0x08, 0x00, 0x00, 0x00, 0x18, 0x07, 0x04, 0x13, 
				 0xC4, 0x02, 0x1E, 0x00, 0x3F, 0xC0, 0x00, 0x00, 
				 0x1E, 0x01, 0x80, 0x08, 0x00, 0x00, 0x1F, 0x01, 
				 0x00, 0x19, 0xC4, 0x02, 0x16, 0x02, 0x04, 0x00, 
				 0x00, 0x13, 0xC0, 0x00, 0x1E, 0x01, 0x00, 0x00, 
				 0x00, 0x00, 0x19, 0xC0, 0x00, 0x13, 0xEA, 0x00, 
				 0x1E, 0x00, 0xFF, 0xC0, 0x00, 0x00, 0x1E, 0x01, 
				 0x00, 0x05, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 
				 0xEA, 0x00, 0x14, 0xFC, 0x03, 0x1E, 0x00, 0xFF, 
				 0xFF, 0xFF, 0xEF, 0x1A, 0xFC, 0x03, 0x12, 0x5C, 
				 0x00, 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 
				 0x5C, 0x00, 0x15, 0x68, 0x00, 0x00, 0x00, 0x15, 
				 0x6C, 0x00, 0x00, 0x00, 0x15, 0x74, 0x00, 0x00, 
				 0x00, 0x15, 0x78, 0x00, 0x00, 0x00, 0x12, 0x5C, 
				 0x00, 0x1E, 0x01, 0x80, 0x00, 0x00, 0x00, 0x18, 
				 0x5C, 0x00, 0x13, 0xEA, 0x00, 0x1E, 0x00, 0x00, 
				 0xC0, 0x00, 0x00, 0x1E, 0x01, 0x08, 0x3F, 0x00, 
				 0x00, 0x1F, 0x01, 0x00, 0x19, 0xEA, 0x00, 0x13, 
				 0xC4, 0x02, 0x1E, 0x00, 0x3F, 0xC0, 0x00, 0x00, 
				 0x1E, 0x01, 0x00, 0x3F, 0x00, 0x00, 0x1F, 0x01, 
				 0x00, 0x19, 0xC4, 0x02, 0x16, 0xC0, 0x00, 0x00, 
				 0x00, 0x00, 0x00};

BYTE t5465_Mode_1600x1200x8_3[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x16, 0x05, 0x04, 0x00, 0x00, 0x16, 0xC0, 0x00, 
				 0x00, 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 
				 0x00, 0x1F, 0x01, 0x00, 0x18, 0xC5, 0x02, 0x18, 
				 0x07, 0x04, 0x15, 0xA0, 0x00, 0xFF, 0x00, 0x09, 
				 0xCE, 0x03, 0x06, 0x05, 0x09, 0xCE, 0x03, 0x09, 
				 0x00, 0x09, 0xCE, 0x03, 0x0A, 0x00, 0x09, 0xCE, 
				 0x03, 0x0B, 0x00, 0x16, 0x80, 0x00, 0x2F, 0x00, 
				 0x16, 0x84, 0x00, 0x08, 0x00, 0x16, 0x88, 0x00, 
				 0x31, 0x00, 0x1D, 0x19, 0x00, 0x00, 0x00, 0x09, 
				 0x00, 0x00, 0x00, 0xC7, 0x00, 0x00, 0x00, 0xC7, 
				 0x00, 0x00, 0x00, 0x89, 0x00, 0x00, 0x00, 0xD0, 
				 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0xDF, 
				 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xB0, 
				 0x00, 0x00, 0x00, 0x83, 0x00, 0x00, 0x00, 0xAF, 
				 0x00, 0x00, 0x00, 0xD0, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0xAF, 0x00, 0x00, 0x00, 0xDF, 
				 0x00, 0x00, 0x00, 0xE3, 0x00, 0x00, 0x00, 0xFF, 
				 0x00, 0x00, 0x00, 0x1D, 0x06, 0x00, 0x64, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x22, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x8F, 0x00, 0x00, 0x00, 
				 0x13, 0xEA, 0x00, 0x1E, 0x00, 0x00, 0xC0, 0x00, 
				 0x00, 0x1E, 0x01, 0x12, 0x0D, 0x00, 0x00, 0x1F, 
				 0x01, 0x00, 0x19, 0xEA, 0x00, 0x12, 0x07, 0x04, 
				 0x1E, 0x00, 0xC0, 0x00, 0x00, 0x00, 0x1E, 0x01, 
				 0x0D, 0x00, 0x00, 0x00, 0x18, 0x07, 0x04, 0x13, 
				 0xC4, 0x02, 0x1E, 0x00, 0x3F, 0xC0, 0x00, 0x00, 
				 0x1E, 0x01, 0x80, 0x0D, 0x00, 0x00, 0x1F, 0x01, 
				 0x00, 0x19, 0xC4, 0x02, 0x13, 0xEA, 0x00, 0x1E, 
				 0x00, 0xC0, 0xFF, 0x00, 0x00, 0x1E, 0x01, 0x1A, 
				 0x00, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 0xEA, 
				 0x00, 0x16, 0x02, 0x04, 0x00, 0x00, 0x13, 0xC0, 
				 0x00, 0x1E, 0x01, 0x00, 0x00, 0x00, 0x00, 0x19, 
				 0xC0, 0x00, 0x13, 0xEA, 0x00, 0x1E, 0x00, 0xFF, 
				 0xC0, 0x00, 0x00, 0x1E, 0x01, 0x00, 0x0D, 0x00, 
				 0x00, 0x1F, 0x01, 0x00, 0x19, 0xEA, 0x00, 0x00, 0x5C};

BYTE t5465_Mode_1600x1200x8_4[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x16, 0x05, 0x04, 0x00, 0x00, 0x16, 0xC0, 0x00, 
				 0x00, 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 
				 0x00, 0x1F, 0x01, 0x00, 0x18, 0xC5, 0x02, 0x18, 
				 0x07, 0x04, 0x15, 0xA0, 0x00, 0xFF, 0x00, 0x09, 
				 0xCE, 0x03, 0x06, 0x05, 0x09, 0xCE, 0x03, 0x09, 
				 0x00, 0x09, 0xCE, 0x03, 0x0A, 0x00, 0x09, 0xCE, 
				 0x03, 0x0B, 0x00, 0x16, 0x80, 0x00, 0x2F, 0x00, 
				 0x16, 0x84, 0x00, 0x0A, 0x00, 0x16, 0x88, 0x00, 
				 0x42, 0x00, 0x1D, 0x19, 0x00, 0x00, 0x00, 0x09, 
				 0x00, 0x00, 0x00, 0xC7, 0x00, 0x00, 0x00, 0xC7, 
				 0x00, 0x00, 0x00, 0x89, 0x00, 0x00, 0x00, 0xD0, 
				 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0xE0, 
				 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xB0, 
				 0x00, 0x00, 0x00, 0x83, 0x00, 0x00, 0x00, 0xAF, 
				 0x00, 0x00, 0x00, 0xD0, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0xAF, 0x00, 0x00, 0x00, 0xE0, 
				 0x00, 0x00, 0x00, 0xE3, 0x00, 0x00, 0x00, 0xFF, 
				 0x00, 0x00, 0x00, 0x1D, 0x06, 0x00, 0x64, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x22, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x8F, 0x00, 0x00, 0x00, 
				 0x13, 0xEA, 0x00, 0x1E, 0x00, 0x00, 0xC0, 0x00, 
				 0x00, 0x1E, 0x01, 0x12, 0x0D, 0x00, 0x00, 0x1F, 
				 0x01, 0x00, 0x19, 0xEA, 0x00, 0x12, 0x07, 0x04, 
				 0x1E, 0x00, 0xC0, 0x00, 0x00, 0x00, 0x1E, 0x01, 
				 0x0D, 0x00, 0x00, 0x00, 0x18, 0x07, 0x04, 0x13, 
				 0xC4, 0x02, 0x1E, 0x00, 0x3F, 0xC0, 0x00, 0x00, 
				 0x1E, 0x01, 0x80, 0x0D, 0x00, 0x00, 0x1F, 0x01, 
				 0x00, 0x19, 0xC4, 0x02, 0x13, 0xEA, 0x00, 0x1E, 
				 0x00, 0xC0, 0xFF, 0x00, 0x00, 0x1E, 0x01, 0x1A, 
				 0x00, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 0xEA, 
				 0x00, 0x16, 0x02, 0x04, 0x00, 0x00, 0x13, 0xC0, 
				 0x00, 0x1E, 0x01, 0x00, 0x00, 0x00, 0x00, 0x19, 
				 0xC0, 0x00, 0x13, 0xEA, 0x00, 0x1E, 0x00, 0xFF, 
				 0xC0, 0x00, 0x00, 0x1E, 0x01, 0x00, 0x0D, 0x00, 
				 0x00, 0x1F, 0x01, 0x00, 0x19, 0xEA, 0x00, 0x00, 0x5C};

BYTE t5465_Mode_1600x1200x8_5[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x16, 0x05, 0x04, 0x00, 0x00, 0x16, 0xC0, 0x00, 
				 0x00, 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 
				 0x00, 0x1F, 0x01, 0x00, 0x18, 0xC5, 0x02, 0x18, 
				 0x07, 0x04, 0x15, 0xA0, 0x00, 0xFF, 0x00, 0x09, 
				 0xCE, 0x03, 0x06, 0x05, 0x09, 0xCE, 0x03, 0x09, 
				 0x00, 0x09, 0xCE, 0x03, 0x0A, 0x00, 0x09, 0xCE, 
				 0x03, 0x0B, 0x00, 0x16, 0x80, 0x00, 0x2F, 0x00, 
				 0x16, 0x84, 0x00, 0x0E, 0x00, 0x16, 0x88, 0x00, 
				 0x63, 0x00, 0x1D, 0x19, 0x00, 0x00, 0x00, 0x09, 
				 0x00, 0x00, 0x00, 0xC7, 0x00, 0x00, 0x00, 0xC7, 
				 0x00, 0x00, 0x00, 0x89, 0x00, 0x00, 0x00, 0xD0, 
				 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0xE0, 
				 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xB0, 
				 0x00, 0x00, 0x00, 0x83, 0x00, 0x00, 0x00, 0xAF, 
				 0x00, 0x00, 0x00, 0xD0, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0xAF, 0x00, 0x00, 0x00, 0xE0, 
				 0x00, 0x00, 0x00, 0xE3, 0x00, 0x00, 0x00, 0xFF, 
				 0x00, 0x00, 0x00, 0x1D, 0x06, 0x00, 0x64, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x22, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x8F, 0x00, 0x00, 0x00, 
				 0x13, 0xEA, 0x00, 0x1E, 0x00, 0x00, 0xC0, 0x00, 
				 0x00, 0x1E, 0x01, 0x12, 0x0D, 0x00, 0x00, 0x1F, 
				 0x01, 0x00, 0x19, 0xEA, 0x00, 0x12, 0x07, 0x04, 
				 0x1E, 0x00, 0xC0, 0x00, 0x00, 0x00, 0x1E, 0x01, 
				 0x0D, 0x00, 0x00, 0x00, 0x18, 0x07, 0x04, 0x13, 
				 0xC4, 0x02, 0x1E, 0x00, 0x3F, 0xC0, 0x00, 0x00, 
				 0x1E, 0x01, 0x80, 0x0D, 0x00, 0x00, 0x1F, 0x01, 
				 0x00, 0x19, 0xC4, 0x02, 0x13, 0xEA, 0x00, 0x1E, 
				 0x00, 0xC0, 0xFF, 0x00, 0x00, 0x1E, 0x01, 0x1D, 
				 0x00, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 0xEA, 
				 0x00, 0x16, 0x02, 0x04, 0x00, 0x00, 0x13, 0xC0, 
				 0x00, 0x1E, 0x01, 0x00, 0x00, 0x00, 0x00, 0x19, 
				 0xC0, 0x00, 0x13, 0xEA, 0x00, 0x1E, 0x00, 0xFF, 
				 0xC0, 0x00, 0x00, 0x1E, 0x01, 0x00, 0x0D, 0x00, 
				 0x00, 0x1F, 0x01, 0x00, 0x19, 0xEA, 0x00, 0x00, 0x5C};

BYTE t5465_Mode_1600x1200x8_3a[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x16, 0x05, 0x04, 0x00, 0x00, 0x16, 0xC0, 0x00, 
				 0x00, 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 
				 0x00, 0x1F, 0x01, 0x00, 0x18, 0xC5, 0x02, 0x18, 
				 0x07, 0x04, 0x15, 0xA0, 0x00, 0xFF, 0x00, 0x09, 
				 0xCE, 0x03, 0x06, 0x05, 0x09, 0xCE, 0x03, 0x09, 
				 0x00, 0x09, 0xCE, 0x03, 0x0A, 0x00, 0x09, 0xCE, 
				 0x03, 0x0B, 0x00, 0x16, 0x80, 0x00, 0x2F, 0x00, 
				 0x16, 0x84, 0x00, 0x08, 0x00, 0x16, 0x88, 0x00, 
				 0x31, 0x00, 0x1D, 0x19, 0x00, 0x00, 0x00, 0x09, 
				 0x00, 0x00, 0x00, 0xC7, 0x00, 0x00, 0x00, 0xC7, 
				 0x00, 0x00, 0x00, 0x89, 0x00, 0x00, 0x00, 0xD0, 
				 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0xDF, 
				 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xB0, 
				 0x00, 0x00, 0x00, 0x83, 0x00, 0x00, 0x00, 0xAF, 
				 0x00, 0x00, 0x00, 0xD0, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0xAF, 0x00, 0x00, 0x00, 0xDF, 
				 0x00, 0x00, 0x00, 0xE3, 0x00, 0x00, 0x00, 0xFF, 
				 0x00, 0x00, 0x00, 0x1D, 0x06, 0x00, 0x64, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x22, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x8F, 0x00, 0x00, 0x00, 
				 0x13, 0xEA, 0x00, 0x1E, 0x00, 0x00, 0xC0, 0x00, 
				 0x00, 0x1E, 0x01, 0x1A, 0x1A, 0x00, 0x00, 0x1F, 
				 0x01, 0x00, 0x19, 0xEA, 0x00, 0x12, 0x07, 0x04, 
				 0x1E, 0x00, 0xC0, 0x00, 0x00, 0x00, 0x1E, 0x01, 
				 0x1A, 0x00, 0x00, 0x00, 0x18, 0x07, 0x04, 0x13, 
				 0xC4, 0x02, 0x1E, 0x00, 0x3F, 0xC0, 0x00, 0x00, 
				 0x1E, 0x01, 0x80, 0x1A, 0x00, 0x00, 0x1F, 0x01, 
				 0x00, 0x19, 0xC4, 0x02, 0x16, 0x02, 0x04, 0x00, 
				 0x00, 0x13, 0xC0, 0x00, 0x1E, 0x01, 0x00, 0x00, 
				 0x00, 0x00, 0x19, 0xC0, 0x00, 0x17, 0x4C, 0x00, 
				 0xA0, 0x00, 0x00, 0x00, 0x17, 0x6C, 0x00, 0x32, 
				 0x00, 0x00, 0x00, 0x13, 0xEA, 0x00, 0x1E, 0x00, 
				 0xFF, 0xC0, 0x00, 0x00, 0x1E, 0x01, 0x00, 0x0D, 
				 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 0xEA, 0x00, 
				 0x00, 0x1F};

BYTE t5465_Mode_1600x1200x8_4a[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x16, 0x05, 0x04, 0x00, 0x00, 0x16, 0xC0, 0x00, 
				 0x00, 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 
				 0x00, 0x1F, 0x01, 0x00, 0x18, 0xC5, 0x02, 0x18, 
				 0x07, 0x04, 0x15, 0xA0, 0x00, 0xFF, 0x00, 0x09, 
				 0xCE, 0x03, 0x06, 0x05, 0x09, 0xCE, 0x03, 0x09, 
				 0x00, 0x09, 0xCE, 0x03, 0x0A, 0x00, 0x09, 0xCE, 
				 0x03, 0x0B, 0x00, 0x16, 0x80, 0x00, 0x2F, 0x00, 
				 0x16, 0x84, 0x00, 0x0A, 0x00, 0x16, 0x88, 0x00, 
				 0x42, 0x00, 0x1D, 0x19, 0x00, 0x00, 0x00, 0x09, 
				 0x00, 0x00, 0x00, 0xC7, 0x00, 0x00, 0x00, 0xC7, 
				 0x00, 0x00, 0x00, 0x89, 0x00, 0x00, 0x00, 0xD0, 
				 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0xE0, 
				 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xB0, 
				 0x00, 0x00, 0x00, 0x83, 0x00, 0x00, 0x00, 0xAF, 
				 0x00, 0x00, 0x00, 0xD0, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0xAF, 0x00, 0x00, 0x00, 0xE0, 
				 0x00, 0x00, 0x00, 0xE3, 0x00, 0x00, 0x00, 0xFF, 
				 0x00, 0x00, 0x00, 0x1D, 0x06, 0x00, 0x64, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x22, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x8F, 0x00, 0x00, 0x00, 
				 0x13, 0xEA, 0x00, 0x1E, 0x00, 0x00, 0xC0, 0x00, 
				 0x00, 0x1E, 0x01, 0x1A, 0x1A, 0x00, 0x00, 0x1F, 
				 0x01, 0x00, 0x19, 0xEA, 0x00, 0x12, 0x07, 0x04, 
				 0x1E, 0x00, 0xC0, 0x00, 0x00, 0x00, 0x1E, 0x01, 
				 0x1A, 0x00, 0x00, 0x00, 0x18, 0x07, 0x04, 0x13, 
				 0xC4, 0x02, 0x1E, 0x00, 0x3F, 0xC0, 0x00, 0x00, 
				 0x1E, 0x01, 0x80, 0x1A, 0x00, 0x00, 0x1F, 0x01, 
				 0x00, 0x19, 0xC4, 0x02, 0x16, 0x02, 0x04, 0x00, 
				 0x00, 0x13, 0xC0, 0x00, 0x1E, 0x01, 0x00, 0x00, 
				 0x00, 0x00, 0x19, 0xC0, 0x00, 0x17, 0x4C, 0x00, 
				 0xA0, 0x00, 0x00, 0x00, 0x17, 0x6C, 0x00, 0x32, 
				 0x00, 0x00, 0x00, 0x13, 0xEA, 0x00, 0x1E, 0x00, 
				 0xFF, 0xC0, 0x00, 0x00, 0x1E, 0x01, 0x00, 0x0D, 
				 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 0xEA, 0x00, 
				 0x00, 0x1F};

BYTE t5465_Mode_1600x1200x8_5a[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x16, 0x05, 0x04, 0x00, 0x00, 0x16, 0xC0, 0x00, 
				 0x00, 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 
				 0x00, 0x1F, 0x01, 0x00, 0x18, 0xC5, 0x02, 0x18, 
				 0x07, 0x04, 0x15, 0xA0, 0x00, 0xFF, 0x00, 0x09, 
				 0xCE, 0x03, 0x06, 0x05, 0x09, 0xCE, 0x03, 0x09, 
				 0x00, 0x09, 0xCE, 0x03, 0x0A, 0x00, 0x09, 0xCE, 
				 0x03, 0x0B, 0x00, 0x16, 0x80, 0x00, 0x2F, 0x00, 
				 0x16, 0x84, 0x00, 0x0E, 0x00, 0x16, 0x88, 0x00, 
				 0x63, 0x00, 0x1D, 0x19, 0x00, 0x00, 0x00, 0x09, 
				 0x00, 0x00, 0x00, 0xC7, 0x00, 0x00, 0x00, 0xC7, 
				 0x00, 0x00, 0x00, 0x89, 0x00, 0x00, 0x00, 0xD0, 
				 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0xE0, 
				 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xB0, 
				 0x00, 0x00, 0x00, 0x83, 0x00, 0x00, 0x00, 0xAF, 
				 0x00, 0x00, 0x00, 0xD0, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0xAF, 0x00, 0x00, 0x00, 0xE0, 
				 0x00, 0x00, 0x00, 0xE3, 0x00, 0x00, 0x00, 0xFF, 
				 0x00, 0x00, 0x00, 0x1D, 0x06, 0x00, 0x64, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x22, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x8F, 0x00, 0x00, 0x00, 
				 0x13, 0xEA, 0x00, 0x1E, 0x00, 0x00, 0xC0, 0x00, 
				 0x00, 0x1E, 0x01, 0x1A, 0x1A, 0x00, 0x00, 0x1F, 
				 0x01, 0x00, 0x19, 0xEA, 0x00, 0x12, 0x07, 0x04, 
				 0x1E, 0x00, 0xC0, 0x00, 0x00, 0x00, 0x1E, 0x01, 
				 0x1A, 0x00, 0x00, 0x00, 0x18, 0x07, 0x04, 0x13, 
				 0xC4, 0x02, 0x1E, 0x00, 0x3F, 0xC0, 0x00, 0x00, 
				 0x1E, 0x01, 0x80, 0x1A, 0x00, 0x00, 0x1F, 0x01, 
				 0x00, 0x19, 0xC4, 0x02, 0x13, 0xEA, 0x00, 0x1E, 
				 0x00, 0xC0, 0xFF, 0x00, 0x00, 0x1E, 0x01, 0x1D, 
				 0x00, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 0xEA, 
				 0x00, 0x16, 0x02, 0x04, 0x00, 0x00, 0x13, 0xC0, 
				 0x00, 0x1E, 0x01, 0x00, 0x00, 0x00, 0x00, 0x19, 
				 0xC0, 0x00, 0x17, 0x4C, 0x00, 0xA0, 0x00, 0x00, 
				 0x00, 0x17, 0x6C, 0x00, 0x32, 0x00, 0x00, 0x00, 
				 0x13, 0xEA, 0x00, 0x1E, 0x00, 0xFF, 0xC0, 0x00, 
				 0x00, 0x1E, 0x01, 0x00, 0x0D, 0x00, 0x00, 0x1F, 
				 0x01, 0x00, 0x19, 0xEA, 0x00, 0x00, 0x00};

BYTE t5465_Mode_320x200x15_1[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x16, 0x05, 0x04, 0x00, 0x00, 0x16, 0xC0, 0x00, 
				 0x00, 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 
				 0x00, 0x1F, 0x01, 0x00, 0x18, 0xC5, 0x02, 0x18, 
				 0x07, 0x04, 0x15, 0xA0, 0x00, 0xFF, 0x00, 0x09, 
				 0xCE, 0x03, 0x06, 0x05, 0x09, 0xCE, 0x03, 0x09, 
				 0x00, 0x09, 0xCE, 0x03, 0x0A, 0x00, 0x09, 0xCE, 
				 0x03, 0x0B, 0x00, 0x16, 0x80, 0x00, 0x2F, 0x00, 
				 0x16, 0x84, 0x00, 0x42, 0x00, 0x16, 0x88, 0x00, 
				 0x74, 0x00, 0x16, 0xC0, 0x00, 0x00, 0x80, 0x1D, 
				 0x19, 0x00, 0x00, 0x00, 0x2D, 0x00, 0x00, 0x00, 
				 0x27, 0x00, 0x00, 0x00, 0x28, 0x00, 0x00, 0x00, 
				 0x8D, 0x00, 0x00, 0x00, 0x2A, 0x00, 0x00, 0x00, 
				 0x8B, 0x00, 0x00, 0x00, 0xA0, 0x00, 0x00, 0x00, 
				 0x1F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0xC0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x91, 0x00, 0x00, 0x00, 
				 0x84, 0x00, 0x00, 0x00, 0x8F, 0x00, 0x00, 0x00, 
				 0x50, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x90, 0x00, 0x00, 0x00, 0xA0, 0x00, 0x00, 0x00, 
				 0xE3, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 
				 0x1D, 0x06, 0x00, 0x64, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x40, 0x00, 0x00, 0x00, 0x22, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x13, 0xEA, 0x00, 
				 0x1E, 0x00, 0x00, 0xC0, 0x00, 0x00, 0x1E, 0x01, 
				 0x11, 0x0A, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 
				 0xEA, 0x00, 0x12, 0x07, 0x04, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x0A, 0x00, 0x00, 
				 0x00, 0x18, 0x07, 0x04, 0x13, 0xC4, 0x02, 0x1E, 
				 0x00, 0x3F, 0xC0, 0x00, 0x00, 0x1E, 0x01, 0x80, 
				 0x0A, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 0xC4, 
				 0x02, 0x16, 0x02, 0x04, 0x00, 0x20, 0x13, 0xC0, 
				 0x00, 0x1E, 0x01, 0x00, 0x16, 0x00, 0x00, 0x19, 
				 0xC0, 0x00, 0x17, 0x4C, 0x00, 0xA0, 0x00, 0x00, 
				 0x00, 0x13, 0xEA, 0x00, 0x1E, 0x00, 0xFF, 0xC0, 
				 0x00, 0x00, 0x1E, 0x01, 0x00, 0x05, 0x00, 0x00, 
				 0x1F, 0x01, 0x00, 0x19, 0xEA, 0x00, 0x00, 0x00};

BYTE t5465_Mode_320x240x15_1[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x16, 0x05, 0x04, 0x00, 0x00, 0x16, 0xC0, 0x00, 
				 0x00, 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 
				 0x00, 0x1F, 0x01, 0x00, 0x18, 0xC5, 0x02, 0x18, 
				 0x07, 0x04, 0x15, 0xA0, 0x00, 0xFF, 0x00, 0x09, 
				 0xCE, 0x03, 0x06, 0x05, 0x09, 0xCE, 0x03, 0x09, 
				 0x00, 0x09, 0xCE, 0x03, 0x0A, 0x00, 0x09, 0xCE, 
				 0x03, 0x0B, 0x00, 0x16, 0x80, 0x00, 0xEF, 0x00, 
				 0x16, 0x84, 0x00, 0x42, 0x00, 0x16, 0x88, 0x00, 
				 0x74, 0x00, 0x16, 0xC0, 0x00, 0x00, 0x80, 0x1D, 
				 0x19, 0x00, 0x00, 0x00, 0x2D, 0x00, 0x00, 0x00, 
				 0x27, 0x00, 0x00, 0x00, 0x27, 0x00, 0x00, 0x00, 
				 0x8C, 0x00, 0x00, 0x00, 0x2A, 0x00, 0x00, 0x00, 
				 0x8B, 0x00, 0x00, 0x00, 0x0B, 0x00, 0x00, 0x00, 
				 0x3E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0xC0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0xE1, 0x00, 0x00, 0x00, 
				 0x83, 0x00, 0x00, 0x00, 0xDF, 0x00, 0x00, 0x00, 
				 0x50, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0xDF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0xE3, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 
				 0x1D, 0x06, 0x00, 0x64, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x80, 0x00, 0x00, 0x00, 0x22, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x13, 0xEA, 0x00, 
				 0x1E, 0x00, 0x00, 0xC0, 0x00, 0x00, 0x1E, 0x01, 
				 0x11, 0x08, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 
				 0xEA, 0x00, 0x12, 0x07, 0x04, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x08, 0x00, 0x00, 
				 0x00, 0x18, 0x07, 0x04, 0x13, 0xC4, 0x02, 0x1E, 
				 0x00, 0x3F, 0xC0, 0x00, 0x00, 0x1E, 0x01, 0x80, 
				 0x08, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 0xC4, 
				 0x02, 0x16, 0x02, 0x04, 0x00, 0x20, 0x13, 0xC0, 
				 0x00, 0x1E, 0x01, 0x00, 0x16, 0x00, 0x00, 0x19, 
				 0xC0, 0x00, 0x17, 0x4C, 0x00, 0x80, 0x00, 0x00, 
				 0x00, 0x13, 0xEA, 0x00, 0x1E, 0x00, 0xFF, 0xC0, 
				 0x00, 0x00, 0x1E, 0x01, 0x00, 0x05, 0x00, 0x00, 
				 0x1F, 0x01, 0x00, 0x19, 0xEA, 0x00, 0x00, 0x00};

BYTE t5465_Mode_320x240x15_2[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x16, 0x05, 0x04, 0x00, 0x00, 0x16, 0xC0, 0x00, 
				 0x00, 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 
				 0x00, 0x1F, 0x01, 0x00, 0x18, 0xC5, 0x02, 0x18, 
				 0x07, 0x04, 0x15, 0xA0, 0x00, 0xFF, 0x00, 0x09, 
				 0xCE, 0x03, 0x06, 0x05, 0x09, 0xCE, 0x03, 0x09, 
				 0x00, 0x09, 0xCE, 0x03, 0x0A, 0x00, 0x09, 0xCE, 
				 0x03, 0x0B, 0x00, 0x16, 0x80, 0x00, 0xEF, 0x00, 
				 0x16, 0x84, 0x00, 0x0A, 0x00, 0x16, 0x88, 0x00, 
				 0x16, 0x00, 0x16, 0xC0, 0x00, 0x00, 0x80, 0x1D, 
				 0x19, 0x00, 0x00, 0x00, 0x2F, 0x00, 0x00, 0x00, 
				 0x27, 0x00, 0x00, 0x00, 0x27, 0x00, 0x00, 0x00, 
				 0x8C, 0x00, 0x00, 0x00, 0x2A, 0x00, 0x00, 0x00, 
				 0x8B, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 
				 0x3E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0xC0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0xE0, 0x00, 0x00, 0x00, 
				 0x83, 0x00, 0x00, 0x00, 0xDF, 0x00, 0x00, 0x00, 
				 0x50, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0xDF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0xE3, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 
				 0x1D, 0x06, 0x00, 0x64, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x80, 0x00, 0x00, 0x00, 0x22, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x13, 0xEA, 0x00, 
				 0x1E, 0x00, 0x00, 0xC0, 0x00, 0x00, 0x1E, 0x01, 
				 0x11, 0x08, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 
				 0xEA, 0x00, 0x12, 0x07, 0x04, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x08, 0x00, 0x00, 
				 0x00, 0x18, 0x07, 0x04, 0x13, 0xC4, 0x02, 0x1E, 
				 0x00, 0x3F, 0xC0, 0x00, 0x00, 0x1E, 0x01, 0x80, 
				 0x08, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 0xC4, 
				 0x02, 0x13, 0xEA, 0x00, 0x1E, 0x00, 0xC0, 0xFF, 
				 0x00, 0x00, 0x1E, 0x01, 0x14, 0x00, 0x00, 0x00, 
				 0x1F, 0x01, 0x00, 0x19, 0xEA, 0x00, 0x16, 0x02, 
				 0x04, 0x00, 0x20, 0x13, 0xC0, 0x00, 0x1E, 0x01, 
				 0x00, 0x16, 0x00, 0x00, 0x19, 0xC0, 0x00, 0x17, 
				 0x4C, 0x00, 0x80, 0x00, 0x00, 0x00, 0x13, 0xEA, 
				 0x00, 0x1E, 0x00, 0xFF, 0xC0, 0x00, 0x00, 0x1E, 
				 0x01, 0x00, 0x05, 0x00, 0x00, 0x1F, 0x01, 0x00, 
				 0x19, 0xEA, 0x00, 0x00, 0x00};

BYTE t5465_Mode_320x400x15_1[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x16, 0x05, 0x04, 0x00, 0x00, 0x16, 0xC0, 0x00, 
				 0x00, 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 
				 0x00, 0x1F, 0x01, 0x00, 0x18, 0xC5, 0x02, 0x18, 
				 0x07, 0x04, 0x15, 0xA0, 0x00, 0xFF, 0x00, 0x09, 
				 0xCE, 0x03, 0x06, 0x05, 0x09, 0xCE, 0x03, 0x09, 
				 0x00, 0x09, 0xCE, 0x03, 0x0A, 0x00, 0x09, 0xCE, 
				 0x03, 0x0B, 0x00, 0x16, 0x80, 0x00, 0x2F, 0x00, 
				 0x16, 0x84, 0x00, 0x42, 0x00, 0x16, 0x88, 0x00, 
				 0x74, 0x00, 0x16, 0xC0, 0x00, 0x00, 0x80, 0x1D, 
				 0x19, 0x00, 0x00, 0x00, 0x2D, 0x00, 0x00, 0x00, 
				 0x27, 0x00, 0x00, 0x00, 0x28, 0x00, 0x00, 0x00, 
				 0x8D, 0x00, 0x00, 0x00, 0x2A, 0x00, 0x00, 0x00, 
				 0x8B, 0x00, 0x00, 0x00, 0xA0, 0x00, 0x00, 0x00, 
				 0x1F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x91, 0x00, 0x00, 0x00, 
				 0x84, 0x00, 0x00, 0x00, 0x8F, 0x00, 0x00, 0x00, 
				 0x50, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x90, 0x00, 0x00, 0x00, 0xA0, 0x00, 0x00, 0x00, 
				 0xE3, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 
				 0x1D, 0x06, 0x00, 0x64, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x40, 0x00, 0x00, 0x00, 0x22, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x13, 0xEA, 0x00, 
				 0x1E, 0x00, 0x00, 0xC0, 0x00, 0x00, 0x1E, 0x01, 
				 0x11, 0x0A, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 
				 0xEA, 0x00, 0x12, 0x07, 0x04, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x0A, 0x00, 0x00, 
				 0x00, 0x18, 0x07, 0x04, 0x13, 0xC4, 0x02, 0x1E, 
				 0x00, 0x3F, 0xC0, 0x00, 0x00, 0x1E, 0x01, 0x80, 
				 0x0A, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 0xC4, 
				 0x02, 0x13, 0xEA, 0x00, 0x1E, 0x00, 0xC0, 0xFF, 
				 0x00, 0x00, 0x1E, 0x01, 0x19, 0x00, 0x00, 0x00, 
				 0x1F, 0x01, 0x00, 0x19, 0xEA, 0x00, 0x16, 0x02, 
				 0x04, 0x00, 0x20, 0x13, 0xC0, 0x00, 0x1E, 0x01, 
				 0x00, 0x16, 0x00, 0x00, 0x19, 0xC0, 0x00, 0x17, 
				 0x4C, 0x00, 0xA0, 0x00, 0x00, 0x00, 0x13, 0xEA, 
				 0x00, 0x1E, 0x00, 0xFF, 0xC0, 0x00, 0x00, 0x1E, 
				 0x01, 0x00, 0x05, 0x00, 0x00, 0x1F, 0x01, 0x00, 
				 0x19, 0xEA, 0x00, 0x00, 0x00};

BYTE t5465_Mode_320x480x15_1[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x16, 0x05, 0x04, 0x00, 0x00, 0x16, 0xC0, 0x00, 
				 0x00, 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 
				 0x00, 0x1F, 0x01, 0x00, 0x18, 0xC5, 0x02, 0x18, 
				 0x07, 0x04, 0x15, 0xA0, 0x00, 0xFF, 0x00, 0x09, 
				 0xCE, 0x03, 0x06, 0x05, 0x09, 0xCE, 0x03, 0x09, 
				 0x00, 0x09, 0xCE, 0x03, 0x0A, 0x00, 0x09, 0xCE, 
				 0x03, 0x0B, 0x00, 0x16, 0x80, 0x00, 0xEF, 0x00, 
				 0x16, 0x84, 0x00, 0x42, 0x00, 0x16, 0x88, 0x00, 
				 0x74, 0x00, 0x16, 0xC0, 0x00, 0x00, 0x80, 0x1D, 
				 0x19, 0x00, 0x00, 0x00, 0x2D, 0x00, 0x00, 0x00, 
				 0x27, 0x00, 0x00, 0x00, 0x27, 0x00, 0x00, 0x00, 
				 0x8C, 0x00, 0x00, 0x00, 0x2A, 0x00, 0x00, 0x00, 
				 0x8B, 0x00, 0x00, 0x00, 0x0B, 0x00, 0x00, 0x00, 
				 0x3E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0xC0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0xE1, 0x00, 0x00, 0x00, 
				 0x83, 0x00, 0x00, 0x00, 0xDF, 0x00, 0x00, 0x00, 
				 0x50, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0xDF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0xE3, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 
				 0x1D, 0x06, 0x00, 0x64, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x80, 0x00, 0x00, 0x00, 0x22, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x17, 0x24, 0x00, 
				 0x40, 0x00, 0x00, 0x00, 0x13, 0xEA, 0x00, 0x1E, 
				 0x00, 0xFF, 0xC0, 0x00, 0x00, 0x1E, 0x01, 0x00, 
				 0x03, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 0xEA, 
				 0x00, 0x13, 0xEA, 0x00, 0x1E, 0x00, 0x00, 0xC0, 
				 0x00, 0x00, 0x1E, 0x01, 0x11, 0x0A, 0x00, 0x00, 
				 0x1F, 0x01, 0x00, 0x19, 0xEA, 0x00, 0x12, 0x07, 
				 0x04, 0x1E, 0x00, 0xC0, 0x00, 0x00, 0x00, 0x1E, 
				 0x01, 0x0A, 0x00, 0x00, 0x00, 0x18, 0x07, 0x04, 
				 0x13, 0xC4, 0x02, 0x1E, 0x00, 0x3F, 0xC0, 0x00, 
				 0x00, 0x1E, 0x01, 0x80, 0x0A, 0x00, 0x00, 0x1F, 
				 0x01, 0x00, 0x19, 0xC4, 0x02, 0x16, 0x02, 0x04, 
				 0x00, 0x20, 0x13, 0xC0, 0x00, 0x1E, 0x01, 0x00, 
				 0x16, 0x00, 0x00, 0x19, 0xC0, 0x00, 0x17, 0x4C, 
				 0x00, 0xA0, 0x00, 0x00, 0x00, 0x13, 0xEA, 0x00, 
				 0x1E, 0x00, 0xFF, 0xC0, 0x00, 0x00, 0x1E, 0x01, 
				 0x00, 0x05, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 
				 0xEA, 0x00, 0x00, 0x00};

BYTE t5465_Mode_320x480x15_2[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x16, 0x05, 0x04, 0x00, 0x00, 0x16, 0xC0, 0x00, 
				 0x00, 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 
				 0x00, 0x1F, 0x01, 0x00, 0x18, 0xC5, 0x02, 0x18, 
				 0x07, 0x04, 0x15, 0xA0, 0x00, 0xFF, 0x00, 0x09, 
				 0xCE, 0x03, 0x06, 0x05, 0x09, 0xCE, 0x03, 0x09, 
				 0x00, 0x09, 0xCE, 0x03, 0x0A, 0x00, 0x09, 0xCE, 
				 0x03, 0x0B, 0x00, 0x16, 0x80, 0x00, 0xEF, 0x00, 
				 0x16, 0x84, 0x00, 0x0A, 0x00, 0x16, 0x88, 0x00, 
				 0x16, 0x00, 0x16, 0xC0, 0x00, 0x00, 0x80, 0x1D, 
				 0x19, 0x00, 0x00, 0x00, 0x2F, 0x00, 0x00, 0x00, 
				 0x27, 0x00, 0x00, 0x00, 0x27, 0x00, 0x00, 0x00, 
				 0x8C, 0x00, 0x00, 0x00, 0x2A, 0x00, 0x00, 0x00, 
				 0x8B, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 
				 0x3E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0xC0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0xE0, 0x00, 0x00, 0x00, 
				 0x83, 0x00, 0x00, 0x00, 0xDF, 0x00, 0x00, 0x00, 
				 0x50, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0xDF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0xE3, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 
				 0x1D, 0x06, 0x00, 0x64, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x80, 0x00, 0x00, 0x00, 0x22, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x17, 0x24, 0x00, 
				 0x40, 0x00, 0x00, 0x00, 0x13, 0xEA, 0x00, 0x1E, 
				 0x00, 0xFF, 0xC0, 0x00, 0x00, 0x1E, 0x01, 0x00, 
				 0x03, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 0xEA, 
				 0x00, 0x13, 0xEA, 0x00, 0x1E, 0x00, 0x00, 0xC0, 
				 0x00, 0x00, 0x1E, 0x01, 0x11, 0x0A, 0x00, 0x00, 
				 0x1F, 0x01, 0x00, 0x19, 0xEA, 0x00, 0x12, 0x07, 
				 0x04, 0x1E, 0x00, 0xC0, 0x00, 0x00, 0x00, 0x1E, 
				 0x01, 0x0A, 0x00, 0x00, 0x00, 0x18, 0x07, 0x04, 
				 0x13, 0xC4, 0x02, 0x1E, 0x00, 0x3F, 0xC0, 0x00, 
				 0x00, 0x1E, 0x01, 0x80, 0x0A, 0x00, 0x00, 0x1F, 
				 0x01, 0x00, 0x19, 0xC4, 0x02, 0x16, 0x02, 0x04, 
				 0x00, 0x20, 0x13, 0xC0, 0x00, 0x1E, 0x01, 0x00, 
				 0x16, 0x00, 0x00, 0x19, 0xC0, 0x00, 0x17, 0x4C, 
				 0x00, 0xA0, 0x00, 0x00, 0x00, 0x13, 0xEA, 0x00, 
				 0x1E, 0x00, 0xFF, 0xC0, 0x00, 0x00, 0x1E, 0x01, 
				 0x00, 0x05, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 
				 0xEA, 0x00, 0x00, 0x00};

BYTE t5465_Mode_360x400x15_1[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x16, 0x05, 0x04, 0x00, 0x00, 0x16, 0xC0, 0x00, 
				 0x00, 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 
				 0x00, 0x1F, 0x01, 0x00, 0x18, 0xC5, 0x02, 0x18, 
				 0x07, 0x04, 0x15, 0xA0, 0x00, 0xFF, 0x00, 0x09, 
				 0xCE, 0x03, 0x06, 0x05, 0x09, 0xCE, 0x03, 0x09, 
				 0x00, 0x09, 0xCE, 0x03, 0x0A, 0x00, 0x09, 0xCE, 
				 0x03, 0x0B, 0x00, 0x16, 0x80, 0x00, 0x2F, 0x00, 
				 0x16, 0x84, 0x00, 0x04, 0x00, 0x16, 0x88, 0x00, 
				 0x08, 0x00, 0x16, 0xC0, 0x00, 0x00, 0x80, 0x1D, 
				 0x19, 0x00, 0x00, 0x00, 0x34, 0x00, 0x00, 0x00, 
				 0x2C, 0x00, 0x00, 0x00, 0x2D, 0x00, 0x00, 0x00, 
				 0x94, 0x00, 0x00, 0x00, 0x2F, 0x00, 0x00, 0x00, 
				 0x92, 0x00, 0x00, 0x00, 0xA0, 0x00, 0x00, 0x00, 
				 0x1F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x91, 0x00, 0x00, 0x00, 
				 0x84, 0x00, 0x00, 0x00, 0x8F, 0x00, 0x00, 0x00, 
				 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x90, 0x00, 0x00, 0x00, 0xA0, 0x00, 0x00, 0x00, 
				 0xE3, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 
				 0x1D, 0x06, 0x00, 0x64, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x40, 0x00, 0x00, 0x00, 0x22, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x13, 0xEA, 0x00, 
				 0x1E, 0x00, 0x00, 0xC0, 0x00, 0x00, 0x1E, 0x01, 
				 0x11, 0x08, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 
				 0xEA, 0x00, 0x12, 0x07, 0x04, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x08, 0x00, 0x00, 
				 0x00, 0x18, 0x07, 0x04, 0x13, 0xC4, 0x02, 0x1E, 
				 0x00, 0x3F, 0xC0, 0x00, 0x00, 0x1E, 0x01, 0x80, 
				 0x08, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 0xC4, 
				 0x02, 0x16, 0x02, 0x04, 0x00, 0x20, 0x13, 0xC0, 
				 0x00, 0x1E, 0x01, 0x00, 0x16, 0x00, 0x00, 0x19, 
				 0xC0, 0x00, 0x17, 0x4C, 0x00, 0x80, 0x00, 0x00, 
				 0x00, 0x13, 0xEA, 0x00, 0x1E, 0x00, 0xFF, 0xC0, 
				 0x00, 0x00, 0x1E, 0x01, 0x00, 0x06, 0x00, 0x00, 
				 0x1F, 0x01, 0x00, 0x19, 0xEA, 0x00, 0x00, 0x4C};

BYTE t5465_Mode_360x400x15_2[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x16, 0x05, 0x04, 0x00, 0x00, 0x16, 0xC0, 0x00, 
				 0x00, 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 
				 0x00, 0x1F, 0x01, 0x00, 0x18, 0xC5, 0x02, 0x18, 
				 0x07, 0x04, 0x15, 0xA0, 0x00, 0xFF, 0x00, 0x09, 
				 0xCE, 0x03, 0x06, 0x05, 0x09, 0xCE, 0x03, 0x09, 
				 0x00, 0x09, 0xCE, 0x03, 0x0A, 0x00, 0x09, 0xCE, 
				 0x03, 0x0B, 0x00, 0x16, 0x80, 0x00, 0x6F, 0x00, 
				 0x16, 0x84, 0x00, 0x32, 0x00, 0x16, 0x88, 0x00, 
				 0x7C, 0x00, 0x16, 0xC0, 0x00, 0x00, 0x80, 0x1D, 
				 0x19, 0x00, 0x00, 0x00, 0x35, 0x00, 0x00, 0x00, 
				 0x2C, 0x00, 0x00, 0x00, 0x2C, 0x00, 0x00, 0x00, 
				 0x93, 0x00, 0x00, 0x00, 0x2F, 0x00, 0x00, 0x00, 
				 0x90, 0x00, 0x00, 0x00, 0xBC, 0x00, 0x00, 0x00, 
				 0x1F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x90, 0x00, 0x00, 0x00, 
				 0x83, 0x00, 0x00, 0x00, 0x8F, 0x00, 0x00, 0x00, 
				 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x8F, 0x00, 0x00, 0x00, 0xBC, 0x00, 0x00, 0x00, 
				 0xE3, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 
				 0x1D, 0x06, 0x00, 0x64, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x40, 0x00, 0x00, 0x00, 0x22, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x13, 0xEA, 0x00, 
				 0x1E, 0x00, 0x00, 0xC0, 0x00, 0x00, 0x1E, 0x01, 
				 0x11, 0x08, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 
				 0xEA, 0x00, 0x12, 0x07, 0x04, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x08, 0x00, 0x00, 
				 0x00, 0x18, 0x07, 0x04, 0x13, 0xC4, 0x02, 0x1E, 
				 0x00, 0x3F, 0xC0, 0x00, 0x00, 0x1E, 0x01, 0x80, 
				 0x08, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 0xC4, 
				 0x02, 0x16, 0x02, 0x04, 0x00, 0x20, 0x13, 0xC0, 
				 0x00, 0x1E, 0x01, 0x00, 0x16, 0x00, 0x00, 0x19, 
				 0xC0, 0x00, 0x17, 0x4C, 0x00, 0x80, 0x00, 0x00, 
				 0x00, 0x13, 0xEA, 0x00, 0x1E, 0x00, 0xFF, 0xC0, 
				 0x00, 0x00, 0x1E, 0x01, 0x00, 0x06, 0x00, 0x00, 
				 0x1F, 0x01, 0x00, 0x19, 0xEA, 0x00, 0x00, 0x4C};

BYTE t5465_Mode_400x300x15_1[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x16, 0x05, 0x04, 0x00, 0x00, 0x16, 0xC0, 0x00, 
				 0x00, 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 
				 0x00, 0x1F, 0x01, 0x00, 0x18, 0xC5, 0x02, 0x18, 
				 0x07, 0x04, 0x15, 0xA0, 0x00, 0xFF, 0x00, 0x09, 
				 0xCE, 0x03, 0x06, 0x05, 0x09, 0xCE, 0x03, 0x09, 
				 0x00, 0x09, 0xCE, 0x03, 0x0A, 0x00, 0x09, 0xCE, 
				 0x03, 0x0B, 0x00, 0x16, 0x80, 0x00, 0x2F, 0x00, 
				 0x16, 0x84, 0x00, 0x18, 0x00, 0x16, 0x88, 0x00, 
				 0x43, 0x00, 0x16, 0xC0, 0x00, 0x00, 0x80, 0x1D, 
				 0x19, 0x00, 0x00, 0x00, 0x3D, 0x00, 0x00, 0x00, 
				 0x31, 0x00, 0x00, 0x00, 0x31, 0x00, 0x00, 0x00, 
				 0x99, 0x00, 0x00, 0x00, 0x35, 0x00, 0x00, 0x00, 
				 0x96, 0x00, 0x00, 0x00, 0x72, 0x00, 0x00, 0x00, 
				 0xF0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0xE0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x58, 0x00, 0x00, 0x00, 
				 0x8C, 0x00, 0x00, 0x00, 0x57, 0x00, 0x00, 0x00, 
				 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x57, 0x00, 0x00, 0x00, 0x72, 0x00, 0x00, 0x00, 
				 0xE3, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 
				 0x1D, 0x06, 0x00, 0x64, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x80, 0x00, 0x00, 0x00, 0x22, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x13, 0xEA, 0x00, 
				 0x1E, 0x00, 0x00, 0xC0, 0x00, 0x00, 0x1E, 0x01, 
				 0x11, 0x08, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 
				 0xEA, 0x00, 0x12, 0x07, 0x04, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x08, 0x00, 0x00, 
				 0x00, 0x18, 0x07, 0x04, 0x13, 0xC4, 0x02, 0x1E, 
				 0x00, 0x3F, 0xC0, 0x00, 0x00, 0x1E, 0x01, 0x80, 
				 0x08, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 0xC4, 
				 0x02, 0x16, 0x02, 0x04, 0x00, 0x20, 0x13, 0xC0, 
				 0x00, 0x1E, 0x01, 0x00, 0x16, 0x00, 0x00, 0x19, 
				 0xC0, 0x00, 0x17, 0x4C, 0x00, 0x80, 0x00, 0x00, 
				 0x00, 0x13, 0xEA, 0x00, 0x1E, 0x00, 0xFF, 0xC0, 
				 0x00, 0x00, 0x1E, 0x01, 0x00, 0x07, 0x00, 0x00, 
				 0x1F, 0x01, 0x00, 0x19, 0xEA, 0x00, 0x00, 0x4C};

BYTE t5465_Mode_400x300x15_2[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x16, 0x05, 0x04, 0x00, 0x00, 0x16, 0xC0, 0x00, 
				 0x00, 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 
				 0x00, 0x1F, 0x01, 0x00, 0x18, 0xC5, 0x02, 0x18, 
				 0x07, 0x04, 0x15, 0xA0, 0x00, 0xFF, 0x00, 0x09, 
				 0xCE, 0x03, 0x06, 0x05, 0x09, 0xCE, 0x03, 0x09, 
				 0x00, 0x09, 0xCE, 0x03, 0x0A, 0x00, 0x09, 0xCE, 
				 0x03, 0x0B, 0x00, 0x16, 0x80, 0x00, 0x2F, 0x00, 
				 0x16, 0x84, 0x00, 0x16, 0x00, 0x16, 0x88, 0x00, 
				 0x4C, 0x00, 0x16, 0xC0, 0x00, 0x00, 0x80, 0x1D, 
				 0x19, 0x00, 0x00, 0x00, 0x3D, 0x00, 0x00, 0x00, 
				 0x31, 0x00, 0x00, 0x00, 0x31, 0x00, 0x00, 0x00, 
				 0x99, 0x00, 0x00, 0x00, 0x34, 0x00, 0x00, 0x00, 
				 0x96, 0x00, 0x00, 0x00, 0x6F, 0x00, 0x00, 0x00, 
				 0xF0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0xE0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x58, 0x00, 0x00, 0x00, 
				 0x8B, 0x00, 0x00, 0x00, 0x57, 0x00, 0x00, 0x00, 
				 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x57, 0x00, 0x00, 0x00, 0x6F, 0x00, 0x00, 0x00, 
				 0xE3, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 
				 0x1D, 0x06, 0x00, 0x64, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x80, 0x00, 0x00, 0x00, 0x22, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x13, 0xEA, 0x00, 
				 0x1E, 0x00, 0x00, 0xC0, 0x00, 0x00, 0x1E, 0x01, 
				 0x11, 0x08, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 
				 0xEA, 0x00, 0x12, 0x07, 0x04, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x08, 0x00, 0x00, 
				 0x00, 0x18, 0x07, 0x04, 0x13, 0xC4, 0x02, 0x1E, 
				 0x00, 0x3F, 0xC0, 0x00, 0x00, 0x1E, 0x01, 0x80, 
				 0x08, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 0xC4, 
				 0x02, 0x13, 0xEA, 0x00, 0x1E, 0x00, 0xC0, 0xFF, 
				 0x00, 0x00, 0x1E, 0x01, 0x12, 0x00, 0x00, 0x00, 
				 0x1F, 0x01, 0x00, 0x19, 0xEA, 0x00, 0x16, 0x02, 
				 0x04, 0x00, 0x20, 0x13, 0xC0, 0x00, 0x1E, 0x01, 
				 0x00, 0x16, 0x00, 0x00, 0x19, 0xC0, 0x00, 0x17, 
				 0x4C, 0x00, 0x80, 0x00, 0x00, 0x00, 0x13, 0xEA, 
				 0x00, 0x1E, 0x00, 0xFF, 0xC0, 0x00, 0x00, 0x1E, 
				 0x01, 0x00, 0x07, 0x00, 0x00, 0x1F, 0x01, 0x00, 
				 0x19, 0xEA, 0x00, 0x00, 0x1F};

BYTE t5465_Mode_512x384x15_1[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x16, 0x05, 0x04, 0x00, 0x00, 0x16, 0xC0, 0x00, 
				 0x00, 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 
				 0x00, 0x1F, 0x01, 0x00, 0x18, 0xC5, 0x02, 0x18, 
				 0x07, 0x04, 0x15, 0xA0, 0x00, 0xFF, 0x00, 0x09, 
				 0xCE, 0x03, 0x06, 0x05, 0x09, 0xCE, 0x03, 0x09, 
				 0x00, 0x09, 0xCE, 0x03, 0x0A, 0x00, 0x09, 0xCE, 
				 0x03, 0x0B, 0x00, 0x16, 0x80, 0x00, 0xEF, 0x00, 
				 0x16, 0x84, 0x00, 0x31, 0x00, 0x16, 0x88, 0x00, 
				 0x6D, 0x00, 0x1D, 0x19, 0x00, 0x00, 0x00, 0x4F, 
				 0x00, 0x00, 0x00, 0x3F, 0x00, 0x00, 0x00, 0x3F, 
				 0x00, 0x00, 0x00, 0x89, 0x00, 0x00, 0x00, 0x42, 
				 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x24, 
				 0x00, 0x00, 0x00, 0xF5, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0xE0, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 
				 0x00, 0x00, 0x00, 0x88, 0x00, 0x00, 0x00, 0xFF, 
				 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 0x24, 
				 0x00, 0x00, 0x00, 0xE3, 0x00, 0x00, 0x00, 0xFF, 
				 0x00, 0x00, 0x00, 0x1D, 0x06, 0x00, 0x64, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0xD0, 0x00, 0x00, 0x00, 
				 0x22, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x13, 0xEA, 0x00, 0x1E, 0x00, 0x00, 0xC0, 0x00, 
				 0x00, 0x1E, 0x01, 0x11, 0x08, 0x00, 0x00, 0x1F, 
				 0x01, 0x00, 0x19, 0xEA, 0x00, 0x12, 0x07, 0x04, 
				 0x1E, 0x00, 0xC0, 0x00, 0x00, 0x00, 0x1E, 0x01, 
				 0x08, 0x00, 0x00, 0x00, 0x18, 0x07, 0x04, 0x13, 
				 0xC4, 0x02, 0x1E, 0x00, 0x3F, 0xC0, 0x00, 0x00, 
				 0x1E, 0x01, 0x80, 0x08, 0x00, 0x00, 0x1F, 0x01, 
				 0x00, 0x19, 0xC4, 0x02, 0x13, 0xEA, 0x00, 0x1E, 
				 0x00, 0xC0, 0xFF, 0x00, 0x00, 0x1E, 0x01, 0x12, 
				 0x00, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 0xEA, 
				 0x00, 0x16, 0x02, 0x04, 0x00, 0x20, 0x13, 0xC0, 
				 0x00, 0x1E, 0x01, 0x00, 0x16, 0x00, 0x00, 0x19, 
				 0xC0, 0x00, 0x17, 0x4C, 0x00, 0x80, 0x00, 0x00, 
				 0x00, 0x13, 0xEA, 0x00, 0x1E, 0x00, 0xFF, 0xC0, 
				 0x00, 0x00, 0x1E, 0x01, 0x00, 0x08, 0x00, 0x00, 
				 0x1F, 0x01, 0x00, 0x19, 0xEA, 0x00, 0x00, 0x00};

BYTE t5465_Mode_512x384x15_2[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x16, 0x05, 0x04, 0x00, 0x00, 0x16, 0xC0, 0x00, 
				 0x00, 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 
				 0x00, 0x1F, 0x01, 0x00, 0x18, 0xC5, 0x02, 0x18, 
				 0x07, 0x04, 0x15, 0xA0, 0x00, 0xFF, 0x00, 0x09, 
				 0xCE, 0x03, 0x06, 0x05, 0x09, 0xCE, 0x03, 0x09, 
				 0x00, 0x09, 0xCE, 0x03, 0x0A, 0x00, 0x09, 0xCE, 
				 0x03, 0x0B, 0x00, 0x16, 0x80, 0x00, 0xEF, 0x00, 
				 0x16, 0x84, 0x00, 0x2B, 0x00, 0x16, 0x88, 0x00, 
				 0x6E, 0x00, 0x1D, 0x19, 0x00, 0x00, 0x00, 0x4E, 
				 0x00, 0x00, 0x00, 0x3F, 0x00, 0x00, 0x00, 0x3F, 
				 0x00, 0x00, 0x00, 0x88, 0x00, 0x00, 0x00, 0x42, 
				 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x24, 
				 0x00, 0x00, 0x00, 0xF5, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0xE0, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 
				 0x00, 0x00, 0x00, 0x88, 0x00, 0x00, 0x00, 0xFF, 
				 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 0x23, 
				 0x00, 0x00, 0x00, 0xE3, 0x00, 0x00, 0x00, 0xFF, 
				 0x00, 0x00, 0x00, 0x1D, 0x06, 0x00, 0x64, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0xD0, 0x00, 0x00, 0x00, 
				 0x22, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x13, 0xEA, 0x00, 0x1E, 0x00, 0x00, 0xC0, 0x00, 
				 0x00, 0x1E, 0x01, 0x11, 0x08, 0x00, 0x00, 0x1F, 
				 0x01, 0x00, 0x19, 0xEA, 0x00, 0x12, 0x07, 0x04, 
				 0x1E, 0x00, 0xC0, 0x00, 0x00, 0x00, 0x1E, 0x01, 
				 0x08, 0x00, 0x00, 0x00, 0x18, 0x07, 0x04, 0x13, 
				 0xC4, 0x02, 0x1E, 0x00, 0x3F, 0xC0, 0x00, 0x00, 
				 0x1E, 0x01, 0x80, 0x08, 0x00, 0x00, 0x1F, 0x01, 
				 0x00, 0x19, 0xC4, 0x02, 0x13, 0xEA, 0x00, 0x1E, 
				 0x00, 0xC0, 0xFF, 0x00, 0x00, 0x1E, 0x01, 0x12, 
				 0x00, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 0xEA, 
				 0x00, 0x16, 0x02, 0x04, 0x00, 0x20, 0x13, 0xC0, 
				 0x00, 0x1E, 0x01, 0x00, 0x16, 0x00, 0x00, 0x19, 
				 0xC0, 0x00, 0x17, 0x4C, 0x00, 0x80, 0x00, 0x00, 
				 0x00, 0x13, 0xEA, 0x00, 0x1E, 0x00, 0xFF, 0xC0, 
				 0x00, 0x00, 0x1E, 0x01, 0x00, 0x08, 0x00, 0x00, 
				 0x1F, 0x01, 0x00, 0x19, 0xEA, 0x00, 0x00, 0x00};

BYTE t5465_Mode_512x480x15_1[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x16, 0x05, 0x04, 0x00, 0x00, 0x16, 0xC0, 0x00, 
				 0x00, 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 
				 0x00, 0x1F, 0x01, 0x00, 0x18, 0xC5, 0x02, 0x18, 
				 0x07, 0x04, 0x15, 0xA0, 0x00, 0xFF, 0x00, 0x09, 
				 0xCE, 0x03, 0x06, 0x05, 0x09, 0xCE, 0x03, 0x09, 
				 0x00, 0x09, 0xCE, 0x03, 0x0A, 0x00, 0x09, 0xCE, 
				 0x03, 0x0B, 0x00, 0x16, 0x80, 0x00, 0x2F, 0x00, 
				 0x16, 0x84, 0x00, 0x10, 0x00, 0x16, 0x88, 0x00, 
				 0x2D, 0x00, 0x16, 0xC0, 0x00, 0x00, 0x80, 0x1D, 
				 0x19, 0x00, 0x00, 0x00, 0x4B, 0x00, 0x00, 0x00, 
				 0x3F, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 
				 0x4B, 0x00, 0x00, 0x00, 0x44, 0x00, 0x00, 0x00, 
				 0x08, 0x00, 0x00, 0x00, 0xF0, 0x00, 0x00, 0x00, 
				 0x1F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0xE1, 0x00, 0x00, 0x00, 
				 0x84, 0x00, 0x00, 0x00, 0xDF, 0x00, 0x00, 0x00, 
				 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0xE0, 0x00, 0x00, 0x00, 0xF0, 0x00, 0x00, 0x00, 
				 0xE3, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 
				 0x1D, 0x06, 0x00, 0x64, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x50, 0x00, 0x00, 0x00, 0x22, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x13, 0xEA, 0x00, 
				 0x1E, 0x00, 0x00, 0xC0, 0x00, 0x00, 0x1E, 0x01, 
				 0x11, 0x08, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 
				 0xEA, 0x00, 0x12, 0x07, 0x04, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x08, 0x00, 0x00, 
				 0x00, 0x18, 0x07, 0x04, 0x13, 0xC4, 0x02, 0x1E, 
				 0x00, 0x3F, 0xC0, 0x00, 0x00, 0x1E, 0x01, 0x80, 
				 0x08, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 0xC4, 
				 0x02, 0x13, 0xEA, 0x00, 0x1E, 0x00, 0xC0, 0xFF, 
				 0x00, 0x00, 0x1E, 0x01, 0x12, 0x00, 0x00, 0x00, 
				 0x1F, 0x01, 0x00, 0x19, 0xEA, 0x00, 0x16, 0x02, 
				 0x04, 0x00, 0x20, 0x13, 0xC0, 0x00, 0x1E, 0x01, 
				 0x00, 0x16, 0x00, 0x00, 0x19, 0xC0, 0x00, 0x17, 
				 0x4C, 0x00, 0x80, 0x00, 0x00, 0x00, 0x13, 0xEA, 
				 0x00, 0x1E, 0x00, 0xFF, 0xC0, 0x00, 0x00, 0x1E, 
				 0x01, 0x00, 0x08, 0x00, 0x00, 0x1F, 0x01, 0x00, 
				 0x19, 0xEA, 0x00, 0x00, 0x1F};

BYTE t5465_Mode_512x480x15_2[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x16, 0x05, 0x04, 0x00, 0x00, 0x16, 0xC0, 0x00, 
				 0x00, 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 
				 0x00, 0x1F, 0x01, 0x00, 0x18, 0xC5, 0x02, 0x18, 
				 0x07, 0x04, 0x15, 0xA0, 0x00, 0xFF, 0x00, 0x09, 
				 0xCE, 0x03, 0x06, 0x05, 0x09, 0xCE, 0x03, 0x09, 
				 0x00, 0x09, 0xCE, 0x03, 0x0A, 0x00, 0x09, 0xCE, 
				 0x03, 0x0B, 0x00, 0x16, 0x80, 0x00, 0x2F, 0x00, 
				 0x16, 0x84, 0x00, 0x12, 0x00, 0x16, 0x88, 0x00, 
				 0x3E, 0x00, 0x16, 0xC0, 0x00, 0x00, 0x80, 0x1D, 
				 0x19, 0x00, 0x00, 0x00, 0x4D, 0x00, 0x00, 0x00, 
				 0x3F, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 
				 0x8D, 0x00, 0x00, 0x00, 0x44, 0x00, 0x00, 0x00, 
				 0x09, 0x00, 0x00, 0x00, 0xF4, 0x00, 0x00, 0x00, 
				 0x1F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0xE1, 0x00, 0x00, 0x00, 
				 0x84, 0x00, 0x00, 0x00, 0xDF, 0x00, 0x00, 0x00, 
				 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0xE0, 0x00, 0x00, 0x00, 0xF4, 0x00, 0x00, 0x00, 
				 0xE3, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 
				 0x1D, 0x06, 0x00, 0x64, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x50, 0x00, 0x00, 0x00, 0x22, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x13, 0xEA, 0x00, 
				 0x1E, 0x00, 0x00, 0xC0, 0x00, 0x00, 0x1E, 0x01, 
				 0x11, 0x08, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 
				 0xEA, 0x00, 0x12, 0x07, 0x04, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x08, 0x00, 0x00, 
				 0x00, 0x18, 0x07, 0x04, 0x13, 0xC4, 0x02, 0x1E, 
				 0x00, 0x3F, 0xC0, 0x00, 0x00, 0x1E, 0x01, 0x80, 
				 0x08, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 0xC4, 
				 0x02, 0x13, 0xEA, 0x00, 0x1E, 0x00, 0xC0, 0xFF, 
				 0x00, 0x00, 0x1E, 0x01, 0x12, 0x00, 0x00, 0x00, 
				 0x1F, 0x01, 0x00, 0x19, 0xEA, 0x00, 0x16, 0x02, 
				 0x04, 0x00, 0x20, 0x13, 0xC0, 0x00, 0x1E, 0x01, 
				 0x00, 0x16, 0x00, 0x00, 0x19, 0xC0, 0x00, 0x17, 
				 0x4C, 0x00, 0x80, 0x00, 0x00, 0x00, 0x13, 0xEA, 
				 0x00, 0x1E, 0x00, 0xFF, 0xC0, 0x00, 0x00, 0x1E, 
				 0x01, 0x00, 0x08, 0x00, 0x00, 0x1F, 0x01, 0x00, 
				 0x19, 0xEA, 0x00, 0x00, 0x1F};

BYTE t5465_Mode_640x350x15_1[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x16, 0x05, 0x04, 0x00, 0x00, 0x16, 0xC0, 0x00, 
				 0x00, 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 
				 0x00, 0x1F, 0x01, 0x00, 0x18, 0xC5, 0x02, 0x18, 
				 0x07, 0x04, 0x15, 0xA0, 0x00, 0xFF, 0x00, 0x09, 
				 0xCE, 0x03, 0x06, 0x05, 0x09, 0xCE, 0x03, 0x09, 
				 0x00, 0x09, 0xCE, 0x03, 0x0A, 0x00, 0x09, 0xCE, 
				 0x03, 0x0B, 0x00, 0x16, 0x80, 0x00, 0xAF, 0x00, 
				 0x16, 0x84, 0x00, 0x3B, 0x00, 0x16, 0x88, 0x00, 
				 0x69, 0x00, 0x1D, 0x19, 0x00, 0x00, 0x00, 0x63, 
				 0x00, 0x00, 0x00, 0x4F, 0x00, 0x00, 0x00, 0x4F, 
				 0x00, 0x00, 0x00, 0x83, 0x00, 0x00, 0x00, 0x53, 
				 0x00, 0x00, 0x00, 0x97, 0x00, 0x00, 0x00, 0xBB, 
				 0x00, 0x00, 0x00, 0x1F, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7D, 
				 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x5D, 
				 0x00, 0x00, 0x00, 0xA0, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x5D, 0x00, 0x00, 0x00, 0xBB, 
				 0x00, 0x00, 0x00, 0xE3, 0x00, 0x00, 0x00, 0xFF, 
				 0x00, 0x00, 0x00, 0x1D, 0x06, 0x00, 0x64, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x50, 0x00, 0x00, 0x00, 
				 0x22, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x13, 0xEA, 0x00, 0x1E, 0x00, 0x00, 0xC0, 0x00, 
				 0x00, 0x1E, 0x01, 0x11, 0x0A, 0x00, 0x00, 0x1F, 
				 0x01, 0x00, 0x19, 0xEA, 0x00, 0x12, 0x07, 0x04, 
				 0x1E, 0x00, 0xC0, 0x00, 0x00, 0x00, 0x1E, 0x01, 
				 0x0A, 0x00, 0x00, 0x00, 0x18, 0x07, 0x04, 0x13, 
				 0xC4, 0x02, 0x1E, 0x00, 0x3F, 0xC0, 0x00, 0x00, 
				 0x1E, 0x01, 0x80, 0x0A, 0x00, 0x00, 0x1F, 0x01, 
				 0x00, 0x19, 0xC4, 0x02, 0x13, 0xEA, 0x00, 0x1E, 
				 0x00, 0xC0, 0xFF, 0x00, 0x00, 0x1E, 0x01, 0x12, 
				 0x00, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 0xEA, 
				 0x00, 0x16, 0x02, 0x04, 0x00, 0x20, 0x13, 0xC0, 
				 0x00, 0x1E, 0x01, 0x00, 0x16, 0x00, 0x00, 0x19, 
				 0xC0, 0x00, 0x17, 0x4C, 0x00, 0xA0, 0x00, 0x00, 
				 0x00, 0x13, 0xEA, 0x00, 0x1E, 0x00, 0xFF, 0xC0, 
				 0x00, 0x00, 0x1E, 0x01, 0x00, 0x0A, 0x00, 0x00, 
				 0x1F, 0x01, 0x00, 0x19, 0xEA, 0x00, 0x00, 0x00};

BYTE t5465_Mode_640x350x15_2[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x16, 0x05, 0x04, 0x00, 0x00, 0x16, 0xC0, 0x00, 
				 0x00, 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 
				 0x00, 0x1F, 0x01, 0x00, 0x18, 0xC5, 0x02, 0x18, 
				 0x07, 0x04, 0x15, 0xA0, 0x00, 0xFF, 0x00, 0x09, 
				 0xCE, 0x03, 0x06, 0x05, 0x09, 0xCE, 0x03, 0x09, 
				 0x00, 0x09, 0xCE, 0x03, 0x0A, 0x00, 0x09, 0xCE, 
				 0x03, 0x0B, 0x00, 0x16, 0x80, 0x00, 0xAF, 0x00, 
				 0x16, 0x84, 0x00, 0x0B, 0x00, 0x16, 0x88, 0x00, 
				 0x16, 0x00, 0x1D, 0x19, 0x00, 0x00, 0x00, 0x63, 
				 0x00, 0x00, 0x00, 0x4F, 0x00, 0x00, 0x00, 0x4F, 
				 0x00, 0x00, 0x00, 0x83, 0x00, 0x00, 0x00, 0x55, 
				 0x00, 0x00, 0x00, 0x99, 0x00, 0x00, 0x00, 0xBB, 
				 0x00, 0x00, 0x00, 0x1F, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7D, 
				 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x5D, 
				 0x00, 0x00, 0x00, 0xA0, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x5D, 0x00, 0x00, 0x00, 0xBB, 
				 0x00, 0x00, 0x00, 0xE3, 0x00, 0x00, 0x00, 0xFF, 
				 0x00, 0x00, 0x00, 0x1D, 0x06, 0x00, 0x64, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x50, 0x00, 0x00, 0x00, 
				 0x22, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x13, 0xEA, 0x00, 0x1E, 0x00, 0x00, 0xC0, 0x00, 
				 0x00, 0x1E, 0x01, 0x11, 0x0A, 0x00, 0x00, 0x1F, 
				 0x01, 0x00, 0x19, 0xEA, 0x00, 0x12, 0x07, 0x04, 
				 0x1E, 0x00, 0xC0, 0x00, 0x00, 0x00, 0x1E, 0x01, 
				 0x0A, 0x00, 0x00, 0x00, 0x18, 0x07, 0x04, 0x13, 
				 0xC4, 0x02, 0x1E, 0x00, 0x3F, 0xC0, 0x00, 0x00, 
				 0x1E, 0x01, 0x80, 0x0A, 0x00, 0x00, 0x1F, 0x01, 
				 0x00, 0x19, 0xC4, 0x02, 0x13, 0xEA, 0x00, 0x1E, 
				 0x00, 0xC0, 0xFF, 0x00, 0x00, 0x1E, 0x01, 0x12, 
				 0x00, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 0xEA, 
				 0x00, 0x16, 0x02, 0x04, 0x00, 0x20, 0x13, 0xC0, 
				 0x00, 0x1E, 0x01, 0x00, 0x16, 0x00, 0x00, 0x19, 
				 0xC0, 0x00, 0x17, 0x4C, 0x00, 0xA0, 0x00, 0x00, 
				 0x00, 0x13, 0xEA, 0x00, 0x1E, 0x00, 0xFF, 0xC0, 
				 0x00, 0x00, 0x1E, 0x01, 0x00, 0x0A, 0x00, 0x00, 
				 0x1F, 0x01, 0x00, 0x19, 0xEA, 0x00, 0x00, 0x00};

BYTE t5465_Mode_640x400x15_1[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x16, 0x05, 0x04, 0x00, 0x00, 0x16, 0xC0, 0x00, 
				 0x00, 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 
				 0x00, 0x1F, 0x01, 0x00, 0x18, 0xC5, 0x02, 0x18, 
				 0x07, 0x04, 0x15, 0xA0, 0x00, 0xFF, 0x00, 0x09, 
				 0xCE, 0x03, 0x06, 0x05, 0x09, 0xCE, 0x03, 0x09, 
				 0x00, 0x09, 0xCE, 0x03, 0x0A, 0x00, 0x09, 0xCE, 
				 0x03, 0x0B, 0x00, 0x16, 0x80, 0x00, 0x6F, 0x00, 
				 0x16, 0x84, 0x00, 0x3F, 0x00, 0x16, 0x88, 0x00, 
				 0x6D, 0x00, 0x1D, 0x19, 0x00, 0x00, 0x00, 0x5F, 
				 0x00, 0x00, 0x00, 0x4F, 0x00, 0x00, 0x00, 0x50, 
				 0x00, 0x00, 0x00, 0x82, 0x00, 0x00, 0x00, 0x53, 
				 0x00, 0x00, 0x00, 0x9F, 0x00, 0x00, 0x00, 0xBF, 
				 0x00, 0x00, 0x00, 0x1F, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xA1, 
				 0x00, 0x00, 0x00, 0xA3, 0x00, 0x00, 0x00, 0x8F, 
				 0x00, 0x00, 0x00, 0x50, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x96, 0x00, 0x00, 0x00, 0xB9, 
				 0x00, 0x00, 0x00, 0xE3, 0x00, 0x00, 0x00, 0xFF, 
				 0x00, 0x00, 0x00, 0x1D, 0x06, 0x00, 0x64, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x50, 0x00, 0x00, 0x00, 
				 0x22, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x13, 0xEA, 0x00, 0x1E, 0x00, 0x00, 0xC0, 0x00, 
				 0x00, 0x1E, 0x01, 0x11, 0x0A, 0x00, 0x00, 0x1F, 
				 0x01, 0x00, 0x19, 0xEA, 0x00, 0x12, 0x07, 0x04, 
				 0x1E, 0x00, 0xC0, 0x00, 0x00, 0x00, 0x1E, 0x01, 
				 0x0A, 0x00, 0x00, 0x00, 0x18, 0x07, 0x04, 0x13, 
				 0xC4, 0x02, 0x1E, 0x00, 0x3F, 0xC0, 0x00, 0x00, 
				 0x1E, 0x01, 0x80, 0x0A, 0x00, 0x00, 0x1F, 0x01, 
				 0x00, 0x19, 0xC4, 0x02, 0x13, 0xEA, 0x00, 0x1E, 
				 0x00, 0xC0, 0xFF, 0x00, 0x00, 0x1E, 0x01, 0x12, 
				 0x00, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 0xEA, 
				 0x00, 0x16, 0x02, 0x04, 0x00, 0x20, 0x13, 0xC0, 
				 0x00, 0x1E, 0x01, 0x00, 0x16, 0x00, 0x00, 0x19, 
				 0xC0, 0x00, 0x17, 0x4C, 0x00, 0xA0, 0x00, 0x00, 
				 0x00, 0x13, 0xEA, 0x00, 0x1E, 0x00, 0xFF, 0xC0, 
				 0x00, 0x00, 0x1E, 0x01, 0x00, 0x0A, 0x00, 0x00, 
				 0x1F, 0x01, 0x00, 0x19, 0xEA, 0x00, 0x00, 0x00};

BYTE t5465_Mode_640x400x15_2[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x16, 0x05, 0x04, 0x00, 0x00, 0x16, 0xC0, 0x00, 
				 0x00, 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 
				 0x00, 0x1F, 0x01, 0x00, 0x18, 0xC5, 0x02, 0x18, 
				 0x07, 0x04, 0x15, 0xA0, 0x00, 0xFF, 0x00, 0x09, 
				 0xCE, 0x03, 0x06, 0x05, 0x09, 0xCE, 0x03, 0x09, 
				 0x00, 0x09, 0xCE, 0x03, 0x0A, 0x00, 0x09, 0xCE, 
				 0x03, 0x0B, 0x00, 0x16, 0x80, 0x00, 0x6F, 0x00, 
				 0x16, 0x84, 0x00, 0x0B, 0x00, 0x16, 0x88, 0x00, 
				 0x16, 0x00, 0x1D, 0x19, 0x00, 0x00, 0x00, 0x63, 
				 0x00, 0x00, 0x00, 0x4F, 0x00, 0x00, 0x00, 0x4F, 
				 0x00, 0x00, 0x00, 0x83, 0x00, 0x00, 0x00, 0x55, 
				 0x00, 0x00, 0x00, 0x99, 0x00, 0x00, 0x00, 0xBB, 
				 0x00, 0x00, 0x00, 0x1F, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x90, 
				 0x00, 0x00, 0x00, 0x83, 0x00, 0x00, 0x00, 0x8F, 
				 0x00, 0x00, 0x00, 0x50, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x8F, 0x00, 0x00, 0x00, 0xBB, 
				 0x00, 0x00, 0x00, 0xE3, 0x00, 0x00, 0x00, 0xFF, 
				 0x00, 0x00, 0x00, 0x1D, 0x06, 0x00, 0x64, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x50, 0x00, 0x00, 0x00, 
				 0x22, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x13, 0xEA, 0x00, 0x1E, 0x00, 0x00, 0xC0, 0x00, 
				 0x00, 0x1E, 0x01, 0x11, 0x0A, 0x00, 0x00, 0x1F, 
				 0x01, 0x00, 0x19, 0xEA, 0x00, 0x12, 0x07, 0x04, 
				 0x1E, 0x00, 0xC0, 0x00, 0x00, 0x00, 0x1E, 0x01, 
				 0x0A, 0x00, 0x00, 0x00, 0x18, 0x07, 0x04, 0x13, 
				 0xC4, 0x02, 0x1E, 0x00, 0x3F, 0xC0, 0x00, 0x00, 
				 0x1E, 0x01, 0x80, 0x0A, 0x00, 0x00, 0x1F, 0x01, 
				 0x00, 0x19, 0xC4, 0x02, 0x13, 0xEA, 0x00, 0x1E, 
				 0x00, 0xC0, 0xFF, 0x00, 0x00, 0x1E, 0x01, 0x12, 
				 0x00, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 0xEA, 
				 0x00, 0x16, 0x02, 0x04, 0x00, 0x20, 0x13, 0xC0, 
				 0x00, 0x1E, 0x01, 0x00, 0x16, 0x00, 0x00, 0x19, 
				 0xC0, 0x00, 0x17, 0x4C, 0x00, 0xA0, 0x00, 0x00, 
				 0x00, 0x13, 0xEA, 0x00, 0x1E, 0x00, 0xFF, 0xC0, 
				 0x00, 0x00, 0x1E, 0x01, 0x00, 0x0A, 0x00, 0x00, 
				 0x1F, 0x01, 0x00, 0x19, 0xEA, 0x00, 0x00, 0x00};

BYTE t5465_Mode_640x400x15_3[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x16, 0x05, 0x04, 0x00, 0x00, 0x16, 0xC0, 0x00, 
				 0x00, 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 
				 0x00, 0x1F, 0x01, 0x00, 0x18, 0xC5, 0x02, 0x18, 
				 0x07, 0x04, 0x15, 0xA0, 0x00, 0xFF, 0x00, 0x09, 
				 0xCE, 0x03, 0x06, 0x05, 0x09, 0xCE, 0x03, 0x09, 
				 0x00, 0x09, 0xCE, 0x03, 0x0A, 0x00, 0x09, 0xCE, 
				 0x03, 0x0B, 0x00, 0x16, 0x80, 0x00, 0x6F, 0x00, 
				 0x16, 0x84, 0x00, 0x0B, 0x00, 0x16, 0x88, 0x00, 
				 0x16, 0x00, 0x1D, 0x19, 0x00, 0x00, 0x00, 0x63, 
				 0x00, 0x00, 0x00, 0x4F, 0x00, 0x00, 0x00, 0x4F, 
				 0x00, 0x00, 0x00, 0x83, 0x00, 0x00, 0x00, 0x55, 
				 0x00, 0x00, 0x00, 0x99, 0x00, 0x00, 0x00, 0xBB, 
				 0x00, 0x00, 0x00, 0x1F, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x90, 
				 0x00, 0x00, 0x00, 0x83, 0x00, 0x00, 0x00, 0x8F, 
				 0x00, 0x00, 0x00, 0x50, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x8F, 0x00, 0x00, 0x00, 0xBB, 
				 0x00, 0x00, 0x00, 0xE3, 0x00, 0x00, 0x00, 0xFF, 
				 0x00, 0x00, 0x00, 0x1D, 0x06, 0x00, 0x64, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x50, 0x00, 0x00, 0x00, 
				 0x22, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x16, 0x84, 0x00, 0x32, 0x00, 0x16, 0x88, 0x00, 
				 0x61, 0x00, 0x13, 0xEA, 0x00, 0x1E, 0x00, 0x00, 
				 0xC0, 0x00, 0x00, 0x1E, 0x01, 0x11, 0x0A, 0x00, 
				 0x00, 0x1F, 0x01, 0x00, 0x19, 0xEA, 0x00, 0x12, 
				 0x07, 0x04, 0x1E, 0x00, 0xC0, 0x00, 0x00, 0x00, 
				 0x1E, 0x01, 0x0A, 0x00, 0x00, 0x00, 0x18, 0x07, 
				 0x04, 0x13, 0xC4, 0x02, 0x1E, 0x00, 0x3F, 0xC0, 
				 0x00, 0x00, 0x1E, 0x01, 0x80, 0x0A, 0x00, 0x00, 
				 0x1F, 0x01, 0x00, 0x19, 0xC4, 0x02, 0x13, 0xEA, 
				 0x00, 0x1E, 0x00, 0xC0, 0xFF, 0x00, 0x00, 0x1E, 
				 0x01, 0x12, 0x00, 0x00, 0x00, 0x1F, 0x01, 0x00, 
				 0x19, 0xEA, 0x00, 0x16, 0x02, 0x04, 0x00, 0x20, 
				 0x13, 0xC0, 0x00, 0x1E, 0x01, 0x00, 0x16, 0x00, 
				 0x00, 0x19, 0xC0, 0x00, 0x17, 0x4C, 0x00, 0xA0, 
				 0x00, 0x00, 0x00, 0x13, 0xEA, 0x00, 0x1E, 0x00, 
				 0xFF, 0xC0, 0x00, 0x00, 0x1E, 0x01, 0x00, 0x0A, 
				 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 0xEA, 0x00, 
				 0x00, 0x00};

BYTE t5465_Mode_640x480x15_1[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x16, 0x05, 0x04, 0x00, 0x00, 0x16, 0xC0, 0x00, 
				 0x00, 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 
				 0x00, 0x1F, 0x01, 0x00, 0x18, 0xC5, 0x02, 0x18, 
				 0x07, 0x04, 0x15, 0xA0, 0x00, 0xFF, 0x00, 0x09, 
				 0xCE, 0x03, 0x06, 0x05, 0x09, 0xCE, 0x03, 0x09, 
				 0x00, 0x09, 0xCE, 0x03, 0x0A, 0x00, 0x09, 0xCE, 
				 0x03, 0x0B, 0x00, 0x16, 0x80, 0x00, 0xEF, 0x00, 
				 0x16, 0x84, 0x00, 0x3F, 0x00, 0x16, 0x88, 0x00, 
				 0x6D, 0x00, 0x1D, 0x19, 0x00, 0x00, 0x00, 0x5F, 
				 0x00, 0x00, 0x00, 0x4F, 0x00, 0x00, 0x00, 0x50, 
				 0x00, 0x00, 0x00, 0x9F, 0x00, 0x00, 0x00, 0x54, 
				 0x00, 0x00, 0x00, 0x1F, 0x00, 0x00, 0x00, 0x0B, 
				 0x00, 0x00, 0x00, 0x3E, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xE9, 
				 0x00, 0x00, 0x00, 0x8B, 0x00, 0x00, 0x00, 0xDF, 
				 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0xE7, 0x00, 0x00, 0x00, 0x04, 
				 0x00, 0x00, 0x00, 0xE3, 0x00, 0x00, 0x00, 0xFF, 
				 0x00, 0x00, 0x00, 0x1D, 0x06, 0x00, 0x64, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x90, 0x00, 0x00, 0x00, 
				 0x22, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x13, 0xEA, 0x00, 0x1E, 0x00, 0x00, 0xC0, 0x00, 
				 0x00, 0x1E, 0x01, 0x11, 0x0A, 0x00, 0x00, 0x1F, 
				 0x01, 0x00, 0x19, 0xEA, 0x00, 0x12, 0x07, 0x04, 
				 0x1E, 0x00, 0xC0, 0x00, 0x00, 0x00, 0x1E, 0x01, 
				 0x0A, 0x00, 0x00, 0x00, 0x18, 0x07, 0x04, 0x13, 
				 0xC4, 0x02, 0x1E, 0x00, 0x3F, 0xC0, 0x00, 0x00, 
				 0x1E, 0x01, 0x80, 0x0A, 0x00, 0x00, 0x1F, 0x01, 
				 0x00, 0x19, 0xC4, 0x02, 0x13, 0xEA, 0x00, 0x1E, 
				 0x00, 0xC0, 0xFF, 0x00, 0x00, 0x1E, 0x01, 0x12, 
				 0x00, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 0xEA, 
				 0x00, 0x16, 0x02, 0x04, 0x00, 0x20, 0x13, 0xC0, 
				 0x00, 0x1E, 0x01, 0x00, 0x16, 0x00, 0x00, 0x19, 
				 0xC0, 0x00, 0x17, 0x4C, 0x00, 0xA0, 0x00, 0x00, 
				 0x00, 0x13, 0xEA, 0x00, 0x1E, 0x00, 0xFF, 0xC0, 
				 0x00, 0x00, 0x1E, 0x01, 0x00, 0x0A, 0x00, 0x00, 
				 0x1F, 0x01, 0x00, 0x19, 0xEA, 0x00, 0x00, 0x0A};

BYTE t5465_Mode_640x480x15_2[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x16, 0x05, 0x04, 0x00, 0x00, 0x16, 0xC0, 0x00, 
				 0x00, 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 
				 0x00, 0x1F, 0x01, 0x00, 0x18, 0xC5, 0x02, 0x18, 
				 0x07, 0x04, 0x15, 0xA0, 0x00, 0xFF, 0x00, 0x09, 
				 0xCE, 0x03, 0x06, 0x05, 0x09, 0xCE, 0x03, 0x09, 
				 0x00, 0x09, 0xCE, 0x03, 0x0A, 0x00, 0x09, 0xCE, 
				 0x03, 0x0B, 0x00, 0x16, 0x80, 0x00, 0xEF, 0x00, 
				 0x16, 0x84, 0x00, 0x0B, 0x00, 0x16, 0x88, 0x00, 
				 0x16, 0x00, 0x1D, 0x19, 0x00, 0x00, 0x00, 0x63, 
				 0x00, 0x00, 0x00, 0x4F, 0x00, 0x00, 0x00, 0x50, 
				 0x00, 0x00, 0x00, 0x82, 0x00, 0x00, 0x00, 0x54, 
				 0x00, 0x00, 0x00, 0x99, 0x00, 0x00, 0x00, 0x06, 
				 0x00, 0x00, 0x00, 0x3E, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xE8, 
				 0x00, 0x00, 0x00, 0x8B, 0x00, 0x00, 0x00, 0xDF, 
				 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0xE7, 0x00, 0x00, 0x00, 0xF3, 
				 0x00, 0x00, 0x00, 0xE3, 0x00, 0x00, 0x00, 0xFF, 
				 0x00, 0x00, 0x00, 0x1D, 0x06, 0x00, 0x64, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x50, 0x00, 0x00, 0x00, 
				 0x22, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x13, 0xEA, 0x00, 0x1E, 0x00, 0x00, 0xC0, 0x00, 
				 0x00, 0x1E, 0x01, 0x11, 0x0A, 0x00, 0x00, 0x1F, 
				 0x01, 0x00, 0x19, 0xEA, 0x00, 0x12, 0x07, 0x04, 
				 0x1E, 0x00, 0xC0, 0x00, 0x00, 0x00, 0x1E, 0x01, 
				 0x0A, 0x00, 0x00, 0x00, 0x18, 0x07, 0x04, 0x13, 
				 0xC4, 0x02, 0x1E, 0x00, 0x3F, 0xC0, 0x00, 0x00, 
				 0x1E, 0x01, 0x80, 0x0A, 0x00, 0x00, 0x1F, 0x01, 
				 0x00, 0x19, 0xC4, 0x02, 0x13, 0xEA, 0x00, 0x1E, 
				 0x00, 0xC0, 0xFF, 0x00, 0x00, 0x1E, 0x01, 0x12, 
				 0x00, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 0xEA, 
				 0x00, 0x16, 0x02, 0x04, 0x00, 0x20, 0x13, 0xC0, 
				 0x00, 0x1E, 0x01, 0x00, 0x16, 0x00, 0x00, 0x19, 
				 0xC0, 0x00, 0x17, 0x4C, 0x00, 0xA0, 0x00, 0x00, 
				 0x00, 0x13, 0xEA, 0x00, 0x1E, 0x00, 0xFF, 0xC0, 
				 0x00, 0x00, 0x1E, 0x01, 0x00, 0x0A, 0x00, 0x00, 
				 0x1F, 0x01, 0x00, 0x19, 0xEA, 0x00, 0x00, 0x0A};

BYTE t5465_Mode_640x480x15_3[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x16, 0x05, 0x04, 0x00, 0x00, 0x16, 0xC0, 0x00, 
				 0x00, 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 
				 0x00, 0x1F, 0x01, 0x00, 0x18, 0xC5, 0x02, 0x18, 
				 0x07, 0x04, 0x15, 0xA0, 0x00, 0xFF, 0x00, 0x09, 
				 0xCE, 0x03, 0x06, 0x05, 0x09, 0xCE, 0x03, 0x09, 
				 0x00, 0x09, 0xCE, 0x03, 0x0A, 0x00, 0x09, 0xCE, 
				 0x03, 0x0B, 0x00, 0x16, 0x80, 0x00, 0xEF, 0x00, 
				 0x16, 0x84, 0x00, 0x0B, 0x00, 0x16, 0x88, 0x00, 
				 0x16, 0x00, 0x1D, 0x19, 0x00, 0x00, 0x00, 0x64, 
				 0x00, 0x00, 0x00, 0x4F, 0x00, 0x00, 0x00, 0x50, 
				 0x00, 0x00, 0x00, 0x82, 0x00, 0x00, 0x00, 0x54, 
				 0x00, 0x00, 0x00, 0x9B, 0x00, 0x00, 0x00, 0xF2, 
				 0x00, 0x00, 0x00, 0x1F, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xE0, 
				 0x00, 0x00, 0x00, 0x83, 0x00, 0x00, 0x00, 0xDF, 
				 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0xDF, 0x00, 0x00, 0x00, 0xF2, 
				 0x00, 0x00, 0x00, 0xE3, 0x00, 0x00, 0x00, 0xFF, 
				 0x00, 0x00, 0x00, 0x1D, 0x06, 0x00, 0x64, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x50, 0x00, 0x00, 0x00, 
				 0x22, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x13, 0xEA, 0x00, 0x1E, 0x00, 0x00, 0xC0, 0x00, 
				 0x00, 0x1E, 0x01, 0x11, 0x0A, 0x00, 0x00, 0x1F, 
				 0x01, 0x00, 0x19, 0xEA, 0x00, 0x12, 0x07, 0x04, 
				 0x1E, 0x00, 0xC0, 0x00, 0x00, 0x00, 0x1E, 0x01, 
				 0x0A, 0x00, 0x00, 0x00, 0x18, 0x07, 0x04, 0x13, 
				 0xC4, 0x02, 0x1E, 0x00, 0x3F, 0xC0, 0x00, 0x00, 
				 0x1E, 0x01, 0x80, 0x0A, 0x00, 0x00, 0x1F, 0x01, 
				 0x00, 0x19, 0xC4, 0x02, 0x13, 0xEA, 0x00, 0x1E, 
				 0x00, 0xC0, 0xFF, 0x00, 0x00, 0x1E, 0x01, 0x12, 
				 0x00, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 0xEA, 
				 0x00, 0x16, 0x02, 0x04, 0x00, 0x20, 0x13, 0xC0, 
				 0x00, 0x1E, 0x01, 0x00, 0x16, 0x00, 0x00, 0x19, 
				 0xC0, 0x00, 0x17, 0x4C, 0x00, 0xA0, 0x00, 0x00, 
				 0x00, 0x13, 0xEA, 0x00, 0x1E, 0x00, 0xFF, 0xC0, 
				 0x00, 0x00, 0x1E, 0x01, 0x00, 0x0A, 0x00, 0x00, 
				 0x1F, 0x01, 0x00, 0x19, 0xEA, 0x00, 0x00, 0x0A};

BYTE t5465_Mode_640x480x15_4[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x16, 0x05, 0x04, 0x00, 0x00, 0x16, 0xC0, 0x00, 
				 0x00, 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 
				 0x00, 0x1F, 0x01, 0x00, 0x18, 0xC5, 0x02, 0x18, 
				 0x07, 0x04, 0x15, 0xA0, 0x00, 0xFF, 0x00, 0x09, 
				 0xCE, 0x03, 0x06, 0x05, 0x09, 0xCE, 0x03, 0x09, 
				 0x00, 0x09, 0xCE, 0x03, 0x0A, 0x00, 0x09, 0xCE, 
				 0x03, 0x0B, 0x00, 0x16, 0x80, 0x00, 0xEF, 0x00, 
				 0x16, 0x84, 0x00, 0x33, 0x00, 0x16, 0x88, 0x00, 
				 0x7E, 0x00, 0x1D, 0x19, 0x00, 0x00, 0x00, 0x63, 
				 0x00, 0x00, 0x00, 0x4F, 0x00, 0x00, 0x00, 0x50, 
				 0x00, 0x00, 0x00, 0x82, 0x00, 0x00, 0x00, 0x55, 
				 0x00, 0x00, 0x00, 0x9B, 0x00, 0x00, 0x00, 0xFB, 
				 0x00, 0x00, 0x00, 0x1F, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xE0, 
				 0x00, 0x00, 0x00, 0x83, 0x00, 0x00, 0x00, 0xDF, 
				 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0xDF, 0x00, 0x00, 0x00, 0xF9, 
				 0x00, 0x00, 0x00, 0xE3, 0x00, 0x00, 0x00, 0xFF, 
				 0x00, 0x00, 0x00, 0x1D, 0x06, 0x00, 0x64, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x50, 0x00, 0x00, 0x00, 
				 0x22, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x13, 0xEA, 0x00, 0x1E, 0x00, 0x00, 0xC0, 0x00, 
				 0x00, 0x1E, 0x01, 0x11, 0x0A, 0x00, 0x00, 0x1F, 
				 0x01, 0x00, 0x19, 0xEA, 0x00, 0x12, 0x07, 0x04, 
				 0x1E, 0x00, 0xC0, 0x00, 0x00, 0x00, 0x1E, 0x01, 
				 0x0A, 0x00, 0x00, 0x00, 0x18, 0x07, 0x04, 0x13, 
				 0xC4, 0x02, 0x1E, 0x00, 0x3F, 0xC0, 0x00, 0x00, 
				 0x1E, 0x01, 0x80, 0x0A, 0x00, 0x00, 0x1F, 0x01, 
				 0x00, 0x19, 0xC4, 0x02, 0x13, 0xEA, 0x00, 0x1E, 
				 0x00, 0xC0, 0xFF, 0x00, 0x00, 0x1E, 0x01, 0x12, 
				 0x00, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 0xEA, 
				 0x00, 0x16, 0x02, 0x04, 0x00, 0x20, 0x13, 0xC0, 
				 0x00, 0x1E, 0x01, 0x00, 0x16, 0x00, 0x00, 0x19, 
				 0xC0, 0x00, 0x17, 0x4C, 0x00, 0xA0, 0x00, 0x00, 
				 0x00, 0x13, 0xEA, 0x00, 0x1E, 0x00, 0xFF, 0xC0, 
				 0x00, 0x00, 0x1E, 0x01, 0x00, 0x0A, 0x00, 0x00, 
				 0x1F, 0x01, 0x00, 0x19, 0xEA, 0x00, 0x00, 0x0A};

BYTE t5465_Mode_800x600x15_1[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x16, 0x05, 0x04, 0x00, 0x00, 0x16, 0xC0, 0x00, 
				 0x00, 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 
				 0x00, 0x1F, 0x01, 0x00, 0x18, 0xC5, 0x02, 0x18, 
				 0x07, 0x04, 0x15, 0xA0, 0x00, 0xFF, 0x00, 0x09, 
				 0xCE, 0x03, 0x06, 0x05, 0x09, 0xCE, 0x03, 0x09, 
				 0x00, 0x09, 0xCE, 0x03, 0x0A, 0x00, 0x09, 0xCE, 
				 0x03, 0x0B, 0x00, 0x16, 0x80, 0x00, 0x2F, 0x00, 
				 0x16, 0x84, 0x00, 0x33, 0x00, 0x16, 0x88, 0x00, 
				 0x7E, 0x00, 0x1D, 0x19, 0x00, 0x00, 0x00, 0x7B, 
				 0x00, 0x00, 0x00, 0x63, 0x00, 0x00, 0x00, 0x64, 
				 0x00, 0x00, 0x00, 0x9B, 0x00, 0x00, 0x00, 0x68, 
				 0x00, 0x00, 0x00, 0x91, 0x00, 0x00, 0x00, 0x6F, 
				 0x00, 0x00, 0x00, 0xF0, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x60, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x58, 
				 0x00, 0x00, 0x00, 0x8A, 0x00, 0x00, 0x00, 0x57, 
				 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x58, 0x00, 0x00, 0x00, 0x6F, 
				 0x00, 0x00, 0x00, 0xE3, 0x00, 0x00, 0x00, 0xFF, 
				 0x00, 0x00, 0x00, 0x1D, 0x06, 0x00, 0x64, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x90, 0x00, 0x00, 0x00, 
				 0x22, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x13, 0xEA, 0x00, 0x1E, 0x00, 0x00, 0xC0, 0x00, 
				 0x00, 0x1E, 0x01, 0x12, 0x0D, 0x00, 0x00, 0x1F, 
				 0x01, 0x00, 0x19, 0xEA, 0x00, 0x12, 0x07, 0x04, 
				 0x1E, 0x00, 0xC0, 0x00, 0x00, 0x00, 0x1E, 0x01, 
				 0x0D, 0x00, 0x00, 0x00, 0x18, 0x07, 0x04, 0x13, 
				 0xC4, 0x02, 0x1E, 0x00, 0x3F, 0xC0, 0x00, 0x00, 
				 0x1E, 0x01, 0x80, 0x0D, 0x00, 0x00, 0x1F, 0x01, 
				 0x00, 0x19, 0xC4, 0x02, 0x13, 0xEA, 0x00, 0x1E, 
				 0x00, 0xC0, 0xFF, 0x00, 0x00, 0x1E, 0x01, 0x13, 
				 0x00, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 0xEA, 
				 0x00, 0x16, 0x02, 0x04, 0x00, 0x20, 0x13, 0xC0, 
				 0x00, 0x1E, 0x01, 0x00, 0x16, 0x00, 0x00, 0x19, 
				 0xC0, 0x00, 0x17, 0x4C, 0x00, 0xD0, 0x00, 0x00, 
				 0x00, 0x13, 0xEA, 0x00, 0x1E, 0x00, 0xFF, 0xC0, 
				 0x00, 0x00, 0x1E, 0x01, 0x00, 0x0D, 0x00, 0x00, 
				 0x1F, 0x01, 0x00, 0x19, 0xEA, 0x00, 0x00, 0x0A};

BYTE t5465_Mode_800x600x15_2[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x16, 0x05, 0x04, 0x00, 0x00, 0x16, 0xC0, 0x00, 
				 0x00, 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 
				 0x00, 0x1F, 0x01, 0x00, 0x18, 0xC5, 0x02, 0x18, 
				 0x07, 0x04, 0x15, 0xA0, 0x00, 0xFF, 0x00, 0x09, 
				 0xCE, 0x03, 0x06, 0x05, 0x09, 0xCE, 0x03, 0x09, 
				 0x00, 0x09, 0xCE, 0x03, 0x0A, 0x00, 0x09, 0xCE, 
				 0x03, 0x0B, 0x00, 0x16, 0x80, 0x00, 0x2F, 0x00, 
				 0x16, 0x84, 0x00, 0x23, 0x00, 0x16, 0x88, 0x00, 
				 0x5F, 0x00, 0x1D, 0x19, 0x00, 0x00, 0x00, 0x7F, 
				 0x00, 0x00, 0x00, 0x63, 0x00, 0x00, 0x00, 0x64, 
				 0x00, 0x00, 0x00, 0x9F, 0x00, 0x00, 0x00, 0x6A, 
				 0x00, 0x00, 0x00, 0x9A, 0x00, 0x00, 0x00, 0x72, 
				 0x00, 0x00, 0x00, 0xF0, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x60, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x58, 
				 0x00, 0x00, 0x00, 0x8C, 0x00, 0x00, 0x00, 0x57, 
				 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x58, 0x00, 0x00, 0x00, 0x70, 
				 0x00, 0x00, 0x00, 0xE3, 0x00, 0x00, 0x00, 0xFF, 
				 0x00, 0x00, 0x00, 0x1D, 0x06, 0x00, 0x64, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x90, 0x00, 0x00, 0x00, 
				 0x22, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x13, 0xEA, 0x00, 0x1E, 0x00, 0x00, 0xC0, 0x00, 
				 0x00, 0x1E, 0x01, 0x12, 0x0D, 0x00, 0x00, 0x1F, 
				 0x01, 0x00, 0x19, 0xEA, 0x00, 0x12, 0x07, 0x04, 
				 0x1E, 0x00, 0xC0, 0x00, 0x00, 0x00, 0x1E, 0x01, 
				 0x0D, 0x00, 0x00, 0x00, 0x18, 0x07, 0x04, 0x13, 
				 0xC4, 0x02, 0x1E, 0x00, 0x3F, 0xC0, 0x00, 0x00, 
				 0x1E, 0x01, 0x80, 0x0D, 0x00, 0x00, 0x1F, 0x01, 
				 0x00, 0x19, 0xC4, 0x02, 0x13, 0xEA, 0x00, 0x1E, 
				 0x00, 0xC0, 0xFF, 0x00, 0x00, 0x1E, 0x01, 0x13, 
				 0x00, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 0xEA, 
				 0x00, 0x16, 0x02, 0x04, 0x00, 0x20, 0x13, 0xC0, 
				 0x00, 0x1E, 0x01, 0x00, 0x16, 0x00, 0x00, 0x19, 
				 0xC0, 0x00, 0x17, 0x4C, 0x00, 0xD0, 0x00, 0x00, 
				 0x00, 0x13, 0xEA, 0x00, 0x1E, 0x00, 0xFF, 0xC0, 
				 0x00, 0x00, 0x1E, 0x01, 0x00, 0x0D, 0x00, 0x00, 
				 0x1F, 0x01, 0x00, 0x19, 0xEA, 0x00, 0x00, 0x0A};

BYTE t5465_Mode_800x600x15_3[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x16, 0x05, 0x04, 0x00, 0x00, 0x16, 0xC0, 0x00, 
				 0x00, 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 
				 0x00, 0x1F, 0x01, 0x00, 0x18, 0xC5, 0x02, 0x18, 
				 0x07, 0x04, 0x15, 0xA0, 0x00, 0xFF, 0x00, 0x09, 
				 0xCE, 0x03, 0x06, 0x05, 0x09, 0xCE, 0x03, 0x09, 
				 0x00, 0x09, 0xCE, 0x03, 0x0A, 0x00, 0x09, 0xCE, 
				 0x03, 0x0B, 0x00, 0x16, 0x80, 0x00, 0x2F, 0x00, 
				 0x16, 0x84, 0x00, 0x25, 0x00, 0x16, 0x88, 0x00, 
				 0x7D, 0x00, 0x1D, 0x19, 0x00, 0x00, 0x00, 0x7D, 
				 0x00, 0x00, 0x00, 0x63, 0x00, 0x00, 0x00, 0x64, 
				 0x00, 0x00, 0x00, 0x9D, 0x00, 0x00, 0x00, 0x6C, 
				 0x00, 0x00, 0x00, 0x9B, 0x00, 0x00, 0x00, 0x97, 
				 0x00, 0x00, 0x00, 0xF0, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x60, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7C, 
				 0x00, 0x00, 0x00, 0x82, 0x00, 0x00, 0x00, 0x57, 
				 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x5F, 0x00, 0x00, 0x00, 0x97, 
				 0x00, 0x00, 0x00, 0xE3, 0x00, 0x00, 0x00, 0xFF, 
				 0x00, 0x00, 0x00, 0x1D, 0x06, 0x00, 0x64, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x90, 0x00, 0x00, 0x00, 
				 0x22, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x13, 0xEA, 0x00, 0x1E, 0x00, 0x00, 0xC0, 0x00, 
				 0x00, 0x1E, 0x01, 0x12, 0x0D, 0x00, 0x00, 0x1F, 
				 0x01, 0x00, 0x19, 0xEA, 0x00, 0x12, 0x07, 0x04, 
				 0x1E, 0x00, 0xC0, 0x00, 0x00, 0x00, 0x1E, 0x01, 
				 0x0D, 0x00, 0x00, 0x00, 0x18, 0x07, 0x04, 0x13, 
				 0xC4, 0x02, 0x1E, 0x00, 0x3F, 0xC0, 0x00, 0x00, 
				 0x1E, 0x01, 0x80, 0x0D, 0x00, 0x00, 0x1F, 0x01, 
				 0x00, 0x19, 0xC4, 0x02, 0x13, 0xEA, 0x00, 0x1E, 
				 0x00, 0xC0, 0xFF, 0x00, 0x00, 0x1E, 0x01, 0x13, 
				 0x00, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 0xEA, 
				 0x00, 0x16, 0x02, 0x04, 0x00, 0x20, 0x13, 0xC0, 
				 0x00, 0x1E, 0x01, 0x00, 0x16, 0x00, 0x00, 0x19, 
				 0xC0, 0x00, 0x17, 0x4C, 0x00, 0xD0, 0x00, 0x00, 
				 0x00, 0x13, 0xEA, 0x00, 0x1E, 0x00, 0xFF, 0xC0, 
				 0x00, 0x00, 0x1E, 0x01, 0x00, 0x0D, 0x00, 0x00, 
				 0x1F, 0x01, 0x00, 0x19, 0xEA, 0x00, 0x00, 0x0A};

BYTE t5465_Mode_800x600x15_4[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x16, 0x05, 0x04, 0x00, 0x00, 0x16, 0xC0, 0x00, 
				 0x00, 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 
				 0x00, 0x1F, 0x01, 0x00, 0x18, 0xC5, 0x02, 0x18, 
				 0x07, 0x04, 0x15, 0xA0, 0x00, 0xFF, 0x00, 0x09, 
				 0xCE, 0x03, 0x06, 0x05, 0x09, 0xCE, 0x03, 0x09, 
				 0x00, 0x09, 0xCE, 0x03, 0x0A, 0x00, 0x09, 0xCE, 
				 0x03, 0x0B, 0x00, 0x16, 0x80, 0x00, 0x2F, 0x00, 
				 0x16, 0x84, 0x00, 0x19, 0x00, 0x16, 0x88, 0x00, 
				 0x53, 0x00, 0x1D, 0x19, 0x00, 0x00, 0x00, 0x7F, 
				 0x00, 0x00, 0x00, 0x63, 0x00, 0x00, 0x00, 0x64, 
				 0x00, 0x00, 0x00, 0x9F, 0x00, 0x00, 0x00, 0x67, 
				 0x00, 0x00, 0x00, 0x91, 0x00, 0x00, 0x00, 0x6F, 
				 0x00, 0x00, 0x00, 0xF0, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x60, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x58, 
				 0x00, 0x00, 0x00, 0x8B, 0x00, 0x00, 0x00, 0x57, 
				 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x57, 0x00, 0x00, 0x00, 0x6F, 
				 0x00, 0x00, 0x00, 0xE3, 0x00, 0x00, 0x00, 0xFF, 
				 0x00, 0x00, 0x00, 0x1D, 0x06, 0x00, 0x64, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x90, 0x00, 0x00, 0x00, 
				 0x22, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x13, 0xEA, 0x00, 0x1E, 0x00, 0x00, 0xC0, 0x00, 
				 0x00, 0x1E, 0x01, 0x12, 0x0D, 0x00, 0x00, 0x1F, 
				 0x01, 0x00, 0x19, 0xEA, 0x00, 0x12, 0x07, 0x04, 
				 0x1E, 0x00, 0xC0, 0x00, 0x00, 0x00, 0x1E, 0x01, 
				 0x0D, 0x00, 0x00, 0x00, 0x18, 0x07, 0x04, 0x13, 
				 0xC4, 0x02, 0x1E, 0x00, 0x3F, 0xC0, 0x00, 0x00, 
				 0x1E, 0x01, 0x80, 0x0D, 0x00, 0x00, 0x1F, 0x01, 
				 0x00, 0x19, 0xC4, 0x02, 0x13, 0xEA, 0x00, 0x1E, 
				 0x00, 0xC0, 0xFF, 0x00, 0x00, 0x1E, 0x01, 0x13, 
				 0x00, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 0xEA, 
				 0x00, 0x16, 0x02, 0x04, 0x00, 0x20, 0x13, 0xC0, 
				 0x00, 0x1E, 0x01, 0x00, 0x16, 0x00, 0x00, 0x19, 
				 0xC0, 0x00, 0x17, 0x4C, 0x00, 0xD0, 0x00, 0x00, 
				 0x00, 0x13, 0xEA, 0x00, 0x1E, 0x00, 0xFF, 0xC0, 
				 0x00, 0x00, 0x1E, 0x01, 0x00, 0x0D, 0x00, 0x00, 
				 0x1F, 0x01, 0x00, 0x19, 0xEA, 0x00, 0x00, 0x0A};

BYTE t5465_Mode_800x600x15_5[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x16, 0x05, 0x04, 0x00, 0x00, 0x16, 0xC0, 0x00, 
				 0x00, 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 
				 0x00, 0x1F, 0x01, 0x00, 0x18, 0xC5, 0x02, 0x18, 
				 0x07, 0x04, 0x15, 0xA0, 0x00, 0xFF, 0x00, 0x09, 
				 0xCE, 0x03, 0x06, 0x05, 0x09, 0xCE, 0x03, 0x09, 
				 0x00, 0x09, 0xCE, 0x03, 0x0A, 0x00, 0x09, 0xCE, 
				 0x03, 0x0B, 0x00, 0x16, 0x80, 0x00, 0x2F, 0x00, 
				 0x16, 0x84, 0x00, 0x1C, 0x00, 0x16, 0x88, 0x00, 
				 0x37, 0x00, 0x1D, 0x19, 0x00, 0x00, 0x00, 0x7E, 
				 0x00, 0x00, 0x00, 0x63, 0x00, 0x00, 0x00, 0x64, 
				 0x00, 0x00, 0x00, 0x9E, 0x00, 0x00, 0x00, 0x69, 
				 0x00, 0x00, 0x00, 0x91, 0x00, 0x00, 0x00, 0x75, 
				 0x00, 0x00, 0x00, 0xF0, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x60, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x58, 
				 0x00, 0x00, 0x00, 0x8B, 0x00, 0x00, 0x00, 0x57, 
				 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x57, 0x00, 0x00, 0x00, 0x75, 
				 0x00, 0x00, 0x00, 0xE3, 0x00, 0x00, 0x00, 0xFF, 
				 0x00, 0x00, 0x00, 0x1D, 0x06, 0x00, 0x64, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x90, 0x00, 0x00, 0x00, 
				 0x22, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x13, 0xEA, 0x00, 0x1E, 0x00, 0x00, 0xC0, 0x00, 
				 0x00, 0x1E, 0x01, 0x12, 0x0D, 0x00, 0x00, 0x1F, 
				 0x01, 0x00, 0x19, 0xEA, 0x00, 0x12, 0x07, 0x04, 
				 0x1E, 0x00, 0xC0, 0x00, 0x00, 0x00, 0x1E, 0x01, 
				 0x0D, 0x00, 0x00, 0x00, 0x18, 0x07, 0x04, 0x13, 
				 0xC4, 0x02, 0x1E, 0x00, 0x3F, 0xC0, 0x00, 0x00, 
				 0x1E, 0x01, 0x80, 0x0D, 0x00, 0x00, 0x1F, 0x01, 
				 0x00, 0x19, 0xC4, 0x02, 0x13, 0xEA, 0x00, 0x1E, 
				 0x00, 0xC0, 0xFF, 0x00, 0x00, 0x1E, 0x01, 0x13, 
				 0x00, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 0xEA, 
				 0x00, 0x16, 0x02, 0x04, 0x00, 0x20, 0x13, 0xC0, 
				 0x00, 0x1E, 0x01, 0x00, 0x16, 0x00, 0x00, 0x19, 
				 0xC0, 0x00, 0x17, 0x4C, 0x00, 0xD0, 0x00, 0x00, 
				 0x00, 0x13, 0xEA, 0x00, 0x1E, 0x00, 0xFF, 0xC0, 
				 0x00, 0x00, 0x1E, 0x01, 0x00, 0x0D, 0x00, 0x00, 
				 0x1F, 0x01, 0x00, 0x19, 0xEA, 0x00, 0x00, 0x0A};

BYTE t5465_Mode_1024x768x15_1[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x16, 0x05, 0x04, 0x00, 0x00, 0x16, 0xC0, 0x00, 
				 0x00, 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 
				 0x00, 0x1F, 0x01, 0x00, 0x18, 0xC5, 0x02, 0x18, 
				 0x07, 0x04, 0x15, 0xA0, 0x00, 0xFF, 0x00, 0x09, 
				 0xCE, 0x03, 0x06, 0x05, 0x09, 0xCE, 0x03, 0x09, 
				 0x00, 0x09, 0xCE, 0x03, 0x0A, 0x00, 0x09, 0xCE, 
				 0x03, 0x0B, 0x00, 0x16, 0x80, 0x00, 0x2F, 0x00, 
				 0x16, 0x84, 0x00, 0x17, 0x00, 0x16, 0x88, 0x00, 
				 0x45, 0x00, 0x1D, 0x19, 0x00, 0x00, 0x00, 0x99, 
				 0x00, 0x00, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x80, 
				 0x00, 0x00, 0x00, 0x99, 0x00, 0x00, 0x00, 0x82, 
				 0x00, 0x00, 0x00, 0x18, 0x00, 0x00, 0x00, 0x96, 
				 0x00, 0x00, 0x00, 0x1F, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7F, 
				 0x00, 0x00, 0x00, 0x83, 0x00, 0x00, 0x00, 0x7F, 
				 0x00, 0x00, 0x00, 0xA0, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x96, 
				 0x00, 0x00, 0x00, 0xE3, 0x00, 0x00, 0x00, 0xFF, 
				 0x00, 0x00, 0x00, 0x1D, 0x06, 0x00, 0x64, 0x00, 
				 0x48, 0x00, 0x00, 0x00, 0x51, 0x00, 0x00, 0x00, 
				 0x22, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x13, 0xEA, 0x00, 0x1E, 0x00, 0x00, 0xC0, 0x00, 
				 0x00, 0x1E, 0x01, 0x52, 0x10, 0x00, 0x00, 0x1F, 
				 0x01, 0x00, 0x19, 0xEA, 0x00, 0x12, 0x07, 0x04, 
				 0x1E, 0x00, 0xC0, 0x00, 0x00, 0x00, 0x1E, 0x01, 
				 0x08, 0x00, 0x00, 0x00, 0x18, 0x07, 0x04, 0x13, 
				 0xC4, 0x02, 0x1E, 0x00, 0x3F, 0xC0, 0x00, 0x00, 
				 0x1E, 0x01, 0xC0, 0x08, 0x00, 0x00, 0x1F, 0x01, 
				 0x00, 0x19, 0xC4, 0x02, 0x13, 0xEA, 0x00, 0x1E, 
				 0x00, 0xC0, 0xFF, 0x00, 0x00, 0x1E, 0x01, 0x19, 
				 0x00, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 0xEA, 
				 0x00, 0x16, 0x02, 0x04, 0x00, 0x28, 0x13, 0xC0, 
				 0x00, 0x1E, 0x01, 0x00, 0x16, 0x00, 0x00, 0x19, 
				 0xC0, 0x00, 0x17, 0x4C, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x17, 0x6C, 0x00, 0x32, 0x00, 0x00, 0x00, 
				 0x13, 0xEA, 0x00, 0x1E, 0x00, 0xFF, 0xC0, 0x00, 
				 0x00, 0x1E, 0x01, 0x00, 0x10, 0x00, 0x00, 0x1F, 
				 0x01, 0x00, 0x19, 0xEA, 0x00, 0x00, 0xEA};

BYTE t5465_Mode_1024x768x15_2[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x16, 0x05, 0x04, 0x00, 0x00, 0x16, 0xC0, 0x00, 
				 0x00, 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 
				 0x00, 0x1F, 0x01, 0x00, 0x18, 0xC5, 0x02, 0x18, 
				 0x07, 0x04, 0x15, 0xA0, 0x00, 0xFF, 0x00, 0x09, 
				 0xCE, 0x03, 0x06, 0x05, 0x09, 0xCE, 0x03, 0x09, 
				 0x00, 0x09, 0xCE, 0x03, 0x0A, 0x00, 0x09, 0xCE, 
				 0x03, 0x0B, 0x00, 0x16, 0x80, 0x00, 0xEF, 0x00, 
				 0x16, 0x84, 0x00, 0x1A, 0x00, 0x16, 0x88, 0x00, 
				 0x3B, 0x00, 0x1D, 0x19, 0x00, 0x00, 0x00, 0xA3, 
				 0x00, 0x00, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x80, 
				 0x00, 0x00, 0x00, 0x83, 0x00, 0x00, 0x00, 0x84, 
				 0x00, 0x00, 0x00, 0x95, 0x00, 0x00, 0x00, 0x24, 
				 0x00, 0x00, 0x00, 0xFD, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x60, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 
				 0x00, 0x00, 0x00, 0x88, 0x00, 0x00, 0x00, 0xFF, 
				 0x00, 0x00, 0x00, 0xA0, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x24, 
				 0x00, 0x00, 0x00, 0xE3, 0x00, 0x00, 0x00, 0xFF, 
				 0x00, 0x00, 0x00, 0x1D, 0x06, 0x00, 0x64, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0xE0, 0x00, 0x00, 0x00, 
				 0x22, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x13, 0xEA, 0x00, 0x1E, 0x00, 0x00, 0xC0, 0x00, 
				 0x00, 0x1E, 0x01, 0x52, 0x10, 0x00, 0x00, 0x1F, 
				 0x01, 0x00, 0x19, 0xEA, 0x00, 0x12, 0x07, 0x04, 
				 0x1E, 0x00, 0xC0, 0x00, 0x00, 0x00, 0x1E, 0x01, 
				 0x08, 0x00, 0x00, 0x00, 0x18, 0x07, 0x04, 0x13, 
				 0xC4, 0x02, 0x1E, 0x00, 0x3F, 0xC0, 0x00, 0x00, 
				 0x1E, 0x01, 0xC0, 0x08, 0x00, 0x00, 0x1F, 0x01, 
				 0x00, 0x19, 0xC4, 0x02, 0x13, 0xEA, 0x00, 0x1E, 
				 0x00, 0xC0, 0xFF, 0x00, 0x00, 0x1E, 0x01, 0x19, 
				 0x00, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 0xEA, 
				 0x00, 0x16, 0x02, 0x04, 0x00, 0x28, 0x13, 0xC0, 
				 0x00, 0x1E, 0x01, 0x00, 0x16, 0x00, 0x00, 0x19, 
				 0xC0, 0x00, 0x17, 0x4C, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x17, 0x6C, 0x00, 0x32, 0x00, 0x00, 0x00, 
				 0x13, 0xEA, 0x00, 0x1E, 0x00, 0xFF, 0xC0, 0x00, 
				 0x00, 0x1E, 0x01, 0x00, 0x10, 0x00, 0x00, 0x1F, 
				 0x01, 0x00, 0x19, 0xEA, 0x00, 0x00, 0xEA};

BYTE t5465_Mode_1024x768x15_3[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x16, 0x05, 0x04, 0x00, 0x00, 0x16, 0xC0, 0x00, 
				 0x00, 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 
				 0x00, 0x1F, 0x01, 0x00, 0x18, 0xC5, 0x02, 0x18, 
				 0x07, 0x04, 0x15, 0xA0, 0x00, 0xFF, 0x00, 0x09, 
				 0xCE, 0x03, 0x06, 0x05, 0x09, 0xCE, 0x03, 0x09, 
				 0x00, 0x09, 0xCE, 0x03, 0x0A, 0x00, 0x09, 0xCE, 
				 0x03, 0x0B, 0x00, 0x16, 0x80, 0x00, 0xEF, 0x00, 
				 0x16, 0x84, 0x00, 0x2A, 0x00, 0x16, 0x88, 0x00, 
				 0x6E, 0x00, 0x1D, 0x19, 0x00, 0x00, 0x00, 0xA1, 
				 0x00, 0x00, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x80, 
				 0x00, 0x00, 0x00, 0x81, 0x00, 0x00, 0x00, 0x84, 
				 0x00, 0x00, 0x00, 0x95, 0x00, 0x00, 0x00, 0x24, 
				 0x00, 0x00, 0x00, 0xFD, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x60, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 
				 0x00, 0x00, 0x00, 0x88, 0x00, 0x00, 0x00, 0xFF, 
				 0x00, 0x00, 0x00, 0xA0, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x24, 
				 0x00, 0x00, 0x00, 0xE3, 0x00, 0x00, 0x00, 0xFF, 
				 0x00, 0x00, 0x00, 0x1D, 0x06, 0x00, 0x64, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0xE0, 0x00, 0x00, 0x00, 
				 0x22, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x13, 0xEA, 0x00, 0x1E, 0x00, 0x00, 0xC0, 0x00, 
				 0x00, 0x1E, 0x01, 0x52, 0x10, 0x00, 0x00, 0x1F, 
				 0x01, 0x00, 0x19, 0xEA, 0x00, 0x12, 0x07, 0x04, 
				 0x1E, 0x00, 0xC0, 0x00, 0x00, 0x00, 0x1E, 0x01, 
				 0x08, 0x00, 0x00, 0x00, 0x18, 0x07, 0x04, 0x13, 
				 0xC4, 0x02, 0x1E, 0x00, 0x3F, 0xC0, 0x00, 0x00, 
				 0x1E, 0x01, 0xC0, 0x08, 0x00, 0x00, 0x1F, 0x01, 
				 0x00, 0x19, 0xC4, 0x02, 0x13, 0xEA, 0x00, 0x1E, 
				 0x00, 0xC0, 0xFF, 0x00, 0x00, 0x1E, 0x01, 0x19, 
				 0x00, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 0xEA, 
				 0x00, 0x16, 0x02, 0x04, 0x00, 0x28, 0x13, 0xC0, 
				 0x00, 0x1E, 0x01, 0x00, 0x16, 0x00, 0x00, 0x19, 
				 0xC0, 0x00, 0x17, 0x4C, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x17, 0x6C, 0x00, 0x32, 0x00, 0x00, 0x00, 
				 0x13, 0xEA, 0x00, 0x1E, 0x00, 0xFF, 0xC0, 0x00, 
				 0x00, 0x1E, 0x01, 0x00, 0x10, 0x00, 0x00, 0x1F, 
				 0x01, 0x00, 0x19, 0xEA, 0x00, 0x00, 0xEA};

BYTE t5465_Mode_1024x768x15_4[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x16, 0x05, 0x04, 0x00, 0x00, 0x16, 0xC0, 0x00, 
				 0x00, 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 
				 0x00, 0x1F, 0x01, 0x00, 0x18, 0xC5, 0x02, 0x18, 
				 0x07, 0x04, 0x15, 0xA0, 0x00, 0xFF, 0x00, 0x09, 
				 0xCE, 0x03, 0x06, 0x05, 0x09, 0xCE, 0x03, 0x09, 
				 0x00, 0x09, 0xCE, 0x03, 0x0A, 0x00, 0x09, 0xCE, 
				 0x03, 0x0B, 0x00, 0x16, 0x80, 0x00, 0x2F, 0x00, 
				 0x16, 0x84, 0x00, 0x10, 0x00, 0x16, 0x88, 0x00, 
				 0x2C, 0x00, 0x1D, 0x19, 0x00, 0x00, 0x00, 0x9F, 
				 0x00, 0x00, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x80, 
				 0x00, 0x00, 0x00, 0x9F, 0x00, 0x00, 0x00, 0x83, 
				 0x00, 0x00, 0x00, 0x0F, 0x00, 0x00, 0x00, 0x1E, 
				 0x00, 0x00, 0x00, 0xF5, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x60, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x83, 0x00, 0x00, 0x00, 0xFF, 
				 0x00, 0x00, 0x00, 0xA0, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 0x1E, 
				 0x00, 0x00, 0x00, 0xE3, 0x00, 0x00, 0x00, 0xFF, 
				 0x00, 0x00, 0x00, 0x1D, 0x06, 0x00, 0x64, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0xE0, 0x00, 0x00, 0x00, 
				 0x22, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x13, 0xEA, 0x00, 0x1E, 0x00, 0x00, 0xC0, 0x00, 
				 0x00, 0x1E, 0x01, 0x52, 0x10, 0x00, 0x00, 0x1F, 
				 0x01, 0x00, 0x19, 0xEA, 0x00, 0x12, 0x07, 0x04, 
				 0x1E, 0x00, 0xC0, 0x00, 0x00, 0x00, 0x1E, 0x01, 
				 0x08, 0x00, 0x00, 0x00, 0x18, 0x07, 0x04, 0x13, 
				 0xC4, 0x02, 0x1E, 0x00, 0x3F, 0xC0, 0x00, 0x00, 
				 0x1E, 0x01, 0xC0, 0x08, 0x00, 0x00, 0x1F, 0x01, 
				 0x00, 0x19, 0xC4, 0x02, 0x13, 0xEA, 0x00, 0x1E, 
				 0x00, 0xC0, 0xFF, 0x00, 0x00, 0x1E, 0x01, 0x19, 
				 0x00, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 0xEA, 
				 0x00, 0x16, 0x02, 0x04, 0x00, 0x28, 0x13, 0xC0, 
				 0x00, 0x1E, 0x01, 0x00, 0x16, 0x00, 0x00, 0x19, 
				 0xC0, 0x00, 0x17, 0x4C, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x17, 0x6C, 0x00, 0x32, 0x00, 0x00, 0x00, 
				 0x13, 0xEA, 0x00, 0x1E, 0x00, 0xFF, 0xC0, 0x00, 
				 0x00, 0x1E, 0x01, 0x00, 0x10, 0x00, 0x00, 0x1F, 
				 0x01, 0x00, 0x19, 0xEA, 0x00, 0x00, 0xEA};

BYTE t5465_Mode_1024x768x15_5[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x16, 0x05, 0x04, 0x00, 0x00, 0x16, 0xC0, 0x00, 
				 0x00, 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 
				 0x00, 0x1F, 0x01, 0x00, 0x18, 0xC5, 0x02, 0x18, 
				 0x07, 0x04, 0x15, 0xA0, 0x00, 0xFF, 0x00, 0x09, 
				 0xCE, 0x03, 0x06, 0x05, 0x09, 0xCE, 0x03, 0x09, 
				 0x00, 0x09, 0xCE, 0x03, 0x0A, 0x00, 0x09, 0xCE, 
				 0x03, 0x0B, 0x00, 0x16, 0x80, 0x00, 0x2F, 0x00, 
				 0x16, 0x84, 0x00, 0x0A, 0x00, 0x16, 0x88, 0x00, 
				 0x21, 0x00, 0x1D, 0x19, 0x00, 0x00, 0x00, 0xA7, 
				 0x00, 0x00, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x80, 
				 0x00, 0x00, 0x00, 0x87, 0x00, 0x00, 0x00, 0x87, 
				 0x00, 0x00, 0x00, 0x93, 0x00, 0x00, 0x00, 0x26, 
				 0x00, 0x00, 0x00, 0xF5, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x60, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x83, 0x00, 0x00, 0x00, 0xFF, 
				 0x00, 0x00, 0x00, 0xA0, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 0x26, 
				 0x00, 0x00, 0x00, 0xE3, 0x00, 0x00, 0x00, 0xFF, 
				 0x00, 0x00, 0x00, 0x1D, 0x06, 0x00, 0x64, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0xE0, 0x00, 0x00, 0x00, 
				 0x22, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x13, 0xEA, 0x00, 0x1E, 0x00, 0x00, 0xC0, 0x00, 
				 0x00, 0x1E, 0x01, 0x52, 0x10, 0x00, 0x00, 0x1F, 
				 0x01, 0x00, 0x19, 0xEA, 0x00, 0x12, 0x07, 0x04, 
				 0x1E, 0x00, 0xC0, 0x00, 0x00, 0x00, 0x1E, 0x01, 
				 0x08, 0x00, 0x00, 0x00, 0x18, 0x07, 0x04, 0x13, 
				 0xC4, 0x02, 0x1E, 0x00, 0x3F, 0xC0, 0x00, 0x00, 
				 0x1E, 0x01, 0xC0, 0x08, 0x00, 0x00, 0x1F, 0x01, 
				 0x00, 0x19, 0xC4, 0x02, 0x13, 0xEA, 0x00, 0x1E, 
				 0x00, 0xC0, 0xFF, 0x00, 0x00, 0x1E, 0x01, 0x19, 
				 0x00, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 0xEA, 
				 0x00, 0x16, 0x02, 0x04, 0x00, 0x28, 0x13, 0xC0, 
				 0x00, 0x1E, 0x01, 0x00, 0x16, 0x00, 0x00, 0x19, 
				 0xC0, 0x00, 0x17, 0x4C, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x17, 0x6C, 0x00, 0x32, 0x00, 0x00, 0x00, 
				 0x13, 0xEA, 0x00, 0x1E, 0x00, 0xFF, 0xC0, 0x00, 
				 0x00, 0x1E, 0x01, 0x00, 0x10, 0x00, 0x00, 0x1F, 
				 0x01, 0x00, 0x19, 0xEA, 0x00, 0x00, 0xEA};

BYTE t5465_Mode_1152x864x15_1[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x16, 0x05, 0x04, 0x00, 0x00, 0x16, 0xC0, 0x00, 
				 0x00, 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 
				 0x00, 0x1F, 0x01, 0x00, 0x18, 0xC5, 0x02, 0x18, 
				 0x07, 0x04, 0x15, 0xA0, 0x00, 0xFF, 0x00, 0x09, 
				 0xCE, 0x03, 0x06, 0x05, 0x09, 0xCE, 0x03, 0x09, 
				 0x00, 0x09, 0xCE, 0x03, 0x0A, 0x00, 0x09, 0xCE, 
				 0x03, 0x0B, 0x00, 0x16, 0x80, 0x00, 0x2F, 0x00, 
				 0x16, 0x84, 0x00, 0x0A, 0x00, 0x16, 0x88, 0x00, 
				 0x21, 0x00, 0x1D, 0x19, 0x00, 0x00, 0x00, 0xB4, 
				 0x00, 0x00, 0x00, 0x8F, 0x00, 0x00, 0x00, 0x8F, 
				 0x00, 0x00, 0x00, 0x94, 0x00, 0x00, 0x00, 0x95, 
				 0x00, 0x00, 0x00, 0x81, 0x00, 0x00, 0x00, 0x8E, 
				 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x60, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x60, 
				 0x00, 0x00, 0x00, 0x83, 0x00, 0x00, 0x00, 0x5F, 
				 0x00, 0x00, 0x00, 0xA0, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x5F, 0x00, 0x00, 0x00, 0x8E, 
				 0x00, 0x00, 0x00, 0xE3, 0x00, 0x00, 0x00, 0xFF, 
				 0x00, 0x00, 0x00, 0x1D, 0x06, 0x00, 0x64, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0xE0, 0x00, 0x00, 0x00, 
				 0x22, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x13, 0xEA, 0x00, 0x1E, 0x00, 0x00, 0xC0, 0x00, 
				 0x00, 0x1E, 0x01, 0x22, 0x14, 0x00, 0x00, 0x1F, 
				 0x01, 0x00, 0x19, 0xEA, 0x00, 0x12, 0x07, 0x04, 
				 0x1E, 0x00, 0xC0, 0x00, 0x00, 0x00, 0x1E, 0x01, 
				 0x14, 0x00, 0x00, 0x00, 0x18, 0x07, 0x04, 0x13, 
				 0xC4, 0x02, 0x1E, 0x00, 0x3F, 0xC0, 0x00, 0x00, 
				 0x1E, 0x01, 0x80, 0x14, 0x00, 0x00, 0x1F, 0x01, 
				 0x00, 0x19, 0xC4, 0x02, 0x16, 0x02, 0x04, 0x00, 
				 0x20, 0x13, 0xC0, 0x00, 0x1E, 0x01, 0x00, 0x16, 
				 0x00, 0x00, 0x19, 0xC0, 0x00, 0x17, 0x4C, 0x00, 
				 0x40, 0x00, 0x00, 0x00, 0x17, 0x6C, 0x00, 0x32, 
				 0x00, 0x00, 0x00, 0x13, 0xEA, 0x00, 0x1E, 0x00, 
				 0xFF, 0xC0, 0x00, 0x00, 0x1E, 0x01, 0x00, 0x12, 
				 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 0xEA, 0x00, 
				 0x00, 0xEA};

BYTE t5465_Mode_1152x864x15_2[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x16, 0x05, 0x04, 0x00, 0x00, 0x16, 0xC0, 0x00, 
				 0x00, 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 
				 0x00, 0x1F, 0x01, 0x00, 0x18, 0xC5, 0x02, 0x18, 
				 0x07, 0x04, 0x15, 0xA0, 0x00, 0xFF, 0x00, 0x09, 
				 0xCE, 0x03, 0x06, 0x05, 0x09, 0xCE, 0x03, 0x09, 
				 0x00, 0x09, 0xCE, 0x03, 0x0A, 0x00, 0x09, 0xCE, 
				 0x03, 0x0B, 0x00, 0x16, 0x80, 0x00, 0x2F, 0x00, 
				 0x16, 0x84, 0x00, 0x16, 0x00, 0x16, 0x88, 0x00, 
				 0x53, 0x00, 0x1D, 0x19, 0x00, 0x00, 0x00, 0xC3, 
				 0x00, 0x00, 0x00, 0x8F, 0x00, 0x00, 0x00, 0x8F, 
				 0x00, 0x00, 0x00, 0x83, 0x00, 0x00, 0x00, 0x99, 
				 0x00, 0x00, 0x00, 0x09, 0x00, 0x00, 0x00, 0x82, 
				 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x60, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x60, 
				 0x00, 0x00, 0x00, 0x83, 0x00, 0x00, 0x00, 0x5F, 
				 0x00, 0x00, 0x00, 0xA0, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x5F, 0x00, 0x00, 0x00, 0x82, 
				 0x00, 0x00, 0x00, 0xE3, 0x00, 0x00, 0x00, 0xFF, 
				 0x00, 0x00, 0x00, 0x1D, 0x06, 0x00, 0x64, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0xF0, 0x00, 0x00, 0x00, 
				 0x22, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x13, 0xEA, 0x00, 0x1E, 0x00, 0x00, 0xC0, 0x00, 
				 0x00, 0x1E, 0x01, 0x22, 0x14, 0x00, 0x00, 0x1F, 
				 0x01, 0x00, 0x19, 0xEA, 0x00, 0x12, 0x07, 0x04, 
				 0x1E, 0x00, 0xC0, 0x00, 0x00, 0x00, 0x1E, 0x01, 
				 0x14, 0x00, 0x00, 0x00, 0x18, 0x07, 0x04, 0x13, 
				 0xC4, 0x02, 0x1E, 0x00, 0x3F, 0xC0, 0x00, 0x00, 
				 0x1E, 0x01, 0x80, 0x14, 0x00, 0x00, 0x1F, 0x01, 
				 0x00, 0x19, 0xC4, 0x02, 0x16, 0x02, 0x04, 0x00, 
				 0x20, 0x13, 0xC0, 0x00, 0x1E, 0x01, 0x00, 0x16, 
				 0x00, 0x00, 0x19, 0xC0, 0x00, 0x17, 0x4C, 0x00, 
				 0x40, 0x00, 0x00, 0x00, 0x17, 0x6C, 0x00, 0x32, 
				 0x00, 0x00, 0x00, 0x13, 0xEA, 0x00, 0x1E, 0x00, 
				 0xFF, 0xC0, 0x00, 0x00, 0x1E, 0x01, 0x00, 0x12, 
				 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 0xEA, 0x00, 
				 0x00, 0xEA};

BYTE t5465_Mode_1152x864x15_3[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x16, 0x05, 0x04, 0x00, 0x00, 0x16, 0xC0, 0x00, 
				 0x00, 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 
				 0x00, 0x1F, 0x01, 0x00, 0x18, 0xC5, 0x02, 0x18, 
				 0x07, 0x04, 0x15, 0xA0, 0x00, 0xFF, 0x00, 0x09, 
				 0xCE, 0x03, 0x06, 0x05, 0x09, 0xCE, 0x03, 0x09, 
				 0x00, 0x09, 0xCE, 0x03, 0x0A, 0x00, 0x09, 0xCE, 
				 0x03, 0x0B, 0x00, 0x16, 0x80, 0x00, 0x2F, 0x00, 
				 0x16, 0x84, 0x00, 0x04, 0x00, 0x16, 0x88, 0x00, 
				 0x11, 0x00, 0x1D, 0x19, 0x00, 0x00, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x8F, 0x00, 0x00, 0x00, 0x8F, 
				 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x99, 
				 0x00, 0x00, 0x00, 0x09, 0x00, 0x00, 0x00, 0x89, 
				 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x60, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x60, 
				 0x00, 0x00, 0x00, 0x83, 0x00, 0x00, 0x00, 0x5F, 
				 0x00, 0x00, 0x00, 0xA0, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x5F, 0x00, 0x00, 0x00, 0x89, 
				 0x00, 0x00, 0x00, 0xE3, 0x00, 0x00, 0x00, 0xFF, 
				 0x00, 0x00, 0x00, 0x1D, 0x06, 0x00, 0x64, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0xF0, 0x00, 0x00, 0x00, 
				 0x22, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x13, 0xEA, 0x00, 0x1E, 0x00, 0x00, 0xC0, 0x00, 
				 0x00, 0x1E, 0x01, 0x22, 0x14, 0x00, 0x00, 0x1F, 
				 0x01, 0x00, 0x19, 0xEA, 0x00, 0x12, 0x07, 0x04, 
				 0x1E, 0x00, 0xC0, 0x00, 0x00, 0x00, 0x1E, 0x01, 
				 0x14, 0x00, 0x00, 0x00, 0x18, 0x07, 0x04, 0x13, 
				 0xC4, 0x02, 0x1E, 0x00, 0x3F, 0xC0, 0x00, 0x00, 
				 0x1E, 0x01, 0x80, 0x14, 0x00, 0x00, 0x1F, 0x01, 
				 0x00, 0x19, 0xC4, 0x02, 0x16, 0x02, 0x04, 0x00, 
				 0x20, 0x13, 0xC0, 0x00, 0x1E, 0x01, 0x00, 0x16, 
				 0x00, 0x00, 0x19, 0xC0, 0x00, 0x17, 0x4C, 0x00, 
				 0x40, 0x00, 0x00, 0x00, 0x17, 0x6C, 0x00, 0x32, 
				 0x00, 0x00, 0x00, 0x13, 0xEA, 0x00, 0x1E, 0x00, 
				 0xFF, 0xC0, 0x00, 0x00, 0x1E, 0x01, 0x00, 0x12, 
				 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 0xEA, 0x00, 
				 0x00, 0xEA};

BYTE t5465_Mode_1280x960x15_1[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x16, 0x05, 0x04, 0x00, 0x00, 0x16, 0xC0, 0x00, 
				 0x00, 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 
				 0x00, 0x1F, 0x01, 0x00, 0x18, 0xC5, 0x02, 0x18, 
				 0x07, 0x04, 0x15, 0xA0, 0x00, 0xFF, 0x00, 0x09, 
				 0xCE, 0x03, 0x06, 0x05, 0x09, 0xCE, 0x03, 0x09, 
				 0x00, 0x09, 0xCE, 0x03, 0x0A, 0x00, 0x09, 0xCE, 
				 0x03, 0x0B, 0x00, 0x16, 0x80, 0x00, 0x2F, 0x00, 
				 0x16, 0x84, 0x00, 0x16, 0x00, 0x16, 0x88, 0x00, 
				 0x53, 0x00, 0x1D, 0x19, 0x00, 0x00, 0x00, 0xDC, 
				 0x00, 0x00, 0x00, 0x9F, 0x00, 0x00, 0x00, 0x9F, 
				 0x00, 0x00, 0x00, 0x9C, 0x00, 0x00, 0x00, 0xAD, 
				 0x00, 0x00, 0x00, 0x1B, 0x00, 0x00, 0x00, 0xE6, 
				 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x60, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x83, 0x00, 0x00, 0x00, 0xBF, 
				 0x00, 0x00, 0x00, 0xA0, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0xBF, 0x00, 0x00, 0x00, 0xE6, 
				 0x00, 0x00, 0x00, 0xE3, 0x00, 0x00, 0x00, 0xFF, 
				 0x00, 0x00, 0x00, 0x1D, 0x06, 0x00, 0x64, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0xF0, 0x00, 0x00, 0x00, 
				 0x22, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x13, 0xEA, 0x00, 0x1E, 0x00, 0x00, 0xC0, 0x00, 
				 0x00, 0x1E, 0x01, 0x22, 0x14, 0x00, 0x00, 0x1F, 
				 0x01, 0x00, 0x19, 0xEA, 0x00, 0x12, 0x07, 0x04, 
				 0x1E, 0x00, 0xC0, 0x00, 0x00, 0x00, 0x1E, 0x01, 
				 0x14, 0x00, 0x00, 0x00, 0x18, 0x07, 0x04, 0x13, 
				 0xC4, 0x02, 0x1E, 0x00, 0x3F, 0xC0, 0x00, 0x00, 
				 0x1E, 0x01, 0x80, 0x14, 0x00, 0x00, 0x1F, 0x01, 
				 0x00, 0x19, 0xC4, 0x02, 0x16, 0x02, 0x04, 0x00, 
				 0x20, 0x13, 0xC0, 0x00, 0x1E, 0x01, 0x00, 0x16, 
				 0x00, 0x00, 0x19, 0xC0, 0x00, 0x17, 0x4C, 0x00, 
				 0x40, 0x00, 0x00, 0x00, 0x17, 0x6C, 0x00, 0x32, 
				 0x00, 0x00, 0x00, 0x13, 0xEA, 0x00, 0x1E, 0x00, 
				 0xFF, 0xC0, 0x00, 0x00, 0x1E, 0x01, 0x00, 0x14, 
				 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 0xEA, 0x00, 
				 0x00, 0xEA};

BYTE t5465_Mode_1280x960x15_2[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x16, 0x05, 0x04, 0x00, 0x00, 0x16, 0xC0, 0x00, 
				 0x00, 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 
				 0x00, 0x1F, 0x01, 0x00, 0x18, 0xC5, 0x02, 0x18, 
				 0x07, 0x04, 0x15, 0xA0, 0x00, 0xFF, 0x00, 0x09, 
				 0xCE, 0x03, 0x06, 0x05, 0x09, 0xCE, 0x03, 0x09, 
				 0x00, 0x09, 0xCE, 0x03, 0x0A, 0x00, 0x09, 0xCE, 
				 0x03, 0x0B, 0x00, 0x16, 0x80, 0x00, 0x2F, 0x00, 
				 0x16, 0x84, 0x00, 0x0A, 0x00, 0x16, 0x88, 0x00, 
				 0x2C, 0x00, 0x1D, 0x19, 0x00, 0x00, 0x00, 0xCD, 
				 0x00, 0x00, 0x00, 0x9F, 0x00, 0x00, 0x00, 0x9F, 
				 0x00, 0x00, 0x00, 0x8D, 0x00, 0x00, 0x00, 0xA5, 
				 0x00, 0x00, 0x00, 0x17, 0x00, 0x00, 0x00, 0xE6, 
				 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x60, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x83, 0x00, 0x00, 0x00, 0xBF, 
				 0x00, 0x00, 0x00, 0xA0, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0xBF, 0x00, 0x00, 0x00, 0xE6, 
				 0x00, 0x00, 0x00, 0xE3, 0x00, 0x00, 0x00, 0xFF, 
				 0x00, 0x00, 0x00, 0x1D, 0x06, 0x00, 0x64, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0xF0, 0x00, 0x00, 0x00, 
				 0x22, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x13, 0xEA, 0x00, 0x1E, 0x00, 0x00, 0xC0, 0x00, 
				 0x00, 0x1E, 0x01, 0x22, 0x14, 0x00, 0x00, 0x1F, 
				 0x01, 0x00, 0x19, 0xEA, 0x00, 0x12, 0x07, 0x04, 
				 0x1E, 0x00, 0xC0, 0x00, 0x00, 0x00, 0x1E, 0x01, 
				 0x14, 0x00, 0x00, 0x00, 0x18, 0x07, 0x04, 0x13, 
				 0xC4, 0x02, 0x1E, 0x00, 0x3F, 0xC0, 0x00, 0x00, 
				 0x1E, 0x01, 0x80, 0x14, 0x00, 0x00, 0x1F, 0x01, 
				 0x00, 0x19, 0xC4, 0x02, 0x16, 0x02, 0x04, 0x00, 
				 0x20, 0x13, 0xC0, 0x00, 0x1E, 0x01, 0x00, 0x16, 
				 0x00, 0x00, 0x19, 0xC0, 0x00, 0x17, 0x4C, 0x00, 
				 0x40, 0x00, 0x00, 0x00, 0x17, 0x6C, 0x00, 0x32, 
				 0x00, 0x00, 0x00, 0x13, 0xEA, 0x00, 0x1E, 0x00, 
				 0xFF, 0xC0, 0x00, 0x00, 0x1E, 0x01, 0x00, 0x14, 
				 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 0xEA, 0x00, 
				 0x00, 0xEA};

BYTE t5465_Mode_1280x960x15_3[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x16, 0x05, 0x04, 0x00, 0x00, 0x16, 0xC0, 0x00, 
				 0x00, 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 
				 0x00, 0x1F, 0x01, 0x00, 0x18, 0xC5, 0x02, 0x18, 
				 0x07, 0x04, 0x15, 0xA0, 0x00, 0xFF, 0x00, 0x09, 
				 0xCE, 0x03, 0x06, 0x05, 0x09, 0xCE, 0x03, 0x09, 
				 0x00, 0x09, 0xCE, 0x03, 0x0A, 0x00, 0x09, 0xCE, 
				 0x03, 0x0B, 0x00, 0x16, 0x80, 0x00, 0x2F, 0x00, 
				 0x16, 0x84, 0x00, 0x10, 0x00, 0x16, 0x88, 0x00, 
				 0x53, 0x00, 0x1D, 0x19, 0x00, 0x00, 0x00, 0xD3, 
				 0x00, 0x00, 0x00, 0x9F, 0x00, 0x00, 0x00, 0x9F, 
				 0x00, 0x00, 0x00, 0x93, 0x00, 0x00, 0x00, 0xA6, 
				 0x00, 0x00, 0x00, 0x1B, 0x00, 0x00, 0x00, 0xF1, 
				 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x60, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x83, 0x00, 0x00, 0x00, 0xBF, 
				 0x00, 0x00, 0x00, 0xA0, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0xBF, 0x00, 0x00, 0x00, 0xF1, 
				 0x00, 0x00, 0x00, 0xE3, 0x00, 0x00, 0x00, 0xFF, 
				 0x00, 0x00, 0x00, 0x1D, 0x06, 0x00, 0x64, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0xF0, 0x00, 0x00, 0x00, 
				 0x22, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x13, 0xEA, 0x00, 0x1E, 0x00, 0x00, 0xC0, 0x00, 
				 0x00, 0x1E, 0x01, 0x22, 0x14, 0x00, 0x00, 0x1F, 
				 0x01, 0x00, 0x19, 0xEA, 0x00, 0x12, 0x07, 0x04, 
				 0x1E, 0x00, 0xC0, 0x00, 0x00, 0x00, 0x1E, 0x01, 
				 0x14, 0x00, 0x00, 0x00, 0x18, 0x07, 0x04, 0x13, 
				 0xC4, 0x02, 0x1E, 0x00, 0x3F, 0xC0, 0x00, 0x00, 
				 0x1E, 0x01, 0x80, 0x14, 0x00, 0x00, 0x1F, 0x01, 
				 0x00, 0x19, 0xC4, 0x02, 0x13, 0xEA, 0x00, 0x1E, 
				 0x00, 0xC0, 0xFF, 0x00, 0x00, 0x1E, 0x01, 0x29, 
				 0x00, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 0xEA, 
				 0x00, 0x16, 0x02, 0x04, 0x00, 0x20, 0x13, 0xC0, 
				 0x00, 0x1E, 0x01, 0x00, 0x16, 0x00, 0x00, 0x19, 
				 0xC0, 0x00, 0x17, 0x4C, 0x00, 0x40, 0x00, 0x00, 
				 0x00, 0x17, 0x6C, 0x00, 0x32, 0x00, 0x00, 0x00, 
				 0x13, 0xEA, 0x00, 0x1E, 0x00, 0xFF, 0xC0, 0x00, 
				 0x00, 0x1E, 0x01, 0x00, 0x14, 0x00, 0x00, 0x1F, 
				 0x01, 0x00, 0x19, 0xEA, 0x00, 0x00, 0xEA};

BYTE t5465_Mode_1280x1024x15_1[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x16, 0x05, 0x04, 0x00, 0x00, 0x16, 0xC0, 0x00, 
				 0x00, 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 
				 0x00, 0x1F, 0x01, 0x00, 0x18, 0xC5, 0x02, 0x18, 
				 0x07, 0x04, 0x15, 0xA0, 0x00, 0xFF, 0x00, 0x09, 
				 0xCE, 0x03, 0x06, 0x05, 0x09, 0xCE, 0x03, 0x09, 
				 0x00, 0x09, 0xCE, 0x03, 0x0A, 0x00, 0x09, 0xCE, 
				 0x03, 0x0B, 0x00, 0x16, 0x80, 0x00, 0x2F, 0x00, 
				 0x16, 0x84, 0x00, 0x04, 0x00, 0x16, 0x88, 0x00, 
				 0x0B, 0x00, 0x1D, 0x19, 0x00, 0x00, 0x00, 0xCF, 
				 0x00, 0x00, 0x00, 0x9F, 0x00, 0x00, 0x00, 0x9F, 
				 0x00, 0x00, 0x00, 0x93, 0x00, 0x00, 0x00, 0xA9, 
				 0x00, 0x00, 0x00, 0x13, 0x00, 0x00, 0x00, 0x14, 
				 0x00, 0x00, 0x00, 0xB2, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x60, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x82, 0x00, 0x00, 0x00, 0xFF, 
				 0x00, 0x00, 0x00, 0xA0, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x14, 
				 0x00, 0x00, 0x00, 0xE3, 0x00, 0x00, 0x00, 0xFF, 
				 0x00, 0x00, 0x00, 0x1D, 0x06, 0x00, 0x64, 0x00, 
				 0x67, 0x00, 0x00, 0x00, 0x81, 0x00, 0x00, 0x00, 
				 0x22, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x13, 0xEA, 0x00, 0x1E, 0x00, 0x00, 0xC0, 0x00, 
				 0x00, 0x1E, 0x01, 0x22, 0x14, 0x00, 0x00, 0x1F, 
				 0x01, 0x00, 0x19, 0xEA, 0x00, 0x12, 0x07, 0x04, 
				 0x1E, 0x00, 0xC0, 0x00, 0x00, 0x00, 0x1E, 0x01, 
				 0x14, 0x00, 0x00, 0x00, 0x18, 0x07, 0x04, 0x13, 
				 0xC4, 0x02, 0x1E, 0x00, 0x3F, 0xC0, 0x00, 0x00, 
				 0x1E, 0x01, 0x80, 0x14, 0x00, 0x00, 0x1F, 0x01, 
				 0x00, 0x19, 0xC4, 0x02, 0x16, 0x02, 0x04, 0x00, 
				 0x20, 0x13, 0xC0, 0x00, 0x1E, 0x01, 0x00, 0x16, 
				 0x00, 0x00, 0x19, 0xC0, 0x00, 0x17, 0x4C, 0x00, 
				 0x40, 0x00, 0x00, 0x00, 0x17, 0x6C, 0x00, 0x32, 
				 0x00, 0x00, 0x00, 0x13, 0xEA, 0x00, 0x1E, 0x00, 
				 0xFF, 0xC0, 0x00, 0x00, 0x1E, 0x01, 0x00, 0x14, 
				 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 0xEA, 0x00, 
				 0x00, 0xEA};

BYTE t5465_Mode_1280x1024x15_2[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x16, 0x05, 0x04, 0x00, 0x00, 0x16, 0xC0, 0x00, 
				 0x00, 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 
				 0x00, 0x1F, 0x01, 0x00, 0x18, 0xC5, 0x02, 0x18, 
				 0x07, 0x04, 0x15, 0xA0, 0x00, 0xFF, 0x00, 0x09, 
				 0xCE, 0x03, 0x06, 0x05, 0x09, 0xCE, 0x03, 0x09, 
				 0x00, 0x09, 0xCE, 0x03, 0x0A, 0x00, 0x09, 0xCE, 
				 0x03, 0x0B, 0x00, 0x16, 0x80, 0x00, 0x2F, 0x00, 
				 0x16, 0x84, 0x00, 0x16, 0x00, 0x16, 0x88, 0x00, 
				 0x53, 0x00, 0x1D, 0x19, 0x00, 0x00, 0x00, 0xCE, 
				 0x00, 0x00, 0x00, 0x9F, 0x00, 0x00, 0x00, 0x9F, 
				 0x00, 0x00, 0x00, 0x91, 0x00, 0x00, 0x00, 0xA7, 
				 0x00, 0x00, 0x00, 0x15, 0x00, 0x00, 0x00, 0x28, 
				 0x00, 0x00, 0x00, 0x5A, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x60, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x83, 0x00, 0x00, 0x00, 0xFF, 
				 0x00, 0x00, 0x00, 0xA0, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 0x24, 
				 0x00, 0x00, 0x00, 0xE3, 0x00, 0x00, 0x00, 0xFF, 
				 0x00, 0x00, 0x00, 0x1D, 0x06, 0x00, 0x64, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x30, 0x00, 0x00, 0x00, 
				 0x22, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x09, 0x00, 0x00, 0x00, 
				 0x13, 0xEA, 0x00, 0x1E, 0x00, 0x00, 0xC0, 0x00, 
				 0x00, 0x1E, 0x01, 0x22, 0x14, 0x00, 0x00, 0x1F, 
				 0x01, 0x00, 0x19, 0xEA, 0x00, 0x12, 0x07, 0x04, 
				 0x1E, 0x00, 0xC0, 0x00, 0x00, 0x00, 0x1E, 0x01, 
				 0x14, 0x00, 0x00, 0x00, 0x18, 0x07, 0x04, 0x13, 
				 0xC4, 0x02, 0x1E, 0x00, 0x3F, 0xC0, 0x00, 0x00, 
				 0x1E, 0x01, 0x80, 0x14, 0x00, 0x00, 0x1F, 0x01, 
				 0x00, 0x19, 0xC4, 0x02, 0x16, 0x02, 0x04, 0x00, 
				 0x20, 0x13, 0xC0, 0x00, 0x1E, 0x01, 0x00, 0x16, 
				 0x00, 0x00, 0x19, 0xC0, 0x00, 0x17, 0x4C, 0x00, 
				 0x40, 0x00, 0x00, 0x00, 0x17, 0x6C, 0x00, 0x32, 
				 0x00, 0x00, 0x00, 0x13, 0xEA, 0x00, 0x1E, 0x00, 
				 0xFF, 0xC0, 0x00, 0x00, 0x1E, 0x01, 0x00, 0x14, 
				 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 0xEA, 0x00, 
				 0x00, 0xEA};

BYTE t5465_Mode_1280x1024x15_3[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x16, 0x05, 0x04, 0x00, 0x00, 0x16, 0xC0, 0x00, 
				 0x00, 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 
				 0x00, 0x1F, 0x01, 0x00, 0x18, 0xC5, 0x02, 0x18, 
				 0x07, 0x04, 0x15, 0xA0, 0x00, 0xFF, 0x00, 0x09, 
				 0xCE, 0x03, 0x06, 0x05, 0x09, 0xCE, 0x03, 0x09, 
				 0x00, 0x09, 0xCE, 0x03, 0x0A, 0x00, 0x09, 0xCE, 
				 0x03, 0x0B, 0x00, 0x16, 0x80, 0x00, 0x2F, 0x00, 
				 0x16, 0x84, 0x00, 0x1A, 0x00, 0x16, 0x88, 0x00, 
				 0x76, 0x00, 0x1D, 0x19, 0x00, 0x00, 0x00, 0xCE, 
				 0x00, 0x00, 0x00, 0x9F, 0x00, 0x00, 0x00, 0x9F, 
				 0x00, 0x00, 0x00, 0x91, 0x00, 0x00, 0x00, 0xA3, 
				 0x00, 0x00, 0x00, 0x15, 0x00, 0x00, 0x00, 0x28, 
				 0x00, 0x00, 0x00, 0x5A, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x60, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x83, 0x00, 0x00, 0x00, 0xFF, 
				 0x00, 0x00, 0x00, 0xA0, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 0x24, 
				 0x00, 0x00, 0x00, 0xE3, 0x00, 0x00, 0x00, 0xFF, 
				 0x00, 0x00, 0x00, 0x1D, 0x06, 0x00, 0x64, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x30, 0x00, 0x00, 0x00, 
				 0x22, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x09, 0x00, 0x00, 0x00, 
				 0x13, 0xEA, 0x00, 0x1E, 0x00, 0x00, 0xC0, 0x00, 
				 0x00, 0x1E, 0x01, 0x22, 0x14, 0x00, 0x00, 0x1F, 
				 0x01, 0x00, 0x19, 0xEA, 0x00, 0x12, 0x07, 0x04, 
				 0x1E, 0x00, 0xC0, 0x00, 0x00, 0x00, 0x1E, 0x01, 
				 0x14, 0x00, 0x00, 0x00, 0x18, 0x07, 0x04, 0x13, 
				 0xC4, 0x02, 0x1E, 0x00, 0x3F, 0xC0, 0x00, 0x00, 
				 0x1E, 0x01, 0x80, 0x14, 0x00, 0x00, 0x1F, 0x01, 
				 0x00, 0x19, 0xC4, 0x02, 0x13, 0xEA, 0x00, 0x1E, 
				 0x00, 0xC0, 0xFF, 0x00, 0x00, 0x1E, 0x01, 0x23, 
				 0x00, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 0xEA, 
				 0x00, 0x16, 0x02, 0x04, 0x00, 0x20, 0x13, 0xC0, 
				 0x00, 0x1E, 0x01, 0x00, 0x16, 0x00, 0x00, 0x19, 
				 0xC0, 0x00, 0x17, 0x4C, 0x00, 0x40, 0x00, 0x00, 
				 0x00, 0x17, 0x6C, 0x00, 0x32, 0x00, 0x00, 0x00, 
				 0x13, 0xEA, 0x00, 0x1E, 0x00, 0xFF, 0xC0, 0x00, 
				 0x00, 0x1E, 0x01, 0x00, 0x14, 0x00, 0x00, 0x1F, 
				 0x01, 0x00, 0x19, 0xEA, 0x00, 0x00, 0xEA};

BYTE t5465_Mode_1280x1024x15_4[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x16, 0x05, 0x04, 0x00, 0x00, 0x16, 0xC0, 0x00, 
				 0x00, 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 
				 0x00, 0x1F, 0x01, 0x00, 0x18, 0xC5, 0x02, 0x18, 
				 0x07, 0x04, 0x15, 0xA0, 0x00, 0xFF, 0x00, 0x09, 
				 0xCE, 0x03, 0x06, 0x05, 0x09, 0xCE, 0x03, 0x09, 
				 0x00, 0x09, 0xCE, 0x03, 0x0A, 0x00, 0x09, 0xCE, 
				 0x03, 0x0B, 0x00, 0x16, 0x80, 0x00, 0x2F, 0x00, 
				 0x16, 0x84, 0x00, 0x0E, 0x00, 0x16, 0x88, 0x00, 
				 0x42, 0x00, 0x1D, 0x19, 0x00, 0x00, 0x00, 0xCE, 
				 0x00, 0x00, 0x00, 0x9F, 0x00, 0x00, 0x00, 0x9F, 
				 0x00, 0x00, 0x00, 0x91, 0x00, 0x00, 0x00, 0xA3, 
				 0x00, 0x00, 0x00, 0x15, 0x00, 0x00, 0x00, 0x28, 
				 0x00, 0x00, 0x00, 0x5A, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x60, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x83, 0x00, 0x00, 0x00, 0xFF, 
				 0x00, 0x00, 0x00, 0xA0, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 0x24, 
				 0x00, 0x00, 0x00, 0xE3, 0x00, 0x00, 0x00, 0xFF, 
				 0x00, 0x00, 0x00, 0x1D, 0x06, 0x00, 0x64, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x30, 0x00, 0x00, 0x00, 
				 0x22, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x09, 0x00, 0x00, 0x00, 
				 0x13, 0xEA, 0x00, 0x1E, 0x00, 0x00, 0xC0, 0x00, 
				 0x00, 0x1E, 0x01, 0x22, 0x14, 0x00, 0x00, 0x1F, 
				 0x01, 0x00, 0x19, 0xEA, 0x00, 0x12, 0x07, 0x04, 
				 0x1E, 0x00, 0xC0, 0x00, 0x00, 0x00, 0x1E, 0x01, 
				 0x14, 0x00, 0x00, 0x00, 0x18, 0x07, 0x04, 0x13, 
				 0xC4, 0x02, 0x1E, 0x00, 0x3F, 0xC0, 0x00, 0x00, 
				 0x1E, 0x01, 0x80, 0x14, 0x00, 0x00, 0x1F, 0x01, 
				 0x00, 0x19, 0xC4, 0x02, 0x13, 0xEA, 0x00, 0x1E, 
				 0x00, 0xC0, 0xFF, 0x00, 0x00, 0x1E, 0x01, 0x25, 
				 0x00, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 0xEA, 
				 0x00, 0x16, 0x02, 0x04, 0x00, 0x20, 0x13, 0xC0, 
				 0x00, 0x1E, 0x01, 0x00, 0x16, 0x00, 0x00, 0x19, 
				 0xC0, 0x00, 0x17, 0x4C, 0x00, 0x40, 0x00, 0x00, 
				 0x00, 0x17, 0x6C, 0x00, 0x32, 0x00, 0x00, 0x00, 
				 0x13, 0xEA, 0x00, 0x1E, 0x00, 0xFF, 0xC0, 0x00, 
				 0x00, 0x1E, 0x01, 0x00, 0x14, 0x00, 0x00, 0x1F, 
				 0x01, 0x00, 0x19, 0xEA, 0x00, 0x00, 0xEA};

BYTE t5465_Mode_1280x1024x15_5[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x16, 0x05, 0x04, 0x00, 0x00, 0x16, 0xC0, 0x00, 
				 0x00, 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 
				 0x00, 0x1F, 0x01, 0x00, 0x18, 0xC5, 0x02, 0x18, 
				 0x07, 0x04, 0x15, 0xA0, 0x00, 0xFF, 0x00, 0x09, 
				 0xCE, 0x03, 0x06, 0x05, 0x09, 0xCE, 0x03, 0x09, 
				 0x00, 0x09, 0xCE, 0x03, 0x0A, 0x00, 0x09, 0xCE, 
				 0x03, 0x0B, 0x00, 0x16, 0x80, 0x00, 0x2F, 0x00, 
				 0x16, 0x84, 0x00, 0x16, 0x00, 0x16, 0x88, 0x00, 
				 0x79, 0x00, 0x1D, 0x19, 0x00, 0x00, 0x00, 0xD3, 
				 0x00, 0x00, 0x00, 0x9F, 0x00, 0x00, 0x00, 0x9F, 
				 0x00, 0x00, 0x00, 0x91, 0x00, 0x00, 0x00, 0xA7, 
				 0x00, 0x00, 0x00, 0x1B, 0x00, 0x00, 0x00, 0x2E, 
				 0x00, 0x00, 0x00, 0x5A, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x60, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x83, 0x00, 0x00, 0x00, 0xFF, 
				 0x00, 0x00, 0x00, 0xA0, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 0x2A, 
				 0x00, 0x00, 0x00, 0xE3, 0x00, 0x00, 0x00, 0xFF, 
				 0x00, 0x00, 0x00, 0x1D, 0x06, 0x00, 0x64, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x30, 0x00, 0x00, 0x00, 
				 0x22, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x09, 0x00, 0x00, 0x00, 
				 0x13, 0xEA, 0x00, 0x1E, 0x00, 0x00, 0xC0, 0x00, 
				 0x00, 0x1E, 0x01, 0x22, 0x14, 0x00, 0x00, 0x1F, 
				 0x01, 0x00, 0x19, 0xEA, 0x00, 0x12, 0x07, 0x04, 
				 0x1E, 0x00, 0xC0, 0x00, 0x00, 0x00, 0x1E, 0x01, 
				 0x14, 0x00, 0x00, 0x00, 0x18, 0x07, 0x04, 0x13, 
				 0xC4, 0x02, 0x1E, 0x00, 0x3F, 0xC0, 0x00, 0x00, 
				 0x1E, 0x01, 0x80, 0x14, 0x00, 0x00, 0x1F, 0x01, 
				 0x00, 0x19, 0xC4, 0x02, 0x13, 0xEA, 0x00, 0x1E, 
				 0x00, 0xC0, 0xFF, 0x00, 0x00, 0x1E, 0x01, 0x33, 
				 0x00, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 0xEA, 
				 0x00, 0x16, 0x02, 0x04, 0x00, 0x20, 0x13, 0xC0, 
				 0x00, 0x1E, 0x01, 0x00, 0x16, 0x00, 0x00, 0x19, 
				 0xC0, 0x00, 0x17, 0x4C, 0x00, 0x40, 0x00, 0x00, 
				 0x00, 0x17, 0x6C, 0x00, 0x32, 0x00, 0x00, 0x00, 
				 0x13, 0xEA, 0x00, 0x1E, 0x00, 0xFF, 0xC0, 0x00, 
				 0x00, 0x1E, 0x01, 0x00, 0x14, 0x00, 0x00, 0x1F, 
				 0x01, 0x00, 0x19, 0xEA, 0x00, 0x00, 0xEA};

BYTE t5465_Mode_1600x1200x15_1[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x16, 0x05, 0x04, 0x00, 0x00, 0x16, 0xC0, 0x00, 
				 0x00, 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 
				 0x00, 0x1F, 0x01, 0x00, 0x18, 0xC5, 0x02, 0x18, 
				 0x07, 0x04, 0x15, 0xA0, 0x00, 0xFF, 0x00, 0x09, 
				 0xCE, 0x03, 0x06, 0x05, 0x09, 0xCE, 0x03, 0x09, 
				 0x00, 0x09, 0xCE, 0x03, 0x0A, 0x00, 0x09, 0xCE, 
				 0x03, 0x0B, 0x00, 0x16, 0x80, 0x00, 0x2F, 0x00, 
				 0x16, 0x84, 0x00, 0x0E, 0x00, 0x16, 0x88, 0x00, 
				 0x42, 0x00, 0x1D, 0x19, 0x00, 0x00, 0x00, 0x09, 
				 0x00, 0x00, 0x00, 0xC7, 0x00, 0x00, 0x00, 0xC7, 
				 0x00, 0x00, 0x00, 0x8C, 0x00, 0x00, 0x00, 0xCF, 
				 0x00, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00, 0x88, 
				 0x00, 0x00, 0x00, 0xE0, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x60, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x58, 
				 0x00, 0x00, 0x00, 0x8B, 0x00, 0x00, 0x00, 0x57, 
				 0x00, 0x00, 0x00, 0xD0, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x58, 0x00, 0x00, 0x00, 0x85, 
				 0x00, 0x00, 0x00, 0xE3, 0x00, 0x00, 0x00, 0xFF, 
				 0x00, 0x00, 0x00, 0x1D, 0x06, 0x00, 0x64, 0x00, 
				 0x84, 0x00, 0x00, 0x00, 0x81, 0x00, 0x00, 0x00, 
				 0x22, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 
				 0x13, 0xEA, 0x00, 0x1E, 0x00, 0x00, 0xC0, 0x00, 
				 0x00, 0x1E, 0x01, 0x1A, 0x1A, 0x00, 0x00, 0x1F, 
				 0x01, 0x00, 0x19, 0xEA, 0x00, 0x12, 0x07, 0x04, 
				 0x1E, 0x00, 0xC0, 0x00, 0x00, 0x00, 0x1E, 0x01, 
				 0x1A, 0x00, 0x00, 0x00, 0x18, 0x07, 0x04, 0x13, 
				 0xC4, 0x02, 0x1E, 0x00, 0x3F, 0xC0, 0x00, 0x00, 
				 0x1E, 0x01, 0x80, 0x1A, 0x00, 0x00, 0x1F, 0x01, 
				 0x00, 0x19, 0xC4, 0x02, 0x13, 0xEA, 0x00, 0x1E, 
				 0x00, 0xC0, 0xFF, 0x00, 0x00, 0x1E, 0x01, 0x29, 
				 0x00, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 0xEA, 
				 0x00, 0x16, 0x02, 0x04, 0x00, 0x20, 0x13, 0xC0, 
				 0x00, 0x1E, 0x01, 0x00, 0x16, 0x00, 0x00, 0x19, 
				 0xC0, 0x00, 0x17, 0x4C, 0x00, 0xA0, 0x00, 0x00, 
				 0x00, 0x17, 0x6C, 0x00, 0x32, 0x00, 0x00, 0x00, 
				 0x13, 0xEA, 0x00, 0x1E, 0x00, 0xFF, 0xC0, 0x00, 
				 0x00, 0x1E, 0x01, 0x00, 0x19, 0x00, 0x00, 0x1F, 
				 0x01, 0x00, 0x19, 0xEA, 0x00, 0x00, 0xEA};

BYTE t5465_Mode_1600x1200x15_2[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x16, 0x05, 0x04, 0x00, 0x00, 0x16, 0xC0, 0x00, 
				 0x00, 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 
				 0x00, 0x1F, 0x01, 0x00, 0x18, 0xC5, 0x02, 0x18, 
				 0x07, 0x04, 0x15, 0xA0, 0x00, 0xFF, 0x00, 0x09, 
				 0xCE, 0x03, 0x06, 0x05, 0x09, 0xCE, 0x03, 0x09, 
				 0x00, 0x09, 0xCE, 0x03, 0x0A, 0x00, 0x09, 0xCE, 
				 0x03, 0x0B, 0x00, 0x16, 0x80, 0x00, 0x2F, 0x00, 
				 0x16, 0x84, 0x00, 0x14, 0x00, 0x16, 0x88, 0x00, 
				 0x71, 0x00, 0x1D, 0x19, 0x00, 0x00, 0x00, 0x09, 
				 0x00, 0x00, 0x00, 0xC7, 0x00, 0x00, 0x00, 0xC7, 
				 0x00, 0x00, 0x00, 0x89, 0x00, 0x00, 0x00, 0xD1, 
				 0x00, 0x00, 0x00, 0x09, 0x00, 0x00, 0x00, 0xDF, 
				 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xB0, 
				 0x00, 0x00, 0x00, 0x83, 0x00, 0x00, 0x00, 0xAF, 
				 0x00, 0x00, 0x00, 0xD0, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0xAF, 0x00, 0x00, 0x00, 0xDF, 
				 0x00, 0x00, 0x00, 0xE3, 0x00, 0x00, 0x00, 0xFF, 
				 0x00, 0x00, 0x00, 0x1D, 0x06, 0x00, 0x64, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x22, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x8F, 0x00, 0x00, 0x00, 
				 0x13, 0xEA, 0x00, 0x1E, 0x00, 0x00, 0xC0, 0x00, 
				 0x00, 0x1E, 0x01, 0x70, 0x1A, 0x00, 0x00, 0x1F, 
				 0x01, 0x00, 0x19, 0xEA, 0x00, 0x12, 0x07, 0x04, 
				 0x1E, 0x00, 0xC0, 0x00, 0x00, 0x00, 0x1E, 0x01, 
				 0x0D, 0x00, 0x00, 0x00, 0x18, 0x07, 0x04, 0x13, 
				 0xC4, 0x02, 0x1E, 0x00, 0x3F, 0xC0, 0x00, 0x00, 
				 0x1E, 0x01, 0xC0, 0x0D, 0x00, 0x00, 0x1F, 0x01, 
				 0x00, 0x19, 0xC4, 0x02, 0x16, 0x02, 0x04, 0x00, 
				 0x28, 0x13, 0xC0, 0x00, 0x1E, 0x01, 0x00, 0x16, 
				 0x00, 0x00, 0x19, 0xC0, 0x00, 0x17, 0x4C, 0x00, 
				 0xA0, 0x00, 0x00, 0x00, 0x17, 0x6C, 0x00, 0x32, 
				 0x00, 0x00, 0x00, 0x13, 0xEA, 0x00, 0x1E, 0x00, 
				 0xFF, 0xC0, 0x00, 0x00, 0x1E, 0x01, 0x00, 0x19, 
				 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 0xEA, 0x00, 
				 0x00, 0xEA};

BYTE t5465_Mode_1600x1200x15_3[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x16, 0x05, 0x04, 0x00, 0x00, 0x16, 0xC0, 0x00, 
				 0x00, 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 
				 0x00, 0x1F, 0x01, 0x00, 0x18, 0xC5, 0x02, 0x18, 
				 0x07, 0x04, 0x15, 0xA0, 0x00, 0xFF, 0x00, 0x09, 
				 0xCE, 0x03, 0x06, 0x05, 0x09, 0xCE, 0x03, 0x09, 
				 0x00, 0x09, 0xCE, 0x03, 0x0A, 0x00, 0x09, 0xCE, 
				 0x03, 0x0B, 0x00, 0x16, 0x80, 0x00, 0x2F, 0x00, 
				 0x16, 0x84, 0x00, 0x08, 0x00, 0x16, 0x88, 0x00, 
				 0x31, 0x00, 0x1D, 0x19, 0x00, 0x00, 0x00, 0x09, 
				 0x00, 0x00, 0x00, 0xC7, 0x00, 0x00, 0x00, 0xC7, 
				 0x00, 0x00, 0x00, 0x89, 0x00, 0x00, 0x00, 0xD0, 
				 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0xDF, 
				 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xB0, 
				 0x00, 0x00, 0x00, 0x83, 0x00, 0x00, 0x00, 0xAF, 
				 0x00, 0x00, 0x00, 0xD0, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0xAF, 0x00, 0x00, 0x00, 0xDF, 
				 0x00, 0x00, 0x00, 0xE3, 0x00, 0x00, 0x00, 0xFF, 
				 0x00, 0x00, 0x00, 0x1D, 0x06, 0x00, 0x64, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x22, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x8F, 0x00, 0x00, 0x00, 
				 0x13, 0xEA, 0x00, 0x1E, 0x00, 0x00, 0xC0, 0x00, 
				 0x00, 0x1E, 0x01, 0x70, 0x1A, 0x00, 0x00, 0x1F, 
				 0x01, 0x00, 0x19, 0xEA, 0x00, 0x12, 0x07, 0x04, 
				 0x1E, 0x00, 0xC0, 0x00, 0x00, 0x00, 0x1E, 0x01, 
				 0x0D, 0x00, 0x00, 0x00, 0x18, 0x07, 0x04, 0x13, 
				 0xC4, 0x02, 0x1E, 0x00, 0x3F, 0xC0, 0x00, 0x00, 
				 0x1E, 0x01, 0xC0, 0x0D, 0x00, 0x00, 0x1F, 0x01, 
				 0x00, 0x19, 0xC4, 0x02, 0x16, 0x02, 0x04, 0x00, 
				 0x28, 0x13, 0xC0, 0x00, 0x1E, 0x01, 0x00, 0x16, 
				 0x00, 0x00, 0x19, 0xC0, 0x00, 0x17, 0x4C, 0x00, 
				 0xA0, 0x00, 0x00, 0x00, 0x17, 0x6C, 0x00, 0x32, 
				 0x00, 0x00, 0x00, 0x13, 0xEA, 0x00, 0x1E, 0x00, 
				 0xFF, 0xC0, 0x00, 0x00, 0x1E, 0x01, 0x00, 0x19, 
				 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 0xEA, 0x00, 
				 0x00, 0xEA};

BYTE t5465_Mode_1600x1200x15_4[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x16, 0x05, 0x04, 0x00, 0x00, 0x16, 0xC0, 0x00, 
				 0x00, 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 
				 0x00, 0x1F, 0x01, 0x00, 0x18, 0xC5, 0x02, 0x18, 
				 0x07, 0x04, 0x15, 0xA0, 0x00, 0xFF, 0x00, 0x09, 
				 0xCE, 0x03, 0x06, 0x05, 0x09, 0xCE, 0x03, 0x09, 
				 0x00, 0x09, 0xCE, 0x03, 0x0A, 0x00, 0x09, 0xCE, 
				 0x03, 0x0B, 0x00, 0x16, 0x80, 0x00, 0x2F, 0x00, 
				 0x16, 0x84, 0x00, 0x0A, 0x00, 0x16, 0x88, 0x00, 
				 0x42, 0x00, 0x1D, 0x19, 0x00, 0x00, 0x00, 0x09, 
				 0x00, 0x00, 0x00, 0xC7, 0x00, 0x00, 0x00, 0xC7, 
				 0x00, 0x00, 0x00, 0x89, 0x00, 0x00, 0x00, 0xD0, 
				 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0xE0, 
				 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xB0, 
				 0x00, 0x00, 0x00, 0x83, 0x00, 0x00, 0x00, 0xAF, 
				 0x00, 0x00, 0x00, 0xD0, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0xAF, 0x00, 0x00, 0x00, 0xE0, 
				 0x00, 0x00, 0x00, 0xE3, 0x00, 0x00, 0x00, 0xFF, 
				 0x00, 0x00, 0x00, 0x1D, 0x06, 0x00, 0x64, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x22, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x8F, 0x00, 0x00, 0x00, 
				 0x13, 0xEA, 0x00, 0x1E, 0x00, 0x00, 0xC0, 0x00, 
				 0x00, 0x1E, 0x01, 0x75, 0x1A, 0x00, 0x00, 0x1F, 
				 0x01, 0x00, 0x19, 0xEA, 0x00, 0x12, 0x07, 0x04, 
				 0x1E, 0x00, 0xC0, 0x00, 0x00, 0x00, 0x1E, 0x01, 
				 0x0D, 0x00, 0x00, 0x00, 0x18, 0x07, 0x04, 0x13, 
				 0xC4, 0x02, 0x1E, 0x00, 0x3F, 0xC0, 0x00, 0x00, 
				 0x1E, 0x01, 0xC0, 0x0D, 0x00, 0x00, 0x1F, 0x01, 
				 0x00, 0x19, 0xC4, 0x02, 0x16, 0x02, 0x04, 0x00, 
				 0x28, 0x13, 0xC0, 0x00, 0x1E, 0x01, 0x00, 0x16, 
				 0x00, 0x00, 0x19, 0xC0, 0x00, 0x17, 0x4C, 0x00, 
				 0xA0, 0x00, 0x00, 0x00, 0x17, 0x6C, 0x00, 0x32, 
				 0x00, 0x00, 0x00, 0x13, 0xEA, 0x00, 0x1E, 0x00, 
				 0xFF, 0xC0, 0x00, 0x00, 0x1E, 0x01, 0x00, 0x19, 
				 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 0xEA, 0x00, 
				 0x00, 0xEA};

BYTE t5465_Mode_1600x1200x16_1[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x16, 0x05, 0x04, 0x00, 0x00, 0x16, 0xC0, 0x00, 
				 0x00, 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 
				 0x00, 0x1F, 0x01, 0x00, 0x18, 0xC5, 0x02, 0x18, 
				 0x07, 0x04, 0x15, 0xA0, 0x00, 0xFF, 0x00, 0x09, 
				 0xCE, 0x03, 0x06, 0x05, 0x09, 0xCE, 0x03, 0x09, 
				 0x00, 0x09, 0xCE, 0x03, 0x0A, 0x00, 0x09, 0xCE, 
				 0x03, 0x0B, 0x00, 0x16, 0x80, 0x00, 0x2F, 0x00, 
				 0x16, 0x84, 0x00, 0x0E, 0x00, 0x16, 0x88, 0x00, 
				 0x42, 0x00, 0x1D, 0x19, 0x00, 0x00, 0x00, 0x09, 
				 0x00, 0x00, 0x00, 0xC7, 0x00, 0x00, 0x00, 0xC7, 
				 0x00, 0x00, 0x00, 0x8C, 0x00, 0x00, 0x00, 0xCF, 
				 0x00, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00, 0x88, 
				 0x00, 0x00, 0x00, 0xE0, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x60, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x58, 
				 0x00, 0x00, 0x00, 0x8B, 0x00, 0x00, 0x00, 0x57, 
				 0x00, 0x00, 0x00, 0xD0, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x58, 0x00, 0x00, 0x00, 0x85, 
				 0x00, 0x00, 0x00, 0xE3, 0x00, 0x00, 0x00, 0xFF, 
				 0x00, 0x00, 0x00, 0x1D, 0x06, 0x00, 0x64, 0x00, 
				 0x84, 0x00, 0x00, 0x00, 0x81, 0x00, 0x00, 0x00, 
				 0x22, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 
				 0x13, 0xEA, 0x00, 0x1E, 0x00, 0x00, 0xC0, 0x00, 
				 0x00, 0x1E, 0x01, 0x1A, 0x1A, 0x00, 0x00, 0x1F, 
				 0x01, 0x00, 0x19, 0xEA, 0x00, 0x12, 0x07, 0x04, 
				 0x1E, 0x00, 0xC0, 0x00, 0x00, 0x00, 0x1E, 0x01, 
				 0x1A, 0x00, 0x00, 0x00, 0x18, 0x07, 0x04, 0x13, 
				 0xC4, 0x02, 0x1E, 0x00, 0x3F, 0xC0, 0x00, 0x00, 
				 0x1E, 0x01, 0x80, 0x1A, 0x00, 0x00, 0x1F, 0x01, 
				 0x00, 0x19, 0xC4, 0x02, 0x13, 0xEA, 0x00, 0x1E, 
				 0x00, 0xC0, 0xFF, 0x00, 0x00, 0x1E, 0x01, 0x29, 
				 0x00, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 0xEA, 
				 0x00, 0x16, 0x02, 0x04, 0x00, 0x20, 0x13, 0xC0, 
				 0x00, 0x1E, 0x01, 0x00, 0x16, 0x00, 0x00, 0x19, 
				 0xC0, 0x00, 0x17, 0x4C, 0x00, 0xA0, 0x00, 0x00, 
				 0x00, 0x17, 0x6C, 0x00, 0x32, 0x00, 0x00, 0x00, 
				 0x13, 0xEA, 0x00, 0x1E, 0x00, 0xFF, 0xC0, 0x00, 
				 0x00, 0x1E, 0x01, 0x00, 0x19, 0x00, 0x00, 0x1F, 
				 0x01, 0x00, 0x19, 0xEA, 0x00, 0x13, 0xC0, 0x00, 
				 0x1E, 0x00, 0x00, 0xC0, 0x00, 0x00, 0x1E, 0x01, 
				 0x00, 0x14, 0x00, 0x00, 0x19, 0xC0, 0x00, 0x13, 
				 0xEA, 0x00, 0x1E, 0x00, 0xFF, 0xC0, 0x00, 0x00, 
				 0x1E, 0x01, 0x00, 0x19, 0x00, 0x00, 0x1F, 0x01, 
				 0x00, 0x19, 0xEA, 0x00, 0x00, 0xEA};

BYTE t5465_Mode_1600x1200x16_2[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x16, 0x05, 0x04, 0x00, 0x00, 0x16, 0xC0, 0x00, 
				 0x00, 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 
				 0x00, 0x1F, 0x01, 0x00, 0x18, 0xC5, 0x02, 0x18, 
				 0x07, 0x04, 0x15, 0xA0, 0x00, 0xFF, 0x00, 0x09, 
				 0xCE, 0x03, 0x06, 0x05, 0x09, 0xCE, 0x03, 0x09, 
				 0x00, 0x09, 0xCE, 0x03, 0x0A, 0x00, 0x09, 0xCE, 
				 0x03, 0x0B, 0x00, 0x16, 0x80, 0x00, 0x2F, 0x00, 
				 0x16, 0x84, 0x00, 0x14, 0x00, 0x16, 0x88, 0x00, 
				 0x71, 0x00, 0x1D, 0x19, 0x00, 0x00, 0x00, 0x09, 
				 0x00, 0x00, 0x00, 0xC7, 0x00, 0x00, 0x00, 0xC7, 
				 0x00, 0x00, 0x00, 0x89, 0x00, 0x00, 0x00, 0xD1, 
				 0x00, 0x00, 0x00, 0x09, 0x00, 0x00, 0x00, 0xDF, 
				 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xB0, 
				 0x00, 0x00, 0x00, 0x83, 0x00, 0x00, 0x00, 0xAF, 
				 0x00, 0x00, 0x00, 0xD0, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0xAF, 0x00, 0x00, 0x00, 0xDF, 
				 0x00, 0x00, 0x00, 0xE3, 0x00, 0x00, 0x00, 0xFF, 
				 0x00, 0x00, 0x00, 0x1D, 0x06, 0x00, 0x64, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x22, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x8F, 0x00, 0x00, 0x00, 
				 0x13, 0xEA, 0x00, 0x1E, 0x00, 0x00, 0xC0, 0x00, 
				 0x00, 0x1E, 0x01, 0x70, 0x1A, 0x00, 0x00, 0x1F, 
				 0x01, 0x00, 0x19, 0xEA, 0x00, 0x12, 0x07, 0x04, 
				 0x1E, 0x00, 0xC0, 0x00, 0x00, 0x00, 0x1E, 0x01, 
				 0x0D, 0x00, 0x00, 0x00, 0x18, 0x07, 0x04, 0x13, 
				 0xC4, 0x02, 0x1E, 0x00, 0x3F, 0xC0, 0x00, 0x00, 
				 0x1E, 0x01, 0xC0, 0x0D, 0x00, 0x00, 0x1F, 0x01, 
				 0x00, 0x19, 0xC4, 0x02, 0x16, 0x02, 0x04, 0x00, 
				 0x28, 0x13, 0xC0, 0x00, 0x1E, 0x01, 0x00, 0x16, 
				 0x00, 0x00, 0x19, 0xC0, 0x00, 0x17, 0x4C, 0x00, 
				 0xA0, 0x00, 0x00, 0x00, 0x17, 0x6C, 0x00, 0x32, 
				 0x00, 0x00, 0x00, 0x13, 0xEA, 0x00, 0x1E, 0x00, 
				 0xFF, 0xC0, 0x00, 0x00, 0x1E, 0x01, 0x00, 0x19, 
				 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 0xEA, 0x00, 
				 0x13, 0xC0, 0x00, 0x1E, 0x00, 0x00, 0xC0, 0x00, 
				 0x00, 0x1E, 0x01, 0x00, 0x14, 0x00, 0x00, 0x19, 
				 0xC0, 0x00, 0x13, 0xEA, 0x00, 0x1E, 0x00, 0xFF, 
				 0xC0, 0x00, 0x00, 0x1E, 0x01, 0x00, 0x19, 0x00, 
				 0x00, 0x1F, 0x01, 0x00, 0x19, 0xEA, 0x00, 0x00, 0xEA};

BYTE t5465_Mode_1600x1200x16_3[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x16, 0x05, 0x04, 0x00, 0x00, 0x16, 0xC0, 0x00, 
				 0x00, 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 
				 0x00, 0x1F, 0x01, 0x00, 0x18, 0xC5, 0x02, 0x18, 
				 0x07, 0x04, 0x15, 0xA0, 0x00, 0xFF, 0x00, 0x09, 
				 0xCE, 0x03, 0x06, 0x05, 0x09, 0xCE, 0x03, 0x09, 
				 0x00, 0x09, 0xCE, 0x03, 0x0A, 0x00, 0x09, 0xCE, 
				 0x03, 0x0B, 0x00, 0x16, 0x80, 0x00, 0x2F, 0x00, 
				 0x16, 0x84, 0x00, 0x08, 0x00, 0x16, 0x88, 0x00, 
				 0x31, 0x00, 0x1D, 0x19, 0x00, 0x00, 0x00, 0x09, 
				 0x00, 0x00, 0x00, 0xC7, 0x00, 0x00, 0x00, 0xC7, 
				 0x00, 0x00, 0x00, 0x89, 0x00, 0x00, 0x00, 0xD0, 
				 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0xDF, 
				 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xB0, 
				 0x00, 0x00, 0x00, 0x83, 0x00, 0x00, 0x00, 0xAF, 
				 0x00, 0x00, 0x00, 0xD0, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0xAF, 0x00, 0x00, 0x00, 0xDF, 
				 0x00, 0x00, 0x00, 0xE3, 0x00, 0x00, 0x00, 0xFF, 
				 0x00, 0x00, 0x00, 0x1D, 0x06, 0x00, 0x64, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x22, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x8F, 0x00, 0x00, 0x00, 
				 0x13, 0xEA, 0x00, 0x1E, 0x00, 0x00, 0xC0, 0x00, 
				 0x00, 0x1E, 0x01, 0x70, 0x1A, 0x00, 0x00, 0x1F, 
				 0x01, 0x00, 0x19, 0xEA, 0x00, 0x12, 0x07, 0x04, 
				 0x1E, 0x00, 0xC0, 0x00, 0x00, 0x00, 0x1E, 0x01, 
				 0x0D, 0x00, 0x00, 0x00, 0x18, 0x07, 0x04, 0x13, 
				 0xC4, 0x02, 0x1E, 0x00, 0x3F, 0xC0, 0x00, 0x00, 
				 0x1E, 0x01, 0xC0, 0x0D, 0x00, 0x00, 0x1F, 0x01, 
				 0x00, 0x19, 0xC4, 0x02, 0x16, 0x02, 0x04, 0x00, 
				 0x28, 0x13, 0xC0, 0x00, 0x1E, 0x01, 0x00, 0x16, 
				 0x00, 0x00, 0x19, 0xC0, 0x00, 0x17, 0x4C, 0x00, 
				 0xA0, 0x00, 0x00, 0x00, 0x17, 0x6C, 0x00, 0x32, 
				 0x00, 0x00, 0x00, 0x13, 0xEA, 0x00, 0x1E, 0x00, 
				 0xFF, 0xC0, 0x00, 0x00, 0x1E, 0x01, 0x00, 0x19, 
				 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 0xEA, 0x00, 
				 0x13, 0xC0, 0x00, 0x1E, 0x00, 0x00, 0xC0, 0x00, 
				 0x00, 0x1E, 0x01, 0x00, 0x14, 0x00, 0x00, 0x19, 
				 0xC0, 0x00, 0x13, 0xEA, 0x00, 0x1E, 0x00, 0xFF, 
				 0xC0, 0x00, 0x00, 0x1E, 0x01, 0x00, 0x19, 0x00, 
				 0x00, 0x1F, 0x01, 0x00, 0x19, 0xEA, 0x00, 0x00, 0xEA};

BYTE t5465_Mode_1600x1200x16_4[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x16, 0x05, 0x04, 0x00, 0x00, 0x16, 0xC0, 0x00, 
				 0x00, 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 
				 0x00, 0x1F, 0x01, 0x00, 0x18, 0xC5, 0x02, 0x18, 
				 0x07, 0x04, 0x15, 0xA0, 0x00, 0xFF, 0x00, 0x09, 
				 0xCE, 0x03, 0x06, 0x05, 0x09, 0xCE, 0x03, 0x09, 
				 0x00, 0x09, 0xCE, 0x03, 0x0A, 0x00, 0x09, 0xCE, 
				 0x03, 0x0B, 0x00, 0x16, 0x80, 0x00, 0x2F, 0x00, 
				 0x16, 0x84, 0x00, 0x0A, 0x00, 0x16, 0x88, 0x00, 
				 0x42, 0x00, 0x1D, 0x19, 0x00, 0x00, 0x00, 0x09, 
				 0x00, 0x00, 0x00, 0xC7, 0x00, 0x00, 0x00, 0xC7, 
				 0x00, 0x00, 0x00, 0x89, 0x00, 0x00, 0x00, 0xD0, 
				 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0xE0, 
				 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xB0, 
				 0x00, 0x00, 0x00, 0x83, 0x00, 0x00, 0x00, 0xAF, 
				 0x00, 0x00, 0x00, 0xD0, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0xAF, 0x00, 0x00, 0x00, 0xE0, 
				 0x00, 0x00, 0x00, 0xE3, 0x00, 0x00, 0x00, 0xFF, 
				 0x00, 0x00, 0x00, 0x1D, 0x06, 0x00, 0x64, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x22, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x8F, 0x00, 0x00, 0x00, 
				 0x13, 0xEA, 0x00, 0x1E, 0x00, 0x00, 0xC0, 0x00, 
				 0x00, 0x1E, 0x01, 0x75, 0x1A, 0x00, 0x00, 0x1F, 
				 0x01, 0x00, 0x19, 0xEA, 0x00, 0x12, 0x07, 0x04, 
				 0x1E, 0x00, 0xC0, 0x00, 0x00, 0x00, 0x1E, 0x01, 
				 0x0D, 0x00, 0x00, 0x00, 0x18, 0x07, 0x04, 0x13, 
				 0xC4, 0x02, 0x1E, 0x00, 0x3F, 0xC0, 0x00, 0x00, 
				 0x1E, 0x01, 0xC0, 0x0D, 0x00, 0x00, 0x1F, 0x01, 
				 0x00, 0x19, 0xC4, 0x02, 0x16, 0x02, 0x04, 0x00, 
				 0x28, 0x13, 0xC0, 0x00, 0x1E, 0x01, 0x00, 0x16, 
				 0x00, 0x00, 0x19, 0xC0, 0x00, 0x17, 0x4C, 0x00, 
				 0xA0, 0x00, 0x00, 0x00, 0x17, 0x6C, 0x00, 0x32, 
				 0x00, 0x00, 0x00, 0x13, 0xEA, 0x00, 0x1E, 0x00, 
				 0xFF, 0xC0, 0x00, 0x00, 0x1E, 0x01, 0x00, 0x19, 
				 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 0xEA, 0x00, 
				 0x13, 0xC0, 0x00, 0x1E, 0x00, 0x00, 0xC0, 0x00, 
				 0x00, 0x1E, 0x01, 0x00, 0x14, 0x00, 0x00, 0x19, 
				 0xC0, 0x00, 0x13, 0xEA, 0x00, 0x1E, 0x00, 0xFF, 
				 0xC0, 0x00, 0x00, 0x1E, 0x01, 0x00, 0x19, 0x00, 
				 0x00, 0x1F, 0x01, 0x00, 0x19, 0xEA, 0x00, 0x00, 0xEA};

BYTE t5465_Mode_320x200x32_1[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x16, 0x05, 0x04, 0x00, 0x00, 0x16, 0xC0, 0x00, 
				 0x00, 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 
				 0x00, 0x1F, 0x01, 0x00, 0x18, 0xC5, 0x02, 0x18, 
				 0x07, 0x04, 0x15, 0xA0, 0x00, 0xFF, 0x00, 0x09, 
				 0xCE, 0x03, 0x06, 0x05, 0x09, 0xCE, 0x03, 0x09, 
				 0x00, 0x09, 0xCE, 0x03, 0x0A, 0x00, 0x09, 0xCE, 
				 0x03, 0x0B, 0x00, 0x16, 0x80, 0x00, 0x2F, 0x00, 
				 0x16, 0x84, 0x00, 0x42, 0x00, 0x16, 0x88, 0x00, 
				 0x74, 0x00, 0x16, 0xC0, 0x00, 0x00, 0x80, 0x1D, 
				 0x19, 0x00, 0x00, 0x00, 0x2D, 0x00, 0x00, 0x00, 
				 0x27, 0x00, 0x00, 0x00, 0x28, 0x00, 0x00, 0x00, 
				 0x8D, 0x00, 0x00, 0x00, 0x2A, 0x00, 0x00, 0x00, 
				 0x8B, 0x00, 0x00, 0x00, 0xA0, 0x00, 0x00, 0x00, 
				 0x1F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0xC0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x91, 0x00, 0x00, 0x00, 
				 0x84, 0x00, 0x00, 0x00, 0x8F, 0x00, 0x00, 0x00, 
				 0x50, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x90, 0x00, 0x00, 0x00, 0xA0, 0x00, 0x00, 0x00, 
				 0xE3, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 
				 0x1D, 0x06, 0x00, 0x64, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x40, 0x00, 0x00, 0x00, 0x22, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x13, 0xEA, 0x00, 
				 0x1E, 0x00, 0x00, 0xC0, 0x00, 0x00, 0x1E, 0x01, 
				 0x11, 0x0A, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 
				 0xEA, 0x00, 0x12, 0x07, 0x04, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x0A, 0x00, 0x00, 
				 0x00, 0x18, 0x07, 0x04, 0x13, 0xC4, 0x02, 0x1E, 
				 0x00, 0x3F, 0xC0, 0x00, 0x00, 0x1E, 0x01, 0x80, 
				 0x0A, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 0xC4, 
				 0x02, 0x13, 0xEA, 0x00, 0x1E, 0x00, 0xC0, 0xFF, 
				 0x00, 0x00, 0x1E, 0x01, 0x12, 0x00, 0x00, 0x00, 
				 0x1F, 0x01, 0x00, 0x19, 0xEA, 0x00, 0x16, 0x02, 
				 0x04, 0x00, 0x60, 0x13, 0xC0, 0x00, 0x1E, 0x01, 
				 0x00, 0x34, 0x00, 0x00, 0x19, 0xC0, 0x00, 0x17, 
				 0x4C, 0x00, 0xA0, 0x00, 0x00, 0x00, 0x13, 0xEA, 
				 0x00, 0x1E, 0x00, 0xFF, 0xC0, 0x00, 0x00, 0x1E, 
				 0x01, 0x00, 0x0A, 0x00, 0x00, 0x1F, 0x01, 0x00, 
				 0x19, 0xEA, 0x00, 0x00, 0x00};

BYTE t5465_Mode_320x240x32_1[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x16, 0x05, 0x04, 0x00, 0x00, 0x16, 0xC0, 0x00, 
				 0x00, 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 
				 0x00, 0x1F, 0x01, 0x00, 0x18, 0xC5, 0x02, 0x18, 
				 0x07, 0x04, 0x15, 0xA0, 0x00, 0xFF, 0x00, 0x09, 
				 0xCE, 0x03, 0x06, 0x05, 0x09, 0xCE, 0x03, 0x09, 
				 0x00, 0x09, 0xCE, 0x03, 0x0A, 0x00, 0x09, 0xCE, 
				 0x03, 0x0B, 0x00, 0x16, 0x80, 0x00, 0xEF, 0x00, 
				 0x16, 0x84, 0x00, 0x42, 0x00, 0x16, 0x88, 0x00, 
				 0x74, 0x00, 0x16, 0xC0, 0x00, 0x00, 0x80, 0x1D, 
				 0x19, 0x00, 0x00, 0x00, 0x2D, 0x00, 0x00, 0x00, 
				 0x27, 0x00, 0x00, 0x00, 0x27, 0x00, 0x00, 0x00, 
				 0x8C, 0x00, 0x00, 0x00, 0x2A, 0x00, 0x00, 0x00, 
				 0x8B, 0x00, 0x00, 0x00, 0x0B, 0x00, 0x00, 0x00, 
				 0x3E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0xC0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0xE1, 0x00, 0x00, 0x00, 
				 0x83, 0x00, 0x00, 0x00, 0xDF, 0x00, 0x00, 0x00, 
				 0x50, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0xDF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0xE3, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 
				 0x1D, 0x06, 0x00, 0x64, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x80, 0x00, 0x00, 0x00, 0x22, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x13, 0xEA, 0x00, 
				 0x1E, 0x00, 0x00, 0xC0, 0x00, 0x00, 0x1E, 0x01, 
				 0x11, 0x0A, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 
				 0xEA, 0x00, 0x12, 0x07, 0x04, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x0A, 0x00, 0x00, 
				 0x00, 0x18, 0x07, 0x04, 0x13, 0xC4, 0x02, 0x1E, 
				 0x00, 0x3F, 0xC0, 0x00, 0x00, 0x1E, 0x01, 0x80, 
				 0x0A, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 0xC4, 
				 0x02, 0x13, 0xEA, 0x00, 0x1E, 0x00, 0xC0, 0xFF, 
				 0x00, 0x00, 0x1E, 0x01, 0x12, 0x00, 0x00, 0x00, 
				 0x1F, 0x01, 0x00, 0x19, 0xEA, 0x00, 0x16, 0x02, 
				 0x04, 0x00, 0x60, 0x13, 0xC0, 0x00, 0x1E, 0x01, 
				 0x00, 0x34, 0x00, 0x00, 0x19, 0xC0, 0x00, 0x17, 
				 0x4C, 0x00, 0xA0, 0x00, 0x00, 0x00, 0x13, 0xEA, 
				 0x00, 0x1E, 0x00, 0xFF, 0xC0, 0x00, 0x00, 0x1E, 
				 0x01, 0x00, 0x0A, 0x00, 0x00, 0x1F, 0x01, 0x00, 
				 0x19, 0xEA, 0x00, 0x00, 0x00};

BYTE t5465_Mode_320x240x32_2[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x16, 0x05, 0x04, 0x00, 0x00, 0x16, 0xC0, 0x00, 
				 0x00, 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 
				 0x00, 0x1F, 0x01, 0x00, 0x18, 0xC5, 0x02, 0x18, 
				 0x07, 0x04, 0x15, 0xA0, 0x00, 0xFF, 0x00, 0x09, 
				 0xCE, 0x03, 0x06, 0x05, 0x09, 0xCE, 0x03, 0x09, 
				 0x00, 0x09, 0xCE, 0x03, 0x0A, 0x00, 0x09, 0xCE, 
				 0x03, 0x0B, 0x00, 0x16, 0x80, 0x00, 0xEF, 0x00, 
				 0x16, 0x84, 0x00, 0x0A, 0x00, 0x16, 0x88, 0x00, 
				 0x16, 0x00, 0x16, 0xC0, 0x00, 0x00, 0x80, 0x1D, 
				 0x19, 0x00, 0x00, 0x00, 0x2F, 0x00, 0x00, 0x00, 
				 0x27, 0x00, 0x00, 0x00, 0x27, 0x00, 0x00, 0x00, 
				 0x8C, 0x00, 0x00, 0x00, 0x2A, 0x00, 0x00, 0x00, 
				 0x8B, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 
				 0x3E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0xC0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0xE0, 0x00, 0x00, 0x00, 
				 0x83, 0x00, 0x00, 0x00, 0xDF, 0x00, 0x00, 0x00, 
				 0x50, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0xDF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0xE3, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 
				 0x1D, 0x06, 0x00, 0x64, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x80, 0x00, 0x00, 0x00, 0x22, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x13, 0xEA, 0x00, 
				 0x1E, 0x00, 0x00, 0xC0, 0x00, 0x00, 0x1E, 0x01, 
				 0x11, 0x0A, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 
				 0xEA, 0x00, 0x12, 0x07, 0x04, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x0A, 0x00, 0x00, 
				 0x00, 0x18, 0x07, 0x04, 0x13, 0xC4, 0x02, 0x1E, 
				 0x00, 0x3F, 0xC0, 0x00, 0x00, 0x1E, 0x01, 0x80, 
				 0x0A, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 0xC4, 
				 0x02, 0x13, 0xEA, 0x00, 0x1E, 0x00, 0xC0, 0xFF, 
				 0x00, 0x00, 0x1E, 0x01, 0x12, 0x00, 0x00, 0x00, 
				 0x1F, 0x01, 0x00, 0x19, 0xEA, 0x00, 0x16, 0x02, 
				 0x04, 0x00, 0x60, 0x13, 0xC0, 0x00, 0x1E, 0x01, 
				 0x00, 0x34, 0x00, 0x00, 0x19, 0xC0, 0x00, 0x17, 
				 0x4C, 0x00, 0xA0, 0x00, 0x00, 0x00, 0x13, 0xEA, 
				 0x00, 0x1E, 0x00, 0xFF, 0xC0, 0x00, 0x00, 0x1E, 
				 0x01, 0x00, 0x0A, 0x00, 0x00, 0x1F, 0x01, 0x00, 
				 0x19, 0xEA, 0x00, 0x00, 0x00};

BYTE t5465_Mode_320x400x32_1[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x16, 0x05, 0x04, 0x00, 0x00, 0x16, 0xC0, 0x00, 
				 0x00, 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 
				 0x00, 0x1F, 0x01, 0x00, 0x18, 0xC5, 0x02, 0x18, 
				 0x07, 0x04, 0x15, 0xA0, 0x00, 0xFF, 0x00, 0x09, 
				 0xCE, 0x03, 0x06, 0x05, 0x09, 0xCE, 0x03, 0x09, 
				 0x00, 0x09, 0xCE, 0x03, 0x0A, 0x00, 0x09, 0xCE, 
				 0x03, 0x0B, 0x00, 0x16, 0x80, 0x00, 0x2F, 0x00, 
				 0x16, 0x84, 0x00, 0x42, 0x00, 0x16, 0x88, 0x00, 
				 0x74, 0x00, 0x16, 0xC0, 0x00, 0x00, 0x80, 0x1D, 
				 0x19, 0x00, 0x00, 0x00, 0x2D, 0x00, 0x00, 0x00, 
				 0x27, 0x00, 0x00, 0x00, 0x28, 0x00, 0x00, 0x00, 
				 0x8D, 0x00, 0x00, 0x00, 0x2A, 0x00, 0x00, 0x00, 
				 0x8B, 0x00, 0x00, 0x00, 0xA0, 0x00, 0x00, 0x00, 
				 0x1F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x91, 0x00, 0x00, 0x00, 
				 0x84, 0x00, 0x00, 0x00, 0x8F, 0x00, 0x00, 0x00, 
				 0x50, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x90, 0x00, 0x00, 0x00, 0xA0, 0x00, 0x00, 0x00, 
				 0xE3, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 
				 0x1D, 0x06, 0x00, 0x64, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x40, 0x00, 0x00, 0x00, 0x22, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x13, 0xEA, 0x00, 
				 0x1E, 0x00, 0x00, 0xC0, 0x00, 0x00, 0x1E, 0x01, 
				 0x11, 0x0A, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 
				 0xEA, 0x00, 0x12, 0x07, 0x04, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x0A, 0x00, 0x00, 
				 0x00, 0x18, 0x07, 0x04, 0x13, 0xC4, 0x02, 0x1E, 
				 0x00, 0x3F, 0xC0, 0x00, 0x00, 0x1E, 0x01, 0x80, 
				 0x0A, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 0xC4, 
				 0x02, 0x13, 0xEA, 0x00, 0x1E, 0x00, 0xC0, 0xFF, 
				 0x00, 0x00, 0x1E, 0x01, 0x19, 0x00, 0x00, 0x00, 
				 0x1F, 0x01, 0x00, 0x19, 0xEA, 0x00, 0x16, 0x02, 
				 0x04, 0x00, 0x60, 0x13, 0xC0, 0x00, 0x1E, 0x01, 
				 0x00, 0x34, 0x00, 0x00, 0x19, 0xC0, 0x00, 0x17, 
				 0x4C, 0x00, 0xA0, 0x00, 0x00, 0x00, 0x13, 0xEA, 
				 0x00, 0x1E, 0x00, 0xFF, 0xC0, 0x00, 0x00, 0x1E, 
				 0x01, 0x00, 0x0A, 0x00, 0x00, 0x1F, 0x01, 0x00, 
				 0x19, 0xEA, 0x00, 0x00, 0x00};

BYTE t5465_Mode_320x480x32_1[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x16, 0x05, 0x04, 0x00, 0x00, 0x16, 0xC0, 0x00, 
				 0x00, 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 
				 0x00, 0x1F, 0x01, 0x00, 0x18, 0xC5, 0x02, 0x18, 
				 0x07, 0x04, 0x15, 0xA0, 0x00, 0xFF, 0x00, 0x09, 
				 0xCE, 0x03, 0x06, 0x05, 0x09, 0xCE, 0x03, 0x09, 
				 0x00, 0x09, 0xCE, 0x03, 0x0A, 0x00, 0x09, 0xCE, 
				 0x03, 0x0B, 0x00, 0x16, 0x80, 0x00, 0xEF, 0x00, 
				 0x16, 0x84, 0x00, 0x42, 0x00, 0x16, 0x88, 0x00, 
				 0x74, 0x00, 0x16, 0xC0, 0x00, 0x00, 0x80, 0x1D, 
				 0x19, 0x00, 0x00, 0x00, 0x2D, 0x00, 0x00, 0x00, 
				 0x27, 0x00, 0x00, 0x00, 0x27, 0x00, 0x00, 0x00, 
				 0x8C, 0x00, 0x00, 0x00, 0x2A, 0x00, 0x00, 0x00, 
				 0x8B, 0x00, 0x00, 0x00, 0x0B, 0x00, 0x00, 0x00, 
				 0x3E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0xC0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0xE1, 0x00, 0x00, 0x00, 
				 0x83, 0x00, 0x00, 0x00, 0xDF, 0x00, 0x00, 0x00, 
				 0x50, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0xDF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0xE3, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 
				 0x1D, 0x06, 0x00, 0x64, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x80, 0x00, 0x00, 0x00, 0x22, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x17, 0x24, 0x00, 
				 0x40, 0x00, 0x00, 0x00, 0x13, 0xEA, 0x00, 0x1E, 
				 0x00, 0xFF, 0xC0, 0x00, 0x00, 0x1E, 0x01, 0x00, 
				 0x03, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 0xEA, 
				 0x00, 0x13, 0xEA, 0x00, 0x1E, 0x00, 0x00, 0xC0, 
				 0x00, 0x00, 0x1E, 0x01, 0x11, 0x0A, 0x00, 0x00, 
				 0x1F, 0x01, 0x00, 0x19, 0xEA, 0x00, 0x12, 0x07, 
				 0x04, 0x1E, 0x00, 0xC0, 0x00, 0x00, 0x00, 0x1E, 
				 0x01, 0x0A, 0x00, 0x00, 0x00, 0x18, 0x07, 0x04, 
				 0x13, 0xC4, 0x02, 0x1E, 0x00, 0x3F, 0xC0, 0x00, 
				 0x00, 0x1E, 0x01, 0x80, 0x0A, 0x00, 0x00, 0x1F, 
				 0x01, 0x00, 0x19, 0xC4, 0x02, 0x13, 0xEA, 0x00, 
				 0x1E, 0x00, 0xC0, 0xFF, 0x00, 0x00, 0x1E, 0x01, 
				 0x13, 0x00, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 
				 0xEA, 0x00, 0x16, 0x02, 0x04, 0x00, 0x60, 0x13, 
				 0xC0, 0x00, 0x1E, 0x01, 0x00, 0x34, 0x00, 0x00, 
				 0x19, 0xC0, 0x00, 0x17, 0x4C, 0x00, 0xA0, 0x00, 
				 0x00, 0x00, 0x13, 0xEA, 0x00, 0x1E, 0x00, 0xFF, 
				 0xC0, 0x00, 0x00, 0x1E, 0x01, 0x00, 0x0A, 0x00, 
				 0x00, 0x1F, 0x01, 0x00, 0x19, 0xEA, 0x00, 0x00, 0x1E};

BYTE t5465_Mode_320x480x32_2[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x16, 0x05, 0x04, 0x00, 0x00, 0x16, 0xC0, 0x00, 
				 0x00, 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 
				 0x00, 0x1F, 0x01, 0x00, 0x18, 0xC5, 0x02, 0x18, 
				 0x07, 0x04, 0x15, 0xA0, 0x00, 0xFF, 0x00, 0x09, 
				 0xCE, 0x03, 0x06, 0x05, 0x09, 0xCE, 0x03, 0x09, 
				 0x00, 0x09, 0xCE, 0x03, 0x0A, 0x00, 0x09, 0xCE, 
				 0x03, 0x0B, 0x00, 0x16, 0x80, 0x00, 0xEF, 0x00, 
				 0x16, 0x84, 0x00, 0x0A, 0x00, 0x16, 0x88, 0x00, 
				 0x16, 0x00, 0x16, 0xC0, 0x00, 0x00, 0x80, 0x1D, 
				 0x19, 0x00, 0x00, 0x00, 0x2F, 0x00, 0x00, 0x00, 
				 0x27, 0x00, 0x00, 0x00, 0x27, 0x00, 0x00, 0x00, 
				 0x8C, 0x00, 0x00, 0x00, 0x2A, 0x00, 0x00, 0x00, 
				 0x8B, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 
				 0x3E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0xC0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0xE0, 0x00, 0x00, 0x00, 
				 0x83, 0x00, 0x00, 0x00, 0xDF, 0x00, 0x00, 0x00, 
				 0x50, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0xDF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0xE3, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 
				 0x1D, 0x06, 0x00, 0x64, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x80, 0x00, 0x00, 0x00, 0x22, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x17, 0x24, 0x00, 
				 0x40, 0x00, 0x00, 0x00, 0x13, 0xEA, 0x00, 0x1E, 
				 0x00, 0xFF, 0xC0, 0x00, 0x00, 0x1E, 0x01, 0x00, 
				 0x03, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 0xEA, 
				 0x00, 0x13, 0xEA, 0x00, 0x1E, 0x00, 0x00, 0xC0, 
				 0x00, 0x00, 0x1E, 0x01, 0x11, 0x0A, 0x00, 0x00, 
				 0x1F, 0x01, 0x00, 0x19, 0xEA, 0x00, 0x12, 0x07, 
				 0x04, 0x1E, 0x00, 0xC0, 0x00, 0x00, 0x00, 0x1E, 
				 0x01, 0x0A, 0x00, 0x00, 0x00, 0x18, 0x07, 0x04, 
				 0x13, 0xC4, 0x02, 0x1E, 0x00, 0x3F, 0xC0, 0x00, 
				 0x00, 0x1E, 0x01, 0x80, 0x0A, 0x00, 0x00, 0x1F, 
				 0x01, 0x00, 0x19, 0xC4, 0x02, 0x13, 0xEA, 0x00, 
				 0x1E, 0x00, 0xC0, 0xFF, 0x00, 0x00, 0x1E, 0x01, 
				 0x13, 0x00, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 
				 0xEA, 0x00, 0x16, 0x02, 0x04, 0x00, 0x60, 0x13, 
				 0xC0, 0x00, 0x1E, 0x01, 0x00, 0x34, 0x00, 0x00, 
				 0x19, 0xC0, 0x00, 0x17, 0x4C, 0x00, 0xA0, 0x00, 
				 0x00, 0x00, 0x13, 0xEA, 0x00, 0x1E, 0x00, 0xFF, 
				 0xC0, 0x00, 0x00, 0x1E, 0x01, 0x00, 0x0A, 0x00, 
				 0x00, 0x1F, 0x01, 0x00, 0x19, 0xEA, 0x00, 0x00, 0x1E};

BYTE t5465_Mode_360x400x32_1[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x16, 0x05, 0x04, 0x00, 0x00, 0x16, 0xC0, 0x00, 
				 0x00, 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 
				 0x00, 0x1F, 0x01, 0x00, 0x18, 0xC5, 0x02, 0x18, 
				 0x07, 0x04, 0x15, 0xA0, 0x00, 0xFF, 0x00, 0x09, 
				 0xCE, 0x03, 0x06, 0x05, 0x09, 0xCE, 0x03, 0x09, 
				 0x00, 0x09, 0xCE, 0x03, 0x0A, 0x00, 0x09, 0xCE, 
				 0x03, 0x0B, 0x00, 0x16, 0x80, 0x00, 0x2F, 0x00, 
				 0x16, 0x84, 0x00, 0x04, 0x00, 0x16, 0x88, 0x00, 
				 0x08, 0x00, 0x16, 0xC0, 0x00, 0x00, 0x80, 0x1D, 
				 0x19, 0x00, 0x00, 0x00, 0x34, 0x00, 0x00, 0x00, 
				 0x2C, 0x00, 0x00, 0x00, 0x2D, 0x00, 0x00, 0x00, 
				 0x94, 0x00, 0x00, 0x00, 0x2F, 0x00, 0x00, 0x00, 
				 0x92, 0x00, 0x00, 0x00, 0xA0, 0x00, 0x00, 0x00, 
				 0x1F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x91, 0x00, 0x00, 0x00, 
				 0x84, 0x00, 0x00, 0x00, 0x8F, 0x00, 0x00, 0x00, 
				 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x90, 0x00, 0x00, 0x00, 0xA0, 0x00, 0x00, 0x00, 
				 0xE3, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 
				 0x1D, 0x06, 0x00, 0x64, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x40, 0x00, 0x00, 0x00, 0x22, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x13, 0xEA, 0x00, 
				 0x1E, 0x00, 0x00, 0xC0, 0x00, 0x00, 0x1E, 0x01, 
				 0x12, 0x0D, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 
				 0xEA, 0x00, 0x12, 0x07, 0x04, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x0D, 0x00, 0x00, 
				 0x00, 0x18, 0x07, 0x04, 0x13, 0xC4, 0x02, 0x1E, 
				 0x00, 0x3F, 0xC0, 0x00, 0x00, 0x1E, 0x01, 0x80, 
				 0x0D, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 0xC4, 
				 0x02, 0x13, 0xEA, 0x00, 0x1E, 0x00, 0xC0, 0xFF, 
				 0x00, 0x00, 0x1E, 0x01, 0x1A, 0x00, 0x00, 0x00, 
				 0x1F, 0x01, 0x00, 0x19, 0xEA, 0x00, 0x16, 0x02, 
				 0x04, 0x00, 0x60, 0x13, 0xC0, 0x00, 0x1E, 0x01, 
				 0x00, 0x34, 0x00, 0x00, 0x19, 0xC0, 0x00, 0x17, 
				 0x4C, 0x00, 0xD0, 0x00, 0x00, 0x00, 0x13, 0xEA, 
				 0x00, 0x1E, 0x00, 0xFF, 0xC0, 0x00, 0x00, 0x1E, 
				 0x01, 0x00, 0x0C, 0x00, 0x00, 0x1F, 0x01, 0x00, 
				 0x19, 0xEA, 0x00, 0x00, 0x4C};

BYTE t5465_Mode_360x400x32_2[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x16, 0x05, 0x04, 0x00, 0x00, 0x16, 0xC0, 0x00, 
				 0x00, 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 
				 0x00, 0x1F, 0x01, 0x00, 0x18, 0xC5, 0x02, 0x18, 
				 0x07, 0x04, 0x15, 0xA0, 0x00, 0xFF, 0x00, 0x09, 
				 0xCE, 0x03, 0x06, 0x05, 0x09, 0xCE, 0x03, 0x09, 
				 0x00, 0x09, 0xCE, 0x03, 0x0A, 0x00, 0x09, 0xCE, 
				 0x03, 0x0B, 0x00, 0x16, 0x80, 0x00, 0x6F, 0x00, 
				 0x16, 0x84, 0x00, 0x32, 0x00, 0x16, 0x88, 0x00, 
				 0x7C, 0x00, 0x16, 0xC0, 0x00, 0x00, 0x80, 0x1D, 
				 0x19, 0x00, 0x00, 0x00, 0x35, 0x00, 0x00, 0x00, 
				 0x2C, 0x00, 0x00, 0x00, 0x2C, 0x00, 0x00, 0x00, 
				 0x93, 0x00, 0x00, 0x00, 0x2F, 0x00, 0x00, 0x00, 
				 0x90, 0x00, 0x00, 0x00, 0xBC, 0x00, 0x00, 0x00, 
				 0x1F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x90, 0x00, 0x00, 0x00, 
				 0x83, 0x00, 0x00, 0x00, 0x8F, 0x00, 0x00, 0x00, 
				 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x8F, 0x00, 0x00, 0x00, 0xBC, 0x00, 0x00, 0x00, 
				 0xE3, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 
				 0x1D, 0x06, 0x00, 0x64, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x40, 0x00, 0x00, 0x00, 0x22, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x13, 0xEA, 0x00, 
				 0x1E, 0x00, 0x00, 0xC0, 0x00, 0x00, 0x1E, 0x01, 
				 0x12, 0x0D, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 
				 0xEA, 0x00, 0x12, 0x07, 0x04, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x0D, 0x00, 0x00, 
				 0x00, 0x18, 0x07, 0x04, 0x13, 0xC4, 0x02, 0x1E, 
				 0x00, 0x3F, 0xC0, 0x00, 0x00, 0x1E, 0x01, 0x80, 
				 0x0D, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 0xC4, 
				 0x02, 0x13, 0xEA, 0x00, 0x1E, 0x00, 0xC0, 0xFF, 
				 0x00, 0x00, 0x1E, 0x01, 0x1A, 0x00, 0x00, 0x00, 
				 0x1F, 0x01, 0x00, 0x19, 0xEA, 0x00, 0x16, 0x02, 
				 0x04, 0x00, 0x60, 0x13, 0xC0, 0x00, 0x1E, 0x01, 
				 0x00, 0x34, 0x00, 0x00, 0x19, 0xC0, 0x00, 0x17, 
				 0x4C, 0x00, 0xD0, 0x00, 0x00, 0x00, 0x13, 0xEA, 
				 0x00, 0x1E, 0x00, 0xFF, 0xC0, 0x00, 0x00, 0x1E, 
				 0x01, 0x00, 0x0C, 0x00, 0x00, 0x1F, 0x01, 0x00, 
				 0x19, 0xEA, 0x00, 0x00, 0x4C};

BYTE t5465_Mode_400x300x32_1[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x16, 0x05, 0x04, 0x00, 0x00, 0x16, 0xC0, 0x00, 
				 0x00, 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 
				 0x00, 0x1F, 0x01, 0x00, 0x18, 0xC5, 0x02, 0x18, 
				 0x07, 0x04, 0x15, 0xA0, 0x00, 0xFF, 0x00, 0x09, 
				 0xCE, 0x03, 0x06, 0x05, 0x09, 0xCE, 0x03, 0x09, 
				 0x00, 0x09, 0xCE, 0x03, 0x0A, 0x00, 0x09, 0xCE, 
				 0x03, 0x0B, 0x00, 0x16, 0x80, 0x00, 0x2F, 0x00, 
				 0x16, 0x84, 0x00, 0x18, 0x00, 0x16, 0x88, 0x00, 
				 0x43, 0x00, 0x16, 0xC0, 0x00, 0x00, 0x80, 0x1D, 
				 0x19, 0x00, 0x00, 0x00, 0x3D, 0x00, 0x00, 0x00, 
				 0x31, 0x00, 0x00, 0x00, 0x31, 0x00, 0x00, 0x00, 
				 0x99, 0x00, 0x00, 0x00, 0x35, 0x00, 0x00, 0x00, 
				 0x96, 0x00, 0x00, 0x00, 0x72, 0x00, 0x00, 0x00, 
				 0xF0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0xE0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x58, 0x00, 0x00, 0x00, 
				 0x8C, 0x00, 0x00, 0x00, 0x57, 0x00, 0x00, 0x00, 
				 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x57, 0x00, 0x00, 0x00, 0x72, 0x00, 0x00, 0x00, 
				 0xE3, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 
				 0x1D, 0x06, 0x00, 0x64, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x80, 0x00, 0x00, 0x00, 0x22, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x13, 0xEA, 0x00, 
				 0x1E, 0x00, 0x00, 0xC0, 0x00, 0x00, 0x1E, 0x01, 
				 0x12, 0x0D, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 
				 0xEA, 0x00, 0x12, 0x07, 0x04, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x0D, 0x00, 0x00, 
				 0x00, 0x18, 0x07, 0x04, 0x13, 0xC4, 0x02, 0x1E, 
				 0x00, 0x3F, 0xC0, 0x00, 0x00, 0x1E, 0x01, 0x80, 
				 0x0D, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 0xC4, 
				 0x02, 0x13, 0xEA, 0x00, 0x1E, 0x00, 0xC0, 0xFF, 
				 0x00, 0x00, 0x1E, 0x01, 0x13, 0x00, 0x00, 0x00, 
				 0x1F, 0x01, 0x00, 0x19, 0xEA, 0x00, 0x16, 0x02, 
				 0x04, 0x00, 0x60, 0x13, 0xC0, 0x00, 0x1E, 0x01, 
				 0x00, 0x34, 0x00, 0x00, 0x19, 0xC0, 0x00, 0x17, 
				 0x4C, 0x00, 0xD0, 0x00, 0x00, 0x00, 0x13, 0xEA, 
				 0x00, 0x1E, 0x00, 0xFF, 0xC0, 0x00, 0x00, 0x1E, 
				 0x01, 0x00, 0x0D, 0x00, 0x00, 0x1F, 0x01, 0x00, 
				 0x19, 0xEA, 0x00, 0x00, 0x4C};

BYTE t5465_Mode_400x300x32_2[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x16, 0x05, 0x04, 0x00, 0x00, 0x16, 0xC0, 0x00, 
				 0x00, 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 
				 0x00, 0x1F, 0x01, 0x00, 0x18, 0xC5, 0x02, 0x18, 
				 0x07, 0x04, 0x15, 0xA0, 0x00, 0xFF, 0x00, 0x09, 
				 0xCE, 0x03, 0x06, 0x05, 0x09, 0xCE, 0x03, 0x09, 
				 0x00, 0x09, 0xCE, 0x03, 0x0A, 0x00, 0x09, 0xCE, 
				 0x03, 0x0B, 0x00, 0x16, 0x80, 0x00, 0x2F, 0x00, 
				 0x16, 0x84, 0x00, 0x16, 0x00, 0x16, 0x88, 0x00, 
				 0x4C, 0x00, 0x16, 0xC0, 0x00, 0x00, 0x80, 0x1D, 
				 0x19, 0x00, 0x00, 0x00, 0x3D, 0x00, 0x00, 0x00, 
				 0x31, 0x00, 0x00, 0x00, 0x31, 0x00, 0x00, 0x00, 
				 0x99, 0x00, 0x00, 0x00, 0x34, 0x00, 0x00, 0x00, 
				 0x96, 0x00, 0x00, 0x00, 0x6F, 0x00, 0x00, 0x00, 
				 0xF0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0xE0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x58, 0x00, 0x00, 0x00, 
				 0x8B, 0x00, 0x00, 0x00, 0x57, 0x00, 0x00, 0x00, 
				 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x57, 0x00, 0x00, 0x00, 0x6F, 0x00, 0x00, 0x00, 
				 0xE3, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 
				 0x1D, 0x06, 0x00, 0x64, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x80, 0x00, 0x00, 0x00, 0x22, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x13, 0xEA, 0x00, 
				 0x1E, 0x00, 0x00, 0xC0, 0x00, 0x00, 0x1E, 0x01, 
				 0x12, 0x0D, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 
				 0xEA, 0x00, 0x12, 0x07, 0x04, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x0D, 0x00, 0x00, 
				 0x00, 0x18, 0x07, 0x04, 0x13, 0xC4, 0x02, 0x1E, 
				 0x00, 0x3F, 0xC0, 0x00, 0x00, 0x1E, 0x01, 0x80, 
				 0x0D, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 0xC4, 
				 0x02, 0x13, 0xEA, 0x00, 0x1E, 0x00, 0xC0, 0xFF, 
				 0x00, 0x00, 0x1E, 0x01, 0x13, 0x00, 0x00, 0x00, 
				 0x1F, 0x01, 0x00, 0x19, 0xEA, 0x00, 0x16, 0x02, 
				 0x04, 0x00, 0x60, 0x13, 0xC0, 0x00, 0x1E, 0x01, 
				 0x00, 0x34, 0x00, 0x00, 0x19, 0xC0, 0x00, 0x17, 
				 0x4C, 0x00, 0xD0, 0x00, 0x00, 0x00, 0x13, 0xEA, 
				 0x00, 0x1E, 0x00, 0xFF, 0xC0, 0x00, 0x00, 0x1E, 
				 0x01, 0x00, 0x0D, 0x00, 0x00, 0x1F, 0x01, 0x00, 
				 0x19, 0xEA, 0x00, 0x00, 0x4C};

BYTE t5465_Mode_512x384x32_1[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x16, 0x05, 0x04, 0x00, 0x00, 0x16, 0xC0, 0x00, 
				 0x00, 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 
				 0x00, 0x1F, 0x01, 0x00, 0x18, 0xC5, 0x02, 0x18, 
				 0x07, 0x04, 0x15, 0xA0, 0x00, 0xFF, 0x00, 0x09, 
				 0xCE, 0x03, 0x06, 0x05, 0x09, 0xCE, 0x03, 0x09, 
				 0x00, 0x09, 0xCE, 0x03, 0x0A, 0x00, 0x09, 0xCE, 
				 0x03, 0x0B, 0x00, 0x16, 0x80, 0x00, 0xEF, 0x00, 
				 0x16, 0x84, 0x00, 0x31, 0x00, 0x16, 0x88, 0x00, 
				 0x6D, 0x00, 0x1D, 0x19, 0x00, 0x00, 0x00, 0x4F, 
				 0x00, 0x00, 0x00, 0x3F, 0x00, 0x00, 0x00, 0x3F, 
				 0x00, 0x00, 0x00, 0x89, 0x00, 0x00, 0x00, 0x42, 
				 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x24, 
				 0x00, 0x00, 0x00, 0xF5, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0xE0, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 
				 0x00, 0x00, 0x00, 0x88, 0x00, 0x00, 0x00, 0xFF, 
				 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 0x24, 
				 0x00, 0x00, 0x00, 0xE3, 0x00, 0x00, 0x00, 0xFF, 
				 0x00, 0x00, 0x00, 0x1D, 0x06, 0x00, 0x64, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0xD0, 0x00, 0x00, 0x00, 
				 0x22, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x13, 0xEA, 0x00, 0x1E, 0x00, 0x00, 0xC0, 0x00, 
				 0x00, 0x1E, 0x01, 0x13, 0x10, 0x00, 0x00, 0x1F, 
				 0x01, 0x00, 0x19, 0xEA, 0x00, 0x12, 0x07, 0x04, 
				 0x1E, 0x00, 0xC0, 0x00, 0x00, 0x00, 0x1E, 0x01, 
				 0x10, 0x00, 0x00, 0x00, 0x18, 0x07, 0x04, 0x13, 
				 0xC4, 0x02, 0x1E, 0x00, 0x3F, 0xC0, 0x00, 0x00, 
				 0x1E, 0x01, 0x80, 0x10, 0x00, 0x00, 0x1F, 0x01, 
				 0x00, 0x19, 0xC4, 0x02, 0x16, 0x02, 0x04, 0x00, 
				 0x60, 0x13, 0xC0, 0x00, 0x1E, 0x01, 0x00, 0x34, 
				 0x00, 0x00, 0x19, 0xC0, 0x00, 0x17, 0x4C, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x17, 0x6C, 0x00, 0x32, 
				 0x00, 0x00, 0x00, 0x13, 0xEA, 0x00, 0x1E, 0x00, 
				 0xFF, 0xC0, 0x00, 0x00, 0x1E, 0x01, 0x00, 0x10, 
				 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 0xEA, 0x00, 
				 0x00, 0x1E};

BYTE t5465_Mode_512x384x32_2[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x16, 0x05, 0x04, 0x00, 0x00, 0x16, 0xC0, 0x00, 
				 0x00, 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 
				 0x00, 0x1F, 0x01, 0x00, 0x18, 0xC5, 0x02, 0x18, 
				 0x07, 0x04, 0x15, 0xA0, 0x00, 0xFF, 0x00, 0x09, 
				 0xCE, 0x03, 0x06, 0x05, 0x09, 0xCE, 0x03, 0x09, 
				 0x00, 0x09, 0xCE, 0x03, 0x0A, 0x00, 0x09, 0xCE, 
				 0x03, 0x0B, 0x00, 0x16, 0x80, 0x00, 0xEF, 0x00, 
				 0x16, 0x84, 0x00, 0x2B, 0x00, 0x16, 0x88, 0x00, 
				 0x6E, 0x00, 0x1D, 0x19, 0x00, 0x00, 0x00, 0x4E, 
				 0x00, 0x00, 0x00, 0x3F, 0x00, 0x00, 0x00, 0x3F, 
				 0x00, 0x00, 0x00, 0x88, 0x00, 0x00, 0x00, 0x42, 
				 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x24, 
				 0x00, 0x00, 0x00, 0xF5, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0xE0, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 
				 0x00, 0x00, 0x00, 0x88, 0x00, 0x00, 0x00, 0xFF, 
				 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 0x23, 
				 0x00, 0x00, 0x00, 0xE3, 0x00, 0x00, 0x00, 0xFF, 
				 0x00, 0x00, 0x00, 0x1D, 0x06, 0x00, 0x64, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0xD0, 0x00, 0x00, 0x00, 
				 0x22, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x13, 0xEA, 0x00, 0x1E, 0x00, 0x00, 0xC0, 0x00, 
				 0x00, 0x1E, 0x01, 0x13, 0x10, 0x00, 0x00, 0x1F, 
				 0x01, 0x00, 0x19, 0xEA, 0x00, 0x12, 0x07, 0x04, 
				 0x1E, 0x00, 0xC0, 0x00, 0x00, 0x00, 0x1E, 0x01, 
				 0x10, 0x00, 0x00, 0x00, 0x18, 0x07, 0x04, 0x13, 
				 0xC4, 0x02, 0x1E, 0x00, 0x3F, 0xC0, 0x00, 0x00, 
				 0x1E, 0x01, 0x80, 0x10, 0x00, 0x00, 0x1F, 0x01, 
				 0x00, 0x19, 0xC4, 0x02, 0x16, 0x02, 0x04, 0x00, 
				 0x60, 0x13, 0xC0, 0x00, 0x1E, 0x01, 0x00, 0x34, 
				 0x00, 0x00, 0x19, 0xC0, 0x00, 0x17, 0x4C, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x17, 0x6C, 0x00, 0x32, 
				 0x00, 0x00, 0x00, 0x13, 0xEA, 0x00, 0x1E, 0x00, 
				 0xFF, 0xC0, 0x00, 0x00, 0x1E, 0x01, 0x00, 0x10, 
				 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 0xEA, 0x00, 
				 0x00, 0x1E};

BYTE t5465_Mode_512x480x32_1[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x16, 0x05, 0x04, 0x00, 0x00, 0x16, 0xC0, 0x00, 
				 0x00, 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 
				 0x00, 0x1F, 0x01, 0x00, 0x18, 0xC5, 0x02, 0x18, 
				 0x07, 0x04, 0x15, 0xA0, 0x00, 0xFF, 0x00, 0x09, 
				 0xCE, 0x03, 0x06, 0x05, 0x09, 0xCE, 0x03, 0x09, 
				 0x00, 0x09, 0xCE, 0x03, 0x0A, 0x00, 0x09, 0xCE, 
				 0x03, 0x0B, 0x00, 0x16, 0x80, 0x00, 0x2F, 0x00, 
				 0x16, 0x84, 0x00, 0x10, 0x00, 0x16, 0x88, 0x00, 
				 0x2D, 0x00, 0x16, 0xC0, 0x00, 0x00, 0x80, 0x1D, 
				 0x19, 0x00, 0x00, 0x00, 0x4B, 0x00, 0x00, 0x00, 
				 0x3F, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 
				 0x4B, 0x00, 0x00, 0x00, 0x44, 0x00, 0x00, 0x00, 
				 0x08, 0x00, 0x00, 0x00, 0xF0, 0x00, 0x00, 0x00, 
				 0x1F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0xE1, 0x00, 0x00, 0x00, 
				 0x84, 0x00, 0x00, 0x00, 0xDF, 0x00, 0x00, 0x00, 
				 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0xE0, 0x00, 0x00, 0x00, 0xF0, 0x00, 0x00, 0x00, 
				 0xE3, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 
				 0x1D, 0x06, 0x00, 0x64, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x50, 0x00, 0x00, 0x00, 0x22, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x13, 0xEA, 0x00, 
				 0x1E, 0x00, 0x00, 0xC0, 0x00, 0x00, 0x1E, 0x01, 
				 0x52, 0x10, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 
				 0xEA, 0x00, 0x12, 0x07, 0x04, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x08, 0x00, 0x00, 
				 0x00, 0x18, 0x07, 0x04, 0x13, 0xC4, 0x02, 0x1E, 
				 0x00, 0x3F, 0xC0, 0x00, 0x00, 0x1E, 0x01, 0xC0, 
				 0x08, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 0xC4, 
				 0x02, 0x13, 0xEA, 0x00, 0x1E, 0x00, 0xC0, 0xFF, 
				 0x00, 0x00, 0x1E, 0x01, 0x0D, 0x00, 0x00, 0x00, 
				 0x1F, 0x01, 0x00, 0x19, 0xEA, 0x00, 0x16, 0x02, 
				 0x04, 0x00, 0x68, 0x13, 0xC0, 0x00, 0x1E, 0x01, 
				 0x00, 0x34, 0x00, 0x00, 0x19, 0xC0, 0x00, 0x17, 
				 0x4C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x17, 0x6C, 
				 0x00, 0x32, 0x00, 0x00, 0x00, 0x13, 0xEA, 0x00, 
				 0x1E, 0x00, 0xFF, 0xC0, 0x00, 0x00, 0x1E, 0x01, 
				 0x00, 0x10, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 
				 0xEA, 0x00, 0x00, 0xEA};

BYTE t5465_Mode_512x480x32_2[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x16, 0x05, 0x04, 0x00, 0x00, 0x16, 0xC0, 0x00, 
				 0x00, 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 
				 0x00, 0x1F, 0x01, 0x00, 0x18, 0xC5, 0x02, 0x18, 
				 0x07, 0x04, 0x15, 0xA0, 0x00, 0xFF, 0x00, 0x09, 
				 0xCE, 0x03, 0x06, 0x05, 0x09, 0xCE, 0x03, 0x09, 
				 0x00, 0x09, 0xCE, 0x03, 0x0A, 0x00, 0x09, 0xCE, 
				 0x03, 0x0B, 0x00, 0x16, 0x80, 0x00, 0x2F, 0x00, 
				 0x16, 0x84, 0x00, 0x12, 0x00, 0x16, 0x88, 0x00, 
				 0x3E, 0x00, 0x16, 0xC0, 0x00, 0x00, 0x80, 0x1D, 
				 0x19, 0x00, 0x00, 0x00, 0x4D, 0x00, 0x00, 0x00, 
				 0x3F, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 
				 0x8D, 0x00, 0x00, 0x00, 0x44, 0x00, 0x00, 0x00, 
				 0x09, 0x00, 0x00, 0x00, 0xF4, 0x00, 0x00, 0x00, 
				 0x1F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0xE1, 0x00, 0x00, 0x00, 
				 0x84, 0x00, 0x00, 0x00, 0xDF, 0x00, 0x00, 0x00, 
				 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0xE0, 0x00, 0x00, 0x00, 0xF4, 0x00, 0x00, 0x00, 
				 0xE3, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 
				 0x1D, 0x06, 0x00, 0x64, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x50, 0x00, 0x00, 0x00, 0x22, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x13, 0xEA, 0x00, 
				 0x1E, 0x00, 0x00, 0xC0, 0x00, 0x00, 0x1E, 0x01, 
				 0x52, 0x10, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 
				 0xEA, 0x00, 0x12, 0x07, 0x04, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x08, 0x00, 0x00, 
				 0x00, 0x18, 0x07, 0x04, 0x13, 0xC4, 0x02, 0x1E, 
				 0x00, 0x3F, 0xC0, 0x00, 0x00, 0x1E, 0x01, 0xC0, 
				 0x08, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 0xC4, 
				 0x02, 0x13, 0xEA, 0x00, 0x1E, 0x00, 0xC0, 0xFF, 
				 0x00, 0x00, 0x1E, 0x01, 0x0E, 0x00, 0x00, 0x00, 
				 0x1F, 0x01, 0x00, 0x19, 0xEA, 0x00, 0x16, 0x02, 
				 0x04, 0x00, 0x68, 0x13, 0xC0, 0x00, 0x1E, 0x01, 
				 0x00, 0x34, 0x00, 0x00, 0x19, 0xC0, 0x00, 0x17, 
				 0x4C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x17, 0x6C, 
				 0x00, 0x32, 0x00, 0x00, 0x00, 0x13, 0xEA, 0x00, 
				 0x1E, 0x00, 0xFF, 0xC0, 0x00, 0x00, 0x1E, 0x01, 
				 0x00, 0x10, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 
				 0xEA, 0x00, 0x00, 0xEA};

BYTE t5465_Mode_640x350x32_1[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x16, 0x05, 0x04, 0x00, 0x00, 0x16, 0xC0, 0x00, 
				 0x00, 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 
				 0x00, 0x1F, 0x01, 0x00, 0x18, 0xC5, 0x02, 0x18, 
				 0x07, 0x04, 0x15, 0xA0, 0x00, 0xFF, 0x00, 0x09, 
				 0xCE, 0x03, 0x06, 0x05, 0x09, 0xCE, 0x03, 0x09, 
				 0x00, 0x09, 0xCE, 0x03, 0x0A, 0x00, 0x09, 0xCE, 
				 0x03, 0x0B, 0x00, 0x16, 0x80, 0x00, 0xAF, 0x00, 
				 0x16, 0x84, 0x00, 0x3B, 0x00, 0x16, 0x88, 0x00, 
				 0x69, 0x00, 0x1D, 0x19, 0x00, 0x00, 0x00, 0x63, 
				 0x00, 0x00, 0x00, 0x4F, 0x00, 0x00, 0x00, 0x4F, 
				 0x00, 0x00, 0x00, 0x83, 0x00, 0x00, 0x00, 0x53, 
				 0x00, 0x00, 0x00, 0x97, 0x00, 0x00, 0x00, 0xBB, 
				 0x00, 0x00, 0x00, 0x1F, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7D, 
				 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x5D, 
				 0x00, 0x00, 0x00, 0xA0, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x5D, 0x00, 0x00, 0x00, 0xBB, 
				 0x00, 0x00, 0x00, 0xE3, 0x00, 0x00, 0x00, 0xFF, 
				 0x00, 0x00, 0x00, 0x1D, 0x06, 0x00, 0x64, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x50, 0x00, 0x00, 0x00, 
				 0x22, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x13, 0xEA, 0x00, 0x1E, 0x00, 0x00, 0xC0, 0x00, 
				 0x00, 0x1E, 0x01, 0x56, 0x14, 0x00, 0x00, 0x1F, 
				 0x01, 0x00, 0x19, 0xEA, 0x00, 0x12, 0x07, 0x04, 
				 0x1E, 0x00, 0xC0, 0x00, 0x00, 0x00, 0x1E, 0x01, 
				 0x0A, 0x00, 0x00, 0x00, 0x18, 0x07, 0x04, 0x13, 
				 0xC4, 0x02, 0x1E, 0x00, 0x3F, 0xC0, 0x00, 0x00, 
				 0x1E, 0x01, 0xC0, 0x0A, 0x00, 0x00, 0x1F, 0x01, 
				 0x00, 0x19, 0xC4, 0x02, 0x13, 0xEA, 0x00, 0x1E, 
				 0x00, 0xC0, 0xFF, 0x00, 0x00, 0x1E, 0x01, 0x13, 
				 0x00, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 0xEA, 
				 0x00, 0x16, 0x02, 0x04, 0x00, 0x68, 0x13, 0xC0, 
				 0x00, 0x1E, 0x01, 0x00, 0x34, 0x00, 0x00, 0x19, 
				 0xC0, 0x00, 0x17, 0x4C, 0x00, 0x40, 0x00, 0x00, 
				 0x00, 0x17, 0x6C, 0x00, 0x32, 0x00, 0x00, 0x00, 
				 0x13, 0xEA, 0x00, 0x1E, 0x00, 0xFF, 0xC0, 0x00, 
				 0x00, 0x1E, 0x01, 0x00, 0x14, 0x00, 0x00, 0x1F, 
				 0x01, 0x00, 0x19, 0xEA, 0x00, 0x00, 0x00};

BYTE t5465_Mode_640x350x32_2[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x16, 0x05, 0x04, 0x00, 0x00, 0x16, 0xC0, 0x00, 
				 0x00, 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 
				 0x00, 0x1F, 0x01, 0x00, 0x18, 0xC5, 0x02, 0x18, 
				 0x07, 0x04, 0x15, 0xA0, 0x00, 0xFF, 0x00, 0x09, 
				 0xCE, 0x03, 0x06, 0x05, 0x09, 0xCE, 0x03, 0x09, 
				 0x00, 0x09, 0xCE, 0x03, 0x0A, 0x00, 0x09, 0xCE, 
				 0x03, 0x0B, 0x00, 0x16, 0x80, 0x00, 0xAF, 0x00, 
				 0x16, 0x84, 0x00, 0x0B, 0x00, 0x16, 0x88, 0x00, 
				 0x16, 0x00, 0x1D, 0x19, 0x00, 0x00, 0x00, 0x63, 
				 0x00, 0x00, 0x00, 0x4F, 0x00, 0x00, 0x00, 0x4F, 
				 0x00, 0x00, 0x00, 0x83, 0x00, 0x00, 0x00, 0x55, 
				 0x00, 0x00, 0x00, 0x99, 0x00, 0x00, 0x00, 0xBB, 
				 0x00, 0x00, 0x00, 0x1F, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7D, 
				 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x5D, 
				 0x00, 0x00, 0x00, 0xA0, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x5D, 0x00, 0x00, 0x00, 0xBB, 
				 0x00, 0x00, 0x00, 0xE3, 0x00, 0x00, 0x00, 0xFF, 
				 0x00, 0x00, 0x00, 0x1D, 0x06, 0x00, 0x64, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x50, 0x00, 0x00, 0x00, 
				 0x22, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x13, 0xEA, 0x00, 0x1E, 0x00, 0x00, 0xC0, 0x00, 
				 0x00, 0x1E, 0x01, 0x56, 0x14, 0x00, 0x00, 0x1F, 
				 0x01, 0x00, 0x19, 0xEA, 0x00, 0x12, 0x07, 0x04, 
				 0x1E, 0x00, 0xC0, 0x00, 0x00, 0x00, 0x1E, 0x01, 
				 0x0A, 0x00, 0x00, 0x00, 0x18, 0x07, 0x04, 0x13, 
				 0xC4, 0x02, 0x1E, 0x00, 0x3F, 0xC0, 0x00, 0x00, 
				 0x1E, 0x01, 0xC0, 0x0A, 0x00, 0x00, 0x1F, 0x01, 
				 0x00, 0x19, 0xC4, 0x02, 0x13, 0xEA, 0x00, 0x1E, 
				 0x00, 0xC0, 0xFF, 0x00, 0x00, 0x1E, 0x01, 0x13, 
				 0x00, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 0xEA, 
				 0x00, 0x16, 0x02, 0x04, 0x00, 0x68, 0x13, 0xC0, 
				 0x00, 0x1E, 0x01, 0x00, 0x34, 0x00, 0x00, 0x19, 
				 0xC0, 0x00, 0x17, 0x4C, 0x00, 0x40, 0x00, 0x00, 
				 0x00, 0x17, 0x6C, 0x00, 0x32, 0x00, 0x00, 0x00, 
				 0x13, 0xEA, 0x00, 0x1E, 0x00, 0xFF, 0xC0, 0x00, 
				 0x00, 0x1E, 0x01, 0x00, 0x14, 0x00, 0x00, 0x1F, 
				 0x01, 0x00, 0x19, 0xEA, 0x00, 0x00, 0x00};

BYTE t5465_Mode_640x400x32_1[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x16, 0x05, 0x04, 0x00, 0x00, 0x16, 0xC0, 0x00, 
				 0x00, 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 
				 0x00, 0x1F, 0x01, 0x00, 0x18, 0xC5, 0x02, 0x18, 
				 0x07, 0x04, 0x15, 0xA0, 0x00, 0xFF, 0x00, 0x09, 
				 0xCE, 0x03, 0x06, 0x05, 0x09, 0xCE, 0x03, 0x09, 
				 0x00, 0x09, 0xCE, 0x03, 0x0A, 0x00, 0x09, 0xCE, 
				 0x03, 0x0B, 0x00, 0x16, 0x80, 0x00, 0x6F, 0x00, 
				 0x16, 0x84, 0x00, 0x3F, 0x00, 0x16, 0x88, 0x00, 
				 0x6D, 0x00, 0x1D, 0x19, 0x00, 0x00, 0x00, 0x5F, 
				 0x00, 0x00, 0x00, 0x4F, 0x00, 0x00, 0x00, 0x50, 
				 0x00, 0x00, 0x00, 0x82, 0x00, 0x00, 0x00, 0x53, 
				 0x00, 0x00, 0x00, 0x9F, 0x00, 0x00, 0x00, 0xBF, 
				 0x00, 0x00, 0x00, 0x1F, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xA1, 
				 0x00, 0x00, 0x00, 0xA3, 0x00, 0x00, 0x00, 0x8F, 
				 0x00, 0x00, 0x00, 0x50, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x96, 0x00, 0x00, 0x00, 0xB9, 
				 0x00, 0x00, 0x00, 0xE3, 0x00, 0x00, 0x00, 0xFF, 
				 0x00, 0x00, 0x00, 0x1D, 0x06, 0x00, 0x64, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x50, 0x00, 0x00, 0x00, 
				 0x22, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x13, 0xEA, 0x00, 0x1E, 0x00, 0x00, 0xC0, 0x00, 
				 0x00, 0x1E, 0x01, 0x56, 0x14, 0x00, 0x00, 0x1F, 
				 0x01, 0x00, 0x19, 0xEA, 0x00, 0x12, 0x07, 0x04, 
				 0x1E, 0x00, 0xC0, 0x00, 0x00, 0x00, 0x1E, 0x01, 
				 0x0A, 0x00, 0x00, 0x00, 0x18, 0x07, 0x04, 0x13, 
				 0xC4, 0x02, 0x1E, 0x00, 0x3F, 0xC0, 0x00, 0x00, 
				 0x1E, 0x01, 0xC0, 0x0A, 0x00, 0x00, 0x1F, 0x01, 
				 0x00, 0x19, 0xC4, 0x02, 0x13, 0xEA, 0x00, 0x1E, 
				 0x00, 0xC0, 0xFF, 0x00, 0x00, 0x1E, 0x01, 0x19, 
				 0x00, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 0xEA, 
				 0x00, 0x16, 0x02, 0x04, 0x00, 0x68, 0x13, 0xC0, 
				 0x00, 0x1E, 0x01, 0x00, 0x34, 0x00, 0x00, 0x19, 
				 0xC0, 0x00, 0x17, 0x4C, 0x00, 0x40, 0x00, 0x00, 
				 0x00, 0x17, 0x6C, 0x00, 0x32, 0x00, 0x00, 0x00, 
				 0x13, 0xEA, 0x00, 0x1E, 0x00, 0xFF, 0xC0, 0x00, 
				 0x00, 0x1E, 0x01, 0x00, 0x14, 0x00, 0x00, 0x1F, 
				 0x01, 0x00, 0x19, 0xEA, 0x00, 0x00, 0x00};

BYTE t5465_Mode_640x400x32_2[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x16, 0x05, 0x04, 0x00, 0x00, 0x16, 0xC0, 0x00, 
				 0x00, 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 
				 0x00, 0x1F, 0x01, 0x00, 0x18, 0xC5, 0x02, 0x18, 
				 0x07, 0x04, 0x15, 0xA0, 0x00, 0xFF, 0x00, 0x09, 
				 0xCE, 0x03, 0x06, 0x05, 0x09, 0xCE, 0x03, 0x09, 
				 0x00, 0x09, 0xCE, 0x03, 0x0A, 0x00, 0x09, 0xCE, 
				 0x03, 0x0B, 0x00, 0x16, 0x80, 0x00, 0x6F, 0x00, 
				 0x16, 0x84, 0x00, 0x0B, 0x00, 0x16, 0x88, 0x00, 
				 0x16, 0x00, 0x1D, 0x19, 0x00, 0x00, 0x00, 0x63, 
				 0x00, 0x00, 0x00, 0x4F, 0x00, 0x00, 0x00, 0x4F, 
				 0x00, 0x00, 0x00, 0x83, 0x00, 0x00, 0x00, 0x55, 
				 0x00, 0x00, 0x00, 0x99, 0x00, 0x00, 0x00, 0xBB, 
				 0x00, 0x00, 0x00, 0x1F, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x90, 
				 0x00, 0x00, 0x00, 0x83, 0x00, 0x00, 0x00, 0x8F, 
				 0x00, 0x00, 0x00, 0x50, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x8F, 0x00, 0x00, 0x00, 0xBB, 
				 0x00, 0x00, 0x00, 0xE3, 0x00, 0x00, 0x00, 0xFF, 
				 0x00, 0x00, 0x00, 0x1D, 0x06, 0x00, 0x64, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x50, 0x00, 0x00, 0x00, 
				 0x22, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x13, 0xEA, 0x00, 0x1E, 0x00, 0x00, 0xC0, 0x00, 
				 0x00, 0x1E, 0x01, 0x56, 0x14, 0x00, 0x00, 0x1F, 
				 0x01, 0x00, 0x19, 0xEA, 0x00, 0x12, 0x07, 0x04, 
				 0x1E, 0x00, 0xC0, 0x00, 0x00, 0x00, 0x1E, 0x01, 
				 0x0A, 0x00, 0x00, 0x00, 0x18, 0x07, 0x04, 0x13, 
				 0xC4, 0x02, 0x1E, 0x00, 0x3F, 0xC0, 0x00, 0x00, 
				 0x1E, 0x01, 0xC0, 0x0A, 0x00, 0x00, 0x1F, 0x01, 
				 0x00, 0x19, 0xC4, 0x02, 0x13, 0xEA, 0x00, 0x1E, 
				 0x00, 0xC0, 0xFF, 0x00, 0x00, 0x1E, 0x01, 0x12, 
				 0x00, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 0xEA, 
				 0x00, 0x16, 0x02, 0x04, 0x00, 0x68, 0x13, 0xC0, 
				 0x00, 0x1E, 0x01, 0x00, 0x34, 0x00, 0x00, 0x19, 
				 0xC0, 0x00, 0x17, 0x4C, 0x00, 0x40, 0x00, 0x00, 
				 0x00, 0x17, 0x6C, 0x00, 0x32, 0x00, 0x00, 0x00, 
				 0x13, 0xEA, 0x00, 0x1E, 0x00, 0xFF, 0xC0, 0x00, 
				 0x00, 0x1E, 0x01, 0x00, 0x14, 0x00, 0x00, 0x1F, 
				 0x01, 0x00, 0x19, 0xEA, 0x00, 0x00, 0x00};

BYTE t5465_Mode_640x480x32_1[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x16, 0x05, 0x04, 0x00, 0x00, 0x16, 0xC0, 0x00, 
				 0x00, 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 
				 0x00, 0x1F, 0x01, 0x00, 0x18, 0xC5, 0x02, 0x18, 
				 0x07, 0x04, 0x15, 0xA0, 0x00, 0xFF, 0x00, 0x09, 
				 0xCE, 0x03, 0x06, 0x05, 0x09, 0xCE, 0x03, 0x09, 
				 0x00, 0x09, 0xCE, 0x03, 0x0A, 0x00, 0x09, 0xCE, 
				 0x03, 0x0B, 0x00, 0x16, 0x80, 0x00, 0xEF, 0x00, 
				 0x16, 0x84, 0x00, 0x3F, 0x00, 0x16, 0x88, 0x00, 
				 0x6D, 0x00, 0x1D, 0x19, 0x00, 0x00, 0x00, 0x5F, 
				 0x00, 0x00, 0x00, 0x4F, 0x00, 0x00, 0x00, 0x50, 
				 0x00, 0x00, 0x00, 0x9F, 0x00, 0x00, 0x00, 0x54, 
				 0x00, 0x00, 0x00, 0x1F, 0x00, 0x00, 0x00, 0x0B, 
				 0x00, 0x00, 0x00, 0x3E, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xE9, 
				 0x00, 0x00, 0x00, 0x8B, 0x00, 0x00, 0x00, 0xDF, 
				 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0xE7, 0x00, 0x00, 0x00, 0x04, 
				 0x00, 0x00, 0x00, 0xE3, 0x00, 0x00, 0x00, 0xFF, 
				 0x00, 0x00, 0x00, 0x1D, 0x06, 0x00, 0x64, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x90, 0x00, 0x00, 0x00, 
				 0x22, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x13, 0xEA, 0x00, 0x1E, 0x00, 0x00, 0xC0, 0x00, 
				 0x00, 0x1E, 0x01, 0x56, 0x14, 0x00, 0x00, 0x1F, 
				 0x01, 0x00, 0x19, 0xEA, 0x00, 0x12, 0x07, 0x04, 
				 0x1E, 0x00, 0xC0, 0x00, 0x00, 0x00, 0x1E, 0x01, 
				 0x0A, 0x00, 0x00, 0x00, 0x18, 0x07, 0x04, 0x13, 
				 0xC4, 0x02, 0x1E, 0x00, 0x3F, 0xC0, 0x00, 0x00, 
				 0x1E, 0x01, 0xC0, 0x0A, 0x00, 0x00, 0x1F, 0x01, 
				 0x00, 0x19, 0xC4, 0x02, 0x13, 0xEA, 0x00, 0x1E, 
				 0x00, 0xC0, 0xFF, 0x00, 0x00, 0x1E, 0x01, 0x12, 
				 0x00, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 0xEA, 
				 0x00, 0x16, 0x02, 0x04, 0x00, 0x68, 0x13, 0xC0, 
				 0x00, 0x1E, 0x01, 0x00, 0x34, 0x00, 0x00, 0x19, 
				 0xC0, 0x00, 0x17, 0x4C, 0x00, 0x40, 0x00, 0x00, 
				 0x00, 0x17, 0x6C, 0x00, 0x32, 0x00, 0x00, 0x00, 
				 0x13, 0xEA, 0x00, 0x1E, 0x00, 0xFF, 0xC0, 0x00, 
				 0x00, 0x1E, 0x01, 0x00, 0x14, 0x00, 0x00, 0x1F, 
				 0x01, 0x00, 0x19, 0xEA, 0x00, 0x00, 0x00};

BYTE t5465_Mode_640x480x32_2[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x16, 0x05, 0x04, 0x00, 0x00, 0x16, 0xC0, 0x00, 
				 0x00, 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 
				 0x00, 0x1F, 0x01, 0x00, 0x18, 0xC5, 0x02, 0x18, 
				 0x07, 0x04, 0x15, 0xA0, 0x00, 0xFF, 0x00, 0x09, 
				 0xCE, 0x03, 0x06, 0x05, 0x09, 0xCE, 0x03, 0x09, 
				 0x00, 0x09, 0xCE, 0x03, 0x0A, 0x00, 0x09, 0xCE, 
				 0x03, 0x0B, 0x00, 0x16, 0x80, 0x00, 0xEF, 0x00, 
				 0x16, 0x84, 0x00, 0x0B, 0x00, 0x16, 0x88, 0x00, 
				 0x16, 0x00, 0x1D, 0x19, 0x00, 0x00, 0x00, 0x63, 
				 0x00, 0x00, 0x00, 0x4F, 0x00, 0x00, 0x00, 0x50, 
				 0x00, 0x00, 0x00, 0x82, 0x00, 0x00, 0x00, 0x54, 
				 0x00, 0x00, 0x00, 0x99, 0x00, 0x00, 0x00, 0x06, 
				 0x00, 0x00, 0x00, 0x3E, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xE8, 
				 0x00, 0x00, 0x00, 0x8B, 0x00, 0x00, 0x00, 0xDF, 
				 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0xE7, 0x00, 0x00, 0x00, 0xF3, 
				 0x00, 0x00, 0x00, 0xE3, 0x00, 0x00, 0x00, 0xFF, 
				 0x00, 0x00, 0x00, 0x1D, 0x06, 0x00, 0x64, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x50, 0x00, 0x00, 0x00, 
				 0x22, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x13, 0xEA, 0x00, 0x1E, 0x00, 0x00, 0xC0, 0x00, 
				 0x00, 0x1E, 0x01, 0x56, 0x14, 0x00, 0x00, 0x1F, 
				 0x01, 0x00, 0x19, 0xEA, 0x00, 0x12, 0x07, 0x04, 
				 0x1E, 0x00, 0xC0, 0x00, 0x00, 0x00, 0x1E, 0x01, 
				 0x0A, 0x00, 0x00, 0x00, 0x18, 0x07, 0x04, 0x13, 
				 0xC4, 0x02, 0x1E, 0x00, 0x3F, 0xC0, 0x00, 0x00, 
				 0x1E, 0x01, 0xC0, 0x0A, 0x00, 0x00, 0x1F, 0x01, 
				 0x00, 0x19, 0xC4, 0x02, 0x13, 0xEA, 0x00, 0x1E, 
				 0x00, 0xC0, 0xFF, 0x00, 0x00, 0x1E, 0x01, 0x12, 
				 0x00, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 0xEA, 
				 0x00, 0x16, 0x02, 0x04, 0x00, 0x68, 0x13, 0xC0, 
				 0x00, 0x1E, 0x01, 0x00, 0x34, 0x00, 0x00, 0x19, 
				 0xC0, 0x00, 0x17, 0x4C, 0x00, 0x40, 0x00, 0x00, 
				 0x00, 0x17, 0x6C, 0x00, 0x32, 0x00, 0x00, 0x00, 
				 0x13, 0xEA, 0x00, 0x1E, 0x00, 0xFF, 0xC0, 0x00, 
				 0x00, 0x1E, 0x01, 0x00, 0x14, 0x00, 0x00, 0x1F, 
				 0x01, 0x00, 0x19, 0xEA, 0x00, 0x00, 0x00};

BYTE t5465_Mode_640x480x32_3[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x16, 0x05, 0x04, 0x00, 0x00, 0x16, 0xC0, 0x00, 
				 0x00, 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 
				 0x00, 0x1F, 0x01, 0x00, 0x18, 0xC5, 0x02, 0x18, 
				 0x07, 0x04, 0x15, 0xA0, 0x00, 0xFF, 0x00, 0x09, 
				 0xCE, 0x03, 0x06, 0x05, 0x09, 0xCE, 0x03, 0x09, 
				 0x00, 0x09, 0xCE, 0x03, 0x0A, 0x00, 0x09, 0xCE, 
				 0x03, 0x0B, 0x00, 0x16, 0x80, 0x00, 0xEF, 0x00, 
				 0x16, 0x84, 0x00, 0x0B, 0x00, 0x16, 0x88, 0x00, 
				 0x16, 0x00, 0x1D, 0x19, 0x00, 0x00, 0x00, 0x64, 
				 0x00, 0x00, 0x00, 0x4F, 0x00, 0x00, 0x00, 0x50, 
				 0x00, 0x00, 0x00, 0x82, 0x00, 0x00, 0x00, 0x54, 
				 0x00, 0x00, 0x00, 0x9B, 0x00, 0x00, 0x00, 0xF2, 
				 0x00, 0x00, 0x00, 0x1F, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xE0, 
				 0x00, 0x00, 0x00, 0x83, 0x00, 0x00, 0x00, 0xDF, 
				 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0xDF, 0x00, 0x00, 0x00, 0xF2, 
				 0x00, 0x00, 0x00, 0xE3, 0x00, 0x00, 0x00, 0xFF, 
				 0x00, 0x00, 0x00, 0x1D, 0x06, 0x00, 0x64, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x50, 0x00, 0x00, 0x00, 
				 0x22, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x13, 0xEA, 0x00, 0x1E, 0x00, 0x00, 0xC0, 0x00, 
				 0x00, 0x1E, 0x01, 0x56, 0x14, 0x00, 0x00, 0x1F, 
				 0x01, 0x00, 0x19, 0xEA, 0x00, 0x12, 0x07, 0x04, 
				 0x1E, 0x00, 0xC0, 0x00, 0x00, 0x00, 0x1E, 0x01, 
				 0x0A, 0x00, 0x00, 0x00, 0x18, 0x07, 0x04, 0x13, 
				 0xC4, 0x02, 0x1E, 0x00, 0x3F, 0xC0, 0x00, 0x00, 
				 0x1E, 0x01, 0xC0, 0x0A, 0x00, 0x00, 0x1F, 0x01, 
				 0x00, 0x19, 0xC4, 0x02, 0x13, 0xEA, 0x00, 0x1E, 
				 0x00, 0xC0, 0xFF, 0x00, 0x00, 0x1E, 0x01, 0x12, 
				 0x00, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 0xEA, 
				 0x00, 0x16, 0x02, 0x04, 0x00, 0x68, 0x13, 0xC0, 
				 0x00, 0x1E, 0x01, 0x00, 0x34, 0x00, 0x00, 0x19, 
				 0xC0, 0x00, 0x17, 0x4C, 0x00, 0x40, 0x00, 0x00, 
				 0x00, 0x17, 0x6C, 0x00, 0x32, 0x00, 0x00, 0x00, 
				 0x13, 0xEA, 0x00, 0x1E, 0x00, 0xFF, 0xC0, 0x00, 
				 0x00, 0x1E, 0x01, 0x00, 0x14, 0x00, 0x00, 0x1F, 
				 0x01, 0x00, 0x19, 0xEA, 0x00, 0x00, 0x00};

BYTE t5465_Mode_640x480x32_4[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x16, 0x05, 0x04, 0x00, 0x00, 0x16, 0xC0, 0x00, 
				 0x00, 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 
				 0x00, 0x1F, 0x01, 0x00, 0x18, 0xC5, 0x02, 0x18, 
				 0x07, 0x04, 0x15, 0xA0, 0x00, 0xFF, 0x00, 0x09, 
				 0xCE, 0x03, 0x06, 0x05, 0x09, 0xCE, 0x03, 0x09, 
				 0x00, 0x09, 0xCE, 0x03, 0x0A, 0x00, 0x09, 0xCE, 
				 0x03, 0x0B, 0x00, 0x16, 0x80, 0x00, 0xEF, 0x00, 
				 0x16, 0x84, 0x00, 0x33, 0x00, 0x16, 0x88, 0x00, 
				 0x7E, 0x00, 0x1D, 0x19, 0x00, 0x00, 0x00, 0x63, 
				 0x00, 0x00, 0x00, 0x4F, 0x00, 0x00, 0x00, 0x50, 
				 0x00, 0x00, 0x00, 0x82, 0x00, 0x00, 0x00, 0x55, 
				 0x00, 0x00, 0x00, 0x9B, 0x00, 0x00, 0x00, 0xFB, 
				 0x00, 0x00, 0x00, 0x1F, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xE0, 
				 0x00, 0x00, 0x00, 0x83, 0x00, 0x00, 0x00, 0xDF, 
				 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0xDF, 0x00, 0x00, 0x00, 0xF9, 
				 0x00, 0x00, 0x00, 0xE3, 0x00, 0x00, 0x00, 0xFF, 
				 0x00, 0x00, 0x00, 0x1D, 0x06, 0x00, 0x64, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x50, 0x00, 0x00, 0x00, 
				 0x22, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x13, 0xEA, 0x00, 0x1E, 0x00, 0x00, 0xC0, 0x00, 
				 0x00, 0x1E, 0x01, 0x56, 0x14, 0x00, 0x00, 0x1F, 
				 0x01, 0x00, 0x19, 0xEA, 0x00, 0x12, 0x07, 0x04, 
				 0x1E, 0x00, 0xC0, 0x00, 0x00, 0x00, 0x1E, 0x01, 
				 0x0A, 0x00, 0x00, 0x00, 0x18, 0x07, 0x04, 0x13, 
				 0xC4, 0x02, 0x1E, 0x00, 0x3F, 0xC0, 0x00, 0x00, 
				 0x1E, 0x01, 0xC0, 0x0A, 0x00, 0x00, 0x1F, 0x01, 
				 0x00, 0x19, 0xC4, 0x02, 0x13, 0xEA, 0x00, 0x1E, 
				 0x00, 0xC0, 0xFF, 0x00, 0x00, 0x1E, 0x01, 0x14, 
				 0x00, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 0xEA, 
				 0x00, 0x16, 0x02, 0x04, 0x00, 0x68, 0x13, 0xC0, 
				 0x00, 0x1E, 0x01, 0x00, 0x34, 0x00, 0x00, 0x19, 
				 0xC0, 0x00, 0x17, 0x4C, 0x00, 0x40, 0x00, 0x00, 
				 0x00, 0x17, 0x6C, 0x00, 0x32, 0x00, 0x00, 0x00, 
				 0x13, 0xEA, 0x00, 0x1E, 0x00, 0xFF, 0xC0, 0x00, 
				 0x00, 0x1E, 0x01, 0x00, 0x14, 0x00, 0x00, 0x1F, 
				 0x01, 0x00, 0x19, 0xEA, 0x00, 0x00, 0x00};

BYTE t5465_Mode_800x600x32_1[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x16, 0x05, 0x04, 0x00, 0x00, 0x16, 0xC0, 0x00, 
				 0x00, 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 
				 0x00, 0x1F, 0x01, 0x00, 0x18, 0xC5, 0x02, 0x18, 
				 0x07, 0x04, 0x15, 0xA0, 0x00, 0xFF, 0x00, 0x09, 
				 0xCE, 0x03, 0x06, 0x05, 0x09, 0xCE, 0x03, 0x09, 
				 0x00, 0x09, 0xCE, 0x03, 0x0A, 0x00, 0x09, 0xCE, 
				 0x03, 0x0B, 0x00, 0x16, 0x80, 0x00, 0x2F, 0x00, 
				 0x16, 0x84, 0x00, 0x33, 0x00, 0x16, 0x88, 0x00, 
				 0x7E, 0x00, 0x1D, 0x19, 0x00, 0x00, 0x00, 0x7B, 
				 0x00, 0x00, 0x00, 0x63, 0x00, 0x00, 0x00, 0x64, 
				 0x00, 0x00, 0x00, 0x9B, 0x00, 0x00, 0x00, 0x68, 
				 0x00, 0x00, 0x00, 0x91, 0x00, 0x00, 0x00, 0x6F, 
				 0x00, 0x00, 0x00, 0xF0, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x60, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x58, 
				 0x00, 0x00, 0x00, 0x8A, 0x00, 0x00, 0x00, 0x57, 
				 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x58, 0x00, 0x00, 0x00, 0x6F, 
				 0x00, 0x00, 0x00, 0xE3, 0x00, 0x00, 0x00, 0xFF, 
				 0x00, 0x00, 0x00, 0x1D, 0x06, 0x00, 0x64, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x90, 0x00, 0x00, 0x00, 
				 0x22, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x13, 0xEA, 0x00, 0x1E, 0x00, 0x00, 0xC0, 0x00, 
				 0x00, 0x1E, 0x01, 0x59, 0x1A, 0x00, 0x00, 0x1F, 
				 0x01, 0x00, 0x19, 0xEA, 0x00, 0x12, 0x07, 0x04, 
				 0x1E, 0x00, 0xC0, 0x00, 0x00, 0x00, 0x1E, 0x01, 
				 0x0D, 0x00, 0x00, 0x00, 0x18, 0x07, 0x04, 0x13, 
				 0xC4, 0x02, 0x1E, 0x00, 0x3F, 0xC0, 0x00, 0x00, 
				 0x1E, 0x01, 0xC0, 0x0D, 0x00, 0x00, 0x1F, 0x01, 
				 0x00, 0x19, 0xC4, 0x02, 0x13, 0xEA, 0x00, 0x1E, 
				 0x00, 0xC0, 0xFF, 0x00, 0x00, 0x1E, 0x01, 0x1D, 
				 0x00, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 0xEA, 
				 0x00, 0x16, 0x02, 0x04, 0x00, 0x68, 0x13, 0xC0, 
				 0x00, 0x1E, 0x01, 0x00, 0x34, 0x00, 0x00, 0x19, 
				 0xC0, 0x00, 0x17, 0x4C, 0x00, 0xA0, 0x00, 0x00, 
				 0x00, 0x17, 0x6C, 0x00, 0x32, 0x00, 0x00, 0x00, 
				 0x13, 0xEA, 0x00, 0x1E, 0x00, 0xFF, 0xC0, 0x00, 
				 0x00, 0x1E, 0x01, 0x00, 0x19, 0x00, 0x00, 0x1F, 
				 0x01, 0x00, 0x19, 0xEA, 0x00, 0x00, 0x00};

BYTE t5465_Mode_800x600x32_2[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x16, 0x05, 0x04, 0x00, 0x00, 0x16, 0xC0, 0x00, 
				 0x00, 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 
				 0x00, 0x1F, 0x01, 0x00, 0x18, 0xC5, 0x02, 0x18, 
				 0x07, 0x04, 0x15, 0xA0, 0x00, 0xFF, 0x00, 0x09, 
				 0xCE, 0x03, 0x06, 0x05, 0x09, 0xCE, 0x03, 0x09, 
				 0x00, 0x09, 0xCE, 0x03, 0x0A, 0x00, 0x09, 0xCE, 
				 0x03, 0x0B, 0x00, 0x16, 0x80, 0x00, 0x2F, 0x00, 
				 0x16, 0x84, 0x00, 0x23, 0x00, 0x16, 0x88, 0x00, 
				 0x5F, 0x00, 0x1D, 0x19, 0x00, 0x00, 0x00, 0x7F, 
				 0x00, 0x00, 0x00, 0x63, 0x00, 0x00, 0x00, 0x64, 
				 0x00, 0x00, 0x00, 0x9F, 0x00, 0x00, 0x00, 0x6A, 
				 0x00, 0x00, 0x00, 0x9A, 0x00, 0x00, 0x00, 0x72, 
				 0x00, 0x00, 0x00, 0xF0, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x60, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x58, 
				 0x00, 0x00, 0x00, 0x8C, 0x00, 0x00, 0x00, 0x57, 
				 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x58, 0x00, 0x00, 0x00, 0x70, 
				 0x00, 0x00, 0x00, 0xE3, 0x00, 0x00, 0x00, 0xFF, 
				 0x00, 0x00, 0x00, 0x1D, 0x06, 0x00, 0x64, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x90, 0x00, 0x00, 0x00, 
				 0x22, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x13, 0xEA, 0x00, 0x1E, 0x00, 0x00, 0xC0, 0x00, 
				 0x00, 0x1E, 0x01, 0x59, 0x1A, 0x00, 0x00, 0x1F, 
				 0x01, 0x00, 0x19, 0xEA, 0x00, 0x12, 0x07, 0x04, 
				 0x1E, 0x00, 0xC0, 0x00, 0x00, 0x00, 0x1E, 0x01, 
				 0x0D, 0x00, 0x00, 0x00, 0x18, 0x07, 0x04, 0x13, 
				 0xC4, 0x02, 0x1E, 0x00, 0x3F, 0xC0, 0x00, 0x00, 
				 0x1E, 0x01, 0xC0, 0x0D, 0x00, 0x00, 0x1F, 0x01, 
				 0x00, 0x19, 0xC4, 0x02, 0x13, 0xEA, 0x00, 0x1E, 
				 0x00, 0xC0, 0xFF, 0x00, 0x00, 0x1E, 0x01, 0x1D, 
				 0x00, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 0xEA, 
				 0x00, 0x16, 0x02, 0x04, 0x00, 0x68, 0x13, 0xC0, 
				 0x00, 0x1E, 0x01, 0x00, 0x34, 0x00, 0x00, 0x19, 
				 0xC0, 0x00, 0x17, 0x4C, 0x00, 0xA0, 0x00, 0x00, 
				 0x00, 0x17, 0x6C, 0x00, 0x32, 0x00, 0x00, 0x00, 
				 0x13, 0xEA, 0x00, 0x1E, 0x00, 0xFF, 0xC0, 0x00, 
				 0x00, 0x1E, 0x01, 0x00, 0x19, 0x00, 0x00, 0x1F, 
				 0x01, 0x00, 0x19, 0xEA, 0x00, 0x00, 0x00};

BYTE t5465_Mode_800x600x32_3[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x16, 0x05, 0x04, 0x00, 0x00, 0x16, 0xC0, 0x00, 
				 0x00, 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 
				 0x00, 0x1F, 0x01, 0x00, 0x18, 0xC5, 0x02, 0x18, 
				 0x07, 0x04, 0x15, 0xA0, 0x00, 0xFF, 0x00, 0x09, 
				 0xCE, 0x03, 0x06, 0x05, 0x09, 0xCE, 0x03, 0x09, 
				 0x00, 0x09, 0xCE, 0x03, 0x0A, 0x00, 0x09, 0xCE, 
				 0x03, 0x0B, 0x00, 0x16, 0x80, 0x00, 0x2F, 0x00, 
				 0x16, 0x84, 0x00, 0x25, 0x00, 0x16, 0x88, 0x00, 
				 0x7D, 0x00, 0x1D, 0x19, 0x00, 0x00, 0x00, 0x7D, 
				 0x00, 0x00, 0x00, 0x63, 0x00, 0x00, 0x00, 0x64, 
				 0x00, 0x00, 0x00, 0x9D, 0x00, 0x00, 0x00, 0x6C, 
				 0x00, 0x00, 0x00, 0x9B, 0x00, 0x00, 0x00, 0x97, 
				 0x00, 0x00, 0x00, 0xF0, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x60, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7C, 
				 0x00, 0x00, 0x00, 0x82, 0x00, 0x00, 0x00, 0x57, 
				 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x5F, 0x00, 0x00, 0x00, 0x97, 
				 0x00, 0x00, 0x00, 0xE3, 0x00, 0x00, 0x00, 0xFF, 
				 0x00, 0x00, 0x00, 0x1D, 0x06, 0x00, 0x64, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x90, 0x00, 0x00, 0x00, 
				 0x22, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x13, 0xEA, 0x00, 0x1E, 0x00, 0x00, 0xC0, 0x00, 
				 0x00, 0x1E, 0x01, 0x59, 0x1A, 0x00, 0x00, 0x1F, 
				 0x01, 0x00, 0x19, 0xEA, 0x00, 0x12, 0x07, 0x04, 
				 0x1E, 0x00, 0xC0, 0x00, 0x00, 0x00, 0x1E, 0x01, 
				 0x0D, 0x00, 0x00, 0x00, 0x18, 0x07, 0x04, 0x13, 
				 0xC4, 0x02, 0x1E, 0x00, 0x3F, 0xC0, 0x00, 0x00, 
				 0x1E, 0x01, 0xC0, 0x0D, 0x00, 0x00, 0x1F, 0x01, 
				 0x00, 0x19, 0xC4, 0x02, 0x13, 0xEA, 0x00, 0x1E, 
				 0x00, 0xC0, 0xFF, 0x00, 0x00, 0x1E, 0x01, 0x1D, 
				 0x00, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 0xEA, 
				 0x00, 0x16, 0x02, 0x04, 0x00, 0x68, 0x13, 0xC0, 
				 0x00, 0x1E, 0x01, 0x00, 0x34, 0x00, 0x00, 0x19, 
				 0xC0, 0x00, 0x17, 0x4C, 0x00, 0xA0, 0x00, 0x00, 
				 0x00, 0x17, 0x6C, 0x00, 0x32, 0x00, 0x00, 0x00, 
				 0x13, 0xEA, 0x00, 0x1E, 0x00, 0xFF, 0xC0, 0x00, 
				 0x00, 0x1E, 0x01, 0x00, 0x19, 0x00, 0x00, 0x1F, 
				 0x01, 0x00, 0x19, 0xEA, 0x00, 0x00, 0x00};

BYTE t5465_Mode_800x600x32_4[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x16, 0x05, 0x04, 0x00, 0x00, 0x16, 0xC0, 0x00, 
				 0x00, 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 
				 0x00, 0x1F, 0x01, 0x00, 0x18, 0xC5, 0x02, 0x18, 
				 0x07, 0x04, 0x15, 0xA0, 0x00, 0xFF, 0x00, 0x09, 
				 0xCE, 0x03, 0x06, 0x05, 0x09, 0xCE, 0x03, 0x09, 
				 0x00, 0x09, 0xCE, 0x03, 0x0A, 0x00, 0x09, 0xCE, 
				 0x03, 0x0B, 0x00, 0x16, 0x80, 0x00, 0x2F, 0x00, 
				 0x16, 0x84, 0x00, 0x19, 0x00, 0x16, 0x88, 0x00, 
				 0x53, 0x00, 0x1D, 0x19, 0x00, 0x00, 0x00, 0x7F, 
				 0x00, 0x00, 0x00, 0x63, 0x00, 0x00, 0x00, 0x64, 
				 0x00, 0x00, 0x00, 0x9F, 0x00, 0x00, 0x00, 0x67, 
				 0x00, 0x00, 0x00, 0x91, 0x00, 0x00, 0x00, 0x6F, 
				 0x00, 0x00, 0x00, 0xF0, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x60, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x58, 
				 0x00, 0x00, 0x00, 0x8B, 0x00, 0x00, 0x00, 0x57, 
				 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x57, 0x00, 0x00, 0x00, 0x6F, 
				 0x00, 0x00, 0x00, 0xE3, 0x00, 0x00, 0x00, 0xFF, 
				 0x00, 0x00, 0x00, 0x1D, 0x06, 0x00, 0x64, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x90, 0x00, 0x00, 0x00, 
				 0x22, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x13, 0xEA, 0x00, 0x1E, 0x00, 0x00, 0xC0, 0x00, 
				 0x00, 0x1E, 0x01, 0x59, 0x1A, 0x00, 0x00, 0x1F, 
				 0x01, 0x00, 0x19, 0xEA, 0x00, 0x12, 0x07, 0x04, 
				 0x1E, 0x00, 0xC0, 0x00, 0x00, 0x00, 0x1E, 0x01, 
				 0x0D, 0x00, 0x00, 0x00, 0x18, 0x07, 0x04, 0x13, 
				 0xC4, 0x02, 0x1E, 0x00, 0x3F, 0xC0, 0x00, 0x00, 
				 0x1E, 0x01, 0xC0, 0x0D, 0x00, 0x00, 0x1F, 0x01, 
				 0x00, 0x19, 0xC4, 0x02, 0x13, 0xEA, 0x00, 0x1E, 
				 0x00, 0xC0, 0xFF, 0x00, 0x00, 0x1E, 0x01, 0x1D, 
				 0x00, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 0xEA, 
				 0x00, 0x16, 0x02, 0x04, 0x00, 0x68, 0x13, 0xC0, 
				 0x00, 0x1E, 0x01, 0x00, 0x34, 0x00, 0x00, 0x19, 
				 0xC0, 0x00, 0x17, 0x4C, 0x00, 0xA0, 0x00, 0x00, 
				 0x00, 0x17, 0x6C, 0x00, 0x32, 0x00, 0x00, 0x00, 
				 0x13, 0xEA, 0x00, 0x1E, 0x00, 0xFF, 0xC0, 0x00, 
				 0x00, 0x1E, 0x01, 0x00, 0x19, 0x00, 0x00, 0x1F, 
				 0x01, 0x00, 0x19, 0xEA, 0x00, 0x00, 0x00};

BYTE t5465_Mode_800x600x32_5[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x16, 0x05, 0x04, 0x00, 0x00, 0x16, 0xC0, 0x00, 
				 0x00, 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 
				 0x00, 0x1F, 0x01, 0x00, 0x18, 0xC5, 0x02, 0x18, 
				 0x07, 0x04, 0x15, 0xA0, 0x00, 0xFF, 0x00, 0x09, 
				 0xCE, 0x03, 0x06, 0x05, 0x09, 0xCE, 0x03, 0x09, 
				 0x00, 0x09, 0xCE, 0x03, 0x0A, 0x00, 0x09, 0xCE, 
				 0x03, 0x0B, 0x00, 0x16, 0x80, 0x00, 0x2F, 0x00, 
				 0x16, 0x84, 0x00, 0x1C, 0x00, 0x16, 0x88, 0x00, 
				 0x37, 0x00, 0x1D, 0x19, 0x00, 0x00, 0x00, 0x7E, 
				 0x00, 0x00, 0x00, 0x63, 0x00, 0x00, 0x00, 0x64, 
				 0x00, 0x00, 0x00, 0x9E, 0x00, 0x00, 0x00, 0x69, 
				 0x00, 0x00, 0x00, 0x91, 0x00, 0x00, 0x00, 0x75, 
				 0x00, 0x00, 0x00, 0xF0, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x60, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x58, 
				 0x00, 0x00, 0x00, 0x8B, 0x00, 0x00, 0x00, 0x57, 
				 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x57, 0x00, 0x00, 0x00, 0x75, 
				 0x00, 0x00, 0x00, 0xE3, 0x00, 0x00, 0x00, 0xFF, 
				 0x00, 0x00, 0x00, 0x1D, 0x06, 0x00, 0x64, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x90, 0x00, 0x00, 0x00, 
				 0x22, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x13, 0xEA, 0x00, 0x1E, 0x00, 0x00, 0xC0, 0x00, 
				 0x00, 0x1E, 0x01, 0x59, 0x1A, 0x00, 0x00, 0x1F, 
				 0x01, 0x00, 0x19, 0xEA, 0x00, 0x12, 0x07, 0x04, 
				 0x1E, 0x00, 0xC0, 0x00, 0x00, 0x00, 0x1E, 0x01, 
				 0x0D, 0x00, 0x00, 0x00, 0x18, 0x07, 0x04, 0x13, 
				 0xC4, 0x02, 0x1E, 0x00, 0x3F, 0xC0, 0x00, 0x00, 
				 0x1E, 0x01, 0xC0, 0x0D, 0x00, 0x00, 0x1F, 0x01, 
				 0x00, 0x19, 0xC4, 0x02, 0x13, 0xEA, 0x00, 0x1E, 
				 0x00, 0xC0, 0xFF, 0x00, 0x00, 0x1E, 0x01, 0x1F, 
				 0x00, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 0xEA, 
				 0x00, 0x16, 0x02, 0x04, 0x00, 0x68, 0x13, 0xC0, 
				 0x00, 0x1E, 0x01, 0x00, 0x34, 0x00, 0x00, 0x19, 
				 0xC0, 0x00, 0x17, 0x4C, 0x00, 0xA0, 0x00, 0x00, 
				 0x00, 0x17, 0x6C, 0x00, 0x32, 0x00, 0x00, 0x00, 
				 0x13, 0xEA, 0x00, 0x1E, 0x00, 0xFF, 0xC0, 0x00, 
				 0x00, 0x1E, 0x01, 0x00, 0x19, 0x00, 0x00, 0x1F, 
				 0x01, 0x00, 0x19, 0xEA, 0x00, 0x00, 0x00};

BYTE t5465_Mode_1024x768x32_1[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x16, 0x05, 0x04, 0x00, 0x00, 0x16, 0xC0, 0x00, 
				 0x00, 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 
				 0x00, 0x1F, 0x01, 0x00, 0x18, 0xC5, 0x02, 0x18, 
				 0x07, 0x04, 0x15, 0xA0, 0x00, 0xFF, 0x00, 0x09, 
				 0xCE, 0x03, 0x06, 0x05, 0x09, 0xCE, 0x03, 0x09, 
				 0x00, 0x09, 0xCE, 0x03, 0x0A, 0x00, 0x09, 0xCE, 
				 0x03, 0x0B, 0x00, 0x16, 0x80, 0x00, 0x2F, 0x00, 
				 0x16, 0x84, 0x00, 0x17, 0x00, 0x16, 0x88, 0x00, 
				 0x45, 0x00, 0x1D, 0x19, 0x00, 0x00, 0x00, 0x99, 
				 0x00, 0x00, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x80, 
				 0x00, 0x00, 0x00, 0x99, 0x00, 0x00, 0x00, 0x82, 
				 0x00, 0x00, 0x00, 0x18, 0x00, 0x00, 0x00, 0x96, 
				 0x00, 0x00, 0x00, 0x1F, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7F, 
				 0x00, 0x00, 0x00, 0x83, 0x00, 0x00, 0x00, 0x7F, 
				 0x00, 0x00, 0x00, 0xA0, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x96, 
				 0x00, 0x00, 0x00, 0xE3, 0x00, 0x00, 0x00, 0xFF, 
				 0x00, 0x00, 0x00, 0x1D, 0x06, 0x00, 0x64, 0x00, 
				 0x48, 0x00, 0x00, 0x00, 0x51, 0x00, 0x00, 0x00, 
				 0x22, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x13, 0xEA, 0x00, 0x1E, 0x00, 0x00, 0xC0, 0x00, 
				 0x00, 0x1E, 0x01, 0x21, 0x20, 0x00, 0x00, 0x1F, 
				 0x01, 0x00, 0x19, 0xEA, 0x00, 0x12, 0x07, 0x04, 
				 0x1E, 0x00, 0xC0, 0x00, 0x00, 0x00, 0x1E, 0x01, 
				 0x10, 0x00, 0x00, 0x00, 0x18, 0x07, 0x04, 0x13, 
				 0xC4, 0x02, 0x1E, 0x00, 0x3F, 0xC0, 0x00, 0x00, 
				 0x1E, 0x01, 0xC0, 0x10, 0x00, 0x00, 0x1F, 0x01, 
				 0x00, 0x19, 0xC4, 0x02, 0x16, 0x02, 0x04, 0x00, 
				 0x68, 0x13, 0xC0, 0x00, 0x1E, 0x01, 0x00, 0x34, 
				 0x00, 0x00, 0x19, 0xC0, 0x00, 0x17, 0x4C, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x17, 0x74, 0x00, 0x01, 
				 0x00, 0x00, 0x00, 0x13, 0xEA, 0x00, 0x1E, 0x00, 
				 0xFF, 0xC0, 0x00, 0x00, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 0xEA, 0x00, 
				 0x00, 0xEA};

BYTE t5465_Mode_1024x768x32_2[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x16, 0x05, 0x04, 0x00, 0x00, 0x16, 0xC0, 0x00, 
				 0x00, 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 
				 0x00, 0x1F, 0x01, 0x00, 0x18, 0xC5, 0x02, 0x18, 
				 0x07, 0x04, 0x15, 0xA0, 0x00, 0xFF, 0x00, 0x09, 
				 0xCE, 0x03, 0x06, 0x05, 0x09, 0xCE, 0x03, 0x09, 
				 0x00, 0x09, 0xCE, 0x03, 0x0A, 0x00, 0x09, 0xCE, 
				 0x03, 0x0B, 0x00, 0x16, 0x80, 0x00, 0xEF, 0x00, 
				 0x16, 0x84, 0x00, 0x1A, 0x00, 0x16, 0x88, 0x00, 
				 0x3B, 0x00, 0x1D, 0x19, 0x00, 0x00, 0x00, 0xA3, 
				 0x00, 0x00, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x80, 
				 0x00, 0x00, 0x00, 0x83, 0x00, 0x00, 0x00, 0x84, 
				 0x00, 0x00, 0x00, 0x95, 0x00, 0x00, 0x00, 0x24, 
				 0x00, 0x00, 0x00, 0xFD, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x60, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 
				 0x00, 0x00, 0x00, 0x88, 0x00, 0x00, 0x00, 0xFF, 
				 0x00, 0x00, 0x00, 0xA0, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x24, 
				 0x00, 0x00, 0x00, 0xE3, 0x00, 0x00, 0x00, 0xFF, 
				 0x00, 0x00, 0x00, 0x1D, 0x06, 0x00, 0x64, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0xE0, 0x00, 0x00, 0x00, 
				 0x22, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x13, 0xEA, 0x00, 0x1E, 0x00, 0x00, 0xC0, 0x00, 
				 0x00, 0x1E, 0x01, 0x21, 0x20, 0x00, 0x00, 0x1F, 
				 0x01, 0x00, 0x19, 0xEA, 0x00, 0x12, 0x07, 0x04, 
				 0x1E, 0x00, 0xC0, 0x00, 0x00, 0x00, 0x1E, 0x01, 
				 0x10, 0x00, 0x00, 0x00, 0x18, 0x07, 0x04, 0x13, 
				 0xC4, 0x02, 0x1E, 0x00, 0x3F, 0xC0, 0x00, 0x00, 
				 0x1E, 0x01, 0xC0, 0x10, 0x00, 0x00, 0x1F, 0x01, 
				 0x00, 0x19, 0xC4, 0x02, 0x13, 0xEA, 0x00, 0x1E, 
				 0x00, 0xC0, 0xFF, 0x00, 0x00, 0x1E, 0x01, 0x23, 
				 0x00, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 0xEA, 
				 0x00, 0x16, 0x02, 0x04, 0x00, 0x68, 0x13, 0xC0, 
				 0x00, 0x1E, 0x01, 0x00, 0x34, 0x00, 0x00, 0x19, 
				 0xC0, 0x00, 0x17, 0x4C, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x17, 0x74, 0x00, 0x01, 0x00, 0x00, 0x00, 
				 0x13, 0xEA, 0x00, 0x1E, 0x00, 0xFF, 0xC0, 0x00, 
				 0x00, 0x1E, 0x01, 0x00, 0x20, 0x00, 0x00, 0x1F, 
				 0x01, 0x00, 0x19, 0xEA, 0x00, 0x00, 0x00};

BYTE t5465_Mode_1024x768x32_3[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x16, 0x05, 0x04, 0x00, 0x00, 0x16, 0xC0, 0x00, 
				 0x00, 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 
				 0x00, 0x1F, 0x01, 0x00, 0x18, 0xC5, 0x02, 0x18, 
				 0x07, 0x04, 0x15, 0xA0, 0x00, 0xFF, 0x00, 0x09, 
				 0xCE, 0x03, 0x06, 0x05, 0x09, 0xCE, 0x03, 0x09, 
				 0x00, 0x09, 0xCE, 0x03, 0x0A, 0x00, 0x09, 0xCE, 
				 0x03, 0x0B, 0x00, 0x16, 0x80, 0x00, 0xEF, 0x00, 
				 0x16, 0x84, 0x00, 0x2A, 0x00, 0x16, 0x88, 0x00, 
				 0x6E, 0x00, 0x1D, 0x19, 0x00, 0x00, 0x00, 0xA1, 
				 0x00, 0x00, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x80, 
				 0x00, 0x00, 0x00, 0x81, 0x00, 0x00, 0x00, 0x84, 
				 0x00, 0x00, 0x00, 0x95, 0x00, 0x00, 0x00, 0x24, 
				 0x00, 0x00, 0x00, 0xFD, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x60, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 
				 0x00, 0x00, 0x00, 0x88, 0x00, 0x00, 0x00, 0xFF, 
				 0x00, 0x00, 0x00, 0xA0, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x24, 
				 0x00, 0x00, 0x00, 0xE3, 0x00, 0x00, 0x00, 0xFF, 
				 0x00, 0x00, 0x00, 0x1D, 0x06, 0x00, 0x64, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0xE0, 0x00, 0x00, 0x00, 
				 0x22, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x13, 0xEA, 0x00, 0x1E, 0x00, 0x00, 0xC0, 0x00, 
				 0x00, 0x1E, 0x01, 0x21, 0x20, 0x00, 0x00, 0x1F, 
				 0x01, 0x00, 0x19, 0xEA, 0x00, 0x12, 0x07, 0x04, 
				 0x1E, 0x00, 0xC0, 0x00, 0x00, 0x00, 0x1E, 0x01, 
				 0x10, 0x00, 0x00, 0x00, 0x18, 0x07, 0x04, 0x13, 
				 0xC4, 0x02, 0x1E, 0x00, 0x3F, 0xC0, 0x00, 0x00, 
				 0x1E, 0x01, 0xC0, 0x10, 0x00, 0x00, 0x1F, 0x01, 
				 0x00, 0x19, 0xC4, 0x02, 0x13, 0xEA, 0x00, 0x1E, 
				 0x00, 0xC0, 0xFF, 0x00, 0x00, 0x1E, 0x01, 0x29, 
				 0x00, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 0xEA, 
				 0x00, 0x16, 0x02, 0x04, 0x00, 0x68, 0x13, 0xC0, 
				 0x00, 0x1E, 0x01, 0x00, 0x34, 0x00, 0x00, 0x19, 
				 0xC0, 0x00, 0x17, 0x4C, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x17, 0x74, 0x00, 0x01, 0x00, 0x00, 0x00, 
				 0x13, 0xEA, 0x00, 0x1E, 0x00, 0xFF, 0xC0, 0x00, 
				 0x00, 0x1E, 0x01, 0x00, 0x20, 0x00, 0x00, 0x1F, 
				 0x01, 0x00, 0x19, 0xEA, 0x00, 0x00, 0x00};

BYTE t5465_Mode_1024x768x32_4[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x16, 0x05, 0x04, 0x00, 0x00, 0x16, 0xC0, 0x00, 
				 0x00, 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 
				 0x00, 0x1F, 0x01, 0x00, 0x18, 0xC5, 0x02, 0x18, 
				 0x07, 0x04, 0x15, 0xA0, 0x00, 0xFF, 0x00, 0x09, 
				 0xCE, 0x03, 0x06, 0x05, 0x09, 0xCE, 0x03, 0x09, 
				 0x00, 0x09, 0xCE, 0x03, 0x0A, 0x00, 0x09, 0xCE, 
				 0x03, 0x0B, 0x00, 0x16, 0x80, 0x00, 0x2F, 0x00, 
				 0x16, 0x84, 0x00, 0x10, 0x00, 0x16, 0x88, 0x00, 
				 0x2C, 0x00, 0x1D, 0x19, 0x00, 0x00, 0x00, 0x9F, 
				 0x00, 0x00, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x80, 
				 0x00, 0x00, 0x00, 0x9F, 0x00, 0x00, 0x00, 0x83, 
				 0x00, 0x00, 0x00, 0x0F, 0x00, 0x00, 0x00, 0x1E, 
				 0x00, 0x00, 0x00, 0xF5, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x60, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x83, 0x00, 0x00, 0x00, 0xFF, 
				 0x00, 0x00, 0x00, 0xA0, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 0x1E, 
				 0x00, 0x00, 0x00, 0xE3, 0x00, 0x00, 0x00, 0xFF, 
				 0x00, 0x00, 0x00, 0x1D, 0x06, 0x00, 0x64, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0xE0, 0x00, 0x00, 0x00, 
				 0x22, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x13, 0xEA, 0x00, 0x1E, 0x00, 0x00, 0xC0, 0x00, 
				 0x00, 0x1E, 0x01, 0x21, 0x20, 0x00, 0x00, 0x1F, 
				 0x01, 0x00, 0x19, 0xEA, 0x00, 0x12, 0x07, 0x04, 
				 0x1E, 0x00, 0xC0, 0x00, 0x00, 0x00, 0x1E, 0x01, 
				 0x10, 0x00, 0x00, 0x00, 0x18, 0x07, 0x04, 0x13, 
				 0xC4, 0x02, 0x1E, 0x00, 0x3F, 0xC0, 0x00, 0x00, 
				 0x1E, 0x01, 0xC0, 0x10, 0x00, 0x00, 0x1F, 0x01, 
				 0x00, 0x19, 0xC4, 0x02, 0x13, 0xEA, 0x00, 0x1E, 
				 0x00, 0xC0, 0xFF, 0x00, 0x00, 0x1E, 0x01, 0x2B, 
				 0x00, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 0xEA, 
				 0x00, 0x16, 0x02, 0x04, 0x00, 0x68, 0x13, 0xC0, 
				 0x00, 0x1E, 0x01, 0x00, 0x34, 0x00, 0x00, 0x19, 
				 0xC0, 0x00, 0x17, 0x4C, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x17, 0x74, 0x00, 0x01, 0x00, 0x00, 0x00, 
				 0x13, 0xEA, 0x00, 0x1E, 0x00, 0xFF, 0xC0, 0x00, 
				 0x00, 0x1E, 0x01, 0x00, 0x20, 0x00, 0x00, 0x1F, 
				 0x01, 0x00, 0x19, 0xEA, 0x00, 0x00, 0x00};

BYTE t5465_Mode_1024x768x32_5[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x16, 0x05, 0x04, 0x00, 0x00, 0x16, 0xC0, 0x00, 
				 0x00, 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 
				 0x00, 0x1F, 0x01, 0x00, 0x18, 0xC5, 0x02, 0x18, 
				 0x07, 0x04, 0x15, 0xA0, 0x00, 0xFF, 0x00, 0x09, 
				 0xCE, 0x03, 0x06, 0x05, 0x09, 0xCE, 0x03, 0x09, 
				 0x00, 0x09, 0xCE, 0x03, 0x0A, 0x00, 0x09, 0xCE, 
				 0x03, 0x0B, 0x00, 0x16, 0x80, 0x00, 0x2F, 0x00, 
				 0x16, 0x84, 0x00, 0x0A, 0x00, 0x16, 0x88, 0x00, 
				 0x21, 0x00, 0x1D, 0x19, 0x00, 0x00, 0x00, 0xA7, 
				 0x00, 0x00, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x80, 
				 0x00, 0x00, 0x00, 0x87, 0x00, 0x00, 0x00, 0x87, 
				 0x00, 0x00, 0x00, 0x93, 0x00, 0x00, 0x00, 0x26, 
				 0x00, 0x00, 0x00, 0xF5, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x60, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x83, 0x00, 0x00, 0x00, 0xFF, 
				 0x00, 0x00, 0x00, 0xA0, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 0x26, 
				 0x00, 0x00, 0x00, 0xE3, 0x00, 0x00, 0x00, 0xFF, 
				 0x00, 0x00, 0x00, 0x1D, 0x06, 0x00, 0x64, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0xE0, 0x00, 0x00, 0x00, 
				 0x22, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x13, 0xEA, 0x00, 0x1E, 0x00, 0x00, 0xC0, 0x00, 
				 0x00, 0x1E, 0x01, 0x21, 0x20, 0x00, 0x00, 0x1F, 
				 0x01, 0x00, 0x19, 0xEA, 0x00, 0x12, 0x07, 0x04, 
				 0x1E, 0x00, 0xC0, 0x00, 0x00, 0x00, 0x1E, 0x01, 
				 0x10, 0x00, 0x00, 0x00, 0x18, 0x07, 0x04, 0x13, 
				 0xC4, 0x02, 0x1E, 0x00, 0x3F, 0xC0, 0x00, 0x00, 
				 0x1E, 0x01, 0xC0, 0x10, 0x00, 0x00, 0x1F, 0x01, 
				 0x00, 0x19, 0xC4, 0x02, 0x13, 0xEA, 0x00, 0x1E, 
				 0x00, 0x00, 0xC0, 0x00, 0x00, 0x1E, 0x01, 0x75, 
				 0x20, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 0xEA, 
				 0x00, 0x16, 0x02, 0x04, 0x00, 0x68, 0x13, 0xC0, 
				 0x00, 0x1E, 0x01, 0x00, 0x34, 0x00, 0x00, 0x19, 
				 0xC0, 0x00, 0x17, 0x4C, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x17, 0x74, 0x00, 0x01, 0x00, 0x00, 0x00, 
				 0x13, 0xEA, 0x00, 0x1E, 0x00, 0xFF, 0xC0, 0x00, 
				 0x00, 0x1E, 0x01, 0x00, 0x20, 0x00, 0x00, 0x1F, 
				 0x01, 0x00, 0x19, 0xEA, 0x00, 0x00, 0x00};

BYTE t5465AD_Mode_1600x1200x8_6[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x16, 0x05, 0x04, 0x00, 0x00, 0x16, 0xC0, 0x00, 
				 0x00, 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 
				 0x00, 0x1F, 0x01, 0x00, 0x18, 0xC5, 0x02, 0x18, 
				 0x07, 0x04, 0x15, 0xA0, 0x00, 0xFF, 0x00, 0x09, 
				 0xCE, 0x03, 0x06, 0x05, 0x09, 0xCE, 0x03, 0x09, 
				 0x00, 0x09, 0xCE, 0x03, 0x0A, 0x00, 0x09, 0xCE, 
				 0x03, 0x0B, 0x00, 0x16, 0x80, 0x00, 0x2F, 0x00, 
				 0x16, 0x84, 0x00, 0x10, 0x00, 0x16, 0x88, 0x00, 
				 0x79, 0x00, 0x1D, 0x19, 0x00, 0x00, 0x00, 0x09, 
				 0x00, 0x00, 0x00, 0xC7, 0x00, 0x00, 0x00, 0xC7, 
				 0x00, 0x00, 0x00, 0x89, 0x00, 0x00, 0x00, 0xD0, 
				 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0xE0, 
				 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xB0, 
				 0x00, 0x00, 0x00, 0x83, 0x00, 0x00, 0x00, 0xAF, 
				 0x00, 0x00, 0x00, 0xD0, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0xAF, 0x00, 0x00, 0x00, 0xE0, 
				 0x00, 0x00, 0x00, 0xE3, 0x00, 0x00, 0x00, 0xFF, 
				 0x00, 0x00, 0x00, 0x1D, 0x06, 0x00, 0x64, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x22, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x8F, 0x00, 0x00, 0x00, 
				 0x13, 0xEA, 0x00, 0x1E, 0x00, 0x00, 0xC0, 0x00, 
				 0x00, 0x1E, 0x01, 0x12, 0x0D, 0x00, 0x00, 0x1F, 
				 0x01, 0x00, 0x19, 0xEA, 0x00, 0x12, 0x07, 0x04, 
				 0x1E, 0x00, 0xC0, 0x00, 0x00, 0x00, 0x1E, 0x01, 
				 0x0D, 0x00, 0x00, 0x00, 0x18, 0x07, 0x04, 0x13, 
				 0xC4, 0x02, 0x1E, 0x00, 0x3F, 0xC0, 0x00, 0x00, 
				 0x1E, 0x01, 0x80, 0x0D, 0x00, 0x00, 0x1F, 0x01, 
				 0x00, 0x19, 0xC4, 0x02, 0x13, 0xEA, 0x00, 0x1E, 
				 0x00, 0xC0, 0xFF, 0x00, 0x00, 0x1E, 0x01, 0x20, 
				 0x00, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 0xEA, 
				 0x00, 0x16, 0x02, 0x04, 0x00, 0x00, 0x13, 0xC0, 
				 0x00, 0x1E, 0x01, 0x00, 0x00, 0x00, 0x00, 0x19, 
				 0xC0, 0x00, 0x13, 0xEA, 0x00, 0x1E, 0x00, 0xFF, 
				 0xC0, 0x00, 0x00, 0x1E, 0x01, 0x00, 0x0D, 0x00, 
				 0x00, 0x1F, 0x01, 0x00, 0x19, 0xEA, 0x00, 0x00, 0x00};

BYTE t5465AD_Mode_1600x1200x8_7[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x16, 0x05, 0x04, 0x00, 0x00, 0x16, 0xC0, 0x00, 
				 0x00, 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 
				 0x00, 0x1F, 0x01, 0x00, 0x18, 0xC5, 0x02, 0x18, 
				 0x07, 0x04, 0x15, 0xA0, 0x00, 0xFF, 0x00, 0x09, 
				 0xCE, 0x03, 0x06, 0x05, 0x09, 0xCE, 0x03, 0x09, 
				 0x00, 0x09, 0xCE, 0x03, 0x0A, 0x00, 0x09, 0xCE, 
				 0x03, 0x0B, 0x00, 0x16, 0x80, 0x00, 0x2F, 0x00, 
				 0x16, 0x84, 0x00, 0x08, 0x00, 0x16, 0x88, 0x00, 
				 0x40, 0x00, 0x1D, 0x19, 0x00, 0x00, 0x00, 0x09, 
				 0x00, 0x00, 0x00, 0xC7, 0x00, 0x00, 0x00, 0xC7, 
				 0x00, 0x00, 0x00, 0x89, 0x00, 0x00, 0x00, 0xD0, 
				 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0xE0, 
				 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xB0, 
				 0x00, 0x00, 0x00, 0x83, 0x00, 0x00, 0x00, 0xAF, 
				 0x00, 0x00, 0x00, 0xD0, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0xAF, 0x00, 0x00, 0x00, 0xE0, 
				 0x00, 0x00, 0x00, 0xE3, 0x00, 0x00, 0x00, 0xFF, 
				 0x00, 0x00, 0x00, 0x1D, 0x06, 0x00, 0x64, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x22, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x8F, 0x00, 0x00, 0x00, 
				 0x13, 0xEA, 0x00, 0x1E, 0x00, 0x00, 0xC0, 0x00, 
				 0x00, 0x1E, 0x01, 0x12, 0x0D, 0x00, 0x00, 0x1F, 
				 0x01, 0x00, 0x19, 0xEA, 0x00, 0x12, 0x07, 0x04, 
				 0x1E, 0x00, 0xC0, 0x00, 0x00, 0x00, 0x1E, 0x01, 
				 0x0D, 0x00, 0x00, 0x00, 0x18, 0x07, 0x04, 0x13, 
				 0xC4, 0x02, 0x1E, 0x00, 0x3F, 0xC0, 0x00, 0x00, 
				 0x1E, 0x01, 0x80, 0x0D, 0x00, 0x00, 0x1F, 0x01, 
				 0x00, 0x19, 0xC4, 0x02, 0x13, 0xEA, 0x00, 0x1E, 
				 0x00, 0xC0, 0xFF, 0x00, 0x00, 0x1E, 0x01, 0x20, 
				 0x00, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 0xEA, 
				 0x00, 0x16, 0x02, 0x04, 0x00, 0x00, 0x13, 0xC0, 
				 0x00, 0x1E, 0x01, 0x00, 0x00, 0x00, 0x00, 0x19, 
				 0xC0, 0x00, 0x13, 0xEA, 0x00, 0x1E, 0x00, 0xFF, 
				 0xC0, 0x00, 0x00, 0x1E, 0x01, 0x00, 0x0D, 0x00, 
				 0x00, 0x1F, 0x01, 0x00, 0x19, 0xEA, 0x00, 0x00, 0x00};

BYTE t5465AD_Mode_1600x1200x8_6a[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x16, 0x05, 0x04, 0x00, 0x00, 0x16, 0xC0, 0x00, 
				 0x00, 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 
				 0x00, 0x1F, 0x01, 0x00, 0x18, 0xC5, 0x02, 0x18, 
				 0x07, 0x04, 0x15, 0xA0, 0x00, 0xFF, 0x00, 0x09, 
				 0xCE, 0x03, 0x06, 0x05, 0x09, 0xCE, 0x03, 0x09, 
				 0x00, 0x09, 0xCE, 0x03, 0x0A, 0x00, 0x09, 0xCE, 
				 0x03, 0x0B, 0x00, 0x16, 0x80, 0x00, 0x2F, 0x00, 
				 0x16, 0x84, 0x00, 0x10, 0x00, 0x16, 0x88, 0x00, 
				 0x79, 0x00, 0x1D, 0x19, 0x00, 0x00, 0x00, 0x09, 
				 0x00, 0x00, 0x00, 0xC7, 0x00, 0x00, 0x00, 0xC7, 
				 0x00, 0x00, 0x00, 0x89, 0x00, 0x00, 0x00, 0xD0, 
				 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0xE0, 
				 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xB0, 
				 0x00, 0x00, 0x00, 0x83, 0x00, 0x00, 0x00, 0xAF, 
				 0x00, 0x00, 0x00, 0xD0, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0xAF, 0x00, 0x00, 0x00, 0xE0, 
				 0x00, 0x00, 0x00, 0xE3, 0x00, 0x00, 0x00, 0xFF, 
				 0x00, 0x00, 0x00, 0x1D, 0x06, 0x00, 0x64, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x22, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x8F, 0x00, 0x00, 0x00, 
				 0x13, 0xEA, 0x00, 0x1E, 0x00, 0x00, 0xC0, 0x00, 
				 0x00, 0x1E, 0x01, 0x1A, 0x1A, 0x00, 0x00, 0x1F, 
				 0x01, 0x00, 0x19, 0xEA, 0x00, 0x12, 0x07, 0x04, 
				 0x1E, 0x00, 0xC0, 0x00, 0x00, 0x00, 0x1E, 0x01, 
				 0x1A, 0x00, 0x00, 0x00, 0x18, 0x07, 0x04, 0x13, 
				 0xC4, 0x02, 0x1E, 0x00, 0x3F, 0xC0, 0x00, 0x00, 
				 0x1E, 0x01, 0x80, 0x1A, 0x00, 0x00, 0x1F, 0x01, 
				 0x00, 0x19, 0xC4, 0x02, 0x13, 0xEA, 0x00, 0x1E, 
				 0x00, 0xC0, 0xFF, 0x00, 0x00, 0x1E, 0x01, 0x20, 
				 0x00, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 0xEA, 
				 0x00, 0x16, 0x02, 0x04, 0x00, 0x00, 0x13, 0xC0, 
				 0x00, 0x1E, 0x01, 0x00, 0x00, 0x00, 0x00, 0x19, 
				 0xC0, 0x00, 0x17, 0x4C, 0x00, 0xA0, 0x00, 0x00, 
				 0x00, 0x17, 0x6C, 0x00, 0x32, 0x00, 0x00, 0x00, 
				 0x13, 0xEA, 0x00, 0x1E, 0x00, 0xFF, 0xC0, 0x00, 
				 0x00, 0x1E, 0x01, 0x00, 0x0D, 0x00, 0x00, 0x1F, 
				 0x01, 0x00, 0x19, 0xEA, 0x00, 0x00, 0x00};

BYTE t5465AD_Mode_1600x1200x8_7a[] =
				{0x09, 0xC4, 0x03, 0x07, 0x00, 0x12, 0x44, 0x00, 
				 0x1E, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x18, 0x44, 
				 0x00, 0x12, 0x5C, 0x00, 0x1E, 0x00, 0x7F, 0x00, 
				 0x00, 0x00, 0x18, 0x5C, 0x00, 0x14, 0xFC, 0x03, 
				 0x1E, 0x01, 0x00, 0x00, 0x00, 0x10, 0x1A, 0xFC, 
				 0x03, 0x13, 0x84, 0x05, 0x1E, 0x01, 0x00, 0x20, 
				 0x00, 0x00, 0x19, 0x84, 0x05, 0x17, 0xE8, 0x05, 
				 0xFF, 0xFF, 0xFF, 0xFF, 0x13, 0x84, 0x05, 0x1E, 
				 0x00, 0xFF, 0xDF, 0x00, 0x00, 0x19, 0x84, 0x05, 
				 0x16, 0x05, 0x04, 0x00, 0x00, 0x16, 0xC0, 0x00, 
				 0x00, 0x00, 0x12, 0xEB, 0x00, 0x1E, 0x00, 0xC0, 
				 0x00, 0x00, 0x00, 0x1E, 0x01, 0x05, 0x00, 0x00, 
				 0x00, 0x1F, 0x01, 0x00, 0x18, 0xC5, 0x02, 0x18, 
				 0x07, 0x04, 0x15, 0xA0, 0x00, 0xFF, 0x00, 0x09, 
				 0xCE, 0x03, 0x06, 0x05, 0x09, 0xCE, 0x03, 0x09, 
				 0x00, 0x09, 0xCE, 0x03, 0x0A, 0x00, 0x09, 0xCE, 
				 0x03, 0x0B, 0x00, 0x16, 0x80, 0x00, 0x2F, 0x00, 
				 0x16, 0x84, 0x00, 0x08, 0x00, 0x16, 0x88, 0x00, 
				 0x40, 0x00, 0x1D, 0x19, 0x00, 0x00, 0x00, 0x09, 
				 0x00, 0x00, 0x00, 0xC7, 0x00, 0x00, 0x00, 0xC7, 
				 0x00, 0x00, 0x00, 0x89, 0x00, 0x00, 0x00, 0xD0, 
				 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0xE0, 
				 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xB0, 
				 0x00, 0x00, 0x00, 0x83, 0x00, 0x00, 0x00, 0xAF, 
				 0x00, 0x00, 0x00, 0xD0, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0xAF, 0x00, 0x00, 0x00, 0xE0, 
				 0x00, 0x00, 0x00, 0xE3, 0x00, 0x00, 0x00, 0xFF, 
				 0x00, 0x00, 0x00, 0x1D, 0x06, 0x00, 0x64, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x22, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
				 0x00, 0x00, 0x00, 0x00, 0x8F, 0x00, 0x00, 0x00, 
				 0x13, 0xEA, 0x00, 0x1E, 0x00, 0x00, 0xC0, 0x00, 
				 0x00, 0x1E, 0x01, 0x1A, 0x1A, 0x00, 0x00, 0x1F, 
				 0x01, 0x00, 0x19, 0xEA, 0x00, 0x12, 0x07, 0x04, 
				 0x1E, 0x00, 0xC0, 0x00, 0x00, 0x00, 0x1E, 0x01, 
				 0x1A, 0x00, 0x00, 0x00, 0x18, 0x07, 0x04, 0x13, 
				 0xC4, 0x02, 0x1E, 0x00, 0x3F, 0xC0, 0x00, 0x00, 
				 0x1E, 0x01, 0x80, 0x1A, 0x00, 0x00, 0x1F, 0x01, 
				 0x00, 0x19, 0xC4, 0x02, 0x13, 0xEA, 0x00, 0x1E, 
				 0x00, 0xC0, 0xFF, 0x00, 0x00, 0x1E, 0x01, 0x20, 
				 0x00, 0x00, 0x00, 0x1F, 0x01, 0x00, 0x19, 0xEA, 
				 0x00, 0x16, 0x02, 0x04, 0x00, 0x00, 0x13, 0xC0, 
				 0x00, 0x1E, 0x01, 0x00, 0x00, 0x00, 0x00, 0x19, 
				 0xC0, 0x00, 0x17, 0x4C, 0x00, 0xA0, 0x00, 0x00, 
				 0x00, 0x17, 0x6C, 0x00, 0x32, 0x00, 0x00, 0x00, 
				 0x13, 0xEA, 0x00, 0x1E, 0x00, 0xFF, 0xC0, 0x00, 
				 0x00, 0x1E, 0x01, 0x00, 0x0D, 0x00, 0x00, 0x1F, 
				 0x01, 0x00, 0x19, 0xEA, 0x00, 0x00, 0x00};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\laguna\mini\cl546x\structs.h ===
/******************************************************************************
*
*   Module:     STRUCTS.H       Mode/Monitor Structure Header Module
*
*   Revision:   1.00
*
*   Date:       April 8, 1994
*
*   Author:     Randy Spurlock
*
*******************************************************************************
*
*   Module Description:
*
*       This module contains the structure declarations for
*   the mode/monitor functions.
*
*******************************************************************************
*
*   Changes:
*
*    DATE     REVISION  DESCRIPTION                             AUTHOR
*  --------   --------  -------------------------------------------------------
*  04/08/94     1.00    Original                                Randy Spurlock
*
*******************************************************************************
*   Local Constants
******************************************************************************/

//
// Is this Windows NT or something else?
//
#ifndef WIN_NT
    #if NT_MINIPORT
        #define WIN_NT 1
    #else
        #define WIN_NT 0
    #endif
#endif

#if WIN_NT
    extern char *MODE_FILE;
#else
    #define MODE_FILE       "Mode.Ini"      /* Controller mode filename          */
#endif 

#define MONITOR_FILE    "Monitor.Ini"   /* Monitor filename                  */

#define HSYNC_POS               0x00    /* Positive horizontal sync. value   */
#define HSYNC_NEG               0x40    /* Negative horizontal sync. value   */
#define VSYNC_POS               0x00    /* Positive vertical sync. value     */
#define VSYNC_NEG               0x80    /* Negative vertical sync. value     */

#define END_TABLE               0x00    /* End of mode table opcode value    */
#define SET_BIOS_MODE           0x01    /* Set BIOS video mode opcode value  */
#define SINGLE_BYTE_INPUT       0x02    /* Single byte input opcode value    */
#define SINGLE_WORD_INPUT       0x03    /* Single word input opcode value    */
#define SINGLE_DWORD_INPUT      0x04    /* Single dword input opcode value   */
#define SINGLE_INDEXED_INPUT    0x05    /* Single indexed input opcode value */
#define SINGLE_BYTE_OUTPUT      0x06    /* Single byte output opcode value   */
#define SINGLE_WORD_OUTPUT      0x07    /* Single word output opcode value   */
#define SINGLE_DWORD_OUTPUT     0x08    /* Single dword output opcode value  */
#define SINGLE_INDEXED_OUTPUT   0x09    /* Single indexed output opcode      */
#define HOLDING_BYTE_OUTPUT     0x0A    /* Holding byte output opcode value  */
#define HOLDING_WORD_OUTPUT     0x0B    /* Holding word output opcode value  */
#define HOLDING_DWORD_OUTPUT    0x0C    /* Holding dword output opcode value */
#define HOLDING_INDEXED_OUTPUT  0x0D    /* Holding indexed output opcode     */
#define MULTIPLE_BYTE_OUTPUT    0x0E    /* Multiple byte output opcode value */
#define MULTIPLE_WORD_OUTPUT    0x0F    /* Multiple word output opcode value */
#define MULTIPLE_DWORD_OUTPUT   0x10    /* Multiple dword output opcode value*/
#define MULTIPLE_INDEXED_OUTPUT 0x11    /* Multiple indexed output opcode    */
#define SINGLE_BYTE_READ        0x12    /* Single byte read opcode value     */
#define SINGLE_WORD_READ        0x13    /* Single word read opcode value     */
#define SINGLE_DWORD_READ       0x14    /* Single dword read opcode value    */
#define SINGLE_BYTE_WRITE       0x15    /* Single byte write opcode value    */
#define SINGLE_WORD_WRITE       0x16    /* Single word write opcode value    */
#define SINGLE_DWORD_WRITE      0x17    /* Single dword write opcode value   */
#define HOLDING_BYTE_WRITE      0x18    /* Holding byte write opcode value   */
#define HOLDING_WORD_WRITE      0x19    /* Holding word write opcode value   */
#define HOLDING_DWORD_WRITE     0x1A    /* Holding dword write opcode value  */
#define MULTIPLE_BYTE_WRITE     0x1B    /* Multiple byte write opcode value  */
#define MULTIPLE_WORD_WRITE     0x1C    /* Multiple word write opcode value  */
#define MULTIPLE_DWORD_WRITE    0x1D    /* Multiple dword write opcode value */
#define PERFORM_OPERATION       0x1E    /* Perform logical operation opcode  */
#define PERFORM_DELAY           0x1F    /* Perform time delay opcode value   */
#define SUB_TABLE               0x20    /* Perform mode sub-table opcode     */
#define I2COUT_WRITE				  0x21    /* Perform I2C Write */

#define AND_OPERATION           0x00    /* Logical AND operation code value  */
#define OR_OPERATION            0x01    /* Logical OR operation code value   */
#define XOR_OPERATION           0x02    /* Logical XOR operation code value  */

/******************************************************************************
*   Type Definitions and Structures
******************************************************************************/
#if WIN_NT && NT_MINIPORT // If NT miniport
    #pragma pack (push,1)
#endif
typedef struct tagMode                  /* Generic mode table structure      */
{
    BYTE        Mode_Opcode;            /* Mode table opcode value           */
    WORD        Mode_Count;             /* Mode table count value            */
} Mode;

typedef struct tagMTE                   /* Mode table end structure          */
{
    BYTE        MTE_Opcode;             /* Mode table end opcode value       */
} MTE;

typedef struct tagSBM                   /* Set BIOS mode structure           */
{
    BYTE        SBM_Opcode;             /* Set BIOS mode opcode value        */
    BYTE        SBM_Mode;               /* BIOS mode value                   */
} SBM;

typedef struct tagSBI                   /* Single byte input structure       */
{
    BYTE        SBI_Opcode;             /* Single byte input opcode value    */
    WORD        SBI_Port;               /* Single byte input port address    */
} SBI;

typedef struct tagSWI                   /* Single word input structure       */
{
    BYTE        SWI_Opcode;             /* Single word input opcode value    */
    WORD        SWI_Port;               /* Single word input port address    */
} SWI;

typedef struct tagSDI                   /* Single dword input structure      */
{
    BYTE        SDI_Opcode;             /* Single dword input opcode value   */
    WORD        SDI_Port;               /* Single dword input port address   */
} SDI;

typedef struct tagSII                   /* Single indexed input structure    */
{
    BYTE        SII_Opcode;             /* Single indexed input opcode value */
    WORD        SII_Port;               /* Single indexed input port address */
    BYTE        SII_Index;              /* Single indexed input index value  */
} SII;

typedef struct tagSBO                   /* Single byte output structure      */
{
    BYTE        SBO_Opcode;             /* Single byte output opcode value   */
    WORD        SBO_Port;               /* Single byte output port address   */
    BYTE        SBO_Value;              /* Single byte output data value     */
} SBO;

typedef struct tagSWO                   /* Single word output structure      */
{
    BYTE        SWO_Opcode;             /* Single word output opcode value   */
    WORD        SWO_Port;               /* Single word output port address   */
    WORD        SWO_Value;              /* Single word output data value     */
} SWO;

typedef struct tagSDO                   /* Single dword output structure     */
{
    BYTE        SDO_Opcode;             /* Single dword output opcode value  */
    WORD        SDO_Port;               /* Single dword output port address  */
    DWORD       SDO_Value;              /* Single dword output data value    */
} SDO;

typedef struct tagSIO                   /* Single indexed output structure   */
{
    BYTE        SIO_Opcode;             /* Single indexed output opcode      */
    WORD        SIO_Port;               /* Single indexed output port addr.  */
    BYTE        SIO_Index;              /* Single indexed output index value */
    BYTE        SIO_Value;              /* Single indexed output data value  */
} SIO;

typedef struct tagHBO                   /* Holding byte output structure     */
{
    BYTE        HBO_Opcode;             /* Holding byte output opcode value  */
    WORD        HBO_Port;               /* Holding byte output port address  */
} HBO;

typedef struct tagHWO                   /* Holding word output structure     */
{
    BYTE        HWO_Opcode;             /* Holding word output opcode value  */
    WORD        HWO_Port;               /* Holding word output port address  */
} HWO;

typedef struct tagHDO                   /* Holding dword output structure    */
{
    BYTE        HDO_Opcode;             /* Holding dword output opcode value */
    WORD        HDO_Port;               /* Holding dword output port address */
} HDO;

typedef struct tagHIO                   /* Holding indexed output structure  */
{
    BYTE        HIO_Opcode;             /* Holding indexed output opcode     */
    WORD        HIO_Port;               /* Holding indexed output port addr. */
    BYTE        HIO_Index;              /* Holding indexed output index      */
} HIO;

typedef struct tagMBO                   /* Multiple byte output structure    */
{
    BYTE        MBO_Opcode;             /* Multiple byte output opcode value */
    WORD        MBO_Count;              /* Multiple byte output data count   */
    WORD        MBO_Port;               /* Multiple byte output port address */
} MBO;

typedef struct tagMWO                   /* Multiple word output structure    */
{
    BYTE        MWO_Opcode;             /* Multiple word output opcode value */
    WORD        MWO_Count;              /* Multiple word output data count   */
    WORD        MWO_Port;               /* Multiple word output port address */
} MWO;

typedef struct tagMDO                   /* Multiple dword output structure   */
{
    BYTE        MDO_Opcode;             /* Multiple dword output opcode value*/
    WORD        MDO_Count;              /* Multiple dword output data count  */
    WORD        MDO_Port;               /* Multiple dword output port address*/
} MDO;

typedef struct tagMIO                   /* Multiple indexed output structure */
{
    BYTE        MIO_Opcode;             /* Multiple indexed output opcode    */
    WORD        MIO_Count;              /* Multiple indexed output count     */
    WORD        MIO_Port;               /* Multiple indexed output port      */
    BYTE        MIO_Index;              /* Multiple indexed output index     */
} MIO;

typedef struct tagSBR                   /* Single byte read structure        */
{
    BYTE        SBR_Opcode;             /* Single byte read opcode value     */
    WORD        SBR_Address;            /* Single byte read address value    */
} SBR;

typedef struct tagSWR                   /* Single word read structure        */
{
    BYTE        SWR_Opcode;             /* Single word read opcode value     */
    WORD        SWR_Address;            /* Single word read address value    */
} SWR;

typedef struct tagSDR                   /* Single dword read structure       */
{
    BYTE        SDR_Opcode;             /* Single dword read opcode value    */
    WORD        SDR_Address;            /* Single dword read address value   */
} SDR;

typedef struct tagSBW                   /* Single byte write structure       */
{
    BYTE        SBW_Opcode;             /* Single byte write opcode value    */
    WORD        SBW_Address;            /* Single byte write address value   */
    WORD        SBW_Value;              /* Single word output data value     */
} SBW;

typedef struct tagSWW                   /* Single word write structure       */
{
    BYTE        SWW_Opcode;             /* Single word write opcode value    */
    WORD        SWW_Address;            /* Single word write address value   */
    WORD        SWW_Value;              /* Single word write data value      */
} SWW;

typedef struct tagSDW                   /* Single dword write structure      */
{
    BYTE        SDW_Opcode;             /* Single dword write opcode value   */
    WORD        SDW_Address;            /* Single dword write address value  */
    DWORD       SDW_Value;              /* Single dword write data value     */
} SDW;

typedef struct tagHBW                   /* Holding byte write structure      */
{
    BYTE        HBW_Opcode;             /* Holding byte write opcode value   */
    WORD        HBW_Address;            /* Holding byte write address value  */
} HBW;

typedef struct tagHWW                   /* Holding word write structure      */
{
    BYTE        HWW_Opcode;             /* Holding word write opcode value   */
    WORD        HWW_Address;            /* Holding word write address value  */
} HWW;

typedef struct tagHDW                   /* Holding dword write structure     */
{
    BYTE        HDW_Opcode;             /* Holding dword write opcode value  */
    WORD        HDW_Address;            /* Holding dword write address value */
} HDW;

typedef struct tagMBW                   /* Multiple byte write structure     */
{
    BYTE        MBW_Opcode;             /* Multiple byte write opcode value  */
    WORD        MBW_Count;              /* Multiple byte write data count    */
    WORD        MBW_Address;            /* Multiple byte write address value */
} MBW;

typedef struct tagMWW                   /* Multiple word write structure     */
{
    BYTE        MWW_Opcode;             /* Multiple word write opcode value  */
    WORD        MWW_Count;              /* Multiple word write data count    */
    WORD        MWW_Address;            /* Multiple word write address value */
} MWW;

typedef struct tagMDW                   /* Multiple dword write structure    */
{
    BYTE        MDW_Opcode;             /* Multiple dword write opcode value */
    WORD        MDW_Count;              /* Multiple dword write data count   */
    WORD        MDW_Address;            /* Multiple dword write address value*/
} MDW;

typedef struct tagLO                    /* Logical operation structure       */
{
    BYTE        LO_Opcode;              /* Logical operation opcode value    */
    BYTE        LO_Operation;           /* Logical operation operation value */
    DWORD       LO_Value;               /* Logical operation data value      */
} LO;

typedef struct tagDO                    /* Delay operation structure         */
{
    BYTE        DO_Opcode;              /* Delay operation opcode value      */
    WORD        DO_Time;                /* Delay operation time value        */
} DO;

typedef struct tagMST                   /* Mode sub-table structure          */
{
    BYTE        MST_Opcode;             /* Mode sub-table opcode value       */
    WORD        MST_Pointer;            /* Mode sub-table pointer value      */
} MST;

typedef struct i2c {
	BYTE		I2C_Opcode;		/* This is the op_code */
	BYTE		I2C_Addr;		/* The 7 bit I2C Address */
	WORD		I2C_Port;		/* I2C Port to talk to */
	WORD		I2C_Count;		/* The number of commands */
} I2C, * PI2C; 

typedef struct i2cdata {
	BYTE	I2C_Reg;			  /* The I2C Register */
	BYTE	I2C_Data;		  /* The I2C Data */
	} I2CDATA, * PI2CDATA;

#if WIN_NT && NT_MINIPORT // If NT miniport
    #pragma pack (pop)
#endif



#if WIN_NT

/******************************************************************************
*
*   Module:     STRUCTS.H       Local Structures Header Module
*
*   Revision:   1.00
*
*   Date:       April 14, 1994
*
*   Author:     Randy Spurlock
*
*******************************************************************************
*
*   Module Description:
*
*       This module contains local structure declarations.
*
*******************************************************************************
*
*   Changes:
*
*    DATE     REVISION  DESCRIPTION                             AUTHOR
*  --------   --------  -------------------------------------------------------
*  04/14/94     1.00    Original                                Randy Spurlock
*
*******************************************************************************
*   Local Definitions
******************************************************************************/
#define NAME_SIZE       64              /* Maximum filename size in bytes    */
#define BUFFER_SIZE     4096            /* Number of bytes in .INI buffer    */

#define ENTRY_LINE      0x00            /* Entry line flag value             */
#define SECTION_LINE    0x01            /* Section header line flag value    */
#define COMMENT_LINE    0x02            /* Comment line flag value           */

/******************************************************************************
*   Local Structures and Unions
******************************************************************************/

typedef struct tagLineInfo              /* Line information structure        */
{
    WORD        nID;                    /* Buffer ID value                   */
    BYTE        fType;                  /* Line type flags                   */
    BYTE        nOffset;                /* Section or entry offset value     */
    BYTE        nLength;                /* Section or entry name length      */
    BYTE        nSize;                  /* Line length value                 */
} LineInfo;

typedef struct tagFreeInfo              /* Free information structure        */
{
    WORD        nID;                    /* Buffer ID value                   */
    DWORD       nSize;                  /* Free space size value             */
} FreeInfo;

typedef struct tagLineHeader            /* Line header structure             */
{
    struct tagLineHeader *pPrev;        /* Pointer to previous line header   */
    struct tagLineHeader *pNext;        /* Pointer to next line header       */
    struct tagLineInfo   Info;          /* Line information structure        */
} LineHeader;

typedef struct tagFreeHeader            /* Free header structure             */
{
    struct tagFreeHeader *pPrev;        /* Pointer to previous free header   */
    struct tagFreeHeader *pNext;        /* Pointer to next free header       */
    struct tagFreeInfo   Info;          /* Free information structure        */
} FreeHeader;

typedef struct tagIniBuffer             /* Ini buffer structure              */
{
    struct tagIniBuffer *pPrev;         /* Pointer to previous ini buffer    */
    struct tagIniBuffer *pNext;         /* Pointer to next ini buffer        */
    char acData[BUFFER_SIZE];           /* Ini data buffer array             */
} IniBuffer;

typedef struct tagIniPointer            /* Ini pointer structure             */
{
    IniBuffer   *pFirst;                /* Pointer to first Ini buffer       */
    IniBuffer   *pLast;                 /* Pointer to last Ini buffer        */
} IniPointer;

typedef struct tagLinePointer           /* Line header pointer structure     */
{
    LineHeader  *pFirst;                /* Pointer to first line header      */
    LineHeader  *pLast;                 /* Pointer to last line header       */
} LinePointer;

typedef struct tagFreePointer           /* Free header pointer structure     */
{
    FreeHeader  *pFirst;                /* Pointer to first free header      */
    FreeHeader  *pLast;                 /* Pointer to last free header       */
} FreePointer;

typedef struct tagIniCache              /* Ini cache structure               */
{
    struct tagIniCache  *pPrev;         /* Pointer to previous ini cache     */
    struct tagIniCache  *pNext;         /* Pointer to next ini cache         */

    char        sCacheFile[NAME_SIZE];  /* Cache filename                    */
    int         nBufferID;              /* Buffer ID value                   */
    BOOL        bDirtyFlag;             /* Cache dirty flag                  */

    IniPointer  pIni;                   /* Ini buffer pointer structure      */
    LinePointer pLine;                  /* Line header pointer structure     */
    FreePointer pFree;                  /* Free header pointer structure     */
} IniCache;

typedef struct tagCachePointer          /* Cache pointer structure           */
{
    IniCache    *pFirst;                /* Pointer to first .INI cache       */
    IniCache    *pLast;                 /* Pointer to last .INI cache        */
} CachePointer;

#endif


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\laguna\mini\cl546x\modestr.c ===
/******************************************************************************
*
*   Module:     ModeStr.C       NT Driver Mode Table Data File
*
*   Author:     Computer Generated (By CGLMode program version: 1.62.02)
*
*******************************************************************************
*
*   Module Description:
*
*       This module contains the mode tables used by the NT driver. This
*   data file is generated by the CGLMode program.
*
*******************************************************************************
*
*   Changes:
*
*******************************************************************************
*   Include Files
******************************************************************************/

{
	    0,   //// ValidMode
	 LG_5462 | LG_5464,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   60,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 1024,   //// Bytes per scan line.
	  640,   //// XResol
	  480,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	    8,   //// Bits per pixel
	    0,   //// Refresh index
	 t546x_Mode_640x480x8_1,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5462 | LG_5464,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   72,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 1024,   //// Bytes per scan line.
	  640,   //// XResol
	  480,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	    8,   //// Bits per pixel
	    0,   //// Refresh index
	 t546x_Mode_640x480x8_2,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5462 | LG_5464,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   75,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 1024,   //// Bytes per scan line.
	  640,   //// XResol
	  480,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	    8,   //// Bits per pixel
	    0,   //// Refresh index
	 t546x_Mode_640x480x8_3,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5462 | LG_5464,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   85,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 1024,   //// Bytes per scan line.
	  640,   //// XResol
	  480,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	    8,   //// Bits per pixel
	    0,   //// Refresh index
	 t546x_Mode_640x480x8_4,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5462 | LG_5464,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   60,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 1280,   //// Bytes per scan line.
	  640,   //// XResol
	  480,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	    8,   //// Bits per pixel
	    0,   //// Refresh index
	 t546x_Mode_640x480x8_1a,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5462 | LG_5464,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   72,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 1280,   //// Bytes per scan line.
	  640,   //// XResol
	  480,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	    8,   //// Bits per pixel
	    0,   //// Refresh index
	 t546x_Mode_640x480x8_2a,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5462 | LG_5464,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   75,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 1280,   //// Bytes per scan line.
	  640,   //// XResol
	  480,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	    8,   //// Bits per pixel
	    0,   //// Refresh index
	 t546x_Mode_640x480x8_3a,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5462 | LG_5464,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   85,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 1280,   //// Bytes per scan line.
	  640,   //// XResol
	  480,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	    8,   //// Bits per pixel
	    0,   //// Refresh index
	 t546x_Mode_640x480x8_4a,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5462 | LG_5464,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   75,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	  640,   //// Bytes per scan line.
	  320,   //// XResol
	  200,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	    8,   //// Bits per pixel
	    0,   //// Refresh index
	 t546x_Mode_320x200x8_1,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5462 | LG_5464,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   60,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	  640,   //// Bytes per scan line.
	  320,   //// XResol
	  240,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	    8,   //// Bits per pixel
	    0,   //// Refresh index
	 t546x_Mode_320x240x8_1,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5462 | LG_5464,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   73,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	  640,   //// Bytes per scan line.
	  320,   //// XResol
	  240,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	    8,   //// Bits per pixel
	    0,   //// Refresh index
	 t546x_Mode_320x240x8_2,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5462 | LG_5464,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   75,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	  640,   //// Bytes per scan line.
	  320,   //// XResol
	  400,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	    8,   //// Bits per pixel
	    0,   //// Refresh index
	 t546x_Mode_320x400x8_1,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5462 | LG_5464,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   60,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	  640,   //// Bytes per scan line.
	  320,   //// XResol
	  480,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	    8,   //// Bits per pixel
	    0,   //// Refresh index
	 t546x_Mode_320x480x8_1,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5462 | LG_5464,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   73,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	  640,   //// Bytes per scan line.
	  320,   //// XResol
	  480,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	    8,   //// Bits per pixel
	    0,   //// Refresh index
	 t546x_Mode_320x480x8_2,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5462 | LG_5464,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   75,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 1024,   //// Bytes per scan line.
	  360,   //// XResol
	  400,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	    8,   //// Bits per pixel
	    0,   //// Refresh index
	 t546x_Mode_360x400x8_1,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5462 | LG_5464,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   85,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 1024,   //// Bytes per scan line.
	  360,   //// XResol
	  400,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	    8,   //// Bits per pixel
	    0,   //// Refresh index
	 t546x_Mode_360x400x8_2,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5462 | LG_5464,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   60,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 1024,   //// Bytes per scan line.
	  400,   //// XResol
	  300,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	    8,   //// Bits per pixel
	    0,   //// Refresh index
	 t546x_Mode_400x300x8_1,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5462 | LG_5464,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   75,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 1024,   //// Bytes per scan line.
	  400,   //// XResol
	  300,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	    8,   //// Bits per pixel
	    0,   //// Refresh index
	 t546x_Mode_400x300x8_2,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5462 | LG_5464,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   60,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 1024,   //// Bytes per scan line.
	  512,   //// XResol
	  384,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	    8,   //// Bits per pixel
	    0,   //// Refresh index
	 t546x_Mode_512x384x8_1,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5462 | LG_5464,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   70,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 1024,   //// Bytes per scan line.
	  512,   //// XResol
	  384,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	    8,   //// Bits per pixel
	    0,   //// Refresh index
	 t546x_Mode_512x384x8_2,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5462 | LG_5464,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   63,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 1024,   //// Bytes per scan line.
	  512,   //// XResol
	  480,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	    8,   //// Bits per pixel
	    0,   //// Refresh index
	 t546x_Mode_512x480x8_1,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5462 | LG_5464,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   75,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 1024,   //// Bytes per scan line.
	  512,   //// XResol
	  480,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	    8,   //// Bits per pixel
	    0,   //// Refresh index
	 t546x_Mode_512x480x8_2,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5462 | LG_5464,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   70,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 1280,   //// Bytes per scan line.
	  640,   //// XResol
	  350,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	    8,   //// Bits per pixel
	    0,   //// Refresh index
	 t546x_Mode_640x350x8_1,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5462 | LG_5464,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   85,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 1280,   //// Bytes per scan line.
	  640,   //// XResol
	  350,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	    8,   //// Bits per pixel
	    0,   //// Refresh index
	 t546x_Mode_640x350x8_2,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5462 | LG_5464,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   70,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	  640,   //// Bytes per scan line.
	  640,   //// XResol
	  400,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	    8,   //// Bits per pixel
	    0,   //// Refresh index
	 t546x_Mode_640x400x8_1,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5462 | LG_5464,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   70,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 1280,   //// Bytes per scan line.
	  640,   //// XResol
	  400,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	    8,   //// Bits per pixel
	    0,   //// Refresh index
	 t546x_Mode_640x400x8_1a,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5462 | LG_5464,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   85,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	  640,   //// Bytes per scan line.
	  640,   //// XResol
	  400,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	    8,   //// Bits per pixel
	    0,   //// Refresh index
	 t546x_Mode_640x400x8_2,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5462 | LG_5464,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   85,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 1280,   //// Bytes per scan line.
	  640,   //// XResol
	  400,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	    8,   //// Bits per pixel
	    0,   //// Refresh index
	 t546x_Mode_640x400x8_2a,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5462 | LG_5464,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	  150,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	  640,   //// Bytes per scan line.
	  640,   //// XResol
	  400,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	    8,   //// Bits per pixel
	    0,   //// Refresh index
	 t546x_Mode_640x400x8_3,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5462 | LG_5464,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	  150,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 1280,   //// Bytes per scan line.
	  640,   //// XResol
	  400,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	    8,   //// Bits per pixel
	    0,   //// Refresh index
	 t546x_Mode_640x400x8_3a,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5462 | LG_5464,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   56,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 1024,   //// Bytes per scan line.
	  800,   //// XResol
	  600,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	    8,   //// Bits per pixel
	    0,   //// Refresh index
	 t546x_Mode_800x600x8_1,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5462 | LG_5464,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   60,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 1024,   //// Bytes per scan line.
	  800,   //// XResol
	  600,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	    8,   //// Bits per pixel
	    0,   //// Refresh index
	 t546x_Mode_800x600x8_2,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5462 | LG_5464,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   72,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 1024,   //// Bytes per scan line.
	  800,   //// XResol
	  600,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	    8,   //// Bits per pixel
	    0,   //// Refresh index
	 t546x_Mode_800x600x8_3,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5462 | LG_5464,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   75,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 1024,   //// Bytes per scan line.
	  800,   //// XResol
	  600,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	    8,   //// Bits per pixel
	    0,   //// Refresh index
	 t546x_Mode_800x600x8_4,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5462 | LG_5464,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   85,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 1024,   //// Bytes per scan line.
	  800,   //// XResol
	  600,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	    8,   //// Bits per pixel
	    0,   //// Refresh index
	 t546x_Mode_800x600x8_5,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5462 | LG_5464,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   56,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 1664,   //// Bytes per scan line.
	  800,   //// XResol
	  600,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	    8,   //// Bits per pixel
	    0,   //// Refresh index
	 t546x_Mode_800x600x8_1a,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5462 | LG_5464,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   60,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 1664,   //// Bytes per scan line.
	  800,   //// XResol
	  600,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	    8,   //// Bits per pixel
	    0,   //// Refresh index
	 t546x_Mode_800x600x8_2a,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5462 | LG_5464,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   72,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 1664,   //// Bytes per scan line.
	  800,   //// XResol
	  600,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	    8,   //// Bits per pixel
	    0,   //// Refresh index
	 t546x_Mode_800x600x8_3a,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5462 | LG_5464,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   75,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 1664,   //// Bytes per scan line.
	  800,   //// XResol
	  600,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	    8,   //// Bits per pixel
	    0,   //// Refresh index
	 t546x_Mode_800x600x8_4a,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5462 | LG_5464,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   85,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 1664,   //// Bytes per scan line.
	  800,   //// XResol
	  600,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	    8,   //// Bits per pixel
	    0,   //// Refresh index
	 t546x_Mode_800x600x8_5a,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5462 | LG_5464,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   43,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 1280,   //// Bytes per scan line.
	 1024,   //// XResol
	  768,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	    8,   //// Bits per pixel
	    0,   //// Refresh index
	 t546x_Mode_1024x768x8_1,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5462 | LG_5464,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   60,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 1280,   //// Bytes per scan line.
	 1024,   //// XResol
	  768,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	    8,   //// Bits per pixel
	    0,   //// Refresh index
	 t546x_Mode_1024x768x8_2,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5462 | LG_5464,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   70,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 1280,   //// Bytes per scan line.
	 1024,   //// XResol
	  768,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	    8,   //// Bits per pixel
	    0,   //// Refresh index
	 t546x_Mode_1024x768x8_3,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5462 | LG_5464,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   75,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 1280,   //// Bytes per scan line.
	 1024,   //// XResol
	  768,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	    8,   //// Bits per pixel
	    0,   //// Refresh index
	 t546x_Mode_1024x768x8_4,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5462 | LG_5464,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   85,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 1280,   //// Bytes per scan line.
	 1024,   //// XResol
	  768,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	    8,   //// Bits per pixel
	    0,   //// Refresh index
	 t546x_Mode_1024x768x8_5,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5462 | LG_5464,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   43,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 2048,   //// Bytes per scan line.
	 1024,   //// XResol
	  768,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	    8,   //// Bits per pixel
	    0,   //// Refresh index
	 t546x_Mode_1024x768x8_1a,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5462 | LG_5464,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   60,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 2048,   //// Bytes per scan line.
	 1024,   //// XResol
	  768,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	    8,   //// Bits per pixel
	    0,   //// Refresh index
	 t546x_Mode_1024x768x8_2a,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5462 | LG_5464,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   70,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 2048,   //// Bytes per scan line.
	 1024,   //// XResol
	  768,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	    8,   //// Bits per pixel
	    0,   //// Refresh index
	 t546x_Mode_1024x768x8_3a,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5462 | LG_5464,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   75,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 2048,   //// Bytes per scan line.
	 1024,   //// XResol
	  768,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	    8,   //// Bits per pixel
	    0,   //// Refresh index
	 t546x_Mode_1024x768x8_4a,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5462 | LG_5464,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   85,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 2048,   //// Bytes per scan line.
	 1024,   //// XResol
	  768,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	    8,   //// Bits per pixel
	    0,   //// Refresh index
	 t546x_Mode_1024x768x8_5a,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5462 | LG_5464,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   70,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 1280,   //// Bytes per scan line.
	 1152,   //// XResol
	  864,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	    8,   //// Bits per pixel
	    0,   //// Refresh index
	 t546x_Mode_1152x864x8_1,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5462 | LG_5464,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   75,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 1280,   //// Bytes per scan line.
	 1152,   //// XResol
	  864,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	    8,   //// Bits per pixel
	    0,   //// Refresh index
	 t546x_Mode_1152x864x8_2,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5462 | LG_5464,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   85,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 1280,   //// Bytes per scan line.
	 1152,   //// XResol
	  864,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	    8,   //// Bits per pixel
	    0,   //// Refresh index
	 t546x_Mode_1152x864x8_3,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5462 | LG_5464,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   60,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 1280,   //// Bytes per scan line.
	 1280,   //// XResol
	  960,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	    8,   //// Bits per pixel
	    0,   //// Refresh index
	 t546x_Mode_1280x960x8_1,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5462 | LG_5464,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   75,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 1280,   //// Bytes per scan line.
	 1280,   //// XResol
	  960,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	    8,   //// Bits per pixel
	    0,   //// Refresh index
	 t546x_Mode_1280x960x8_2,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5462 | LG_5464,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   85,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 1280,   //// Bytes per scan line.
	 1280,   //// XResol
	  960,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	    8,   //// Bits per pixel
	    0,   //// Refresh index
	 t546x_Mode_1280x960x8_3,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5462 | LG_5464,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   43,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 1280,   //// Bytes per scan line.
	 1280,   //// XResol
	 1024,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	    8,   //// Bits per pixel
	    0,   //// Refresh index
	 t546x_Mode_1280x1024x8_1,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5462 | LG_5464,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   60,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 1280,   //// Bytes per scan line.
	 1280,   //// XResol
	 1024,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	    8,   //// Bits per pixel
	    0,   //// Refresh index
	 t546x_Mode_1280x1024x8_2,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5462 | LG_5464,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   71,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 1280,   //// Bytes per scan line.
	 1280,   //// XResol
	 1024,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	    8,   //// Bits per pixel
	    0,   //// Refresh index
	 t546x_Mode_1280x1024x8_3,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5462 | LG_5464,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   75,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 1280,   //// Bytes per scan line.
	 1280,   //// XResol
	 1024,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	    8,   //// Bits per pixel
	    0,   //// Refresh index
	 t546x_Mode_1280x1024x8_4,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5462 | LG_5464,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   85,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 1280,   //// Bytes per scan line.
	 1280,   //// XResol
	 1024,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	    8,   //// Bits per pixel
	    0,   //// Refresh index
	 t546x_Mode_1280x1024x8_5,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5462 | LG_5464,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   43,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 2560,   //// Bytes per scan line.
	 1280,   //// XResol
	 1024,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	    8,   //// Bits per pixel
	    0,   //// Refresh index
	 t546x_Mode_1280x1024x8_1a,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5462 | LG_5464,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   60,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 2560,   //// Bytes per scan line.
	 1280,   //// XResol
	 1024,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	    8,   //// Bits per pixel
	    0,   //// Refresh index
	 t546x_Mode_1280x1024x8_2a,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5462 | LG_5464,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   71,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 2560,   //// Bytes per scan line.
	 1280,   //// XResol
	 1024,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	    8,   //// Bits per pixel
	    0,   //// Refresh index
	 t546x_Mode_1280x1024x8_3a,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5462 | LG_5464,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   75,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 2560,   //// Bytes per scan line.
	 1280,   //// XResol
	 1024,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	    8,   //// Bits per pixel
	    0,   //// Refresh index
	 t546x_Mode_1280x1024x8_4a,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5462 | LG_5464,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   85,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 2560,   //// Bytes per scan line.
	 1280,   //// XResol
	 1024,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	    8,   //// Bits per pixel
	    0,   //// Refresh index
	 t546x_Mode_1280x1024x8_5a,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5462 | LG_5464,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   48,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 1664,   //// Bytes per scan line.
	 1600,   //// XResol
	 1200,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	    8,   //// Bits per pixel
	    0,   //// Refresh index
	 t546x_Mode_1600x1200x8_1,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5462 | LG_5464,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   60,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 1664,   //// Bytes per scan line.
	 1600,   //// XResol
	 1200,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	    8,   //// Bits per pixel
	    0,   //// Refresh index
	 t546x_Mode_1600x1200x8_2,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5462 | LG_5464,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   48,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 3328,   //// Bytes per scan line.
	 1600,   //// XResol
	 1200,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	    8,   //// Bits per pixel
	    0,   //// Refresh index
	 t546x_Mode_1600x1200x8_1a,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5462 | LG_5464,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   60,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 3328,   //// Bytes per scan line.
	 1600,   //// XResol
	 1200,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	    8,   //// Bits per pixel
	    0,   //// Refresh index
	 t546x_Mode_1600x1200x8_2a,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5462 | LG_5464,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   75,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 1280,   //// Bytes per scan line.
	  320,   //// XResol
	  200,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	   16,   //// Bits per pixel
	    0,   //// Refresh index
	 t546x_Mode_320x200x16_1,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5462 | LG_5464,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   60,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 1024,   //// Bytes per scan line.
	  320,   //// XResol
	  240,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	   16,   //// Bits per pixel
	    0,   //// Refresh index
	 t546x_Mode_320x240x16_1,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5462 | LG_5464,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   73,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 1024,   //// Bytes per scan line.
	  320,   //// XResol
	  240,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	   16,   //// Bits per pixel
	    0,   //// Refresh index
	 t546x_Mode_320x240x16_2,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5462 | LG_5464,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   75,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 1280,   //// Bytes per scan line.
	  320,   //// XResol
	  400,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	   16,   //// Bits per pixel
	    0,   //// Refresh index
	 t546x_Mode_320x400x16_1,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5462 | LG_5464,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   60,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 1280,   //// Bytes per scan line.
	  320,   //// XResol
	  480,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	   16,   //// Bits per pixel
	    0,   //// Refresh index
	 t546x_Mode_320x480x16_1,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5462 | LG_5464,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   73,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 1280,   //// Bytes per scan line.
	  320,   //// XResol
	  480,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	   16,   //// Bits per pixel
	    0,   //// Refresh index
	 t546x_Mode_320x480x16_2,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5462 | LG_5464,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   75,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 1024,   //// Bytes per scan line.
	  360,   //// XResol
	  400,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	   16,   //// Bits per pixel
	    0,   //// Refresh index
	 t546x_Mode_360x400x16_1,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5462 | LG_5464,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   85,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 1024,   //// Bytes per scan line.
	  360,   //// XResol
	  400,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	   16,   //// Bits per pixel
	    0,   //// Refresh index
	 t546x_Mode_360x400x16_2,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5462 | LG_5464,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   60,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 1024,   //// Bytes per scan line.
	  400,   //// XResol
	  300,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	   16,   //// Bits per pixel
	    0,   //// Refresh index
	 t546x_Mode_400x300x16_1,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5462 | LG_5464,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   75,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 1024,   //// Bytes per scan line.
	  400,   //// XResol
	  300,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	   16,   //// Bits per pixel
	    0,   //// Refresh index
	 t546x_Mode_400x300x16_2,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5462 | LG_5464,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   60,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 1024,   //// Bytes per scan line.
	  512,   //// XResol
	  384,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	   16,   //// Bits per pixel
	    0,   //// Refresh index
	 t546x_Mode_512x384x16_1,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5462 | LG_5464,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   70,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 1024,   //// Bytes per scan line.
	  512,   //// XResol
	  384,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	   16,   //// Bits per pixel
	    0,   //// Refresh index
	 t546x_Mode_512x384x16_2,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5462 | LG_5464,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   63,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 1024,   //// Bytes per scan line.
	  512,   //// XResol
	  480,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	   16,   //// Bits per pixel
	    0,   //// Refresh index
	 t546x_Mode_512x480x16_1,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5462 | LG_5464,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   75,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 1024,   //// Bytes per scan line.
	  512,   //// XResol
	  480,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	   16,   //// Bits per pixel
	    0,   //// Refresh index
	 t546x_Mode_512x480x16_2,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5462 | LG_5464,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   70,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 1280,   //// Bytes per scan line.
	  640,   //// XResol
	  350,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	   16,   //// Bits per pixel
	    0,   //// Refresh index
	 t546x_Mode_640x350x16_1,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5462 | LG_5464,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   85,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 1280,   //// Bytes per scan line.
	  640,   //// XResol
	  350,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	   16,   //// Bits per pixel
	    0,   //// Refresh index
	 t546x_Mode_640x350x16_2,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5462 | LG_5464,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   70,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 1280,   //// Bytes per scan line.
	  640,   //// XResol
	  400,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	   16,   //// Bits per pixel
	    0,   //// Refresh index
	 t546x_Mode_640x400x16_1,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5462 | LG_5464,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   60,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 1280,   //// Bytes per scan line.
	  640,   //// XResol
	  480,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	   16,   //// Bits per pixel
	    0,   //// Refresh index
	 t546x_Mode_640x480x16_1,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5462 | LG_5464,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   72,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 1280,   //// Bytes per scan line.
	  640,   //// XResol
	  480,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	   16,   //// Bits per pixel
	    0,   //// Refresh index
	 t546x_Mode_640x480x16_2,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5462 | LG_5464,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   75,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 1280,   //// Bytes per scan line.
	  640,   //// XResol
	  480,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	   16,   //// Bits per pixel
	    0,   //// Refresh index
	 t546x_Mode_640x480x16_3,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5462 | LG_5464,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   85,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 1280,   //// Bytes per scan line.
	  640,   //// XResol
	  480,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	   16,   //// Bits per pixel
	    0,   //// Refresh index
	 t546x_Mode_640x480x16_4,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5462 | LG_5464,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   56,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 1664,   //// Bytes per scan line.
	  800,   //// XResol
	  600,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	   16,   //// Bits per pixel
	    0,   //// Refresh index
	 t546x_Mode_800x600x16_1,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5462 | LG_5464,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   60,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 1664,   //// Bytes per scan line.
	  800,   //// XResol
	  600,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	   16,   //// Bits per pixel
	    0,   //// Refresh index
	 t546x_Mode_800x600x16_2,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5462 | LG_5464,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   72,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 1664,   //// Bytes per scan line.
	  800,   //// XResol
	  600,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	   16,   //// Bits per pixel
	    0,   //// Refresh index
	 t546x_Mode_800x600x16_3,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5462 | LG_5464,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   75,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 1664,   //// Bytes per scan line.
	  800,   //// XResol
	  600,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	   16,   //// Bits per pixel
	    0,   //// Refresh index
	 t546x_Mode_800x600x16_4,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5462 | LG_5464,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   85,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 1664,   //// Bytes per scan line.
	  800,   //// XResol
	  600,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	   16,   //// Bits per pixel
	    0,   //// Refresh index
	 t546x_Mode_800x600x16_5,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5462 | LG_5464,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   43,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 2048,   //// Bytes per scan line.
	 1024,   //// XResol
	  768,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	   16,   //// Bits per pixel
	    0,   //// Refresh index
	 t546x_Mode_1024x768x16_1,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5462 | LG_5464,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   60,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 2048,   //// Bytes per scan line.
	 1024,   //// XResol
	  768,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	   16,   //// Bits per pixel
	    0,   //// Refresh index
	 t546x_Mode_1024x768x16_2,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5462 | LG_5464,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   70,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 2048,   //// Bytes per scan line.
	 1024,   //// XResol
	  768,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	   16,   //// Bits per pixel
	    0,   //// Refresh index
	 t546x_Mode_1024x768x16_3,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5462 | LG_5464,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   75,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 2048,   //// Bytes per scan line.
	 1024,   //// XResol
	  768,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	   16,   //// Bits per pixel
	    0,   //// Refresh index
	 t546x_Mode_1024x768x16_4,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5462 | LG_5464,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   85,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 2048,   //// Bytes per scan line.
	 1024,   //// XResol
	  768,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	   16,   //// Bits per pixel
	    0,   //// Refresh index
	 t546x_Mode_1024x768x16_5,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5462 | LG_5464,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   70,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 2560,   //// Bytes per scan line.
	 1152,   //// XResol
	  864,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	   16,   //// Bits per pixel
	    0,   //// Refresh index
	 t546x_Mode_1152x864x16_1,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5462 | LG_5464,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   75,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 2560,   //// Bytes per scan line.
	 1152,   //// XResol
	  864,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	   16,   //// Bits per pixel
	    0,   //// Refresh index
	 t546x_Mode_1152x864x16_2,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5462 | LG_5464,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   85,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 2560,   //// Bytes per scan line.
	 1152,   //// XResol
	  864,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	   16,   //// Bits per pixel
	    0,   //// Refresh index
	 t546x_Mode_1152x864x16_3,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5462 | LG_5464,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   60,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 2560,   //// Bytes per scan line.
	 1280,   //// XResol
	  960,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	   16,   //// Bits per pixel
	    0,   //// Refresh index
	 t546x_Mode_1280x960x16_1,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5462 | LG_5464,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   75,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 2560,   //// Bytes per scan line.
	 1280,   //// XResol
	  960,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	   16,   //// Bits per pixel
	    0,   //// Refresh index
	 t546x_Mode_1280x960x16_2,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5462 | LG_5464,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   85,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 2560,   //// Bytes per scan line.
	 1280,   //// XResol
	  960,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	   16,   //// Bits per pixel
	    0,   //// Refresh index
	 t546x_Mode_1280x960x16_3,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5462 | LG_5464,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   43,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 2560,   //// Bytes per scan line.
	 1280,   //// XResol
	 1024,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	   16,   //// Bits per pixel
	    0,   //// Refresh index
	 t546x_Mode_1280x1024x16_1,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5462 | LG_5464,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   60,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 2560,   //// Bytes per scan line.
	 1280,   //// XResol
	 1024,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	   16,   //// Bits per pixel
	    0,   //// Refresh index
	 t546x_Mode_1280x1024x16_2,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5462 | LG_5464,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   71,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 2560,   //// Bytes per scan line.
	 1280,   //// XResol
	 1024,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	   16,   //// Bits per pixel
	    0,   //// Refresh index
	 t546x_Mode_1280x1024x16_3,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5462 | LG_5464,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   75,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 2560,   //// Bytes per scan line.
	 1280,   //// XResol
	 1024,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	   16,   //// Bits per pixel
	    0,   //// Refresh index
	 t546x_Mode_1280x1024x16_4,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5462 | LG_5464,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   70,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 2048,   //// Bytes per scan line.
	  640,   //// XResol
	  400,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	   24,   //// Bits per pixel
	    0,   //// Refresh index
	 t546x_Mode_640x400x24_1,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5462 | LG_5464,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   85,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 2048,   //// Bytes per scan line.
	  640,   //// XResol
	  400,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	   24,   //// Bits per pixel
	    0,   //// Refresh index
	 t546x_Mode_640x400x24_2,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5462 | LG_5464,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	  150,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 2048,   //// Bytes per scan line.
	  640,   //// XResol
	  400,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	   24,   //// Bits per pixel
	    0,   //// Refresh index
	 t546x_Mode_640x400x24_3,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5462 | LG_5464,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   60,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 2048,   //// Bytes per scan line.
	  640,   //// XResol
	  480,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	   24,   //// Bits per pixel
	    0,   //// Refresh index
	 t546x_Mode_640x480x24_1,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5462 | LG_5464,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   72,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 2048,   //// Bytes per scan line.
	  640,   //// XResol
	  480,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	   24,   //// Bits per pixel
	    0,   //// Refresh index
	 t546x_Mode_640x480x24_2,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5462 | LG_5464,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   75,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 2048,   //// Bytes per scan line.
	  640,   //// XResol
	  480,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	   24,   //// Bits per pixel
	    0,   //// Refresh index
	 t546x_Mode_640x480x24_3,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5462 | LG_5464,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   85,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 2048,   //// Bytes per scan line.
	  640,   //// XResol
	  480,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	   24,   //// Bits per pixel
	    0,   //// Refresh index
	 t546x_Mode_640x480x24_4,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5462 | LG_5464,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   56,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 2560,   //// Bytes per scan line.
	  800,   //// XResol
	  600,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	   24,   //// Bits per pixel
	    0,   //// Refresh index
	 t546x_Mode_800x600x24_1,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5462 | LG_5464,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   60,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 2560,   //// Bytes per scan line.
	  800,   //// XResol
	  600,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	   24,   //// Bits per pixel
	    0,   //// Refresh index
	 t546x_Mode_800x600x24_2,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5462 | LG_5464,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   72,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 2560,   //// Bytes per scan line.
	  800,   //// XResol
	  600,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	   24,   //// Bits per pixel
	    0,   //// Refresh index
	 t546x_Mode_800x600x24_3,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5462 | LG_5464,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   75,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 2560,   //// Bytes per scan line.
	  800,   //// XResol
	  600,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	   24,   //// Bits per pixel
	    0,   //// Refresh index
	 t546x_Mode_800x600x24_4,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5462 | LG_5464,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   85,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 2560,   //// Bytes per scan line.
	  800,   //// XResol
	  600,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	   24,   //// Bits per pixel
	    0,   //// Refresh index
	 t546x_Mode_800x600x24_5,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5462 | LG_5464,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   43,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 3328,   //// Bytes per scan line.
	 1024,   //// XResol
	  768,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	   24,   //// Bits per pixel
	    0,   //// Refresh index
	 t546x_Mode_1024x768x24_1,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5462 | LG_5464,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   60,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 3328,   //// Bytes per scan line.
	 1024,   //// XResol
	  768,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	   24,   //// Bits per pixel
	    0,   //// Refresh index
	 t546x_Mode_1024x768x24_2,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5462 | LG_5464,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   70,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 3328,   //// Bytes per scan line.
	 1024,   //// XResol
	  768,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	   24,   //// Bits per pixel
	    0,   //// Refresh index
	 t546x_Mode_1024x768x24_3,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5462 | LG_5464,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   75,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 3328,   //// Bytes per scan line.
	 1024,   //// XResol
	  768,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	   24,   //// Bits per pixel
	    0,   //// Refresh index
	 t546x_Mode_1024x768x24_4,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5462 | LG_5464,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   85,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 3328,   //// Bytes per scan line.
	 1024,   //// XResol
	  768,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	   24,   //// Bits per pixel
	    0,   //// Refresh index
	 t546x_Mode_1024x768x24_5,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5462 | LG_5464,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	    0,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	    0,   //// Bytes per scan line.
	    0,   //// XResol
	    0,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	    0,   //// Bits per pixel
	    0,   //// Refresh index
	 t546x_Mode_Reset,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5464,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   65,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 1664,   //// Bytes per scan line.
	 1600,   //// XResol
	 1200,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	    8,   //// Bits per pixel
	    0,   //// Refresh index
	 t5464_Mode_1600x1200x8_3,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5464,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   70,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 1664,   //// Bytes per scan line.
	 1600,   //// XResol
	 1200,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	    8,   //// Bits per pixel
	    0,   //// Refresh index
	 t5464_Mode_1600x1200x8_4,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5464,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   75,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 1664,   //// Bytes per scan line.
	 1600,   //// XResol
	 1200,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	    8,   //// Bits per pixel
	    0,   //// Refresh index
	 t5464_Mode_1600x1200x8_5,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5464,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   80,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 1664,   //// Bytes per scan line.
	 1600,   //// XResol
	 1200,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	    8,   //// Bits per pixel
	    0,   //// Refresh index
	 t5464_Mode_1600x1200x8_6,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5464,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   85,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 1664,   //// Bytes per scan line.
	 1600,   //// XResol
	 1200,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	    8,   //// Bits per pixel
	    0,   //// Refresh index
	 t5464_Mode_1600x1200x8_7,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5464,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   65,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 3328,   //// Bytes per scan line.
	 1600,   //// XResol
	 1200,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	    8,   //// Bits per pixel
	    0,   //// Refresh index
	 t5464_Mode_1600x1200x8_3a,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5464,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   70,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 3328,   //// Bytes per scan line.
	 1600,   //// XResol
	 1200,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	    8,   //// Bits per pixel
	    0,   //// Refresh index
	 t5464_Mode_1600x1200x8_4a,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5464,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   75,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 3328,   //// Bytes per scan line.
	 1600,   //// XResol
	 1200,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	    8,   //// Bits per pixel
	    0,   //// Refresh index
	 t5464_Mode_1600x1200x8_5a,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5464,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   80,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 3328,   //// Bytes per scan line.
	 1600,   //// XResol
	 1200,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	    8,   //// Bits per pixel
	    0,   //// Refresh index
	 t5464_Mode_1600x1200x8_6a,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5464,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   85,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 3328,   //// Bytes per scan line.
	 1600,   //// XResol
	 1200,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	    8,   //// Bits per pixel
	    0,   //// Refresh index
	 t5464_Mode_1600x1200x8_7a,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5464,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   75,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 1280,   //// Bytes per scan line.
	  320,   //// XResol
	  200,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	   15,   //// Bits per pixel
	    0,   //// Refresh index
	 t5464_Mode_320x200x15_1,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5464,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   60,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 1024,   //// Bytes per scan line.
	  320,   //// XResol
	  240,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	   15,   //// Bits per pixel
	    0,   //// Refresh index
	 t5464_Mode_320x240x15_1,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5464,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   73,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 1024,   //// Bytes per scan line.
	  320,   //// XResol
	  240,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	   15,   //// Bits per pixel
	    0,   //// Refresh index
	 t5464_Mode_320x240x15_2,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5464,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   75,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 1280,   //// Bytes per scan line.
	  320,   //// XResol
	  400,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	   15,   //// Bits per pixel
	    0,   //// Refresh index
	 t5464_Mode_320x400x15_1,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5464,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   60,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 1280,   //// Bytes per scan line.
	  320,   //// XResol
	  480,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	   15,   //// Bits per pixel
	    0,   //// Refresh index
	 t5464_Mode_320x480x15_1,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5464,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   73,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 1280,   //// Bytes per scan line.
	  320,   //// XResol
	  480,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	   15,   //// Bits per pixel
	    0,   //// Refresh index
	 t5464_Mode_320x480x15_2,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5464,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   75,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 1024,   //// Bytes per scan line.
	  360,   //// XResol
	  400,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	   15,   //// Bits per pixel
	    0,   //// Refresh index
	 t5464_Mode_360x400x15_1,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5464,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   85,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 1024,   //// Bytes per scan line.
	  360,   //// XResol
	  400,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	   15,   //// Bits per pixel
	    0,   //// Refresh index
	 t5464_Mode_360x400x15_2,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5464,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   60,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 1024,   //// Bytes per scan line.
	  400,   //// XResol
	  300,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	   15,   //// Bits per pixel
	    0,   //// Refresh index
	 t5464_Mode_400x300x15_1,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5464,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   75,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 1024,   //// Bytes per scan line.
	  400,   //// XResol
	  300,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	   15,   //// Bits per pixel
	    0,   //// Refresh index
	 t5464_Mode_400x300x15_2,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5464,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   60,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 1024,   //// Bytes per scan line.
	  512,   //// XResol
	  384,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	   15,   //// Bits per pixel
	    0,   //// Refresh index
	 t5464_Mode_512x384x15_1,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5464,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   70,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 1024,   //// Bytes per scan line.
	  512,   //// XResol
	  384,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	   15,   //// Bits per pixel
	    0,   //// Refresh index
	 t5464_Mode_512x384x15_2,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5464,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   63,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 1024,   //// Bytes per scan line.
	  512,   //// XResol
	  480,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	   15,   //// Bits per pixel
	    0,   //// Refresh index
	 t5464_Mode_512x480x15_1,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5464,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   75,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 1024,   //// Bytes per scan line.
	  512,   //// XResol
	  480,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	   15,   //// Bits per pixel
	    0,   //// Refresh index
	 t5464_Mode_512x480x15_2,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5464,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   70,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 1280,   //// Bytes per scan line.
	  640,   //// XResol
	  350,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	   15,   //// Bits per pixel
	    0,   //// Refresh index
	 t5464_Mode_640x350x15_1,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5464,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   85,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 1280,   //// Bytes per scan line.
	  640,   //// XResol
	  350,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	   15,   //// Bits per pixel
	    0,   //// Refresh index
	 t5464_Mode_640x350x15_2,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5464,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   70,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 1280,   //// Bytes per scan line.
	  640,   //// XResol
	  400,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	   15,   //// Bits per pixel
	    0,   //// Refresh index
	 t5464_Mode_640x400x15_1,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5464,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   85,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 1280,   //// Bytes per scan line.
	  640,   //// XResol
	  400,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	   15,   //// Bits per pixel
	    0,   //// Refresh index
	 t5464_Mode_640x400x15_2,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5464,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	  150,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 1280,   //// Bytes per scan line.
	  640,   //// XResol
	  400,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	   15,   //// Bits per pixel
	    0,   //// Refresh index
	 t5464_Mode_640x400x15_3,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5464,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   60,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 1280,   //// Bytes per scan line.
	  640,   //// XResol
	  480,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	   15,   //// Bits per pixel
	    0,   //// Refresh index
	 t5464_Mode_640x480x15_1,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5464,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   72,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 1280,   //// Bytes per scan line.
	  640,   //// XResol
	  480,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	   15,   //// Bits per pixel
	    0,   //// Refresh index
	 t5464_Mode_640x480x15_2,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5464,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   75,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 1280,   //// Bytes per scan line.
	  640,   //// XResol
	  480,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	   15,   //// Bits per pixel
	    0,   //// Refresh index
	 t5464_Mode_640x480x15_3,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5464,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   85,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 1280,   //// Bytes per scan line.
	  640,   //// XResol
	  480,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	   15,   //// Bits per pixel
	    0,   //// Refresh index
	 t5464_Mode_640x480x15_4,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5464,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   56,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 1664,   //// Bytes per scan line.
	  800,   //// XResol
	  600,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	   15,   //// Bits per pixel
	    0,   //// Refresh index
	 t5464_Mode_800x600x15_1,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5464,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   60,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 1664,   //// Bytes per scan line.
	  800,   //// XResol
	  600,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	   15,   //// Bits per pixel
	    0,   //// Refresh index
	 t5464_Mode_800x600x15_2,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5464,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   72,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 1664,   //// Bytes per scan line.
	  800,   //// XResol
	  600,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	   15,   //// Bits per pixel
	    0,   //// Refresh index
	 t5464_Mode_800x600x15_3,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5464,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   75,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 1664,   //// Bytes per scan line.
	  800,   //// XResol
	  600,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	   15,   //// Bits per pixel
	    0,   //// Refresh index
	 t5464_Mode_800x600x15_4,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5464,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   85,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 1664,   //// Bytes per scan line.
	  800,   //// XResol
	  600,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	   15,   //// Bits per pixel
	    0,   //// Refresh index
	 t5464_Mode_800x600x15_5,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5464,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   43,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 2048,   //// Bytes per scan line.
	 1024,   //// XResol
	  768,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	   15,   //// Bits per pixel
	    0,   //// Refresh index
	 t5464_Mode_1024x768x15_1,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5464,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   60,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 2048,   //// Bytes per scan line.
	 1024,   //// XResol
	  768,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	   15,   //// Bits per pixel
	    0,   //// Refresh index
	 t5464_Mode_1024x768x15_2,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5464,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   70,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 2048,   //// Bytes per scan line.
	 1024,   //// XResol
	  768,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	   15,   //// Bits per pixel
	    0,   //// Refresh index
	 t5464_Mode_1024x768x15_3,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5464,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   75,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 2048,   //// Bytes per scan line.
	 1024,   //// XResol
	  768,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	   15,   //// Bits per pixel
	    0,   //// Refresh index
	 t5464_Mode_1024x768x15_4,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5464,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   85,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 2048,   //// Bytes per scan line.
	 1024,   //// XResol
	  768,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	   15,   //// Bits per pixel
	    0,   //// Refresh index
	 t5464_Mode_1024x768x15_5,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5464,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   70,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 2560,   //// Bytes per scan line.
	 1152,   //// XResol
	  864,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	   15,   //// Bits per pixel
	    0,   //// Refresh index
	 t5464_Mode_1152x864x15_1,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5464,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   75,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 2560,   //// Bytes per scan line.
	 1152,   //// XResol
	  864,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	   15,   //// Bits per pixel
	    0,   //// Refresh index
	 t5464_Mode_1152x864x15_2,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5464,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   85,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 2560,   //// Bytes per scan line.
	 1152,   //// XResol
	  864,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	   15,   //// Bits per pixel
	    0,   //// Refresh index
	 t5464_Mode_1152x864x15_3,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5464,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   60,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 2560,   //// Bytes per scan line.
	 1280,   //// XResol
	  960,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	   15,   //// Bits per pixel
	    0,   //// Refresh index
	 t5464_Mode_1280x960x15_1,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5464,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   75,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 2560,   //// Bytes per scan line.
	 1280,   //// XResol
	  960,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	   15,   //// Bits per pixel
	    0,   //// Refresh index
	 t5464_Mode_1280x960x15_2,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5464,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   85,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 2560,   //// Bytes per scan line.
	 1280,   //// XResol
	  960,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	   15,   //// Bits per pixel
	    0,   //// Refresh index
	 t5464_Mode_1280x960x15_3,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5464,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   43,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 2560,   //// Bytes per scan line.
	 1280,   //// XResol
	 1024,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	   15,   //// Bits per pixel
	    0,   //// Refresh index
	 t5464_Mode_1280x1024x15_1,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5464,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   60,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 2560,   //// Bytes per scan line.
	 1280,   //// XResol
	 1024,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	   15,   //// Bits per pixel
	    0,   //// Refresh index
	 t5464_Mode_1280x1024x15_2,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5464,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   71,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 2560,   //// Bytes per scan line.
	 1280,   //// XResol
	 1024,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	   15,   //// Bits per pixel
	    0,   //// Refresh index
	 t5464_Mode_1280x1024x15_3,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5464,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   75,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 2560,   //// Bytes per scan line.
	 1280,   //// XResol
	 1024,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	   15,   //// Bits per pixel
	    0,   //// Refresh index
	 t5464_Mode_1280x1024x15_4,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5464,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   48,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 3328,   //// Bytes per scan line.
	 1600,   //// XResol
	 1200,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	   15,   //// Bits per pixel
	    0,   //// Refresh index
	 t5464_Mode_1600x1200x15_1,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5464,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   48,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 3328,   //// Bytes per scan line.
	 1600,   //// XResol
	 1200,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	   16,   //// Bits per pixel
	    0,   //// Refresh index
	 t5464_Mode_1600x1200x16_1,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5464,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   75,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 1280,   //// Bytes per scan line.
	  320,   //// XResol
	  200,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	   32,   //// Bits per pixel
	    0,   //// Refresh index
	 t5464_Mode_320x200x32_1,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5464,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   60,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 1280,   //// Bytes per scan line.
	  320,   //// XResol
	  240,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	   32,   //// Bits per pixel
	    0,   //// Refresh index
	 t5464_Mode_320x240x32_1,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5464,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   73,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 1280,   //// Bytes per scan line.
	  320,   //// XResol
	  240,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	   32,   //// Bits per pixel
	    0,   //// Refresh index
	 t5464_Mode_320x240x32_2,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5464,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   75,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 1280,   //// Bytes per scan line.
	  320,   //// XResol
	  400,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	   32,   //// Bits per pixel
	    0,   //// Refresh index
	 t5464_Mode_320x400x32_1,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5464,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   60,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 1280,   //// Bytes per scan line.
	  320,   //// XResol
	  480,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	   32,   //// Bits per pixel
	    0,   //// Refresh index
	 t5464_Mode_320x480x32_1,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5464,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   73,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 1280,   //// Bytes per scan line.
	  320,   //// XResol
	  480,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	   32,   //// Bits per pixel
	    0,   //// Refresh index
	 t5464_Mode_320x480x32_2,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5464,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   75,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 1664,   //// Bytes per scan line.
	  360,   //// XResol
	  400,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	   32,   //// Bits per pixel
	    0,   //// Refresh index
	 t5464_Mode_360x400x32_1,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5464,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   85,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 1664,   //// Bytes per scan line.
	  360,   //// XResol
	  400,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	   32,   //// Bits per pixel
	    0,   //// Refresh index
	 t5464_Mode_360x400x32_2,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5464,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   60,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 1664,   //// Bytes per scan line.
	  400,   //// XResol
	  300,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	   32,   //// Bits per pixel
	    0,   //// Refresh index
	 t5464_Mode_400x300x32_1,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5464,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   75,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 1664,   //// Bytes per scan line.
	  400,   //// XResol
	  300,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	   32,   //// Bits per pixel
	    0,   //// Refresh index
	 t5464_Mode_400x300x32_2,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5464,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   60,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 2048,   //// Bytes per scan line.
	  512,   //// XResol
	  384,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	   32,   //// Bits per pixel
	    0,   //// Refresh index
	 t5464_Mode_512x384x32_1,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5464,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   70,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 2048,   //// Bytes per scan line.
	  512,   //// XResol
	  384,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	   32,   //// Bits per pixel
	    0,   //// Refresh index
	 t5464_Mode_512x384x32_2,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5464,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   63,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 2048,   //// Bytes per scan line.
	  512,   //// XResol
	  480,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	   32,   //// Bits per pixel
	    0,   //// Refresh index
	 t5464_Mode_512x480x32_1,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5464,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   75,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 2048,   //// Bytes per scan line.
	  512,   //// XResol
	  480,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	   32,   //// Bits per pixel
	    0,   //// Refresh index
	 t5464_Mode_512x480x32_2,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5464,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   70,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 2560,   //// Bytes per scan line.
	  640,   //// XResol
	  350,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	   32,   //// Bits per pixel
	    0,   //// Refresh index
	 t5464_Mode_640x350x32_1,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5464,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   86,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 2560,   //// Bytes per scan line.
	  640,   //// XResol
	  350,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	   32,   //// Bits per pixel
	    0,   //// Refresh index
	 t5464_Mode_640x350x32_2,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5464,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   70,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 2560,   //// Bytes per scan line.
	  640,   //// XResol
	  400,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	   32,   //// Bits per pixel
	    0,   //// Refresh index
	 t5464_Mode_640x400x32_1,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5464,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   85,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 2560,   //// Bytes per scan line.
	  640,   //// XResol
	  400,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	   32,   //// Bits per pixel
	    0,   //// Refresh index
	 t5464_Mode_640x400x32_2,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5464,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   60,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 2560,   //// Bytes per scan line.
	  640,   //// XResol
	  480,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	   32,   //// Bits per pixel
	    0,   //// Refresh index
	 t5464_Mode_640x480x32_1,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5464,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   72,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 2560,   //// Bytes per scan line.
	  640,   //// XResol
	  480,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	   32,   //// Bits per pixel
	    0,   //// Refresh index
	 t5464_Mode_640x480x32_2,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5464,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   75,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 2560,   //// Bytes per scan line.
	  640,   //// XResol
	  480,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	   32,   //// Bits per pixel
	    0,   //// Refresh index
	 t5464_Mode_640x480x32_3,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5464,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   85,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 2560,   //// Bytes per scan line.
	  640,   //// XResol
	  480,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	   32,   //// Bits per pixel
	    0,   //// Refresh index
	 t5464_Mode_640x480x32_4,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5464,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   56,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 3328,   //// Bytes per scan line.
	  800,   //// XResol
	  600,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	   32,   //// Bits per pixel
	    0,   //// Refresh index
	 t5464_Mode_800x600x32_1,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5464,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   60,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 3328,   //// Bytes per scan line.
	  800,   //// XResol
	  600,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	   32,   //// Bits per pixel
	    0,   //// Refresh index
	 t5464_Mode_800x600x32_2,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5464,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   72,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 3328,   //// Bytes per scan line.
	  800,   //// XResol
	  600,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	   32,   //// Bits per pixel
	    0,   //// Refresh index
	 t5464_Mode_800x600x32_3,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5464,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   75,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 3328,   //// Bytes per scan line.
	  800,   //// XResol
	  600,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	   32,   //// Bits per pixel
	    0,   //// Refresh index
	 t5464_Mode_800x600x32_4,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5464,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   85,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 3328,   //// Bytes per scan line.
	  800,   //// XResol
	  600,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	   32,   //// Bits per pixel
	    0,   //// Refresh index
	 t5464_Mode_800x600x32_5,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5464,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   43,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 4096,   //// Bytes per scan line.
	 1024,   //// XResol
	  768,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	   32,   //// Bits per pixel
	    0,   //// Refresh index
	 t5464_Mode_1024x768x32_1,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5464,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   60,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 4096,   //// Bytes per scan line.
	 1024,   //// XResol
	  768,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	   32,   //// Bits per pixel
	    0,   //// Refresh index
	 t5464_Mode_1024x768x32_2,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5464,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   60,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 1024,   //// Bytes per scan line.
	  640,   //// XResol
	  480,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	    8,   //// Bits per pixel
	    0,   //// Refresh index
	 t5464_Mode_640x480x8_1,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5464,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   72,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 1024,   //// Bytes per scan line.
	  640,   //// XResol
	  480,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	    8,   //// Bits per pixel
	    0,   //// Refresh index
	 t5464_Mode_640x480x8_2,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5464,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   75,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 1024,   //// Bytes per scan line.
	  640,   //// XResol
	  480,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	    8,   //// Bits per pixel
	    0,   //// Refresh index
	 t5464_Mode_640x480x8_3,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5464,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   85,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 1024,   //// Bytes per scan line.
	  640,   //// XResol
	  480,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	    8,   //// Bits per pixel
	    0,   //// Refresh index
	 t5464_Mode_640x480x8_4,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5464,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   60,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 1280,   //// Bytes per scan line.
	  640,   //// XResol
	  480,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	    8,   //// Bits per pixel
	    0,   //// Refresh index
	 t5464_Mode_640x480x8_1a,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5464,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   72,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 1280,   //// Bytes per scan line.
	  640,   //// XResol
	  480,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	    8,   //// Bits per pixel
	    0,   //// Refresh index
	 t5464_Mode_640x480x8_2a,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5464,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   75,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 1280,   //// Bytes per scan line.
	  640,   //// XResol
	  480,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	    8,   //// Bits per pixel
	    0,   //// Refresh index
	 t5464_Mode_640x480x8_3a,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5464,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   85,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 1280,   //// Bytes per scan line.
	  640,   //// XResol
	  480,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	    8,   //// Bits per pixel
	    0,   //// Refresh index
	 t5464_Mode_640x480x8_4a,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5464,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   75,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	  640,   //// Bytes per scan line.
	  320,   //// XResol
	  200,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	    8,   //// Bits per pixel
	    0,   //// Refresh index
	 t5464_Mode_320x200x8_1,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5464,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   60,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	  640,   //// Bytes per scan line.
	  320,   //// XResol
	  240,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	    8,   //// Bits per pixel
	    0,   //// Refresh index
	 t5464_Mode_320x240x8_1,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5464,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   73,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	  640,   //// Bytes per scan line.
	  320,   //// XResol
	  240,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	    8,   //// Bits per pixel
	    0,   //// Refresh index
	 t5464_Mode_320x240x8_2,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5464,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   75,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	  640,   //// Bytes per scan line.
	  320,   //// XResol
	  400,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	    8,   //// Bits per pixel
	    0,   //// Refresh index
	 t5464_Mode_320x400x8_1,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5464,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   60,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	  640,   //// Bytes per scan line.
	  320,   //// XResol
	  480,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	    8,   //// Bits per pixel
	    0,   //// Refresh index
	 t5464_Mode_320x480x8_1,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5464,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   73,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	  640,   //// Bytes per scan line.
	  320,   //// XResol
	  480,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	    8,   //// Bits per pixel
	    0,   //// Refresh index
	 t5464_Mode_320x480x8_2,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5464,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   75,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 1024,   //// Bytes per scan line.
	  360,   //// XResol
	  400,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	    8,   //// Bits per pixel
	    0,   //// Refresh index
	 t5464_Mode_360x400x8_1,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5464,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   85,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 1024,   //// Bytes per scan line.
	  360,   //// XResol
	  400,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	    8,   //// Bits per pixel
	    0,   //// Refresh index
	 t5464_Mode_360x400x8_2,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5464,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   60,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 1024,   //// Bytes per scan line.
	  400,   //// XResol
	  300,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	    8,   //// Bits per pixel
	    0,   //// Refresh index
	 t5464_Mode_400x300x8_1,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5464,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   75,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 1024,   //// Bytes per scan line.
	  400,   //// XResol
	  300,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	    8,   //// Bits per pixel
	    0,   //// Refresh index
	 t5464_Mode_400x300x8_2,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5464,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   60,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 1024,   //// Bytes per scan line.
	  512,   //// XResol
	  384,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	    8,   //// Bits per pixel
	    0,   //// Refresh index
	 t5464_Mode_512x384x8_1,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5464,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   70,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 1024,   //// Bytes per scan line.
	  512,   //// XResol
	  384,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	    8,   //// Bits per pixel
	    0,   //// Refresh index
	 t5464_Mode_512x384x8_2,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5464,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   63,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 1024,   //// Bytes per scan line.
	  512,   //// XResol
	  480,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	    8,   //// Bits per pixel
	    0,   //// Refresh index
	 t5464_Mode_512x480x8_1,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5464,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   75,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 1024,   //// Bytes per scan line.
	  512,   //// XResol
	  480,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	    8,   //// Bits per pixel
	    0,   //// Refresh index
	 t5464_Mode_512x480x8_2,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5464,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   70,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 1280,   //// Bytes per scan line.
	  640,   //// XResol
	  350,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	    8,   //// Bits per pixel
	    0,   //// Refresh index
	 t5464_Mode_640x350x8_1,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5464,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   85,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 1280,   //// Bytes per scan line.
	  640,   //// XResol
	  350,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	    8,   //// Bits per pixel
	    0,   //// Refresh index
	 t5464_Mode_640x350x8_2,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5464,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   70,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	  640,   //// Bytes per scan line.
	  640,   //// XResol
	  400,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	    8,   //// Bits per pixel
	    0,   //// Refresh index
	 t5464_Mode_640x400x8_1,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5464,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   70,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 1280,   //// Bytes per scan line.
	  640,   //// XResol
	  400,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	    8,   //// Bits per pixel
	    0,   //// Refresh index
	 t5464_Mode_640x400x8_1a,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5464,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   85,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	  640,   //// Bytes per scan line.
	  640,   //// XResol
	  400,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	    8,   //// Bits per pixel
	    0,   //// Refresh index
	 t5464_Mode_640x400x8_2,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5464,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   85,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 1280,   //// Bytes per scan line.
	  640,   //// XResol
	  400,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	    8,   //// Bits per pixel
	    0,   //// Refresh index
	 t5464_Mode_640x400x8_2a,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5464,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	  150,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	  640,   //// Bytes per scan line.
	  640,   //// XResol
	  400,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	    8,   //// Bits per pixel
	    0,   //// Refresh index
	 t5464_Mode_640x400x8_3,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5464,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	  150,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 1280,   //// Bytes per scan line.
	  640,   //// XResol
	  400,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	    8,   //// Bits per pixel
	    0,   //// Refresh index
	 t5464_Mode_640x400x8_3a,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5464,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   56,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 1024,   //// Bytes per scan line.
	  800,   //// XResol
	  600,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	    8,   //// Bits per pixel
	    0,   //// Refresh index
	 t5464_Mode_800x600x8_1,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5464,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   60,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 1024,   //// Bytes per scan line.
	  800,   //// XResol
	  600,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	    8,   //// Bits per pixel
	    0,   //// Refresh index
	 t5464_Mode_800x600x8_2,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5464,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   72,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 1024,   //// Bytes per scan line.
	  800,   //// XResol
	  600,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	    8,   //// Bits per pixel
	    0,   //// Refresh index
	 t5464_Mode_800x600x8_3,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5464,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   75,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 1024,   //// Bytes per scan line.
	  800,   //// XResol
	  600,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	    8,   //// Bits per pixel
	    0,   //// Refresh index
	 t5464_Mode_800x600x8_4,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5464,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   85,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 1024,   //// Bytes per scan line.
	  800,   //// XResol
	  600,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	    8,   //// Bits per pixel
	    0,   //// Refresh index
	 t5464_Mode_800x600x8_5,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5464,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   56,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 1664,   //// Bytes per scan line.
	  800,   //// XResol
	  600,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	    8,   //// Bits per pixel
	    0,   //// Refresh index
	 t5464_Mode_800x600x8_1a,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5464,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   60,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 1664,   //// Bytes per scan line.
	  800,   //// XResol
	  600,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	    8,   //// Bits per pixel
	    0,   //// Refresh index
	 t5464_Mode_800x600x8_2a,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5464,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   72,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 1664,   //// Bytes per scan line.
	  800,   //// XResol
	  600,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	    8,   //// Bits per pixel
	    0,   //// Refresh index
	 t5464_Mode_800x600x8_3a,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5464,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   75,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 1664,   //// Bytes per scan line.
	  800,   //// XResol
	  600,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	    8,   //// Bits per pixel
	    0,   //// Refresh index
	 t5464_Mode_800x600x8_4a,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5464,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   85,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 1664,   //// Bytes per scan line.
	  800,   //// XResol
	  600,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	    8,   //// Bits per pixel
	    0,   //// Refresh index
	 t5464_Mode_800x600x8_5a,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5464,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   43,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 1280,   //// Bytes per scan line.
	 1024,   //// XResol
	  768,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	    8,   //// Bits per pixel
	    0,   //// Refresh index
	 t5464_Mode_1024x768x8_1,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5464,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   60,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 1280,   //// Bytes per scan line.
	 1024,   //// XResol
	  768,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	    8,   //// Bits per pixel
	    0,   //// Refresh index
	 t5464_Mode_1024x768x8_2,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5464,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   70,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 1280,   //// Bytes per scan line.
	 1024,   //// XResol
	  768,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	    8,   //// Bits per pixel
	    0,   //// Refresh index
	 t5464_Mode_1024x768x8_3,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5464,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   75,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 1280,   //// Bytes per scan line.
	 1024,   //// XResol
	  768,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	    8,   //// Bits per pixel
	    0,   //// Refresh index
	 t5464_Mode_1024x768x8_4,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5464,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   85,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 1280,   //// Bytes per scan line.
	 1024,   //// XResol
	  768,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	    8,   //// Bits per pixel
	    0,   //// Refresh index
	 t5464_Mode_1024x768x8_5,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5464,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   43,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 2048,   //// Bytes per scan line.
	 1024,   //// XResol
	  768,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	    8,   //// Bits per pixel
	    0,   //// Refresh index
	 t5464_Mode_1024x768x8_1a,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5464,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   60,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 2048,   //// Bytes per scan line.
	 1024,   //// XResol
	  768,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	    8,   //// Bits per pixel
	    0,   //// Refresh index
	 t5464_Mode_1024x768x8_2a,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5464,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   70,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 2048,   //// Bytes per scan line.
	 1024,   //// XResol
	  768,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	    8,   //// Bits per pixel
	    0,   //// Refresh index
	 t5464_Mode_1024x768x8_3a,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5464,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   75,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 2048,   //// Bytes per scan line.
	 1024,   //// XResol
	  768,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	    8,   //// Bits per pixel
	    0,   //// Refresh index
	 t5464_Mode_1024x768x8_4a,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5464,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   85,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 2048,   //// Bytes per scan line.
	 1024,   //// XResol
	  768,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	    8,   //// Bits per pixel
	    0,   //// Refresh index
	 t5464_Mode_1024x768x8_5a,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5464,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   70,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 1280,   //// Bytes per scan line.
	 1152,   //// XResol
	  864,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	    8,   //// Bits per pixel
	    0,   //// Refresh index
	 t5464_Mode_1152x864x8_1,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5464,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   75,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 1280,   //// Bytes per scan line.
	 1152,   //// XResol
	  864,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	    8,   //// Bits per pixel
	    0,   //// Refresh index
	 t5464_Mode_1152x864x8_2,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5464,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   85,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 1280,   //// Bytes per scan line.
	 1152,   //// XResol
	  864,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	    8,   //// Bits per pixel
	    0,   //// Refresh index
	 t5464_Mode_1152x864x8_3,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5464,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   60,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 1280,   //// Bytes per scan line.
	 1280,   //// XResol
	  960,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	    8,   //// Bits per pixel
	    0,   //// Refresh index
	 t5464_Mode_1280x960x8_1,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5464,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   75,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 1280,   //// Bytes per scan line.
	 1280,   //// XResol
	  960,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	    8,   //// Bits per pixel
	    0,   //// Refresh index
	 t5464_Mode_1280x960x8_2,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5464,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   85,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 1280,   //// Bytes per scan line.
	 1280,   //// XResol
	  960,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	    8,   //// Bits per pixel
	    0,   //// Refresh index
	 t5464_Mode_1280x960x8_3,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5464,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   43,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 1280,   //// Bytes per scan line.
	 1280,   //// XResol
	 1024,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	    8,   //// Bits per pixel
	    0,   //// Refresh index
	 t5464_Mode_1280x1024x8_1,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5464,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   60,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 1280,   //// Bytes per scan line.
	 1280,   //// XResol
	 1024,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	    8,   //// Bits per pixel
	    0,   //// Refresh index
	 t5464_Mode_1280x1024x8_2,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5464,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   71,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 1280,   //// Bytes per scan line.
	 1280,   //// XResol
	 1024,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	    8,   //// Bits per pixel
	    0,   //// Refresh index
	 t5464_Mode_1280x1024x8_3,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5464,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   75,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 1280,   //// Bytes per scan line.
	 1280,   //// XResol
	 1024,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	    8,   //// Bits per pixel
	    0,   //// Refresh index
	 t5464_Mode_1280x1024x8_4,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5464,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   85,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 1280,   //// Bytes per scan line.
	 1280,   //// XResol
	 1024,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	    8,   //// Bits per pixel
	    0,   //// Refresh index
	 t5464_Mode_1280x1024x8_5,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5464,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   43,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 2560,   //// Bytes per scan line.
	 1280,   //// XResol
	 1024,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	    8,   //// Bits per pixel
	    0,   //// Refresh index
	 t5464_Mode_1280x1024x8_1a,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5464,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   60,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 2560,   //// Bytes per scan line.
	 1280,   //// XResol
	 1024,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	    8,   //// Bits per pixel
	    0,   //// Refresh index
	 t5464_Mode_1280x1024x8_2a,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5464,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   71,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 2560,   //// Bytes per scan line.
	 1280,   //// XResol
	 1024,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	    8,   //// Bits per pixel
	    0,   //// Refresh index
	 t5464_Mode_1280x1024x8_3a,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5464,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   75,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 2560,   //// Bytes per scan line.
	 1280,   //// XResol
	 1024,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	    8,   //// Bits per pixel
	    0,   //// Refresh index
	 t5464_Mode_1280x1024x8_4a,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5464,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   85,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 2560,   //// Bytes per scan line.
	 1280,   //// XResol
	 1024,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	    8,   //// Bits per pixel
	    0,   //// Refresh index
	 t5464_Mode_1280x1024x8_5a,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5464,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   48,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 1664,   //// Bytes per scan line.
	 1600,   //// XResol
	 1200,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	    8,   //// Bits per pixel
	    0,   //// Refresh index
	 t5464_Mode_1600x1200x8_1,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5464,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   60,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 1664,   //// Bytes per scan line.
	 1600,   //// XResol
	 1200,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	    8,   //// Bits per pixel
	    0,   //// Refresh index
	 t5464_Mode_1600x1200x8_2,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5464,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   48,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 3328,   //// Bytes per scan line.
	 1600,   //// XResol
	 1200,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	    8,   //// Bits per pixel
	    0,   //// Refresh index
	 t5464_Mode_1600x1200x8_1a,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5464,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   60,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 3328,   //// Bytes per scan line.
	 1600,   //// XResol
	 1200,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	    8,   //// Bits per pixel
	    0,   //// Refresh index
	 t5464_Mode_1600x1200x8_2a,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5464,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   75,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 1280,   //// Bytes per scan line.
	  320,   //// XResol
	  200,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	   16,   //// Bits per pixel
	    0,   //// Refresh index
	 t5464_Mode_320x200x16_1,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5464,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   60,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 1024,   //// Bytes per scan line.
	  320,   //// XResol
	  240,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	   16,   //// Bits per pixel
	    0,   //// Refresh index
	 t5464_Mode_320x240x16_1,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5464,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   73,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 1024,   //// Bytes per scan line.
	  320,   //// XResol
	  240,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	   16,   //// Bits per pixel
	    0,   //// Refresh index
	 t5464_Mode_320x240x16_2,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5464,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   75,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 1280,   //// Bytes per scan line.
	  320,   //// XResol
	  400,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	   16,   //// Bits per pixel
	    0,   //// Refresh index
	 t5464_Mode_320x400x16_1,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5464,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   60,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 1280,   //// Bytes per scan line.
	  320,   //// XResol
	  480,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	   16,   //// Bits per pixel
	    0,   //// Refresh index
	 t5464_Mode_320x480x16_1,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5464,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   73,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 1280,   //// Bytes per scan line.
	  320,   //// XResol
	  480,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	   16,   //// Bits per pixel
	    0,   //// Refresh index
	 t5464_Mode_320x480x16_2,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5464,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   75,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 1024,   //// Bytes per scan line.
	  360,   //// XResol
	  400,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	   16,   //// Bits per pixel
	    0,   //// Refresh index
	 t5464_Mode_360x400x16_1,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5464,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   85,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 1024,   //// Bytes per scan line.
	  360,   //// XResol
	  400,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	   16,   //// Bits per pixel
	    0,   //// Refresh index
	 t5464_Mode_360x400x16_2,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5464,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   60,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 1024,   //// Bytes per scan line.
	  400,   //// XResol
	  300,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	   16,   //// Bits per pixel
	    0,   //// Refresh index
	 t5464_Mode_400x300x16_1,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5464,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   75,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 1024,   //// Bytes per scan line.
	  400,   //// XResol
	  300,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	   16,   //// Bits per pixel
	    0,   //// Refresh index
	 t5464_Mode_400x300x16_2,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5464,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   60,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 1024,   //// Bytes per scan line.
	  512,   //// XResol
	  384,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	   16,   //// Bits per pixel
	    0,   //// Refresh index
	 t5464_Mode_512x384x16_1,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5464,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   70,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 1024,   //// Bytes per scan line.
	  512,   //// XResol
	  384,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	   16,   //// Bits per pixel
	    0,   //// Refresh index
	 t5464_Mode_512x384x16_2,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5464,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   63,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 1024,   //// Bytes per scan line.
	  512,   //// XResol
	  480,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	   16,   //// Bits per pixel
	    0,   //// Refresh index
	 t5464_Mode_512x480x16_1,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5464,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   75,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 1024,   //// Bytes per scan line.
	  512,   //// XResol
	  480,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	   16,   //// Bits per pixel
	    0,   //// Refresh index
	 t5464_Mode_512x480x16_2,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5464,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   70,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 1280,   //// Bytes per scan line.
	  640,   //// XResol
	  350,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	   16,   //// Bits per pixel
	    0,   //// Refresh index
	 t5464_Mode_640x350x16_1,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5464,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   85,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 1280,   //// Bytes per scan line.
	  640,   //// XResol
	  350,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	   16,   //// Bits per pixel
	    0,   //// Refresh index
	 t5464_Mode_640x350x16_2,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5464,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   70,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 1280,   //// Bytes per scan line.
	  640,   //// XResol
	  400,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	   16,   //// Bits per pixel
	    0,   //// Refresh index
	 t5464_Mode_640x400x16_1,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5464,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   60,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 1280,   //// Bytes per scan line.
	  640,   //// XResol
	  480,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	   16,   //// Bits per pixel
	    0,   //// Refresh index
	 t5464_Mode_640x480x16_1,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5464,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   72,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 1280,   //// Bytes per scan line.
	  640,   //// XResol
	  480,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	   16,   //// Bits per pixel
	    0,   //// Refresh index
	 t5464_Mode_640x480x16_2,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5464,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   75,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 1280,   //// Bytes per scan line.
	  640,   //// XResol
	  480,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	   16,   //// Bits per pixel
	    0,   //// Refresh index
	 t5464_Mode_640x480x16_3,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5464,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   85,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 1280,   //// Bytes per scan line.
	  640,   //// XResol
	  480,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	   16,   //// Bits per pixel
	    0,   //// Refresh index
	 t5464_Mode_640x480x16_4,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5464,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   56,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 1664,   //// Bytes per scan line.
	  800,   //// XResol
	  600,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	   16,   //// Bits per pixel
	    0,   //// Refresh index
	 t5464_Mode_800x600x16_1,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5464,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   60,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 1664,   //// Bytes per scan line.
	  800,   //// XResol
	  600,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	   16,   //// Bits per pixel
	    0,   //// Refresh index
	 t5464_Mode_800x600x16_2,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5464,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   72,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 1664,   //// Bytes per scan line.
	  800,   //// XResol
	  600,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	   16,   //// Bits per pixel
	    0,   //// Refresh index
	 t5464_Mode_800x600x16_3,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5464,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   75,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 1664,   //// Bytes per scan line.
	  800,   //// XResol
	  600,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	   16,   //// Bits per pixel
	    0,   //// Refresh index
	 t5464_Mode_800x600x16_4,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5464,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   85,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 1664,   //// Bytes per scan line.
	  800,   //// XResol
	  600,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	   16,   //// Bits per pixel
	    0,   //// Refresh index
	 t5464_Mode_800x600x16_5,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5464,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   43,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 2048,   //// Bytes per scan line.
	 1024,   //// XResol
	  768,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	   16,   //// Bits per pixel
	    0,   //// Refresh index
	 t5464_Mode_1024x768x16_1,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5464,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   60,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 2048,   //// Bytes per scan line.
	 1024,   //// XResol
	  768,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	   16,   //// Bits per pixel
	    0,   //// Refresh index
	 t5464_Mode_1024x768x16_2,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5464,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   70,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 2048,   //// Bytes per scan line.
	 1024,   //// XResol
	  768,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	   16,   //// Bits per pixel
	    0,   //// Refresh index
	 t5464_Mode_1024x768x16_3,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5464,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   75,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 2048,   //// Bytes per scan line.
	 1024,   //// XResol
	  768,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	   16,   //// Bits per pixel
	    0,   //// Refresh index
	 t5464_Mode_1024x768x16_4,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5464,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   85,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 2048,   //// Bytes per scan line.
	 1024,   //// XResol
	  768,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	   16,   //// Bits per pixel
	    0,   //// Refresh index
	 t5464_Mode_1024x768x16_5,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5464,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   70,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 2560,   //// Bytes per scan line.
	 1152,   //// XResol
	  864,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	   16,   //// Bits per pixel
	    0,   //// Refresh index
	 t5464_Mode_1152x864x16_1,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5464,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   75,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 2560,   //// Bytes per scan line.
	 1152,   //// XResol
	  864,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	   16,   //// Bits per pixel
	    0,   //// Refresh index
	 t5464_Mode_1152x864x16_2,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5464,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   85,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 2560,   //// Bytes per scan line.
	 1152,   //// XResol
	  864,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	   16,   //// Bits per pixel
	    0,   //// Refresh index
	 t5464_Mode_1152x864x16_3,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5464,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   60,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 2560,   //// Bytes per scan line.
	 1280,   //// XResol
	  960,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	   16,   //// Bits per pixel
	    0,   //// Refresh index
	 t5464_Mode_1280x960x16_1,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5464,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   75,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 2560,   //// Bytes per scan line.
	 1280,   //// XResol
	  960,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	   16,   //// Bits per pixel
	    0,   //// Refresh index
	 t5464_Mode_1280x960x16_2,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5464,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   85,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 2560,   //// Bytes per scan line.
	 1280,   //// XResol
	  960,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	   16,   //// Bits per pixel
	    0,   //// Refresh index
	 t5464_Mode_1280x960x16_3,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5464,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   43,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 2560,   //// Bytes per scan line.
	 1280,   //// XResol
	 1024,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	   16,   //// Bits per pixel
	    0,   //// Refresh index
	 t5464_Mode_1280x1024x16_1,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5464,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   60,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 2560,   //// Bytes per scan line.
	 1280,   //// XResol
	 1024,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	   16,   //// Bits per pixel
	    0,   //// Refresh index
	 t5464_Mode_1280x1024x16_2,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5464,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   71,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 2560,   //// Bytes per scan line.
	 1280,   //// XResol
	 1024,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	   16,   //// Bits per pixel
	    0,   //// Refresh index
	 t5464_Mode_1280x1024x16_3,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5464,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   75,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 2560,   //// Bytes per scan line.
	 1280,   //// XResol
	 1024,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	   16,   //// Bits per pixel
	    0,   //// Refresh index
	 t5464_Mode_1280x1024x16_4,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5464,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   70,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 2048,   //// Bytes per scan line.
	  640,   //// XResol
	  400,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	   24,   //// Bits per pixel
	    0,   //// Refresh index
	 t5464_Mode_640x400x24_1,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5464,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   85,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 2048,   //// Bytes per scan line.
	  640,   //// XResol
	  400,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	   24,   //// Bits per pixel
	    0,   //// Refresh index
	 t5464_Mode_640x400x24_2,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5464,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	  150,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 2048,   //// Bytes per scan line.
	  640,   //// XResol
	  400,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	   24,   //// Bits per pixel
	    0,   //// Refresh index
	 t5464_Mode_640x400x24_3,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5464,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   60,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 2048,   //// Bytes per scan line.
	  640,   //// XResol
	  480,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	   24,   //// Bits per pixel
	    0,   //// Refresh index
	 t5464_Mode_640x480x24_1,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5464,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   72,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 2048,   //// Bytes per scan line.
	  640,   //// XResol
	  480,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	   24,   //// Bits per pixel
	    0,   //// Refresh index
	 t5464_Mode_640x480x24_2,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5464,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   75,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 2048,   //// Bytes per scan line.
	  640,   //// XResol
	  480,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	   24,   //// Bits per pixel
	    0,   //// Refresh index
	 t5464_Mode_640x480x24_3,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5464,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   85,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 2048,   //// Bytes per scan line.
	  640,   //// XResol
	  480,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	   24,   //// Bits per pixel
	    0,   //// Refresh index
	 t5464_Mode_640x480x24_4,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5464,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   56,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 2560,   //// Bytes per scan line.
	  800,   //// XResol
	  600,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	   24,   //// Bits per pixel
	    0,   //// Refresh index
	 t5464_Mode_800x600x24_1,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5464,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   60,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 2560,   //// Bytes per scan line.
	  800,   //// XResol
	  600,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	   24,   //// Bits per pixel
	    0,   //// Refresh index
	 t5464_Mode_800x600x24_2,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5464,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   72,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 2560,   //// Bytes per scan line.
	  800,   //// XResol
	  600,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	   24,   //// Bits per pixel
	    0,   //// Refresh index
	 t5464_Mode_800x600x24_3,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5464,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   75,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 2560,   //// Bytes per scan line.
	  800,   //// XResol
	  600,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	   24,   //// Bits per pixel
	    0,   //// Refresh index
	 t5464_Mode_800x600x24_4,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5464,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   85,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 2560,   //// Bytes per scan line.
	  800,   //// XResol
	  600,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	   24,   //// Bits per pixel
	    0,   //// Refresh index
	 t5464_Mode_800x600x24_5,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5464,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   43,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 3328,   //// Bytes per scan line.
	 1024,   //// XResol
	  768,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	   24,   //// Bits per pixel
	    0,   //// Refresh index
	 t5464_Mode_1024x768x24_1,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5464,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   60,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 3328,   //// Bytes per scan line.
	 1024,   //// XResol
	  768,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	   24,   //// Bits per pixel
	    0,   //// Refresh index
	 t5464_Mode_1024x768x24_2,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5464,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   70,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 3328,   //// Bytes per scan line.
	 1024,   //// XResol
	  768,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	   24,   //// Bits per pixel
	    0,   //// Refresh index
	 t5464_Mode_1024x768x24_3,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5464,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   75,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 3328,   //// Bytes per scan line.
	 1024,   //// XResol
	  768,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	   24,   //// Bits per pixel
	    0,   //// Refresh index
	 t5464_Mode_1024x768x24_4,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5464,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   85,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 3328,   //// Bytes per scan line.
	 1024,   //// XResol
	  768,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	   24,   //// Bits per pixel
	    0,   //// Refresh index
	 t5464_Mode_1024x768x24_5,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5464,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	    0,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	    0,   //// Bytes per scan line.
	    0,   //// XResol
	    0,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	    0,   //// Bits per pixel
	    0,   //// Refresh index
	 t5464_Mode_Reset,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5465,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   60,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 1024,   //// Bytes per scan line.
	  640,   //// XResol
	  480,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	    8,   //// Bits per pixel
	    0,   //// Refresh index
	 t5465_Mode_640x480x8_1,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5465,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   72,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 1024,   //// Bytes per scan line.
	  640,   //// XResol
	  480,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	    8,   //// Bits per pixel
	    0,   //// Refresh index
	 t5465_Mode_640x480x8_2,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5465,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   75,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 1024,   //// Bytes per scan line.
	  640,   //// XResol
	  480,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	    8,   //// Bits per pixel
	    0,   //// Refresh index
	 t5465_Mode_640x480x8_3,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5465,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   85,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 1024,   //// Bytes per scan line.
	  640,   //// XResol
	  480,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	    8,   //// Bits per pixel
	    0,   //// Refresh index
	 t5465_Mode_640x480x8_4,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5465,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   60,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 1280,   //// Bytes per scan line.
	  640,   //// XResol
	  480,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	    8,   //// Bits per pixel
	    0,   //// Refresh index
	 t5465_Mode_640x480x8_1a,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5465,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   72,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 1280,   //// Bytes per scan line.
	  640,   //// XResol
	  480,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	    8,   //// Bits per pixel
	    0,   //// Refresh index
	 t5465_Mode_640x480x8_2a,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5465,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   75,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 1280,   //// Bytes per scan line.
	  640,   //// XResol
	  480,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	    8,   //// Bits per pixel
	    0,   //// Refresh index
	 t5465_Mode_640x480x8_3a,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5465,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   85,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 1280,   //// Bytes per scan line.
	  640,   //// XResol
	  480,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	    8,   //// Bits per pixel
	    0,   //// Refresh index
	 t5465_Mode_640x480x8_4a,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5465,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   75,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	  640,   //// Bytes per scan line.
	  320,   //// XResol
	  200,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	    8,   //// Bits per pixel
	    0,   //// Refresh index
	 t5465_Mode_320x200x8_1,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5465,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   60,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	  640,   //// Bytes per scan line.
	  320,   //// XResol
	  240,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	    8,   //// Bits per pixel
	    0,   //// Refresh index
	 t5465_Mode_320x240x8_1,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5465,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   73,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	  640,   //// Bytes per scan line.
	  320,   //// XResol
	  240,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	    8,   //// Bits per pixel
	    0,   //// Refresh index
	 t5465_Mode_320x240x8_2,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5465,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   75,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	  640,   //// Bytes per scan line.
	  320,   //// XResol
	  400,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	    8,   //// Bits per pixel
	    0,   //// Refresh index
	 t5465_Mode_320x400x8_1,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5465,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   60,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	  640,   //// Bytes per scan line.
	  320,   //// XResol
	  480,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	    8,   //// Bits per pixel
	    0,   //// Refresh index
	 t5465_Mode_320x480x8_1,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5465,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   73,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	  640,   //// Bytes per scan line.
	  320,   //// XResol
	  480,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	    8,   //// Bits per pixel
	    0,   //// Refresh index
	 t5465_Mode_320x480x8_2,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5465,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   75,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 1024,   //// Bytes per scan line.
	  360,   //// XResol
	  400,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	    8,   //// Bits per pixel
	    0,   //// Refresh index
	 t5465_Mode_360x400x8_1,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5465,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   85,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 1024,   //// Bytes per scan line.
	  360,   //// XResol
	  400,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	    8,   //// Bits per pixel
	    0,   //// Refresh index
	 t5465_Mode_360x400x8_2,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5465,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   60,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 1024,   //// Bytes per scan line.
	  400,   //// XResol
	  300,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	    8,   //// Bits per pixel
	    0,   //// Refresh index
	 t5465_Mode_400x300x8_1,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5465,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   75,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 1024,   //// Bytes per scan line.
	  400,   //// XResol
	  300,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	    8,   //// Bits per pixel
	    0,   //// Refresh index
	 t5465_Mode_400x300x8_2,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5465,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   60,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 1024,   //// Bytes per scan line.
	  512,   //// XResol
	  384,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	    8,   //// Bits per pixel
	    0,   //// Refresh index
	 t5465_Mode_512x384x8_1,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5465,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   70,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 1024,   //// Bytes per scan line.
	  512,   //// XResol
	  384,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	    8,   //// Bits per pixel
	    0,   //// Refresh index
	 t5465_Mode_512x384x8_2,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5465,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   63,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 1024,   //// Bytes per scan line.
	  512,   //// XResol
	  480,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	    8,   //// Bits per pixel
	    0,   //// Refresh index
	 t5465_Mode_512x480x8_1,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5465,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   75,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 1024,   //// Bytes per scan line.
	  512,   //// XResol
	  480,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	    8,   //// Bits per pixel
	    0,   //// Refresh index
	 t5465_Mode_512x480x8_2,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5465,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   70,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 1280,   //// Bytes per scan line.
	  640,   //// XResol
	  350,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	    8,   //// Bits per pixel
	    0,   //// Refresh index
	 t5465_Mode_640x350x8_1,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5465,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   85,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 1280,   //// Bytes per scan line.
	  640,   //// XResol
	  350,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	    8,   //// Bits per pixel
	    0,   //// Refresh index
	 t5465_Mode_640x350x8_2,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5465,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   70,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	  640,   //// Bytes per scan line.
	  640,   //// XResol
	  400,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	    8,   //// Bits per pixel
	    0,   //// Refresh index
	 t5465_Mode_640x400x8_1,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5465,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   70,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 1280,   //// Bytes per scan line.
	  640,   //// XResol
	  400,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	    8,   //// Bits per pixel
	    0,   //// Refresh index
	 t5465_Mode_640x400x8_1a,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5465,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   85,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	  640,   //// Bytes per scan line.
	  640,   //// XResol
	  400,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	    8,   //// Bits per pixel
	    0,   //// Refresh index
	 t5465_Mode_640x400x8_2,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5465,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   85,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 1280,   //// Bytes per scan line.
	  640,   //// XResol
	  400,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	    8,   //// Bits per pixel
	    0,   //// Refresh index
	 t5465_Mode_640x400x8_2a,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5465,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	  150,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	  640,   //// Bytes per scan line.
	  640,   //// XResol
	  400,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	    8,   //// Bits per pixel
	    0,   //// Refresh index
	 t5465_Mode_640x400x8_3,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5465,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	  150,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 1280,   //// Bytes per scan line.
	  640,   //// XResol
	  400,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	    8,   //// Bits per pixel
	    0,   //// Refresh index
	 t5465_Mode_640x400x8_3a,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5465,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   56,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 1024,   //// Bytes per scan line.
	  800,   //// XResol
	  600,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	    8,   //// Bits per pixel
	    0,   //// Refresh index
	 t5465_Mode_800x600x8_1,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5465,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   60,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 1024,   //// Bytes per scan line.
	  800,   //// XResol
	  600,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	    8,   //// Bits per pixel
	    0,   //// Refresh index
	 t5465_Mode_800x600x8_2,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5465,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   72,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 1024,   //// Bytes per scan line.
	  800,   //// XResol
	  600,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	    8,   //// Bits per pixel
	    0,   //// Refresh index
	 t5465_Mode_800x600x8_3,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5465,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   75,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 1024,   //// Bytes per scan line.
	  800,   //// XResol
	  600,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	    8,   //// Bits per pixel
	    0,   //// Refresh index
	 t5465_Mode_800x600x8_4,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5465,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   85,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 1024,   //// Bytes per scan line.
	  800,   //// XResol
	  600,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	    8,   //// Bits per pixel
	    0,   //// Refresh index
	 t5465_Mode_800x600x8_5,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5465,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   56,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 1664,   //// Bytes per scan line.
	  800,   //// XResol
	  600,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	    8,   //// Bits per pixel
	    0,   //// Refresh index
	 t5465_Mode_800x600x8_1a,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5465,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   60,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 1664,   //// Bytes per scan line.
	  800,   //// XResol
	  600,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	    8,   //// Bits per pixel
	    0,   //// Refresh index
	 t5465_Mode_800x600x8_2a,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5465,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   72,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 1664,   //// Bytes per scan line.
	  800,   //// XResol
	  600,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	    8,   //// Bits per pixel
	    0,   //// Refresh index
	 t5465_Mode_800x600x8_3a,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5465,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   75,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 1664,   //// Bytes per scan line.
	  800,   //// XResol
	  600,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	    8,   //// Bits per pixel
	    0,   //// Refresh index
	 t5465_Mode_800x600x8_4a,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5465,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   85,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 1664,   //// Bytes per scan line.
	  800,   //// XResol
	  600,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	    8,   //// Bits per pixel
	    0,   //// Refresh index
	 t5465_Mode_800x600x8_5a,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5465,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   43,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 1280,   //// Bytes per scan line.
	 1024,   //// XResol
	  768,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	    8,   //// Bits per pixel
	    0,   //// Refresh index
	 t5465_Mode_1024x768x8_1,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5465,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   60,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 1280,   //// Bytes per scan line.
	 1024,   //// XResol
	  768,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	    8,   //// Bits per pixel
	    0,   //// Refresh index
	 t5465_Mode_1024x768x8_2,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5465,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   70,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 1280,   //// Bytes per scan line.
	 1024,   //// XResol
	  768,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	    8,   //// Bits per pixel
	    0,   //// Refresh index
	 t5465_Mode_1024x768x8_3,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5465,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   75,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 1280,   //// Bytes per scan line.
	 1024,   //// XResol
	  768,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	    8,   //// Bits per pixel
	    0,   //// Refresh index
	 t5465_Mode_1024x768x8_4,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5465,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   85,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 1280,   //// Bytes per scan line.
	 1024,   //// XResol
	  768,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	    8,   //// Bits per pixel
	    0,   //// Refresh index
	 t5465_Mode_1024x768x8_5,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5465,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   43,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 2048,   //// Bytes per scan line.
	 1024,   //// XResol
	  768,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	    8,   //// Bits per pixel
	    0,   //// Refresh index
	 t5465_Mode_1024x768x8_1a,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5465,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   60,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 2048,   //// Bytes per scan line.
	 1024,   //// XResol
	  768,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	    8,   //// Bits per pixel
	    0,   //// Refresh index
	 t5465_Mode_1024x768x8_2a,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5465,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   70,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 2048,   //// Bytes per scan line.
	 1024,   //// XResol
	  768,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	    8,   //// Bits per pixel
	    0,   //// Refresh index
	 t5465_Mode_1024x768x8_3a,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5465,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   75,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 2048,   //// Bytes per scan line.
	 1024,   //// XResol
	  768,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	    8,   //// Bits per pixel
	    0,   //// Refresh index
	 t5465_Mode_1024x768x8_4a,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5465,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   85,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 2048,   //// Bytes per scan line.
	 1024,   //// XResol
	  768,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	    8,   //// Bits per pixel
	    0,   //// Refresh index
	 t5465_Mode_1024x768x8_5a,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5465,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   70,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 1280,   //// Bytes per scan line.
	 1152,   //// XResol
	  864,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	    8,   //// Bits per pixel
	    0,   //// Refresh index
	 t5465_Mode_1152x864x8_1,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5465,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   75,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 1280,   //// Bytes per scan line.
	 1152,   //// XResol
	  864,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	    8,   //// Bits per pixel
	    0,   //// Refresh index
	 t5465_Mode_1152x864x8_2,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5465,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   85,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 1280,   //// Bytes per scan line.
	 1152,   //// XResol
	  864,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	    8,   //// Bits per pixel
	    0,   //// Refresh index
	 t5465_Mode_1152x864x8_3,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5465,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   60,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 1280,   //// Bytes per scan line.
	 1280,   //// XResol
	  960,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	    8,   //// Bits per pixel
	    0,   //// Refresh index
	 t5465_Mode_1280x960x8_1,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5465,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   75,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 1280,   //// Bytes per scan line.
	 1280,   //// XResol
	  960,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	    8,   //// Bits per pixel
	    0,   //// Refresh index
	 t5465_Mode_1280x960x8_2,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5465,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   85,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 1280,   //// Bytes per scan line.
	 1280,   //// XResol
	  960,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	    8,   //// Bits per pixel
	    0,   //// Refresh index
	 t5465_Mode_1280x960x8_3,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5465,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   43,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 1280,   //// Bytes per scan line.
	 1280,   //// XResol
	 1024,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	    8,   //// Bits per pixel
	    0,   //// Refresh index
	 t5465_Mode_1280x1024x8_1,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5465,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   60,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 1280,   //// Bytes per scan line.
	 1280,   //// XResol
	 1024,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	    8,   //// Bits per pixel
	    0,   //// Refresh index
	 t5465_Mode_1280x1024x8_2,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5465,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   72,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 1280,   //// Bytes per scan line.
	 1280,   //// XResol
	 1024,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	    8,   //// Bits per pixel
	    0,   //// Refresh index
	 t5465_Mode_1280x1024x8_3,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5465,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   75,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 1280,   //// Bytes per scan line.
	 1280,   //// XResol
	 1024,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	    8,   //// Bits per pixel
	    0,   //// Refresh index
	 t5465_Mode_1280x1024x8_4,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5465,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   85,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 1280,   //// Bytes per scan line.
	 1280,   //// XResol
	 1024,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	    8,   //// Bits per pixel
	    0,   //// Refresh index
	 t5465_Mode_1280x1024x8_5,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5465,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   43,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 2560,   //// Bytes per scan line.
	 1280,   //// XResol
	 1024,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	    8,   //// Bits per pixel
	    0,   //// Refresh index
	 t5465_Mode_1280x1024x8_1a,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5465,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   60,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 2560,   //// Bytes per scan line.
	 1280,   //// XResol
	 1024,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	    8,   //// Bits per pixel
	    0,   //// Refresh index
	 t5465_Mode_1280x1024x8_2a,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5465,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   72,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 2560,   //// Bytes per scan line.
	 1280,   //// XResol
	 1024,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	    8,   //// Bits per pixel
	    0,   //// Refresh index
	 t5465_Mode_1280x1024x8_3a,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5465,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   75,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 2560,   //// Bytes per scan line.
	 1280,   //// XResol
	 1024,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	    8,   //// Bits per pixel
	    0,   //// Refresh index
	 t5465_Mode_1280x1024x8_4a,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5465,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   85,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 2560,   //// Bytes per scan line.
	 1280,   //// XResol
	 1024,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	    8,   //// Bits per pixel
	    0,   //// Refresh index
	 t5465_Mode_1280x1024x8_5a,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5465,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   48,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 1664,   //// Bytes per scan line.
	 1600,   //// XResol
	 1200,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	    8,   //// Bits per pixel
	    0,   //// Refresh index
	 t5465_Mode_1600x1200x8_1,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5465,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   60,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 1664,   //// Bytes per scan line.
	 1600,   //// XResol
	 1200,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	    8,   //// Bits per pixel
	    0,   //// Refresh index
	 t5465_Mode_1600x1200x8_2,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5465,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   48,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 3328,   //// Bytes per scan line.
	 1600,   //// XResol
	 1200,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	    8,   //// Bits per pixel
	    0,   //// Refresh index
	 t5465_Mode_1600x1200x8_1a,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5465,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   60,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 3328,   //// Bytes per scan line.
	 1600,   //// XResol
	 1200,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	    8,   //// Bits per pixel
	    0,   //// Refresh index
	 t5465_Mode_1600x1200x8_2a,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5465,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   75,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 1280,   //// Bytes per scan line.
	  320,   //// XResol
	  200,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	   16,   //// Bits per pixel
	    0,   //// Refresh index
	 t5465_Mode_320x200x16_1,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5465,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   60,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 1024,   //// Bytes per scan line.
	  320,   //// XResol
	  240,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	   16,   //// Bits per pixel
	    0,   //// Refresh index
	 t5465_Mode_320x240x16_1,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5465,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   73,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 1024,   //// Bytes per scan line.
	  320,   //// XResol
	  240,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	   16,   //// Bits per pixel
	    0,   //// Refresh index
	 t5465_Mode_320x240x16_2,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5465,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   75,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 1280,   //// Bytes per scan line.
	  320,   //// XResol
	  400,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	   16,   //// Bits per pixel
	    0,   //// Refresh index
	 t5465_Mode_320x400x16_1,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5465,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   60,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 1280,   //// Bytes per scan line.
	  320,   //// XResol
	  480,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	   16,   //// Bits per pixel
	    0,   //// Refresh index
	 t5465_Mode_320x480x16_1,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5465,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   73,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 1280,   //// Bytes per scan line.
	  320,   //// XResol
	  480,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	   16,   //// Bits per pixel
	    0,   //// Refresh index
	 t5465_Mode_320x480x16_2,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5465,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   75,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 1024,   //// Bytes per scan line.
	  360,   //// XResol
	  400,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	   16,   //// Bits per pixel
	    0,   //// Refresh index
	 t5465_Mode_360x400x16_1,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5465,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   85,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 1024,   //// Bytes per scan line.
	  360,   //// XResol
	  400,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	   16,   //// Bits per pixel
	    0,   //// Refresh index
	 t5465_Mode_360x400x16_2,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5465,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   60,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 1024,   //// Bytes per scan line.
	  400,   //// XResol
	  300,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	   16,   //// Bits per pixel
	    0,   //// Refresh index
	 t5465_Mode_400x300x16_1,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5465,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   75,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 1024,   //// Bytes per scan line.
	  400,   //// XResol
	  300,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	   16,   //// Bits per pixel
	    0,   //// Refresh index
	 t5465_Mode_400x300x16_2,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5465,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   60,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 1024,   //// Bytes per scan line.
	  512,   //// XResol
	  384,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	   16,   //// Bits per pixel
	    0,   //// Refresh index
	 t5465_Mode_512x384x16_1,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5465,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   70,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 1024,   //// Bytes per scan line.
	  512,   //// XResol
	  384,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	   16,   //// Bits per pixel
	    0,   //// Refresh index
	 t5465_Mode_512x384x16_2,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5465,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   63,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 1024,   //// Bytes per scan line.
	  512,   //// XResol
	  480,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	   16,   //// Bits per pixel
	    0,   //// Refresh index
	 t5465_Mode_512x480x16_1,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5465,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   75,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 1024,   //// Bytes per scan line.
	  512,   //// XResol
	  480,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	   16,   //// Bits per pixel
	    0,   //// Refresh index
	 t5465_Mode_512x480x16_2,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5465,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   70,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 1280,   //// Bytes per scan line.
	  640,   //// XResol
	  350,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	   16,   //// Bits per pixel
	    0,   //// Refresh index
	 t5465_Mode_640x350x16_1,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5465,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   85,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 1280,   //// Bytes per scan line.
	  640,   //// XResol
	  350,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	   16,   //// Bits per pixel
	    0,   //// Refresh index
	 t5465_Mode_640x350x16_2,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5465,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   70,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 1280,   //// Bytes per scan line.
	  640,   //// XResol
	  400,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	   16,   //// Bits per pixel
	    0,   //// Refresh index
	 t5465_Mode_640x400x16_1,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5465,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   85,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 1280,   //// Bytes per scan line.
	  640,   //// XResol
	  400,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	   16,   //// Bits per pixel
	    0,   //// Refresh index
	 t5465_Mode_640x400x16_2,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5465,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	  150,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 1280,   //// Bytes per scan line.
	  640,   //// XResol
	  400,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	   16,   //// Bits per pixel
	    0,   //// Refresh index
	 t5465_Mode_640x400x16_3,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5465,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   60,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 1280,   //// Bytes per scan line.
	  640,   //// XResol
	  480,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	   16,   //// Bits per pixel
	    0,   //// Refresh index
	 t5465_Mode_640x480x16_1,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5465,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   72,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 1280,   //// Bytes per scan line.
	  640,   //// XResol
	  480,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	   16,   //// Bits per pixel
	    0,   //// Refresh index
	 t5465_Mode_640x480x16_2,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5465,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   75,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 1280,   //// Bytes per scan line.
	  640,   //// XResol
	  480,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	   16,   //// Bits per pixel
	    0,   //// Refresh index
	 t5465_Mode_640x480x16_3,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5465,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   85,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 1280,   //// Bytes per scan line.
	  640,   //// XResol
	  480,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	   16,   //// Bits per pixel
	    0,   //// Refresh index
	 t5465_Mode_640x480x16_4,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5465,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   56,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 1664,   //// Bytes per scan line.
	  800,   //// XResol
	  600,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	   16,   //// Bits per pixel
	    0,   //// Refresh index
	 t5465_Mode_800x600x16_1,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5465,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   60,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 1664,   //// Bytes per scan line.
	  800,   //// XResol
	  600,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	   16,   //// Bits per pixel
	    0,   //// Refresh index
	 t5465_Mode_800x600x16_2,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5465,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   72,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 1664,   //// Bytes per scan line.
	  800,   //// XResol
	  600,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	   16,   //// Bits per pixel
	    0,   //// Refresh index
	 t5465_Mode_800x600x16_3,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5465,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   75,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 1664,   //// Bytes per scan line.
	  800,   //// XResol
	  600,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	   16,   //// Bits per pixel
	    0,   //// Refresh index
	 t5465_Mode_800x600x16_4,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5465,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   85,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 1664,   //// Bytes per scan line.
	  800,   //// XResol
	  600,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	   16,   //// Bits per pixel
	    0,   //// Refresh index
	 t5465_Mode_800x600x16_5,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5465,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   43,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 2048,   //// Bytes per scan line.
	 1024,   //// XResol
	  768,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	   16,   //// Bits per pixel
	    0,   //// Refresh index
	 t5465_Mode_1024x768x16_1,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5465,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   60,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 2048,   //// Bytes per scan line.
	 1024,   //// XResol
	  768,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	   16,   //// Bits per pixel
	    0,   //// Refresh index
	 t5465_Mode_1024x768x16_2,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5465,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   70,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 2048,   //// Bytes per scan line.
	 1024,   //// XResol
	  768,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	   16,   //// Bits per pixel
	    0,   //// Refresh index
	 t5465_Mode_1024x768x16_3,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5465,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   75,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 2048,   //// Bytes per scan line.
	 1024,   //// XResol
	  768,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	   16,   //// Bits per pixel
	    0,   //// Refresh index
	 t5465_Mode_1024x768x16_4,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5465,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   85,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 2048,   //// Bytes per scan line.
	 1024,   //// XResol
	  768,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	   16,   //// Bits per pixel
	    0,   //// Refresh index
	 t5465_Mode_1024x768x16_5,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5465,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   70,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 2560,   //// Bytes per scan line.
	 1152,   //// XResol
	  864,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	   16,   //// Bits per pixel
	    0,   //// Refresh index
	 t5465_Mode_1152x864x16_1,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5465,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   75,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 2560,   //// Bytes per scan line.
	 1152,   //// XResol
	  864,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	   16,   //// Bits per pixel
	    0,   //// Refresh index
	 t5465_Mode_1152x864x16_2,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5465,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   85,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 2560,   //// Bytes per scan line.
	 1152,   //// XResol
	  864,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	   16,   //// Bits per pixel
	    0,   //// Refresh index
	 t5465_Mode_1152x864x16_3,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5465,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   60,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 2560,   //// Bytes per scan line.
	 1280,   //// XResol
	  960,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	   16,   //// Bits per pixel
	    0,   //// Refresh index
	 t5465_Mode_1280x960x16_1,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5465,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   75,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 2560,   //// Bytes per scan line.
	 1280,   //// XResol
	  960,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	   16,   //// Bits per pixel
	    0,   //// Refresh index
	 t5465_Mode_1280x960x16_2,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5465,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   85,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 2560,   //// Bytes per scan line.
	 1280,   //// XResol
	  960,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	   16,   //// Bits per pixel
	    0,   //// Refresh index
	 t5465_Mode_1280x960x16_3,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5465,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   43,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 2560,   //// Bytes per scan line.
	 1280,   //// XResol
	 1024,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	   16,   //// Bits per pixel
	    0,   //// Refresh index
	 t5465_Mode_1280x1024x16_1,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5465,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   60,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 2560,   //// Bytes per scan line.
	 1280,   //// XResol
	 1024,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	   16,   //// Bits per pixel
	    0,   //// Refresh index
	 t5465_Mode_1280x1024x16_2,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5465,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   72,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 2560,   //// Bytes per scan line.
	 1280,   //// XResol
	 1024,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	   16,   //// Bits per pixel
	    0,   //// Refresh index
	 t5465_Mode_1280x1024x16_3,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5465,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   75,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 2560,   //// Bytes per scan line.
	 1280,   //// XResol
	 1024,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	   16,   //// Bits per pixel
	    0,   //// Refresh index
	 t5465_Mode_1280x1024x16_4,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5465,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   85,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 2560,   //// Bytes per scan line.
	 1280,   //// XResol
	 1024,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	   16,   //// Bits per pixel
	    0,   //// Refresh index
	 t5465_Mode_1280x1024x16_5,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5465,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   70,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 2048,   //// Bytes per scan line.
	  640,   //// XResol
	  400,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	   24,   //// Bits per pixel
	    0,   //// Refresh index
	 t5465_Mode_640x400x24_1,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5465,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   85,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 2048,   //// Bytes per scan line.
	  640,   //// XResol
	  400,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	   24,   //// Bits per pixel
	    0,   //// Refresh index
	 t5465_Mode_640x400x24_2,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5465,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	  150,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 2048,   //// Bytes per scan line.
	  640,   //// XResol
	  400,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	   24,   //// Bits per pixel
	    0,   //// Refresh index
	 t5465_Mode_640x400x24_3,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5465,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   60,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 2048,   //// Bytes per scan line.
	  640,   //// XResol
	  480,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	   24,   //// Bits per pixel
	    0,   //// Refresh index
	 t5465_Mode_640x480x24_1,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5465,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   72,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 2048,   //// Bytes per scan line.
	  640,   //// XResol
	  480,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	   24,   //// Bits per pixel
	    0,   //// Refresh index
	 t5465_Mode_640x480x24_2,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5465,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   75,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 2048,   //// Bytes per scan line.
	  640,   //// XResol
	  480,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	   24,   //// Bits per pixel
	    0,   //// Refresh index
	 t5465_Mode_640x480x24_3,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5465,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   85,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 2048,   //// Bytes per scan line.
	  640,   //// XResol
	  480,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	   24,   //// Bits per pixel
	    0,   //// Refresh index
	 t5465_Mode_640x480x24_4,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5465,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   56,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 2560,   //// Bytes per scan line.
	  800,   //// XResol
	  600,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	   24,   //// Bits per pixel
	    0,   //// Refresh index
	 t5465_Mode_800x600x24_1,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5465,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   60,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 2560,   //// Bytes per scan line.
	  800,   //// XResol
	  600,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	   24,   //// Bits per pixel
	    0,   //// Refresh index
	 t5465_Mode_800x600x24_2,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5465,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   72,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 2560,   //// Bytes per scan line.
	  800,   //// XResol
	  600,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	   24,   //// Bits per pixel
	    0,   //// Refresh index
	 t5465_Mode_800x600x24_3,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5465,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   75,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 2560,   //// Bytes per scan line.
	  800,   //// XResol
	  600,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	   24,   //// Bits per pixel
	    0,   //// Refresh index
	 t5465_Mode_800x600x24_4,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5465,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   85,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 2560,   //// Bytes per scan line.
	  800,   //// XResol
	  600,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	   24,   //// Bits per pixel
	    0,   //// Refresh index
	 t5465_Mode_800x600x24_5,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5465,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   43,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 3328,   //// Bytes per scan line.
	 1024,   //// XResol
	  768,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	   24,   //// Bits per pixel
	    0,   //// Refresh index
	 t5465_Mode_1024x768x24_1,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5465,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   60,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 3328,   //// Bytes per scan line.
	 1024,   //// XResol
	  768,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	   24,   //// Bits per pixel
	    0,   //// Refresh index
	 t5465_Mode_1024x768x24_2,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5465,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   70,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 3328,   //// Bytes per scan line.
	 1024,   //// XResol
	  768,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	   24,   //// Bits per pixel
	    0,   //// Refresh index
	 t5465_Mode_1024x768x24_3,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5465,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   75,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 3328,   //// Bytes per scan line.
	 1024,   //// XResol
	  768,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	   24,   //// Bits per pixel
	    0,   //// Refresh index
	 t5465_Mode_1024x768x24_4,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5465,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   85,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 3328,   //// Bytes per scan line.
	 1024,   //// XResol
	  768,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	   24,   //// Bits per pixel
	    0,   //// Refresh index
	 t5465_Mode_1024x768x24_5,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5465,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   70,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 4096,   //// Bytes per scan line.
	 1152,   //// XResol
	  864,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	   24,   //// Bits per pixel
	    0,   //// Refresh index
	 t5465_Mode_1152x864x24_1,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5465,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   75,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 4096,   //// Bytes per scan line.
	 1152,   //// XResol
	  864,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	   24,   //// Bits per pixel
	    0,   //// Refresh index
	 t5465_Mode_1152x864x24_2,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5465,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   85,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 4096,   //// Bytes per scan line.
	 1152,   //// XResol
	  864,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	   24,   //// Bits per pixel
	    0,   //// Refresh index
	 t5465_Mode_1152x864x24_3,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5465,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   60,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 4096,   //// Bytes per scan line.
	 1280,   //// XResol
	  960,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	   24,   //// Bits per pixel
	    0,   //// Refresh index
	 t5465_Mode_1280x960x24_1,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5465,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   75,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 4096,   //// Bytes per scan line.
	 1280,   //// XResol
	  960,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	   24,   //// Bits per pixel
	    0,   //// Refresh index
	 t5465_Mode_1280x960x24_2,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5465,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   43,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 4096,   //// Bytes per scan line.
	 1280,   //// XResol
	 1024,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	   24,   //// Bits per pixel
	    0,   //// Refresh index
	 t5465_Mode_1280x1024x24_1,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5465,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   60,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 4096,   //// Bytes per scan line.
	 1280,   //// XResol
	 1024,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	   24,   //// Bits per pixel
	    0,   //// Refresh index
	 t5465_Mode_1280x1024x24_2,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5465,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	    0,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	    0,   //// Bytes per scan line.
	    0,   //// XResol
	    0,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	    0,   //// Bits per pixel
	    0,   //// Refresh index
	 t5465_Mode_Reset,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5465,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   65,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 1664,   //// Bytes per scan line.
	 1600,   //// XResol
	 1200,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	    8,   //// Bits per pixel
	    0,   //// Refresh index
	 t5465_Mode_1600x1200x8_3,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5465,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   70,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 1664,   //// Bytes per scan line.
	 1600,   //// XResol
	 1200,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	    8,   //// Bits per pixel
	    0,   //// Refresh index
	 t5465_Mode_1600x1200x8_4,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5465,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   75,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 1664,   //// Bytes per scan line.
	 1600,   //// XResol
	 1200,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	    8,   //// Bits per pixel
	    0,   //// Refresh index
	 t5465_Mode_1600x1200x8_5,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5465,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   65,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 3328,   //// Bytes per scan line.
	 1600,   //// XResol
	 1200,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	    8,   //// Bits per pixel
	    0,   //// Refresh index
	 t5465_Mode_1600x1200x8_3a,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5465,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   70,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 3328,   //// Bytes per scan line.
	 1600,   //// XResol
	 1200,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	    8,   //// Bits per pixel
	    0,   //// Refresh index
	 t5465_Mode_1600x1200x8_4a,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5465,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   75,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 3328,   //// Bytes per scan line.
	 1600,   //// XResol
	 1200,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	    8,   //// Bits per pixel
	    0,   //// Refresh index
	 t5465_Mode_1600x1200x8_5a,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5465,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   75,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 1280,   //// Bytes per scan line.
	  320,   //// XResol
	  200,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	   15,   //// Bits per pixel
	    0,   //// Refresh index
	 t5465_Mode_320x200x15_1,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5465,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   60,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 1024,   //// Bytes per scan line.
	  320,   //// XResol
	  240,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	   15,   //// Bits per pixel
	    0,   //// Refresh index
	 t5465_Mode_320x240x15_1,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5465,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   73,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 1024,   //// Bytes per scan line.
	  320,   //// XResol
	  240,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	   15,   //// Bits per pixel
	    0,   //// Refresh index
	 t5465_Mode_320x240x15_2,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5465,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   75,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 1280,   //// Bytes per scan line.
	  320,   //// XResol
	  400,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	   15,   //// Bits per pixel
	    0,   //// Refresh index
	 t5465_Mode_320x400x15_1,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5465,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   60,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 1280,   //// Bytes per scan line.
	  320,   //// XResol
	  480,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	   15,   //// Bits per pixel
	    0,   //// Refresh index
	 t5465_Mode_320x480x15_1,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5465,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   73,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 1280,   //// Bytes per scan line.
	  320,   //// XResol
	  480,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	   15,   //// Bits per pixel
	    0,   //// Refresh index
	 t5465_Mode_320x480x15_2,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5465,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   75,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 1024,   //// Bytes per scan line.
	  360,   //// XResol
	  400,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	   15,   //// Bits per pixel
	    0,   //// Refresh index
	 t5465_Mode_360x400x15_1,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5465,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   85,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 1024,   //// Bytes per scan line.
	  360,   //// XResol
	  400,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	   15,   //// Bits per pixel
	    0,   //// Refresh index
	 t5465_Mode_360x400x15_2,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5465,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   60,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 1024,   //// Bytes per scan line.
	  400,   //// XResol
	  300,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	   15,   //// Bits per pixel
	    0,   //// Refresh index
	 t5465_Mode_400x300x15_1,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5465,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   75,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 1024,   //// Bytes per scan line.
	  400,   //// XResol
	  300,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	   15,   //// Bits per pixel
	    0,   //// Refresh index
	 t5465_Mode_400x300x15_2,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5465,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   60,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 1024,   //// Bytes per scan line.
	  512,   //// XResol
	  384,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	   15,   //// Bits per pixel
	    0,   //// Refresh index
	 t5465_Mode_512x384x15_1,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5465,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   70,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 1024,   //// Bytes per scan line.
	  512,   //// XResol
	  384,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	   15,   //// Bits per pixel
	    0,   //// Refresh index
	 t5465_Mode_512x384x15_2,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5465,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   63,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 1024,   //// Bytes per scan line.
	  512,   //// XResol
	  480,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	   15,   //// Bits per pixel
	    0,   //// Refresh index
	 t5465_Mode_512x480x15_1,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5465,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   75,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 1024,   //// Bytes per scan line.
	  512,   //// XResol
	  480,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	   15,   //// Bits per pixel
	    0,   //// Refresh index
	 t5465_Mode_512x480x15_2,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5465,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   70,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 1280,   //// Bytes per scan line.
	  640,   //// XResol
	  350,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	   15,   //// Bits per pixel
	    0,   //// Refresh index
	 t5465_Mode_640x350x15_1,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5465,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   85,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 1280,   //// Bytes per scan line.
	  640,   //// XResol
	  350,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	   15,   //// Bits per pixel
	    0,   //// Refresh index
	 t5465_Mode_640x350x15_2,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5465,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   70,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 1280,   //// Bytes per scan line.
	  640,   //// XResol
	  400,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	   15,   //// Bits per pixel
	    0,   //// Refresh index
	 t5465_Mode_640x400x15_1,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5465,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   85,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 1280,   //// Bytes per scan line.
	  640,   //// XResol
	  400,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	   15,   //// Bits per pixel
	    0,   //// Refresh index
	 t5465_Mode_640x400x15_2,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5465,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	  150,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 1280,   //// Bytes per scan line.
	  640,   //// XResol
	  400,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	   15,   //// Bits per pixel
	    0,   //// Refresh index
	 t5465_Mode_640x400x15_3,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5465,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   60,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 1280,   //// Bytes per scan line.
	  640,   //// XResol
	  480,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	   15,   //// Bits per pixel
	    0,   //// Refresh index
	 t5465_Mode_640x480x15_1,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5465,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   72,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 1280,   //// Bytes per scan line.
	  640,   //// XResol
	  480,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	   15,   //// Bits per pixel
	    0,   //// Refresh index
	 t5465_Mode_640x480x15_2,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5465,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   75,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 1280,   //// Bytes per scan line.
	  640,   //// XResol
	  480,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	   15,   //// Bits per pixel
	    0,   //// Refresh index
	 t5465_Mode_640x480x15_3,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5465,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   85,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 1280,   //// Bytes per scan line.
	  640,   //// XResol
	  480,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	   15,   //// Bits per pixel
	    0,   //// Refresh index
	 t5465_Mode_640x480x15_4,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5465,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   56,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 1664,   //// Bytes per scan line.
	  800,   //// XResol
	  600,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	   15,   //// Bits per pixel
	    0,   //// Refresh index
	 t5465_Mode_800x600x15_1,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5465,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   60,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 1664,   //// Bytes per scan line.
	  800,   //// XResol
	  600,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	   15,   //// Bits per pixel
	    0,   //// Refresh index
	 t5465_Mode_800x600x15_2,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5465,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   72,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 1664,   //// Bytes per scan line.
	  800,   //// XResol
	  600,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	   15,   //// Bits per pixel
	    0,   //// Refresh index
	 t5465_Mode_800x600x15_3,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5465,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   75,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 1664,   //// Bytes per scan line.
	  800,   //// XResol
	  600,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	   15,   //// Bits per pixel
	    0,   //// Refresh index
	 t5465_Mode_800x600x15_4,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5465,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   85,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 1664,   //// Bytes per scan line.
	  800,   //// XResol
	  600,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	   15,   //// Bits per pixel
	    0,   //// Refresh index
	 t5465_Mode_800x600x15_5,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5465,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   43,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 2048,   //// Bytes per scan line.
	 1024,   //// XResol
	  768,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	   15,   //// Bits per pixel
	    0,   //// Refresh index
	 t5465_Mode_1024x768x15_1,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5465,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   60,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 2048,   //// Bytes per scan line.
	 1024,   //// XResol
	  768,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	   15,   //// Bits per pixel
	    0,   //// Refresh index
	 t5465_Mode_1024x768x15_2,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5465,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   70,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 2048,   //// Bytes per scan line.
	 1024,   //// XResol
	  768,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	   15,   //// Bits per pixel
	    0,   //// Refresh index
	 t5465_Mode_1024x768x15_3,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5465,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   75,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 2048,   //// Bytes per scan line.
	 1024,   //// XResol
	  768,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	   15,   //// Bits per pixel
	    0,   //// Refresh index
	 t5465_Mode_1024x768x15_4,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5465,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   85,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 2048,   //// Bytes per scan line.
	 1024,   //// XResol
	  768,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	   15,   //// Bits per pixel
	    0,   //// Refresh index
	 t5465_Mode_1024x768x15_5,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5465,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   70,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 2560,   //// Bytes per scan line.
	 1152,   //// XResol
	  864,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	   15,   //// Bits per pixel
	    0,   //// Refresh index
	 t5465_Mode_1152x864x15_1,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5465,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   75,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 2560,   //// Bytes per scan line.
	 1152,   //// XResol
	  864,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	   15,   //// Bits per pixel
	    0,   //// Refresh index
	 t5465_Mode_1152x864x15_2,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5465,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   85,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 2560,   //// Bytes per scan line.
	 1152,   //// XResol
	  864,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	   15,   //// Bits per pixel
	    0,   //// Refresh index
	 t5465_Mode_1152x864x15_3,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5465,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   60,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 2560,   //// Bytes per scan line.
	 1280,   //// XResol
	  960,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	   15,   //// Bits per pixel
	    0,   //// Refresh index
	 t5465_Mode_1280x960x15_1,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5465,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   75,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 2560,   //// Bytes per scan line.
	 1280,   //// XResol
	  960,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	   15,   //// Bits per pixel
	    0,   //// Refresh index
	 t5465_Mode_1280x960x15_2,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5465,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   85,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 2560,   //// Bytes per scan line.
	 1280,   //// XResol
	  960,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	   15,   //// Bits per pixel
	    0,   //// Refresh index
	 t5465_Mode_1280x960x15_3,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5465,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   43,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 2560,   //// Bytes per scan line.
	 1280,   //// XResol
	 1024,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	   15,   //// Bits per pixel
	    0,   //// Refresh index
	 t5465_Mode_1280x1024x15_1,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5465,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   60,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 2560,   //// Bytes per scan line.
	 1280,   //// XResol
	 1024,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	   15,   //// Bits per pixel
	    0,   //// Refresh index
	 t5465_Mode_1280x1024x15_2,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5465,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   72,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 2560,   //// Bytes per scan line.
	 1280,   //// XResol
	 1024,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	   15,   //// Bits per pixel
	    0,   //// Refresh index
	 t5465_Mode_1280x1024x15_3,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5465,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   75,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 2560,   //// Bytes per scan line.
	 1280,   //// XResol
	 1024,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	   15,   //// Bits per pixel
	    0,   //// Refresh index
	 t5465_Mode_1280x1024x15_4,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5465,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   85,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 2560,   //// Bytes per scan line.
	 1280,   //// XResol
	 1024,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	   15,   //// Bits per pixel
	    0,   //// Refresh index
	 t5465_Mode_1280x1024x15_5,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5465,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   48,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 3328,   //// Bytes per scan line.
	 1600,   //// XResol
	 1200,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	   15,   //// Bits per pixel
	    0,   //// Refresh index
	 t5465_Mode_1600x1200x15_1,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5465,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   60,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 3328,   //// Bytes per scan line.
	 1600,   //// XResol
	 1200,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	   15,   //// Bits per pixel
	    0,   //// Refresh index
	 t5465_Mode_1600x1200x15_2,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5465,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   65,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 3328,   //// Bytes per scan line.
	 1600,   //// XResol
	 1200,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	   15,   //// Bits per pixel
	    0,   //// Refresh index
	 t5465_Mode_1600x1200x15_3,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5465,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   70,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 3328,   //// Bytes per scan line.
	 1600,   //// XResol
	 1200,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	   15,   //// Bits per pixel
	    0,   //// Refresh index
	 t5465_Mode_1600x1200x15_4,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5465,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   48,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 3328,   //// Bytes per scan line.
	 1600,   //// XResol
	 1200,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	   16,   //// Bits per pixel
	    0,   //// Refresh index
	 t5465_Mode_1600x1200x16_1,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5465,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   60,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 3328,   //// Bytes per scan line.
	 1600,   //// XResol
	 1200,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	   16,   //// Bits per pixel
	    0,   //// Refresh index
	 t5465_Mode_1600x1200x16_2,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5465,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   65,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 3328,   //// Bytes per scan line.
	 1600,   //// XResol
	 1200,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	   16,   //// Bits per pixel
	    0,   //// Refresh index
	 t5465_Mode_1600x1200x16_3,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5465,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   70,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 3328,   //// Bytes per scan line.
	 1600,   //// XResol
	 1200,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	   16,   //// Bits per pixel
	    0,   //// Refresh index
	 t5465_Mode_1600x1200x16_4,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5465,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   75,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 1280,   //// Bytes per scan line.
	  320,   //// XResol
	  200,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	   32,   //// Bits per pixel
	    0,   //// Refresh index
	 t5465_Mode_320x200x32_1,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5465,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   60,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 1280,   //// Bytes per scan line.
	  320,   //// XResol
	  240,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	   32,   //// Bits per pixel
	    0,   //// Refresh index
	 t5465_Mode_320x240x32_1,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5465,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   73,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 1280,   //// Bytes per scan line.
	  320,   //// XResol
	  240,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	   32,   //// Bits per pixel
	    0,   //// Refresh index
	 t5465_Mode_320x240x32_2,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5465,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   75,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 1280,   //// Bytes per scan line.
	  320,   //// XResol
	  400,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	   32,   //// Bits per pixel
	    0,   //// Refresh index
	 t5465_Mode_320x400x32_1,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5465,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   60,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 1280,   //// Bytes per scan line.
	  320,   //// XResol
	  480,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	   32,   //// Bits per pixel
	    0,   //// Refresh index
	 t5465_Mode_320x480x32_1,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5465,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   73,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 1280,   //// Bytes per scan line.
	  320,   //// XResol
	  480,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	   32,   //// Bits per pixel
	    0,   //// Refresh index
	 t5465_Mode_320x480x32_2,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5465,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   75,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 1664,   //// Bytes per scan line.
	  360,   //// XResol
	  400,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	   32,   //// Bits per pixel
	    0,   //// Refresh index
	 t5465_Mode_360x400x32_1,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5465,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   85,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 1664,   //// Bytes per scan line.
	  360,   //// XResol
	  400,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	   32,   //// Bits per pixel
	    0,   //// Refresh index
	 t5465_Mode_360x400x32_2,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5465,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   60,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 1664,   //// Bytes per scan line.
	  400,   //// XResol
	  300,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	   32,   //// Bits per pixel
	    0,   //// Refresh index
	 t5465_Mode_400x300x32_1,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5465,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   75,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 1664,   //// Bytes per scan line.
	  400,   //// XResol
	  300,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	   32,   //// Bits per pixel
	    0,   //// Refresh index
	 t5465_Mode_400x300x32_2,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5465,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   60,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 2048,   //// Bytes per scan line.
	  512,   //// XResol
	  384,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	   32,   //// Bits per pixel
	    0,   //// Refresh index
	 t5465_Mode_512x384x32_1,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5465,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   70,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 2048,   //// Bytes per scan line.
	  512,   //// XResol
	  384,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	   32,   //// Bits per pixel
	    0,   //// Refresh index
	 t5465_Mode_512x384x32_2,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5465,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   63,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 2048,   //// Bytes per scan line.
	  512,   //// XResol
	  480,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	   32,   //// Bits per pixel
	    0,   //// Refresh index
	 t5465_Mode_512x480x32_1,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5465,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   75,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 2048,   //// Bytes per scan line.
	  512,   //// XResol
	  480,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	   32,   //// Bits per pixel
	    0,   //// Refresh index
	 t5465_Mode_512x480x32_2,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5465,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   70,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 2560,   //// Bytes per scan line.
	  640,   //// XResol
	  350,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	   32,   //// Bits per pixel
	    0,   //// Refresh index
	 t5465_Mode_640x350x32_1,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5465,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   86,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 2560,   //// Bytes per scan line.
	  640,   //// XResol
	  350,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	   32,   //// Bits per pixel
	    0,   //// Refresh index
	 t5465_Mode_640x350x32_2,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5465,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   70,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 2560,   //// Bytes per scan line.
	  640,   //// XResol
	  400,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	   32,   //// Bits per pixel
	    0,   //// Refresh index
	 t5465_Mode_640x400x32_1,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5465,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   85,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 2560,   //// Bytes per scan line.
	  640,   //// XResol
	  400,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	   32,   //// Bits per pixel
	    0,   //// Refresh index
	 t5465_Mode_640x400x32_2,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5465,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   60,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 2560,   //// Bytes per scan line.
	  640,   //// XResol
	  480,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	   32,   //// Bits per pixel
	    0,   //// Refresh index
	 t5465_Mode_640x480x32_1,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5465,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   72,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 2560,   //// Bytes per scan line.
	  640,   //// XResol
	  480,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	   32,   //// Bits per pixel
	    0,   //// Refresh index
	 t5465_Mode_640x480x32_2,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5465,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   75,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 2560,   //// Bytes per scan line.
	  640,   //// XResol
	  480,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	   32,   //// Bits per pixel
	    0,   //// Refresh index
	 t5465_Mode_640x480x32_3,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5465,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   85,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 2560,   //// Bytes per scan line.
	  640,   //// XResol
	  480,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	   32,   //// Bits per pixel
	    0,   //// Refresh index
	 t5465_Mode_640x480x32_4,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5465,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   56,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 3328,   //// Bytes per scan line.
	  800,   //// XResol
	  600,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	   32,   //// Bits per pixel
	    0,   //// Refresh index
	 t5465_Mode_800x600x32_1,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5465,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   60,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 3328,   //// Bytes per scan line.
	  800,   //// XResol
	  600,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	   32,   //// Bits per pixel
	    0,   //// Refresh index
	 t5465_Mode_800x600x32_2,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5465,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   72,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 3328,   //// Bytes per scan line.
	  800,   //// XResol
	  600,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	   32,   //// Bits per pixel
	    0,   //// Refresh index
	 t5465_Mode_800x600x32_3,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5465,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   75,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 3328,   //// Bytes per scan line.
	  800,   //// XResol
	  600,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	   32,   //// Bits per pixel
	    0,   //// Refresh index
	 t5465_Mode_800x600x32_4,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5465,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   85,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 3328,   //// Bytes per scan line.
	  800,   //// XResol
	  600,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	   32,   //// Bits per pixel
	    0,   //// Refresh index
	 t5465_Mode_800x600x32_5,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5465,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   43,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 4096,   //// Bytes per scan line.
	 1024,   //// XResol
	  768,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	   32,   //// Bits per pixel
	    0,   //// Refresh index
	 t5465_Mode_1024x768x32_1,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5465,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   60,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 4096,   //// Bytes per scan line.
	 1024,   //// XResol
	  768,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	   32,   //// Bits per pixel
	    0,   //// Refresh index
	 t5465_Mode_1024x768x32_2,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5465,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   70,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 4096,   //// Bytes per scan line.
	 1024,   //// XResol
	  768,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	   32,   //// Bits per pixel
	    0,   //// Refresh index
	 t5465_Mode_1024x768x32_3,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5465,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   75,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 4096,   //// Bytes per scan line.
	 1024,   //// XResol
	  768,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	   32,   //// Bits per pixel
	    0,   //// Refresh index
	 t5465_Mode_1024x768x32_4,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5465,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   85,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 4096,   //// Bytes per scan line.
	 1024,   //// XResol
	  768,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	   32,   //// Bits per pixel
	    0,   //// Refresh index
	 t5465_Mode_1024x768x32_5,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5465AD,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   80,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 1664,   //// Bytes per scan line.
	 1600,   //// XResol
	 1200,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	    8,   //// Bits per pixel
	    0,   //// Refresh index
	 t5465AD_Mode_1600x1200x8_6,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5465AD,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   85,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 1664,   //// Bytes per scan line.
	 1600,   //// XResol
	 1200,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	    8,   //// Bits per pixel
	    0,   //// Refresh index
	 t5465AD_Mode_1600x1200x8_7,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5465AD,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   80,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 3328,   //// Bytes per scan line.
	 1600,   //// XResol
	 1200,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	    8,   //// Bits per pixel
	    0,   //// Refresh index
	 t5465AD_Mode_1600x1200x8_6a,  //// Mode set string
},

{
	    0,   //// ValidMode
	 LG_5465AD,  //// mode works on these chips.
	 VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, 
	   85,   //// Frequency
	    0,   //// Don't use the BIOS to set the mode.
	 3328,   //// Bytes per scan line.
	 1600,   //// XResol
	 1200,   //// YResol
	    8,   //// XCharSize
	   16,   //// YCharSize
	    1,   //// Num of Planes
	    8,   //// Bits per pixel
	    0,   //// Refresh index
	 t5465AD_Mode_1600x1200x8_7a,  //// Mode set string
},
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\laguna\mini\cl546x\setmode.c ===
/******************************************************************************
*
*   Module:     SETMODE.C       Set Video Mode Function Module
*
*   Revision:   1.00
*
*   Date:       April 8, 1994
*
*   Author:     Randy Spurlock
*
*******************************************************************************
*
*   Module Description:
*
*       This module contains code for the SetMode function. This
*   function can be used to set a video mode that was obtained via the
*   GetModeTable function.
*
*******************************************************************************
*
*   Changes:
*
*    DATE     REVISION  DESCRIPTION                             AUTHOR
*  --------   --------  -------------------------------------------------------
*  04/08/94     1.00    Original                                Randy Spurlock
*
*******************************************************************************
*   Include Files
******************************************************************************/
#include        <stdlib.h>              /* Include standard library header   */
#include        <stdio.h>               /* Include standard I/O header file  */
#include        <conio.h>               /* Include console I/O header file   */
#include        <dos.h>                 /* Include dos header file           */
#include        <string.h>              /* Include string header file        */
#include        <malloc.h>              /* Include malloc header file        */

//
// Is this Windows NT or something else?
//
#ifndef WIN_NT
    #if NT_MINIPORT
        #define WIN_NT 1
    #else
        #define WIN_NT 0
    #endif
#endif

#include        "type.h"                /* Include type header file          */
#include        "modemon.h"             /* Include mode/monitor header file  */

#include        "structs.h"             /* Include the struct header file    */

#if WIN_NT && NT_MINIPORT // If NT and Miniport
    #include "cirrus.h"
#endif

/******************************************************************************
*   Local Defintions
******************************************************************************/
#define STACK_SIZE      32              /* Maximum stack size value          */

#define VIDEO_BIOS      0x10            /* Video BIOS function value         */
#define VIDEO_SETMODE   0x00            /* Video set mode funtion value      */

#define DMA_PAGE        0x84            /* Unused DMA page register port     */

#if WIN_NT // If NT and Miniport
    #if NT_MINIPORT
        //
        // NT Miniport has it's own set of I/O functions.
        //
        #define outp(port,val)  VideoPortWritePortUchar ((unsigned char *)port,  (unsigned char)val)
        #define outpw(port,val) VideoPortWritePortUshort((unsigned short *)port, (unsigned short)val)
        #define outpd(port,val) VideoPortWritePortUlong ((unsigned long *)port,  (unsigned long)val)

        #define inp(port)   VideoPortReadPortUchar  ((unsigned char *)port)
        #define inpw(port)  VideoPortReadPortUshort ((unsigned short *)port)
        #define inpd(port)  VideoPortReadPortUlong  ((unsigned long *)port)
    #else
        #define outp(port,val)       _outp  ((unsigned short)(port), (BYTE) (val))  
        #define outpw(port,val)      _outpw ((unsigned short)(port), (WORD) (val)) 
        #define outpd(port,val)      _outpd ((unsigned short)(port), (DWORD)(val)) 

        #define inp(port)            _inp  ((unsigned short)(port))   
        #define inpw(port)           _inpw ((unsigned short)(port))  
        #define inpd(port)           _inpd ((unsigned short)(port))  
    #endif


	#if 0 // Stress test
    #if defined(ALLOC_PRAGMA)
        #pragma alloc_text(PAGE,SetMode)
    #endif
	#endif
#endif

#if WIN_NT
    #ifndef NT_MINIPORT
        #define VideoDebugPrint(x)
    #endif
#endif

#if !(WIN_NT)
int WriteI2CRegister(BYTE * pMem, int nPort, int nAddr, int nReg, int nData);
#endif

void WaitNVsyncs (BYTE * pMemory, WORD wNumVsyncs );

/******************************************************************************
*
*   void SetMode(BYTE *pModeTable, BYTE *pMemory)
*
*   Where:
*
*       pModeTable    - Pointer to mode table to set
*       pMemory       - Pointer to memory mapped I/O space
*
*   Notes:
*
*       This function will set the video mode using the mode table.
*
******************************************************************************/
void SetMode(BYTE *pModeTable, BYTE *pMemory, BYTE * pBinaryData, ULONG SkipIO)
{
    DWORD nHold;                        /* Holding register value            */
    int nPort;                          /* Register port address value       */
    int nOffset;                        /* Memory address offset value       */
    int nIndex;                         /* Register port index value         */
    int nCount;                         /* Multiple output count value       */
    int nLoop;                          /* Generic loop counter              */
    int nPointer = 0;                   /* Stack pointer value               */
    int anStack[STACK_SIZE];            /* Stack array                       */
    BYTE *pPointer;                     /* Mode table pointer                */
    #if !(WIN_NT)
    union REGS Regs;                    /* Register union structure          */
    #endif
	int i;										 /* Temporary Register for Counting */
	PI2C pI2C;			 						 /* Some data pointers */
	PI2CDATA pI2CData;

#if 0 // Stress test
    #if NT_MINIPORT
        PAGED_CODE();
    #endif
#endif

    /* Loop processing the commands in the mode table */

    pPointer = pModeTable;              /* Initialize the mode table pointer */

    while (TRUE == TRUE)
    {
        /* Switch on the mode command opcode */
#if 0
		  if (*(DWORD *)(pMemory + 0x3F8) & 0x0100 == 0x0000)
				{
				fprintf(stdout,"VGA Shadow %x\n", (DWORD *)(pMemory + 0x3F8));
				exit(0);
				}
		  fprintf(stdout,"Type %x %x %x Shadow=%x\n", ((Mode *) pPointer)->Mode_Opcode, pPointer, pBinaryData, *(DWORD *)(pMemory + 0x3F8));
#endif

        //VideoDebugPrint((2, " Setmode: Processing opcode 0x%X.\n",
        //    ((Mode *) pPointer)->Mode_Opcode));

        switch(((Mode *) pPointer)->Mode_Opcode)
        {
            case END_TABLE:             /* End of table command */

                /* Check for end of top level */

                if (nPointer == 0)
                    return;             /* End of mode set, return to caller */
                else
                    pPointer = pModeTable + anStack[--nPointer];

                break;

            case SET_BIOS_MODE:         /* Set BIOS mode command */

                /* Setup the required registers and do the BIOS mode set */
                #if WIN_NT
                    VideoDebugPrint((2,
                    "\n* * * * CL546X.SYS * Unsupported BIOS call in SetMode() * * * *\n\n"));
                #else
                    Regs.h.ah = VIDEO_SETMODE;
                    Regs.h.al = ((SBM *) pPointer)->SBM_Mode;

                    #ifdef  __WATCOMC__
                    int386(VIDEO_BIOS, &Regs, &Regs);
                    #else
                    int86(VIDEO_BIOS, &Regs, &Regs);
                    #endif
                #endif

                /* Update the mode table pointer */

                pPointer += sizeof(SBM);

                break;

            case SINGLE_INDEXED_OUTPUT: /* Single indexed output command */

                if (!SkipIO)    // are VGA regs ours?
                {
                    /* Setup the register index value */

                    outp(((SIO *) pPointer)->SIO_Port,
                        ((SIO *) pPointer)->SIO_Index);

                    /* Output a single byte to the desired port */

                    outp(((SIO *) pPointer)->SIO_Port + 1,
                        ((SIO *) pPointer)->SIO_Value);
                }

                /* Update the mode table pointer */

                pPointer += sizeof(SIO);

                break;

#if 0
            case SINGLE_BYTE_INPUT:     /* Single byte input command */

                /* Input a single byte into the holding buffer */

                nHold = inp(((SBI *) pPointer)->SBI_Port);

                /* Update the mode table pointer */

                pPointer += sizeof(SBI);

                break;

            case SINGLE_WORD_INPUT:     /* Single word input command */

                /* Input a single word into the holding buffer */

                nHold = inpw(((SWI *) pPointer)->SWI_Port);

                /* Update the mode table pointer */

                pPointer += sizeof(SWI);

                break;

            case SINGLE_DWORD_INPUT:    /* Single dword input command */

                /* Input a single dword into the holding buffer */

                nHold = inpd(((SDI *) pPointer)->SDI_Port);

                /* Update the mode table pointer */

                pPointer += sizeof(SDI);

                break;

            case SINGLE_INDEXED_INPUT:  /* Single indexed input command */

                /* Setup the register index value */

                outp(((SII *) pPointer)->SII_Port,
                     ((SII *) pPointer)->SII_Index);

                /* Input a single byte into the holding buffer */

                nHold = inp(((SII *) pPointer)->SII_Port + 1);

                /* Update the mode table pointer */

                pPointer += sizeof(SII);

                break;

            case SINGLE_BYTE_OUTPUT:    /* Single byte output command */

                /* Output a single byte to the desired port */

                outp(((SBO *) pPointer)->SBO_Port,
                     ((SBO *) pPointer)->SBO_Value);

                /* Update the mode table pointer */

                pPointer += sizeof(SBO);

                break;

            case SINGLE_WORD_OUTPUT:    /* Single word output command */

                /* Output a single word to the desired port */

                outpw(((SWO *) pPointer)->SWO_Port,
                      ((SWO *) pPointer)->SWO_Value);

                /* Update the mode table pointer */

                pPointer += sizeof(SWO);

                break;

            case SINGLE_DWORD_OUTPUT:   /* Single dword output command */

                /* Output a single dword to the desired port */

                outpd(((SDO *) pPointer)->SDO_Port,
                      ((SDO *) pPointer)->SDO_Value);

                /* Update the mode table pointer */

                pPointer += sizeof(SDO);

                break;

            case HOLDING_BYTE_OUTPUT:   /* Holding byte output command */

                /* Output holding byte to the desired port */

                outp(((HBO *) pPointer)->HBO_Port, nHold);

                /* Update the mode table pointer */

                pPointer += sizeof(HBO);

                break;

            case HOLDING_WORD_OUTPUT:   /* Holding word output command */

                /* Output holding word to the desired port */

                outpw(((HWO *) pPointer)->HWO_Port, nHold);

                /* Update the mode table pointer */

                pPointer += sizeof(HWO);

                break;

            case HOLDING_DWORD_OUTPUT:  /* Holding dword output command */

                /* Output holding dword to the desired port */

                outpd(((HDO *) pPointer)->HDO_Port, nHold);

                /* Update the mode table pointer */

                pPointer += sizeof(HDO);

                break;

            case HOLDING_INDEXED_OUTPUT:/* Holding indexed output command */

                /* Setup the register index value */

                outp(((HIO *) pPointer)->HIO_Port,
                     ((HIO *) pPointer)->HIO_Index);

                /* Output holding byte to the desired port */

                outp(((HIO *) pPointer)->HIO_Port + 1, nHold);

                /* Update the mode table pointer */

                pPointer += sizeof(HIO);

                break;

            case MULTIPLE_BYTE_OUTPUT:  /* Multiple byte output command */

                /* Setup the port address and count values */

                nPort = ((MBO *) pPointer)->MBO_Port;
                nCount = ((MBO *) pPointer)->MBO_Count;

                /* Update the mode table pointer */

                pPointer += sizeof(MBO);

                /* Loop outputting bytes to the desired port */

                for (nLoop = 0; nLoop < nCount; nLoop++)
                    outp(nPort, *((BYTE *) pPointer++));

                break;

            case MULTIPLE_WORD_OUTPUT:  /* Multiple word output command */

                /* Setup the port address and count values */

                nPort = ((MWO *) pPointer)->MWO_Port;
                nCount = ((MWO *) pPointer)->MWO_Count;

                /* Update the mode table pointer */

                pPointer += sizeof(MWO);

                /* Loop outputting words to the desired port */

                for (nLoop = 0; nLoop < nCount; nLoop++)
                    outpw(nPort, *((WORD *) pPointer++));

                break;

            case MULTIPLE_DWORD_OUTPUT: /* Multiple dword output command */

                /* Setup the port address and count values */

                nPort = ((MDO *) pPointer)->MDO_Port;
                nCount = ((MDO *) pPointer)->MDO_Count;

                /* Update the mode table pointer */

                pPointer += sizeof(MDO);

                /* Loop outputting dwords to the desired port */

                for (nLoop = 0; nLoop < nCount; nLoop++)
                    outpd(nPort, *((DWORD *) pPointer++));

                break;

            case MULTIPLE_INDEXED_OUTPUT:/* Multiple indexed output command */

                /* Setup the port address and count values */

                nPort = ((MIO *) pPointer)->MIO_Port;
                nIndex = ((MIO *) pPointer)->MIO_Index;
                nCount = ((MIO *) pPointer)->MIO_Count;

                /* Update the mode table pointer */

                pPointer += sizeof(MIO);

                /* Loop outputting bytes to the desired port */

                for (nLoop = 0; nLoop < nCount; nLoop++)
                {
                    /* Setup the register index value */

                    outp(nPort, nIndex++);

                    /* Output the actual data value */

                    outp(nPort + 1, *((BYTE *) pPointer++));
                }

                break;
#endif
            case SINGLE_BYTE_READ:      /* Single byte read command */

                /* Read a single byte into the holding buffer */

                nHold = *((BYTE *) (pMemory + (((SBR *) pPointer)->SBR_Address)));

                /* Update the mode table pointer */

                pPointer += sizeof(SBR);

                break;

            case SINGLE_WORD_READ:      /* Single word read command */

                /* Read a single word into the holding buffer */

                nHold = *((WORD *) (pMemory + (((SWR *) pPointer)->SWR_Address)));

                /* Update the mode table pointer */

                pPointer += sizeof(SWR);

                break;

            case SINGLE_DWORD_READ:     /* Single dword read command */

                /* Read a single dword into the holding buffer */

                nHold = *((DWORD *) (pMemory + (((SDR *) pPointer)->SDR_Address)));

                /* Update the mode table pointer */

                pPointer += sizeof(SDR);

                break;

            case SINGLE_BYTE_WRITE:     /* Single byte write command */

                /* Write a single byte to the desired adress */

                *((BYTE *) (pMemory + (((SBW *) pPointer)->SBW_Address))) =
                    (BYTE) ((SBW *) pPointer)->SBW_Value;

#if 0
					fprintf(stdout,"SBW %x %x\n", 
					((SBW *) pPointer)->SBW_Address,
					((SBW *) pPointer)->SBW_Value);
#endif
                /* Update the mode table pointer */

                pPointer += sizeof(SBW);

                break;

            case SINGLE_WORD_WRITE:     /* Single word write command */

                /* Write a single word to the desired address */

                *((WORD *) (pMemory + (((SWW *) pPointer)->SWW_Address))) =
                    ((SWW *) pPointer)->SWW_Value;

                /* Update the mode table pointer */
#if 0			
					fprintf(stdout,"SWW %x %x\n", 
					((SWW *) pPointer)->SWW_Address,
					((SWW *) pPointer)->SWW_Value);
#endif

                pPointer += sizeof(SWW);

                break;

            case SINGLE_DWORD_WRITE:    /* Single dword write command */

                /* Write a single dword to the desired address */

                *((DWORD *) (pMemory + (((SDW *) pPointer)->SDW_Address))) =
                    ((SDW *) pPointer)->SDW_Value;

                /* Update the mode table pointer */

#if 0
					fprintf(stdout,"SDW %x %x\n", 
					((SDW *) pPointer)->SDW_Address,
					((SDW *) pPointer)->SDW_Value);
#endif
                pPointer += sizeof(SDW);

                break;

            case HOLDING_BYTE_WRITE:    /* Holding byte write command */

                /* Write holding byte to the desired address */

                *((BYTE *) (pMemory + (((HBW *) pPointer)->HBW_Address))) =(BYTE) nHold;

#if 0
					fprintf(stdout,"HBW %x %x\n", 
					((HBW *) pPointer)->HBW_Address,
					nHold);
#endif
                /* Update the mode table pointer */

                pPointer += sizeof(HBW);

                break;

            case HOLDING_WORD_WRITE:    /* Holding word write command */

                /* Write holding word to the desired address */

                *((WORD *) (pMemory + (((HWW *) pPointer)->HWW_Address))) = (WORD) nHold;

                /* Update the mode table pointer */

#if 0
					fprintf(stdout,"HWW %x %x\n", 
					((HWW *) pPointer)->HWW_Address,
					nHold);
#endif
                pPointer += sizeof(HWW);

                break;

            case HOLDING_DWORD_WRITE:   /* Holding dword write command */

                /* Write holding dword to the desired address */

                *((DWORD *) (pMemory + (((HDW *) pPointer)->HDW_Address))) = nHold;

                /* Update the mode table pointer */

#if 0
					fprintf(stdout,"HDW %x %x\n", 
					((HDW *) pPointer)->HDW_Address,
					nHold);
#endif
                pPointer += sizeof(HDW);

                break;

            case MULTIPLE_BYTE_WRITE:   /* Multiple byte write command */

                /* Setup the offset and count values */

                nOffset = ((MBW *) pPointer)->MBW_Address;
                nCount = ((MBW *) pPointer)->MBW_Count;

                /* Update the mode table pointer */

                pPointer += sizeof(MBW);

                /* Loop writing bytes to the desired addresses */

                for (nLoop = 0; nLoop < nCount; nLoop++)
                {
                    /* Write the next byte and update memory offset value */

#if 0
					fprintf(stdout,"MBW %x %x\n", nOffset, (BYTE *)pPointer);
#endif
                    *((BYTE *) (pMemory + nOffset)) = *((BYTE *) pPointer++);
                    nOffset += sizeof(BYTE);
                }

                break;

            case MULTIPLE_WORD_WRITE:   /* Multiple word write command */

                /* Setup the offset and count values */

                nOffset = ((MWW *) pPointer)->MWW_Address;
                nCount = ((MWW *) pPointer)->MWW_Count;

                /* Update the mode table pointer */

                pPointer += sizeof(MWW);

                /* Loop writing words to the desired addresses */

                for (nLoop = 0; nLoop < nCount; nLoop++)
                {
                    /* Write the next word and update memory offset value */

#if 0
					fprintf(stdout,"MWW %x %x\n", nOffset, (WORD *)pPointer);
#endif
                    *((WORD *) (pMemory + nOffset)) = *((WORD *) pPointer++);
                    nOffset += sizeof(WORD);
                }

                break;

            case MULTIPLE_DWORD_WRITE:  /* Multiple dword write command */

                /* Setup the address and count values */

                nOffset = ((MDW *) pPointer)->MDW_Address;
                nCount = ((MDW *) pPointer)->MDW_Count;

                /* Update the mode table pointer */

                pPointer += sizeof(MDW);

                /* Loop writing dwords to the desired addresses */
#if 0
					fprintf(stdout,"nOffset %x nCount %d\n", nOffset, nCount);
#endif

                for (nLoop = 0; nLoop < nCount; nLoop++)
                {
                    /* Write the next dword and update memory offset value */
#if 0
					fprintf(stdout,"nOffset %x Data %x %x\n", nOffset, *pPointer, pPointer);
#endif
                    *((DWORD *) (pMemory + nOffset)) = *((DWORD *) pPointer);
						  pPointer += sizeof(DWORD);
                    nOffset += sizeof(DWORD);
                }

                break;

            case PERFORM_OPERATION:     /* Perform logical operation command */

                /* Switch on the logical operation type */

                switch(((LO *) pPointer)->LO_Operation)
                {
                    case AND_OPERATION: /* Logical AND operation */

                        /* Perform logical AND operation on holding value */

                        nHold &= ((LO *) pPointer)->LO_Value;

                        break;

                    case OR_OPERATION:  /* Logical OR operation */

                        /* Perform logical OR operation on holding value */

                        nHold |= ((LO *) pPointer)->LO_Value;

                        break;

                    case XOR_OPERATION: /* Logical XOR operation */

                        /* Perform logical XOR operation on holding value */

                        nHold ^= ((LO *) pPointer)->LO_Value;

                        break;
                }
                /* Update the mode table pointer */

                pPointer += sizeof(LO);

                break;

            case PERFORM_DELAY:         /* Perform delay operation command */

		       // delay by waiting for the specified number of vsyncs
      		   WaitNVsyncs(pMemory, (WORD)((DO *)pPointer)->DO_Time);

       		   /* Update the mode table pointer */
       		   pPointer += sizeof(DO);

               break;

            case SUB_TABLE:             /* Perform mode sub-table command */

                /* Check the current nesting level */

                if (nPointer < STACK_SIZE)
                {
                    /* Put current offset into stack and update the pointer */

                    anStack[nPointer++] = pPointer - pModeTable + sizeof(MST);

						  if (pBinaryData)
								pPointer = pBinaryData + ((MST *) pPointer)->MST_Pointer;
						  else
						  		pPointer = pModeTable + ((MST *) pPointer)->MST_Pointer;
                }
                else                    /* Nesting level too deep, skip table */
				{
                    #if WIN_NT
                        VideoDebugPrint((2,
                        "\n* * * * CL546X.SYS * Nesting level too deep in SetMode()\n\n"));
                    #else
					    fprintf(stdout,"Nesting to depth %s %d\n", __FILE__, __LINE__);
                    #endif
                    pPointer += sizeof(MST);
				}
                break;

				case I2COUT_WRITE:
                    #if WIN_NT
                        VideoDebugPrint((2,
                        "\n* * * * CL546X.SYS * Unsupported I2C call in SetMode() \n\n"));
                    #endif
					pI2C = (PI2C)pPointer;

					pI2CData = (PI2CDATA)(pPointer + sizeof(I2C));
					for (i=0; i<pI2C->I2C_Count; i++)
						{
                        #if !WIN_NT
						WriteI2CRegister(pMemory, pI2C->I2C_Port, pI2C->I2C_Addr, pI2CData->I2C_Reg, pI2CData->I2C_Data);
                        #endif
						pI2CData++;
						}
					pPointer += sizeof(I2C) + pI2C->I2C_Count * sizeof(I2CDATA);
					break;

            default:                    /* Unknown mode command, abort */
                #if WIN_NT
                   VideoDebugPrint((2,
                   "Miniport - Setmode abort.  Unknnown command.\n"));
                #else
					 fprintf(stdout,"Unknown Command [%x] %s %d\n", ((Mode *) pPointer)->Mode_Opcode, __FILE__, __LINE__);
                #endif
		        return;                 /* Invalid command, return to caller */
                break;
        }
    }
    /* Mode set is complete, return control to the caller */

    return;                             /* Return control to the caller */
}

void WaitNVsyncs (BYTE * pMemory, WORD wNumVsyncs )
{
        volatile BYTE * pMBE = (BYTE *)(pMemory + 0xEC);
        unsigned long uCount = 0x00FFFF;
        int nPort;

        // VideoDebugPrint((2, " ---- WaitNVsyncs.  Enter.\n"));

        //
        // This code will work on 5462, 5464, 5465
        //

#if 0
        nPort = inp(0x3cc) & 0x01 ? 0x3da : 0x3ba;

        while ( (inp(nPort) & 0x08) && (--uCount) )
                ;

        uCount =  0x00FFFF;
        while ( (!(inp(nPort) & 0x08)) && (--uCount) )
                ;
#else
        while ( ((*pMBE & 0x80) == 0x80) && (--uCount) )
                ;

        uCount =  0x00FFFF;
        while ( ((*pMBE & 0x80) == 0x00) && (--uCount) )
                ;
#endif

        // VideoDebugPrint((2, " ---- WaitNVsyncs.  Exit.\n"));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\laguna\mini\cl546x\modemon.h ===
/******************************************************************************
*
*   Module:     MODEMON.H       Mode/Monitor Functions Header Module
*
*   Revision:   1.00
*
*   Date:       April 8, 1994
*
*   Author:     Randy Spurlock
*
*******************************************************************************
*
*   Module Description:
*
*       This module contains the type declarations and function
*   prototypes for the mode/monitor functions.
*
*******************************************************************************
*
*   Changes:
*
*    DATE     REVISION  DESCRIPTION                             AUTHOR
*  --------   --------  -------------------------------------------------------
*  04/08/94     1.00    Original                                Randy Spurlock
*
*
*******************************************************************************
* Modified for NT Laguna Mode Switch Library by Noel VanHook
* Copyright (c) 1997 Cirrus Logic, Inc.
*
*	$Log:   X:/log/laguna/nt35/miniport/cl546x/modemon.h  $
* 
*    Rev 1.6   22 Oct 1997 13:18:48   noelv
* Added code to track the length of mode strings.  Don't rely on _memsize().
* 
*    Rev 1.5   28 Aug 1997 14:25:00   noelv
* Moved SetMode prototype
*
******************************************************************************/

/******************************************************************************
*   Type Definitions and Structures
******************************************************************************/
typedef struct tagRange                 /* Range structure                   */
{
    union tagMinimum                    /* Minimum value for the range       */
    {
        int     nMin;
        long    lMin;
        float   fMin;
    } Minimum;
    union tagMaximum                    /* Maximum value for the range       */
    {
        int     nMax;
        long    lMax;
        float   fMax;
    } Maximum;
} Range;

typedef struct tagMonListHeader         /* Monitor list header structure     */
{
    int         nMonitor;               /* Number of monitors in the list    */
} MonListHeader;

typedef struct tagMonListEntry          /* Monitor list entry structure      */
{
    char        *pszName;               /* Pointer to monitor name string    */
    char        *pszDesc;               /* Pointer to monitor description    */
} MonListEntry;

typedef struct tagMonList               /* Monitor list structure            */
{
    MonListHeader       MonHeader;      /* Monitor list header               */
    MonListEntry        MonEntry[];     /* Start of the monitor list entries */
} MonList;

typedef struct tagMonInfoHeader         /* Monitor info. header structure    */
{
    int         nMode;                  /* Number of monitor modes in list   */
} MonInfoHeader;

typedef struct tagMonInfoEntry          /* Monitor info. entry structure     */
{
    char        *pszName;               /* Pointer to monitor mode name      */
    Range       rHoriz;                 /* Horizontal range values           */
    Range       rVert;                  /* Vertical range values             */
    int         nSync;                  /* Horiz./Vert. sync. polarities     */
    int         nResX;                  /* Maximum suggested X resolution    */
    int         nResY;                  /* Maximum suggested Y resolution    */
} MonInfoEntry;

typedef struct tagMonInfo               /* Monitor information structure     */
{
    MonInfoHeader       MonHeader;      /* Monitor information header        */
    MonInfoEntry        MonEntry[];     /* Start of the monitor entries      */
} MonInfo;

typedef struct tagModeInfoEntry         /* Mode information entry structure  */
{
    char        *pszName;               /* Pointer to mode name string       */
    float       fHsync;                 /* Horizontal sync. frequency value  */
    float       fVsync;                 /* Vertical sync. frequency value    */
    int         nResX;                  /* Horizontal (X) resolution value   */
    int         nResY;                  /* Vertical (Y) resolution value     */
    int         nBPP;                   /* Pixel depth (Bits/Pixel)          */
    int         nMemory;                /* Memory size (Kbytes)              */
    int         nPitch;                 /* Pitch value (Bytes)               */
    unsigned int nAttr;                 /* Mode attribute value              */
	 BYTE * pModeTable;						 /* p Mode Table */
} ModeInfoEntry;

typedef struct tagModeListHeader        /* Mode list header structure        */
{
    int         nMode;                  /* Number of modes in the list       */
	 int 			 nSize;						 /* Size of Entry in bytes */
} ModeListHeader;

typedef struct tagModeListEntry         /* Mode list entry structure         */
{
    ModeInfoEntry ModeEntry;            /* Mode information entry            */
    MonInfoEntry *pMonEntry;            /* Monitor mode index value          */
} ModeListEntry;

typedef struct tagModeList              /* Mode list structure               */
{
    ModeListHeader      ModeHeader;     /* Mode list header                  */
    ModeListEntry       ModeEntry[];    /* Start of the mode list entries    */
} ModeList;

typedef struct tagModeInfo              /* Mode information structure        */
{
    ModeInfoEntry       ModeEntry;      /* Mode information entry            */
} ModeInfo;

/******************************************************************************
*   Function Prototypes
******************************************************************************/
MonList *GetMonitorList(void);
MonInfo *GetMonitorInfo(char *);
ModeList *GetModeList(MonInfo *, char *);
ModeInfo *GetModeInfo(char *, char *);
#if WIN_NT
    BYTE *GetModeTable(char *, char *, int *);
#else
    BYTE *GetModeTable(char *, char *);
#endif


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\laguna\mini\include\5465bw.h ===
/**********************************************************
* Copyright Cirrus Logic, 1997. All rights reserved.
***********************************************************
*
*  5465BW.H - Bandwidth function header for CL-GD5465
*
***********************************************************
*
*  Author: Rick Tillery
*  Date:   03/20/97
*
*  Revision History:
*  -----------------
*  WHO             WHEN            WHAT/WHY/HOW
*  ---             ----            ------------
*
***********************************************************/
// If WinNT 3.5 skip all the source code
#if defined WINNT_VER35      // WINNT_VER35

#else


#ifndef _5465BW_H
#define _5465BW_H

#ifndef WINNT_VER40
#include <Windows.h>
#endif

#ifdef DEBUGSTRINGS
  #ifndef ODS
extern void __cdecl Msg( LPSTR szFormat, ... );

    #define ODS Msg
  #endif // ODS
#else
  #ifndef ODS
    #define ODS (void)
  #endif // ODS
#endif  // DEBUGSTRINGS

#ifdef _DEBUG
  #define BREAK1  _asm int 01h
  #define BREAK3  _asm int 03h
#else
  #define BREAK1
  #define BREAK3
#endif  // _DEBUG

#include "BW.h"

#include <stdlib.h>


//
// CL-GD5465 specifications
//
#define FIFOWIDTH   64                // Bits

#define BLTFIFOSIZE 32                // QWORDS
#define CAPFIFOSIZE 16                // QWORDS
#define GFXFIFOSIZE 64                // QWORDS
#define VIDFIFOSIZE 32                // QWORDS

#define NORM_RANDOM     14            // MCLKs for random access
#ifndef OLDONE
#define CONC_RANDOM      8            // MCLKs for concurrent random access
#define CONC_HIT_LATENCY (8 - 2)      // MCLKs for concurrent hit minus
#else
#define CONC_RANDOM      10            // MCLKs for concurrent random access
#define CONC_HIT_LATENCY 8             // MCLKs for concurrent hit minus
#endif
#define NORM_HIT_LATENCY (4 - 2)      // MCLKs for hit minus MCLK/VCLK sync
                                      //  MCLK/VCLK sync
#define RIF_SAVINGS      4            // MCLKs savings for sequential randoms
#define SYNCDELAY        3            // MCLKs for synchronization delay to
                                      //  account for VCLK/MCLK sync, state
                                      //  machine and RIF delays
#define DISP_LATENCY     6ul            // Max delay through display arbitraion
                                        //  pipeline.
#define ONEVIDLEVELFILL 2             // MCLKs to fill one video FIFO level
#define ONELEVEL        1
#define ARBSYNC       5               // Arbitration sync (pipelining)

#define CURSORFILL    2
#define BLTFILL       (BLTFIFOSIZE / 2) // MCLKs to burst fill BLT FIFO
#define CAPFILL       (CAPFIFOSIZE / 2) // MCLKs to burst fill capture FIFO
#define VIDFILL       (VIDFIFOSIZE / 2) // MCLKs to burst fill video FIFO
#define VID420FILL    (VIDFIFOSIZE / 4) // 4:2:0 divides FIFO into two

#define REF_XTAL  (14318182ul)        // Crystal reference frequency (Hz)
#define TVO_XTAL  (27000000ul)        // TV-Out reference freq.

typedef struct BWREGS_
{
  BYTE MISCOutput;      // 0x0080
  BYTE VCLK3Denom;      // 0x0084
  BYTE VCLK3Num;        // 0x0088
  WORD DispThrsTiming;  // 0x00EA
  WORD GfVdFormat;      // 0x00C0  
  WORD RIFControl;      // 0x0200
  BYTE BCLK_Mult;       // 0x02C0
  BYTE BCLK_Denom;      // 0x02C1
  WORD Control2;        // 0x0418
  BYTE CR1;             // 0x4  Get Screen Width from these registers
  BYTE CR1E;            // 0x78
}BWREGS, FAR *LPBWREGS;

#ifdef WINNT_VER40
// Be sure to synchronize the following structures with the one
// in i386\Laguna.inc!
//
typedef struct PROGREGS_
{
  WORD VW0_FIFO_THRSH;
  WORD DispThrsTiming;
}PROGREGS, FAR *LPPROGREGS;

#else
typedef struct PROGREGS_
{
  WORD VW0_FIFO_THRSH;
  WORD DispThrsTiming;
}PROGREGS, FAR *LPPROGREGS;
#endif

static int ScaleMultiply(DWORD, DWORD, LPDWORD);
DWORD ChipCalcTileWidth(LPBWREGS);
BOOL ChipCalcMCLK(LPBWREGS, LPDWORD);
BOOL ChipCalcVCLK(LPBWREGS, LPDWORD);
BOOL ChipGetMCLK
(
#ifdef WINNT_VER40
  PDEV  *,
#endif
  LPDWORD
);
BOOL ChipGetVCLK
(
#ifdef WINNT_VER40
  PDEV  *,
#endif
  LPDWORD
);
BOOL ChipIsEnoughBandwidth(LPPROGREGS, LPVIDCONFIG, LPBWREGS);


#endif // _5465BW_H
#endif // WINNT_VER35

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\laguna\mini\include\brush.h ===
/******************************Module*Header*******************************\
 *
 * Module Name: brush.h
 *
 * contains prototypes for the brush cache.
 *
 * Copyright (c) 1997 Cirrus Logic, Inc.
 *
 * $Log:   X:/log/laguna/nt35/displays/cl546x/brush.h  $
* 
*    Rev 1.2   26 Feb 1997 10:44:10   noelv
* 
* Fixed structure packing.
* 
*    Rev 1.1   19 Feb 1997 13:06:40   noelv
* Added vInvalidateBrushCache()
* 
*    Rev 1.0   06 Feb 1997 10:34:00   noelv
* Initial revision.
 *
\**************************************************************************/

#include "memmgr.h"

#ifndef _BRUSH_H_
#define _BRUSH_H_


//
// Brush Structures
// See BRUSH.C for comments about how brushes are realized and cached.
// Prototypes for brush handling functions are later on in this file.
//

/*
 * Be sure to synchronize these structures with those in i386\Laguna.inc!
 */

#pragma pack(1)

// A realized brush.  The brush must be cached before it is used.
typedef struct {
  ULONG   nPatSize;
  ULONG   iBitmapFormat;
  ULONG   ulForeColor;
  ULONG   ulBackColor;
  ULONG   iType;        // brush type
  ULONG   iUniq;        // unique value for brush
  ULONG   cache_slot;   // Slot number of cache table entry.
  ULONG   cache_xy;
  ULONG   cjMask;       // offset to mask bits in ajPattern[]
  BYTE    ajPattern[0]; // pattern bits followed by mask bits
} RBRUSH, *PRBRUSH;

#define BRUSH_MONO      1
#define BRUSH_4BPP      2
#define BRUSH_DITHER    3
#define BRUSH_COLOR     4

// An entry in the Brush caching table.
typedef struct {
  ULONG xy;
  PBYTE pjLinear;
  VOID *brushID;  // Address of realized brush structure if this 
                  // cache entry is used.  For verifying that a cache
                  // entry is still valid.
} BC_ENTRY;


#define XLATE_PATSIZE  32      // 8*8 16-color pattern
#define XLATE_COLORS   16      // 8*8 16-color pattern

// An entry in the mono cache table.
typedef struct
{
  ULONG xy;            // x,y location of brush
  PBYTE pjLinear;      // linear address of brush
  ULONG iUniq;         // unique value for brush
  BYTE  ajPattern[8];  // 8x8 monochrome pattern
} MC_ENTRY;

// An entry in the 4-bpp caching table.
typedef struct
{
  ULONG xy;            // x,y location of brush
  PBYTE pjLinear;      // linear address of brush
  ULONG iUniq;         // unique value for brush
  BYTE  ajPattern[XLATE_PATSIZE];  // 8x8 16-color pattern
  ULONG ajPalette[XLATE_COLORS];   // 16-color palette
} XC_ENTRY;

// An entry in the dither cache table.
typedef struct
{
  ULONG xy;        // x,y location of brush
  PBYTE pjLinear;  // linear address of brush
  ULONG ulColor;   // logical color of brush
} DC_ENTRY;


// Define the number of brushes to cache.
#define NUM_MONO_BRUSHES    32     // 2 lines
#define NUM_4BPP_BRUSHES    8      // 4, 8, or 16 lines
#define NUM_DITHER_BRUSHES  8      // 4 lines
#define NUM_COLOR_BRUSHES   32     // 16 lines
#define NUM_SOLID_BRUSHES   4      // 8 lines
#define NUM_8BPP_BRUSHES    (NUM_COLOR_BRUSHES)
#define NUM_16BPP_BRUSHES   (NUM_COLOR_BRUSHES/2)
#define NUM_TC_BRUSHES      (NUM_COLOR_BRUSHES/4)

//
// Brush routines.
//

void vInitBrushCache(
    struct _PDEV *ppdev);

void vInvalidateBrushCache(
    struct _PDEV *ppdev);

ULONG ExpandColor(
    ULONG iSolidColor, 
    ULONG ulBitCount);

BOOL SetBrush(
    struct _PDEV *ppdev,
    ULONG     *bltdef, 
    BRUSHOBJ* pbo, 
    POINTL*   pptlBrush);

BOOL CacheBrush(
    struct _PDEV *ppdev,
    PRBRUSH pRbrush);

VOID vDitherColor(ULONG rgb, ULONG *pul);

// restore default structure alignment
#pragma pack()

#endif // _BRUSH_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\laguna\mini\include\bw.h ===
/**************************************************************************
***************************************************************************
*
*     Copyright (c) 1997, Cirrus Logic, Inc.
*                 All Rights Reserved
*
* FILE:         bw.h
*
* DESCRIPTION:
*
* REVISION HISTORY:
*
* $Log:   X:/log/laguna/ddraw/inc/bw.h  $
* 
*    Rev 1.3   18 Sep 1997 16:05:28   bennyn
* 
* Fixed NT 3.51 compile/link problem
* 
*    Rev 1.2   12 Sep 1997 12:11:08   bennyn
* 
* Modified for NT DD overlay support.
* 
*    Rev 1.1   15 May 1997 15:51:06   XCONG
* 
* Change BWE flags for DDRAW
* 
*    Rev 1.0   14 Apr 1997 11:03:48   RUSSL
* PDC Release
*
***************************************************************************
***************************************************************************/

/**********************************************************
* Copyright Cirrus Logic, Inc. 1996. All rights reserved.
***********************************************************
*
* BW.H
*
* Contains common preprocessor definitions needed for
*  bandwidth equations.
*
***********************************************************
*
*  WHO WHEN     WHAT/WHY/HOW
*  --- ----     ------------
*  RT  11/07/96 Created.
*
***********************************************************/
// If WinNT 3.5 skip all the source code
#if defined WINNT_VER35      // WINNT_VER35

#else


#ifndef BW_H
#define BW_H

#ifdef DOSDEBUG
#include <stdio.h>
#endif // DOSDEBUG

#define VCFLG_CAP       0x00000001ul  // Capture enabled
#define VCFLG_DISP      0x00000002ul  // Display enabled
#define VCFLG_COLORKEY  0x00000004ul  // Color key (destination) enabled
#define VCFLG_CHROMAKEY 0x00000008ul  // Chroma key (source color key) enabled
#define VCFLG_420       0x00000010ul  // 4:2:0 video
#define VCFLG_PAN       0x00000020ul  // Panning display mode

#ifdef WINNT_VER40
// Be sure to synchronize the following structures with the one
// in i386\Laguna.inc!
//
typedef struct VIDCONFIG_
{
  SIZEL sizXfer;    // Size of xfered data in pixels by lines (after cropping)
  SIZEL sizCap;     // Size of data stored in memory in pixels by lines
  SIZEL sizSrc;     // Size of data read from memory in pixels by lines
  SIZEL sizDisp;    // Size of video window rectangle in pixels by lines
  UINT  uXferDepth; // Bits per transferred pixel
  UINT  uCapDepth;  // Bits per pixel stored in memory
  UINT  uSrcDepth;  // Bits per pixel read from memory
  UINT  uDispDepth; // Bits per pixel of video window
  UINT  uGfxDepth;  // Bits per pixel of graphics screen
  DWORD dwXferRate; // Peak pixels per second into video port
  DWORD dwFlags;
}VIDCONFIG, FAR *LPVIDCONFIG;

#else
typedef struct VIDCONFIG_
{
  SIZE  sizXfer;    // Size of xfered data in pixels by lines (after cropping)
  SIZE  sizCap;     // Size of data stored in memory in pixels by lines
  SIZE  sizSrc;     // Size of data read from memory in pixels by lines
  SIZE  sizDisp;    // Size of video window rectangle in pixels by lines
  UINT  uXferDepth; // Bits per transferred pixel
  UINT  uCapDepth;  // Bits per pixel stored in memory
  UINT  uSrcDepth;  // Bits per pixel read from memory
  UINT  uDispDepth; // Bits per pixel of video window
  UINT  uGfxDepth;  // Bits per pixel of graphics screen
  DWORD dwXferRate; // Peak pixels per second into video port
  DWORD dwFlags;
}VIDCONFIG, FAR *LPVIDCONFIG;
#endif

#ifndef ODS
# ifdef DOSDEBUG
#   define ODS printf
# else
#   define ODS (void)
# endif // DOSDEBUG
#endif // !ODS

#endif // BW_H
#endif // WINNT_VER35

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\laguna\mini\cl546x\i386\cfglgmem.asm ===
;*******************************************************************************
;
; Copyright (c)	1996-1998, Cirrus Logic, Inc.
; All Rights Reserved.
;
; FILE:	$Workfile:   CfgLgMem.asm  $
;
; REVISION HISTORY: $Log:   //uinac/Log/Log/Laguna/NT35/Miniport/CL546x/i386/CfgLgMem.asm  $
; 
;    Rev 1.0   Jan 22 1998 16:26:58   frido
; Initial revision.
;
;*******************************************************************************

.586p
.MODEL FLAT, STDCALL

.NOLIST
include i386\CfgLgMem.inc
if 0					; this is for the buggy	build.exe
#include "i386\CfgLgMem.inc"
endif
.LIST

.CODE

GetuPVersionInfo	PROTO	STDCALL
PreMTRRChange		PROTO	STDCALL
PostMTRRChange		PROTO	STDCALL,
		dwCR4		:DWORD
SetMemType		PROTO	STDCALL,
		dwPhysAddr	:DWORD,
		dwSize		:DWORD,
		dwMemType	:DWORD,
		pMTRRReg	:DWORD
ConfigureLagunaMemory	PROTO	STDCALL,
		dwPhysFB	:DWORD,
		dwFBSize	:DWORD
ReleaseMTRRs		PROTO	STDCALL,
		dwFBMTRRReg	:DWORD

;****************************************************************************
;*
;* FUNCTION:	GetuPVersionInfo
;*
;* DESCRIPTION:	Determines cpu, returns family identification in edx:eax
;*		where possible.
;*
;*		Based on sample	code from Intel	App Note AP-485
;*		"Intel Processor Identification	with the CPUID Instruction"
;*
;****************************************************************************

GetuPVersionInfo PROC
LOCAL	highestVal	:DWORD,
	VersionInfo	:QWORD

	pushfd
	pushad

	pushfd					;transfer eflags to eax
	pop	eax

	mov	ecx, eax			;save copy of eflags

	; Test for 386.
	xor	eax, FLAGS_AC_BIT		;toggle AC bit
	push	eax				;transfer eax back to eflags
	popfd
	pushfd					;transfer eflags back to eax
	pop	eax

	; If AC bit did not stay put, then its a 386.
	xor	eax, ecx
	jnz	check_486

	mov	DWORD PTR [VersionInfo][0], FAMILY_386
	mov	DWORD PTR [VersionInfo][4], 0
	jmp	GVIdone

check_486:
	mov	eax, ecx			;get another copy of eflags

	xor	eax, FLAGS_ID_BIT		;toggle ID bit
	push	eax				;transfer eax back to eflags
	popfd
	pushfd					;transfer eflags back to eax
	pop	eax

	; If ID bit did not stay put, the CPUID instruction is not supported.
	; If CPUID is not supported, it must be a 486 if we got to here.
	xor	eax, ecx
	jnz	has_cpuid

	mov	DWORD PTR [VersionInfo][0], FAMILY_486
	mov	DWORD PTR [VersionInfo][4], 0
	jmp	GVIdone

has_cpuid:
	xor	eax, eax			;call cpuid with 0 in eax to get
	cpuid					;  vendor id string and highest
						;  value of eax recognized

	mov	[highestVal], eax		;save highest value

	cmp	ebx, 'uneG'			;ebx,edx,ecx should have
	jne	notIntel			;  'GenuineIntel'
	cmp	edx, 'Ieni'
	jne	notIntel
	cmp	ecx, 'letn'
	je	isIntel

notIntel:
	mov	DWORD PTR [VersionInfo][0], 0
	mov	DWORD PTR [VersionInfo][4], 0
	jmp	GVIdone

isIntel:
	mov	eax, 1
	cmp	eax, [highestVal]
	jle	hasSig

	mov	DWORD PTR [VersionInfo][0], 0
	mov	DWORD PTR [VersionInfo][4], 0
	jmp	GVIdone

hasSig:
	cpuid
	mov	DWORD PTR [VersionInfo][0], eax
	mov	DWORD PTR [VersionInfo][4], edx

GVIdone:
	popad
	popfd

	mov	eax, DWORD PTR [VersionInfo][0]
	mov	edx, DWORD PTR [VersionInfo][4]
	ret

GetuPVersionInfo ENDP

;****************************************************************************
;*
;* FUNCTION:	SetMemType
;*
;* DESCRIPTION:	Sets a MTRR for the physical address range specified to the
;*		memory type specified. Only supports variable range MTRR's.
;*
;*		Based on the MEMTYPESET	pseudo code from chapter 11 of the
;*		"Pentium Pro Family Developer's Manual Volume 3: Operating
;*		System Writer's Guide".
;*
;****************************************************************************

SetMemType PROC \
USES	ebx esi edi,
	dwPhysAddr	:DWORD,
	dwSize		:DWORD,
	dwMemType	:DWORD,
	pMTRRReg	:DWORD
LOCAL	dwMTRRRegCnt	:DWORD,
	dwMaxPhysAddr	:DWORD,
	dwCR4		:DWORD

	; Check	for valid memory type.
	mov	ebx, [dwMemType]

	cmp	ebx, WRITE_COMBINING
	jbe	SMTTypeOk

	cmp	ebx, WRITE_PROTECTED
	ja	SMTErrorInvalidParam

	cmp	ebx, WRITE_THROUGH
	jb	SMTErrorInvalidParam

SMTTypeOk:
	; Check if cpu supports MTRR's.
	INVOKE	GetuPVersionInfo
	test	edx, FEATURE_MTRR
	jz	SMTErrorNotSupported

	mov	ecx, MSR_MTRRcapsReg
	rdmsr

	; If memory type is WC, check if CPU supports WC.
	cmp	ebx, WRITE_COMBINING
	jne	SMTNotWC

	test	eax, MTRRcap_WC_BIT
	jz	SMTErrorNotSupported

SMTNotWC:
	; Cave count of variable MTRR's available.
	and	eax, MTRRcap_VCNT_MASK
	mov	[dwMTRRRegCnt], eax

	; If count is zero then fail.
	or	eax, eax
	jz	SMTErrorNotSupported

	; Check size is not zero and is multiple of 4kB.
	mov	ecx, [dwSize]
	or	ecx, ecx
	jz	SMTErrorInvalidParam

	test	ecx, 00000FFFh
	jnz	SMTErrorInvalidParam

	; Check physAddr is on page (4kB) boundary.
	mov	eax, [dwPhysAddr]
	test	eax, 00000FFFh
	jnz	SMTErrorInvalidParam

	; Check physAddr + size <= 4GB
	add	eax, ecx
	jb	SMTErrorInvalidParam
	mov	[dwMaxPhysAddr], eax		;save this for	later

	; Check power of 2 requirement. This cheats, since I know the size will
	; be 2, 4, 6 or 8 MB.
	dec	ecx
	and	ecx, [dwPhysAddr]
	jnz	SMTErrorInvalidParam

	; Loop over MTRR's to see if this memory range overlaps with a memory
	; range already specified by another MTRR.
	mov	ebx, [dwMTRRRegCnt]
	mov	ecx, [MSR_MTRRphysBase0Reg]

SMTMTRRLoop1:
	; Read the physBase reg.
	rdmsr
	inc	ecx
	mov	edi, edx			;physBase is in edi:esi
	mov	esi, eax

	; Read the physMask reg.
	rdmsr					;physMask is in edx:eax

	test	eax, MTRRphysMask_V_BIT
	jz	SMTMTRRNextPair

	; This MTRR is being used so check for overlap between it's memory range\
	; and the mem range we want to set.

	; Get base physical addr of this MTRR.
	and	esi, MTRRphysBase_PHYS_BASE_MASK_LO
	cmp	esi, [dwMaxPhysAddr]
	ja	SMTMTRRNextPair

	; Convert mask to a size. This probably doesn't always work.
	and	eax, MTRRphysMask_PHYS_MASK_MASK_LO
	not	eax
	inc	eax

	; Find end phys addr of this MTRR.
	add	esi, eax
	cmp	esi, [dwPhysAddr]
	jb	SMTMTRRNextPair

	; Hell, there's an overlap, so fail for now.
	jmp	SMTErrorAlreadyAssigned

SMTMTRRNextPair:
	inc	ecx
	dec	ebx
	jnz	SMTMTRRLoop1

	; Look for first available MTRR.
	mov	ebx, [dwMTRRRegCnt]
	mov	ecx, MSR_MTRRphysMask0Reg

SMTMTRRLoop2:
	; Read physMask reg & check V bit.
	rdmsr
	test	eax, MTRRphysMask_V_BIT
	jz	SMTFoundAvailMTRR

	add	ecx, 2
	dec	ebx
	jnz	SMTMTRRLoop2

	; If we get here then all the MTRR's are already in use so we must fail
	; the call.
	jmp	SMTErrorAccessDenied

SMTFoundAvailMTRR:
	dec	ecx			;ecx contains physBase MSR reg number

	mov	eax, [pMTRRReg]
	mov	[eax], ecx		;save MTRR reg we're going to use

	; Disable
	INVOKE	PreMTRRChange
	mov	[dwCR4], eax

	; Update the MTRR. Set the physBase reg.
	mov	eax, [dwPhysAddr]
	mov	ecx, [dwMemType]
	and	eax, MTRRphysBase_PHYS_BASE_MASK_LO
	and	ecx, MTRRphysBase_TYPE_MASK
	or	eax, ecx
	xor	edx, edx
	mov	ecx, [pMTRRReg]
	mov	ecx, [ecx]
	wrmsr

	; Set the physMask reg.
	mov	eax, [dwSize]
	dec	eax
	not	eax
	and	eax, MTRRphysMask_PHYS_MASK_MASK_LO
	or	eax, MTRRphysMask_V_BIT
	inc	ecx
	xor	edx, edx
	or	edx, MTRRphysMask_PHYS_MASK_MASK_HI
	wrmsr

	; Enable.
	INVOKE	PostMTRRChange, [dwCR4]

SMTDone:
	mov	eax, mVDD_SUCCESS
SMTRet:
	ret

SMTErrorInvalidParam:
	mov	eax, mVDDERR_INVALID_PARAMETER
	jmp	SMTRet

SMTErrorNotSupported:
	mov	eax, mVDDERR_NOT_SUPPORTED
	jmp	SMTRet

SMTErrorAlreadyAssigned:
	mov	eax, mVDDERR_ALREADY_ASSIGNED
	jmp	SMTRet

SMTErrorAccessDenied:
	mov	eax, mVDDERR_ACCESS_DENIED
	jmp	SMTRet

SetMemType ENDP

;****************************************************************************
;*
;* FUNCTION:	PreMTRRChange
;*
;* DESCRIPTION:
;*
;****************************************************************************

PreMTRRChange PROC
LOCAL	dwCR4		:DWORD

	; Disable interrupts.
	cli

	; Save CR4.
	mov	eax, cr4
	mov	[dwCR4], eax

	; Disable caching.
	mov	eax, cr0
	or	eax, CR0_CD_BIT			;set CD bit in CR0
	and	eax, NOT CR0_NW_BIT		;clear NW bit in CR0
	mov	cr0, eax

	; Flush the caches.
	wbinvd

	; Flush the TLB's.
	mov	eax, cr3
	mov	cr3, eax

	; Disable MTRR's.
	mov	ecx, MSR_MTRRdefTypeReg
	rdmsr
	and	eax, NOT MSR_MTRREnable
	wrmsr

	; Return the saved CR4 value.
	mov	eax, [dwCR4]
	ret

PreMTRRChange ENDP

;****************************************************************************
;*
;* FUNCTION:	PostMTRRChange
;*
;* DESCRIPTION:
;*
;****************************************************************************

PostMTRRChange PROC,
	dwCR4		:DWORD

	; Flush caches.
	wbinvd

	; Flush TLB's.
	mov	eax, cr3
	mov	cr3, eax

	; Enable MTRR's
	mov	ecx, MSR_MTRRdefTypeReg
	rdmsr
	or	eax, MSR_MTRREnable
	wrmsr

	; Enable caches.
	mov	eax, cr0
	and	eax, NOT (CR0_CD_BIT OR CR0_NW_BIT)
	mov	cr0, eax

	; Restore cr4.
	mov	eax, [dwCR4]
	mov	cr4, eax

	; Enable interrupts.
	sti
	ret

PostMTRRChange ENDP

;****************************************************************************
;*
;* FUNCTION:	ConfigureLagunaMemory
;*
;* DESCRIPTION:	Set physical address of frame buffer to write combined caching.
;*		Only supports CPU's with MTRR's.
;*
;****************************************************************************

ConfigureLagunaMemory PROC,
	dwPhysFB	:DWORD,
	dwFBSize	:DWORD
LOCAL	dwFBMTRRReg	:DWORD

	; Initialize dwFBMTRRReg.
	mov	[dwFBMTRRReg], 0

	; Set frame buffer to write-combining memory type assigned to a dwFBSize
	; block of memory starting at the physical address of the frame buffer.
	mov	eax, [dwPhysFB]
	mov	ecx, [dwFBSize]
	lea	edx, [dwFBMTRRReg]
	INVOKE	SetMemType, eax, ecx, WRITE_COMBINING, edx

	mov	eax, [dwFBMTRRReg]
	ret

ConfigureLagunaMemory ENDP

;****************************************************************************
;*
;* FUNCTION:	ReleaseFBMTRR
;*
;* DESCRIPTION:	Clears the MTRR	used for the frame buffer on system
;*		exit
;*
;****************************************************************************

ReleaseMTRRs PROC,
	dwFBMTRRReg	:DWORD
LOCAL	dwCR4		:DWORD

	; See if we have a valid MTRR register.
	mov	eax, [dwFBMTRRReg]
	cmp	eax, MSR_MTRRphysBase0Reg
	jb	RMFBDone

	cmp	eax, MSR_MTRRphysBase7Reg
	ja	RMFBDone

	; Disable.
	INVOKE	PreMTRRChange
	mov	[dwCR4], eax

	; Update the MTRR. Set the physBase reg.
	xor	eax, eax
	xor	edx, edx
	mov	ecx, [dwFBMTRRReg]
	wrmsr

	; Set the physMask reg.
	inc	ecx
	wrmsr

	; Enable.
	INVOKE	PostMTRRChange, [dwCR4]

RMFBDone:
	ret

ReleaseMTRRs ENDP
END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\laguna\mini\include\config.h ===
/* config.h	
 * 	stuff here is meant to deal w/ portability issues
 * 	across architectur/platforms
 *
 *	ALL_HOST defined means do all work on host, as opposed to some on
 *		TI board
 *
 *	DIRECT_IO defined means the CPU running the code cas do direct file IO
 *
 *	NO_ADDR_CONST_EXPR defined means the compiler in use can't do address
 *		arithmetic in integer constant expressions, i.e. case statement
 */

#ifndef _CONFIG_H_
#define _CONFIG_H_

#ifdef sun
#define ALL_HOST		/* do all the work on the host */
#define DIRECT_IO		/* the CPU doing the graphics can do file IO */
/*#define NO_ADDR_CONST_EXPR */
#else /* def sun */
#define ALL_HOST		/* do all the work on the host */
#define DIRECT_IO		/* the CPU doing the graphics can do file IO */
#define NO_ADDR_CONST_EXPR
#endif /* def sun */

#ifndef FAR
#ifdef MSDOS
#define FAR far
#else
#define FAR
#endif
#endif

/* deal w/ the different pointer addressing, i.e. PR_SHIFT != 0 means bit
 * 	addressing 
 */
#ifdef MSDOS 
#define PR_SHIFT 0		/* Host code; byte addresses */
#elif sun
#define PR_SHIFT 0		/* Host code; byte addresses */
#else
#define PR_SHIFT 3		/* TI code; bit of byte addresses */
#endif /* MSDOS */

/* the following macros are for dealing w/ TI "asm" statement */
#ifdef ALL_HOST
#define DISABLE_INTERRUPT	
#define ENABLE_INTERRUPT	
#define ASM( a,b) b
#else /* ALL_HOST */
#define DISABLE_INTERRUPT	asm (" DINT")
#define ENABLE_INTERRUPT	asm (" EINT")
#define ASM( a,b) a
#endif /*  ALL_HOST */


#endif /* __CONFIG_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\laguna\mini\include\ddinline.h ===
/**************************************************************************
***************************************************************************
*
*     Copyright (c) 1996, Cirrus Logic, Inc.
*                 All Rights Reserved
*
* FILE:         ddinline.h
*
* DESCRIPTION:  Private declarations for DDraw blt code
*
* REVISION HISTORY:
*
* $Log:   X:/log/laguna/ddraw/inc/ddinline.h  $
* 
*    Rev 1.5   Feb 16 1998 16:33:02   frido
* The previous fix should only happen for Windows 95.
* 
*    Rev 1.4   08 Jan 1998 12:38:12   eleland
* Added a SyncWithQueueManager call in CurrentVLine.  This fixes
* a PCI bus hang (PDR 10917).
* 
*    Rev 1.3   06 Jan 1998 14:20:42   xcong
* Access pDriverData locally for multi-monitor support.
* 
*    Rev 1.2   29 Aug 1997 17:46:34   RUSSL
* Needed a couple more defines for previous change
* 
*    Rev 1.1   29 Aug 1997 17:40:02   RUSSL
* Added CurrentVLine for 65 NT overlay
*
*    Rev 1.0   20 Jan 1997 14:42:42   bennyn
* Initial revision.
*
***************************************************************************
***************************************************************************/
// If WinNT 3.5 skip all the source code
#if defined WINNT_VER35      // WINNT_VER35

#else


#ifndef _DDINLINE_H_
#define _DDINLINE_H_

/***************************************************************************
* I N L I N E   F U N C T I O N S
****************************************************************************/

/***************************************************************************
*
* FUNCTION:     DupColor()
*
* DESCRIPTION:
*
****************************************************************************/

static __inline DWORD DupColor
(
#ifdef WINNT_VER40
  struct _PDEV        *ppdev,
//??  struct _DRIVERDATA  *lpDDHALData,
#else
   LPGLOBALDATA lpDDHALData,
#endif
  DWORD dwColor
)
{
  return (8 == BITSPERPIXEL) ?
         MAKELONG( MAKEWORD(dwColor,dwColor), MAKEWORD(dwColor,dwColor) )
         : (16 == BITSPERPIXEL) ?
         MAKELONG( dwColor, dwColor ) : // bpp must be 24 or 32.
         dwColor;
}

/***************************************************************************
*
* FUNCTION:     EnoughFifoForBlt()
*
* DESCRIPTION:
*
****************************************************************************/

/*
 * EnoughFifoForBlt should be replaced with a test to see if there is enough
 * room in the hardware fifo for a blt
 */
static __inline BOOL EnoughFifoForBlt
(
#ifdef WINNT_VER40
  struct _DRIVERDATA  *lpDDHALData
#else
  LPGLOBALDATA  lpDDHALData
#endif
)
{
  // This should probably be a little more specific to each call !!!
  // A (untiled) stretch blt actually needs 17 free entries.
  const BYTE QFREE = 16;

  PVGAR pREG = (PVGAR) lpDDHALData->RegsAddress;
  return (pREG->grQFREE >= QFREE);
}

/***************************************************************************
*
* FUNCTION:     DupZFill
*
* DESCRIPTION:  Gets the actual value for Z fills
*
****************************************************************************/
//JGO added for Laguna3D integration

static __inline DWORD DupZFill
(
#ifdef WINNT_VER40
  struct _PDEV  *ppdev,
#else
  LPGLOBALDATA lpDDHALData,
#endif
  DWORD   dwFillValue,
  DWORD   zBpp
)
{

    return (8 == zBpp) ?
        MAKELONG( MAKEWORD(dwFillValue,dwFillValue),
                  MAKEWORD(dwFillValue,dwFillValue) )
         : (16 == BITSPERPIXEL) ?
        MAKELONG( dwFillValue, dwFillValue )
         : // bpp must be 24 or 32.
        dwFillValue;
}

#ifdef WINNT_VER40
#if DRIVER_5465 && defined(OVERLAY)

#define CSL           0x00C4
#define CSL_5464      0x0140

/***************************************************************************
*
* FUNCTION:     CurrentVLine
*
* DESCRIPTION:
*
****************************************************************************/
static __inline int CurrentVLine (PDEV* ppdev)
{
  WORD   cline;
  PBYTE  pMMReg = (PBYTE) ppdev->pLgREGS_real;
  PWORD  pCSL;
  BYTE   tmpb;

#ifndef WINNT_VER40
  SyncWithQueueManager(lpDDHALData);
#endif

  // on 5462 there is no CurrentScanLine register
  // on RevAA of 5465 it's busted
  if ((CL_GD5462 == ppdev->dwLgDevID) ||
     ((CL_GD5465 == ppdev->dwLgDevID) && (0 == ppdev->dwLgDevRev)))
     return 0;

  if (IN_VBLANK)
     return 0;

  // read current scanline
  if (ppdev->dwLgDevID == CL_GD5464)
     pCSL = (PWORD) (pMMReg + CSL_5464);
  else
     pCSL = (PWORD) (pMMReg + CSL);

  cline = *pCSL & 0x0FFF;

  // if scanline doubling is enabled, divide current scanline by 2
  tmpb = (BYTE) LLDR_SZ (grCR9);
  if (0x80 & tmpb)
     cline /= 2;

  // if current scanline is past end of visible screen return 0
  if (cline >= ppdev->cyScreen)
    return 0;
  else
    return cline;
}
#endif  // DRIVER_5465 && OVERLAY
#endif  // WINNT_VER40

#endif /* _DDINLINE_H_ */
#endif // WINNT_VER35
/* Don't write below this endif */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\laguna\mini\include\font.h ===
/******************************Module*Header*******************************\
 *
 * Module Name:  font.h
 *
 * Author:    Frido Garritsen
 *
 * Purpose:    Define the font cache structures.
 *
 * Copyright (c) 1996 Cirrus Logic, Inc.
 *
 * $Log:   X:/log/laguna/nt35/displays/cl546x/FONT.H  $
* 
*    Rev 1.5   20 Aug 1996 11:04:56   noelv
* Bugfix release from Frido 8-19-96
* 
*    Rev 1.0   14 Aug 1996 17:16:36   frido
* Initial revision.
* 
*    Rev 1.4   25 Jul 1996 15:53:12   bennyn
* 
* Modified for DirectDraw support
 * 
 *    Rev 1.3   05 Mar 1996 11:59:46   noelv
 * Frido version 19
 * 
 *    Rev 1.3   28 Feb 1996 22:39:06   frido
 * Removed bug in naming ulFontCountl.
 * 
 *    Rev 1.2   03 Feb 1996 12:22:20   frido
 * Added text clipping.
 * 
 *    Rev 1.1   25 Jan 1996 12:49:38   frido
 * Added font cache ID counter to FONTCACHE structure.
 * 
 *    Rev 1.0   23 Jan 1996 15:14:52   frido
 * Initial release.
 *
\**************************************************************************/

#define  BYTES_PER_TILE  128   // Number of bytes per tile line.
#define  LINES_PER_TILE  16    // Number of lines per tile.

#define CACHE_EXPAND_XPAR  0x105501F0  // DRAWBLTDEF register value.

// support routines

extern BYTE Swiz[];

void AddToFontCacheChain(PDEV*       ppdev,
                         FONTOBJ*    pfo,
                         PFONTCACHE  pfc);

VOID AllocGlyph(
  PFONTCACHE  pfc,    // Pointer to font cache.
  GLYPHBITS*  pgb,    // Pointer to glyph to cache.
  PGLYPHCACHE  pgc      // Pointer to glyph cache structure.
);

long GetGlyphSize(
  GLYPHBITS*  pgb,    // Pointer to glyph.
  POINTL*    pptlOrigin,  // Pointer to return origin in.
  DWORD*    pcSize    // Pointer to return size of glyph in.
);

BOOL AllocFontCache(
  PFONTCACHE  pfc,    // Pointer to font cache.
  long    cWidth,    // Width (in bytes) to allocate.
  long    cHeight,  // Height to allocate.
  POINTL*    ppnt    // Point to return cooridinate in.
);

VOID FontCache(
  PFONTCACHE  pfc,    // Pointer to font cache.
  STROBJ*    pstro    // Pointer to glyphs.
);

VOID ClipCache(
  PFONTCACHE  pfc,    // Pointer to font cache.
  STROBJ*    pstro,    // Pointer to glyphs.
  RECTL    rclBounds  // Clipping rectangle.
);

VOID DrawGlyph(
  PDEV*    ppdev,    // Pointer to physical device.
  GLYPHBITS*  pgb,    // Pointer to glyph to draw.
  POINTL    ptl      // Location of glyph.
);

VOID ClipGlyph(
  PDEV*    ppdev,    // Pointer to physical device.
  GLYPHBITS*  pgb,    // Pointer to glyph to draw.
  POINTL    ptl,    // Location of glyph.
  RECTL    rclBounds  // Clipping rectangle.
);

#define PACK_XY(x, y)    ((WORD)(x) | ((DWORD)(y) << 16))

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\laguna\mini\cl546x\cirrus.c ===
/******************************************************************************
*
*                ******************************************
*                * Copyright (c) 1995, Cirrus Logic, Inc. *
*                *            All Rights Reserved         *
*                ******************************************
*
* PROJECT:  Laguna I (CL-GD546x) - 
*
* FILE:     cirrus.c
*
* AUTHOR:   Benny Ng
*
* DESCRIPTION:
*           This is the Cirrus Logic Laguna NT miniport driver.
*           (kernel mode only)
*           Based on the S3 miniport from NT DDK.
*
*   Copyright (c) 1995, 1996 Cirrus Logic, Inc.
*
* MODULES:
*           DriverEntry()
*           CLFindAdapter()
*           CLInitialize()
*           CLStartIO()
*           VS_Control_Hack()
*           Output_To_VS_CLK_CONTROL()
*           PMNT_Init()
*           PMNT_SetACPIState()
*           PMNT_GetACPIState()
*           PMNT_SetHwModuleState()
*           PMNT_GetHwModuleState()
*           PMNT_Close()
*           CLSetColorLookup()
*           CLFindVmemSize()
*           CLWriteRegistryInfo()
*           CLValidateModes()
*           CLCopyModeInfo()
*           CLSetMode()
*           CLSetMonitorType()
*           CLPowerManagement()
*
* REVISION HISTORY:
*   5/30/95     Benny Ng      Initial version
*
* $Log:   //uinac/log/log/laguna/nt35/miniport/cl546x/CIRRUS.C  $
* 
*    Rev 1.131   Jun 16 1998 09:51:24   frido
* PDR#????? - Make CLResetHw and all dependent functions
* non-pageable.
* 
*    Rev 1.130   May 04 1998 11:54:58   frido
* Oops. wrong check.
* 
*    Rev 1.129   May 04 1998 11:31:16   frido
* Changed the FIFO override code to include clocks 16h and 17h and
* changed the values in the override table.
* 
*    Rev 1.128   Apr 30 1998 15:30:18   frido
* PDR#11398. CLRegistryCallback has been added to patch the
* InstalledDisplayDrivers registry entry in case a remote control program
* like LapLink or Timbuktu has been loaded.
* 
*    Rev 1.127   Apr 23 1998 16:18:34   frido
* PDR#11377. Test PCI command register when looking for a Laguna
* borda. It might be disabled.
* 
*    Rev 1.126   Apr 23 1998 14:54:46   frido
* PDR#11290. Before changing to a text mode from a graphics mode, we
* need to enable the PCI configuration registers.
* 
*    Rev 1.125   Apr 20 1998 11:33:54   frido
* PDR#11350. Added CLResetHw routine which resets the hardware to
* the default text mode.
* 
*    Rev 1.124   Apr 17 1998 13:54:00   frido
* Keep sync polarity as is, but only make them negative when the monitor
* requires it.
* 
*    Rev 1.123   Apr 15 1998 10:07:38   frido
* PDR#11317: The SyncPolarity registry key has changed a bit. Now it
* is a string value which will hold EDID manufacturer and monitor codes
* for monitors that need negative polarity.
* 
*    Rev 1.122   Apr 02 1998 15:50:06   frido
* Changed the SyncPolarity code. It is now dynamic using the EDID
* manufacturer and product code to compare with a list in the registry.
* 
*    Rev 1.121   Mar 30 1998 15:02:48   frido
* PDR#11284. I changed the delay before writing the palette data in the
* CLSetColorLookup routine. Now when the vertical retrace is being
* activated, all remaining palette entries are send to the chip.
* 
*    Rev 1.120   Mar 25 1998 18:28:56   frido
* Why don't I compile before checking in? That would catch the errors...
* 
*    Rev 1.119   Mar 25 1998 18:20:28   frido
* Fixed the CLGetMonitorSyncPolarity function.
* 
*    Rev 1.118   Mar 25 1998 17:57:56   frido
* Added IOCTL_STALL.
* 
*    Rev 1.117   Mar 25 1998 10:22:50   frido
* Removed the multi-string registry hack for NT 5.0.
* 
*    Rev 1.116   Mar 25 1998 10:19:04   frido
* Added new code for monitor sync polarity.
* 
*    Rev 1.115   Feb 25 1998 15:39:04   frido
* Added NT 5.0 PnP & Power Saving support.
* 
*    Rev 1.114   Jan 22 1998 16:25:24   frido
* Added a call to enable Write Combined Caching for Intel CPU's.
* 
*    Rev 1.113   Jan 21 1998 17:49:22   frido
* Redfined the validation of the chipset for frame buffer bursting.
* 
*    Rev 1.112   Jan 21 1998 17:43:16   frido
* Enabled frame buffer bursting on 5465AF and higher.
* 
*    Rev 1.111   Jan 06 1998 16:47:22   frido
* I have added a LowRes registry flag. If it is not available or 0, low-res
* modes are disabled. If the value is 1, low-res modes are enabled.
* 
*    Rev 1.110   Dec 10 1997 13:17:50   frido
* Merged from 1.62 branch.
* 
*    Rev 1.109.1.3   Nov 20 1997 14:57:02   frido
* Re-enabled 640x350 and 640x400 as normal modes.
* 
*    Rev 1.109.1.2   Nov 19 1997 10:04:10   phyang
* Added FIFO Threshold override table for clock speed 0x14h.
* 
*    Rev 1.109.1.1   Nov 17 1997 11:06:10   frido
* Added MULTI_CLOCK support.  This new feature (as per customer
* request) overrides the FIFO Threshold value for certain modes at
* different clock speeds.
* 
*    Rev 1.109.1.0   Nov 10 1997 11:41:04   phyang
* Added 5 device I/O control codes for utilities to update registry values.
* 
*    Rev 1.109   Nov 04 1997 09:22:56   frido
* Added code to disable LOWRES modes if defined in SWAT.h.
* 
*    Rev 1.108   Nov 03 1997 16:58:08   phyang
* Added USB Fix flag query support and better mode filter function.
* 
*    Rev 1.107   Oct 23 1997 15:46:20   phyang
* Move usMaxVtFrequency and usMaxXResolution to HW_DEVICE_EXTENSION.
* 
*    Rev 1.106   23 Oct 1997 11:17:04   noelv
* Added new DDC filter function.
* RE-enabled DD modes.
* 
*    Rev 1.104   07 Oct 1997 16:45:42   frido
* I have removed all low-res modes again, WHQL fails at 320x400 and 340x400.
* 
*    Rev 1.103   27 Sep 1997 10:58:44   frido
* Removed the displaying of the version number.  It would generate STOP
* messages during unattended setup.
* 
*    Rev 1.102   16 Sep 1997 13:46:16   frido
* Added patch to counteract NT's memory leak when using multiple display
* driver DLL's.
* 
*    Rev 1.101   16 Sep 1997 13:30:12   bennyn
* 
* Display the version message after Laguna chip family is detected.
* 
*    Rev 1.100   12 Sep 1997 09:09:22   FRIDO
* Enabled 256-byte prefetch.
* 
*    Rev 1.99   04 Sep 1997 16:37:16   bennyn
* 
* Added restore and set video window regs before and after the mode change.
* 
*    Rev 1.98   29 Aug 1997 12:26:02   noelv
* restore file after roll-back
* 
*    Rev 1.96   27 Aug 1997 10:29:18   noelv
* Apply CONTROL[4] fix to AF chip, too.
* 
*    Rev 1.95   26 Aug 1997 11:46:46   noelv
* Enable lo-res DDRAW modes.
* 
*    Rev 1.94   20 Aug 1997 16:59:58   noelv
* Typo in version string (again :)
* 
*    Rev 1.93   20 Aug 1997 09:33:18   bennyn
* 
* Added automatically detects PnP monitor support
* 
*    Rev 1.92   19 Aug 1997 17:40:16   noelv
* 
* Added newline to driver version string
* 
*    Rev 1.91   14 Aug 1997 14:44:56   noelv
* 
* Changed the way the version is reported.
* 
*    Rev 1.90   13 Aug 1997 11:22:10   noelv
* Added [5465AD] setcion to MODE.INI
* 
*    Rev 1.89   07 Aug 1997 15:30:18   noelv
* Made AGP_VGA_HACK and FAVOR_MODE_INI a permanent part of the driver.
* Removed their #defines
* 
*    Rev 1.88   04 Aug 1997 16:26:12   BENNYN
* Commented out the EDID mode filter function
* 
*    Rev 1.87   29 Jul 1997 15:10:04   noelv
* 0x0484 to perfomance reg to get rid of snow in foxbear.
* 
*    Rev 1.86   23 Jul 1997 09:26:44   bennyn
* 
* Added code to handle IOCTL_GET_BIOS_VERSION command
* 
*    Rev 1.85   22 Jul 1997 12:39:40   bennyn
* 
* Trunicate the mode table of EDID data is available
* 
*    Rev 1.84   21 Jul 1997 13:51:52   bennyn
* 
* Added call to ReadVesaTiming()
* 
*    Rev 1.83   15 Jul 1997 09:20:18   noelv
* Added AGP card support for NT 3.51
* 
*    Rev 1.82   14 Jul 1997 16:51:50   bennyn
* Removed setting the mclk to 13h for cl5465
* 
*    Rev 1.81   02 Jul 1997 15:08:52   noelv
* Fixes the clock-set code for 5465.  Set the clock to 13h
* 
*    Rev 1.80   01 Jul 1997 14:48:02   bennyn
* Change MCLK to 14 for 5465
* 
*    Rev 1.79   20 Jun 1997 13:45:36   bennyn
* 
* Added power manager functions to Miniport
* 
*    Rev 1.78   19 Jun 1997 11:32:52   BENNYN
* Disabled the 256-bytes fetch
* 
*    Rev 1.77   16 Jun 1997 16:25:20   noelv
* 
* 5465AD HW workarounds from Frido
* SWAT: 
* SWAT:    Rev 1.4   07 Jun 1997 12:45:08   frido
* SWAT: Added setting of CONTROL[4] bit for 5465AD chip.
* 
*    Rev 1.76   15 May 1997 15:57:02   noelv
* Moved SWAT4 stuff to the miniport
* 
*    Rev 1.75   14 May 1997 16:56:04   bennyn
* Fixed PDR 9630
* 
*    Rev 1.74   05 May 1997 16:38:52   noelv
* Wait for blank before writing to the palette
* 
*    Rev 1.73   30 Apr 1997 16:41:24   noelv
* Moved global SystemIoBusNumber into the device extension, where it belongs.
* 
*    Rev 1.72   24 Apr 1997 11:00:52   SueS
* Enable MMIO access to PCI space on a reset device IOCTL.  Added
* function CLEnablePCIConfigMMIO.
* 
*    Rev 1.71   23 Apr 1997 07:20:10   SueS
* Added new IOCTL for enabling memory-mapped I/O access to PCI 
* configuration registers.  Save PCI slot number for use in later
* kernel function call.
* 
*    Rev 1.70   22 Apr 1997 11:01:44   noelv
* 
* Added forward compatible chip ids.
* 
*    Rev 1.69   17 Apr 1997 14:34:00   noelv
* Changed interleave for 8 meg boards.
* Expanded frame buffer memory space to 16 meg.
* Don't patch MODE.INI modes.
* 
*    Rev 1.68   04 Apr 1997 14:45:56   noelv
* Removed VL access ranges.  Rearranged VGA access ranges.
* Changed call to SetMode() to include the new parameter.
* 
*    Rev 1.67   28 Mar 1997 16:59:38   noelv
* Added 5464 and 5465 specific code to CLEnableTiling.
* 
*    Rev 1.66   28 Mar 1997 13:29:30   noelv
* Fixed tiling on NT 3.51
* 
*    Rev 1.65   27 Mar 1997 11:33:36   noelv
* Favor MODE.INI modes over BIOS modes.
* Fix ClEnableTiling for 5464.
* 
*    Rev 1.64   24 Mar 1997 16:07:58   noelv
* Changed memory detect to use memory mapped registers (instead of VGA).
* 
*    Rev 1.63   03 Mar 1997 14:42:14   SueS
* Subtract 1 from tiles per line (Win95 <fetch-1> bandwidth improvement).
* Set address translation delay to 3 clocks.
* 
*    Rev 1.62   28 Feb 1997 11:19:16   SueS
* For bus mastering (which isn't currently enabled), get an adapter object
* for the call to HalAllocateCommonBuffer.  Otherwise, we bomb when we boot
* in VGA mode with bus mastering turned on.
* 
*    Rev 1.61   26 Feb 1997 16:14:38   noelv
* CLPatchModeTable now correctly locates a planar BIOS.
* 
*    Rev 1.60   21 Feb 1997 16:16:44   noelv
* Fixed typo in AGP code.
* 
*    Rev 1.59   21 Feb 1997 15:20:50   noelv
* Sped up CLPatchModeTable
* 
*    Rev 1.58   21 Feb 1997 14:42:10   noelv
* Oops.  I swapped the frame buffer and register address spaces by accident.
* 
*    Rev 1.57   21 Feb 1997 12:53:42   noelv
* AGP and 5465 4meg support
* 
*    Rev 1.56   19 Feb 1997 13:16:44   noelv
* Added partial AGP support
* 
*    Rev 1.55   04 Feb 1997 15:35:58   bennyn
* Interleave off for VGA modes, on for extended modes
* 
*    Rev 1.54   03 Feb 1997 13:24:46   noelv
* Remove 1280x960
* 
*    Rev 1.53   31 Jan 1997 10:00:26   noelv
* Allowed +/- 1 hz when matching refresh reates between MODE.INI and BIOS
* 
*    Rev 1.52   28 Jan 1997 11:32:32   noelv
* write the correct chip type to the registry.
* 
*    Rev 1.51   14 Jan 1997 17:23:08   bennyn
* Modified to support 5465
* 
*    Rev 1.50   14 Jan 1997 12:32:02   noelv
* Split MODE.INI by chip type
* 
*    Rev 1.49   09 Dec 1996 15:50:44   bennyn
* Supported the 5465 MMIO & FB base addr PCI offset change
* 
*    Rev 1.48   03 Dec 1996 10:51:42   noelv
* Always use 2-way interleave
* 
*    Rev 1.47   26 Nov 1996 08:42:50   SueS
* Added case for closing the log file.
* 
*    Rev 1.46   13 Nov 1996 16:19:46   noelv
* Disabled WC memory for the 5462
* 
*    Rev 1.45   13 Nov 1996 15:28:36   SueS
* Added support for two new IOCTL codes used for the file logging option.
* There is an IOCTL request to open the file and another to write to it.
* 
*    Rev 1.44   13 Nov 1996 08:18:12   noelv
* 
* Cleaned up support for 5464 register set.
* 
*    Rev 1.43   11 Nov 1996 10:42:08   noelv
* Turn off bus mastering abilities for release builds.
* 
*    Rev 1.42   07 Nov 1996 10:48:04   BENNYN
* Turn-on P6WC bit and added support for BD and 5465 parts
* 
*    Rev 1.41   30 Oct 1996 14:06:50   bennyn
* 
* Modified for pageable miniport
* 
*    Rev 1.40   23 Oct 1996 16:03:14   noelv
* 
* Added BUS MASTERING support.
* 
*    Rev 1.39   07 Oct 1996 14:28:20   noelv
* Removed WC memory.
* 
*    Rev 1.38   03 Oct 1996 17:12:10   noelv
* removed LNCTRL init.
* 
*    Rev 1.37   01 Oct 1996 17:39:08   noelv
* Don't read LnCntl reg.
* 
*    Rev 1.36   30 Sep 1996 10:01:42   noelv
* Used 16 bit writes to do clear-screen BLT, 'cause 5464 was hanging.
* 
*    Rev 1.35   24 Sep 1996 10:02:00   noelv
* Added venus chipset to known bad.
* 
*    Rev 1.34   18 Sep 1996 15:49:12   noelv
* P^ cache enabled on NT 4.0 only
* 
*    Rev 1.33   13 Sep 1996 15:35:36   bennyn
* Turn-on the P6 cache
* 
*    Rev 1.32   30 Aug 1996 13:00:18   noelv
* 
* Set interleave before calling SetMode().
* 
*    Rev 1.31   23 Aug 1996 14:18:28   noelv
* 
* Fixed syntax error.
* 
*    Rev 1.30   23 Aug 1996 14:14:48   noelv
* Accidently timmed VGA modes from NT 3.51 driver.
* 
*    Rev 1.29   23 Aug 1996 09:43:34   noelv
* Frido bug release 8-23.
* 
*    Rev 1.28   22 Aug 1996 18:47:12   noelv
* fixed typo in ttrimming DD modes from nt3.51
* 
*    Rev 1.27   22 Aug 1996 17:39:06   noelv
* Trim DD modes from NT3.51
* 
*    Rev 1.26   22 Aug 1996 16:35:06   noelv
* Changed for new mode.ini
* 
*    Rev 1.25   21 Aug 1996 16:42:58   noelv
* Turned down the clock on the '64
* 
*    Rev 1.24   20 Aug 1996 11:57:50   noelv
* 
* Added correct chip ID to registry.
* 
*    Rev 1.23   20 Aug 1996 11:26:56   noelv
* Bugfix release from Frido 8-19-96
* 
*    Rev 1.4   18 Aug 1996 23:24:36   frido
* #1334? - Changed hardware registers to 'volatile'.
* 
*    Rev 1.3   17 Aug 1996 17:31:18   frido
* Cleanup up #1242 patch by blanking screen before clearing video memory.
* 
*    Rev 1.2   16 Aug 1996 14:34:42   frido
* #1242 - Added clearing of video memory.
* 
*    Rev 1.1   15 Aug 1996 12:45:10   frido
* Fixed warning messages.
* 
*    Rev 1.0   14 Aug 1996 17:12:18   frido
* Initial revision.
* 
*    Rev 1.21   15 Jul 1996 17:18:00   noelv
* Added wait for idle before mode switch
* 
*    Rev 1.20   11 Jul 1996 15:30:38   bennyn
* Modified to support DirectDraw
* 
*    Rev 1.19   25 Jun 1996 10:48:58   bennyn
* Bring-up the 5464
* 
*    Rev 1.18   19 Jun 1996 11:04:48   noelv
* New mode switch code.
* 
*    Rev 1.17   05 Jun 1996 09:01:38   noelv
* Reserve 8 meg of address space for the frame buffer.
* 
*    Rev 1.16   13 May 1996 14:52:34   bennyn
* Added 5464 support
* 
*    Rev 1.15   10 Apr 1996 17:58:42   bennyn
* 
* Conditional turn on HD_BRST_EN
* 
*    Rev 1.14   26 Mar 1996 16:46:14   noelv
* 
* Test pointer in CLPatchModeTable befor using it.
* 
*    Rev 1.13   12 Mar 1996 16:11:46   noelv
* 
* Removed support for AC chip.
* 
*    Rev 1.12   02 Mar 1996 12:30:02   noelv
* Miniport now patches the ModeTable with information read from the BIOS
* 
*    Rev 1.11   23 Jan 1996 14:08:38   bennyn
* Modified for COMPAQ
* 
*    Rev 1.10   20 Nov 1995 13:43:54   noelv
* Updated registry with adapter string and DAC type.
* 
*    Rev 1.9   16 Nov 1995 13:27:04   bennyn
* 
* Fixed not recognize AC parts & Added handling of IOCTL_CL_BIOS.
* 
*    Rev 1.8   26 Oct 1995 10:14:06   NOELV
* Added version information.
* 
*    Rev 1.7   27 Sep 1995 11:03:00   bennyn
* Fixed setting TRUE color modes
* 
*    Rev 1.6   22 Sep 1995 10:25:00   bennyn
* 
*    Rev 1.5   19 Sep 1995 08:27:44   bennyn
* Fixed register space addr mask problem
* 
*    Rev 1.4   24 Aug 1995 08:13:22   bennyn
* Set the CONTROL, LNCNTL & TILE_CTRL registers, this is corresponding to the
* 
*    Rev 1.3   22 Aug 1995 10:16:58   bennyn
* Inital version for real HW
* 
*    Rev 1.2   21 Aug 1995 15:30:04   bennyn
* 
*    Rev 1.1   17 Aug 1995 08:17:56   BENNYN
* 
*    Rev 1.0   24 Jul 1995 13:22:38   NOELV
* Initial revision.
*
****************************************************************************
****************************************************************************/


/*----------------------------- INCLUDES ----------------------------------*/
#include "cirrus.h"
#include "modemon.h"
#include "version.h"
#include "SWAT.h"

/*----------------------------- DEFINES -----------------------------------*/
//#define  DBGBRK
#define PCIACCESS1
#define NO_BUS_MASTER 1
#define DISPLVL      2

#ifdef  DBGBRK
#define NTAPI __stdcall
    VOID NTAPI DbgBreakPoint(VOID);
#endif

#define VOLATILE volatile

#define QUERY_MONITOR_ID            0x22446688
#define QUERY_NONDDC_MONITOR_ID     0x11223344

#define VESA_POWER_FUNCTION 0x4f10
#define VESA_POWER_ON       0x0000
#define VESA_POWER_STANDBY  0x0100
#define VESA_POWER_SUSPEND  0x0200
#define VESA_POWER_OFF      0x0400
#define VESA_GET_POWER_FUNC 0x0000
#define VESA_SET_POWER_FUNC 0x0001
#define VESA_STATUS_SUCCESS 0x004f


// The 5465 (to at least AC) has a problem when PCI configuration space
// is accessible in memory space.  On 16-bit writes, a 32-bit write is
// actually performed, so the next register has garbage written to it.
// We get around this problem by clearing bit 0 of the Vendor Specific
// Control register in PCI configuration space.  When this bit is set
// to 0, PCI configuration registers are not available through memory
// mapped I/O.  Since some functions require access to PCI registers,
// and only the miniport can access the kernel function to reenable it,
// the display driver must post a message to the miniport to enable this
// bit when needed.
//
#define VS_CONTROL_HACK 1

/*--------------------- STATIC FUNCTION PROTOTYPES ------------------------*/

/*--------------------------- ENUMERATIONS --------------------------------*/

/*----------------------------- TYPEDEFS ----------------------------------*/
typedef struct {
  USHORT  VendorId;     // Vender Id
  USHORT  DeviceId;     // Device Id
  USHORT  HwRev;        // HW rev
} BADCHIPSET;

/*-------------------------- STATIC VARIABLES -----------------------------*/
//
// VGA Access Ranges definitions
//
VIDEO_ACCESS_RANGE CLAccessRanges[NUM_VGA_ACCESS_RANGES] = {
//         RangeStart        RangeLength
//         |                 |         RangeInIoSpace
//         |                 |         |  RangeVisible
//   +-----+-----+           |         |  |  RangeShareable
//   v           v           v         v  v  v
  {0x000003B0, 0x00000000, 0x0000000c, 1, 1, 1}, // First chunk of vga ports
  {0x000003C0, 0x00000000, 0x00000020, 1, 1, 1}, // Remainder of vga ports
  {0x000A0000, 0x00000000, 0x00020000, 0, 1, 1}, // VGA memory

};

#define NUMBADCHIPSET  3
BADCHIPSET BadChipSet[NUMBADCHIPSET] =
{
  {0x0E11, 0x0001, 0x0003},
  {0x0E11, 0x1000, 0x0001},
  {0x8086, 0x1237, 0x0000},
};

unsigned long resetmode = 0xFFFFFFFF;

//
// Device ID supported by this miniport
//
USHORT  DeviceId[] = 
{
    // Supported chips.
    CL_GD5462,
    CL_GD5464,
    CL_GD5464_BD,
    CL_GD5465,

    // For forward compatiblty...
    CL_GD546x_D7,
    CL_GD546x_D8,
    CL_GD546x_D9,
    CL_GD546x_DA,
    CL_GD546x_DB,
    CL_GD546x_DC,
    CL_GD546x_DD,
    CL_GD546x_DE,
    CL_GD546x_DF,

    // Terminator
    0
};

#define ALWAYS_ON_VS_CLK_CTL    0x0000C0A0  // VW_CLK, RAMDAC_CLK

static DWORD LgPM_vs_clk_table[] = 
{
   0x00000001,          // MOD_2D
   0x00000002,          // MOD_STRETCH
   0x00000004,          // MOD_3D
   0x00000008,          // MOD_EXTMODE
   0x00000010,          // MOD_VGA
   0x00000000,          // MOD_RAMDAC
   0x00000040,          // MOD_VPORT
   0x00000000,          // MOD_VW
   0x00000100,          // MOD_TVOUT
   0x00000000,          // Reserved9
   0x00000000,          // Reserved10
   0x00000000,          // Reserved11
   0x00000000,          // Reserved12
   0x00000000,          // Reserved13
   0x00004000,          // SYBCLK_OTHER_EN
   0x00008000,          // DISP_OTHER_EN
   0x00000000,          // Reserved16
   0x00000000,          // Reserved17
   0x00000000,          // Reserved18
   0x00000000,          // Reserved19
   0x00000000,          // Reserved20
   0x00000000,          // Reserved21
   0x00000000,          // Reserved22
   0x00000000,          // Reserved23
   0x00000000,          // Reserved24
   0x00000000,          // Reserved25
   0x00000000,          // Reserved26
   0x00000000,          // Reserved27
   0x00000000,          // Reserved28
   0x00000000,          // Reserved29
   0x00000000,          // Reserved30
   0x00000000           // Reserved31
};

 
//
// Memory interleave is based on how much memory we have.
// For BIOS modes we don't muck with memory interleave.
// But if MODE.INI is used to set the mode, we need to set the 
// memory interleave ourselves.
//
#define ONE_WAY (0x00 << 6)
#define TWO_WAY (0x01 << 6)
#define FOUR_WAY (0x02 << 6)
unsigned char bLeave[] = {
	TWO_WAY,
	TWO_WAY,
	TWO_WAY,
	FOUR_WAY,
	TWO_WAY,
	TWO_WAY,
	TWO_WAY,
	FOUR_WAY,
	};


#if LOG_FILE
    extern HANDLE LogFileHandle;          // Handle for log file
#endif


/*-------------------------- EXTERNAL FUNCTIONS --------------------------*/
extern ULONG RtlWriteRegistryValue(ULONG RelativeTo, PWSTR Path,
								   PWSTR ValueName, ULONG ValueType,
								   PVOID ValueData, ULONG ValueLength);
extern DWORD ConfigureLagunaMemory(DWORD dwPhysFB, DWORD dwFBSize);
extern void  ReleaseMTRRs(DWORD dwFBMTRRReg);

/*-------------------------- GLOBAL FUNCTIONS -----------------------------*/
VOID HalDisplayString(PUCHAR);

#if 0
VP_STATUS CLGetLowResValue(PHW_DEVICE_EXTENSION HwDeviceExtension,
		PVOID Context, PWSTR ValueName, PVOID ValueData, ULONG ValueLength);
#endif

#if defined(ALLOC_PRAGMA)
 #pragma alloc_text(PAGE,DriverEntry)
 #pragma alloc_text(PAGE,CLFindAdapter)
 #pragma alloc_text(PAGE,CLInitialize)
 #pragma alloc_text(PAGE,CLStartIO)
 #pragma alloc_text(PAGE,ReadClockLine)
 #pragma alloc_text(PAGE,WriteClockLine)
 #pragma alloc_text(PAGE,WriteDataLine)
 #pragma alloc_text(PAGE,ReadDataLine)
 #pragma alloc_text(PAGE,WaitVSync)
 #pragma alloc_text(PAGE,VS_Control_Hack)
 #pragma alloc_text(PAGE,Output_To_VS_CLK_CONTROL)
 #pragma alloc_text(PAGE,PMNT_Init)
 #pragma alloc_text(PAGE,PMNT_SetACPIState)
 #pragma alloc_text(PAGE,PMNT_GetACPIState)
 #pragma alloc_text(PAGE,PMNT_SetHwModuleState)
 #pragma alloc_text(PAGE,PMNT_GetHwModuleState)
 #pragma alloc_text(PAGE,PMNT_Close)
 #pragma alloc_text(PAGE,CLSetColorLookup)
 #pragma alloc_text(PAGE,CLFindVmemSize)
 #pragma alloc_text(PAGE,CLWriteRegistryInfo)
 #pragma alloc_text(PAGE,CLValidateModes)
 #pragma alloc_text(PAGE,CLCopyModeInfo)
#if 0 // Stress test
 #pragma alloc_text(PAGE,CLSetMode)
 #pragma alloc_text(PAGE,CLSetMonitorType)
 #pragma alloc_text(PAGE,CLEnableTiling)
#endif
 #pragma alloc_text(PAGE,CLPowerManagement)
 #pragma alloc_text(PAGE,CLPatchModeTable)
 #pragma alloc_text(PAGE,CLEnablePciBurst)
 #pragma alloc_text(PAGE,CLFindLagunaOnPciBus)
 #pragma alloc_text(PAGE,ClAllocateCommonBuffer)
#if 0
 #pragma alloc_text(PAGE,CLGetLowResValue)
#endif
 #if _WIN32_WINNT >= 0x0500
  #pragma alloc_text(PAGE,CLGetChildDescriptor)
  #pragma alloc_text(PAGE,CLGetPowerState)
  #pragma alloc_text(PAGE,CLSetPowerState)
  #pragma alloc_text(PAGE,GetDDCInformation)
 #endif
#endif


/****************************************************************************
* FUNCTION NAME: DriverEntry()
*
* DESCRIPTION:
*   Installable driver initialization entry point.
*   This entry point is called directly by the I/O system.
*
* REVISION HISTORY:
*   5/30/95     Benny Ng      Initial version
****************************************************************************/
ULONG  DriverEntry (PVOID Context1,
                    PVOID Context2)
{
    VIDEO_HW_INITIALIZATION_DATA hwInitData;
    ULONG status;
    ULONG status1;

    PAGED_CODE();

    VideoDebugPrint((DISPLVL, "Miniport - CL546x DriverEntry\n"));


    //
    // Zero out structure.
    //
    VideoPortZeroMemory(&hwInitData, sizeof(VIDEO_HW_INITIALIZATION_DATA));

    //
    // Specify sizes of structure and extension.
    //
    hwInitData.HwInitDataSize = sizeof(VIDEO_HW_INITIALIZATION_DATA);

    //
    // Set entry points.
    //
    hwInitData.HwFindAdapter = CLFindAdapter;
    hwInitData.HwInitialize = CLInitialize;
    hwInitData.HwInterrupt = NULL;
    hwInitData.HwStartIO = CLStartIO;
#if 1 // PDR#11350
    hwInitData.HwResetHw = CLResetHw;
#endif

#if _WIN32_WINNT >= 0x0500
	hwInitData.HwGetVideoChildDescriptor = CLGetChildDescriptor;
	hwInitData.HwGetPowerState = CLGetPowerState;
	hwInitData.HwSetPowerState = CLSetPowerState;
#endif

    //
    // Determine the size we require for the device extension.
    //
    hwInitData.HwDeviceExtensionSize = sizeof(HW_DEVICE_EXTENSION);

    //
    // Always start with parameters for device0 in this case.
    //
    // This device only supports PCI bus types.
    //
    hwInitData.AdapterInterfaceType = PCIBus;
    status = VideoPortInitialize(Context1,
                                 Context2,
                                 &hwInitData,
                                 NULL);

    return status;

} // end DriverEntry()


#if _WIN32_WINNT >= 0x0500

#define QUERY_ACPI_MONITOR_ID       0x0100
#define QUERY_ACPI_PANEL_ID         0x0110
#define QUERY_ACPI_TV_ID            0x0200

/*******************************************************************************
*	Enumerate all devices controlled by the Laguna graphics chip. This includes
*	DDC monitors attached to the board, as well as other devices which may be
*	connected to the I2C bus.
*/
ULONG CLGetChildDescriptor(
	PVOID HwDeviceExtension,	  // Pointer to our hardware device context
								  // structure.
	PVIDEO_CHILD_ENUM_INFO ChildEnumInfo, // Information about the device that
	                                      // should be enumerated 
	PVIDEO_CHILD_TYPE pChildType, // Type of child we are enumerating - monitor,
								  // I2C, ...
	PVOID pChildDescriptor,		  // Identification structure of the device
								  // (EDID, string).
	ULONG* pUId,				  // Private unique 32 bit ID to be passed back to
								  // the miniport.
	PVOID  pUnused      		  // unused
)
/*
*	The return value is TRUE if the child device existed, FALSE if it did not.
*******************************************************************************/
{
	PHW_DEVICE_EXTENSION hwDeviceExtension = HwDeviceExtension;

    switch (ChildEnumInfo->ChildIndex)
    {
    case 0:

        //
        // Case 0 is used to enumerate devices found by the ACPI firmware.
        //
        // For monitor devices enumerated by ACPI, the video port will get
        // the EDID directly from ACPI.
        //

        switch (ChildEnumInfo->ACPIHwId)
        {

        case QUERY_ACPI_MONITOR_ID:

            *pChildType = Monitor;
            *pUId       = ChildEnumInfo->ACPIHwId;

            return ERROR_MORE_DATA;


        case QUERY_ACPI_PANEL_ID:

            *pChildType = Monitor;
            *pUId       = ChildEnumInfo->ACPIHwId;

            return ERROR_MORE_DATA;

        case QUERY_ACPI_TV_ID:

            *pChildType = Monitor;
            *pUId       = ChildEnumInfo->ACPIHwId;

            return ERROR_MORE_DATA;


        default:

            ASSERT(FALSE);
            return ERROR_NO_MORE_DEVICES;
        }

    case 1:
		// Obtain the EDID structure via DDC.
		if (GetDDCInformation(HwDeviceExtension, pChildDescriptor, ChildEnumInfo->ChildDescriptorSize))
		{
			*pChildType = Monitor;
			*pUId = 0x22446688;

			VideoDebugPrint((1, "CLGetChildDescriptor - "
					"successfully read EDID structure\n"));
		}
		else
		{
			// Always return at least a monitor.
			*pChildType = Monitor;
			*pUId = 0x11223344;

			VideoDebugPrint((1, "CLGetChildDescriptor - "
					"DDC not supported\n"));
		}

        return ERROR_MORE_DATA;

    default:

        return ERROR_NO_MORE_DEVICES;
	}
}


/*******************************************************************************
*	Returns the power state information.
*/
VP_STATUS CLGetPowerState(
	PHW_DEVICE_EXTENSION HwDeviceExtension,		 // Pointer to our hardware
												 // device extension structure.
	ULONG HwDeviceId,							 // Private unique 32 bit ID
												 // identifying the device.
	PVIDEO_POWER_MANAGEMENT VideoPowerManagement // Power state information.
)
/*
*	The return value is TRUE if the power state can be set, FALSE otherwise.
*******************************************************************************/
{
	VP_STATUS status;

    //
    // We only support power setting for the monitor.  Make sure the
    // HwDeviceId matches one the the monitors we could report.
    //

    if ((HwDeviceId == QUERY_NONDDC_MONITOR_ID) ||
        (HwDeviceId == QUERY_MONITOR_ID)) {

        VIDEO_X86_BIOS_ARGUMENTS biosArguments;

        //
        // We are querying the power support for the monitor.
        //

        if ((VideoPowerManagement->PowerState == VideoPowerOn) ||
            (VideoPowerManagement->PowerState == VideoPowerHibernate)) {

            return NO_ERROR;
        }

        VideoPortZeroMemory(&biosArguments, sizeof(VIDEO_X86_BIOS_ARGUMENTS));

        biosArguments.Eax = VESA_POWER_FUNCTION;
        biosArguments.Ebx = VESA_GET_POWER_FUNC;

        status = VideoPortInt10(HwDeviceExtension, &biosArguments);

        if ( (status == NO_ERROR ) && 
             ( (biosArguments.Eax & 0xffff) == VESA_STATUS_SUCCESS)) {

            switch (VideoPowerManagement->PowerState) {

            case VideoPowerStandBy:
                return (biosArguments.Ebx & VESA_POWER_STANDBY) ?
                       NO_ERROR : ERROR_INVALID_FUNCTION;

            case VideoPowerSuspend:
                return (biosArguments.Ebx & VESA_POWER_SUSPEND) ?
                       NO_ERROR : ERROR_INVALID_FUNCTION;

            case VideoPowerOff:
                return (biosArguments.Ebx & VESA_POWER_OFF) ?
                       NO_ERROR : ERROR_INVALID_FUNCTION;

            default:

                break;
            }
        }

        VideoDebugPrint((1, "This device does not support Power Management.\n"));
        return ERROR_INVALID_FUNCTION;


    } else if (HwDeviceId == DISPLAY_ADAPTER_HW_ID) {

        //
        // We are querying power support for the graphics card.
        //

        switch (VideoPowerManagement->PowerState) {

            case VideoPowerOn:
            case VideoPowerHibernate:
            case VideoPowerStandBy:

                return NO_ERROR;

            case VideoPowerOff:
            case VideoPowerSuspend:

                //
                // Indicate that we can't do VideoPowerOff, because
                // we have no way of coming back when power is re-applied
                // to the card.
                //

                return ERROR_INVALID_FUNCTION;

            default:

                ASSERT(FALSE);
                return ERROR_INVALID_FUNCTION;
        }

    } else {

        VideoDebugPrint((1, "Unknown HwDeviceId"));
        ASSERT(FALSE);
        return ERROR_INVALID_PARAMETER;
    }
}


/*******************************************************************************
*	Set the power state for a given device.
*/
VP_STATUS CLSetPowerState(
	PHW_DEVICE_EXTENSION HwDeviceExtension,		 // Pointer to our hardware
												 // device extension structure.
	ULONG HwDeviceId,							 // Private unique 32 bit ID
												 // identifying the device.
	PVIDEO_POWER_MANAGEMENT VideoPowerManagement // Power state information.
)
/*
*	The return value is TRUE if the power state can be set, FALSE otherwise.
*******************************************************************************/
{
	VP_STATUS status;

    //
    // Make sure we recognize the device.
    //

    if ((HwDeviceId == QUERY_NONDDC_MONITOR_ID) ||
        (HwDeviceId == QUERY_MONITOR_ID)) {

        VIDEO_X86_BIOS_ARGUMENTS biosArguments;

        VideoPortZeroMemory(&biosArguments, sizeof(VIDEO_X86_BIOS_ARGUMENTS));

        biosArguments.Eax = VESA_POWER_FUNCTION;
        biosArguments.Ebx = VESA_SET_POWER_FUNC;

        switch (VideoPowerManagement->PowerState) {
        case VideoPowerOn:
        case VideoPowerHibernate:
            biosArguments.Ebx |= VESA_POWER_ON;
            break;

        case VideoPowerStandBy:
            biosArguments.Ebx |= VESA_POWER_STANDBY;
            break;

        case VideoPowerSuspend:
            biosArguments.Ebx |= VESA_POWER_SUSPEND;
            break;

        case VideoPowerOff:
            biosArguments.Ebx |= VESA_POWER_OFF;
            break;

        default:
            VideoDebugPrint((1, "Unknown power state.\n"));
            ASSERT(FALSE);
            return ERROR_INVALID_PARAMETER;
        }

        status = VideoPortInt10(HwDeviceExtension, &biosArguments);

        if ( (status == NO_ERROR ) && 
             ((biosArguments.Eax & 0xffff) == VESA_STATUS_SUCCESS)) {

            HwDeviceExtension->MonitorEnabled =
                ((VideoPowerManagement->PowerState == VideoPowerOn) ||
                (VideoPowerManagement->PowerState == VideoPowerHibernate));

            return NO_ERROR;
        } 
        else {

            VideoDebugPrint((1, "CLSetPowerState: Int10 failed \n"));
            return ERROR_INVALID_PARAMETER;
        }

    } else if (HwDeviceId == DISPLAY_ADAPTER_HW_ID) {

        switch (VideoPowerManagement->PowerState) {

            case VideoPowerOn:
            case VideoPowerStandBy:
            case VideoPowerSuspend:
            case VideoPowerOff:
            case VideoPowerHibernate:

                return NO_ERROR;

            default:

                ASSERT(FALSE);
                return ERROR_INVALID_PARAMETER;
        }

    } else {

        VideoDebugPrint((1, "Unknown HwDeviceId"));
        ASSERT(FALSE);
        return ERROR_INVALID_PARAMETER;
    }
}
#endif


/****************************************************************************
* FUNCTION NAME: CLFindAdapter()
*
* DESCRIPTION:
*   This routine is called to determine if the adapter for this driver
*   is present in the system.
*   If it is present, the function fills out some information describing
*   the adapter.
*
* REVISION HISTORY:
*   5/30/95     Benny Ng      Initial version
****************************************************************************/
VP_STATUS  CLFindAdapter (
    PVOID HwDeviceExtension,            // Our global data
    PVOID HwContext,                    // Not used.
    PWSTR ArgumentString,               // Not used.
    PVIDEO_PORT_CONFIG_INFO ConfigInfo, // Pass info about card back to NT
    PUCHAR Again)                       // We always say 'no'
{
    PHW_DEVICE_EXTENSION hwDeviceExtension = HwDeviceExtension;

    PVIDEO_ACCESS_RANGE     pAccessRanges;
    VIDEO_ACCESS_RANGE      AccessRanges[TOTAL_ACCESS_RANGES];
    PVOID     MappedAddress[TOTAL_ACCESS_RANGES];

    ULONG     ReleaseCnt=0, start_range, skip_ranges;
    VP_STATUS status = ERROR_DEV_NOT_EXIST;
    ULONG     i;
    ULONG     ulFirstAccessRange;
    unsigned long SystemIoBusNumber;

    PAGED_CODE();

    VideoDebugPrint((DISPLVL, 
        "Miniport - CLFindAdapter.  AdapterInterfaceType is %d.\n", 
        ConfigInfo->AdapterInterfaceType));
    VideoDebugPrint((DISPLVL, 
        "Miniport - CLFindAdapter.  SystemIoBusNumber is %d.\n", 
        ConfigInfo->SystemIoBusNumber));
    SystemIoBusNumber = ConfigInfo->SystemIoBusNumber;

    #ifdef  DBGBRK
        DbgBreakPoint();
    #endif


    //
    // Make sure the size of the structure is at least as large as what we
    // are expecting (check version of the config info structure).
    //
    if (ConfigInfo->Length < sizeof(VIDEO_PORT_CONFIG_INFO))
    {
       VideoDebugPrint((DISPLVL, "Miniport - CLFindAdapter parameter wrong size.\n"));
       return (ERROR_INVALID_PARAMETER);
    }

    //
    // Detect a PCI card.  We don't do ISA bus.  We don't do VL bus.
    //
    // After detecting the chip, we fill in the register and frame buffer
    // access ranges with data from PCI registers.
    // The location and size of the VGA access ranges is constant,
    // but the location of our registers and frame buffer depend on where
    // the PCI BIOS decided to put them.
    //
    pAccessRanges = &AccessRanges[FIRST_MM_ACCESS_RANGE]; 
    if (ConfigInfo->AdapterInterfaceType == PCIBus)
        status = CLFindLagunaOnPciBus(hwDeviceExtension, pAccessRanges);


    //
    // If we didn't find our chip, then return failure.
    //
    if (status != NO_ERROR)
    {
        VideoDebugPrint((DISPLVL, 
            "Miniport - CLFindLagunaOnPciBus did not find a Laguna chip.\n"));
        *Again = 0;
        return status;
    }

    // 
    // The maximum possible frame buffer size is 1/4 of frame buffer 
    // address space decoded by the chip.  This is because the chip 
    // replicates the frame buffer address space 4 times.	
    //
    AccessRanges[MM_FRAME_BUFFER_ACCESS_RANGE].RangeLength /= 4;

    //
    // Hey, hey, hey.  We found a chip.
    //
    VideoDebugPrint((DISPLVL, "Miniport - CLFindLagunaOnPciBus found a CL546x.\n"));


//
// We will start by see if if we can get the VGA resources.
//

    // assume we can get the VGA resources
    hwDeviceExtension->Dont_Do_VGA = 0;
    ulFirstAccessRange = FIRST_VGA_ACCESS_RANGE;

    // Copy the VGA access ranges into our AccessRanges structure.
    VideoPortMoveMemory(AccessRanges,
                        CLAccessRanges,
                        sizeof(VIDEO_ACCESS_RANGE) * NUM_VGA_ACCESS_RANGES);

    // Check to see if there is a VGA I/O hardware resource conflict.
    VideoDebugPrint((DISPLVL, "Miniport - Verifying the VGA access ranges.\n"));
    status = VideoPortVerifyAccessRanges(hwDeviceExtension,
                                         NUM_VGA_ACCESS_RANGES,
                                         AccessRanges);
    VideoDebugPrint ((DISPLVL, 
       "Miniport - VGA access ranges verification was %s. Status was %d.\n",
       ((status == NO_ERROR) ? "successful" : "not successful"), status));

    if (status != NO_ERROR)
    {

        // We didn't get the VGA space.  We may be a secondary adapter so
        // continue but hands off VGA resources.
        hwDeviceExtension->Dont_Do_VGA = 1;

        MappedAddress[0] =
        MappedAddress[1] =
        MappedAddress[2] = NULL;

        ulFirstAccessRange = FIRST_MM_ACCESS_RANGE; // skip VGA resources
    }

//
// Now verify the Laguna register and frame buffer ranges.
// (include VGA ranges if the are available to us)
//

    status = VideoPortVerifyAccessRanges(hwDeviceExtension,
                                        (TOTAL_ACCESS_RANGES-ulFirstAccessRange),
                                        &AccessRanges[ulFirstAccessRange]);


    if (status != NO_ERROR)
        return status;      // !!!!!!! CONFLICT !!!!!!!

    // Now map the access ranges.
    VideoDebugPrint ((DISPLVL, "Miniport - Mapping access ranges.\n"));

    for (i = ulFirstAccessRange; i < TOTAL_ACCESS_RANGES; i++)
    {
        pAccessRanges = &AccessRanges[i];
        VideoDebugPrint((DISPLVL, 
            "Miniport - Mapping range. Start=0x%08X:0x%08X Length=%d.\n",
            pAccessRanges->RangeStart.HighPart, 
            pAccessRanges->RangeStart.LowPart,
            pAccessRanges->RangeLength ));

        if ((MappedAddress[i] = VideoPortGetDeviceBase(hwDeviceExtension,
                                pAccessRanges->RangeStart,
                                pAccessRanges->RangeLength,
                                pAccessRanges->RangeInIoSpace)) == NULL)
        {
            VideoDebugPrint((DISPLVL, "Miniport - Mapping failed\n"));

            VideoDebugPrint ((DISPLVL, 
                "Miniport - Unmapping access ranges.\n"));

            // Unmap the previously mapped addresses
            while (i-- > ulFirstAccessRange)
            {
                VideoPortFreeDeviceBase(hwDeviceExtension, &MappedAddress[i]);
            }   

            return ERROR_DEV_NOT_EXIST;
        }
        else
            VideoDebugPrint((DISPLVL,"Miniport - Mapping successful.\n"));
    } // end for


    // Save the location of the VGA registers.
    hwDeviceExtension->IOAddress = MappedAddress[0];

    //
    // Initialize variables in hardware extension 
    //
    hwDeviceExtension->CurrentModeNum = (ULONG) -1;
    hwDeviceExtension->CurrentMode = NULL;
    hwDeviceExtension->PowerState = VideoPowerOn;
    hwDeviceExtension->SystemIoBusNumber=SystemIoBusNumber;

    //
    // Save the VGA mapped address.
    //
    // hwDeviceExtension->VLIOAddress = MappedAddress[1];

    //
    // Save the physical register address information
    //
    pAccessRanges = &AccessRanges[MM_REGISTER_ACCESS_RANGE];
    hwDeviceExtension->PhysicalRegisterAddress = pAccessRanges->RangeStart;
    hwDeviceExtension->PhysicalRegisterLength = pAccessRanges->RangeLength;
    hwDeviceExtension->PhysicalFrameInIoSpace = pAccessRanges->RangeInIoSpace;

    //
    // Save the virtual register address information
    //
    hwDeviceExtension->RegisterAddress = MappedAddress[MM_REGISTER_ACCESS_RANGE];
    hwDeviceExtension->RegisterLength  = pAccessRanges->RangeLength;

    //
    // Get the size of the video memory.
    //
    if ((hwDeviceExtension->AdapterMemorySize = 
                CLFindVmemSize(hwDeviceExtension)) == 0)
    {
        VideoDebugPrint((DISPLVL, "Miniport - No VMEM installed\n"));

        // Unmap our access ranges.
        for (i=0; i < ReleaseCnt; i++)
            VideoPortFreeDeviceBase(hwDeviceExtension, &MappedAddress[i]);

        // Erase the claim on the hardware resource
        VideoPortVerifyAccessRanges(hwDeviceExtension,
                                 0,
                                 AccessRanges);

        return ERROR_DEV_NOT_EXIST;
    }
     
    //
    // Save the physical frame buffer address information
    //
    pAccessRanges = &AccessRanges[MM_FRAME_BUFFER_ACCESS_RANGE];
    hwDeviceExtension->PhysicalFrameAddress = pAccessRanges->RangeStart;
    hwDeviceExtension->PhysicalFrameLength = pAccessRanges->RangeLength;
    hwDeviceExtension->PhysicalRegisterInIoSpace = 
                                             pAccessRanges->RangeInIoSpace;

    //
    // Save the virtual frame buffer address information.
    //
    hwDeviceExtension->FrameAddress = MappedAddress[MM_FRAME_BUFFER_ACCESS_RANGE];
    hwDeviceExtension->FrameLength  = hwDeviceExtension->AdapterMemorySize;

    VideoDebugPrint
    ((DISPLVL, 
    "Miniport - Physical Reg location= 0x%08X, Physical FB location=0x%08X \n"
    "           Physical Reg size=       %08d, Physical FB size=      %08d \n",
                   hwDeviceExtension->PhysicalRegisterAddress.LowPart,
                   hwDeviceExtension->PhysicalFrameAddress.LowPart,
                   hwDeviceExtension->PhysicalRegisterLength,
                   hwDeviceExtension->PhysicalFrameLength
           ));

    VideoDebugPrint
    ((DISPLVL, 
    "Miniport - Logical Reg address=0x%08X,  Logical FB address=0x%08X \n"
    "           Logical Reg size=     %08d,  Logical FB size=     %08d \n",
                   hwDeviceExtension->RegisterAddress,
                   hwDeviceExtension->FrameAddress,
                   hwDeviceExtension->RegisterLength,
                   hwDeviceExtension->FrameLength
                   ));

    //
    // We have this so that the int10 will also work on the VGA also if we
    // use it in this driver.
    //
    if( ! hwDeviceExtension->Dont_Do_VGA )
    {
        ConfigInfo->VdmPhysicalVideoMemoryAddress.LowPart  = 0x000A0000;
        ConfigInfo->VdmPhysicalVideoMemoryAddress.HighPart = 0x00000000;
        ConfigInfo->VdmPhysicalVideoMemoryLength           = 0x00020000;
    }
    //
    // Clear out the Emulator entries and the state size since this driver
    // does not support them.
    //
    ConfigInfo->NumEmulatorAccessEntries     = 0;
    ConfigInfo->EmulatorAccessEntries        = NULL;
    ConfigInfo->EmulatorAccessEntriesContext = 0;

    //
    // This driver does not do SAVE/RESTORE of hardware state.
    //
    ConfigInfo->HardwareStateSize = 0;

    {
        BOOLEAN HDBrstEN = TRUE;

        //
        // Enable burst mode
        //
        HDBrstEN = CLEnablePciBurst(HwDeviceExtension);

        //
        // We now have a complete hardware description of the hardware.
        // Save the information to the registry so it can be used by
        // configuration programs - such as the display applet
        //
        CLWriteRegistryInfo(HwDeviceExtension, HDBrstEN);
    }

	// Always set AGPDataStreaming flag

    hwDeviceExtension->dwAGPDataStreamingFlag = 1;

    //
    // Here we prune valid modes, based on memory requirements.
    // It would be better if we could make the VESA call to determine
    // the modes that the BIOS supports; however, that requires a buffer
    // and it don't work with NT Int 10 support.
    //
    // We prune modes so that we will not annoy the user by presenting
    // modes in the 'Video Applet' which we know the user can't use.
    //
    CLValidateModes(HwDeviceExtension);
    CLPatchModeTable(HwDeviceExtension);

    //
    // If we're doing DMA, we need a page locked buffer.
    //
    ClAllocateCommonBuffer(HwDeviceExtension);

    //
    // Initial the power manager data
    //
    PMNT_Init(hwDeviceExtension);

	//
	// Get the monitor sync polarity. (now just use default)
	//
	hwDeviceExtension->dwPolarity = 0;

    //
    // Initialize the monitor state to "On".
    //

    hwDeviceExtension->MonitorEnabled = TRUE;

    //
    // Indicate we do not wish to be called over
    //
    *Again = 0;

    //
    // Indicate a successful completion status.
    //
    return NO_ERROR;

} // end CLFindAdapter()


/****************************************************************************
* FUNCTION NAME: CLInitialize()
*
* DESCRIPTION:
*   This routine does one time initialization of the device.
*
* REVISION HISTORY:
*   5/30/95     Benny Ng      Initial version
****************************************************************************/
BOOLEAN  CLInitialize (PVOID HwDeviceExtension)
{
    PHW_DEVICE_EXTENSION hwDeviceExtension = HwDeviceExtension;

    PAGED_CODE();
    VideoDebugPrint((DISPLVL, "Miniport - CLInitialize\n"));

#if i386
	hwDeviceExtension->dwFBMTRRReg = ConfigureLagunaMemory(
			(DWORD) hwDeviceExtension->PhysicalFrameAddress.LowPart,
			(DWORD) hwDeviceExtension->PhysicalFrameLength);
#endif

    return TRUE;

} // end CLInitialize()


#if 1 // PDR#11350
/****************************************************************************
* FUNCTION NAME: CLResetHw()
*
* DESCRIPTION:
*   This routine resets the hardware to mode 3.
****************************************************************************/
BOOLEAN CLResetHw(
	PHW_DEVICE_EXTENSION HwDeviceExtension,
	ULONG Columns,
	ULONG Rows
)
{
	#undef LAGUNA_REGS
	#define LAGUNA_REGS HwDeviceExtension->RegisterAddress

	ULONG i;
	VOLATILE USHORT* pCursorControl = (USHORT*)(LAGUNA_REGS + 0x00E6);

    VideoDebugPrint((DISPLVL, "Miniport - CLResetHw\n"));

	// Disable the hardware cursor.
	*pCursorControl &= ~0x01;

#if VS_CONTROL_HACK
	// Enable PCI configuration registers.
    CLEnablePCIConfigMMIO(HwDeviceExtension);
#endif

	// Set the default text mode.
	if (resetmode != 0xFFFFFFFF)
	{
		VIDEO_MODE VideoMode;

		VideoMode.RequestedMode = resetmode;
		CLSetMode(HwDeviceExtension, &VideoMode);
	}

    return FALSE; // Let the HAL handle the VGA registers.
}
#endif


//**************************************************************************
// Enable or Disable the MMIO access
//
void VS_Control_Hack(PHW_DEVICE_EXTENSION HwDeviceExtension, BOOL Enable)
{
#if VS_CONTROL_HACK
  #undef LAGUNA_REGS
  #define LAGUNA_REGS HwDeviceExtension->RegisterAddress
  VOLATILE DWORD* pVS_CONTROL_reg = (DWORD*)(LAGUNA_REGS + 0x3FC);

  if (Enable)
  {
     CLEnablePCIConfigMMIO(HwDeviceExtension);
  }
  else
  {
     // Clear bit 0 to disable PCI register MMIO access
     *pVS_CONTROL_reg = *pVS_CONTROL_reg & 0xFFFFFFFE;
  }
#endif  // if VS_CONTROL_HACK
}


//**************************************************************************
// Write value to VS_CLOCK_CONTROL register
//
void Output_To_VS_CLK_CONTROL(PHW_DEVICE_EXTENSION HwDeviceExtension, DWORD val)
{
  #undef LAGUNA_REGS
  #define LAGUNA_REGS HwDeviceExtension->RegisterAddress
  VOLATILE DWORD* pVSCLK_CONTROL_reg = (DWORD*)(LAGUNA_REGS + 0x3F4);
  VOLATILE DWORD* pVS_CONTROL_reg = (DWORD*)(LAGUNA_REGS + 0x3FC);

  VS_Control_Hack(HwDeviceExtension, TRUE);

  // Enable VS_CLK_CONTROL write
  *pVS_CONTROL_reg = *pVS_CONTROL_reg | 0x800;

  *pVSCLK_CONTROL_reg = val;

  // Disable VS_CLK_CONTROL write
  *pVS_CONTROL_reg = *pVS_CONTROL_reg & 0xFFFFF7FF;

  VS_Control_Hack(HwDeviceExtension, FALSE);
}


/****************************************************************************
* FUNCTION NAME: PMNT_Init()
*
* DESCRIPTION:   The routine initializes the PM internal variables.
*
* Return:        None
****************************************************************************/
void PMNT_Init(PHW_DEVICE_EXTENSION hwDeviceExtension)
{
  LGPWRMGR_DATA* pdata;
  DWORD  clkdata;
  DWORD  mask;
  int  i;

  #undef LAGUNA_REGS
  #define LAGUNA_REGS hwDeviceExtension->RegisterAddress
  VOLATILE DWORD* pVSCLK_CONTROL_reg = (DWORD*)(LAGUNA_REGS + 0x3F4);

  // Points to the internal structure
  pdata = &(hwDeviceExtension->PMdata);

  pdata->wInitSignature = 0xA55A;
  pdata->VS_clk_ctl_state = 0;

  // Initial VS_CLK_CTL image
  clkdata = *pVSCLK_CONTROL_reg;

  pdata->VS_clk_ctl_state = clkdata & 0xFFFF;
  mask = 1;
  for (i=0; i < TOTAL_MOD; i++)
  {
    if ((clkdata & mask) != 0)
       pdata->Mod_refcnt[i] = 1;
    else
       pdata->Mod_refcnt[i] = 0;

    mask = mask << 1;
  };

  // Set internal ACPI state to D0 state
  pdata->ACPI_state = ACPI_D0;

  return;
}; // PMNT_Init


/****************************************************************************
* FUNCTION NAME: PMNT_SetACPIState()
*
* DESCRIPTION:   This routine sets to the specified ACPI state.
*                
* Input:
*   state - ACPI states (ACPI_D0, ACPI_D1, ACPI_D2, ACPI_D3).
*
****************************************************************************/
VP_STATUS PMNT_SetACPIState (PHW_DEVICE_EXTENSION hwDeviceExtension, ULONG state)
{
  P_LGPWRMGR_DATA pdata;
  DWORD  VS_clk_ctl_val;

  pdata = &(hwDeviceExtension->PMdata);

  // Returns FALSE if signature is invalid or invalid state number
  if ((pdata->wInitSignature != 0xA55A) || (state >= TOTAL_ACPI))
     return ERROR_INVALID_PARAMETER;

  switch (state)
  {
    case ACPI_D0:
    {
      VS_clk_ctl_val = pdata->VS_clk_ctl_state;
      break;
    }; // case ACPI_D0

    case ACPI_D1:
    case ACPI_D2:
    {
      VS_clk_ctl_val = ALWAYS_ON_VS_CLK_CTL;
      break;
    }; // case ACPI_D1 & ACPI_D2

    case ACPI_D3:
    {
      VS_clk_ctl_val = 0;
      break;
    }; // case ACPI_D3
  }; // end switch

  // Output the VS_CLK_CONTROL
  Output_To_VS_CLK_CONTROL(hwDeviceExtension, VS_clk_ctl_val);

  // Update internal ACPI state
  pdata->ACPI_state = state;

  return NO_ERROR;
};  // PMNT_SetACPIState


/****************************************************************************
* FUNCTION NAME: PMNT_GetACPIState()
*
* DESCRIPTION: This API returns the current ACPI state in use  
*                
* Input:
*   state - Pointer to ULONG variable for returning ACPI state
*           (ACPI_D0, ACPI_D1, ACPI_D2, ACPI_D3).
*
****************************************************************************/
VP_STATUS PMNT_GetACPIState (PHW_DEVICE_EXTENSION hwDeviceExtension, ULONG* state)
{
  P_LGPWRMGR_DATA pdata;

  pdata = &(hwDeviceExtension->PMdata);

  // Returns FALSE if signature is invalid
  if (pdata->wInitSignature != 0xA55A)
     return ERROR_INVALID_PARAMETER;

  *state = pdata->ACPI_state;

  return NO_ERROR;
}; // PMNT_GetACPIState


/****************************************************************************
* FUNCTION NAME: PMNT_SetHwModuleState()
*
* DESCRIPTION:   This routine validates the request for any conflict between
*                the request and the current chip operation. If it is valid,
*                it will enable or disable the specified HW module by turning
*                on or off appropriate HW clocks and returns NO_ERROR. If it is 
*                invalid or there is a conflict to the current chip operation,
*                it ignores the request and return FAIL.
*
* Input:
*   hwmod - can be one of the following HW modules
*             MOD_2D
*             MOD_3D
*             MOD_TVOUT
*             MOD_VPORT
*             MOD_VGA
*             MOD_EXTMODE
*             MOD_STRETCH
*
*   state - Ether ENABLE or DISABLE.
*
*****************************************************************************/
VP_STATUS PMNT_SetHwModuleState (PHW_DEVICE_EXTENSION hwDeviceExtension,
                                 ULONG hwmod,
                                 ULONG state)
{
  P_LGPWRMGR_DATA pdata;

  pdata = &(hwDeviceExtension->PMdata);

  // Returns FALSE if signature is invalid || invalid module number
  if ((pdata->wInitSignature != 0xA55A) || (hwmod >= TOTAL_MOD))
     return ERROR_INVALID_PARAMETER;

  // Returns FALSE if ACPI state is not in D0 state
  if (pdata->ACPI_state != ACPI_D0)
     return ERROR_INVALID_FUNCTION;

  // Perform the operation on VS_CLK_CONTROL
  if (state == ENABLE)
  {
     // Enable the module
     pdata->VS_clk_ctl_state |= LgPM_vs_clk_table[hwmod];

     if (pdata->Mod_refcnt[hwmod] != 0xFFFFFFFF)
        pdata->Mod_refcnt[hwmod]++;
  }
  else
  {
     // Disable the module
     if (pdata->Mod_refcnt[hwmod] != 0)
     {
        pdata->Mod_refcnt[hwmod]--;

        if (pdata->Mod_refcnt[hwmod] == 0)
           pdata->VS_clk_ctl_state &= (~LgPM_vs_clk_table[hwmod]);
     };  // endif (Mod_refcnt[hwmod] != 0)
  };  // endif (state == ENABLE)

  // Output the VS_CLK_CONTROL
  Output_To_VS_CLK_CONTROL(hwDeviceExtension, pdata->VS_clk_ctl_state);

  return NO_ERROR;
};  // PMNT_SetHwModuleState



/****************************************************************************
* FUNCTION NAME: PMNT_GetHwModuleState()
*
* DESCRIPTION:   This routine returns the current state of a particular
*                hardware module.
* 
* Input:
*   hwmod - can be one of the following HW modules
*             MOD_2D
*             MOD_3D
*             MOD_TVOUT
*             MOD_VPORT
*             MOD_VGA
*             MOD_EXTMODE
*             MOD_STRETCH
*
*   state - Pointer to ULONG variable for returning the HW module state
*           (ENABLE or DISABLE).
*
****************************************************************************/
VP_STATUS PMNT_GetHwModuleState (PHW_DEVICE_EXTENSION hwDeviceExtension,
                                 ULONG hwmod,
                                 ULONG* state)
{
  P_LGPWRMGR_DATA pdata;

  pdata = &(hwDeviceExtension->PMdata);

  *state = DISABLE;

  // Returns FALSE if signature is invalid || invalid module number
  if ((pdata->wInitSignature != 0xA55A) || (hwmod >= TOTAL_MOD))
     return ERROR_INVALID_PARAMETER;

  // Returns FALSE if ACPI state is not in D0 state
  if (pdata->ACPI_state != ACPI_D0)
     return ERROR_INVALID_FUNCTION;

  if (pdata->Mod_refcnt[hwmod] != 0)
     *state = ENABLE;

  return NO_ERROR;
};  // PMNT_GetHwModuleState



/****************************************************************************
* FUNCTION NAME: PMNT_Close()
*
* DESCRIPTION:   This routine closes down the power management module.
*                
****************************************************************************/
void PMNT_Close (PHW_DEVICE_EXTENSION hwDeviceExtension)
{
  P_LGPWRMGR_DATA pdata;

  pdata = &(hwDeviceExtension->PMdata);

  // Returns FALSE if signature is invalid
  if (pdata->wInitSignature != 0xA55A)
     return;

  pdata->wInitSignature = 0x0;
};  // PMNT_Close



/****************************************************************************
* FUNCTION NAME: CLStartIO()
*
* DESCRIPTION:
*   This routine is the main execution routine for the miniport driver. It
*   accepts a Video Request Packet, performs the request, and then returns
*   with the appropriate status.
*
* REVISION HISTORY:
*   5/30/95     Benny Ng      Initial version
****************************************************************************/
BOOLEAN  CLStartIO (PVOID HwDeviceExtension,
                    PVIDEO_REQUEST_PACKET RequestPacket)
{
  VP_STATUS status;
  PHW_DEVICE_EXTENSION hwDeviceExtension = HwDeviceExtension;
  PVIDEO_POWER_MANAGEMENT PMInformation;
  PVIDEO_MODE_INFORMATION modeInformation;
  PVIDEO_MEMORY_INFORMATION memoryInformation;
  VIDEO_MODE videoMode;
  PVIDEO_PUBLIC_ACCESS_RANGES portAccess;
  PVIDEO_MEMORY mappedMemory;
  PMODETABLE pVideoMode;
  ULONG inIoSpace;
  ULONG i;

  PHYSICAL_ADDRESS AdjFBAddr;
  ULONG  AdjFBLength;
  ULONG  ReservedFBLength;

  VOLATILE PUCHAR pOffset2D_reg;
  ULONG  FBOffset;
  ULONG  Temp;

  PVIDEO_SHARE_MEMORY pShareMemory;
  PVIDEO_SHARE_MEMORY_INFORMATION pShareMemoryInformation;
  PHYSICAL_ADDRESS shareAddress;
  PVOID virtualAddress;
  ULONG sharedViewSize;

  PAGED_CODE();

  //
  // If the current power state is VideoPowerOff, fails all
  // IOCTL_VIDEO_XXX requests until the IOCTL_VIDEO_SET_POWER_MANAGEMENT
  // request that resets to a power-on condition
  //
  if ((hwDeviceExtension->PowerState == VideoPowerOff))
  {
     VideoDebugPrint((DISPLVL, "Miniport - PowerOff\n"));

     return FALSE;
  };


  //
  // Switch on the IoContolCode in the RequestPacket. It indicates which
  // function must be performed by the driver.
  //
  switch (RequestPacket->IoControlCode)
  {
  //-----------------------------------------------------

#if 0 // not supported anymore

  //-----------------------------------------------------
  case IOCTL_GET_BIOS_VERSION:
  {
    WORD *pOut = (WORD *) RequestPacket->OutputBuffer;

    if ((RequestPacket->OutputBufferLength <
        (RequestPacket->StatusBlock->Information = sizeof(WORD))))
    {
       status = ERROR_INSUFFICIENT_BUFFER;
       break;
    };

    *pOut = hwDeviceExtension->BIOSVersion;
    status = NO_ERROR;
    break;
  };  // end case IOCTL_GET_BIOS_VERSION

  //-----------------------------------------------------
  case IOCTL_SET_HW_MODULE_POWER_STATE:
  {
    PLGPM_IN_STRUCT   pInLGPM; 
    PLGPM_OUT_STRUCT  pOutLGPM;

    if ((RequestPacket->OutputBufferLength <
         (RequestPacket->StatusBlock->Information =
                          sizeof(PLGPM_OUT_STRUCT))) ||
        (RequestPacket->InputBufferLength < sizeof(LGPM_IN_STRUCT)))
    {
       status = ERROR_INSUFFICIENT_BUFFER;
       break;
    };

    pInLGPM  = (PLGPM_IN_STRUCT)  RequestPacket->InputBuffer;
    pOutLGPM = (PLGPM_OUT_STRUCT) RequestPacket->OutputBuffer;

    status = PMNT_SetHwModuleState (hwDeviceExtension,
                                    pInLGPM->arg1,
                                    pInLGPM->arg2);

    break;
  };  // end case IOCTL_SET_HW_MODULE_POWER_STATE

  //-----------------------------------------------------
  case IOCTL_GET_HW_MODULE_POWER_STATE:
  {
    PLGPM_IN_STRUCT   pInLGPM; 
    PLGPM_OUT_STRUCT  pOutLGPM;

    if ((RequestPacket->OutputBufferLength <
         (RequestPacket->StatusBlock->Information =
                          sizeof(PLGPM_OUT_STRUCT))) ||
        (RequestPacket->InputBufferLength < sizeof(LGPM_IN_STRUCT)))
    {
       status = ERROR_INSUFFICIENT_BUFFER;
       break;
    };

    pInLGPM  = (PLGPM_IN_STRUCT)  RequestPacket->InputBuffer;
    pOutLGPM = (PLGPM_OUT_STRUCT) RequestPacket->OutputBuffer;

    status = PMNT_GetHwModuleState (hwDeviceExtension,
                                    pInLGPM->arg1,
                                    (ULONG*) pInLGPM->arg2);

    break;
  };  // end case IOCTL_GET_HW_MODULE_POWER_STATE

#endif// 0 // not supported anymore

  //-----------------------------------------------------
  case IOCTL_GET_AGPDATASTREAMING:
  {
    DWORD *pOut = (DWORD *) RequestPacket->OutputBuffer;

    if ((RequestPacket->OutputBufferLength <
        (RequestPacket->StatusBlock->Information = sizeof(DWORD))))
    {
       status = ERROR_INSUFFICIENT_BUFFER;
       break;
    };

	*pOut = hwDeviceExtension->dwAGPDataStreamingFlag;

    status = NO_ERROR;
    break;
  };  // end case IOCTL_GET_AGPDATASTREAMING

  //-----------------------------------------------------
  case IOCTL_VIDEO_SHARE_VIDEO_MEMORY:

    VideoDebugPrint((DISPLVL, "Miniport - ShareVideoMemory\n"));

#ifdef  DBGBRK
    DbgBreakPoint();
#endif

    if (
        (RequestPacket->OutputBufferLength 
                 < sizeof(VIDEO_SHARE_MEMORY_INFORMATION)) 
        || (RequestPacket->InputBufferLength  < sizeof(VIDEO_MEMORY)))
    {
       VideoDebugPrint((1, 
                    "Miniport - SHARE_VIDEO_MEM-INSUFFICIENT_BUF\n"));
       status = ERROR_INSUFFICIENT_BUFFER;
       break;
    };

    pShareMemory = RequestPacket->InputBuffer;

#if 0 // extra rectangle at bottom makes this more complex, I'm taking the
      // easy way out and assume that the display driver is asking for
      // a reasonable ammount of space

    if ((pShareMemory->ViewOffset > hwDeviceExtension->AdapterMemorySize) ||
        ((pShareMemory->ViewOffset + pShareMemory->ViewSize) >
              hwDeviceExtension->AdapterMemorySize))
    {
       VideoDebugPrint((1, "Miniport - SHARE_VIDEO_MEM-INVALID_PARAM\n"));
       status = ERROR_INVALID_PARAMETER;
       break;
    };
#endif

    RequestPacket->StatusBlock->Information = 
            sizeof(VIDEO_SHARE_MEMORY_INFORMATION);

    // Beware: the input buffer and the output buffer are the same
    // buffer, and therefore data should not be copied from one to the
    // other
    //
    virtualAddress = pShareMemory->ProcessHandle;
    sharedViewSize = pShareMemory->ViewSize;

    inIoSpace = 0;

    // Enable the USWC on the P6 processor
    #ifdef VIDEO_MEMORY_SPACE_P6CACHE
       if (hwDeviceExtension->ChipID != CL_GD5462)
           inIoSpace |= VIDEO_MEMORY_SPACE_P6CACHE;
    #endif

    // NOTE: we are ignoring ViewOffset
    //
    shareAddress.QuadPart = hwDeviceExtension->PhysicalFrameAddress.QuadPart;

    status = VideoPortMapMemory(hwDeviceExtension,
                                shareAddress,
                                &sharedViewSize,
                                &inIoSpace,
                                &virtualAddress);

    pShareMemoryInformation = RequestPacket->OutputBuffer;

    pShareMemoryInformation->SharedViewOffset = pShareMemory->ViewOffset;
    pShareMemoryInformation->VirtualAddress = virtualAddress;
    pShareMemoryInformation->SharedViewSize = sharedViewSize;

    break;


  //-----------------------------------------------------
  case IOCTL_VIDEO_UNSHARE_VIDEO_MEMORY:

    VideoDebugPrint((DISPLVL, "Miniport - UnshareVideoMemory\n"));

#ifdef  DBGBRK
    DbgBreakPoint();
#endif

    if (RequestPacket->InputBufferLength < sizeof(VIDEO_SHARE_MEMORY))
    {
       status = ERROR_INSUFFICIENT_BUFFER;
       break;
    };

    pShareMemory = RequestPacket->InputBuffer;

    status = VideoPortUnmapMemory(hwDeviceExtension,
                                  pShareMemory->RequestedVirtualAddress,
                                  pShareMemory->ProcessHandle);

    break;


  //-----------------------------------------------------
  case IOCTL_VIDEO_MAP_VIDEO_MEMORY:

    VideoDebugPrint((DISPLVL, "Miniport - MapVideoMemory\n"));
    #ifdef  DBGBRK
        DbgBreakPoint();
    #endif

    if ((RequestPacket->OutputBufferLength <
         (RequestPacket->StatusBlock->Information =
                          sizeof(VIDEO_MEMORY_INFORMATION))) ||
         (RequestPacket->InputBufferLength < sizeof(VIDEO_MEMORY)))
    {
       status = ERROR_INSUFFICIENT_BUFFER;
       break;
    };

    memoryInformation = RequestPacket->OutputBuffer;
    memoryInformation->VideoRamBase = ((PVIDEO_MEMORY)
            (RequestPacket->InputBuffer))->RequestedVirtualAddress;

    //
    // Adjust the FB starting address and size based on OFFSET_2D
    //
    pOffset2D_reg = hwDeviceExtension->RegisterAddress + OFFSET_2D_REG;
    FBOffset = ((ULONG) *pOffset2D_reg) & 0xFF;

    VideoDebugPrint((DISPLVL, "Miniport - OFFSET_2D=%xH\n", FBOffset));

    Temp = hwDeviceExtension->CurrentMode->BytesPerScanLine;
    FBOffset = (FBOffset * 64) * Temp;

    AdjFBAddr = hwDeviceExtension->PhysicalFrameAddress;
    AdjFBAddr.LowPart += FBOffset;

    ReservedFBLength = hwDeviceExtension->PhysicalFrameLength; 

    // v-normmi added room for extra rectangle at bottom left
    if (ReservedFBLength < 0x800000)
    {
       ReservedFBLength += (Temp*4*32); // pitch * 4 max height tiles
    }
    //
    // Do memory mapping
    //
    inIoSpace = 0;

    // Enable the USWC on the P6 processor
    #ifdef VIDEO_MEMORY_SPACE_P6CACHE
       if (hwDeviceExtension->ChipID != CL_GD5462)
           inIoSpace |= VIDEO_MEMORY_SPACE_P6CACHE;
    #endif

    status = VideoPortMapMemory(hwDeviceExtension,
                                AdjFBAddr,
                                &ReservedFBLength,
                                &inIoSpace,
                                &(memoryInformation->VideoRamBase));

    //
    // The frame buffer and virtual memory are equivalent in this
    // case.
    //
    memoryInformation->FrameBufferBase = memoryInformation->VideoRamBase;

    //
    // This is the *real* amount of memory on the board.
    // This gets reported back to the display driver.
    //
    AdjFBLength = hwDeviceExtension->FrameLength - FBOffset;
    memoryInformation->VideoRamLength = AdjFBLength;
    memoryInformation->FrameBufferLength = AdjFBLength;

    VideoDebugPrint((DISPLVL, "Miniport - DD FB virtual spac=%xH\n",
                    memoryInformation->FrameBufferBase));

    break;



  //-----------------------------------------------------
  case IOCTL_VIDEO_UNMAP_VIDEO_MEMORY:

    VideoDebugPrint((DISPLVL, "Miniport - UnMapVideoMemory\n"));

#ifdef  DBGBRK
    DbgBreakPoint();
#endif

    if (RequestPacket->InputBufferLength < sizeof(VIDEO_MEMORY))
    {
       status = ERROR_INSUFFICIENT_BUFFER;
       break;
    };

    status = VideoPortUnmapMemory(hwDeviceExtension,
             ((PVIDEO_MEMORY) (RequestPacket->InputBuffer))->RequestedVirtualAddress,
             0);

    break;


  //-----------------------------------------------------
  case IOCTL_VIDEO_QUERY_PUBLIC_ACCESS_RANGES:

    VideoDebugPrint((DISPLVL, "Miniport - QueryPublicAccessRanges\n"));

#ifdef  DBGBRK
    DbgBreakPoint();
#endif

    if (RequestPacket->OutputBufferLength <
       (RequestPacket->StatusBlock->Information = sizeof(VIDEO_PUBLIC_ACCESS_RANGES)))
    {
       status = ERROR_INSUFFICIENT_BUFFER;
       break;
    };

    portAccess = RequestPacket->OutputBuffer;

    portAccess->VirtualAddress  = (PVOID) NULL;    // Requested VA
    portAccess->InIoSpace       = FALSE;
    portAccess->MappedInIoSpace = portAccess->InIoSpace;

    status = VideoPortMapMemory(hwDeviceExtension,
                                hwDeviceExtension->PhysicalRegisterAddress,
                                &hwDeviceExtension->RegisterLength,
                                &portAccess->MappedInIoSpace,
                                &portAccess->VirtualAddress);

    VideoDebugPrint((DISPLVL, "Miniport - DD Reg virtual spac=%xH\n",
                    portAccess->VirtualAddress));

    break;

 
  //-----------------------------------------------------
  case IOCTL_VIDEO_FREE_PUBLIC_ACCESS_RANGES:

    VideoDebugPrint((DISPLVL, "Miniport - FreePublicAccessRanges\n"));

#ifdef  DBGBRK
    DbgBreakPoint();
#endif

    if (RequestPacket->InputBufferLength < 2 * sizeof(VIDEO_MEMORY))
    {
       status = ERROR_INSUFFICIENT_BUFFER;
       break;
    };

    status = NO_ERROR;

    mappedMemory = RequestPacket->InputBuffer;

    for (i = 0; i < 2; i++)
    {
      if (mappedMemory->RequestedVirtualAddress != NULL)
      {
         status = VideoPortUnmapMemory(hwDeviceExtension,
                                       mappedMemory->RequestedVirtualAddress,
                                       0);
      };

      mappedMemory++;
    }  // end for

    break;

  
  //-----------------------------------------------------
  case IOCTL_VIDEO_QUERY_AVAIL_MODES:

    VideoDebugPrint((DISPLVL, "Miniport - QueryAvailableModes\n"));

#ifdef  DBGBRK
    DbgBreakPoint();
#endif

    if (RequestPacket->OutputBufferLength <
        (RequestPacket->StatusBlock->Information =
         hwDeviceExtension->NumAvailableModes * sizeof(VIDEO_MODE_INFORMATION)))
    {
       status = ERROR_INSUFFICIENT_BUFFER;
       break;
    };

    modeInformation = (PVIDEO_MODE_INFORMATION) RequestPacket->OutputBuffer;

    //
    // For each mode supported by the card, store the mode characteristics
    // in the output buffer.
    //
    for (i = 0; i < TotalVideoModes; i++)
    {
      // Points to the selected mode table slot
      //
      pVideoMode = &ModeTable[i];

      // Check whether the mode is valid
      //
      if (pVideoMode->ValidMode)
      {
         //
         // Copy the selected mode information into the
         // VIDEO_MODE_INFORMATION structure buffer.
         //
         CLCopyModeInfo(HwDeviceExtension, modeInformation, i, pVideoMode);

         //
         // Points to next VIDEO_MODE_INFORMATION structure slot
         //
         modeInformation++;
      };
    } /* end for */

    status = NO_ERROR;

    break;


  //-----------------------------------------------------
  case IOCTL_VIDEO_QUERY_CURRENT_MODE:

    VideoDebugPrint((DISPLVL, "Miniport - QueryCurrentModes\n"));

#ifdef  DBGBRK
    DbgBreakPoint();
#endif

    //
    // Find out the size of the data to be put in the the buffer and return
    // that in the status information (whether or not the information is
    // there). If the buffer passed in is not large enough return an
    // appropriate error code.
    //
    if (RequestPacket->OutputBufferLength <
        (RequestPacket->StatusBlock->Information =
                                       sizeof(VIDEO_MODE_INFORMATION)))
    {
       status = ERROR_INSUFFICIENT_BUFFER;
       break;
    };

    //
    // check if a mode has been set
    //
    if (hwDeviceExtension->CurrentMode == NULL)
    {
       status = ERROR_INVALID_FUNCTION;
       break;
    };

    modeInformation = (PVIDEO_MODE_INFORMATION) RequestPacket->OutputBuffer;

    // Copy the selected mode information into the
    // VIDEO_MODE_INFORMATION structure provided by NT.
    //
    CLCopyModeInfo(hwDeviceExtension,
                   modeInformation,
                   hwDeviceExtension->CurrentModeNum,
                   hwDeviceExtension->CurrentMode);

    status = NO_ERROR;

    break;


  //-----------------------------------------------------
  case IOCTL_VIDEO_QUERY_NUM_AVAIL_MODES:

    VideoDebugPrint((DISPLVL, "Miniport - QueryNumAvailableModes\n"));

#ifdef  DBGBRK
    DbgBreakPoint();
#endif

    //
    // Find out the size of the data to be put in the the buffer and
    // return that in the status information (whether or not the
    // information is there). If the buffer passed in is not large
    // enough return an appropriate error code.
    //
    if (RequestPacket->OutputBufferLength <
        (RequestPacket->StatusBlock->Information = sizeof(VIDEO_NUM_MODES)))
    {
       status = ERROR_INSUFFICIENT_BUFFER;
       break;
    };

    ((PVIDEO_NUM_MODES)RequestPacket->OutputBuffer)->NumModes =
         hwDeviceExtension->NumAvailableModes;

    ((PVIDEO_NUM_MODES)RequestPacket->OutputBuffer)->ModeInformationLength =
        sizeof(VIDEO_MODE_INFORMATION);

    status = NO_ERROR;

    break;

 
  //-----------------------------------------------------
  case IOCTL_VIDEO_SET_COLOR_REGISTERS:

    VideoDebugPrint((DISPLVL, "Miniport - SetColorRegs\n"));

#ifdef  DBGBRK
    DbgBreakPoint();
#endif

    status = CLSetColorLookup(HwDeviceExtension,
                              (PVIDEO_CLUT) RequestPacket->InputBuffer,
                              RequestPacket->InputBufferLength);

    break;


  //-----------------------------------------------------
  case IOCTL_VIDEO_SET_CURRENT_MODE:

    VideoDebugPrint((DISPLVL, "Miniport - SetCurrentMode\n"));

#ifdef  DBGBRK
    DbgBreakPoint();
#endif

    //
    // Check if the size of the data in the input buffer is large enough.
    //
    if (RequestPacket->InputBufferLength < sizeof(VIDEO_MODE))
    {
       status = ERROR_INSUFFICIENT_BUFFER;
       break;
    };

    status = CLSetMode(HwDeviceExtension,
                       (PVIDEO_MODE) RequestPacket->InputBuffer);
    break;


  //-----------------------------------------------------
  case IOCTL_VIDEO_RESET_DEVICE:

    VideoDebugPrint((DISPLVL, "Miniport - ResetDevice\n"));

#if VS_CONTROL_HACK
    CLEnablePCIConfigMMIO(HwDeviceExtension);
#endif

#ifdef  DBGBRK
    DbgBreakPoint();
#endif

    if ( ! hwDeviceExtension->Dont_Do_VGA ) // Only if VGA regs are available.
    {
        // Initialize the DAC to 0 (black).
        //
        // Turn off the screen at the DAC.
        //
        VideoPortWritePortUchar((PUCHAR) 0x3c6, (UCHAR) 0x0);

        for (i = 0; i < 256; i++)
        {
        VideoPortWritePortUchar((PUCHAR) 0x3c8, (UCHAR) i);
        VideoPortWritePortUchar((PUCHAR) 0x3c9, (UCHAR) 0);
        VideoPortWritePortUchar((PUCHAR) 0x3c9, (UCHAR) 0);
        VideoPortWritePortUchar((PUCHAR) 0x3c9, (UCHAR) 0);
        } // end for

        //
        // Turn on the screen at the DAC
        //
        VideoPortWritePortUchar((PUCHAR) 0x3c6, (UCHAR) 0xFF);
    }
    videoMode.RequestedMode = resetmode; // mode.ini
    //videoMode.RequestedMode = DEFAULT_MODE; // BIOS

    status = CLSetMode(HwDeviceExtension, (PVIDEO_MODE) &videoMode);

    break;

#if 0 // not supported anymore
  
  //-----------------------------------------------------
  case IOCTL_VIDEO_GET_POWER_MANAGEMENT:

    VideoDebugPrint((DISPLVL, "Miniport - GetPowerManagement\n"));

#ifdef  DBGBRK
    DbgBreakPoint();
#endif

    //
    // Find out the size of the data to be put in the the buffer and return
    // that in the status information (whether or not the information is
    // there). If the buffer passed in is not large enough return an
    // appropriate error code.
    //
    if (RequestPacket->OutputBufferLength <
        (RequestPacket->StatusBlock->Information =
                                       sizeof(VIDEO_POWER_MANAGEMENT)))
    {
       status = ERROR_INSUFFICIENT_BUFFER;
       break;
    };

    PMInformation = (PVIDEO_POWER_MANAGEMENT) RequestPacket->OutputBuffer;

    status = CLPowerManagement(HwDeviceExtension, PMInformation, FALSE);

    break;


  //-----------------------------------------------------
  case IOCTL_CL_STRING_DISPLAY:

    VideoDebugPrint((DISPLVL, "Miniport - StringDisplay\n"));

    #ifdef  DBGBRK
        DbgBreakPoint();
    #endif

    HalDisplayString((PUCHAR) RequestPacket->InputBuffer);

    status = NO_ERROR;

    break;

#endif// 0 // not supported anymore


    // ----------------------------------------------------------------
    case IOCTL_CL_GET_COMMON_BUFFER:
    {
        //
        // Communicate to the display driver the location and size of the 
        // common DMA buffer.
        //
        // The display driver gives us a pointer to this structure.
        // We fill in the values here.
        //
        // struct {
        //     PUCHAR PhysAddress;
        //     PUCHAR VirtAddress;
        //     ULONG  Length;
        // } *pCommonBufferInfo;

        COMMON_BUFFER_INFO *pCommonBufferInfo;

        VideoDebugPrint((DISPLVL, "Miniport - Get Common Buffer.\n"));


        RequestPacket->StatusBlock->Information = sizeof(COMMON_BUFFER_INFO);
        if (RequestPacket->OutputBufferLength < sizeof(COMMON_BUFFER_INFO))
        {
            VideoDebugPrint((DISPLVL, "Miniport - Buffer size mismatch.\n"));
            status = ERROR_INSUFFICIENT_BUFFER;
            break;
        }

        //
        // Retrieve pointer to CommonBufferInfo struct.
        //
        pCommonBufferInfo = (COMMON_BUFFER_INFO *)(RequestPacket->OutputBuffer);


        // 
        // Fill it in.
        //
        pCommonBufferInfo->PhysAddress = 
                                    hwDeviceExtension->PhysicalCommonBufferAddr;

        pCommonBufferInfo->VirtAddress = 
                                    hwDeviceExtension->VirtualCommonBufferAddr;

        pCommonBufferInfo->Length =  hwDeviceExtension->CommonBufferSize;

        status = NO_ERROR;
    }
    break;

#if VS_CONTROL_HACK
    // ----------------------------------------------------------------
    case IOCTL_VIDEO_ENABLE_PCI_MMIO:
    {
       status = CLEnablePCIConfigMMIO(HwDeviceExtension);
       break;
    }
#endif    // VS_CONTROL_HACK

#if LOG_FILE
    // ----------------------------------------------------------------
    case IOCTL_CL_CREATE_LOG_FILE:
    {
       LogFileHandle = CreateLogFile();
       status = NO_ERROR;
    }
    break;

    // ----------------------------------------------------------------
    case IOCTL_CL_WRITE_LOG_FILE:
    {
       WriteLogFile(LogFileHandle,
                    RequestPacket->InputBuffer,
                    RequestPacket->InputBufferLength);
       status = NO_ERROR;
    }
    break;

    // ----------------------------------------------------------------
    case IOCTL_CL_CLOSE_LOG_FILE:
    {
       CloseLogFile(LogFileHandle);
       status = NO_ERROR;
    }
    break;

#endif

#if 1
    // ----------------------------------------------------------------
    case IOCTL_STALL:
    {
       VideoPortStallExecution(*(PULONG) RequestPacket->InputBuffer);
       status = NO_ERROR;
    }
    break;
#endif

  //-----------------------------------------------------
  // if we get here, an invalid IoControlCode was specified.
  //
  default:
    VideoDebugPrint((DISPLVL, "Miniport - invalid command= %xH\n",
                     RequestPacket->IoControlCode));

    #ifdef  DBGBRK
        DbgBreakPoint();
    #endif

    status = ERROR_INVALID_FUNCTION;
    break;

  } // end switch

  RequestPacket->StatusBlock->Status = status;
  return TRUE;

} // end CLStartIO()


/****************************************************************************
* FUNCTION NAME: CLSetColorLookup()
*
* DESCRIPTION:
*   This routine sets a specified portion of the color lookup table settings.
*
* REVISION HISTORY:
*   5/30/95     Benny Ng      Initial version
****************************************************************************/
VP_STATUS  CLSetColorLookup (PHW_DEVICE_EXTENSION HwDeviceExtension,
                             PVIDEO_CLUT ClutBuffer,
                             ULONG ClutBufferSize)
{
  USHORT i;
  USHORT FirstEntry;

  #undef LAGUNA_REGS
  #define LAGUNA_REGS HwDeviceExtension->RegisterAddress
  VOLATILE BYTE* pPal_Addr_Reg =  (BYTE*)(LAGUNA_REGS + 0xA8);
  VOLATILE BYTE* pPal_Data_Reg =  (BYTE*)(LAGUNA_REGS + 0xAC);

  ULONG cCounter = 0;


  PAGED_CODE();

  //
  // Check if the size of the data in the input buffer is large enough.
  //
  if ((ClutBufferSize < sizeof(VIDEO_CLUT) - sizeof(ULONG)) ||
      (ClutBufferSize < sizeof(VIDEO_CLUT) +
                 (sizeof(ULONG) * (ClutBuffer->NumEntries - 1))))
  {
     return ERROR_INSUFFICIENT_BUFFER;
  };

  //
  // Check to see if the parameters are valid.
  //
  if ((ClutBuffer->NumEntries == 0) ||
      (ClutBuffer->FirstEntry > VIDEO_MAX_COLOR_REGISTER) ||
      (ClutBuffer->FirstEntry + ClutBuffer->NumEntries >
          VIDEO_MAX_COLOR_REGISTER + 1))
  {
     return ERROR_INVALID_PARAMETER;
  };

    //
    //  Set CLUT registers directly on the hardware
    //

    FirstEntry = ClutBuffer->FirstEntry;
    for (i = 0; i < ClutBuffer->NumEntries; i++)
    {
        // Wait for blanking
        if ((HwDeviceExtension->Dont_Do_VGA == FALSE) &&
            (HwDeviceExtension->MonitorEnabled == TRUE)) // Only wait for blanking if VGA regs are available.
        {
#if 1 // PDR#11284
			if (cCounter-- == 0)
			{
				// Wait for end of vertical retrace.
				while (VideoPortReadPortUchar((PUCHAR) 0x3DA) & 0x08) ;

				// Wait for beginning of display disable.
				while(  (VideoPortReadPortUchar((PUCHAR) 0x3DA) & 0x01)) ;
				while(! (VideoPortReadPortUchar((PUCHAR) 0x3DA) & 0x01)) ;

				// Load the counter.
				cCounter = (VideoPortReadPortUchar((PUCHAR) 0x3DA) & 0x08)
						? 256 : 0;
			}
#else
            // Wait for bit-0 becomes 0
            while(1)
            {
              unsigned char stat;

              stat = VideoPortReadPortUchar( (PUCHAR)0x3DA );
              if (!(stat & 1)) // Test bit 0.  If it's a 0
                 break;        // then continue.
            }

            // Wait for bit-0 becomes 1
            while(1)
            {
              unsigned char stat;

              stat = VideoPortReadPortUchar( (PUCHAR)0x3DA );
              if (stat & 1) // Test bit 0.  If it's a 1
                 break;     // then continue.
            }
#endif
        }

        // Write the entry.
        *pPal_Addr_Reg = (UCHAR) (FirstEntry + i);
        *pPal_Data_Reg = (UCHAR) (ClutBuffer->LookupTable[i].RgbArray.Red);
        *pPal_Data_Reg = (UCHAR) (ClutBuffer->LookupTable[i].RgbArray.Green);
        *pPal_Data_Reg = (UCHAR) (ClutBuffer->LookupTable[i].RgbArray.Blue);
    } // end for

  return NO_ERROR;

} // end CLSetColorLookup()



/****************************************************************************
* FUNCTION NAME: CLFindVmemSize()
*
* DESCRIPTION:
*   This routine returns the amount of RAM installed on the card.
*
* REVISION HISTORY:
*   5/30/95     Benny Ng      Initial version
****************************************************************************/
ULONG CLFindVmemSize (PHW_DEVICE_EXTENSION HwDeviceExtension)
{
  UCHAR OrigSRindex;
  ULONG memsize;

  #define LAGUNA_REGS HwDeviceExtension->RegisterAddress

  VOLATILE USHORT* pRIF_reg =          (USHORT*)(LAGUNA_REGS + 0x200);

  PAGED_CODE();


    /*
    1.) If 62 or 64 or 65 AC or below
        Lower 3 bits of RIF is the number of banks -1.  Add one and multiply
        by 1MB

    2.) If 65 AD then some bits in the RIF have changed
         
         Then bits 15:14 have been overloaded <they are now called memory
         type>
          MEM_TYPE == 00b --- use step 1
          MEM_TYPE == 01b --- use step 1
          MEM_TYPE == 10b or MEM_TYPE == 11b then
             Lower 3 bits of RIF is the number of banks -1.  Add one and
             multiply by 2MB. 

    */

    memsize = *pRIF_reg;      // get RIF register.
    memsize = memsize & 7;    // keep lowest 3 bits.
    memsize = memsize + 1;    // Add 1 to get number of banks.
    memsize = memsize * 1024 * 1024; // multiply by 1 meg per bank.


    //
    // If the chip is 5465AD or later, adjust the memory size.
    //
    if ((HwDeviceExtension->ChipID > CL_GD5465) || 
       ((HwDeviceExtension->ChipID==CL_GD5465)&&(HwDeviceExtension->ChipRev>1)))
    {
        unsigned long mem_type = *pRIF_reg;
        mem_type = mem_type >> 14;

        if (mem_type >= 2)
            memsize *= 2;  // 2 megabytes per bank.
    }

    VideoDebugPrint((DISPLVL, "Miniport - AdapterMemorySize= 0x%X (%d meg)\n",
        memsize, memsize/(1024*1024)));

    //
    // Return the Number of bytes of RAM installed.
    //
    return (memsize);

} // CirrusFindVmemSize()



/****************************************************************************
* FUNCTION NAME: CLWriteRegistryInfo()
*
* DESCRIPTION:
*   Write hardware information to registry.
*
* REVISION HISTORY:
*   5/30/95     Benny Ng      Initial version
****************************************************************************/
VOID CLWriteRegistryInfo (PHW_DEVICE_EXTENSION hwDeviceExtension,
                          BOOLEAN hdbrsten)
{
  PWSTR pszString;
  ULONG cbString;

  PAGED_CODE();

   VideoDebugPrint((DISPLVL, "Miniport - CLWriteRegestryInfo.\n"));

  // Store Memory Size
  VideoPortSetRegistryParameters(hwDeviceExtension,
                                 L"HardwareInformation.MemorySize",
                                 &hwDeviceExtension->AdapterMemorySize,
                                 sizeof(ULONG));

  // Store chip Type
  if (hwDeviceExtension->ChipID == CL_GD5462)
  {
      pszString = L"Cirrus Logic 5462";
      cbString = sizeof(L"Cirrus Logic 5462");
  }
  else  if (hwDeviceExtension->ChipID == CL_GD5464)
  {
      pszString = L"Cirrus Logic 5464";
      cbString = sizeof(L"Cirrus Logic 5464");
  }
  else  if (hwDeviceExtension->ChipID == CL_GD5465)
  {
      pszString = L"Cirrus Logic 5465";
      cbString = sizeof(L"Cirrus Logic 5465");
  }
  else
  {
      pszString = L"Cirrus Logic 546x";
      cbString = sizeof(L"Cirrus Logic 546x");
  }
  VideoPortSetRegistryParameters(hwDeviceExtension,
                                 L"HardwareInformation.ChipType",
                                 pszString,
                                 cbString);

  // Store DAC Type
  pszString = L"Internal";
  cbString = sizeof(L"Internal");
  VideoPortSetRegistryParameters(hwDeviceExtension,
                                 L"HardwareInformation.DacType",
                                 pszString,
                                 cbString);

  // Store Adapter String
  pszString = L"Cirrus Logic VisualMedia(TM) Accelerator";
  cbString = sizeof(L"Cirrus Logic VisualMedia(TM) Accelerator");
  VideoPortSetRegistryParameters(hwDeviceExtension,
                                 L"HardwareInformation.AdapterString",
                                 pszString,
                                 cbString);

  // HD BRST EN
  if (hdbrsten)
  {
     pszString = L"1";
     cbString = sizeof(L"1");
  }
  else
  {
     pszString = L"0";
     cbString = sizeof(L"0");
  };
  VideoPortSetRegistryParameters(hwDeviceExtension,
                                 L"HardwareInformation.HdBrstEn",
                                 pszString,
                                 cbString);

   VideoDebugPrint((DISPLVL, "Miniport - CLWriteRegestryInfo - Exit.\n"));

} // end CLWriteRegistryInfo()


// Verify the BIOS ID.
// At offset 001e these is a string that says "IBM VGA Compatible".
//
#define CheckBiosID(BiosAddress) \
         (   ( *(BiosAddress+0x1E) == 'I') \
          && ( *(BiosAddress+0x1F) == 'B') \
          && ( *(BiosAddress+0x20) == 'M') \
          && ( *(BiosAddress+0x21) == ' ') \
          && ( *(BiosAddress+0x22) == 'V') \
          && ( *(BiosAddress+0x23) == 'G') \
          && ( *(BiosAddress+0x24) == 'A') \
          && ( *(BiosAddress+0x25) == ' ') \
          && ( *(BiosAddress+0x26) == 'C') \
          && ( *(BiosAddress+0x27) == 'o') \
          && ( *(BiosAddress+0x28) == 'm') \
          && ( *(BiosAddress+0x29) == 'p') \
          && ( *(BiosAddress+0x2A) == 'a') \
          && ( *(BiosAddress+0x2B) == 't') \
          && ( *(BiosAddress+0x2C) == 'i') \
          && ( *(BiosAddress+0x2D) == 'b') \
          && ( *(BiosAddress+0x2E) == 'l') \
          && ( *(BiosAddress+0x2F) == 'e') \
         ) \




/****************************************************************************
* FUNCTION NAME: CLPatchModeTable()
*
* DESCRIPTION:
*   This routine patches the ModeTable with info from the BIOS
*
* MUST be called AFTER ClValidateModes!
*
****************************************************************************/
VOID CLPatchModeTable (PHW_DEVICE_EXTENSION HwDeviceExtension)
{
    unsigned long index;
    unsigned char *BiosAddress; // Pointer to start of BIOS.
    ULONG SupParms;             // Offset of SUpplimental parameter table.
    unsigned char s_TPL;        // Tiles per line.
    unsigned char s_TFIFO;      // Tiled display and threshold fifo.
    USHORT TileWidth;           // Tile width.  128 or 256.
    USHORT FB_Pitch;            // Frame buffer pitch.
    VIDEO_X86_BIOS_ARGUMENTS biosregs;
    PHYSICAL_ADDRESS PhysAddr;  // Our Video Bios

    PAGED_CODE();

    VideoDebugPrint((DISPLVL, "Miniport - PatchModeTable.\n"));

    if (HwDeviceExtension->Dont_Do_VGA)
    {
            VideoDebugPrint((DISPLVL, 
                "Miniport - PatchModeTable - No VGA! - Exit.\n"));
            return;
    }

    //
    // NVH
    // We're going to do something weird here.
    // The scan line lengths in the mode table entries in MTBL.C 
    // may not be right.  So before we copy the mode info into NT, we are 
    // going to query the BIOS and patch the mode table entry if necessary.
    // When we query the BIOS, it will hand us a 16 bit pointer
    // in ES:DI that points to the supplimental parameter table
    // for the mode we are interested in.  From there we will get the 
    // information we need to patch the ModeTable in MTBL.C
    // The tricky part is that VideoPortInt10 does not provide a way
    // for the BIOS to pass back DS.  
    // A chat with the BIOS author revealed that DS will always be 
    // either 0xC000 or 0xE000.  So we convert physical address 0x000C0000 
    // into a 32 bit pointer with VideoPortGetDeviceBase(), and then look
    // at it to see if it points to the BIOS.  If not, we try again with 
    // 0x000E0000
    // Once we locate our BIOS we make BIOS call, and add the returned 
    // value of DI to our BIOS pointer, and viola! we have a usable pointer 
    // to the supplimental parameter table in the BIOS.
    // 
    // Someday I will have to atone for my sins.
    //

    //
    // Here we get a pointer to the Video BIOS so we can examine the
    // mode tables.  The BIOS may be at C0000, or maybe E0000.  We'll try both.
    // At offset 001e these is a string that says "IBM VGA Compatible".
    //
    PhysAddr.HighPart = 0;
    PhysAddr.LowPart = 0xC0000;
    BiosAddress = VideoPortGetDeviceBase(
                    HwDeviceExtension,
                    PhysAddr, // RangeStart
                    0x10000,  // RangeLength,
                    FALSE);  // In memory space.

    if (BiosAddress==NULL || !CheckBiosID(BiosAddress))
    {
        if (BiosAddress!=NULL)
            VideoPortFreeDeviceBase(HwDeviceExtension,BiosAddress);
        // It's at E0000.
        PhysAddr.HighPart = 0;
        PhysAddr.LowPart = 0xE0000;
        BiosAddress = VideoPortGetDeviceBase(
                        HwDeviceExtension,
                        PhysAddr, // RangeStart
                        0x10000,  // RangeLength,
                        FALSE);  // In memory space.

    }

    if (BiosAddress!=NULL && CheckBiosID(BiosAddress))
    {
        // Found it
        VideoDebugPrint((DISPLVL, "PatchModeTable - Found BIOS at 0x%08X.\n",
            BiosAddress));
    }
    else
    {
        // Didn't find it
        if (BiosAddress!=NULL)
            VideoPortFreeDeviceBase(HwDeviceExtension,BiosAddress);
        VideoDebugPrint((DISPLVL,"PatchModeTable - Couldn't find the BIOS.\n"));
        return;
    }

    //
    // Get the BIOS version informaton
    {
       WORD   ver;
       UCHAR  val;
       unsigned char *pBiosAddrTmp;

       ver = 0;
       pBiosAddrTmp = BiosAddress + 0x5f;

       ver = (*pBiosAddrTmp) - 0x30;

       pBiosAddrTmp++;
       pBiosAddrTmp++;

       val = (*pBiosAddrTmp) - 0x30;
       pBiosAddrTmp++;
       val = (val << 4) + ((*pBiosAddrTmp) - 0x30);
       ver = (ver << 8) | val;

       HwDeviceExtension->BIOSVersion = ver;
    }

    //
    // Now read the frame buffer pitch from the BIOS 
    // and patch the ModeTable.
    //

    for (index=0; index < TotalVideoModes; ++index)
    {

    	// If we don't use the BIOS for this mode, don't patch it
	    if (ModeTable[index].SetModeString)
	        continue;

        // If it's not a valid mode, don't patch it.
        // All BIOS hires modes 
        // *should* be marked invalid by now, meaning the rest of this 
        // function does nothing.
        if (ModeTable[index].ValidMode == FALSE)
            continue;

    	// If it's not a hires mode, don't patch it.
	    if (ModeTable[index].BitsPerPixel < 8)
	        continue;

        VideoDebugPrint((DISPLVL, "    Patching Mode %d - %dx%dx%d@%d.\n", 
            index, 
            ModeTable[index].XResol , 
            ModeTable[index].YResol ,
            ModeTable[index].BitsPerPixel ,
            ModeTable[index].Frequency
            ));

        // Ask the BIOS where the supplimental parameter 
        // table for this mode is.
        biosregs.Eax = 0x1200 | ModeTable[index].BIOSModeNum;
        biosregs.Ebx = 0xA0;
        biosregs.Ecx = biosregs.Edx = biosregs.Esi = biosregs.Edi = 0;
        VideoPortInt10(HwDeviceExtension, &biosregs);
        SupParms = biosregs.Edi & 0x0000FFFF;

        if (SupParms == 0x0000FFFF)
            // BIOS call failed.
            continue;


        // Tiles per line is at offset 14 from start of table.
        if (HwDeviceExtension->ChipID <= CL_GD5464_BD)
           s_TPL = *(BiosAddress + SupParms + 14);
        else
           s_TPL = *(BiosAddress + SupParms + 15);

        // If this is a tiled mode, patch the table.
        if (s_TPL != 0)
        {
            // Tiled display register is at offset 15
           if (HwDeviceExtension->ChipID <= CL_GD5464_BD)
              s_TFIFO = *(BiosAddress + SupParms + 15);
           else
              s_TFIFO = *(BiosAddress + SupParms + 16);
            
            // Bit 6 of s_TFIFO is 0 for 128 byte wide tiles and
            // 1 for 256 byte wide tiles.
            TileWidth = (s_TFIFO & 0x40) ? 256 : 128;

            if (HwDeviceExtension->ChipID > CL_GD5464_BD)
               s_TPL = (s_TFIFO & 0x40) ? s_TPL>> 1 : s_TPL;

            // Calculate pitch of the frame buffer.
            FB_Pitch = TileWidth * s_TPL;

            // Patch the ModeTable entry.
            ModeTable[index].BytesPerScanLine = FB_Pitch;
        }
    }

    VideoPortFreeDeviceBase(HwDeviceExtension,BiosAddress);

    VideoDebugPrint((DISPLVL, "Miniport - CLPatchModeTable - Exit.\n"));

} // end CLPatchModeTable()





/****************************************************************************
* FUNCTION NAME: CLValidateModes()
*
* DESCRIPTION:
*   Determines which modes are valid and which are not.
*
* REVISION HISTORY:
*   5/30/95     Benny Ng      Initial version
****************************************************************************/
VOID CLValidateModes (PHW_DEVICE_EXTENSION HwDeviceExtension)
{
  ULONG i,j;
  ULONG ReqireMem;
  PMODETABLE pVMode;


  PAGED_CODE();

    VideoDebugPrint((DISPLVL, "Miniport - CLValidateModes.\n"));

    HwDeviceExtension->NumAvailableModes = 0;
    HwDeviceExtension->NumTotalModes = TotalVideoModes;

    //
    // All the modes in the table start out marked invalid.
    // We will step through the table one mode at a time, examining
    // each mode to see if we will support it.
    // If we decide to support the mode, we will mark it as valid.
    //

    for (i = 0; i < TotalVideoModes; i++)
    {
        pVMode = &ModeTable[i];


        //
        // Is the mode supported by this chip?
        //
        if (pVMode->ChipType & LG_ALL)
        {
            //
            // This mode is valid for all laguna chips.
            // Fall through.
            //
            ;
        }
        else if  ((pVMode->ChipType & LG_5465)  &&
                  (HwDeviceExtension->ChipID == CL_GD5465))
        {
            //
            // We are a 5465 and this mode is valid for 5465 chips.
            // Fall through.
            //
            ;
        }
        else if  ((pVMode->ChipType & LG_5465AD)  &&
                  ((HwDeviceExtension->ChipID == CL_GD5465) && (HwDeviceExtension->ChipRev>1)))
        {
            //
            // We are a 5465AD and this mode is valid for 5465AD chips.
            // Fall through.
            //
            ;
        }
        else if  ((pVMode->ChipType & LG_5464)  &&
                  (HwDeviceExtension->ChipID == CL_GD5464))
        {
            //
            // We are a 5464 and this mode is valid for 5464 chips.
            // Fall through.
            //
            ;
        }
        else if  ((pVMode->ChipType & LG_5462)  &&
                  (HwDeviceExtension->ChipID == CL_GD5462))
        {
            //
            // We are a 5462 and this mode is valid for 5462 chips.
            // Fall through.
            //
            ;
        }
        else 
        {
            //
            // This chip doesn't do this mode.  
            // Leave this mode marked invalid and get the next mode.
            //
            continue;
        }

        //
        // Is this the RESET mode?
        // We have once special mode in the mode table that resets the chip.
        // We don't want to mark it as VALID, since it's not a real mode.
        // But we do want to remember what it is, since we we need it for
        // IOCTL_VIDEO_RESET_DEVICE
        //
        if (pVMode->XResol == 0)
        {
            resetmode = i;
            continue;
        }

        // 
        // Does the video board have enough memory to do this mode?
        // 
        ReqireMem = pVMode->NumOfPlanes * pVMode->BytesPerScanLine * pVMode->YResol;
        if (HwDeviceExtension->AdapterMemorySize < ReqireMem)
        {
            //
            // We don't have enough memory to support this mode.
            // Leave this mode marked invalid and get the next mode.
            // 
            continue;
        };


        //
        // Disable BIOS modes if we don't do VGA
        //
        if (HwDeviceExtension->Dont_Do_VGA)
        {
           if (pVMode->BIOSModeNum != 0)
                continue; // Skip this mode.
        }

        //
        // The NT 4.0 Display Applet automatically trims Direct Draw modes 
        // from the mode list that it shows to the user.
        // It bases it's decision on the number of scan lines in the mode.
        // Modes with less then 480 scan lines don't even show up in the 
        // list of available modes.
        //
        // Unfortunatly we have some Direct Draw modes with 480 scan lines 
        // but fewer than 640 columns (like 320x480).  The display applet 
        // thinks that these are desktop modes, since they have 480 scan lines,
        // but we disagree.  To prevent the user from selecting them, we
        // will remove them entirely.
        //
        if ( (pVMode->YResol == 480) && (pVMode->XResol < 640))
        {
            if ((pVMode->BIOSModeNum == 0) || (pVMode->BIOSModeNum > 0x12))
            {
                // This mode has less than 640 columns.
                // This mode is not a VGA mode.
                continue;  // Skip it.
            }
        }
#if 0
		// Get the LowRes registry value.
		if ((VideoPortGetRegistryParameters(HwDeviceExtension, L"LowRes", FALSE,
				CLGetLowResValue, NULL) != NO_ERROR)
				|| (HwDeviceExtension->fLowRes == FALSE)
			)
		{
			//
			// Disable support for all low resolution modes (less than 640x350).
			//
	        if ( (pVMode->XResol < 640) || (pVMode->YResol < 350) )
    	    {
        	    if ((pVMode->BIOSModeNum == 0) || (pVMode->BIOSModeNum > 0x12))
            	{
	                // This mode is a non-VGA low resolution mode, skip it.
	                continue;
	            }
	        }
		}
#endif
        //
        // Mark the mode as available.
        pVMode->ValidMode = TRUE;
        HwDeviceExtension->NumAvailableModes++;

    } // end for

    
    //
    // There may be duplicate modes in the BIOS and MODE.INI.
    //
    for (i = 0; i < TotalVideoModes; i++)
    {
        pVMode = &ModeTable[i];

        if (pVMode->ValidMode != TRUE)
            continue;

        //
        // We will favor the MODE.INI modes over the BIOS modes.
        // We want the last instance of each mode in the table.
        // So, for each mode M, we scan the rest of the table and 
        // if we find a mode that is equivilant to mode M, we
        // disable this mode.
        //
        for (j=(i+1); j<TotalVideoModes; j++)
        {
            // Does this mode match pVMode?
            if( ModeTable[j].ValidMode    == TRUE                 &&
                ModeTable[j].XResol       == pVMode->XResol       &&
                ModeTable[j].YResol       == pVMode->YResol       &&
                ModeTable[j].BitsPerPixel == pVMode->BitsPerPixel &&
                    /* Match refresh within +/- 1 Hz */
                ModeTable[j].Frequency >= pVMode->Frequency-1     &&
                ModeTable[j].Frequency <= pVMode->Frequency+1      )
            {
                // Yep, it's the same mode.  Disable pVMode.
                pVMode->ValidMode = FALSE;
            }
        } // end inner for loop
    } // end outer for loop

    VideoDebugPrint((DISPLVL, "Miniport - CLValidateModes - Exit.\n"));

} // end CLValidateModes()

#if 0
VP_STATUS CLGetLowResValue(PHW_DEVICE_EXTENSION HwDeviceExtension,
		PVOID Context, PWSTR ValueName, PVOID ValueData, ULONG ValueLength)
{
	PAGED_CODE();

	if (ValueLength > 0 && ValueLength <= sizeof(DWORD))
	{
		HwDeviceExtension->fLowRes = (*(BYTE*) ValueData != 0);
		return(NO_ERROR);
	}

	HwDeviceExtension->fLowRes = FALSE;
	return(ERROR_INVALID_PARAMETER);
}
#endif
/****************************************************************************
* FUNCTION NAME: CopyModeInfo()
*
* DESCRIPTION:
*   This routine copy the selected mode informations from mode table
*   into the VIDEO_MODE_INFORMATION structure provided by NT.
*
* REVISION HISTORY:
*   5/30/95     Benny Ng      Initial version
****************************************************************************/
VOID CLCopyModeInfo (PHW_DEVICE_EXTENSION HwDeviceExtension,
                     PVIDEO_MODE_INFORMATION videoModes,
                     ULONG ModeIndex,
                     PMODETABLE ModeInfo)
{

  PAGED_CODE();

  //
  // Copy the mode informations to window supplied buffer
  //
  videoModes->Length          = sizeof(VIDEO_MODE_INFORMATION);
  videoModes->ModeIndex       = ModeIndex;
  videoModes->VisScreenWidth  = ModeInfo->XResol;
  videoModes->VisScreenHeight = ModeInfo->YResol;
  videoModes->ScreenStride    = ModeInfo->BytesPerScanLine;
  videoModes->NumberOfPlanes  = ModeInfo->NumOfPlanes;
  videoModes->BitsPerPlane    = ModeInfo->BitsPerPixel;
  videoModes->Frequency       = ModeInfo->Frequency;
  videoModes->XMillimeter     = 320;  // temp hardcoded constant
  videoModes->YMillimeter     = 240;  // temp hardcoded constant

  if (videoModes->BitsPerPlane >= 8)
  {
     //
     // Calculate the bitmap width (note the '+ 1' on BitsPerPlane is
     // so that '15bpp' works out right):
     //
     videoModes->VideoMemoryBitmapWidth =
         videoModes->ScreenStride / ((videoModes->BitsPerPlane + 1) >> 3);

     //
     // Calculate the bitmap height.
     //
     videoModes->VideoMemoryBitmapHeight =
         HwDeviceExtension->AdapterMemorySize / videoModes->ScreenStride;
  }
  else
  {
     videoModes->VideoMemoryBitmapWidth  = 0;
     videoModes->VideoMemoryBitmapHeight = 0;
  };

  //
  // Set Mono/Color & Text/Graphic modes, interlace/non-interlace
  //
  videoModes->AttributeFlags = ModeInfo->fbType;

  if ((ModeInfo->BitsPerPixel == 24) || (ModeInfo->BitsPerPixel == 32))
  {
     videoModes->NumberRedBits   = 8;
     videoModes->NumberGreenBits = 8;
     videoModes->NumberBlueBits  = 8;
     videoModes->RedMask         = 0xff0000;
     videoModes->GreenMask       = 0x00ff00;
     videoModes->BlueMask        = 0x0000ff;
  }
  else if (ModeInfo->BitsPerPixel == 16)
  {
     videoModes->NumberRedBits   = 5;
     videoModes->NumberGreenBits = 6;
     videoModes->NumberBlueBits  = 5;
     videoModes->RedMask         = 0x1F << 11;
     videoModes->GreenMask       = 0x3F << 5;
     videoModes->BlueMask        = 0x1F;
  }
  else
  {
     videoModes->NumberRedBits   = 6;
     videoModes->NumberGreenBits = 6;
     videoModes->NumberBlueBits  = 6;
     videoModes->RedMask         = 0;
     videoModes->GreenMask       = 0;
     videoModes->BlueMask        = 0;
     videoModes->AttributeFlags |=
                (VIDEO_MODE_PALETTE_DRIVEN | VIDEO_MODE_MANAGED_PALETTE);
  };
} // end CLCopyModeInfo()



//*****************************************************************************
//
// CLEnableTiling()
//
//     Enable Tiled mode for Laguna chip.
//
//
//*****************************************************************************

VOID CLEnableTiling(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
	PMODETABLE  pReqModeTable
)
{
    #undef LAGUNA_REGS
    #define LAGUNA_REGS HwDeviceExtension->RegisterAddress

	VOLATILE PUSHORT pControl_reg  =      (PUSHORT)(LAGUNA_REGS + 0x402);
	VOLATILE PUCHAR  pTileCtrl_reg =      (PUCHAR) (LAGUNA_REGS + 0x407);
	VOLATILE UCHAR*  pPixelMask_reg =     (UCHAR*) (LAGUNA_REGS + 0xA0);
	VOLATILE USHORT* pDTTR_reg =          (USHORT*)(LAGUNA_REGS + 0xEA);
	VOLATILE USHORT* pTilingCtrl_reg =    (USHORT*)(LAGUNA_REGS + 0x2C4);

    PVIDEO_X86_BIOS_ARGUMENTS pInbiosargs;
    PVIDEO_X86_BIOS_ARGUMENTS pOutbiosargs;
	VIDEO_X86_BIOS_ARGUMENTS biosargs;

	unsigned long VidMem;
	unsigned long ulInterleave; 
    unsigned long TilesPerLine;
    unsigned long WideTiles;
    unsigned long BitsPerPixel;


	VideoDebugPrint((DISPLVL, "Miniport - Setting tiling.\n"));

    //
    // If it's not a Hi Res mode, turn off tiling.
    //
	if (pReqModeTable->BitsPerPixel < 8)
    {
    	VideoDebugPrint((DISPLVL, "Miniport - Not hi-res mode.  No tiling.\n"));

        *pControl_reg |= 0x1000; // Set bit 12 of CONTROL
        if (HwDeviceExtension->ChipID >= CL_GD5465)
            *pTilingCtrl_reg &= 0xFF7F; //Clear bit 7 of TILING_CONTROL

        HwDeviceExtension->TileSize        = 0;
        HwDeviceExtension->TiledMode       = 0;
        HwDeviceExtension->TiledTPL        = 0;
        HwDeviceExtension->TiledInterleave = 0;
        return;
    }


    //
    // It is a hi res mode.  Turn on tiling.
    //


    //
    // If we used the BIOS to set the mode, use the BIOS to enable tiling.
    // Also set TILE_CTRL, TILING_CTRL, CONTROL and DTTR.
    //
    if 	(!(pReqModeTable->SetModeString))
    {
    	// Call BIOS to set tiling.
		VideoDebugPrint((DISPLVL, 
		    "Miniport - Using BIOS. Setting tiled mode.\n"));
		VideoPortZeroMemory(&biosargs, sizeof(VIDEO_X86_BIOS_ARGUMENTS));
		biosargs.Eax = 0x1200;
		biosargs.Ebx = 0x00B3;
		VideoPortInt10(HwDeviceExtension, &biosargs);

        // Get tile size
        WideTiles = (biosargs.Eax & 0xFF) - 1;  // AL=1 for narrow,  2 for wide

        // Get tiles per line
        TilesPerLine = biosargs.Ebx & 0xFF;  //BL is tiles per line
        if ((HwDeviceExtension->ChipID >= CL_GD5465) && WideTiles)
            TilesPerLine /= 2;

        // Get color depth
   	    BitsPerPixel = pReqModeTable->BitsPerPixel;
   	    BitsPerPixel = (BitsPerPixel/ 8) - 1; // Convert 8,16,24,32 to 0,1,2,3

        // Get memory interleave
    	ulInterleave = (BYTE)(biosargs.Ebx >> 8); // BH is memory interleave.
        ulInterleave = ulInterleave << 6;         // shift to bits 6-7

        // Set DTTR bits 14-15
        *pDTTR_reg &= 0x3FFF;                     // Clear bits 14-15
        *pDTTR_reg |= (WORD) (ulInterleave << 8); // Set bits 14-15

        // Set tile control reg.
        *pTileCtrl_reg = (BYTE)( ulInterleave    // set bits 6-7  
                                | TilesPerLine); // Set bits 0-5

        // Set tiling control reg
        if (HwDeviceExtension->ChipID >= CL_GD5465)
        {
            *pTilingCtrl_reg &= 0x003F;                  // Clear bits 6-15
            *pTilingCtrl_reg |=  ( (ulInterleave << 8)   // Set bits 14-15
                                 | (TilesPerLine << 8)   // Set bits 8-13
                                 | (1 << 7)              // set bit 7
                                 | (WideTiles<<6) );     // Set bits 6
        }

        // Set control reg
		*pControl_reg =(WORD) ( (BitsPerPixel << 13)
					          | (WideTiles  << 11)  );

    }

    //
    // If we used MODE.INI to set the mode.
    //
    else 
    {
        //
        // Set memory interleave
        //
        VidMem = HwDeviceExtension->AdapterMemorySize >> 20;
    	ulInterleave = bLeave[VidMem - 1]; 

        // TILE_CTRL bits 6-7
        *pTileCtrl_reg &=  0x3F;                // Clear bits 6-7
        *pTileCtrl_reg |= (USHORT)ulInterleave; // Set bits 6-7

        // DTTR bits 14-15
        ulInterleave = ulInterleave << 8;   // Shift interleave to bit 14-15
        *pDTTR_reg &= 0x3FFF;               // Clear bits 14-15
        *pDTTR_reg |= (USHORT)ulInterleave; // Set bits 14-15

        // TILING_CTRL bits 14-15
        if (HwDeviceExtension->ChipID >= CL_GD5465)
        {
            *pTilingCtrl_reg &= 0x3FFF;           // Clear bits 14-15
            *pTilingCtrl_reg |= (USHORT)ulInterleave;     // Set bits 14-15
        }
        else
        {
            WORD tpl = *pTileCtrl_reg;
            WORD dttr = *pDTTR_reg;

            // DTTR tiles per line - bits 8-13.
            tpl  = tpl  & 0x003F;   // tiles per line is in bits 0-5.
            tpl = tpl << 8;         // shift to bits 8-12.
            dttr &= 0xC0FF;         // Clear bits 8-13 in DTTR
            dttr |= tpl;            // Set bits 8-13 in DTTR
            *pDTTR_reg = dttr;

            // CONTROL enable tiling - bit 12.
            *pControl_reg &= 0xEFFF; // clear bit 12
        }
    }      

#if 0
    //
    // If the fetch tiles per line is greater than the display tiles per line
    // we can reduce the fetch tiles per line by 1.  This speeds things
    // up a bit.
    //
    if (HwDeviceExtension->ChipID >= CL_GD5465)
    {
        unsigned long fetch_tpl = (*pDTTR_reg >> 8) & 0x3F;
        unsigned long display_tpl = (*pTileCtrl_reg) & 0x3F;

        if (fetch_tpl > display_tpl)
            *pDTTR_reg -= 0x0100;                 // One less tile per line
    }
#endif

    

    //
    // Now put some mode information into the HwDeviceExtension.
    //
    HwDeviceExtension->TileSize        = ((*pControl_reg >> 11) & 3) + 1;
    HwDeviceExtension->TiledMode       = (UCHAR) pReqModeTable->BIOSModeNum;
    HwDeviceExtension->TiledTPL        = *pTileCtrl_reg & 0x3F; 
    HwDeviceExtension->TiledInterleave = *pTileCtrl_reg >> 6;


	//
	// Report some debug information.
	//

	VideoDebugPrint((DISPLVL, "\n"
	    " CONTROL(402):     0x%04X  BPP=%2d  Tiling=%s  Size=%s \n",
	    *pControl_reg, 
	    ((((*pControl_reg & 0x6000) >>13) +1) *8),          // bpp
        (*pControl_reg & 0x1000) ? "disabled" : "enabled ", // tile disable 
        (*pControl_reg & 0x0800) ? "wide  " : "narrow"      // tile size 
	    ));

	VideoDebugPrint((DISPLVL, 
	    " TILE_CTRL(407):   0x%04X  Interleave=%d  TPL=%2d\n",
	    *pTileCtrl_reg, 
	    (1<<((*pTileCtrl_reg & 0xC0) >> 6)), // Interleave
	    (*pTileCtrl_reg & 0x3F)              // Tiles per line.
	    ));

	VideoDebugPrint((DISPLVL, 
	    " DTTR(EA):         0x%04X  Interleave=%d  FetchTPL=%2d  Size=%s\n",
	    *pDTTR_reg,
	    (1<<((*pDTTR_reg & 0xC000) >> 14)),         // Interleave
	    ((*pDTTR_reg & 0x3F00) >> 8),               // Tiles per line.
        ((*pDTTR_reg & 0x0040) ? "wide  " : "narrow") // tile size 
	    ));


    if (HwDeviceExtension->ChipID >= CL_GD5465)
 	  VideoDebugPrint((DISPLVL, 
	    " TILING_CTRL(2C4): 0x%04X  Interleave=%d  TPL=%2d  Tiling=%s Size=%s\n",
	    *pTilingCtrl_reg,
	    (1<<((*pTilingCtrl_reg & 0xC000) >> 14)),               // Interleave
	    ((*pTilingCtrl_reg & 0x3F00) >> 8),                     // Tile per line
        ((*pTilingCtrl_reg & 0x0080) ? "enabled " : "disabled"), // tile enable 
        ((*pTilingCtrl_reg & 0x0040) ? "wide  " : "narrow")      // tile size 
	    ));

	VideoDebugPrint((DISPLVL,"\n"));

}

#if MULTI_CLOCK
/******************************************************************************\
*
* CLOverrideFIFOThreshold()
*
* Description:	Override the FIFO Threshold value for CL-GD5465 chips running
*				at different clock speeds.
*
* Arguments:	PHW_DEVICE_EXTENSION HwDeviceExtension
*					Pointer to hardware device extension.
*				PMODETABLE pReqModeTable
*					Pointer to MODETABLE structure containing the video mode
*					just set.
*
* Return value:	Nothing.
*
\******************************************************************************/
void CLOverrideFIFOThreshold(PHW_DEVICE_EXTENSION HwDeviceExtension,
							 PMODETABLE pReqModeTable)
{
    #undef LAGUNA_REGS
    #define LAGUNA_REGS HwDeviceExtension->RegisterAddress

	VOLATILE USHORT* pDisplayThreshold_reg = (USHORT*) (LAGUNA_REGS + 0x00EA);
	VOLATILE BYTE*	 pBCLKMultiplier_reg = (BYTE*) (LAGUNA_REGS + 0x02C0);
	int				 i;
	BYTE			 BCLKMultiplier;

	static struct _FIFOTABLE
	{
		USHORT	xRes;
		USHORT	yRes;
		UCHAR	BitsPerPixel;
		USHORT	RefreshRate;
		BYTE	BCLKMin;
		BYTE	BCLKMax;
		USHORT	FIFOThreshold;
	} FIFOTable[] =

	// Here we define the FIFO Threshold override values for certain modes.
	{
		// xres, yres, bpp, refresh, clockmin, clockmax, FIFOThreshold
		{  1600, 1200,  16,      70,     0x14,     0x17,          0x31},
		{  1152,  864,  24,      85,     0x14,     0x17,          0x31},
		{  1280,  960,  24,      75,     0x14,     0x17,          0x31},
		{  1024,  768,  32,      85,     0x14,     0x17,          0x31},
	};

	// Get the current clock speed.
	BCLKMultiplier = *pBCLKMultiplier_reg;

	// Browse the table to find a match for the requested video mode.
	for (i = 0; i < sizeof(FIFOTable) / sizeof(FIFOTable[0]); i++)
	{
		if (   (FIFOTable[i].xRes         == pReqModeTable->XResol)
			&& (FIFOTable[i].yRes         == pReqModeTable->YResol)
			&& (FIFOTable[i].BitsPerPixel == pReqModeTable->BitsPerPixel)
			&& (FIFOTable[i].RefreshRate  == pReqModeTable->Frequency)
			&& (FIFOTable[i].BCLKMin      <= BCLKMultiplier)
			&& (FIFOTable[i].BCLKMax      >= BCLKMultiplier)
		)
		{
			// The requested video mode has been found, so override the FIFO
			// Threshold value.
            VideoDebugPrint((DISPLVL, "\nMiniport - FIFO Threshold was %04X.\n",
            		*pDisplayThreshold_reg));
			*pDisplayThreshold_reg = (*pDisplayThreshold_reg & ~0x003F)
								   | FIFOTable[i].FIFOThreshold;
            VideoDebugPrint((DISPLVL,
            		"\nMiniport - FIFO Threshold changed to %04X.\n",
            		*pDisplayThreshold_reg));
			break;
		}
	}
}
#endif

/****************************************************************************
* FUNCTION NAME: CLSetMode()
*
* DESCRIPTION:
*   This routine sets the Laguna into the requested mode.
*
* REVISION HISTORY:
*   5/30/95     Benny Ng      Initial version
****************************************************************************/
static __inline void SetVW0_TEST0 (PHW_DEVICE_EXTENSION HwDeviceExtension)
{
    #undef LAGUNA_REGS
    #define LAGUNA_REGS HwDeviceExtension->RegisterAddress

	VOLATILE ULONG*  pVW0_TEST0 =         (ULONG*) (LAGUNA_REGS + 0x80F0);

   // Set VW0_TEST0 to 0x42 after mode change
   if (HwDeviceExtension->ChipID >= CL_GD5465)
	   *pVW0_TEST0 = 0x42;
};

VP_STATUS CLSetMode (PHW_DEVICE_EXTENSION HwDeviceExtension,
                     PVIDEO_MODE Mode)
{
	VP_STATUS status;
	PMODETABLE  pReqModeTable;
	VIDEO_X86_BIOS_ARGUMENTS biosargs;
	ULONG   ReqMode;
	USHORT  ClrMemMask = 0x0000;

    #undef LAGUNA_REGS
    #define LAGUNA_REGS HwDeviceExtension->RegisterAddress

	VOLATILE PUSHORT pStatus_reg =        (PUSHORT)(LAGUNA_REGS + STATUS_REG);
	VOLATILE PUSHORT pControl_reg  =      (PUSHORT)(LAGUNA_REGS + CONTROL_REG);
	VOLATILE PUCHAR  pTileCtrl_reg =      (PUCHAR) (LAGUNA_REGS + TILE_CTRL_REG);
	VOLATILE ULONG*  pOP0_opRDRAM_reg =   (ULONG*) (LAGUNA_REGS + 0x520);
	VOLATILE WORD*   pOP0_opRDRAM_X_reg = (WORD*)  (LAGUNA_REGS + 0x520);
	VOLATILE WORD*   pOP0_opRDRAM_Y_reg = (WORD*)  (LAGUNA_REGS + 0x522);
	VOLATILE ULONG*  pDRAWBLTDEF_reg =    (ULONG*) (LAGUNA_REGS + 0x584);
	VOLATILE ULONG*  pOP0_opBGCOLOR_reg = (ULONG*) (LAGUNA_REGS + 0x5E4);
	VOLATILE ULONG*  pBITMASK_reg =	      (ULONG*) (LAGUNA_REGS + 0x5E8);
	VOLATILE ULONG*  pBLTEXT_EX_reg =     (ULONG*) (LAGUNA_REGS + 0x700);
	VOLATILE WORD*   pBLTEXT_EX_X_reg =   (WORD*)  (LAGUNA_REGS + 0x700);
	VOLATILE WORD*   pBLTEXT_EX_Y_reg =   (WORD*)  (LAGUNA_REGS + 0x702);
	VOLATILE BYTE*   pMCLK_reg =          (BYTE*)  (LAGUNA_REGS + 0x08C);
	VOLATILE USHORT* pDTTR_reg =          (USHORT*)(LAGUNA_REGS + 0xEA);

	VOLATILE ULONG*  pVW0_HSTRT =         (ULONG*) (LAGUNA_REGS + 0x8000);
	VOLATILE ULONG*  pVW0_CONTROL0 =      (ULONG*) (LAGUNA_REGS + 0x80E4);
	VOLATILE ULONG*  pVW0_TEST0 =         (ULONG*) (LAGUNA_REGS + 0x80F0);

	VOLATILE BYTE*	 pMISC_OUTPUT_reg =	  (BYTE*)  (LAGUNA_REGS + 0x0080);

#if 0 // Stress test
    PAGED_CODE();
#endif

    // Reset the video window registers to their boot state
    if (HwDeviceExtension->ChipID >= CL_GD5465)
    {
       VOLATILE ULONG*  pVW0_REGS;

   	 *pVW0_CONTROL0 = 1;  // Disable and arm VW0

       // Fill VW0 regs between HSTRT and CONTROL0 with 0
       for (pVW0_REGS = pVW0_HSTRT; pVW0_REGS < pVW0_CONTROL0; pVW0_REGS++)
           *pVW0_REGS = 0;

   	 *pVW0_CONTROL0 = 1;  // arm VW0
	    *pVW0_TEST0 = 0xA;   // Reset TEST0 reg to boot state
    };

    //
    // AGP HACK!!!
    // If we don't have access to VGA modes, then lie.
    //
    if (HwDeviceExtension->Dont_Do_VGA)
    {
        if ((Mode->RequestedMode) == DEFAULT_MODE)
        {
            VideoDebugPrint((DISPLVL, 
                "\nMiniport - Impliment DEFAULT_MODE for Dont_Do_VGA.\n"));


        	// Wait for chip to go idle.
        	while (*pStatus_reg & 0x07);

            // disable tiling.
        	ReqMode = Mode->RequestedMode & ~VIDEO_MODE_NO_ZERO_MEMORY;
        	pReqModeTable = &ModeTable[ReqMode];

            CLEnableTiling(HwDeviceExtension, pReqModeTable);

        	HwDeviceExtension->CurrentModeNum =Mode->RequestedMode;

         SetVW0_TEST0(HwDeviceExtension);
        	return NO_ERROR;
        }
    }

	//
	// Check to see if we are requesting a valid mode
	//
	ReqMode = Mode->RequestedMode & ~VIDEO_MODE_NO_ZERO_MEMORY;

	if (Mode->RequestedMode & VIDEO_MODE_NO_ZERO_MEMORY)
	{
		ClrMemMask = 0x8000;
	}

	if (ReqMode >= TotalVideoModes)
	{
      SetVW0_TEST0(HwDeviceExtension);
		return ERROR_INVALID_PARAMETER;
	}

	//
	// If selected mode = current mode then return.
	//
	if (HwDeviceExtension->CurrentModeNum == ReqMode)
	{
      SetVW0_TEST0(HwDeviceExtension);
		return NO_ERROR;
	}

    //
    // Points to the selected mode table slot
    //
	pReqModeTable = &ModeTable[ReqMode];

    //
    // Don't try to set the mode it it is not supported by the chip/card.
    //
    if (pReqModeTable->ValidMode != TRUE)
    {
        // The reset mode is marked invalid, but we still need to 
        // "set" it for IOCTL_VIDEO_RESET_DEVICE.
        if (Mode->RequestedMode != resetmode) 
	    {
          SetVW0_TEST0(HwDeviceExtension);
		    return ERROR_INVALID_PARAMETER;
    	}
    }

	//
	// Wait for chip to go idle.
	//
	while (*pStatus_reg & 0x07);

#if VS_CONTROL_HACK
	// Enable PCI configuration registers.
    CLEnablePCIConfigMMIO(HwDeviceExtension);
#endif

	//
	// If a SetModeString is available, then call SetMode().
	// 
	if (pReqModeTable->SetModeString)
	{
	    UCHAR reg_SR15;

	    // Set the mode.
	    VideoDebugPrint((DISPLVL, "Miniport - Calling SetMode\n"));
	    SetMode(pReqModeTable->SetModeString,
	            HwDeviceExtension->RegisterAddress,
	            NULL,
	            HwDeviceExtension->Dont_Do_VGA);

        if (Mode->RequestedMode == resetmode) 
        {
	        // After doing HwReset, NT can call the BIOS to set a mode.
	        // There is one 'gotcha' here.  If we previously set a mode without 
	        // using the BIOS, then the BIOS doesn't know what the current mode 
	        // is, and may not set the new mode correctly.  
	        // If we clear bit 5 in SR15 prior to setting the mode, then the
	        // BIOS will 'set everything' when it sets the mode.

	        VideoPortWritePortUchar((PUCHAR) 0x3C4, 0x15);	// Select SR15
	        reg_SR15 = VideoPortReadPortUchar((PUCHAR) 0x3C5);	// Read SR15
	        reg_SR15 = reg_SR15 & 0xDF ; // 1101 1111 		// Clear bit 5
	        VideoPortWritePortUchar((PUCHAR) 0x3C4, 0x15);	// Select SR15
	        VideoPortWritePortUchar((PUCHAR) 0x3C5, reg_SR15);	// Write SR15
        }

	}

    //
    // Otherwise, use BIOS to set the mode.
    //
	else 
	{
	    UCHAR reg_SR15;

	    VideoDebugPrint((DISPLVL, "Miniport - Using BIOS to set the mode\n"));

        //
        // Set the Vertical Monitor type.
        //
        if (!CLSetMonitorType(HwDeviceExtension, pReqModeTable->YResol,
                              pReqModeTable->MonitorTypeVal))
        {
            SetVW0_TEST0(HwDeviceExtension);
            return ERROR_INVALID_PARAMETER;
        };

	    //
	    // We are using the BIOS to set the mode.
	    // There is one 'gotcha' here.  If we previously set a mode without 
	    // using the BIOS, then the BIOS doesn't know what the current mode 
	    // is, and may not set the new mode correctly.  
	    // If we clear bit 5 in SR15 prior to setting the mode, then the
	    // BIOS will 'set everything' when it sets the mode.
	    //
	    VideoPortWritePortUchar((PUCHAR) 0x3C4, 0x15);	// Select SR15
	    reg_SR15 = VideoPortReadPortUchar((PUCHAR) 0x3C5);	// Read SR15
	    reg_SR15 = reg_SR15 & 0xDF ; // 1101 1111 		// Clear bit 5
	    VideoPortWritePortUchar((PUCHAR) 0x3C4, 0x15);	// Select SR15
	    VideoPortWritePortUchar((PUCHAR) 0x3C5, reg_SR15);	// Write SR15


	    //
	    // Set the selected mode.
	    //
	    VideoPortZeroMemory(&biosargs, sizeof(VIDEO_X86_BIOS_ARGUMENTS));
	    biosargs.Eax = 0x4F02;
	    biosargs.Ebx = pReqModeTable->BIOSModeNum | ClrMemMask;
	    VideoDebugPrint((DISPLVL, "Miniport - Mode=%xH\n", biosargs.Ebx));

	    if ((status = VideoPortInt10(HwDeviceExtension, &biosargs)) != NO_ERROR)
        {
            SetVW0_TEST0(HwDeviceExtension);
            return status;
        };

        if ((biosargs.Eax & 0xffff) != VESA_STATUS_SUCCESS) 
        {
            SetVW0_TEST0(HwDeviceExtension);
            VideoDebugPrint((1, "CLSetMode: Int10 call failed. Mode=%xH\n", biosargs.Ebx));
            return ERROR_INVALID_PARAMETER;
        }

    } // End use BIOS to set mode.

	// Set monitor sync polarity for hi-res modes.
	if (pReqModeTable->XResol >= 320 || pReqModeTable->YResol >= 200)
	{
		*pMISC_OUTPUT_reg |= (BYTE) HwDeviceExtension->dwPolarity;
	}

    //
    // Enable Tiling.
    //
    CLEnableTiling(HwDeviceExtension, pReqModeTable);

	//
	// SWAT, 7 Jun 97
	// 5465AD: Set bit 4 in the CONTROL register to disable bugfix 201 which is
	// causing hang ups in HostToScreen bitblts.
	//
	if (   (HwDeviceExtension->ChipID == CL_GD5465)
		&& (HwDeviceExtension->ChipRev >= 2)
	)
	{
		*pControl_reg |= 0x0010;
	}

    //
    // Turn down the clock a bit on the 5464 and 65.
    //
    VideoDebugPrint((DISPLVL, "Miniport - MCLK was %xH.\n", *pMCLK_reg));
    if (HwDeviceExtension->ChipID == CL_GD5464)
    {
        *pMCLK_reg = 0x10;
        VideoDebugPrint((DISPLVL, "Miniport - MCLK set to %xH.\n", *pMCLK_reg));
    }
//    else if (HwDeviceExtension->ChipID >= CL_GD5465)
//    {
//    	pMCLK_reg = (BYTE*)  (LAGUNA_REGS + 0x2C0);
//        *pMCLK_reg = 0x13;
//        VideoDebugPrint((DISPLVL, "Miniport - MCLK set to %xH.\n", *pMCLK_reg));
//    }

#if MULTI_CLOCK
{
	// The current mode table files have no single value for the FIFO Threshold
	// register for all clock speeds.  So we need to override the FIFO Threshold
	// registers in case we are running at a clock speed that otherwise would
	// produce a lot of noise on the screen.  Notice we only implement this
	// routine for the CL-GD5465 chip.
	if (HwDeviceExtension->ChipID == CL_GD5465)
	{
		CLOverrideFIFOThreshold(HwDeviceExtension, pReqModeTable);
	}
}
#endif

	// Clear the video memory if we have a graphics mode.
	if ((pReqModeTable->BitsPerPixel >= 8) && !ClrMemMask)
	{
		*pBITMASK_reg       = 0xFFFFFFFF;	// enable all bits
		*pDRAWBLTDEF_reg    = 0x100700F0;	// solid color fill, ROP_PATCOPY
		*pOP0_opBGCOLOR_reg = 0;			// fill with black

        //
        // Chip bug.  
        // On the 5464 we must do 16 bit writes for the first BLT, 
        // or the chip might hang.
        //
		*pOP0_opRDRAM_X_reg   = 0;			// fill at 0,0
		*pOP0_opRDRAM_Y_reg   = 0;			// fill at 0,0
		*pBLTEXT_EX_X_reg     = pReqModeTable->XResol;
		*pBLTEXT_EX_Y_reg     = pReqModeTable->YResol;

		// Wait for the blit to complete.
		while (*pStatus_reg & 0x07);
	}

	//
	// Report some debug information.
	//
	VideoDebugPrint((DISPLVL, 
	    "Miniport - CONTROL=%Xh, TILE_CTRL=%Xh, DTTR=%Xh\n",
	    *pControl_reg, *pTileCtrl_reg, *pDTTR_reg));
	VideoDebugPrint((DISPLVL, 
	    "Miniport - TileSize=%d, TiledTPL=%d, Interleave=%d\n",
	     HwDeviceExtension->TileSize, HwDeviceExtension->TiledTPL,
	     HwDeviceExtension->TiledInterleave));

	//
	// Store the new mode values.
	//
	HwDeviceExtension->CurrentMode    = pReqModeTable;
	HwDeviceExtension->CurrentModeNum = ReqMode;

   SetVW0_TEST0(HwDeviceExtension);
	return NO_ERROR;

} //end CLSetMode()



/****************************************************************************
* FUNCTION NAME: CLSetMonitorType()
*
* DESCRIPTION:
*   Setup the monitor type.
*
* REVISION HISTORY:
*   5/30/95     Benny Ng      Initial version
****************************************************************************/
BOOLEAN CLSetMonitorType (PHW_DEVICE_EXTENSION HwDeviceExtension,
                          USHORT VertScanlines,
                          UCHAR  MonitorTypeVal)
{
  VIDEO_X86_BIOS_ARGUMENTS biosArguments;
  ULONG tempEAX, tempEBX, tempECX;
  BOOLEAN err = FALSE;

#if 0 // Stress test
  PAGED_CODE();
#endif

  VideoDebugPrint((DISPLVL, "Miniport - SetMonitorType\n"));

  if (HwDeviceExtension->Dont_Do_VGA)
  {
      VideoDebugPrint((DISPLVL, 
          "\nMiniport - Impliment CLSetMonitorType for Dont_Do_VGA\n\n"));
      return TRUE;
  }

  //
  // Decode the selected frequency and selected vertical scanlines,
  //
  tempEAX = 0;
  tempEBX = 0;
  tempECX = 0;

  if (VertScanlines <= 480)
  {
     // Set the Max vertical resolution & frequency
     tempEAX = MonitorTypeVal & 0xF0;
  }
  else if (VertScanlines <= 600)
  {
     // Set the Max vertical resolution & frequency
     tempEAX = 0x1;
     tempEBX = MonitorTypeVal << 8;
  }
  else if (VertScanlines <= 768)
  {
     // Set the Max vertical resolution & frequency
     tempEAX = 0x2;
     tempEBX = MonitorTypeVal << 8;
  }
  else if (VertScanlines <= 1024)
  {
     // Set the Max vertical resolution & frequency
     tempEAX = 0x3;
     tempECX = MonitorTypeVal << 8;
  }
  else if (VertScanlines <= 1200)
  {
     // Set the Max vertical resolution & frequency
     tempEAX = 0x4;
     tempECX = MonitorTypeVal << 8;
  }
  else
  {
     err = TRUE;
  };
  
  //
  // If invalid Vertical scanlines, return FALSE
  //
  if (err)
  {
     return FALSE;
  };

  //
  // Set the selected monitor type
  //
  VideoPortZeroMemory(&biosArguments, sizeof(VIDEO_X86_BIOS_ARGUMENTS));

  biosArguments.Eax = 0x00001200 | tempEAX;
  biosArguments.Ebx = 0x000000A4 | tempEBX;
  biosArguments.Ecx = tempECX;
                      
  if (VideoPortInt10(HwDeviceExtension, &biosArguments) == NO_ERROR)
  {
     return TRUE;
  }
  else
  {
     VideoDebugPrint((DISPLVL, "Miniport - Set Monitor Type failed\n"));

     return FALSE;
  };

} // end CLSetMonitorType()



/****************************************************************************
* FUNCTION NAME: CLPowerManagement()
*
* DESCRIPTION:
*   This routine get or set the power state. If it is GET operation, it
*   saves current power state in the VIDEO_POWER_MANAGEMENT structure
*   provided by NT.
*
* REVISION HISTORY:
*   5/30/95     Benny Ng      Initial version
****************************************************************************/
VP_STATUS CLPowerManagement (PHW_DEVICE_EXTENSION HwDeviceExtension,
                             PVIDEO_POWER_MANAGEMENT pPMinfo,
                             BOOLEAN SetPowerState)
{
  VP_STATUS status;
  VIDEO_X86_BIOS_ARGUMENTS biosargs;

  PAGED_CODE();

  //
  // Setup VIDEO_X86_BIOS_ARGUMENTS structure to do an INT 10 to
  // set or get power state
  //
  VideoPortZeroMemory(&biosargs, sizeof(VIDEO_X86_BIOS_ARGUMENTS));
  biosargs.Eax = 0x4F10;

  if (SetPowerState) 
  {
     switch (pPMinfo->PowerState)
     {
       case VideoPowerOn:
         biosargs.Ebx = 0x0001;
         break;
   
       case VideoPowerStandBy:
         biosargs.Ebx = 0x0101;
         break;
   
       case VideoPowerSuspend:
         biosargs.Ebx = 0x0201;
         break;
   
       case VideoPowerOff:
         biosargs.Ebx = 0x0401;
         break;
   
       default:
         break;
     };
  }
  else
  {
     biosargs.Ebx = 0x0002;
  };

  if (biosargs.Ebx == 0)
  {
     return ERROR_INVALID_PARAMETER;
  };

  //
  // Do the BIOS call
  //
  if ((status = VideoPortInt10(HwDeviceExtension, &biosargs)) != NO_ERROR)
  {
     return status;
  };

  //
  // If it is GET operation, saves the power state in the output buffer
  //
  if (!SetPowerState) 
  {
     pPMinfo->Length = sizeof(VIDEO_POWER_MANAGEMENT);
     pPMinfo->DPMSVersion = 0x1;

     switch (biosargs.Ebx & 0x00000F00)
     {
       case 0x000:
         pPMinfo->PowerState = VideoPowerOn;
         break;
   
       case 0x100:
         pPMinfo->PowerState = VideoPowerStandBy;
         break;
   
       case 0x200:
         pPMinfo->PowerState = VideoPowerSuspend;
         break;
   
       case 0x400:
         pPMinfo->PowerState = VideoPowerOff;
         break;
   
       default:
         pPMinfo->PowerState = (ULONG) -1;
         break;
     };
  };
 
  //
  // Update the local copy of the power state
  //
  if (pPMinfo->PowerState != (ULONG) -1)
  {
     HwDeviceExtension->PowerState = pPMinfo->PowerState;
  };

  return NO_ERROR;

}; // CLGetPowerManagement()





//*****************************************************************************
//
// CLEnablePciBurst()
//
//     Detect bad motherboard chip sets and don't turn on the HD_BRST_EN bit.
//
//     Return TRUE if bursting was enabled.
//     Return FALSE if it was disabled.
//
//*****************************************************************************

BOOLEAN CLEnablePciBurst(
    PHW_DEVICE_EXTENSION hwDeviceExtension
)
{
    PCI_COMMON_CONFIG       PciCommonConfig;
    BOOLEAN HDBrstEN;
    USHORT  VendorId, DevId, HWRev;
    ULONG   Slot, Bus, ulTmp, i;

    #undef LAGUNA_REGS
    #define LAGUNA_REGS (hwDeviceExtension->RegisterAddress)
    VOLATILE ULONG *pHostMasterControl = (PULONG) (LAGUNA_REGS + 0x4440);
    VOLATILE ULONG *pVSControl_reg =     (PULONG) (LAGUNA_REGS + VSCONTROL_REG);
    VOLATILE WORD  *pFB_Cache_Ctrl =     (WORD *) (LAGUNA_REGS + 0x2C8);
	VOLATILE USHORT *pTilingCtrl_reg =   (USHORT*)(LAGUNA_REGS + 0x2C4);
	VOLATILE USHORT *pPerformance_reg =  (USHORT*)(LAGUNA_REGS + 0x58C);
    VOLATILE ULONG *pControl2_reg =      (PULONG) (LAGUNA_REGS + 0x418);

    PAGED_CODE();

    VideoDebugPrint((DISPLVL, "Miniport - CLEnablePciBurst.\n"));


    //
    // There are three burst settings we need to concern ourselves with.
    //
    // FRAME BUFFER - Bursting to the frame buffer is broken on the 
    //      5462, 5464 and 5465.  We always turn this off.
    //
    // HOSTDATA - Bursting to HOSTDATA works for some motherboard chipsets
    //      but not for others.  We have a table listing the bad chipsets.
    //
    // HOST_X_Y - Bursting to the Host XY unit is broken on the 5464, but
    //      works on the 5465.
    //


	if (   (hwDeviceExtension->ChipID > CL_GD5465)
		|| (   (hwDeviceExtension->ChipID == CL_GD5465)
			&& (hwDeviceExtension->ChipRev >= 3)
		)
	)
	{
		// Enable frame buffer bursting on 5465AF and higher.
		*pVSControl_reg |= (1 << 13);	
        VideoDebugPrint((DISPLVL, "-> Enabled frame buffer bursting.\n"));
	}
	else
    {
		// Disable frame buffer bursting on all other chips.
        *pVSControl_reg &= ~(1 << 13);
        VideoDebugPrint((DISPLVL, "-> Disabled frame buffer bursting.\n"));
    }


    //
    // HostXY.  Disable on 5464.
    //
    if (hwDeviceExtension->ChipID == CL_GD5464)
    {
        ulTmp = *pHostMasterControl;
        ulTmp |= 0x3;                // Set bit 0-1 to disable burst.
        *pHostMasterControl = ulTmp;
        VideoDebugPrint((DISPLVL, "        Disabled HOST_XY bursting.\n"));

    }
    else if (hwDeviceExtension->ChipID > CL_GD5464)
    {
        ulTmp = *pHostMasterControl;
        ulTmp &= 0xFFFFFFFC;       // Clear bit 0-1 to enable burst.
        *pHostMasterControl = ulTmp;
        VideoDebugPrint((DISPLVL, "        Enabled HOST_XY bursting.\n"));
    }


    //
    // HOSTDATA bursting.
    //

#if 1
    HDBrstEN = FALSE;  // force 'disabled' till the following code is validated

#else
    HDBrstEN = TRUE;  // default is 'enabled'.

    // For each ID in our list of bad motherboards.
    for (i = 0; i < NUMBADCHIPSET && HDBrstEN; i++) 
    {
        VendorId = BadChipSet[i].VendorId;
        DevId    = BadChipSet[i].DeviceId;
        HWRev    = BadChipSet[i].HwRev;     

        //
        // search PCI space and see if the bad ID is there.
        //
        Bus = 0;
        Slot = 0;
        while ( ulTmp = HalGetBusData(PCIConfiguration,
                                      Bus,
                                      Slot,
                                      &PciCommonConfig,
                                      PCI_COMMON_HDR_LENGTH) )
        {
            if ((ulTmp > 4) &&
                (PciCommonConfig.VendorID == VendorId) &&
                (PciCommonConfig.DeviceID == DevId))
            {
                // This motherboard is a bad one.
                HDBrstEN = FALSE;
                break;  // quit looking.
            }
            if ( ++Slot == MAX_SLOTS )
            {
                 Slot = 0;
                 Bus++;
            }
        } // end while
    }  // end for each id in our list of bad ones.
#endif

    if (HDBrstEN)
    {
        ulTmp = *pVSControl_reg;
        ulTmp  |=  0x00001000;   // Set bit 12 to enable.
        *pVSControl_reg = ulTmp;
        VideoDebugPrint((DISPLVL, "        Enabled HOSTDATA bursting.\n"));
    }
    else
    {
        ulTmp = *pVSControl_reg;
        ulTmp  &=  0xFFFFEFFF;   // Clear bit 12 to disable.
        *pVSControl_reg = ulTmp;
        VideoDebugPrint((DISPLVL, "        Disabled HOSTDATA bursting.\n"));
    }


    //
    // Frame buffer caching is broken on the 65
    //
    if (hwDeviceExtension->ChipID >= CL_GD5465)
    {
        //
        // Frame buffer caching is broken on the 65
        //
        WORD temp = *pFB_Cache_Ctrl;
        temp = temp & 0xFFFE; // turn off bit 0.
        *pFB_Cache_Ctrl = temp;
    }


    // 
    // Enable 5465AD optimizations.
    //
    if ( ((hwDeviceExtension->ChipID==CL_GD5465)   // 5465
              && (hwDeviceExtension->ChipRev>1))   // rev AD
       || (hwDeviceExtension->ChipID > CL_GD5465)) // and later.
    {
    	// Reduce Address Translate Delay to 3 clocks.
	    *pTilingCtrl_reg = (*pTilingCtrl_reg| 0x0001);

	    // Enable 256-byte fetch.
        *pPerformance_reg = (*pPerformance_reg & ~0x4000);
	    *pControl2_reg = (*pControl2_reg  | 0x0010);
    }

    *pPerformance_reg = (*pPerformance_reg | 0x0484);


    VideoDebugPrint((DISPLVL, "Miniport - CLEnablePciBurst - Exit.\n"));
    return HDBrstEN;
}


//*****************************************************************************
//
//  CLFindLagunaOnPciBus
//
//  Scan all the slots on the PCI bus and look for a Laguna chip.
// 
//  If we find one, store it's PCI ID in the hwDeviceExtension, and
//  and store it's PCI mappings in the AccessRanges structure.
//
//  Return NO_ERROR if we find a Laguna
//  Return ERROR_DEV_NOT_EXIST if we don't
//
//*****************************************************************************

VP_STATUS CLFindLagunaOnPciBus(
    PHW_DEVICE_EXTENSION hwDeviceExtension,
    PVIDEO_ACCESS_RANGE  pAccessRanges // Points to the first of the two Laguna
                                       // access ranges.  We will fill these 
                                       // two ranges with data from PCI space.
)
{
    UCHAR Command;
    PCI_COMMON_CONFIG       PciCommonConfig;
    BOOLEAN DeviceFound = FALSE;
    USHORT  VendorId = VENDOR_ID;     // Vender Id
    ULONG   Slot = 0;
    ULONG ulTmp,i;
    VP_STATUS status = ERROR_DEV_NOT_EXIST;


    PAGED_CODE();

    VideoDebugPrint((DISPLVL, "Miniport - Searching PCI bus for Laguna card.\n"));

#if _WIN32_WINNT >= 0x0500
	status = VideoPortGetAccessRanges(hwDeviceExtension,
									  0,
									  NULL,
									  NUM_MM_ACCESS_RANGES,
									  pAccessRanges,
									  NULL,
									  NULL,
									  NULL);

	if (status == NO_ERROR)
	{
		ulTmp = VideoPortGetBusData(hwDeviceExtension,
		    						 PCIConfiguration,
									 0,
									 &PciCommonConfig,
									 0,
									 PCI_COMMON_HDR_LENGTH);

        // Rev AC of the Laguna chip (5462) is not supported.
		if (   (PciCommonConfig.DeviceID == CL_GD5462)	// CL-GD5462
			&& (PciCommonConfig.RevisionID == 0)		// Rev AC
		)
		{
			status = ERROR_DEV_NOT_EXIST;
		}
	}
#else
    //
    // Loop through the PCI slots, looking our chip.
    //
    for (Slot = 0; Slot < MAX_SLOTS; Slot++)
    {
        // Get data from a PCI slot.
        ulTmp = VideoPortGetBusData(hwDeviceExtension,
                                    PCIConfiguration,
                                    Slot,
                                    &PciCommonConfig,
                                    0,
                                    PCI_COMMON_HDR_LENGTH);

        // Is the card in this slot a Cirrus card?
        if ((ulTmp > 4) && (PciCommonConfig.VendorID != VendorId))
            continue;  // Nope.  Next slot.



        //
        // It's a Cirrus card.  But is it a Laguna?
        // Loop through our list of Laguna devices and see if 
        // the card in this slot is on the list.
        //
        i = 0;
        DeviceFound = FALSE;
        while ((DeviceId[i] != 0) && (DeviceFound == FALSE))
        {
            if (   (PciCommonConfig.DeviceID == DeviceId[i])
#if 1 // PDR#11377
				&& (PciCommonConfig.Command &
						(PCI_ENABLE_IO_SPACE | PCI_ENABLE_MEMORY_SPACE))
#endif
			)
			{
                 DeviceFound = TRUE; // It's a Laguna.
                 break;              // Exit FOR loop.
             }
             i++;
        } 

        if (! DeviceFound)  
            continue;    // Nope, not a supported Laguna.  Next slot.


        // Rev AC of the Laguna chip (5462) is not supported.
        if ((PciCommonConfig.DeviceID == CL_GD5462) &&
            (PciCommonConfig.RevisionID == 0))         // Rev AC
                continue; // move on to next PCI slot.

        // We found a card we can use.  Quit looking.
        status = NO_ERROR;
        break; // Exit FOR loop.

    }  // end for slot
#endif

    //
    // Did we find our chip?
    //
    if (status != NO_ERROR)
        return status; // Nope.  Return the error.

    //
    // Store the chip ID and revision in the DeviceExtention so
    // the display driver can find out what chip it's using.
    //
    hwDeviceExtension->ChipID = PciCommonConfig.DeviceID;
    hwDeviceExtension->ChipRev = PciCommonConfig.RevisionID;

    // Save the slot number for future use.
    hwDeviceExtension->SlotNumber = Slot;

    //
    // Tell PCI to enable the IO and memory addresses.
    //

    // Get PCI COMMAND reg.
    ulTmp = VideoPortGetBusData(
                hwDeviceExtension,
                PCIConfiguration,
                Slot,
                &Command,
                FIELD_OFFSET(PCI_COMMON_CONFIG, Command),
                1);

    if (ulTmp != 1) // Error talking to PCI space.
        return ERROR_DEV_NOT_EXIST;

    // The 5464 and later can Bus Master.
    if (hwDeviceExtension->ChipID >= CL_GD5464)
        Command |=  PCI_ENABLE_BUS_MASTER;

    // Set PCI COMMAND reg.
    VideoPortSetBusData(hwDeviceExtension,
                    PCIConfiguration,
                    Slot,
                    &Command,
                    FIELD_OFFSET(PCI_COMMON_CONFIG, Command),
                    1);


    //
    // Get the PCI configuration data
    //   
    ulTmp = VideoPortGetBusData(hwDeviceExtension,
                                PCIConfiguration,
                                Slot,
                                &PciCommonConfig,
                                0,
                                PCI_COMMON_HDR_LENGTH);

    //
    // Setup Access Range for Register space
    //
    if (hwDeviceExtension->ChipID == CL_GD5462)
    {
        // 5462 decodes 16 k of register address space.
        pAccessRanges->RangeStart.LowPart =
                PciCommonConfig.u.type0.BaseAddresses[0] & 0xFFFFC000;
        pAccessRanges->RangeStart.HighPart = 0x00000000;
        pAccessRanges->RangeLength    = (16 * 1024);
    }
    else if (hwDeviceExtension->ChipID <= CL_GD5464_BD)
    {
        // 5464 and BD decode 32 k of register address space.
        pAccessRanges->RangeStart.LowPart =
                PciCommonConfig.u.type0.BaseAddresses[0] & 0xFFFF8000;
        pAccessRanges->RangeStart.HighPart = 0x00000000;
        pAccessRanges->RangeLength    = (32 * 1024);
    }
    else // For the 5465 and later we swapped the the PCI regs around.
    {
        // Use the defaults
        pAccessRanges->RangeStart.LowPart =
                PciCommonConfig.u.type0.BaseAddresses[1]
                & DEFAULT_RESERVED_REGISTER_MASK;
        pAccessRanges->RangeStart.HighPart = 0x00000000;
        pAccessRanges->RangeLength    = DEFAULT_RESERVED_REGISTER_SPACE;
    }

    pAccessRanges->RangeInIoSpace = FALSE;
    pAccessRanges->RangeVisible   = TRUE;
    pAccessRanges->RangeShareable = FALSE;


    //
    // Setup Access Range for Frame buffer
    // the 62 and the 64 both use the default frame buffer size.
    //   
    ++pAccessRanges; // move to next access range to be filled in.

    // The 65 and later have PCI BASE ADDR regs 0 and 1 reversed.
    if (hwDeviceExtension->ChipID <= CL_GD5464_BD)
       pAccessRanges->RangeStart.LowPart =
           PciCommonConfig.u.type0.BaseAddresses[1] & DEFAULT_RESERVED_FB_MASK;
    else
       pAccessRanges->RangeStart.LowPart =
           PciCommonConfig.u.type0.BaseAddresses[0] & DEFAULT_RESERVED_FB_MASK;

    pAccessRanges->RangeStart.HighPart = 0x00000000;
    pAccessRanges->RangeLength = DEFAULT_RESERVED_FB_SPACE;
    pAccessRanges->RangeInIoSpace = FALSE;
    pAccessRanges->RangeVisible   = TRUE;
    pAccessRanges->RangeShareable = FALSE;

    status = NO_ERROR;


    return status;
}



// ****************************************************************************
//
// ClAllocateCommonBuffer()
// 
// Allocates a locked down common buffer for bus mastered data transfers.
//
// If the Alloc fails, it isn't fatal; we just don't do bus mastering.
// The driver can test the size of the common buffer to see if it exists.
//
// ****************************************************************************
VOID ClAllocateCommonBuffer(
    PHW_DEVICE_EXTENSION    HwDeviceExtension
)
{
    PHYSICAL_ADDRESS logicalAddress;
    PVOID VirtualAddr;
    PADAPTER_OBJECT AdapterObject;
    DEVICE_DESCRIPTION DeviceDescription;
    ULONG NumberOfMapRegisters;

    PAGED_CODE();

    //
    // No common buffer exists at this time.
    //
    HwDeviceExtension->CommonBufferSize = 0;
    HwDeviceExtension->PhysicalCommonBufferAddr = 0;
    HwDeviceExtension->VirtualCommonBufferAddr = 0;

    #if NO_BUS_MASTER
        return;
    #else

    //
    // CL5462 doesn't do bus masters.
    //
    if (HwDeviceExtension->ChipID == CL_GD5462)
    {
        VideoDebugPrint((DISPLVL, 
        "Miniport - AllocCommonBuffer Failed:  CL5462 doesn't bus master.\n"));
        return;
    }

    // Set up the device attributes description
    RtlZeroMemory(&DeviceDescription, sizeof(DeviceDescription));
    DeviceDescription.Version = DEVICE_DESCRIPTION_VERSION;
    DeviceDescription.Master = TRUE;
    DeviceDescription.ScatterGather = TRUE;
    DeviceDescription.DemandMode = TRUE;
    DeviceDescription.AutoInitialize = TRUE;
    DeviceDescription.Dma32BitAddresses = TRUE;
    DeviceDescription.IgnoreCount = FALSE;
    DeviceDescription.Reserved1 = FALSE;
    DeviceDescription.Reserved2 = FALSE;
    DeviceDescription.BusNumber = HwDeviceExtension->SystemIoBusNumber;
    DeviceDescription.DmaChannel = 0; 
    DeviceDescription.InterfaceType = PCIBus;
    DeviceDescription.DmaWidth = Width32Bits;
    DeviceDescription.DmaSpeed = 0;
    DeviceDescription.MaximumLength = SIZE_BUS_MASTER_BUFFER;
    DeviceDescription.DmaPort = 0;
    
    NumberOfMapRegisters = SIZE_BUS_MASTER_BUFFER/PAGE_SIZE + 1;

    // Get a pointer to the adapter object.  This is required for allocating
    // a buffer for bus mastering.
    AdapterObject = (PADAPTER_OBJECT)HalGetAdapter(&DeviceDescription, &NumberOfMapRegisters);

    if (AdapterObject == NULL)
       VideoDebugPrint((DISPLVL, "Miniport - HalGetAdapter failed.\n"));

    //
    // Request a common buffer.
    // The physical address of the common buffer will come back in 
    // logicalAddress
    //
    VirtualAddr = (void *)HalAllocateCommonBuffer( 
                AdapterObject,          // (IN)  Adapter object
                SIZE_BUS_MASTER_BUFFER, // (IN)  Length.
                &logicalAddress,        // (OUT) Phys address.        
                FALSE);                 // (IN)  Not cachable.

    //
    // Warn if we got back a NULL
    //                 
    if (VirtualAddr == NULL)
    {
        VideoDebugPrint((DISPLVL, 
            "Miniport - AllocCommonBuffer Virtual Addr Failed.\n"));
        return;
    }

    if ((logicalAddress.HighPart==0) && (logicalAddress.LowPart==0))
    {
        VideoDebugPrint((DISPLVL, 
            "Miniport - AllocCommonBuffer Physical Addr Failed.\n"));
        return;
    }

    //
    // CL5464 chip bug.  If bit 27 of the address is 0, it will
    // hose the chip.
    //
    if ( logicalAddress.LowPart & (1>>27) )
    {
        VideoDebugPrint((DISPLVL, 
          "Miniport - AllocCommonBuffer failed: Physical Addr bit 27 set.\n"));
        return;
    }

    //
    // Store the size and address of the common buffer.
    // Size != 0 will indicate success to the rest of the driver.
    //
    HwDeviceExtension->CommonBufferSize = SIZE_BUS_MASTER_BUFFER;
    HwDeviceExtension->VirtualCommonBufferAddr = (UCHAR*) VirtualAddr;
    HwDeviceExtension->PhysicalCommonBufferAddr = 
                                        (UCHAR*) logicalAddress.LowPart;

    VideoDebugPrint((DISPLVL, 
       "Miniport - Buffer is at HIGH: 0x%08X  LOW: 0x%08X  Virtual: 0x%08X\n",
        logicalAddress.HighPart, logicalAddress.LowPart, VirtualAddr));
 
    #endif // NO_BUS_MASTER
}


#if VS_CONTROL_HACK
// ****************************************************************************
//
// CLEnablePCIConfigMMIO()
// 
// Enables memory-mapped access to PCI configuration registers.
//
// ****************************************************************************
VP_STATUS CLEnablePCIConfigMMIO(
    PHW_DEVICE_EXTENSION    HwDeviceExtension
)
{
   ULONG VSCValue;
   ULONG ulTmp;

   // Get the current value of the VSC register       
   ulTmp = VideoPortGetBusData(
              HwDeviceExtension,
              PCIConfiguration,                     // bus data type
              HwDeviceExtension->SlotNumber,        // slot number
              &VSCValue,                            // buffer for returned data
              0xfc,                                 // VS Control offset
              4);                                   // 4 bytes

    if (ulTmp != 4)     // we only want 4 bytes back
    {
       return(ERROR_DEV_NOT_EXIST);
    }
    else
    {
       // Set bit to enable memory-mapped access to PCI configuration regs
       VSCValue |= 1;
       VideoPortSetBusData(
            HwDeviceExtension,
            PCIConfiguration,                       // bus data type
            HwDeviceExtension->SlotNumber,          // slot number
            &VSCValue,                              // value to set
            0xfc,                                   // VS Control offset
            4);                                     // 4 bytes

       return(NO_ERROR);
    }
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\laguna\mini\include\bltp.h ===
/**************************************************************************
***************************************************************************
*
*     Copyright (c) 1996, Cirrus Logic, Inc.
*                 All Rights Reserved
*
* FILE:         bltP.h
*
* DESCRIPTION:  Private declarations for DDraw blt code
*
* REVISION HISTORY:
*
* $Log:   X:\log\laguna\ddraw\inc\bltp.h  $
* 
*    Rev 1.11   06 Jan 1998 14:19:44   xcong
* Access pDriverData locally for multi-monitor support.
* 
*    Rev 1.10   03 Oct 1997 14:25:34   RUSSL
* Removed some defines
*
*    Rev 1.9   03 Oct 1997 14:15:58   RUSSL
* Initial changes for use of hw clipped blts
* All changes wrapped in #if ENABLE_CLIPPEDBLTS/#endif blocks and
* ENABLE_CLIPPEDBLTS defaults to 0 (so the code is disabled)
*
*    Rev 1.8   24 Jul 1997 10:02:00   RUSSL
* Added some defines
*
*    Rev 1.7   14 Jul 1997 14:47:28   RUSSL
* Added function prototypes for DIR_DrvStrBlt65 and DL_DrvStrBlt65
*
*    Rev 1.6   03 Apr 1997 15:03:08   RUSSL
* Added PFN_DRVDSTMBLT typedef, global var decl, DIR_DrvDstMBlt and
* DL_DrvDstMBlt function prototypes
*
*    Rev 1.5   26 Mar 1997 13:52:06   RUSSL
* Added PFN_DRVSRCMBLT typedef, global var decl, DIR_DrvSrcMBlt and
* DL_DrvSrcMBlt function prototypes
*
*    Rev 1.4   20 Jan 1997 14:46:40   bennyn
* Moved inline code to ddinline.h
*
*    Rev 1.3   15 Jan 1997 11:06:54   RUSSL
* Added global function ptr vars for Win95
* Moved inline functions from ddblt.c: DupColor, EnoughFifoForBlt & DupZFill
* Added function prototypes for TransparentStretch & StretchColor
*
*    Rev 1.2   05 Dec 1996 08:48:24   SueS
* Added real DD_LOG define for NT.
*
*    Rev 1.1   25 Nov 1996 16:12:42   bennyn
* Added #define DD_LOG for NT
*
*    Rev 1.0   25 Nov 1996 15:04:34   RUSSL
* Initial revision.
*
*    Rev 1.1   01 Nov 1996 13:01:42   RUSSL
* Merge WIN95 & WINNT code for Blt32
*
*    Rev 1.0   01 Nov 1996 09:28:16   BENNYN
* Initial revision.
*
*    Rev 1.0   25 Oct 1996 10:47:50   RUSSL
* Initial revision.
*
***************************************************************************
***************************************************************************/
// If WinNT 3.5 skip all the source code
#if defined WINNT_VER35      // WINNT_VER35

#else


#ifndef _BLTP_H_
#define _BLTP_H_

/***************************************************************************
* D E F I N E S
****************************************************************************/

#ifndef ENABLE_CLIPPEDBLTS
#ifdef WINNT_VER40
#define ENABLE_CLIPPEDBLTS    0
#else // Win95
#define ENABLE_CLIPPEDBLTS    0
#endif
#endif

#define ROP_OP0_copy    0xAA
#define ROP_OP1_copy    0xCC
#define ROP_OP2_copy    0xF0

#ifdef DEBUG
#define INLINE
#else
#define INLINE  __inline
#endif

/***************************************************************************
* T Y P E D E F S
****************************************************************************/

#ifdef WINNT_VER40
   // Note: there's no if LOG_CALLS here because it's not defined yet
   #define DD_LOG(x)      \
   {                      \
      DDFormatLogFile x ; \
      WriteLogFile(ppdev->pmfile, lg_buf, lg_i, ppdev->TxtBuff, &ppdev->TxtBuffIndex);	\
   }

typedef void (*PFN_DELAY9BLT)(struct _PDEV*,struct _DRIVERDATA*,BOOL);
typedef void (*PFN_EDGEFILLBLT)(struct _PDEV*,struct _DRIVERDATA*,int,int,int,int,DWORD,BOOL);
typedef void (*PFN_MEDGEFILLBLT)(struct _PDEV*,struct _DRIVERDATA*,int,int,int,int,DWORD,BOOL);
typedef void (*PFN_DRVDSTBLT)(struct _PDEV*,struct _DRIVERDATA*,DWORD,DWORD,DWORD,DWORD);
typedef void (*PFN_DRVDSTMBLT)(struct _PDEV*,struct _DRIVERDATA*,DWORD,DWORD,DWORD,DWORD);
typedef void (*PFN_DRVSRCBLT)(struct _PDEV*,struct _DRIVERDATA*,DWORD,DWORD,DWORD,DWORD,DWORD,DWORD);
typedef void (*PFN_DRVSRCMBLT)(struct _PDEV*,struct _DRIVERDATA*,DWORD,DWORD,DWORD,DWORD,DWORD,DWORD);
typedef void (*PFN_DRVSTRBLT)(struct _PDEV*,struct _DRIVERDATA*,struct _autoblt_regs*);
typedef void (*PFN_DRVSTRMBLT)(struct _PDEV*,struct _DRIVERDATA*,struct _autoblt_regs*);
typedef void (*PFN_DRVSTRMBLTY)(struct _PDEV*,struct _DRIVERDATA*,struct _autoblt_regs*);
typedef void (*PFN_DRVSTRMBLTX)(struct _PDEV*,struct _DRIVERDATA*,struct _autoblt_regs*);
typedef void (*PFN_DRVSTRBLTY)(struct _PDEV*,struct _DRIVERDATA*,struct _autoblt_regs*);
typedef void (*PFN_DRVSTRBLTX)(struct _PDEV*,struct _DRIVERDATA*,struct _autoblt_regs*);

#if ENABLE_CLIPPEDBLTS
typedef void (*PFN_CLIPPEDDRVDSTBLT)(struct _PDEV*,struct _DRIVERDATA*,DWORD,DWORD,DWORD,DWORD,DWORD,DWORD,LPRECT);
typedef void (*PFN_CLIPPEDDRVDSTMBLT)(struct _PDEV*,struct _DRIVERDATA*,DWORD,DWORD,DWORD,DWORD,DWORD,DWORD,LPRECT);
typedef void (*PFN_CLIPPEDDRVSRCBLT)(struct _PDEV*,struct _DRIVERDATA*,DWORD,DWORD,DWORD,DWORD,DWORD,DWORD,DWORD,DWORD,DWORD,LPRECT);
#endif

#else
typedef void (*PFN_DELAY9BLT)(LPGLOBALDATA,BOOL);
typedef void (*PFN_EDGEFILLBLT)(LPGLOBALDATA,int,int,int,int,DWORD,BOOL);
typedef void (*PFN_MEDGEFILLBLT)(LPGLOBALDATA,int,int,int,int,DWORD,BOOL);
typedef void (*PFN_DRVDSTBLT)(LPGLOBALDATA,DWORD,DWORD,DWORD,DWORD);
typedef void (*PFN_DRVDSTMBLT)(LPGLOBALDATA,DWORD,DWORD,DWORD,DWORD);
typedef void (*PFN_DRVSRCBLT)(LPGLOBALDATA,DWORD,DWORD,DWORD,DWORD,DWORD,DWORD);
typedef void (*PFN_DRVSRCMBLT)(LPGLOBALDATA,DWORD,DWORD,DWORD,DWORD,DWORD,DWORD);
typedef void (*PFN_DRVSTRBLT)(LPGLOBALDATA,autoblt_ptr);
typedef void (*PFN_DRVSTRMBLT)(LPGLOBALDATA,autoblt_ptr);
typedef void (*PFN_DRVSTRMBLTY)(LPGLOBALDATA,autoblt_ptr);
typedef void (*PFN_DRVSTRMBLTX)(LPGLOBALDATA,autoblt_ptr);
typedef void (*PFN_DRVSTRBLTY)(LPGLOBALDATA,autoblt_ptr);
typedef void (*PFN_DRVSTRBLTX)(LPGLOBALDATA,autoblt_ptr);

#if ENABLE_CLIPPEDBLTS
typedef void (*PFN_CLIPPEDDRVDSTBLT)(LPGLOBALDATA,DWORD,DWORD,DWORD,DWORD,DWORD,DWORD,LPRECT);
typedef void (*PFN_CLIPPEDDRVDSTMBLT)(LPGLOBALDATA,DWORD,DWORD,DWORD,DWORD,DWORD,DWORD,LPRECT);
typedef void (*PFN_CLIPPEDDRVSRCBLT)(LPGLOBALDATA,DWORD,DWORD,DWORD,DWORD,DWORD,DWORD,DWORD,DWORD,DWORD,LPRECT);
#endif

#endif  // !WINNT_VER40

#if ENABLE_CLIPPEDBLTS
typedef struct _DDRECTL
{
  REG32   loc;
  REG32   ext;
} DDRECTL;
#endif

/***************************************************************************
* G L O B A L   V A R I A B L E S
****************************************************************************/

#ifndef WINNT_VER40

extern PFN_DELAY9BLT    pfnDelay9BitBlt;
extern PFN_EDGEFILLBLT  pfnEdgeFillBlt;
extern PFN_MEDGEFILLBLT pfnMEdgeFillBlt;
extern PFN_DRVDSTBLT    pfnDrvDstBlt;
extern PFN_DRVDSTMBLT   pfnDrvDstMBlt;
extern PFN_DRVSRCBLT    pfnDrvSrcBlt;
extern PFN_DRVSRCMBLT   pfnDrvSrcMBlt;
extern PFN_DRVSTRBLT    pfnDrvStrBlt;
extern PFN_DRVSTRMBLT   pfnDrvStrMBlt;
extern PFN_DRVSTRMBLTY  pfnDrvStrMBltY;
extern PFN_DRVSTRMBLTX  pfnDrvStrMBltX;
extern PFN_DRVSTRBLTY   pfnDrvStrBltY;
extern PFN_DRVSTRBLTX   pfnDrvStrBltX;

#if ENABLE_CLIPPEDBLTS
extern PFN_CLIPPEDDRVDSTBLT   pfnClippedDrvDstBlt;
extern PFN_CLIPPEDDRVDSTMBLT  pfnClippedDrvDstMBlt;
extern PFN_CLIPPEDDRVSRCBLT   pfnClippedDrvSrcBlt;
#endif

#endif

/***************************************************************************
* F U N C T I O N   P R O T O T Y P E S
****************************************************************************/

// functions in ddblt.c
extern void TransparentStretch
(
#ifdef WINNT_VER40
  struct _PDEV        *ppdev,
  struct _DRIVERDATA  *lpDDHALData,
#else
  LPGLOBALDATA lpDDHALData,
#endif
  int   xDst,
  int   yDst,
  int   cxDst,
  int   cyDst,
  int   xSrc,
  int   ySrc,
  int   cxSrc,
  int   cySrc,
  DWORD ColorKey
);

extern void StretchColor
(
#ifdef WINNT_VER40
  struct _PDEV        *ppdev,
  struct _DRIVERDATA  *lpDDHALData,
#else
  LPGLOBALDATA lpDDHALData,
#endif
  int   xDst,
  int   yDst,
  int   cxDst,
  int   cyDst,
  int   xSrc,
  int   ySrc,
  int   cxSrc,
  int   cySrc,
  DWORD ColorKey
);

// Direct Programming blts in blt_dir.c
extern void DIR_Delay9BitBlt
(
#ifdef WINNT_VER40
  struct _PDEV        *ppdev,
  struct _DRIVERDATA  *lpDDHALData,
#else
  LPGLOBALDATA  lpDDHALData,
#endif
  BOOL        ninebit_on
);

extern void DIR_EdgeFillBlt
(
#ifdef WINNT_VER40
  struct _PDEV        *ppdev,
  struct _DRIVERDATA  *lpDDHALData,
#else
  LPGLOBALDATA  lpDDHALData,
#endif
  int         xFill,
  int         yFill,
  int         cxFill,
  int         cyFill,
  DWORD       FillValue,
  BOOL        ninebit_on
);

extern void DIR_MEdgeFillBlt
(
#ifdef WINNT_VER40
  struct _PDEV        *ppdev,
  struct _DRIVERDATA  *lpDDHALData,
#else
  LPGLOBALDATA  lpDDHALData,
#endif
  int         xFill,
  int         yFill,
  int         cxFill,
  int         cyFill,
  DWORD       FillValue,
  BOOL        ninebit_on
);

extern void DIR_DrvDstBlt
(
#ifdef WINNT_VER40
  struct _PDEV        *ppdev,
  struct _DRIVERDATA  *lpDDHALData,
#else
  LPGLOBALDATA  lpDDHALData,
#endif
  DWORD       dwDrawBlt,
  DWORD       dwDstCoord,
  DWORD       dwBgColor,
  DWORD       dwExtents
);

extern void DIR_DrvDstMBlt
(
#ifdef WINNT_VER40
  struct _PDEV        *ppdev,
  struct _DRIVERDATA  *lpDDHALData,
#else
  LPGLOBALDATA  lpDDHALData,
#endif
  DWORD       dwDrawBlt,
  DWORD       dwDstCoord,
  DWORD       dwBgColor,
  DWORD       dwExtents
);

extern void DIR_DrvSrcBlt
(
#ifdef WINNT_VER40
  struct _PDEV        *ppdev,
  struct _DRIVERDATA  *lpDDHALData,
#else
  LPGLOBALDATA  lpDDHALData,
#endif
  DWORD       dwDrawBlt,
  DWORD       dwDstCoord,
  DWORD       dwSrcCoord,
  DWORD       dwKeyCoord,
  DWORD       dwKeyColor,
  DWORD       dwExtents
);

extern void DIR_DrvSrcMBlt
(
#ifdef WINNT_VER40
  struct _PDEV        *ppdev,
  struct _DRIVERDATA  *lpDDHALData,
#else
  LPGLOBALDATA  lpDDHALData,
#endif
  DWORD       dwDrawBlt,
  DWORD       dwDstCoord,
  DWORD       dwSrcCoord,
  DWORD       dwKeyCoord,
  DWORD       dwKeyColor,
  DWORD       dwExtents
);

extern void DIR_DrvStrBlt
(
#ifdef WINNT_VER40
  struct _PDEV        *ppdev,
  struct _DRIVERDATA  *lpDDHALData,
  struct _autoblt_regs *pblt
#else
  LPGLOBALDATA  lpDDHALData,
  autoblt_ptr pblt
#endif
);

extern void DIR_DrvStrBlt65
(
#ifdef WINNT_VER40
  struct _PDEV        *ppdev,
  struct _DRIVERDATA  *lpDDHALData,
  struct _autoblt_regs *pblt
#else
  LPGLOBALDATA  lpDDHALData,
  autoblt_ptr pblt
#endif
);

extern void DIR_DrvStrMBlt
(
#ifdef WINNT_VER40
  struct _PDEV        *ppdev,
  struct _DRIVERDATA  *lpDDHALData,
  struct _autoblt_regs *pblt
#else
  LPGLOBALDATA  lpDDHALData,
  autoblt_ptr pblt
#endif
);

extern void DIR_DrvStrMBltY
(
#ifdef WINNT_VER40
  struct _PDEV        *ppdev,
  struct _DRIVERDATA  *lpDDHALData,
  struct _autoblt_regs *pblt
#else
  LPGLOBALDATA  lpDDHALData,
  autoblt_ptr pblt
#endif
);

extern void DIR_DrvStrMBltX
(
#ifdef WINNT_VER40
  struct _PDEV        *ppdev,
  struct _DRIVERDATA  *lpDDHALData,
  struct _autoblt_regs *pblt
#else
  LPGLOBALDATA  lpDDHALData,
  autoblt_ptr pblt
#endif
);

extern void DIR_DrvStrBltY
(
#ifdef WINNT_VER40
  struct _PDEV        *ppdev,
  struct _DRIVERDATA  *lpDDHALData,
  struct _autoblt_regs *pblt
#else
  LPGLOBALDATA  lpDDHALData,
  autoblt_ptr pblt
#endif
);

extern void DIR_DrvStrBltX
(
#ifdef WINNT_VER40
  struct _PDEV        *ppdev,
  struct _DRIVERDATA  *lpDDHALData,
  struct _autoblt_regs *pblt
#else
  LPGLOBALDATA  lpDDHALData,
  autoblt_ptr pblt
#endif
);

#if ENABLE_CLIPPEDBLTS
extern void DIR_HWClippedDrvDstBlt
(
#ifdef WINNT_VER40
  struct _PDEV        *ppdev,
  struct _DRIVERDATA  *lpDDHALData,
#else
  LPGLOBALDATA  lpDDHALData,
#endif
  DWORD       dwDrawBlt,
  DWORD       dwDstCoord,
  DWORD       dwBgColor,
  DWORD       dwExtents,
  DWORD       dwDstBaseXY,
  DWORD       dwRectCnt,
  LPRECT      pDestRects
);

extern void DIR_HWClippedDrvDstMBlt
(
#ifdef WINNT_VER40
  struct _PDEV        *ppdev,
  struct _DRIVERDATA  *lpDDHALData,
#else
  LPGLOBALDATA  lpDDHALData,
#endif
  DWORD       dwDrawBlt,
  DWORD       dwDstCoord,
  DWORD       dwBgColor,
  DWORD       dwExtents,
  DWORD       dwDstBaseXY,
  DWORD       dwRectCnt,
  LPRECT      pDestRects
);

extern void DIR_HWClippedDrvSrcBlt
(
#ifdef WINNT_VER40
  struct _PDEV        *ppdev,
  struct _DRIVERDATA  *lpDDHALData,
#else
  LPGLOBALDATA  lpDDHALData,
#endif
  DWORD       dwDrawBlt,
  DWORD       dwDstCoord,
  DWORD       dwSrcCoord,
  DWORD       dwKeyCoord,
  DWORD       dwKeyColor,
  DWORD       dwExtents,
  DWORD       dwDstBaseXY,
  DWORD       dwSrcBaseXY,
  DWORD       dwRectCnt,
  LPRECT      pDestRects
);
extern void DIR_SWClippedDrvDstBlt
(
#ifdef WINNT_VER40
  struct _PDEV        *ppdev,
  struct _DRIVERDATA  *lpDDHALData,
#else
  LPGLOBALDATA  lpDDHALData,
#endif
  DWORD       dwDrawBlt,
  DWORD       dwDstCoord,
  DWORD       dwBgColor,
  DWORD       dwExtents,
  DWORD       dwDstBaseXY,
  DWORD       dwRectCnt,
  LPRECT      pDestRects
);

extern void DIR_SWClippedDrvDstMBlt
(
#ifdef WINNT_VER40
  struct _PDEV        *ppdev,
  struct _DRIVERDATA  *lpDDHALData,
#else
  LPGLOBALDATA  lpDDHALData,
#endif
  DWORD       dwDrawBlt,
  DWORD       dwDstCoord,
  DWORD       dwBgColor,
  DWORD       dwExtents,
  DWORD       dwDstBaseXY,
  DWORD       dwRectCnt,
  LPRECT      pDestRects
);

extern void DIR_SWClippedDrvSrcBlt
(
#ifdef WINNT_VER40
  struct _PDEV        *ppdev,
  struct _DRIVERDATA  *lpDDHALData,
#else
  LPGLOBALDATA  lpDDHALData,
#endif
  DWORD       dwDrawBlt,
  DWORD       dwDstCoord,
  DWORD       dwSrcCoord,
  DWORD       dwKeyCoord,
  DWORD       dwKeyColor,
  DWORD       dwExtents,
  DWORD       dwDstBaseXY,
  DWORD       dwSrcBaseXY,
  DWORD       dwRectCnt,
  LPRECT      pDestRects
);
#endif

// Display List Programming blts in blt_dl.c
extern void DL_Delay9BitBlt
(
#ifdef WINNT_VER40
  struct _PDEV        *ppdev,
  struct _DRIVERDATA  *lpDDHALData,
#else
  LPGLOBALDATA  lpDDHALData,
#endif
  BOOL        ninebit_on
);

extern void DL_EdgeFillBlt
(
#ifdef WINNT_VER40
  struct _PDEV        *ppdev,
  struct _DRIVERDATA  *lpDDHALData,
#else
  LPGLOBALDATA  lpDDHALData,
#endif
  int         xFill,
  int         yFill,
  int         cxFill,
  int         cyFill,
  DWORD       FillValue,
  BOOL        ninebit_on
);

extern void DL_MEdgeFillBlt
(
#ifdef WINNT_VER40
  struct _PDEV        *ppdev,
  struct _DRIVERDATA  *lpDDHALData,
#else
  LPGLOBALDATA  lpDDHALData,
#endif
  int         xFill,
  int         yFill,
  int         cxFill,
  int         cyFill,
  DWORD       FillValue,
  BOOL        ninebit_on
);

extern void DL_DrvDstBlt
(
#ifdef WINNT_VER40
  struct _PDEV        *ppdev,
  struct _DRIVERDATA  *lpDDHALData,
#else
  LPGLOBALDATA  lpDDHALData,
#endif
  DWORD       dwDrawBlt,
  DWORD       dwDstCoord,
  DWORD       dwBgColor,
  DWORD       dwExtents
);

extern void DL_DrvDstMBlt
(
#ifdef WINNT_VER40
  struct _PDEV        *ppdev,
  struct _DRIVERDATA  *lpDDHALData,
#else
  LPGLOBALDATA  lpDDHALData,
#endif
  DWORD       dwDrawBlt,
  DWORD       dwDstCoord,
  DWORD       dwBgColor,
  DWORD       dwExtents
);

extern void DL_DrvSrcBlt
(
#ifdef WINNT_VER40
  struct _PDEV        *ppdev,
  struct _DRIVERDATA  *lpDDHALData,
#else
  LPGLOBALDATA  lpDDHALData,
#endif
  DWORD       dwDrawBlt,
  DWORD       dwDstCoord,
  DWORD       dwSrcCoord,
  DWORD       dwKeyCoord,
  DWORD       dwKeyColor,
  DWORD       dwExtents
);

extern void DL_DrvSrcMBlt
(
#ifdef WINNT_VER40
  struct _PDEV        *ppdev,
  struct _DRIVERDATA  *lpDDHALData,
#else
  LPGLOBALDATA  lpDDHALData,
#endif
  DWORD       dwDrawBlt,
  DWORD       dwDstCoord,
  DWORD       dwSrcCoord,
  DWORD       dwKeyCoord,
  DWORD       dwKeyColor,
  DWORD       dwExtents
);

extern void DL_DrvStrBlt
(
#ifdef WINNT_VER40
  struct _PDEV        *ppdev,
  struct _DRIVERDATA  *lpDDHALData,
  struct _autoblt_regs *pblt
#else
  LPGLOBALDATA  lpDDHALData,
  autoblt_ptr pblt
#endif
);

extern void DL_DrvStrBlt65
(
#ifdef WINNT_VER40
  struct _PDEV        *ppdev,
  struct _DRIVERDATA  *lpDDHALData,
  struct _autoblt_regs *pblt
#else
  LPGLOBALDATA  lpDDHALData,
  autoblt_ptr pblt
#endif
);

extern void DL_DrvStrMBlt
(
#ifdef WINNT_VER40
  struct _PDEV        *ppdev,
  struct _DRIVERDATA  *lpDDHALData,
  struct _autoblt_regs *pblt
#else
  LPGLOBALDATA  lpDDHALData,
  autoblt_ptr pblt
#endif
);

extern void DL_DrvStrMBltY
(
#ifdef WINNT_VER40
  struct _PDEV        *ppdev,
  struct _DRIVERDATA  *lpDDHALData,
  struct _autoblt_regs *pblt
#else
  LPGLOBALDATA  lpDDHALData,
  autoblt_ptr pblt
#endif
);

extern void DL_DrvStrMBltX
(
#ifdef WINNT_VER40
  struct _PDEV        *ppdev,
  struct _DRIVERDATA  *lpDDHALData,
  struct _autoblt_regs *pblt
#else
  LPGLOBALDATA  lpDDHALData,
  autoblt_ptr pblt
#endif
);

extern void DL_DrvStrBltY
(
#ifdef WINNT_VER40
  struct _PDEV        *ppdev,
  struct _DRIVERDATA  *lpDDHALData,
  struct _autoblt_regs *pblt
#else
  LPGLOBALDATA  lpDDHALData,
  autoblt_ptr pblt
#endif
);

extern void DL_DrvStrBltX
(
#ifdef WINNT_VER40
  struct _PDEV        *ppdev,
  struct _DRIVERDATA  *lpDDHALData,
  struct _autoblt_regs *pblt
#else
  LPGLOBALDATA  lpDDHALData,
  autoblt_ptr pblt
#endif
);

#if ENABLE_CLIPPEDBLTS
extern void DL_HWClippedDrvDstBlt
(
#ifdef WINNT_VER40
  struct _PDEV        *ppdev,
  struct _DRIVERDATA  *lpDDHALData,
#else
  LPGLOBALDATA  lpDDHALData,
#endif
  DWORD       dwDrawBlt,
  DWORD       dwDstCoord,
  DWORD       dwBgColor,
  DWORD       dwExtents,
  DWORD       dwDstBaseXY,
  DWORD       dwRectCnt,
  LPRECT      pDestRects
);

extern void DL_HWClippedDrvDstMBlt
(
#ifdef WINNT_VER40
  struct _PDEV        *ppdev,
  struct _DRIVERDATA  *lpDDHALData,
#else
  LPGLOBALDATA  lpDDHALData,
#endif
  DWORD       dwDrawBlt,
  DWORD       dwDstCoord,
  DWORD       dwBgColor,
  DWORD       dwExtents,
  DWORD       dwDstBaseXY,
  DWORD       dwRectCnt,
  LPRECT      pDestRects
);

extern void DL_HWClippedDrvSrcBlt
(
#ifdef WINNT_VER40
  struct _PDEV        *ppdev,
  struct _DRIVERDATA  *lpDDHALData,
#else
  LPGLOBALDATA  lpDDHALData,
#endif
  DWORD       dwDrawBlt,
  DWORD       dwDstCoord,
  DWORD       dwSrcCoord,
  DWORD       dwKeyCoord,
  DWORD       dwKeyColor,
  DWORD       dwExtents,
  DWORD       dwDstBaseXY,
  DWORD       dwSrcBaseXY,
  DWORD       dwRectCnt,
  LPRECT      pDestRects
);
extern void DL_SWClippedDrvDstBlt
(
#ifdef WINNT_VER40
  struct _PDEV        *ppdev,
  struct _DRIVERDATA  *lpDDHALData,
#else
  LPGLOBALDATA  lpDDHALData,
#endif
  DWORD       dwDrawBlt,
  DWORD       dwDstCoord,
  DWORD       dwBgColor,
  DWORD       dwExtents,
  DWORD       dwDstBaseXY,
  DWORD       dwRectCnt,
  LPRECT      pDestRects
);

extern void DL_SWClippedDrvDstMBlt
(
#ifdef WINNT_VER40
  struct _PDEV        *ppdev,
  struct _DRIVERDATA  *lpDDHALData,
#else
  LPGLOBALDATA  lpDDHALData,
#endif
  DWORD       dwDrawBlt,
  DWORD       dwDstCoord,
  DWORD       dwBgColor,
  DWORD       dwExtents,
  DWORD       dwDstBaseXY,
  DWORD       dwRectCnt,
  LPRECT      pDestRects
);

extern void DL_SWClippedDrvSrcBlt
(
#ifdef WINNT_VER40
  struct _PDEV        *ppdev,
  struct _DRIVERDATA  *lpDDHALData,
#else
  LPGLOBALDATA  lpDDHALData,
#endif
  DWORD       dwDrawBlt,
  DWORD       dwDstCoord,
  DWORD       dwSrcCoord,
  DWORD       dwKeyCoord,
  DWORD       dwKeyColor,
  DWORD       dwExtents,
  DWORD       dwDstBaseXY,
  DWORD       dwSrcBaseXY,
  DWORD       dwRectCnt,
  LPRECT      pDestRects
);
#endif

#endif /* _BLTP_H_ */
#endif // WINNT_VER35
/* Don't write below this endif */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\laguna\mini\include\clioctl.h ===
/****************************************************************************
*****************************************************************************
*
*                ******************************************
*                * Copyright (c) 1995, Cirrus Logic, Inc. *
*                *            All Rights Reserved         *
*                ******************************************
*
* PROJECT:	Laguna I (CL-GD5462) - 
*
* FILE:		clioctl.h
*
* AUTHOR:   Benny Ng
*
* DESCRIPTION:
*           This module contains the definitions of IOCTL commands
*           between the NT miniport and the display.
*
* MODULES:
*
* REVISION HISTORY:
*  $Log:   X:/log/laguna/nt35/displays/cl546x/CLIOCTL.H  $
* 
*    Rev 1.14   Mar 25 1998 17:56:54   frido
* Added IOCTL_STALL.
* 
*    Rev 1.13   Dec 10 1997 13:24:54   frido
* Merged from 1.62 branch.
* 
*    Rev 1.12.1.0   Nov 10 1997 11:25:14   phyang
* Added 5 IOCTL code for utilities to update registry values.
* 
*    Rev 1.12   Nov 03 1997 16:44:24   phyang
* Added IOCTL_GET_AGPDATASTREAMING.
* 
*    Rev 1.11   28 Aug 1997 15:16:06   noelv
* 
* Merged with miniport CLIOCTL.H.  Now we only use this one.
* 
*    Rev 1.10   23 Jul 1997 09:18:30   bennyn
* 
* Added IOCTL_GET_BIOS_VERSION
* 
*    Rev 1.9   21 Jul 1997 16:21:06   bennyn
* Added IOCTL for getting EDID data
* 
*    Rev 1.8   20 Jun 1997 13:33:18   bennyn
* 
* Added power manager data structure and #define
* 
*    Rev 1.7   23 Apr 1997 07:38:26   SueS
* Added IOCTL for enabling memory-mapped I/O access to PCI
* configuration registers.
* 
*    Rev 1.6   21 Mar 1997 13:41:20   noelv
* Combined LOG_CALLS, LOG_WRITES and LOG_QFREE into ENABLE_LOG_FILE
* 
*    Rev 1.5   18 Mar 1997 09:28:58   bennyn
* Added Intel DPMS support
* 
*    Rev 1.4   26 Nov 1996 10:15:24   SueS
* Added IOCTL for closing the log file.
* 
*    Rev 1.3   13 Nov 1996 17:06:58   SueS
* Added two IOCTL codes for notifying the miniport driver on
* file logging functions.
*   11/16/95     Benny Ng      Initial version
*
****************************************************************************
****************************************************************************/


//---------------------------------------------------------------------------
//
// The following macro(CTL_CODE) is defined in WINIOCTL.H. That file states
// that functions 2048-4095 are reserved for "customers". So I picked an 
// arbitrary value of 0x900=2304. 
//
#define CIRRUS_ESCAPE_FUNCTION    0x5000   // for Intel DPMS

#define IOCTL_CL_STRING_DISPLAY \
    CTL_CODE(FILE_DEVICE_VIDEO, 0x900, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_CL_GET_COMMON_BUFFER \
    CTL_CODE(FILE_DEVICE_VIDEO, 0x902, METHOD_BUFFERED, FILE_ANY_ACCESS)

#if ENABLE_LOG_FILE
  #define IOCTL_CL_CREATE_LOG_FILE \
    CTL_CODE(FILE_DEVICE_VIDEO, 0x903, METHOD_BUFFERED, FILE_ANY_ACCESS)

  #define IOCTL_CL_WRITE_LOG_FILE \
    CTL_CODE(FILE_DEVICE_VIDEO, 0x904, METHOD_BUFFERED, FILE_ANY_ACCESS)

  #define IOCTL_CL_CLOSE_LOG_FILE \
    CTL_CODE(FILE_DEVICE_VIDEO, 0x905, METHOD_BUFFERED, FILE_ANY_ACCESS)
#endif

  #define IOCTL_VIDEO_ENABLE_PCI_MMIO \
    CTL_CODE(FILE_DEVICE_VIDEO, 0x906, METHOD_BUFFERED, FILE_ANY_ACCESS)

  #define IOCTL_SET_HW_MODULE_POWER_STATE \
    CTL_CODE(FILE_DEVICE_VIDEO, 0x907, METHOD_BUFFERED, FILE_ANY_ACCESS)

  #define IOCTL_GET_HW_MODULE_POWER_STATE \
    CTL_CODE(FILE_DEVICE_VIDEO, 0x908, METHOD_BUFFERED, FILE_ANY_ACCESS)

  #define IOCTL_GET_BIOS_VERSION \
    CTL_CODE(FILE_DEVICE_VIDEO, 0x90A, METHOD_BUFFERED, FILE_ANY_ACCESS)

  #define IOCTL_GET_AGPDATASTREAMING \
    CTL_CODE(FILE_DEVICE_VIDEO, 0x90B, METHOD_BUFFERED, FILE_ANY_ACCESS)

  #define IOCTL_STALL \
    CTL_CODE(FILE_DEVICE_VIDEO, 0x911, METHOD_BUFFERED, FILE_ANY_ACCESS)

// =====================================================================
// Define structure used for power manager
// =====================================================================
#ifndef __LGPWRMGR_H__
#define __LGPWRMGR_H__

#define  ENABLE           0x1
#define  DISABLE          0x0

#define  ACPI_D0          0x0
#define  ACPI_D1          0x1
#define  ACPI_D2          0x2
#define  ACPI_D3          0x3
#define  TOTAL_ACPI       4

#define  MOD_2D           0x0
#define  MOD_STRETCH      0x1
#define  MOD_3D           0x2
#define  MOD_EXTMODE      0x3
#define  MOD_VGA          0x4
#define  MOD_RAMDAC       0x5
#define  MOD_VPORT        0x6
#define  MOD_VW           0x7
#define  MOD_TVOUT        0x8
#define  TOTAL_MOD        MOD_TVOUT+1

typedef struct _LGPM_IN_STRUCT {
    ULONG arg1;
    ULONG arg2;
} LGPM_IN_STRUCT, *PLGPM_IN_STRUCT;

typedef struct _LGPM_OUT_STRUCT {
    BOOL  status;
    ULONG retval;
} LGPM_OUT_STRUCT, *PLGPM_OUT_STRUCT;

#endif  // #ifndef __LGPWRMGR_H__

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\laguna\mini\include\cirrus.h ===
/****************************************************************************
*****************************************************************************
*
*                ******************************************
*                * Copyright (c) 1995, Cirrus Logic, Inc. *
*                *            All Rights Reserved         *
*                ******************************************
*
* PROJECT:	Laguna I (CL-GD5462) - 
*
* FILE:		cirrus.h
*
* AUTHOR:   Benny Ng
*
* DESCRIPTION:
*           This module contains the definitions for the Cirrus
*           Logic Laguna NT miniport driver. (kernel mode only)
*           Based on the S3 miniport from NT DDK.
*
*   Copyright (c) 1995, 1996 Cirrus Logic, Inc.
*
* MODULES:
*
* REVISION HISTORY:
*   5/30/95     Benny Ng      Initial version
*
* $Log:   X:/log/laguna/nt35/miniport/cl546x/CIRRUS.H  $
* 
*    Rev 1.46   Apr 20 1998 10:48:56   frido
* Oops. I missed a semi colon.
* 
*    Rev 1.45   Apr 20 1998 10:47:02   frido
* PDR#11350. Added CLResetHw prototype.
* 
*    Rev 1.44   Mar 25 1998 10:17:14   frido
* Added CLGetMonitorSyncPolarity function declaration.
* 
*    Rev 1.43   Mar 25 1998 10:08:40   frido
* Added dwPolarity field to HW_DEVICE_EXTENSION structure.
* 
*    Rev 1.42   Feb 24 1998 15:10:38   frido
* Added GetDDCInformation for NT 5.0.
* 
*    Rev 1.41   Feb 18 1998 14:16:28   frido
* PDR#11209. Added status to ReadByte.
* 
*    Rev 1.40   Jan 22 1998 11:10:18   frido
* Added dwFBMTTRReg variable for Write Combining on i386.
* 
*    Rev 1.39   Jan 07 1998 10:55:52   frido
* Added fLowRes field.
* 
*    Rev 1.38   Nov 03 1997 16:46:20   phyang
* Added data and function declarations for USB Fix and better EDID support.
* 
*    Rev 1.37   Oct 23 1997 15:50:42   phyang
* Moved globals for DDC filter function to HW_DEVICE_EXTENSION.
* 
*    Rev 1.36   23 Oct 1997 11:18:04   noelv
* 
* Added globals for DDC filter function.
* 
*    Rev 1.35   04 Sep 1997 11:35:04   bennyn
* Extended the register space from 8000h to A000h
* 
*    Rev 1.34   28 Aug 1997 17:13:08   noelv
* Added Setmode prototype.
* 
*    Rev 1.33   20 Aug 1997 09:31:36   bennyn
* 
* Added automatically detects PnP monitor support
* 
*    Rev 1.32   13 Aug 1997 11:22:14   noelv
* Added [5465AD] setcion to MODE.INI
* 
*    Rev 1.31   01 Aug 1997 16:29:56   noelv
* Removed BIOS and VGA from IOCTL_VIDEO_RESET_DEVICE
* 
*    Rev 1.30   23 Jul 1997 09:12:00   bennyn
* 
* Added BIOSVersion into HwDeviceExtension structure
* 
*    Rev 1.29   21 Jul 1997 13:51:10   bennyn
* 
* Added EDID data into HwDeviceExtension structure
* 
*    Rev 1.28   20 Jun 1997 13:44:02   bennyn
* 
* Added power manager data to HW Extension structure
* 
*    Rev 1.27   30 Apr 1997 16:42:04   noelv
* Moved global SystemIoBusNumber into the device extension, where it belongs.
* 
*    Rev 1.26   24 Apr 1997 10:09:22   SueS
* Added prototype for CLEnablePCIConfigMMIO.
* 
*    Rev 1.25   23 Apr 1997 06:58:42   SueS
* Added PCI slot number to HW_DEVICE_EXTENSION structure.  Added function
* prototypes for some kernel calls.
* 
*    Rev 1.24   22 Apr 1997 11:02:02   noelv
* 
* Added forward compatible chip ids.
* 
*    Rev 1.23   04 Apr 1997 14:46:44   noelv
* Removed VL access ranges.  REarranged VGA access ranges.
* Changed call to SetMode() to include the new parameter.
* 
*    Rev 1.22   28 Feb 1997 11:20:44   SueS
* Added structures and defines used in HalGetAdapter call.
* 
*    Rev 1.21   21 Feb 1997 14:41:32   noelv
* Oops.  I swapped the frame buffer and register address spaces by accident.
* 
*    Rev 1.20   21 Feb 1997 12:53:24   noelv
* AGP and 5465 4meg support
* 
*    Rev 1.19   21 Jan 1997 11:29:48   noelv
* Added LG_NONE
* 
*    Rev 1.18   14 Jan 1997 12:31:42   noelv
* Split MODE.INI by chip type
* 
*    Rev 1.17   14 Nov 1996 15:27:00   noelv
* 
* Removed warning for HalAllocCommonBuffer
* 
*    Rev 1.16   13 Nov 1996 15:24:14   SueS
* Added new include file for use with log file option.
* 
*    Rev 1.15   13 Nov 1996 08:17:48   noelv
* 
* Cleaned up support for 5464 register set.
* 
*    Rev 1.14   07 Nov 1996 09:40:26   bennyn
* Added device ID for BD and 5465
* 
*    Rev 1.13   23 Oct 1996 15:59:34   noelv
* Added bus mastering stuff.
* 
*    Rev 1.12   21 Aug 1996 10:11:46   noelv
* Added defines for chip ids
* 
*    Rev 1.11   20 Aug 1996 11:26:40   noelv
* Bugfix release from Frido 8-19-96
* 
*    Rev 1.1   15 Aug 1996 12:45:28   frido
* Added #include 'type.h".
* Added prototype for SetMode() function.
* 
*    Rev 1.0   14 Aug 1996 17:12:10   frido
* Initial revision.
* 
*    Rev 1.10   17 Jul 1996 09:42:20   noelv
* Fixed location of STATUS register.
* 
*    Rev 1.9   15 Jul 1996 17:18:24   noelv
* Added wait for idle before mode switch
* 
*    Rev 1.8   19 Jun 1996 11:04:10   noelv
* New mode switch code.
* 
*    Rev 1.7   13 May 1996 14:52:54   bennyn
* 
* Added 5464 support
* 
*    Rev 1.6   10 Apr 1996 17:58:06   bennyn
* Conditional turn of HD_BRST_EN
* 
*    Rev 1.5   02 Mar 1996 12:30:46   noelv
* Miniport now patches the ModeTable with information read from the BIOS
* 
*    Rev 1.4   07 Dec 1995 16:33:10   noelv
* Changed MAX_SLOTS to 32
* 
*    Rev 1.3   18 Sep 1995 10:02:26   bennyn
* 
*    Rev 1.2   23 Aug 1995 14:45:26   bennyn
* 
*    Rev 1.1   17 Aug 1995 08:18:08   BENNYN
* 
* 
*    Rev 1.0   24 Jul 1995 13:22:54   NOELV
* Initial revision.
*
****************************************************************************
****************************************************************************/

/*----------------------------- INCLUDES ----------------------------------*/
#include <dderror.h>
#include <devioctl.h>
#include <miniport.h>

#include <ntddvdeo.h>
#include <video.h>

#include "logfile.h"
#include "type.h"
#include "clioctl.h"

/*----------------------------- DEFINES -----------------------------------*/
//
// Vendor and Device ID definitions
//
#define  VENDOR_ID       0x1013     // Vender Id for Cirrus Logic

#define  CL_GD5462       0x00D0     // 5462
#define  CL_GD5464       0x00D4     // 5464
#define  CL_GD5464_BD    0x00D5     // 5464 BD
#define  CL_GD5465       0x00D6     // 5465

// 
// These Laguna chips don't exist yet, but we'll support them when 
// they get here, 'cause we're FORWARD COMPATIBLE!  All future
// chips are GUARENTEED to look and act just like the 5465.
// Yep, yep, yep!  (sigh.)
//
#define CL_GD546x_D7    0x00D7
#define CL_GD546x_D8    0x00D8
#define CL_GD546x_D9    0x00D9
#define CL_GD546x_DA    0x00DA
#define CL_GD546x_DB    0x00DB
#define CL_GD546x_DC    0x00DC
#define CL_GD546x_DD    0x00DD
#define CL_GD546x_DE    0x00DE
#define CL_GD546x_DF    0x00DF


//
// I'm preparing to rip all the VGA out of the miniport.
// This flag is to allow me to get it right the 
// first time.
//
#define USE_VGA 1


//
// How much memory to lock down for bus mastered host data transfers
//
#define SIZE_BUS_MASTER_BUFFER (4*1024)

//
// Default mode: VGA mode 3
//
#define DEFAULT_MODE                0

//
// Laguna memory-mapped registers
//
#define STATUS_REG		            0x400
#define VSCONTROL_REG               0x3FC
#define CONTROL_REG                 0x402
#define OFFSET_2D_REG               0x405
#define TILE_CTRL_REG               0x407
#define LNCNTL_REG                  0x50E

//
// PCI memory-mapped registers
//
#define PCI_COMMAND_REG             0x304
#define PCI_BASE_ADDR_0_REG         0x0310  // Base Address 0 register
#define PCI_BASE_ADDR_1_REG         0x0314  // Base Address 1 register

//
// Number of PCI slots in a machine.
//
#define MAX_SLOTS                   256 


//
// Number of access ranges used by the Laguna.
//
#if USE_VGA
    #define FIRST_VGA_ACCESS_RANGE	     0
    #define LAST_VGA_ACCESS_RANGE	     2
    #define NUM_VGA_ACCESS_RANGES        3

    #define FIRST_MM_ACCESS_RANGE	     3
    #define LAST_MM_ACCESS_RANGE	     4
    #define NUM_MM_ACCESS_RANGES         2

    #define MM_REGISTER_ACCESS_RANGE     3
    #define MM_FRAME_BUFFER_ACCESS_RANGE 4

    #define TOTAL_ACCESS_RANGES         NUM_VGA_ACCESS_RANGES + NUM_MM_ACCESS_RANGES
#else
    #define FIRST_VGA_ACCESS_RANGE	     0
    #define LAST_VGA_ACCESS_RANGE	     2
    #define NUM_VGA_ACCESS_RANGES        3

    #define FIRST_MM_ACCESS_RANGE	     3
    #define LAST_MM_ACCESS_RANGE	     4
    #define NUM_MM_ACCESS_RANGES         2

    #define MM_REGISTER_ACCESS_RANGE     3
    #define MM_FRAME_BUFFER_ACCESS_RANGE 4

    #define TOTAL_ACCESS_RANGES         NUM_VGA_ACCESS_RANGES + NUM_MM_ACCESS_RANGES
#endif

//
// If we don't know how much register space the chip decodes, we guess
//
#define DEFAULT_RESERVED_REGISTER_SPACE     0xA000 
#define DEFAULT_RESERVED_REGISTER_MASK      0xFFFF8000  // 32 k

//
// If we don't know how much frame buffer space the chip decodes, we guess
//
#define DEFAULT_RESERVED_FB_SPACE           0x02000000 // 32 meg
#define DEFAULT_RESERVED_FB_MASK            0xFE000000 // 32 meg


//
// Palette-related info.
// Highest valid DAC color register index.
//
#define VIDEO_MAX_COLOR_REGISTER    0xFF

#if USE_VGA
    //
    // Register definitions used with VideoPortRead/Write functions
    // VGA IO index
    //
    #define SEQ_ADDRESS_PORT            0x0014  // Sequence Controller Address
    #define SEQ_DATA_PORT               0x0015  // Sequence Controller Data register
    #define IND_SR_6                    0x0006  // Index in Sequencer to enable exts
    #define IND_SR_9                    0x0009  // Scratch pad register SR9
    #define IND_SR_14                   0x0014  // Scratch pad register SR14

    #define CRTC_ADDRESS_PORT_MONO      0x0004  // Mono mode CRTC Address
    #define CRTC_DATA_PORT_MONO         0x0005  // Mono mode CRTC Data register
    #define CRTC_ADDRESS_PORT_COLOR     0x0024  // Color mode CRTC Address
    #define CRTC_DATA_PORT_COLOR        0x0025  // Color mode CRTC Data register
    #define IND_CL_ID_REG               0x0027  // index in CRTC of ID Register
#endif

//
// Register definitions used with VideoPortRead/Write functions
// Memory-mapped IO index
//
#define DAC_PIXEL_MASK_PORT         0x00A0  // DAC pixel mask reg
#define DAC_ADDRESS_WRITE_PORT      0x00A8  // DAC register write index reg
#define DAC_DATA_REG_PORT           0x00AC  // DAC data transfer reg
#define MISC_OUTPUT_REG_READ_PORT   0x0080  // Misc Output reg read port


//
// Define the supported version numbers for the device description structure.
//
#define DEVICE_DESCRIPTION_VERSION  0
#define DEVICE_DESCRIPTION_VERSION1 1


//
// Define the page size for the Intel 386 as 4096 (0x1000).
//
#define PAGE_SIZE (ULONG)0x1000


//
// Define the index of max.frequency table for each resolution.
//
#define MODE_640_INDEX		0
#define MODE_720_INDEX		1
#define MODE_800_INDEX		2
#define MODE_832_INDEX		3
#define MODE_1024_INDEX		4
#define MODE_1152_INDEX		5
#define MODE_1280_INDEX		6
#define MODE_1600_INDEX		7
#define INVALID_MODE_INDEX	8


//
// bios stuff
//
#define VESA_POWER_FUNCTION 0x4f10
#define VESA_POWER_ON       0x0000
#define VESA_POWER_STANDBY  0x0100
#define VESA_POWER_SUSPEND  0x0200
#define VESA_POWER_OFF      0x0400
#define VESA_GET_POWER_FUNC 0x0000
#define VESA_SET_POWER_FUNC 0x0001
#define VESA_STATUS_SUCCESS 0x004f

/*----------------------------- TYPEDEFS ----------------------------------*/
//
// Used to pass information about the common buffer from the miniport to the display driver.
//

typedef struct _COMMON_BUFFER_INFO {
    PUCHAR PhysAddress;
    PUCHAR VirtAddress;
    ULONG  Length;
} COMMON_BUFFER_INFO;


//
// Mode table structure
// Structure used for the mode table informations
//
typedef struct {
   BOOLEAN  ValidMode;        // TRUE: Mode is valid.
   ULONG    ChipType;         // Chips which support this mode.
   USHORT   fbType;           // color or monochrome, text or graphics,
                              // via VIDEO_MODE_COLOR and VIDEO_MODE_GRAPHICS
                              // and interlace or non-interlace via
                              // VIDEO_MODE_INTERLACED

   USHORT   Frequency;        // Frequency
   USHORT   BIOSModeNum;      // BIOS Mode number

   USHORT   BytesPerScanLine; // Bytes Per Scan Line
   USHORT   XResol;           // Horizontal resolution in pixels or char
   USHORT   YResol;           // Vertical  resolution in pixels or char
   UCHAR    XCharSize;        // Char cell width  in pixels
   UCHAR    YCharSize;        // Char cell height in pixels
   UCHAR    NumOfPlanes;      // Number of memory planes
   UCHAR    BitsPerPixel;     // Bits per pixel
   UCHAR    MonitorTypeVal;   // Monitor type setting bytes
   UCHAR    *SetModeString;   // Instruction string used by SetMode().

} MODETABLE, *PMODETABLE;

//
// Valid flags for ChipType field.
// Must match defines in CGLMODE.C
//
#define LG_NONE   (0     )
#define LG_ALL    (1     )
#define LG_5462   (1 << 1)
#define LG_5464   (1 << 2)
#define LG_5465   (1 << 3)
#define LG_5465AD (1 << 4)

#define ALWAY_ON_VS_CLK_CTL    0x0000C0A0  // VW_CLK, RAMDAC_CLK

typedef struct _LG_PWRMGR_DATA {
  WORD   wInitSignature;
  int    Mod_refcnt[TOTAL_MOD];
  DWORD  ACPI_state;
  DWORD  VS_clk_ctl_state;
} LGPWRMGR_DATA, *P_LGPWRMGR_DATA;


//
// Define device extension structure. This is device dependent/private
// information.
//
typedef struct _HW_DEVICE_EXTENSION {
   LGPWRMGR_DATA PMdata;            // Power manager data area

   #if USE_VGA
   PUCHAR IOAddress;                // base I/O address of VGA ports.
   #endif

   PUCHAR FrameAddress;             // base virtual address of video memory
   ULONG  FrameLength;

   PUCHAR RegisterAddress;          // base virtual address of Register Space
   ULONG  RegisterLength;

   PHYSICAL_ADDRESS PhysicalFrameAddress;
   ULONG PhysicalFrameLength;
   UCHAR PhysicalFrameInIoSpace;

   PHYSICAL_ADDRESS PhysicalRegisterAddress;
   ULONG PhysicalRegisterLength;
   UCHAR PhysicalRegisterInIoSpace;
   DWORD dwFBMTRRReg;

   ULONG AdapterMemorySize;         // Installed RAM

   ULONG CurrentModeNum;            // Current Mode Number
   PMODETABLE CurrentMode;          // pointer current mode information
   ULONG ChipID;                    // PCI Device ID
   ULONG ChipRev;                   // PCI Chip Revision
   ULONG NumAvailableModes;         // number of available modes
   ULONG NumTotalModes;             // total number of modes

   ULONG PowerState;                // Power state =
                                    //   VideoPowerOn or VideoPowerStandBy or
                                    //   VideoPowerSuspend or VideoPowerOff

   UCHAR TileSize;                  // Tile size
   UCHAR TiledMode;                 // Tiled mode or 0xFF if error
   UCHAR TiledTPL;                  // Tiled mode TPL
   UCHAR TiledInterleave;           // Tiled Interleave

   PUCHAR PhysicalCommonBufferAddr;
   PUCHAR VirtualCommonBufferAddr;
   ULONG CommonBufferSize;
   ULONG SlotNumber;                // PCI slot number
   unsigned long SystemIoBusNumber; // Bus number (0=PCI, 1=AGP)

   WORD    BIOSVersion;

   // DDC2B & EDID data
   DWORD   dwDDCFlag;
   BOOLEAN EDIDFlag;
   UCHAR   EDIDBuffer[128];
   ULONG   ulEDIDMaxTiming;
   USHORT  usMaxVtFrequency;
   USHORT  usMaxXResolution;
   USHORT  usMaxFrequencyTable[8];
   BOOLEAN MultiSyncFlag;
   ULONG   ulMaxHzFrequency;

   // USB fix flag
   DWORD   dwAGPDataStreamingFlag;
   DWORD   fLowRes;

   // Monitor sync polarity.
   DWORD   dwPolarity;

   // secondary adapter can't access VGA resources
   ULONG    Dont_Do_VGA;

   // output clock and data lines need to be inverted on some chips or cards
   // (used only in CLDDC2B.c)
   UCHAR    I2Cflavor;

   BOOLEAN  MonitorEnabled;

} HW_DEVICE_EXTENSION, *PHW_DEVICE_EXTENSION;


//
// Define the device description structure.
//
typedef struct _DEVICE_DESCRIPTION {
    ULONG Version;
    BOOLEAN Master;
    BOOLEAN ScatterGather;
    BOOLEAN DemandMode;
    BOOLEAN AutoInitialize;
    BOOLEAN Dma32BitAddresses;
    BOOLEAN IgnoreCount;
    BOOLEAN Reserved1;          // must be false
    BOOLEAN Reserved2;          // must be false
    ULONG BusNumber;
    ULONG DmaChannel;
    INTERFACE_TYPE  InterfaceType;
    DMA_WIDTH DmaWidth;
    DMA_SPEED DmaSpeed;
    ULONG MaximumLength;
    ULONG DmaPort;
} DEVICE_DESCRIPTION, *PDEVICE_DESCRIPTION;


/*-------------------------- External FUNCTIONS -----------------------------*/
typedef struct _ADAPTER_OBJECT *PADAPTER_OBJECT; // ntndis

PVOID
HalAllocateCommonBuffer(
    PADAPTER_OBJECT AdapterObject,
    ULONG Length,
    PPHYSICAL_ADDRESS LogicalAddress,
    BOOLEAN CacheEnabled
    );

PVOID
HalFreeCommonBuffer(
    PADAPTER_OBJECT AdapterObject,
    ULONG Length,
    PPHYSICAL_ADDRESS LogicalAddress,
    PVOID VirtualAddress,
    BOOLEAN CacheEnabled
    );

PADAPTER_OBJECT
HalGetAdapter(
    PDEVICE_DESCRIPTION DeviceDescription,
    PULONG NumberOfMapRegisters
    );

VOID
RtlZeroMemory (
   VOID UNALIGNED *Destination,
   ULONG Length
   );

ULONG
HalGetBusDataByOffset(
    IN BUS_DATA_TYPE BusDataType,
    IN ULONG BusNumber,
    IN ULONG SlotNumber,
    IN PVOID Buffer,
    IN ULONG Offset,
    IN ULONG Length
    );

ULONG
HalSetBusDataByOffset(
    IN BUS_DATA_TYPE BusDataType,
    IN ULONG BusNumber,
    IN ULONG SlotNumber,
    IN PVOID Buffer,
    IN ULONG Offset,
    IN ULONG Length
    );


/*-------------------------- GLOBAL FUNCTIONS -----------------------------*/
//
// Global Reference.
//
extern MODETABLE  ModeTable[];
extern ULONG      TotalVideoModes;


VP_STATUS  CLFindAdapter(
    PVOID HwDeviceExtension,
    PVOID HwContext,
    PWSTR ArgumentString,
    PVIDEO_PORT_CONFIG_INFO ConfigInfo,
    PUCHAR Again
    );

BOOLEAN  CLInitialize(
    PVOID HwDeviceExtension
    );

#if _WIN32_WINNT >= 0x0500

ULONG CLGetChildDescriptor(
    IN  PVOID                   HwDeviceExtension,
    IN  PVIDEO_CHILD_ENUM_INFO  ChildEnumInfo,
    OUT PVIDEO_CHILD_TYPE       VideoChildType,
    OUT PVOID                   pChildDescriptor,
    OUT PULONG                  UId,
    OUT PVOID                   pUnused
    );

VP_STATUS CLGetPowerState(
    PVOID                   HwDeviceExtension,
    ULONG                   HwId,
    PVIDEO_POWER_MANAGEMENT VideoPowerControl
    );

VP_STATUS CLSetPowerState(
    PVOID                   HwDeviceExtension,
    ULONG                   HwId,
    PVIDEO_POWER_MANAGEMENT VideoPowerControl
    );

#endif

BOOLEAN ReadDataLine(
    PHW_DEVICE_EXTENSION HwDeviceExtension
    );                                                   
 
BOOLEAN ReadClockLine(
    PHW_DEVICE_EXTENSION HwDeviceExtension
    );                                                   
                                                    
VOID WriteClockLine(                        
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    UCHAR data
    );
                                                   
VOID WriteDataLine(                        
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    UCHAR data
    );                                                   
 
VOID WaitVSync(                        
    PHW_DEVICE_EXTENSION HwDeviceExtension
    );                                                   

#if _WIN32_WINNT >= 0x0500
BOOLEAN GetDDCInformation(
	PHW_DEVICE_EXTENSION HwDeviceExtension,
	PVOID QueryBuffer,
	ULONG BufferSize
	);
#endif

void VS_Control_Hack(PHW_DEVICE_EXTENSION HwDeviceExtension, BOOL Enable);

void Output_To_VS_CLK_CONTROL(PHW_DEVICE_EXTENSION HwDeviceExtension, DWORD val);

void PMNT_Init(PHW_DEVICE_EXTENSION HwDeviceExtension);

VP_STATUS PMNT_SetACPIState (PHW_DEVICE_EXTENSION HwDeviceExtension, ULONG state);

VP_STATUS PMNT_GetACPIState (PHW_DEVICE_EXTENSION HwDeviceExtension, ULONG* state);

VP_STATUS PMNT_SetHwModuleState (PHW_DEVICE_EXTENSION HwDeviceExtension,
                                 ULONG hwmod, ULONG state);

VP_STATUS PMNT_GetHwModuleState (PHW_DEVICE_EXTENSION HwDeviceExtension,
                                 ULONG hwmod, ULONG* state);

void PMNT_Close (PHW_DEVICE_EXTENSION HwDeviceExtension);

#if 1 // PDR#11350
BOOLEAN CLResetHw(
	PHW_DEVICE_EXTENSION HwDeviceExtension,
	ULONG Columns,
	ULONG Rows
);
#endif

BOOLEAN  CLStartIO(
    PVOID HwDeviceExtension,
    PVIDEO_REQUEST_PACKET RequestPacket
    );

VP_STATUS  CLSetColorLookup(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    PVIDEO_CLUT ClutBuffer,
    ULONG ClutBufferSize
    );

BOOLEAN  CLIsPresent(
   PHW_DEVICE_EXTENSION HwDeviceExtension
   );

ULONG  CLFindVmemSize(
   PHW_DEVICE_EXTENSION HwDeviceExtension
   );

VOID  CLWriteRegistryInfo(
   PHW_DEVICE_EXTENSION hwDeviceExtension,
   BOOLEAN hdbrsten
   );

VOID  CLValidateModes(
   PHW_DEVICE_EXTENSION HwDeviceExtension
   );

VOID  CLCopyModeInfo(
   PHW_DEVICE_EXTENSION HwDeviceExtension,
   PVIDEO_MODE_INFORMATION videoModes,
   ULONG ModeIndex,
   PMODETABLE ModeInfo
   );

VP_STATUS  CLSetMode(
   PHW_DEVICE_EXTENSION HwDeviceExtension,
   PVIDEO_MODE Mode
   );

BOOLEAN  CLSetMonitorType(
   PHW_DEVICE_EXTENSION HwDeviceExtension,
   USHORT VertScanlines,
   UCHAR  MonitorTypeVal
   );

VP_STATUS CLPowerManagement(
   PHW_DEVICE_EXTENSION HwDeviceExtension,
   PVIDEO_POWER_MANAGEMENT pPMinfo,
   BOOLEAN SetPowerState
   );

BOOLEAN CLEnablePciBurst(
    PHW_DEVICE_EXTENSION hwDeviceExtension
);

VP_STATUS CLFindLagunaOnPciBus(
    PHW_DEVICE_EXTENSION hwDeviceExtension,
    PVIDEO_ACCESS_RANGE  pAccessRanges
);

VOID CLPatchModeTable (
    PHW_DEVICE_EXTENSION HwDeviceExtension
);

VOID ClAllocateCommonBuffer(
    PHW_DEVICE_EXTENSION    HwDeviceExtension
);

VOID CLEnableTiling(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
	PMODETABLE  pReqModeTable
);

VP_STATUS CLEnablePCIConfigMMIO(
    PHW_DEVICE_EXTENSION    HwDeviceExtension
);

void SetMode(BYTE *pModeTable, BYTE *pMemory, BYTE * pBinaryData, ULONG SkipIO);

//
// The rest of this file isn't used.
//

#if 0
#if ENABLE_BUS_MASTERING 
HW_DMA_RETURN  CLStartDma(
    PHW_DEVICE_EXTENSION    HwDeviceExtension,
    PVIDEO_REQUEST_PACKET   RequestPacket,
    PVOID                   pMappedUserEvent,
    PVOID                   pDisplayEvent,
    PVOID                   pDmaCompletionEvent
   );
#endif

#if ENABLE_BUS_MASTERING
	PUCHAR IoBuffer;
	ULONG IoBufferSize;
	PVOID DmaHandle;
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\laguna\mini\cl546x\i386\cfglgmem.inc ===
;*******************************************************************************
;
; Copyright (c) 1996-1998, Cirrus Logic, Inc.
; All Rights Reserved.
;
; FILE: $Workfile:   CfgLgMem.inc  $
;
; DESCRIPTION:
;
; REVISION HISTORY: $Log:   //uinac/Log/Log/Laguna/NT35/Miniport/CL546x/i386/CfgLgMem.inc  $
; 
;    Rev 1.0   Jan 22 1998 16:26:58   frido
; Initial revision.
;
;****************************************************************************

IFNDEF _CFGLGMEM_INC_
_CFGLGMEM_INC_			EQU		1

;****************************************************************************
;* E Q U A T E S
;****************************************************************************

; eflags bits.
FLAGS_AC_BIT			EQU		00040000h
FLAGS_ID_BIT			EQU		00200000h

; CPUID	info feature flags & processor signature equates.
STEPPING_MASK			EQU		00000000fh
MODEL_MASK			EQU		0000000f0h
FAMILY_MASK			EQU		000000f00h
UP_TYPE_MASK			EQU		000003000h

FAMILY_386			EQU		000000300h
FAMILY_486			EQU		000000400h
FAMILY_PENTIUM			EQU		000000500h
FAMILY_PENTIUM_PRO		EQU		000000600h

FEATURE_FPU			EQU		000000001h
FEATURE_VME			EQU		000000002h
FEATURE_PSE			EQU		000000008h
FEATURE_TSC			EQU		000000010h
FEATURE_MSR			EQU		000000020h
FEATURE_PAE			EQU		000000040h
FEATURE_MCE			EQU		000000080h
FEATURE_CX8			EQU		000000100h
FEATURE_APIC			EQU		000000200h
FEATURE_MTRR			EQU		000001000h
FEATURE_PGE			EQU		000002000h
FEATURE_MCA			EQU		000004000h
FEATURE_CMOV			EQU		000008000h

; MSR MTRR registers, masks, bits, etc.
MSR_MTRRcapsReg			EQU		0FEh
MSR_MTRRphysBase0Reg		EQU		200h
MSR_MTRRphysMask0Reg		EQU		201h
MSR_MTRRphysBase1Reg		EQU		202h
MSR_MTRRphysMask1Reg		EQU		203h
MSR_MTRRphysBase2Reg		EQU		204h
MSR_MTRRphysMask2Reg		EQU		205h
MSR_MTRRphysBase3Reg		EQU		206h
MSR_MTRRphysMask3Reg		EQU		207h
MSR_MTRRphysBase4Reg		EQU		208h
MSR_MTRRphysMask4Reg		EQU		209h
MSR_MTRRphysBase5Reg		EQU		20Ah
MSR_MTRRphysMask5Reg		EQU		20Bh
MSR_MTRRphysBase6Reg		EQU		20Ch
MSR_MTRRphysMask6Reg		EQU		20Dh
MSR_MTRRphysBase7Reg		EQU		20Eh
MSR_MTRRphysMask7Reg		EQU		20Fh
MSR_MTRRfix64K_00000Reg		EQU		250h
MSR_MTRRfix64K_80000Reg		EQU		258h
MSR_MTRRfix64K_A0000Reg		EQU		259h
MSR_MTRRfix64K_C0000Reg		EQU		268h
MSR_MTRRfix64K_C8000Reg		EQU		269h
MSR_MTRRfix64K_D0000Reg		EQU		26Ah
MSR_MTRRfix64K_D8000Reg		EQU		26Bh
MSR_MTRRfix64K_E0000Reg		EQU		26Ch
MSR_MTRRfix64K_E8000Reg		EQU		26Dh
MSR_MTRRfix64K_F0000Reg		EQU		26Eh
MSR_MTRRfix64K_F8000Reg		EQU		26Fh
MSR_MTRRdefTypeReg		EQU		2FFh

MSR_DefMemTypeMask		EQU		07h
MSR_FixedMTRREnable		EQU		0400h
MSR_MTRREnable			EQU		0800h

MTRRcap_WC_BIT			EQU		0400h
MTRRcap_FIX_BIT			EQU		0100h
MTRRcap_VCNT_MASK		EQU		0FFh

MTRRdefType_E_BIT		EQU		0800h
MTRRdefType_FE_BIT		EQU		0400h
MTRRdefType_DEF_TYPE_MASK	EQU		0FFh

MTRRphysBase_PHYS_BASE_MASK_LO	EQU		0FFFFF000h
MTRRphysBase_PHYS_BASE_MASK_HI	EQU		0Fh
MTRRphysBase_TYPE_MASK		EQU		0FFh
MTRRphysMask_PHYS_MASK_MASK_LO	EQU		0FFFFF000h
MTRRphysMask_PHYS_MASK_MASK_HI	EQU		0Fh
MTRRphysMask_V_BIT		EQU		0800h

; Memory types available on P6.
UNCACHEABLE			EQU		0
WRITE_COMBINING			EQU		1
WRITE_THROUGH			EQU		4
WRITE_BACK			EQU		5
WRITE_PROTECTED			EQU		6

; CR0 bits.
CR0_CD_BIT			EQU		40000000h
CR0_NW_BIT			EQU		20000000h

; Error codes.
mVDD_SUCCESS			EQU		0
mVDDERR_INVALID_PARAMETER	EQU		57h
mVDDERR_NOT_SUPPORTED		EQU		32h
mVDDERR_ALREADY_ASSIGNED	EQU		55h
mVDDERR_ACCESS_DENIED		EQU		5h

ENDIF ; _CFGLGMEM_INC_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\laguna\mini\include\hdtable.h ===
/*
* HDTABLE.H
* This provides a work around for the Laguna hostdata bug.
* 
* Copyright (c) 1995 Cirrus Logic, Inc.
*/


/* the ExtraDwodTable is indexed by as follows (verilog notation)
*       index[15:00] =    bltext [10:0] dst_phase [2:0] src_phase [1:0] 
*
*       index[15:05] =    bltext [10:00]
*       index[04:02] = dst_phase [02:00]
*       index[01:00] = src_phase [01:00]
*/
#if ! DRIVER_5465
#define MAKE_HD_INDEX(ext_x, src_phase, dst_x)  \
         (((ext_x)     & 0x07FF) << 5) |          \
         (((dst_x)     & 0x07)  << 2)  |          \
         ((src_phase) & 0x03) 

extern unsigned char ExtraDwordTable[];
#endif

//
// The table is actually defined in HDTABLE.C
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\laguna\mini\include\debug.h ===
/***************************************************************************\
* Module Name: debug.h
*
* Commonly used debugging macros.
*
* Copyright (c) 1992 Microsoft Corporation
\***************************************************************************/

extern
VOID
DebugPrint(
    ULONG DebugPrintLevel,
    PCHAR DebugMessage,
    ...
    ) ;

//  DDRAW uses DBG_MESSAGE instead of DISPDBG.
#define DBG_MESSAGE(x) DISPDBG((0,x))


// if we are in a debug environment, macros should

#if DBG
#define DISPDBG(arg) DebugPrint arg

#ifdef WINNT_VER40
#define RIP(x) { DebugPrint(0, x); EngDebugBreak();}
#else
#define RIP(x) { DebugPrint(0, x); DebugBreak();}
#endif

#define ASSERTMSG(x,m) { if (!(x)) {RIP(m);} }

// if we are not in a debug environment, we want all of the debug
// information to be stripped out.

#else
#define DISPDBG(arg)
#define RIP(x)
#define ASSERTMSG(x,m)


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\laguna\mini\include\driver.h ===
/******************************Module*Header*******************************\
 *
 * Module Name: driver.h
 *
 * contains prototypes for the driver.
 *
 * Copyright (c) 1992 Microsoft Corporation
 * Copyright (c) 1995 Cirrus Logic, Inc.
 *
 * Cirrus extensions by Noel VanHook
 *
 * $Log:   X:/log/laguna/nt35/displays/cl546x/DRIVER.H  $
* 
*    Rev 1.70   Mar 25 1998 16:33:54   frido
* Added dwOverlayCount and dwCONTROL2Save variables.
* 
*    Rev 1.69   Mar 04 1998 14:42:26   frido
* Added shadowFGCOLOR.
* 
*    Rev 1.68   Feb 27 1998 17:01:14   frido
* Added shadowQFREE register.
* 
*    Rev 1.67   Jan 20 1998 11:41:52   frido
* Changed fDataStreaming into dwDataStreaming.
* Added shadow variables for BGCOLOR and DRAWBLTDEF registers.
* 
*    Rev 1.66   Jan 16 1998 14:07:38   frido
* Changed SOLID_COLOR_FILL so it uses the pattern.
* 
*    Rev 1.65   Nov 03 1997 15:53:44   frido
* Added fDataStreaming variable to PDEV structure.
* 
*    Rev 1.64   16 Oct 1997 09:47:38   bennyn
* Added bPrevModeDDOutOfVideoMem to PDEV
* 
*    Rev 1.63   18 Sep 1997 16:12:02   bennyn
* 
* Fixed NT 3.51 compile/link problem
* 
*    Rev 1.62   12 Sep 1997 12:04:14   bennyn
* 
* Added DD overlay support
* 
*    Rev 1.61   29 Aug 1997 17:08:36   RUSSL
* Added overlay support
*
*    Rev 1.60   18 Aug 1997 09:17:50   FRIDO
* Added fields for bitmap filter.
*
*    Rev 1.59   11 Aug 1997 14:11:00   bennyn
*
* Enabled GetScanLine support
*
*    Rev 1.58   08 Aug 1997 14:46:20   FRIDO
* Added support for new memory manager.
*
*    Rev 1.57   22 Jul 1997 12:31:10   bennyn
* Added dwLgVenID to PDEV
*
*    Rev 1.56   02 Jul 1997 15:13:02   noelv
*
* Added prototype for LgMatchDriverToChip()
*
*    Rev 1.55   20 Jun 1997 13:27:34   bennyn
*
* Eliminated power manager data area from PDEV
*
*    Rev 1.54   23 May 1997 15:40:16   noelv
* Added chip revision to PDEV
*
*    Rev 1.53   29 Apr 1997 16:26:26   noelv
* Added SWAT code.
* SWAT:
* SWAT:    Rev 1.6   24 Apr 1997 12:05:22   frido
* SWAT: Fixed compiler bugs.
* SWAT:
* SWAT:    Rev 1.5   24 Apr 1997 10:39:50   frido
* SWAT: NT140b09 merge.
* SWAT: Removed memory manager changes for now.
*
*    Rev 1.52   22 Apr 1997 11:03:22   noelv
* Added forward compatible chip ids.
* SWAT:
* SWAT:    Rev 1.4   18 Apr 1997 17:21:26   frido
* SWAT: Fixed a typo (OFM_HandleChain).
* SWAT:
* SWAT:    Rev 1.3   17 Apr 1997 23:16:20   frido
* SWAT: NT140b07 merge.
*
*    Rev 1.51   16 Apr 1997 10:52:18   bennyn
*
* Should use PFN_DRVSRCMBLT instead of PFN_DRVSTRBLTX for pfnDrvSrcMBlt.
* SWAT:
* SWAT:    Rev 1.2   11 Apr 1997 12:38:22   frido
* SWAT: Added OFM_HandleChain.
* SWAT:
* SWAT:    Rev 1.1   09 Apr 1997 17:34:30   frido
* SWAT: Added fPreAllocate and nPages.
* SWAT: Added FONTCELL structure and variables.
*
*    Rev 1.50   08 Apr 1997 11:38:02   einkauf
* pdev adds to complete mcd
*
*    Rev 1.49   04 Apr 1997 16:51:26   noelv
*
* Added pointer for new Direct Draw functions.
*
*    Rev 1.48   27 Mar 1997 14:31:54   noelv
*
* Added new DDRAW function.
*
*    Rev 1.47   21 Mar 1997 13:38:40   noelv
*
* Synced PDEV with LAGUNA.INC
*
*    Rev 1.46   26 Feb 1997 13:21:26   noelv
* Disabel MCD code for NT 3.5x
*
*    Rev 1.45   26 Feb 1997 10:45:38   noelv
* Added OpenGL MCD code from ADC.
*
*    Rev 1.44   19 Feb 1997 13:08:38   noelv
* Added translation table cache
*
*    Rev 1.43   06 Feb 1997 10:36:10   noelv
*
* Moved MEMMGR andBRUSH stuff to their own header files.
*
*    Rev 1.42   23 Jan 1997 17:13:02   bennyn
*
* Modified to support 5465 DD
*
*    Rev 1.41   20 Jan 1997 14:49:34   bennyn
*
* Added blt65 prototypes
*
*    Rev 1.40   16 Jan 1997 11:35:16   bennyn
*
* Added power manager variables to PDEV
*
*    Rev 1.39   17 Dec 1996 16:44:54   SueS
* Changed parameters in CloseLogFile prototype.
*
*    Rev 1.38   10 Dec 1996 13:28:08   bennyn
* Added ulFreq to PDEV
*
*    Rev 1.37   05 Dec 1996 08:51:58   SueS
* Added function to help with formatting strings for DirectDraw logging.
* Added defines if logging is turned off.
*
*    Rev 1.36   27 Nov 1996 11:32:36   noelv
* Disabled Magic Bitmap.  Yeah!!!
*
*    Rev 1.35   26 Nov 1996 10:22:56   SueS
* Added new function parameters and variables for logging with buffering.
*
*    Rev 1.34   18 Nov 1996 10:15:20   bennyn
*
* Added grFormat to PDEV
*
*    Rev 1.33   13 Nov 1996 17:06:10   SueS
* Added function prototypes for file logging functions.
*
*    Rev 1.32   12 Nov 1996 15:18:34   bennyn
*
* Added handle for DD blt scratch buffer
*
*    Rev 1.31   07 Nov 1996 16:13:40   bennyn
*
* Added support to alloc offscn mem in DD createsurface
*
*    Rev 1.30   01 Nov 1996 09:20:40   BENNYN
* Added support for shareable DD blt code
*
*    Rev 1.29   31 Oct 1996 11:14:42   noelv
*
* Split common buffer into two buffers.
*
*    Rev 1.28   25 Oct 1996 11:52:14   noelv
* added second common buffer
*
*    Rev 1.27   24 Oct 1996 14:27:32   noelv
* Added common buffer for bus mastering.
*
*    Rev 1.26   23 Oct 1996 14:39:04   BENNYN
* Added YUV cursor variables to PDEV
*
*    Rev 1.25   04 Oct 1996 16:50:46   bennyn
*
* Added DirectDraw YVU support
*
*    Rev 1.24   18 Sep 1996 13:57:44   bennyn
* Modified to support DD stretchBLT
*
*    Rev 1.23   22 Aug 1996 18:14:48   noelv
* Frido bug fix release 8-22.
*
*    Rev 1.22   20 Aug 1996 11:04:54   noelv
* Bugfix release from Frido 8-19-96
*
*    Rev 1.2   17 Aug 1996 13:40:28   frido
* New release from Bellevue.
*
*    Rev 1.1   15 Aug 1996 11:35:08   frido
* Changed to conform to the precompiled header.
*
*    Rev 1.0   14 Aug 1996 17:16:36   frido
* Initial revision.
*
*    Rev 1.20   25 Jul 1996 15:52:56   bennyn
* Modified for DirectDraw
*
*    Rev 1.19   16 Jul 1996 14:26:04   BENNYN
*
*    Rev 1.18   11 Jul 1996 15:53:24   bennyn
*
* Added DirectDraw support
 *
 *    Rev 1.17   23 May 1996 16:22:16   BENNYN
 * Added SubFreeQ declarations
 *
 *    Rev 1.16   17 May 1996 12:04:52   bennyn
 * Added #define DBGBREAKPOINT
 *
 *    Rev 1.15   08 May 1996 17:02:04   noelv
 * preallocated device bitmap.
 *
 *    Rev 1.14   03 May 1996 15:06:34   noelv
 *
 * Added flag to turn font cache on and off
 *
 *    Rev 1.13   01 May 1996 10:58:44   bennyn
 *
 * Modified for NT4.0
 *
 *    Rev 1.12   25 Apr 1996 22:42:52   noelv
 * Cleaned up data logging some.
 *
 *    Rev 1.11   10 Apr 1996 14:15:42   NOELV
 *
 * Frido release 27
 *
 *    Rev 1.20   07 Apr 1996 17:12:26   frido
 * Added solid brush cache.
 *
 *    Rev 1.19   01 Apr 1996 13:58:18   frido
 * Changed layout of brush cache.
 *
 *    Rev 1.18   28 Mar 1996 19:57:38   frido
 * New Bellevue release.
 *
 *    Rev 1.8   25 Mar 1996 18:57:52   noelv
 * Added define for turning cursor bug fix on and off.
 *
 *    Rev 1.7   14 Mar 1996 09:36:22   andys
 * Added dcTileWidth and dcSRAMWidth
 *
 *    Rev 1.6   12 Mar 1996 15:46:42   noelv
 * Added support file Stroke and Fill
 *
 *    Rev 1.5   11 Mar 1996 11:54:20   noelv
 *
 * Added log file pointer to PDEV
 *
 *    Rev 1.4   07 Mar 1996 18:21:52   bennyn
 *
 *
 *    Rev 1.3   05 Mar 1996 11:59:38   noelv
 * Frido version 19
 *
 *    Rev 1.13   29 Feb 1996 19:56:40   frido
 * Added bEnable to PDEV structure.
 *
 *    Rev 1.12   27 Feb 1996 16:38:34   frido
 * Changed DSURF structure.
 * Added device bitmap store/restore.
 *
 *    Rev 1.11   26 Feb 1996 23:38:18   frido
 * Added function pointers for ScreenToHost and HostToScreen.
 *
 *    Rev 1.10   24 Feb 1996 01:24:26   frido
 * Added device bitmaps.
 *
 *    Rev 1.9   17 Feb 1996 21:45:30   frido
 *
 *
 *    Rev 1.8   13 Feb 1996 16:51:10   frido
 * Changed the layout of the PDEV structure.
 * Changed the layout of all brush caches.
 * Changed the number of brush caches.
 *
 *    Rev 1.7   10 Feb 1996 21:42:26   frido
 * Split monochrome and colored translation brushes.
 *
 *    Rev 1.6   08 Feb 1996 00:18:38   frido
 * Changed number of XLATE caches to 8.
 *
 *    Rev 1.5   05 Feb 1996 17:35:52   frido
 * Added translation cache.
 *
 *    Rev 1.4   03 Feb 1996 13:38:32   frido
 * Use the compile switch "-Dfrido=0" to disable my extensions.
 *
 *    Rev 1.3   25 Jan 1996 12:46:54   frido
 * Added font counter ID to PDEV structure.
 *
 *    Rev 1.2   20 Jan 1996 22:13:44   frido
 * Added dither cache.
 *
\**************************************************************************/

#include "swat.h"
#include "debug.h"
#include "laguna.h"
#include "optimize.h"
#include "memmgr.h"
#include "brush.h"
#include "xlate.h"
#if MEMMGR
#include "mmCore.h"    // new memory manager
#endif

#if DRIVER_5465 && defined(OVERLAY)
#include "overlay.h"
#include "5465bw.h"
#include "bw.h"
#endif

#ifdef WINNT_VER40
#define ALLOC_TAG 'XGLC'		// Memory Tag

#define DBGBREAKPOINT()   EngDebugBreak()
#define MEM_ALLOC(FLAGS, SIZE, TAG) EngAllocMem((FLAGS), (SIZE), (TAG))
#define MEMORY_FREE(pMEM) EngFreeMem(pMEM)
#define DEVICE_IO_CTRL(A, B, C, D, E, F, G, H) (EngDeviceIoControl((A), (B), (C), (D), (E), (F), (G)) == 0)

#else

#define DBGBREAKPOINT()   DbgBreakPoint()
#define MEM_ALLOC(FLAGS, SIZE) LocalAlloc((FLAGS), (SIZE))
#define MEMORY_FREE(pMEM) LocalFree(pMEM)
#define DEVICE_IO_CTRL(A, B, C, D, E, F, G, H) DeviceIoControl((A), (B), (C), (D), (E), (F), (G), (H))

#endif


#ifndef frido
  #define frido 1
#endif

#if WINBENCH96
    #define MAGIC_SIZEX  400
    #define MAGIC_SIZEY  90
#endif

#define S2H_USE_ENGINE 0	// ScreenToHost flag
                           //	0 - Use direct access to screen buffer
                           //	1 - Use hardware


//
// These specify how much the desktop should be shrunk to allow off screen
// memory to be visible on screen.
// For example: if OFFSCREEN_LINES is 100, the desktop height will be reduced
// by 100 lines, and the bottom 100 screen lines will be the first 100 lines
// of off screen memory.  This allows us to view and debug cached brushes, etc.
//
#define OFFSCREEN_LINES 0
#define OFFSCREEN_COLS 0


typedef BOOL COPYFN(SURFOBJ *psoTrg, SURFOBJ *psoSrc, XLATEOBJ *pxlo,
                    RECTL *prclTrg, POINTL *pptlSrc, ULONG ulDRAWBLTDEF);




/*
 *	Be sure to synchronize these structures with those in i386\Laguna.inc!
 */

#pragma pack(1)

/*****************************************************************************\
 * DirectDraw
\*****************************************************************************/
enum SSREGNAMES
{
  ACCUM,
  MAJ,
  MIN,
  MAX_REGS
};

// Allocate offscreen memory for DD in createsurface instead of
// DD enable
#define ALLOC_IN_CREATESURFACE

//#define DDDRV_GETSCANLINE
#define RDRAM_8BIT

// Stuff for tidying up access to grFormat
#define FMT_VCLK_DIV2   0x4000
#define FMT_GRX_MASK    0x3e00  // Mask for the Graphics depth & format fields
#define FMT_GRX_GAMMA   0x0800
#define FMT_VID_MASK    0x003e  // Mask for the Vide depth & video format fields
#define FMT_VID_GAMMA   0x0001

#define FMT_8BPP        0
#define FMT_16BPP       1
#define FMT_24BPP       2
#define FMT_32BPP       3

#define FMT_VID_COLORDEPTH_SHIFT  4
#define FMT_VID_8BPP        (FMT_8BPP  << FMT_VID_COLORDEPTH_SHIFT)
#define FMT_VID_16BPP       (FMT_16BPP << FMT_VID_COLORDEPTH_SHIFT)
#define FMT_VID_24BPP       (FMT_24BPP << FMT_VID_COLORDEPTH_SHIFT)
#define FMT_VID_32BPP       (FMT_32BPP << FMT_VID_COLORDEPTH_SHIFT)

#define FMT_GRX_COLORDEPTH_SHIFT  12
#define FMT_GRX_8BPP        (FMT_8BPP  << FMT_GRX_COLORDEPTH_SHIFT)
#define FMT_GRX_16BPP       (FMT_16BPP << FMT_GRX_COLORDEPTH_SHIFT)
#define FMT_GRX_24BPP       (FMT_24BPP << FMT_GRX_COLORDEPTH_SHIFT)
#define FMT_GRX_32BPP       (FMT_32BPP << FMT_GRX_COLORDEPTH_SHIFT)

#define FMT_PALETTIZED  0
#define FMT_GREYSCALE   1
#define FMT_RGB         2
#define FMT_ACCUPAK     4
#define FMT_YUV422      5
#define FMT_YUV444      6

#define FMT_VID_FORMAT_SHIFT  1
#define FMT_VID_PALETTIZED  (FMT_PALETTIZED << FMT_VID_FORMAT_SHIFT)
#define FMT_VID_GREYSCALE   (FMT_GREYSCALE  << FMT_VID_FORMAT_SHIFT)
#define FMT_VID_RGB         (FMT_RGB        << FMT_VID_FORMAT_SHIFT)
#define FMT_VID_ACCUPAK     (FMT_ACCUPAK    << FMT_VID_FORMAT_SHIFT)
#define FMT_VID_YUV422      (FMT_YUV422     << FMT_VID_FORMAT_SHIFT)
#define FMT_VID_YUV444      (FMT_YUV444     << FMT_VID_FORMAT_SHIFT)

#define FMT_GRX_FORMAT_SHIFT  9
#define FMT_GRX_PALETTIZED  (FMT_PALETTIZED << FMT_GRX_FORMAT_SHIFT)
#define FMT_GRX_GREYSCALE   (FMT_GREYSCALE  << FMT_GRX_FORMAT_SHIFT)
#define FMT_GRX_RGB         (FMT_RGB        << FMT_GRX_FORMAT_SHIFT)
#define FMT_GRX_ACCUPAK     (FMT_ACCUPAK    << FMT_GRX_FORMAT_SHIFT)
#define FMT_GRX_YUV422      (FMT_YUV422     << FMT_GRX_FORMAT_SHIFT)
#define FMT_GRX_YUV444      (FMT_YUV444     << FMT_GRX_FORMAT_SHIFT)

// STOP_BLT_[1,2,3] Register Fields
#define ENABLE_VIDEO_WINDOW   0x80
#define ENABLE_VIDEO_FORMAT   0x40

// External Overlay Control Register Fields
#define ENABLE_RAMBUS_9TH_BIT 0x01

#define SET_DRVSEM_YUV()    (pDriverData->DrvSemaphore |=  DRVSEM_YUV_ON)
#define CLR_DRVSEM_YUV()    (pDriverData->DrvSemaphore &= ~DRVSEM_YUV_ON)

// IN_VBLANK tests to see if the hardware is currently in the vertical blank.
#define IN_VBLANK         (_inp(0x3da) & 8)
#define IN_DISPLAY        (!IN_VBLANK)

// IN_DISPLAYENABLE tests to see if the display is enable
#define IN_DISPLAYENABLE  (_inp(0x3da) & 1)

#define BITSPERPIXEL   (ppdev->ulBitCount)
#define BYTESPERPIXEL  (BITSPERPIXEL / 8)

#define BYTE1FROMDWORD(dw)  ((BYTE)dw)
#define BYTE2FROMDWORD(dw)  ((BYTE)((DWORD)dw >> 8))
#define BYTE3FROMDWORD(dw)  ((BYTE)((DWORD)dw >> 16))
#define BYTE4FROMDWORD(dw)  ((BYTE)((DWORD)dw >> 24))

// Bits defined in DrvSemaphore
//	Be sure to synchronize these structures with those in i386\Laguna.inc!
#define DRVSEM_CURSOR_REMOVED_BIT   0
#define DRVSEM_HW_CURSOR_BIT        1
#define DRVSEM_IN_USE_BIT           2
#define DRVSEM_NEW_CURSOR_XY_BIT    3
#define DRVSEM_CHECK_CURSOR_BIT     4
#define DRVSEM_CURSOR_IN_USE_BIT    5
#define DRVSEM_CURSOR_CHANGED_BIT   6
#define DRVSEM_3D_BUSY_BIT          7
#define DRVSEM_MISSED_SET_BIT       8
#define DRVSEM_YUV_ON_BIT           9
#define DRVSEM_DISABLE_SETS_BIT     10
#define DRVSEM_YUV_RECT_VALID_BIT   11

// the corresponding mask values
//	Be sure to synchronize these structures with those in i386\Laguna.inc!
#define DRVSEM_CHECK_CURSOR         (1 << DRVSEM_CHECK_CURSOR_BIT)
#define DRVSEM_NEW_CURSOR_XY        (1 << DRVSEM_NEW_CURSOR_XY_BIT)
#define DRVSEM_IN_USE               (1 << DRVSEM_IN_USE_BIT)
#define DRVSEM_CURSOR_REMOVED       (1 << DRVSEM_CURSOR_REMOVED_BIT)
#define DRVSEM_HW_CURSOR            (1 << DRVSEM_HW_CURSOR_BIT)
#define DRVSEM_CURSOR_IN_USE        (1 << DRVSEM_CURSOR_IN_USE_BIT)
#define DRVSEM_CURSOR_CHANGED       (1 << DRVSEM_CURSOR_CHANGED_BIT)
#define DRVSEM_3D_BUSY              (1 << DRVSEM_3D_BUSY_BIT)
#define DRVSEM_MISSED_SET           (1 << DRVSEM_MISSED_SET_BIT)
#define DRVSEM_YUV_ON               (1 << DRVSEM_YUV_ON_BIT)
#define DRVSEM_DISABLE_SETS         (1 << DRVSEM_DISABLE_SETS_BIT)
#define DRVSEM_YUV_RECT_VALID       (1 << DRVSEM_YUV_RECT_VALID_BIT)

#define ROUND_UP_TO_64K(x)  (((ULONG)(x) + 0x10000 - 1) & ~(0x10000 - 1))

#define mmioFOURCC( ch0, ch1, ch2, ch3 )                           \
           ( (DWORD)(BYTE)(ch0) | ( (DWORD)(BYTE)(ch1) << 8 ) |    \
           ( (DWORD)(BYTE)(ch2) << 16 ) | ( (DWORD)(BYTE)(ch3) << 24 ) )

#define FOURCC_UYVY mmioFOURCC('U', 'Y', 'V', 'Y')

typedef volatile GAR * PVGAR;

typedef struct offscr_yuv {
  RECTL SrcRect;
  WORD  nInUse;
  WORD  ratio;
} OFFSCR_YUV, * POFFSCR_YUV;


#if DRIVER_5465 && defined(OVERLAY)

#ifndef ENABLE_MIRRORING
#define ENABLE_MIRRORING    0
#endif

#ifndef ENABLE_YUVPLANAR
#define ENABLE_YUVPLANAR    0
#endif

// Be sure to synchronize the following structures with the one
// in i386\Laguna.inc!
#define MAX_FOURCCS   3
#define MAX_VIDEO_WINDOWS   8

#endif

// This DRIVERDATA structure is similar to GLOBALDATA structure in Win95
// DirectDraw and declares for compartible reason.
//
// Be sure to synchronize this structure with the one in i386\Laguna.inc!
//
typedef struct  _DRIVERDATA
{
  DWORD    PTAGFooPixel;      // ptag workaround pixel
  WORD     fNineBitRDRAMS;    // flag to indicate if 9bit RDRAMS present
  BOOL     fReset;
  PBYTE    ScreenAddress;     // base of screen memory (Same as pjScreen in PDEV)
  PBYTE    VideoBase;         // base of video memory (Same as pjScreen in PDEV)
  volatile GAR *RegsAddress;  // base address of Laguna MMIO regs
  WORD     DrvSemaphore;
  WORD     EdgeTrim;

  // Coordinate of the YUV rectange
  WORD     YUVTop;
  WORD     YUVLeft;
  WORD     YUVXExt;
  WORD     YUVYExt;

  // Video Format semaphores, you must set the VIDEO_FORMAT bit in
  // VideoSemaphore before making changes to CurrentVideoFormat and
  // NumVideoSurfaces. After you are done making changes, you must
  // clear the VIDEO_FORMAT bit in VideoSemaphore.
  //
  // Once you've SET the VIDEO_FORMAT bit, you can increment or decrement
  // the NumVideoSurfaces if CurrentVideoFormat is the same type.  You can
  // only change the CurrentVideoFormat, if the NumVideoSurfaces is zero.
  // Therefore if the NumVideoSurfaces is not zero and CurrentVideoFormat
  // is not the type of surface you want to create, you MUST FAIL the surface
  // creation request! After changing the video format you must program the
  // FORMAT register with the new video format.
  // When you are done making changes, CLEAR the VIDEO_FORMAT bit!
  WORD    VideoSemaphore;     // semaphores to control interaction between
                              // DCI's & VPM's use of video hardware
  WORD    CurrentVideoFormat; // value of current video format YUV422, etc.
                              // Same as low byte of FORMAT register
  WORD    NumVideoSurfaces;   // number of surfaces currently in use with
                              // CurrentVideoFormat
  DWORD   ScratchBufferOrg;

#ifdef WINNT_VER40
#if DRIVER_5465 && defined(OVERLAY)
  BOOL                fOverlaySupport;
  OVERLAYTABLE        OverlayTable;
  DWORD				  dwOverlayCount;
  DWORD				  dwCONTROL2Save;

  // Win95 5465over.c static vars
  BOOL                bUseBWEqn;
  BOOL                bNoOverlayInThisMode;

  PDD_SURFACE_LOCAL   lpHardwareOwner[MAX_VIDEO_WINDOWS];
  PDD_SURFACE_LOCAL   lpColorSurfaceVW[MAX_VIDEO_WINDOWS];
  PDD_SURFACE_LOCAL   lpSrcColorSurfaceVW[MAX_VIDEO_WINDOWS];

  RECTL               grOverlaySrc[MAX_VIDEO_WINDOWS];
  RECTL               grOverlayDest[MAX_VIDEO_WINDOWS];
  DWORD               gdwFourccVW[MAX_VIDEO_WINDOWS];
  BOOL                bIsVWMirrored[MAX_VIDEO_WINDOWS];

  DWORD               gdwAvailVW;                 // Next available video window
  DWORD               gdwColorKey;
  DWORD               gdwSrcColorKeyLow;
  DWORD               gdwSrcColorKeyHigh;
  DWORD               gdwDestColorKeyOwnerVW;     // DstColorKey owner (NULL or FLG_VWX)
  DWORD               gdwSrcColorKeyOwnerVW;      // SrcColorKey owner (NULL or FLG_VWX)

  int                 giOvlyCnt[MAX_VIDEO_WINDOWS];
  int                 giPlanarCnt;                // with other overlay surfaces
  BOOL                bCLPLLobotomyMode;

  // Win95 5465over.c global vars
  OVERLAYFLIPRECORD   gsOverlayFlip;

  PROGREGS            gsProgRegs;

  VIDCONFIG           gvidConfig;

  WORD                gwNormalDTTR;
  DWORD               dwNumVideoWindows;

  BOOL                bEnableCLPL;

  // NT only data
  DWORD     dwMaxOverlayStretch;
  DWORD     dwMinOverlayStretch;

  DWORD     dwFourCC[MAX_FOURCCS];
#else
  DWORD     dwFourCC;
#endif  // #if DRIVER_5465 && defined(OVERLAY)
#endif // WINNT_VER40

  DWORD   signature;      // Expected value: 0x9abcdef0;

} DRIVERDATA, *PDRIVERDATA;


// FLIPRECORD structure keeps track of when the last page flip occurred
typedef struct  _FLIPRECORD
{
#ifdef WINNT_VER40
  FLATPTR   fpFlipFrom;             // Surface we last flipped from
#endif // WINNT_VER40
  LONGLONG  liFlipTime;             // Time at which last flip
                                    //   occured
  LONGLONG  liFlipDuration;         // Precise amount of time it
                                    //   takes from vblank to vblank
  BOOL      bFlipFlag;              // True if we think a flip is
  BOOL      bHaveEverCrossedVBlank; // True if we noticed that we
                                    //   switched from inactive to
                                    //   vblank
  BOOL      bWasEverInDisplay;      // True if we ever noticed that
                                    //   we were inactive
  WORD      dwFlipScanLine;
} FLIPRECORD, *PFLIPRECORD;


/*****************************************************************************\
 * DSURF structure - Device Bitmaps
\*****************************************************************************/
typedef struct _DSURF
{
  struct _PDEV*    ppdev;   // pointer to pdev structure
  struct _OFMHDL*  pofm;    // pointer to off-screen memory handle
  SURFOBJ*         pso;     // pointer to surface object
  POINTL           ptl;     // x,y offset of bitmap
  SIZEL           sizl;     // size of device bitmap
  DWORD           packedXY; // packed x,y offset of bitmap
} DSURF, *PDSURF;


#define TMP_BUFFER_SIZE    8192  // Size in bytes of 'pvTmpBuffer. Has to be
                                 // at least enough to store an entire scan
                                 // line (i.e., 6400 for 1600x1200x32).



//
// For cursor/pointer
//
#define DEF_CURSOR              0       // GDI support cursor
#define HW_CURSOR               1       // Use HW cursor
#define SW_CURSOR               2       // Use SW cursor
#define HW_POINTER_DIMENSION    64      // Maximum dimension of default


// Font structures
#define  MAX_GLYPHS      256   // Maximum number of glyphs per font.
typedef struct _FONTMEMORY
{
  POFMHDL   pTile;             // Handle to tile.
  ULONG     ulLastX;           // Last allocated column.
  struct _FONTMEMORY*  pNext;  // Hointer to next structure.
} FONTMEMORY, *PFONTMEMORY;

typedef struct _GLYPHCACHE
{
  DWORD   xyPos;               // Off-screen x,y position of glyph.
  DWORD   cSize;               // Width and height of glyph.
  POINTL  ptlOrigin;           // Origin of glyph.
  // If xyPos == 0 then the glyph is not yet cached.
  // If cSize == 0 then the glyph is empty.
  // If cSize == -1 then the glyph is uncacheable.
} GLYPHCACHE, *PGLYPHCACHE;

// SWAT3 changes for font cache allocation scheme start here.
typedef struct _FONTCELL *PFONTCELL;
typedef struct _FONTCACHE *PFONTCACHE;
typedef struct _PDEV *PPDEV;

typedef struct _FONTCACHE
{
	PPDEV		ppdev;				 // Pointer to physical device.
	PFONTMEMORY	pFontMemory;		 // Pointer to font cache memory.
	PFONTCELL	pFontCell;			 // Pointer to first font cell.
	ULONG		ulFontCount;		 // Font cache ID counter.
	GLYPHCACHE	aGlyphs[MAX_GLYPHS]; // Array of cached glyphs.
	FONTOBJ*	pfo;				 // Pointer to FONTOBJ for this cache.
	PFONTCACHE	pfcPrev;			 // Pointer to previous FONTCACHE structure.
	PFONTCACHE	pfcNext;			 // Pointer to next FONTCACHE structure.
} FONTCACHE, *PFONTCACHE;

typedef struct _FONTCELL
{
	LONG		x;			// X location of this cell (in bytes).
	LONG		y;			// Y location of this cell (in bytes).
	PFONTCACHE	pfc;		// Pointer to FONTCACHE occupying this cell.
	ULONG		ulLastX;	// Last allocated column.
	PFONTCELL	pNext;		// Pointer to next font cell for this font cache.
} FONTCELL, *PFONTCELL;
// end SWAT3 changes.



typedef POFMHDL (WINAPI *ALLOCOFFSCNMEMFUNC)();
typedef BOOL    (WINAPI *FREEOFFSCNMEMFUNC)();
typedef VOID    (WINAPI *ASSERTMODEMCDFUNC)();

/*
 *  Be sure to synchronize this structure with the one in i386\Laguna.inc!
 */
typedef struct  _PDEV
{
  HANDLE  hDriver;                    // Handle to \Device\Screen
  HDEV    hdevEng;                    // Engine's handle to PDEV
  HSURF   hsurfEng;                   // Engine's handle to surface
  HPALETTE hpalDefault;               // Handle to the default palette for device.
  PBYTE   pjScreen;                   // This is pointer to base screen address
  ULONG   cxScreen;                   // Visible screen width
  ULONG   cyScreen;                   // Visible screen height
  ULONG   cxMemory;                   // Width  of Video RAM
  ULONG   cyMemory;                   // Height of Video RAM
  ULONG   ulMode;                     // Mode the mini-port driver is in.
  ULONG   ulFreq;                     // Frequency
  LONG    lDeltaScreen;               // Distance from one scan to the next.
  FLONG   flRed;                      // For bitfields device, Red Mask
  FLONG   flGreen;                    // For bitfields device, Green Mask
  FLONG   flBlue;                     // For bitfields device, Blue Mask
  ULONG   cPaletteShift;              // number of bits the 8-8-8 palette must
                                      // be shifted by to fit in the hardware
                                      // palette.
  POINTL  ptlHotSpot;                 // adjustment for pointer hot spot
  ULONG   cPatterns;                  // Count of bitmap patterns created
  HBITMAP ahbmPat[HS_DDI_MAX];        // Engine handles to standard patterns

  PALETTEENTRY *pPal;                 // If this is pal managed, this is the pal

  PBYTE   pjOffScreen;                // This is pointer to start of off screen memory
  ULONG   iBitmapFormat;
  ULONG   ulBitCount;                 // # of bits per pel 8,16,24,32 are only supported.
  ULONG   iBytesPerPixel;

  autoblt_regs PtrABlt[3];            // auto BLT tables

#ifdef WINNT_VER40
  HSEMAPHORE  CShsem;                 // Critical Section Handle to Semaphore
#else
  CRITICAL_SECTION  PtrCritSec;       // Pointer critical section
#endif

  RECTL   prcl;                       // Cursor rectange
  BOOL    PtrBusy;
  BOOL    fHwCursorActive;            // Are we currently using the hw cursor
  BOOL    CursorHidden;               // Indicate the cursor is hidden
  POFMHDL PtrMaskHandle;              // Pointer mask handle.
  POFMHDL PtrImageHandle;             // Pointer image save area handle.
  POFMHDL PtrABltHandle;              // Pointer auto BLT handle.
  ULONG   PtrXHotSpot;                // X & Y position of the pointer hot spot
  ULONG   PtrYHotSpot;
  ULONG   PtrX;                       // X & Y position of the pointer
  ULONG   PtrY;
  ULONG   PtrSzX;                     // Pointer dimensions
  ULONG   PtrSzY;
  LONG    PointerUsage;               // DEF_CURSOR - GDI support cursor.
                                      // HW_CURSOR  - Use HW cursor.
                                      // SW_CURSOR  - Use SW cursor.

  DWORD   grCONTROL;
  DWORD   grFORMAT;
  DWORD   grVS_CONTROL;

  // For offscreen memory manager
  LONG    lOffset_2D;                 // Offset-2D register value.
  LONG    lTileSize;                  // Selected tile size.
  LONG    lTotalMem;                  // Installed memory.
  BOOL    OFM_init;                   // TRUE InitOffScnMem() has been called.

#ifdef WINNT_VER40
  HSEMAPHORE  MMhsem;                 // Memory Manager Handle to Semaphore
#else
  HANDLE  MutexHdl;                   // Mutex handle
#endif

  BOOL    bDirectDrawInUse;           // DirectDraw InUse flag.
  POFMHDL ScrnHandle;                 // Active screen handle.
  POFMHDL OFM_UsedQ;                  // Off screen memory queues.
  POFMHDL OFM_FreeQ;
  POFMHDL OFM_SubFreeQ1;
  POFMHDL OFM_SubFreeQ2;
  FONTCACHE* pfcChain;                // Pointer to chain of FONTCACHE

  POFMHDL  Bcache;                    // This is the offscreen memory used to
                                      // cache the brush bits in.
  MC_ENTRY Mtable[NUM_MONO_BRUSHES];  //  Table to manage mono brush cache.
  XC_ENTRY Xtable[NUM_4BPP_BRUSHES];  //  Table to manage 4-bpp brush cache.
  DC_ENTRY Dtable[NUM_DITHER_BRUSHES]; //  Table to manage dither brush cache.
  BC_ENTRY Ctable[NUM_COLOR_BRUSHES]; //  Table to manage color brush cache.
  DC_ENTRY Stable[NUM_SOLID_BRUSHES];
  ULONG   SNext;
  ULONG   CLast;        // Last usable index in color cache table.
  ULONG   MNext;        // Where next mono brush will be cached.
  ULONG   XNext;        // Where next 4-bpp brush will be cached.
  ULONG   DNext;        // Where next dither brush will be cached.
  ULONG   CNext;        // Where next color brush will be cached.

  ULONG   ulFontCount;     // Font cache counter.
  ULONG   UseFontCache;    // Flag to turn on and off.

  POINTL  ptlOffset;    // x,y offset (for device bitmaps).
  BOOL  bEnable;        // Hardware enabled flag.

  COPYFN  *pfnHostToScreen;    // HostToScreen routine.
  COPYFN  *pfnScreenToHost;    // ScreenToHost routine.

  // Here we have the pointer to the memory mapped registers.  For
  // analysis reasons we sometimes want to 'null' out the hardware
  // by aiming the register pointer at blank memory.  We keep two
  // pointers to registers. pLgREGS_real and pLgREGS usually both point
  // to the registers, but we can set flags in LAGUNA.H to cause pLgREGS
  // to point to 'buffer' instead.  This is useful for testing which
  // parts of the driver are software bound and which are hardware bound.

  volatile GAR *pLgREGS_real; // Always points to the memory mapped registers.
  volatile GAR *pLgREGS;      // May point registers, may point to buffer.

  WORD  dcTileWidth;       // Number of Pixels in Current Tile Size
  WORD  dcSRAMWidth;       // Number of Pixels that will fit into SRAM

  // These were added to support stroke and fill with the least amount of
  // changes.
  ULONG uBLTDEF;
  ULONG uRop;
  PVOID pvTmpBuffer; // General purpose temporary buffer, TMP_BUFFER_SIZE in
                     // size (Remember to synchronize if you use this for
                     // device bitmaps or async pointers)


  #if ENABLE_LOG_FILE
    void *pmfile;
    char  TxtBuff[0x1000];
    DWORD TxtBuffIndex;
  #endif

  #if NULL_HW
    char *buffer[0x8000];   // Empty memory used to "null" the registers.
  #endif


  //
  // Reserve a little space for device bitmaps.
  //
  #if WINBENCH96
      POFMHDL pofmMagic;
      ULONG   bMagicUsed;
  #endif

// SWAT1 changes.
	BOOL		fPreAllocate;
	int			nPages;
// SWAT3 changes.
	#define 	FONTCELL_COUNT	64			// Number of font cells
	#define 	FONTCELL_X		128			// Width in bytes of a font cell
	#define 	FONTCELL_Y		16			// Height of a font cell
	POFMHDL		pofmFontCache;				// Font cache allocation heap
	FONTCELL	fcGrid[FONTCELL_COUNT];		// Array of font cache cells
#if MEMMGR
// MEMMGR changes.
	IIMEMMGR	mmMemMgr;
	LONG		must_have_width;
	BOOL		fBitmapFilter;
	SIZEL		szlBitmapMin;
	SIZEL		szlBitmapMax;
#endif

   //
   // For DirectDraw
   //
	BOOL		   bPrevModeDDOutOfVideoMem;
   POFMHDL     DirectDrawHandle;           // DirectDraw handle.
   FLIPRECORD  flipRecord;
   DRIVERDATA  DriverData;
   OFFSCR_YUV  offscr_YUV;
   DWORD       dwDDLinearCnt;              // Ref count of active DD locks
   PBYTE       pPtrMaskHost;

   BOOL        bYUVuseSWPtr;
   DWORD       dwLgVenID;                  // PCI Vendor ID
   DWORD       dwLgDevID;                  // PCI Device ID
   DWORD       dwLgDevRev;                 // PCI Device Revision
   BOOL        bYUVSurfaceOn;
   WORD        InitBPP;

   LONG        lRegVals[2][MAX_REGS];
   LONG        sShrinkInc;
   ULONG       usLnCntl;
   ULONG       usStretchCtrl;

#ifdef WINNT_VER40
   // DirectDraw display list pointer
   PFN_DELAY9BLT    pfnDelay9BitBlt;
   PFN_EDGEFILLBLT  pfnEdgeFillBlt;
   PFN_MEDGEFILLBLT pfnMEdgeFillBlt;
   PFN_DRVDSTBLT    pfnDrvDstBlt;
   PFN_DRVDSTBLT    pfnDrvDstMBlt;
   PFN_DRVSRCBLT    pfnDrvSrcBlt;
   PFN_DRVSRCMBLT   pfnDrvSrcMBlt;
   PFN_DRVSTRBLT    pfnDrvStrBlt;
   PFN_DRVSTRMBLT   pfnDrvStrMBlt;
   PFN_DRVSTRMBLTY  pfnDrvStrMBltY;
   PFN_DRVSTRMBLTX  pfnDrvStrMBltX;
   PFN_DRVSTRBLTY   pfnDrvStrBltY;
   PFN_DRVSTRBLTX   pfnDrvStrBltX;
#endif

   POFMHDL  DDScratchBufHandle;     // DirectDraw scratch buffer handle.
   PDDOFM   DDOffScnMemQ;           // DirectDraw offscreen mem queue.

   #ifdef BUS_MASTER
   BYTE*	Buf1VirtAddr;
   BYTE*	Buf2VirtAddr;

   BYTE*	Buf1PhysAddr;
   BYTE*	Buf2PhysAddr;

   ULONG	BufLength;
   #endif

   #ifndef WINNT_VER35
   // START OpenGL MCD additions (based on MGA driver in NT4.0 DDK)
   HANDLE      hMCD;                   // Handle to MCD engine dll
   MCDENGESCFILTERFUNC pMCDFilterFunc; // MCD engine filter function
   LONG        cDoubleBufferRef;       // Reference count for current number
                                       //   of RC's that have active double-
   LONG        cZBufferRef;            // Reference count for current number
                                       //   of RC's that have active z-buffers
   POFMHDL pohBackBuffer;              // ofscreen pools
   POFMHDL pohZBuffer;

   DWORD temp_DL_chunk[SIZE_TEMP_DL];       // temporary mem for display lists

   TSystem LL_State;

   ALLOCOFFSCNMEMFUNC   pAllocOffScnMem;
   FREEOFFSCNMEMFUNC    pFreeOffScnMem;
   ASSERTMODEMCDFUNC    pAssertModeMCD;

   // recip table to support up to 2K x 2K resolution
   #define LAST_FRECIP 2048
   float   frecips[LAST_FRECIP+1];

   ULONG    pLastDevRC;
   DWORD    NumMCDContexts;

   ULONG    iUniqueness;

   // pointer to first and last entries in linked list of texture control blocks
   LL_Texture   *pFirstTexture;
   LL_Texture   *pLastTexture;
   // END OpenGL MCD additions
   #endif

    // Translation table cache.
    POFMHDL XlateCache;
    ULONG   XlateCacheId;
    WORD    CachedChromaCtrl;
    WORD    CachedStretchCtrl;

    DWORD   signature;         // Expected value: 0x12345678;

#if DATASTREAMING
	DWORD	dwDataStreaming;
	DWORD	shadowFGCOLOR;
	DWORD	shadowBGCOLOR;
	DWORD	shadowDRAWBLTDEF;
	BYTE	shadowQFREE;
#endif

} PDEV, *PPDEV;


// MCD Prototypes (MCD_TEMP??)
#ifndef WINNT_VER35
BOOL MCDrvGetEntryPoints(MCDSURFACE *pMCDSurface, MCDDRIVER *pMCDDriver);
#endif

DWORD getAvailableModes(HANDLE, PVIDEO_MODE_INFORMATION *, DWORD *);
BOOL bInitPDEV(PPDEV, PDEVMODEW, GDIINFO *, DEVINFO *);
BOOL bInitSURF(PPDEV, BOOL);
BOOL bInitPaletteInfo(PPDEV, DEVINFO *);
VOID InitPointer(PPDEV);
BOOL bInit256ColorPalette(PPDEV);
BOOL bInitPatterns(PPDEV, ULONG);
VOID vDisablePalette(PPDEV);
VOID vDisablePatterns(PPDEV);
VOID vDisableSURF(PPDEV);
BOOL LgMatchDriverToChip(PPDEV ppdev);



#define MAX_CLUT_SIZE (sizeof(VIDEO_CLUT) + (sizeof(ULONG) * 256))


//
// Pointer routines
//
VOID RestoreSaveShowCursor(PPDEV ppdev, LONG  x, LONG  y);
ULONG ConvertMaskBufToLinearAddr(PPDEV ppdev);


#ifdef WINNT_VER40
// GrabVideoFormat will set & test the VIDEO_FORMAT bit of
// pDriverData->VideoSemaphore if the bit was already set it
// will loop until the bit wasn't set at that point nobody else
// is modifying pDriverData->CurrentVideoFormat and/or
// pDriverData->NumVideoSurfaces so the caller is free to make
// their changes
void __inline GRAB_VIDEO_FORMAT_SEMAPHORE (WORD *pVideoSemaphore )
{
  _asm
  {
    mov     edi,pVideoSemaphore
    waitloop:
    bts     word PTR [edi],0
    jc      waitloop
  }
}

void __inline UNGRAB_VIDEO_FORMAT_SEMAPHORE (WORD *pVideoSemaphore)
{
  _asm
  {
    mov     edi,pVideoSemaphore
    btr     word PTR [edi],0
  }
}
/*
 * DrawEngineBusy should be replaced by a test to see the bltter is still
 * busy drawing
 */
static __inline BOOL DrawEngineBusy(DRIVERDATA* pDriverData)
{
  PVGAR pREG = (PVGAR) pDriverData->RegsAddress;

  return  ( pREG->grSTATUS != 0 );
}

// Convert offset into X, Y coordinate
static __inline DWORD cvlxy(LONG pitch, DWORD dwOffset, unsigned nBytesPixel)
{
  // Convert a linear frame buffer offset into a XY DWORD.
  // Offset mod pitch div bytes/pixel  = X
  // Offset div pitch          = Y
  return (MAKELONG((dwOffset % pitch) / nBytesPixel, (dwOffset / pitch)));
}

//
// DirectDraw function prototypes
//
void BltInit (PDEV* ppdev,  BOOL bEnableDisplayListBlts );
VOID vGetDisplayDuration(PFLIPRECORD pflipRecord);
HRESULT vUpdateFlipStatus(PFLIPRECORD pflipRecord, FLATPTR fpVidMem);
DWORD DdBlt(PDD_BLTDATA lpBlt);
DWORD Blt65(PDD_BLTDATA pbd);
DWORD DdFlip(PDD_FLIPDATA lpFlip);
DWORD DdLock(PDD_LOCKDATA lpLock);
DWORD DdUnlock(PDD_UNLOCKDATA lpUnlock);
DWORD DdGetBltStatus(PDD_GETBLTSTATUSDATA lpGetBltStatus);
DWORD DdGetFlipStatus(PDD_GETFLIPSTATUSDATA lpGetFlipStatus);
DWORD DdWaitForVerticalBlank(PDD_WAITFORVERTICALBLANKDATA lpWaitForVerticalBlank);
void SetGamma(PDEV* ppdev, DRIVERDATA* pDriverData);

DWORD CanCreateSurface (PDD_CANCREATESURFACEDATA lpInput);
DWORD CreateSurface (PDD_CREATESURFACEDATA lpInput);
DWORD DestroySurface (PDD_DESTROYSURFACEDATA lpInput);

//#ifdef  DDDRV_GETSCANLINE
DWORD GetScanLine(PDD_GETSCANLINEDATA lpGetScanLine);
//#endif

#endif  // WINNT_VER40 DirectDraw

//
// Determines the size of the DriverExtra information in the DEVMODE
// structure passed to and from the display driver.
//

#define DRIVER_EXTRA_SIZE 0



//
// Clipping Control Stuff
// Holds a list of clipping rectangles.  We give this structure to GDI, and
// GDI fills it in.
//

typedef struct {
  ULONG   c;
  RECTL   arcl[8];
} ENUMRECTS8;

typedef ENUMRECTS8 *PENUMRECTS8;

#define MIN(a, b) ((a) < (b) ? (a) : (b))
#define MAX(a, b) ((a) > (b) ? (a) : (b))



//
//////////////////////////////////////////////////////////////////////
// Text stuff
//

// DRAWBLTDEF values
#define TEXT_EXPAND_XPAR        0x106601F0
#define TEXT_EXPAND_OPAQUE      0x100600F0
#define SOLID_COLOR_FILL        0x100700F0

typedef struct _XLATECOLORS {       // Specifies foreground and background
ULONG   iBackColor;                 //   colours for faking a 1bpp XLATEOBJ
ULONG   iForeColor;
} XLATECOLORS;                      /* xlc, pxlc */

BOOL bEnableText(PDEV*);
VOID vDisableText(PDEV*);
VOID vAssertModeText(PDEV*, BOOL);

/*
  Function prototypes for device bitmap saving/restoring.
*/
BOOL bCreateDibFromScreen(PPDEV ppdev, PDSURF pdsurf);
BOOL bCreateScreenFromDib(PPDEV ppdev, PDSURF pdsurf);


#if ENABLE_LOG_FILE
// Function prototypes for logging information to disk

    HANDLE CreateLogFile(
        HANDLE hDriver,
        PDWORD Index);

    BOOL WriteLogFile(
        HANDLE hDriver,
        LPVOID lpBuffer,
        DWORD BytesToWrite,
        PCHAR TextBuffer,
        PDWORD Index);

    BOOL CloseLogFile(
        HANDLE hDriver,
        PCHAR TextBuffer,
        PDWORD Index);

    void DDFormatLogFile(
        LPSTR szFormat, ...);


#else
   #define CreateLogFile(a, b)
   #define WriteLogFile(a, b, c, d, e)
   #define CloseLogFile(a)
   #define DDFormatLogFile // turn it into a comment
#endif

// restore default structure alignment
#pragma pack()



=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\laguna\mini\include\lgtypes.h ===
/*****************************************************************************\
*
*	(c) Copyright 1991, Appian Technology Inc.
*	(c) Copyright 1995, Cirrus Logic, Inc.
*
*	Project:	Laguna
*
*	Title:		lgtypes.h
*
*	Environment:	Independent
*
*	Adapter:	Independent
*
*	Description:	Common type definitions for Laguna SW in general.
*
\*****************************************************************************/

#ifndef _LGTYPES_H
#define _LGTYPES_H

/*  We use #define here instead of typedef to make it easier on systems
    where these same types are also defined elsewhere, i.e., it is possible
    to use #ifdef, #undef, etc. on these types.  */

#define BYTE unsigned char
#define WORD unsigned short
// MARKEINKAUF removed this - mcdmath.h couldn't tolerate since using DWORD in inline asm
//#define DWORD unsigned long 
#define STATIC static

typedef unsigned long ul;
typedef unsigned short word;
typedef unsigned char byte;
typedef unsigned char boolean;


typedef struct PT { 
	WORD	X;
	WORD	Y;
} PT;


/* #define LOHI struct LOHI mae*/
typedef struct LOHI {
    WORD	LO;
    WORD	HI;
} LOHI;


typedef union _reg32 {
	DWORD	dw;
	DWORD	DW;
	PT		pt;
	PT		PT;
	LOHI	lh;
	LOHI	LH;
} REG32;


typedef struct LOHI16 {
	BYTE	LO;
    BYTE	HI;
} LOHI16;

typedef struct PT16 { 
	BYTE	X;
	BYTE	Y;
} PT16;


typedef union _reg16 {
	WORD	w;
	WORD	W;
	PT16	pt;
	PT16	PT;
	LOHI16	lh;
	LOHI16	LH;
} REG16;

#endif	/* ndef _98TYPES_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\laguna\mini\include\lines.h ===
/******************************Module*Header*******************************\
* Module Name: lines.h
*
* Line drawing constants and structures.
*
* NOTE: This file mirrors LINES.INC.  Changes here must be reflected in
* the .inc file!
*
* Copyright (c) 1992-1995 Microsoft Corporation
\**************************************************************************/

typedef struct _PDEV PDEV;      // Handy forward declaration

// We have to be careful that we don't overflow any registers when using
// the hardware to draw lines (as opposed to going through the strips
// routines, which will never overflow).  We accomplish this by simply
// checking the bounds of the path; if it is so large that any of the
// hardware terms may overflow, we punt the entire path to the strips
// code (should be pretty rare).

#define MAX_INTEGER_BOUND  (1535)   // S3's line length term is limited to
#define MIN_INTEGER_BOUND  (-512)   //   a maximum value of 2047

// We have special strip routines when all strips have at most this many
// pixels:

#define MAX_SHORT_STROKE_LENGTH 15

// # of strip drawers in every group:

#define NUM_STRIP_DRAW_DIRECTIONS 4

// # of strip drawers for doing either solid lines or styled lines:

#define NUM_STRIP_DRAW_STYLES 8

typedef LONG STYLEPOS;

#define STYLE_MAX_COUNT     16
#define STYLE_MAX_VALUE     0x3fffL
#define RUN_MAX             20
#define STRIP_MAX           100
#define STYLE_DENSITY       3

// Flip and round flags:

#define FL_H_ROUND_DOWN         0x00000080L     // .... .... 1... ....
#define FL_V_ROUND_DOWN         0x00008000L     // 1... .... .... ....

#define FL_FLIP_D               0x00000005L     // .... .... .... .1.1
#define FL_FLIP_V               0x00000008L     // .... .... .... 1...
#define FL_FLIP_SLOPE_ONE       0x00000010L     // .... .... ...1 ....
#define FL_FLIP_HALF            0x00000002L     // .... .... .... ..1.
#define FL_FLIP_H               0x00000200L     // .... ..1. .... ....

#define FL_ROUND_MASK           0x0000001CL     // .... .... ...1 11..
#define FL_ROUND_SHIFT          2

#define FL_RECTLCLIP_MASK       0x0000000CL     // .... .... .... 11..
#define FL_RECTLCLIP_SHIFT      2

#define FL_STRIP_MASK           0x00000003L     // .... .... .... ..11
#define FL_STRIP_SHIFT          0

#define FL_SIMPLE_CLIP          0x00000020      // .... .... ..1. ....
#define FL_COMPLEX_CLIP         0x00000040      // .... .... .1.. ....
#define FL_CLIP                (FL_SIMPLE_CLIP | FL_COMPLEX_CLIP)

#define FL_STYLED               0x00000400L     // .... .1.. .... ....
#define FL_ALTERNATESTYLED      0x00001000L     // ...1 .... .... ....

#define FL_STYLE_MASK           0x00000400L
#define FL_STYLE_SHIFT          10

#define FL_LAST_PEL_INCLUSIVE   0x00002000L     // ..1. .... .... ....

// Miscellaneous DDA defines:

#define LROUND(x, flRoundDown) (((x) + F/2 - ((flRoundDown) > 0)) >> 4)
#define F                     16
#define FLOG2                 4
#define LFLOOR(x)             ((x) >> 4)
#define FXFRAC(x)             ((x) & (F - 1))

////////////////////////////////////////////////////////////////////////////
// NOTE: The following structures must exactly match those declared in
//       lines.inc!

typedef struct _STRIP {
    LONG   cStrips;               // # of strips in array
    LONG   flFlips;               // Indicates if line goes up or down
    POINTL ptlStart;             // first point
    LONG   alStrips[STRIP_MAX];   // Array of strips
} STRIP;

typedef struct _LINESTATE {
    STYLEPOS*       pspStart;       // Pointer to start of style array
    STYLEPOS*       pspEnd;         // Pointer to end of style array
    STYLEPOS*       psp;            // Pointer to current style entry

    STYLEPOS        spRemaining;    // To go in current style
    STYLEPOS        spTotal;        // Sum of style array
    STYLEPOS        spTotal2;       // Twice sum of style array
    STYLEPOS        spNext;         // Style state at start of next line
    STYLEPOS        spComplex;      // Style state at start of complex clip line

    STYLEPOS*       aspRtoL;        // Style array in right-to-left order
    STYLEPOS*       aspLtoR;        // Style array in left-to-right order

    ULONG           ulStyleMask;    // Are we working on a gap in the style?
                                    // 0xff if yes, 0x0 if not
    ULONG           xyDensity;      // Density of style
    ULONG           cStyle;         // Size of style array

    ULONG           ulStyleMaskLtoR;// Original style mask, left-to-right order
    ULONG           ulStyleMaskRtoL;// Original style mask, right-to-left order

    BOOL            ulStartMask;    // Determines if first element in style
                                    // array is for a gap or a dash

} LINESTATE;                        /* ls */

// Strip drawer prototype:

typedef VOID (*PFNSTRIP)(PDEV*, STRIP*, LINESTATE*);
extern PFNSTRIP gapfnStrip[];

// Strip drawers:

VOID vssSolidHorizontal(PDEV* ppdev, STRIP *pStrip, LINESTATE *pLineState);
VOID vrlSolidHorizontal(PDEV* ppdev, STRIP *pStrip, LINESTATE *pLineState);

VOID vssSolidVertical(PDEV* ppdev, STRIP *pStrip, LINESTATE *pLineState);
VOID vrlSolidVertical(PDEV* ppdev, STRIP *pStrip, LINESTATE *pLineState);

VOID vssSolidDiagonalHorizontal(PDEV* ppdev, STRIP *pStrip, LINESTATE *pLineState);
VOID vrlSolidDiagonalHorizontal(PDEV* ppdev, STRIP *pStrip, LINESTATE *pLineState);

VOID vssSolidDiagonalVertical(PDEV* ppdev, STRIP *pStrip, LINESTATE *pLineState);
VOID vrlSolidDiagonalVertical(PDEV* ppdev, STRIP *pStrip, LINESTATE *pLineState);

VOID vStripStyledHorizontal(PDEV* ppdev, STRIP *pStrip, LINESTATE *pLineState);
VOID vStripStyledVertical(PDEV* ppdev, STRIP *pStrip, LINESTATE *pLineState);

// External calls:

BOOL bLines(PDEV*, POINTFIX*, POINTFIX*, RUN* prun, ULONG,
            LINESTATE*, RECTL*, PFNSTRIP*, FLONG);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\laguna\mini\include\l2d.h ===
/**************************************************************************
***************************************************************************
*
*     Copyright (c) 1996, Cirrus Logic, Inc.
*                 All Rights Reserved
*
* FILE:         l2d.h
*
* DESCRIPTION:
*
* REVISION HISTORY:
*
* $Log:   X:/log/laguna/ddraw/inc/L2D.H  $
* 
*    Rev 1.2   03 Oct 1997 14:04:04   RUSSL
* Added hw clip register defines
*
*    Rev 1.1   23 Jan 1997 17:16:04   bennyn
*
* Changed the register naming
*
*    Rev 1.0   25 Nov 1996 14:59:56   RUSSL
* Initial revision.
*
*    Rev 1.1   01 Nov 1996 13:02:46   RUSSL
* Merge WIN95 & WINNT code for Blt32
*
*    Rev 1.0   01 Nov 1996 09:28:32   BENNYN
* Initial revision.
*
*    Rev 1.0   25 Oct 1996 10:47:56   RUSSL
* Initial revision.
*
***************************************************************************
***************************************************************************/

/********************************************************************************
*
*   Module:     L2D.H           Header for 2D portion of the library
*
*   Revision:   1.00
*
*   Date:       04/10/96
*
*   Author:     Evan Leland
*
*********************************************************************************
*
*   Module Description:
*
*       This header file contais structures used in Laguna 2D
*       library.  This header is accessible to the user?
*
*   Note: do not change the values of these defines as some of them
*         are hard coded in the hardware
*
*********************************************************************************
*
*   Changes:
*
*   DATE     REV   DESCRIPTION OF CHANGES                 AUTHOR
* --------   ----  -----------------------------------   -----------
* 04/10/96   1.00  Original                              Evan Leland
* --------   ----  -----------------------------------   -----------
*********************************************************************************/

// If WinNT 3.5 skip all the source code
#if defined WINNT_VER35      // WINNT_VER35

#else


#ifndef _L2D_H_
#define _L2D_H_

//#if 0
//#include "l3d.h"                        // 3D definitions, functions
//#include "l3system.h"                   // low-level defs
//
//#define SSA_ARM     1
//#define VGA_FLIP    2
//
//#define misc_vga_ctrl     (*(BYTE  *)((BYTE *) LL_State.pRegs + 0x001a))
//#define vert_sync_end     (*(BYTE  *)((BYTE *) LL_State.pRegs + 0x0044))
//#define vert_disp_end     (*(BYTE  *)((BYTE *) LL_State.pRegs + 0x0048))
//#define vert_blnk_end     (*(BYTE  *)((BYTE *) LL_State.pRegs + 0x0058))
//#define cur_scnln_reg     (*(BYTE  *)((BYTE *) LL_State.pRegs + 0x0140))
//#define ssa_reg           (*(WORD  *)((BYTE *) LL_State.pRegs + 0x0144))
//#define mb_ctrl_reg       (*(BYTE  *)((BYTE *) LL_State.pRegs + 0x0148))
//#define pf_status_reg     (*(DWORD *)((BYTE *) LL_State.pRegs + 0x4424))
//#define host_3d_data_port (*(DWORD *)((BYTE *) LL_State.pRegs + 0x4800))
//
//typedef struct {                        // the following are cached:
//
//    DWORD   dwBGcolor;                  // background color register
//    DWORD   dwFGcolor;                  // foreground color register
//
//    BYTE    bCR1B;                      // vga extended display controls reg
//    BYTE    bCR1D;                      // vga screen start A extension reg
//
//    int     dPageFlip;                  // type of double buffering set
//
//} TSystem2D;
//
//typedef enum { BLT_MASTER_IO, BLT_Y15, BLT_LAGUNA1 } blt_type_t;
//
//// temp!
//void LL_DumpRegs();
//
//// constructor, destructor
//BOOL _InitLib_2D(LL_DeviceState *);
//BOOL _CloseLib_2D();
//
//DWORD SetColor_8bit  (LL_Color *pColor);
//DWORD SetColor_16bit (LL_Color *pColor);
//DWORD SetColor_15bit (LL_Color *pColor);
//DWORD SetColor_32bit (LL_Color *pColor);
//DWORD SetColor_Z24bit(LL_Color *pColor);
//
//// 2D operations using display list
//DWORD *fnColorFill(DWORD *dwNext, LL_Batch *pBatch);
//DWORD *fnCopyBuffer(DWORD *dwNext, LL_Batch *pBatch);
//DWORD *fnSetDisplayBuffer(DWORD *dwNext, LL_Batch *pBatch);
//DWORD *fnSetRenderBuffer(DWORD *dwNext, LL_Batch *pBatch);
//DWORD *fnSetFGColor(DWORD *dwNext, LL_Batch *pBatch);
//DWORD *fnSetBGColor(DWORD *dwNext, LL_Batch *pBatch);
//DWORD *fnCopyPattern(DWORD *dwNext, LL_Batch *pBatch);
//DWORD *fnMonoToColorExpand(DWORD *dwNext, LL_Batch *pBatch);
//DWORD *fnTransparentBLT(DWORD *dwNext, LL_Batch *pBatch);
//DWORD *fnZFill(DWORD *dwNext, LL_Batch *pBatch);
//DWORD *fnResizeBLT(DWORD *dwNext, LL_Batch *pBatch);
//DWORD *fnWaitForPageFlip(DWORD *dwNext, LL_Batch *pBatch);
//
////
//// TEMP: 5464 resize data formats
////
//#define LL_RESIZE_CLUT          0x0
//#define LL_RESIZE_1555          0x1
//#define LL_RESIZE_565           0x2
//#define LL_RESIZE_RGB           0x3
//#define LL_RESIZE_ARGB          0x4
//#define LL_RESIZE_YUV           0x9
//
//#define LL_X_INTERP             0x4
//#define LL_Y_INTERP             0x8
//
//// blt type INTERNAL identifiers
////
//
//#define LL_BLT_MONO_PATTERN     2
//#define LL_BLT_COLOR_PATTERN    3
//
//#define BLT_SRC_COPY            0
//#define BLT_MONO_EXPAND         1
//#define BLT_MONO_TRANSPARENCY   4
//#define BLT_COLOR_TRANSPARENCY  5
//#define BLT_RESIZE              6
//
//#define BLT_FF                  0x0     // blt frame-frame
//#define BLT_HF                  0x1     // blt host-frame
//#define BLT_FH                  0x2     // blt frame-host
//#define BLT_HH                  0x3     // blt host-host
//#endif

//
//  2D register (sub)set
//

#define COMMAND_2D              0x480
//#if 0
//#define CONTROL                 0x402
//#define BITMASK                 0x5E8
//#define BLTDEF                  0x586
//#define DRAWDEF                 0x584
//#define LNCNTL                  0x50E   // name conflicts with autoblt_regs!
//#define STRETCH                 0x510
//#define STATUS                  0x400
//
#define L2D_OP0_OPRDRAM           0x520
//#define L2D_OP1_OPRDRAM           0x540
//#define L2D_OP2_OPRDRAM           0x560
#define L2D_OP0_OPMRDRAM          0x524
//#define L2D_OP1_OPMRDRAM          0x544
//#define L2D_OP2_OPMRDRAM          0x564
//#define L2D_OP0_OPSRAM            0x528
//#define L2D_OP1_OPSRAM            0x548
//#define L2D_OP2_OPSRAM            0x568
//#define L2D_OP1_OPMSRAM           0x54A
//#define L2D_OP2_OPMSRAM           0x56A
//#define L2D_OP_BGCOLOR            0x5E4
//#define L2D_OP_FGCOLOR            0x5E0
//#endif

#define L2D_CLIPULE               0x590
#define L2D_CLIPLOR               0x594
#define L2D_MCLIPULE              0x598
#define L2D_MCLIPLOR              0x59C

#define L2D_BLTEXT_EX             0x700
#define L2D_MBLTEXT_EX            0x720
//#define BLTEXT_XEX              0x600
#define L2D_BLTEXTR_EX            0x708
#define L2D_MBLTEXTR_EX           0x728

#define L2D_CLIPULE_EX            0x760
#define L2D_CLIPLOR_EX            0x770
#define L2D_MCLIPULE_EX           0x780
#define L2D_MCLIPLOR_EX           0x790

//#if 0
//#define PATOFF                  0x52A   // name conflicts with autoblt_regs!
//#define SHRINKINC               0x582   // name conflicts with autoblt_regs!
//#define SRCX                    0x580   // name conflicts with autoblt_regs!
//#define MAJX                    0x50A
//#define MAJY                    0x502
//#define MINX                    0x508
//#define MINY                    0x500
//#define ACCUMX                  0x50c
//#define ACCUMY                  0x504
//#define ALPHA_AB                0x5e0
//#define CHROMA_CTL              0x512
//#define CHROMA_LOW              0x5f0
//#define CHROMA_UPR              0x5f4
//#define HOSTDATA                0x800
//
//#define OFFSET_2D               0x405
//#define TIMEOUT                 0x406
//#define TILE_CTRL               0x407
//#endif

//
//  the same 2D registers for use with COMMAND register burst writes
//

#define C_MINY                  0x0080
#define C_MAJY                  0x0081
#define C_ACCUMY                0x0082
#define C_MINX                  0x0084
#define C_MAJX                  0x0085
#define C_ACCUMX                0x0086
#define C_LNCNTL                0x0087
#define C_STRCTL                0x0088
#define C_CMPCNTL               0x0089
#define C_RX_0                  0x0090
#define C_RY_0                  0x0091
#define C_MRX_0                 0x0092
#define C_MRY_0                 0x0093
#define C_SRAM_0                0x0094
#define C_PATOFF                0x0095

#define C_RX_1                  0x00a0
#define C_RY_1                  0x00a1
#define C_MRX_1                 0x00a2
#define C_MRY_1                 0x00a3
#define C_SRAM_1                0x00a4
#define C_MSRAM_1               0x00a5

#define C_RX_2                  0x00b0
#define C_RY_2                  0x00b1
#define C_MRX_2                 0x00b2
#define C_MRY_2                 0x00b3
#define C_SRAM_2                0x00b4
#define C_MSRAM_2               0x00b5

#define C_SRCX                  0x00c0
#define C_SHINC                 0x00c1
#define C_DRWDEF                0x00c2
#define C_BLTDEF                0x00c3
#define C_MONOQW                0x00c4

#define C_BLTX                  0x0100
#define C_BLTY                  0x0101
#define C_MBLTX                 0x0110

#define C_EX_BLT                0x0200
#define C_EX_FBLT               0x0201
#define C_EX_RBLT               0x0202
#define C_EX_LINE               0x0203
#define C_FG_L                  0x00f0
#define C_FG_H                  0x00f1
#define C_BG_L                  0x00f2
#define C_BG_H                  0x00f3
#define C_BITMSK_L              0x00f4
#define C_BITMSK_H              0x00f5
#define C_PTAG                  0x00f6
#define C_CHROMAL_L             0x00f8
#define C_CHROMAL_H             0x00f9
#define C_CHROMAU_L             0x00fa
#define C_CHROMAU_H             0x00fb

#define C_CLIPULE_X             0x00c8
#define C_CLIPULE_Y             0x00c9
#define C_CLIPLOR_X             0x00ca
#define C_CLIPLOR_Y             0x00cb

#define C_MCLIPULE_X            0x00cc
#define C_MCLIPULE_Y            0x00cd
#define C_MCLIPLOR_X            0x00ce
#define C_MCLIPLOR_Y            0x00cf

#define C_BLTEXT_X              0x008c
#define C_BLTEXT_Y              0x008d
#define C_MBLTEXT_X             0x008e
#define C_MBLTEXT_Y             0x008f

//
// VGA registers
//

#define VGA_REG140              0x0140
#define VGA_SCANLINE_COMPARE    0x0142
#define VGA_SSA_REG             0x0144
#define VGA_MB_CTRL             0x0148

#define VGA_HTOTAL              0x0000
#define VGA_HDISP_END           0x0004
#define VGA_HBLNK_START         0x0008
#define VGA_HBLNK_END           0x000C
#define VGA_HSYNC_START         0x0010
#define VGA_HSYNC_END           0x0014

#define VGA_VTOTAL              0x0018
#define VGA_VDISP_END           0x0048
#define VGA_VBLNK_START         0x0054
#define VGA_VBLNK_END           0x0058
#define VGA_VSYNC_START         0x0040
#define VGA_VSYNC_END           0x0044

#define VGA_SSA_H               0x0030
#define VGA_SSA_L               0x0034
#define VGA_CR1B                0x006C
#define VGA_CR1D                0x0074
#define VGA_PAL_ADDR_READ       0x00A4
#define VGA_PAL_ADDR_WRITE      0x00A8
#define VGA_PIXEL_DATA          0x00AC
#define VGA_CLUT_LOAD           0x009c
#define VGA_CURSOR_PRESET       0x00E4
#define VGA_MISC_CONTROL        0x00e6
#define VGA_CURSOR_ADDR         0x00e8
#define VGA_CURSOR_X            0x00e0
#define VGA_CURSOR_Y            0x00e2
#define VGA_PAL_STATE           0x00b0

#define DTTR                    0xEA
#define CONTROL                 0x402

//
// host data port: in host data device
//
#define HD_PORT                 0x800

//
// 2D versions of some 3D registers shadowed in l3d.h:
// Most register defines are divided by four so that they can be added correctly
// to the global register file pointer, LL_State.pRegs, which is a dword pointer.
// Some 2D operations need these registers defined in their full glory for use
// with write_dev_regs:

///////////////////////////////////////////////////////
//  HostXY Unit Registers - Must use WRITE_DEV_REGS  //
///////////////////////////////////////////////////////

#define HXY_BASE0_ADDRESS_PTR   0x4200
#define HXY_BASE0_START_XY      0x4204
#define HXY_BASE0_EXTENT_XY     0x4208
#define HXY_BASE1_ADDRESS_PTR   0x4210
#define HXY_BASE1_OFFSET0       0x4214
#define HXY_BASE1_OFFSET1       0x4218
#define HXY_BASE1_LENGTH        0x421C
#define HXY_HOST_CTRL           0x4240

//
// Laguna Format 1 instruction useful defines
//

#define DEV_VGAMEM              0x00000000
#define DEV_VGAFB               0x00200000
#define DEV_VPORT               0x00400000
#define DEV_LPB                 0x00600000
#define DEV_MISC                0x00800000
#define DEV_ENG2D               0x00A00000
#define DEV_HD                  0x00C00000
#define DEV_FB                  0x00E00000
#define DEV_ROM                 0x01000000
#define DEV_ENG3D               0x01200000
#define DEV_HOSTXY              0x01400000
#define DEV_HOSTDATA            0x01600000

#define F1_ADR_MASK             0x0001FFC0
#define F1_CNT_MASK             0x0000003f
#define F1_STL_MASK             0x04000000
#define F1_ADR_SHIFT            6
#define F1_STL_SHIFT            26
#define F1_BEN_SHIFT            17
#define F1_BEN_MASK             0x001e0000

//
// Laguna Format 2 instruction useful defines
//

#define F2_STL_SHIFT            26
#define F2_ADR_SHIFT            2
#define F2_STL_MASK             0x04000000
#define F2_ADR_MASK             0x003ffffc
#define F2_INC_MASK             0x00000001

//
// Laguna events for Format 4 instructions
//

#define EV_VBLANK               0x00000001
#define EV_EVSYNC               0x00000002
#define EV_LINE_COMPARE         0x00000004
#define EV_BUFFER_SWITCH        0x00000008
#define EV_Z_BUFFER_COMPARE     0x00000010
#define EV_POLY_ENG_NOT_BUSY    0x00000020
#define EV_EXEC_ENG_3D_NOT_BUSY 0x00000040
#define EV_XY_ENG_NOT_BUSY      0x00000080
#define EV_BLT_ENG_NOT_BUSY     0x00000100
#define EV_BLT_WF_NOT_EMPTY     0x00000200
#define EV_DL_READY_STATUS      0x00000400

#define EV_FETCH_MODE           0x00000800
//
// Format 4 masks
//

#define F4_STL_SHIFT    26
#define F4_NOT_MASK     0x01000000
#define F4_STL_MASK     0x04000000
#define F4_EVN_MASK     0x000007ff

//
// Emulator macros for building Laguna operations in display list
//

#define write_dev_regs(dev, ben, adr, cnt, stl) \
    (WRITE_DEV_REGS                         |   \
  (((stl) << F1_STL_SHIFT) & F1_STL_MASK)   |   \
    (dev)                                   |   \
  (((ben) << F1_BEN_SHIFT) & F1_BEN_MASK)   |   \
  (((adr) << F1_ADR_SHIFT) & F1_ADR_MASK)   |   \
   ((cnt)                  & F1_CNT_MASK))

#define read_dev_regs(dev, adr, cnt, stl)       \
    (READ_DEV_REGS                          |   \
  (((stl) << F1_STL_SHIFT) & F1_STL_MASK)   |   \
    (dev)                                   |   \
  (((adr) << F1_ADR_SHIFT) & F1_ADR_MASK)   |   \
   ((cnt)                  & F1_CNT_MASK))

#define write_dest_addr(adr, inc, stl)          \
    (WRITE_DEST_ADDR                        |   \
  (((stl) << F2_STL_SHIFT) & F2_STL_MASK)   |   \
  (((adr) << F2_ADR_SHIFT) & F2_ADR_MASK)   |   \
   ((inc)                  & F2_INC_MASK))

#define wait_3d(evn, stl)                       \
    (WAIT                                   |   \
  (((stl) << F4_STL_SHIFT) & F4_STL_MASK)   |   \
   ((evn)                  & F4_EVN_MASK))

#define nwait_3d(evn, stl)                      \
    (WAIT                                   |   \
  (((stl) << F4_STL_SHIFT) & F4_STL_MASK)   |   \
                             F4_NOT_MASK    |   \
   ((evn)                  & F4_EVN_MASK))

// opcode common to the control instructions
//
#define CONTROL_OPCODE  0x68000000
#define NOP_SUB_OPCODE  0x00800000

#define nop_3d(stl)                             \
    (CONTROL_OPCODE | NOP_SUB_OPCODE | (stl << 26))

//#if 0
////  useful macros:
////
////  setreg, no cache: do not cache state for this register
////
//#define SETREGB_NC(reg, value)                                                      \
//    (*((BYTE *) ((BYTE *) LL_State.pRegs + reg)) = value)
//
//#define SETREGW_NC(reg, value)                                                      \
//    (*((WORD *) ((BYTE *) LL_State.pRegs + reg)) = value)
//
//#define SETREGD_NC(reg, value)                                                      \
//    (*((DWORD *) ((BYTE *) LL_State.pRegs + reg)) = value)
//
//#define SETREG_3D(reg, value)                                                       \
//    (*((DWORD *) (LL_State.pRegs + reg)) = value)
//
//// set 2d reg with cache
////
//#define SETREGD_2D(offset, reg, value)                                              \
//    (*((DWORD *) ((BYTE *) LL_State.pRegs + (offset))) = LL_State2D.reg = (value))
//
//// wait for events in coprocessor mode
////
//#if 0
//#define wait_and_3d(event)                                                          \
//    {                                                                               \
//        DWORD   status;                                                             \
//        while ((status = (*((DWORD *)LL_State.pRegs + PF_STATUS_3D)) & event)) {};  \
//    }
//#else
//#define wait_and_3d(event)                                                          \
//    {                                                                               \
//        while ((*((DWORD *)LL_State.pRegs + PF_STATUS_3D)) & event) {};             \
//    }
//#endif
//
//#define host_host(src, dst)                         \
//    ((src->dwFlags & BUFFER_IN_SYSTEM) &&           \
//     (dst->dwFlags & BUFFER_IN_SYSTEM))
//
//#define host_frame(src, dst)                        \
//    ((src->dwFlags & BUFFER_IN_SYSTEM) &&           \
//    !(dst->dwFlags & BUFFER_IN_SYSTEM))
//
//#define frame_host(src, dst)                        \
//    (!(src->dwFlags & BUFFER_IN_SYSTEM) &&          \
//      (dst->dwFlags & BUFFER_IN_SYSTEM))
//
//#define frame_frame(src, dst)                       \
//    (!(src->dwFlags & BUFFER_IN_SYSTEM) &&          \
//     !(dst->dwFlags & BUFFER_IN_SYSTEM))
//
//#define GetColor(pixel_mode, pColor, which)                         \
//    switch (pixel_mode)                                             \
//    {                                                               \
//        case PIXEL_MODE_332:                                        \
//            pColor->r =  LL_State2D.which & 0xe0;                   \
//            pColor->g = (LL_State2D.which & 0x1c) << 3;             \
//            pColor->b = (LL_State2D.which & 0x02) << 6;             \
//            break;                                                  \
//        case PIXEL_MODE_555:                                        \
//            pColor->r = (LL_State2D.which & 0x7c00) >> 7;           \
//            pColor->g = (LL_State2D.which & 0x03e0) >> 2;           \
//            pColor->b = (LL_State2D.which & 0x001f) << 3;           \
//            break;                                                  \
//        case PIXEL_MODE_565:                                        \
//            pColor->r = (LL_State2D.which & 0xf800) >> 8;           \
//            pColor->g = (LL_State2D.which & 0x07e0) >> 3;           \
//            pColor->b = (LL_State2D.which & 0x001f) << 3;           \
//            break;                                                  \
//        case PIXEL_MODE_A888:                                       \
//        case PIXEL_MODE_Z888:                                       \
//            pColor->r = (LL_State2D.which & 0xff0000) >> 16;        \
//            pColor->g = (LL_State2D.which & 0x00ff00) >> 8;         \
//            pColor->b = (LL_State2D.which & 0x0000ff);              \
//            break;                                                  \
//        default:                                                    \
//            pColor->r = 0;                                          \
//            pColor->g = 0;                                          \
//            pColor->b = 0;                                          \
//            break;                                                  \
//    }
//
//#define blt_buf_set_bpp(pBuf, bpp)                                  \
//    if (pBuf == LL_State.pBufZ)                                     \
//    {                                                               \
//        bpp = LL_State.Control0.Z_Stride_Control ? 8 : 16;          \
//    }                                                               \
//    else                                                            \
//    {                                                               \
//        bpp = LL_State.wBpp;                                        \
//    }
//
//#define blt_buf_set_pix_mode(pBuf, pmode)                           \
//    if (pBuf == LL_State.pBufZ)                                     \
//    {                                                               \
//        pmode = LL_State.Control0.Z_Stride_Control ?                \
//                PIXEL_MODE_332 : PIXEL_MODE_565;                    \
//    }                                                               \
//    else                                                            \
//    {                                                               \
//        pmode = LL_State.Control0.Pixel_Mode;                       \
//    }
//
//// pixels per dword
////
//#define px_per_dw(bpp)  (32 / (bpp))
//
//// bytes per pixel ... NOTE: don't use with 1 bpp!!
////
//#define by_per_px(bpp)  (bpp / 8)
//
//#define set_color(color, _r, _g, _b)    \
//        color.r = _r;                   \
//        color.g = _g;                   \
//        color.b = _b;
//
//#define set_vert(vert, _x, _y)          \
//        vert.x = _x;                    \
//        vert.y = _y;
//
//#define set_rect(rect, x1, y1, x2, y2)  \
//        rect.left   = x1;               \
//        rect.top    = y1;               \
//        rect.right  = x2;               \
//        rect.bottom = y2;
//
//#define print_2d_status(i)              \
//        printf("status register %d: %04x\n", i, *(WORD *)((BYTE *)LL_State.pRegs + STATUS))
//
//#define get_2d_status()                 \
//        (* (WORD *) ( (BYTE *) LL_State.pRegs + STATUS ) )
//#endif

#endif // _L2D_H_
#endif // WINNT_VER35
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\laguna\mini\include\memmgr.h ===
/******************************Module*Header*******************************\
 *
 * Module Name: memmgr.h
 *
 * contains prototypes for the memory manager.
 *
 * Copyright (c) 1997 Cirrus Logic, Inc.
 *
 * $Log:   X:/log/laguna/nt35/displays/cl546x/memmgr.h  $
* 
*    Rev 1.4   18 Sep 1997 16:13:28   bennyn
* 
* Fixed NT 3.51 compile/link problem
* 
*    Rev 1.3   12 Sep 1997 12:06:32   bennyn
* 
* Modified for DD overlay support.
* 
*    Rev 1.2   08 Aug 1997 14:34:10   FRIDO
* Added SCREEN_ALLOCATE and MUST_HAVE flags.
* 
*    Rev 1.1   26 Feb 1997 10:46:08   noelv
* Added OpenGL MCD code from ADC.
* 
*    Rev 1.0   06 Feb 1997 10:34:10   noelv
* Initial revision.
 *
\**************************************************************************/

#ifndef _MEMMGR_H_
#define _MEMMGR_H_    

/*
 * Be sure to synchronize these structures with those in i386\Laguna.inc!
 */

#pragma pack(1)

//
// For offscreen memory manager
//
typedef VOID (*POFM_CALLBACK)();

#define NO_X_TILE_AlIGN       0x1
#define NO_Y_TILE_AlIGN       0x2
#define PIXEL_AlIGN           0x4
#define DISCARDABLE_FLAG      0x8
#define SAVESCREEN_FLAG	      0x10
#define SCREEN_ALLOCATE       0x4000
#define MUST_HAVE             0x8000

#define MCD_NO_X_OFFSET         0x20    //MCD - allows forcing AllocOffScnMem to get block with x=0
#define MCD_Z_BUFFER_ALLOCATE   0x40    //MCD - force 16 bpp allocate for Z on 32 scanline boundary
#define MCD_DRAW_BUFFER_ALLOCATE 0x80   //MCD - force allocate for 3d backbuffer on 32 scanline boundary
                                        
#define MCD_TEXTURE8_ALLOCATE   0x100   //MCD - force  8 bpp block for texture map 
#define MCD_TEXTURE16_ALLOCATE  0x200   //MCD - force 16 bpp block for texture map 
#define MCD_TEXTURE32_ALLOCATE  0x400   //MCD - force 32 bpp block for texture map 

#define EIGHT_BYTES_ALIGN       0x800   // Align in 8 bytes boundary

#define MCD_TEXTURE_ALLOCATE    (MCD_TEXTURE8_ALLOCATE|MCD_TEXTURE16_ALLOCATE|MCD_TEXTURE32_ALLOCATE)
#define MCD_TEXTURE_ALLOC_SHIFT 8       //num bits to shift alignflag to get numbytes per texel

typedef struct _OFMHDL
{
  ULONG  x;                   // actual X, Y position
  ULONG  y;
  ULONG  aligned_x;           // aligned X, Y position
  ULONG  aligned_y;
  LONG   sizex;               // Allocated X & Y sizes (in bytes)
  LONG   sizey;
  ULONG  alignflag;           // Alignment flag
  ULONG  flag;                // Status flag
  POFM_CALLBACK  pcallback;   // callback function pointer
  struct _OFMHDL *prevhdl;
  struct _OFMHDL *nexthdl;
  struct _OFMHDL *subprvhdl;
  struct _OFMHDL *subnxthdl;
  struct _OFMHDL *prvFonthdl;
  struct _OFMHDL *nxtFonthdl;
  struct _DSURF *pdsurf;       // If this offscreen memory block holds a 
                               // device bitmap, then this is it. 
} OFMHDL, *POFMHDL;


#if DRIVER_5465 && defined(OVERLAY) && defined(WINNT_VER40)
#else
typedef struct _DDOFM
{
  struct _DDOFM   *prevhdl;
  struct _DDOFM   *nexthdl;
  POFMHDL         phdl;
} DDOFM, *PDDOFM;
#endif



//
// Offscreen memory manager function prototypes
//
BOOL InitOffScnMem(struct _PDEV *ppdev);
POFMHDL AllocOffScnMem(struct _PDEV *ppdev, PSIZEL surf, ULONG alignflag, POFM_CALLBACK pcallback);
BOOL FreeOffScnMem(struct _PDEV *ppdev, POFMHDL psurf);
void CloseOffScnMem(struct _PDEV *ppdev);
PVOID ConvertToVideoBufferAddr(struct _PDEV *ppdev, POFMHDL psurf);
POFMHDL DDOffScnMemAlloc(struct _PDEV *ppdev);
void  DDOffScnMemRestore(struct _PDEV *ppdev);

// restore default structure alignment
#pragma pack()

#endif // _MEMMGR_H_


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\laguna\mini\include\l3d.h ===
/**************************************************************************
***************************************************************************
*
*     Copyright (c) 1997, Cirrus Logic, Inc.
*                 All Rights Reserved
*
* FILE:         l3d.h
*
* DESCRIPTION:  546X 3D engine defines and structures
*
* AUTHOR:       Goran Devic, Mark Einkauf
*
***************************************************************************
***************************************************************************/
#ifndef _L3D_H_
#define _L3D_H_

/*********************************************************************
*   Defines and basic types
**********************************************************************/
#ifndef OPENGL_MCD	// LL3D's type.h redundant with basic type definitions in other DDK/msdev headers
#include "type.h"                   /* Include basic types           */
#endif // ndef OPENGL_MCD

/*********************************************************************
*
*   Library initialization defines
*
**********************************************************************/
#define LL_USE_BUFFER_B     0x0001  /* Use double buffering          */
#define LL_USE_BUFFER_Z     0x0002  /* Use Z buffer                  */
#define LL_BUFFER_Z_8BPP    0x0004  /* Use 8bpp instead of 16bpp Z   */
#define LL_BUFFER_Z888      0x0008  /* Only in 32bpp use Z888        */
#define LL_8BPP_INDEXED     0x0010  /* Only in 8bpp - indexed mode   */
#define LL_HARDWARE_CURSOR  0x0020  /* Use hardware cursor           */

/*********************************************************************
*
*   Buffer identification numbers and Z stride info. 
*
*   Used with LL_InitLib()
*
**********************************************************************/
#define LL_ID_BUFFER_A      0       /* ID of the primary buffer      */
#define LL_ID_BUFFER_B      1       /* ID of the secondary buffer    */
#define LL_ID_BUFFER_Z      2       /* ID of the Z buffer in RDRAM   */


/*********************************************************************
*
*   Destination defines for the objects
*
*   Used with LL_SetZBuffer
*
**********************************************************************/
#define LL_IN_RDRAM         0       /* Object is in the RDRAM memory */
#define LL_IN_HOST          1       /* Object is in Host memory      */


/*********************************************************************
*
*   Rendering mode
*
*   Used with LL_SetRenderingMode
*
**********************************************************************/
#define LL_PROCESSOR_MODE   0       /* Use processor mode            */
#define LL_COPROCESSOR_MODE 1       /* Use coprocessor indirect mode */


/*********************************************************************
*
*   Texture flag values
*
*   Used with LL_RegisterTexture
*
**********************************************************************/
#define LL_SYSTEM_ONLY      1       /* Put texture in system memory  */
#define LL_VIDEO_ONLY       2       /* Put texture in video memory   */
#define LL_DEFAULT          0       /* Try video, then system        */

/*********************************************************************
*
*   Texture types
*
*   Used with LL_RegisterTexture
*
**********************************************************************/
#define LL_TEX_4BPP         0       /* 4 Bpp indexed                 */
#define LL_TEX_8BPP         2       /* 8 Bpp indexed                 */
#define LL_TEX_332          3       /* 3:3:2 true color              */
#define LL_TEX_565          4       /* 5:6:5 true color              */
#define LL_TEX_1555         5       /* (mask):5:5:5 true color       */
#define LL_TEX_1888         6       /* (mask):8:8:8 true color       */
#define LL_TEX_8_ALPHA     10       /* alpha only                    */
#define LL_TEX_4444        12       /* 4:4:4:4 true color            */
#define LL_TEX_8888        14       /* 8:8:8:8 true color            */


/*********************************************************************
*
*   Cursor modes 
*
*   Used with LL_SetCursor        
*
**********************************************************************/
#define LL_CUR_DISABLE      0       /* Turn off cursor               */
#define LL_CUR_32x3         1       /* 32x32 cursor, 3 colors/t      */
#define LL_CUR_32x2         2       /* 32x32 cursor, 2 colors        */
#define LL_CUR_32x2H        3       /* 32x32 cursor, 2 colors+hghlt  */
#define LL_CUR_64x3         5       /* 64x64 cursor, 3 colors/t      */
#define LL_CUR_64x2         6       /* 64x64 cursor, 2 colors        */
#define LL_CUR_64x2H        7       /* 64x64 cursor, 2 colors+hghlt  */

//These are new for CGL 1.70, and are defined in CGL as:
#define LL_ALT_32x3         0x09
#define LL_ALT_32x2H        0x0A
#define LL_ALT_32x2         0x0B
#define LL_ALT_64x3         0x0D
#define LL_ALT_64x2H        0x0E
#define LL_ALT_64x2         0x0F

#define NEED_MOUSE_UPDATE   0x01 //if the coordinates of cursor need updated
#define MOUSE_IS_UPDATED    0x00 //if the coordinates have been updated

/*********************************************************************
*
*   Z Compare modes:
*
*   Used with LL_SetZCompareMode(mode), LL_GetZCompareMode()
*
**********************************************************************/
#define LL_Z_WRITE_GREATER_EQUAL   0x00000000  /* True if new >= old */
#define LL_Z_WRITE_GREATER         0x00000001  /* True if new >  old */
#define LL_Z_WRITE_LESS_EQUAL      0x00000002  /* True if new <= old */
#define LL_Z_WRITE_LESS            0x00000003  /* True if new <  old */
#define LL_Z_WRITE_NOT_EQUAL       0x00000004  /* True if new <> old */
#define LL_Z_WRITE_EQUAL           0x00000005  /* True if new =  old */

/*********************************************************************
*
*   Functional Z modes:
*
*   Used with LL_SetZMode(mode), LL_GetZMode()
*
**********************************************************************/
#define LL_Z_MODE_NORMAL           0x00000000  /* Normal operation   */
#define LL_Z_MODE_MASK             0x00000001  /* Z not written      */
#define LL_Z_MODE_ALWAYS           0x00000002  /* Z, color always wrt*/
#define LL_Z_MODE_ONLY             0x00000003  /* Color not written  */
#define LL_Z_MODE_HIT              0x00000004  /* collision dtct only*/



/*********************************************************************
*
*   Color compare controls
*
*   Used with LL_ColorBoundsControl( dwControl)
*
**********************************************************************/
#define LL_COLOR_SATURATE_ENABLE   0x00000040  /* for indexed mode   */
#define LL_COLOR_SATURATE_DISABLE  0x00000000  /* (default)          */

#define LL_COLOR_COMPARE_INCLUSIVE 0x00000400  /* tc modes           */
#define LL_COLOR_COMPARE_EXCLUSIVE 0x00000000  /* tc modes (default) */
#define LL_COLOR_COMPARE_BLUE      0x00000200  /* blue (default off) */
#define LL_COLOR_COMPARE_GREEN     0x00000100  /* green (default off)*/
#define LL_COLOR_COMPARE_RED       0x00000080  /* red (default off)  */


/*********************************************************************
*
*   Notes on Alpha blending and Lighting section:
*
*   If used separately, every combination of alpha mode and destination
*   is valid.  Note that if LL_ALPHA_DEST_INTERP or LL_LIGHTING_INTERP_RGB
*   are selected, color interpolators may not be used.
*
*   When using alpha blending and lighting at the same time, be careful
*   not to use Polyeng or LA-interpolators more than once.
*
**********************************************************************/
/*********************************************************************
*
*   Alpha mode:  Magnitude of alpha blending will be taken from
*       - constant alpha, use LL_SetConstantAlpha(src/new,dest/old)
*           this mode uses LA-interpolators
*       - interpolated, variable alpha from LA-interpolators
*           this mode also uses LA-interpolators
*       - alpha field from the frame buffer
*
*   Used with LL_SetAlphaMode(mode), LL_GetAlphaMode()
*
**********************************************************************/
#define LL_ALPHA_CONST             0x00000000  /* Constant alpha     */
#define LL_ALPHA_TEXTURE           0x00000001  /* Texture  alpha     */
#define LL_ALPHA_INTERP            0x00000002  /* Using LA interp.   */
#define LL_ALPHA_FRAME             0x00000003  /* Using frame values */

/*********************************************************************
*
*   Alpha destination: Selects where the second color input to the 
*       alpha multiplier comes from
*       - color from the frame buffer ("normal" alpha blending)
*       - constant color (also called fog) from COLOR0 register
*       - interpolated, shaded color from the polygon engine (also fog)
*           also LL_GOURAUD must be set in the flags
*           this mode uses Polyengine color registers
*
*   Fog: Use aliases LL_FOG_CONST and LL_FOG_INTERP to avoid fetching
*       colors from the frame and to set the fog color.
*
*   Used with LL_SetAlphaDestColor(mode), LL_GetAlphaDestColor()
*
**********************************************************************/
#define LL_ALPHA_DEST_FRAME        0x00000000  /* Using frame color  */
#define LL_ALPHA_DEST_CONST        0x00000001  /* Constant color     */
#define LL_ALPHA_DEST_INTERP       0x00000002  /* Using poly engine  */

#define LL_FOG_CONST               0x00000001  /* Constant fog       */
#define LL_FOG_INTERP              0x00000002  /* Using poly engine  */

/*********************************************************************
*
*   Lighting source: Selects the value for the lighting multiplier
*       - interpolated light from the polygon engine
*           load lighting values as r,g,b components
*           also LL_GOURAUD must be set in the flags
*           this mode uses Polyengine color registers
*       - interpolated light from the alpha interpolator
*           load lighting values as alpha components
*           this mode uses LA-interpolators
*       - constant light from the COLOR1 register
*
*   Used with LL_SetLightingSource(mode), LL_GetLightingSource()
*
**********************************************************************/
#define LL_LIGHTING_INTERP_RGB     0x00000000  /* Using poly engine  */
#define LL_LIGHTING_INTERP_ALPHA   0x00000001  /* Using LA interp.   */
#define LL_LIGHTING_CONST          0x00000002  /* Constant light     */
#define LL_LIGHTING_TEXTURE        0x00000003  /* FrameScaling Mode  */


/*********************************************************************
*
*   Rendering instruction modifiers
*
*   Used in dwFlags field with LL_POINT...LL_INDEXED_POLY
*
**********************************************************************/
#define LL_SAME_COLOR   0x00008000  /* Use previously loaded color   */
#define LL_Z_BUFFER     0x00002000  /* Use Z buffer                  */
#define LL_ALPHA        0x00000001  /* Do Alpha blending             */
#define LL_LIGHTING     0x00040000  /* Do lighting                   */
#define LL_STIPPLE      0x00080000  /* Enable stipple or             */
#define LL_PATTERN      0x00100000  /* Enable pattern or             */
#define LL_DITHER       0x00200000  /* Enable dither,use PATTERN_RAM */
#define LL_GOURAUD      0x00001000  /* Enable Gouraud shading        */
#define LL_TEXTURE      0x00020000  /* Use texture mapping           */
#define LL_PERSPECTIVE  0x00010000  /* Perspective corrected texture */
#define LL_TEX_FILTER   0x40000000  /* Filtered textures             */
#define LL_TEX_SATURATE 0x20000000  /* Texture saturation (opp wrap) */
#define LL_TEX_DECAL    0x10000000  /* Texture masking (1555,1888)   */
#define LL_TEX_DECAL_INTERP 0x18000000  /*Texture masking (1555,1888)*/

//positions in TxCtl0_3D register
#define CLMCD_TEX_FILTER       0x00040000  /* Filtered textures             */
#define CLMCD_TEX_U_SATURATE   0x00000008  /* Texture saturation (opp wrap) */
#define CLMCD_TEX_V_SATURATE   0x00000080  /* Texture saturation (opp wrap) */
#define CLMCD_TEX_DECAL        0x00200000  /* Texture masking (1555,1888)   */
#define CLMCD_TEX_DECAL_INTERP 0x00400000  /* Texture masking (1555,1888)   */
#define CLMCD_TEX_DECAL_POL    0x00100000  /* Texture masking (1555,1888)   */


/*********************************************************************
*
*   Type of the line mesh:
*       - lines are concatenated, each reusing the predecessor's
*         vertex as its first vertex
*       - first vertex defines the center of a "wheel" structure with
*         each succesive vertex defining the outer point
*       - list of independent pairs of vertices
*
**********************************************************************/
#define LL_LINE_STRIP   0x02000000  /* Line strip mesh of lines      */
#define LL_LINE_FAN     0x01000000  /* Line fan mesh of lines        */
#define LL_LINE_LIST    0x00000000  /* Line list mesh of lines       */


/*********************************************************************
*
*   Type of the polygon mesh:
*       - triangles are concatenated, each reusing the predecessor's
*         last two vertices as its own first two
*       - first vertex defines the center of a "wheel" structure with
*         each succesive vertex pair defining the outer points
*       - list of independent triplets of vertices
*
**********************************************************************/
#define LL_POLY_STRIP   0x02000000  /* Poly strip mesh of triangles  */
#define LL_POLY_FAN     0x01000000  /* Poly fan mesh of triangles    */
#define LL_POLY_LIST    0x00000000  /* Poly list mesh of triangles   */


/**************************************************************************
*
*   Commands for the bOp field of a batch cell
*
***************************************************************************/
#define LL_IDLE                     0x00 /* Stops Laguna execution        */
#define LL_NOP                      0x01 /* Does nothing                  */
                                    
#define LL_POINT                    0x02 /* Point primitive(s)            */
#define LL_LINE                     0x03 /* Line primitive(s)             */
#define LL_POLY                     0x04 /* Triangle primitive(s)         */
                                    
#define LL_SET_COLOR0               0x08 /* Sets color0 register w/dwFlags*/
#define LL_SET_COLOR1               0x09 /* Sets color1 register w/dwFlags*/

#define LL_SET_DEST_COLOR_BOUNDS    0x0B /* Sets the color bounds regs    */
#define LL_SET_CLIP_REGION          0x0C /* Sets clip region and flags    */
#define LL_SET_Z_MODE               0x0D /* Sets the Z functional mode    */
#define LL_SET_Z_BUFFER             0x0E /* Sets the location of the Zbuf */
#define LL_SET_Z_COMPARE_MODE       0x0F /* Sets the Z compare mode       */
#define LL_SET_ALPHA_MODE           0x10 /* Sets the alpha blending mode  */
#define LL_SET_CONSTANT_ALPHA       0x11 /* Sets the constants for alpha  */
#define LL_SET_ALPHA_DEST_COLOR     0x12 /* Sets the alpha destination col*/
#define LL_SET_LIGHTING_SOURCE      0x13 /* Sets the lighting source      */
#define LL_AALINE                   0x14 /* Anti-aliased True Color Line(s*/
#define LL_RAW_DATA                 0x15 /* Copy data into d-list         */
#define LL_QUALITY                  0x16 /* Sets the speed/quality dial   */
#define LL_SET_TEXTURE_COLOR_BOUNDS 0x17 /* Sets the texture color bounds */
#define LL_SET_PATTERN              0x18 /* Sets pattern registers */


/*********************************************************************
*
*   LL_Vert structure defines a vertex with its X,Y,Z coordinates.
*   Also, the coordinates on the texture that may be associated with
*   it are also stored in this structure as (U,V) fields.  If the 
*   texture is perspective corrected, the vertex' W factor is used.
*
*   The pixel on the screen that is associated with this vertex has
*   color 'index' (if THE indexed mode is used), or (r,g,b) if a true
*   color mode is used.
*
*   If alpha blending is used, alpha value is stored in the 'a' field.
*
*   Add DWORD values are fixed point 16:16.
*
**********************************************************************/
typedef struct                      /* Vertex structure              */
{
    DWORD  x;                       /* X screen coordinate           */
    DWORD  y;                       /* Y screen coordinate           */
    DWORD  z;                       /* Z coordinate                  */
    DWORD  u;                       /* Texture u coordinate          */
    DWORD  v;                       /* Texture v coordinate          */
    float  w;                       /* Perspective w factor          */

    union
    {
        BYTE index;                 /* Indexed color value           */
        struct
        {
            BYTE r;                 /* Red component                 */
            BYTE g;                 /* Green component               */
            BYTE b;                 /* Blue component                */
            BYTE a;                 /* Alpha component               */
        };
    };

} LL_Vert;


/*********************************************************************
*
*   LL_Batch structure holds the operation that is being requested,
*   along with its parameters.
*
*   The array of the vertices used in the current operation
*   is pointed to by pVert pointer.
*
**********************************************************************/
typedef struct                      /* Batch cell structure          */
{
    BYTE     bOp;                   /* Operation requested           */
    BYTE     bRop;                  /* Raster operation for 2D       */
    WORD     wBuf;                  /* Texture / Buffer designator   */
    WORD     wCount;                /* General purpose counter       */
    DWORD    dwFlags;               /* Operation flag modifiers      */
    LL_Vert *pVert;                 /* Pointer to the associated     */
                                    /*  array of vertices            */
} LL_Batch;


/*********************************************************************
*
*   LL_Pattern structure holds the pattern to be stored in the
*   PATTERN_RAM registers.  These values are used for pattern, 
*   dither or stipple (only one at a time).
*
**********************************************************************/
typedef struct                      /* pattern holding structure     */
{
    DWORD pat[ 8 ];                 /* 8 word pattern                */

} LL_Pattern;


/*********************************************************************
*
*   LL_Rect structure defines a general rectangular region
*
**********************************************************************/
typedef struct
{
    DWORD left;                     /* x1                            */
    DWORD top;                      /* y1                            */
    DWORD right;                    /* x2                            */
    DWORD bottom;                   /* y2                            */

} LL_Rect;


/*********************************************************************
*
*   LL_Color structure defines color by its components or index
*
**********************************************************************/
typedef struct
{
    union
    {
        struct                      /* If in true color mode,        */
        {
            BYTE r;                 /* Red component                 */
            BYTE g;                 /* Green component               */
            BYTE b;                 /* Blue component                */
        };
        BYTE index;                 /* Index if in 8bpp indexed mode */
    };

} LL_Color;

typedef struct {
    float   x;
    float   y;
    float   w;
    float   u;
    float   v;
} TEXTURE_VERTEX;


/*********************************************************************
*
*   LL_Texture structure defines a texture map
*
**********************************************************************/
typedef struct _LL_Texture
{
    void *pohTextureMap;            // control block for region containing map in offscreen memory
    MCDTEXTURE *pTex;               // ptr to texture in user memory
//  LL_Color * ColPalette;          /* Pointer to palette if indexed       */
//  BYTE  bMem;                     /* Index to the texture memory block   */
    DWORD dwTxCtlBits;
    float fWidth;                   /* Texture X dimension in texels       */
    float fHeight;                  /* Texture Y dimension in texels       */
    BYTE  bSizeMask;                /* Encoded size 0=16,... Y[7:4],X[3:0] */
    BYTE  bType;                    /* Texture type                        */
//  BYTE  fIndexed;                 /* True for indexed textures           */
//  BYTE  bLookupOffset;            /* Palette lookup offset (indexed only)*/
    WORD  wXloc;                    /* X offset location in bytes          */
    WORD  wYloc;                    /* Y offset location in lines          */
    float fLastDrvDraw;             /* time stamp, sort of */           

    BYTE  bAlphaInTexture;          
    BYTE  bNegativeMap;          
    BYTE  bMasking;          

    // doubly linked list pointers
   struct _LL_Texture*  prev;
   struct _LL_Texture*  next;

} LL_Texture;


/*********************************************************************
*
*   LL_DeviceState structure hold the information about the state 
*   of the graphics processor (hardware).
*
*   During the library initialization, the following fields have to
*   be initialized:
*
*       dwFlags with optional
*           LL_USE_BUFFER_B     or
*           LL_USE_BUFFER_Z     or
*           LL_BUFFER_Z_8BPP    or
*           LL_BUFFER_Z888      or
*           LL_8BPP_INDEXED     or
*           LL_HARDWARE_CURSOR 
*
*       dwDisplayListLen with the amount of memory to lock for the
*           physical graphics device display list (in bytes).
*
*       dwSystemTexturesLen with the total size for the system 
*           textures (in bytes)
*
**********************************************************************/
typedef struct
{
    /* These three fields may be set before calling the LL_InitLib function                */

    DWORD dwFlags;                  /* Init flags                                          */
    DWORD dwDisplayListLen;         /* Total size for the display lists in bytes           */
    DWORD dwSystemTexturesLen;      /* Total size for the system textures in bytes         */

    /* These variables may be used by the software                                         */

    DWORD *pRegs;                   /* Register apperture, pointer to memory mappped I/O   */
    BYTE  *pFrame;                  /* Frame apperture, pointer to the linear frame buffer */
    DWORD dwVRAM;                   /* Amount of video memory on the card in bytes         */
    WORD  wHoriz;                   /* Current horizontal resolution                       */
    WORD  wVert;                    /* Current vertical resolution                         */

} LL_DeviceState;


/*********************************************************************
*
*   LL_Point structure defines a general point coordinates
*
**********************************************************************/
typedef struct
{
    DWORD nX;                       /* x coordinate   */
    DWORD nY;                       /* y coordinate   */

} LL_Point;


/*********************************************************************
*
*   Font support structures and macros
*
**********************************************************************/
typedef struct                      // Font header structure
{
    WORD    nMinimum;               // Font minimum character code value
    WORD    nMaximum;               // Font maximum character code value
    WORD    nDefault;               // Font default character code value
    WORD    nHeight;                // Font height in pixels
    DWORD   nReserved;              // Font reserved data
    WORD    nIndex[];               // Font index array

} LL_FontHeader;


typedef struct                      // Font structure
{
    LL_FontHeader   *pHeader;       // Pointer to font header
    BYTE            *pBitmap;       // Pointer to font bitmap
    int             nID;            // Font buffer ID value
    char            cBreak;         // Break character value
    int             nExtra;         // Current break extra in pixels
    int             nLast;          // Previous break extra in pixels
    int             nSpace;         // Current font spacing in pixels
    int             nPrevious;      // Previous font spacing in pixels
    int             nAverage;       // Average font width in pixels
    int             nMaximum;       // Maximum font width in pixels

} LL_Font;

#define Y_EXTENT(Extent)    ((unsigned) (Extent) >> 16)
#define X_EXTENT(Extent)    ((Extent) & 0xFFFF)

#define TEX_MASK_EN					0x00200000
#define TEX_HIPRECISION_2NDORDER    0x00800000  // 8.24 vs. 16.16 2nd order terms

#ifdef CGL // Goran will have equivalent soon??...

#define LL_PIXEL_MASK_DISABLE		0x00000000
#define LL_PIXEL_MASK_ENABLE	   	0x00000001  

// TX_CTL0_3D values
#define LL_TEX_U_OVF_SAT_EN 		0x00000004
#define LL_TEX_V_OVF_SAT_EN 		0x00000080
#define LL_TEXMODE_A888				0x00000600	
#define LL_TEXMODE_A555				0x00000500
#define LL_TEXMODE_565				0x00000400	// not used by CGL
#define LL_TEXMODE_332				0x00000300
#define LL_TEXMODE_8MAP				0x00000200
#define LL_TEXMODE_4MAP				0x00000000	// not used by CGL

#define TEX_MASK_FUNC				0x00400000
#define TEX_MASK_EN					0x00200000
#define TEX_MASK_POL				0x00100000
#define TEX_HIPRECISION_2NDORDER    0x00800000  // 8.24 vs. 16.16 2nd order terms

#define LL_TEX_FILTER_ENABLE		0x00040000

// TX_CTL1_3D values
#define CCOMP_INCLUSIVE				0x08000000
#define TX_BLU_COMP					0x04000000
#define TX_GRN_COMP					0x02000000
#define TX_RED_COMP					0x01000000

#define ABS(a)		(((a) < 0) ? -(a) : (a))

#endif // CGL

// BEGIN Chris' additions                          //
typedef unsigned long ULONG;					   //
typedef ULONG * PULONG ;						   //
typedef unsigned short UWORD ;					   //
typedef UWORD * PUWORD ;						   //
typedef unsigned char UBYTE;					   //
typedef UBYTE * PUBYTE;							   //
typedef struct {								   //
 unsigned char bBlue,bGreen,bRed,bAlpha;		   //
} LL_COLOR_ST;//this mimics the CGL_COLOR_ST.Should we include CGL in this library instead of mimicing this struct?//
#define num_of_regs     42                         //
#define num_of_insignificant_regs 46               //
#define num_of_modes    70						   //

#define LL_DISABLE   	  0x00
#define LL_32x32x3   	  0x01
#define LL_32x32x2HL 	  0x02
#define LL_32x32x2   	  0x03
#define LL_64x64x3   	  0x05
#define LL_64x64x2HL 	  0x06
#define LL_64x64x2   	  0x07

// following was moved here from setmode.c
#ifdef B4_REALHW
/* Defines the code for the 5462 chip that is the underlying         */
/* hardware for the testing before 5464 comes out.  This code should */
/* then be modified to reflect real code returned by the BIOS        */
/* function 12h subfunction 80h (Inquire VGA type)                   */
#define EBIOS_CLGD5462      0x60    /* BIOS Laguna 1 signature       */
#define EBIOS_CLGD5464      0xD4    /* BIOS Laguna 3D signature      */
#define EBIOS_CLGD5464B     0xD0    /* BIOS Laguna 3D alt signature  */
#else
/* Defines the code for the 5462 chip that is the underlying         */
/* hardware for the testing before 5464 comes out.  This code should */
/* then be modified to reflect real code returned by the BIOS        */
/* function 12h subfunction 80h (Inquire VGA type)                   */
#define EBIOS_CLGD5462      0x60    /* BIOS Laguna 1 signature       */
#define EBIOS_CLGD5464      0x64    /* BIOS Laguna 3D signature      */
#define EBIOS_CLGD5464B     0x61    /* BIOS Laguna 3D alt signature  */
#endif

// END Chris' additions


/*********************************************************************
*
*   Error codes
*
**********************************************************************/
#define LL_OK                   0x0000  // There was no error
#define LL_ERROR            0xffffffff  // Generic error prefix

#define LLE_PCX_FILE_OPEN       0x0002  // Error opening file
#define LLE_PCX_READ_HEADER     0x0003  // Error reading the header
#define LLE_PCX_NOT_SUITABLE    0x0004  // Not a suitable PCX file
#define LLE_PCX_PALETTE_READ    0x0005  // Error reading the palette
#define LLE_PCX_PALETTE_SEEK    0x0006  // Error seeking the palette
#define LLE_PCX_ALLOC_PALETTE   0x0007  // Error allocating memory

#define LLE_TEX_ALLOC           0x0008  // Texture memory allocation failure
#define LLE_TEX_BAD_ID          0x0009  // Invalid texture ID
#define LLE_TEX_TOO_MANY        0x000a  // Too many textures
#define LLE_TEX_DIMENSION       0x000b  // Invalid texture dimensions
#define LLE_TEX_TYPE            0x000c  // Invalid texture type
#define LLE_TEX_STORAGE         0x000d  // Invalid storage type
#define LLE_TEX_LOCKED          0x000e  // Use of locked texture
#define LLE_TEX_NOT_LOCKED      0x000f  // Unlocking of unlocked texture

#define LLE_BUF_CONFIG          0x0010  // Wrong buffers configuration
#define LLE_BUF_PITCH           0x0011  // Invalid buffer pitch
#define LLE_BUF_NUM             0x0012  // Too many buffers
#define LLE_BUF_ALLOC           0x0013  // Error allocating buffer
#define LLE_BUF_BAD_ID          0x0014  // Invalid buffer ID
#define LLE_BUF_FREE            0x0015  // Buffer already free
#define LLE_BUF_FREE_VIDEO      0x0016  // Cannot free a buffer in vram
#define LLE_BUF_NOT_ALLOC       0x0017  // Buffer was not allocated

#define LLE_INI_NOT_LAGUNA      0x0018  // Wrong hardware (from extended BIOS)
#define LLE_INI_MODE            0x0019  // Invalid graphcs mode
#define LLE_INI_DL_LEN          0x001a  // Invalid display list size
#define LLE_INI_ALLOC_DL        0x001b  // D-list allocation error
#define LLE_INI_Z_BUFFER        0x001c  // Invalid Z buffer placement

#define LLE_FON_LOAD            0x001d  // Error loading font
#define LLE_FON_ALLOC           0x001e  // Error allocating font memory


/*********************************************************************
*
*   Function prototypes
*
**********************************************************************/

// Init/Execute Functions
//
extern DWORD LL_InitLib( VOID *ppdev );
#ifndef CGL // modemon way (mode.ini)
extern DWORD LL_InitGraph( LL_DeviceState *DC, char *sController, char *sMode );
#else // cgl's dll (embedded mode tables)
extern DWORD LL_InitGraph( LL_DeviceState *DC, char *sController, int Mode );
#endif
extern DWORD LL_CloseGraph( LL_DeviceState *DC );
extern void LL_QueueOp( LL_Batch *pBatch );
extern void LL_Execute( LL_Batch * pBatch );
extern void LL_Wait();
extern void LL_SetRenderingMode( DWORD dwMode );
#ifndef CGL // CGL has own version as of 6/24/96 - ChrisS may merge
extern void LL_SetPalette( LL_Color * Col, BYTE first, int count );
#endif
extern BYTE LL_SpeedQualityDial( int SpeedQuality );

// Buffer Functions
//
extern DWORD LL_AllocSystemBuffer( DWORD Xdim, DWORD Ydim, DWORD pitch );
extern DWORD LL_RegisterUserBuffer( BYTE * pMem, DWORD Xdim, DWORD Ydim, DWORD pitch );
extern DWORD LL_FreeSystemBuffer( DWORD dwBufID );

// Texture Management Functions
//
#ifndef CGL
extern DWORD LL_RegisterTexture( DWORD dwFlags, WORD wWidth, WORD wHeight, BYTE bType );
#else
extern DWORD LL_RegisterTexture( DWORD dwFlags, WORD wWidth, WORD wBufWidth, WORD wHeight, BYTE bType, DWORD dwAddress );
#endif
extern DWORD LL_FreeTexture( DWORD dwID );
extern LL_Texture * LL_LockTexture( DWORD dwID );
extern DWORD LL_UnLockTexture( DWORD dwID );
extern DWORD LL_SetTexturePaletteOffset( DWORD dwID, BYTE bOffset );
extern void UpdateTextureInfo();


// Control Functions
//
extern void LL_SetZBuffer( DWORD buf_num );
extern void LL_SetZCompareMode( DWORD dwZCompareMode );
extern DWORD LL_GetZCompareMode();
extern void LL_SetZMode( DWORD dwZMode );
extern DWORD LL_GetZMode();
extern void LL_SetAlphaMode( DWORD dwAlphaMode );
extern DWORD LL_GetAlphaMode();
extern void LL_SetAlphaDestColor( DWORD dwAlphaDestColor );
extern DWORD LL_GetAlphaDestColor();
extern void LL_SetLightingSource( DWORD dwLighting );
extern DWORD LL_GetLightingSource();
extern void LL_SetClipRegion( LL_Rect * rect );
extern void LL_GetClipRegion( LL_Rect * rect );
extern void LL_SetPattern( LL_Pattern *Pattern );
extern void LL_GetPattern( LL_Pattern *Pattern );
extern void LL_SetPatternOffset( BYTE bOffsetX, BYTE bOffsetY );
extern void LL_GetPatternOffset( BYTE * pbOffsetX, BYTE * pbOffsetY );

extern void LL_SetTextureColorBounds( DWORD dwControl, LL_Color * Min, LL_Color * Max );
extern void LL_SetDestColorBounds( DWORD dwControl, LL_Color * Min, LL_Color * Max );

extern void LL_SetColor0( DWORD dwColor0 );
extern void LL_SetColor1( DWORD dwColor1 );
extern void LL_GetColorRegisters( DWORD * pdwColor0, DWORD * pdwColor1 );
extern void LL_SetConstantAlpha( WORD wSource, WORD wDestination );

// Hardware cursor / Mouse functions
//
#ifndef CGL // CGL has own version as of 6/24/96 - ChrisS may merge
extern void LL_SetCursor( BYTE bMode, LL_Color * pColor, BYTE * pbCursor);
extern void LL_SetCursorPos( WORD wX, WORD wY );
#endif // CGL
extern void LL_GetMouseStatus( WORD * pwX, WORD * pwY, WORD * pwButtons );
extern void LL_SetMouseCallback( void (far *fnCallback)( WORD wX, WORD wY, WORD wButtons ) );
extern void LL_SetCursorHotSpot( BYTE bX, BYTE bY );

// Font functions
//
extern LL_Font * LL_FontLoad( char * pName );
extern LL_Font * LL_FontUnload( LL_Font * pFont );
extern int LL_FontExtent( LL_Font * pFont, char * pString );
extern int LL_FontWrite( LL_Font * pFont, LL_Point * pPoint, LL_Rect * pClip, char *pString );

// Support Functons
//
extern void DumpDisplayList( DWORD *pPtr, DWORD dwLen );
extern DWORD LL_PCX_Load( LL_Texture * pTex, char * sName, WORD wAlphaIndex );
extern DWORD LL_PCX_Load_Buffer( DWORD dwBufID, char * sName, WORD wAlphaIndex, BYTE bType );
extern char * LL_ErrorStr( DWORD error_code );



#endif // _L3D_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\laguna\mini\include\optimize.h ===
;/*
COMMENT !

    USE_ASM
    -------
        0   use "C" code
        1   use "ASM" code for i386 CPU's

;*/
    #define USE_ASM         1   /*  C switch        !
            USE_ASM =       1   ;   Assembly switch */


;/*
COMMENT !

    USB_FIX    --------
        0   Disable USB fix
        1   Enable USB fix

;*/
    #define USB_FIX_ENABLED        0   /*  C switch        !
            USB_FIX_ENABLED =      0   ;   Assembly switch */


;/*
COMMENT !

    WINBENCH96
    --------
        0   Allocate all device bitmap sizes.
        1   Allocate only device bitmaps in the WinBench 96 size range.

;*/
    #define WINBENCH96        0   /*  C switch        !
            WINBENCH96 =      0   ;   Assembly switch */

;/*
COMMENT !

    INLINE_ASM
    ----------
        0   Don't use i386 inline assembly.
        1   Use i386 inline assembly.

;*/
    #define INLINE_ASM      1   /*  C switch        !
            INLINE_ASM =    1   ;   Assembly switch */



;/*
COMMENT !

    SOLID_CACHE
    -----------
        0   Don't use solid brush cache in special cases.
        1   Use solid brush cache in special places.

;*/
    #define SOLID_CACHE		1	/*  C switch        !
            SOLID_CACHE =	1	;   Assembly switch */



;/*
COMMENT !

    BUS_MASTER
    -----------
        0   Don't use bus mastering to transfer host data.
        1   Use bus mastering to transfer host data.

;*/
    #define BUS_MASTER      0   /*  C switch        !
            BUS_MASTER  =   0   ;   Assembly switch */



;/*
COMMENT !

    LOG_CALLS
    -----------
        0   Normal operation.
        1   Log GDI calls into the driver.
            This will disable USE_ASM.

;*/
    #define LOG_CALLS       0   /*  C switch        !
            LOG_CALLS   =   0   ;   Assembly switch */



;/*
COMMENT !

    HW_CLIPPING
    -----------
        0   Don't use hardware clipping.
        1   Use hardware clipping (5465 only).

;*/
    #define HW_CLIPPING         0   /*  C switch        !
            HW_CLIPPING     =   0   ;   Assembly switch */







;/* ========================== LOG_WRITES =================================
COMMENT !

    LOG_WRITES
    -----------
        0   Normal operation.
        1   Log writes to the chip.
            This will disable USE_ASM.

;*/
    #define LOG_WRITES      0   /*  C switch        !
            LOG_WRITES  =   0   ;   Assembly switch */



;/* ========================== LOG_QFREE =================================
COMMENT !

    LOG_QFREE
    -----------
        0   Normal operation.
        1   Log QFREE register at selected places.
;*/
    #define LOG_QFREE       0   /*  C switch        !
            LOG_QFREE   =   0   ;   Assembly switch */



;/* ========================== ENABLE_LOG_SWITCH =============================
COMMENT !

    ENABLE_LOG_SWITCH
    ------------------
        0   Continuous logging (when loggin is enabled above)
        1   Turn loggin on and off with pointer.
;*/
    #define ENABLE_LOG_SWITCH       0   /*  C switch        !
            ENABLE_LOG_SWITCH   =   0   ;   Assembly switch */




;/*  ================== ENABLE_LOG_FILE =================================
COMMENT !

 This enables the log file.

;*/

    //  C switches
    #define ENABLE_LOG_FILE (LOG_CALLS | LOG_WRITES | LOG_QFREE)
    /*  End of C switches !

    ;   Assembly switches
    ENABLE_LOG_FILE = (LOG_CALLS OR LOG_WRITES OR LOG_QFREE)
    ;   End of assembly switches */





;/* =========== INFINITE_OFFSCREEN_MEMORY =================================
COMMENT !

//
// This option causes DrvCreateDeviceBitmap to always succeed.
// It maps all device bitmaps to screen 0,0.  Thus we have an "infinite"
// supply of offscreen memory. 
//
// It is not necessary to set USE_ASM = 0 for this flag.
//
;*/
    #define INFINITE_OFFSCREEN_MEM      0   /*  C switch        !
            INFINITE_OFFSCREEN_MEM  =   0   ;   Assembly switch */





;/*  ================== NULL driver flags ================================
COMMENT !

 Once NULL driver capabilities are enabled, they are turned on and off 
 by moving the pointer to (0,0) which toggles do_flag on and off.
 See DrvMovePointer().

 These allow us to selectively 'short circuit' certain parts of the driver.
        0   Normal operation.
        1   Immediately return TRUE.

 It is not necessary to set USE_ASM = 0 for the null driver flags.

;*/

    //  C switches
    #define NULL_BITBLT 		0
    #define NULL_COPYBITS		0
    #define NULL_LINETO 		0
    #define NULL_PAINT  		0
    #define NULL_PATH   		0
    #define NULL_POINTER		0
    #define NULL_STRETCH		0
    #define NULL_STROKE 		0
    #define NULL_STROKEFILL		0
    #define NULL_TEXTOUT		0
    #define NULL_HW			0
    /*  End of C switches !

;   Assembly switches
        NULL_BITBLT	=   	0
        NULL_COPYBITS	=	0
        NULL_LINETO	=   	0
        NULL_PAINT	=   	0
        NULL_PATH	=   	0
        NULL_POINTER	=	0
        NULL_STRETCH	=	0
        NULL_STROKE	=   	0
        NULL_STROKEFILL	=	0
        NULL_TEXTOUT	=	0
        NULL_HW		=	0
;   End of assembly switches */




;/*  ================== POINTER_SWITCH ================================
COMMENT !

 This enables a global flag, or switch, that we can turn on and off by 
 moving the HW pointer to screen(0,0)

;*/

//  C switches
#define POINTER_SWITCH_ENABLED \
         (NULL_BITBLT | NULL_PAINT | NULL_COPYBITS | NULL_LINETO | \
          NULL_TEXTOUT | NULL_PATH | NULL_HW | NULL_STROKE | \
          NULL_STROKEFILL | NULL_STRETCH | NULL_POINTER | NULL_HW |\
          ENABLE_LOG_SWITCH | INFINITE_OFFSCREEN_MEM)

/*  End of C switches !

;   Assembly switches
        POINTER_SWITCH_ENABLED = \
         (NULL_BITBLT OR NULL_PAINT OR NULL_COPYBITS OR NULL_LINETO OR \
          NULL_TEXTOUT OR NULL_PATH OR NULL_HW OR NULL_STROKE OR \
          NULL_STROKEFILL OR NULL_STRETCH OR NULL_POINTER OR NULL_HW OR\
          ENABLE_LOG_SWITCH OR INFINITE_OFFSCREEN_MEM)

;   End of assembly switches */



;/*  ===================== DISABLE USE_ASM ====================================
COMMENT !

    Some of the switches above are incompatible with the assembly language
    part of the driver.

;*/

//  C switches
#if (LOG_CALLS || LOG_WRITES)
    #define USE_ASM 0
#endif
/*  End of C switches !

;   Assembly switches
IF (LOG_CALLS OR LOG_WRITES)
    USE_ASM = 0
ENDIF
;   End of assembly switches */



;/*  ===================== CHECK_QFREE ====================================
COMMENT !

    Log the value of the QFREE register.

;*/

//  C macro
#if LOG_QFREE
    extern unsigned long QfreeData[32];
    #define CHECK_QFREE() \
        do{ \
            register unsigned long temp; /* Because grQFREE is a volatile */ \
            temp = LLDR_SZ(grQFREE);     /* we must store it in a temp    */ \
            ++QfreeData[temp];           /* before using it as an index.  */ \
        } while(0)
#else
    #define CHECK_QFREE()
#endif

/*  End of C macro !

;   Assembly macro

IF LOG_QFREE
    EXTERN QfreeData: DWORD 
    CHECK_QFREE MACRO base:=<ebp> 
        push    eax                             ; Save eax and edx
        push    edx                             ; 

        xor     eax, eax                        ; Eax = 0
        mov     al, BYTE PTR [base + grQFREE]   ; Eax = QFREE
        mov     edx, DWORD PTR QfreeData[eax*4] ; Get histogram entry for QFREE
        inc     edx                             ;   increment it,
        mov     DWORD PTR QfreeData[eax*4], edx ;   and store it.

        pop     edx                             ; Restore edx and eax
        pop     eax                             ; 
    ENDM
ELSE
    CHECK_QFREE MACRO base:=<ebp> 
    ENDM
ENDIF

;   End of assembly macro */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\laguna\mini\include\pwrmgr.h ===
/***************************************************************************
*
*                ******************************************
*                * Copyright (c) 1997, Cirrus Logic, Inc. *
*                *            All Rights Reserved         *
*                ******************************************
*
* PROJECT:  Laguna (CL-GD546X) - 
*
* FILE:     pwrmgr.h
*
* AUTHOR:   Benny Ng
*
* DESCRIPTION:
*           This is the include file for Power manager code.
*
* MODULES:
*
* REVISION HISTORY:
* $Log:   X:/log/laguna/powermgr/inc/pwrmgr.h  $
* 
*    Rev 1.2   20 Jun 1997 13:25:42   bennyn
* Moved power manager functions to Miniport
* 
*    Rev 1.1   23 Jan 1997 16:33:32   bennyn
* 
* 
*    Rev 1.0   16 Jan 1997 11:48:00   bennyn
* Initial revision.
* 
****************************************************************************
****************************************************************************/

#if defined WINNT_VER35      // WINNT_VER35
  // If WinNT 3.5 skip all the source code
#else

BOOL LgPM_SetHwModuleState (PPDEV ppdev, ULONG hwmod, ULONG state);
BOOL LgPM_GetHwModuleState (PPDEV ppdev, ULONG hwmod, ULONG* state);

#endif // WINNT_VER35

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\laguna\mini\include\lgddmsg.h ===
/****************************************************************************
******************************************************************************
*
*                ******************************************
*                * Copyright (c) 1995, Cirrus Logic, Inc. *
*                *            All Rights Reserved         *
*                ******************************************
*
* PROJECT:	Laguna I (CL-GD546x) - 
*
* FILE:		lgddmsg.h
*
* AUTHOR:   Benny Ng
*
* DESCRIPTION:
*   This is the header file which will define the custom message between
*   the NT app and display driver.
*
* MODULES:
*
* REVISION HISTORY:
*   11/15/95     Benny Ng      Initial version
*
****************************************************************************
****************************************************************************/

#define  READ_OPR        1
#define  WRITE_OPR       2

#define  BYTE_ACCESS     1
#define  WORD_ACCESS     2
#define  DWORD_ACCESS    3


// =====================================================================
// Define structure used to call the BIOS int 10 function
// =====================================================================
typedef struct _VIDEO_X86_BIOS_ARGUMENTS {
    ULONG Eax;
    ULONG Ebx;
    ULONG Ecx;
    ULONG Edx;
    ULONG Esi;
    ULONG Edi;
    ULONG Ebp;
} VIDEO_X86_BIOS_ARGUMENTS, *PVIDEO_X86_BIOS_ARGUMENTS;


typedef struct _MMREG_ACCESS {
    ULONG Offset;
    ULONG ReadVal;
    ULONG WriteVal;
    ULONG RdWrFlag;     // 1=Read, 2=Write
    ULONG AccessType;   // 1=Byte, 2=Word,  3=Dword
} MMREG_ACCESS, *PMMREG_ACCESS;

// =====================================================================
// Define structure used for power manager
// =====================================================================
#ifndef __LGPWRMGR_H__
#define __LGPWRMGR_H__

#define  ENABLE           0x1
#define  DISABLE          0x0

#define  MOD_2D           0x0
#define  MOD_STRETCH      0x1
#define  MOD_3D           0x2
#define  MOD_EXTMODE      0x3
#define  MOD_VGA          0x4
#define  MOD_RAMDAC       0x5
#define  MOD_VPORT        0x6
#define  MOD_VW           0x7
#define  MOD_TVOUT        0x8
#define  TOTAL_MOD        MOD_TVOUT+1

typedef struct _LGPM_IN_STRUCT {
    ULONG arg1;
    ULONG arg2;
} LGPM_IN_STRUCT, *PLGPM_IN_STRUCT;

typedef struct _LGPM_OUT_STRUCT {
    BOOL  status;
    ULONG retval;
} LGPM_OUT_STRUCT, *PLGPM_OUT_STRUCT;

#endif  // #ifndef __LGPWRMGR_H__



// =====================================================================
#define IS_CIRRUS_DRIVER            9005

#define BIOS_CALL_REQUEST           0xF001
#define GET_CL_MMAP_ADDR            0xF002
#define ID_LGPM_SETHWMODULESTATE    0xF003
#define ID_LGPM_GETHWMODULESTATE    0xF004
#define GET_VIDEO_MEM_SIZE          0xF006
#define GET_PCI_VEN_DEV_ID          0xF007
#define CRTC_READ                   0xF008
#define GET_BIOS_VERSION            0xF009
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\laguna\mini\include\roptab.h ===
/******************************Module*Header**********************************\
* Module Name: ROPTAB.H
* Author: Noel VanHook
* Date: Apr 23, 1995
* Purpose: Table lookup for BLT operands.
*
* Copyright (c) 1995 Cirrus Logic, Inc.
*
\*****************************************************************************/
#ifndef _ROPTBL_H_
#define _ROPTBL_H_


//
// The table is indexed by rop code.  Each entry is a pointer to 
// which blt function to use for that rop code.
// BLT functions are selected based on what operands they use.
//
// Make sure BLT functions are prototyped before including this file.
//
//

BLTFN *RopTab[] = {
/* 00 */ op0BLT,     // BLACKNESS.
/* 01 */ op1op2BLT,
/* 02 */ op1op2BLT,
/* 03 */ op1op2BLT,
/* 04 */ op1op2BLT,
/* 05 */ op2BLT,     // DPon
/* 06 */ op1op2BLT,
/* 07 */ op1op2BLT,
/* 08 */ op1op2BLT,
/* 09 */ op1op2BLT,
/* 0A */ op2BLT,     // DPna
/* 0B */ op1op2BLT,
/* 0C */ op1op2BLT,
/* 0D */ op1op2BLT,
/* 0E */ op1op2BLT,
/* 0F */ op2BLT,     // Pn
/* 10 */ op1op2BLT,
/* 11 */ op1BLT,     // DSon
/* 12 */ op1op2BLT,
/* 13 */ op1op2BLT,
/* 14 */ op1op2BLT,
/* 15 */ op1op2BLT,
/* 16 */ op1op2BLT,
/* 17 */ op1op2BLT,
/* 18 */ op1op2BLT,
/* 19 */ op1op2BLT,
/* 1A */ op1op2BLT,
/* 1B */ op1op2BLT,
/* 1C */ op1op2BLT,
/* 1D */ op1op2BLT,
/* 1E */ op1op2BLT,
/* 1F */ op1op2BLT,
/* 20 */ op1op2BLT,
/* 21 */ op1op2BLT,
/* 22 */ op1BLT,      // DSna
/* 23 */ op1op2BLT,
/* 24 */ op1op2BLT,
/* 25 */ op1op2BLT,
/* 26 */ op1op2BLT,
/* 27 */ op1op2BLT,
/* 28 */ op1op2BLT,
/* 29 */ op1op2BLT,
/* 2A */ op1op2BLT,
/* 2B */ op1op2BLT,
/* 2C */ op1op2BLT,
/* 2D */ op1op2BLT,
/* 2E */ op1op2BLT,
/* 2F */ op1op2BLT,
/* 30 */ op1op2BLT,
/* 31 */ op1op2BLT,
/* 32 */ op1op2BLT,
/* 33 */ op1BLT,     // Sn    -- NOT SRC COPY
/* 34 */ op1op2BLT,
/* 35 */ op1op2BLT,
/* 36 */ op1op2BLT,
/* 37 */ op1op2BLT,
/* 38 */ op1op2BLT,
/* 39 */ op1op2BLT,
/* 3A */ op1op2BLT,
/* 3B */ op1op2BLT,
/* 3C */ op1op2BLT,
/* 3D */ op1op2BLT,
/* 3E */ op1op2BLT,
/* 3F */ op1op2BLT,
/* 40 */ op1op2BLT,
/* 41 */ op1op2BLT,
/* 42 */ op1op2BLT,
/* 43 */ op1op2BLT,
/* 44 */ op1BLT,     // SDna  -- SRC ERASE
/* 45 */ op1op2BLT,
/* 46 */ op1op2BLT,
/* 47 */ op1op2BLT,
/* 48 */ op1op2BLT,
/* 49 */ op1op2BLT,
/* 4A */ op1op2BLT,
/* 4B */ op1op2BLT,
/* 4C */ op1op2BLT,
/* 4D */ op1op2BLT,
/* 4E */ op1op2BLT,
/* 4F */ op1op2BLT,
/* 50 */ op2BLT,     // PDna
/* 51 */ op1op2BLT,
/* 52 */ op1op2BLT,
/* 53 */ op1op2BLT,
/* 54 */ op1op2BLT,
/* 55 */ op0BLT,     // DEST INVERT. Blinking things, like a text cursor.
/* 56 */ op1op2BLT,
/* 57 */ op1op2BLT,
/* 58 */ op1op2BLT,
/* 59 */ op1op2BLT,
/* 5A */ op2BLT,     // DPx   -- PAT INVERT
/* 5B */ op1op2BLT,
/* 5C */ op1op2BLT,
/* 5D */ op1op2BLT,
/* 5E */ op1op2BLT,
/* 5F */ op2BLT,     // DPan
/* 60 */ op1op2BLT,
/* 61 */ op1op2BLT,
/* 62 */ op1op2BLT,
/* 63 */ op1op2BLT,
/* 64 */ op1op2BLT,
/* 65 */ op1op2BLT,
/* 66 */ op1BLT,     // DSx   -- SRC INVERT
/* 67 */ op1op2BLT,
/* 68 */ op1op2BLT,
/* 69 */ op1op2BLT,
/* 6A */ op1op2BLT,
/* 6B */ op1op2BLT,
/* 6C */ op1op2BLT,
/* 6D */ op1op2BLT,
/* 6E */ op1op2BLT,
/* 6F */ op1op2BLT,
/* 70 */ op1op2BLT,
/* 71 */ op1op2BLT,
/* 72 */ op1op2BLT,
/* 73 */ op1op2BLT,
/* 74 */ op1op2BLT,
/* 75 */ op1op2BLT,
/* 76 */ op1op2BLT,
/* 77 */ op1BLT,     // DSan
/* 78 */ op1op2BLT,
/* 79 */ op1op2BLT,
/* 7A */ op1op2BLT,
/* 7B */ op1op2BLT,
/* 7C */ op1op2BLT,
/* 7D */ op1op2BLT,
/* 7E */ op1op2BLT,
/* 7F */ op1op2BLT,
/* 80 */ op1op2BLT,
/* 81 */ op1op2BLT,
/* 82 */ op1op2BLT,
/* 83 */ op1op2BLT,
/* 84 */ op1op2BLT,
/* 85 */ op1op2BLT,
/* 86 */ op1op2BLT,
/* 87 */ op1op2BLT,
/* 88 */ op1BLT,     // DSa   -- SRC AND
/* 89 */ op1op2BLT,
/* 8A */ op1op2BLT,
/* 8B */ op1op2BLT,
/* 8C */ op1op2BLT,
/* 8D */ op1op2BLT,
/* 8E */ op1op2BLT,
/* 8F */ op1op2BLT,
/* 90 */ op1op2BLT,
/* 91 */ op1op2BLT,
/* 92 */ op1op2BLT,
/* 93 */ op1op2BLT,
/* 94 */ op1op2BLT,
/* 95 */ op1op2BLT,
/* 96 */ op1op2BLT,
/* 97 */ op1op2BLT,
/* 98 */ op1op2BLT,
/* 99 */ op1BLT,     // DSa   -- SRC AND
/* 9A */ op1op2BLT,
/* 9B */ op1op2BLT,
/* 9C */ op1op2BLT,
/* 9D */ op1op2BLT,
/* 9E */ op1op2BLT,
/* 9F */ op1op2BLT,
/* A0 */ op2BLT,     // DPa
/* A1 */ op1op2BLT,
/* A2 */ op1op2BLT,
/* A3 */ op1op2BLT,
/* A4 */ op1op2BLT,
/* A5 */ op2BLT,     // DPxn
/* A6 */ op1op2BLT,
/* A7 */ op1op2BLT,
/* A8 */ op1op2BLT,
/* A9 */ op1op2BLT,
/* AA */ op0BLT,     // DEST = DEST.  
/* AB */ op1op2BLT,
/* AC */ op1op2BLT,
/* AD */ op1op2BLT,
/* AE */ op1op2BLT,
/* AF */ op2BLT,     // DPno
/* B0 */ op1op2BLT,
/* B1 */ op1op2BLT,
/* B2 */ op1op2BLT,
/* B3 */ op1op2BLT,
/* B4 */ op1op2BLT,
/* B5 */ op1op2BLT,
/* B6 */ op1op2BLT,
/* B7 */ op1op2BLT,
/* B8 */ op1op2BLT,
/* B9 */ op1op2BLT,
/* BA */ op1op2BLT,
/* BB */ op1BLT,     // DSno  -- MERGE PAINT
/* BC */ op1op2BLT,
/* BD */ op1op2BLT,
/* BE */ op1op2BLT,
/* BF */ op1op2BLT,
/* C0 */ op1op2BLT,
/* C1 */ op1op2BLT,
/* C2 */ op1op2BLT,
/* C3 */ op1op2BLT,
/* C4 */ op1op2BLT,
/* C5 */ op1op2BLT,
/* C6 */ op1op2BLT,
/* C7 */ op1op2BLT,
/* C8 */ op1op2BLT,
/* C9 */ op1op2BLT,
/* CA */ op1op2BLT,
/* CB */ op1op2BLT,
/* CC */ op1BLT,     // S     -- SRC COPY
/* CD */ op1op2BLT,
/* CE */ op1op2BLT,
/* CF */ op1op2BLT,
/* D0 */ op1op2BLT,
/* D1 */ op1op2BLT,
/* D2 */ op1op2BLT,
/* D3 */ op1op2BLT,
/* D4 */ op1op2BLT,
/* D5 */ op1op2BLT,
/* D6 */ op1op2BLT,
/* D7 */ op1op2BLT,
/* D8 */ op1op2BLT,
/* D9 */ op1op2BLT,
/* DA */ op1op2BLT,
/* DB */ op1op2BLT,
/* DC */ op1op2BLT,
/* DD */ op1BLT,     // SDno
/* DE */ op1op2BLT,
/* DF */ op1op2BLT,
/* E0 */ op1op2BLT,
/* E1 */ op1op2BLT,
/* E2 */ op1op2BLT,
/* E3 */ op1op2BLT,
/* E4 */ op1op2BLT,
/* E5 */ op1op2BLT,
/* E6 */ op1op2BLT,
/* E7 */ op1op2BLT,
/* E8 */ op1op2BLT,
/* E9 */ op1op2BLT,
/* EA */ op1op2BLT,
/* EB */ op1op2BLT,
/* EC */ op1op2BLT,
/* ED */ op1op2BLT,
/* EE */ op1BLT,     // DSo   -- SRC PAINT
/* EF */ op1op2BLT,
/* F0 */ op2BLT,     // P     -- PAT COPY.  Used for fills.
/* F1 */ op1op2BLT,
/* F2 */ op1op2BLT,
/* F3 */ op1op2BLT,
/* F4 */ op1op2BLT,
/* F5 */ op2BLT,     // PDno
/* F6 */ op1op2BLT,
/* F7 */ op1op2BLT,
/* F8 */ op1op2BLT,
/* F9 */ op1op2BLT,
/* FA */ op2BLT,     // DPo
/* FB */ op1op2BLT,
/* FC */ op1op2BLT,
/* FD */ op1op2BLT,
/* FE */ op1op2BLT,
/* FF */ op0BLT,     // WHITENESS.
};

#endif // _ROPTBL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\laguna\mini\include\setmode.h ===
//
// NT Miniport SetMode() header file.
//
//


//
// Default mode: VGA mode 3
//
#define DEFAULT_MODE                0

//
// The mode switch library exports these symbols to the miniport.
//


//
// Mode table structure
// Structure used for the mode table informations
//
typedef struct {
   BOOLEAN  ValidMode;        // TRUE: Mode is valid.
   ULONG    ChipType;         // Chips which support this mode.
   USHORT   fbType;           // color or monochrome, text or graphics,
                              // via VIDEO_MODE_COLOR and VIDEO_MODE_GRAPHICS
                              // and interlace or non-interlace via
                              // VIDEO_MODE_INTERLACED

   USHORT   Frequency;        // Frequency
   USHORT   BIOSModeNum;      // BIOS Mode number

   USHORT   BytesPerScanLine; // Bytes Per Scan Line
   USHORT   XResol;           // Horizontal resolution in pixels or char
   USHORT   YResol;           // Vertical  resolution in pixels or char
   UCHAR    XCharSize;        // Char cell width  in pixels
   UCHAR    YCharSize;        // Char cell height in pixels
   UCHAR    NumOfPlanes;      // Number of memory planes
   UCHAR    BitsPerPixel;     // Bits per pixel
   UCHAR    MonitorTypeVal;   // Monitor type setting bytes
   UCHAR    *SetModeString;   // Instructino string used by SetMode().

} MODETABLE, *PMODETABLE;

extern MODETABLE  ModeTable[];
extern ULONG      TotalVideoModes;
void SetMode(BYTE *, BYTE *, BYTE *);
unsigned long GetVmemSize(BYTE *Regs);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\laguna\mini\include\l3system.h ===
/**************************************************************************
***************************************************************************
*
*     Copyright (c) 1997, Cirrus Logic, Inc.
*                 All Rights Reserved
*
* FILE:         l3system.h
*
* DESCRIPTION:  546X 3D engine defines and structures
*
* AUTHOR:       Goran Devic, Mark Einkauf
*
* REVISION HISTORY:
*
* $Log:   W:/log/laguna/ddraw/inc/l3system.h  $
* 
*    Rev 1.4   01 Jul 1997 09:58:18   einkauf
* 
* add dither x,y offsets, to fix bexact.c OpenGL conformance test
* 
*    Rev 1.3   08 Apr 1997 12:42:14   einkauf
* cleanup TSystem struct; misc to complete MCD code
* 
*    Rev 1.2   05 Mar 1997 02:32:02   KENTL
* 
* Attempted to merge Rev 1.0 with Rev 1.1. The most recent check-in was
* severely incompatible with the Win95 build of DirectDraw. For some reason,
* only a tiny section of this file is used or even compatible with the
* Win95 build. Revision 1.0 had vast sections of the file commented out.
* Apparently, those sections are required for the WinNT build. I wrapped
* those sections in a couple of huge #ifdef WINNT_VER40, but I haven't
* tested this in an NT build. It seems to work for Win95, though.
* 
*    Rev 1.0   25 Nov 1996 15:00:40   RUSSL
* Initial revision.
* 
****************************************************************************
***************************************************************************/

#ifndef _L3SYSTEM_H_
#define _L3SYSTEM_H_

#ifdef WINNT_VER40

#define OPENGL_MCD


/*********************************************************************
*   Include types and debug info
**********************************************************************/
#ifndef OPENGL_MCD	// LL3D's type.h redundant with basic type definitions in other DDK/msdev headers
#include "type.h"
#endif // ndef OPENGL_MCD

#include "l3d.h"						    

#define	TRUE                1
#define FALSE               0

/*********************************************************************
*   Local Variables and defines
**********************************************************************/
#define KB                  1024        // Defines a kilobyte
#define MAX_DL_SIZE         (512 * KB)  // Maximum size of display list
#define NUM_DL              2           // Number of display lists
#define NUM_BUFFERS         32          // Number of allocation buffers; 
                                        //  video, system memory and user
#define NUM_TEXTURES        512         // Number of textures
#define NUM_TEX_MEM         4           // Number of system texture memory 
                                        //  chunks (each chunk is 4Mb)
#define EXTRA_FRACT         4           // Texture params functions may use 
                                        //  some extra bit for precision


// MCD_TEMP - support for temporary dlist of 2K only
#define SIZE_TEMP_DL    2048

#define DL_START_OFFSET		20			

/*********************************************************************
*   Buffer flags in LL_State structure (dont change!)
**********************************************************************/
#define BUFFER_IN_RDRAM         0
#define BUFFER_IN_SYSTEM        1
#define Z_BUFFER                2
#define BUFFER_USER             4
#define BUFFER_FREE             0x80000000

/*********************************************************************
*   Textures flags in LL_State structure (dont change!)
**********************************************************************/
#define TEX_FREE            0x80000000  // Free slot for the texture
#define TEX_NOT_LOADED      0x40000000  // Texture just registered
#define TEX_IN_SYSTEM       0x20000000  // Currently located in system mem
#define TEX_TILED           0x10000000  // Texture is in tiled form
#define TEX_LOCKED          0x08000000  // Texture is locked

#define TEX_MAX_PRIORITY    0xfffffffe  // Priority level
#define TEX_DEFAULT_PRIORITY         1  // Default texture priority level


/*********************************************************************
*
*   Registers in the form suitable for adding to a pointer to a
*   double word.
*
**********************************************************************/

///////////////////////////////////////////////////////
//  3D Rendering Registers                           // 
///////////////////////////////////////////////////////

#define X_3D                          (0x4000/4)
#define Y_3D                          (0x4004/4)
#define R_3D                          (0x4008/4)
#define G_3D                          (0x400C/4)
#define B_3D                          (0x4010/4)
#define DX_MAIN_3D                    (0x4014/4)
#define Y_COUNT_3D                    (0x4018/4)
#define WIDTH1_3D                     (0x401C/4)
#define WIDTH2_3D                     (0x4020/4)
#define DWIDTH1_3D                    (0x4024/4)
#define DWIDTH2_3D                    (0x4028/4)
#define DR_MAIN_3D                    (0x402C/4)
#define DG_MAIN_3D                    (0x4030/4)
#define DB_MAIN_3D                    (0x4034/4)
#define DR_ORTHO_3D                   (0x4038/4)
#define DG_ORTHO_3D                   (0x403C/4)
#define DB_ORTHO_3D                   (0x4040/4)
#define Z_3D                          (0x4044/4)
#define DZ_MAIN_3D                    (0x4048/4)
#define DZ_ORTHO_3D                   (0x404C/4)
#define V_3D                          (0x4050/4)
#define U_3D                          (0x4054/4)
#define DV_MAIN_3D                    (0x4058/4)
#define DU_MAIN_3D                    (0x405C/4)
#define DV_ORTHO_3D                   (0x4060/4)
#define DU_ORTHO_3D                   (0x4064/4)
#define D2V_MAIN_3D                   (0x4068/4)
#define D2U_MAIN_3D                   (0x406C/4)
#define D2V_ORTHO_3D                  (0x4070/4)
#define D2U_ORTHO_3D                  (0x4074/4)
#define DV_ORTHO_ADD_3D               (0x4078/4)
#define DU_ORTHO_ADD_3D               (0x407C/4)

#define A_3D                          (0x40C0/4)
#define DA_MAIN_3D                    (0x40C4/4)
#define DA_ORTHO_3D                   (0x40C8/4)


///////////////////////////////////////////////////////
//  3D Control registers                             // 
///////////////////////////////////////////////////////

#define CONTROL_MASK_3D               (0x4100/4)
#define CONTROL0_3D                   (0x4104/4)
#define COLOR_MIN_BOUNDS_3D           (0x4108/4)
#define COLOR_MAX_BOUNDS_3D           (0x410C/4)
#define CONTROL1_3D                   (0x4110/4)
#define BASE0_ADDR_3D                 (0x4114/4)
#define BASE1_ADDR_3D                 (0x4118/4)

#define TX_CTL0_3D                    (0x4120/4)
#define TX_XYBASE_3D                  (0x4124/4)
#define TX_CTL1_3D                    (0x4128/4)
#define TX_CTL2_3D                    (0x412C/4)
#define COLOR0_3D                     (0x4130/4)
#define COLOR1_3D                     (0x4134/4)
#define Z_COLLIDE_3D                  (0x4138/4)
#define STATUS0_3D                    (0x413C/4)
#define PATTERN_RAM_0_3D              (0x4140/4)
#define PATTERN_RAM_1_3D              (0x4144/4)
#define PATTERN_RAM_2_3D              (0x4148/4)
#define PATTERN_RAM_3_3D              (0x414C/4)
#define PATTERN_RAM_4_3D              (0x4150/4)
#define PATTERN_RAM_5_3D              (0x4154/4)
#define PATTERN_RAM_6_3D              (0x4158/4)
#define PATTERN_RAM_7_3D              (0x415C/4)
#define X_CLIP_3D                     (0x4160/4)
#define Y_CLIP_3D                     (0x4164/4)
#define TEX_SRAM_CTRL_3D              (0x4168/4)


///////////////////////////////////////////////////////
//  HostXY Unit Registers - Must use WRITE_DEV_REGS  //
///////////////////////////////////////////////////////

#define HXY_BASE0_ADDRESS_PTR_3D      (0x4200/4)
#define HXY_BASE0_START_XY_3D         (0x4204/4)
#define HXY_BASE0_EXTENT_XY_3D        (0x4208/4)

#define HXY_BASE1_ADDRESS_PTR_3D      (0x4210/4)
#define HXY_BASE1_OFFSET0_3D          (0x4214/4)
#define HXY_BASE1_OFFSET1_3D          (0x4218/4)
#define HXY_BASE1_LENGTH_3D           (0x421C/4)

#define HXY_HOST_CTRL_3D              (0x4240/4)

#define MAILBOX0_3D                   (0x4260/4)
#define MAILBOX1_3D                   (0x4264/4)
#define MAILBOX2_3D                   (0x4268/4)
#define MAILBOX3_3D                   (0x426C/4)


///////////////////////////////////////////////////////
//  The 3D Prefetch Unit Registers                   //
///////////////////////////////////////////////////////

#define PF_BASE_ADDR_3D               (0x4400/4)
#define PF_CTRL_3D                    (0x4404/4)
#define PF_DEST_ADDR_3D               (0x4408/4)
#define PF_FB_SEG_3D                  (0x440C/4)

#define PF_INST_ADDR_3D               (0x4420/4)
#define PF_STATUS_3D                  (0x4424/4)

#define HOST_MASTER_CTRL_3D           (0x4440/4)

#define PF_INST_3D                    (0x4480/4)

#define HOST_3D_DATA_PORT             (0x4800/4)


/*********************************************************************
*
*   Device select for the WRITE_DEV_REGS instruction
*
**********************************************************************/
#define VGAMEM                        (0x00000000 << 21)
#define VGAFB                         (0x00000001 << 21)
#define VPORT                         (0x00000002 << 21)
#define LPB                           (0x00000003 << 21)
#define MISC                          (0x00000004 << 21)
#define ENG2D                         (0x00000005 << 21)
#define HD                            (0x00000006 << 21)
#define FB                            (0x00000007 << 21)
#define ROM                           (0x00000008 << 21)
#define ENG3D                         (0x00000009 << 21)
#define HOST_XY                       (0x0000000A << 21)
#define HDATA_3D                      (0x0000000B << 21)


#endif // WINNT_VER40
/*********************************************************************
*
*   Laguna 3D Micro Instruction Set
*
**********************************************************************/

#define OPCODE_MASK                    0xF8000000
#define POINT                          0x00000000
#define LINE                           0x08000000
#define POLY                           0x10000000
#define WRITE_REGISTER                 0x18000000
#define READ_REGISTER                  0x20000000
#define WRITE_DEV_REGS                 0x28000000
#define READ_DEV_REGS                  0x30000000
#define BRANCH                         0x38000000
#define C_BRANCH                       0x40000000
#define NC_BRANCH                      0x48000000
#define CALL                           0x50000000
#define WRITE_DEST_ADDR                0x58000000

#define IDLE                           0x68000000
#define CLEAR                          0x69400000
#define WAIT                           0x72000000
#define WAIT_AND                       0x72000000
#define NWAIT_AND                      0x73000000
#define WAIT_OR                        0x70000000
#define NWAIT_OR                       0x71000000
#define CLEAR_INT                      0x78000000
#define SET_INT                        0x7A000000
#define TEST                           0x80000000
#define TEST_AND                       0x82000000
#define NTEST_AND                      0x83000000
#define TEST_OR                        0x80000000
#define NTEST_OR                       0x81000000
#define WRITE_PREFETCH_CONTROL         0x88000000

#ifdef WINNT_VER40     // Not WINNT_VER40

/*********************************************************************
*
*   Prefetch status flags (Almost the same as events)
*
**********************************************************************/
#define ST_VBLANK                      0x00000001
#define ST_EVSYNC                      0x00000002
#define ST_LINE_COMPARE                0x00000004
#define ST_BUFFER_SWITCH               0x00000008
#define ST_Z_BUFFER_COMPARE            0x00000010
#define ST_POLY_ENG_BUSY               0x00000020
#define ST_EXEC_ENG_3D_BUSY            0x00000040
#define ST_XY_ENG_BUSY                 0x00000080
#define ST_BLT_ENG_BUSY                0x00000100
#define ST_BLT_WF_EMPTY                0x00000200
#define ST_DL_READY_STATUS             0x00000400


/*********************************************************************
*
*   Defines for pixel modes (Control0 register)
*
**********************************************************************/
#define PIXEL_MODE_INDEXED             0
#define PIXEL_MODE_332                 1
#define PIXEL_MODE_565                 2
#define PIXEL_MODE_555                 3
#define PIXEL_MODE_A888                4
#define PIXEL_MODE_Z888                5

/*********************************************************************
*
*   Macros for building the instruction opcodes
*
**********************************************************************/
//#define make_point( imodif, count )  (POINT | imodif | count)

#define mk_reg( reg )                  (((reg)-0x1000) << 6)
#define mk_dev_reg( reg )              ((((reg)-0x1080)*4) << 6)

#define write_register( reg, count ) \
( WRITE_REGISTER | mk_reg(reg) | count )

#define write_dev_register( device, reg, count ) \
( WRITE_DEV_REGS | device | mk_dev_reg(reg) | count )

// Set the register and the cache in LL_State to a specific value
#define SETREG(Offset,Reg,Value) \
    *(ppdev->LL_State.pRegs + (Offset)) = ppdev->LL_State.Reg = (Value); /*inp(0x80); inp(0x80)*/

// setreg, no cache: do not cache state for this register
#define SETREG_NC(reg, value)     \
    (*(ppdev->LL_State.pRegs + reg) = value); /*inp(0x80); inp(0x80)*/

// Clears the range of registers
#define CLEAR_RANGE( StartReg, EndReg ) \
    memset( (void *)(ppdev->LL_State.pRegs + (StartReg)), 0, ((EndReg) - (StartReg)+1)*4 )



#ifndef OPENGL_MCD
// The polling for the 3d engine busy bit is done inline to avoid Watcom
// optimization of accessing a byte instead of a dword of that register.
//
#pragma aux Poll3DEngineBusy =   \
"lp:    test dword ptr [eax], 2" \
"       jnz  lp"                 \
parm caller [eax];
#endif // ndef OPENGL_MCD


// Instruction modifier set
//
#define STALL                          0x04000000
#define GOURAUD                        0x00001000
#define Z_ON                           0x00002000
#define SAME_COLOR                     0x00008000
#define TEXTURE_LINEAR                 0x00020000
#define TEXTURE_PERSPECTIVE            0x00030000
#define LIGHTING                       0x00040000
#define STIPPLE                        0x00080000
#define PATTERN                        0x00100000
#define DITHER                         0x00200000
#define ALPHA                          0x00400000
#define FETCH_COLOR                    0x00800000
#define WARP_MODE                      0x01000000
#define MODIFIER_EXPANSION             0x02000000


/*********************************************************************
*
*   Speed / Quality decision values
*
**********************************************************************/
#define LLQ_POLY_SUBPIXEL   192   // When poly param will use fp / subpixels
#define LLQ_POLY_FLOAT      64    // Polys start to use fp
#define LLQ_LINE_SUBPIXEL   128   // When lines will consider subpixel addressing


/*********************************************************************
*
*   Control0_3d register bitfields
*
**********************************************************************/
typedef struct
{
DWORD Pixel_Mode            : 3;  // Color frame buffer drawing mode
DWORD Res1                  : 1;  // Reserved
DWORD Pixel_Mask_Enable     : 1;  // Enables pixel masking
DWORD Pixel_Mask_Polarity   : 1;  // Polarity of the pixel masks
DWORD Color_Saturate_En     : 1;  // Enables saturation in indexed mode
DWORD Red_Color_Compare_En  : 1;  // Enables compare to bounds for red
DWORD Green_Color_Compare_En: 1;  // Enables compare to bounds for green
DWORD Blue_Color_Compare_En : 1;  // Enables compare to bounds for blue
DWORD Color_Compare_Mode    : 1;  // Mask inclusive/exclusive to bounds
DWORD Alpha_Mode            : 2;  // Selects alpha blending mode
DWORD Alpha_Dest_Color_Sel  : 2;  // Selects the DEST_RGB input to alpha
DWORD Alpha_Blending_Enable : 1;  // Enables alpha blending
DWORD Z_Stride_Control      : 1;  // 16/8 bit Z depth
DWORD Frame_Scaling_Enable  : 1;  // Enables frame scaling (multiply src*dest)
DWORD Res2                  : 2;  // Reserved
DWORD Z_Compare_Mode        : 4;  // Different Z compare function
DWORD Z_Collision_Detect_En : 1;  // Enables Z collision detection
DWORD Light_Src_Sel         : 2;  // Selects the lighting source input
DWORD Res3                  : 1;  // Reserved
DWORD Z_Mode                : 3;  // Controls Z and color update method
DWORD Res4                  : 1;  // Reserved

} TControl0Reg;


/*********************************************************************
*
*   Base0_addr_3d register bitfields
*
**********************************************************************/
typedef struct
{
DWORD Res1                  : 6;  // Reserved
DWORD Color_Buffer_X_Offset : 7;  // Offset to color buffer X address
DWORD Color_Buffer_Location : 1;  // For drawing: 0-rdram, 1-host
DWORD Z_Buffer_Location     : 1;  // For drawing: 0-rdram, 1-host
DWORD Texture_Location      : 1;  // For drawing: 0-rdram, 1-host
DWORD Pattern_Y_Offset      : 4;  // Pattern lookup offset for y address
DWORD Res2                  : 4;  // Reserved
DWORD Pattern_X_Offset      : 4;  // Pattern lookup offset for x address
DWORD Res3                  : 4;  // Reserved

} TBase0Reg;


/*********************************************************************
*
*   Base1_addr_3d register bitfields
*
**********************************************************************/
typedef struct
{
DWORD Res1                  : 5;  // Reserved
DWORD Color_Buffer_Y_Offset : 8;  // Y offset from the color space Y base
DWORD Res2                  : 8;  // Reserved
DWORD Z_Buffer_Y_Offset     : 8;  // Y offset from the color space Y base
DWORD Res3                  : 3;  // Reserved

} TBase1Reg;

/*********************************************************************
*
*   Tx_Ctl0_3d register bitfields
*
**********************************************************************/
#define TX_CTL0_MASK (~0x0C08F000)// All the reserved bits
typedef struct
{
DWORD Tex_U_Address_Mask    : 3;  // Texture width (U space)
DWORD Tex_U_Ovf_Sat_En      : 1;  // Texture saturation enable for U
DWORD Tex_V_Address_Mask    : 3;  // Texture height (V space)
DWORD Tex_V_Ovf_Sat_En      : 1;  // Texture saturation enable for V
DWORD Texel_Mode            : 4;  // Texture type
DWORD Res1                  : 4;  // Reserved
DWORD Texel_Lookup_En       : 1;  // Use texel data as lookup index
DWORD Tex_As_Src            : 1;  // Specifies texture as source
DWORD Fil_Tex_En            : 1;  // Enables filtering
DWORD Res2                  : 1;  // Reserved
DWORD Tex_Mask_Polarity     : 1;  // Polarity of the masking bit
DWORD Tex_Mask_Enable       : 1;  // Enables texture masking
DWORD Tex_Mask_Function     : 1;  // Texture masking function 
DWORD UV_Precision          : 1;  // UV_Precision 8.24
DWORD Address_Mux           : 2;  // Texel UV Mux Select
DWORD Res4                  : 2;  // Reserved
DWORD CLUT_Offset           : 4;  // Color Lookup Table offset for 4, 8 bpp

} TTxCtl0Reg;


/*********************************************************************
*
*   Tx_Ctl1_3d register bitfields
*
**********************************************************************/
typedef struct
{
DWORD Tex_Min_Blue_Color          : 8;
DWORD Tex_Min_Green_Color         : 8;
DWORD Tex_Min_Red_Color           : 8;
DWORD Tex_Red_Color_Compare       : 1;
DWORD Tex_Green_Color_Compare     : 1;
DWORD Tex_Blue_Color_Compare      : 1;
DWORD Tex_Color_Compare_Mode      : 1;
DWORD Res                         : 4;

} TTxCtl1Reg;

/*********************************************************************
*
*   Tx_Ctl2_3d register bitfields
*
**********************************************************************/
typedef struct
{
DWORD Tex_Max_Blue_Color          : 8;
DWORD Tex_Max_Green_Color         : 8;
DWORD Tex_Max_Red_Color           : 8;
DWORD Tex_Fraction_Mask           : 3;
DWORD En_Cont_Bilinear            : 1;
DWORD En_Step_Bilinear            : 1;
DWORD Mask_Threshold              : 3;

} TTxCtl2Reg;


/*********************************************************************
*
*   Tx_XYBase_3d register bitfields
*
**********************************************************************/
typedef struct
{
WORD  Tex_X_Base_Addr;            // Texture base X coordinate
WORD  Tex_Y_Base_Addr;            // Texture base Y coordinate

} TTxXYBaseReg;


/*********************************************************************
*
*   HXY_Host_Ctrl_3d register bitfields
*
**********************************************************************/
typedef struct
{
DWORD  HostXYEnable  :  1;         // Host XY enable bit
DWORD  Res1          :  7;         // Reserved
DWORD  HostYPitch    :  6;         // Host Y Pitch of the system
DWORD  Res2          : 18;         // Reserved

} THXYHostCtrlReg;


/*********************************************************************
*
*   TMem structure defines a memory block
*
**********************************************************************/
typedef struct
{
    DWORD  hMem;                    // Memory handle
    DWORD *dwAddress;               // Linear address
    DWORD  dwSize;                  // Size of the buffer
    DWORD  dwPhyPtr;                // Physical / page table address

} TMem;


/*********************************************************************
*
*   Buffer information structure (buffers A, B, Z, ...)
*
**********************************************************************/
typedef struct
{
    DWORD dwFlags;                  // Buffer flags
    DWORD dwAddress;                // Buffer start byte address (absolute linear)
    DWORD dwPhyAdr;                 // Buffer physical address (system)
    DWORD dwPitchCode;              // Pitch code of a buffer (system)
    DWORD dwPitchBytes;             // Pitch of a buffer in bytes
    DWORD hMem;                     // Internal memory handle (system)
    LL_Rect Extent;                 // Buffer location offsets (video)

} TBuffer;


/*********************************************************************
*
*   TDisplayList structure defines a display list.
*
**********************************************************************/
typedef struct
{
    // pdwNext points to the next available location within this 
    // display list to fill in the Laguna instruction.
    // It is used for parametarization routines that postincrement
    // this variable.
    //
    DWORD *pdwNext;

    // Memory handle for this display list as optained from the
    // internal memory allocation function
    //
    DWORD hMem;

    // Linear address of the display list
    //
    DWORD *pdwLinPtr;

    // Linear address of the display list
    //
    DWORD *pdwStartOutPtr;  //ME - next word to be output

    // Physical address for a display list is next; it may also
    // be the address to the page table.  This address has the
    // appropriate format to be stored in the BASE* class registers
    //
    DWORD dwPhyPtr;

    // The length of a display list in bytes
    //
    DWORD dwLen;

    // Safety margin for building the display list
    //
    DWORD dwMargin;

} TDisplayList;


/*********************************************************************
*
*   TTextureState structure defines a texture state
*
**********************************************************************/
typedef struct
{
    LL_Texture Tex[ NUM_TEXTURES ]; // Array of texture information
    TMem Mem[ NUM_TEX_MEM ];        // Allocated memory information
    DWORD dwMemBlocks;              // Number of Mem entries used
    LL_Texture *pLastTexture;          // Used to cache textures

} TTextureState;


/*********************************************************************
*
*   TTextureRegs structure defines a texture registers
*
**********************************************************************/
typedef struct
{
    DWORD dv_main;
    DWORD du_main;
    DWORD dv_ortho;
    DWORD du_ortho;
    DWORD d2v_main;
    DWORD d2u_main;
    DWORD d2v_ortho;
    DWORD d2u_ortho;
    DWORD dv_ortho_add;
    DWORD du_ortho_add;

} TTextureRegs;


/*********************************************************************
*
*   System State Structure
*
**********************************************************************/
typedef struct
{
    DWORD rColor_Min_Bounds;        // Color compare min bounds
    DWORD rColor_Max_Bounds;        // Color compare max bounds

    DWORD AlphaConstSource;         // Constant source alpha (9:16)
    DWORD AlphaConstDest;           // Constant destination alpha (9:16)

    // Display lists management
    TDisplayList DL[ NUM_DL ];      // Array of d-list segments
    TDisplayList *pDL;              // Current display list to build
    DWORD dwCdl;                    // Index of the current d-list

    // Information from the init / current graphics mode
    DWORD *pRegs;                   // Register apperture
    BYTE  *pFrame;                  // Frame apperture

    unsigned 	int		pattern_ram_state;
	LL_Pattern	dither_array;

    WORD    dither_x_offset; 
    WORD    dither_y_offset; 

} TSystem;

typedef struct                      // MOUSE header structure
{
    WORD wX_Position;
    WORD wY_Position;
    WORD wStatus; //assigned to NEED_MOUSE_UPDATE or MOUSE_IS_UPDATED

} TMouseInfo;

extern void _TriFillTex(
                int right2left,
                int hiprecision_2ndorder,
                TTextureRegs * r,
                TEXTURE_VERTEX *vmin,
                TEXTURE_VERTEX *vmid,
                TEXTURE_VERTEX *vmax,
                float frecip_vm_y,
                float frecip_del_x_mid );


void _RunLaguna( );

#ifndef OPENGL_MCD // from here down, structs are more specific to LL3D

/*********************************************************************
*   Global Variables
**********************************************************************/

extern TSystem LL_State;
extern TMouseInfo LL_MouseInfo;


/*********************************************************************
*   External Functions
**********************************************************************/

extern BYTE *  GetLagunaApperture( int base );

/*********************************************************************
*   From PAGETBL.C:
**********************************************************************/

extern DWORD   AllocSystemMemory( DWORD dwSize );
extern void    FreeSystemMemory( DWORD hHandle );
extern DWORD   GetLinearAddress( DWORD hHandle );
extern DWORD   GetPhysicalAddress( DWORD hHandle );
extern DWORD * GetRegisterApperture();

/*********************************************************************
*   Extern functions: l3d.c, control.c, points.c, lines.c, polys.c
**********************************************************************/

extern DWORD * fnInvalidOp( DWORD *, LL_Batch * );
extern DWORD * fnNop( DWORD *, LL_Batch * );

extern DWORD * fnPoint( DWORD *, LL_Batch * );
extern DWORD * fnAALine( DWORD *, LL_Batch * );
extern DWORD * fnLine( DWORD *, LL_Batch * );
extern DWORD * fnPoly( DWORD *, LL_Batch * );
extern DWORD * fnNicePoly( DWORD *, LL_Batch * );
extern DWORD * fnPolyFast( DWORD *, LL_Batch * );

extern DWORD * fnSetClipRegion( DWORD *, LL_Batch * );
extern DWORD * fnSetZBuffer( DWORD *, LL_Batch * );
extern DWORD * fnSetZCompareMode( DWORD *, LL_Batch * );
extern DWORD * fnSetZMode( DWORD *, LL_Batch * );
extern DWORD * fnSetAlphaMode( DWORD *, LL_Batch * );
extern DWORD * fnSetAlphaDestColor( DWORD *, LL_Batch * );
extern DWORD * fnSetLightingSource( DWORD *, LL_Batch * );
extern DWORD * fnSetColor0( DWORD *, LL_Batch * );
extern DWORD * fnSetColor1( DWORD *, LL_Batch * );
extern DWORD * fnSetConstantAlpha( DWORD *, LL_Batch * );
extern DWORD * fnSetPattern(DWORD *dwNext, LL_Batch *pBatch);

extern DWORD * fnQuality( DWORD *, LL_Batch * );

extern DWORD * fnSetTextureColorBounds( DWORD *, LL_Batch * );
extern DWORD * fnSetDestColorBounds( DWORD *, LL_Batch * );

extern void    LL_ControlInit();
extern void    _ShutDown( char * szMsg, ... );

/*********************************************************************
*   From displist.c
**********************************************************************/

extern DWORD * (* fnList[256])( DWORD *, LL_Batch * );
extern DWORD * _RunLaguna( DWORD *pdwNext );

/*********************************************************************
*   From textures.c
**********************************************************************/

extern int     _InitTextures();
extern void    _CloseTextures();

/*********************************************************************
*   From mem.c
**********************************************************************/

extern void    _InitKmem( BYTE *, DWORD );
extern DWORD * _kmalloc( const DWORD * pBlock, int );
extern void    _kfree( const DWORD * pBlock, void * );

/*********************************************************************
*   From texparm.c
**********************************************************************/

typedef union
{
    float    f;
    long     i; 
} PTEXTURE;

#define CGL_XYZ DWORD

extern void _TriFillTex( int dir_flag, int dx_main, TTextureRegs * r,
#ifdef B4_PERF
    LL_Vert * vmin, LL_Vert * vmid, LL_Vert * vmax,
#else
    CGL_XYZ *pV1, PTEXTURE *pT1,
    CGL_XYZ *pV2, PTEXTURE *pT2,
    CGL_XYZ *pV3, PTEXTURE *pT3,
#endif
    int recip_vm_y, int recip_vd_y, int del_x_mid );


/*********************************************************************
*
*   Debug defines that are used to determine the specific file
*   for inclusion of debug information.  For definition, see makefile.
*
**********************************************************************/
#define DEBUG_L3D       0x0001    /* Enable debug info in L3d.c      */
#define DEBUG_PAGETBL   0x0002    /* Enable debug info in pagetbl.c  */
#define DEBUG_CONTROL   0x0004    /* Enable debug info in control.c  */
#define DEBUG_MEM       0x0008    /* Enable debug info in mem.c      */
#define DEBUG_TEX       0x0010    /* Enable debug info in textures.c */
#define DEBUG_PCX       0x0020    /* Enable debug info in pcx.c      */
#define DEBUG_BUFFERS   0x0040    /* Enable debug info in buffers.c  */

#ifdef CGL // added for CGL DLL 
#define L3D_MALLOC  dpmiAlloc
#define L3D_FREE    dpmiFree
#else
#define L3D_MALLOC  malloc
#define L3D_FREE    free
#endif

#endif // ndef OPENGL_MCD

#endif //  _L3SYSTEM_H_
#endif // WINNT_VER40
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\laguna\mini\include\swat.h ===
;/* Oh no - a polymorphic include file!
COMMENT !
********************************************************************************
*
* Copyright (c) 1997, Cirrus Logic, Inc.
* All Rights Reserved.
*
* FILE:			$Workfile:   swat.h  $
*
* DESCRIPTION:	This file hols the SWAT optimization flags.
*
* $Log:   X:/log/laguna/nt35/displays/cl546x/swat.h  $
* 
*    Rev 1.14   Jan 07 1998 10:56:42   frido
* Removed LOWRES switch.
* 
*    Rev 1.13   Dec 10 1997 13:23:38   frido
* Merged from 1.62 branch.
* 
*    Rev 1.12.1.1   Nov 18 1997 15:18:48   frido
* Turned MULTI_CLOCK on.
* 
*    Rev 1.12.1.0   Nov 17 1997 11:00:38   frido
* Added MUTLI_CLOCK (defaults to off).
* 
*    Rev 1.12   Nov 04 1997 09:15:24   frido
* Added COLOR_TRANSLATE and LOWRES switches.
* 
*    Rev 1.11   Nov 03 1997 18:33:24   frido
* Turned DATASTREAMING switch on.
* 
*    Rev 1.10   Oct 24 1997 10:37:46   frido
* Added DATASTREAMING switch (default off).
* 
*    Rev 1.9   27 Aug 1997 10:39:28   noelv
* Enabled SWAT7 and MEMMGR
* 
*    Rev 1.8   19 Aug 1997 17:32:34   noelv
* Turned off SWAT7 for WHQL release.
* 
*    Rev 1.7   18 Aug 1997 13:59:12   noelv
* 
* Turned off MEMMGR for 8/20 WHQL release.  We'll turn it back on after WHQL
* 
*    Rev 1.6   14 Aug 1997 15:36:16   noelv
* Turn on the new memory manager
* 
*    Rev 1.5   08 Aug 1997 15:36:24   FRIDO
* Changed PREFETCH into SWAT7 (as it used to be).
* 
*    Rev 1.4   08 Aug 1997 14:46:10   FRIDO
* Added MEMMGR and PREFETCH switches.
* 
*    Rev 1.3   28 May 1997 12:33:16   noelv
* Fixed type in SWAT1.
* 
*    Rev 1.2   07 May 1997 13:55:10   noelv
* Turned all opts on except 4 for nt140b11f
* 
*    Rev 1.1   01 May 1997 10:42:24   noelv
* disabled SWAT for now.
* 
*    Rev 1.0   29 Apr 1997 16:27:56   noelv
* Initial revision.
* SWAT: 
* SWAT:    Rev 1.1   24 Apr 1997 12:23:30   frido
* SWAT: Removed SWAT5 switch (memory manager).
* SWAT: 
* SWAT:    Rev 1.0   19 Apr 1997 17:11:20   frido
* SWAT: First release.
*
********************************************************************************
END COMMENT ! ;*/

;/*
COMMENT !

	SWAT1 - Heap Pre-Allocation
	---------------------------

	WinBench 97 is a nice program but it has a flaw.  Since it will now create
	fonts and allocate device bitmaps during its test it is also measuring the
	performance of your system.  Every time memory is allocated for fonts,
	pens, brushes, or device bitmaps memory is being allocated and most likely
	Windows NT will swap memory to the hard disk to achieve this goal.  This is
	why putting in more memory will help to increase the score since there will
	be less hard disk swapping involved.  We need to counteract this behaviour
	and make WInBench 97 less dependend on the amount of system memory and hard
	disk speed.

	WinBench 97 uses 300x150 size bitmaps for its pause box.  The pause box is
	showed when WinBench 97 has disabled timing and is loading more playback
	data from the hard disk.  So here we have a way to do some stuff when which
	will not be timed.  What we will do is allocate enough heap memory for 8
	full-screen device bitmaps.  This will make the PowerPoint test very happy
	since it is allocating these 8 full-screen device bitmaps during the slide
	show.  The only drawback is that NT will swap memory to hard disk in the
	background.  This will lower the Access score which we don't want.  That is
	why we have added a counter.  The Access test uses 10 300x150 bitmaps so we
	count down until Access has passed.  Then we will start pre-allocating heap
	space during each 300x150 bitmap request.

	But this will drop the CorelDRAW test a little which *will* show up in the
	overall score.  So one extra allocation is requested.  We will pre-allocate
	the heap memory during every full-screen device bitmap (see SWAT2) when the
	count down counter has reached zero.

;*/
	#define	SWAT1					1	/*	C switch		!
			SWAT1				=	1	;	Assembly switch	*/

;/*
COMMENT !

	SWAT2 - Hostifying
	------------------

	WinBench 97 is creating and destroying two full-screen device bitmaps
	during the setup stage of every GDI playback test.  So this is a good time
	to hostify all device bitmaps in the off-screen memory heap to make room
	for more urgent device bitmaps.

;*/
	#define	SWAT2					1	/*	C switch		!
			SWAT2				=	1	;	Assembly switch	*/

;/*
COMMENT !

	SWAT3 - Font Cache
	------------------

	The old font cache was a fast font cache but it had one limitation.  It
	would allocate the memory for each font everywhere in the off-screen memory
	which means it would fragment the memory heap very much.

	During initialization a 128kB memory pool will be allocated in off-screen
	memory.  Each time the font cache needs to allocate a font tile (128x16)
	for a new font it will now be allocated from this pool, which will hold up
	to 64 font tiles.

;*/
	#define	SWAT3					1	/*	C switch		!
			SWAT3				=	1	;	Assembly switch	*/

;/*
COMMENT !

	SWAT4 - Hardware Optimization
	-----------------------------

	Set the following hardware options for the CL-GD5465 chip:

		1) Enable 4-way interleaving on 4MB and 8MB boards.
		2) Reduce Address Translate Delay to 3 clocks.
		3) On AC revision and higher enable 256-byte fetch.
		4) On AC revision and higher enable frame buffer bursting.

;*/
	#define	SWAT4					0	/*	C switch		!
			SWAT4				=	0	;	Assembly switch	*/

;/*
COMMENT !

	SWAT6 - Striping
	----------------

	Enable striping in the pattern blit functions.

;*/
	#define	SWAT6					1	/*	C switch		!
			SWAT6				=	1	;	Assembly switch	*/

;/*
COMMENT !

	MEMMGR
	------

	Enable new memory manager.

;*/
	#define	MEMMGR					1	/*	C switch		!
			MEMMGR				=	1	;	Assembly switch	*/

;/*
COMMENT !

	SWAT7 - Monochrome width cut-off
	--------------------------------

	Cut off monochrome source expansion to 896 pixels to fix the silicon bugs
	in 256-byte prefetch.

;*/
	#define	SWAT7					1	/*	C switch		!
			SWAT7				=	1	;	Assembly switch	*/

;/*
COMMENT !

	DATASTREAMING - PCI/AGP Data Streaming
	--------------------------------------

	Wait for enough FIFO slots before writing anything to the command FIFO of
	the chip.

;*/
	#define	DATASTREAMING			1	/*	C switch		!
			DATASTREAMING		=	1	;	Assembly switch	*/

;/*
COMMENT !

	COLOR_TRANSLATE - Hardware color translation
	--------------------------------------------

	Enable or disable hardwrae color translation.

;*/
	#define	COLOR_TRANSLATE			0	/*	C switch		!
			COLOR_TRANSLATE		=	0	;	Assembly switch	*/

;/*
COMMENT !

	MULTI_CLOCK - Multi RAMBUS clock
	--------------------------------

	Enable or disable multi clock support (e.g. 515MB/s and 600MB/s).

;*/
	#define	MULTI_CLOCK				1	/*	C switch		!
			MULTI_CLOCK			=	1	;	Assembly switch	*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\laguna\mini\include\laguna.h ===
/******************************************************************************\
*
* $Workfile:   LAGUNA.H  $
*
* This file to be included by all host programs.
* 
* Copyright (c) 1995,1997 Cirrus Logic, Inc. 
*
* $Log:   X:/log/laguna/nt35/displays/cl546x/LAGUNA.H  $
* 
*    Rev 1.38   Mar 04 1998 16:13:30   frido
* Removed a warning message for the 5462/5464 chips in the REQUIRE
* macro.
* 
*    Rev 1.37   Mar 04 1998 16:08:50   frido
* Removed an invalid break.
* 
*    Rev 1.36   Mar 04 1998 14:54:48   frido
* Added contional REQUIRE in the new shadow macros.
* 
*    Rev 1.35   Mar 04 1998 14:52:54   frido
* Added new shadowing macros.
* 
*    Rev 1.34   Feb 27 1998 17:02:16   frido
* Changed REQUIRE and WRITE_STRING macros for new
* shadowQFREE register.
* 
*    Rev 1.33   Jan 20 1998 11:42:46   frido
* Changed REQUIRE and WRITESTRING macros to support the new
* scheme for GBP on.
* Added shadowing of BGCOLOR and DRAWBLTDEF registers.
* 
*    Rev 1.32   Jan 16 1998 09:50:38   frido
* Changed the way the GBP OFF handles WRITE_STRING macros.
* 
*    Rev 1.31   Dec 10 1997 13:24:58   frido
* Merged from 1.62 branch.
* 
*    Rev 1.30.1.0   Nov 18 1997 18:09:00   frido
* Changed WRITE_STRING macro so it will work when
* DATASTREAMING is turned of.
* Changed FUDGE to 0, we are not using DMA inside NT.
* 
*    Rev 1.30   Nov 04 1997 19:01:18   frido
* Changed HOSTDATA size from 0x800 DWORDs into 0x800 BYTEs. Silly me!
* 
*    Rev 1.29   Nov 04 1997 09:17:30   frido
* Added Data Streaming macros (REQUIRE and WRITE_STRING).
*
\******************************************************************************/

#ifndef _LAGUNA_H 
#define _LAGUNA_H 

#include "optimize.h"
#include "config.h"
#include "lgregs.h"


//
// PCI ID for Laguna chips.
//
#define CL_GD5462       0x00D0     // 5462
#define CL_GD5464       0x00D4     // 5464
#define CL_GD5464_BD    0x00D5     // 5464 BD
#define CL_GD5465       0x00D6     // 5465

//
// These chips don't exist yet, but we're FORWARD COMPATIBLE
// so we'll define them anyway.  I've been GUARENTEED that they
// will look and feel just like 5465 chips.
//
#define CL_GD546x_F7       0x00D7
#define CL_GD546x_F8       0x00D8
#define CL_GD546x_F9       0x00D9
#define CL_GD546x_FA       0x00DA
#define CL_GD546x_FB       0x00DB
#define CL_GD546x_FC       0x00DC
#define CL_GD546x_FD       0x00DD
#define CL_GD546x_FE       0x00DE
#define CL_GD546x_FF       0x00DF


//
// CHIP BUG: For certian values in PRESET register cursor enable/disable
// causes scanlines to be duplicated at the cursor hot spot.  (Seen
// as screen jump.)  There are lots of ways around this.  The easiest 
// is to turn the cursor on and leave it on.  Enable/Disable is handled by
// moving the cursor on/off the visable screen.
//
#define HW_PRESET_BUG 1



// The 5465 (to at least AC) has a problem when PCI configuration space
// is accessible in memory space.  On 16-bit writes, a 32-bit write is
// actually performed, so the next register has garbage written to it.
// We get around this problem by clearing bit 0 of the Vendor Specific
// Control register in PCI configuration space.  When this bit is set
// to 0, PCI configuration registers are not available through memory
// mapped I/O.  Since some functions, such as power management, require
// access to PCI registers, the display driver must post a message to
// the miniport to enable this bit when needed.
//
#define  VS_CONTROL_HACK 1


#if ENABLE_LOG_FILE
    extern long lg_i;
    extern char lg_buf[256];
#endif

#if POINTER_SWITCH_ENABLED
    extern int pointer_switch;
#endif



// The definitions are not portable. 486 / PC only !!!
typedef struct {
	BYTE	b;
	BYTE	g;
	BYTE	r;
	} pix24;

typedef	struct {
	BYTE u;
	BYTE y1;
	BYTE v;
	BYTE y2;
	} yuv_422;

typedef	struct {
	unsigned int v : 6;
	unsigned int u : 6;
	unsigned int y0: 5;
	unsigned int y1: 5;
	unsigned int y2: 5;
	unsigned int y3: 5;
	} yuv_411;

typedef	struct {
	unsigned int b : 5;
	unsigned int g : 5;
	unsigned int r : 5;
	} rgb_555;

typedef	struct {
	unsigned int b : 5;
	unsigned int g : 6;
	unsigned int r : 5;
	} rgb_565;


typedef union {
	DWORD	p32;
	yuv_422	yuv422;
	yuv_411	yuv411;
	pix24	p24;
	rgb_555	rgb555;
	rgb_565	rgb565;
	WORD	p16[2];
	BYTE	p8[4];
	} pixel;


#define FALSE 0
#ifndef TRUE
    #define TRUE (~FALSE)
#endif

/* from struct.h */
#define	fldoff(str, fld)	((int)&(((struct str *)0)->fld))
#define	fldsiz(str, fld)	(sizeof(((struct str *)0)->fld))

#define HPRR(pr_reg)      (_AP_direct_read(PADDR(pr_reg),fldsiz(PLUTOREGS,pr_reg), (ul)0))
#define RPR(pr_reg)       HPRR(pr_reg)
#define EHIST             (*(EXHIST*)excepttion) /* Exception History buffer      */
#define STAMP             (*(bytearray*)0x0)     /* time date stamp               */
#define HISTORYBUFFERADDR (ul)&history           /* 34020 address of recording    */


/* External functions the host program can call */

/*-------------------------------------------------------------------------*/

/* Function prototypes for emulator. Functions defined in host_if.c */
int     _cdecl _AP_init(int mode, void * frame_buf);
void    _cdecl _AP_write(ul addr, int size, ul data);
ul      _cdecl _AP_read(ul addr,int size);
void    _cdecl _AP_run(void);
boolean _cdecl _AP_busy();
boolean _cdecl _AP_done();
boolean _cdecl _AP_rfifo_empty();
boolean _cdecl _AP_require(int size);
ul      _cdecl _AP_direct_read(ul addr,int size);
void    _cdecl _AP_fb_write(ul offset, pixel data, ul size);
pixel   _cdecl _AP_fb_read(ul offset, ul size);


#if LOG_QFREE

    #define START_OF_BLT() \
    do{ \
        CHECK_QFREE(); \
    } while(0)

    #define END_OF_BLT() \
    do{ \
    } while(0)
        
#else
    #define START_OF_BLT()
    #define END_OF_BLT()
#endif





//
// This waits for the chip to go idle
//
#define WAIT_FOR_IDLE()                  \
    do {                                 \
        while (LLDR_SZ (grSTATUS) != 0); \
    } while (0)



//
// Macro to require a certian number of free queue entries.
//
#if DATASTREAMING
    #define FUDGE 2
    #define REQUIRE(n)														\
    {																		\
		if (ppdev->dwDataStreaming & 0x80000000)							\
		{																	\
			if (ppdev->shadowQFREE < ((n) + FUDGE))							\
			{																\
				while (ppdev->shadowQFREE < (n) + FUDGE)					\
				{															\
					ppdev->shadowQFREE = LLDR_SZ(grQFREE);					\
				}															\
			}																\
			ppdev->shadowQFREE -= (BYTE) n;									\
		}																	\
		else if (ppdev->dwDataStreaming)									\
		{																	\
			if (LLDR_SZ(grQFREE) < ((n) + FUDGE))							\
			{																\
				while (LLDR_SZ(grSTATUS) & 0x8005) ;						\
				ppdev->dwDataStreaming = 0;									\
			}																\
		}																	\
	}
	#define ENDREQUIRE()													\
	{																		\
		ppdev->dwDataStreaming |= 1;										\
	}
	#define WRITE_STRING(src, dwords)										\
	{																		\
		ULONG nDwords, nTotal = (ULONG) (dwords);							\
		PULONG data = (PULONG) (src);										\
		if (ppdev->dwDataStreaming & 0x80000000)							\
		{																	\
			while (nTotal > 0)												\
			{																\
				nDwords = (ULONG) ppdev->shadowQFREE;						\
				if (nDwords > FUDGE)										\
				{															\
					nDwords = min(nDwords - FUDGE, nTotal);					\
					memcpy((LPVOID) ppdev->pLgREGS->grHOSTDATA, data, nDwords * 4);	\
					data += nDwords;										\
					nTotal -= nDwords;										\
				}															\
				ppdev->shadowQFREE = LLDR_SZ(grQFREE);						\
			}																\
		}																	\
		else																\
		{																	\
			if ( ppdev->dwDataStreaming && (LLDR_SZ(grQFREE) < nTotal) )	\
			{																\
				while (LLDR_SZ(grSTATUS) & 0x8005) ;						\
				ppdev->dwDataStreaming = 0;									\
			}																\
			while (nTotal > 0)												\
			{																\
				nDwords = min(nTotal, 0x200);								\
				memcpy((LPVOID) ppdev->pLgREGS->grHOSTDATA, data, nDwords * 4);	\
				data += nDwords;											\
				nTotal -= nDwords;											\
			}																\
		}																	\
	}
#else
    #define REQUIRE(n)
	#define ENDREQUIRE()
	#define WRITE_STRING(src, dwords)										\
	{																		\
		ULONG nDwords, nTotal = (ULONG) (dwords);							\
		PULONG data = (PULONG) (src);										\
		while (nTotal > 0)													\
		{																	\
			nDwords = min(nTotal, 0x200);									\
			memcpy((LPVOID) ppdev->pLgREGS->grHOSTDATA, data, nDwords * 4);	\
			data += nDwords;												\
			nTotal -= nDwords;												\
		}																	\
	}
#endif

// 
// Macros to read Laguna registers.
//
#define LADDR(pr_reg) fldoff(GAR,pr_reg)

// #define LLDR(pr_reg,pr_siz)   _AP_direct_read((ul)LADDR(pr_reg),pr_siz)
#define LLDR(pr_reg,pr_siz)   (ppdev->pLgREGS_real->pr_reg)
#define LLDR_SZ(pr_reg)  LLDR(pr_reg, fldsiz(GAR,pr_reg))

// #define LLR(pr_reg,pr_siz)   _AP_read((ul)LADDR(pr_reg),pr_siz)
#define LLR(pr_reg,pr_siz)   LLDR(pr_reg,pr_siz)
#define LLR_SZ(pr_reg)   LLR(pr_reg, fldsiz(GAR,pr_reg))


#if LOG_WRITES
    #define LG_LOG(reg,val) 	  					     	\
    do {								     	\
	    lg_i = sprintf(lg_buf,"LL\t%4X\t%08X\r\n", 			     	\
            ((DWORD)(&ppdev->pLgREGS->reg) - (DWORD)(&ppdev->pLgREGS->grCR0)),	\
	    (val));							     	\
            WriteLogFile(ppdev->pmfile, lg_buf, lg_i, ppdev->TxtBuff, &ppdev->TxtBuffIndex);	\
    } while(0)
#else
    #define LG_LOG(reg,val) 
#endif

//
// Macros to write Laguna registers.
// 
// This is an amazingly, incredibly hairy macro that, believe it or not,
// will be greatly reduced by a good compiler.  The "if" can be 
// pre-determined by the compiler. 
// The purpose of this is to ensure that exactly the right number of bytes
// is written to the chip.  If the programmer writes, say, a BYTE to a 
// DWORD sized register, we need to be sure that the byte is zero extended
// and that a full DWORD gets written. 
//
#define LRWRITE(pr_reg,pr_siz,value) 					\
do { 									\
  LG_LOG(pr_reg,(value));						\
  if (sizeof(ppdev->pLgREGS->pr_reg) == sizeof(BYTE)) 			\
     {									\
        *(volatile BYTE *)(&ppdev->pLgREGS->pr_reg) = (BYTE)(value); 	\
     }									\
  else if (sizeof(ppdev->pLgREGS->pr_reg) == sizeof(WORD)) 		\
     {									\
	*(volatile WORD *)(&ppdev->pLgREGS->pr_reg) = (WORD)(value); 	\
	*(volatile WORD *)(&ppdev->pLgREGS->grBOGUS) = (WORD)(value); 	\
	LG_LOG(grBOGUS,(value));					\
     }									\
  else  								\
     {									\
	 *(volatile DWORD *)(&ppdev->pLgREGS->pr_reg) = (DWORD)(value); \
     }									\
} while(0)

#define LL(pr_reg,value) LRWRITE(pr_reg, fldsiz(GAR,pr_reg), value)




// ----------------------------------------------------------------------------
//
// Certian registers have been giving us problems.  We provide special
// write macros for them.
//

//
// Writes any 8 bit register.
//
#define LL8(pr_reg,value)                                               \
    do {                                                                \
        LG_LOG(pr_reg,(value));                                         \
        (*(volatile BYTE *)(&ppdev->pLgREGS->pr_reg) = (BYTE)(value));  \
    } while(0)



//
// Writes any 16 bit register.
//
#define LL16(pr_reg,value) 						\
    do { 								\
        LG_LOG(pr_reg,(value));						\
        (*(volatile WORD *)(&ppdev->pLgREGS->pr_reg) = (WORD)(value));  \
    } while(0)



//
// Double writes any 16 bit register.
//
#define LL16d(pr_reg,value) 						\
    do { 								\
        (*(volatile WORD *)(&ppdev->pLgREGS->pr_reg) =  (WORD)(value)); \
        LG_LOG(pr_reg,(value));						\
        (*(volatile WORD *)(&ppdev->pLgREGS->grBOGUS) = (WORD)(value)); \
        LG_LOG(grBOGUS,(value));					\
    } while(0)

	 

//
// Writes any 32 bit register.
//
#define LL32(pr_reg,value)													\
{																			\
	*(volatile DWORD *)(&ppdev->pLgREGS->pr_reg) = (DWORD)(value);			\
}

//
// MACROS FOR BLTEXT REGISTER.
//

    #define LL_BLTEXT(x,y) \
    LL32 (grBLTEXT_EX.dw, (((DWORD)(y) << 16) | ((DWORD)(x))))

#if ! DRIVER_5465
    #define LL_MBLTEXT(x,y) \
        do {                                \
            LL16 (grMBLTEXT_EX.pt.X,  x);   \
            LL16 (grBLTEXT_EX.pt.Y,  y);    \
        } while(0)
#else
    #define LL_MBLTEXT(x,y) \
    LL32 (grMBLTEXT_EX.dw, (((DWORD)(y) << 16) | ((DWORD)(x))))
#endif

    #define LL_BLTEXTR(x,y) \
    LL32 (grBLTEXTR_EX.dw, (((DWORD)(y) << 16) | ((DWORD)(x))))

    #define LL_BLTEXT_EXT(x,y) \
    LL32 (grBLTEXT.dw, (((DWORD)(y) << 16) | ((DWORD)(x))))

    #define LL_MBLTEXT_EXT(x,y) 		\
    LL32 (grMBLTEXT.dw, (((DWORD)(y) << 16) | ((DWORD)(x))))


    // Launch a BLT using the color translation features of the 
    // resize engine. (1:1 resize)
    #define LL_BLTEXT_XLATE(src_bpp, x, y) \
        do {\
                LL16 (grMIN_X, (~((x)-1)));\
                LL16 (grMAJ_X, (x));\
                LL16 (grACCUM_X, ((x)-1));\
                LL16 (grMIN_Y, (~((y)-1)));\
                LL16 (grMAJ_Y, (y));\
                LL16 (grACCUM_Y, ((y)-1));\
                LL16 (grSRCX, (((x)*(src_bpp)) >> 3) );\
                LL_BLTEXTR((x), (y));\
        } while(0)



//
// MACROS FOR CLIPULE/CLIPLOR REGISTERS.
//
    #define LL_CLIPULE(x,y)                                         \
    LL32 (grCLIPULE.dw, (((DWORD)(y) << 16) | ((DWORD)(x))));

    #define LL_MCLIPULE(x,y)                                        \
    LL32 (grMCLIPULE.dw, (((DWORD)(y) << 16) | ((DWORD)(x))));

    #define LL_CLIPLOR(x,y)                                         \
    LL32 (grCLIPLOR.dw, (((DWORD)(y) << 16) | ((DWORD)(x))));

    #define LL_MCLIPLOR(x,y)                                        \
    LL32 (grMCLIPLOR.dw, (((DWORD)(y) << 16) | ((DWORD)(x))));

    #define LL_CLIPULE_EX(x,y)                                      \
    LL32 (grCLIPULE_EX.dw, (((DWORD)(y) << 16) | ((DWORD)(x))));

    #define LL_MCLIPULE_EX(x,y)                                     \
    LL32 (grMCLIPULE_EX.dw, (((DWORD)(y) << 16) | ((DWORD)(x))));

    #define LL_CLIPLOR_EX(x,y)                                      \
    LL32 (grCLIPLOR_EX.dw, (((DWORD)(y) << 16) | ((DWORD)(x))));

    #define LL_MCLIPLOR_EX(x,y)                                     \
    LL32 (grMCLIPLOR_EX.dw, (((DWORD)(y) << 16) | ((DWORD)(x))));



//
// MACROS FOR OP0_opRDRAM REGISTER.
//
    #define LL_OP0(x,y) \
    LL32 (grOP0_opRDRAM.dw, (((DWORD)(y) << 16) | ((DWORD)(x))))

    #define LL_OP0_MONO(x,y) \
    LL32 (grOP0_opMRDRAM.dw, (((DWORD)(y) << 16) | ((DWORD)(x))))




//
// MACROS FOR OP1_opRDRAM REGISTER.
//
    #define LL_OP1(x,y) \
    LL32 (grOP1_opRDRAM.dw, (((DWORD)(y) << 16) | ((DWORD)(x))))

    #define LL_OP1_MONO(x,y) \
    LL32 (grOP1_opMRDRAM.dw, (((DWORD)(y) << 16) | ((DWORD)(x))))




//
// MACROS FOR OP2_opRDRAM REGISTER.
//
    #define LL_OP2(x,y) \
    LL32 (grOP2_opRDRAM.dw, (((DWORD)(y) << 16) | ((DWORD)(x))))

    #define LL_OP2_MONO(x,y) \
    LL32 (grOP2_opMRDRAM.dw, (((DWORD)(y) << 16) | ((DWORD)(x))))




//
// -- End of special write macros --------------------------------------------
//




/*  HPR is the copy of REGISTER_STRUCTURE that the host reads and writes from.
    PR is the actual register state after the information has gone
    through the FIFO.  Immediate registers are kept up-to-date in HPR.
    These structures are allocated in the link file.  */

extern GAR PR;		/* the emulator working copy */
extern GAR HPR[4];		/* the "host" copy */

#define LAGUNA_SRAM_SIZE	32  /* dwords */

#define IS_SRC 0x03		/* Source mask. */

struct _vid_mode {
	BYTE	Bpp;		// Bytes per pixel (8 / 16 / 24 / 32)
	WORD	Xextent;	// Display rsolution in pixels eg 1280
	WORD	Yextent;	// Vertical display resolution
	WORD	Xpitch;		// Offset in bytes from line 0 to line 1
	int		Vesa_Mode;	// Mode number for VESA ( if supported by S3 )
	};

typedef struct _vid_mode vid_mode;
typedef vid_mode *vid_ptr;


/***************************************************************************
*
* MACRO:        SYNC_W_3D
*
* DESCRIPTION:  If 3d context(s) active, wait until 3d engine idle
*                or until 1,000,000 checks have failed
*
****************************************************************************/

#if WINNT_VER40 && DRIVER_5465     // WINNT_VER40

    #define SYNC_3D_CONDITIONS (ST_POLY_ENG_BUSY|ST_EXEC_ENG_3D_BUSY|ST_XY_ENG_BUSY|/*ST_BLT_ENG_BUSY|*/ST_BLT_WF_EMPTY)

    #define ENSURE_3D_IDLE(ppdev)                                                                               \
    {                                                                                                           \
         int num_syncs=2;                                                                                       \
         /* there is a slight chance of a window in which all bits go off while engine fetching */              \
         /*   next command - double read should catch that                                      */              \
         while (num_syncs--)                                                                                    \
         {                                                                                                      \
             int status;                                                                                        \
             volatile int wait_count=0;                                                                         \
             do                                                                                                 \
             {                                                                                                  \
                 status = (*((volatile *)((DWORD *)(ppdev->pLgREGS) + PF_STATUS_3D)) & 0x3FF) ^ SYNC_3D_CONDITIONS; \
                 /* do something to give bus a breather, and to prevent eternal stall */                        \
                 wait_count++;                                                                                  \
             } while(((status & SYNC_3D_CONDITIONS) != SYNC_3D_CONDITIONS) && wait_count<1000000);              \
         }                                                                                                      \
    }

    #define SYNC_W_3D(ppdev)                                                                                    \
    {                                                                                                           \
        if (ppdev->NumMCDContexts > 0)                                                                          \
        {                                                                                                       \
            ENSURE_3D_IDLE(ppdev);                                                                              \
        }                                                                                                       \
    }

#else // WINNT_VER40 && DRIVER_5465

    // no 3D on NT before NT4.0.  No 3D on 62 and not used on 64.
    #define ENSURE_3D_IDLE(ppdev)    {}
    #define SYNC_W_3D(ppdev)    {}

#endif // WINNT_VER40

//
// New shadowing macros.
//
#define LL_FGCOLOR(color, r)												\
{																			\
	if ((DWORD) (color) != ppdev->shadowFGCOLOR)							\
	{																		\
		if (r) REQUIRE(r);													\
		LL32(grOP_opFGCOLOR, ppdev->shadowFGCOLOR = (DWORD) (color));		\
	}																		\
}

#define LL_BGCOLOR(color, r)												\
{																			\
	if ((DWORD) (color) != ppdev->shadowBGCOLOR)							\
	{																		\
		if (r) REQUIRE(r);													\
		LL32(grOP_opBGCOLOR, ppdev->shadowBGCOLOR = (DWORD) (color));		\
	}																		\
}

#define LL_DRAWBLTDEF(drawbltdef, r)										\
{																			\
	if ((DWORD) (drawbltdef) != ppdev->shadowDRAWBLTDEF)					\
	{																		\
		if (r) REQUIRE(r);													\
		LL32(grDRAWBLTDEF, ppdev->shadowDRAWBLTDEF = (DWORD) (drawbltdef));	\
	}																		\
}

#endif /* ndef _LAGUNA_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\laguna\mini\include\lgregs.h ===
/****************************************************************************
*****************************************************************************
*
*                ******************************************
*                * Copyright (c) 1995, Cirrus Logic, Inc. *
*                *            All Rights Reserved         *
*                ******************************************
*
* PROJECT:           Laguna I - Emulator
*
* FILE:              lgregs.h
*
* AUTHOR:            Austin Watson / Martin Barber.
*
* DESCRIPTION:       Register layout for Laguna Access.
*
* MODULES:
*
* REVISION HISTORY:
*                    5/10/95 agw - added all V1.5 memory mapped regs.
*
* $Log:   X:/log/laguna/nt35/displays/cl546x/LGREGS.H  $
* 
*    Rev 1.16   Dec 10 1997 13:25:02   frido
* Merged from 1.62 branch.
* 
*    Rev 1.15.1.0   Nov 18 1997 15:17:54   frido
* Always have the 3D registers available for the 5465 chip.
* Added mailbox registers for hardware debugging.
* 
*    Rev 1.15   Nov 04 1997 11:44:24   frido
* Fixed a typo in grCONTROL2 register.
* 
*    Rev 1.14   29 Aug 1997 17:08:52   RUSSL
* Added overlay support
*
*    Rev 1.13   29 Apr 1997 16:26:32   noelv
* Added SWAT code.
* SWAT:
* SWAT:    Rev 1.2   24 Apr 1997 10:10:12   frido
* SWAT: NT140b09 merge.
*
*    Rev 1.12   06 Feb 1997 10:34:22   noelv
*
* Added 5465 registers.
*
*    Rev 1.11   28 Jan 1997 14:32:38   SueS
* Added CHROMA_CNTL, BLTEXT, and MBLTEXT for the 65.
*
*    Rev 1.10   24 Jan 1997 08:29:48   SueS
* Added some more clipping registers for the 5465.
*
*    Rev 1.9   23 Jan 1997 17:15:18   bennyn
*
* Modified to support 5465 DD
*
*    Rev 1.8   16 Jan 1997 11:40:18   bennyn
*
* Added VS_CLK_CONTROL register
*
*    Rev 1.7   01 Nov 1996 09:25:18   BENNYN
*
*
*    Rev 1.6   25 Oct 1996 11:54:08   noelv
*
* Added ifdef around new '64 registers
*
*    Rev 1.5   24 Oct 1996 14:27:14   noelv
*
* Added some 3d registers.
*
*    Rev 1.4   20 Aug 1996 11:05:06   noelv
* Bugfix release from Frido 8-19-96
*
*    Rev 1.0   14 Aug 1996 17:16:38   frido
* Initial revision.
*
*    Rev 1.3   05 Mar 1996 11:59:54   noelv
* Frido version 19
 *
 *    Rev 1.0   17 Jan 1996 12:53:24   frido
 * Checked in from initial workfile by PVCS Version Manager Project Assistant.
*
*    Rev 1.1   11 Oct 1995 14:49:20   NOELV
*
* Added BOGUS register at address 5FC.
*
*    Rev 1.0   28 Jul 1995 14:03:20   NOELV
* Initial revision.
*
*    Rev 1.1   29 Jun 1995 13:23:18   NOELV
*
*
****************************************************************************
****************************************************************************/

#ifndef _LGREGS_
#define _LGREGS_

#include "lgtypes.h"
#include "optimize.h"

#if DRIVER_5465 && defined(OVERLAY)
/* 5465 Video Window registers data type */
#define MAX_VIDEO_WINDOWS       8   // space for eight video windows in MMIO regs

typedef struct tagVIDEOWINDOWSTRUCT
{
  WORD  grVW_HSTRT;                         // Base of VW + 0x0000
  BYTE  grPAD1_VW[0x0004-0x0002];
  WORD  grVW_HEND;                          // Base of VW + 0x0004
  WORD  grVW_HSDSZ;                         // Base of VW + 0x0006
  DWORD grVW_HACCUM_STP;                    // Base of VW + 0x0008
  DWORD grVW_HACCUM_SD;                     // Base of VW + 0x000C
  WORD  grVW_VSTRT;                         // Base of VW + 0x0010
  WORD  grVW_VEND;                          // Base of VW + 0x0012
  DWORD grVW_VACCUM_STP;                    // Base of VW + 0x0014
  DWORD grVW_VACCUM_SDA;                    // Base of VW + 0x0018
  DWORD grVW_VACCUM_SDB;                    // Base of VW + 0x001C
  DWORD grVW_PSD_STRT_ADDR;                 // Base of VW + 0x0020
  DWORD grVW_SSD_STRT_ADDR;                 // Base of VW + 0x0024
  DWORD grVW_PSD_UVSTRT_ADDR;               // Base of VW + 0x0028
  DWORD grVW_SSD_UVSTRT_ADDR;               // Base of VW + 0x002C
  BYTE  grPAD2_VW[0x0040-0x0030];
  WORD  grVW_SD_PITCH;                      // Base of VW + 0x0040
  BYTE  grPAD3_VW[0x0044-0x0042];
  DWORD grVW_CLRKEY_MIN;                    // Base of VW + 0x0044
  DWORD grVW_CLRKEY_MAX;                    // Base of VW + 0x0048
  DWORD grVW_CHRMKEY_MIN;                   // Base of VW + 0x004C
  DWORD grVW_CHRMKEY_MAX;                   // Base of VW + 0x0050
  WORD  grVW_BRIGHT_ADJ;                    // Base of VW + 0x0054
  BYTE  grPAD4_VW[0x00D4-0x0056];
  BYTE  grVW_Z_ORDER;                       // Base of VW + 0x00D4
  BYTE  grPAD5_VW[0x00D8-0x00D5];
  WORD  grVW_FIFO_THRSH;                    // Base of VW + 0x00D8
  BYTE  grPAD6_VW[0x00E0-0x00DA];
  DWORD grVW_CONTROL1;                      // Base of VW + 0x00E0
  DWORD grVW_CONTROL0;                      // Base of VW + 0x00E4
  DWORD grVW_CAP1;                          // Base of VW + 0x00E8
  DWORD grVW_CAP0;                          // Base of VW + 0x00EC
  DWORD grVW_TEST0;                         // Base of VW + 0x00F0
  BYTE  grPAD7_VW[0x0100-0x00F4];
} VIDEOWINDOWSTRUCT;
#endif	// DRIVER_5465 && OVERLAY

/*  Registers to be added. */
/*  5.3   PCI Configuration Registers */
/*  5.4   IO Registers */
/*        5.4.1 General VGA Registers */
/*        5.4.2 VGA Sequencer Registers */
/*        5.4.3 CRT Controller Registers */
/*        5.4.4 VGA Graphics Controller Registers */
/*        5.4.5 Attribute Controller Registers */
/*        5.4.6 Host Control Registers */

/*  Laguna Graphics Accelerator Registers data type. */

typedef struct GAR {

/*  5.5   Memory Mapped Registers */
/*  5.5.1 Memory Mapped VGA Regsiters */
  BYTE grCR0;      /* 0h */
  BYTE grPADCR0[3];
  BYTE grCR1;      /* 04h */
  BYTE grPADCR1[3];
  BYTE grCR2;      /* 08h */
  BYTE grPADCR2[3];
  BYTE grCR3;      /* 0Ch */
  BYTE grPADCR3[3];
  BYTE grCR4;      /* 010h */
  BYTE grPADCR4[3];
  BYTE grCR5;      /* 014h */
  BYTE grPADCR5[3];
  BYTE grCR6;      /* 018h */
  BYTE grPADCR[3];
  BYTE grCR7;      /* 01Ch */
  BYTE grPADCR7[3];
  BYTE grCR8;      /* 020h */
  BYTE grPADCR8[3];
  BYTE grCR9;      /* 024h */
  BYTE grPADCR9[3];
  BYTE grCRA;      /* 028h */
  BYTE grPADCRA[3];
  BYTE grCRB;      /* 02Ch */
  BYTE grPADCRB[3];
  BYTE grCRC;      /* 030h */
  BYTE grPADCRC[3];
  BYTE grCRD;      /* 034h */
  BYTE grPADCRD[3];
  BYTE grCRE;      /* 038h */
  BYTE grPADCRE[3];
  BYTE grCRF;      /* 03Ch */
  BYTE grPADCRF[3];
  BYTE grCR10;    /* 040h */
  BYTE grPADCR10[3];
  BYTE grCR11;    /* 044h */
  BYTE grPADCR11[3];
  BYTE grCR12;    /* 048h */
  BYTE grPADCR12[3];
  BYTE grCR13;    /* 04Ch */
  BYTE grPADCR13[3];
  BYTE grCR14;    /* 050h */
  BYTE grPADCR14[3];
  BYTE grCR15;    /* 054h */
  BYTE grPADCR15[3];
  BYTE grCR16;    /* 058h */
  BYTE grPADCR16[3];
  BYTE grCR17;    /* 05Ch */
  BYTE grPADCR17[3];
  BYTE grCR18;    /* 060h */
  BYTE grPADCR18[3];
  BYTE grCR19;    /* 064h */
  BYTE grPADCR19[3];
  BYTE grCR1A;    /* 068h */
  BYTE grPADCR1A[3];
  BYTE grCR1B;    /* 06Ch */
  BYTE grPADCR1B[0x74-0x6D];

  BYTE grCR1D;    /* 074h */
  BYTE grPADCR1D[3];
  BYTE grCR1E;    /* 078h */
  BYTE grPADCR1E[0x80-0x79];

  BYTE grMISC;    /* 080h */
  BYTE grPADMISC[3];
  BYTE grSRE;      /* 084h */
  BYTE grPADSRE[3];
  BYTE grSR1E;    /* 088h */
  BYTE grPADSR1E[3];
  BYTE grBCLK_Numerator;    /* 08Ch */
  BYTE grPADBCLK_Numerator[3];

  BYTE grSR18;    /* 090h */
  BYTE grPADSR18[3];
  BYTE grSR19;    /* 094h */
  BYTE grPADSR19[3];
  BYTE grSR1A;    /* 098h */
  BYTE grPADSR1A[0xA0-0x99];

  BYTE grPalette_Mask;        /* 0A0h */
  BYTE grPADPalette_Mask[3];
  BYTE grPalette_Read_Address;    /* 0A4h */
  BYTE grPADPalette_Read_Address[3];
#define  grPalette_State_Read_Only grPalette_Read_Address
  BYTE grPalette_Write_Address;    /* 0A8h */
  BYTE grPADPalette_Write_Address[3];
  BYTE grPalette_Data;        /* 0ACh */
  BYTE grPADPalette_Data[0xB0-0xAD];

/*  5.5.2 Video Pipeline Registers */

  BYTE grPalette_State;   /* 0B0h */
  BYTE grPADPalette_State[0xB4 - 0xB1];

  BYTE grExternal_Overlay;/* 0B4h */
  BYTE grPADExternal_Overlay[0xB8- 0xB5];

  BYTE grColor_Key;       /* 0B8h */
  BYTE grPADColor_Key[0xBC- 0xB9];

  BYTE grColor_Key_Mask;  /* 0BCh */
  BYTE grPADColor_Key_Mask[0xC0- 0xBD];

  WORD grFormat;          /* 0C0h */
  BYTE grPADFormat[0xCA- 0xC2];

  BYTE grStart_BLT_3;     /* 0CAh */
  BYTE grStop_BLT_3;      /* 0CBh */
  WORD grX_Start_2;       /* 0CCh */
  WORD grY_Start_2;       /* 0CEh */
  WORD grX_End_2;         /* 0D0h */
  WORD grY_End_2;         /* 0D2h */
  BYTE grStart_BLT_2;     /* 0D4h */
  BYTE grStop_BLT_2;      /* 0D5h */
  BYTE grPADStop_BLT_2[0xDE- 0xD6];

  BYTE grStart_BLT_1;     /* 0DEh */
  BYTE grStop_BLT_1;      /* 0DFh */
  WORD grCursor_X;        /* 0E0h */
  WORD grCursor_Y;        /* 0E2h */
  WORD grCursor_Preset;   /* 0E4h */
  WORD grCursor_Control;  /* 0E6h */
  WORD grCursor_Location; /* 0E8h */
  WORD grDisplay_Threshold_and_Tiling;  /* 0EAh */
  BYTE grPADDisplay_Thr[0xF0- 0xEC];

  WORD grTest;            /* 0F0h */
  WORD grTest_HT;         /* 0F2h */
  WORD grTest_VT;         /* 0F4h */

  BYTE  grPADTest_VT[0x100 - 0x00F6];

/*  5.5.3 VPort Registers */

  WORD  grX_Start_Odd;    /* 100h */
  WORD  grX_Start_Even;   /* 102h */
  WORD  grY_Start_Odd;    /* 104h */
  WORD  grY_Start_Even;   /* 106h */
  WORD  grVport_Width;    /* 108h */
  BYTE  grVport_Height;   /* 10Ah */
  BYTE  grPADVport_Height;
  WORD  grVport_Mode;     /* 10Ch */

  BYTE  grVportpad[0x180 - 0x10E];

/*  5.5.4 LPB Registers */

  BYTE  grLPB_Data[0x1F8-0x180];    /* 180h */
  BYTE  grPADLPB[0x1FC - 0x1F8];
  WORD  grLPB_Config;     /* 1FCh */
  WORD  grLPB_Status;     /* 1FEh */

#define grLPB_Data_0 grLPB_Data[0]
#define grLPB_Data_1 grLPB_Data[1]
#define grLPB_Data_2 grLPB_Data[2]
#define grLPB_Data_3 grLPB_Data[3]
#define grLPB_Data_4 grLPB_Data[4]
#define grLPB_Data_5 grLPB_Data[5]
#define grLPB_Data_6 grLPB_Data[6]
#define grLPB_Data_7 grLPB_Data[7]
#define grLPB_Data_8 grLPB_Data[8]
#define grLPB_Data_9 grLPB_Data[9]
#define grLPB_Data_10 grLPB_Data[10]
#define grLPB_Data_11 grLPB_Data[11]
#define grLPB_Data_12 grLPB_Data[12]
#define grLPB_Data_13 grLPB_Data[13]
#define grLPB_Data_14 grLPB_Data[14]
#define grLPB_Data_15 grLPB_Data[15]
#define grLPB_Data_16 grLPB_Data[16]
#define grLPB_Data_17 grLPB_Data[17]
#define grLPB_Data_18 grLPB_Data[18]
#define grLPB_Data_19 grLPB_Data[19]
#define grLPB_Data_20 grLPB_Data[20]
#define grLPB_Data_21 grLPB_Data[21]
#define grLPB_Data_22 grLPB_Data[22]
#define grLPB_Data_23 grLPB_Data[23]
#define grLPB_Data_24 grLPB_Data[24]
#define grLPB_Data_25 grLPB_Data[25]
#define grLPB_Data_26 grLPB_Data[26]
#define grLPB_Data_27 grLPB_Data[27]
#define grLPB_Data_28 grLPB_Data[28]
#define grLPB_Data_29 grLPB_Data[29]
#define grLPB_Data_30 grLPB_Data[30]
#define grLPB_Data_31 grLPB_Data[31]

/*  5.5.5 RAMBUS Registers */
/*  RAMBUS Registers for BIOS Simulation */

  WORD   grRIF_CONTROL;    /* 200 */
  WORD   grRAC_CONTROL;    /* 202 */
  WORD   grRAMBUS_TRANS;   /* 204 */
  BYTE   grPADRAMBUS_TRANS[0x240 - 0x206];
  REG32  grRAMBUS_DATA;   /* 240 */
  BYTE   grPADRAMBUS_DATA[0x280 - 0x244];

/*  5.5.6 Miscellaneous Registers */
  WORD   grSerial_BusA;					/* 0280h */
  WORD   grSerial_BusB;    				/* 0282h */
  BYTE   grPADMiscellaneous_1[0x2C0 - 0x284];
  BYTE	 grBCLK_Multiplier;				/* 0x2C0 */
  BYTE	 grBCLK_Denominator;			/* 0x2C1 */
  BYTE   grPADMiscellaneous_2[0x2C4 - 0x2C2];
  WORD	 grTiling_Control;				/* 0x2C4 */
  BYTE   grPADMiscellaneous_3[0x2C8 - 0x2C6];
  WORD   grFrame_Buffer_Cache_Control;	/* 0x2C8 */
  BYTE	 grPADMiscellaneous_4[0x300 - 0x2CA];

/*  5.5.7 PCI Configuration Registers */
  WORD   grVendor_ID;      /* 0300h */
  WORD   grDevice_ID;      /* 0302h */
  WORD   grCommand;        /* 0304h */
  WORD   grStatus;         /* 0306h */
  BYTE   grRevision_ID;    /* 0308h */
  BYTE   grClass_Code;     /* 0309h */
  BYTE   grPADClass_Code[0x30E - 0x30A];

  BYTE   grHeader_Type;    /* 030Eh */
  BYTE   grPADHeader_Type[0x310 - 0x30F];

  REG32  grBase_Address_0;      /* 0310h */
  REG32  grBase_Address_1;      /* 0314h */
  BYTE   grPADBase_Address_1[0x32C - 0x318];

  WORD   grSubsystem_Vendor_ID; /* 032Ch */
  WORD   grSubsystem_ID;        /* 032Eh */
  REG32  grExpansion_ROM_Base;  /* 0330h */
  BYTE   grPADExpansion_ROM_Base[0x33C - 0x334];

  BYTE   grInterrupt_Line;    /* 033Ch */
  BYTE   grInterrupt_Pin;     /* 033Dh */
//#if DRIVER_5465
  BYTE   grPADInterrupt_Pin[0x3F4 - 0x33E];
  DWORD  grVS_Clk_Control;   /* 03F4h */
//#else
//  BYTE   grPADInterrupt_Pin[0x3F8 - 0x33E];
//#endif

  REG32  grVGA_Shadow;       /* 03F8h */
  DWORD  grVS_Control;       /* 03FCh */

/*  5.5.8 Graphics Accelerator Registers */

/*  The 2D Engine control registers */

  WORD   grSTATUS;           /* 400 */
  WORD   grCONTROL;          /* 402 */
  BYTE   grQFREE;            /* 404 */
  BYTE   grOFFSET_2D;        /* 405 */
  BYTE   grTIMEOUT;          /* 406 */
  BYTE   grTILE_CTRL;        /* 407 */
  REG32  grRESIZE_A_opRDRAM; /* 408 */
  REG32  grRESIZE_B_opRDRAM; /* 40C */
  REG32  grRESIZE_C_opRDRAM; /* 410 */
  WORD	 grSWIZ_CNTL;		 /* 414 */
  WORD	 pad99;
  WORD	 grCONTROL2;		 /* 418 */
  BYTE   pad2[0x480 - 0x41A];
  REG32  grCOMMAND;          /* 480 */
  BYTE   pad3[0x500 - 0x484];
  WORD   grMIN_Y;            /* 500 */
  WORD   grMAJ_Y;            /* 502 */
  WORD   grACCUM_Y;          /* 504 */
  BYTE   pad3A[0x508 - 0x506];
  WORD   grMIN_X;            /* 508 */
  WORD   grMAJ_X;            /* 50A */
  WORD   grACCUM_X;          /* 50C */
  REG16  grLNCNTL;           /* 50E */
  REG16  grSTRETCH_CNTL;     /* 510 */
  REG16  grCHROMA_CNTL;      /* 512 */
  BYTE   pad3B[0x518 - 0x514];
  REG32  grBLTEXT;           /* 518 */
  REG32  grMBLTEXT;          /* 51C */
  REG32  grOP0_opRDRAM;      /* 520 */
  REG32  grOP0_opMRDRAM;     /* 524 */
  WORD   grOP0_opSRAM;       /* 528 */
  REG16  grPATOFF;           /* 52A */
  BYTE   pad4[0x540 - 0x52C];
  REG32  grOP1_opRDRAM;      /* 540 */
  REG32  grOP1_opMRDRAM;     /* 544 */
  WORD   grOP1_opSRAM;       /* 548 */
  WORD   grOP1_opMSRAM;      /* 54A */
  BYTE   pad5[0x560 - 0x54C];
  REG32  grOP2_opRDRAM;      /* 560 */
  REG32  grOP2_opMRDRAM;     /* 564 */
  WORD   grOP2_opSRAM;       /* 568 */
  WORD   grOP2_opMSRAM;      /* 56A */
  BYTE   pad6[0x580 - 0x56C];
  WORD   grSRCX;             /* 580 */
  REG16  grSHRINKINC;        /* 582 */

  REG32  grDRAWBLTDEF;       /* 584 */
#define  grDRAWDEF grDRAWBLTDEF.LH.LO   /* 584 */
#define  grBLTDEF  grDRAWBLTDEF.LH.HI   /* 586 */

  REG16  grMONOQW;           /* 588 */
  WORD   pad6a;              /* 58A */
  WORD   grPERFORMANCE;      /* 58C */
  WORD   pad7;               /* 58E */
  REG32  grCLIPULE;          /* 590 */
  REG32  grCLIPLOR;          /* 594 */
  REG32  grMCLIPULE;         /* 598 */
  REG32  grMCLIPLOR;         /* 59C */
  BYTE   pad7a[0x5e0 - 0x5A0];

  REG32  grOP_opFGCOLOR;     /* 5E0 */
  REG32  grOP_opBGCOLOR;     /* 5E4 */
  REG32  grBITMASK;          /* 5E8 */
  WORD   grPTAG;             /* 5EC */
  BYTE   pad8[0x5FC - 0x5ee];
  WORD   grBOGUS;            /* 5FC */
  REG32  grBLTEXT_XEX;       /* 600 */
  REG32  grBLTEXTFF_XEX;     /* 604 */
  REG32  grBLTEXTR_XEX;      /* 608 */
  WORD   grBLTEXT_LN_EX;     /* 60C */
  BYTE   pad9[0x620 - 0x60E];
  REG32  grMBLTEXT_XEX;      /* 620 */
  BYTE   pad9a[0x628 - 0x624];
  REG32  grMBLTEXTR_XEX;     /* 628 */
  BYTE   pad9b[0x700 - 0x62C];
  REG32  grBLTEXT_EX;        /* 700 */
  REG32  grBLTEXTFF_EX;      /* 704 */
  REG32  grBLTEXTR_EX;       /* 708 */
  BYTE   pad10[0x720 - 0x70c];
  REG32  grMBLTEXT_EX;       /* 720 */
  BYTE   pad10a[0x728 - 0x724];
  REG32  grMBLTEXTR_EX;      /* 728 */
  BYTE   pad10b[0x760 - 0x72C];
  REG32  grCLIPULE_EX;       /* 760 */
  BYTE   pad10c[0x770 - 0x764];
  REG32  grCLIPLOR_EX;       /* 770 */
  BYTE   pad10d[0x780 - 0x774];
  REG32  grMCLIPULE_EX;      /* 780 */
  BYTE   pad10e[0x790 - 0x784];
  REG32  grMCLIPLOR_EX;      /* 790 */
  BYTE   pad10f[0x7fc - 0x794];
  WORD   RECORD;             /*  7fc dummy for emulator */
  WORD   BREAKPOINT;         /*  7fe dummy for harware sim */
  DWORD  grHOSTDATA[0x800];  /* 800 thru 27ff  */

#if DRIVER_5465
  BYTE   pad23[0x413C - 0x2800];

  DWORD  grSTATUS0_3D;       /* 413C*/

  BYTE   pad24[0x4200 - 0x4140];

  DWORD  grHXY_BASE0_ADDRESS_PTR_3D;     /* 4200 */
  REG32  grHXY_BASE0_START_3D;           /* 4204 */
  REG32  grHXY_BASE0_EXTENT_3D;          /* 4208 */

  DWORD  pad25;            /* 420C */

  DWORD  grHXY_BASE1_ADDRESS_PTR_3D;     /* 4210 */
  DWORD  grHXY_BASE1_OFFSET0_3D;         /* 4214 */
  DWORD  grHXY_BASE1_OFFSET1_3D;         /* 4218 */
  DWORD  grHXY_BASE1_LENGTH_3D;          /* 421C */

  DWORD  pad27[8];               /* 4220 thru 423C */

  DWORD  grHXY_HOST_CRTL_3D;     /* 4240 */
  BYTE   pad3x[0x4260 - 0x4244];
  DWORD  grMAILBOX0_3D;			 /* 4260 */
  DWORD  grMAILBOX1_3D;			 /* 4264 */
  DWORD  grMAILBOX2_3D;			 /* 4268 */
  DWORD  grMAILBOX3_3D;			 /* 426C */
  BYTE   pad30[0x4424 - 0x4270];
  DWORD  grPF_STATUS_3D;         /* 4424 */

  BYTE   pad50[0x8000 - 0x4428];
#if defined(OVERLAY)
  /* Video Window Registers (CL_GD5465) */
  struct tagVIDEOWINDOWSTRUCT   VideoWindow[MAX_VIDEO_WINDOWS];
#endif
#endif

} Graphics_Accelerator_Registers_Type, * pGraphics_Accelerator_Registers_Type, GAR;

/*  Status Register values */

#define STATUS_FIFO_NOT_EMPTY 0x0001
#define STATUS_PIPE_BUSY 0x0002
#define STATUS_DATA_AVAIL 0x8000

#define STATUS_IDLE ( STATUS_PIPE_BUSY | STATUS_FIFO_NOT_EMPTY )

/*  Control register values */
#define WFIFO_SIZE_32 0x0100
#define HOST_DATA_AUTO 0x0200
#define SWIZ_CNTL 0x0400
/*  bits 12:11 define tile size */
#define TILE_SIZE_128 0x0000
#define TILE_SIZE_256 0x0800
#define TILE_SIZE_2048 0x1800
/*  bits 14:13 define bits per pixel for graphics modes */
#define CNTL_8_BPP 0x0000
#define CNTL_16_BPP 0x2000
#define CNTL_24_BPP 0x4000
#define CNTL_32_BPP 0x6000

/*  Tile_ctrl register */
/*  bits 7:6 interleave memory */
#define ILM_1_WAY 0x00
#define ILM_2_WAY 0x40
#define ILM_4_WAY 0x80
/*  bits 5:0 define BYTE pitch of display memory in conjunction with TILE_SIZE */
/*  from Control register */


/*
 * DRAWDEF contents
*/
#define DD_ROP      0x0000
#define DD_TRANS    0x0100      /*  transparent */
#define DD_TRANSOP  0x0200
#define DD_PTAG     0x0400
#define DD_CLIPEN   0x0800

/*  These bits moved to LNCNTL */
/* #define DD_INTERP    0x0800 */
/* #define DD_XSHRINK    0x1000 */
/* #define DD_YSHRINK    0x2000 */

#define DD_SAT_2    0x4000
#define DD_SAT_1    0x8000


/*  LN_CNTL fields */

#define LN_XINTP_EN    0x0001
#define LN_YINTP_EN    0x0002
#define LN_XSHRINK    0x0004
#define LN_YSHRINK    0x0008

/* These are the autoblt control bits */

#define LN_RESIZE 0x0100
#define LN_CHAIN_EN 0x0200

/*  These are the yuv411 output average control bits */
#define  LN_LOWPASS 0x1000
#define LN_UVHOLD 0x2000

/* This extracts the data format field from LNCNTL */

#define LN_FORMAT 0x00F0
#define LN_YUV_SHIFT 4

#define LN_8BIT  0x0000
#define LN_RGB555 0x0001
#define LN_RGB565 0x0002
#define LN_YUV422 0x0003
#define LN_24ARGB 0x0004
#define LN_24PACK 0x0005
#define LN_YUV411 0x0006
/*  7 - 15 are reserved */

/*
 * pmBLTDEF contents
 */

#define BD_OP2    0x0001  /*  start of OP2 field 3:0 */
#define BD_OP1    0x0010  /*  start of OP1 field 7:4 */
#define BD_OP0    0x0100  /*  start of OP0 field 8:8 */
#define BD_TRACK_X  0x0200  /*  Track OP ptrs in X 9:9 (when implemented) */
#define BD_TRACK_Y  0x0400  /*  Track OP ptrs in Y 10:10 (when implemented) */
#define BD_SAME    0x0800  /*  common operand field 11:11 */
#define BD_RES    0x1000  /*  start of RES field 14:12 */
#define BD_YDIR    0x8000  /*  y direction bit 15: */

/*
 * Field values for BD_OP? and BD_res.
 * LL( grBLTDEF,  (BD_OP1 * IS_HOST_MONO) +
 *      (BD_OP2 * (IS_VRAM + IS_PATTERN )) +
 *      (BD_RES * IS_VRAM) );
 */

#define IS_SRAM    0x0000
#define IS_VRAM    0x0001
#define IS_HOST    0x0002
#define IS_SOLID  0x0007
#define IS_SRAM_MONO  0x0004
#define IS_VRAM_MONO  0x0005
#define IS_HOST_MONO  0x0006
#define IS_PATTERN  0x0008
#define IS_MONO    0x0004

/*  these are for BD_RES only */
#define IS_SRAM0  0x0004
#define IS_SRAM1  0x0005
#define IS_SRAM2  0x0006
#define IS_SRAM12  0x0007

/*  these are for BD_SAME */
#define NONE  0x0000


// Be sure to synchronize this structure with the one in i386\Laguna.inc!
typedef struct _autoblt_regs {
  REG16  LNCNTL;
  REG16  SHRINKINC;
  REG32  DRAWBLTDEF;
  REG32  FGCOLOR;
  REG32  BGCOLOR;
  REG32  OP0_opRDRAM;
  WORD   MAJ_Y;
  WORD   MIN_Y;
  REG32  OP1_opRDRAM;
  WORD   ACCUM_Y;
  REG16  PATOFF;
  REG32  OP2_opRDRAM;
  WORD   MAJ_X;
  WORD   MIN_X;
  REG32  BLTEXT;
  WORD   ACCUM_X;
  WORD   OP0_opSRAM;
  WORD   SRCX;
  WORD   OP2_opSRAM;
  REG32  BLTEXTR_EX;
  REG32  MBLTEXTR_EX;
  REG32  OP0_opMRDRAM;
  REG32  OP1_opMRDRAM;
  REG16  STRETCH_CNTL;
  REG16  RESERVED;       // Needs this to make it into DWORD boundary
  REG32  CLIPULE;
  REG32  CLIPLOR;
  REG32  NEXT_HEAD;      /*  XY address of next in chain if LNCTL chain set */
} autoblt_regs, *autoblt_ptr;


#endif   /*  _LGREGS_ */

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\laguna\mini\include\type.h ===
/******************************************************************************
*
*   Module:     TYPE.H          Generic Type Header Module
*
*   Revision:   1.00
*
*   Date:       April 14, 1994
*
*   Author:     Randy Spurlock
*
*******************************************************************************
*
*   Module Description:
*
*       This module contains generic type declarations.
*
*******************************************************************************
*
*   Changes:
*
*    DATE     REVISION  DESCRIPTION                             AUTHOR
*  --------   --------  -------------------------------------------------------
*  04/14/94     1.00    Original                                Randy Spurlock
*
*******************************************************************************
*   Constant Declarations
******************************************************************************/
#define TRUE            1               /* Define TRUE as the value 1        */
#define FALSE           0               /* Define FALSE as the value 0       */

/******************************************************************************
*   Type Definitions
******************************************************************************/
typedef int BOOL;                       /* Define a boolean as an integer    */

typedef unsigned char BYTE;             /* Define a byte data type           */
typedef unsigned short int WORD;        /* Define a word data type           */
typedef unsigned long DWORD;            /* Define a double word data type    */


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\laguna\mini\include\version.h ===
/*
*
* File: Include\Version.h
*
* This file is created by makefile.mak.
*
*/

#define NT_VER_DRIVER 100*1 + 71
#define VER_REV       7

#ifdef WINNT_VER35
    #define NT_VER_MAJOR  3
    #define NT_VER_MINOR  51
    #define NT_VER_BUILD  1057
    #define NT_VER_STRING "3.51.1057.171"
    #define VER_MAJ       3
    #define VER_MIN       5
#else
    #if _WIN32_WINNT >= 0x0500
        #define NT_VER_MAJOR  5
        #define NT_VER_MINOR  00
        #define NT_VER_BUILD  1907
        #define NT_VER_STRING "5.00.1907.001"
    #else
        #define NT_VER_MAJOR  4
        #define NT_VER_MINOR  00
        #define NT_VER_BUILD  1381
        #define NT_VER_STRING "4.00.1381.171"
    #endif
#endif

#define CL_VER_STRING NT_VER_STRING "5.00.1907.981017.001"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\laguna\mini\include\xlate.h ===
/******************************Module*Header*******************************\
*
* Module Name: Xlate.h
* Author: Noel VanHook
* Purpose: Handles hardware color translation.
*
* Copyright (c) 1997 Cirrus Logic, Inc.
*
* $Log:   X:/log/laguna/nt35/displays/cl546x/xlate.h  $
* 
*    Rev 1.3   15 Oct 1997 14:19:50   noelv
* Moved ODD to xlate.c
* 
*    Rev 1.2   15 Oct 1997 12:06:24   noelv
* 
* Added hostdata workaround for 65.
* 
*    Rev 1.1   19 Feb 1997 13:07:32   noelv
* Added translation table cache
* 
*    Rev 1.0   06 Feb 1997 10:35:48   noelv
* Initial revision.
*/

#ifndef _XLATE_H_
#pragma pack(1)

extern ULONG ulXlate[16];


//
// External functions.
//
BOOLEAN bCacheXlateTable(struct _PDEV *ppdev, 
                        unsigned long **ppulXlate,
                        SURFOBJ  *psoTrg,
                        SURFOBJ  *psoSrc,
                        XLATEOBJ *pxlo,
                        BYTE      rop);

void vInitHwXlate(struct _PDEV *ppdev);

void vInvalidateXlateCache(struct _PDEV *ppdev);



/*

In 16, 24, and 32 BPP HOSTDATA color translation may or may not work 
correctly on the 5465.
The following is an email from Gary describing how to tell a good BLT from
a bad BLT.

==========================================================================
Subject:   color translate L3DA lockups
    Date:  Fri, 10 Oct 97 09:50:03 PDT
    From:  garyru (Gary Rudolph)
       To: noelv, vernh, martinb
      CC:  garyru

Here is the function to determine if the wrong amount
of host data will be fetched for a color translate
when the source and dest bpp differ.  Add the least
significant three bits of the number of source bytes
to the least significant three bits of OP1 address
and use that value to determine if "Odd" is set using
the table below.  Then use the least significant
three bits of destination bytes plus the least significant
three bits of OP1 address and use that value to determine
if "Odd" is set.  If you come up with the same value for
"Odd" in both cases, then the right amount of host
data will be fetched.  If the values of "Odd" are 
different then the engine will fetch one too many
or one too few dwords of host data per line.


Add             Odd
---             ---
0000    0       0
0001    1       1
0010    2       1
0011    3       1
0100    4       1
0101    5       0
0110    6       0
0111    7       0
1000    8       0
1001    9       1
1010    10      1
1011    11      1
1100    12      1
1101    13      0
1110    14      0
1111    15      0


Example:  8 to 32 translate
bltx = 639 pixels
op1 = 0000

Source
639 = 0x27F 
        111
    +   000
                ---
                111  ---> Odd = 0

Dest
639 x 4 = 0x9FC
                100
        +   000
                ---
                100  ---> Odd = 1

It is the Dest value of "Odd" that is used, so the engine
only fetches one dWord of the last Qword incorrectly.

I think the fix for the L128 is to use the srcx value rather
than the byte converted blt extent to determine the number
of dWords of host data to fetch.


-Gary
===========================================================================

*/

// Declared in XLATE.C
extern char ODD[]; // = {0,1,1,1, 1,0,0,0, 0,1,1,1, 1,0,0,0};


#define XLATE_IS_BROKEN(width_in_bytes, bytes_per_pixel, phase)               \
(                                                                             \
 ODD [   ((width_in_bytes) & 7)  /* lowest three bits of source bytes */      \
       + ((phase) & 7 ) ]        /* plus lowest three bits of OP_1 */         \
            !=                                                                \
 ODD [ (((width_in_bytes)*(bytes_per_pixel)) & 7) /* low bits of dest bytes */\
      +((phase) & 7) ]         /* plus lowest three bits of OP_1 */           \
)                                                                             \







#endif // _XLATE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\laguna\mini\include\mmcore.h ===
;/* Oh no - A polymorphic include file!
COMMENT ~ */
/******************************************************************************\
*
* $Workfile:   mmCore.h  $
*
* This is a polymorphic include file for the memory manager.
*
* Copyright (c) 1997, Cirrus Logic, Inc.
* All Rights Reserved.
*
* $Log:   X:/log/laguna/nt35/include/mmCore.h  $
* 
*    Rev 1.2   Oct 24 1997 10:39:22   frido
* Copied from WIndows 95 tree.
* 
*    Rev 1.4   23 Oct 1997 09:34:20   frido
* Removed changes from RandyS.
* Merged file with 161 tree.
* 
*    Rev 1.2.1.0   15 Oct 1997 12:54:16   frido
* Changed back to 200 nodes.
* Added function prototypes for new roll back functions.
* Added debugging macros.
* 
*    Rev 1.2   01 Oct 1997 10:17:02   frido
* Increased the number of nodes to 250 (fixes PDR 10650).
* 
*    Rev 1.1   14 Aug 1997 16:57:58   FRIDO
* mmco
* Added mmFlags field to DEVMEM structure.
* Added NOTE_... status values.
* 
*    Rev 1.0   07 Aug 1997 17:40:36   FRIDO
* Initial revision.
* SWAT: 
* SWAT:    Rev 1.0   17 Jun 1997 17:12:24   frido
* SWAT: Combined Windows 95 and NT versions together.
* SWAT: 
* SWAT:    Rev 1.5   16 Jun 1997 23:20:20   frido
* SWAT: More combined Windows 95 / NT stuff build in.
* SWAT: 
* SWAT:    Rev 1.4   21 May 1997 14:55:10   frido
* SWAT: Changed debug routines.
* SWAT: 
* SWAT:    Rev 1.3   16 May 1997 23:05:10   frido
* SWAT: Moved TILE_ALIGNMENT to SWAT.inc.
* SWAT: 
* SWAT:    Rev 1.2   06 May 1997 17:57:50   frido
* SWAT: Added tile alignment.
* SWAT: 
* SWAT:    Rev 1.1   03 May 1997 14:23:26   frido
* SWAT: A brand new interface.
* SWAT: 
* SWAT:    Rev 1.0   22 Apr 1997 15:26:52   frido
* SWAT: Copied to WN140b18 release.
* 
*    Rev 1.8   21 Mar 1997 14:03:46   frido
* Moved old memory manager core back to root.
* 
*    Rev 1.4.1.0   19 Mar 1997 13:45:40   frido
* Old memory core.
* 
*    Rev 1.4   06 Mar 1997 00:23:36   frido
* Added memory mover.
* 
*    Rev 1.3   27 Feb 1997 22:26:10   frido
* New memory manager core.
* 
*    Rev 1.2   18 Feb 1997 12:13:34   frido
* Changed WORD into UINT and pascal into PASCAL for Win32 debugging.
* 
*    Rev 1.1   13 Feb 1997 18:03:22   frido
* Added memory packer.
* 
*    Rev 1.0   13 Feb 1997 11:19:44   frido
* Ported from test case.
*
\******************************************************************************/

/******************************************************************************\
*																			   *
*								   C   P A R T								   *
*																			   *
\******************************************************************************/

#ifndef _MMCORE_H_
#define _MMCORE_H_

#define	TILE_ALIGNMENT	0		// align device bitmaps so there are as few tile
								//   crosses as possible
#define	DEBUG_HEAP		0		// enable debugging of heaps
#define	MM_NUM_HANDLES	200		// number of handles in each array

#ifdef WIN95 /* Windows 95 */
	typedef unsigned int UINT;
	typedef unsigned long ULONG;
	#define MUL(n1, n2) 		mmMultiply(n1, n2)
	#define MM_MOVEABLE(pdm)	( (pdm->client != NULL) && \
								  (pdm->client->mem_moved != NULL) )
	#define MM_HOSTIFYABLE(pdm)	(pdm->client->evict_single != NULL)
	#define MM_HOSTIFY(pdm)		pdm->client->evict_single(pdm)

#else /* Windows NT */
	#define MUL(n1, n2)			(ULONG)((UINT)(n1) * (UINT)(n2))
	#define MM_MOVEABLE(pdm)	( (pdm->ofm.pdsurf != NULL) && \
								  !(pdm->ofm.alignflag & DISCARDABLE_FLAG) )
	#define MM_HOSTIFYABLE(pdm)	(pdm->ofm.pcallback != NULL)
	#define MM_HOSTIFY(pdm)		((FNMMHOSTIFY)(pdm->ofm.pcallback))(pdm)

	/*
		GXPOINT structure required for memory manager.
	*/
	typedef union _GXPOINT
	{
		struct
		{
			UINT	x;
			UINT	y;
		} pt;

	} GXPOINT;

	/*
		The DEVMEM structure is a wrapper around the NT off-screen memory node.
	*/
	typedef struct _DEVMEM *PDEVMEM;
	typedef struct _DEVMEM
	{
		OFMHDL	ofm;					// NT structure
		GXPOINT	cbAddr;					// address in bytes of this node
		GXPOINT	cbSize;					// size in bytes of this node
		GXPOINT	cbAlign;				// alignment in bytes of this node
		PDEVMEM	next;					// pointer to next DEVMEM structure
		PDEVMEM	prev;					// pointer to previous DEVMEM structure
		DWORD	mmFlags;				// flags

	} DEVMEM;
#endif

#define	NODE_AVAILABLE	0
#define	NODE_FREE		1
#define	NODE_USED		2

typedef enum
{
	NO_NODES,
	SINGLE_NODE,
	MULTIPLE_NODES

} REMOVE_METHOD;

typedef struct _HANDLES *PHANDLES;
typedef struct _HANDLES
{
	PHANDLES	pNext;
	DEVMEM		dmArray[MM_NUM_HANDLES];

} HANDLES;

typedef struct _IIMEMMGR
{
	UINT		mmTileWidth;			// width of tile in bytes
	UINT		mmHeapWidth;			// width of heap
	UINT		mmHeapHeight;			// height of heap
	BOOL		mmDebugHeaps;			// debug flag

	PDEVMEM		pdmUsed;				// used list
	PDEVMEM		pdmFree;				// free list (unpacked)
	PDEVMEM 	pdmHeap;				// heap list (packed)
	PDEVMEM 	pdmHandles;				// handles list

	PHANDLES	phArray;				// array of handles
	
} IIMEMMGR, * PIIMEMMGR;

typedef struct _GXRECT
{
	UINT	left;
	UINT	top;
	UINT	right;
	UINT	bottom;
	ULONG	area;

} GXRECT, FAR* LPGXRECT;

typedef void (*FNMMCOPY)(PDEVMEM pdmNew, PDEVMEM pdmOld);
typedef UINT (*FNMMCALLBACK)(PDEVMEM pdm);
typedef BOOL (*FNMMHOSTIFY)(PDEVMEM pdm);

BOOL FAR mmInit(PIIMEMMGR pmm);

BOOL mmAllocArray(PIIMEMMGR pmm);
PDEVMEM mmAllocNode(PIIMEMMGR pmm);
void mmFreeNode(PIIMEMMGR pmm, PDEVMEM pdm);

PDEVMEM mmAlloc(PIIMEMMGR pmm, GXPOINT size, GXPOINT align);
PDEVMEM mmAllocGrid(PIIMEMMGR pmm, GXPOINT size, GXPOINT align, UINT count);
PDEVMEM mmAllocLargest(PIIMEMMGR pmm, GXPOINT align);
void mmFree(PIIMEMMGR pmm, PDEVMEM pdm);

void mmPack(PIIMEMMGR pmm);
PDEVMEM mmMove(PIIMEMMGR pmm, GXPOINT size, GXPOINT align, FNMMCOPY fnCopy);

void mmInsertInList(PDEVMEM FAR* pdmRoot, PDEVMEM pdm);
void mmRemoveFromList(PDEVMEM FAR* pdmRoot, PDEVMEM pdm);
BOOL FAR far_mmAddRectToList(PIIMEMMGR pmm, PDEVMEM FAR* pdmRoot,
							 LPGXRECT lpRect);
BOOL mmAddRectToList(PIIMEMMGR pmm, PDEVMEM FAR* pdmRoot, LPGXRECT lpRect,
					 BOOL fRollBack);
PDEVMEM mmRemoveRectFromList(PIIMEMMGR pmm, PDEVMEM FAR* pdmRoot,
							 LPGXRECT lpRect, REMOVE_METHOD fMethod);
void mmCombine(PIIMEMMGR pmm, PDEVMEM pdmRoot);
void mmRollBackAdd(PIIMEMMGR pmm, PDEVMEM FAR* pdmRoot, LPGXRECT lpRect,
				   LPGXRECT rectList, UINT nCount);
void mmRollBackRemove(PIIMEMMGR pmm, PDEVMEM FAR* pdmRoot,
					  PDEVMEM FAR* pdmList);

BOOL mmFindRect(PIIMEMMGR pmm, LPGXRECT lpRect, GXPOINT size, GXPOINT align);
UINT mmGetLeft(PIIMEMMGR pmm, PDEVMEM pdmNode, LPGXRECT lpRect, GXPOINT size,
			   GXPOINT align);
UINT mmGetRight(PIIMEMMGR pmm, PDEVMEM pdmNode, LPGXRECT lpRect, GXPOINT size,
				GXPOINT align);
UINT mmGetBottom(PIIMEMMGR pmm, PDEVMEM pdmNode, LPGXRECT lpRect, GXPOINT size,
				 GXPOINT align);
ULONG mmGetBest(PIIMEMMGR pmm, PDEVMEM pdmNode, LPGXRECT lpRect, GXPOINT size,
				GXPOINT align);
ULONG mmGetLargest(PDEVMEM pdmNode, LPGXRECT lpRect, GXPOINT align);
UINT mmAlignX(PIIMEMMGR pmm, UINT x, UINT size, UINT align, BOOL fLeft);

#ifdef WIN95
UINT mmFindClient(PIIMEMMGR pmm, PCLIENT pClient, FNMMCALLBACK fnCallback);
ULONG mmMultiply(UINT n1, UINT n2);
#endif

#if DEBUG_HEAP
	void mmBreak();
	void mmDumpList(PDEVMEM pdmRoot, LPCSTR lpszMessage);
	ULONG mmDebugList(PDEVMEM pdmRoot, BOOL fCheckSort);
	void mmDebug(LPCSTR lpszFormat, ...);
	#define mmTRACE(s) //Debug s
	#define mmASSERT(c,s) if (c) { mmDebug s; mmBreak(); }
#else
	#define mmBreak()
	#define mmDebugList(pdmRoot, fCheckSort)
	#define mmTRACE(s)
	#define mmASSERT(c,s)
#endif

#endif /* _MMCORE_H_ */

/******************************************************************************\
*																			   *
*							A S S E M B L Y   P A R T						   *
*																			   *
\******************************************************************************/
/*~ END COMMENT
MM_NUM_HANDLES		EQU			200

GXPOINT UNION
	STRUCT pt
		x			UINT		?
		y			UINT		?
	ENDS
GXPOINT ENDS

PDEVMEM				TYPEDEF		PTR DEVMEM
DEVMEM STRUCT
	ofm				OFMHDL		{}
	cbAddr			GXPOINT		{}
	cbSize			GXPOINT		{}
	cbAlign			GXPOINT		{}
	next			PDEVMEM		?
	prev			PDEVMEM		?
DEVMEM ENDS

PHANDLES			TYPEDEF		PTR HANDLES
HANDLES STRUCT
	pNext			PHANDLES	?
	dmArray			DEVMEM		MM_NUM_HANDLES DUP({})
HANDLES ENDS

IIMEMMGR STRUCT
	mmTileWidth		UINT		?
	mmHeapWidth		UINT		?
	mmHeapHeight	UINT		?
	mmDebugHeaps	BOOL		?

	pdmUsed			PDEVMEM		?
	pdmFree			PDEVMEM		?
	pdmHeap			PDEVMEM		?
	pdmHandles		PDEVMEM		?

	phArray			PHANDLES	?
IIMEMMGR ENDS

; end of polymorphic include file */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\laguna\mini\include\overlay.h ===
/**************************************************************************
***************************************************************************
*
*     Copyright (c) 1997, Cirrus Logic, Inc.
*                 All Rights Reserved
*
* FILE:         overlay.h
*
* DESCRIPTION:
*
* REVISION HISTORY:
*
* $Log:   X:/log/laguna/ddraw/inc/overlay.h  $
* 
*    Rev 1.13   Mar 26 1998 09:52:50   frido
* Fixed a hangup in overlays when switching from DOS and Overfly.
* 
*    Rev 1.12   06 Jan 1998 13:26:50   xcong
* Access pDriverData locally for multi-monitor support.
* 
*    Rev 1.11   18 Sep 1997 16:10:42   bennyn
* 
* Fixed NT 3.51 compile/link problem
* 
*    Rev 1.10   12 Sep 1997 12:12:48   bennyn
* 
* Modified for NT DD overlay support
* 
*    Rev 1.9   29 Aug 1997 16:11:52   RUSSL
* Added support for NT
*
*    Rev 1.8   28 Jul 1997 09:13:06   RUSSL
* Added arg passed to pfnGetFlipStatus
* Added GetVideoWidowIndex inline function
* Added dwNumVideoWindows global var
*
*    Rev 1.7   20 Jun 1997 11:24:54   RUSSL
* Added CLPL fourcc code, added a linear bit flag in surface flags, and
* changed OVERLAYTABLE pfnCreateSurface function to return an HRESULT
*
*    Rev 1.6   15 May 1997 10:50:58   RUSSL
* Changed OVERLAYTABLE pfnCanCreateSurface function to return an HRESULT
*
*    Rev 1.5   14 May 1997 14:51:30   KENTL
* Added #define for FLG_PANNING
*
*    Rev 1.4   13 May 1997 10:33:54   RUSSL
* Added gsOverlayFlip to global vars
*
*    Rev 1.3   21 Feb 1997 11:30:46   RUSSL
* Added FLG_YUY2 define
*
*    Rev 1.2   27 Jan 1997 18:33:54   RUSSL
* Removed SetCaps from OVERLAYTABLE structure
* Added Set5465FlipDuration function prototype
* Moved GetFormatInfo function prototype to surface.h
*
*    Rev 1.1   21 Jan 1997 14:35:42   RUSSL
* Added FLG_VWx defines, etc.
* Added 5465 function prototypes
*
*    Rev 1.0   15 Jan 1997 11:01:50   RUSSL
* Initial revision.
*
***************************************************************************
***************************************************************************/

// If WinNT 3.5 skip all the source code
#if defined WINNT_VER35      // WINNT_VER35

#else


#ifndef _OVERLAY_H_
#define _OVERLAY_H_

/***************************************************************************
* D E F I N E S
****************************************************************************/

/* surface flags -----------------------------------------*/

#define FLG_BEGIN_ACCESS      (DWORD)0x00000001
#define FLG_ENABLED           (DWORD)0x00000002
//#define FLG_CONVERT_PACKJR    (DWORD)0x00000004
#define FLG_MUST_RASTER       (DWORD)0x00000008
#define FLG_TWO_MEG           (DWORD)0x00000010
#define FLG_CHECK             (DWORD)0x00000020
#define FLG_COLOR_KEY         (DWORD)0x00000040
#define FLG_INTERPOLATE       (DWORD)0x00000080
#define FLG_OVERLAY           (DWORD)0x00000100
#define FLG_YUV422            (DWORD)0x00000200
//#define FLG_PACKJR            (DWORD)0x00000400
#define FLG_USE_OFFSET        (DWORD)0x00000800
#define FLG_YUVPLANAR         (DWORD)0x00001000
#define FLG_SRC_COLOR_KEY     (DWORD)0x00002000
#define FLG_DECIMATE          (DWORD)0x00004000
#define FLG_CAPTURE           (DWORD)0x00008000

#define FLG_VW0               (DWORD)0x00010000
#define FLG_VW1               (DWORD)0x00020000
#define FLG_VW2               (DWORD)0x00040000
#define FLG_VW3               (DWORD)0x00080000
#define FLG_VW4               (DWORD)0x00100000
#define FLG_VW5               (DWORD)0x00200000
#define FLG_VW6               (DWORD)0x00400000
#define FLG_VW7               (DWORD)0x00800000
#define	FLG_PANNING           (DWORD)0x01000000

#define FLG_VW_MASK           (DWORD)0x00FF0000
#define FLG_VW_SHIFT          16

#define FLG_UYVY              FLG_YUV422
#define FLG_YUY2              (DWORD)0x40000000
#define FLG_DECIMATE4         (DWORD)0x80000000
#define FLG_LINEAR            (DWORD)0x10000000

#define MIN_OLAY_WIDTH        4

#define FOURCC_YUVPLANAR      mmioFOURCC('C','L','P','L')

/***************************************************************************
* T Y P E D E F S
****************************************************************************/

#ifdef WINNT_VER40

#include <memmgr.h>

typedef struct _PDEV PDEV;

// Be sure to synchronize the following structures with the one
// in i386\Laguna.inc!
//
typedef struct tagOVERLAYTABLE
{
  HRESULT (*pfnCanCreateSurface)(PDEV*, DWORD, DWORD);
  HRESULT (*pfnCreateSurface)(PDEV*, PDD_SURFACE_LOCAL, DWORD);
  VOID    (*pfnDestroySurface)(PDEV*, PDD_DESTROYSURFACEDATA);
  DWORD   (*pfnLock)(PDEV*, PDD_LOCKDATA);
  VOID    (*pfnUnlock)(PDEV*, PDD_UNLOCKDATA);
  VOID    (*pfnSetColorKey)(PDEV*, PDD_SETCOLORKEYDATA);
  DWORD   (*pfnFlip)(PDEV*, PDD_FLIPDATA);
  DWORD   (*pfnUpdateOverlay)(PDEV*, PDD_UPDATEOVERLAYDATA);
  DWORD   (*pfnSetOverlayPos)(PDEV*, PDD_SETOVERLAYPOSITIONDATA);
  DWORD   (*pfnGetFlipStatus)(PDEV*, FLATPTR,DWORD);
} OVERLAYTABLE, *LPOVERLAYTABLE;

// Be sure to synchronize the following structures with the one
// in i386\Laguna.inc!
//
typedef struct
{
  FLATPTR  fpFlipFrom;
  LONGLONG liFlipTime;

  DWORD    dwFlipDuration;
  DWORD    dwFlipScanline;
  BOOL     bFlipFlag;
  BOOL     bHaveEverCrossedVBlank;
  BOOL     bWasEverInDisplay;
} OVERLAYFLIPRECORD;

#else
typedef struct tagOVERLAYTABLE
{
  HRESULT (*pfnCanCreateSurface)(GLOBALDATA *,DWORD, DWORD);
  HRESULT (*pfnCreateSurface)(LPDDRAWI_DIRECTDRAWSURFACE, DWORD, LPGLOBALDATA);
  VOID    (*pfnDestroySurface)(LPDDHAL_DESTROYSURFACEDATA);
  DWORD   (*pfnLock)(LPDDHAL_LOCKDATA);
  VOID    (*pfnUnlock)(LPDDHAL_UNLOCKDATA);
  VOID    (*pfnSetColorKey)(LPDDHAL_SETCOLORKEYDATA);
  DWORD   (*pfnFlip)(LPDDHAL_FLIPDATA);
  DWORD   (*pfnUpdateOverlay)(LPDDHAL_UPDATEOVERLAYDATA);
  DWORD   (*pfnSetOverlayPos)(LPDDHAL_SETOVERLAYPOSITIONDATA);
  DWORD   (*pfnGetFlipStatus)(LPGLOBALDATA,FLATPTR,DWORD);
} OVERLAYTABLE, *LPOVERLAYTABLE;

typedef struct
{
  FLATPTR  fpFlipFrom;
  __int64  liFlipTime;
  DWORD    dwFlipDuration;
  DWORD    dwFlipScanline;
  BOOL     bFlipFlag;
  BOOL     bHaveEverCrossedVBlank;
  BOOL     bWasEverInDisplay;
} OVERLAYFLIPRECORD;
#endif

#ifdef WINNT_VER40

#if DRIVER_5465 && defined(OVERLAY)
#define   DDOFM     SURFACE_DATA
#define   PDDOFM    LP_SURFACE_DATA
#endif

//this structure is used to store information per surface
typedef struct surface_data
{
  // This is the inclusion of DDOFM structure.
  // When OVERLAY is defined, DDOFM structure will be map to this structure
  struct surface_data   *prevhdl;
  struct surface_data   *nexthdl;
  POFMHDL         phdl;

   //
   // Note: Not all fields will get used/set for all types of surfaces!
   //
//   PMEMBLK  pMemblk;
//   VOID*    pLinearAddr;      // Linear address of memory block if linear
//                              // memory allocated via dmAllocLinear.
//   LPVOID   lpTextureData;
   LPVOID   lpCLPLData;
//   DWORD    dwFlags;
   DWORD    dwOverlayFlags;
//   WORD     wMemtype;         // Memory type (if we allocated surface).
//   DWORD    dwBitsPerPixel;
//   DWORD    dwBytesPerPixel;  // Rounded to nearest byte!
//   DWORD    dwBaseLinearAddr; // Linear address of memory heap.
//   DWORD    dwBasePhysAddr;   // Physical address of memory heap.
//   DWORD    dwBaseOffset;     // Offset of surface from base of memory heap.
   DWORD    dwOverlayOffset;   // Offset of overlay surface by clipping
#if DDRAW_COMPAT >= 50
   DWORD    dwAutoBaseAddr1;  //Auto flip Vport surface 1 address
   DWORD    dwAutoBaseAddr2;  //Auto flip Vport surface 2 address

   DDPIXELFORMAT ddpfAltPixelFormat;  // if pixel fmt is different than
                              // we lead DDraw to believe it is
#endif
}SURFACE_DATA, *LP_SURFACE_DATA;
#endif

/***************************************************************************
* G L O B A L   V A R I A B L E S
****************************************************************************/

#ifndef WINNT_VER40
extern OVERLAYTABLE       OverlayTable;
extern OVERLAYFLIPRECORD  gsOverlayFlip;
extern DWORD              dwNumVideoWindows;
#endif

/***************************************************************************
* I N L I N E   F U N C T I O N S
****************************************************************************/

/***************************************************************************
*
* FUNCTION:     GetVideoWindowIndex
*
* DESCRIPTION:
*
****************************************************************************/

static __inline DWORD
GetVideoWindowIndex ( DWORD dwOverlayFlags )
{
  DWORD   dwVWIndex;
  DWORD   dwTemp;


  // Isn't there a better way to count the number of zeros to the right of
  // the FLG_VWx bit?
  dwTemp = (dwOverlayFlags & FLG_VW_MASK) >> FLG_VW_SHIFT;
  dwVWIndex = 0;
  if (dwTemp != 0)	// Only do the next loop if there is any bit set.
  while (0 == (dwTemp & 0x00000001))
  {
    dwTemp >>= 1;
    dwVWIndex++;
  }
  // if the video window index is larger than or equal to the number of video
  // windows implemented in the hardware, then this surface was assigned an
  // invalid video window!
//  ASSERT(dwNumVideoWindows > dwVWIndex);

  return dwVWIndex;
}

/***************************************************************************
* F U N C T I O N   P R O T O T Y P E S
****************************************************************************/

#ifdef WINNT_VER40
DWORD __stdcall UpdateOverlay32      ( PDD_UPDATEOVERLAYDATA );
DWORD __stdcall SetOverlayPosition32 ( PDD_SETOVERLAYPOSITIONDATA );
DWORD __stdcall SetColorKey32        ( PDD_SETCOLORKEYDATA );

BOOL QueryOverlaySupport ( PDEV*, DWORD );
VOID OverlayInit         ( PDEV*, DWORD, PDD_SURFACECALLBACKS, PDD_HALINFO );
VOID OverlayReInit       ( PDEV*, DWORD, PDD_HALINFO );

// 5465 function prototypes
VOID Init5465Overlay     ( PDEV*, DWORD, PDD_HALINFO, LPOVERLAYTABLE );
VOID Init5465Info        ( PDEV*, PDD_HALINFO );
VOID Set5465FlipDuration ( PDEV*, DWORD );
#else
DWORD __stdcall UpdateOverlay32      ( LPDDHAL_UPDATEOVERLAYDATA );
DWORD __stdcall SetOverlayPosition32 ( LPDDHAL_SETOVERLAYPOSITIONDATA );
DWORD __stdcall SetColorKey32        ( LPDDHAL_SETCOLORKEYDATA );

BOOL QueryOverlaySupport ( LPGLOBALDATA, DWORD);
VOID OverlayInit         ( DWORD, LPDDHAL_DDSURFACECALLBACKS, LPDDHALINFO, GLOBALDATA * );
VOID OverlayReInit       ( DWORD, LPDDHALINFO ,GLOBALDATA * );

// 5465 function prototypes
VOID Init5465Overlay     ( DWORD, LPDDHALINFO, LPOVERLAYTABLE, GLOBALDATA * );
VOID Init5465Info        ( LPDDHALINFO, GLOBALDATA * );
VOID Set5465FlipDuration ( DWORD );
#endif

#endif /* _OVERLAY_H_ */
#endif // WINNT_VER35
/* Don't write below this endif */


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\mirror\disp\debug.c ===
/******************************Module*Header*******************************\
*
*                           *******************
*                           * GDI SAMPLE CODE *
*                           *******************
*
* Module Name: debug.c
*
* debug helpers routine
*
* Copyright (c) 1992-1998 Microsoft Corporation
*
\**************************************************************************/

#include "driver.h"

#if DBG

ULONG DebugLevel = 0;

/*****************************************************************************
 *
 *   Routine Description:
 *
 *      This function is variable-argument, level-sensitive debug print
 *      routine.
 *      If the specified debug level for the print statement is lower or equal
 *      to the current debug level, the message will be printed.
 *
 *   Arguments:
 *
 *      DebugPrintLevel - Specifies at which debugging level the string should
 *          be printed
 *
 *      DebugMessage - Variable argument ascii c string
 *
 *   Return Value:
 *
 *      None.
 *
 ***************************************************************************/

VOID
DebugPrint(
    ULONG DebugPrintLevel,
    PCHAR DebugMessage,
    ...
    )

{

    va_list ap;

    va_start(ap, DebugMessage);

    if (DebugPrintLevel <= DebugLevel)
    {
        EngDebugPrint("", DebugMessage, ap);
    }

    va_end(ap);

}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\mirror\disp\driver.h ===
/******************************Module*Header*******************************\
*
*                           *******************
*                           * GDI SAMPLE CODE *
*                           *******************
*
* Module Name: driver.h
*
* contains prototypes for the frame buffer driver.
*
* Copyright (c) 1992-1998 Microsoft Corporation
\**************************************************************************/

#define DBG 1

#include "stddef.h"

#include <stdarg.h>

#include "windef.h"
#include "wingdi.h"
#include "winddi.h"
#include "devioctl.h"
#include "ntddvdeo.h"
#include "debug.h"

typedef struct  _PDEV
{
    HANDLE  hDriver;                    // Handle to \Device\Screen
    HDEV    hdevEng;                    // Engine's handle to PDEV
    HSURF   hsurfEng;                   // Engine's handle to surface
    HPALETTE hpalDefault;               // Handle to the default palette for device.
    PBYTE   pjScreen;                   // This is pointer to base screen address
    ULONG   cxScreen;                   // Visible screen width
    ULONG   cyScreen;                   // Visible screen height
    POINTL  ptlOrg;                     // Where this display is anchored in
                                        //   the virtual desktop.
    ULONG   ulMode;                     // Mode the mini-port driver is in.
    LONG    lDeltaScreen;               // Distance from one scan to the next.
    ULONG   cScreenSize;                // size of video memory, including
                                        // offscreen memory.
    PVOID   pOffscreenList;             // linked list of DCI offscreen surfaces.
    FLONG   flRed;                      // For bitfields device, Red Mask
    FLONG   flGreen;                    // For bitfields device, Green Mask
    FLONG   flBlue;                     // For bitfields device, Blue Mask
    ULONG   cPaletteShift;              // number of bits the 8-8-8 palette must
                                        // be shifted by to fit in the hardware
                                        // palette.
    ULONG   ulBitCount;                 // # of bits per pel 8,16,24,32 are only supported.
    POINTL  ptlHotSpot;                 // adjustment for pointer hot spot
    VIDEO_POINTER_CAPABILITIES PointerCapabilities; // HW pointer abilities
    PVIDEO_POINTER_ATTRIBUTES pPointerAttributes; // hardware pointer attributes
    DWORD   cjPointerAttributes;        // Size of buffer allocated
    BOOL    fHwCursorActive;            // Are we currently using the hw cursor
    PALETTEENTRY *pPal;                 // If this is pal managed, this is the pal
    BOOL    bSupportDCI;                // Does the miniport support DCI?

    PVOID   pvTmpBuffer;                // ptr to MIRRSURF bits for screen surface
} PDEV, *PPDEV;

typedef struct _MIRRSURF {
    PPDEV   *pdev;
    ULONG   cx;               
    ULONG   cy;
    ULONG   lDelta;
    ULONG   ulBitCount;
    BOOL    bIsScreen;

} MIRRSURF, *PMIRRSURF;

DWORD getAvailableModes(HANDLE, PVIDEO_MODE_INFORMATION *, DWORD *);
BOOL bInitPDEV(PPDEV, PDEVMODEW, GDIINFO *, DEVINFO *);
BOOL bInitSURF(PPDEV, BOOL);
BOOL bInitPaletteInfo(PPDEV, DEVINFO *);
BOOL bInitPointer(PPDEV, DEVINFO *);
BOOL bInit256ColorPalette(PPDEV);
VOID vDisablePalette(PPDEV);
VOID vDisableSURF(PPDEV);

#define MAX_CLUT_SIZE (sizeof(VIDEO_CLUT) + (sizeof(ULONG) * 256))

//
// Determines the size of the DriverExtra information in the DEVMODE
// structure passed to and from the display driver.
//

#define DRIVER_EXTRA_SIZE 0

#define DLL_NAME                L"framebuf"   // Name of the DLL in UNICODE
#define STANDARD_DEBUG_PREFIX   "FRAMEBUF: "  // All debug output is prefixed
#define ALLOC_TAG               'bfDD'        // Four byte tag (characters in
                                              // reverse order) used for memory
                                              // allocations
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\mirror\disp\screen.c ===
/******************************Module*Header*******************************\
*
*                           *******************
*                           * GDI SAMPLE CODE *
*                           *******************
*
* Module Name: screen.c
*
* Initializes the GDIINFO and DEVINFO structures for DrvEnablePDEV.
*
* Copyright (c) 1992-1998 Microsoft Corporation
\**************************************************************************/

#include "driver.h"

#define SYSTM_LOGFONT {16,7,0,0,700,0,0,0,ANSI_CHARSET,OUT_DEFAULT_PRECIS,CLIP_DEFAULT_PRECIS,DEFAULT_QUALITY,VARIABLE_PITCH | FF_DONTCARE,L"System"}
#define HELVE_LOGFONT {12,9,0,0,400,0,0,0,ANSI_CHARSET,OUT_DEFAULT_PRECIS,CLIP_STROKE_PRECIS,PROOF_QUALITY,VARIABLE_PITCH | FF_DONTCARE,L"MS Sans Serif"}
#define COURI_LOGFONT {12,9,0,0,400,0,0,0,ANSI_CHARSET,OUT_DEFAULT_PRECIS,CLIP_STROKE_PRECIS,PROOF_QUALITY,FIXED_PITCH | FF_DONTCARE, L"Courier"}

// This is the basic devinfo for a default driver.  This is used as a base and customized based
// on information passed back from the miniport driver.

const DEVINFO gDevInfoFrameBuffer = {
    ( GCAPS_OPAQUERECT
    | GCAPS_LAYERED
                   ), /* Graphics capabilities         */
    SYSTM_LOGFONT,    /* Default font description */
    HELVE_LOGFONT,    /* ANSI variable font description   */
    COURI_LOGFONT,    /* ANSI fixed font description          */
    0,                /* Count of device fonts          */
    0,                /* Preferred DIB format          */
    8,                /* Width of color dither          */
    8,                /* Height of color dither   */
    0                 /* Default palette to use for this device */
};

// This is default palette from Win 3.1

#define NUMPALCOLORS 256
#define NUMPALRESERVED 20

ULONG palColors[NUMPALCOLORS][4] =
{
    { 0,   0,   0,   0  },  // 0
    { 0x80,0,   0,   0  },  // 1
    { 0,   0x80,0,   0  },  // 2
    { 0x80,0x80,0,   0  },  // 3
    { 0,   0,   0x80,0  },  // 4
    { 0x80,0,   0x80,0  },  // 5
    { 0,   0x80,0x80,0  },  // 6
    { 0xC0,0xC0,0xC0,0  },  // 7

    { 192, 220, 192, 0  },  // 8
    { 166, 202, 240, 0  },  // 9
    { 255, 251, 240, 0  },  // 10
    { 160, 160, 164, 0  },  // 11

    { 0x80,0x80,0x80,0  },  // 12
    { 0xFF,0,   0,   0  },  // 13
    { 0,   0xFF,0,   0  },  // 14
    { 0xFF,0xFF,0,   0  },  // 15
    { 0,   0,   0xFF,0  },  // 16
    { 0xFF,0,   0xFF,0  },  // 17
    { 0,   0xFF,0xFF,0  },  // 18
    { 0xFF,0xFF,0xFF,0  }   // 19
};

/******************************Public*Routine******************************\
* bInitPDEV
*
* Determine the mode we should be in based on the DEVMODE passed in.
* For mirrored devices we don't bother querying the miniport.
*
\**************************************************************************/

BOOL bInitPDEV(
PPDEV ppdev,
DEVMODEW *pDevMode,
GDIINFO *pGdiInfo,
DEVINFO *pDevInfo)
{
    ULONG cModes;
    PVIDEO_MODE_INFORMATION pVideoBuffer, pVideoModeSelected, pVideoTemp;
    VIDEO_COLOR_CAPABILITIES colorCapabilities;
    ULONG ulTemp;
    BOOL bSelectDefault;
    ULONG cbModeSize;
    ULONG red, green, blue;
    INT i;

    //
    // Fill in the GDIINFO data structure with the information returned from
    // the kernel driver.
    //
    
    ppdev->ulMode = 0;
    ppdev->cxScreen = pDevMode->dmPelsWidth;
    ppdev->cyScreen = pDevMode->dmPelsHeight;
    ppdev->ulBitCount = pDevMode->dmBitsPerPel;
    ppdev->lDeltaScreen = 0;
    
    ppdev->flRed = 0x00FF0000;
    ppdev->flGreen = 0x000FF00;
    ppdev->flBlue = 0x00000FF;
    
    pGdiInfo->ulVersion    = GDI_DRIVER_VERSION;
    pGdiInfo->ulTechnology = DT_RASDISPLAY;
    pGdiInfo->ulHorzSize   = 0;
    pGdiInfo->ulVertSize   = 0;

    pGdiInfo->ulHorzRes        = ppdev->cxScreen;
    pGdiInfo->ulVertRes        = ppdev->cyScreen;
    pGdiInfo->ulPanningHorzRes = 0;
    pGdiInfo->ulPanningVertRes = 0;
    pGdiInfo->cBitsPixel       = 8;
    pGdiInfo->cPlanes          = 1; 
    pGdiInfo->ulVRefresh       = 1;       // not used
    pGdiInfo->ulBltAlignment   = 1;     // We don't have accelerated screen-
                                        //   to-screen blts, and any
                                        //   window alignment is okay

    pGdiInfo->ulLogPixelsX = pDevMode->dmLogPixels;
    pGdiInfo->ulLogPixelsY = pDevMode->dmLogPixels;

    pGdiInfo->flTextCaps = TC_RA_ABLE;

    pGdiInfo->flRaster = 0;           // flRaster is reserved by DDI

    pGdiInfo->ulDACRed   = 8;
    pGdiInfo->ulDACGreen = 8;
    pGdiInfo->ulDACBlue  = 8;

    pGdiInfo->ulAspectX    = 0x24;    // One-to-one aspect ratio
    pGdiInfo->ulAspectY    = 0x24;
    pGdiInfo->ulAspectXY   = 0x33;

    pGdiInfo->xStyleStep   = 1;       // A style unit is 3 pels
    pGdiInfo->yStyleStep   = 1;
    pGdiInfo->denStyleStep = 3;

    pGdiInfo->ptlPhysOffset.x = 0;
    pGdiInfo->ptlPhysOffset.y = 0;
    pGdiInfo->szlPhysSize.cx  = 0;
    pGdiInfo->szlPhysSize.cy  = 0;

    // RGB and CMY color info.

    pGdiInfo->ciDevice.Red.x = 6700;
    pGdiInfo->ciDevice.Red.y = 3300;
    pGdiInfo->ciDevice.Red.Y = 0;
    pGdiInfo->ciDevice.Green.x = 2100;
    pGdiInfo->ciDevice.Green.y = 7100;
    pGdiInfo->ciDevice.Green.Y = 0;
    pGdiInfo->ciDevice.Blue.x = 1400;
    pGdiInfo->ciDevice.Blue.y = 800;
    pGdiInfo->ciDevice.Blue.Y = 0;
    pGdiInfo->ciDevice.AlignmentWhite.x = 3127;
    pGdiInfo->ciDevice.AlignmentWhite.y = 3290;
    pGdiInfo->ciDevice.AlignmentWhite.Y = 0;

    pGdiInfo->ciDevice.RedGamma = 20000;
    pGdiInfo->ciDevice.GreenGamma = 20000;
    pGdiInfo->ciDevice.BlueGamma = 20000;

    pGdiInfo->ciDevice.Cyan.x = 0;
    pGdiInfo->ciDevice.Cyan.y = 0;
    pGdiInfo->ciDevice.Cyan.Y = 0;
    pGdiInfo->ciDevice.Magenta.x = 0;
    pGdiInfo->ciDevice.Magenta.y = 0;
    pGdiInfo->ciDevice.Magenta.Y = 0;
    pGdiInfo->ciDevice.Yellow.x = 0;
    pGdiInfo->ciDevice.Yellow.y = 0;
    pGdiInfo->ciDevice.Yellow.Y = 0;

    // No dye correction for raster displays.

    pGdiInfo->ciDevice.MagentaInCyanDye = 0;
    pGdiInfo->ciDevice.YellowInCyanDye = 0;
    pGdiInfo->ciDevice.CyanInMagentaDye = 0;
    pGdiInfo->ciDevice.YellowInMagentaDye = 0;
    pGdiInfo->ciDevice.CyanInYellowDye = 0;
    pGdiInfo->ciDevice.MagentaInYellowDye = 0;

    pGdiInfo->ulDevicePelsDPI = 0;   // For printers only
    pGdiInfo->ulPrimaryOrder = PRIMARY_ORDER_CBA;

    // Note: this should be modified later to take into account the size
    // of the display and the resolution.

    pGdiInfo->ulHTPatternSize = HT_PATSIZE_4x4_M;

    pGdiInfo->flHTFlags = HT_FLAG_ADDITIVE_PRIMS;

    // Fill in the basic devinfo structure

    *pDevInfo = gDevInfoFrameBuffer;

    // Fill in the rest of the devinfo and GdiInfo structures.

    if (ppdev->ulBitCount == 8)
    {
        // It is Palette Managed.

        pGdiInfo->ulNumColors = 20;
        pGdiInfo->ulNumPalReg = 1 << ppdev->ulBitCount;

        pDevInfo->flGraphicsCaps |= (GCAPS_PALMANAGED | GCAPS_COLOR_DITHER);

        pGdiInfo->ulHTOutputFormat = HT_FORMAT_8BPP;
        pDevInfo->iDitherFormat = BMF_8BPP;

        // Assuming palette is orthogonal - all colors are same size.

        ppdev->cPaletteShift   = 8 - pGdiInfo->ulDACRed;
    }
    else
    {
        pGdiInfo->ulNumColors = (ULONG) (-1);
        pGdiInfo->ulNumPalReg = 0;

        if (ppdev->ulBitCount == 16)
        {
            pGdiInfo->ulHTOutputFormat = HT_FORMAT_16BPP;
            pDevInfo->iDitherFormat = BMF_16BPP;
        }
        else if (ppdev->ulBitCount == 24)
        {
            pGdiInfo->ulHTOutputFormat = HT_FORMAT_24BPP;
            pDevInfo->iDitherFormat = BMF_24BPP;
        }
        else
        {
            pGdiInfo->ulHTOutputFormat = HT_FORMAT_32BPP;
            pDevInfo->iDitherFormat = BMF_32BPP;
        }
    }

    // create remaining palette entries, simple loop to create uniformly
    // distributed color values.

    red = 0, green = 0, blue = 0;
    
    for (i = NUMPALRESERVED; i < NUMPALCOLORS; i++) {
        palColors[i][0] = red;
        palColors[i][1] = green;
        palColors[i][2] = blue;
        palColors[i][3] = 0;

        if (!(red += 32))
            if (!(green += 32))
                blue += 64;
    }

    if (ppdev->ulBitCount == 8)
    {
    pDevInfo->hpalDefault = ppdev->hpalDefault =
       
                  EngCreatePalette(PAL_INDEXED,
                                   NUMPALCOLORS,     // cColors
                                   (ULONG*)&palColors[0],       // pulColors
                                   0,
                                   0,
                                   0);         // flRed, flGreen, flBlue [not used]
    }
    else
    {
        pDevInfo->hpalDefault = ppdev->hpalDefault =
                EngCreatePalette(PAL_BITFIELDS, 0,NULL,
                                 ppdev->flRed,ppdev->flBlue,ppdev->flGreen);
    }

    
    
    return(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\mirror\app\main.cxx ===
//
// Generic Windows program template
//

#include <stdio.h>
#include <stdlib.h>
#include <stdarg.h>
#include <windows.h>

#include <winddi.h>
#include <tchar.h>
#include <winbase.h>
#include <winreg.h>

CHAR* programName;      // program name
HINSTANCE appInstance;  // handle to the application instance

LPSTR driverName = "Microsoft Mirror Driver";

LPSTR dispCode[7] = {
   "Change Successful",
   "Must Restart",
   "Bad Flags",
   "Bad Parameters",
   "Failed",
   "Bad Mode",
   "Not Updated"};

LPSTR GetDispCode(INT code)
{
   switch (code) {
   
   case DISP_CHANGE_SUCCESSFUL: return dispCode[0];
   
   case DISP_CHANGE_RESTART: return dispCode[1];
   
   case DISP_CHANGE_BADFLAGS: return dispCode[2];
   
   case DISP_CHANGE_BADPARAM: return dispCode[3];
   
   case DISP_CHANGE_FAILED: return dispCode[4];
   
   case DISP_CHANGE_BADMODE: return dispCode[5];
   
   case DISP_CHANGE_NOTUPDATED: return dispCode[6];
   
   default:
      static char tmp[MAX_PATH];
      sprintf(&tmp[0],"Unknown code: %08x\n", code);
      return (LPTSTR)&tmp[0];
   
   }
   
   return NULL;   // can't happen
}

//
// Handle window repaint event
//

VOID
DoPaint(
    HWND hwnd
    )

{
    HDC hdc;
    PAINTSTRUCT ps;
    
    hdc = BeginPaint(hwnd, &ps);

    COLORREF red = 0x00FF0000;

    HBRUSH hbr = CreateSolidBrush(red);

    RECT r;
    r.left = ps.rcPaint.left;
    r.top = ps.rcPaint.top;
    r.right = ps.rcPaint.right;
    r.bottom = ps.rcPaint.bottom;

    FillRect(hdc, &r, hbr);

    EndPaint(hwnd, &ps);
}


//
// Window callback procedure
//

LRESULT CALLBACK
MyWindowProc(
    HWND    hwnd,
    UINT    uMsg,
    WPARAM  wParam,
    LPARAM  lParam
    )

{
    switch (uMsg)
    {
    case WM_PAINT:
        DoPaint(hwnd);
        break;

    case WM_DISPLAYCHANGE:
       {
        WORD cxScreen = LOWORD(lParam);
        WORD cyScreen = HIWORD(lParam);
        WPARAM format = wParam;
        
        // Add hook to re-initialize the mirror driver's surface

       }
       break;

    case WM_DESTROY:
        PostQuitMessage(0);
        break;

    default:
        return DefWindowProc(hwnd, uMsg, wParam, lParam);
    }

    return 0;
}


//
// Create main application window
//

VOID
CreateMyWindow(
   //********************************************************************
    PCSTR title
    )

#define MYWNDCLASSNAME "Mirror Sample"

{
   //********************************************************************

    //
    // Register window class if necessary
    //

    static BOOL wndclassRegistered = FALSE;

    if (!wndclassRegistered)
    {
        WNDCLASS wndClass =
        {
            0,
            MyWindowProc,
            0,
            0,
            appInstance,
            NULL,
            NULL,
            NULL,
            NULL,
            MYWNDCLASSNAME
        };

        RegisterClass(&wndClass);
        wndclassRegistered = TRUE;
    }

    HWND hwnd;
    INT width = 300, height = 300;

    //********************************************************************

    hwnd = CreateWindow(
                    MYWNDCLASSNAME,
                    title,
                    WS_OVERLAPPED | WS_SYSMENU | WS_VISIBLE,
                    CW_USEDEFAULT,
                    CW_USEDEFAULT,
                    width,
                    height,
                    NULL,
                    NULL,
                    appInstance,
                    NULL);

    if (hwnd == NULL)
    {
       printf("Can't create main window.\n");
       exit(-1);
    }

}


//
// Main program entrypoint
//

VOID _cdecl
main(
    INT argc,
    CHAR **argv
    )

{
    programName = *argv++;
    argc--;
    appInstance = GetModuleHandle(NULL);

    //
    // Create the main application window
    //
    //********************************************************************

    DEVMODE devmode;

    FillMemory(&devmode, sizeof(DEVMODE), 0);

    devmode.dmSize = sizeof(DEVMODE);
    devmode.dmDriverExtra = 0;

    BOOL change = EnumDisplaySettings(NULL,
                                      ENUM_CURRENT_SETTINGS,
                                      &devmode);

    devmode.dmFields = DM_BITSPERPEL |
                       DM_PELSWIDTH | 
                       DM_PELSHEIGHT;

    if (change) 
    {
        // query all display devices in the system until we hit
        // our favourate mirrored driver, then extract the device name string
        // of the format '\\.\DISPLAY#'
       
        DISPLAY_DEVICE dispDevice;
       
        FillMemory(&dispDevice, sizeof(DISPLAY_DEVICE), 0);
       
        dispDevice.cb = sizeof(DISPLAY_DEVICE);
       
        LPSTR deviceName = NULL;

        devmode.dmDeviceName[0] = '\0';

        INT devNum = 0;
        BOOL result;

        while (result = EnumDisplayDevices(NULL,
                                  devNum,
                                  &dispDevice,
                                  0))
        {
          if (strcmp(&dispDevice.DeviceString[0], driverName) == 0)
              break;

           devNum++;
        }
       
        if (!result)
        {
           printf("No '%s' found.\n", driverName);
           exit(0);
        }

        printf("DevNum:%d\nName:%s\nString:%s\nID:%s\nKey:%s\n\n",
               devNum,
               &dispDevice.DeviceName[0],
               &dispDevice.DeviceString[0],
               &dispDevice.DeviceID[0],
               &dispDevice.DeviceKey[0]);

        CHAR deviceNum[MAX_PATH];
        LPSTR deviceSub;

        // Simply extract 'DEVICE#' from registry key.  This will depend
        // on how many mirrored devices your driver has and which ones
        // you intend to use.

        _strupr(&dispDevice.DeviceKey[0]);

        deviceSub = strstr(&dispDevice.DeviceKey[0],
                           "\\DEVICE");

        if (!deviceSub) 
            strcpy(&deviceNum[0], "DEVICE0");
        else
            strcpy(&deviceNum[0], ++deviceSub);
        
        // Add 'Attach.ToDesktop' setting.
        //

        HKEY hKeyProfileMirror = (HKEY)0;
        if (RegCreateKey(HKEY_LOCAL_MACHINE,
                        _T("SYSTEM\\CurrentControlSet\\Hardware Profiles\\Current\\System\\CurrentControlSet\\Services\\mirror"),
                         &hKeyProfileMirror) != ERROR_SUCCESS)
        {
           printf("Can't access registry.\n");
           return;
        }

        HKEY hKeyDevice = (HKEY)0;
        if (RegCreateKey(hKeyProfileMirror,
                         _T(&deviceNum[0]),
                         &hKeyDevice) != ERROR_SUCCESS)
        {
           printf("Can't access DEVICE# hardware profiles key.\n");
           return;
        }

        DWORD one = 1;
        if (RegSetValueEx(hKeyDevice,
                          _T("Attach.ToDesktop"),
                          0,
                          REG_DWORD,
                          (unsigned char *)&one,
                          4) != ERROR_SUCCESS)
        {
           printf("Can't set Attach.ToDesktop to 0x1\n");
           return;
        }

        strcpy((LPSTR)&devmode.dmDeviceName[0], "mirror");
        deviceName = (LPSTR)&dispDevice.DeviceName[0];

        // add 'Default.*' settings to the registry under above hKeyProfile\mirror\device
        INT code =
        ChangeDisplaySettingsEx(deviceName,
                                &devmode, 
                                NULL,
                                CDS_UPDATEREGISTRY,
                                NULL
                                );
    
        printf("Update Register on device mode: %s\n", GetDispCode(code));

        code = ChangeDisplaySettingsEx(deviceName,
                                &devmode, 
                                NULL,
                                0,
                                NULL
                                );
   
        printf("Raw dynamic mode change on device mode: %s\n", GetDispCode(code));

        HDC hdc = CreateDC("DISPLAY",
                           deviceName,
                           NULL,
                           NULL);

        // we should be hooked as layered at this point
        HDC hdc2 = CreateCompatibleDC(hdc);

        // call DrvCreateDeviceBitmap
        HBITMAP hbm = CreateCompatibleBitmap(hdc, 100, 100);

        SelectObject(hdc2, hbm);
        
        BitBlt(hdc2, 0, 0, 50, 50, hdc, 0, 0, SRCCOPY);

        // delete the device context
        DeleteDC(hdc2);
        DeleteDC(hdc);
        // 
        // CreateMyWindow("Mirror Sample");
        // ^^^^ Use this to test catching window initializiation messages.
        //

        // Disable attachment to desktop so we aren't attached on
        // the next bootup.  Our test app is done!

        DWORD zero = 0;
        if (RegSetValueEx(hKeyDevice,
                          _T("Attach.ToDesktop"),
                          0,
                          REG_DWORD,
                          (unsigned char *)&zero,
                          4) != ERROR_SUCCESS)
        {
           printf("Can't set Attach.ToDesktop to 0x0\n");
           return;
        }

        RegCloseKey(hKeyProfileMirror);
        RegCloseKey(hKeyDevice);

        printf("Performed bit blit.  Finished. \n");
        return;
    }
    else
    {
        printf("Can't get display settings.\n");
    }

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\mirror\disp\debug.h ===
/***************************************************************************\
*
*                           *******************
*                           * GDI SAMPLE CODE *
*                           *******************
*
* Module Name: debug.h
*
* Commonly used debugging macros.
*
* Copyright (c) 1992-1998 Microsoft Corporation
\***************************************************************************/


#if DBG

VOID
DebugPrint(
    ULONG DebugPrintLevel,
    PCHAR DebugMessage,
    ...
    );

#define DISPDBG(arg) DebugPrint arg
#define RIP(x) { DebugPrint(0, x); EngDebugBreak();}

#else

#define DISPDBG(arg)
#define RIP(x)

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\mirror\disp\enable.c ===
/******************************Module*Header*******************************\
*
*                           *******************
*                           * GDI SAMPLE CODE *
*                           *******************
*
* Module Name: enable.c
*
* This module contains the functions that enable and disable the
* driver, the pdev, and the surface.
*
* Copyright (c) 1992-1998 Microsoft Corporation
\**************************************************************************/
#define DBG 1

#include "driver.h"

// The driver function table with all function index/address pairs

static DRVFN gadrvfn[] =
{
    {   INDEX_DrvEnablePDEV,            (PFN) DrvEnablePDEV         },
    {   INDEX_DrvCompletePDEV,          (PFN) DrvCompletePDEV       },
    {   INDEX_DrvDisablePDEV,           (PFN) DrvDisablePDEV        },
    {   INDEX_DrvEnableSurface,         (PFN) DrvEnableSurface      },
    {   INDEX_DrvDisableSurface,        (PFN) DrvDisableSurface     },
    {   INDEX_DrvAssertMode,            (PFN) DrvAssertMode         },
#if 0
    // Windows 2000 Beta 3 has a bug in GDI that causes a crash 
    // if a mirror driver supports device bitmaps.  A fix will be
    // in Windows 2000 RC0.
    {   INDEX_DrvCreateDeviceBitmap,    (PFN) DrvCreateDeviceBitmap },
    {   INDEX_DrvDeleteDeviceBitmap,    (PFN) DrvDeleteDeviceBitmap },
#endif
    {   INDEX_DrvTextOut,               (PFN) DrvTextOut            },
    {   INDEX_DrvBitBlt,                (PFN) DrvBitBlt             },
    {   INDEX_DrvCopyBits,              (PFN) DrvCopyBits           },
    {   INDEX_DrvStrokePath,            (PFN) DrvStrokePath         },
};

//
// always hook these routines to ensure the mirrored driver
// is called for our surfaces
//

#define flGlobalHooks   HOOK_BITBLT|HOOK_TEXTOUT|HOOK_COPYBITS|HOOK_STROKEPATH

// Define the functions you want to hook for 8/16/24/32 pel formats

#define HOOKS_BMF8BPP 0

#define HOOKS_BMF16BPP 0

#define HOOKS_BMF24BPP 0

#define HOOKS_BMF32BPP 0

/******************************Public*Routine******************************\
* DrvEnableDriver
*
* Enables the driver by retrieving the drivers function table and version.
*
\**************************************************************************/

BOOL DrvEnableDriver(
ULONG iEngineVersion,
ULONG cj,
PDRVENABLEDATA pded)
{
// Engine Version is passed down so future drivers can support previous
// engine versions.  A next generation driver can support both the old
// and new engine conventions if told what version of engine it is
// working with.  For the first version the driver does nothing with it.

    iEngineVersion;

    DISPDBG((0,"DrvEnableDriver:\n"));

// Fill in as much as we can.

    if (cj >= sizeof(DRVENABLEDATA))
        pded->pdrvfn = gadrvfn;

    if (cj >= (sizeof(ULONG) * 2))
        pded->c = sizeof(gadrvfn) / sizeof(DRVFN);

// DDI version this driver was targeted for is passed back to engine.
// Future graphic's engine may break calls down to old driver format.

    if (cj >= sizeof(ULONG))
	// DDI_DRIVER_VERSION is now out-dated. See winddi.h
	// DDI_DRIVER_VERSION_NT4 is equivalent to the old DDI_DRIVER_VERSION
        pded->iDriverVersion = DDI_DRIVER_VERSION_NT4;

    return(TRUE);
}

/******************************Public*Routine******************************\
* DrvEnablePDEV
*
* DDI function, Enables the Physical Device.
*
* Return Value: device handle to pdev.
*
\**************************************************************************/

DHPDEV DrvEnablePDEV(
DEVMODEW   *pDevmode,       // Pointer to DEVMODE
PWSTR       pwszLogAddress, // Logical address
ULONG       cPatterns,      // number of patterns
HSURF      *ahsurfPatterns, // return standard patterns
ULONG       cjGdiInfo,      // Length of memory pointed to by pGdiInfo
ULONG      *pGdiInfo,       // Pointer to GdiInfo structure
ULONG       cjDevInfo,      // Length of following PDEVINFO structure
DEVINFO    *pDevInfo,       // physical device information structure
HDEV        hdev,           // HDEV, used for callbacks
PWSTR       pwszDeviceName, // DeviceName - not used
HANDLE      hDriver)        // Handle to base driver
{
    GDIINFO GdiInfo;
    DEVINFO DevInfo;
    PPDEV   ppdev = (PPDEV) NULL;

    DISPDBG((0,"DrvEnablePDEV:\n"));

    UNREFERENCED_PARAMETER(pwszLogAddress);
    UNREFERENCED_PARAMETER(pwszDeviceName);

    // Allocate a physical device structure.

    ppdev = (PPDEV) EngAllocMem(0, sizeof(PDEV), ALLOC_TAG);

    if (ppdev == (PPDEV) NULL)
    {
        RIP("DISP DrvEnablePDEV failed EngAllocMem\n");
        return((DHPDEV) 0);
    }

    memset(ppdev, 0, sizeof(PDEV));

    // Save the screen handle in the PDEV.

    ppdev->hDriver = hDriver;

    // Get the current screen mode information.  Set up device caps and devinfo.

    if (!bInitPDEV(ppdev, pDevmode, &GdiInfo, &DevInfo))
    {
        DISPDBG((0,"DISP DrvEnablePDEV failed\n"));
        goto error_free;
    }
    
    // Copy the devinfo into the engine buffer.

    memcpy(pDevInfo, &DevInfo, min(sizeof(DEVINFO), cjDevInfo));

    // Set the pdevCaps with GdiInfo we have prepared to the list of caps for this
    // pdev.

    memcpy(pGdiInfo, &GdiInfo, min(cjGdiInfo, sizeof(GDIINFO)));

    //
    return((DHPDEV) ppdev);

    // Error case for failure.
error_free:
    EngFreeMem(ppdev);
    return((DHPDEV) 0);
}

/******************************Public*Routine******************************\
* DrvCompletePDEV
*
* Store the HPDEV, the engines handle for this PDEV, in the DHPDEV.
*
\**************************************************************************/

VOID DrvCompletePDEV(
DHPDEV dhpdev,
HDEV  hdev)
{
    ((PPDEV) dhpdev)->hdevEng = hdev;
}

/******************************Public*Routine******************************\
* DrvDisablePDEV
*
* Release the resources allocated in DrvEnablePDEV.  If a surface has been
* enabled DrvDisableSurface will have already been called.
*
\**************************************************************************/

VOID DrvDisablePDEV(
DHPDEV dhpdev)
{
   PPDEV ppdev = (PPDEV) dhpdev;
   
   EngDeletePalette(ppdev->hpalDefault);

   EngFreeMem(dhpdev);
}

/******************************Public*Routine******************************\
* DrvEnableSurface
*
* Enable the surface for the device.  Hook the calls this driver supports.
*
* Return: Handle to the surface if successful, 0 for failure.
*
\**************************************************************************/

HSURF DrvEnableSurface(
DHPDEV dhpdev)
{
    PPDEV ppdev;
    HSURF hsurf;
    SIZEL sizl;
    ULONG ulBitmapType;
    FLONG flHooks;
    ULONG mirrorsize;
    MIRRSURF *mirrsurf;
    DHSURF dhsurf;

    // Create engine bitmap around frame buffer.

    DISPDBG((0,"DrvEnableSurface:\n"));

    ppdev = (PPDEV) dhpdev;

    ppdev->ptlOrg.x = 0;
    ppdev->ptlOrg.y = 0;

    sizl.cx = ppdev->cxScreen;
    sizl.cy = ppdev->cyScreen;

    if (ppdev->ulBitCount == 16)
    {
        ulBitmapType = BMF_16BPP;
        flHooks = HOOKS_BMF16BPP;
    }
    else if (ppdev->ulBitCount == 24)
    {
        ulBitmapType = BMF_24BPP;
        flHooks = HOOKS_BMF24BPP;
    }
    else
    {
        ulBitmapType = BMF_32BPP;
        flHooks = HOOKS_BMF32BPP;
    }
    
    flHooks |= flGlobalHooks;

    mirrorsize = (ULONG)(sizeof(MIRRSURF) + 
                         ppdev->lDeltaScreen * sizl.cy);
    
    mirrsurf = (MIRRSURF *) EngAllocMem(FL_ZERO_MEMORY,
                                                  mirrorsize,
                                                  0x4D495252);
    
    dhsurf = (DHSURF) mirrsurf;

    hsurf = EngCreateDeviceSurface(dhsurf,
                                   sizl,
                                   ulBitmapType);

    if (hsurf == (HSURF) 0)
    {
        RIP("DISP DrvEnableSurface failed EngCreateBitmap\n");
        return(FALSE);
    }

    if (!EngAssociateSurface(hsurf, ppdev->hdevEng, flHooks))
    {
        RIP("DISRP DrvEnableSurface failed EngAssociateSurface\n");
        EngDeleteSurface(hsurf);
        return(FALSE);
    }

    ppdev->hsurfEng = (HSURF) hsurf;
    ppdev->pvTmpBuffer = (PVOID) dhsurf;

    mirrsurf->cx = ppdev->cxScreen;
    mirrsurf->cy = ppdev->cyScreen;
    mirrsurf->lDelta = ppdev->lDeltaScreen;
    mirrsurf->ulBitCount = ppdev->ulBitCount;
    mirrsurf->bIsScreen = TRUE;

    return(hsurf);
}

/******************************Public*Routine******************************\
* DrvDisableSurface
*
* Free resources allocated by DrvEnableSurface.  Release the surface.
*
\**************************************************************************/

VOID DrvDisableSurface(
DHPDEV dhpdev)
{
    PPDEV ppdev = (PPDEV) dhpdev;

    DISPDBG((0,"DrvDisableSurface:\n"));

    EngDeleteSurface( ppdev->hsurfEng );
    
    // deallocate MIRRSURF structure.

    EngFreeMem( ppdev->pvTmpBuffer );
}

/******************************Public*Routine******************************\
* DrvCopyBits
*
\**************************************************************************/

BOOL DrvCopyBits(
   OUT SURFOBJ *psoDst,
   IN SURFOBJ *psoSrc,
   IN CLIPOBJ *pco,
   IN XLATEOBJ *pxlo,
   IN RECTL *prclDst,
   IN POINTL *pptlSrc
   )
{
   INT cnt1 = 0, cnt2 = 0;

   DISPDBG((1,"Mirror Driver DrvCopyBits: \n"));

   if (psoSrc)
   {
       if (psoSrc->dhsurf)
       {
          MIRRSURF *mirrsurf = (MIRRSURF *)psoSrc->dhsurf;

          if (mirrsurf->bIsScreen) 
          {
             DISPDBG((1, "From Mirror Screen "));
          }
          else
          {
             DISPDBG((1, "From Mirror DFB "));
          }
          cnt1 ++;
       }
       else
       {
          DISPDBG((1, "From DIB "));
       }
   }

   if (psoDst)
   {
       if (psoDst->dhsurf)
       {
          MIRRSURF *mirrsurf = (MIRRSURF *)psoDst->dhsurf;

          if (mirrsurf->bIsScreen) 
          {
             DISPDBG((1, "to MirrorScreen "));
          }
          else
          {
             DISPDBG((1, "to Mirror DFB "));
          }
          cnt2 ++;
       }
       else
       {
          DISPDBG((1, "to DIB "));
       }
   }

   if (cnt1 && cnt2)
   {
      DISPDBG((1, " [Send Request Over Wire]\n"));
   }
   else if (cnt1)
   {
      DISPDBG((1, " [Read Cached Bits, Or Pull Bits]\n"));
   }
   else if (cnt2) 
   {
      DISPDBG((1, " [Push Bits/Compress]\n"));
   }
   else
   {
      DISPDBG((1, " [What Are We Doing Here?]\n"));
   }

   return FALSE;
}

/******************************Public*Routine******************************\
* DrvBitBlt
*
\**************************************************************************/

BOOL DrvBitBlt(
   IN SURFOBJ *psoDst,
   IN SURFOBJ *psoSrc,
   IN SURFOBJ *psoMask,
   IN CLIPOBJ *pco,
   IN XLATEOBJ *pxlo,
   IN RECTL *prclDst,
   IN POINTL *pptlSrc,
   IN POINTL *pptlMask,
   IN BRUSHOBJ *pbo,
   IN POINTL *pptlBrush,
   IN ROP4 rop4
   )
{
   INT cnt1 = 0, cnt2 = 0;

   DISPDBG((1,
            "Mirror Driver DrvBitBlt (Mask=%08x, rop=%08x:\n",
            psoMask, 
            rop4));

   if (psoSrc)
   {
       if (psoSrc->dhsurf)
       {
          MIRRSURF *mirrsurf = (MIRRSURF *)psoSrc->dhsurf;

          if (mirrsurf->bIsScreen) 
          {
             DISPDBG((1, "From Mirror Screen "));
          }
          else
          {
             DISPDBG((1, "From Mirror DFB "));
          }
          cnt1 ++;
       }
       else
       {
          DISPDBG((1, "From DIB "));
       }
   }

   if (psoDst)
   {
       if (psoDst->dhsurf)
       {
          MIRRSURF *mirrsurf = (MIRRSURF *)psoDst->dhsurf;

          if (mirrsurf->bIsScreen) 
          {
             DISPDBG((1, "to MirrorScreen "));
          }
          else
          {
             DISPDBG((1, "to Mirror DFB "));
          }
          cnt2 ++;
       }
       else
       {
          DISPDBG((1, "to DIB "));
       }
   }

   if (cnt1 && cnt2)
   {
      DISPDBG((1, " [Send Request Over Wire]\n"));
   }
   else if (cnt1)
   {
      DISPDBG((1, " [Read Cached Bits, Or Pull Bits]\n"));
   }
   else if (cnt2) 
   {
      DISPDBG((1, " [Push Bits/Compress]\n"));
   }
   else
   {
      DISPDBG((1, " [What Are We Doing Here?]\n"));
   }

   return FALSE;
}

BOOL DrvTextOut(
   IN SURFOBJ *psoDst,
   IN STROBJ *pstro,
   IN FONTOBJ *pfo,
   IN CLIPOBJ *pco,
   IN RECTL *prclExtra,
   IN RECTL *prclOpaque,
   IN BRUSHOBJ *pboFore,
   IN BRUSHOBJ *pboOpaque,
   IN POINTL *pptlOrg,
   IN MIX mix
   )
{
   DISPDBG((1,
            "Mirror Driver DrvTextOut: pwstr=%08x\n",
            pstro ? pstro->pwszOrg : (WCHAR*)-1));

   return FALSE;
}

BOOL
DrvStrokePath(SURFOBJ*   pso,
              PATHOBJ*   ppo,
              CLIPOBJ*   pco,
              XFORMOBJ*  pxo,
              BRUSHOBJ*  pbo,
              POINTL*    pptlBrush,
              LINEATTRS* pLineAttrs,
              MIX        mix)
{
   DISPDBG((1,
            "Mirror Driver DrvStrokePath:\n"));

   return FALSE;
}

#if 0

HBITMAP DrvCreateDeviceBitmap(
   IN DHPDEV dhpdev,
   IN SIZEL sizl,
   IN ULONG iFormat
   )
{
   HBITMAP hbm;
   MIRRSURF *mirrsurf;
   ULONG mirrorsize;
   DHSURF dhsurf;
   ULONG stride;
   HSURF hsurf;

   PPDEV ppdev = (PPDEV) dhpdev;
   
   DISPDBG((1,"CreateDeviceBitmap:\n"));
   
   if (iFormat == BMF_1BPP || iFormat == BMF_4BPP)
   {
      return NULL;
   };

   // DWORD align each stride
   stride = (sizl.cx*(iFormat/8)+3);
   stride -= stride % 4;
   
   mirrorsize = (int)(sizeof(MIRRSURF) + stride * sizl.cy);

   mirrsurf = (MIRRSURF *) EngAllocMem(FL_ZERO_MEMORY,
                                       mirrorsize,
                                       0x4D495252);

   dhsurf = (DHSURF) mirrsurf;

   hsurf = (HSURF) EngCreateDeviceBitmap(dhsurf,
                                 sizl,
                                 iFormat);

   if (hsurf == (HSURF) 0)
   {
       RIP("DISP DrvEnableSurface failed EngCreateBitmap\n");
       return(FALSE);
   }

   if (!EngAssociateSurface(hsurf, 
                            ppdev->hdevEng, 
                            flGlobalHooks))
   {
       RIP("DISP DrvEnableSurface failed EngAssociateSurface\n");
       EngDeleteSurface(hsurf);
       return(FALSE);
   }
  
   mirrsurf->cx = sizl.cx;
   mirrsurf->cy = sizl.cy;
   mirrsurf->lDelta = stride;
   mirrsurf->ulBitCount = iFormat;
   mirrsurf->bIsScreen = TRUE;
  
   return((HBITMAP)hsurf);
}

VOID DrvDeleteDeviceBitmap(
   IN DHSURF dhsurf
   )
{
   MIRRSURF *mirrsurf;
   
   DISPDBG((1, "DeleteDeviceBitmap:\n"));

   mirrsurf = (MIRRSURF *) dhsurf;

   EngFreeMem((PVOID) mirrsurf);
}
#endif

/******************************Public*Routine******************************\
* DrvAssertMode
*
* Enable/Disable the given device.
*
\**************************************************************************/

DrvAssertMode(DHPDEV  dhpdev,
              BOOL    bEnable)
{
    PPDEV ppdev = (PPDEV) dhpdev;

    DISPDBG((0, "DrvAssertMode(%lx, %lx)", dhpdev, bEnable));

    return TRUE;

}// DrvAssertMode()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\modex\disp\debug.h ===
/***************************************************************************\
* Module Name: debug.h
*
* Commonly used debugging macros.
*
* Copyright (c) 1992-1995 Microsoft Corporation
\***************************************************************************/

#if DBG

VOID
DebugPrint(
    ULONG DebugPrintLevel,
    PCHAR DebugMessage,
    ...
    );

#define DISPDBG(arg) DebugPrint arg
#define RIP(x) { DebugPrint(0, x); EngDebugBreak();}
#define ASSERTDD(x, y) if (!(x)) RIP (y)
#define STATEDBG(level)
#define LOGDBG(arg)

#else

#define DISPDBG(arg)
#define RIP(x)
#define ASSERTDD(x, y)
#define STATEDBG(level)
#define LOGDBG(arg)

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\mirror\mini\mirror.c ===
#include "dderror.h"
#include "devioctl.h"
#include "miniport.h"
#include "ntddvdeo.h"
#include "video.h"

#include "mirror.h"

VOID DbgBreakPoint() {};

VOID MirrorNotImplemented(char *s)
{
   VideoDebugPrint((0, "Mirror Sample: Not used '%s'.\n", s));
}

BOOLEAN
MirrorResetHW(
    PVOID HwDeviceExtension,
    ULONG Columns,
    ULONG Rows
    )
{
   MirrorNotImplemented("MirrorResetHW");
   
   return TRUE;
}

BOOLEAN
MirrorVidInterrupt(
    PVOID HwDeviceExtension
    )
{
   MirrorNotImplemented("MirrorVidInterrupt");

   return TRUE;
}

VP_STATUS
MirrorGetPowerState(
    PVOID                   HwDeviceExtension,
    ULONG                   HwId,
    PVIDEO_POWER_MANAGEMENT VideoPowerControl
    )
{
   MirrorNotImplemented("MirrorGetPowerState");

   return NO_ERROR;
}

VP_STATUS
MirrorSetPowerState(
    PVOID                   HwDeviceExtension,
    ULONG                   HwId,
    PVIDEO_POWER_MANAGEMENT VideoPowerControl
    )
{
   MirrorNotImplemented("MirrorSetPowerState");

   return NO_ERROR;
}

ULONG
MirrorGetChildDescriptor (
    IN  PVOID                  HwDeviceExtension,
    IN  PVIDEO_CHILD_ENUM_INFO ChildEnumInfo,
    OUT PVIDEO_CHILD_TYPE      pChildType,
    OUT PVOID                  pChildDescriptor,
    OUT PULONG                 pUId,
    OUT PULONG                 pUnused
    )
{
   MirrorNotImplemented("MirrorGetChildDescriptor");

   return ERROR_NO_MORE_DEVICES;
}

VP_STATUS MirrorFindAdapter(
   IN PVOID HwDeviceExtension,
   IN PVOID HwContext,
   IN PWSTR ArgumentString,
   IN OUT PVIDEO_PORT_CONFIG_INFO ConfigInfo,
   OUT PUCHAR Again
   )
{
   VideoDebugPrint((0,"FindAdapter Called.\n"));
 
   return NO_ERROR;
}

BOOLEAN MirrorInitialize(
   PVOID HwDeviceExtension
   )
{
   VideoDebugPrint((0,"Initialize Called.\n"));

   return TRUE;
}

BOOLEAN MirrorStartIO(
   PVOID HwDeviceExtension,
   PVIDEO_REQUEST_PACKET RequestPacket
   )
{
   VideoDebugPrint((0,"StartIO Called.\n"));

   return TRUE;
}

ULONG
DriverEntry (
    PVOID Context1,
    PVOID Context2
    )
{

    VIDEO_HW_INITIALIZATION_DATA hwInitData;
    ULONG initializationStatus;

    VideoDebugPrint((0, "Mirrored Driver VideoPort [Driver Entry]\n"));

    // Zero out structure.

    VideoPortZeroMemory(&hwInitData, sizeof(VIDEO_HW_INITIALIZATION_DATA));

    // Specify sizes of structure and extension.

    hwInitData.HwInitDataSize = sizeof(VIDEO_HW_INITIALIZATION_DATA);

    // Set entry points.

    hwInitData.HwFindAdapter             = &MirrorFindAdapter;
    hwInitData.HwInitialize              = &MirrorInitialize;
    hwInitData.HwStartIO                 = &MirrorStartIO;
    hwInitData.HwResetHw                 = &MirrorResetHW;
    hwInitData.HwInterrupt               = &MirrorVidInterrupt;
    hwInitData.HwGetPowerState           = &MirrorGetPowerState;
    hwInitData.HwSetPowerState           = &MirrorSetPowerState;
    hwInitData.HwGetVideoChildDescriptor = &MirrorGetChildDescriptor;

    hwInitData.HwLegacyResourceList      = NULL; 
    hwInitData.HwLegacyResourceCount     = 0; 

    // no device extension necessary
    hwInitData.HwDeviceExtensionSize = 0;
    hwInitData.AdapterInterfaceType = 0;

    initializationStatus = VideoPortInitialize(Context1,
                                               Context2,
                                               &hwInitData,
                                               NULL);

    return initializationStatus;

} // end DriverEntry()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\mirror\mini\mirror.h ===
VOID DummyInterface();

VP_STATUS MirrorFindAdapter(
   IN PVOID HwDeviceExtension,
   IN PVOID HwContext,
   IN PWSTR ArgumentString,
   IN OUT PVIDEO_PORT_CONFIG_INFO ConfigInfo,
   OUT PUCHAR Again
   );

BOOLEAN MirrorInitialize(
   PVOID HwDeviceExtension
   );

BOOLEAN MirrorStartIO(
   PVOID HwDeviceExtension,
   PVIDEO_REQUEST_PACKET RequestPacket
   );

ULONG
DriverEntry (
    PVOID Context1,
    PVOID Context2
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\modex\disp\draw.c ===
/******************************Module*Header*******************************\
* Module Name: draw.c
*
* The drawing guts of a portable 16-colour VGA driver for Windows NT.  The
* implementation herein may possibly be the simplest method of bringing
* up a driver whose surface is not directly writable by GDI.  One might
* use the phrase "quick and dirty" when describing it.
*
* We create a 4bpp bitmap that is the size of the screen, and simply
* have GDI do all the drawing to it.  We update the screen directly
* from the bitmap, based on the bounds of the drawing (basically
* employing "dirty rectangles").
*
* In total, the only hardware-specific code we had to write was the
* initialization code, and a routine for doing aligned srccopy blts
* from a DIB to the screen.
*
* Obvious Note: This approach is definitely not recommended if you want
*               to get decent performance.
*
* Copyright (c) 1994-1995 Microsoft Corporation
\**************************************************************************/

#include "precomp.h"

/******************************Public*Routine******************************\
* DrvStrokePath
*
\**************************************************************************/

BOOL DrvStrokePath(
SURFOBJ*   pso,
PATHOBJ*   ppo,
CLIPOBJ*   pco,
XFORMOBJ*  pxo,
BRUSHOBJ*  pbo,
POINTL*    pptlBrush,
LINEATTRS* pla,
MIX        mix)
{
    BOOL        b;
    PDEV*       ppdev;
    RECTFX      rcfxBounds;
    RECTL       rclBounds;

    ppdev = (PDEV*) pso->dhpdev;

    b = EngStrokePath(ppdev->pso, ppo, pco, pxo, pbo, pptlBrush, pla, mix);

    // Get the path bounds and make it lower-right exclusive:

    PATHOBJ_vGetBounds(ppo, &rcfxBounds);

    rclBounds.left   = (rcfxBounds.xLeft   >> 4);
    rclBounds.top    = (rcfxBounds.yTop    >> 4);
    rclBounds.right  = (rcfxBounds.xRight  >> 4) + 2;
    rclBounds.bottom = (rcfxBounds.yBottom >> 4) + 2;

    // Don't update the screen if we're currently showing an 'off-screen'
    // DirectDraw flip buffer:

    if (ppdev->fpScreenOffset == 0)
    {
        vUpdate(ppdev, &rclBounds, pco);
    }

    return(b);
}

/******************************Public*Routine******************************\
* DrvBitBlt
*
\**************************************************************************/

BOOL DrvBitBlt(
SURFOBJ*  psoDst,
SURFOBJ*  psoSrc,
SURFOBJ*  psoMask,
CLIPOBJ*  pco,
XLATEOBJ* pxlo,
RECTL*    prclDst,
POINTL*   pptlSrc,
POINTL*   pptlMask,
BRUSHOBJ* pbo,
POINTL*   pptlBrush,
ROP4      rop4)
{
    BOOL        bUpdate;
    BOOL        b;
    PDEV*       ppdev;

    bUpdate = FALSE;
    if (psoDst->iType == STYPE_DEVICE)
    {
        bUpdate = TRUE;
        ppdev   = (PDEV*) psoDst->dhpdev;
        psoDst  = ppdev->pso;
    }
    if ((psoSrc != NULL) && (psoSrc->iType == STYPE_DEVICE))
    {
        ppdev   = (PDEV*) psoSrc->dhpdev;
        psoSrc  = ppdev->pso;
    }

    b = EngBitBlt(psoDst, psoSrc, psoMask, pco, pxlo, prclDst, pptlSrc,
                  pptlMask, pbo, pptlBrush, rop4);

    if (bUpdate)
    {
        // Don't update the screen if we're currently showing an 'off-screen'
        // DirectDraw flip buffer:

        if (ppdev->fpScreenOffset == 0)
        {
            vUpdate(ppdev, prclDst, pco);
        }
    }

    return(b);
}

/******************************Public*Routine******************************\
* DrvCopyBits
*
\**************************************************************************/

BOOL DrvCopyBits(
SURFOBJ*  psoDst,
SURFOBJ*  psoSrc,
CLIPOBJ*  pco,
XLATEOBJ* pxlo,
RECTL*    prclDst,
POINTL*   pptlSrc)
{
    BOOL        bUpdate;
    BOOL        b;
    PDEV*       ppdev;

    return(DrvBitBlt(psoDst, psoSrc, NULL, pco, pxlo, prclDst, pptlSrc,
                     NULL, NULL, NULL, 0xcccc));
}

/******************************Public*Routine******************************\
* DrvTextOut
*
\**************************************************************************/

BOOL DrvTextOut(
SURFOBJ*  pso,
STROBJ*   pstro,
FONTOBJ*  pfo,
CLIPOBJ*  pco,
RECTL*    prclExtra,
RECTL*    prclOpaque,
BRUSHOBJ* pboFore,
BRUSHOBJ* pboOpaque,
POINTL*   pptlOrg,
MIX       mix)
{
    BOOL        b;
    PDEV*       ppdev;

    ppdev = (PDEV*) pso->dhpdev;

    b = EngTextOut(ppdev->pso, pstro, pfo, pco, prclExtra, prclOpaque,
                   pboFore, pboOpaque, pptlOrg, mix);

    // Don't update the screen if we're currently showing an 'off-screen'
    // DirectDraw flip buffer:

    if (ppdev->fpScreenOffset == 0)
    {
        vUpdate(ppdev, (prclOpaque != NULL) ? prclOpaque : &pstro->rclBkGround,
                pco);
    }

    return(b);
}

/******************************Public*Routine******************************\
* DrvPaint
*
\**************************************************************************/

BOOL DrvPaint(
SURFOBJ*  pso,
CLIPOBJ*  pco,
BRUSHOBJ* pbo,
POINTL*   pptlBrush,
MIX       mix)
{
    BOOL        b;
    PDEV*       ppdev;

    ppdev = (PDEV*) pso->dhpdev;

    b = EngPaint(ppdev->pso, pco, pbo, pptlBrush, mix);

    // Don't update the screen if we're currently showing an 'off-screen'
    // DirectDraw flip buffer:

    if (ppdev->fpScreenOffset == 0)
    {
        vUpdate(ppdev, &pco->rclBounds, pco);
    }

    return(b);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\modex\disp\driver.h ===
/******************************Module*Header*******************************\
* Module Name: driver.h
*
* Contains prototypes for the display driver.
*
* Copyright (c) 1992-1995 Microsoft Corporation
\**************************************************************************/

typedef struct _PDEV PDEV;      // Handy forward declaration

//////////////////////////////////////////////////////////////////////
// Miscellaneous shared stuff

#define DLL_NAME                L"modex"        // Name of the DLL in UNICODE
#define STANDARD_DEBUG_PREFIX   "ModeX: "       // All debug output is prefixed
                                                //   by this string
#define ALLOC_TAG               'xdmD'          // Dmdx
                                                // Four byte tag (characters in
                                                // reverse order) used for
                                                // memory allocations

#define DRIVER_EXTRA_SIZE   0   // Size of the DriverExtra information in the
                                //   DEVMODE structure

#define NUM_FLIP_BUFFERS    5   // Total number of flip buffers that we'll tell
                                //   DirectDraw we have, including the primary
                                //   surface buffer

/////////////////////////////////////////////////////////////////////////
// Palette stuff

BOOL bEnablePalette(PDEV*);
VOID vDisablePalette(PDEV*);
VOID vAssertModePalette(PDEV*, BOOL);

BOOL bInitializePalette(PDEV*, DEVINFO*);
VOID vUninitializePalette(PDEV*);

#define MAX_CLUT_SIZE (sizeof(VIDEO_CLUT) + (sizeof(ULONG) * 256))

/////////////////////////////////////////////////////////////////////////
// DirectDraw stuff

typedef struct _FLIPRECORD
{
    FLATPTR         fpFlipFrom;             // Surface we last flipped from
    LONGLONG        liFlipTime;             // Time at which last flip
                                            //   occured
    LONGLONG        liFlipDuration;         // Precise amount of time it
                                            //   takes from vblank to vblank
    BOOL            bHaveEverCrossedVBlank; // True if we noticed that we
                                            //   switched from inactive to
                                            //   vblank
    BOOL            bWasEverInDisplay;      // True if we ever noticed that
                                            //   we were inactive
    BOOL            bFlipFlag;              // True if we think a flip is
                                            //   still pending
} FLIPRECORD;

BOOL bEnableDirectDraw(PDEV*);
VOID vDisableDirectDraw(PDEV*);
VOID vAssertModeDirectDraw(PDEV*, BOOL);

////////////////////////////////////////////////////////////////////////
// The Physical Device data structure

typedef struct  _PDEV
{
    ULONG       iBitmapFormat;          // BMF_8BPP (our current colour depth)
    UCHAR*      pjBase;                 // Mapped IO port base for this PDEV
    LONG        lVgaDelta;              // VGA screen stride
    BYTE*       pjVga;                  // Points to VGA's base screen address
    ULONG       cjVgaOffset;            // Offset from pjVga to current flip
                                        //   buffer
    ULONG       iVgaPage;               // Page number of current flip buffer
    ULONG       cVgaPages;              // Count of flip buffers
    ULONG       cjVgaPageSize;          // Size of a flip buffer

    BYTE*       pjScreen;               // Points to shadow buffer
    LONG        lScreenDelta;           // Shadow buffer stride
    FLATPTR     fpScreenOffset;         // Offset to current DirectDraw flip
                                        //   buffer; if zero, primary GDI
                                        //   surface is visible
    LONG        cxScreen;               // Visible screen width
    LONG        cyScreen;               // Visible screen height
    LONG        cxMemory;               // Shadow buffer width
    LONG        cyMemory;               // Shadow buffer height

    HANDLE      hDriver;                // Handle to \Device\Screen
    HDEV        hdevEng;                // Engine's handle to PDEV
    HSURF       hsurfScreen;            // Engine's handle to screen surface
    HSURF       hsurfShadow;            // Engine's handle to our shadow buffer

    FLONG       flHooks;                // What we're hooking from GDI

    ULONG       ulMode;                 // Mode the mini-port driver is in.

    SURFOBJ*    pso;                    // DIB copy of our shaodw surface to
                                        //   which we have GDI draw everything
    LONG        cLocks;                 // Number of current DirectDraw
                                        //   locks
    RECTL       rclLock;                // Bounding box of all current Direct-
                                        //   Draw locks

    ////////// Palette stuff:

    PALETTEENTRY* pPal;                 // The palette if palette managed
    HPALETTE    hpalDefault;            // GDI handle to the default palette.
    FLONG       flRed;                  // Red mask for 16/32bpp bitfields
    FLONG       flGreen;                // Green mask for 16/32bpp bitfields
    FLONG       flBlue;                 // Blue mask for 16/32bpp bitfields
    ULONG       cPaletteShift;          // number of bits the 8-8-8 palette must
                                        // be shifted by to fit in the hardware

    /////////// DirectDraw stuff:

    FLIPRECORD  flipRecord;             // Used to track vertical blank status
    ULONG       cDwordsPerPlane;        // Total number of dwords per plane

} PDEV, *PPDEV;

/////////////////////////////////////////////////////////////////////////
// Miscellaneous prototypes:

VOID vUpdate(PDEV*, RECTL*, CLIPOBJ*);
BOOL bAssertModeHardware(PDEV*, BOOL);
BOOL bEnableHardware(PDEV*);
VOID vDisableHardware(PDEV*);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\modex\disp\enable.c ===
/******************************Module*Header*******************************\
* Module Name: enable.c
*
* The initialization guts of the portable ModeX 256 colour VGA driver.
*
* The drawing guts of a portable 256-colour ModeX driver for Windows NT.
* The implementation herein may possibly be the simplest method of bringing
* up a driver whose surface is not directly writable by GDI.  One might
* use the phrase "quick and dirty" when describing it.
*
* We create a 8bpp bitmap that is the size of the screen, and simply
* have GDI do all the drawing to it.  We update the screen directly
* from the bitmap, based on the bounds of the drawing (basically
* employing "dirty rectangles").
*
* In total, the only hardware-specific code we had to write was the
* initialization code, and a routine for doing aligned srccopy blts
* from a DIB to the screen.
*
* Obvious Note: This approach is definitely not recommended for decent
*               driver performance.
*
* Copyright (c) 1994-1995 Microsoft Corporation
\**************************************************************************/

#include "precomp.h"

/******************************Public*Structure****************************\
* DFVFN gadrvfn[]
*
* Build the driver function table gadrvfn with function index/address
* pairs.  This table tells GDI which DDI calls we support, and their
* location (GDI does an indirect call through this table to call us).
*
\**************************************************************************/

static DRVFN gadrvfn[] = {
    {   INDEX_DrvEnablePDEV,            (PFN) DrvEnablePDEV             },
    {   INDEX_DrvCompletePDEV,          (PFN) DrvCompletePDEV           },
    {   INDEX_DrvDisablePDEV,           (PFN) DrvDisablePDEV            },
    {   INDEX_DrvEnableSurface,         (PFN) DrvEnableSurface          },
    {   INDEX_DrvDisableSurface,        (PFN) DrvDisableSurface         },
    {   INDEX_DrvDitherColor,           (PFN) DrvDitherColor            },
    {   INDEX_DrvAssertMode,            (PFN) DrvAssertMode             },
    {   INDEX_DrvGetModes,              (PFN) DrvGetModes               },
    {   INDEX_DrvBitBlt,                (PFN) DrvBitBlt                 },
    {   INDEX_DrvTextOut,               (PFN) DrvTextOut                },
    {   INDEX_DrvStrokePath,            (PFN) DrvStrokePath             },
    {   INDEX_DrvCopyBits,              (PFN) DrvCopyBits               },
    {   INDEX_DrvPaint,                 (PFN) DrvPaint                  },
    {   INDEX_DrvSetPalette,            (PFN) DrvSetPalette             },
    {   INDEX_DrvGetDirectDrawInfo,     (PFN) DrvGetDirectDrawInfo      },
    {   INDEX_DrvEnableDirectDraw,      (PFN) DrvEnableDirectDraw       },
    {   INDEX_DrvDisableDirectDraw,     (PFN) DrvDisableDirectDraw      },
};

ULONG gcdrvfn = sizeof(gadrvfn) / sizeof(DRVFN);

/******************************Public*Structure****************************\
* GDIINFO ggdiDefault
*
* This contains the default GDIINFO fields that are passed back to GDI
* during DrvEnablePDEV.
*
* NOTE: This structure defaults to values for a 8bpp palette device.
\**************************************************************************/

GDIINFO ggdiDefault = {
     GDI_DRIVER_VERSION,
     DT_RASDISPLAY,         // ulTechnology
     0,                     // ulHorzSize
     0,                     // ulVertSize
     0,                     // ulHorzRes (filled in at initialization)
     0,                     // ulVertRes (filled in at initialization)
     8,                     // cBitsPixel
     1,                     // cPlanes
     20,                    // ulNumColors
     0,                     // flRaster (DDI reserved field)

     0,                     // ulLogPixelsX (filled in at initialization)
     0,                     // ulLogPixelsY (filled in at initialization)

     TC_RA_ABLE,            // flTextCaps

     0,                     // ulDACRed
     0,                     // ulDACGree
     0,                     // ulDACBlue

     0x0024,                // ulAspectX  (one-to-one aspect ratio)
     0x0024,                // ulAspectY
     0x0033,                // ulAspectXY

     1,                     // xStyleStep
     1,                     // yStyleSte;
     3,                     // denStyleStep

     { 0, 0 },              // ptlPhysOffset
     { 0, 0 },              // szlPhysSize

     256,                   // ulNumPalReg (win3.1 16 color drivers say 0 too)

// These fields are for halftone initialization.

     {                                          // ciDevice, ColorInfo
        { 6700, 3300, 0 },                      // Red
        { 2100, 7100, 0 },                      // Green
        { 1400,  800, 0 },                      // Blue
        { 1750, 3950, 0 },                      // Cyan
        { 4050, 2050, 0 },                      // Magenta
        { 4400, 5200, 0 },                      // Yellow
        { 3127, 3290, 0 },                      // AlignmentWhite
        20000,                                  // RedGamma
        20000,                                  // GreenGamma
        20000,                                  // BlueGamma
        0, 0, 0, 0, 0, 0
     },

     0,                      // ulDevicePelsDPI  (filled in at initialization)
     PRIMARY_ORDER_CBA,                         // ulPrimaryOrder
     HT_PATSIZE_4x4_M,                          // ulHTPatternSize
     HT_FORMAT_8BPP,                            // ulHTOutputFormat
     HT_FLAG_ADDITIVE_PRIMS,                    // flHTFlags

     0,                                         // ulVRefresh
     1,                      // ulBltAlignment (preferred window alignment
                             //   for fast-text routines)
     0,                                         // ulPanningHorzRes
     0,                                         // ulPanningVertRes
};

/******************************Public*Structure****************************\
* DEVINFO gdevinfoDefault
*
* This contains the default DEVINFO fields that are passed back to GDI
* during DrvEnablePDEV.
*
* NOTE: This structure defaults to values for a 8bpp palette device.
\**************************************************************************/

#define SYSTM_LOGFONT {16,7,0,0,700,0,0,0,ANSI_CHARSET,OUT_DEFAULT_PRECIS, \
                       CLIP_DEFAULT_PRECIS,DEFAULT_QUALITY, \
                       VARIABLE_PITCH | FF_DONTCARE,L"System"}
#define HELVE_LOGFONT {12,9,0,0,400,0,0,0,ANSI_CHARSET,OUT_DEFAULT_PRECIS, \
                       CLIP_STROKE_PRECIS,PROOF_QUALITY, \
                       VARIABLE_PITCH | FF_DONTCARE,  L"MS Sans Serif"}
#define COURI_LOGFONT {12,9,0,0,400,0,0,0,ANSI_CHARSET,OUT_DEFAULT_PRECIS, \
                       CLIP_STROKE_PRECIS,PROOF_QUALITY, \
                       FIXED_PITCH | FF_DONTCARE, L"Courier"}

DEVINFO gdevinfoDefault =
{
    (GCAPS_MONO_DITHER  |
     GCAPS_COLOR_DITHER |
     GCAPS_DIRECTDRAW   |
     GCAPS_PALMANAGED),
                    // Graphics capabilities

    SYSTM_LOGFONT,  // Default font description
    HELVE_LOGFONT,  // ANSI variable font description
    COURI_LOGFONT,  // ANSI fixed font description
    0,              // Count of device fonts
    BMF_8BPP,       // preferred DIB format
    8,              // Width of color dither
    8,              // Height of color dither
    0               // Default palette to use for this device
};

/******************************Public*Data*Struct*************************\
* VGALOGPALETTE logPalVGA
*
* This is the palette for the VGA.
*
\**************************************************************************/

typedef struct _VGALOGPALETTE
{
    USHORT          ident;
    USHORT          NumEntries;
    PALETTEENTRY    palPalEntry[16];
} VGALOGPALETTE;

const VGALOGPALETTE logPalVGA =
{
    0x400,  // Driver version
    16,     // Number of entries
    {
        { 0,   0,   0,   0 },       // 0
        { 0x80,0,   0,   0 },       // 1
        { 0,   0x80,0,   0 },       // 2
        { 0x80,0x80,0,   0 },       // 3
        { 0,   0,   0x80,0 },       // 4
        { 0x80,0,   0x80,0 },       // 5
        { 0,   0x80,0x80,0 },       // 6
        { 0x80,0x80,0x80,0 },       // 7

        { 0xC0,0xC0,0xC0,0 },       // 8
        { 0xFF,0,   0,   0 },       // 9
        { 0,   0xFF,0,   0 },       // 10
        { 0xFF,0xFF,0,   0 },       // 11
        { 0,   0,   0xFF,0 },       // 12
        { 0xFF,0,   0xFF,0 },       // 13
        { 0,   0xFF,0xFF,0 },       // 14
        { 0xFF,0xFF,0xFF,0 }        // 15
    }
};

/******************************Public*Routine******************************\
* BOOL DrvEnableDriver
*
* Enables the driver by retrieving the drivers function table and version.
*
\**************************************************************************/

BOOL DrvEnableDriver(
ULONG          iEngineVersion,
ULONG          cj,
DRVENABLEDATA* pded)
{
    // Engine Version is passed down so future drivers can support previous
    // engine versions.  A next generation driver can support both the old
    // and new engine conventions if told what version of engine it is
    // working with.  For the first version the driver does nothing with it.

    // Fill in as much as we can.

    if (cj >= sizeof(DRVENABLEDATA))
        pded->pdrvfn = gadrvfn;

    if (cj >= (sizeof(ULONG) * 2))
        pded->c = gcdrvfn;

    // DDI version this driver was targeted for is passed back to engine.
    // Future graphic's engine may break calls down to old driver format.

    if (cj >= sizeof(ULONG))
        pded->iDriverVersion = DDI_DRIVER_VERSION_NT4;

    return(TRUE);
}

/******************************Public*Routine******************************\
* VOID DrvDisableDriver
*
* Tells the driver it is being disabled. Release any resources allocated in
* DrvEnableDriver.
*
\**************************************************************************/

VOID DrvDisableDriver(VOID)
{
    return;
}

/******************************Public*Routine******************************\
* DWORD getAvailableModes
*
* Calls the miniport to get the list of modes supported by the kernel driver,
* and returns the list of modes supported by the diplay driver among those
*
* returns the number of entries in the videomode buffer.
* 0 means no modes are supported by the miniport or that an error occured.
*
* NOTE: the buffer must be freed up by the caller.
*
\**************************************************************************/

DWORD getAvailableModes(
HANDLE                   hDriver,
PVIDEO_MODE_INFORMATION* modeInformation,
DWORD*                   cbModeSize)
{
    ULONG ulTemp;
    VIDEO_NUM_MODES modes;
    PVIDEO_MODE_INFORMATION pVideoTemp;
    DWORD status;

    //
    // Get the number of modes supported by the mini-port
    //

    if (status = EngDeviceIoControl(hDriver,
            IOCTL_VIDEO_QUERY_NUM_AVAIL_MODES,
            NULL,
            0,
            &modes,
            sizeof(VIDEO_NUM_MODES),
            &ulTemp))
    {
        DISPDBG((0, "getAvailableModes failed VIDEO_QUERY_NUM_AVAIL_MODES"));
        DISPDBG((0, "Win32 Status = %x", status));
        return(0);
    }

    *cbModeSize = modes.ModeInformationLength;

    //
    // Allocate the buffer for the mini-port to write the modes in.
    //

    *modeInformation = (PVIDEO_MODE_INFORMATION)
                        EngAllocMem(FL_ZERO_MEMORY,
                                   modes.NumModes *
                                   modes.ModeInformationLength, ALLOC_TAG);

    if (*modeInformation == (PVIDEO_MODE_INFORMATION) NULL)
    {
        DISPDBG((0, "getAvailableModes failed EngAllocMem"));
        return(0);
    }

    //
    // Ask the mini-port to fill in the available modes.
    //

    if (status = EngDeviceIoControl(hDriver,
            IOCTL_VIDEO_QUERY_AVAIL_MODES,
            NULL,
            0,
            *modeInformation,
            modes.NumModes * modes.ModeInformationLength,
            &ulTemp))
    {

        DISPDBG((0, "getAvailableModes failed VIDEO_QUERY_AVAIL_MODES"));
        DISPDBG((0, "Win32 Status = %x", status));

        EngFreeMem(*modeInformation);
        *modeInformation = (PVIDEO_MODE_INFORMATION) NULL;

        return(0);
    }

    //
    // Now see which of these modes are supported by the display driver.
    // As an internal mechanism, set the length to 0 for the modes we
    // DO NOT support.
    //

    ulTemp = modes.NumModes;
    pVideoTemp = *modeInformation;

    //
    // Mode is rejected if it is not 8 planes, or not graphics, or is not
    // one of 1 bits per pel.
    //

    while (ulTemp--)
    {
        DISPDBG((2, "Planes: %li  BitsPerPlane: %li  ScreenWidth: %li",
            pVideoTemp->NumberOfPlanes,
            pVideoTemp->BitsPerPlane,
            pVideoTemp->VisScreenWidth));

        if ((pVideoTemp->NumberOfPlanes != 8) ||
            !(pVideoTemp->AttributeFlags & VIDEO_MODE_GRAPHICS) ||
            (pVideoTemp->BitsPerPlane != 1) ||
            (pVideoTemp->VisScreenWidth > 320))
        {
            pVideoTemp->Length = 0;
        }

        pVideoTemp = (PVIDEO_MODE_INFORMATION)
            (((PUCHAR)pVideoTemp) + modes.ModeInformationLength);
    }

    return(modes.NumModes);

}

/******************************Public*Routine******************************\
* BOOL bInitializeModeFields
*
* Initializes a bunch of fields in the pdev, devcaps (aka gdiinfo), and
* devinfo based on the requested mode.
*
\**************************************************************************/

BOOL bInitializeModeFields(
PDEV*     ppdev,
GDIINFO*  pgdi,
DEVINFO*  pdi,
DEVMODEW* pdm)
{
    ULONG                   cModes;
    PVIDEO_MODE_INFORMATION pVideoBuffer;
    PVIDEO_MODE_INFORMATION pVideoModeSelected;
    PVIDEO_MODE_INFORMATION pVideoTemp;
    BOOL                    bSelectDefault;
    VIDEO_MODE_INFORMATION  VideoModeInformation;
    ULONG                   cbModeSize;

    // Call the miniport to get mode information

    cModes = getAvailableModes(ppdev->hDriver, &pVideoBuffer, &cbModeSize);
    if (cModes == 0)
        goto ReturnFalse;

    // Now see if the requested mode has a match in that table.

    pVideoModeSelected = NULL;
    pVideoTemp = pVideoBuffer;

    if ((pdm->dmPelsWidth        == 0) &&
        (pdm->dmPelsHeight       == 0) &&
        (pdm->dmBitsPerPel       == 0) &&
        (pdm->dmDisplayFrequency == 0))
    {
        DISPDBG((1, "Default mode requested"));
        bSelectDefault = TRUE;
    }
    else
    {
        DISPDBG((1, "Requested mode..."));
        DISPDBG((1, "   Screen width  -- %li", pdm->dmPelsWidth));
        DISPDBG((1, "   Screen height -- %li", pdm->dmPelsHeight));
        DISPDBG((1, "   Bits per pel  -- %li", pdm->dmBitsPerPel));
        DISPDBG((1, "   Frequency     -- %li", pdm->dmDisplayFrequency));

        bSelectDefault = FALSE;
    }

    while (cModes--)
    {
        if (pVideoTemp->Length != 0)
        {
            DISPDBG((2, "   Checking against miniport mode:"));
            DISPDBG((2, "      Screen width  -- %li", pVideoTemp->VisScreenWidth));
            DISPDBG((2, "      Screen height -- %li", pVideoTemp->VisScreenHeight));
            DISPDBG((2, "      Bits per pel  -- %li", pVideoTemp->BitsPerPlane *
                                                      pVideoTemp->NumberOfPlanes));
            DISPDBG((2, "      Frequency     -- %li", pVideoTemp->Frequency));

            if (bSelectDefault ||
                ((pVideoTemp->VisScreenWidth  == pdm->dmPelsWidth) &&
                 (pVideoTemp->VisScreenHeight == pdm->dmPelsHeight) &&
                 (pVideoTemp->BitsPerPlane *
                  pVideoTemp->NumberOfPlanes  == pdm->dmBitsPerPel) &&
                 (pVideoTemp->Frequency       == pdm->dmDisplayFrequency)))
            {
                pVideoModeSelected = pVideoTemp;
                DISPDBG((1, "...Found a mode match!"));
                break;
            }
        }

        pVideoTemp = (PVIDEO_MODE_INFORMATION)
            (((PUCHAR)pVideoTemp) + cbModeSize);

    }

    // If no mode has been found, return an error

    if (pVideoModeSelected == NULL)
    {
        DISPDBG((1, "...Couldn't find a mode match!"));
        EngFreeMem(pVideoBuffer);
        goto ReturnFalse;
    }

    // We have chosen the one we want.  Save it in a stack buffer and
    // get rid of allocated memory before we forget to free it.

    VideoModeInformation = *pVideoModeSelected;
    EngFreeMem(pVideoBuffer);

    // Set up screen information from the mini-port:

    ppdev->ulMode           = VideoModeInformation.ModeIndex;
    ppdev->cxScreen         = VideoModeInformation.VisScreenWidth;
    ppdev->cyScreen         = VideoModeInformation.VisScreenHeight;

    DISPDBG((1, "ScreenStride: %lx", VideoModeInformation.ScreenStride));

    ppdev->flHooks          = (HOOK_BITBLT     |
                               HOOK_TEXTOUT    |
                               HOOK_COPYBITS   |
                               HOOK_STROKEPATH |
                               HOOK_PAINT);

    // Fill in the GDIINFO data structure with the default 8bpp values:

    *pgdi = ggdiDefault;

    // Now overwrite the defaults with the relevant information returned
    // from the kernel driver:

    pgdi->ulHorzSize        = VideoModeInformation.XMillimeter;
    pgdi->ulVertSize        = VideoModeInformation.YMillimeter;

    pgdi->ulHorzRes         = VideoModeInformation.VisScreenWidth;
    pgdi->ulVertRes         = VideoModeInformation.VisScreenHeight;
    pgdi->ulPanningHorzRes  = VideoModeInformation.VisScreenWidth;
    pgdi->ulPanningVertRes  = VideoModeInformation.VisScreenHeight;

    // NOTE: We exchange BitsPerPlane and NumberOfPlanes for compatibility.
    //       The miniport knows the true value of 8 planes, but we have to
    //       tell applications that there's only 1 plane otherwise some of
    //       them will undoubtedly fall over.

    pgdi->cBitsPixel        = VideoModeInformation.NumberOfPlanes;
    pgdi->cPlanes           = VideoModeInformation.BitsPerPlane;

    pgdi->ulVRefresh        = VideoModeInformation.Frequency;
    pgdi->ulDACRed          = VideoModeInformation.NumberRedBits;
    pgdi->ulDACGreen        = VideoModeInformation.NumberGreenBits;
    pgdi->ulDACBlue         = VideoModeInformation.NumberBlueBits;

    pgdi->ulLogPixelsX      = pdm->dmLogPixels;
    pgdi->ulLogPixelsY      = pdm->dmLogPixels;

    // Fill in the devinfo structure with the default 8bpp values:

    *pdi = gdevinfoDefault;

    ppdev->iBitmapFormat    = BMF_8BPP;
    ppdev->cPaletteShift    = 8 - pgdi->ulDACRed;

    return(TRUE);

ReturnFalse:

    DISPDBG((0, "Failed bInitializeModeFields"));

    return(FALSE);
}

/******************************Public*Routine******************************\
* DHPDEV DrvEnablePDEV
*
* Initializes a bunch of fields for GDI, based on the mode we've been asked
* to do.  This is the first thing called after DrvEnableDriver, when GDI
* wants to get some information about us.
*
* (This function mostly returns back information; DrvEnableSurface is used
* for initializing the hardware and driver components.)
*
\**************************************************************************/

DHPDEV DrvEnablePDEV(
DEVMODEW*   pdm,            // Contains data pertaining to requested mode
PWSTR       pwszLogAddr,    // Logical address
ULONG       cPat,           // Count of standard patterns
HSURF*      phsurfPatterns, // Buffer for standard patterns
ULONG       cjCaps,         // Size of buffer for device caps 'pdevcaps'
ULONG*      pdevcaps,       // Buffer for device caps, also known as 'gdiinfo'
ULONG       cjDevInfo,      // Number of bytes in device info 'pdi'
DEVINFO*    pdi,            // Device information
HDEV        hdev,           // HDEV, used for callbacks
PWSTR       pwszDeviceName, // Device name
HANDLE      hDriver)        // Kernel driver handle
{
    PDEV*   ppdev;

    // Future versions of NT had better supply 'devcaps' and 'devinfo'
    // structures that are the same size or larger than the current
    // structures:

    if ((cjCaps < sizeof(GDIINFO)) || (cjDevInfo < sizeof(DEVINFO)))
    {
        DISPDBG((0, "DrvEnablePDEV - Buffer size too small"));
        goto ReturnFailure0;
    }

    // Allocate a physical device structure.  Note that we definitely
    // rely on the zero initialization:

    ppdev = (PDEV*) EngAllocMem(FL_ZERO_MEMORY, sizeof(PDEV), ALLOC_TAG);
    if (ppdev == NULL)
    {
        DISPDBG((0, "DrvEnablePDEV - Failed EngAllocMem"));
        goto ReturnFailure0;
    }

    ppdev->hDriver = hDriver;

    // Get the current screen mode information.  Set up device caps and
    // devinfo:

    if (!bInitializeModeFields(ppdev, (GDIINFO*) pdevcaps, pdi, pdm))
    {
        DISPDBG((0, "DrvEnablePDEV - Failed bInitializeModeFields"));
        goto ReturnFailure1;
    }

    // Initialize palette information.

    if (!bInitializePalette(ppdev, pdi))
    {
        DISPDBG((0, "DrvEnablePDEV - Failed bInitializePalette"));
        goto ReturnFailure1;
    }

    return((DHPDEV) ppdev);

ReturnFailure1:
    DrvDisablePDEV((DHPDEV) ppdev);

ReturnFailure0:
    DISPDBG((0, "Failed DrvEnablePDEV"));

    return(0);
}

/******************************Public*Routine******************************\
* DrvDisablePDEV
*
* Release the resources allocated in DrvEnablePDEV.  If a surface has been
* enabled DrvDisableSurface will have already been called.
*
* Note: In an error, we may call this before DrvEnablePDEV is done.
*
\**************************************************************************/

VOID DrvDisablePDEV(
DHPDEV  dhpdev)
{
    PDEV*   ppdev;

    ppdev = (PDEV*) dhpdev;

    vUninitializePalette(ppdev);
    EngFreeMem(ppdev);
}

/******************************Public*Routine******************************\
* VOID DrvCompletePDEV
*
* Store the HPDEV, the engines handle for this PDEV, in the DHPDEV.
*
\**************************************************************************/

VOID DrvCompletePDEV(
DHPDEV dhpdev,
HDEV   hdev)
{
    ((PDEV*) dhpdev)->hdevEng = hdev;
}

/******************************Public*Routine******************************\
* HSURF DrvEnableSurface
*
* Creates the drawing surface, initializes the hardware, and initializes
* driver components.  This function is called after DrvEnablePDEV, and
* performs the final device initialization.
*
\**************************************************************************/

HSURF DrvEnableSurface(
DHPDEV dhpdev)
{
    PDEV*       ppdev;
    HSURF       hsurfShadow;
    HSURF       hsurfDevice;
    SIZEL       sizl;
    SURFOBJ*    psoShadow;

    ppdev = (PDEV*) dhpdev;

    /////////////////////////////////////////////////////////////////////
    // Have GDI create the actual SURFOBJ.
    //
    // Our drawing surface is going to be 'device-managed', meaning that
    // GDI cannot draw on the framebuffer bits directly, and as such we
    // create the surface via EngCreateSurface.  By doing this, we ensure
    // that GDI will only ever access the bitmaps bits via the Drv calls
    // that we've HOOKed.

    sizl.cx = ppdev->cxScreen;
    sizl.cy = ppdev->cyScreen;

    hsurfDevice = EngCreateDeviceSurface(NULL, sizl, ppdev->iBitmapFormat);
    if (hsurfDevice == 0)
    {
        DISPDBG((0, "DrvEnableSurface - Failed EngCreateSurface"));
        goto ReturnFailure;
    }

    ppdev->hsurfScreen = hsurfDevice;       // Remember it for clean-up

    /////////////////////////////////////////////////////////////////////
    // Now associate the surface and the PDEV.
    //
    // We have to associate the surface we just created with our physical
    // device so that GDI can get information related to the PDEV when
    // it's drawing to the surface (such as, for example, the length of
    // styles on the device when simulating styled lines).
    //

    if (!EngAssociateSurface(hsurfDevice, ppdev->hdevEng, ppdev->flHooks))
    {
        DISPDBG((0, "DrvEnableSurface - Failed EngAssociateSurface"));
        goto ReturnFailure;
    }

    // Since we are employing a shadow buffer, we can fake out DirectDraw
    // and indicate that we have more flip surfaces in our shadow buffer
    // than we do on the physical device.  However, we need room for at
    // least two physical flip surfaces on the device to do this; at 320x480,
    // there's enough physical video memory for only one flip surface, so
    // we have to tell DirectDraw that we don't have any off-screen memory,
    // and so can't do any flips:

    ppdev->cxMemory = ppdev->cxScreen;
    ppdev->cyMemory = ppdev->cyScreen;
    if (ppdev->cyScreen <= 400)
    {
        ppdev->cyMemory *= NUM_FLIP_BUFFERS;
    }

    // Create the 8bpp DIB on which we'll have GDI do all the drawing.
    // We'll merely occasionally blt portions to the screen to update.

    sizl.cy = ppdev->cyMemory;
    sizl.cx = ppdev->cxMemory;

    // We allocate a kernel-mode section so that we can map a view of the
    // frame buffer bitmap into user-mode for use with DirectDraw:

    hsurfShadow = (HSURF) EngCreateBitmap(sizl,
                                          sizl.cx,
                                          ppdev->iBitmapFormat,
                                          BMF_KMSECTION | BMF_TOPDOWN,
                                          NULL);
    if (hsurfShadow == 0)
        goto ReturnFailure;

    psoShadow = EngLockSurface(hsurfShadow);
    if (psoShadow == NULL)
        goto ReturnFailure;

    ppdev->lScreenDelta = sizl.cx;
    ppdev->pjScreen     = psoShadow->pvScan0;
    ppdev->pso          = psoShadow;

    ASSERTDD(psoShadow->pvScan0 == psoShadow->pvBits,
        "We'll be assuming in DirectDraw that the bitmap is bottom-up");

    if (!EngAssociateSurface(hsurfShadow, ppdev->hdevEng, 0))
    {
        DISPDBG((0, "DrvEnableSurface - Failed second EngAssociateSurface"));
        goto ReturnFailure;
    }

    /////////////////////////////////////////////////////////////////////
    // Now enable all the subcomponents.
    //
    // Note that the order in which these 'Enable' functions are called
    // may be significant in low off-screen memory conditions, because
    // the off-screen heap manager may fail some of the later
    // allocations...

    if (!bEnableHardware(ppdev))
        goto ReturnFailure;

    if (!bEnablePalette(ppdev))
        goto ReturnFailure;

    if (!bEnableDirectDraw(ppdev))
        goto ReturnFailure;

    DISPDBG((5, "Passed DrvEnableSurface"));

    return(hsurfDevice);

ReturnFailure:
    DrvDisableSurface((DHPDEV) ppdev);

    DISPDBG((0, "Failed DrvEnableSurface"));

    return(0);
}

/******************************Public*Routine******************************\
* VOID DrvDisableSurface
*
* Free resources allocated by DrvEnableSurface.  Release the surface.
*
* Note: In an error case, we may call this before DrvEnableSurface is
*       completely done.
*
\**************************************************************************/

VOID DrvDisableSurface(
DHPDEV dhpdev)
{
    PDEV*   ppdev;
    HSURF   hsurf;

    ppdev = (PDEV*) dhpdev;

    // Note: In an error case, some of the following relies on the
    //       fact that the PDEV is zero-initialized, so fields like
    //       'hsurfScreen' will be zero unless the surface has been
    //       sucessfully initialized, and makes the assumption that
    //       EngDeleteSurface can take '0' as a parameter.

    vDisableDirectDraw(ppdev);
    vDisablePalette(ppdev);
    vDisableHardware(ppdev);

    if (ppdev->pso) {
        hsurf = ppdev->pso->hsurf;

        EngUnlockSurface(ppdev->pso);
        EngDeleteSurface(hsurf);
    }

    EngDeleteSurface(ppdev->hsurfScreen);
}

/******************************Public*Routine******************************\
* VOID DrvAssertMode
*
* This asks the device to reset itself to the mode of the pdev passed in.
*
\**************************************************************************/

BOOL DrvAssertMode(
DHPDEV  dhpdev,
BOOL    bEnable)
{
    PDEV* ppdev;

    ppdev = (PDEV*) dhpdev;

    if (!bEnable)
    {
        //////////////////////////////////////////////////////////////
        // Disable - Switch to full-screen mode

        vAssertModeDirectDraw(ppdev, FALSE);

        vAssertModePalette(ppdev, FALSE);

        if (bAssertModeHardware(ppdev, FALSE))
        {
            return(TRUE);
        }

        vAssertModeDirectDraw(ppdev, TRUE);
    }
    else
    {
        //////////////////////////////////////////////////////////////
        // Enable - Switch back to graphics mode

        // We have to enable every subcomponent in the reverse order
        // in which it was disabled:

        if (bAssertModeHardware(ppdev, TRUE))
        {
            vAssertModePalette(ppdev, TRUE);

            vAssertModeDirectDraw(ppdev, TRUE);

            return(TRUE);
        }
    }

    return(FALSE);
}

/******************************Public*Routine******************************\
* ULONG DrvGetModes
*
* Returns the list of available modes for the device.
*
\**************************************************************************/

ULONG DrvGetModes(
HANDLE      hDriver,
ULONG       cjSize,
DEVMODEW*   pdm)
{
    DWORD cModes;
    DWORD cbOutputSize;
    PVIDEO_MODE_INFORMATION pVideoModeInformation;
    PVIDEO_MODE_INFORMATION pVideoTemp;
    DWORD cOutputModes = cjSize / (sizeof(DEVMODEW) + DRIVER_EXTRA_SIZE);
    DWORD cbModeSize;

    cModes = getAvailableModes(hDriver,
                            (PVIDEO_MODE_INFORMATION *) &pVideoModeInformation,
                            &cbModeSize);
    if (cModes == 0)
    {
        DISPDBG((0, "DrvGetModes failed to get mode information"));
        return(0);
    }

    if (pdm == NULL)
    {
        cbOutputSize = cModes * (sizeof(DEVMODEW) + DRIVER_EXTRA_SIZE);
    }
    else
    {
        //
        // Now copy the information for the supported modes back into the
        // output buffer
        //

        cbOutputSize = 0;

        pVideoTemp = pVideoModeInformation;

        do
        {
            if (pVideoTemp->Length != 0)
            {
                if (cOutputModes == 0)
                {
                    break;
                }

                //
                // Zero the entire structure to start off with.
                //

                memset(pdm, 0, sizeof(DEVMODEW));

                //
                // Set the name of the device to the name of the DLL.
                //

                memcpy(pdm->dmDeviceName, DLL_NAME, sizeof(DLL_NAME));

                pdm->dmSpecVersion      = DM_SPECVERSION;
                pdm->dmDriverVersion    = DM_SPECVERSION;
                pdm->dmSize             = sizeof(DEVMODEW);
                pdm->dmDriverExtra      = DRIVER_EXTRA_SIZE;

                pdm->dmBitsPerPel       = pVideoTemp->NumberOfPlanes *
                                          pVideoTemp->BitsPerPlane;
                pdm->dmPelsWidth        = pVideoTemp->VisScreenWidth;
                pdm->dmPelsHeight       = pVideoTemp->VisScreenHeight;
                pdm->dmDisplayFrequency = pVideoTemp->Frequency;
                pdm->dmDisplayFlags     = 0;

                pdm->dmFields           = DM_BITSPERPEL       |
                                          DM_PELSWIDTH        |
                                          DM_PELSHEIGHT       |
                                          DM_DISPLAYFREQUENCY |
                                          DM_DISPLAYFLAGS     ;

                //
                // Go to the next DEVMODE entry in the buffer.
                //

                cOutputModes--;

                pdm = (LPDEVMODEW) ( ((ULONG_PTR)pdm) + sizeof(DEVMODEW)
                                                     + DRIVER_EXTRA_SIZE);

                cbOutputSize += (sizeof(DEVMODEW) + DRIVER_EXTRA_SIZE);

            }

            pVideoTemp = (PVIDEO_MODE_INFORMATION)
                (((PUCHAR)pVideoTemp) + cbModeSize);


        } while (--cModes);
    }

    EngFreeMem(pVideoModeInformation);

    return(cbOutputSize);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\modex\disp\color.c ===
/******************************Module*Header*******************************\
* Module Name: color.c
*
* This algorithm for color dithering is patent pending and its use is
* restricted to Microsoft products and drivers for Microsoft products.
* Use in non-Microsoft products or in drivers for non-Microsoft product is
* prohibited without written permission from Microsoft.
*
* The patent application is the primary reference for the operation of the
* color dithering code.
*
* Note that in the comments and variable names, "vertex" means "vertex of
* either the inner (half intensity) or outer (full intensity) color cube."
* Vertices map to colors 0-6 and 248-255 of the Windows standard (required)
* 256-color palette, where vertices 0-6 and 248 are the vertices of the inner
* color cube, and 0 plus 249-255 are the vertices of the full color cube.
* Vertex 7 is 75% gray; this could be used in the dither, but that would break
* apps that depend on the exact Windows 3.1 dithering. This code is Window 3.1
* compatible.
*
* Copyright (c) 1992 Microsoft Corporation
\**************************************************************************/

#include "precomp.h"

/**************************************************************************\
* This function takes a value from 0 - 255 and uses it to create an
* 8x8 pile of bits in the form of a 1BPP bitmap.  It can also take an
* RGB value and make an 8x8 bitmap.  These can then be used as brushes
* to simulate color unavaible on the device.
*
* For monochrome the basic algorithm is equivalent to turning on bits
* in the 8x8 array according to the following order:
*
*  00 32 08 40 02 34 10 42
*  48 16 56 24 50 18 58 26
*  12 44 04 36 14 46 06 38
*  60 28 52 20 62 30 54 22
*  03 35 11 43 01 33 09 41
*  51 19 59 27 49 17 57 25
*  15 47 07 39 13 45 05 37
*  63 31 55 23 61 29 53 21
*
* Reference: A Survey of Techniques for the Display of Continous
*            Tone Pictures on Bilevel Displays,;
*            Jarvis, Judice, & Ninke;
*            COMPUTER GRAPHICS AND IMAGE PROCESSING 5, pp 13-40, (1976)
\**************************************************************************/

#define SWAP_RB 0x00000004
#define SWAP_GB 0x00000002
#define SWAP_RG 0x00000001

#define SWAPTHEM(a,b) (ulTemp = a, a = b, b = ulTemp)

// PATTERNSIZE is the number of pixels in a dither pattern.
#define PATTERNSIZE 64

typedef union _PAL_ULONG {
    PALETTEENTRY pal;
    ULONG ul;
} PAL_ULONG;

typedef struct _VERTEX_DATA {
    ULONG ulCount;  // # of pixels in this vertex
    ULONG ulVertex; // vertex #
} VERTEX_DATA;

// Tells which row to turn a pel on in when dithering for monochrome bitmaps.
static BYTE ajByte[] = {
    0, 4, 0, 4, 2, 6, 2, 6,
    0, 4, 0, 4, 2, 6, 2, 6,
    1, 5, 1, 5, 3, 7, 3, 7,
    1, 5, 1, 5, 3, 7, 3, 7,
    0, 4, 0, 4, 2, 6, 2, 6,
    0, 4, 0, 4, 2, 6, 2, 6,
    1, 5, 1, 5, 3, 7, 3, 7,
    1, 5, 1, 5, 3, 7, 3, 7
};

// The array of monochrome bits used for monc
static BYTE ajBits[] = {
    0x80, 0x08, 0x08, 0x80, 0x20, 0x02, 0x02, 0x20,
    0x20, 0x02, 0x02, 0x20, 0x80, 0x08, 0x08, 0x80,
    0x40, 0x04, 0x04, 0x40, 0x10, 0x01, 0x01, 0x10,
    0x10, 0x01, 0x01, 0x10, 0x40, 0x04, 0x04, 0x40,
    0x40, 0x04, 0x04, 0x40, 0x10, 0x01, 0x01, 0x10,
    0x10, 0x01, 0x01, 0x10, 0x40, 0x04, 0x04, 0x40,
    0x80, 0x08, 0x08, 0x80, 0x20, 0x02, 0x02, 0x20,
    0x20, 0x02, 0x02, 0x20, 0x80, 0x08, 0x08, 0x80
};

// Translates vertices back to the original subspace. Each row is a subspace,
// as encoded in ulSymmetry, and each column is a vertex between 0 and 15.
BYTE jSwapSubSpace[8*16] = {
    0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,
    0, 2, 1, 3, 4, 6, 5, 7, 8, 10, 9, 11, 12, 14, 13, 15,
    0, 1, 4, 5, 2, 3, 6, 7, 8, 9, 12, 13, 10, 11, 14, 15,
    0, 4, 1, 5, 2, 6, 3, 7, 8, 12, 9, 13, 10, 14, 11, 15,
    0, 4, 2, 6, 1, 5, 3, 7, 8, 12, 10, 14, 9, 13, 11, 15,
    0, 2, 4, 6, 1, 3, 5, 7, 8, 10, 12, 14, 9, 11, 13, 15,
    0, 4, 1, 5, 2, 6, 3, 7, 8, 12, 9, 13, 10, 14, 11, 15,
    0, 1, 4, 5, 2, 3, 6, 7, 8, 9, 12, 13, 10, 11, 14, 15,
};

// Converts a nibble value in the range 0-15 to a dword value containing the
// nibble value packed 8 times.
ULONG ulNibbleToDwordWithConvert[16] = {
    0x00000000,
    0x01010101,
    0x02020202,
    0x03030303,
    0x04040404,
    0x05050505,
    0x06060606,
    0xF8F8F8F8,
    0x07070707,
    0xF9F9F9F9,
    0xFAFAFAFA,
    0xFBFBFBFB,
    0xFCFCFCFC,
    0xFDFDFDFD,
    0xFEFEFEFE,
    0xFFFFFFFF
};

// Specifies where in the dither pattern colors should be placed in order
// of increasing intensity.
ULONG aulDitherOrder[] = {
  0, 36,  4, 32, 18, 54, 22, 50,
  2, 38,  6, 34, 16, 52, 20, 48,
  9, 45, 13, 41, 27, 63, 31, 59,
 11, 47, 15, 43, 25, 61, 29, 57,
  1, 37,  5, 33, 19, 55, 23, 51,
  3, 39,  7, 35, 17, 53, 21, 49,
  8, 44, 12, 40, 26, 62, 30, 58,
 10, 46, 14, 42, 24, 60, 28, 56,
};

// Array to convert to 256 color from 16 color. Maps from index that represents
// a 16-color vertex (color) to value that specifies the color index in the
// 256-color palette.

BYTE ajConvert[] =
{
    0,
    1,
    2,
    3,
    4,
    5,
    6,
    248,
    7,
    249,
    250,
    251,
    252,
    253,
    254,
    255
};

/******************************Public*Routine******************************\
* DrvDitherColor
*
* Dithers an RGB color to an 8X8 approximation using the reserved VGA colors
*
\**************************************************************************/

ULONG DrvDitherColor(
IN  DHPDEV dhpdev,
IN  ULONG  iMode,
IN  ULONG  rgb,
OUT ULONG *pul)
{
    ULONG   ulGrey, ulRed, ulGre, ulBlu, ulSymmetry;
    ULONG   ulRedTemp, ulGreenTemp, ulBlueTemp, ulTemp;
    VERTEX_DATA vVertexData[4];
    VERTEX_DATA *pvVertexData;
    VERTEX_DATA *pvVertexDataEnd;
    ULONG  *pulDitherOrder;
    ULONG   ulNumPixels;
    BYTE    jColor;
    ULONG   ulColor;
    VERTEX_DATA *pvMaxVertex;
    ULONG   ulVertex0Temp, ulVertex1Temp, ulVertex2Temp, ulVertex3Temp;
    BYTE   *pjDither = (BYTE *)pul;

    // Figure out if we need a full color dither or only a monochrome dither
    if (iMode != DM_MONOCHROME) {

        // Full color dither

        // Split the color into red, green, and blue components
        ulRedTemp   = ((PAL_ULONG *)&rgb)->pal.peRed;
        ulGreenTemp   = ((PAL_ULONG *)&rgb)->pal.peGreen;
        ulBlueTemp   = ((PAL_ULONG *)&rgb)->pal.peBlue;

        // Sort the RGB so that the point is transformed into subspace 0, and
        // keep track of the swaps in ulSymmetry so we can unravel it again
        // later.  We want r >= g >= b (subspace 0).
        ulSymmetry = 0;
        if (ulBlueTemp > ulRedTemp) {
            SWAPTHEM(ulBlueTemp,ulRedTemp);
            ulSymmetry = SWAP_RB;
        }

        if (ulBlueTemp > ulGreenTemp) {
            SWAPTHEM(ulBlueTemp,ulGreenTemp);
            ulSymmetry |= SWAP_GB;
        }

        if (ulGreenTemp > ulRedTemp) {
            SWAPTHEM(ulGreenTemp,ulRedTemp);
            ulSymmetry |= SWAP_RG;
        }

        ulSymmetry <<= 4;   // for lookup purposes

        // Scale the values from 0-255 to 0-64. Note that the scaling is not
        // symmetric at the ends; this is done to match Windows 3.1 dithering
        ulRed = (ulRedTemp + 1) >> 2;
        ulGre = (ulGreenTemp + 1) >> 2;
        ulBlu = (ulBlueTemp + 1) >> 2;

        // Compute the subsubspace within subspace 0 in which the point lies,
        // then calculate the # of pixels to dither in the colors that are the
        // four vertexes of the tetrahedron bounding the color we're emulating.
        // Only vertices with more than zero pixels are stored, and the
        // vertices are stored in order of increasing intensity, saving us the
        // need to sort them later
        if ((ulRedTemp + ulGreenTemp) > 256) {
            // Subsubspace 2 or 3
            if ((ulRedTemp + ulBlueTemp) > 256) {
                // Subsubspace 3
                // Calculate the number of pixels per vertex, still in
                // subsubspace 3, then convert to original subspace. The pixel
                // counts and vertex numbers are matching pairs, stored in
                // ascending intensity order, skipping vertices with zero
                // pixels. The vertex intensity order for subsubspace 3 is:
                // 7, 9, 0x0B, 0x0F
                pvVertexData = vVertexData;
                if ((ulVertex0Temp = (64 - ulRed) << 1) != 0) {
                    pvVertexData->ulCount = ulVertex0Temp;
                    pvVertexData++->ulVertex = jSwapSubSpace[ulSymmetry + 0x07];
                }
                ulVertex2Temp = ulGre - ulBlu;
                ulVertex3Temp = (ulRed - 64) + ulBlu;
                if ((ulVertex1Temp = ((PATTERNSIZE - ulVertex0Temp) -
                        ulVertex2Temp) - ulVertex3Temp) != 0) {
                    pvVertexData->ulCount = ulVertex1Temp;
                    pvVertexData++->ulVertex = jSwapSubSpace[ulSymmetry + 0x09];
                }
                if (ulVertex2Temp != 0) {
                    pvVertexData->ulCount = ulVertex2Temp;
                    pvVertexData++->ulVertex = jSwapSubSpace[ulSymmetry + 0x0B];
                }
                if (ulVertex3Temp != 0) {
                    pvVertexData->ulCount = ulVertex3Temp;
                    pvVertexData++->ulVertex = jSwapSubSpace[ulSymmetry + 0x0F];
                }
            } else {
                // Subsubspace 2
                // Calculate the number of pixels per vertex, still in
                // subsubspace 2, then convert to original subspace. The pixel
                // counts and vertex numbers are matching pairs, stored in
                // ascending intensity order, skipping vertices with zero
                // pixels. The vertex intensity order for subsubspace 2 is:
                // 3, 7, 9, 0x0B
                pvVertexData = vVertexData;
                ulVertex1Temp = ulBlu << 1;
                ulVertex2Temp = ulRed - ulGre;
                ulVertex3Temp = (ulRed - 32) + (ulGre - 32);
                if ((ulVertex0Temp = ((PATTERNSIZE - ulVertex1Temp) -
                            ulVertex2Temp) - ulVertex3Temp) != 0) {
                    pvVertexData->ulCount = ulVertex0Temp;
                    pvVertexData++->ulVertex = jSwapSubSpace[ulSymmetry + 0x03];
                }
                if (ulVertex1Temp != 0) {
                    pvVertexData->ulCount = ulVertex1Temp;
                    pvVertexData++->ulVertex = jSwapSubSpace[ulSymmetry + 0x07];
                }
                if (ulVertex2Temp != 0) {
                    pvVertexData->ulCount = ulVertex2Temp;
                    pvVertexData++->ulVertex = jSwapSubSpace[ulSymmetry + 0x09];
                }
                if (ulVertex3Temp != 0) {
                    pvVertexData->ulCount = ulVertex3Temp;
                    pvVertexData++->ulVertex = jSwapSubSpace[ulSymmetry + 0x0B];
                }
            }
        } else {
            // Subsubspace 0 or 1
            if (ulRedTemp > 128) {
                // Subsubspace 1
                // Calculate the number of pixels per vertex, still in
                // subsubspace 1, then convert to original subspace. The pixel
                // counts and vertex numbers are matching pairs, stored in
                // ascending intensity order, skipping vertices with zero
                // pixels. The vertex intensity order for subsubspace 1 is:
                // 1, 3, 7, 9
                pvVertexData = vVertexData;
                if ((ulVertex0Temp = ((32 - ulGre) + (32 - ulRed)) << 1) != 0) {
                    pvVertexData->ulCount = ulVertex0Temp;
                    pvVertexData++->ulVertex = jSwapSubSpace[ulSymmetry + 0x01];
                }
                ulVertex2Temp = ulBlu << 1;
                ulVertex3Temp = (ulRed - 32) << 1;
                if ((ulVertex1Temp = ((PATTERNSIZE - ulVertex0Temp) -
                        ulVertex2Temp) - ulVertex3Temp) != 0) {
                    pvVertexData->ulCount = ulVertex1Temp;
                    pvVertexData++->ulVertex = jSwapSubSpace[ulSymmetry + 0x03];
                }
                if (ulVertex2Temp != 0) {
                    pvVertexData->ulCount = ulVertex2Temp;
                    pvVertexData++->ulVertex = jSwapSubSpace[ulSymmetry + 0x07];
                }
                if (ulVertex3Temp != 0) {
                    pvVertexData->ulCount = ulVertex3Temp;
                    pvVertexData++->ulVertex = jSwapSubSpace[ulSymmetry + 0x09];
                }
            } else {
                // Subsubspace 0
                // Calculate the number of pixels per vertex, still in
                // subsubspace 0, then convert to original subspace. The pixel
                // counts and vertex numbers are matching pairs, stored in
                // ascending intensity order, skipping vertices with zero
                // pixels. The vertex intensity order for subsubspace 0 is:
                // 0, 1, 3, 7
                pvVertexData = vVertexData;
                if ((ulVertex0Temp = (32 - ulRed) << 1) != 0) {
                    pvVertexData->ulCount = ulVertex0Temp;
                    pvVertexData++->ulVertex = jSwapSubSpace[ulSymmetry + 0x00];
                }
                if ((ulVertex1Temp = (ulRed - ulGre) << 1) != 0) {
                    pvVertexData->ulCount = ulVertex1Temp;
                    pvVertexData++->ulVertex = jSwapSubSpace[ulSymmetry + 0x01];
                }
                ulVertex3Temp = ulBlu << 1;
                if ((ulVertex2Temp = ((PATTERNSIZE - ulVertex0Temp) -
                        ulVertex1Temp) - ulVertex3Temp) != 0) {
                    pvVertexData->ulCount = ulVertex2Temp;
                    pvVertexData++->ulVertex = jSwapSubSpace[ulSymmetry + 0x03];
                }
                if (ulVertex3Temp != 0) {
                    pvVertexData->ulCount = ulVertex3Temp;
                    pvVertexData++->ulVertex = jSwapSubSpace[ulSymmetry + 0x07];
                }
            }
        }

        // Now that we have found the bounding vertices and the number of
        // pixels to dither for each vertex, we can create the dither pattern

        // Handle 1, 2, and 3 & 4 vertices per dither separately
        ulTemp = (ULONG)(pvVertexData - vVertexData); // # of vertices with more than
                                                // zero pixels
        if (ulTemp > 2) {

            // There are 3 or 4 vertices in this dither

            if (ulTemp == 3) {

                // There are 3 vertices in this dither

                // Find the vertex with the most pixels, and fill the whole
                // destination bitmap with that vertex's color, which is faster
                // than dithering it
                if (vVertexData[1].ulCount >= vVertexData[2].ulCount) {
                    pvMaxVertex = &vVertexData[1];
                    ulTemp = vVertexData[1].ulCount;
                } else {
                    pvMaxVertex = &vVertexData[2];
                    ulTemp = vVertexData[2].ulCount;
                }

            } else {

                // There are 4 vertices in this dither

                // Find the vertex with the most pixels, and fill the whole
                // destination bitmap with that vertex's color, which is faster
                // than dithering it
                if (vVertexData[2].ulCount >= vVertexData[3].ulCount) {
                    pvMaxVertex = &vVertexData[2];
                    ulTemp = vVertexData[2].ulCount;
                } else {
                    pvMaxVertex = &vVertexData[3];
                    ulTemp = vVertexData[3].ulCount;
                }
            }

            if (vVertexData[1].ulCount > ulTemp) {
                pvMaxVertex = &vVertexData[1];
                ulTemp = vVertexData[1].ulCount;
            }
            if (vVertexData[0].ulCount > ulTemp) {
                pvMaxVertex = &vVertexData[0];
            }

            pvVertexDataEnd = pvVertexData;

            // Prepare a dword version of the most common vertex number (color)
            ulColor = ulNibbleToDwordWithConvert[pvMaxVertex->ulVertex];

            // Mark that the vertex we're about to do doesn't need to be done
            // later
            pvMaxVertex->ulVertex = 0xFF;

            // Block fill the dither pattern with the more common vertex
            *pul = ulColor;
            *(pul+1) = ulColor;
            *(pul+2) = ulColor;
            *(pul+3) = ulColor;
            *(pul+4) = ulColor;
            *(pul+5) = ulColor;
            *(pul+6) = ulColor;
            *(pul+7) = ulColor;
            *(pul+8) = ulColor;
            *(pul+9) = ulColor;
            *(pul+10) = ulColor;
            *(pul+11) = ulColor;
            *(pul+12) = ulColor;
            *(pul+13) = ulColor;
            *(pul+14) = ulColor;
            *(pul+15) = ulColor;

            // Now dither all the remaining vertices in order 0->2 or 0->3
            // (in order of increasing intensity)
            pulDitherOrder = aulDitherOrder;
            pvVertexData = vVertexData;
            do {
                if (pvVertexData->ulVertex == 0xFF) {
                    // This is the max vertex, which we already did, but we
                    // have to account for it in the dither order
                    pulDitherOrder += pvVertexData->ulCount;
                } else {
                    jColor = ajConvert[pvVertexData->ulVertex];
                    ulNumPixels = pvVertexData->ulCount;
                    switch (ulNumPixels & 3) {
                        case 3:
                            pjDither[*(pulDitherOrder+2)] = jColor;
                        case 2:
                            pjDither[*(pulDitherOrder+1)] = jColor;
                        case 1:
                            pjDither[*(pulDitherOrder+0)] = jColor;
                            pulDitherOrder += ulNumPixels & 3;
                        case 0:
                            break;
                    }
                    if ((ulNumPixels >>= 2) != 0) {
                        do {
                            pjDither[*pulDitherOrder] = jColor;
                            pjDither[*(pulDitherOrder+1)] = jColor;
                            pjDither[*(pulDitherOrder+2)] = jColor;
                            pjDither[*(pulDitherOrder+3)] = jColor;
                            pulDitherOrder += 4;
                        } while (--ulNumPixels);
                    }
                }
            } while (++pvVertexData < pvVertexDataEnd);

        } else if (ulTemp == 2) {

            // There are exactly two vertices with more than zero pixels; fill
            // in the dither array as follows: block fill with vertex with more
            // points first, then dither in the other vertex
            if (vVertexData[0].ulCount >= vVertexData[1].ulCount) {
                // There are no more vertex 1 than vertex 0 pixels, so do
                // the block fill with vertex 0
                ulColor = ulNibbleToDwordWithConvert[vVertexData[0].ulVertex];
                // Do the dither with vertex 1
                jColor = ajConvert[vVertexData[1].ulVertex];
                ulNumPixels = vVertexData[1].ulCount;
                // Set where to start dithering with vertex 1 (vertex 0 is
                // lower intensity, so its pixels come first in the dither
                // order)
                pulDitherOrder = aulDitherOrder + vVertexData[0].ulCount;
            } else {
                // There are more vertex 1 pixels, so do the block fill
                // with vertex 1
                ulColor = ulNibbleToDwordWithConvert[vVertexData[1].ulVertex];
                // Do the dither with vertex 0
                jColor = ajConvert[vVertexData[0].ulVertex];
                ulNumPixels = vVertexData[0].ulCount;
                // Set where to start dithering with vertex 0 (vertex 0 is
                // lower intensity, so its pixels come first in the dither
                // order)
                pulDitherOrder = aulDitherOrder;
            }

            // Block fill the dither pattern with the more common vertex
            *pul = ulColor;
            *(pul+1) = ulColor;
            *(pul+2) = ulColor;
            *(pul+3) = ulColor;
            *(pul+4) = ulColor;
            *(pul+5) = ulColor;
            *(pul+6) = ulColor;
            *(pul+7) = ulColor;
            *(pul+8) = ulColor;
            *(pul+9) = ulColor;
            *(pul+10) = ulColor;
            *(pul+11) = ulColor;
            *(pul+12) = ulColor;
            *(pul+13) = ulColor;
            *(pul+14) = ulColor;
            *(pul+15) = ulColor;

            // Dither in the less common vertex
            switch (ulNumPixels & 3) {
                case 3:
                    pjDither[*(pulDitherOrder+2)] = jColor;
                case 2:
                    pjDither[*(pulDitherOrder+1)] = jColor;
                case 1:
                    pjDither[*(pulDitherOrder+0)] = jColor;
                    pulDitherOrder += ulNumPixels & 3;
                case 0:
                    break;
            }
            if ((ulNumPixels >>= 2) != 0) {
                do {
                    pjDither[*pulDitherOrder] = jColor;
                    pjDither[*(pulDitherOrder+1)] = jColor;
                    pjDither[*(pulDitherOrder+2)] = jColor;
                    pjDither[*(pulDitherOrder+3)] = jColor;
                    pulDitherOrder += 4;
                } while (--ulNumPixels);
            }

        } else {

            // There is only one vertex in this dither

            // No sorting or dithering is needed for just one color; we can
            // just generate the final DIB directly
            ulColor = ulNibbleToDwordWithConvert[vVertexData[0].ulVertex];
            *pul = ulColor;
            *(pul+1) = ulColor;
            *(pul+2) = ulColor;
            *(pul+3) = ulColor;
            *(pul+4) = ulColor;
            *(pul+5) = ulColor;
            *(pul+6) = ulColor;
            *(pul+7) = ulColor;
            *(pul+8) = ulColor;
            *(pul+9) = ulColor;
            *(pul+10) = ulColor;
            *(pul+11) = ulColor;
            *(pul+12) = ulColor;
            *(pul+13) = ulColor;
            *(pul+14) = ulColor;
            *(pul+15) = ulColor;
        }

    } else {

        // For monochrome we will only use the Intensity (grey level)
        RtlFillMemory((PVOID) pul, PATTERNSIZE/2, 0);  // zero the dither bits

        ulRed   = (ULONG) ((PALETTEENTRY *) &rgb)->peRed;
        ulGre = (ULONG) ((PALETTEENTRY *) &rgb)->peGreen;
        ulBlu  = (ULONG) ((PALETTEENTRY *) &rgb)->peBlue;

        // I = .30R + .59G + .11B
        // For convience the following ratios are used:
        //
        //  77/256 = 30.08%
        // 151/256 = 58.98%
        //  28/256 = 10.94%

        ulGrey  = (((ulRed * 77) + (ulGre * 151) + (ulBlu * 28)) >> 8) & 255;

        // Convert the RGBI from 0-255 to 0-64 notation.

        ulGrey = (ulGrey + 1) >> 2;

        while(ulGrey) {
            ulGrey--;
            pul[ajByte[ulGrey]] |= ((ULONG) ajBits[ulGrey]);
        }
    }

    return(DCR_DRIVER);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\modex\disp\debug.c ===
/******************************Module*Header*******************************\
* Module Name: debug.c
*
* debug helpers routine
*
* Copyright (c) 1992-1995 Microsoft Corporation
*
\**************************************************************************/

#include "precomp.h"

#if DBG

ULONG DebugLevel = 0;

/*****************************************************************************
 *
 *   Routine Description:
 *
 *      This function is variable-argument, level-sensitive debug print
 *      routine.
 *      If the specified debug level for the print statement is lower or equal
 *      to the current debug level, the message will be printed.
 *
 *   Arguments:
 *
 *      DebugPrintLevel - Specifies at which debugging level the string should
 *          be printed
 *
 *      DebugMessage - Variable argument ascii c string
 *
 *   Return Value:
 *
 *      None.
 *
 ***************************************************************************/

VOID
DebugPrint(
    ULONG DebugPrintLevel,
    PCHAR DebugMessage,
    ...
    )

{

    va_list ap;

    va_start(ap, DebugMessage);

    if (DebugPrintLevel <= DebugLevel)
    {
        EngDebugPrint(STANDARD_DEBUG_PREFIX, DebugMessage, ap);
        EngDebugPrint("", "\n", ap);
    }

    va_end(ap);

}

#endif  // DBG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\modex\disp\ddraw.c ===
/******************************Module*Header*******************************\
* Module Name: ddraw.c
*
* Implements all the DirectDraw components for the driver.
*
* Copyright (c) 1995-1996 Microsoft Corporation
\**************************************************************************/

#include "precomp.h"

#define VBLANK_IS_ACTIVE(pjBase) \
    (READ_PORT_UCHAR(pjBase + VGA_BASE + IN_STAT_1) & 0x8)

#define DISPLAY_IS_ACTIVE(pjBase) \
    (!(READ_PORT_UCHAR(pjBase + VGA_BASE + IN_STAT_1) & 0x1))

#define START_ADDRESS_HIGH  0x0C        // Index for Frame Buffer Start

/******************************Public*Routine******************************\
* VOID vGetDisplayDuration
*
* Get the length, in EngQueryPerformanceCounter() ticks, of a refresh cycle.
*
* If we could trust the miniport to return back and accurate value for
* the refresh rate, we could use that.  Unfortunately, our miniport doesn't
* ensure that it's an accurate value.
*
\**************************************************************************/

#define NUM_VBLANKS_TO_MEASURE      1
#define NUM_MEASUREMENTS_TO_TAKE    8

VOID vGetDisplayDuration(
PDEV* ppdev)
{
    BYTE*       pjBase;
    LONG        i;
    LONG        j;
    LONGLONG    li;
    LONGLONG    liFrequency;
    LONGLONG    liMin;
    LONGLONG    aliMeasurement[NUM_MEASUREMENTS_TO_TAKE + 1];

    pjBase = ppdev->pjBase;

    memset(&ppdev->flipRecord, 0, sizeof(ppdev->flipRecord));

    // Warm up EngQUeryPerformanceCounter to make sure it's in the working
    // set:

    EngQueryPerformanceCounter(&li);

    // Unfortunately, since NT is a proper multitasking system, we can't
    // just disable interrupts to take an accurate reading.  We also can't
    // do anything so goofy as dynamically change our thread's priority to
    // real-time.
    //
    // So we just do a bunch of short measurements and take the minimum.
    //
    // It would be 'okay' if we got a result that's longer than the actual
    // VBlank cycle time -- nothing bad would happen except that the app
    // would run a little slower.  We don't want to get a result that's
    // shorter than the actual VBlank cycle time -- that could cause us
    // to start drawing over a frame before the Flip has occured.
    //
    // Skip a couple of vertical blanks to allow the hardware to settle
    // down after the mode change, to make our readings accurate:

    for (i = 2; i != 0; i--)
    {
        while (VBLANK_IS_ACTIVE(pjBase))
            ;
        while (!(VBLANK_IS_ACTIVE(pjBase)))
            ;
    }

    for (i = 0; i < NUM_MEASUREMENTS_TO_TAKE; i++)
    {
        // We're at the start of the VBlank active cycle!

        EngQueryPerformanceCounter(&aliMeasurement[i]);

        // Okay, so life in a multi-tasking environment isn't all that
        // simple.  What if we had taken a context switch just before
        // the above EngQueryPerformanceCounter call, and now were half
        // way through the VBlank inactive cycle?  Then we would measure
        // only half a VBlank cycle, which is obviously bad.  The worst
        // thing we can do is get a time shorter than the actual VBlank
        // cycle time.
        //
        // So we solve this by making sure we're in the VBlank active
        // time before and after we query the time.  If it's not, we'll
        // sync up to the next VBlank (it's okay to measure this period --
        // it will be guaranteed to be longer than the VBlank cycle and
        // will likely be thrown out when we select the minimum sample).
        // There's a chance that we'll take a context switch and return
        // just before the end of the active VBlank time -- meaning that
        // the actual measured time would be less than the true amount --
        // but since the VBlank is active less than 1% of the time, this
        // means that we would have a maximum of 1% error approximately
        // 1% of the times we take a context switch.  An acceptable risk.
        //
        // This next line will cause us wait if we're no longer in the
        // VBlank active cycle as we should be at this point:

        while (!(VBLANK_IS_ACTIVE(pjBase)))
            ;

        for (j = 0; j < NUM_VBLANKS_TO_MEASURE; j++)
        {
            while (VBLANK_IS_ACTIVE(pjBase))
                ;
            while (!(VBLANK_IS_ACTIVE(pjBase)))
                ;
        }
    }

    EngQueryPerformanceCounter(&aliMeasurement[NUM_MEASUREMENTS_TO_TAKE]);

    // Use the minimum:

    liMin = aliMeasurement[1] - aliMeasurement[0];

    DISPDBG((1, "Refresh count: %li - %li", 1, (ULONG) liMin));

    for (i = 2; i <= NUM_MEASUREMENTS_TO_TAKE; i++)
    {
        li = aliMeasurement[i] - aliMeasurement[i - 1];

        DISPDBG((1, "               %li - %li", i, (ULONG) li));

        if (li < liMin)
            liMin = li;
    }


    // Round the result:

    ppdev->flipRecord.liFlipDuration
        = (DWORD) (liMin + (NUM_VBLANKS_TO_MEASURE / 2)) / NUM_VBLANKS_TO_MEASURE;
    ppdev->flipRecord.bFlipFlag  = FALSE;
    ppdev->flipRecord.fpFlipFrom = 0;

    // We need the refresh rate in Hz to query the S3 miniport about the
    // streams parameters:

    EngQueryPerformanceFrequency(&liFrequency);

    DISPDBG((1, "Frequency %li.%03li Hz",
        (ULONG) (EngQueryPerformanceFrequency(&li),
            li / ppdev->flipRecord.liFlipDuration),
        (ULONG) (EngQueryPerformanceFrequency(&li),
            ((li * 1000) / ppdev->flipRecord.liFlipDuration) % 1000)));
}

/******************************Public*Routine******************************\
* HRESULT ddrvalUpdateFlipStatus
*
* Checks and sees if the most recent flip has occurred.
*
* Unfortunately, the hardware has no ability to tell us whether a vertical
* retrace has occured since the flip command was given other than by
* sampling the vertical-blank-active and display-active status bits.
*
\**************************************************************************/

HRESULT ddrvalUpdateFlipStatus(
PDEV*   ppdev,
FLATPTR fpVidMem)
{
    BYTE*       pjBase;
    LONGLONG    liTime;

    pjBase = ppdev->pjBase;

    if ((ppdev->flipRecord.bFlipFlag) &&
        ((fpVidMem == (FLATPTR) -1) ||
         (fpVidMem == ppdev->flipRecord.fpFlipFrom)))
    {
        if (VBLANK_IS_ACTIVE(pjBase))
        {
            if (ppdev->flipRecord.bWasEverInDisplay)
            {
                ppdev->flipRecord.bHaveEverCrossedVBlank = TRUE;
            }
        }
        else if (DISPLAY_IS_ACTIVE(pjBase))
        {
            if (ppdev->flipRecord.bHaveEverCrossedVBlank)
            {
                ppdev->flipRecord.bFlipFlag = FALSE;
                return(DD_OK);
            }
            ppdev->flipRecord.bWasEverInDisplay = TRUE;
        }

        // It's pretty unlikely that we'll happen to sample the vertical-
        // blank-active at the first vertical blank after the flip command
        // has been given.  So to provide better results, we also check the
        // time elapsed since the flip.  If it's more than the duration of
        // one entire refresh of the display, then we know for sure it has
        // happened:

        EngQueryPerformanceCounter(&liTime);

        if (liTime - ppdev->flipRecord.liFlipTime
                                <= ppdev->flipRecord.liFlipDuration)
        {
            return(DDERR_WASSTILLDRAWING);
        }

        ppdev->flipRecord.bFlipFlag = FALSE;
    }

    return(DD_OK);
}

/******************************Public*Routine******************************\
* DWORD DdMapMemory
*
* This is a new DDI call specific to Windows NT that is used to map
* or unmap all the application modifiable portions of the frame buffer
* into the specified process's address space.
*
\**************************************************************************/

DWORD DdMapMemory(
PDD_MAPMEMORYDATA lpMapMemory)
{
    PDEV*   ppdev;

    ppdev = (PDEV*) lpMapMemory->lpDD->dhpdev;

    // By returning DDHAL_DRIVER_NOTHANDLED and setting 'bMap' to -1, we
    // have GDI take care of mapping the section that is our 'shadow buffer'
    // directly into the application's address space.  We tell GDI our kernel
    // mode address by sticking it in 'fpProcess':

    lpMapMemory->fpProcess = (FLATPTR) ppdev->pjScreen;
    lpMapMemory->bMap      = (BOOL) -1;

    return(DDHAL_DRIVER_NOTHANDLED);
}

/******************************Public*Routine******************************\
* DWORD DdWaitForVerticalBlank
*
*  3-Dec-1995 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

DWORD DdWaitForVerticalBlank(
PDD_WAITFORVERTICALBLANKDATA lpWaitForVerticalBlank)
{
    PDEV*   ppdev;
    BYTE*   pjBase;

    ppdev = (PDEV*) lpWaitForVerticalBlank->lpDD->dhpdev;
    pjBase = ppdev->pjBase;

    lpWaitForVerticalBlank->ddRVal = DD_OK;

    switch (lpWaitForVerticalBlank->dwFlags)
    {
    case DDWAITVB_I_TESTVB:
        lpWaitForVerticalBlank->bIsInVB = (VBLANK_IS_ACTIVE(pjBase) != 0);
        break;

    case DDWAITVB_BLOCKBEGIN:
        while (VBLANK_IS_ACTIVE(pjBase))
            ;
        while (!VBLANK_IS_ACTIVE(pjBase))
            ;
        break;

    case DDWAITVB_BLOCKEND:
        while (!VBLANK_IS_ACTIVE(pjBase))
            ;
        while (VBLANK_IS_ACTIVE(pjBase))
            ;
        break;
    }

    return(DDHAL_DRIVER_HANDLED);
}

/******************************Public*Routine******************************\
* DWORD DdLock
*
\**************************************************************************/

DWORD DdLock(
PDD_LOCKDATA lpLock)
{
    PDEV*               ppdev;
    DD_SURFACE_LOCAL*   lpSurfaceLocal;

    ppdev = (PDEV*) lpLock->lpDD->dhpdev;
    lpSurfaceLocal = lpLock->lpDDSurface;

    if (lpSurfaceLocal->ddsCaps.dwCaps & DDSCAPS_PRIMARYSURFACE)
    {
        // If the application is locking the currently visible flip
        // surface, remember the bounds of its lock so that we can
        // use it at Unlock time to update the physical display:

        ppdev->cLocks++;

        if ((ppdev->cLocks == 1) && (lpLock->bHasRect))
        {
            ppdev->rclLock = lpLock->rArea;
        }
        else
        {
            // If we were real keen, we would union the new area with
            // the old.  But we're not:

            ppdev->rclLock.top    = 0;
            ppdev->rclLock.left   = 0;
            ppdev->rclLock.right  = ppdev->cxScreen;
            ppdev->rclLock.bottom = ppdev->cyScreen;
        }
    }

    return(DDHAL_DRIVER_NOTHANDLED);
}

/******************************Public*Routine******************************\
* DWORD DdUnlock
*
*  3-Dec-1995 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

DWORD DdUnlock(
PDD_UNLOCKDATA lpUnlock)
{
    PDEV*               ppdev;
    DD_SURFACE_LOCAL*   lpSurfaceLocal;

    ppdev = (PDEV*) lpUnlock->lpDD->dhpdev;
    lpSurfaceLocal = lpUnlock->lpDDSurface;

    // If this flip buffer is visible, then we have to update the physical
    // screen with the shadow contents.

    if (lpSurfaceLocal->ddsCaps.dwCaps & DDSCAPS_PRIMARYSURFACE)
    {
        vUpdate(ppdev, &ppdev->rclLock, NULL);

        ppdev->cLocks--;

        ASSERTDD(ppdev->cLocks >= 0, "Invalid lock count");
    }

    return(DDHAL_DRIVER_NOTHANDLED);
}

/******************************Public*Routine******************************\
* DWORD DdFlip
*
*  3-Dec-1995 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

DWORD DdFlip(
PDD_FLIPDATA lpFlip)
{
    PDEV*   ppdev;
    BYTE*   pjBase;
    HRESULT ddrval;
    ULONG   cDwordsPerPlane;
    BYTE*   pjSourceStart;
    BYTE*   pjDestinationStart;
    BYTE*   pjSource;
    BYTE*   pjDestination;
    LONG    iPage;
    LONG    i;
    ULONG   ul;
    FLATPTR fpVidMem;

    ppdev = (PDEV*) lpFlip->lpDD->dhpdev;
    pjBase = ppdev->pjBase;

    // Is the current flip still in progress?
    //
    // Don't want a flip to work until after the last flip is done,
    // so we ask for the general flip status and ignore the vmem.

    ddrval = ddrvalUpdateFlipStatus(ppdev, (FLATPTR) -1);
    if (ddrval != DD_OK)
    {
        lpFlip->ddRVal = DDERR_WASSTILLDRAWING;
        return(DDHAL_DRIVER_HANDLED);
    }

    // Make the following page the current back-buffer.  We always flip
    // between three pages, so watch for our limit:

    ppdev->cjVgaOffset += ppdev->cjVgaPageSize;
    if (++ppdev->iVgaPage == ppdev->cVgaPages)
    {
        ppdev->iVgaPage = 0;
        ppdev->cjVgaOffset = 0;
    }

    // Copy from the DIB surface to the current VGA back-buffer.  We have
    // to convert to planar format on the way:

    pjDestinationStart    = ppdev->pjVga + ppdev->cjVgaOffset;
    fpVidMem              = lpFlip->lpSurfTarg->lpGbl->fpVidMem;
    pjSourceStart         = ppdev->pjScreen + fpVidMem;
    cDwordsPerPlane       = ppdev->cDwordsPerPlane;

    // Remember what DirectDraw surface is currently 'visible':

    ppdev->fpScreenOffset = fpVidMem;

    // Now do the blt!

    WRITE_PORT_UCHAR(pjBase + VGA_BASE + SEQ_ADDR, SEQ_MAP_MASK);

    for (iPage = 0; iPage < 4; iPage++, pjSourceStart++)
    {
        WRITE_PORT_UCHAR(pjBase + VGA_BASE + SEQ_DATA, 1 << iPage);

    #if defined(_X86_)

        _asm {
            mov     esi,pjSourceStart
            mov     edi,pjDestinationStart
            mov     ecx,cDwordsPerPlane

        PixelLoop:
            mov     al,[esi+8]
            mov     ah,[esi+12]
            shl     eax,16
            mov     al,[esi]
            mov     ah,[esi+4]

            mov     [edi],eax
            add     edi,4
            add     esi,16

            dec     ecx
            jnz     PixelLoop
        }

    #else

        pjSource      = pjSourceStart;
        pjDestination = pjDestinationStart;

        for (i = cDwordsPerPlane; i != 0; i--)
        {
            ul = (*(pjSource))
               | (*(pjSource + 4) << 8)
               | (*(pjSource + 8) << 16)
               | (*(pjSource + 12) << 24);

            WRITE_REGISTER_ULONG((ULONG*) pjDestination, ul);

            pjDestination += 4;
            pjSource      += 16;
        }

    #endif

    }

    // Now flip to the page we just updated:

    WRITE_PORT_USHORT((USHORT*) (pjBase + VGA_BASE + CRTC_ADDR),
        (USHORT) ((ppdev->cjVgaOffset) & 0xff00) | START_ADDRESS_HIGH);

    // Remember where and when we were when we did the flip:

    EngQueryPerformanceCounter(&ppdev->flipRecord.liFlipTime);

    ppdev->flipRecord.bFlipFlag              = TRUE;
    ppdev->flipRecord.bHaveEverCrossedVBlank = FALSE;
    ppdev->flipRecord.bWasEverInDisplay      = FALSE;

    ppdev->flipRecord.fpFlipFrom = lpFlip->lpSurfCurr->lpGbl->fpVidMem;

    lpFlip->ddRVal = DD_OK;
    return(DDHAL_DRIVER_HANDLED);
}

/******************************Public*Routine******************************\
* BOOL DrvGetDirectDrawInfo
*
*  3-Dec-1995 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

BOOL DrvGetDirectDrawInfo(
DHPDEV          dhpdev,
DD_HALINFO*     pHalInfo,
DWORD*          pdwNumHeaps,
VIDEOMEMORY*    pvmList,            // Will be NULL on first call
DWORD*          pdwNumFourCC,
DWORD*          pdwFourCC)          // Will be NULL on first call
{
    PDEV*  ppdev;

    ppdev = (PDEV*) dhpdev;

    pHalInfo->dwSize = sizeof(*pHalInfo);

    // Current primary surface attributes.  Since HalInfo is zero-initialized
    // by GDI, we only have to fill in the fields which should be non-zero:

    pHalInfo->vmiData.dwDisplayWidth  = ppdev->cxScreen;
    pHalInfo->vmiData.dwDisplayHeight = ppdev->cyScreen;
    pHalInfo->vmiData.lDisplayPitch   = ppdev->lScreenDelta;
    pHalInfo->vmiData.pvPrimary       = ppdev->pjScreen;

    pHalInfo->vmiData.ddpfDisplay.dwSize  = sizeof(DDPIXELFORMAT);
    pHalInfo->vmiData.ddpfDisplay.dwFlags = DDPF_RGB | DDPF_PALETTEINDEXED8;

    pHalInfo->vmiData.ddpfDisplay.dwRGBBitCount = 8;

    // These masks will be zero at 8bpp:

    pHalInfo->vmiData.ddpfDisplay.dwRBitMask = 0;
    pHalInfo->vmiData.ddpfDisplay.dwGBitMask = 0;
    pHalInfo->vmiData.ddpfDisplay.dwBBitMask = 0;
    pHalInfo->vmiData.ddpfDisplay.dwRGBAlphaBitMask = 0;

    *pdwNumHeaps = 0;
    if (ppdev->cyMemory != ppdev->cyScreen)
    {
        *pdwNumHeaps = 1;
        if (pvmList != NULL)
        {
            pvmList->dwFlags        = VIDMEM_ISRECTANGULAR;
            pvmList->fpStart        = ppdev->cyScreen * ppdev->lScreenDelta;
            pvmList->dwWidth        = ppdev->lScreenDelta;
            pvmList->dwHeight       = ppdev->cyMemory - ppdev->cyScreen;
            pvmList->ddsCaps.dwCaps = DDSCAPS_OFFSCREENPLAIN;
        }
    }

    // Capabilities supported:

    pHalInfo->ddCaps.dwFXCaps   = 0;
    pHalInfo->ddCaps.dwCaps     = 0;
    pHalInfo->ddCaps.dwCKeyCaps = 0;
    pHalInfo->ddCaps.ddsCaps.dwCaps = DDSCAPS_OFFSCREENPLAIN
                                    | DDSCAPS_PRIMARYSURFACE
                                    | DDSCAPS_FLIP;

    // Required alignments of the scan lines for each kind of memory:

    pHalInfo->vmiData.dwOffscreenAlign = 4;

    // FourCCs supported:

    *pdwNumFourCC = 0;

    return(TRUE);
}

/******************************Public*Routine******************************\
* BOOL DrvEnableDirectDraw
*
*  3-Dec-1995 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

BOOL DrvEnableDirectDraw(
DHPDEV                  dhpdev,
DD_CALLBACKS*           pCallBacks,
DD_SURFACECALLBACKS*    pSurfaceCallBacks,
DD_PALETTECALLBACKS*    pPaletteCallBacks)
{
    pCallBacks->WaitForVerticalBlank  = DdWaitForVerticalBlank;
    pCallBacks->MapMemory             = DdMapMemory;
    pCallBacks->dwFlags               = DDHAL_CB32_WAITFORVERTICALBLANK
                                      | DDHAL_CB32_MAPMEMORY;

    pSurfaceCallBacks->Flip           = DdFlip;
    pSurfaceCallBacks->Lock           = DdLock;
    pSurfaceCallBacks->Unlock         = DdUnlock;
    pSurfaceCallBacks->dwFlags        = DDHAL_SURFCB32_FLIP
                                      | DDHAL_SURFCB32_LOCK
                                      | DDHAL_SURFCB32_UNLOCK;

    return(TRUE);
}

/******************************Public*Routine******************************\
* VOID DrvDisableDirectDraw
*
*  3-Dec-1995 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

VOID DrvDisableDirectDraw(
DHPDEV      dhpdev)
{
}

/******************************Public*Routine******************************\
* BOOL bEnableDirectDraw
*
* This function is called by enable.c when the mode is first initialized,
* right after the miniport does the mode-set.
*
\**************************************************************************/

BOOL bEnableDirectDraw(
PDEV*   ppdev)
{
    // Calculate the total number of dwords per plane for flipping:

    ppdev->cDwordsPerPlane = (ppdev->cyScreen * ppdev->lVgaDelta) >> 2;

    // We only program the high byte of the VGA offset, so the page size must
    // be a multiple of 256:

    ppdev->cjVgaPageSize = ((ppdev->cyScreen * ppdev->lVgaDelta) + 255) & ~255;

    // VGAs can address only 64k of memory, so that limits the number of
    // page-flip buffers we can have:

    ppdev->cVgaPages = 64 * 1024 / ppdev->cjVgaPageSize;

    // Accurately measure the refresh rate for later:

    vGetDisplayDuration(ppdev);

    return(TRUE);
}

/******************************Public*Routine******************************\
* VOID vAssertModeDirectDraw
*
* This function is called by enable.c when entering or leaving the
* DOS full-screen character mode.
*
\**************************************************************************/

VOID vAssertModeDirectDraw(
PDEV*   ppdev,
BOOL    bEnable)
{
}

/******************************Public*Routine******************************\
* VOID vDisableDirectDraw
*
* This function is called by enable.c when the driver is shutting down.
*
\**************************************************************************/

VOID vDisableDirectDraw(
PDEV*   ppdev)
{
    ASSERTDD(ppdev->cLocks == 0, "Invalid lock count");
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\modex\disp\hw.h ===
/******************************Module*Header*******************************\
* Module Name: hw.h
*
* All the hardware specific driver file stuff.
*
* Copyright (c) 1992-1995 Microsoft Corporation
\**************************************************************************/

//  Miscellaneous Registers used only at EGA/VGA initialization time

#define MISC_OUTPUT         0x0C2       // Miscellaneous Output Register
#define CRTC_ADDR           0x0D4       // CRTC Address Register for color mode
#define CRTC_DATA           0x0D5       // CRTC Data    Register for color mode
#define GRAF_1_POS          0x0CC       // Graphics 1 Address Register
#define GRAF_2_POS          0x0CA       // Graphics 2 Address Register
#define ATTR_READ           0x0DA       // Attribute Controler Read  Address
#define ATTR_WRITE          0x0C0       // Attribute Controler Write Address
#define IN_STAT_0           0x0C2       // Input Status Register 0
#define IN_STAT_1           0x0DA       // Input Status Register 1

//  EGA/VGA Register Definitions.
//
//  The following definitions are the EGA/VGA registers and values
//  used by this driver.  All other registers are set up at
//  when the EGA/VGA is placed into graphics mode and never altered
//  afterwards.
//
//  All unspecified bits in the following registers must be 0.

#define EGA_BASE            0x300       // Base address of the EGA (3xx)
#define VGA_BASE            0x300       // Base address of the VGA (3xx)

//  SEQUencer Registers Used

#define SEQ_ADDR            0xC4        // SEQUencer Address Register
#define SEQ_DATA            0xC5        // SEQUencer Data    Register

#define SEQ_MAP_MASK        0x02        // Write Plane Enable Mask
#define MM_C0               0x01        // C0 plane enable
#define MM_C1               0x02        // C1 plane enable
#define MM_C2               0x04        // C2 plane enable
#define MM_C3               0x08        // C3 plane enable
#define MM_ALL              0x0f        // All planes

#define SEQ_MODE            0x04        // Memory Mode
#define SM_ALPHA            0x01        // Char map select enable
#define SM_EXTENDED         0x02        // Extended memory present
#define SM_ODD_PLANE        0x04        // Odd/even bytes to same plane

//  Graphics Controller Registers Used

#define GRAF_ADDR           0xCE        // Graphics Controller Address Register
#define GRAF_DATA           0xCF        // Graphics Controller Data    Register

#define GRAF_SET_RESET      0x00        // Set/Reset Plane Color
#define GRAF_ENAB_SR        0x01        // Set/Reset Enable
#define GRAF_COL_COMP       0x02        // Color Compare Register

#define GRAF_DATA_ROT       0x03        // Data Rotate Register
#define DR_ROT_CNT          0x07        //   Data Rotate Count
#define DR_SET              0x00        //   Data Unmodified
#define DR_AND              0x08        //   Data ANDed with latches
#define DR_OR               0x10        //   Data ORed  with latches
#define DR_XOR              0x18        //   Data XORed with latches

#define GRAF_READ_MAP       0x04        // Read Map Select Register
#define RM_C0               0x00        //   Read C0 plane
#define RM_C1               0x01        //   Read C1 plane
#define RM_C2               0x02        //   Read C2 plane
#define RM_C3               0x03        //   Read C3 plane

#define GRAF_MODE           0x05        // Mode Register
#define M_PROC_WRITE        0x00        //   Write processor data rotated
#define M_LATCH_WRITE       0x01        //   Write latched data
#define M_COLOR_WRITE       0x02        //   Write processor data as color
#define M_AND_WRITE         0x03        //   Write (procdata AND bitmask)
#define M_DATA_READ         0x00        //   Read selected plane
#define M_COLOR_READ        0x08        //   Read color compare

#define GRAF_MISC           0x06        // Miscellaneous Register
#define MS_NON_ALPHA        0x01        //   Char generator disabled
#define MS_ODD_EVEN         0x02        //   Map odd addresses to even
#define MS_A0000_128K       0x00        //   Memory present at A0000, 128kb
#define MS_A0000_64K        0x04        //   Memory present at A0000, 64kb
#define MS_B0000_32K        0x08        //   Memory present at B0000, 32kb
#define MS_B8000_32K        0x0C        //   Memory present at B8000, 32kb
#define MS_ADDR_MASK        0x0C

#define GRAF_CDC            0x07        // Color Don't Care Register
#define GRAF_BIT_MASK       0x08        // Bit Mask Register

////////////////////////////////////////////////////////////////////////
// Direct access macros
//

#define OUT_WORD(pjBase, addr, w)                           \
{                                                           \
    MEMORY_BARRIER();                                       \
    WRITE_PORT_USHORT((BYTE*) (pjBase) + (addr), (USHORT) (w)); \
}

#define OUT_BYTE(pjBase, addr, j)                           \
{                                                           \
    MEMORY_BARRIER();                                       \
    WRITE_PORT_UCHAR((BYTE*) (pjBase) + (addr), (UCHAR) (j)); \
}

#define WRITE_WORD(pwAddr, w)                               \
    WRITE_REGISTER_USHORT((USHORT*) (pwAddr), (USHORT) (w))

#define WRITE_BYTE(pbAddr, b)                             \
    WRITE_REGISTER_UCHAR((UCHAR *) (pbAddr), (UCHAR) (b))
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\modex\disp\hardware.c ===
/******************************Module*Header*******************************\
* Module Name: hardware.c
*
* Contains all the code that touches the display hardware.
*
* Copyright (c) 1994-1995 Microsoft Corporation
\**************************************************************************/

#include "precomp.h"

/******************************Public*Routine******************************\
* BOOL bAssertModeHardware
*
* Sets the appropriate hardware state for graphics mode or full-screen.
*
\**************************************************************************/

BOOL bAssertModeHardware(
PDEV* ppdev,
BOOL  bEnable)
{
    DWORD   ReturnedDataLength;
    BYTE*   pjBase;
    RECTL   rcl;

    pjBase = ppdev->pjBase;

    if (bEnable)
    {
        // Reset some state:

        ppdev->cjVgaOffset    = 0;
        ppdev->iVgaPage       = 0;
        ppdev->fpScreenOffset = 0;

        // Set the desired mode.

        if (EngDeviceIoControl(ppdev->hDriver,
                             IOCTL_VIDEO_SET_CURRENT_MODE,
                             &ppdev->ulMode,  // input buffer
                             sizeof(VIDEO_MODE),
                             NULL,
                             0,
                             &ReturnedDataLength))
        {
            DISPDBG((0, "bAssertModeHardware - Failed VIDEO_SET_CURRENT_MODE"));
            goto ReturnFalse;
        }

        // Now blank the screen:

        rcl.left   = 0;
        rcl.top    = 0;
        rcl.right  = ppdev->cxScreen;
        rcl.bottom = ppdev->cyScreen;

        vUpdate(ppdev, &rcl, NULL);

        DISPDBG((5, "Passed bAssertModeHardware"));
    }
    else
    {
        // Call the kernel driver to reset the device to a known state.
        // NTVDM will take things from there:

        if (EngDeviceIoControl(ppdev->hDriver,
                             IOCTL_VIDEO_RESET_DEVICE,
                             NULL,
                             0,
                             NULL,
                             0,
                             &ReturnedDataLength))
        {
            DISPDBG((0, "bAssertModeHardware - Failed reset IOCTL"));
            goto ReturnFalse;
        }
    }

    return(TRUE);

ReturnFalse:

    DISPDBG((0, "Failed bAssertModeHardware"));

    return(FALSE);
}

/******************************Public*Routine******************************\
* BOOL bEnableHardware
*
* Puts the hardware into the requested mode and initializes it.
*
* Note: Should be called before any access is done to the hardware from
*       the display driver.
*
\**************************************************************************/

BOOL bEnableHardware(
PDEV*   ppdev)
{
    VIDEO_MEMORY                VideoMemory;
    VIDEO_MEMORY_INFORMATION    VideoMemoryInfo;
    VIDEO_MODE_INFORMATION      VideoModeInfo;
    DWORD                       ReturnedDataLength;
    VIDEO_PUBLIC_ACCESS_RANGES  VideoAccessRange;
    DWORD                       status;

#if defined(_X86_)

    ppdev->pjBase = NULL;

#else

    // Map io ports into virtual memory:

    VideoMemory.RequestedVirtualAddress = NULL;

    if (EngDeviceIoControl(ppdev->hDriver,
                         IOCTL_VIDEO_QUERY_PUBLIC_ACCESS_RANGES,
                         NULL,                      // input buffer
                         0,
                         &VideoAccessRange,         // output buffer
                         sizeof (VideoAccessRange),
                         &ReturnedDataLength))
    {
        RIP("bEnableHardware - Initialization error mapping IO port base");
        goto ReturnFalse;
    }

    ppdev->pjBase = (UCHAR*) VideoAccessRange.VirtualAddress;

#endif

    // Set the desired mode. (Must come before IOCTL_VIDEO_MAP_VIDEO_MEMORY;
    // that IOCTL returns information for the current mode, so there must be a
    // current mode for which to return information.)

    if (EngDeviceIoControl(ppdev->hDriver,
                         IOCTL_VIDEO_SET_CURRENT_MODE,
                         &ppdev->ulMode,        // input buffer
                         sizeof(VIDEO_MODE),
                         NULL,
                         0,
                         &ReturnedDataLength))
    {
        RIP("bEnableHardware - Set current mode");
        goto ReturnFalse;
    }

    // Get the linear memory address range.

    VideoMemory.RequestedVirtualAddress = NULL;

    if (EngDeviceIoControl(ppdev->hDriver,
                         IOCTL_VIDEO_MAP_VIDEO_MEMORY,
                         &VideoMemory,      // input buffer
                         sizeof(VIDEO_MEMORY),
                         &VideoMemoryInfo,  // output buffer
                         sizeof(VideoMemoryInfo),
                         &ReturnedDataLength))
    {
        DISPDBG((0, "bEnableHardware - Error mapping buffer address"));
        goto ReturnFalse;
    }

    DISPDBG((1, "FrameBufferBase: %lx", VideoMemoryInfo.FrameBufferBase));

    // Record the Frame Buffer Linear Address.

    ppdev->pjVga = (BYTE*) VideoMemoryInfo.FrameBufferBase;

    // Store the width of the screen in bytes, per-plane:

    ppdev->lVgaDelta = ppdev->cxScreen / 4;

    if (!bAssertModeHardware(ppdev, TRUE))
        goto ReturnFalse;

    DISPDBG((5, "Passed bEnableHardware"));

    return(TRUE);

ReturnFalse:

    DISPDBG((0, "Failed bEnableHardware"));

    return(FALSE);
}

/******************************Public*Routine******************************\
* VOID vDisableHardware
*
* Undoes anything done in bEnableHardware.
*
* Note: In an error case, we may call this before bEnableHardware is
*       completely done.
*
\**************************************************************************/

VOID vDisableHardware(
PDEV*   ppdev)
{
    DWORD        ReturnedDataLength;
    VIDEO_MEMORY VideoMemory;

    VideoMemory.RequestedVirtualAddress = ppdev->pjVga;

    if (EngDeviceIoControl(ppdev->hDriver,
                         IOCTL_VIDEO_UNMAP_VIDEO_MEMORY,
                         &VideoMemory,
                         sizeof(VIDEO_MEMORY),
                         NULL,
                         0,
                         &ReturnedDataLength))
    {
        DISPDBG((0, "vDisableHardware failed IOCTL_VIDEO_UNMAP_VIDEO"));
    }

#if !defined(_X86_)

    VideoMemory.RequestedVirtualAddress = ppdev->pjBase;

    if (EngDeviceIoControl(ppdev->hDriver,
                         IOCTL_VIDEO_FREE_PUBLIC_ACCESS_RANGES,
                         &VideoMemory,
                         sizeof(VIDEO_MEMORY),
                         NULL,
                         0,
                         &ReturnedDataLength))
    {
        DISPDBG((0, "vDisableHardware failed IOCTL_VIDEO_FREE_PUBLIC_ACCESS"));
    }

#endif

}

/******************************Public*Routine******************************\
* VOID vUpdate(ppdev, prcl, pco)
*
* Updates the screen from the DIB surface for the given rectangle.
* Increases the rectangle size if necessary for easy alignment.
*
* NOTE: Life is made complicated by the fact that we are faking DirectDraw
*       'flip' surfaces.  When we're asked by GDI to draw, it should be
*       copied from the shadow buffer to the physical screen only if
*       DirectDraw is currently 'flipped' to the primary surface.
*
\**************************************************************************/

VOID vUpdate(PDEV* ppdev, RECTL* prcl, CLIPOBJ* pco)
{
    BYTE*       pjBase;
    RECTL       rcl;
    SURFOBJ*    pso;
    LONG        lSrcDelta;
    BYTE*       pjSrcStart;
    BYTE*       pjSrc;
    LONG        lDstDelta;
    BYTE*       pjDstStart;
    BYTE*       pjDst;
    ULONG       cy;
    ULONG       cDwordsPerPlane;
    ULONG       iPage;
    ULONG       i;
    ULONG       ul;

    pjBase = ppdev->pjBase;

    if ((pco == NULL) || (pco->iDComplexity == DC_TRIVIAL))
    {
        // We have to clip to the screen dimensions because we may have
        // been a bit loose when we guessed the bounds of the drawing:

        rcl.left   = max(0,               prcl->left);
        rcl.top    = max(0,               prcl->top);
        rcl.right  = min(ppdev->cxScreen, prcl->right);
        rcl.bottom = min(ppdev->cyScreen, prcl->bottom);
    }
    else
    {
        // We may as well save ourselves some blting by clipping to
        // the clip object's maximum extent.  The clip object's bounds
        // are guaranteed to be contained within the dimensions of the
        // screen:

        rcl.left   = max(pco->rclBounds.left,   prcl->left);
        rcl.top    = max(pco->rclBounds.top,    prcl->top);
        rcl.right  = min(pco->rclBounds.right,  prcl->right);
        rcl.bottom = min(pco->rclBounds.bottom, prcl->bottom);
    }

    // Be paranoid:

    if ((rcl.left >= rcl.right) || (rcl.top >= rcl.bottom))
        return;

    // Align to dwords to keep things simple.

    rcl.left  = (rcl.left) & ~15;
    rcl.right = (rcl.right + 15) & ~15;

    lSrcDelta  = ppdev->lScreenDelta;
    pjSrcStart = ppdev->pjScreen + ppdev->fpScreenOffset
                                 + (rcl.top * lSrcDelta)
                                 + rcl.left;

    lDstDelta  = ppdev->lVgaDelta;
    pjDstStart = ppdev->pjVga + ppdev->cjVgaOffset
                              + (rcl.top * lDstDelta)
                              + (rcl.left >> 2);

    cy              = (rcl.bottom - rcl.top);
    cDwordsPerPlane = (rcl.right - rcl.left) >> 4;
    lSrcDelta      -= 4;        // Account for per-plane increment

    WRITE_PORT_UCHAR(pjBase + VGA_BASE + SEQ_ADDR, SEQ_MAP_MASK);

    do {
        for (iPage = 0; iPage < 4; iPage++, pjSrcStart++)
        {
            WRITE_PORT_UCHAR(pjBase + VGA_BASE + SEQ_DATA, 1 << iPage);

            pjSrc = pjSrcStart;
            pjDst = pjDstStart;

        #if defined(_X86_)

            _asm {
                mov     esi,pjSrcStart
                mov     edi,pjDstStart
                mov     ecx,cDwordsPerPlane

            PixelLoop:
                mov     al,[esi+8]
                mov     ah,[esi+12]
                shl     eax,16
                mov     al,[esi]
                mov     ah,[esi+4]

                mov     [edi],eax
                add     edi,4
                add     esi,16

                dec     ecx
                jnz     PixelLoop
            }

        #else

            for (i = cDwordsPerPlane; i != 0; i--)
            {
                ul = (*(pjSrc))
                   | (*(pjSrc + 4) << 8)
                   | (*(pjSrc + 8) << 16)
                   | (*(pjSrc + 12) << 24);

                WRITE_REGISTER_ULONG((ULONG*) pjDst, ul);

                pjDst += 4;
                pjSrc += 16;
            }

        #endif

        }

        pjSrcStart += lSrcDelta;
        pjDstStart += lDstDelta;

    } while (--cy != 0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\modex\disp\precomp.h ===
/******************************Module*Header*******************************\
* Module Name: precomp.h
*
* Common headers used throughout the display driver.  This entire include
* file will typically be pre-compiled.
*
* Copyright (c) 1993-1995 Microsoft Corporation
\**************************************************************************/

#include <stddef.h>
#include <stdarg.h>
#include <limits.h>
#include <windef.h>
#include <winerror.h>
#include <wingdi.h>
#include <winddi.h>
#include <devioctl.h>
#include <ntddvdeo.h>
#include <ioaccess.h>

#include "driver.h"
#include "debug.h"
#include "hw.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\port\dma.c ===
/*++

Copyright (c) 1990-2000  Microsoft Corporation

Module Name:

  dma.c

Abstract:

    This is the NT Video port driver dma support module.

Author:

    Bruce McQuistan (brucemc) Mar. 1996

Environment:

    kernel mode only

Notes:


Revision History:

--*/

#include "videoprt.h"

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, VideoPortGetCommonBuffer)
#pragma alloc_text(PAGE, VideoPortFreeCommonBuffer)
#pragma alloc_text(PAGE, VideoPortDoDma)
#pragma alloc_text(PAGE, VideoPortUnlockPages)
#pragma alloc_text(PAGE, VideoPortSetBytesUsed)
#pragma alloc_text(PAGE, VideoPortMapDmaMemory)
#pragma alloc_text(PAGE, VideoPortUnmapDmaMemory)
#pragma alloc_text(PAGE, VideoPortGetDmaAdapter)
#pragma alloc_text(PAGE, VideoPortPutDmaAdapter)
#pragma alloc_text(PAGE, VideoPortAllocateCommonBuffer)
#pragma alloc_text(PAGE, VideoPortReleaseCommonBuffer)
#pragma alloc_text(PAGE, VideoPortLockBuffer)
#endif

#define MAX_COMMON_BUFFER_SIZE      0x40000

PVOID
VideoPortAllocateContiguousMemory(
    IN  PVOID            HwDeviceExtension,
    IN  ULONG            NumberOfBytes,
    IN  PHYSICAL_ADDRESS HighestAcceptableAddress
    )
{
    if ((NumberOfBytes > MAX_COMMON_BUFFER_SIZE))
        return NULL;

    return MmAllocateContiguousMemory(NumberOfBytes, HighestAcceptableAddress);
}

PVOID
VideoPortGetCommonBuffer(
    IN  PVOID             HwDeviceExtension,
    IN  ULONG             DesiredLength,
    IN  ULONG             Alignment,
    OUT PPHYSICAL_ADDRESS LogicalAddress,
    OUT PULONG            ActualLength,
    IN  BOOLEAN           CacheEnabled
    )

/*++

Routine Description:

    Provides physical address visible to both device and system. Memory
    seen as contiguous by device.

Arguments:
    HwDeviceExtension   - device extension available to miniport.
    DesiredLength       - size of desired memory (should be minimal).
    Alignment           - Desired alignment of buffer, currently unused.
    LogicalAddress      - [out] parameter which will hold physical address of
                          of the buffer upon function return.
    ActualLength        - Actual length of buffer.
    CacheEnabled        - Specifies whether the allocated memory can be cached.

Return Value:
    Virtual address of the common buffer.

--*/

{
    PFDO_EXTENSION fdoExtension = GET_FDO_EXT(HwDeviceExtension);
    VP_DMA_ADAPTER vpDmaAdapter;
    PVOID VirtualAddress;

    if (DesiredLength > MAX_COMMON_BUFFER_SIZE) {

        return NULL;
    }

    vpDmaAdapter.DmaAdapterObject = fdoExtension->DmaAdapterObject;

    VirtualAddress = VideoPortAllocateCommonBuffer(HwDeviceExtension,
                                                   &vpDmaAdapter,
                                                   DesiredLength,
                                                   LogicalAddress,
                                                   CacheEnabled,
                                                   NULL);

    *ActualLength = VirtualAddress ? DesiredLength : 0;

    return (VirtualAddress);
}

VOID
VideoPortFreeCommonBuffer(
    IN  PVOID            HwDeviceExtension,
    IN  ULONG            Length,
    IN  PVOID            VirtualAddress,
    IN  PHYSICAL_ADDRESS LogicalAddress,
    IN  BOOLEAN          CacheEnabled
)
/*++

Routine Description:

    Frees memory allocated by VideoPortGetCommonBuffer.

Arguments:
    HwDeviceExtension   - device extension available to miniport.
    DesiredLength       - size of memory allocated.
    Alignment           - Desired liagnment of buffer, currently unused.
    VirtualAddress      - [out] parameter which will hold virtual address of
                        the buffer upon function return.
    LogicalAddress      - [out] parameter which will hold physical address of
                        of the buffer upon function return.
    CacheEnabled        - Specifies whether the allocated memory can be cached.

Return Value:
    VOID.

--*/

{
    PFDO_EXTENSION fdoExtension = GET_FDO_EXT(HwDeviceExtension);
    VP_DMA_ADAPTER vpDmaAdapter;

    vpDmaAdapter.DmaAdapterObject = fdoExtension->DmaAdapterObject;

    VideoPortReleaseCommonBuffer( HwDeviceExtension,
                                  &vpDmaAdapter,
                                  Length,
                                  LogicalAddress,
                                  VirtualAddress,
                                  CacheEnabled );
}

PDMA
VideoPortDoDma(
    IN      PVOID       HwDeviceExtension,
    IN      PDMA        pDma,
    IN      DMA_FLAGS   DmaFlags
    )

/*++

    This function is obsolete. 

--*/

{
    return NULL;
}

PDMA
VideoPortAssociateEventsWithDmaHandle(
    IN      PVOID                   HwDeviceExtension,
    IN OUT  PVIDEO_REQUEST_PACKET   pVrp,
    IN      PVOID                   MappedUserEvent,
    IN      PVOID                   DisplayDriverEvent
    )

/*++

    This function is obsolete. 

--*/

{
    return NULL;
}


BOOLEAN
VideoPortLockPages(
    IN      PVOID                   HwDeviceExtension,
    IN OUT  PVIDEO_REQUEST_PACKET   pVrp,
    IN      PEVENT                  pMappedUserEvent,
    IN      PEVENT                  pDisplayEvent,
    IN      DMA_FLAGS               DmaFlags
    )
/*++

Routine Description:

    This function is obsolete. For the purpose of compatability, we
    lock the memory when DmaFlags == VideoPortDmaInitOnly. But we do
    nothing more than that.

--*/

{
    PMDL Mdl;

    pVideoDebugPrint((Error, "VideoPortLockPages is obsolete!\n"));

    *(PULONG_PTR)(pVrp->OutputBuffer) = (ULONG_PTR) 0;

    if (DmaFlags != VideoPortDmaInitOnly) {

        return FALSE;
    }

    Mdl = VideoPortLockBuffer( HwDeviceExtension,
                               pVrp->InputBuffer,
                               pVrp->InputBufferLength,    
                               VpModifyAccess );
    if( Mdl == NULL ){

        return FALSE;
    }

    //
    // Put pMdl into OutputBuffer.
    //

    *(PULONG_PTR)(pVrp->OutputBuffer) = (ULONG_PTR) Mdl;

    return TRUE;

}

BOOLEAN
VideoPortUnlockPages(
    PVOID   HwDeviceExtension,
    PDMA    pDma
    )
/*++

Routine Description:

    This function is obsolete. For the purpose of compatability, we
    just unlock the memory and does nothing more than that.

--*/
{

    PMDL Mdl = (PMDL) pDma;

    pVideoDebugPrint((Error, "VideoPortUnLockPages is obsolete!\n"));
    VideoPortUnlockBuffer( HwDeviceExtension, Mdl );
    return TRUE;
}

PVOID
VideoPortGetDmaContext(
    PVOID       HwDeviceExtension,
    IN  PDMA    pDma
    )
/*++

    This function is obsolete. 

--*/
{
    return NULL;
}

VOID
VideoPortSetDmaContext(
    IN      PVOID   HwDeviceExtension,
    IN OUT  PDMA    pDma,
    IN      PVOID   InstanceContext
    )
/*++

    This function is obsolete. 

--*/
{
}

PVOID
VideoPortGetMdl(
    IN  PVOID   HwDeviceExtension,
    IN  PDMA    pDma
    )
/*++

Routine Description:

    This function is obsolete. We still return the Mdl for the purpose
    of compatibility.

--*/

{
    //
    // pDma is the Mdl ( see VideoPortLockPages )
    //

    return (PVOID) pDma;
}

ULONG
VideoPortGetBytesUsed(
    IN  PVOID   HwDeviceExtension,
    IN  PDMA    pDma
    )
/*++

    This function is obsolete. 

--*/
{
    return 0;
}

VOID
VideoPortSetBytesUsed(
    IN      PVOID   HwDeviceExtension,
    IN OUT  PDMA    pDma,
    IN      ULONG   BytesUsed
    )
/*++

Routine Description:

    This function is obsolete. 

--*/
{
}

PDMA
VideoPortMapDmaMemory(
    IN      PVOID                   HwDeviceExtension,
    IN      PVIDEO_REQUEST_PACKET   pVrp,
    IN      PHYSICAL_ADDRESS        BoardAddress,
    IN      PULONG                  Length,
    IN      PULONG                  InIoSpace,
    IN      PVOID                   MappedUserEvent,
    IN      PVOID                   DisplayDriverEvent,
    IN OUT  PVOID                 * VirtualAddress
    )

/*++

    This function is obsolete. 

--*/

{
    return NULL;
}

BOOLEAN
VideoPortUnmapDmaMemory(
    PVOID               HwDeviceExtension,
    PVOID               VirtualAddress,
    HANDLE              ProcessHandle,
    PDMA                BoardMemoryHandle
    )

/*++

    This function is obsolete. 

--*/

{
    return FALSE;
}


//
// New DMA code start here
// 

PVP_DMA_ADAPTER
VideoPortGetDmaAdapter(
    IN PVOID                   HwDeviceExtension,
    IN PVP_DEVICE_DESCRIPTION  VpDeviceDescription
    )
/*++

Routine Description:

Arguments:

    HwDeviceExtension   - Points to the miniport driver's device extension.
    VpDeviceDescription - Points to a DEVICE_DESCRIPTION structure, which 
                          describes the attributes of the physical device.  

Return Value:

    Returns a pointer to a VP_DMA_ADAPTER on sucess, or NULL otherwise.

--*/

{

    DEVICE_DESCRIPTION DeviceDescription;
    ULONG              numberOfMapRegisters;
    PVP_DMA_ADAPTER    VpDmaAdapter, p;
    PFDO_EXTENSION     fdoExtension = GET_FDO_EXT(HwDeviceExtension);

    VpDmaAdapter = ExAllocatePoolWithTag( NonPagedPool,
                                          sizeof(VP_DMA_ADAPTER),
                                          VP_TAG );

    if(!VpDmaAdapter) {
    
        return NULL;

    } else {
    
        RtlZeroMemory((PVOID) VpDmaAdapter, sizeof(VP_DMA_ADAPTER));
    }

    //
    // Fill in DEVICE_DESCRITION with the data passed in. We also assume
    // the this is a busmaster device. 
    //

    DeviceDescription.Version           = DEVICE_DESCRIPTION_VERSION;
    DeviceDescription.ScatterGather     = VpDeviceDescription->ScatterGather;
    DeviceDescription.Dma32BitAddresses = VpDeviceDescription->Dma32BitAddresses;
    DeviceDescription.Dma64BitAddresses = VpDeviceDescription->Dma64BitAddresses;
    DeviceDescription.MaximumLength     = VpDeviceDescription->MaximumLength;

    DeviceDescription.BusNumber         = fdoExtension->SystemIoBusNumber;
    DeviceDescription.InterfaceType     = fdoExtension->AdapterInterfaceType;

    DeviceDescription.Master            = TRUE;
    DeviceDescription.DemandMode        = FALSE;
    DeviceDescription.AutoInitialize    = FALSE;
    DeviceDescription.IgnoreCount       = FALSE;
    DeviceDescription.Reserved1         = FALSE;
    DeviceDescription.DmaWidth          = FALSE;
    DeviceDescription.DmaSpeed          = FALSE;
    DeviceDescription.DmaPort           = FALSE;
    DeviceDescription.DmaChannel        = 0;


    VpDmaAdapter->DmaAdapterObject = IoGetDmaAdapter( 
                                         fdoExtension->PhysicalDeviceObject,
                                         &DeviceDescription,
                                         &numberOfMapRegisters
                                         );

    if(!(VpDmaAdapter->DmaAdapterObject)) {
   
        ExFreePool((PVOID)VpDmaAdapter);
        return NULL;

    } else {
   
        //
        // Initialize the other fields of VP_DMA_ADAPTER
        //

        VpDmaAdapter->NumberOfMapRegisters = numberOfMapRegisters; 
    }

    //
    // Add the new VpDmaAdapter to the list 
    // 

    VpDmaAdapter->NextVpDmaAdapter = fdoExtension->VpDmaAdapterHead;
    fdoExtension->VpDmaAdapterHead = VpDmaAdapter;

    return(VpDmaAdapter);   

}

VOID
VideoPortPutDmaAdapter(
    IN PVOID           HwDeviceExtension,
    IN PVP_DMA_ADAPTER VpDmaAdapter
    )

/*++

Routine Description:

Arguments:

    HwDeviceExtension - Points to the miniport driver's device extension.
    VpDmaAdapter      - Points to the VP_DMA_ADAPTER structure returned by 
                        VideoPortGetDmaAdapter.

Return Value:

    Frees the resource allocated in VideoPortGetDmaAdapter

--*/

{
    PVP_DMA_ADAPTER p, q;
    PFDO_EXTENSION fdoExtension = GET_FDO_EXT(HwDeviceExtension);

    //
    // Frees the DMA_ADAPTER structure allocated by IoGetDmaAdapter
    //

    DMA_OPERATION(PutDmaAdapter)(VpDmaAdapter->DmaAdapterObject);

    //
    // Remove this VpDmaAdapter from the list 
    // 

    p = fdoExtension->VpDmaAdapterHead;

    if ( p == VpDmaAdapter ) {

        fdoExtension->VpDmaAdapterHead = p->NextVpDmaAdapter;

    } else {

        q = p->NextVpDmaAdapter;
 
        while ( q != NULL) {

            if ( q == VpDmaAdapter ) {
                 p->NextVpDmaAdapter = q->NextVpDmaAdapter;
                 break;
            }

            p = q;
            q = p->NextVpDmaAdapter;
        } 

        ASSERT (q);
    }

    ExFreePool((PVOID)VpDmaAdapter);

}

PVOID
VideoPortAllocateCommonBuffer(
    IN  PVOID             HwDeviceExtension,
    IN  PVP_DMA_ADAPTER   VpDmaAdapter,
    IN  ULONG             DesiredLength,
    OUT PPHYSICAL_ADDRESS LogicalAddress,
    IN  BOOLEAN           CacheEnabled,
    OUT PVOID             Reserved
    )

/*++

Routine Description:

    This function allocates and maps system memory so that it is simultaneously
    accessible from both the processor and a device for common-buffer DMA 
    operations.

Arguments:

    HwDeviceExtension - Points to the miniport driver's device extension.

    VpDmaAdapter      - Points to the VP_DMA_ADAPTER structure returned by 
                        VideoPortGetDmaAdapter.

    DesiredLength     - Specifies the requested number of bytes of memory. 

    LogicalAddress    - Points to a variable that receives the logical 
                        address to be used by the adapter to access the 
                        allocated buffer. 

    CacheEnabled      - Specifies whether the allocated memory can be cached. 

    Reserved          - Reserved

Return Value:

    Returns the base virtual address of the allocated buffer if successful. 
    Otherwise, returns NULL if the buffer cannot be allocated.

--*/

{
    PVOID VirtualAddress;

    PFDO_EXTENSION fdoExtension = GET_FDO_EXT(HwDeviceExtension);

    if ((VpDmaAdapter == NULL) || (VpDmaAdapter->DmaAdapterObject == NULL)) {

        pVideoDebugPrint((Error, 
            "VideoPortAllocateCommonBuffer: Invalid DMA adapter!\n"));

        ASSERT(FALSE);

        return NULL;
    }


    VirtualAddress = 
           DMA_OPERATION(AllocateCommonBuffer)(VpDmaAdapter->DmaAdapterObject,
                                               DesiredLength,
                                               LogicalAddress,
                                               CacheEnabled);

    if (Reserved) {

        *(PULONG)Reserved = VirtualAddress ? DesiredLength : 0;

        pVideoDebugPrint((Error, 
            "VideoPortAllocateCommonBuffer: The last parameter of this function is reserved and should be set to NULL!\n"));

    }

    return VirtualAddress;
}

VOID
VideoPortReleaseCommonBuffer(
    IN  PVOID             HwDeviceExtension,
    IN  PVP_DMA_ADAPTER   VpDmaAdapter,
    IN  ULONG             Length,
    IN  PHYSICAL_ADDRESS  LogicalAddress,
    IN  PVOID             VirtualAddress,
    IN  BOOLEAN           CacheEnabled
    )

/*++

Routine Description:

    This function frees a common buffer allocated by VideoPortAllocateCommonBuffer

Arguments:

    HwDeviceExtension - Points to the miniport driver's device extension.
    VpDmaAdapter      - Points to the VP_DMA_ADAPTER structure returned by 
                        VideoPortGetDmaAdapter.
    Length            - Specifies the number of bytes of memory to be freed. 
    LogicalAddress    - Specifies the logical address of the buffer to be freed. 
    VirtualAddress    - Points to the corresponding virtual address of the 
                        allocated memory range. 
    CacheEnabled      - Specifies whether the allocated memory can be cached. 

Return Value:

    None

--*/

{

    PFDO_EXTENSION fdoExtension = GET_FDO_EXT(HwDeviceExtension);

    if ((VpDmaAdapter == NULL) || (VpDmaAdapter->DmaAdapterObject == NULL)) {

        pVideoDebugPrint((Error, 
            " VideoPortReleaseCommonBuffer: Invalid DMA Adapter!\n" ));

        ASSERT(FALSE);
        return;
    }

    DMA_OPERATION(FreeCommonBuffer)( VpDmaAdapter->DmaAdapterObject,
                                     Length,
                                     LogicalAddress,
                                     VirtualAddress,
                                     CacheEnabled );
}

PVOID
VideoPortLockBuffer(
    IN PVOID               HwDeviceExtension,
    IN PVOID               BaseAddress,
    IN ULONG               Length,
    IN VP_LOCK_OPERATION   Operation
    )

/*++

Routine Description:

    This function probes specified buffer, makes them resident, and locks 
    the physical pages mapped by the virtual address range in memory.

Arguments:

    HwDeviceExtension - Points to the miniport driver's device extension.
    BaseAddress       - Virtual address of the buffer to be locked.
    Length            - Specifies the length in bytes of the buffer to be locked. 
    Operation         - Specifies the type of operation for which the caller 
                        wants the access rights probed and the pages locked, 
                        one of VpReadAccess, VpWriteAccess, or VpModifyAccess. 
Return Value:

    Returns a pointer to an MDL, or NULL if the MDL cannot be allocated.

--*/

{

    PMDL Mdl;

    //
    // Allocate the MDL, but don't stuff it in the Irp, as IoCompleteRequest
    // will free it!
    //

    Mdl = IoAllocateMdl(BaseAddress, Length, FALSE, FALSE, NULL);

    if (!Mdl) {

        pVideoDebugPrint((Warn, "VideoPortLockBuffer: No MDL address!\n"));
        return NULL;
    }

    //
    // Lock down the users buffer
    //

    __try {

       MmProbeAndLockPages( Mdl, KernelMode, Operation );

    } 
    __except(EXCEPTION_EXECUTE_HANDLER) {

        IoFreeMdl(Mdl);

        pVideoDebugPrint((Error,
                  "VideoPortLockBuffer: MmProbeandLockPages exception\n"));

        Mdl = NULL;
    }

    return Mdl;
}

VOID
VideoPortUnlockBuffer(
    IN PVOID   HwDeviceExtension,
    IN PVOID   Mdl
    )

/*++

Routine Description:

    This function unlocks physical pages described by a given MDL.

Arguments:

    HwDeviceExtension - Points to the miniport driver's device extension.
    Mdl               - A Pointer that returned from VideoPortLockBuffer.

Return Value:

    None

--*/

{
    if(Mdl == NULL) {
        
        ASSERT(FALSE);
        return;
    }

    MmUnlockPages(Mdl);
    IoFreeMdl(Mdl);
}

typedef struct __LIST_CONTROL_CONTEXT {
    PVOID                   MiniportContext;
    PVOID                   HwDeviceExtension;
    PVP_DMA_ADAPTER         VpDmaAdapter;
    PEXECUTE_DMA            ExecuteDmaRoutine;
    PVP_SCATTER_GATHER_LIST VpScatterGather;
    } LIST_CONTROL_CONTEXT, *PLIST_CONTROL_CONTEXT;


VP_STATUS
VideoPortStartDma(
    IN PVOID HwDeviceExtension,
    IN PVP_DMA_ADAPTER VpDmaAdapter,
    IN PVOID Mdl,
    IN ULONG Offset,
    IN OUT PULONG pLength,
    IN PEXECUTE_DMA ExecuteDmaRoutine,
    IN PVOID MiniportContext,
    IN BOOLEAN WriteToDevice 
    )

/*++

Routine Description:

    This function flushes the memory from caches of host processors and
    calls GetScatterGatherList to build scatter/gather list

Arguments:

    HwDeviceExtension - Points to the miniport driver's device extension.

    VpDmaAdapter      - Points to the VP_DMA_ADAPTER structure returned by 
                        VideoPortGetDmaAdapter.

    Mdl               - Points to the MDL that describes the buffer

    Offset            - The byte offset in the buffer from where DMA operation 
                        starts. 

    pLength           - Specifies the requested transfer size in bytes.
                        On return, this points to the actual size to be 
                        transferred.

    ExecuteDmaRoutine - Points to a miniport driver-supplied ExecuteDmaRoutine 
                        routine which will be called to program hardware 
                        registers to start actual DMA operation. 

    MiniportContext   - Points to the miniport driver-determined context to 
                        be passed to the ExecuteDmaRoutine. 

    WriteToDevice     - Indicates the direction of the DMA transfer: 
                        TRUE for a transfer from the buffer to the device,
                        and FALSE otherwise. 
Return Value:

    VP_STATUS

--*/

{
    KIRQL currentIrql;
    ULONG NumberOfMapRegisters;
    NTSTATUS ntStatus;
    PLIST_CONTROL_CONTEXT Context;
    PVOID CurrentVa;

    PFDO_EXTENSION fdoExtension = GET_FDO_EXT(HwDeviceExtension);

    Context = ( PLIST_CONTROL_CONTEXT )
                ExAllocatePoolWithTag ( NonPagedPool,
                                        sizeof(LIST_CONTROL_CONTEXT),
                                        VP_TAG );
    if (Context == NULL) {
        *pLength = 0;
        return ERROR_NOT_ENOUGH_MEMORY;
    }  

    //
    // Flush the buffer
    //

    KeFlushIoBuffers( Mdl, !WriteToDevice, TRUE );

    //
    // Calculate the number of map registers needed.
    //

    CurrentVa = (PVOID)((PUCHAR)MmGetMdlVirtualAddress((PMDL)Mdl) + Offset);

    NumberOfMapRegisters = ADDRESS_AND_SIZE_TO_SPAN_PAGES (CurrentVa, *pLength);
                                  
    //
    // If the number of map registers needed is greater than the maximum
    // number we can handle, we will do a partial transfer.
    //
    // We updated *pLength here so that it is safe to check this value 
    // when the miniport callback routine get called. 
    //

    if (NumberOfMapRegisters > VpDmaAdapter->NumberOfMapRegisters) {

        NumberOfMapRegisters = VpDmaAdapter->NumberOfMapRegisters;
        *pLength = NumberOfMapRegisters * PAGE_SIZE - BYTE_OFFSET(CurrentVa);

    }

    //
    //  Prepare Context for pVideoPortListControl
    //

    Context->HwDeviceExtension = HwDeviceExtension;
    Context->MiniportContext   = MiniportContext;
    Context->VpDmaAdapter      = VpDmaAdapter;
    Context->ExecuteDmaRoutine = ExecuteDmaRoutine;

    //
    //  Call GetScatterGatherList which will call pVideoPortListControl to 
    //  build scatter-gather list
    //

    KeRaiseIrql( DISPATCH_LEVEL, &currentIrql );

    ntStatus = DMA_OPERATION(GetScatterGatherList) (
                   VpDmaAdapter->DmaAdapterObject,       // AdapterObject
                   fdoExtension->FunctionalDeviceObject, // DeviceObject
                   Mdl,                                  // Mdl
                   CurrentVa,                            // CurrentVa
                   *pLength,                             // Transfer Size
                   pVideoPortListControl,                // ExecutionRoutine 
                   Context,                              // Context
                   WriteToDevice );                      // WriteToDevice

    KeLowerIrql(currentIrql);

    if(!NT_SUCCESS(ntStatus)) {

        *pLength = 0;
        ExFreePool((PVOID) Context);
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    return NO_ERROR;
}

BOOLEAN
pVideoPortSynchronizeExecuteDma(
    PLIST_CONTROL_CONTEXT Context
    )
{
    (Context->ExecuteDmaRoutine)( Context->HwDeviceExtension,
                                  Context->VpDmaAdapter,
                                  Context->VpScatterGather,
                                  Context->MiniportContext );
    return TRUE;
}

VOID
pVideoPortListControl (
    IN PDEVICE_OBJECT       DeviceObject,
    IN PIRP                 Irp,
    IN PSCATTER_GATHER_LIST ScatterGather,
    IN PVOID                ListControlContext
    )

/*++

Routine Description:

    Get scatter/gather list and calls the miniport callback function to
    start actual DMA transfer

Arguments:

Return Value:

    None

--*/

{
    PLIST_CONTROL_CONTEXT Context;
    PFDO_EXTENSION fdoExtension;
    PVP_SCATTER_GATHER_LIST VpScatterGather;

    Context         = (PLIST_CONTROL_CONTEXT)ListControlContext;
    fdoExtension    = GET_FDO_EXT(Context->HwDeviceExtension);
    VpScatterGather = (PVP_SCATTER_GATHER_LIST )(ScatterGather);

    Context->VpScatterGather = VpScatterGather;

    VideoPortSynchronizeExecution( fdoExtension->HwDeviceExtension,
                                   VpMediumPriority,
                                   pVideoPortSynchronizeExecuteDma,
                                   Context );

    ExFreePool((PVOID) Context);
}

VP_STATUS
VideoPortCompleteDma(
    IN PVOID                   HwDeviceExtension,
    IN PVP_DMA_ADAPTER         VpDmaAdapter,
    IN PVP_SCATTER_GATHER_LIST VpScatterGather,
    IN BOOLEAN                 WriteToDevice
    )

/*++

Routine Description:

    This function flushs the adapter buffers, frees the map registers and 
    frees the scatter/gather list previously allocated by GetScatterGatherList.

Arguments:

    HwDeviceExtension - Points to the miniport driver's device extension.
    VpScatterGather   - Points to a scatter/gather list previously passed 
                        to miniport callback routine ExecuteDmaRoutine. 
    WriteToDevice     - Indicates the direction of the DMA transfer: 
                        specify TRUE for a transfer from the buffer to 
                        the device, and FALSE otherwise. 

--*/

{

    KIRQL currentIrql;

    //
    // Call PutScatterGatherList to flush the adapter buffers, free 
    // the map registers and the scatter/gather list previously 
    // allocated by GetScatterGatherList.
    //

    KeRaiseIrql( DISPATCH_LEVEL, &currentIrql );
    
    DMA_OPERATION(PutScatterGatherList)( VpDmaAdapter->DmaAdapterObject,
                                         (PSCATTER_GATHER_LIST)VpScatterGather,
                                         WriteToDevice );
    KeLowerIrql(currentIrql);

    return NO_ERROR;
}

#if DBG
VOID
pDumpScatterGather(PVP_SCATTER_GATHER_LIST SGList)
{
   
    PVP_SCATTER_GATHER_ELEMENT Element;
    LONG i;

    pVideoDebugPrint((Info, "NumberOfElements = %d\n", SGList->NumberOfElements));

    Element = SGList->Elements;
    for(i = 0; i < (LONG)(SGList->NumberOfElements); i++) { 

        pVideoDebugPrint((Error, "Length = 0x%x, Address = 0x%x\n", 
                         Element[i].Length, Element[i].Address));
    }
}

#endif  // DBG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\modex\disp\palette.c ===
/******************************Module*Header*******************************\
* Module Name: palette.c
*
* Palette support.
*
* Copyright (c) 1992-1996 Microsoft Corporation
\**************************************************************************/

#include "precomp.h"

// Global Table defining the 20 Window default colours.  For 256 colour
// palettes the first 10 must be put at the beginning of the palette
// and the last 10 at the end of the palette.

PALETTEENTRY gapalBase[20] =
{
    { 0,   0,   0,   0 },       // 0
    { 0x80,0,   0,   0 },       // 1
    { 0,   0x80,0,   0 },       // 2
    { 0x80,0x80,0,   0 },       // 3
    { 0,   0,   0x80,0 },       // 4
    { 0x80,0,   0x80,0 },       // 5
    { 0,   0x80,0x80,0 },       // 6
    { 0xC0,0xC0,0xC0,0 },       // 7
    { 192, 220, 192, 0 },       // 8
    { 166, 202, 240, 0 },       // 9
    { 255, 251, 240, 0 },       // 10
    { 160, 160, 164, 0 },       // 11
    { 0x80,0x80,0x80,0 },       // 12
    { 0xFF,0,   0   ,0 },       // 13
    { 0,   0xFF,0   ,0 },       // 14
    { 0xFF,0xFF,0   ,0 },       // 15
    { 0   ,0,   0xFF,0 },       // 16
    { 0xFF,0,   0xFF,0 },       // 17
    { 0,   0xFF,0xFF,0 },       // 18
    { 0xFF,0xFF,0xFF,0 },       // 19
};

/******************************Public*Routine******************************\
* BOOL bInitializePalette
*
* Initializes default palette for PDEV.
*
\**************************************************************************/

BOOL bInitializePalette(
PDEV*    ppdev,
DEVINFO* pdi)
{
    PALETTEENTRY*   ppal;
    PALETTEENTRY*   ppalTmp;
    ULONG           ulLoop;
    BYTE            jRed;
    BYTE            jGre;
    BYTE            jBlu;
    HPALETTE        hpal;

    if (ppdev->iBitmapFormat == BMF_8BPP)
    {
        // Allocate our palette:

        ppal = EngAllocMem(FL_ZERO_MEMORY, sizeof(PALETTEENTRY) * 256, ALLOC_TAG);
        if (ppal == NULL)
            goto ReturnFalse;

        ppdev->pPal = ppal;

        // Generate 256 (8*4*4) RGB combinations to fill the palette

        jRed = 0;
        jGre = 0;
        jBlu = 0;

        ppalTmp = ppal;

        for (ulLoop = 256; ulLoop != 0; ulLoop--)
        {
            ppalTmp->peRed   = jRed;
            ppalTmp->peGreen = jGre;
            ppalTmp->peBlue  = jBlu;
            ppalTmp->peFlags = 0;

            ppalTmp++;

            if (!(jRed += 32))
                if (!(jGre += 32))
                    jBlu += 64;
        }

        // Fill in Windows reserved colours from the WIN 3.0 DDK
        // The Window Manager reserved the first and last 10 colours for
        // painting windows borders and for non-palette managed applications.

        for (ulLoop = 0; ulLoop < 10; ulLoop++)
        {
            // First 10

            ppal[ulLoop]       = gapalBase[ulLoop];

            // Last 10

            ppal[246 + ulLoop] = gapalBase[ulLoop+10];
        }

        // Create handle for palette.

        hpal = EngCreatePalette(PAL_INDEXED, 256, (ULONG*) ppal, 0, 0, 0);
    }
    else
    {
        ASSERTDD((ppdev->iBitmapFormat == BMF_16BPP) ||
         (ppdev->iBitmapFormat == BMF_24BPP) ||
         (ppdev->iBitmapFormat == BMF_32BPP),
         "This case handles only 16, 24 or 32bpp");

        hpal = EngCreatePalette(PAL_BITFIELDS, 0, NULL,
                                ppdev->flRed, ppdev->flGreen, ppdev->flBlue);
    }

    ppdev->hpalDefault = hpal;
    pdi->hpalDefault   = hpal;

    if (hpal == 0)
        goto ReturnFalse;

    return(TRUE);

ReturnFalse:

    DISPDBG((0, "Failed bInitializePalette"));
    return(FALSE);
}

/******************************Public*Routine******************************\
* VOID vUninitializePalette
*
* Frees resources allocated by bInitializePalette.
*
* Note: In an error case, this may be called before bInitializePalette.
*
\**************************************************************************/

VOID vUninitializePalette(PDEV* ppdev)
{
    // Delete the default palette if we created one:

    if (ppdev->hpalDefault != 0)
        EngDeletePalette(ppdev->hpalDefault);

    if (ppdev->pPal != (PALETTEENTRY*) NULL)
        EngFreeMem(ppdev->pPal);
}

/******************************Public*Routine******************************\
* BOOL bEnablePalette
*
* Initialize the hardware's 8bpp palette registers.
*
\**************************************************************************/

BOOL bEnablePalette(PDEV* ppdev)
{
    BYTE        ajClutSpace[MAX_CLUT_SIZE];
    PVIDEO_CLUT pScreenClut;
    ULONG       ulReturnedDataLength;
    ULONG       cColors;
    PVIDEO_CLUTDATA pScreenClutData;

    if (ppdev->iBitmapFormat == BMF_8BPP)
    {
        // Fill in pScreenClut header info:

        pScreenClut             = (PVIDEO_CLUT) ajClutSpace;
        pScreenClut->NumEntries = 256;
        pScreenClut->FirstEntry = 0;

        // Copy colours in:

        cColors = 256;
        pScreenClutData = (PVIDEO_CLUTDATA) (&(pScreenClut->LookupTable[0]));

        while(cColors--)
        {
            pScreenClutData[cColors].Red =    ppdev->pPal[cColors].peRed >>
                                              ppdev->cPaletteShift;
            pScreenClutData[cColors].Green =  ppdev->pPal[cColors].peGreen >>
                                              ppdev->cPaletteShift;
            pScreenClutData[cColors].Blue =   ppdev->pPal[cColors].peBlue >>
                                              ppdev->cPaletteShift;
            pScreenClutData[cColors].Unused = 0;
        }

        // Set palette registers:

        if (EngDeviceIoControl(ppdev->hDriver,
                               IOCTL_VIDEO_SET_COLOR_REGISTERS,
                               pScreenClut,
                               MAX_CLUT_SIZE,
                               NULL,
                               0,
                               &ulReturnedDataLength))
        {
            DISPDBG((0, "Failed bEnablePalette"));
            return(FALSE);
        }
    }

    DISPDBG((5, "Passed bEnablePalette"));

    return(TRUE);
}

/******************************Public*Routine******************************\
* VOID vDisablePalette
*
* Undoes anything done in bEnablePalette.
*
\**************************************************************************/

VOID vDisablePalette(
PDEV*   ppdev)
{
    // Nothin' to do
}

/******************************Public*Routine******************************\
* VOID vAssertModePalette
*
* Sets/resets the palette in preparation for full-screen/graphics mode.
*
\**************************************************************************/

VOID vAssertModePalette(
PDEV*   ppdev,
BOOL    bEnable)
{
    // USER immediately calls DrvSetPalette after switching out of
    // full-screen, so we don't have to worry about resetting the
    // palette here.
}

/******************************Public*Routine******************************\
* BOOL DrvSetPalette
*
* DDI entry point for manipulating the palette.
*
\**************************************************************************/

BOOL DrvSetPalette(
DHPDEV  dhpdev,
PALOBJ* ppalo,
FLONG   fl,
ULONG   iStart,
ULONG   cColors)
{
    BYTE            ajClutSpace[MAX_CLUT_SIZE];
    PVIDEO_CLUT     pScreenClut;
    PVIDEO_CLUTDATA pScreenClutData;
    PDEV*           ppdev;

    UNREFERENCED_PARAMETER(fl);

    ppdev = (PDEV*) dhpdev;

    // Fill in pScreenClut header info:

    pScreenClut             = (PVIDEO_CLUT) ajClutSpace;
    pScreenClut->NumEntries = (USHORT) cColors;
    pScreenClut->FirstEntry = (USHORT) iStart;

    pScreenClutData = (PVIDEO_CLUTDATA) (&(pScreenClut->LookupTable[0]));

    if (cColors != PALOBJ_cGetColors(ppalo, iStart, cColors,
                                     (ULONG*) pScreenClutData))
    {
        DISPDBG((0, "DrvSetPalette failed PALOBJ_cGetColors"));
        return (FALSE);
    }

    // Set the high reserved byte in each palette entry to 0.
    // Do the appropriate palette shifting to fit in the DAC.

    if (ppdev->cPaletteShift)
    {
        while(cColors--)
        {
            pScreenClutData[cColors].Red >>= ppdev->cPaletteShift;
            pScreenClutData[cColors].Green >>= ppdev->cPaletteShift;
            pScreenClutData[cColors].Blue >>= ppdev->cPaletteShift;
            pScreenClutData[cColors].Unused = 0;
        }
    }
    else
    {
        while(cColors--)
        {
            pScreenClutData[cColors].Unused = 0;
        }
    }

    // Set palette registers

    if (EngDeviceIoControl(ppdev->hDriver,
                           IOCTL_VIDEO_SET_COLOR_REGISTERS,
                           pScreenClut,
                           MAX_CLUT_SIZE,
                           NULL,
                           0,
                           &cColors))
    {
        DISPDBG((0, "DrvSetPalette failed SET_COLOR_REGISTERS"));
        return (FALSE);
    }

    return(TRUE);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\port\agp.c ===
/*++

Copyright (c) 1990-2000  Microsoft Corporation

Module Name:

    agp.c

Abstract:

    This is the agp portion of the video port driver.

Author:

    Erick Smith (ericks) Oct. 1997

Environment:

    kernel mode only

Revision History:

--*/


#include "videoprt.h"

#define AGP_PAGE_SIZE        PAGE_SIZE
#define AGP_BLOCK_SIZE       (AGP_PAGE_SIZE * 16)
#define AGP_CLUSTER_SIZE     (AGP_BLOCK_SIZE * 16)
#define PAGES_PER_BLOCK      (AGP_BLOCK_SIZE / AGP_PAGE_SIZE)
#define BLOCKS_PER_CLUSTER   (AGP_CLUSTER_SIZE / AGP_BLOCK_SIZE)

PVOID
AllocateReservedRegion(
    IN HANDLE ProcessHandle,
    IN ULONG Pages
    );

BOOLEAN
UpdateReservedRegion(
    IN PFDO_EXTENSION fdoExtension,
    IN PVIRTUAL_RESERVE_CONTEXT VirtualContext,
    IN ULONG Pages,
    IN ULONG Offset
    );

VOID
ReleaseReservedRegion(
    IN HANDLE ProcessHandle,
    IN PVOID VirtualAddress,
    IN ULONG Pages
    );


#if DBG
VOID
DumpBitField(
    PREGION Region
    );
#endif

#pragma alloc_text(PAGE,VpQueryAgpInterface)
#pragma alloc_text(PAGE,AgpReservePhysical)
#pragma alloc_text(PAGE,AgpReleasePhysical)
#pragma alloc_text(PAGE,AgpCommitPhysical)
#pragma alloc_text(PAGE,AgpFreePhysical)
#pragma alloc_text(PAGE,AgpReserveVirtual)
#pragma alloc_text(PAGE,AgpReleaseVirtual)
#pragma alloc_text(PAGE,AgpCommitVirtual)
#pragma alloc_text(PAGE,AgpFreeVirtual)
#pragma alloc_text(PAGE,AgpSetRate)
#pragma alloc_text(PAGE,VideoPortGetAgpServices)
#pragma alloc_text(PAGE,VpGetAgpServices2)
#pragma alloc_text(PAGE,AllocateReservedRegion)
#pragma alloc_text(PAGE,UpdateReservedRegion)
#pragma alloc_text(PAGE,ReleaseReservedRegion)
#pragma alloc_text(PAGE,CreateBitField)
#pragma alloc_text(PAGE,ModifyRegion)
#pragma alloc_text(PAGE,FindFirstRun)

#if DBG
#pragma alloc_text(PAGE,DumpBitField)
#endif

#if DBG
VOID
DumpBitField(
    PREGION Region
    )
{
    ULONG i;
    ULONG Index = 0;
    USHORT Mask = 1;

    ASSERT(Region != NULL);

    for (i=0; i<Region->Length; i++) {
        if (Mask & Region->BitField[Index]) {
            pVideoDebugPrint((1, "1"));
        } else {
            pVideoDebugPrint((1, "0"));
        }
        Mask <<= 1;
        if (Mask == 0) {
            Index++;
            Mask = 1;
        }
    }
    pVideoDebugPrint((1, "\n"));
}
#endif

BOOLEAN
CreateBitField(
    PREGION *Region,
    ULONG Length
    )

/*++

Routine Description:

    This routine creates and initializes a bitfield.

Arguments:

    Length - Number of items to track.

    Region - Location in which to store the pointer to the REGION handle.

Returns:

    TRUE - the the bitfield was created successfully,
    FALSE - otherwise.

--*/

{
    ULONG NumWords = (Length + 15) / 16;
    BOOLEAN bRet = FALSE;
    PREGION Buffer;

    ASSERT(Length != 0);

    Buffer = (PREGION) ExAllocatePoolWithTag(PagedPool | POOL_COLD_ALLOCATION, sizeof(REGION) + (NumWords - 1) * sizeof(USHORT), VP_TAG);

    if (Buffer) {

        Buffer->Length = Length;
        Buffer->NumWords = NumWords;
        RtlZeroMemory(Buffer->BitField, NumWords * sizeof(USHORT));

        bRet = TRUE;
    }

    *Region = Buffer;
    return bRet;
}

VOID
ModifyRegion(
    PREGION Region,
    ULONG Offset,
    ULONG Length,
    BOOLEAN Set
    )

/*++

Routine Description:

    Sets 'Length' bits starting at position 'Offset' in the bitfield.

Arguments:

    Region - Pointer to the region to modify.

    Offset - Offset into the bitfield at which to start.

    Length - Number of bits to set.

    Set - TRUE if you want to set the region, FALSE to clear it.


--*/

{
    ULONG Index = Offset / 16;
    ULONG Count = ((Offset + Length - 1) / 16) - Index;
    USHORT lMask = ~((1 << (Offset & 15)) - 1);
    USHORT rMask = ((1 << ((Offset + Length - 1) & 15)) * 2) - 1;
    PUSHORT ptr = &Region->BitField[Index];

    ASSERT(Region != NULL);
    ASSERT(Length != 0);

    if (Count == 0) {

        //
        // Only one WORD is modified, so combine left and right masks.
        //

        lMask &= rMask;
    }

    if (Set) {

        *ptr++ |= lMask;

        while (Count > 1) {
            *ptr++ |= 0xFFFF;
            Count--;
        }

        if (Count) {
            *ptr |= rMask;
        }

    } else {

        *ptr++ &= ~lMask;

        while (Count > 1) {
            *ptr++ &= 0;
            Count--;
        }

        if (Count) {
            *ptr++ &= ~rMask;
        }
    }

#if DBG
    pVideoDebugPrint((1, "Current BitField for Region: 0x%x\n", Region));
    //DumpBitField(Region);
#endif
}

BOOLEAN
FindFirstRun(
    PREGION Region,
    PULONG Offset,
    PULONG Length
    )

/*++

Routine Description:

    This routine finds the first run of bits in a bitfield.

Arguments:

    Region - Pointer to the region to operate on.

    Offset - Pointer to a ULONG to hold the offset of the run.

    Length - Pointer to a ULONG to hold the length of a run.

Returns:

    TRUE if a run was detected,
    FALSE otherwise.

--*/

{
    PUSHORT ptr = Region->BitField;
    ULONG Index = 0;
    USHORT BitMask;
    ULONG lsb;
    ULONG Count;
    USHORT ptrVal;

    ASSERT(Region != NULL);
    ASSERT(Offset != NULL);
    ASSERT(Length != NULL);

    while ((Index < Region->NumWords) && (*ptr == 0)) {
        ptr++;
        Index++;
    }

    if (Index == Region->NumWords) {
        return FALSE;
    }

    //
    // Find least significant bit
    //

    lsb = 0;
    ptrVal = *ptr;
    BitMask = 1;

    while ((ptrVal & BitMask) == 0) {
        BitMask <<= 1;
        lsb++;
    }

    *Offset = (Index * 16) + lsb;

    //
    // Determine the run length
    //

    Count = 0;

    while (Index < Region->NumWords) {
        if (ptrVal & BitMask) {
            BitMask <<= 1;
            Count++;

            if (BitMask == 0) {
                BitMask = 0x1;
                Index++;
                ptrVal = *++ptr;
                while ((ptrVal == 0xFFFF) && (Index < Region->NumWords)) {
                    Index++;
                    Count += 16;
                    ptrVal = *ptr++;
                }
            }

        } else {
            break;
        }
    }

    *Length = Count;
    return TRUE;
}

BOOLEAN
VpQueryAgpInterface(
    PFDO_EXTENSION FdoExtension,
    USHORT InterfaceVersion
    )

/*++

Routine Description:

    Send a QueryInterface Irp to our parent (the PCI bus driver) to
    retrieve the AGP_BUS_INTERFACE.

Returns:

    NT_STATUS code

--*/

{
    KEVENT             Event;
    PIRP               QueryIrp = NULL;
    IO_STATUS_BLOCK    IoStatusBlock;
    PIO_STACK_LOCATION NextStack;
    NTSTATUS           Status;

    ASSERT(FdoExtension != NULL);

    KeInitializeEvent(&Event, SynchronizationEvent, FALSE);

    QueryIrp = IoBuildSynchronousFsdRequest(IRP_MJ_FLUSH_BUFFERS,
                                            FdoExtension->AttachedDeviceObject,
                                            NULL,
                                            0,
                                            NULL,
                                            &Event,
                                            &IoStatusBlock);

    if (QueryIrp == NULL) {
        return FALSE;
    }

    NextStack = IoGetNextIrpStackLocation(QueryIrp);

    //
    // Set the default error code.
    //

    QueryIrp->IoStatus.Status = IoStatusBlock.Status = STATUS_NOT_SUPPORTED;

    //
    // Set up for a QueryInterface Irp.
    //

    NextStack->MajorFunction = IRP_MJ_PNP;
    NextStack->MinorFunction = IRP_MN_QUERY_INTERFACE;

    NextStack->Parameters.QueryInterface.InterfaceType = &GUID_AGP_BUS_INTERFACE_STANDARD;
    NextStack->Parameters.QueryInterface.Size = sizeof(AGP_BUS_INTERFACE_STANDARD);
    NextStack->Parameters.QueryInterface.Version = InterfaceVersion;
    NextStack->Parameters.QueryInterface.Interface = (PINTERFACE) &FdoExtension->AgpInterface;
    NextStack->Parameters.QueryInterface.InterfaceSpecificData = NULL;

    FdoExtension->AgpInterface.Size = sizeof(AGP_BUS_INTERFACE_STANDARD);
    FdoExtension->AgpInterface.Version = InterfaceVersion;

    Status = IoCallDriver(FdoExtension->AttachedDeviceObject, QueryIrp);

    if (Status == STATUS_PENDING) {
        KeWaitForSingleObject(&Event, Executive, KernelMode, FALSE, NULL);
        Status = IoStatusBlock.Status;
    }

    return NT_SUCCESS(Status);
}

PHYSICAL_ADDRESS
AgpReservePhysical(
    IN PVOID Context,
    IN ULONG Pages,
    IN VIDEO_PORT_CACHE_TYPE Caching,
    OUT PVOID *PhysicalReserveContext
    )

/*++

Routine Description:

    Reserves a range of physical addresses for AGP.

Arguments:

    Context - The Agp Context

    Pages - Number of pages to reserve

    Caching - Specifies the type of caching to use

    PhysicalReserveContext - Location to store our reservation context.

Returns:

    The base of the physical address range reserved.

--*/

{
    PFDO_EXTENSION fdoExtension = GET_FDO_EXT(Context);
    PHYSICAL_ADDRESS PhysicalAddress = {0,0};
    NTSTATUS status = STATUS_INSUFFICIENT_RESOURCES;
    PPHYSICAL_RESERVE_CONTEXT ReserveContext;
    PVOID MapHandle;
    ULONG Blocks;
    MEMORY_CACHING_TYPE CacheType;

    ASSERT(PhysicalReserveContext != NULL);
    ASSERT(Caching <= VpCached);

    Pages = (Pages + PAGES_PER_BLOCK - 1) & ~(PAGES_PER_BLOCK - 1);
    Blocks = Pages / PAGES_PER_BLOCK;

    pVideoDebugPrint((1, "AGP: Reserving 0x%x Pages of Address Space\n", Pages));

    switch (Caching) {
    case VpNonCached:     CacheType = MmNonCached;     break;
    case VpWriteCombined: CacheType = MmWriteCombined; break;
    case VpCached:        CacheType = MmCached;        break;
    }

    ReserveContext = ExAllocatePoolWithTag(PagedPool | POOL_COLD_ALLOCATION,
                                           sizeof(PHYSICAL_RESERVE_CONTEXT),
                                           VP_TAG);

    if (ReserveContext) {

        RtlZeroMemory(ReserveContext, sizeof(PHYSICAL_RESERVE_CONTEXT));

        if (CreateBitField(&ReserveContext->MapTable, Blocks)) {

            if (CreateBitField(&ReserveContext->Region, Pages)) {

                status = fdoExtension->AgpInterface.ReserveMemory(
                             fdoExtension->AgpInterface.AgpContext,
                             Pages,
                             CacheType,
                             &MapHandle,
                             &PhysicalAddress);

                if (NT_SUCCESS(status)) {

                    ReserveContext->Pages = Pages;
                    ReserveContext->Caching = CacheType;
                    ReserveContext->MapHandle = MapHandle;
                    ReserveContext->PhysicalAddress = PhysicalAddress;

                }
            }
        }
    }

    if (NT_SUCCESS(status) == FALSE) {

        if (ReserveContext) {

            if (ReserveContext->Region) {
                ExFreePool(ReserveContext->Region);
            }

            if (ReserveContext->MapTable) {
                ExFreePool(ReserveContext->MapTable);
            }

            ExFreePool(ReserveContext);
            ReserveContext = NULL;
        }

        PhysicalAddress.QuadPart = 0;
    }

    *PhysicalReserveContext = ReserveContext;
    return PhysicalAddress;
}

VOID
AgpReleasePhysical(
    PVOID Context,
    PVOID PhysicalReserveContext
    )

/*++

Routine Description:

    Releases a range of reserved physical address.

Arguments:

    Context - The Agp Context

    PhysicalReserveContext - The reservation context.

Returns:

    none.

--*/

{
    PFDO_EXTENSION fdoExtension = GET_FDO_EXT(Context);
    PPHYSICAL_RESERVE_CONTEXT ReserveContext;
    ULONG Pages;
    ULONG Offset;

    ASSERT(PhysicalReserveContext != NULL);

    ReserveContext = (PPHYSICAL_RESERVE_CONTEXT) PhysicalReserveContext;

    pVideoDebugPrint((1, "AGP: Releasing 0x%x Pages of Address Space\n", ReserveContext->Pages));

    //
    // Make sure all pages have been freed
    //

    while (FindFirstRun(ReserveContext->Region, &Offset, &Pages)) {
        AgpFreePhysical(Context, PhysicalReserveContext, Pages, Offset);
    }

    fdoExtension->AgpInterface.ReleaseMemory(fdoExtension->AgpInterface.AgpContext,
                                             ReserveContext->MapHandle);

    ExFreePool(ReserveContext->Region);
    ExFreePool(ReserveContext->MapTable);
    ExFreePool(ReserveContext);
}

BOOLEAN
AgpCommitPhysical(
    PVOID Context,
    PVOID PhysicalReserveContext,
    ULONG Pages,
    ULONG Offset
    )

/*++

Routine Description:

    Locks down system memory and backs a portion of the reserved region.

Arguments:

    Context - The Agp Context

    PhysicalReserveContext - The reservation context.

    Pages - Number of pages to commit.

    Offset - The offset into the reserved region at which to commit the pages.

Returns:

    TRUE if successful,
    FALSE otherwise.

--*/

{
    PFDO_EXTENSION fdoExtension = GET_FDO_EXT(Context);
    PHYSICAL_ADDRESS MemoryBase = {0,0};
    PPHYSICAL_RESERVE_CONTEXT ReserveContext;
    NTSTATUS status;
    PMDL Mdl;
    ULONG StartBlock = Offset / PAGES_PER_BLOCK;
    ULONG EndBlock = (Offset + Pages + PAGES_PER_BLOCK - 1) / PAGES_PER_BLOCK;
    ULONG i;
    PUSHORT MapTable;
    PUSHORT BitField;

    ASSERT(PhysicalReserveContext != NULL);
    ASSERT(Pages != 0);

    ReserveContext = (PPHYSICAL_RESERVE_CONTEXT) PhysicalReserveContext;
    MapTable = ReserveContext->MapTable->BitField;
    BitField = ReserveContext->Region->BitField;

    //
    // Try to commit the new pages.  The agp filter driver handles
    // the case where some of these pages are already committed, so
    // lets try to get them all at once.
    //

    status =
        fdoExtension->AgpInterface.CommitMemory(
            fdoExtension->AgpInterface.AgpContext,
            ReserveContext->MapHandle,
            PAGES_PER_BLOCK * (EndBlock - StartBlock),
            Offset & ~(PAGES_PER_BLOCK - 1),
            NULL,
            &MemoryBase);

    if (NT_SUCCESS(status)) {

        ModifyRegion(ReserveContext->Region, Offset, Pages, TRUE);

        for (i=StartBlock; i<EndBlock; i++) {

            ULONG Cluster = i / BLOCKS_PER_CLUSTER;
            ULONG Block = 1 << (i & (BLOCKS_PER_CLUSTER - 1));

            //
            // Update the MapTable for the committed pages.
            //

            MapTable[Cluster] |= Block;
        }

    } else {

        pVideoDebugPrint((0, "Commit Physical failed with status: 0x%x\n", status));
    }

    return NT_SUCCESS(status);
}

VOID
AgpFreePhysical(
    IN PVOID Context,
    IN PVOID PhysicalReserveContext,
    IN ULONG Pages,
    IN ULONG Offset
    )

/*++

Routine Description:

    Releases the memory used to back a portion of the reserved region.

Arguments:

    Context - The Agp Context

    PhysicalReserveContext - The reservation context.

    Pages - Number of pages to release.

    Offset - The offset into the reserved region at which to release the pages.

Returns:

    none.

--*/

{
    PFDO_EXTENSION fdoExtension = GET_FDO_EXT(Context);
    PPHYSICAL_RESERVE_CONTEXT ReserveContext;
    PMDL Mdl;
    ULONG StartBlock = Offset / PAGES_PER_BLOCK;
    ULONG EndBlock = (Offset + Pages + PAGES_PER_BLOCK - 1) / PAGES_PER_BLOCK;
    ULONG i;
    PUSHORT MapTable;
    PUSHORT BitField;

    ASSERT(PhysicalReserveContext != NULL);
    ASSERT(Pages != 0);

    ReserveContext = (PPHYSICAL_RESERVE_CONTEXT) PhysicalReserveContext;
    MapTable = ReserveContext->MapTable->BitField;
    BitField = ReserveContext->Region->BitField;

    ModifyRegion(ReserveContext->Region, Offset, Pages, FALSE);

    //
    // Postion the offset to the start of the first block
    //

    Offset = Offset & ~(PAGES_PER_BLOCK - 1);

    for (i=StartBlock; i<EndBlock; i++) {

        ULONG Cluster = i / BLOCKS_PER_CLUSTER;
        ULONG Block = 1 << (i & (BLOCKS_PER_CLUSTER - 1));

        //
        // If this block is mapped, then release it.
        //

        if ((BitField[i] == 0) && (MapTable[Cluster] & Block)) {

            fdoExtension->AgpInterface.FreeMemory(
                fdoExtension->AgpInterface.AgpContext,
                ReserveContext->MapHandle,
                PAGES_PER_BLOCK,
                Offset);

            MapTable[Cluster] &= ~Block;
        }

        //
        // Go to the next 64k block
        //

        Offset += PAGES_PER_BLOCK;
    }
}


PVOID
AgpReserveVirtual(
    IN PVOID Context,
    IN HANDLE ProcessHandle,
    IN PVOID PhysicalReserveContext,
    OUT PVOID *VirtualReserveContext
    )

/*++

Routine Description:

    Reserves a range of virtual addresses for AGP.

Arguments:

    Context - The Agp Context

    ProcessHandle - The handle of the process in which to reserve the
        virtual address range.

    PhysicalReserveContext - The physical reservation context to assoctiate
        with the given virtual reservation.

    VirtualReserveContext - The location in which to store the virtual
        reserve context.

Returns:

    The base of the virtual address range reserved.

Notes:

    You can't reserve a range of kernel address space, but if you want to
    commit into kernel space you still need a reservation handle.  Pass in
    NULL for the process handle in this case.

    For the moment, we'll commit the entire region when the do a reservation
    in kernel space.  Then Commit and Free will be no-ops.

--*/

{
    PFDO_EXTENSION fdoExtension = GET_FDO_EXT(Context);
    NTSTATUS status = STATUS_SUCCESS;
    ULONG Protect = PAGE_READWRITE;
    PVIRTUAL_RESERVE_CONTEXT ReserveContext;
    PPHYSICAL_RESERVE_CONTEXT PhysicalContext;
    PVOID VirtualAddress = NULL;
    PEPROCESS Process = NULL;
    ULONG Blocks;

    ASSERT(PhysicalReserveContext != NULL);
    ASSERT(VirtualReserveContext != NULL);

    PhysicalContext = (PPHYSICAL_RESERVE_CONTEXT) PhysicalReserveContext;
    Blocks = (PhysicalContext->Pages + PAGES_PER_BLOCK - 1) / PAGES_PER_BLOCK;

    ReserveContext = ExAllocatePoolWithTag(PagedPool | POOL_COLD_ALLOCATION,
                                           sizeof(VIRTUAL_RESERVE_CONTEXT),
                                           VP_TAG);

    if (ReserveContext) {

        RtlZeroMemory(ReserveContext, sizeof(VIRTUAL_RESERVE_CONTEXT));

        if (CreateBitField(&ReserveContext->MapTable, Blocks)) {

            if (CreateBitField(&ReserveContext->Region, PhysicalContext->Pages)) {

                if (PhysicalContext->Caching == MmNonCached) {
                    Protect |= PAGE_NOCACHE;
                }

                //
                // Make sure we have the real process handle.
                //

                if (ProcessHandle == NtCurrentProcess()) {
                    Process = PsGetCurrentProcess();
                }

                ReserveContext->ProcessHandle = ProcessHandle;
                ReserveContext->Process = Process;
                ReserveContext->PhysicalReserveContext =
                    (PPHYSICAL_RESERVE_CONTEXT) PhysicalReserveContext;

                if (ProcessHandle) {

                    VirtualAddress =
                        AllocateReservedRegion(
                            ProcessHandle,
                            PhysicalContext->Pages);

                } else {

                    //
                    // For a kernel reservation, go ahead and commit the
                    // entire range.
                    //

                    if (fdoExtension->AgpInterface.Capabilities &
                        AGP_CAPABILITIES_MAP_PHYSICAL)
                    {
                        //
                        // CPU can access AGP memory through AGP aperature.
                        //

                        VirtualAddress =
                            MmMapIoSpace(PhysicalContext->PhysicalAddress,
                                         PhysicalContext->Pages * AGP_PAGE_SIZE,
                                         PhysicalContext->Caching);

                        //
                        // Not all systems support USWC, so if we attempted to map USWC
                        // and failed, try again with just non-cached.
                        //

                        if ((VirtualAddress == NULL) &&
                            (PhysicalContext->Caching != MmNonCached)) {

                            pVideoDebugPrint((1, "Attempt to map cached memory failed.  Try uncached.\n"));

                            VirtualAddress = MmMapIoSpace(PhysicalContext->PhysicalAddress,
                                                          PhysicalContext->Pages * AGP_PAGE_SIZE,
                                                          MmNonCached);
                        }

                    } else {

                        PMDL Mdl;

                        //
                        // Get the MDL for the range we are trying to map.
                        //

                        Mdl = MmCreateMdl(NULL, NULL, PhysicalContext->Pages * AGP_PAGE_SIZE);

                        if (Mdl) {

                            fdoExtension->AgpInterface.GetMappedPages(
                                             fdoExtension->AgpInterface.AgpContext,
                                             PhysicalContext->MapHandle,
                                             PhysicalContext->Pages,
                                             0,
                                             Mdl);

                            Mdl->MdlFlags |= MDL_PAGES_LOCKED | MDL_MAPPING_CAN_FAIL;

                            //
                            // We must use the CPU's virtual memory mechanism to
                            // make the non-contiguous MDL look contiguous.
                            //

                            VirtualAddress =
                                MmMapLockedPagesSpecifyCache(
                                    Mdl,
                                    (KPROCESSOR_MODE)KernelMode,
                                    PhysicalContext->Caching,
                                    NULL,
                                    TRUE,
                                    HighPagePriority);

                            ExFreePool(Mdl);
                        }
                    }
                }

                ReserveContext->VirtualAddress = VirtualAddress;
            }
        }
    }

    //
    // If anything failed, make sure we clean everything up.
    //

    if (VirtualAddress == NULL) {

        if (ReserveContext) {

            if (ReserveContext->Region) {
                ExFreePool(ReserveContext->Region);
            }

            if (ReserveContext->MapTable) {
                ExFreePool(ReserveContext->MapTable);
            }

            ExFreePool(ReserveContext);
            ReserveContext = NULL;
        }
    }

    *VirtualReserveContext = ReserveContext;
    return VirtualAddress;
}

VOID
AgpReleaseVirtual(
    IN PVOID Context,
    IN PVOID VirtualReserveContext
    )

/*++

Routine Description:

    Releases a range of reserved virtual addresses.

Arguments:

    Context - The Agp Context

    VirtualReserveContext - The reservation context.

Returns:

    none.

--*/

{
    PFDO_EXTENSION fdoExtension = GET_FDO_EXT(Context);
    PVIRTUAL_RESERVE_CONTEXT VirtualContext;
    PPHYSICAL_RESERVE_CONTEXT PhysicalContext;
    BOOLEAN Attached = FALSE;
    ULONG Offset;
    ULONG Pages;

    ASSERT(VirtualReserveContext != NULL);

    VirtualContext = (PVIRTUAL_RESERVE_CONTEXT) VirtualReserveContext;
    PhysicalContext = VirtualContext->PhysicalReserveContext;

    if (VirtualContext->ProcessHandle) {

        //
        // Make sure all pages have been freed
        //

        while (FindFirstRun(VirtualContext->Region, &Offset, &Pages)) {
            AgpFreeVirtual(Context, VirtualReserveContext, Pages, Offset);
        }

        //
        // Now release all the reserved pages
        //

        if (VirtualContext->ProcessHandle == NtCurrentProcess()) {

            if (VirtualContext->Process != PsGetCurrentProcess()) {

                KeAttachProcess(PEProcessToPKProcess(VirtualContext->Process));
                Attached = TRUE;
            }
        }

        ReleaseReservedRegion(
            VirtualContext->ProcessHandle,
            VirtualContext->VirtualAddress,
            VirtualContext->PhysicalReserveContext->Pages);

        if (Attached) {
            KeDetachProcess();
        }

    } else {

        //
        // This was kernel virtual memory, so release the memory we
        // committed at reserve time.
        //

        if (fdoExtension->AgpInterface.Capabilities &
            AGP_CAPABILITIES_MAP_PHYSICAL)
        {
            MmUnmapIoSpace(VirtualContext->VirtualAddress,
                           PhysicalContext->Pages * AGP_PAGE_SIZE);

        } else {

            PMDL Mdl;

            //
            // Get the MDL for the range we are trying to free.
            //

            Mdl = MmCreateMdl(NULL, NULL, PhysicalContext->Pages * AGP_PAGE_SIZE);

            if (Mdl) {

                fdoExtension->AgpInterface.GetMappedPages(
                                fdoExtension->AgpInterface.AgpContext,
                                PhysicalContext->MapHandle,
                                PhysicalContext->Pages,
                                0,
                                Mdl);

                Mdl->MdlFlags |= MDL_PAGES_LOCKED;
                Mdl->MdlFlags |= MDL_MAPPED_TO_SYSTEM_VA;
                Mdl->MappedSystemVa = VirtualContext->VirtualAddress;

                MmUnmapLockedPages(
                    VirtualContext->VirtualAddress,
                    Mdl);

                ExFreePool(Mdl);

            } else {

                //
                // We couldn't free the memory because we couldn't allocate
                // memory for the MDL.  We can free a small chunk at a time
                // by using a MDL on the stack.
                //

                ASSERT(FALSE);
            }
        }
    }

    ExFreePool(VirtualContext->Region);
    ExFreePool(VirtualContext->MapTable);
    ExFreePool(VirtualContext);
}

PVOID
AllocateReservedRegion(
    IN HANDLE ProcessHandle,
    IN ULONG Pages
    )

/*++

Routine Description:

    Reserves a range of user mode virtual addresses.

Arguments:

    ProcessHandle - The process in which we need to modify the mappings.

    Pages - The number of pages to reserve.

Returns:

    Pointer to the reserved region of memory.

--*/

{
    NTSTATUS Status;
    ULONG_PTR VirtualAddress = 0;
    ULONG Blocks = (Pages + PAGES_PER_BLOCK - 1) / PAGES_PER_BLOCK;

    //
    // Pad the length so we can get an AGP_BLOCK_SIZE aligned region.
    //

    SIZE_T Length = Blocks * AGP_BLOCK_SIZE + AGP_BLOCK_SIZE - PAGE_SIZE;

    ASSERT(ProcessHandle != 0);
    ASSERT(Pages != 0);

    //
    // Find a chunk of virtual addresses where we can put our reserved
    // region.
    //
    // Note: We are using ZwAllocateVirtualMemory to reserve the memory,
    // but ZwMapViewOfSection to commit pages.  Since ZwMapViewOfSection
    // wants to align to 64K, lets try to get a 64K aligned pointer.
    //

    Status =
        ZwAllocateVirtualMemory(
            ProcessHandle,
            (PVOID)&VirtualAddress,
            0,
            &Length,
            MEM_RESERVE,
            PAGE_READWRITE);

    if (NT_SUCCESS(Status)) {

        ULONG_PTR NewAddress = (VirtualAddress + AGP_BLOCK_SIZE - 1) & ~(AGP_BLOCK_SIZE - 1);
        ULONG i;

        pVideoDebugPrint((1, "Reserved 0x%x, length = 0x%x\n", VirtualAddress, Length));

        //
        // We were able to reserve a region of memory.  Now lets free it, and
        // reallocate in AGP_BLOCK_SIZE size blocks.
        //

        ZwFreeVirtualMemory(
            ProcessHandle,
            (PVOID)&VirtualAddress,
            &Length,
            MEM_RELEASE);

        //
        // Reserve the memory again in 64k chunks.
        //

        VirtualAddress = NewAddress;
        Length = AGP_BLOCK_SIZE;

        for (i=0; i<Blocks; i++) {

            Status =
                ZwAllocateVirtualMemory(
                    ProcessHandle,
                    (PVOID)&VirtualAddress,
                    0,
                    &Length,
                    MEM_RESERVE,
                    PAGE_READWRITE);

            if (NT_SUCCESS(Status) == FALSE) {

                break;
            }

            VirtualAddress += AGP_BLOCK_SIZE;
        }

        if (NT_SUCCESS(Status) == FALSE) {

            //
            // clean up and return error
            //

            VirtualAddress = NewAddress;

            while (i--) {

                ZwFreeVirtualMemory(
                    ProcessHandle,
                    (PVOID)&VirtualAddress,
                    &Length,
                    MEM_RELEASE);

                VirtualAddress += AGP_BLOCK_SIZE;
            }

            //
            // Indicate we failed to reserve the memory
            //

            pVideoDebugPrint((0, "We failed to allocate the reserved region\n"));
            return NULL;
        }

        return (PVOID)NewAddress;

    } else {

        pVideoDebugPrint((0, "AllocateReservedRegion Failed: Status = 0x%x\n", Status));
        ASSERT(FALSE);

        return NULL;
    }
}

VOID
ReleaseReservedRegion(
    IN HANDLE ProcessHandle,
    IN PVOID VirtualAddress,
    IN ULONG Pages
    )

/*++

Routine Description:

    Reserves a range of user mode virtual addresses.

Arguments:

    ProcessHandle - The process in which we need to modify the mappings.

    Pages - The number of pages to reserve.

Returns:

    Pointer to the reserved region of memory.

--*/

{
    NTSTATUS Status;
    ULONG_PTR RunningVirtualAddress = (ULONG_PTR)VirtualAddress;
    ULONG Blocks = (Pages + PAGES_PER_BLOCK - 1) / PAGES_PER_BLOCK;
    ULONG i;
    SIZE_T Length = AGP_BLOCK_SIZE;

    ASSERT(ProcessHandle != 0);
    ASSERT(Pages != 0);

    //
    // Individually release each block we have reserved.
    //

    for (i=0; i<Blocks; i++) {

        Status =
            ZwFreeVirtualMemory(
                ProcessHandle,
                (PVOID)&RunningVirtualAddress,
                &Length,
                MEM_RELEASE);

        RunningVirtualAddress += AGP_BLOCK_SIZE;

        if (NT_SUCCESS(Status) == FALSE) {

            pVideoDebugPrint((0, "ReleaseReservedRegion Failed: Status = 0x%x\n", Status));
            ASSERT(FALSE);
        }
    }
}

NTSTATUS
MapBlock(
    IN PFDO_EXTENSION fdoExtension,
    IN PVIRTUAL_RESERVE_CONTEXT VirtualContext,
    IN HANDLE ProcessHandle,
    IN PHYSICAL_ADDRESS *PhysicalAddress,
    IN PVOID VirtualAddress,
    IN ULONG Protect,
    IN BOOLEAN Release
    )

/*++

Routine Desciption:

Notes:

    This function assumes it is being calling within the context of the
    correct process.

--*/

{
    NTSTATUS ntStatus;

    if (Release) {

        if (fdoExtension->AgpInterface.Capabilities &
            AGP_CAPABILITIES_MAP_PHYSICAL)
        {
            ZwUnmapViewOfSection(
                VirtualContext->ProcessHandle,
                VirtualAddress);

        } else {

            PMDL Mdl;

            //
            // Get the MDL for the range we are trying to map.
            //

            Mdl = MmCreateMdl(NULL, NULL, AGP_BLOCK_SIZE);

            if (Mdl) {

                ULONG Offset;

                //
                // Calculate the offset into the range
                //

                Offset = (ULONG)(((ULONG_PTR)VirtualAddress - (ULONG_PTR)VirtualContext->VirtualAddress) / PAGE_SIZE);


                fdoExtension->AgpInterface.GetMappedPages(
                                fdoExtension->AgpInterface.AgpContext,
                                VirtualContext->PhysicalReserveContext->MapHandle,
                                AGP_BLOCK_SIZE / PAGE_SIZE,
                                Offset,
                                Mdl);

                Mdl->MdlFlags |= MDL_PAGES_LOCKED;

                MmUnmapLockedPages(
                    VirtualAddress,
                    Mdl);

                ExFreePool(Mdl);

            } else {

                //
                // We couldn't free the memory because we couldn't allocate
                // memory for the MDL.  We can free a small chunk at a time
                // by using a MDL on the stack.
                //

                ASSERT(FALSE);
            }
        }

        ntStatus = STATUS_SUCCESS;

    } else {

        if (fdoExtension->AgpInterface.Capabilities &
            AGP_CAPABILITIES_MAP_PHYSICAL)
        {
            HANDLE PhysicalMemoryHandle;

            //
            // CPU can access AGP memory through AGP aperature.
            //

            //
            // Get a handle to the physical memory section using our pointer.
            // If this fails, return.
            //

            ntStatus =
                ObOpenObjectByPointer(
                    PhysicalMemorySection,
                    0L,
                    (PACCESS_STATE) NULL,
                    SECTION_ALL_ACCESS,
                    (POBJECT_TYPE) NULL,
                    KernelMode,
                    &PhysicalMemoryHandle);

            //
            // If successful, map the memory.
            //

            if (NT_SUCCESS(ntStatus)) {

                SIZE_T Length = AGP_BLOCK_SIZE;

                pVideoDebugPrint((2, "Mapping VA 0x%x for 0x%x bytes.\n",
                                     VirtualAddress,
                                     Length));

                ntStatus =
                    ZwMapViewOfSection(
                        PhysicalMemoryHandle,
                        ProcessHandle,
                        &VirtualAddress,
                        0,
                        AGP_BLOCK_SIZE,
                        PhysicalAddress,
                        &Length,
                        ViewUnmap,
                        0,
                        Protect);

                if (NT_SUCCESS(ntStatus) == FALSE) {
                    pVideoDebugPrint((1, "ntStatus = 0x%x\n", ntStatus));
                }

                ZwClose(PhysicalMemoryHandle);
            }

        } else {

            PMDL Mdl;

            //
            // Get the MDL for the range we are trying to map.
            //

            Mdl = MmCreateMdl(NULL, NULL, AGP_BLOCK_SIZE);

            if (Mdl) {

                ULONG Offset;

                //
                // Calculate the offset into the range
                //

                Offset = (ULONG)(((ULONG_PTR)VirtualAddress - (ULONG_PTR)VirtualContext->VirtualAddress) / PAGE_SIZE);

                fdoExtension->AgpInterface.GetMappedPages(
                                 fdoExtension->AgpInterface.AgpContext,
                                 VirtualContext->PhysicalReserveContext->MapHandle,
                                 AGP_BLOCK_SIZE / PAGE_SIZE,
                                 Offset,
                                 Mdl);

                Mdl->MdlFlags |= MDL_PAGES_LOCKED | MDL_MAPPING_CAN_FAIL;

                //
                // We must use the CPU's virtual memory mechanism to
                // make the non-contiguous MDL look contiguous.
                //

                VirtualAddress =
                    MmMapLockedPagesSpecifyCache(
                        Mdl,
                        (KPROCESSOR_MODE)UserMode,
                        VirtualContext->PhysicalReserveContext->Caching,
                        (PVOID)VirtualAddress,
                        TRUE,
                        HighPagePriority);

                ASSERT(VirtualAddress);

                ExFreePool(Mdl);
            }

            ntStatus = STATUS_SUCCESS;
        }
    }

    return ntStatus;
}

NTSTATUS
UpdateBlock(
    IN HANDLE ProcessHandle,
    IN PVOID VirtualAddress,
    IN ULONG Protect,
    IN BOOLEAN Release
    )

/*++

Routine Description:

    Marks a region of user mode memory as being either reserved, or
    available.

Arguments:

    ProcessHandle - The process in which we need to modify the mappings.

    VirtualAddress - The address to update

    Protect - Caching attributes

    Release - TRUE release the block, FALSE reserve it.

Returns:

    Status of the operation.

--*/

{
    NTSTATUS Status;
    SIZE_T Length = AGP_BLOCK_SIZE;

    pVideoDebugPrint((1, "Update VA 0x%x. Action = %s\n",
                         VirtualAddress,
                         Release ? "Release" : "Reserve"));

    if (Release) {

        Status =
            ZwFreeVirtualMemory(
                ProcessHandle,
                &VirtualAddress,
                &Length,
                MEM_RELEASE);

    } else {

        Status =
            ZwAllocateVirtualMemory(
                ProcessHandle,
                &VirtualAddress,
                0,
                &Length,
                MEM_RESERVE,
                Protect);
    }

    return Status;
}

BOOLEAN
UpdateReservedRegion(
    IN PFDO_EXTENSION fdoExtension,
    IN PVIRTUAL_RESERVE_CONTEXT VirtualContext,
    IN ULONG Pages,
    IN ULONG Offset
    )

/*++

Routine Description:

    Ensure that the range of pages specified is correctly reserved/released.

Arguments:

    fdoExtension - The device extension for the miniport.

    VirtualContext - The context for the reserved region to update.

    Pages - The number of 4K pages to reserve.

    Offset - The offset into the reserved region to update.

    Release - TRUE if we are releasing memory, FALSE otherwise.

Returns:

    TRUE success, FALSE at least a partial failure occured.

Notes:

    No cleanup is done on failure.  So part of the range may ultimately
    be mapped and the rest not.  This is ok.  The only side effect is that
    even though we return a failure we did do part of the work.  Our
    internal data structures remain in a consistent state.

--*/

{
    ULONG StartBlock = Offset / PAGES_PER_BLOCK;
    ULONG EndBlock = (Offset + Pages + PAGES_PER_BLOCK - 1) / PAGES_PER_BLOCK;
    ULONG Protect;
    ULONG i;

    NTSTATUS Status;

    PUSHORT BitField = VirtualContext->Region->BitField;
    PUSHORT MapTable = VirtualContext->MapTable->BitField;

    HANDLE Process = VirtualContext->ProcessHandle;
    PVOID VirtualAddress = (PUCHAR)VirtualContext->VirtualAddress + StartBlock * AGP_BLOCK_SIZE;

    PHYSICAL_ADDRESS PhysicalAddress;

    BOOLEAN bRet = TRUE;

    ASSERT(VirtualContext != NULL);
    ASSERT(Pages != 0);

    //
    // Calculate the effective Physical Address
    //

    PhysicalAddress = VirtualContext->PhysicalReserveContext->PhysicalAddress;
    PhysicalAddress.QuadPart += StartBlock * AGP_BLOCK_SIZE;

    //
    // Determine the appropriate page protection
    //

    if (VirtualContext->PhysicalReserveContext->Caching != MmNonCached) {
        Protect = PAGE_READWRITE | PAGE_WRITECOMBINE;
    } else {
        Protect = PAGE_READWRITE | PAGE_NOCACHE;
    }

    for (i=StartBlock; i<EndBlock; i++) {

        ULONG Cluster = i / BLOCKS_PER_CLUSTER;
        ULONG Block = 1 << (i & (BLOCKS_PER_CLUSTER - 1));

        if ((BitField[i] == 0) && (MapTable[Cluster] & Block)) {

            //
            // Unmap user mode memory
            //

            Status = MapBlock(fdoExtension, VirtualContext, Process, &PhysicalAddress, VirtualAddress, Protect, TRUE);

            if (NT_SUCCESS(Status) == FALSE) {
                pVideoDebugPrint((0, "MapBlock(TRUE) failed.  Status = 0x%x\n", Status));
                ASSERT(FALSE);
                bRet = FALSE;
            }

            //
            // Reserve the memory so we can map into it again in the
            // future.
            //

            Status = UpdateBlock(Process, VirtualAddress, PAGE_READWRITE, FALSE);
            MapTable[Cluster] &= ~Block;

            if (NT_SUCCESS(Status) == FALSE) {
                pVideoDebugPrint((0, "UpdateBlock(FALSE) failed.  Status = 0x%x\n", Status));
                ASSERT(FALSE);
                bRet = FALSE;
            }

        } else if ((BitField[i]) && ((MapTable[Cluster] & Block) == 0)) {

            //
            // Release claim on memory so we can map it.
            //

            Status = UpdateBlock(Process, VirtualAddress, PAGE_READWRITE, TRUE);
            MapTable[Cluster] |= Block;

            if (NT_SUCCESS(Status) == FALSE) {
                pVideoDebugPrint((0, "UpdateBlock(TRUE) failed.  Status = 0x%x\n", Status));
                ASSERT(FALSE);
                bRet = FALSE;
            }

            //
            // Map the pages into the user mode process
            //

            Status = MapBlock(fdoExtension, VirtualContext, Process, &PhysicalAddress, VirtualAddress, Protect, FALSE);

            if (NT_SUCCESS(Status) == FALSE) {
                pVideoDebugPrint((0, "MapBlock(FALSE) failed.  Status = 0x%x\n", Status));
                ASSERT(FALSE);
                bRet = FALSE;
            }
        }

        //
        // Go to the next 64k block
        //

        VirtualAddress = (PUCHAR)VirtualAddress + AGP_BLOCK_SIZE;
        PhysicalAddress.QuadPart += AGP_BLOCK_SIZE;
    }

    return bRet;
}

PVOID
AgpCommitVirtual(
    IN PVOID Context,
    IN PVOID VirtualReserveContext,
    IN ULONG Pages,
    IN ULONG Offset
    )

/*++

Routine Description:

    Reserves a range of physical addresses for AGP.

Arguments:

    Context - The Agp Context

    VirtualReserveContext - The reservation context.

    Pages - Number of pages to commit.

    Offset - The offset into the reserved region at which to commit the pages.

Returns:

    The virtual address for the base of the commited pages.

--*/

{
    PFDO_EXTENSION fdoExtension = GET_FDO_EXT(Context);
    PVIRTUAL_RESERVE_CONTEXT VirtualContext;
    PPHYSICAL_RESERVE_CONTEXT PhysicalContext;
    PVOID VirtualAddress = NULL;
    NTSTATUS ntStatus;
    BOOLEAN Attached = FALSE;

    ASSERT(VirtualReserveContext != NULL);
    ASSERT(Pages >= 1);

    VirtualContext = (PVIRTUAL_RESERVE_CONTEXT) VirtualReserveContext;
    PhysicalContext = VirtualContext->PhysicalReserveContext;

    //
    // Confirm that the pages being committed fit into the reserved
    // region.
    //
    // We only need to check the last page they are trying to commit. If
    // it is not in the reserved region then we need to fail.
    //

    if ((Offset + Pages) > PhysicalContext->Pages) {
        pVideoDebugPrint((1, "Attempt to commit pages outside of reserved region\n"));
        ASSERT(FALSE);
        return NULL;
    }

    //
    // Calculate the effective virtual address.
    //

    VirtualAddress = ((PUCHAR)VirtualContext->VirtualAddress + Offset * AGP_PAGE_SIZE);

    if (VirtualContext->ProcessHandle) {

        //
        // Make sure we are in the correct process context.
        //

        if (VirtualContext->ProcessHandle == NtCurrentProcess()) {

            if (VirtualContext->Process != PsGetCurrentProcess()) {

                KeAttachProcess(PEProcessToPKProcess(VirtualContext->Process));
                Attached = TRUE;
            }
        }

        ModifyRegion(VirtualContext->Region, Offset, Pages, TRUE);

        //
        // Update the virtual address space.
        //

        if (UpdateReservedRegion(fdoExtension,
                                 VirtualContext,
                                 Pages,
                                 Offset) == FALSE) {

            //
            // Part of the commit failed.  Indicate this by returning
            // a NULL.
            //

            VirtualAddress = NULL;
        }

        //
        // Restore initial process context.
        //

        if (Attached) {
            KeDetachProcess();
        }

    } else {

        //
        // Kernel mode commit.  Do nothing, the memory is already mapped.
        //
    }

    return VirtualAddress;
}

VOID
AgpFreeVirtual(
    IN PVOID Context,
    IN PVOID VirtualReserveContext,
    IN ULONG Pages,
    IN ULONG Offset
    )

/*++

Routine Description:

    Frees a range of virtual addresses.

Arguments:

    Context - The Agp Context

    VirtualReserveContext - The reservation context.

    Pages - Number of pages to release.

    Offset - The offset into the reserved region at which to release the pages.

Returns:

    none.

--*/

{
    PFDO_EXTENSION fdoExtension = GET_FDO_EXT(Context);
    PVIRTUAL_RESERVE_CONTEXT VirtualContext;
    PPHYSICAL_RESERVE_CONTEXT PhysicalContext;
    PVOID VirtualAddress;
    BOOLEAN Attached=FALSE;
    NTSTATUS Status;

    ASSERT(VirtualReserveContext != NULL);

    VirtualContext = (PVIRTUAL_RESERVE_CONTEXT) VirtualReserveContext;
    PhysicalContext = VirtualContext->PhysicalReserveContext;

    VirtualAddress = (PUCHAR)((ULONG_PTR)VirtualContext->VirtualAddress + Offset * AGP_PAGE_SIZE);

    //
    // Make sure we are in the correct process context.
    //

    if (VirtualContext->ProcessHandle != NULL) {

        if (VirtualContext->ProcessHandle == NtCurrentProcess()) {

            if (VirtualContext->Process != PsGetCurrentProcess()) {

                KeAttachProcess(PEProcessToPKProcess(VirtualContext->Process));
                Attached = TRUE;
            }
        }

        ModifyRegion(VirtualContext->Region, Offset, Pages, FALSE);

        UpdateReservedRegion(fdoExtension,
                             VirtualContext,
                             Pages,
                             Offset);

        if (Attached) {
            KeDetachProcess();
        }

    } else {

        //
        // Kernel Space Free - do nothing.
        //
    }
}

BOOLEAN
AgpSetRate(
    IN PVOID Context,
    IN ULONG AgpRate
    )

/*++

Routine Description:

    Thsi function sets chipset's AGP rate.

Arguments:

    Context - The Agp Context

    AgpRate - The Agp rate to set.

Returns:

    TRUE if successful,
    FALSE otherwise.

--*/

{
    PFDO_EXTENSION fdoExtension;
    NTSTATUS ntStatus;
    BOOLEAN bStatus = FALSE;

    ASSERT(NULL != Context);

    fdoExtension = GET_FDO_EXT(Context);

    ASSERT(NULL != fdoExtension);

    if (fdoExtension->AgpInterface.Version > VIDEO_PORT_AGP_INTERFACE_VERSION_1)
    {
        ASSERT(NULL != fdoExtension->AgpInterface.AgpContext);

        //
        // Try to set chipset's AGP rate.
        //

        ntStatus = fdoExtension->AgpInterface.SetRate(fdoExtension->AgpInterface.AgpContext, AgpRate);
        bStatus  = NT_SUCCESS(ntStatus);
    }

    return bStatus;
}

BOOLEAN
VideoPortGetAgpServices(
    IN PVOID HwDeviceExtension,
    OUT PVIDEO_PORT_AGP_SERVICES AgpServices
    )

/*++

Routine Description:

    This routine returns a set of AGP services to the caller.

Arguments:

    HwDeviceExtension - Pointer to the miniports device extension

    AgpServices - A buffer in which to place the AGP services.

Returns:

    TRUE if successful,
    FALSE otherwise.

--*/

{
    PFDO_EXTENSION fdoExtension = GET_FDO_EXT(HwDeviceExtension);
    SYSTEM_BASIC_INFORMATION basicInfo;
    NTSTATUS status;

    ASSERT(HwDeviceExtension != NULL);
    ASSERT(AgpServices != NULL);

    //
    // This entry point is only valid for PnP Drivers.
    //

    if ((fdoExtension->Flags & LEGACY_DRIVER) == 0) {

        if (VpQueryAgpInterface(fdoExtension, AGP_BUS_INTERFACE_V1)) {

            //
            // Fill in the list of function pointers.
            //

            AgpServices->AgpReservePhysical = AgpReservePhysical;
            AgpServices->AgpCommitPhysical  = AgpCommitPhysical;
            AgpServices->AgpFreePhysical    = AgpFreePhysical;
            AgpServices->AgpReleasePhysical = AgpReleasePhysical;

            AgpServices->AgpReserveVirtual  = AgpReserveVirtual;
            AgpServices->AgpCommitVirtual   = AgpCommitVirtual;
            AgpServices->AgpFreeVirtual     = AgpFreeVirtual;
            AgpServices->AgpReleaseVirtual  = AgpReleaseVirtual;

            status = ZwQuerySystemInformation (SystemBasicInformation,
                               &basicInfo,
                               sizeof(basicInfo),
                               NULL);

            if (NT_SUCCESS(status) == FALSE) {
                pVideoDebugPrint((0, "VIDEOPRT: Failed AGP system information.\n"));
                return FALSE;
            }

            AgpServices->AllocationLimit = (basicInfo.NumberOfPhysicalPages *
                            basicInfo.PageSize) / 8;

            pVideoDebugPrint((Trace, "VIDEOPRT: AGP system information success.\n"));
            
            return TRUE;

        } else {
            
            pVideoDebugPrint((0, "VIDEOPRT: Failed AGP system information.\n"));
            return FALSE;
        }

    } else {

        pVideoDebugPrint((1, "VideoPortGetAgpServices - only valid on PnP drivers\n"));
        return FALSE;
    }
}

VP_STATUS
VpGetAgpServices2(
    IN PVOID pHwDeviceExtension,
    OUT PVIDEO_PORT_AGP_INTERFACE_2 pAgpInterface
    )

/*++

Routine Description:

    This routine returns a set of AGP services to the caller.

Arguments:

    pHwDeviceExtension - Pointer to the miniports device extension

    pAgpInterface - A buffer in which to place the AGP services.

Returns:

    TRUE if successful,
    FALSE otherwise.

--*/

{
    PFDO_EXTENSION pFdoExtension;
    SYSTEM_BASIC_INFORMATION basicInfo;
    NTSTATUS ntStatus;

    ASSERT(NULL != pHwDeviceExtension);
    ASSERT(NULL != pAgpInterface);

    pFdoExtension = GET_FDO_EXT(pHwDeviceExtension);

    //
    // This entry point is only valid for PnP Drivers.
    //

    if ((pFdoExtension->Flags & LEGACY_DRIVER) == 0)
    {
        if (VpQueryAgpInterface(pFdoExtension, AGP_BUS_INTERFACE_V2))
        {
            //
            // Fill in an interface structure.
            //

            pAgpInterface->Context              = pHwDeviceExtension;
            pAgpInterface->InterfaceReference   = VpInterfaceDefaultReference;
            pAgpInterface->InterfaceDereference = VpInterfaceDefaultDereference;

            pAgpInterface->AgpReservePhysical   = AgpReservePhysical;
            pAgpInterface->AgpCommitPhysical    = AgpCommitPhysical;
            pAgpInterface->AgpFreePhysical      = AgpFreePhysical;
            pAgpInterface->AgpReleasePhysical   = AgpReleasePhysical;

            pAgpInterface->AgpReserveVirtual    = AgpReserveVirtual;
            pAgpInterface->AgpCommitVirtual     = AgpCommitVirtual;
            pAgpInterface->AgpFreeVirtual       = AgpFreeVirtual;
            pAgpInterface->AgpReleaseVirtual    = AgpReleaseVirtual;

            pAgpInterface->AgpSetRate           = AgpSetRate;

            ntStatus = ZwQuerySystemInformation(SystemBasicInformation,
                                                &basicInfo,
                                                sizeof (basicInfo),
                                                NULL);

            if (NT_SUCCESS(ntStatus) == FALSE)
            {
                pVideoDebugPrint((0, "VIDEOPRT!VideoPortGetAgpServices2: Failed AGP system information.\n"));
                return ERROR_DEV_NOT_EXIST;
            }

            pAgpInterface->AgpAllocationLimit = (basicInfo.NumberOfPhysicalPages * basicInfo.PageSize) / 8;

            //
            // Reference the interface before handing it out.
            //

            pAgpInterface->InterfaceReference(pAgpInterface->Context);

            pVideoDebugPrint((Trace, "VIDEOPRT!VideoPortGetAgpServices2: AGP system information success.\n"));

            return NO_ERROR;
        }
        else
        {
            pVideoDebugPrint((0, "VIDEOPRT!VideoPortGetAgpServices2: Failed AGP system information.\n"));
            return ERROR_DEV_NOT_EXIST;
        }
    }
    else
    {
        pVideoDebugPrint((1, "VIDEOPRT!VideoPortGetAgpServices2: Only valid on PnP drivers\n"));
        return ERROR_DEV_NOT_EXIST;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\port\acpi.c ===
/*++

Copyright (c) 1990-2000  Microsoft Corporation

Module Name:

    pnp.c

Abstract:

    This is the pnp portion of the video port driver.

Environment:

    kernel mode only

Revision History:

--*/

#include "videoprt.h"

#pragma alloc_text(PAGE,pVideoPortQueryACPIInterface)
#pragma alloc_text(PAGE,pVideoPortACPIEventHandler)
#pragma alloc_text(PAGE,pVideoPortACPIIoctl)
#pragma alloc_text(PAGE,VpRegisterLCDCallbacks)
#pragma alloc_text(PAGE,VpUnregisterLCDCallbacks)
#pragma alloc_text(PAGE,VpRegisterPowerStateCallback)
#pragma alloc_text(PAGE,VpDelayedPowerStateCallback)
#pragma alloc_text(PAGE,VpSetLCDPowerUsage)

BOOLEAN 
pCheckDeviceRelations(
    PFDO_EXTENSION FdoExtension, 
    BOOLEAN bNewMonitor
    );

NTSTATUS
pVideoPortQueryACPIInterface(
    PDEVICE_SPECIFIC_EXTENSION DoSpecificExtension
    )

/*++

Routine Description:

    Send a QueryInterface Irp to our parent (the PCI bus driver) to
    retrieve the AGP_BUS_INTERFACE.

Returns:

    NT_STATUS code

--*/

{
    KEVENT                  Event;
    PIRP                    QueryIrp = NULL;
    IO_STATUS_BLOCK         IoStatusBlock;
    PIO_STACK_LOCATION      NextStack;
    NTSTATUS                Status;
    ACPI_INTERFACE_STANDARD AcpiInterface;
    PFDO_EXTENSION          FdoExtension = DoSpecificExtension->pFdoExtension;

    //
    // For those special cases, don't use ACPI HotKey switching
    //
    if (VpSetupTypeAtBoot != SETUPTYPE_NONE) {
        return STATUS_INVALID_PARAMETER;
    }

    if (FdoExtension->Flags & LEGACY_DETECT) {
        return STATUS_INVALID_PARAMETER;
    }
    
    if ((FdoExtension->Flags & FINDADAPTER_SUCCEEDED) == 0) {
        return STATUS_INVALID_PARAMETER;
    }

    KeInitializeEvent(&Event, SynchronizationEvent, FALSE);

    QueryIrp = IoBuildSynchronousFsdRequest(IRP_MJ_PNP,
                                            FdoExtension->AttachedDeviceObject,
                                            NULL,
                                            0,
                                            NULL,
                                            &Event,
                                            &IoStatusBlock);

    if (QueryIrp == NULL) {

        return STATUS_INVALID_PARAMETER;
    }

    //
    // Set the default error code.
    //

    QueryIrp->IoStatus.Status = STATUS_NOT_SUPPORTED;

    //
    // Set up for a QueryInterface Irp.
    //

    NextStack = IoGetNextIrpStackLocation(QueryIrp);

    NextStack->MajorFunction = IRP_MJ_PNP;
    NextStack->MinorFunction = IRP_MN_QUERY_INTERFACE;

    NextStack->Parameters.QueryInterface.InterfaceType = &GUID_ACPI_INTERFACE_STANDARD;
    NextStack->Parameters.QueryInterface.Size = sizeof(ACPI_INTERFACE_STANDARD);
    NextStack->Parameters.QueryInterface.Version = 1;
    NextStack->Parameters.QueryInterface.Interface = (PINTERFACE) &AcpiInterface;
    NextStack->Parameters.QueryInterface.InterfaceSpecificData = NULL;

    AcpiInterface.Size = sizeof(ACPI_INTERFACE_STANDARD);
    AcpiInterface.Version = 1;


    //
    // Call the filter driver.
    //

    Status = IoCallDriver(FdoExtension->AttachedDeviceObject, QueryIrp);

    if (Status == STATUS_PENDING) {

        KeWaitForSingleObject(&Event, Executive, KernelMode, FALSE, NULL);

        Status = IoStatusBlock.Status;

    }

    if (NT_SUCCESS(Status))
    {
        pVideoDebugPrint((0, "VideoPort: This is an ACPI Machine !\n"));

        //
        // Let's register for this event and provide our default handler.
        //

        AcpiInterface.RegisterForDeviceNotifications(AcpiInterface.Context, //FdoExtension->AttachedDeviceObject,
                                                     pVideoPortACPIEventCallback,
                                                     DoSpecificExtension);

        //
        // Register for LCD notifications 
        //

        VpRegisterLCDCallbacks();
    }

    //
    // Turn on HotKey switching notify mode 
    //
    if (NT_SUCCESS(Status))
    {
        ULONG active = 0;
        UCHAR outputBuffer[sizeof(ACPI_EVAL_OUTPUT_BUFFER) + 10];
        Status = pVideoPortACPIIoctl(FdoExtension->AttachedDeviceObject,
                                     (ULONG) ('SOD_'),
                                     &active,
                                     NULL,
                                     0,
                                     (PACPI_EVAL_OUTPUT_BUFFER)outputBuffer);
    }


    //
    // Register Dock/Undock notification
    //
    if (NT_SUCCESS(Status))
    {
        Status = IoRegisterPlugPlayNotification(EventCategoryHardwareProfileChange, 
                                                0,
                                                NULL,
                                                FdoExtension->FunctionalDeviceObject->DriverObject,
                                                pVideoPortDockEventCallback,
                                                DoSpecificExtension,
                                                &DockCallbackHandle);
    }

    return Status;
}

NTSTATUS
pVideoPortDockEventCallback (
    PVOID NotificationStructure,
    PDEVICE_SPECIFIC_EXTENSION DoSpecificExtension
    )
{
    UNREFERENCED_PARAMETER(NotificationStructure);

    pVideoPortACPIEventCallback(DoSpecificExtension, 0x77);

    return STATUS_SUCCESS;
}

VOID
pVideoPortACPIEventCallback(
    PDEVICE_SPECIFIC_EXTENSION DoSpecificExtension,
    ULONG eventID
    )
/*++

Routine Description:

    Event notification callback for panel switching

    NOTE  This routine is not pageable as it is called from DPC level by
    the ACPI BIOS.

--*/
{
    PVIDEO_ACPI_EVENT_CONTEXT pContext;

    //
    // There are some cases the BIOS send the notofication even before the device is opened
    //
    if (!DoSpecificExtension->DeviceOpened)
        return;

    if (InterlockedIncrement(&(DoSpecificExtension->AcpiVideoEventsOutstanding)) < 2) {

        // Queue work item
        pContext = ExAllocatePoolWithTag(NonPagedPool,
                                         sizeof(VIDEO_ACPI_EVENT_CONTEXT),
                                         VP_TAG);

        if (pContext && (eventID == 0x80 || eventID == 0x81 || eventID == 0x90 || eventID == 0x77))
        {
            pContext->DoSpecificExtension = DoSpecificExtension;
            pContext->EventID             = eventID;

            ExInitializeWorkItem(&(pContext->workItem),
                                 pVideoPortACPIEventHandler,
                                 pContext);

            ExQueueWorkItem(&(pContext->workItem), DelayedWorkQueue);
        }
    }
    else
    {
        // We're getting a Notify storm, and we already have a work item on the job.
        InterlockedDecrement(&(DoSpecificExtension->AcpiVideoEventsOutstanding));
    }

    return;
}


VOID
pVideoPortACPIEventHandler(
    PVIDEO_ACPI_EVENT_CONTEXT EventContext
    )
/*++

Routine Description:

    Event handler for panel switching

--*/
{
    UCHAR                outputBuffer[0x200 + sizeof(ACPI_EVAL_OUTPUT_BUFFER)];
    PCHILD_PDO_EXTENSION pChildDeviceExtension;
    PDEVICE_OBJECT       AttachedDeviceObject;
    PDEVICE_OBJECT       pChildPdos[10];
    ULONG                active, szChildIDs, i, AllowSwitch = 0, Switched = 0;
    PVIDEO_CHILD_STATE_CONFIGURATION pChildIDs;
    NTSTATUS             Status;
    BOOLEAN              bNewMonitor;
    VIDEO_WIN32K_CALLBACKS_PARAMS calloutParams;
    PFDO_EXTENSION FdoExtension;

    FdoExtension = EventContext->DoSpecificExtension->pFdoExtension;

    ASSERT (FdoExtension != NULL);
    
    pVideoDebugPrint((1, "pVideoPortACPIEventHandler: Event %08lx trigerred!\n",
                      EventContext->EventID));

    AttachedDeviceObject = FdoExtension->AttachedDeviceObject;

    if (FdoExtension->DevicePowerState != PowerDeviceD0)
    {
        EventContext->DoSpecificExtension->CachedEventID = EventContext->EventID;
        goto ExitACPIEventHandler;
    }
    else
    {
        EventContext->DoSpecificExtension->CachedEventID = 0;
    }

    //
    // Dock/Undock event handling
    //
    if (EventContext->EventID == 0x77)
    {
        calloutParams.CalloutType = VideoDisplaySwitchCallout;
        calloutParams.PhysDisp = EventContext->DoSpecificExtension->PhysDisp;
        calloutParams.Param = (ULONG_PTR)NULL;
        VpWin32kCallout(&calloutParams);

        goto ExitACPIEventHandler;
    }

    //
    // Disable BIOS notification
    //
    active = 2;
    pVideoPortACPIIoctl(AttachedDeviceObject,
                        (ULONG) ('SOD_'),
                        &active,
                        NULL,
                        0,
                        (PACPI_EVAL_OUTPUT_BUFFER)outputBuffer);

    if (EventContext->EventID == 0x90)
    {
        calloutParams.CalloutType = VideoWakeupCallout;

        VpWin32kCallout(&calloutParams);
    }
    else
    {
        szChildIDs = sizeof(VIDEO_CHILD_STATE_CONFIGURATION) + FdoExtension->ChildPdoNumber*sizeof(VIDEO_CHILD_STATE);
        pChildIDs = (PVIDEO_CHILD_STATE_CONFIGURATION)ExAllocatePoolWithTag(PagedPool,
                                                                  szChildIDs,
                                                                  VP_TAG);
        if (pChildIDs != NULL)
        {
            //
            // During switching, no PnP action is allowed
            //
            ACQUIRE_DEVICE_LOCK (FdoExtension);

            pChildIDs->Count = 0;

            for (pChildDeviceExtension = FdoExtension->ChildPdoList;
                 pChildDeviceExtension != NULL;
                 pChildDeviceExtension = pChildDeviceExtension->NextChild
                )
            {
                if ((!pChildDeviceExtension->bIsEnumerated) ||
                    pChildDeviceExtension->VideoChildDescriptor->Type != Monitor)
                {
                    continue;
                }

                pChildIDs->ChildStateArray[pChildIDs->Count].Id = pChildDeviceExtension->VideoChildDescriptor->UId;
                pChildIDs->ChildStateArray[pChildIDs->Count].State = 0;
                pChildPdos[pChildIDs->Count] = pChildDeviceExtension->ChildDeviceObject;

                Status = pVideoPortACPIIoctl(
                             IoGetAttachedDevice(pChildDeviceExtension->ChildDeviceObject),
                             (ULONG) ('SGD_'),
                             NULL,
                             NULL,
                             sizeof(ACPI_EVAL_OUTPUT_BUFFER)+0x10,
                             (PACPI_EVAL_OUTPUT_BUFFER)outputBuffer);

                if (NT_SUCCESS(Status))
                {
                    ASSERT(((PACPI_EVAL_OUTPUT_BUFFER)outputBuffer)->Argument[0].Type == ACPI_METHOD_ARGUMENT_INTEGER);
                    ASSERT(((PACPI_EVAL_OUTPUT_BUFFER)outputBuffer)->Argument[0].DataLength == sizeof(ULONG));

                    if (((PACPI_EVAL_OUTPUT_BUFFER)outputBuffer)->Argument[0].Argument)
                    {
                        pChildIDs->ChildStateArray[pChildIDs->Count].State = 1;
                    }
                }

                pChildIDs->Count++;
            }

            szChildIDs = sizeof(VIDEO_CHILD_STATE_CONFIGURATION) + pChildIDs->Count*sizeof(VIDEO_CHILD_STATE);

            //
            // Notify Miniport that display switching is about to happen.
            // Treat the switch is allowed by default.
            //

            AllowSwitch = 1;

            pVideoMiniDeviceIoControl(FdoExtension->FunctionalDeviceObject,
                                      IOCTL_VIDEO_VALIDATE_CHILD_STATE_CONFIGURATION,
                                      (PVOID)pChildIDs,
                                      szChildIDs,
                                      &AllowSwitch,
                                      sizeof(ULONG));

            //
            // If Miniport says it's OK to proceed
            //
            if (AllowSwitch != 0)
            {
                //
                // Check the Miniport do the switching for us
                //
                Status = pVideoMiniDeviceIoControl(FdoExtension->FunctionalDeviceObject,
                                                   IOCTL_VIDEO_SET_CHILD_STATE_CONFIGURATION,
                                                   (PVOID)pChildIDs,
                                                   szChildIDs,
                                                   NULL,
                                                   0);
                if (NT_SUCCESS(Status))
                {
                    pVideoDebugPrint((1, "VideoPort: Moniport does the switch!\n"));
                    Switched = 1;
                }
            }

            //
            // The last _DSS needs to commit the switching
            //
            if (pChildIDs->Count > 0)
            {
                pChildIDs->ChildStateArray[pChildIDs->Count-1].State |= 0x80000000;
            }
        
            for (i = 0; i < pChildIDs->Count; i++)
            {
                //
                // If Miniport doesn't like to proceed or it does the switching already, just notify BIOS to go to next _DGS state
                //
                // Found some bad BIOS(Toshiba).  They do switch anyway regardless of 0x40000000 bit.  This has extremely bad effect
                // on DualView
                //
                if (!AllowSwitch)
                    continue;
                if (Switched)
                {
                    pChildIDs->ChildStateArray[i].State |= 0x40000000;
                }
                pVideoPortACPIIoctl(IoGetAttachedDevice(pChildPdos[i]),
                                    (ULONG) ('SSD_'),
                                    &pChildIDs->ChildStateArray[i].State,
                                    NULL,
                                    0,
                                    (PACPI_EVAL_OUTPUT_BUFFER)outputBuffer);
            }

            RELEASE_DEVICE_LOCK (FdoExtension);

            ExFreePool(pChildIDs);
        }

        //
        // On switching displays, call GDI / USER to tell the device to rebuild mode list
        // and change current mode if neccesary
        //

        pVideoDebugPrint((0, "VideoPrt.sys: Display switching occured - calling GDI to rebuild mode table.\n"));

        calloutParams.CalloutType = VideoDisplaySwitchCallout;
        calloutParams.PhysDisp = (AllowSwitch) ? EventContext->DoSpecificExtension->PhysDisp : NULL;

        //
        // On Monitor changing, we receive Notify(81)
        // On waking up from hibernation, we receive Notify(90)
        // We also make IoInvalidateDeviceRelation happen inside Callout routine
        //

        bNewMonitor = (EventContext->EventID == 0x81);

        if (pCheckDeviceRelations(FdoExtension, bNewMonitor) )
        {
            calloutParams.Param = (ULONG_PTR)FdoExtension->PhysicalDeviceObject;
        }
        else
        {
            calloutParams.Param = (ULONG_PTR)NULL;
        }

        VpWin32kCallout(&calloutParams);
    }

ExitACPIEventHandler:

    //
    // Reenable BIOS notification 
    //

    active = 0;
    pVideoPortACPIIoctl(AttachedDeviceObject,
                        (ULONG) ('SOD_'),
                        &active,
                        NULL,
                        0,
                        (PACPI_EVAL_OUTPUT_BUFFER)outputBuffer);

    InterlockedDecrement(&(EventContext->DoSpecificExtension->AcpiVideoEventsOutstanding));

    //
    // This also ends up freeing the work item as it's embedded in the context.
    //

    ExFreePool(EventContext);

    return;
}




NTSTATUS
pVideoPortACPIIoctl(
    IN  PDEVICE_OBJECT           DeviceObject,
    IN  ULONG                    MethodName,
    IN  PULONG                   InputParam1,
    IN  PULONG                   InputParam2,
    IN  ULONG                    OutputBufferSize,
    IN  PACPI_EVAL_OUTPUT_BUFFER pOutputBuffer
    )
/*++

Routine Description:

    Called to send a request to the DeviceObject

Arguments:

    DeviceObject    - The request is sent to this device object
    MethodName      - Name of the method to be run in ACPI space
    pArgumets       - Pointer that will receive the address of the ACPI data

Return Value:

    NT Status of the operation

--*/
{
    UCHAR                           buffer[sizeof(ACPI_EVAL_INPUT_BUFFER_COMPLEX) +
                                           sizeof(ACPI_METHOD_ARGUMENT)];
    PACPI_EVAL_INPUT_BUFFER_COMPLEX pInputBuffer;
    ULONG                           size;
    IO_STATUS_BLOCK                 ioBlock;
    KEVENT                          event;
    NTSTATUS                        status;
    PIRP                            irp;

    pVideoDebugPrint((2, "Call ACPI method %c%c%c%c!\n",
                      *((PUCHAR)&MethodName),   *((PUCHAR)&MethodName+1),
                      *((PUCHAR)&MethodName+2), *((PUCHAR)&MethodName+3) ));

    pInputBuffer = (PACPI_EVAL_INPUT_BUFFER_COMPLEX) buffer;

    pInputBuffer->MethodNameAsUlong = MethodName;

    if (InputParam1 == NULL)
    {
        size = sizeof(ACPI_EVAL_INPUT_BUFFER);

        pInputBuffer->Signature = ACPI_EVAL_INPUT_BUFFER_SIGNATURE;
    }
    else
    {
        size = sizeof(ACPI_EVAL_INPUT_BUFFER_COMPLEX);

        pInputBuffer->Signature       = ACPI_EVAL_INPUT_BUFFER_COMPLEX_SIGNATURE;
        pInputBuffer->Size            = sizeof(ACPI_METHOD_ARGUMENT);
        pInputBuffer->ArgumentCount   = 1;

        pInputBuffer->Argument[0].Type       = ACPI_METHOD_ARGUMENT_INTEGER;
        pInputBuffer->Argument[0].DataLength = sizeof(ULONG);
        pInputBuffer->Argument[0].Argument   = *InputParam1;
    }

    if (InputParam2)
    {
        size = sizeof(ACPI_EVAL_INPUT_BUFFER_COMPLEX) +
               sizeof(ACPI_METHOD_ARGUMENT);

        pInputBuffer->Size            = 2 * sizeof(ACPI_METHOD_ARGUMENT);
        pInputBuffer->ArgumentCount   = 2;

        pInputBuffer->Argument[1].Type       = ACPI_METHOD_ARGUMENT_INTEGER;
        pInputBuffer->Argument[1].DataLength = sizeof(ULONG);
        pInputBuffer->Argument[1].Argument   = *InputParam2;
    }

    //
    // Initialize an event to wait on
    //

    KeInitializeEvent(&event, SynchronizationEvent, FALSE);

    //
    // Build the request
    //

    irp = IoBuildDeviceIoControlRequest(IOCTL_ACPI_EVAL_METHOD,
                                        DeviceObject,
                                        pInputBuffer,
                                        size,
                                        pOutputBuffer,
                                        OutputBufferSize,
                                        FALSE,
                                        &event,
                                        &ioBlock);

    if (!irp)
    {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    // Pass request to DeviceObject, always wait for completion routine
    //

    status = IoCallDriver(DeviceObject, irp);

    if (status == STATUS_PENDING)
    {
        //
        // Wait for the irp to be completed, then grab the real status code
        //

        KeWaitForSingleObject(&event,
                              Executive,
                              KernelMode,
                              FALSE,
                              NULL);

        status = ioBlock.Status;
    }

    //
    // Sanity check the data
    //

    if (NT_SUCCESS(status) && OutputBufferSize != 0)
    {
        if (((pOutputBuffer)->Signature != ACPI_EVAL_OUTPUT_BUFFER_SIGNATURE) ||
            ((pOutputBuffer)->Count == 0))
        {
            status = STATUS_ACPI_INVALID_DATA;
        }
    }

    return status;
}

NTSTATUS
pVideoMiniDeviceIoControl(
    IN PDEVICE_OBJECT DeviceObject,
    IN ULONG dwIoControlCode,
    IN PVOID lpInBuffer,
    IN ULONG nInBufferSize,
    OUT PVOID lpOutBuffer,
    IN ULONG nOutBufferSize
    )
{
    PFDO_EXTENSION combinedExtension;
    PFDO_EXTENSION fdoExtension;

    VIDEO_REQUEST_PACKET vrp;
    STATUS_BLOCK statusBlock;

    combinedExtension = DeviceObject->DeviceExtension;
    fdoExtension = combinedExtension->pFdoExtension;

    statusBlock.Status = ERROR_INVALID_FUNCTION;

    vrp.IoControlCode      = dwIoControlCode;
    vrp.StatusBlock        = &statusBlock;
    vrp.InputBuffer        = lpInBuffer;
    vrp.InputBufferLength  = nInBufferSize;
    vrp.OutputBuffer       = lpOutBuffer;
    vrp.OutputBufferLength = nOutBufferSize;

    //
    // Send the request to the miniport directly.
    //

    fdoExtension->HwStartIO(combinedExtension->HwDeviceExtension, &vrp);

    pVideoPortMapToNtStatus(&statusBlock);

    return (statusBlock.Status);
}


NTSTATUS
VpQueryBacklightLevels(
    IN  PDEVICE_OBJECT DeviceObject,
    OUT PUCHAR ucBacklightLevels,
    OUT PULONG pulNumberOfLevelsSupported
    )

/*++

Routine Description:

    This function will query the list of levels supported by _BCL.
    
Arguments:

    DeviceObject: The ACPI device object attached to our LCD device.
    
    ucBacklightLevels: The list of backlight levels supported by the ACPI BIOS.

    pulNumberOfLevelsSupported: This is the number of actual levels the ACPI BIOS supports,

Returns:

    NO_ERROR if it succeeds
    Various error codes if it fails
    
--*/

{
    PACPI_EVAL_OUTPUT_BUFFER Buffer = NULL;
    PACPI_METHOD_ARGUMENT Argument = NULL;
    ULONG Granularity = 80;
    ULONG BufferMaxSize = 4096;
    NTSTATUS Status = STATUS_UNSUCCESSFUL;
    ULONG Level = 100;
    ULONG count = 0;
    PBACKLIGHT_STATUS pVpBacklightStatus = &VpBacklightStatus;
    PUCHAR ucLevels = ucBacklightLevels;
    

    PAGED_CODE();
    ASSERT (DeviceObject != NULL);

    //
    // Get the list of brightness levels supported
    //

    do {

        Buffer = (PACPI_EVAL_OUTPUT_BUFFER)ExAllocatePoolWithTag(
            PagedPool,
            Granularity,
            VP_TAG);
    
        if (Buffer == NULL) {
            
            pVideoDebugPrint((Warn, 
                "VIDEOPRT: VpQueryBacklightLevels: Memory allocation failed."));
            Status = STATUS_INSUFFICIENT_RESOURCES;
            break;
        }

        RtlZeroMemory(Buffer, Granularity);   

        Status = pVideoPortACPIIoctl(
            DeviceObject,
            (ULONG) ('LCB_'),
            NULL,
            NULL,
            Granularity,
            Buffer);
    
        if (Status == STATUS_BUFFER_OVERFLOW) {

            ExFreePool(Buffer);
            Buffer = NULL;
            Granularity <<= 1;
            
            if (Granularity > BufferMaxSize) {

                pVideoDebugPrint((Warn, 
                    "VIDEOPRT: _BCL failed. Expected buffer is too big."));
                Status = STATUS_ACPI_INVALID_DATA;
                break;
            }
        
        } else if (!NT_SUCCESS(Status)) {
            
            pVideoDebugPrint((Warn, 
                "VIDEOPRT: _BCL failed. Status = 0x%x\n", Status));
        
        } else {

            pVideoDebugPrint((Trace, "VIDEOPRT: _BCL succeeded.\n"));
        }
    
    } while (Status == STATUS_BUFFER_OVERFLOW);

    if ((Buffer == NULL) || (!NT_SUCCESS(Status))) 
        goto Fallout;

    //
    // We should have 2+ levels.  If we have only have 2 levels, the
    //  BIOS only reports the recommended AC/DC values.  This function
    //  is therefore only useful if we have 3+ levels reported by the
    //  ACPI BIOS.
    //

    if (Buffer->Count < 3) {
        pVideoDebugPrint((Warn, 
            "VIDEOPRT: _BCL returned an fewer than three arguments."));
        Status = STATUS_ACPI_INVALID_DATA;
        goto Fallout;
    }

    //
    // Save off BIOS "default" AC value for initial settings.
    //

    Argument = Buffer->Argument;
    
    if (Argument->Type != ACPI_METHOD_ARGUMENT_INTEGER) {
        pVideoDebugPrint((Warn, 
            "VIDEOPRT: _BCL returned an invalid argument."));
        Status = STATUS_ACPI_INVALID_DATA;
        goto Fallout;
    }

    Level = Argument->Argument;
    pVpBacklightStatus->bBIOSDefaultACKnown = TRUE;
    pVpBacklightStatus->ucBIOSDefaultAC = (unsigned char) Level;

    //
    // Save off BIOS "default" DC value for initial settings.
    //
    
    Argument = ACPI_METHOD_NEXT_ARGUMENT(Argument);
    
    if (Argument->T