b = REMSmb_service_info_0;
        if (Native) {
            SetSizes( sizeof(SERVICE_INFO_0), MAX_SERVICE_0_STRING_SIZE );
        } else {
            // RAP sizes set below.
        }
        break;

    case 1 :
        LocalDataDesc16 = REM16_service_info_1;
        LocalDataDesc32 = REM32_service_info_1;
        LocalDataDescSmb = REMSmb_service_info_1;
        if (Native) {
            SetSizes( sizeof(SERVICE_INFO_1), MAX_SERVICE_1_STRING_SIZE );
        } else {
            // RAP sizes set below.
        }
        break;

    case 2 :
        LocalDataDesc16 = REM16_service_info_2;
        LocalDataDesc32 = REM32_service_info_2;
        LocalDataDescSmb = REMSmb_service_info_2;
        if (Native) {
            SetSizes( sizeof(SERVICE_INFO_2), MAX_SERVICE_2_STRING_SIZE );
        } else {
            // RAP sizes set below.
        }
        break;

    default :
        return (ERROR_INVALID_LEVEL);
    }

    // Set RAP sizes
    if (Native == FALSE) {
        DWORD NonnativeFixedSize;
        NonnativeFixedSize = RapStructureSize (
            LocalDataDesc16,
            Both,   // transmission mode
            FALSE);  // not native
        NetpAssert( NonnativeFixedSize > 0 );
        SetSizes( NonnativeFixedSize, 0 );
    }

    NetpSetOptionalArg( DataDesc16, LocalDataDesc16 );
    NetpSetOptionalArg( DataDesc32, LocalDataDesc32 );
    NetpSetOptionalArg( DataDescSmb, LocalDataDescSmb );

    IF_DEBUG(STRUCINF) {
        if (DataDesc16) {
            NetpKdPrint(( PREFIX_NETLIB
                    "NetpServiceStructureInfo: desc 16 is "
                    FORMAT_LPDESC ".\n", *DataDesc16 ));
        }
        if (DataDesc32) {
            NetpKdPrint(( PREFIX_NETLIB
                    "NetpServiceStructureInfo: desc 32 is "
                    FORMAT_LPDESC ".\n", *DataDesc32 ));
        }
        if (DataDescSmb) {
            NetpKdPrint(( PREFIX_NETLIB
                    "NetpServiceStructureInfo: desc Smb is "
                    FORMAT_LPDESC ".\n", *DataDescSmb ));
        }
    }

    return (NERR_Success);

} // NetpServiceStructureInfo
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\netlib\ultow.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    ULToW.c

Abstract:

    ULToW converts an unsigned long to a wide-character string.

Author:

    John Rogers (JohnRo) 10-Jan-1992

Environment:

    Win32 - User mode only.
    Requires ANSI C extensions: slash-slash comments, long external names,
    _ultoa().

Revision History:

    10-Jan-1992 JohnRo
        Created.

--*/

#include <windef.h>

#include <netdebug.h>           // _ultoa().
#include <stdlib.h>             // _ultoa().
#include <tstring.h>            // My prototypes.


LPWSTR
ultow (
    IN DWORD Value,
    OUT LPWSTR Area,
    IN DWORD Radix
    )
{
    CHAR TempStr[33];           // Space for 32 bit num in base 2, and null.

    NetpAssert( Area != NULL );
    NetpAssert( Radix >= 2 );
    NetpAssert( Radix <= 36 );

    (void) _ultoa(Value, TempStr, Radix);

    NetpCopyStrToWStr( Area, TempStr );

    return (Area);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\netlib\time.c ===
/*++

Copyright (c) 1991-1993  Microsoft Corporation

Module Name:

    Time.c

Abstract:

    This file contains the various time routines.

Author:

    Dan Hinsley (DanHi) 12-Oct-1991

Environment:

    Interface is portable to any flat, 32-bit environment.  (Uses Win32
    typedefs.)  Requires ANSI C extensions: slash-slash comments, long
    external names, _timezone global variable.

Revision History:

    12-Oct-1991 DanHi
        Created.  (Moved from NetCmd\Map32 directory, file netlib.c)
    28-Oct-1991 DanHi
        Moved net_asctime, net_gmtime and time_now from netcmd\map32\netlib.c
        to here.
    20-Aug-1992 JohnRo
        RAID 2920: Support UTC timezone in net code.
    01-Oct-1992 JohnRo
        RAID 3556: Added NetpSystemTimeToGmtTime() for DosPrint APIs.
    15-Apr-1993 Danl
        Fixed NetpLocalTimeZoneOffset so that it uses the windows calls and
        obtains the correct bias.
    14-Jun-1993 JohnRo
        RAID 13080: Allow repl between different timezones.
        Also, DanL asked me to remove printf() call.
    18-Jun-1993 JohnRo
        RAID 13594: Extracted NetpLocalTimeZoneOffset() so srvsvc.dll doesn't
        get too big.
        Use NetpKdPrint() where possible.
    09-Jul-1993 JohnRo
        RAID 15736: OS/2 time stamps are broken again (try rounding down).

--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include <windows.h>

#include <debuglib.h>   // IF_DEBUG().
#include <time.h>       // struct tm, time_t.
#include <malloc.h>
#include <netdebug.h>   // NetpAssert(), NetpKdPrint(), FORMAT_ equates.
#include <prefix.h>     // PREFIX_ equates.
#include <string.h>
#include <timelib.h>    // My prototypes, NetpLocalTimeZoneOffset().
#include <lmerr.h>      // NERR_InternalError, NO_ERROR, etc.
#include <stdlib.h>


static int _lpdays[] = {
        -1, 30, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334, 365
};

static int _days[] = {
        -1, 30, 58, 89, 119, 150, 180, 211, 242, 272, 303, 333, 364
};

#define DaySec        (24*60*60)
#define YearSec (365*DaySec)
#define DecSec        315532800      /* secs in 1970-1979 */
#define Day1    4               /* Jan. 1, 1970 was a Thursday */
#define Day180        2                /* Jan. 1, 1980 was a Tuesday */


int
net_gmtime(
    time_t *Time,
    struct tm *TimeStruct
    )
/*++

Routine Description:

    This function is the same as the CRT gmtime except it takes the structure
    to fill as a user supplied parameter, sets the date to 1/1/80 if the time
    passed in is before that date and returns 1.

Arguments:

    Time         - Pointer to the number of seconds since 1970.

    TimeStruct   - Pointer to the buffer to place the time struct.

Return Value:

    0 if date < 1/1/80, 1 otherwise.

--*/
{
    LONG ac;                /* accumulator */
    int *mdays;             /* pointer to days or lpdays */
    int lpcnt;              /* leap-year count */

    if (*Time < (LONG) DecSec) {
        /*
         * Before 1980; convert it to 0:00:00 Jan 1, 1980
         */
        TimeStruct->tm_year = 80;
        TimeStruct->tm_mday = 1;
        TimeStruct->tm_mon = TimeStruct->tm_yday = TimeStruct->tm_isdst = 0;
        TimeStruct->tm_hour = TimeStruct->tm_min = TimeStruct->tm_sec = 0;
        TimeStruct->tm_wday = Day180;
        return(1);
    }

    /*
     * Make 1st try at determining year
     */
    TimeStruct->tm_year = (int) (*Time / (LONG) YearSec);
    ac = (LONG)(*Time % (LONG) YearSec) - (lpcnt = (TimeStruct->tm_year + 1) / 4) *
        (LONG) DaySec;
    /*
     * Correct for leap-years passed since 1970.  In the previous
     * calculation, since the lesser value of YearSec was used, (365 days)
     * for certain dates ac will be < 0 and tm_year will be too high.
     * (These dates will tend to be NEAR the end of December.)
     * This is fixed by adding years back into ac until it is >= 0.
     */
    while (ac < 0) {
        ac += (LONG) YearSec;
        if (!((TimeStruct->tm_year + 1) % 4)) {
            ac += (LONG) DaySec;
            lpcnt--;
        }
        TimeStruct->tm_year--;
    }

    /*
     * See if this is a leap year
     */
    TimeStruct->tm_year += 1970;
    if (!(TimeStruct->tm_year % 4) && ((TimeStruct->tm_year % 100) || !(TimeStruct->tm_year % 400)))
        /* Yes */
        mdays = _lpdays;
    else
        /* No */
        mdays = _days;
    /*
     *      Put year in proper form.
     *      Determine yday, month, hour, minute, and second.
     */
    TimeStruct->tm_year -= 1900;
    TimeStruct->tm_yday = (int) (ac / (LONG) DaySec);
    ac %= (LONG) DaySec;
    for (TimeStruct->tm_mon = 1; mdays[TimeStruct->tm_mon] < TimeStruct->tm_yday; TimeStruct->tm_mon++)
            ;
    TimeStruct->tm_mday = TimeStruct->tm_yday - mdays[--TimeStruct->tm_mon];
    TimeStruct->tm_hour = (int) (ac / 3600);
    ac %= 3600;
    TimeStruct->tm_min = (int) (ac / 60);
    TimeStruct->tm_sec = (int) (ac % 60);
    /*
     * Determine day of week
     */
    TimeStruct->tm_wday = ((TimeStruct->tm_year-70)*365 + lpcnt + TimeStruct->tm_yday + Day1) % 7;

    TimeStruct->tm_isdst = 0;
    return(0);
}


DWORD
time_now(
    VOID
    )
/*++

Routine Description:

    This function returns the UTC time in seconds since 1970.

Arguments:

    None.

Return Value:

    None.

--*/
{
    LARGE_INTEGER Time;
    DWORD         CurrentTime;

    //
    // Get the 64-bit system time.
    // Convert the system time to the number of seconds
    // since 1-1-1970.
    //

    NtQuerySystemTime(&Time);

    if (!RtlTimeToSecondsSince1970(&Time, &CurrentTime))
    {
        CurrentTime = 0;
    }

    return CurrentTime;
}


VOID
NetpGmtTimeToLocalTime(
    IN DWORD GmtTime,           // seconds since 1970 (GMT), or 0, or -1.
    OUT LPDWORD LocalTime       // seconds since 1970 (local), or, or -1.
    )
{

    NetpAssert( LocalTime != NULL );
    if ( (GmtTime == 0) || (GmtTime == (DWORD)(-1)) ) {
        *LocalTime = GmtTime;  // preserve 0 and -1 values.
    } else {
        *LocalTime = GmtTime - NetpLocalTimeZoneOffset();
    }

    IF_DEBUG( TIME ) {
        NetpKdPrint(( PREFIX_NETLIB
                "NetpGmtTimeToLocalTime: done.\n" ));
        NetpDbgDisplayTimestamp( "gmt (in)", GmtTime );
        NetpDbgDisplayTimestamp( "local (out)", *LocalTime );
    }

} // NetpGmtTimeToLocalTime



VOID
NetpLocalTimeToGmtTime(
    IN DWORD LocalTime,         // seconds since 1970 (local), or 0, or -1.
    OUT LPDWORD GmtTime         // seconds since 1970 (GMT), or 0, or -1.
    )
{
    NetpAssert( GmtTime != NULL );
    if ( (LocalTime == 0) || (LocalTime == (DWORD)(-1)) ) {
        *GmtTime = LocalTime;  // preserve 0 and -1 values.
    } else {
        *GmtTime = LocalTime + NetpLocalTimeZoneOffset();
    }

    IF_DEBUG( TIME ) {
        NetpKdPrint(( PREFIX_NETLIB
                "NetpLocalTimeToGmtTime: done.\n" ));
        NetpDbgDisplayTimestamp( "local (in)", LocalTime );
        NetpDbgDisplayTimestamp( "gmt (out)", *GmtTime );
    }

} // NetpLocalTimeToGmtTime



NET_API_STATUS
NetpSystemTimeToGmtTime(
    IN LPSYSTEMTIME WinSplitTime,
    OUT LPDWORD GmtTime         // seconds since 1970 (GMT).
    )
{
    TIME_FIELDS NtSplitTime;
    LARGE_INTEGER NtPreciseTime;

    if ( (WinSplitTime==NULL) || (GmtTime==NULL) ) {
        return (ERROR_INVALID_PARAMETER);
    }

    NtSplitTime.Year         = (CSHORT) WinSplitTime->wYear;
    NtSplitTime.Month        = (CSHORT) WinSplitTime->wMonth;
    NtSplitTime.Day          = (CSHORT) WinSplitTime->wDay;
    NtSplitTime.Hour         = (CSHORT) WinSplitTime->wHour;
    NtSplitTime.Minute       = (CSHORT) WinSplitTime->wMinute;
    NtSplitTime.Second       = (CSHORT) WinSplitTime->wSecond;
    NtSplitTime.Milliseconds = (CSHORT) WinSplitTime->wMilliseconds;
    NtSplitTime.Weekday      = (CSHORT) WinSplitTime->wDayOfWeek;

    if ( !RtlTimeFieldsToTime (
            & NtSplitTime,    // input
            & NtPreciseTime   // output
            ) ) {

        NetpKdPrint(( PREFIX_NETLIB
                "NetpSystemTimeToGmtTime: RtlTimeFieldsToTime failed.\n" ));

        return (NERR_InternalError);
    }

    if ( !RtlTimeToSecondsSince1970 (
            & NtPreciseTime,   // input
            (PULONG) GmtTime ) ) {

        NetpKdPrint(( PREFIX_NETLIB
                "NetpSystemTimeToGmtTime: "
                "RtlTimeToSecondsSince1970 failed.\n" ));

        return (NERR_InternalError);
    }

    return (NO_ERROR);

} // NetpSystemTimeToGmtTime



VOID
NetpGetTimeFormat(
    LPNET_TIME_FORMAT   TimeFormat
    )

/*++

Routine Description:

    This function obtains the user-specific format for the time and date
    strings (short format).  The format is returned in a structure
    pointed to by the TimeFormat parameter.

    MEMORY_USAGE   ** IMPORTANT **
    NOTE:  This function expects any NON-NULL pointers in the TimeFormat
    structure to be allocated on the heap.  It will attempt to free those
    pointers in order to update the format.  This function allocates memory
    from the heap for the various structure members that are pointers to
    strings.  It is the caller's responsiblilty to free each of these
    pointers.

Arguments:

    TimeFormat - A pointer to a structure in which the format information
        can be stored.

Return Value:


--*/
{
    CHAR        czParseString[MAX_TIME_SIZE];
    LPSTR       pTempString;
    INT         numChars;
    LPSTR       AMPMString="";
    LPSTR       ProfileLoc = "intl";
    LPSTR       emptyStr = "";

    //-----------------------------------------
    // Get the Date Format  (M/d/yy)
    //-----------------------------------------
    pTempString = czParseString;
    numChars = GetProfileStringA(
                    ProfileLoc,
                    "sShortDate",
                    emptyStr,
                    czParseString,
                    MAX_TIME_SIZE);

    if (numChars == 0) {
        //
        // No data, use the default.
        //
        pTempString = "M/d/yy";
        numChars = strlen(pTempString);
    }

    if (TimeFormat->DateFormat != NULL) {
        LocalFree(TimeFormat->DateFormat);
        TimeFormat->DateFormat = NULL;
    }

    TimeFormat->DateFormat = LocalAlloc(LMEM_ZEROINIT, numChars+sizeof(CHAR));
    if (TimeFormat->DateFormat != NULL) {
        strcpy(TimeFormat->DateFormat, pTempString);
    }

    //-----------------------------------------
    // 12 or 24 hour format?
    //-----------------------------------------
    TimeFormat->TwelveHour = TRUE;
    numChars = GetProfileStringA(
                ProfileLoc,
                "iTime",
                emptyStr,
                czParseString,
                MAX_TIME_SIZE);
    if (numChars > 0) {
        if (*czParseString == '1'){
            TimeFormat->TwelveHour = FALSE;
        }
    }

    //-----------------------------------------
    // Where put AMPM string?
    //-----------------------------------------
    TimeFormat->TimePrefix = FALSE;
    numChars = GetProfileStringA(
                ProfileLoc,
                "iTimePrefix",
                emptyStr,
                czParseString,
                MAX_TIME_SIZE);
    if (numChars > 0) {
        if (*czParseString == '1'){
            TimeFormat->TimePrefix = TRUE;
        }
    }

    //-----------------------------------------
    // Is there a Leading Zero?
    //-----------------------------------------
    TimeFormat->LeadingZero = FALSE;
    if (GetProfileIntA(ProfileLoc,"iTLZero",0) == 1) {
        TimeFormat->LeadingZero = TRUE;
    }

    //-----------------------------------------
    // Get the Time Separator character.
    //-----------------------------------------
    if (TimeFormat->TimeSeparator != NULL) {
        LocalFree(TimeFormat->TimeSeparator);
        TimeFormat->TimeSeparator = NULL;
    }
    numChars = GetProfileStringA(
                ProfileLoc,
                "sTime",
                emptyStr,
                czParseString,
                MAX_TIME_SIZE);

    if (numChars == 0) {
        //
        // No data, use the default.
        //
        pTempString = ":";
        numChars = strlen(pTempString);
    }
    else {
        pTempString = czParseString;
    }
    TimeFormat->TimeSeparator = LocalAlloc(LMEM_FIXED, numChars + sizeof(CHAR));
    if (TimeFormat->TimeSeparator != NULL) {
        strcpy(TimeFormat->TimeSeparator, pTempString);
    }
    //-------------------------------------------------
    // Get the AM string.
    //-------------------------------------------------
    pTempString = czParseString;
    numChars = GetProfileStringA(
                    ProfileLoc,
                    "s1159",
                    emptyStr,
                    czParseString,
                    MAX_TIME_SIZE);

    if (numChars == 0) {
        pTempString = emptyStr;
    }
    if (TimeFormat->AMString != NULL) {
        LocalFree(TimeFormat->AMString);
    }

    TimeFormat->AMString = LocalAlloc(LMEM_FIXED,strlen(pTempString)+sizeof(CHAR));
    if (TimeFormat->AMString != NULL) {
        strcpy(TimeFormat->AMString,pTempString);
    }

    //-------------------------------------------------
    // Get the PM string.
    //-------------------------------------------------
    pTempString = czParseString;
    numChars = GetProfileStringA(
                ProfileLoc,
                "s2359",
                emptyStr,
                czParseString,
                MAX_TIME_SIZE);

    if (numChars == 0) {
        pTempString = emptyStr;
    }
    if (TimeFormat->PMString != NULL) {
        LocalFree(TimeFormat->PMString);
    }

    TimeFormat->PMString = LocalAlloc(LMEM_FIXED,strlen(pTempString)+sizeof(WCHAR));
    if (TimeFormat->PMString != NULL) {
        strcpy(TimeFormat->PMString,pTempString);
    }

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\netlib\usrprop.c ===
/*++

Copyright (c) 1993-1993  Microsoft Corporation

Module Name:

    usrprop.c

Abstract:

    This module implements QueryUserProperty() and SetUserProperty()
    which read and write NetWare Properties to the UserParms field.

Author:

    Andy Herron (andyhe)    24-May-1993
    Congpa You  (CongpaY)   28-Oct-1993   Seperated SetUserProperty() and
                                          QueryUserProperty() out from usrprop.c
                                          in ncpsrv\svcdlls\ncpsvc\libbind,
                                          modified the code and  fixed a few
                                          existing problems.

Revision History:

--*/

#include "nt.h"
#include "ntrtl.h"
#include "nturtl.h"
#include "ntioapi.h"
#include "windef.h"
#include "winbase.h"
#include "stdio.h"
#include "stdlib.h"
#include "winuser.h"

#include <fpnwcomm.h>
#include <usrprop.h>

//
//   All internal (opaque) structures are listed here since no one else
//   needs to reference them.
//

//
// The user's Parameter field is mapped out to a structure that contains
// the backlevel 48 WCHARs for Mac/Ras compatibility plus a new structure
// that is basically an array of chars that make up a property name plus
// a property value.
//

//
//  This is the structure for an individual property.  Note that there are
//  no null terminators in this.
//
typedef struct _USER_PROPERTY {
    WCHAR   PropertyLength;     // length of property name
    WCHAR   ValueLength;        // length of property value
    WCHAR   PropertyFlag;       // type of property (1 = set, 2 = item)
    WCHAR   Property[1];        // start of property name, followed by value
} USER_PROPERTY, *PUSER_PROPERTY;

//
//  This is the structure that maps the beginning of the user's Parameters
//  field.  It is only separate so that we can do a sizeof() without including
//  the first property, which may or may not be there.
//

typedef struct _USER_PROPERTIES_HDR {
    WCHAR   BacklevelParms[48];     // RAS & Mac data stored here.
    WCHAR   PropertySignature;      // signature that we can look for.
    WCHAR   PropertyCount;          // number of properties present.
} USER_PROPERTIES_HDR, *PUSER_PROPERTIES_HDR;

//
//  This structure maps out the whole of the user's Parameters field when
//  the user properties structure is present and at least one property is
//  defined.
//

typedef struct _USER_PROPERTIES {
    USER_PROPERTIES_HDR Header;
    USER_PROPERTY   FirstProperty;
} USER_PROPERTIES, *PUSER_PROPERTIES;

//
// forward references
//

NTSTATUS
UserPropertyAllocBlock (
    IN PUNICODE_STRING Existing,
    IN ULONG DesiredLength,
    IN OUT PUNICODE_STRING New
    );

BOOL
FindUserProperty (
    PUSER_PROPERTIES UserProperties,
    LPWSTR           Property,
    PUSER_PROPERTY  *pUserProperty,
    USHORT          *pCount
    );

VOID
RemoveUserProperty (
    UNICODE_STRING *puniUserParms,
    PUSER_PROPERTY  UserProperty,
    USHORT          Count,
    BOOL           *Update
    );

VOID
NetpParmsUserPropertyFree (
    LPWSTR NewUserParms
    )
{
    LocalFree( NewUserParms );
    return;
}

NTSTATUS
NetpParmsSetUserProperty (
    IN LPWSTR          UserParms,
    IN LPWSTR          Property,
    IN UNICODE_STRING  PropertyValue,
    IN WCHAR           PropertyFlag,
    OUT LPWSTR        *pNewUserParms,   // memory has to be freed afer use.
    OUT BOOL          *Update
    )
/*
    This function sets a property field in the user's Parameters field.
*/
{
    NTSTATUS status;
    UNICODE_STRING uniUserParms;
    UNICODE_STRING uniNewUserParms;
    USHORT Count = 0;
    USHORT PropertyLength;
    USHORT ValueLength;
    PUSER_PROPERTIES UserProperties;
    PUSER_PROPERTY   UserProperty;
    LPWSTR PropertyValueString = NULL;
    USHORT  oldUserParmsLength;
    INT i;
    UCHAR *pchValue = NULL;

    // Check if parameters are correct.
    if (Property == NULL)
    {
        return( STATUS_INVALID_PARAMETER );
    }

    // Initialize output variables.
    *Update = FALSE;
    *pNewUserParms = NULL;

    try {

        oldUserParmsLength = (USHORT)((lstrlenW(UserParms) + 1) * sizeof(WCHAR));

    } except ( EXCEPTION_EXECUTE_HANDLER ) {

        //
        //  if we can't get the length of the current UserParameters, we loose
        //  the whole thing.
        //

        UserParms = NULL;
    }

    // Convert UserParms to unicode string.
    uniUserParms.Buffer = UserParms;
    uniUserParms.Length = UserParms ? oldUserParmsLength : 0;
    uniUserParms.MaximumLength = uniUserParms.Length;

    /** Get the length of the property name **/

    PropertyLength = (USHORT)(lstrlenW( Property ) * sizeof(WCHAR));

    /** Get the length of the property value **/
    ValueLength = PropertyValue.Length;

    if (ValueLength != 0)
    {
        PCHAR hexValues = "0123456789abcdef";

        // Convert property value to asci string so that
        // if property value is 0, it can be stored correctly.

        PropertyValueString = (LPWSTR) LocalAlloc (LPTR, (ValueLength+1)*sizeof (WCHAR));
        if (!PropertyValueString)
        {
            return(STATUS_NO_MEMORY) ;
        }

        pchValue = (UCHAR *) PropertyValue.Buffer;

        // Since we don't want to pull in user32.dll, we'll roll our own
        // byte to hex code.

        for (i = 0; i < ValueLength; i++)
        {
            *((PCHAR)(PropertyValueString+i)) =            hexValues[((*(pchValue+i)) & 0xF0) >> 4];
            *((PCHAR)((PCHAR)(PropertyValueString+i)+1)) = hexValues[((*(pchValue+i)) & 0x0F)];
        }

        *(PropertyValueString+ValueLength) = 0;
        ValueLength = ValueLength * sizeof (WCHAR);
    }

    //
    // check that user has valid property structure , if not, create one
    //

    if (UserParms != NULL)
    {
        Count = oldUserParmsLength;
    }

    if (Count < sizeof( USER_PROPERTIES))
    {
        Count = sizeof( USER_PROPERTIES_HDR ) + sizeof(WCHAR);
    }

    if (ValueLength > 0)
    {
        Count += sizeof( USER_PROPERTY ) + PropertyLength + ValueLength;
    }

    if (Count > 0x7FFF)
    {
        // can't be bigger than 32K of user parms.
        if (PropertyValueString) {
            LocalFree( PropertyValueString );
        }
        return (STATUS_BUFFER_OVERFLOW);
    }

    try {

        status = UserPropertyAllocBlock( &uniUserParms,
                                         Count,
                                         &uniNewUserParms );
    } except ( EXCEPTION_EXECUTE_HANDLER ) {

        //
        //  if we can't copy the current UserParameters, we loose the whole thing.
        //

        UserParms = NULL;
        uniUserParms.Buffer = UserParms;
        uniUserParms.Length = 0;
        uniUserParms.MaximumLength = uniUserParms.Length;

        Count = sizeof( USER_PROPERTIES_HDR ) + sizeof(WCHAR);
        if (ValueLength > 0) {
            Count += sizeof( USER_PROPERTY ) + PropertyLength + ValueLength;
        }

        status = UserPropertyAllocBlock( &uniUserParms,
                                         Count,
                                         &uniNewUserParms );
    }

    if ( !NT_SUCCESS(status) ) {
        if (PropertyValueString) {
            LocalFree( PropertyValueString );
        }
        return status;
    }

    // Make the output pNewUserParms point to uniNewUserPams's buffer
    // which is the new UserParms string.

    *pNewUserParms = uniNewUserParms.Buffer;

    UserProperties = (PUSER_PROPERTIES) uniNewUserParms.Buffer;

    try {

        if (FindUserProperty (UserProperties,
                              Property,
                              &UserProperty,
                              &Count))
        {
            RemoveUserProperty ( &uniNewUserParms,
                                 UserProperty,
                                 Count,
                                 Update);
        }
    } except ( EXCEPTION_EXECUTE_HANDLER ) {

        //
        //  we have corrupted user parms here... get rid of them.
        //

        *Update = TRUE;

        if (*pNewUserParms != NULL) {
            LocalFree( *pNewUserParms );
        }
        *pNewUserParms = NULL;
        status = STATUS_INVALID_PARAMETER;
    }

    if ( !NT_SUCCESS(status) ) {

        if (PropertyValueString) {
            LocalFree( PropertyValueString );
        }
        return status;
    }

    //
    //  If the new value of the property is not null, add it.
    //

    if (ValueLength > 0) {

        try {

            // find the end of the parameters list

            UserProperty = &(UserProperties->FirstProperty);

            for (Count = 1; Count <= UserProperties->Header.PropertyCount; Count++)
            {
                UserProperty = (PUSER_PROPERTY)
                                   ((LPSTR)((LPSTR) UserProperty +
                                         sizeof(USER_PROPERTY) + // length of entry
                                         UserProperty->PropertyLength +
                                         UserProperty->ValueLength -
                                         sizeof(WCHAR)));  // for Property[0]
            }

            //
            // append it to the end and update length of string
            //

            UserProperty->PropertyFlag   = (PropertyFlag & NCP_SET) ?
                                            USER_PROPERTY_TYPE_SET :
                                            USER_PROPERTY_TYPE_ITEM;

            UserProperty->PropertyLength = PropertyLength;
            UserProperty->ValueLength    = ValueLength;

            RtlCopyMemory(  &(UserProperty->Property[0]),
                            Property,
                            PropertyLength );

            RtlCopyMemory(  &(UserProperty->Property[PropertyLength / sizeof(WCHAR)]),
                            PropertyValueString,
                            ValueLength );

            uniNewUserParms.Length +=
                            sizeof(USER_PROPERTY) + // length of entry
                            PropertyLength +    // length of property name string
                            ValueLength -       // length of value string
                            sizeof(WCHAR);      // account for WCHAR Property[1]

            UserProperties->Header.PropertyCount++;

        } except ( EXCEPTION_EXECUTE_HANDLER ) {

            //
            //  we have corrupted user parms here... get rid of them.
            //

            if (*pNewUserParms != NULL) {
                LocalFree( *pNewUserParms );
            }
            *pNewUserParms = NULL;
            status = STATUS_INVALID_PARAMETER;
        }
        *Update = TRUE;
    }

    // UserParms is already null terminated. We don't need to set the
    // end of UserParms to be NULL since we zero init the buffer already.

    if (PropertyValueString) {
        LocalFree( PropertyValueString );
    }
    return( status );
}

NTSTATUS
NetpParmsSetUserPropertyWithLength (
    IN PUNICODE_STRING UserParms,
    IN LPWSTR          Property,
    IN UNICODE_STRING  PropertyValue,
    IN WCHAR           PropertyFlag,
    OUT LPWSTR        *pNewUserParms,   // memory has to be freed afer use.
    OUT BOOL          *Update
    )
/*
    This function sets a property field in the user's Parameters field.
*/
{
    NTSTATUS status;
    UNICODE_STRING newUserParms;
    ULONG length;
    PWCHAR ptr;

    length = UserParms->Length;

    if (UserParms->MaximumLength < length + sizeof(WCHAR)) {

        //
        //  have to realloc
        //

        newUserParms.Buffer = UserParms->Buffer;
        newUserParms.Length =
                    newUserParms.MaximumLength =
                    (USHORT) ( length + sizeof(WCHAR) );

        newUserParms.Buffer = LocalAlloc (LPTR, newUserParms.Length);

        if (newUserParms.Buffer == NULL) {

            return STATUS_INSUFFICIENT_RESOURCES;
        }

        RtlCopyMemory(  newUserParms.Buffer,
                        UserParms->Buffer,
                        length );

    } else {

        newUserParms.Buffer = UserParms->Buffer;
        newUserParms.Length = (USHORT) length;
        newUserParms.MaximumLength = UserParms->MaximumLength;
    }

    //
    //  Slap in null terminator
    //

    ptr = newUserParms.Buffer + ( length / sizeof(WCHAR) );
    *ptr = L'\0';

    status = NetpParmsSetUserProperty(   newUserParms.Buffer,
                                         Property,
                                         PropertyValue,
                                         PropertyFlag,
                                         pNewUserParms,
                                         Update );

    if (newUserParms.Buffer != UserParms->Buffer) {

        LocalFree( newUserParms.Buffer );
    }

    return(status);
}

#define MAPHEXTODIGIT(x) ( x >= '0' && x <= '9' ? (x-'0') :        \
                           x >= 'A' && x <= 'F' ? (x-'A'+10) :     \
                           x >= 'a' && x <= 'f' ? (x-'a'+10) : 0 )


NTSTATUS
NetpParmsQueryUserProperty (
    IN  LPWSTR          UserParms,
    IN  LPWSTR          PropertyName,
    OUT PWCHAR          PropertyFlag,
    OUT PUNICODE_STRING PropertyValue
    )
/*
    This routine returns a user definable property value as it is stored
    in the user's Parameters field.  Note that the RAS/MAC fields are
    stripped before we start processing user properties.
*/
{
    NTSTATUS        status = STATUS_SUCCESS;
    USHORT          PropertyNameLength;
    USHORT          Count;
    PUSER_PROPERTY  UserProperty;
    WCHAR          *Value;
    UINT            i;
    CHAR           *PropertyValueString = NULL;
    CHAR           *pchValue;

    // Set PropertyValue->Length to 0 initially. If the property is not found
    // it will still be 0 on exit.

    PropertyValue->Length = 0;
    PropertyValue->Buffer = NULL;

    try {

        PropertyNameLength = (USHORT)(lstrlenW(PropertyName) * sizeof(WCHAR));

        // Check if UserParms have the right structure.

        if (FindUserProperty ((PUSER_PROPERTIES) UserParms,
                              PropertyName,
                              &UserProperty,
                              &Count) ) {

            Value = (LPWSTR)(LPSTR)((LPSTR) &(UserProperty->Property[0]) +
                                              PropertyNameLength);

            //
            //  Found the requested property
            //

            //
            //  Copy the property flag.
            //

            if (PropertyFlag) {
                *PropertyFlag = UserProperty->PropertyFlag;
            }

            // Allocate memory for PropertyValue->Buffer

            PropertyValueString = LocalAlloc ( LPTR, UserProperty->ValueLength+1);
            PropertyValue->Buffer = LocalAlloc ( LPTR, UserProperty->ValueLength/sizeof(WCHAR));

            //
            //  Make sure the property value length is valid.
            //
            if ((PropertyValue->Buffer == NULL) || (PropertyValueString == NULL)) {

                status = STATUS_INSUFFICIENT_RESOURCES;

                if (PropertyValue->Buffer != NULL) {
                    LocalFree( PropertyValue->Buffer );
                    PropertyValue->Buffer = NULL;
                }

            } else {

                //
                //  Copy the property value to the buffer.
                //

                RtlCopyMemory( PropertyValueString,
                               Value,
                               UserProperty->ValueLength );

                pchValue = (CHAR *) PropertyValue->Buffer;

                // Convert from value unicode string to value.
                for (i = 0; i < UserProperty->ValueLength/sizeof(WCHAR) ; i++)
                {
                     // sscanf will trash memory.
                     // sscanf( PropertyValueString+2*i, "%2x", pchValue+i);

                     pchValue[i] = MAPHEXTODIGIT( PropertyValueString[2*i]) * 16 +
                                   MAPHEXTODIGIT( PropertyValueString[2*i+1]);
                }

                PropertyValue->Length = UserProperty->ValueLength/sizeof(WCHAR);
                PropertyValue->MaximumLength = UserProperty->ValueLength/sizeof(WCHAR);
            }
        }

    } except ( EXCEPTION_EXECUTE_HANDLER ) {

        //
        //  we have corrupted user parms here... can't return a decent value
        //

        if (PropertyValue->Buffer != NULL) {
            LocalFree( PropertyValue->Buffer );
            PropertyValue->Buffer = NULL;
        }

        PropertyValue->Length = 0;
        status = STATUS_INVALID_PARAMETER;
    }

    if ( PropertyValueString != NULL ) {
        LocalFree( PropertyValueString);
    }

    return status;
}

NTSTATUS
NetpParmsQueryUserPropertyWithLength (
    IN  PUNICODE_STRING UserParms,
    IN  LPWSTR          PropertyName,
    OUT PWCHAR          PropertyFlag,
    OUT PUNICODE_STRING PropertyValue
    )
/*
    This routine returns a user definable property value as it is stored
    in the user's Parameters field.  Note that the RAS/MAC fields are
    stripped before we start processing user properties.
*/
{
    NTSTATUS status;
    UNICODE_STRING newUserParms;
    ULONG length;
    PWCHAR ptr;

    length = UserParms->Length;

    if (UserParms->MaximumLength < length + sizeof(WCHAR)) {

        //
        //  have to realloc
        //

        newUserParms.Buffer = UserParms->Buffer;
        newUserParms.Length =
                    newUserParms.MaximumLength =
                    (USHORT) (length + sizeof(WCHAR) );

        newUserParms.Buffer = LocalAlloc (LPTR, newUserParms.Length);

        if (newUserParms.Buffer == NULL) {

            return STATUS_INSUFFICIENT_RESOURCES;
        }

        RtlCopyMemory(  newUserParms.Buffer,
                        UserParms->Buffer,
                        length );

    } else {

        newUserParms.Buffer = UserParms->Buffer;
        newUserParms.Length = (USHORT) length;
        newUserParms.MaximumLength = UserParms->MaximumLength;
    }

    //
    //  Slap in null terminator
    //

    ptr = newUserParms.Buffer + ( length / sizeof(WCHAR) );
    *ptr = L'\0';

    status = NetpParmsQueryUserProperty( newUserParms.Buffer,
                                         PropertyName,
                                         PropertyFlag,
                                         PropertyValue );

    if (newUserParms.Buffer != UserParms->Buffer) {

        LocalFree( newUserParms.Buffer );
    }

    return(status);
}

// Common routine used by QueryUserProperty() and SetUserProperty().

BOOL
FindUserProperty (
    PUSER_PROPERTIES UserProperties,
    LPWSTR           Property,
    PUSER_PROPERTY  *pUserProperty,
    USHORT          *pCount
    )
{
    BOOL   fFound = FALSE;
    USHORT PropertyLength;

    //
    // Check if user has valid property structure attached,
    // pointed to by UserProperties.
    //

    if (  ( UserProperties != NULL )
       && ( lstrlenW( (LPWSTR) UserProperties) * sizeof(WCHAR) >
            sizeof(UserProperties->Header.BacklevelParms))
       && ( UserProperties->Header.PropertySignature == USER_PROPERTY_SIGNATURE)
       )
    {
        //
        // user has valid property structure.
        //

        *pUserProperty = &(UserProperties->FirstProperty);

        PropertyLength = (USHORT)(lstrlenW( Property ) * sizeof(WCHAR));

        for ( *pCount = 1; *pCount <= UserProperties->Header.PropertyCount;
              (*pCount)++ )
        {
            if (  ( PropertyLength == (*pUserProperty)->PropertyLength )
               && ( RtlCompareMemory( &((*pUserProperty)->Property[0]),
                                      Property,
                                      PropertyLength ) == PropertyLength )
               )
            {
                fFound = TRUE;
                break;
            }

            *pUserProperty = (PUSER_PROPERTY)
                                     ((LPSTR) (*pUserProperty)
                                     + sizeof( USER_PROPERTY )
                                     + (*pUserProperty)->PropertyLength
                                     + (*pUserProperty)->ValueLength
                                     - sizeof(WCHAR));  // for Property[0]
        }
    }

    return( fFound );
}


// Remove a property field from the User Parms.

VOID
RemoveUserProperty (
    UNICODE_STRING *puniUserParms,
    PUSER_PROPERTY  UserProperty,
    USHORT          Count,
    BOOL           *Update
    )
{
    PUSER_PROPERTIES    UserProperties;
    PUSER_PROPERTY      NextProperty;
    USHORT              OldParmLength;

    UserProperties = (PUSER_PROPERTIES) puniUserParms->Buffer;

    OldParmLength = sizeof( USER_PROPERTY ) +
                    UserProperty->PropertyLength +
                    UserProperty->ValueLength -
                    sizeof(WCHAR);  // for Property[0]


    NextProperty = (PUSER_PROPERTY)(LPSTR)((LPSTR) UserProperty + OldParmLength);

    //
    // if we're not on the last one, copy the remaining buffer up
    //

    if (Count < UserProperties->Header.PropertyCount) {

        RtlMoveMemory(  UserProperty,
                        NextProperty,
                        puniUserParms->Length -
                        ((LPSTR) NextProperty -
                         (LPSTR) puniUserParms->Buffer ));
    }

    //
    //  Now reduce the length of the buffer by the amount we pulled out
    //

    puniUserParms->Length -= OldParmLength;

    UserProperties->Header.PropertyCount--;

    *Update = TRUE;
}


NTSTATUS
UserPropertyAllocBlock (
    IN PUNICODE_STRING     Existing,
    IN ULONG               DesiredLength,
    IN OUT PUNICODE_STRING New
    )
/*
    This allocates a larger block for user's parameters and copies the old
    block in.
*/
{
    PUSER_PROPERTIES    UserProperties;
    CLONG               Count;
    WCHAR               *pNewBuff;


    //
    //  We will allocate a new buffer to store the new parameters
    //  and copy the existing parameters into it.
    //

    New->Buffer = LocalAlloc (LPTR, DesiredLength);

    if ( New->Buffer == NULL)
    {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    New->MaximumLength = (USHORT) DesiredLength;

    if (Existing != NULL)
    {

        New->Length = Existing->Length;

        RtlCopyMemory(  New->Buffer,
                        Existing->Buffer,
                        Existing->Length );
    }
    else
    {
        New->Length = 0;
    }

    //
    //  Ensure that we don't have any nulls in our string.
    //

    for ( Count = 0;
          Count < New->Length / sizeof(WCHAR);
          Count++ )
    {
        if (*(New->Buffer + Count) == L'\0')
        {
            New->Length = (USHORT) Count * sizeof(WCHAR);
            break;
        }
    }

    //
    //  now pad it out with spaces until reached Mac+Ras reserved length
    //

    pNewBuff = (WCHAR *) New->Buffer + ( New->Length / sizeof(WCHAR) );

    while ( New->Length < sizeof(UserProperties->Header.BacklevelParms))
    {
        *( pNewBuff++ ) = L' ';
        New->Length += sizeof(WCHAR);
    }

    //
    //  If the signature isn't there, stick it in and set prop count to 0
    //

    UserProperties = (PUSER_PROPERTIES) New->Buffer;

    if (New->Length < sizeof(USER_PROPERTIES_HDR) ||
        UserProperties->Header.PropertySignature != USER_PROPERTY_SIGNATURE)
    {

        UserProperties->Header.PropertySignature = USER_PROPERTY_SIGNATURE;
        UserProperties->Header.PropertyCount = 0;

        New->Length = sizeof(USER_PROPERTIES_HDR);
    }

    return STATUS_SUCCESS;
}

// usrprop.c eof.
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\netlib\timezone.c ===
/*++

Copyright (c) 1991-1993  Microsoft Corporation

Module Name:

    TimeZone.c

Abstract:

    This file just contains NetpLocalTimeZoneOffset().  (It is the only
    NetLib time function used by SRVSVC.DLL at this time, and ChuckL wants
    to keep that DLL as small as possible.)

Author:

    JR (John Rogers, JohnRo@Microsoft) 20-Aug-1992

Environment:

    Interface is portable to any flat, 32-bit environment.
    Uses Win32 typedefs.
    Requires ANSI C extensions: slash-slash comments, long external names.

Revision History:

    20-Aug-1992 JohnRo
        RAID 2920: Support UTC timezone in net code.
    01-Oct-1992 JohnRo
        RAID 3556: Added NetpSystemTimeToGmtTime() for DosPrint APIs.
    15-Apr-1993 Danl
        Fixed NetpLocalTimeZoneOffset so that it uses the windows calls and
        obtains the correct bias.
    14-Jun-1993 JohnRo
        RAID 13080: Allow repl between different timezones.
        Also, DanL asked me to remove printf() call.
    18-Jun-1993 JohnRo
        RAID 13594: Extracted NetpLocalTimeZoneOffset() so srvsvc.dll doesn't
        get too big.
        Use NetpKdPrint() where possible.

--*/


// These must be included first:

#include <windows.h>

// These may be included in any order:

#include <netdebug.h>   // NetpAssert(), NetpKdPrint(), FORMAT_ equates.
#include <prefix.h>     // PREFIX_ equates.
#include <timelib.h>    // My prototypes.


LONG  // Number of seconds from UTC.  Positive values for west of Greenwich,
// negative values for east of Greenwich.
NetpLocalTimeZoneOffset(
    VOID
    )
{
    TIME_ZONE_INFORMATION   tzInfo;
    LONG                    bias;

    switch (GetTimeZoneInformation(&tzInfo)) {
    case TIME_ZONE_ID_DAYLIGHT:
        bias = tzInfo.Bias + tzInfo.DaylightBias;
        break;
    case TIME_ZONE_ID_STANDARD:
        bias = tzInfo.Bias + tzInfo.StandardBias;
        break;
    case TIME_ZONE_ID_UNKNOWN:
        bias = tzInfo.Bias;
        break;
    default:
        NetpKdPrint(( PREFIX_NETLIB
                "NetpLocalTimeZoneOffset: GetTimeZoneInformation failed.\n" ));
        return(0);
    }
    bias *= 60;
    return(bias);

} // NetpLocalTimeZoneOffset
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\netlib\wcsicmp.c ===
/*++

Copyright (c) 1991-92  Microsoft Corporation

Module Name:

    _wcsicmp.c

Abstract:

    Temporary versions of _wcsicmp and _wcscmpi routines.

Author:

    Cliff Van Dyke (cliffv) 20-Feb-1991

Environment:

    User mode only.
    Contains NT-specific code.
    Requires ANSI C extensions: slash-slash comments, long external names.

Revision History:

    17-Apr-1991 (cliffv)
        Incorporated review comments.
    27-Sep-1991 JohnRo
        Swiped _wcsicmp() from Cliff and put it in NetLib.  Added _wcsicmp().
    09-Apr-1992 JohnRo
        Prepare for WCHAR.H (_wcsicmp vs _wcscmpi, etc).

--*/


#include <nt.h>
#include <ntrtl.h>
#include <windef.h>
#include <wchar.h>




#if 0
// _wcsicmp is preferred over _wcscmpi, which won't be implemented by
// initial library from KarlSi.  --JR 09-Apr-1992
int
_wcscmpi(
    IN const wchar_t *string1,
    IN const wchar_t *string2
    )
{
    return (_wcsicmp(string1, string2));

} // _wcscmpi
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\netlib\wtol.c ===
/*++

Copyright (c) 1991-1992  Microsoft Corporation

Module Name:

    WToL.c

Abstract:

    Contains wcs string functions that are not available in wcstr.h

Author:

    10/29/91    madana
        temp code.

Environment:

    User mode only.
    Contains NT-specific code.
    Requires ANSI C extensions: slash-slash comments, long external names.
    Tab size is set to 4.

Revision History:

    09-Jan-1992 JohnRo
        Moved MadanA's wcstol() from replicator svc to NetLib.
        Changed name to avoid probable conflict with strtol -> wcstol routine.
--*/

#include <windef.h>

#include <tstring.h>            // My prototypes.



LONG
wtol(
    IN LPWSTR string
    )
{
    LONG value = 0;

    while((*string != L'\0')  && 
            (*string >= L'0') && 
            ( *string <= L'9')) {
        value = value * 10 + (*string - L'0');
        string++;
    }

    return(value);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\netlib\wksinfo.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    WksInfo.c

Abstract:

    This file contains NetpWkstaStructureInfo().

Author:

    John Rogers (JohnRo) 15-Aug-1991

Environment:

    Portable to any flat, 32-bit environment.  (Uses Win32 typedefs.)
    Requires ANSI C extensions: slash-slash comments, long external names.

Revision History:

    15-Aug-1991 JohnRo
        Implement downlevel NetWksta APIs.
    20-Nov-1991 JohnRo
        Removed NT dependencies to reduce recompiles.

--*/

// These must be included first:

#include <windef.h>             // IN, DWORD, etc.
#include <lmcons.h>             // LM20_ equates, NET_API_STATUS, etc.
#include <lmwksta.h>            // WKSTA_INFO_100, etc.  (Needed by dlwksta.h)
#include <rap.h>                // LPDESC, needed by <strucinf.h>.

// These may be included in any order:

#include <dlwksta.h>            // WKSTA_INFO_0, MAX_WKSTA_ equates, etc.
#include <lmerr.h>              // ERROR_ and NERR_ equates.
#include <netlib.h>             // NetpSetOptionalArg().
#include <netdebug.h>           // NetpAssert().
#include <remdef.h>             // REM16_, REM32_, REMSmb_ equates.
#include <strucinf.h>           // My prototype.


NET_API_STATUS
NetpWkstaStructureInfo (
    IN DWORD Level,
    IN DWORD ParmNum,  // Use PARMNUM_ALL if not applicable.
    IN BOOL Native,    // Should sizes be native or RAP?
    OUT LPDESC * DataDesc16 OPTIONAL,
    OUT LPDESC * DataDesc32 OPTIONAL,
    OUT LPDESC * DataDescSmb OPTIONAL,
    OUT LPDWORD MaxSize OPTIONAL,
    OUT LPDWORD FixedSize OPTIONAL,
    OUT LPDWORD StringSize OPTIONAL
    )

{
    DBG_UNREFERENCED_PARAMETER(ParmNum);

    NetpAssert( Native );

    //
    // Decide what to do based on the info level.  Note that normally we'd
    // be using REM16_, REM32_, and REMSmb_ descriptors here.  However,
    // the REM16_ and REM32_ ones have been modified to reflect a nonexistant
    // field (svX_platform_id).  This messes up the automatic conversions
    // done by RxRemoteApi.  So, we use "downlevel" descriptors (DL_REM_)
    // which are defined in DlWksta.h, or we use the REMSmb descriptors for
    // more things than they were intended.
    //
    switch (Level) {

#define SetSizes(fixed,variable) \
    { \
        NetpSetOptionalArg( MaxSize, (fixed) + (variable) ); \
        NetpSetOptionalArg( FixedSize, (fixed) ); \
        NetpSetOptionalArg( StringSize, (variable) ); \
    }

    case 0 :
        NetpSetOptionalArg( DataDesc16, REMSmb_wksta_info_0 );
        NetpSetOptionalArg( DataDesc32, DL_REM_wksta_info_0 );
        NetpSetOptionalArg( DataDescSmb, REMSmb_wksta_info_0 );
        SetSizes( sizeof(WKSTA_INFO_0), MAX_WKSTA_0_STRING_SIZE );
        break;

    case 1 :
        NetpSetOptionalArg( DataDesc16, REMSmb_wksta_info_1 );
        NetpSetOptionalArg( DataDesc32, DL_REM_wksta_info_1 );
        NetpSetOptionalArg( DataDescSmb, REMSmb_wksta_info_1 );
        SetSizes( sizeof(WKSTA_INFO_1), MAX_WKSTA_1_STRING_SIZE );
        break;

    case 10 :
        NetpSetOptionalArg( DataDesc16, REMSmb_wksta_info_10 );
        NetpSetOptionalArg( DataDesc32, DL_REM_wksta_info_10 );
        NetpSetOptionalArg( DataDescSmb, REMSmb_wksta_info_10 );
        SetSizes( sizeof(WKSTA_INFO_10), MAX_WKSTA_10_STRING_SIZE );
        break;

    case 100 :
        NetpSetOptionalArg( DataDesc16, NULL );
        NetpSetOptionalArg( DataDesc32, REM32_wksta_info_100 );
        NetpSetOptionalArg( DataDescSmb, NULL );
        SetSizes( sizeof(WKSTA_INFO_100), MAX_WKSTA_100_STRING_SIZE );
        break;

    case 101 :
        NetpSetOptionalArg( DataDesc16, NULL );
        NetpSetOptionalArg( DataDesc32, REM32_wksta_info_101 );
        NetpSetOptionalArg( DataDescSmb, NULL );
        SetSizes( sizeof(WKSTA_INFO_101), MAX_WKSTA_101_STRING_SIZE );
        break;

    case 102 :
        NetpSetOptionalArg( DataDesc16, NULL );
        NetpSetOptionalArg( DataDesc32, REM32_wksta_info_102 );
        NetpSetOptionalArg( DataDescSmb, NULL );
        SetSizes( sizeof(WKSTA_INFO_102), MAX_WKSTA_102_STRING_SIZE );
        break;

    case 302 :
        NetpSetOptionalArg( DataDesc16, NULL );
        NetpSetOptionalArg( DataDesc32, REM32_wksta_info_302 );
        NetpSetOptionalArg( DataDescSmb, NULL );
        SetSizes( sizeof(WKSTA_INFO_302), MAX_WKSTA_302_STRING_SIZE );
        break;

    case 402 :
        NetpSetOptionalArg( DataDesc16, NULL );
        NetpSetOptionalArg( DataDesc32, REM32_wksta_info_402 );
        NetpSetOptionalArg( DataDescSmb, NULL );
        SetSizes( sizeof(WKSTA_INFO_402), MAX_WKSTA_402_STRING_SIZE );
        break;

    case 502 :
        NetpSetOptionalArg( DataDesc16, NULL );
        NetpSetOptionalArg( DataDesc32, REM32_wksta_info_502 );
        NetpSetOptionalArg( DataDescSmb, NULL );
        SetSizes( sizeof(WKSTA_INFO_502), MAX_WKSTA_502_STRING_SIZE );
        break;

    default :
        return (ERROR_INVALID_LEVEL);
    }


    return (NERR_Success);

} // NetpWkstaStructureInfo
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\netlib\xlatesvc.c ===
/*++

Copyright (c) 1992 Microsoft Corporation

Module Name:

    XlateSvc.c

Abstract:

    This module contains NetpTranslateServiceName().

Author:

    John Rogers (JohnRo) 08-May-1992

Environment:

    Portable to any flat, 32-bit environment.  (Uses Win32 typedefs.)
    Requires ANSI C extensions: slash-slash comments, long external names.

Notes:

    This code assumes that the info levels are subsets of each other.

Revision History:

    08-May-1992 JohnRo
        Created.
    10-May-1992 JohnRo
        Added debug output to translate service name routine.
    06-Aug-1992 JohnRo
        RAID 3021: NetService APIs don't always translate svc names.

--*/

// These must be included first:

#include <windef.h>     // IN, DWORD, etc.
#include <lmcons.h>     // NET_API_STATUS.

// These may be included in any order:

#include <debuglib.h>   // IF_DEBUG().
#include <lmapibuf.h>   // NetApiBufferAllocate(), etc.
#include <lmsname.h>    // SERVICE_ and SERVICE_LM20_ equates.
#include <lmsvc.h>      // LPSERVER_INFO_2, etc.
#include <netdebug.h>   // NetpKdPrint(()), FORMAT_ equates.
#include <netlib.h>     // My prototypes, NetpIsServiceLevelValid().
#include <prefix.h>     // PREFIX_ equates.
#include <strucinf.h>   // NetpServiceStructureInfo().
#include <tstr.h>       // TCHAR_EOS.
#include <winerror.h>   // NO_ERROR and ERROR_ equates.


NET_API_STATUS
NetpTranslateNamesInServiceArray(
    IN DWORD Level,
    IN LPVOID OldArrayBase,
    IN DWORD EntryCount,
    IN BOOL PreferNewStyle,
    OUT LPVOID * FinalArrayBase
    )
{
    NET_API_STATUS ApiStatus;
    DWORD EntryIndex;
    DWORD FixedSize;
    DWORD MaxSize;
    LPVOID NewArrayBase = NULL;
    LPVOID NewEntry;
    LPTSTR NewStringTop;
    LPVOID OldEntry;

    // Check for GP fault and make error handling easier.
    if (FinalArrayBase != NULL) {
        *FinalArrayBase = NULL;
    }

    // Check for caller errors.
    if ( !NetpIsServiceLevelValid( Level ) ) {
        return (ERROR_INVALID_LEVEL);
    } else if (OldArrayBase == NULL) {
        return (ERROR_INVALID_PARAMETER);
    } else if (FinalArrayBase == NULL) {
        return (ERROR_INVALID_PARAMETER);
    }

    if (EntryCount == 0) {
        return(NO_ERROR);
    }

    ApiStatus = NetpServiceStructureInfo (
            Level,
            PARMNUM_ALL,
            TRUE,         // yes, we want native sizes
            NULL,         // don't need DataDesc16
            NULL,         // don't need DataDesc32
            NULL,         // don't need DataDescSmb
            & MaxSize,    // max entry size in bytes
            & FixedSize,  // need fixed entry size (in bytes)
            NULL );       // don't need StringSize
    NetpAssert( ApiStatus == NO_ERROR );  // already checked Level.
    NetpAssert( (FixedSize > 0) && (MaxSize > 0) );

    //
    // Allocate the new array.
    //
    ApiStatus = NetApiBufferAllocate(
            EntryCount * MaxSize,                  // byte count
            (LPVOID *) (LPVOID) & NewArrayBase );  // alloc'ed area
    if (ApiStatus != NO_ERROR) {
        return (ApiStatus);
    }
    NetpAssert( NewArrayBase != NULL );

    //
    // Set up things for the usual string copy scenario.
    //
    NewStringTop = (LPTSTR) NetpPointerPlusSomeBytes(
                NewArrayBase,
                EntryCount * MaxSize);


#define COPY_OPTIONAL_STRING( OutField, InString ) \
    { \
        NetpAssert( NewStruct != NULL); \
        if ( (InString) == NULL ) { \
            NewStruct->OutField = NULL; \
        } else { \
            COPY_REQUIRED_STRING( OutField, InString ); \
        } \
    }

#define COPY_REQUIRED_STRING( OutField, InString ) \
    { \
        BOOL CopyOK; \
        NetpAssert( NewStruct != NULL); \
        NetpAssert( InString != NULL); \
        CopyOK = NetpCopyStringToBuffer ( \
            InString, \
            STRLEN(InString), \
            NewFixedEnd, \
            & NewStringTop, \
            & NewStruct->OutField); \
        NetpAssert(CopyOK); \
    }

    //
    // Copy the array, translating names while we're at it.
    //
    NewEntry = NewArrayBase;
    OldEntry = OldArrayBase;
    for (EntryIndex=0; EntryIndex < EntryCount; ++EntryIndex) {

        LPTSTR NewName = NULL;

        // These variables are used by the COPY_REQUIRED_STRING and
        // COPY_OPTIONAL_STRING macros.
        LPSERVICE_INFO_2 NewStruct = NewEntry;
        LPSERVICE_INFO_2 OldStruct = OldEntry;

        LPBYTE NewFixedEnd = NetpPointerPlusSomeBytes(NewEntry, FixedSize);

        ApiStatus = NetpTranslateServiceName(
                OldStruct->svci2_name,
                PreferNewStyle,
                & NewName );
        if (ApiStatus != NO_ERROR) {
            goto Cleanup;
        }
        NetpAssert( NewName != NULL );
        COPY_REQUIRED_STRING( svci2_name, NewName );
        NetpAssert( (NewStruct->svci2_name) != NULL );

        if (Level > 0) {
            NewStruct->svci2_status = OldStruct->svci2_status;
            NewStruct->svci2_code   = OldStruct->svci2_code  ;
            NewStruct->svci2_pid    = OldStruct->svci2_pid   ;
        }
        if (Level > 1) {
            COPY_OPTIONAL_STRING( svci2_text, OldStruct->svci2_text );
            COPY_REQUIRED_STRING(svci2_display_name,OldStruct->svci2_display_name );

            //
            // Since this routine is used by NT and downlevel NetService wrappers
            // we cannot just write a default values in the specific_error field.
            //
            if ((unsigned short) OldStruct->svci2_code != ERROR_SERVICE_SPECIFIC_ERROR) {
                NewStruct->svci2_specific_error = 0;
            }
            else {
                NewStruct->svci2_specific_error = OldStruct->svci2_specific_error;
            }
        }

        NewEntry =
                NetpPointerPlusSomeBytes( NewEntry, FixedSize );
        OldEntry =
                NetpPointerPlusSomeBytes( OldEntry, FixedSize );
    }

    ApiStatus = NO_ERROR;

Cleanup:

    if (ApiStatus != NO_ERROR) {
        if (NewArrayBase != NULL) {
            (VOID) NetApiBufferFree( NewArrayBase );
        }
        NetpAssert( (*FinalArrayBase) == NULL );
    } else {
        *FinalArrayBase = NewArrayBase;
    }


    return (ApiStatus);

} // NetpTranslateNamesInServiceArray


NET_API_STATUS
NetpTranslateServiceName(
    IN LPTSTR GivenServiceName,
    IN BOOL PreferNewStyle,
    OUT LPTSTR * TranslatedName
    )
/*++

Routine Description:

    This routine attempts to translate a given service name to
    an old-style (as used by downlevel Lanman machines) or new-style
    (as used by NT machines) name.  For instance, "WORKSTATION" might
    become "LanmanWorkstation", or vice versa.  This routine is used in
    remoting NetService APIs in three different flavors:

        - NT-to-NT (prefer a new-style name)
        - NT-to-downlevel (prefer an old-style name)
        - downlevel-to-NT (prefer a new-style name)

Arguments:

    GivenServiceName - Supplies the number of strings specified in ArgsArray.

    PreferNewStyle - Indicates whether the call prefers a new-style name
        (for use on an NT system) as opposed to an old-style name (for use
        on a downlevel LanMan system).

    TranslatedName - This pointer will be set to one of the following:

        - a static (constant) string with the translated service name.
        - GivenServiceName if the service name is not recognized.  (This
          may be the case for nonstandard Lanman services, and is not considered
          an error by this routine.)
        - NULL if an error occurs.

Return Value:

    NET_API_STATUS - NO_ERROR or ERROR_INVALID_PARAMETER.

--*/
{

    //
    // Error check caller.
    //
    if (TranslatedName == NULL) {
        return (ERROR_INVALID_PARAMETER);
    } else if (GivenServiceName == NULL) {
        *TranslatedName = NULL;
        return (ERROR_INVALID_PARAMETER);
    } else if ((*GivenServiceName) == TCHAR_EOS) {
        *TranslatedName = NULL;
        return (ERROR_INVALID_PARAMETER);
    }

#define TRY_NAME( NewName, OldName ) \
    { \
        if (STRICMP(GivenServiceName, OldName)==0 ) { \
            if (PreferNewStyle) { \
                *TranslatedName = (NewName); \
            } else { \
                /* Given matches old, except possibly mixed case. */ \
                /* Be pessimistic and send upper case only do downlevel. */ \
                *TranslatedName = (OldName); \
            } \
            goto Done; \
        } else if (STRICMP(GivenServiceName, NewName)==0 ) { \
            if (PreferNewStyle) { \
                /* Have choice between given and new name here. */ \
                /* New APIs handle mixed case, so preserve callers's case. */ \
                *TranslatedName = (GivenServiceName); \
            } else { \
                *TranslatedName = (OldName); \
            } \
            goto Done; \
        } \
    }

    //
    // Do brute-force comparisons of names
    //
    // PERFORMANCE NOTE: This list should be in order from
    // most-often used to least-often.  Note that workstation and
    // server are often used as part of remoting APIs, so I
    // think they should be first.

    TRY_NAME( SERVICE_WORKSTATION,  SERVICE_LM20_WORKSTATION );

    TRY_NAME( SERVICE_SERVER,  SERVICE_LM20_SERVER );

    TRY_NAME( SERVICE_BROWSER,  SERVICE_LM20_BROWSER );

    TRY_NAME( SERVICE_MESSENGER,  SERVICE_LM20_MESSENGER );

    TRY_NAME( SERVICE_NETRUN,  SERVICE_LM20_NETRUN );

    TRY_NAME( SERVICE_SPOOLER,  SERVICE_LM20_SPOOLER );

    TRY_NAME( SERVICE_ALERTER,  SERVICE_LM20_ALERTER );

    TRY_NAME( SERVICE_NETLOGON,  SERVICE_LM20_NETLOGON );

    TRY_NAME( SERVICE_NETPOPUP,  SERVICE_LM20_NETPOPUP );

    TRY_NAME( SERVICE_SQLSERVER,  SERVICE_LM20_SQLSERVER );

    TRY_NAME( SERVICE_REPL,  SERVICE_LM20_REPL );

    TRY_NAME( SERVICE_RIPL,  SERVICE_LM20_RIPL );

    TRY_NAME( SERVICE_TIMESOURCE,  SERVICE_LM20_TIMESOURCE );

    TRY_NAME( SERVICE_AFP,  SERVICE_LM20_AFP );

    TRY_NAME( SERVICE_UPS,  SERVICE_LM20_UPS );

    TRY_NAME( SERVICE_XACTSRV,  SERVICE_LM20_XACTSRV );

    TRY_NAME( SERVICE_TCPIP,  SERVICE_LM20_TCPIP );

    //
    // No match.  Use given name.
    //
    *TranslatedName = GivenServiceName;

Done:

    IF_DEBUG( XLATESVC ) {
        NetpKdPrint(( PREFIX_NETLIB "NetpTranslateServiceName: "
                " translated " FORMAT_LPTSTR " to " FORMAT_LPTSTR ".\n",
                GivenServiceName, *TranslatedName ));
    }

    return (NO_ERROR);

} // NetpTranslateServiceName
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\netlib\wcsfuncs.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    wcsfuncs.c

Abstract:

    Temporary unicode-only string functions until languages supply
    real run-times

        _wcsnicmp
        towupper
        iswalpha
        iswdigit
        _wcsupr
        wcstomb
Author:

    Richard L Firth (rfirth) 09-Mar-1992

Revision History:

--*/

#ifdef UNICODE

#include <windows.h>
#include <ctype.h>

int _wcsnicmp(LPWSTR s1, LPWSTR s2, DWORD len) {
    int result = 0;

    while (*s1 && *s2 && !(result = (toupper(*s1) - toupper(*s2))) && len) {
        ++s1;
        ++s2;
        --len;
    }
    return result;
}

#if 0
int iswalpha(WCHAR ch) {
    return isalpha(ch);
}

int iswdigit(WCHAR ch) {
    return isdigit(ch);
}
#endif

LPWSTR _wcsupr(LPWSTR str) {
    LPWSTR start = str;
    while (*str) {
        *str = toupper(*str);
        ++str;
    }
    return start;
}

int wcstomb(LPSTR str, LPWSTR wstr) {
    while (*wstr) {
        *str++ = (char)*wstr++;
    }
    return 0; //?
}
#endif

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\rap\arraylen.c ===
/*++

Copyright (c) 1987-1992 Microsoft Corporation

Module Name:

    ArrayLen.c

Abstract:

    This module contains Remote Admin Protocol (RAP) routines.  These routines
    are shared between XactSrv and RpcXlate.

Author:

    (Various LanMan 2.x people.)

Environment:

    Portable to any flat, 32-bit environment.  (Uses Win32 typedefs.)
    Requires ANSI C extensions: slash-slash comments, long external names.

Revision History:

    12-Mar-1991 JohnRo
        Converted from LanMan 2.x to NT Rap (Remote Admin Protocol) routines.
    14-Apr-1991 JohnRo
        Reduced recompiles.  Got rid of tabs in file.
    29-Sep-1991 JohnRo
        Made changes suggested by PC-LINT.  Work toward possible conversion of
        descs to UNICODE.
    16-Aug-1992 JohnRo
        RAID 2920: Support UTC timezone in net code.
        Use PREFIX_ equates.

--*/


// These must be included first:

#include <windef.h>             // IN, LPDWORD, NULL, OPTIONAL, DWORD, etc.
#include <lmcons.h>             // NET_API_STATUS

// These may be included in any order:

#include <netdebug.h>           // NetpAssert(), NetpDbg routines.
#include <prefix.h>     // PREFIX_ equates.
#include <rap.h>                // LPDESC, my non-private prototypes, etc.
#include <remtypes.h>           // REM_WORD, etc.


DWORD
RapArrayLength(
    IN LPDESC Descriptor,
    IN OUT LPDESC * UpdatedDescriptorPtr,
    IN RAP_TRANSMISSION_MODE TransmissionMode
    )

/*++

Routine Description:

    RapArrayLength gets the length of an array described by type descriptor
    element.  This routine also updates the descriptor string pointer to point
    to the last char in the element of the descriptor string.

Arguments:

    Descriptor - Points to first character in the descriptor element to be
        processed.

    UpdatedDescriptorPtr - The address of the pointer passed as Descriptor.
        On exit, this will be updated to point to last character in descriptor
        element.

    Transmission Mode - Indicates whether this array is part of a response,
        a request, or both.

Return Value:

    DWORD - Length, in bytes of the array described by the descriptor string
        element.  This may be zero, depending on the value of Transmission
        Mode.

--*/


{
    DWORD num_elements;
    DWORD element_length;

    // First set length of an element in the array.

    switch (*Descriptor) {
    case REM_BYTE :
        element_length = sizeof(BYTE);
        break;

    case REM_WORD :
        element_length = sizeof(WORD);
        break;

    case REM_DWORD :
    case REM_SIGNED_DWORD :
        element_length = sizeof(DWORD);
        break;

    case REM_BYTE_PTR :
        element_length = sizeof(BYTE);
        break;

    case REM_WORD_PTR :
        element_length = sizeof(WORD);
        break;

    case REM_DWORD_PTR :
        element_length = sizeof(DWORD);
        break;

    case REM_RCV_BYTE_PTR :
        if (TransmissionMode == Request) {
            return (0);
        }
        element_length = sizeof(BYTE);
        break;

    case REM_RCV_WORD_PTR :
        if (TransmissionMode == Request) {
            return (0);
        }
        element_length = sizeof(WORD);
        break;

    case REM_RCV_DWORD_PTR :
        if (TransmissionMode == Request) {
            return (0);
        }
        element_length = sizeof(DWORD);
        break;

    case REM_NULL_PTR :
        return (0);

    case REM_FILL_BYTES :
        element_length = sizeof(BYTE);
        break;

    case REM_SEND_BUF_PTR :
        NetpAssert(TransmissionMode != Response);
        return (0);

    /*
     * Warning: following fixes a bug in which "b21" type
     *            combinations in parmeter string will be
     *            handled correctly when pointer to such "bit map"
     *            in the struct is NULL. These two dumbos could
     *            interfere so we  force a success return.
    */
    case REM_SEND_LENBUF:
        return (0);

    //
    // Set element length to zero since strings don't get stored in
    // the structure, but fall through so UpdatedDescriptorPtr is still
    // incremented to point past the maximum length count, if present.
    //

    case REM_ASCIZ:
    case REM_ASCIZ_TRUNCATABLE:
        element_length = 0;
        break;

    case REM_EPOCH_TIME_GMT:    /*FALLTHROUGH*/
    case REM_EPOCH_TIME_LOCAL:  /*FALLTHROUGH*/
        element_length = sizeof(DWORD);
        break;

    default:
        NetpKdPrint(( PREFIX_NETRAP
                "RapArrayLength: Unexpected desc char '" FORMAT_DESC_CHAR
                "'.\n", *Descriptor));
        NetpBreakPoint();
        return (0);
    }

    // Now get number of elements in the array.

    for ( num_elements = 0, Descriptor++;
            DESC_CHAR_IS_DIGIT( *Descriptor );
            Descriptor++, (*UpdatedDescriptorPtr)++) {

        num_elements = (10 * num_elements) + DESC_DIGIT_TO_NUM( *Descriptor );

    }

    return (element_length == 0)
               ? 0
               : ( num_elements == 0
                     ? element_length
                     : element_length * num_elements );
} // RapArrayLength
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\rap\ascii.c ===
/*++

Copyright (c) 1991 Microsoft Corporation

Module Name:

    ASCII.c

Abstract:

    This module contains code for Remote Admin Protocol use.

Author:

    David Treadwell (davidtr)    07-Jan-1991

Environment:

    Portable to any flat, 32-bit environment.  (Uses Win32 typedefs.)

Revision History:

    27-Feb-1991 JohnRo
        Converted from Xs routines to Rap routines.
    14-Apr-1991 JohnRo
        Reduce recompiles.
    17-Apr-1991 JohnRo
        Make it clear that "input" pointer is updated.
    19-Aug-1991 JohnRo
        Improve UNICODE handling.
        Reduce recompiles.
    07-Sep-1991 JohnRo
        Use DESC_DIGIT_TO_NUM().  Made changes suggested by PC-LINT.

--*/


// These must be included first:
#include <windef.h>             // IN, LPDWORD, NULL, OPTIONAL, DWORD, etc.
#include <lmcons.h>             // NET_API_STATUS

// These may be included in any order:
#include <rap.h>                // My prototype, LPDESC, DESC_CHAR_IS_DIGIT().


DWORD
RapAsciiToDecimal (
   IN OUT LPDESC *Number
   )

/*++

Routine Description:

    This routine converts an ASCII string to decimal and updates the
    input pointer to point the last character of the number.  The string is
    parm of a descriptor.

Arguments:

    Number - points to a LPDESC pointing to a number in ASCII format.  The
        pointer is updated to point to the next location after the number.

Return Value:

    The decimal value of the string.

--*/

{
    LPDESC s;
    DWORD actualNumber = 0;

    //
    // Walk through the number, multiplying the current value by ten to
    // update place, and adding the next digit.
    //

    for ( s = *Number; DESC_CHAR_IS_DIGIT( *s ); s++ ) {

        actualNumber = actualNumber * 10 + DESC_DIGIT_TO_NUM( *s );

    }

    //
    // Set up the output pointer to point to the character after the last
    // digit of the number.
    //

    *Number = s;

    return actualNumber;

} // RapAsciiToDecimal
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\rap\auxdata.c ===
/*++

Copyright (c) 1991 Microsoft Corporation

Module Name:

    AuxData.c

Abstract:

    This module contains Remote Admin Protocol (RAP) routines.  These routines
    are shared between XactSrv and RpcXlate.

Author:

    Shanku Niyogi (w-shanku)    15-Mar-1991

Environment:

    Portable to any flat, 32-bit environment.  (Uses Win32 typedefs.)
    Requires ANSI C extensions: slash-slash comments, long external names.

Revision History:

    08-Apr-1991 JohnRo
        Added assertion checking.
    14-Apr-1991 JohnRo
        Reduce recompiles.
    15-May-1991 JohnRo
        Added native vs. RAP handling.
    10-Jul-1991 JohnRo
        RapExamineDescriptor() has yet another parameter.
    20-Sep-1991 JohnRo
        Downlevel NetService APIs.  (Handle REM_DATA_BLOCK correctly.)

--*/


// These must be included first:

#include <windef.h>             // IN, LPDWORD, NULL, OPTIONAL, DWORD, etc.
#include <lmcons.h>             // NET_API_STATUS

// These may be included in any order:

#include <align.h>              // ALIGN_WORD, etc.
#include <netdebug.h>           // NetpAssert().
#include <rap.h>                // My prototypes, LPDESC, NO_AUX_DATA, etc.
#include <remtypes.h>           // REM_WORD, etc.
#include <smbgtpt.h>            // SmbPutUshort(), etc.
#include <string.h>             // strchr().


DWORD
RapAuxDataCountOffset (
    IN LPDESC Descriptor,
    IN RAP_TRANSMISSION_MODE TransmissionMode,
    IN BOOL Native
    )

/*++

Routine Description:

    This routine determines the offset from the start of the structure of
    the auxiliary data count ( described by REM_AUX_NUM or REM_AUX_NUM_DWORD
    descriptor characters ).

Arguments:

    Descriptor - the format of the structure.

    Transmission Mode - Indicates whether this array is part of a response,
        a request, or both.

    Native - TRUE iff the descriptor defines a native structure.  (This flag is
        used to decide whether or not to align fields.)

Return Value:

    DWORD - The offset, in bytes, from the start of the structure to the
        count data, or the value NO_AUX_DATA.

--*/

{
    DWORD auxDataCountOffset;

    NetpAssert(Descriptor != NULL);
    NetpAssert(*Descriptor != '\0');

    if (Descriptor[0] != REM_DATA_BLOCK) {

        //
        // Regular structure/whatever.
        //
        RapExamineDescriptor(
                Descriptor,
                NULL,
                NULL,
                NULL,
                &auxDataCountOffset,
                NULL,
                NULL,  // don't need to know structure alignment
                TransmissionMode,
                Native
                );

    } else {

        //
        // REM_DATA_BLOCK: Unstructured data.
        //
        NetpAssert( Descriptor[1] == '\0' );
        auxDataCountOffset = NO_AUX_DATA;

    }

    return auxDataCountOffset;

} // RapAuxDataCountOffset

DWORD
RapAuxDataCount (
    IN LPBYTE Buffer,
    IN LPDESC Descriptor,
    IN RAP_TRANSMISSION_MODE TransmissionMode,
    IN BOOL Native
    )

/*++

Routine Description:

    This routine determines the actual count of the number of auxiliary
    structures, taking into consideration whether the count is a 16-bit
    or a 32-bit quantity.

Arguments:

    Buffer - a pointer to the start of the data buffer.

    Descriptor - the format of the structure.

    Transmission Mode - Indicates whether this array is part of a response,
        a request, or both.

    Native - TRUE iff the descriptor defines a native structure.  (This flag is
        used to decide whether or not to align fields.)

Return Value:

    DWORD - The number of auxiliary data structures, or the value NO_AUX_DATA.

--*/

{
    DWORD auxDataCountOffset;

    NetpAssert(Descriptor != NULL);
    NetpAssert(*Descriptor != '\0');

    auxDataCountOffset = RapAuxDataCountOffset(
                             Descriptor,
                             TransmissionMode,
                             Native
                             );

    //
    // No auxiliary data count offset found. There isn't any auxiliary data.
    //

    if ( auxDataCountOffset == NO_AUX_DATA) {

        return NO_AUX_DATA;
    }

    //
    // Check if the descriptor character was a word or dword count type.
    // Get appropriate value, and return it as a dword.
    //

    NetpAssert(sizeof(DESC_CHAR) == sizeof(char));
    NetpAssert(RapPossiblyAlignCount( 
            auxDataCountOffset, ALIGN_WORD, Native) == auxDataCountOffset );
    if ( strchr( Descriptor, REM_AUX_NUM_DWORD ) != NULL ) {

        return SmbGetUlong( (LPDWORD)( Buffer + auxDataCountOffset ));

    } else {

        return (DWORD)SmbGetUshort( (LPWORD)( Buffer + auxDataCountOffset ));

    }

} // RapAuxDataCount
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\rap\data.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    Data.c

Abstract:

    Global data for Rap routines.  (Debug only, so no security problems.)

Author:

    John Rogers (JohnRo) 29-Apr-1991

Environment:

    Portable to any flat, 32-bit environment.  (Uses Win32 typedefs.)
    Requires ANSI C extensions: slash-slash comments, long external names.

Revision History:

    29-Apr-1991 JohnRo
        Created.
--*/


// These must be included first:
#include <windef.h>             // DWORD, etc.

// These may be included in any order:
#include <rapdebug.h>           // extern for RappTrace.

#if DBG
DWORD RappTrace = 0;
#endif // DBG

// That's all, folks!
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\rap\parmnum.c ===
/*++

Copyright (c) 1991 Microsoft Corporation

Module Name:

    ParmNum.c

Abstract:

    This module contains Remote Admin Protocol (RAP) routines.  These routines
    are shared between XactSrv and RpcXlate.

Author:

    Shanku Niyogi (W-Shanku)    14-Apr-1991

Environment:

    Portable to any flat, 32-bit environment.  (Uses Win32 typedefs.)
    Requires ANSI C extensions: slash-slash comments, long external names.

Revision History:

    14-Apr-1991 W-Shanku
        Created.
    17-Apr-1991 JohnRo
        Reduce recompiles.
    06-May-1991 JohnRo
        Use REM_UNSUPPORTED_FIELD equate.
    15-May-1991 JohnRo
        Added native vs. RAP handling.
    04-Jun-1991 JohnRo
        Made changes suggested by PC-LINT.
    11-Jul-1991 JohnRo
        RapExamineDescriptor() has yet another parameter.
        Also added more debug code.
        Made minor changes allowing descriptors to be UNICODE someday.
    15-Aug-1991 JohnRo
        Reduce recompiles (use MEMCPY macro).
    21-Nov-1991 JohnRo
        Removed NT dependencies to reduce recompiles.

--*/


// These must be included first:

#include <windef.h>             // IN, DWORD, etc.
#include <lmcons.h>             // NET_API_STATUS.

// These may be included in any order:

#include <netlib.h>             // NetpMemoryAllocate().
#include <netdebug.h>           // NetpAssert(), NetpKdPrint(()), FORMAT equates.
#include <rap.h>                // LPDESC, my prototype.
#include <rapdebug.h>           // IF_DEBUG().
#include <remtypes.h>           // REM_UNSUPPORTED_FIELD.
#include <tstring.h>            // MEMCPY().


LPDESC
RapParmNumDescriptor(
    IN LPDESC Descriptor,
    IN DWORD ParmNum,
    IN RAP_TRANSMISSION_MODE TransmissionMode,
    IN BOOL Native
    )

/*++

Routine Description:

    This routine determines the substring for a given field number within
    a descriptor string, makes a null-terminated copy of it, and returns
    a pointer to this string.

Arguments:

    Descriptor - the format of the structure.

    ParmNum - the field number.

    Transmission Mode - Indicates whether this array is part of a response,
        a request, or both.

    Native - TRUE iff the descriptor defines a native structure.  (This flag is
        used to decide whether or not to align fields.)

Return Value:

    LPDESC - A pointer to a descriptor string for the field.  This string is
        dynamically allocated and must be freed with NetpMemoryFree.
        If the parmnum is invalid, a pointer to an unsupported field
        descriptor ( REM_UNSUPPORTED_FIELD ) is returned.  If the string
        cannot be allocated, a NULL pointer is returned.

--*/

{
    static DESC_CHAR descUnsupported[] = { REM_UNSUPPORTED_FIELD, '\0' };
    LPDESC descStart;
    LPDESC descEnd;
    LPDESC descCopy;
    DWORD length;

    //
    // I (JR) have a theory that this must only being used for data structures,
    // and never requests or responses.  So, let's do a quick check:
    //
    NetpAssert( TransmissionMode == Both );

    //
    // Scan the descriptor for the field indexed by ParmNum.  Set descStart
    // to point to that portion of the descriptor.
    //
    RapExamineDescriptor(
                Descriptor,
                &ParmNum,
                NULL,
                NULL,
                NULL,
                &descStart,
                NULL,  // don't need to know structure alignment
                TransmissionMode,
                Native
                );

    if ( descStart == NULL ) {

        IF_DEBUG(PARMNUM) {
            NetpKdPrint(( "RapParmNumDescriptor: examine says unsupported.\n" ));
        }

        descStart = descUnsupported;

    } else if (*descStart == REM_UNSUPPORTED_FIELD) {

        IF_DEBUG(PARMNUM) {
            NetpKdPrint(( "RapParmNumDescriptor: desc says unsupported.\n" ));
        }
    }

    //
    // See if descriptor character is followed by any numeric characters.
    // These are part of the descriptor.
    //

    descEnd = descStart + 1;

    (void) RapAsciiToDecimal( &descEnd );

    //
    // Find the length of the field descriptor, and allocate memory for it.
    //

    NetpAssert( descEnd > descStart );
    length = (DWORD) (descEnd - descStart);

    descCopy = NetpMemoryAllocate( (length + 1) * sizeof(DESC_CHAR) );
    if ( descCopy == NULL ) {

        return NULL;

    }

    //
    // Copy the string, and put a null terminator after it.
    //

    (void) MEMCPY( descCopy, descStart, length * sizeof(DESC_CHAR) );
    descCopy[length] = '\0';

    IF_DEBUG(PARMNUM) {
        NetpKdPrint(( "RapParmNumDescriptor: final desc for field "
                FORMAT_DWORD " is " FORMAT_LPDESC ".\n",
                ParmNum, descCopy ));
    }

    return descCopy;

} // RapParmNumDescriptor
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\rap\fieldsiz.c ===
/*++

Copyright (c) 1987-1992  Microsoft Corporation

Module Name:

    FieldSiz.c

Abstract:

    RAP (remote admin protocol) utility code.

Author:

    John Rogers (JohnRo) 05-Mar-1991

Environment:

    Portable to any flat, 32-bit environment.  (Uses Win32 typedefs.)
    Requires ANSI C extensions: slash-slash comments, long external names.

Revision History:

    (various NBU people)
        LanMan 2.x code
    05-Mar-1991 JohnRo
        Created portable version from LanMan 2.x sources.
    14-Apr-1991 JohnRo
        Reduce recompiles.  Got rid of tabs in source file, per NT standards.
    17-Apr-1991 JohnRo
        Added support for REM_IGNORE.
        Added debug msg when unexpected desc char found.
    07-Sep-1991 JohnRo
        Move toward possibility of descs being in UNICODE.
    21-Nov-1991 JohnRo
        Removed NT dependencies to reduce recompiles.
    16-Aug-1992 JohnRo
        RAID 2920: Support UTC timezone in net code.
        Use PREFIX_ equates.

--*/


// These must be included first:

#include <windef.h>             // IN, LPDWORD, NULL, OPTIONAL, DWORD, etc.
#include <lmcons.h>             // NET_API_STATUS

// These may be included in any order:

#include <netdebug.h>           // NetpBreakPoint().
#include <prefix.h>     // PREFIX_ equates.
#include <rap.h>                // My prototype, FORMAT_LPDESC_CHAR, LPDESC.
#include <remtypes.h>           // REM_WORD, etc.

DWORD
RapGetFieldSize(
    IN LPDESC TypePointer,
    IN OUT LPDESC * TypePointerAddress,
    IN RAP_TRANSMISSION_MODE TransmissionMode
    )

/*++

Routine Description:

    RapGetFieldSize gets the length of a field described by a type descriptor
    element.  It calculates the length of an field described by an element of
    a descriptor string and updates the descriptor string pointer to point
    to the last char in the element of the descriptor string.

Arguments:

    TypePointer - Points to first character in the descriptor element to be
        processed.

    TypePointerAddress - The address of the pointer passed as TypePointer.  On
        exit, *TypePointerAddress points to last character in descriptor
        element.

    Transmission Mode - Indicates whether this array is part of a response,
        a request, or both.

Return Value:

    Length in bytes of the field described by the descriptor string element.

--*/

{
    DESC_CHAR c;

    c = *TypePointer;                /* Get descriptor type char */

    if ( (RapIsPointer(c)) || (c == REM_NULL_PTR) ) { // All pointers same size.

        while ( ++TypePointer, DESC_CHAR_IS_DIGIT( *TypePointer ) ) {

            (*TypePointerAddress)++;        /* Move ptr to end of field size */

        }

        return (sizeof(LPVOID));
    }

    // Here if descriptor was not a pointer type so have to find the field
    // length specifically.

    switch ( c ) {
    case (REM_WORD):
    case (REM_BYTE):
    case (REM_DWORD):
    case (REM_SIGNED_DWORD):
        return (RapArrayLength(TypePointer,
                        TypePointerAddress,
                        TransmissionMode));
    case (REM_AUX_NUM):
    case (REM_PARMNUM):
    case (REM_RCV_BUF_LEN):
    case (REM_SEND_BUF_LEN):
        return (sizeof(unsigned short));
    case (REM_DATA_BLOCK):
        return (0);                        /* No structure for this */
    case (REM_DATE_TIME):
    case (REM_AUX_NUM_DWORD):
        return (sizeof(unsigned long));
    case (REM_IGNORE):
        return (0);
    case REM_EPOCH_TIME_GMT:  /*FALLTHROUGH*/
    case REM_EPOCH_TIME_LOCAL:
	return (sizeof(DWORD));
    default:
        NetpKdPrint(( PREFIX_NETRAP
                "RapGetFieldSize: unexpected desc '" FORMAT_LPDESC_CHAR
                "'.\n", c));
        NetpBreakPoint();
        return (0);
    }

    /*NOTREACHED*/

} // RapGetFieldSize
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\rap\examine.c ===
/*++

Copyright (c) 1991-1992 Microsoft Corporation

Module Name:

    Examine.c

Abstract:

    This module contains Remote Admin Protocol (RAP) routines.  These routines
    are shared between XactSrv and RpcXlate.

Author:

    David Treadwell (davidtr)    07-Jan-1991

Environment:

    Portable to any flat, 32-bit environment.  (Uses Win32 typedefs.)
    Requires ANSI C extensions: slash-slash comments, long external names.

Revision History:

    05-Mar-1991 JohnRo
        Converted from Xs (XactSrv) to Rap (Remote Admin Protocol) names.
    15-Mar-1991 W-Shanku
        Additional character support; changes to make code neater.
    14-Apr-1991 JohnRo
        Reduce recompiles.
    15-May-1991 JohnRo
        Added first cut at native vs. RAP handling.
        Added support for REM_SEND_LENBUF for print APIs.
    04-Jun-1991 JohnRo
        Made changes suggested by PC-LINT.
    11-Jul-1991 JohnRo
        Support StructureAlignment parameter.
    07-Oct-1991 JohnRo
        Made changes suggested by PC-LINT.
    16-Aug-1992 JohnRo
        RAID 2920: Support UTC timezone in net code.
        Use PREFIX_ equates.

--*/


// These must be included first:

#include <windef.h>             // IN, LPDWORD, NULL, OPTIONAL, DWORD, etc.
#include <lmcons.h>             // NET_API_STATUS

// These may be included in any order:

#include <align.h>              // ALIGN_WORD, etc.
#include <netdebug.h>           // NetpAssert().
#include <prefix.h>     // PREFIX_ equates.
#include <rap.h>                // My prototype, LPDESC.
#include <remtypes.h>           // REM_WORD, etc.

VOID
RapExamineDescriptor (
    IN LPDESC DescriptorString,
    IN LPDWORD ParmNum OPTIONAL,
    OUT LPDWORD StructureSize OPTIONAL,
    OUT LPDWORD LastPointerOffset OPTIONAL,
    OUT LPDWORD AuxDataCountOffset OPTIONAL,
    OUT LPDESC * ParmNumDescriptor OPTIONAL,
    OUT LPDWORD StructureAlignment OPTIONAL,
    IN RAP_TRANSMISSION_MODE TransmissionMode,
    IN BOOL Native
    )

/*++

Routine Description:

    Performs various examination functions on a descriptor string, including

        - finding the size of the fixed structure.
        - finding the last pointer to variable-length data in the structure.
        - finding the auxiliary descriptor character in the string.
        - finding the type of a given field in the descriptor.

    These functions traverse the descriptor string in a similar manner, and
    are thus grouped together, with wrappers for individual functions
    elsewhere.

Arguments:

    DescriptorString - a string that describes a fixed-length structure.

    ParmNum - an optional pointer to a DWORD indicating the field within
        the descriptor to find.

    StructureSize - a pointer to a DWORD to receive the size, in bytes,
        of the structure.

    LastPointerOffset - a pointer to a DWORD to receive the last pointer
        to variable-length data in the structure. If there is no pointer
        in the structure, the DWORD receives the constant value
        NO_POINTER_IN_STRUCTURE.

    AuxDataCountOffset - an optional pointer to a DWORD to receive the offset
        of the auxiliary data structure count.  This is set to
        NO_AUX_DATA if none is found.

    ParmNumDescriptor - an optional pointer to a LPDESC to receive a
        pointer to a specific field within the descriptor.

    StructureAlignment - an optional pointer to a DWORD to receive the
        alignment of this structure if it must be aligned and padded to appear
        in an array.  (This will be set to 1 if no alignment is necessary.)

    Transmission Mode - Indicates whether this array is part of a response,
        a request, or both.

    Native - TRUE iff the descriptor defines a native structure.  (This flag is
        used to decide whether or not to align fields.)

Return Value:

    None.

--*/

{
    LPDESC s;
    DWORD field;
    DWORD size = 0;
    DWORD auxDataCountOffset = NO_AUX_DATA;
    DWORD lastPointerOffset = NO_POINTER_IN_STRUCTURE;
    LPDESC parmNumDescriptor = NULL;
    DWORD worstAlignmentSoFar = ALIGN_BYTE;

#define UPDATE_WORST_ALIGNMENT(value)      \
    if ( (value) > worstAlignmentSoFar) {  \
       worstAlignmentSoFar = value;        \
    }

#define POINTER_SIZE (Native ? sizeof(PVOID) : sizeof(DWORD))

    //
    // Check for wierdness that could break null pointer handling.
    //

    NetpAssert(sizeof(LPSTR) == sizeof(LPVOID));

    //
    // Walk through the descriptor string, updating the length count
    // for each field described.
    //

    field = 1;

    for ( s = DescriptorString; *s != '\0'; field++ ) {

        if (( ParmNum != NULL ) && ( *ParmNum == field )) {

            parmNumDescriptor = s;
        }

        switch ( *(s++) ) {

        case REM_RCV_BYTE_PTR:

            if (TransmissionMode == Request) {

                //
                // These aren't sent as part of request. Just skip past any
                // array size numeric characters in descriptor.
                //

                (void) RapAsciiToDecimal( &s );

                break;
            }

            /* FALLTHROUGH */

        case REM_BYTE:

            //
            // A byte or array of bytes.
            //

            size += sizeof(CHAR) * RapDescArrayLength( s );
            UPDATE_WORST_ALIGNMENT( ALIGN_BYTE );

            break;

        case REM_BYTE_PTR:
        case REM_FILL_BYTES:

            //
            // A pointer to a byte or array of bytes.
            //

            if (TransmissionMode == Response ) {

                //
                // In a response (Xactsrv-style) context, this type
                // is allocated enough room for the pointer. Also skip
                // over any array size numeric characters.
                //

                size = RapPossiblyAlignCount(size, ALIGN_LPBYTE, Native);
                UPDATE_WORST_ALIGNMENT( ALIGN_LPBYTE );
                lastPointerOffset = size;

                size += POINTER_SIZE;

            } else {

                size += POINTER_SIZE;
                UPDATE_WORST_ALIGNMENT( ALIGN_BYTE );

            }

            //
            // must move the descriptor past any arraylength info
            //

            (void) RapAsciiToDecimal( &s );
            break;

        case REM_RCV_WORD_PTR :
        case REM_SEND_BUF_LEN :

            if (TransmissionMode == Request) {

                //
                // These aren't sent as part of request. Just skip past any
                // array size numeric characters in descriptor.
                //

                (void) RapAsciiToDecimal( &s );

                break;
            }

            /* FALLTHROUGH */

        case REM_WORD:
        case REM_PARMNUM:
        case REM_RCV_BUF_LEN:
        case REM_ENTRIES_READ:

            //
            // A word or array of words.
            //

            size = RapPossiblyAlignCount(size, ALIGN_WORD, Native);
            size += sizeof(WORD) * RapDescArrayLength( s );
            UPDATE_WORST_ALIGNMENT( ALIGN_WORD );

            break;

        case REM_RCV_DWORD_PTR :

            if (TransmissionMode == Request) {

                //
                // These aren't sent as part of request. Just skip past any
                // array size numeric characters in descriptor.
                //

                (void) RapAsciiToDecimal( &s );

                break;
            }

            /* FALLTHROUGH */

        case REM_DWORD:
        case REM_SIGNED_DWORD:

            //
            // A doubleword or array of doublewords.
            //

            size = RapPossiblyAlignCount(size, ALIGN_DWORD, Native);
            size += sizeof(DWORD) * RapDescArrayLength( s );
            UPDATE_WORST_ALIGNMENT( ALIGN_DWORD );

            break;

        case REM_ASCIZ:                 // ptr to ASCIIZ string
        case REM_ASCIZ_TRUNCATABLE:     // ptr to truncatable ASCIZ string

            size = RapPossiblyAlignCount(size, ALIGN_LPSTR, Native);
            lastPointerOffset = size;
            size += POINTER_SIZE;
            UPDATE_WORST_ALIGNMENT( ALIGN_LPBYTE );
            (void) RapDescStringLength( s );

            break;

        case REM_SEND_BUF_PTR:          // ptr to send buffer
        case REM_SEND_LENBUF:           // FAR ptr to send buffer w/ len.

            if (TransmissionMode == Request) {

                //
                // These aren't sent as part of request.
                //

                break;
            }

            /* FALLTHROUGH */

        case REM_RCV_BUF_PTR:           // ptr to receive buffer

            size = RapPossiblyAlignCount(size, ALIGN_LPBYTE, Native);
            lastPointerOffset = size;
            /* FALLTHROUGH */

        case REM_NULL_PTR:              // null ptr

            size = RapPossiblyAlignCount(size, ALIGN_LPSTR, Native);
            size += POINTER_SIZE;
            UPDATE_WORST_ALIGNMENT( ALIGN_LPBYTE );

            break;

        case REM_AUX_NUM:               // 16-bit aux. data count

            size = RapPossiblyAlignCount(size, ALIGN_WORD, Native);
            auxDataCountOffset = size;

            size += sizeof(WORD);
            UPDATE_WORST_ALIGNMENT( ALIGN_WORD );

            break;

        case REM_AUX_NUM_DWORD:         // 32-bit aux. data count

            size = RapPossiblyAlignCount(size, ALIGN_DWORD, Native);
            auxDataCountOffset = size;

            size += sizeof(DWORD);
            UPDATE_WORST_ALIGNMENT( ALIGN_DWORD );

            break;

        case REM_IGNORE :
        case REM_UNSUPPORTED_FIELD :

            //
            // A placeholder for pad bytes.  It represents no space in the
            // structure.
            //

            break;

        case REM_EPOCH_TIME_GMT:   /*FALLTHROUGH*/
        case REM_EPOCH_TIME_LOCAL:

            //
            // A time in seconds since 1970.  32-bits, unsigned.
            //

            size = RapPossiblyAlignCount(size, ALIGN_DWORD, Native);
            size += sizeof(DWORD);
            UPDATE_WORST_ALIGNMENT( ALIGN_DWORD );

            break;

        default:

            // !!!!
            NetpKdPrint(( PREFIX_NETRAP
                        "RapExamineDescriptor: unsupported character: "
                        FORMAT_DESC_CHAR " at " FORMAT_LPVOID ".\n",
                        *(s - 1), s - 1 ));
            NetpAssert(FALSE);
        }
    }

    //
    // Set up return information as appropriate.
    //

    if ( StructureSize != NULL ) {
        *StructureSize = size;
    }

    if ( LastPointerOffset != NULL ) {
        *LastPointerOffset = lastPointerOffset;
    }

    if ( AuxDataCountOffset != NULL ) {
        *AuxDataCountOffset = auxDataCountOffset;
    }

    if ( ParmNumDescriptor != NULL ) {
        *ParmNumDescriptor = parmNumDescriptor;
    }

    if ( StructureAlignment != NULL ) {
        *StructureAlignment = worstAlignmentSoFar;
    }

    return;

} // RapExamineDescriptor
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\rap\pointer.c ===
/*++

Copyright (c) 1991 Microsoft Corporation

Module Name:

    Pointer.c

Abstract:

    This module contains Remote Admin Protocol (RAP) routines.  These routines
    are shared between XactSrv and RpcXlate.

Author:

    Shanku Niyogi (w-shanku)    15-Feb-1991

Environment:

    Portable to any flat, 32-bit environment.  (Uses Win32 typedefs.)
    Requires ANSI C extensions: slash-slash comments, long external names.

Revision History:

    14-Apr-1991 JohnRo
        Reduce recompiles.
    15-May-1991 JohnRo
        Added native vs. RAP handling.
    10-Jul-1991 JohnRo
        RapExamineDescriptor() has yet another parameter.
--*/


// These must be included first:
#include <windef.h>             // IN, LPDWORD, NULL, OPTIONAL, DWORD, etc.
#include <lmcons.h>             // NET_API_STATUS

// These may be included in any order:
#include <rap.h>                // My prototype, LPDESC.


DWORD
RapLastPointerOffset (
    IN LPDESC Descriptor,
    IN RAP_TRANSMISSION_MODE TransmissionMode,
    IN BOOL Native
    )

/*++

Routine Description:

    This routine determines the offset from the start of the structure to
    the last pointer in the structure.

Arguments:

    Descriptor - the format of the structure.

    Transmission Mode - Indicates whether this array is part of a response,
        a request, or both.

    Native - TRUE iff the descriptor defines a native structure.  (This flag is
        used to decide whether or not to align fields.)

Return Value:

    DWORD - The offset from the start of the structure to the last pointer
        in the structure, or the value NO_POINTER_IN_STRUCTURE if there are
        no pointers in the structure.

--*/

{
    DWORD lastPointerOffset;

    RapExamineDescriptor(
                Descriptor,
                NULL,
                NULL,
                &lastPointerOffset,
                NULL,
                NULL,
                NULL,  // don't need to know structure alignment
                TransmissionMode,
                Native
                );

    return lastPointerOffset;

} // RapLastPointerOffset
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\rap\strucsiz.c ===
/*++

Copyright (c) 1991 Microsoft Corporation

Module Name:

    StrucSiz.c

Abstract:

    This module contains Remote Admin Protocol (RAP) routines.  These routines
    are shared between XactSrv and RpcXlate.

Author:

    David Treadwell (davidtr)    07-Jan-1991

Environment:

    Portable to any flat, 32-bit environment.  (Uses Win32 typedefs.)
    Requires ANSI C extensions: slash-slash comments, long external names.

Revision History:

    04-Mar-1991 JohnRo
        Converted from Xs (XactSrv) to Rap (Remote Admin Protocol) names.
    15-Mar-1991 W-Shanku
        Moved auxiliary data count support elsewhere.
    14-Apr-1991 JohnRo
        Reduce recompiles.
    15-May-1991 JohnRo
        Added native vs. RAP handling.
    10-Jul-1991 JohnRo
        RapExamineDescriptor() has yet another parameter.

--*/


// These must be included first:
#include <windef.h>             // IN, LPDWORD, NULL, OPTIONAL, DWORD, etc.
#include <lmcons.h>             // NET_API_STATUS

// These may be included in any order:
#include <rap.h>                // My prototype, LPDESC.


DWORD
RapStructureSize (
    IN LPDESC Descriptor,
    IN RAP_TRANSMISSION_MODE TransmissionMode,
    IN BOOL Native
    )

/*++

Routine Description:

    This routine determines size of the fixed structure described by the
    descriptor string.

Arguments:

    Descriptor - the format of the structure.

    Transmission Mode - Indicates whether this array is part of a response,
        a request, or both.

    Native - TRUE iff the descriptor defines a native structure.  (This flag is
        used to decide whether or not to align fields.)

Return Value:

    DWORD - The number of bytes in the fixed part of the structure.

--*/

{
    DWORD structureSize;

    RapExamineDescriptor(
                Descriptor,
                NULL,
                &structureSize,
                NULL,
                NULL,
                NULL,
                NULL,  // don't need to know structure alignment
                TransmissionMode,
                Native
                );

    return structureSize;

} // RapStructureSize
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\rap\convert.c ===
/*++

Copyright (c) 1991-1992 Microsoft Corporation

Module Name:

    Convert.c

Abstract:

    This module contains RapConvertSingleEntry and RapConvertSingleEntryEx,
    routines used by XactSrv and RpcXlate.

Author:

    David Treadwell (davidtr)    07-Jan-1991

Environment:

    Portable to any flat, 32-bit environment.  (Uses Win32 typedefs.)
    Requires ANSI C extensions: slash-slash comments, long external names.

Revision History:

    12-Mar-1991 JohnRo
        Converted from Xs routines to Rap routines.
        Added TransmissionMode handling.
        Changed to use <remtypes.h> REM_ equates for descriptor chars.

    18-Mar-1991 W-Shanku
        Added new conversion pairs.
        Changes to make code neater.
        Use SmbGet/Put for all structure data greater than one byte.

    14-Apr-1991 JohnRo
        Reduce recompiles.

    16-Apr-1991 JohnRo
        Include <lmcons.h> for <netlib.h>.

    21-Apr-1991 JohnRo
        Clarify that OutStructure is OUT, not IN.

    29-Apr-1991 JohnRo
        Quiet debug output by default.

    15-May-1991 JohnRo
        Added conversion mode handling.

    20-May-1991 JohnRo
        Stub out REM_SEND_LENBUF for print APIs.  Use FORMAT_LPVOID.

    05-Jun-1991 JohnRo
        Added support for RapTotalSize().

    19-Jun-1991 JohnRo
        Do more alignment handling, to fix print job get info (level 1) bug.

    01-Jul-1991 JohnRo
        Use Rap Get/Put macros.

    19-Aug-1991 JohnRo
        Reduce recompiles (use MEMCPY macro).  Use DESCLEN macro.
        Use DESC_CHAR_IS_DIGIT() macro too.

    07-Sep-1991 JohnRo
        PC-LINT says we don't need <lmcons.h> here.

    19-Sep-1991 T-JamesW
        Added support for string maximum length counts.
        Added support for REM_ASCIZ_TRUNCATABLE.
        Removed DESCLEN calls in which string is not a descriptor.

    07-Oct-1991 JohnRo
        Support implicit conversion between UNICODE and code page.
        Changed last debug print formats to use equates.  (This will help if
        we change the descriptor strings to be UNICODE.)
        Use DESC_CHAR in T-JamesW's code.

    26-Oct-1991 W-ShankN
        Fixed z->B conversion to support a NULL source string.

    13-Nov-1991 W-ShankN
        Fixed up bugs in some of newer code.

    22-Nov-1991 JohnRo
        Added debug print if we aren't even writing fixed portion.
        Get rid of a few unused local variables.

    24-Nov-1991 W-ShankN
        Added Unicode support for several cases.

    05-Dec-1991 W-ShankN
        Added REM_BYTE_PTR, REM_SEND_LENBUF.

    15-Jun-1992 JohnRo
        RAID 10324: net print vs. UNICODE (added REM_BYTE to REM_WORD convert).
    17-Aug-1992 JohnRo
        RAID 2920: Support UTC timezone in net code.
        Use PREFIX_ equates.
    01-Oct-1992 JohnRo
        RAID 3556: Added NetpSystemTimeToGmtTime() for DosPrint APIs.

--*/


#define UNSUPPORTED_COMBINATION(One, TheOther) \
    { \
        NetpKdPrint(( PREFIX_NETRAP \
                  "RapConvertSingleEntry: Unsupported combination: " \
                  "'" FORMAT_DESC_CHAR "' and '" FORMAT_DESC_CHAR "'\n", \
                  (One), (TheOther) )); \
        NetpAssert(FALSE); \
    }

// These must be included first:
#include <windows.h>    // IN, LPTSTR, etc.
#include <lmcons.h>             // NET_API_STATUS.

// These may be included in any order:
#include <lmerr.h>              // NERR_Success, etc.
#include <align.h>              // ROUND_UP_POINTER(), ALIGN_DWORD, etc.
#include <netdebug.h>           // FORMAT_ equates, NetpAssert(), etc.
#include <rap.h>                // My prototype, LPDESC, DESCLEN(), etc.
#include <rapdebug.h>           // IF_DEBUG().
#include <rapgtpt.h>            // RapGetDword(), etc.
#include <remtypes.h>           // REM_WORD, etc.
#include <string.h>             // strlen().
#include <tstring.h>            // MEMCPY(), STRLEN().
#include <netlib.h>             // NetpMemoryAllocate
#include <prefix.h>     // PREFIX_ equates.
#include <timelib.h>    // NetpGmtTimeToLocalTime(), etc.

#define RAP_POINTER_SIZE( _isNative, _SetOffsets )  (_isNative ? sizeof(LPVOID) : sizeof(DWORD) )
#define RAP_PUT_POINTER( _SetOffsets, Ptr, Value, Native ) if (Native) {RapPutDword_Ptr( Ptr, Value, Native ); } else { RapPutDword( Ptr, Value, Native );}

PVOID
RapGetPointer(
    IN PVOID InStructure,
    IN BOOL InNative,
    IN UINT_PTR Bias
    )
{
    UINT_PTR Value;

    if ( InNative ) {
        // remark: used to call RapGetDword but that truncated
        // 64 bit pointers. See bug 104264 for more.
        Value = * (UINT_PTR*) (InStructure);
    }
    else {
        Value = SmbGetUlong( (LPDWORD) (InStructure) );
    }

#if defined(_WIN64)

    //
    // For 64-bit, RapSetPointer() stores only the buffer offset.  This,
    // together with the original address of the buffer (Bias) yields the
    // pointer value.
    //

    if( Value != 0 ) {
        Value += Bias;
    }

#endif

    return (PVOID)Value;
}

NET_API_STATUS
RapConvertSingleEntryEx (
    IN LPBYTE InStructure,
    IN LPDESC InStructureDesc,
    IN BOOL MeaninglessInputPointers,
    IN LPBYTE OutBufferStart OPTIONAL,
    OUT LPBYTE OutStructure OPTIONAL,
    IN LPDESC OutStructureDesc,
    IN BOOL SetOffsets,
    IN OUT LPBYTE *StringLocation OPTIONAL,
    IN OUT LPDWORD BytesRequired,
    IN RAP_TRANSMISSION_MODE TransmissionMode,
    IN RAP_CONVERSION_MODE ConversionMode,
    IN UINT_PTR Bias
    )

/*++

Routine Description:

    This routine converts a single structure from one representation to
    another.  The representations are described by the descriptor strings
    (see the "OS/2 Lanman Remote Admin Protocol" spec).

    If there isn't enough space in the buffer for the entire structure,
    this routine simply updates the BytesRequired parameter.  Therefore,
    callers have a convenient mechanism for determining the total buffer
    size required to get all the information without special-casing for
    buffer overflow.

Arguments:

    InStructure - a pointer to the input structure.

    InStructureDesc - the descriptor string for the input string.

    MeaninglessInputPointers - if TRUE, then all pointers in the input
        structure are meaningless.  This routine should assume that
        the first variable data immediately follows the input structure,
        and the rest of the variable data follows in order.

    OutBufferStart - the first byte in the output buffer.  For Enum APIs,
        this is used to calculate offsets from the start of the buffer
        for string pointers.  (This pointer may be null, to allow length
        computations only.)

    OutStructure - a pointer to where to put the actual output structure.
        (This pointer may be null, to allow length computations only.)

    OutStructureDesc - the descriptor string for the output structure.

    SetOffsets - TRUE if pointer values in the output structure should
        actually be set to the offset from the beginning of the structure.
        FALSE if the actual addresses should be used.

    StringLocation - the *last* location for variable-length data.  The
        data will be placed before this location and the pointer will
        be updated to reflect the data added.

    BytesRequired - the total number of bytes that would be required to
        store the complete output structure.  This allows the calling
        routine to track the total required for all information without
        worrying about buffer overflow.

    Transmission Mode - Indicates whether this array is part of a response,
        a request, or both.

    Conversion Mode - Indicates whether this is a RAP-to-native, native-to-RAP,
        or native-to-native conversion.

    Bias - Indicates the bias that must be applied to embedded pointers
        before dereferencing them.

Return Value:

    None.

--*/

{
    BOOL inNative, outNative;
    BOOL inUNICODE, outUNICODE;
    DWORD outStructureSize;
    LPBYTE nextStructureLocation;
    BOOL fixedWrite;
    BOOL outputBufferSupplied;
    LPBYTE variableInputData;
    DESC_CHAR currentInStructureDesc;

    NetpAssert( sizeof(CHAR) == sizeof(BYTE) );
    
    switch (ConversionMode) {
    case NativeToNative : inNative=TRUE ; outNative=TRUE ; break;
    case NativeToRap    : inNative=TRUE ; outNative=FALSE; break;
    case RapToNative    : inNative=FALSE; outNative=TRUE ; break;
    case RapToRap       : inNative=FALSE; outNative=FALSE; break;
    default :
        NetpKdPrint(( PREFIX_NETRAP
                "RapConvertSingleEntry: invalid conversion mode!\n"));
        NetpAssert(FALSE);
        return ERROR_INVALID_PARAMETER;
    }

    //
    // Make sure there's actually some data to convert
    //

    if ( *InStructureDesc != '\0' && InStructure == NULL )
    {
        return ERROR_INVALID_PARAMETER;
    }

    // Policy: native format implies TCHARs, RAP format imples default codepage.
    inUNICODE = inNative;
    outUNICODE = outNative;

    if (OutStructure != NULL) {
        NetpAssert(OutBufferStart != NULL);
        NetpAssert(StringLocation != NULL);
        outputBufferSupplied = TRUE;
    } else {
        NetpAssert(OutBufferStart == NULL);
        outputBufferSupplied = FALSE;
    }

    //
    // If the input doesn't have good pointers, the variable data is
    // stored after the fixed structure.  Set up to handle this.
    //

    if ( MeaninglessInputPointers ) {
        variableInputData = InStructure
                        + RapStructureSize(
                            InStructureDesc, TransmissionMode, inNative );
    }

    //
    // Find the size of the output structure and update variables with it.
    //

    outStructureSize =
            RapStructureSize( OutStructureDesc, TransmissionMode, outNative );

    *BytesRequired += outStructureSize;
    if (OutStructure != NULL) {
        nextStructureLocation = OutStructure + outStructureSize;
    } else {
        nextStructureLocation = NULL;
    }

    IF_DEBUG(CONVERT) {
        NetpKdPrint(( PREFIX_NETRAP
                "RapConvertSingleEntry: bytes required starts at "
                FORMAT_DWORD "\n", *BytesRequired ));
    }

    //
    // Determine whether the fixed structure will fit.  If it won't, we'll
    // still loop through the descriptor strings in order to determine
    // how much space the converted structure will take (to fill in the
    // proper value in BytesRequired).
    //

    if ( OutStructure != NULL) {
        if ( OutStructure + outStructureSize > *StringLocation ) {
            fixedWrite = FALSE;
            IF_DEBUG(CONVERT) {
                NetpKdPrint(( PREFIX_NETRAP
                        "RapConvertSingleEntry: NOT WRITING FIXED AREA.\n" ));
            }
        } else {
            fixedWrite = TRUE;
        }
    } else {
        fixedWrite = FALSE;
    }

    //
    // Loop through the input descriptor string, converting entries as
    // we go.
    //

    while ( *InStructureDesc != '\0' ) {

        IF_DEBUG(CONVERT) {
            NetpKdPrint(( PREFIX_NETRAP "InStruct at " FORMAT_LPVOID
                        ", desc at " FORMAT_LPVOID " (" FORMAT_DESC_CHAR ")"
                        ", outStruct at " FORMAT_LPVOID ", "
                        "desc at " FORMAT_LPVOID " (" FORMAT_DESC_CHAR ")\n",
                        (LPVOID) InStructure, (LPVOID) InStructureDesc,
                        *InStructureDesc,
                        (LPVOID) OutStructure, (LPVOID) OutStructureDesc,
                        *OutStructureDesc ));
        }

        NetpAssert( *OutStructureDesc != '\0' );

        switch ( currentInStructureDesc = *InStructureDesc++ ) {

        case REM_BYTE:

            switch ( *OutStructureDesc++ ) {

            case REM_BYTE: {

                //
                // Convert a byte or bytes to bytes.
                //

                DWORD inLength, outLength;

                // Get lengths and update descriptor pointers.
                inLength = RapDescArrayLength( InStructureDesc );
                outLength = RapDescArrayLength( OutStructureDesc );

                //
                // Assumption - the array sizes should match.  If one length
                // is twice the other, do the appropriate Ansi/Unicode conversion.
                //

                NetpAssert( inLength > 0 );
                NetpAssert( outLength > 0 );
                if ( outLength == inLength ) {

                    for( ; inLength > 0; inLength-- ) {

                        if ( fixedWrite ) {
                            *OutStructure = *InStructure;
                            OutStructure++;
                        }

                        InStructure++;
                    }

                } else if (outLength == (DWORD) (2*inLength)) {
                    NetpAssert( sizeof(TCHAR) == (2*sizeof(CHAR)) );
                    if ( fixedWrite ) {
                        NetpCopyStrToWStr(
                                (LPWSTR) OutStructure,     // dest
                                (LPSTR) InStructure);      // src
                        OutStructure += outLength;
                    }
                    InStructure += inLength;

                } else if (inLength == (DWORD) (2*outLength)) {
                    NetpAssert( sizeof(TCHAR) == (2*sizeof(CHAR)) );
                    if ( fixedWrite ) {
                        NetpCopyWStrToStrDBCS(
                                (LPSTR) OutStructure,       // dest
                                (LPWSTR) InStructure);      // src
                        OutStructure += outLength;
                    }
                    InStructure += inLength;

                } else {
                    NetpAssert( FALSE );
                }

                break;

            }

            case REM_BYTE_PTR: {

                DWORD inLength, outLength;
                LPDWORD offset;
                LPBYTE bytePtr;

                //
                // Convert a fixed byte array to an indirect array of
                // bytes.
                //

                inLength = RapDescArrayLength( InStructureDesc );
                outLength = RapDescArrayLength( OutStructureDesc );

                //
                // Assumption - the array sizes should match.
                //

                NetpAssert( inLength == outLength );

                //
                // Update input pointer.
                //

                bytePtr = InStructure;
                InStructure += inLength;

                //
                // Align output pointer if necessary.
                //

                if ( fixedWrite ) {
                    OutStructure = RapPossiblyAlignPointer(
                            OutStructure, ALIGN_LPBYTE, outNative );
                }

                //
                // Update bytes required.
                //

                *BytesRequired += outLength;

                IF_DEBUG(CONVERT) {
                    NetpKdPrint(( PREFIX_NETRAP
                            "RapConvertSingleEntry: bytes required now "
                            FORMAT_DWORD "\n", *BytesRequired ));
                }

                //
                // Determine whether the data will fit in the available
                // buffer space.
                //

                if ( outputBufferSupplied ) {

                    offset = (LPDWORD) OutStructure;
                    if ( fixedWrite ) {
                        OutStructure += RAP_POINTER_SIZE( outNative, SetOffsets );
                    }
                    IF_DEBUG(CONVERT) {
                        NetpKdPrint(( PREFIX_NETRAP
                          "RapConvertSingleEntry: B->b, "
                          "offset after alignment is " FORMAT_LPVOID "\n",
                          (LPVOID) offset ));
                    }

                    if ( (ULONG_PTR)*StringLocation <
                             (ULONG_PTR)nextStructureLocation + outLength ) {

                        //
                        // There isn't enough space to hold the data--it
                        // would go into the last fixed structure.  Put a
                        // NULL in the offset and don't copy over the
                        // data.
                        //

                        if ( fixedWrite ) {
                            RAP_PUT_POINTER( SetOffsets, offset, 0, outNative );
                        }

                        break;
                    }

                    //
                    // Determine where the bytes will go.
                    //

                    IF_DEBUG(CONVERT) {
                        NetpKdPrint(( PREFIX_NETRAP
                                "RapConvertSingleEntry: B->b, "
                                "*StringLocation=" FORMAT_LPVOID "\n",
                                (LPVOID) *StringLocation ));
                    }
                    *StringLocation = *StringLocation - outLength;

                    //
                    // Set the offset value or the actual address in the
                    // fixed structure.  Update the fixed structure
                    // pointer.
                    //

                    if ( fixedWrite ) {
                        if ( SetOffsets ) {
                            IF_DEBUG(CONVERT) {
                                NetpKdPrint(( PREFIX_NETRAP
                                  "RapConvertSingleEntry: B->b, "
                                  "setting offset " FORMAT_HEX_DWORD "\n",
                                  (DWORD)( *StringLocation - OutBufferStart )));
                            }
                            RapPutDword( offset,
                                    (DWORD)( *StringLocation - OutBufferStart),
                                    outNative );
                        } else {
                            IF_DEBUG(CONVERT) {
                                NetpKdPrint(( PREFIX_NETRAP
                                        "RapConvertSingleEntry: B->b, "
                                        "setting pointer " FORMAT_POINTER
                                        "\n", (DWORD_PTR) (*StringLocation) ));
                            }
                            RapPutDword_Ptr( offset,
                                    (DWORD_PTR)( *StringLocation ),
                                    outNative);
                        }

                        //
                        // Copy over the bytes.
                        //

                        memcpy(
                            (LPBYTE)*StringLocation,
                            bytePtr,
                            inLength
                            );
                    }

                } // if ( outputBufferSupplied )

                break;
            }

            case REM_WORD : {

                //
                // Convert an unsigned byte to an 16-bit unsigned word.
                //
                NetpAssert( !DESC_CHAR_IS_DIGIT( *InStructureDesc ) );
                NetpAssert( !DESC_CHAR_IS_DIGIT( *OutStructureDesc ) );

                if ( fixedWrite ) {
                    LPWORD outData = RapPossiblyAlignPointer(
                            (LPWORD)(LPVOID)OutStructure,
                            ALIGN_WORD, outNative );

                    RapPutWord( outData, (WORD) *InStructure, outNative );
                    OutStructure = ((LPBYTE)outData) + sizeof(WORD);
                }

                InStructure++;
                break;
            }

            case REM_DWORD : {

                //
                // Convert a byte to a 32-bit unsigned value.
                //

                NetpAssert( !DESC_CHAR_IS_DIGIT( *InStructureDesc ));

                if ( fixedWrite ) {
                    LPDWORD outData = RapPossiblyAlignPointer(
                            (LPDWORD)(LPVOID)OutStructure,
                            ALIGN_DWORD, outNative );

                    RapPutDword( outData, (DWORD)*InStructure, outNative );
                    OutStructure = ((LPBYTE)outData) + sizeof(DWORD);
                }

                InStructure++;
                break;
            }

            case REM_SIGNED_DWORD :

                //
                // Convert a byte to a 32-bit sign extended value.
                //


                NetpAssert( !DESC_CHAR_IS_DIGIT( *InStructureDesc ));

                if ( fixedWrite ) {

                    LPDWORD outData = RapPossiblyAlignPointer(
                            (LPDWORD)OutStructure, ALIGN_DWORD, outNative );
                    DWORD data = (DWORD) *(LPDWORD)RapPossiblyAlignPointer(
                            (LPDWORD)InStructure, ALIGN_DWORD, inNative );
                                       
                    if ( data & 0x80 ) {

                        data |= 0xFFFFFF00;
                    }
                    RapPutDword( outData, data, outNative );
                    OutStructure = OutStructure + sizeof(DWORD);
                }

                InStructure++;
                break;

            case REM_IGNORE :

                //
                // The input is an ignored pad.  Just update pointers.
                //

                InStructure += RapDescArrayLength( InStructureDesc );

                break;

            case REM_ASCIZ:
            case REM_ASCIZ_TRUNCATABLE: {

                //
                // Convert a byte array to an ASCIIZ.
                //

                LPDWORD offset;
                DWORD inLength, outLength;
                DWORD stringSize;
                LPBYTE stringPtr = InStructure;

                //
                // Determine how long the string is and whether it will
                // fit in the available buffer space.  Note that the
                // stringLength variable includes the zero terminator.
                //

                // Get lengths and update descriptor pointers.
                inLength = RapDescArrayLength( InStructureDesc );
                outLength = RapDescStringLength( OutStructureDesc );

                //
                // Assumption - Byte arrays are never copied into strings
                //     which cannot hold them.
                //

                NetpAssert( outLength == 0
                            || inLength <= outLength );

                //
                // Update the in structure pointer to point after the
                // byte array.  Determine the true length of the string
                // and update the number of bytes required to reflect
                // the variable data necessary.
                //

                InStructure += inLength;
                if (inUNICODE)
                {
                    if( outUNICODE )
                    {
                        stringSize = STRLEN( (LPTSTR) stringPtr );
                    }
                    else
                    {
                        stringSize = NetpUnicodeToDBCSLen( (LPTSTR)stringPtr ) + 1;
                    }
                }
                else
                {
                    stringSize = strlen( (LPSTR) stringPtr ) + 1;
                }

                if (outUNICODE) {

                    stringSize = STRING_SPACE_REQD( stringSize );
                    if ( outputBufferSupplied && *StringLocation !=
                           ROUND_DOWN_POINTER( *StringLocation, ALIGN_TCHAR )) {

                        stringSize += sizeof(TCHAR);
                    }
                    if ( fixedWrite ) {
                        OutStructure = RapPossiblyAlignPointer(
                                OutStructure, ALIGN_LPTSTR, outNative );
                    }
                } else {
                    if ( fixedWrite ) {
                        OutStructure = RapPossiblyAlignPointer(
                                OutStructure, ALIGN_LPSTR, outNative );
                    }
                }
                *BytesRequired += stringSize;

                IF_DEBUG(CONVERT) {
                    NetpKdPrint(( PREFIX_NETRAP
                            "RapConvertSingleEntry: bytes required now "
                            FORMAT_DWORD "\n", *BytesRequired ));
                }

                if ( outputBufferSupplied ) {

                    //
                    // Set the location where a pointer to the output string
                    // will be placed and update the output structure pointer
                    // to point after the pointer to the string.
                    //

                    offset = (LPDWORD)OutStructure;
                    if ( fixedWrite ) {
                        OutStructure += RAP_POINTER_SIZE(outNative, SetOffsets);
                    }

                    if ( (ULONG_PTR)*StringLocation <
                             (ULONG_PTR)nextStructureLocation + stringSize ) {

                        //
                        // There isn't enough space to hold the string--it
                        // would go into the last fixed structure.  Put a
                        // NULL in the offset and don't copy over the
                        // string.
                        //

                        if ( fixedWrite ) {
                            RAP_PUT_POINTER( SetOffsets, offset, 0, outNative );
                        }

                        break;
                    }

                    //
                    // Determine where the string will go.
                    //

                    *StringLocation = *StringLocation - stringSize;

                    //
                    // Set the offset value or the actual address in the
                    // fixed structure.  Update the fixed structure
                    // pointer.
                    //

                    if ( fixedWrite ) {
                        if ( SetOffsets ) {
                            RapPutDword( offset,
                                (DWORD)( *StringLocation - OutBufferStart),
                                outNative );
                        } else {
                            RapPutDword_Ptr( offset, (DWORD_PTR)*StringLocation,
                                outNative );
                        }
                    }

                    //
                    // Copy over the string.
                    //

                    if ( inUNICODE && outUNICODE ) {

                        STRCPY( (LPTSTR)*StringLocation, (LPTSTR)stringPtr );

                    } else if ( inUNICODE ) {

                        NetpCopyWStrToStrDBCS( (LPSTR)*StringLocation,
                            (LPTSTR)stringPtr );

                    } else if ( outUNICODE ) {

                        NetpCopyStrToTStr( (LPTSTR)*StringLocation,
                            (LPSTR)stringPtr );

                    } else {

                        strcpy( (LPSTR)*StringLocation, (LPSTR)stringPtr );
                    }

                } // if ( outputBufferSupplied )

                break;
            }

            default:

                UNSUPPORTED_COMBINATION( REM_BYTE, *(OutStructureDesc-1) );
            }

            break;

        case REM_BYTE_PTR: {

            LPBYTE bytePtr;
            DWORD inLength;

            inLength = RapDescArrayLength( InStructureDesc );
            NetpAssert( inLength > 0 );

            InStructure = RapPossiblyAlignPointer(
                    InStructure, ALIGN_LPBYTE, inNative);

            //
            // Set up a pointer to the bytes.  If the pointer stored in
            // the input structure is bad, find out where the bytes are
            // really stored.
            //

            bytePtr = RapGetPointer( InStructure, inNative, Bias );

            if ( MeaninglessInputPointers && bytePtr != NULL ) {
                bytePtr = variableInputData;
                variableInputData += inLength;
            }

            IF_DEBUG(CONVERT) {
                NetpKdPrint(( PREFIX_NETRAP
                        "RapConvertSingleEntry: b->stuff, bytePtr="
                        FORMAT_LPVOID "\n", (LPVOID) bytePtr ));
            }

            //
            // Update the InStructure pointer.
            //

            InStructure += RAP_POINTER_SIZE( inNative, FALSE );
                        
            switch ( *OutStructureDesc++ ) {

            case REM_BYTE: {

                DWORD outLength;

                //
                // Convert a indirect array of bytes to a fixed byte
                // array.
                //

                outLength = RapDescArrayLength( OutStructureDesc );

                //
                // Assumption - the array sizes should match.
                //

                NetpAssert( inLength == outLength );

                //
                // Copy the buffer. If the source pointer is NULL, we can
                // just fill the output with zeroes.
                //

                if ( fixedWrite ) {

                    for ( ; outLength > 0; outLength-- ) {

                        *OutStructure++ = ( bytePtr ? *bytePtr++ : (BYTE)0 );
                    }
                }

                break;
            }

            case REM_BYTE_PTR: {

                //
                // The input has a pointer to a number of bytes, the output
                // is the same. Copy the bytes.
                //

                DWORD outLength;
                LPDWORD offset;

                outLength = RapDescArrayLength( OutStructureDesc );

                //
                // Assumption - the array sizes should match.
                //

                NetpAssert( inLength == outLength );

                //
                // Align output pointer if necessary.
                //

                if ( fixedWrite ) {
                    OutStructure = RapPossiblyAlignPointer(
                            OutStructure, ALIGN_LPBYTE, outNative );
                }

                //
                // If the byte pointer is NULL, just copy the NULL
                // pointer and update other pointers.
                //

                if ( bytePtr == NULL ) {

                    if ( fixedWrite ) {
                        RAP_PUT_POINTER(
                                    SetOffsets,
                                    (LPDWORD)OutStructure,
                                    0,
                                    outNative );
                        OutStructure += RAP_POINTER_SIZE( outNative, SetOffsets );                       
                    }

                    break;
                }

                //
                // Update bytes required.
                //

                *BytesRequired += outLength;

                IF_DEBUG(CONVERT) {
                    NetpKdPrint(( PREFIX_NETRAP
                            "RapConvertSingleEntry: bytes required now "
                            FORMAT_DWORD "\n", *BytesRequired ));
                }

                //
                // Determine whether the data will fit in the available
                // buffer space.
                //

                if ( outputBufferSupplied ) {

                    offset = (LPDWORD) OutStructure;
                    if ( fixedWrite ) {
                        OutStructure += RAP_POINTER_SIZE( outNative, SetOffsets );
                    }
                    IF_DEBUG(CONVERT) {
                        NetpKdPrint(( PREFIX_NETRAP
                          "RapConvertSingleEntry: b->b, "
                          "offset after alignment is " FORMAT_LPVOID "\n",
                          (LPVOID) offset ));
                    }

                    if ( (ULONG_PTR)*StringLocation <
                             (ULONG_PTR)nextStructureLocation + outLength ) {

                        //
                        // There isn't enough space to hold the data--it
                        // would go into the last fixed structure.  Put a
                        // NULL in the offset and don't copy over the
                        // data.
                        //

                        if ( fixedWrite ) {
                            RAP_PUT_POINTER( SetOffsets, offset, 0, outNative );
                        }

                        break;
                    }

                    //
                    // Determine where the bytes will go.
                    //

                    IF_DEBUG(CONVERT) {
                        NetpKdPrint(( PREFIX_NETRAP
                                "RapConvertSingleEntry: b->b, "
                                "*StringLocation=" FORMAT_LPVOID "\n",
                                (LPVOID) *StringLocation ));
                    }
                    *StringLocation = *StringLocation - outLength;

                    //
                    // Set the offset value or the actual address in the
                    // fixed structure.  Update the fixed structure
                    // pointer.
                    //

                    if ( fixedWrite ) {
                        if ( SetOffsets ) {
                            IF_DEBUG(CONVERT) {
                                NetpKdPrint(( PREFIX_NETRAP
                                  "RapConvertSingleEntry: b->b, "
                                  "setting offset " FORMAT_HEX_DWORD "\n",
                                  (DWORD)( *StringLocation - OutBufferStart )));
                            }
                            RapPutDword( offset,
                                    (DWORD)( *StringLocation - OutBufferStart),
                                    outNative );
                        } else {
                            IF_DEBUG(CONVERT) {
                                NetpKdPrint(( PREFIX_NETRAP
                                        "RapConvertSingleEntry: b->b, "
                                        "setting pointer " FORMAT_POINTER
                                        "\n", (DWORD_PTR) (*StringLocation) ));
                            }
                            RapPutDword_Ptr( offset,
                                    (DWORD_PTR)( *StringLocation ),
                                    outNative);
                        }

                        //
                        // Copy over the bytes.
                        //

                        memcpy(
                            (LPBYTE)*StringLocation,
                            bytePtr,
                            inLength
                            );
                    }

                } // if ( outputBufferSupplied )

                break;
            }

            case REM_IGNORE :

                //
                // The input is an ignored pad.
                //

                break;

            default:

                UNSUPPORTED_COMBINATION( REM_BYTE_PTR, *(OutStructureDesc-1) );
            }

            break;

        }

        case REM_ASCIZ:
        case REM_ASCIZ_TRUNCATABLE: {

            LPSTR stringPtr;

            InStructure = RapPossiblyAlignPointer(
                    InStructure, ALIGN_LPSTR, inNative);

            //
            // Set up a pointer to the string.  If the pointer stored in
            // the input structure is nonzero and we have meaningless input,
            // pointers, find out where the string is really stored.
            // Even if the input pointers are "meaningless" a value
            // of NULL is relevant.
            //

            stringPtr = RapGetPointer( InStructure, inNative, Bias );

            if ( MeaninglessInputPointers && stringPtr != NULL ) {
                stringPtr = variableInputData;
                variableInputData += strlen( (LPSTR) variableInputData ) + 1;
            }

            IF_DEBUG(CONVERT) {
                NetpKdPrint(( PREFIX_NETRAP
                        "RapConvertSingleEntry: z->stuff, stringPtr="
                        FORMAT_LPVOID "\n", (LPVOID) stringPtr ));
            }

            //
            // Update the InStructure pointer
            //    Take into account the fact that on Win64, pointers are 8 bytes, but Non-Native ones are 4 bytes
            //
            InStructure += RAP_POINTER_SIZE( inNative, FALSE );
                        
            //
            // Fill in the output based on the descriptor.
            //

            switch ( *OutStructureDesc++ ) {

            case REM_BYTE: {

                DWORD inSize, outSize, stringSize;

                //
                // Align output structure.
                //

                if (fixedWrite && outUNICODE) {
                    OutStructure = RapPossiblyAlignPointer(
                            OutStructure, ALIGN_TCHAR, inNative );
                }

                //
                // Convert a zero-terminated string to a set number of
                // bytes.
                //

                inSize = RapDescStringLength( InStructureDesc );
                outSize = RapDescArrayLength( OutStructureDesc );

                //
                // Make sure that if the string is not truncatable,
                // the destination is large enough to hold it.
                //

                if ( stringPtr != NULL ) {
                    if (inUNICODE) {
                        stringSize = STRSIZE( (LPTSTR)stringPtr );
                        if (!outUNICODE) {
                            stringSize = NetpUnicodeToDBCSLen( (LPTSTR)stringPtr )+1;
                        }
                    } else {
                        stringSize = strlen( (LPSTR)stringPtr ) + 1;
                        if (outUNICODE) {
                            stringSize = stringSize * sizeof(WCHAR);
                        }
                    }
                } else {
                    stringSize = 0;
                }

                if ( stringSize > outSize ) {

                    if ( currentInStructureDesc == REM_ASCIZ ) {

                        IF_DEBUG(CONVERT) {
                            NetpKdPrint(( PREFIX_NETRAP
                                    "RapConvertSingleEntry: "
                                    "String too long\n" ));
                        }

                        return ERROR_INVALID_PARAMETER;

                    } else {

                        IF_DEBUG(CONVERT) {
                            NetpKdPrint(( PREFIX_NETRAP
                                    "RapConvertSingleEntry: "
                                    "String truncated\n" ));
                        }
                    }
                }

                //
                // Copy either the entire string or the number of bytes
                // that will fit, whichever is less.  Make sure that
                // we leave at least one byte for a zero terminator.
                //

                if ( fixedWrite && stringPtr != NULL ) {

                    if ( outUNICODE ) {

                        LPTSTR Source;

                        if ( !inUNICODE ) {

                            Source = NetpMemoryAllocate(
                                         STRING_SPACE_REQD( stringSize ));
                            if ( Source == NULL ) {
                                return NERR_NoRoom;
                            }
                            NetpCopyStrToTStr( Source,
                                (LPSTR)stringPtr );
                            stringPtr = (LPBYTE)Source;
                        }

                        for ( ;
                              outSize > 1 && *(TCHAR *)stringPtr != TCHAR_EOS;
                              outSize -= sizeof(TCHAR) ) {
                            *(TCHAR *)OutStructure = *(TCHAR *)stringPtr;
                            OutStructure += sizeof(TCHAR);
                            stringPtr += sizeof(TCHAR);
                        }

                        if ( !inUNICODE) {
                            NetpMemoryFree( Source );
                        }

                    } else {

                        LPSTR Source;

                        if ( inUNICODE ) {

                            Source = NetpMemoryAllocate( stringSize );
                            if ( Source == NULL ) {
                                return NERR_NoRoom;
                            }
                            NetpCopyWStrToStrDBCS( Source,
                                (LPTSTR)stringPtr );
                            stringPtr = (LPBYTE)Source;
                        }

                        for ( ;
                              outSize > 1 && *stringPtr != '\0';
                              outSize-- ) {
                            *OutStructure++ = (BYTE) *stringPtr++;
                        }

                        if ( inUNICODE ) {
                            NetpMemoryFree( Source );
                        }
                    }
                }

                //
                // Fill out the remaining bytes with zeros.
                //

                if ( fixedWrite ) {
                    while ( outSize-- > 0 ) {
                        *OutStructure++ = '\0';
                    }
                }

                break;
            }

            case REM_IGNORE:

                //
                // The input is an ignored field.  Instructure is already
                // updated, so just skip over the string length limit.
                //

                (void) RapDescStringLength( InStructureDesc );

                break;

            case REM_ASCIZ:
            case REM_ASCIZ_TRUNCATABLE: {

                //
                // The input has a string pointer, the output gets an
                // offset in the fixed structure to a later location
                // which gets the actual string.
                //

                LPDWORD offset;
                DWORD inLength, outLength;
                DWORD stringLength;
                DWORD stringSize;

                // Get lengths and update descriptor pointers.
                inLength = RapDescStringLength( InStructureDesc );
                outLength = RapDescStringLength( OutStructureDesc );

                if ( fixedWrite ) {
                    OutStructure = RapPossiblyAlignPointer(
                            OutStructure, ALIGN_LPSTR, outNative );
                }

                //
                // If the string pointer is NULL, just copy the NULL
                // pointer and update other pointers.
                //

                if ( stringPtr == NULL ) {

                    if ( fixedWrite ) {
                        RAP_PUT_POINTER(
                                SetOffsets,
                                (LPDWORD)OutStructure,
                                0,
                                outNative );
                        OutStructure += RAP_POINTER_SIZE( outNative, SetOffsets );
                    }

                    break;
                }

                //
                // If the string does not fit in the destination and the
                // string in not truncatable, then fail.
                //

                if (inUNICODE) {
                    if( outUNICODE )
                    {
                        stringLength = STRLEN( (LPTSTR)stringPtr ) + 1;
                    }
                    else
                    {
                        stringLength = NetpUnicodeToDBCSLen( (LPTSTR)stringPtr ) + 1;
                    }
                } else {
                    stringLength = strlen( (LPSTR)stringPtr ) + 1;
                }

                if ( outLength > 0
                     && stringLength > outLength ) {

                    if ( currentInStructureDesc == REM_ASCIZ ) {

                        IF_DEBUG(CONVERT) {
                            NetpKdPrint(( PREFIX_NETRAP
                                    "RapConvertSingleEntry: "
                                    "String too long\n" ));
                        }

                        return ERROR_INVALID_PARAMETER;

                    } else {

                        IF_DEBUG(CONVERT) {
                            NetpKdPrint(( PREFIX_NETRAP
                                    "RapConvertSingleEntry: "
                                    "String truncated\n" ));
                        }
                    }

                    stringLength = outLength;
                }

                //
                // Determine how long the string is and whether it will
                // fit in the available buffer space.  Note that the
                // stringLength variable includes the zero terminator.
                //

                if (outUNICODE) {
                    stringSize = STRING_SPACE_REQD(stringLength);
                    if ( outputBufferSupplied && *StringLocation !=
                           ROUND_DOWN_POINTER( *StringLocation, ALIGN_TCHAR )) {

                        stringSize++;
                    }
                } else {
                    stringSize = stringLength;
                }
                *BytesRequired += stringSize;

                IF_DEBUG(CONVERT) {
                    NetpKdPrint(( PREFIX_NETRAP
                            "RapConvertSingleEntry: bytes required now "
                            FORMAT_DWORD "\n", *BytesRequired ));
                }

                if ( outputBufferSupplied ) {
                    offset = (LPDWORD) OutStructure;
                    if ( fixedWrite ) {
                        OutStructure += RAP_POINTER_SIZE( outNative, SetOffsets );
                    }
                    IF_DEBUG(CONVERT) {
                        NetpKdPrint(( PREFIX_NETRAP
                                "RapConvertSingleEntry: z->z, "
                                "offset after alignment is " FORMAT_LPVOID "\n",
                                (LPVOID) offset ));
                    }
                    if ( (ULONG_PTR)*StringLocation <
                             (ULONG_PTR)nextStructureLocation + stringSize ) {

                        //
                        // There isn't enough space to hold the string--it
                        // would go into the last fixed structure.  Put a
                        // NULL in the offset and don't copy over the
                        // string.
                        //

                        if ( fixedWrite ) {
                            RAP_PUT_POINTER( SetOffsets, offset, 0, outNative );
                        }

                        break;
                    }

                    //
                    // Determine where the string will go.
                    //

                    IF_DEBUG(CONVERT) {
                        NetpKdPrint(( PREFIX_NETRAP
                                "RapConvertSingleEntry: z->z, "
                                "*StringLocation=" FORMAT_LPVOID "\n",
                                (LPVOID) *StringLocation ));
                    }
                    *StringLocation = *StringLocation - stringSize;

                    //
                    // Set the offset value or the actual address in the
                    // fixed structure.  Update the fixed structure
                    // pointer.
                    //

                    if ( fixedWrite ) {
                        if ( SetOffsets ) {
                            IF_DEBUG(CONVERT) {
                                NetpKdPrint(( PREFIX_NETRAP
                                  "RapConvertSingleEntry: z->z, "
                                  "setting offset " FORMAT_HEX_DWORD "\n",
                                  (DWORD)( *StringLocation - OutBufferStart )));
                            }
                            RapPutDword( offset,
                                    (DWORD)( *StringLocation - OutBufferStart),
                                    outNative );
                        } else {
                            IF_DEBUG(CONVERT) {
                                NetpKdPrint(( PREFIX_NETRAP
                                        "RapConvertSingleEntry: z->z, "
                                        "setting pointer " FORMAT_POINTER
                                        "\n", (DWORD_PTR) (*StringLocation) ));
                            }
                            RapPutDword_Ptr( offset,
                                    (DWORD_PTR)( *StringLocation ),
                                    outNative);
                        }

                        //
                        // Copy over the string, truncating if necessary.
                        //

                        if ( inUNICODE && outUNICODE ) {

                            STRNCPY( (LPTSTR)*StringLocation, (LPTSTR)stringPtr,
                                stringLength - 1 );
                            *(LPTSTR)( StringLocation
                                + stringSize - sizeof(TCHAR)) = TCHAR_EOS;

                        } else if ( inUNICODE ) {

                            LPTSTR Source;

                            Source = NetpMemoryAllocate(
                                         STRING_SPACE_REQD( stringLength ));
                            if ( Source == NULL ) {
                                return NERR_NoRoom;
                            }
                            STRNCPY( Source, (LPTSTR)stringPtr,
                                stringLength - 1 );
                            Source[stringLength - 1] = TCHAR_EOS;

                            NetpCopyWStrToStrDBCS( (LPSTR)*StringLocation,
                                Source );

                            NetpMemoryFree( Source );


                        } else if ( outUNICODE ) {
                            LPSTR Source;

                            Source = NetpMemoryAllocate( stringLength );
                            if ( Source == NULL ) {
                                return NERR_NoRoom;
                            }
                            strncpy( Source, (LPSTR)stringPtr,
                                stringLength - 1 );
                            Source[stringLength - 1] = '\0';

                            NetpCopyStrToTStr( (LPTSTR)*StringLocation,
                                Source );

                            NetpMemoryFree( Source );

                        } else {

                            strncpy( (LPSTR)*StringLocation, (LPSTR)stringPtr,
                                stringLength - 1 );
                            (*StringLocation)[stringLength - 1] = '\0';
                        }

                    }

                } // if ( outputBufferSupplied )

                break;
            }

            case REM_BYTE_PTR: {

                //
                // The input has a byte pointer, the output gets an offset
                // in the fixed structure to a later location which gets
                // the actual bytes.
                //

                LPDWORD offset;
                DWORD inLength, outLength;
                DWORD stringLength;

                // Get lengths and update descriptor pointers.
                inLength = RapDescStringLength( InStructureDesc );
                outLength = RapDescArrayLength( OutStructureDesc );

                if ( fixedWrite ) {
                    OutStructure = RapPossiblyAlignPointer(
                                       OutStructure, ALIGN_LPSTR, outNative );
                }

                //
                // If the string does not fit in the destination and the
                // string is not truncatable, then fail.
                //

                stringLength = strlen( (LPSTR)stringPtr ) + 1;

                if ( stringLength > outLength ) {

                    if ( currentInStructureDesc == REM_ASCIZ ) {

                        IF_DEBUG(CONVERT) {
                            NetpKdPrint(( PREFIX_NETRAP
                                    "RapConvertSingleEntry: "
                                    "String too long\n" ));
                        }

                        return ERROR_INVALID_PARAMETER;

                    } else {

                        IF_DEBUG(CONVERT) {
                            NetpKdPrint(( PREFIX_NETRAP
                                    "RapConvertSingleEntry: "
                                    "String truncated\n" ));
                        }
                    }

                    stringLength = outLength;
                }

                //
                //
                // If the string pointer is NULL, just copy the NULL value
                // and update pointers.
                //

                if ( stringPtr == NULL ) {

                    if ( fixedWrite ) {
                        RAP_PUT_POINTER(
                                SetOffsets,
                                (LPDWORD)OutStructure,
                                0,
                                outNative );
                        OutStructure += RAP_POINTER_SIZE( outNative, SetOffsets );
                    }

                    break;
                }

                //
                // Determine how long the string and array are, and whether
                // the array will fit in the available buffer space.
                // The stringLength variable includes the zero terminator.
                //

                *BytesRequired += outLength;

                IF_DEBUG(CONVERT) {
                    NetpKdPrint(( PREFIX_NETRAP
                            "RapConvertSingleEntry: bytes required now "
                            FORMAT_DWORD "\n", *BytesRequired ));
                }

                if ( outputBufferSupplied ) {
                    offset = (LPDWORD)OutStructure;
                    if ( fixedWrite ) {
                        OutStructure += RAP_POINTER_SIZE( outNative, SetOffsets );
                    }

                    if ( (ULONG_PTR)*StringLocation <
                             (ULONG_PTR)nextStructureLocation + outLength ) {

                        //
                        // There isn't enough space to hold the array--it
                        // would go into the last fixed structure.  Put a
                        // NULL in the offset and don't copy over the
                        // string.
                        //

                        if ( fixedWrite ) {
                            RAP_PUT_POINTER( SetOffsets, offset, 0, outNative );
                        }

                        break;
                    }

                    //
                    // Determine where the array will go.
                    //

                    *StringLocation = *StringLocation - outLength;

                    //
                    // Set the offset value or the actual address in the
                    // fixed structure.  Update the fixed structure
                    // pointer.
                    //

                    if ( fixedWrite ) {
                        if ( SetOffsets ) {
                            RapPutDword(
                                    offset,
                                    (DWORD)( *StringLocation - OutBufferStart ),
                                    outNative );
                        } else {
                            RapPutDword_Ptr(
                                    offset,
                                    (DWORD_PTR)( *StringLocation ),
                                    outNative );
                        }
                    }

                    //
                    // Copy over the string. If the source string is smaller
                    // than the target array, only copy the string length.
                    // Otherwise, copy as many bytes as necessary to fill the
                    // array.  Note that truncated strings will not be
                    // null terminated.
                    //

                    (void)MEMCPY(
                              *StringLocation,
                              stringPtr,
                              stringLength );

                } // if ( outputBufferSupplied )
                break;
            }

            default:

                UNSUPPORTED_COMBINATION( REM_ASCIZ, *(OutStructureDesc-1) );
            }

            break;
        }

        case REM_AUX_NUM:

            //
            // 16-bit auxiliary data count.
            //

            switch ( *OutStructureDesc++ ) {

            case REM_AUX_NUM:

                //
                // No conversion required.
                //

                if ( fixedWrite ) {

                    RapPutWord(
                            (LPWORD)OutStructure,
                            RapGetWord( InStructure, inNative ),
                            outNative );
                    OutStructure +=  sizeof(WORD);
                }

                InStructure += sizeof(WORD);

                break;

            case REM_AUX_NUM_DWORD:

                //
                // Convert 16-bit to 32-bit
                //

                if ( fixedWrite ) {

                    RapPutDword(
                            (LPDWORD)OutStructure,
                            (DWORD)RapGetWord( InStructure, inNative ),
                            outNative );
                    OutStructure +=  sizeof(DWORD);
                }

                InStructure += sizeof(WORD);

                break;

            default:

                UNSUPPORTED_COMBINATION( REM_AUX_NUM, *(OutStructureDesc-1) );

            }

            break;

        case REM_AUX_NUM_DWORD:

            //
            // 32-bit auxiliary data count.
            //

            switch ( *OutStructureDesc++ ) {

            case REM_AUX_NUM_DWORD:

                //
                // No conversion required.
                //

                if ( fixedWrite ) {

                    RapPutWord(
                            (LPWORD)OutStructure,
                            RapGetWord( InStructure, inNative ),
                            outNative );
                    OutStructure += sizeof(DWORD);
                }

                InStructure += sizeof(DWORD);

                break;

            case REM_AUX_NUM:

                //
                // Convert 32-bit to 16-bit
                //

                if ( fixedWrite ) {

                    RapPutWord(
                            (LPWORD)OutStructure,
                            (WORD)RapGetWord( InStructure, inNative ),
                            outNative );
                    OutStructure += sizeof(WORD);
                }

                InStructure += sizeof(DWORD);

                break;

            default:

                UNSUPPORTED_COMBINATION( REM_AUX_NUM_DWORD,
                          *(OutStructureDesc-1) );

            }

            break;

        case REM_NULL_PTR:

            //
            // Convert a null pointer to another type.
            //

            switch ( *OutStructureDesc++ ) {

            case REM_NULL_PTR:
            case REM_ASCIZ: {

                //
                // Convert a null pointer to a string pointer.
                //

                (void) RapDescStringLength(
                        OutStructureDesc );  // updated by this call

                if ( fixedWrite ) {
                    RAP_PUT_POINTER(
                            SetOffsets,
                            (LPDWORD)OutStructure,
                            0,
                            outNative );
                    OutStructure += RAP_POINTER_SIZE( outNative, SetOffsets );
                }

                InStructure += RAP_POINTER_SIZE( inNative, FALSE );
                break;
            }

            case REM_IGNORE:

                //
                // The input is an ignored field. Do nothing.
                //

                break;

            default:

                UNSUPPORTED_COMBINATION( REM_NULL_PTR, *(OutStructureDesc-1) );
            }

            break;

        case REM_WORD: {

            //
            // Convert a word to another numerical data type.
            //

            WORD inData = RapGetWord( InStructure, inNative );

            InStructure += sizeof(WORD);

            NetpAssert( !DESC_CHAR_IS_DIGIT( *OutStructureDesc ) );

            switch ( *OutStructureDesc++ ) {

            case REM_BYTE:

                if ( fixedWrite ) {
                    *OutStructure++ = (BYTE)(inData & 0xFF);
                }

                break;

            case REM_WORD: {

                if ( fixedWrite ) {
                    LPWORD outData = (LPWORD)OutStructure;

                    RapPutWord( outData, inData, outNative );
                    OutStructure = OutStructure + sizeof(WORD);
                }

                break;
            }

            case REM_DWORD: {

                if ( fixedWrite ) {
                    LPDWORD outData = (LPDWORD)OutStructure;

                    RapPutDword( outData, (DWORD)inData, outNative );
                    OutStructure = OutStructure + sizeof(DWORD);
                }

                break;
            }

            case REM_SIGNED_DWORD: {


                if ( fixedWrite ) {
                    LPDWORD outData = (LPDWORD)OutStructure;
                    DWORD data = (DWORD)inData;

                    if ( data & 0x8000 ) {

                        data |= 0xFFFF0000;
                    }
                    RapPutDword( outData, data, outNative );

                    OutStructure = OutStructure + sizeof(DWORD);
                }

                break;
            }

            case REM_IGNORE :

                //
                // The input is an ignored pad.  Just update pointers.
                //

                break;

            default:

                UNSUPPORTED_COMBINATION( REM_WORD, *(OutStructureDesc-1) );
            }

            break;
        }

        case REM_DWORD:
        case REM_SIGNED_DWORD: {

            //
            // The input is a longword (four bytes), the output will be
            // a numerical data type.
            //
            // !!! may need support for doubleword arrays

            DWORD inData;
            InStructure = RapPossiblyAlignPointer(
                    InStructure, ALIGN_DWORD, inNative);

            inData = RapGetDword( InStructure, inNative );

            NetpAssert( !DESC_CHAR_IS_DIGIT( *OutStructureDesc ) );

            InStructure += sizeof(DWORD);

            switch ( *OutStructureDesc++ ) {

            case REM_BYTE:

                if ( fixedWrite ) {
                    *OutStructure++ = (BYTE)(inData & 0xFF);
                }

                break;

            case REM_WORD: {

                if ( fixedWrite ) {
                    LPWORD outData = RapPossiblyAlignPointer(
                            (LPWORD)OutStructure, ALIGN_WORD, outNative);

                    RapPutWord( outData, (WORD)(inData & 0xFFFF), outNative );
                    OutStructure = OutStructure + sizeof(WORD);
                }

                break;
            }

            case REM_DWORD:
            case REM_SIGNED_DWORD: {

                if ( fixedWrite ) {
                    LPDWORD outData = RapPossiblyAlignPointer(
                            (LPDWORD)OutStructure, ALIGN_DWORD, outNative);

                    RapPutDword( outData, inData, outNative );
                    OutStructure = OutStructure + sizeof(DWORD);
                }

                break;
            }

            case REM_IGNORE :

                //
                // The input is an ignored pad.  Just update pointers.
                //

                break;

            default:

                UNSUPPORTED_COMBINATION( REM_DWORD, *(OutStructureDesc-1) );
            }

            break;
        }

        case REM_IGNORE :

            //
            // The next location in the output is an irrelevant field.
            // Skip over it.
            //

            switch( *OutStructureDesc++ ) {

            case REM_BYTE:

                if (OutStructure != NULL && fixedWrite) {
                    OutStructure += RapDescArrayLength( OutStructureDesc );
                } else {

                    //
                    // We need this so that it skips the numbers
                    //

                    (void) RapDescArrayLength( OutStructureDesc );
                }
                break;

            case REM_WORD:

                if (OutStructure != NULL && fixedWrite) {
                    OutStructure += sizeof(WORD) *
                                    RapDescArrayLength( OutStructureDesc );
                }
                break;

            case REM_DWORD:

                if (OutStructure != NULL && fixedWrite) {
                    OutStructure += sizeof(DWORD) *
                                    RapDescArrayLength( OutStructureDesc );
                }
                break;

            case REM_IGNORE:

                break;

            case REM_BYTE_PTR:

                (void) RapAsciiToDecimal( &OutStructureDesc );
                /* FALLTHROUGH */

            case REM_NULL_PTR:

                if (OutStructure != NULL && fixedWrite) {
                    OutStructure += sizeof(LPSTR);
                }

                break;

            case REM_ASCIZ:

                (void) RapDescStringLength(
                        OutStructureDesc );  // will be updated

                if (OutStructure != NULL && fixedWrite) {
                    OutStructure += sizeof(LPSTR);
                }

                break;

            case REM_EPOCH_TIME_LOCAL:
                if (OutStructure != NULL && fixedWrite) {
                    OutStructure += sizeof(DWORD);
                }
                break;

            default:

                UNSUPPORTED_COMBINATION( REM_IGNORE, *(OutStructureDesc-1) );
            }

            break;

        case REM_SEND_LENBUF: {

            LPBYTE bytePtr;
            DWORD length;

            InStructure = RapPossiblyAlignPointer(
                    InStructure, ALIGN_LPBYTE, inNative);

            //
            // Set up a pointer to the bytes.  If the pointer stored in
            // the input structure is bad, find out where the bytes are
            // really stored.
            //

            bytePtr = RapGetPointer( InStructure, inNative, Bias );

            if ( MeaninglessInputPointers && bytePtr != NULL ) {
                bytePtr = variableInputData;
            }

            IF_DEBUG(CONVERT) {
                NetpKdPrint(( PREFIX_NETRAP
                        "RapConvertSingleEntry: b->stuff, bytePtr="
                        FORMAT_LPVOID "\n", (LPVOID) bytePtr ));
            }

            //
            // Get the length of the buffer, if we can. Also update pointers
            // if necessary.
            //

            if ( bytePtr != NULL ) {

                length = (DWORD)SmbGetUshort( (LPWORD)bytePtr );
                if ( MeaninglessInputPointers ) {
                    variableInputData += length;
                }

            } else {

                length = 0;
            }

            //
            // Update the InStructure pointer.
            //
            InStructure += RAP_POINTER_SIZE( inNative, FALSE );           

            switch ( *OutStructureDesc++ ) {

            case REM_SEND_LENBUF: {

                //
                // The input has a pointer to a variable size buffer, the
                // output is the same. Copy the bytes.
                //

                LPDWORD offset;

                //
                // Align output pointer if necessary.
                //

                if ( fixedWrite ) {
                    OutStructure = RapPossiblyAlignPointer(
                            OutStructure, ALIGN_LPBYTE, outNative );
                }

                //
                // If the byte pointer is NULL, just copy the NULL
                // pointer and update other pointers.
                //

                if ( bytePtr == NULL ) {

                    if ( fixedWrite ) {
                        RAP_PUT_POINTER(
                                SetOffsets,
                                (LPDWORD)OutStructure,
                                0,
                                outNative );
                        OutStructure += RAP_POINTER_SIZE( outNative, SetOffsets );
                    }

                    break;
                }

                //
                // Update bytes required.
                //

                *BytesRequired += length;

                IF_DEBUG(CONVERT) {
                    NetpKdPrint(( PREFIX_NETRAP
                            "RapConvertSingleEntry: bytes required now "
                            FORMAT_DWORD "\n", *BytesRequired ));
                }

                //
                // Determine whether the data will fit in the available
                // buffer space.
                //

                if ( outputBufferSupplied ) {

                    offset = (LPDWORD) OutStructure;
                    if ( fixedWrite ) {
                        OutStructure += sizeof(LPBYTE);
                    }
                    IF_DEBUG(CONVERT) {
                        NetpKdPrint(( PREFIX_NETRAP
                          "RapConvertSingleEntry: l->l, "
                          "offset after alignment is " FORMAT_LPVOID "\n",
                          (LPVOID) offset ));
                    }

                    if ( (ULONG_PTR)*StringLocation <
                             (ULONG_PTR)nextStructureLocation + length ) {

                        //
                        // There isn't enough space to hold the data--it
                        // would go into the last fixed structure.  Put a
                        // NULL in the offset and don't copy over the
                        // data.
                        //

                        if ( fixedWrite ) {
                            RAP_PUT_POINTER( SetOffsets, offset, 0, outNative );
                        }

                        break;
                    }

                    //
                    // Determine where the buffer will go.
                    //

                    IF_DEBUG(CONVERT) {
                        NetpKdPrint(( PREFIX_NETRAP
                                "RapConvertSingleEntry: l->l, "
                                "*StringLocation=" FORMAT_LPVOID "\n",
                                (LPVOID) *StringLocation ));
                    }
                    *StringLocation = *StringLocation - length;

                    //
                    // Set the offset value or the actual address in the
                    // fixed structure.  Update the fixed structure
                    // pointer.
                    //

                    if ( fixedWrite ) {
                        if ( SetOffsets ) {
                            IF_DEBUG(CONVERT) {
                                NetpKdPrint(( PREFIX_NETRAP
                                  "RapConvertSingleEntry: l->l, "
                                  "setting offset " FORMAT_HEX_DWORD "\n",
                                  (DWORD)( *StringLocation - OutBufferStart )));
                            }
                            RapPutDword( offset,
                                    (DWORD)( *StringLocation - OutBufferStart),
                                    outNative );
                        } else {
                            IF_DEBUG(CONVERT) {
                                NetpKdPrint(( PREFIX_NETRAP
                                        "RapConvertSingleEntry: l->l, "
                                        "setting pointer " FORMAT_POINTER
                                        "\n", (DWORD_PTR) (*StringLocation) ));
                            }
                            RapPutDword_Ptr( offset,
                                    (DWORD_PTR)( *StringLocation ),
                                    outNative);
                        }

                        //
                        // Copy over the bytes.
                        //

                        memcpy(
                            (LPBYTE)*StringLocation,
                            bytePtr,
                            length
                            );
                    }

                } // if ( outputBufferSupplied )

                break;
            }

            case REM_IGNORE :

                //
                // The input is an ignored pad.
                //

                break;

            default:

                UNSUPPORTED_COMBINATION( REM_SEND_LENBUF,
                    *(OutStructureDesc-1) );
            }

            break;

        }

        case REM_EPOCH_TIME_GMT: {

            //
            // The input is a longword (four bytes), the output will be
            // a numerical data type.
            //

            DWORD gmtTime, localTime;
            InStructure = RapPossiblyAlignPointer(
                    InStructure, ALIGN_DWORD, inNative);

            gmtTime = RapGetDword( InStructure, inNative );

            NetpAssert( !DESC_CHAR_IS_DIGIT( *OutStructureDesc ) );

            InStructure += sizeof(DWORD);

            switch ( *OutStructureDesc++ ) {

            case REM_EPOCH_TIME_GMT:

                if ( fixedWrite ) {
                    LPDWORD outData = RapPossiblyAlignPointer(
                            (LPDWORD)OutStructure, ALIGN_DWORD, outNative);

                    RapPutDword( outData, gmtTime, outNative );
                    OutStructure = OutStructure + sizeof(DWORD);
                }

                break;

            case REM_EPOCH_TIME_LOCAL:

                if ( fixedWrite ) {
                    LPDWORD outData = RapPossiblyAlignPointer(
                            (LPDWORD)OutStructure, ALIGN_DWORD, outNative);

                    NetpGmtTimeToLocalTime( gmtTime, & localTime );
                    RapPutDword( outData, localTime, outNative );
                    OutStructure = OutStructure + sizeof(DWORD);
                }

                break;

            case REM_IGNORE :

                //
                // The input is an ignored pad.  Just update pointers.
                //

                break;

            default:

                UNSUPPORTED_COMBINATION(
                        REM_EPOCH_TIME_GMT,
                        *(OutStructureDesc-1) );
            }

            break;
        }


        case REM_EPOCH_TIME_LOCAL: {

            //
            // The input is a longword (four bytes) in seconds since
            // 1970 (local timezone).
            //

            DWORD gmtTime, localTime;
            InStructure = RapPossiblyAlignPointer(
                    InStructure, ALIGN_DWORD, inNative);

            localTime = RapGetDword( InStructure, inNative );

            NetpAssert( !DESC_CHAR_IS_DIGIT( *OutStructureDesc ) );

            InStructure += sizeof(DWORD);

            switch ( *OutStructureDesc++ ) {

            case REM_EPOCH_TIME_GMT:

                if ( fixedWrite ) {
                    LPDWORD outData = RapPossiblyAlignPointer(
                            (LPDWORD)OutStructure, ALIGN_DWORD, outNative);

                    NetpLocalTimeToGmtTime( localTime, & gmtTime );
                    RapPutDword( outData, gmtTime, outNative );
                    OutStructure = OutStructure + sizeof(DWORD);
                }

                break;

            case REM_EPOCH_TIME_LOCAL:

                if ( fixedWrite ) {
                    LPDWORD outData = RapPossiblyAlignPointer(
                            (LPDWORD)OutStructure, ALIGN_DWORD, outNative);

                    RapPutDword( outData, localTime, outNative );
                    OutStructure = OutStructure + sizeof(DWORD);
                }

                break;

            case REM_IGNORE :

                //
                // The input is an ignored pad.  Just update pointers.
                //

                break;

            default:

                UNSUPPORTED_COMBINATION(
                        REM_EPOCH_TIME_LOCAL,
                        *(OutStructureDesc-1) );
            }

            break;
        }

        default:

            NetpKdPrint(( PREFIX_NETRAP
                    "RapConvertSingleEntry: Unsupported input character"
                    " at " FORMAT_LPVOID ": " FORMAT_DESC_CHAR "\n",
                    (LPVOID) (InStructureDesc-1), *(InStructureDesc-1) ));
            NetpAssert(FALSE);
        }
    }

    return NERR_Success;

} // RapConvertSingleEntryEx


NET_API_STATUS
RapConvertSingleEntry (
    IN LPBYTE InStructure,
    IN LPDESC InStructureDesc,
    IN BOOL MeaninglessInputPointers,
    IN LPBYTE OutBufferStart OPTIONAL,
    OUT LPBYTE OutStructure OPTIONAL,
    IN LPDESC OutStructureDesc,
    IN BOOL SetOffsets,
    IN OUT LPBYTE *StringLocation OPTIONAL,
    IN OUT LPDWORD BytesRequired,
    IN RAP_TRANSMISSION_MODE TransmissionMode,
    IN RAP_CONVERSION_MODE ConversionMode
    )

/*++

Routine Description:

    This routine converts a single structure from one representation to
    another.  The representations are described by the descriptor strings
    (see the "OS/2 Lanman Remote Admin Protocol" spec).

    If there isn't enough space in the buffer for the entire structure,
    this routine simply updates the BytesRequired parameter.  Therefore,
    callers have a convenient mechanism for determining the total buffer
    size required to get all the information without special-casing for
    buffer overflow.

Arguments:

    InStructure - a pointer to the input structure.

    InStructureDesc - the descriptor string for the input string.

    MeaninglessInputPointers - if TRUE, then all pointers in the input
        structure are meaningless.  This routine should assume that
        the first variable data immediately follows the input structure,
        and the rest of the variable data follows in order.

    OutBufferStart - the first byte in the output buffer.  For Enum APIs,
        this is used to calculate offsets from the start of the buffer
        for string pointers.  (This pointer may be null, to allow length
        computations only.)

    OutStructure - a pointer to where to put the actual output structure.
        (This pointer may be null, to allow length computations only.)

    OutStructureDesc - the descriptor string for the output structure.

    SetOffsets - TRUE if pointer values in the output structure should
        actually be set to the offset from the beginning of the structure.
        FALSE if the actual addresses should be used.

    StringLocation - the *last* location for variable-length data.  The
        data will be placed before this location and the pointer will
        be updated to reflect the data added.

    BytesRequired - the total number of bytes that would be required to
        store the complete output structure.  This allows the calling
        routine to track the total required for all information without
        worrying about buffer overflow.

    Transmission Mode - Indicates whether this array is part of a response,
        a request, or both.

    Conversion Mode - Indicates whether this is a RAP-to-native, native-to-RAP,
        or native-to-native conversion.

Return Value:

    None.

--*/

{
    NET_API_STATUS netStatus;

    netStatus = RapConvertSingleEntryEx (InStructure,
                                         InStructureDesc,
                                         MeaninglessInputPointers,
                                         OutBufferStart,
                                         OutStructure,
                                         OutStructureDesc,
                                         SetOffsets,
                                         StringLocation,
                                         BytesRequired,
                                         TransmissionMode,
                                         ConversionMode,
                                         0 );

    return netStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\rap\strucalg.c ===
/*++

Copyright (c) 1991 Microsoft Corporation

Module Name:

    StrucAlg.c

Abstract:

    This module contains Remote Admin Protocol (RAP) routines.  These routines
    are shared between XactSrv and RpcXlate.

Author:

    John Rogers (JohnRo)  10-Jul-1991

Environment:

    Portable to any flat, 32-bit environment.  (Uses Win32 typedefs.)
    Requires ANSI C extensions: slash-slash comments, long external names.

Revision History:

    10-Jul-1991 JohnRo
        Created.

--*/


// These must be included first:

#include <windef.h>             // IN, LPDWORD, NULL, OPTIONAL, DWORD, etc.
#include <lmcons.h>             // NET_API_STATUS

// These may be included in any order:

#include <align.h>              // ALIGN_ equates.
#include <netdebug.h>           // NetpKdPrint(()), FORMAT_DWORD.
#include <rap.h>                // My prototype, LPDESC, FORMAT_LPDESC.
#include <rapdebug.h>           // IF_DEBUG().


DWORD
RapStructureAlignment (
    IN LPDESC Descriptor,
    IN RAP_TRANSMISSION_MODE TransmissionMode,
    IN BOOL Native
    )

/*++

Routine Description:

    This routine determines how much a given structure would need to be
    aligned if present in an array.

Arguments:

    Descriptor - the format of the structure.

    Transmission Mode - Indicates whether this array is part of a response,
        a request, or both.

    Native - TRUE iff the descriptor defines a native structure.  (This flag is
        used to decide whether or not to align fields.)

Return Value:

    DWORD - The number of bytes of alignment for the structure.  This may be
    1 for byte alignment.

--*/

{
    DWORD Alignment;
#if DBG
    DWORD FixedSize;
#endif

    //
    // I (JR) have a theory that this must only being used for data structures,
    // and never requests or responses.  (Request and responses are never
    // aligned; that's part of the Remote Admin Protocol definition.)  So,
    // let's do a quick check:
    //
    NetpAssert( TransmissionMode == Both );

    //
    // Walk the descriptor and find the worst alignment for it.
    //
    RapExamineDescriptor(
                Descriptor,
                NULL,
#if DBG
                & FixedSize,
#else
                NULL,  // don't need structure size
#endif
                NULL,
                NULL,
                NULL,
                & Alignment,
                TransmissionMode,
                Native
                );

    IF_DEBUG(STRUCALG) {
        NetpKdPrint(( "RapStructureAlignment: alignment of " FORMAT_LPDESC
                " is " FORMAT_DWORD ".\n", Descriptor, Alignment ));
    }

    //
    //  Let's do some sanity checked of the alignment value we got back.
    //
    NetpAssert( Alignment >= ALIGN_BYTE );
    NetpAssert( Alignment <= ALIGN_WORST );
#if DBG
    NetpAssert( Alignment <= FixedSize );
#endif

    return Alignment;

} // RapStructureAlignment
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\rap\validsmb.c ===
/*++

Copyright (c) 1991-1992 Microsoft Corporation

Module Name:

    ValidSmb.c

Abstract:

    This module contains RapIsValidDescriptorSmb, which tests a descriptor to
    make sure it is a valid descriptor which can be placed in an SMB..

Author:

    John Rogers (JohnRo) 17-Apr-1991

Environment:

    Portable to any flat, 32-bit environment.  (Uses Win32 typedefs.)
    Requires ANSI C extensions: slash-slash comments, long external names.

Revision History:

    17-Apr-1991 JohnRo
        Created.
    03-Jun-1991 JohnRo
        PC-LINT found a bug.
    19-Aug-1991 JohnRo
        Allow UNICODE use.
        Avoid FORMAT_POINTER equate (nonportable).
    16-Aug-1992 JohnRo
        RAID 2920: Support UTC timezone in net code.
        Use PREFIX_ equates.

--*/


// These must be included first:
#include <windef.h>             // IN, LPDWORD, NULL, OPTIONAL, DWORD, etc.
#include <lmcons.h>             // NET_API_STATUS

// These may be included in any order:
#include <netdebug.h>           // NetpBreakPoint(), NetpKdPrint(()).
#include <prefix.h>     // PREFIX_ equates.
#include <rap.h>                // My prototype, LPDESC, DESC_CHAR_IS_DIGIT().
#include <remtypes.h>           // REM_WORD, etc.

BOOL
RapIsValidDescriptorSmb (
    IN LPDESC Desc
    )

/*++

Routine Description:

    RapIsValidDescriptorSmb checks a given descriptor to make sure it is
    valid for sending to a 16-bit downlevel machine in an SMB.

Arguments:

    Desc - the alleged descriptor string.  Note that a null pointer is
        invalid, but a pointer to a null string is OK.

Return Value:

    BOOL - TRUE if valid, FALSE otherwise.

--*/

{
    if (Desc == NULL) {
        return (FALSE);
    }
    if (*Desc == '\0') {
        return (TRUE);
    }

    //
    // Loop through the input descriptor string.
    //

    while ( *Desc != '\0' ) {

        switch ( *Desc++ ) {

        ///////////////////////////////////////
        // Items which allow trailing digits //
        ///////////////////////////////////////

        case REM_BYTE:
        case REM_WORD:
        case REM_DWORD:
        case REM_BYTE_PTR:
        case REM_WORD_PTR:
        case REM_DWORD_PTR:
        case REM_RCV_BYTE_PTR:
        case REM_RCV_WORD_PTR:
        case REM_RCV_DWORD_PTR:
        case REM_FILL_BYTES:

            // Skip digits...
            while (DESC_CHAR_IS_DIGIT(*Desc)) {
                Desc++;
            }
            break;

        /////////////////////////////////////////////
        // Items which don't allow trailing digits //
        /////////////////////////////////////////////

        case REM_ASCIZ:  // Strings with trailing digits are internal use only.
        case REM_NULL_PTR:
        case REM_SEND_BUF_PTR:
        case REM_SEND_BUF_LEN:
        case REM_SEND_LENBUF:
        case REM_DATE_TIME:
        case REM_RCV_BUF_PTR:
        case REM_RCV_BUF_LEN:
        case REM_PARMNUM:
        case REM_ENTRIES_READ:
        case REM_AUX_NUM:
        case REM_AUX_NUM_DWORD:
        case REM_DATA_BLOCK:

            if (DESC_CHAR_IS_DIGIT( *Desc )) {
                NetpKdPrint(( PREFIX_NETRAP
			"RapIsValidDescriptorSmb: "
                        "Unsupported digit(s) at " FORMAT_LPVOID
                        ": for " FORMAT_LPDESC_CHAR "\n",
                        (LPVOID) (Desc-1), *(Desc-1) ));
                NetpBreakPoint();
                return (FALSE);
            }
            break;

        ///////////////////////////////////////
        // Items which are internal use only //
        ///////////////////////////////////////

        case REM_SIGNED_DWORD:
        case REM_SIGNED_DWORD_PTR:
        case REM_ASCIZ_TRUNCATABLE:
        case REM_IGNORE:
        case REM_WORD_LINEAR:
        case REM_UNSUPPORTED_FIELD:
        case REM_EPOCH_TIME_GMT:   /*FALLTHROUGH*/
        case REM_EPOCH_TIME_LOCAL:
            // Internal only!
            NetpKdPrint(( PREFIX_NETRAP
		    "RapIsValidDescriptorSmb: Internal use only desc"
                    " at " FORMAT_LPVOID ": " FORMAT_LPDESC_CHAR "\n",
                    (LPVOID) (Desc-1), *(Desc-1) ));
            NetpBreakPoint();
            return (FALSE);

        default:

            NetpKdPrint(( PREFIX_NETRAP
		    "RapIsValidDescriptorSmb: Unsupported input character"
                    " at " FORMAT_LPVOID ": " FORMAT_LPDESC_CHAR "\n",
                    (LPVOID) (Desc-1), *(Desc-1) ));
            NetpBreakPoint();
            return (FALSE);
        }
    }
    return (TRUE);  // All OK.

} // RapIsValidDescriptorSmb
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\rap\totalsiz.c ===
/*++

Copyright (c) 1991 Microsoft Corporation

Module Name:

    TotalSiz.c

Abstract:

    This module contains RapTotalSize.

Author:

    John Rogers (JohnRo)  05-Jun-1991

Environment:

    Portable to any flat, 32-bit environment.  (Uses Win32 typedefs.)
    Requires ANSI C extensions: slash-slash comments, long external names.

Revision History:

    05-Jun-1991 JohnRo
        Created RapTotalSize().
--*/


// These must be included first:

#include <windef.h>             // IN, LPDWORD, NULL, OPTIONAL, DWORD, etc.
#include <lmcons.h>             // NET_API_STATUS

// These may be included in any order:

#include <lmerr.h>
#include <netdebug.h>           // NetpKdPrint(()), FORMAT_ equates.
#include <rap.h>                // My prototype, RapConvertSingleEntry(), etc.
#include <rapdebug.h>           // IF_DEBUG().


DWORD
RapTotalSize (
    IN LPBYTE InStructure,
    IN LPDESC InStructureDesc,
    IN LPDESC OutStructureDesc,
    IN BOOL MeaninglessInputPointers,
    IN RAP_TRANSMISSION_MODE TransmissionMode,
    IN RAP_CONVERSION_MODE ConversionMode
    )

/*++

Routine Description:

    This routine computes the total size (fixed and string) of a given
    structure.

Arguments:

    InStructure - a pointer to the input structure.

    InStructureDesc - the descriptor string for the input structure.

    OutStructureDesc - the descriptor string for the output structure.
        (May be the same as input, in many cases.)

    MeaninglessInputPointers - if TRUE, then all pointers in the input
        structure are meaningless.  This routine should assume that
        the first variable data immediately follows the input structure,
        and the rest of the variable data follows in order.

    Transmission Mode - Indicates whether this structure is part of a response,
        a request, or both.

    Conversion Mode - Indicates whether this is a RAP-to-native, native-to-RAP,
        or native-to-native conversion.

Return Value:

    DWORD - number of bytes required for the structure

--*/

{
    NET_API_STATUS status;
    DWORD BytesRequired = 0;

    status = RapConvertSingleEntry (
                 InStructure,
                 InStructureDesc,
                 MeaninglessInputPointers,
                 NULL,             // no output buffer start
                 NULL,             // no output buffer
                 OutStructureDesc, // out desc (may be same as input)
                 FALSE,            // don't want offsets (doesn't matter)
                 NULL,             // no string location
                 & BytesRequired,  // size needed (updated)
                 TransmissionMode,
                 ConversionMode);

    NetpAssert( status == NERR_Success );

    IF_DEBUG(TOTALSIZ) {
        NetpKdPrint(("RapTotalSize: size is " FORMAT_DWORD ".\n",
                BytesRequired));
    }

    return (BytesRequired);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\rpcxlate\rxapi\audclear.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    AudClear.c

Abstract:

    This file contains the RpcXlate code to handle the NetAuditClear API.

Author:

    John Rogers (JohnRo) 04-Nov-1991

Environment:

    Portable to any flat, 32-bit environment.  (Uses Win32 typedefs.)
    Requires ANSI C extensions: slash-slash comments, long external names.

Revision History:

    04-Nov-1991 JohnRo
        Created.

--*/

// These must be included first:

#include <windef.h>             // IN, DWORD, etc.
#include <lmcons.h>             // DEVLEN, NET_API_STATUS, etc.
#include <lmaudit.h>            // Needed by rxaudit.h

// These may be included in any order:

#include <apinums.h>            // API_ equates.
#include <netdebug.h>           // NetpKdPrint(()), FORMAT_ equates.
#include <remdef.h>             // REM16_, REM32_, REMSmb_ equates.
#include <rx.h>                 // RxRemoteApi().
#include <rxaudit.h>            // My prototype(s).


NET_API_STATUS
RxNetAuditClear (
    IN LPTSTR UncServerName,
    IN LPTSTR BackupFile OPTIONAL,
    IN LPTSTR Reserved OPTIONAL
    )
{
    NetpAssert(UncServerName != NULL);
    NetpAssert(*UncServerName != '\0');

    return (RxRemoteApi(
            API_WAuditClear,            // API number
            UncServerName,
            REMSmb_NetAuditClear_P,     // parm desc
            NULL,                       // no data desc 16
            NULL,                       // no data desc 32
            NULL,                       // no data desc SMB
            NULL,                       // no aux desc 16
            NULL,                       // no aux desc 32
            NULL,                       // no aux desc SMB
            0,                          // flags: not a null session API
            // rest of API's arguments, in 32-bit LM2.x format:
            BackupFile,
            Reserved));

} // RxNetAuditClear
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\rpcxlate\rxapi\audcpvar.c ===
/*++

Copyright (c) 1991-1992  Microsoft Corporation

Module Name:

    AudCpVar.c

Abstract:

    This file contains RxpConvertAuditEntryVariableData.

Author:

    John Rogers (JohnRo) 07-Nov-1991

Environment:

    Portable to any flat, 32-bit environment.  (Uses Win32 typedefs.)
    Requires ANSI C extensions: slash-slash comments, long external names.

Notes:

    This code depends on the numeric values which are assigned to the
    AE_ equates in <lmaudit.h>.

Revision History:

    07-Nov-1991 JohnRo
        Created.
    18-Nov-1991 JohnRo
        Fixed bug setting StringLocation for RapConvertSingleEntry.
        Fixed bug computing OutputStringOffset in macro.
        Added assertion checking.
        Made changes suggested by PC-LINT.
    27-Jan-1992 JohnRo
        Fixed bug where *OutputVariableSizePtr was often not set.
        Use <winerror.h> and NO_ERROR where possible.
    04-Feb-1992 JohnRo
        Oops, output variable size should include string sizes!
    14-Jun-1992 JohnRo
        RAID 12410: NetAuditRead may trash memory.
        Fixed a bug where AE_NETLOGON records were being truncated.
    07-Jul-1992 JohnRo
        RAID 9933: ALIGN_WORST should be 8 for x86 builds.
    27-Oct-1992 JohnRo
        RAID 10218: Added AE_LOCKOUT support.  Fixed AE_SRVSTATUS and
        AE_GENERIC.

--*/

// These must be included first:

#include <windef.h>             // IN, DWORD, etc.
#include <lmcons.h>             // DEVLEN, NET_API_STATUS, etc.
#include <lmaudit.h>            // Needed by rxaudit.h; AE_ equates.

// These may be included in any order:

#include <align.h>      // ALIGN_ and related equates.
#include <netdebug.h>   // DBGSTATIC.
#include <rap.h>                // RapConvertSingleEntry(), etc.
#include <remdef.h>             // REM16_, REM32_ descriptors.
#include <rxaudit.h>            // My prototype.
#include <smbgtpt.h>            // SmbGet macros.
#include <string.h>             // strlen().
#include <tstring.h>            // MEMCPY(), NetpCopyStrToTStr().
#include <winerror.h>           // NO_ERROR.


typedef struct {
    LPDESC Desc16;
    LPDESC Desc32;
} AUDIT_CONV_DATA, *LPAUDIT_CONV_DATA;


//
// Conversion array, indexed by AE_ value (in ae_type field in fixed portion):
//
DBGSTATIC AUDIT_CONV_DATA DescriptorTable[] = {

    { REM16_audit_entry_srvstatus, REM32_audit_entry_srvstatus },  // 0
    { REM16_audit_entry_sesslogon, REM32_audit_entry_sesslogon },  // 1
    { REM16_audit_entry_sesslogoff, REM32_audit_entry_sesslogoff },  // 2
    { REM16_audit_entry_sesspwerr, REM32_audit_entry_sesspwerr },  // 3
    { REM16_audit_entry_connstart, REM32_audit_entry_connstart },  // 4
    { REM16_audit_entry_connstop, REM32_audit_entry_connstop },  // 5
    { REM16_audit_entry_connrej, REM32_audit_entry_connrej },  // 6

    // Note: 16-bit ae_resaccess and ae_resaccess2 both get converted to
    // the same structure (32-bit ae_resaccess).
    { REM16_audit_entry_resaccess, REM32_audit_entry_resaccess },  // 7

    { REM16_audit_entry_resaccessrej, REM32_audit_entry_resaccessrej },  // 8
    { REM16_audit_entry_closefile, REM32_audit_entry_closefile },  // 9
    { NULL, NULL },  // 10 reserved
    { REM16_audit_entry_servicestat, REM32_audit_entry_servicestat },  // 11
    { REM16_audit_entry_aclmod, REM32_audit_entry_aclmod },  // 12
    { REM16_audit_entry_uasmod, REM32_audit_entry_uasmod },  // 13
    { REM16_audit_entry_netlogon, REM32_audit_entry_netlogon },  // 14
    { REM16_audit_entry_netlogoff, REM32_audit_entry_netlogoff },  // 15
    { NULL, NULL },  // 16 AE_NETLOGDENIED not supported in LanMan 2.0
    { REM16_audit_entry_acclim, REM32_audit_entry_acclim },  // 17

    // Note: 16-bit ae_resaccess and ae_resaccess2 both get converted to
    // 32-bit ae_resaccess.
    { REM16_audit_entry_resaccess2, REM32_audit_entry_resaccess },  // 18

    { REM16_audit_entry_aclmod, REM32_audit_entry_aclmod },  // 19
    { REM16_audit_entry_lockout, REM32_audit_entry_lockout },  // 20
    { NULL, NULL }  // 21 AE_GENERIC_TYPE

    // Add new entries here.  Indexes must match AE_ equates in <lmaudit.h>.
    // Change AE_MAX_KNOWN below at same time.
    };


// Max table entry:
#define AE_MAX_KNOWN  21


VOID
RxpConvertAuditEntryVariableData(
    IN DWORD EntryType,
    IN LPVOID InputVariablePtr,
    OUT LPVOID OutputVariablePtr,
    IN DWORD InputVariableSize,
    OUT LPDWORD OutputVariableSizePtr
    )

{
    BOOL DoByteCopy;

    NetpAssert( InputVariablePtr != NULL );
    NetpAssert( OutputVariablePtr != NULL );
    NetpAssert( POINTER_IS_ALIGNED( OutputVariablePtr, ALIGN_WORST ) );
    NetpAssert( InputVariablePtr != NULL );

    if (InputVariableSize == 0) {

        DoByteCopy = FALSE;
        *OutputVariableSizePtr = 0;

    } else if (EntryType > AE_MAX_KNOWN) {

        // Can't convert if there isn't even a table entry.
        DoByteCopy = TRUE;

    } else {

        LPAUDIT_CONV_DATA TableEntryPtr;

        TableEntryPtr = & DescriptorTable[EntryType];
        NetpAssert( TableEntryPtr != NULL );

        if (TableEntryPtr->Desc16 == NULL) {
            NetpAssert( TableEntryPtr->Desc32 == NULL );
            DoByteCopy = TRUE;          // Table entry but no descriptors.

        } else {
            DWORD NonStringSize;
            DWORD OutputVariableSize;   // (updated by CopyAndFixupString())
            LPTSTR StringLocation;      // string in output entry  (ditto)
            NET_API_STATUS Status;

            NetpAssert( TableEntryPtr->Desc32 != NULL );

            // No bytes yet (RapConvertSingleEntry will update).
            NonStringSize = 0;

            DoByteCopy = FALSE;         // Assume intelligent conversion.

            // RapConvertSingleEntry should not do any strings, but expects
            // a "valid" StringLocation.
            StringLocation = (LPTSTR) ( ( (LPBYTE) OutputVariablePtr )
                    + RapStructureSize(
                            TableEntryPtr->Desc32,
                            Both,       // transmission mode
                            TRUE) );    // want native size.

            //
            // Use RapConvertSingleEntry() to convert the DWORDS, etc.
            // These structures have 16-bit offsets to strings, which
            // we'll have to handle ourselves.
            //
            Status = RapConvertSingleEntry(
                    InputVariablePtr,           // in struct
                    TableEntryPtr->Desc16,      // in struct desc
                    FALSE,                      // no meaningless input ptrs
                    OutputVariablePtr,          // out struct start
                    OutputVariablePtr,          // out struct
                    TableEntryPtr->Desc32,      // out struc desc
                    FALSE,                      // we want ptrs, not offsets.
                    (LPBYTE *) (LPVOID *) & StringLocation,  // str area
                    & NonStringSize,        // bytes required (will be updated)
                    Both,                       // transmission mode
                    RapToNative);               // conversion mode

            NetpAssert( Status == NO_ERROR );
            NetpAssert( NonStringSize > 0 );


            //
            // Set up for doing our own string copying.
            //
            StringLocation =
                    (LPTSTR) ( (LPBYTE) OutputVariablePtr + NonStringSize );


//
// Macro to copy, convert, and update size to reflect a string.
// OutputVariableSize must be set to the size of the fixed portion *BEFORE*
// calling this macro.
//
#define CopyAndFixupString( OldFieldOffset, StructPtrType, NewFieldName ) \
    { \
        LPWORD InputFieldPtr = (LPWORD) \
                (((LPBYTE) InputVariablePtr) + (OldFieldOffset)); \
        DWORD InputStringOffset = (WORD) SmbGetUshort( InputFieldPtr ); \
        StructPtrType NewStruct = (LPVOID) OutputVariablePtr; \
        if (InputStringOffset != 0) { \
            LPSTR OldStringPtr \
                    = ((LPSTR) InputVariablePtr) + InputStringOffset; \
            DWORD OldStringLen = (DWORD) strlen( OldStringPtr ); \
            DWORD OutputStringOffset; \
            DWORD OutputStringSize = (OldStringLen+1) * sizeof(TCHAR); \
            NetpCopyStrToTStr( \
                    StringLocation,  /* dest */ \
                    OldStringPtr);   /* src */ \
            OutputStringOffset = (DWORD) (((LPBYTE) StringLocation) \
                        - (LPBYTE) OutputVariablePtr ); \
            NetpAssert( !RapValueWouldBeTruncated( OutputStringOffset ) ); \
            NewStruct->NewFieldName = OutputStringOffset; \
            OutputVariableSize += OutputStringSize; \
            StringLocation = (LPVOID) \
                    ( ((LPBYTE)StringLocation) + OutputStringSize ); \
        } else { \
            NewStruct->NewFieldName = 0; \
        } \
    }


            switch (EntryType) {
            case AE_SRVSTATUS :
                OutputVariableSize = sizeof(struct _AE_SRVSTATUS);
                break;

            case AE_SESSLOGON :
                OutputVariableSize = sizeof(struct _AE_SESSLOGON);
                CopyAndFixupString( 0, LPAE_SESSLOGON, ae_so_compname );
                CopyAndFixupString( 2, LPAE_SESSLOGON, ae_so_username );
                break;

            case AE_SESSLOGOFF :
                OutputVariableSize = sizeof(struct _AE_SESSLOGOFF);
                CopyAndFixupString( 0, LPAE_SESSLOGOFF, ae_sf_compname );
                CopyAndFixupString( 2, LPAE_SESSLOGOFF, ae_sf_username );
                break;

            case AE_SESSPWERR :
                OutputVariableSize = sizeof(struct _AE_SESSPWERR);
                CopyAndFixupString( 0, LPAE_SESSPWERR, ae_sp_compname );
                CopyAndFixupString( 2, LPAE_SESSPWERR, ae_sp_username );
                break;

            case AE_CONNSTART :
                OutputVariableSize = sizeof(struct _AE_CONNSTART);
                CopyAndFixupString( 0, LPAE_CONNSTART, ae_ct_compname );
                CopyAndFixupString( 2, LPAE_CONNSTART, ae_ct_username );
                CopyAndFixupString( 4, LPAE_CONNSTART, ae_ct_netname );
                break;

            case AE_CONNSTOP :
                OutputVariableSize = sizeof(struct _AE_CONNSTOP);
                CopyAndFixupString( 0, LPAE_CONNSTOP, ae_cp_compname );
                CopyAndFixupString( 2, LPAE_CONNSTOP, ae_cp_username );
                CopyAndFixupString( 4, LPAE_CONNSTOP, ae_cp_netname );
                break;

            case AE_CONNREJ :
                OutputVariableSize = sizeof(struct _AE_CONNREJ);
                CopyAndFixupString( 0, LPAE_CONNREJ, ae_cr_compname );
                CopyAndFixupString( 2, LPAE_CONNREJ, ae_cr_username );
                CopyAndFixupString( 4, LPAE_CONNREJ, ae_cr_netname );
                break;

            case AE_RESACCESS :  /* FALLTHROUGH */
            case AE_RESACCESS2 : // AE_RESACCESS is subset of AE_RESACCESS2

                // Note: 16-bit ae_resaccess and ae_resaccess2 both get
                // converted to the same 32-bit ae_resaccess structure.

                OutputVariableSize = sizeof(struct _AE_RESACCESS);
                CopyAndFixupString( 0, LPAE_RESACCESS, ae_ra_compname );
                CopyAndFixupString( 2, LPAE_RESACCESS, ae_ra_username );
                CopyAndFixupString( 4, LPAE_RESACCESS, ae_ra_resname );
                break;

            case AE_RESACCESSREJ :
                OutputVariableSize = sizeof(struct _AE_RESACCESSREJ);
                CopyAndFixupString( 0, LPAE_RESACCESSREJ, ae_rr_compname );
                CopyAndFixupString( 2, LPAE_RESACCESSREJ, ae_rr_username );
                CopyAndFixupString( 4, LPAE_RESACCESSREJ, ae_rr_resname );
                break;

            case AE_CLOSEFILE :
                OutputVariableSize = sizeof(struct _AE_CLOSEFILE);
                CopyAndFixupString( 0, LPAE_CLOSEFILE, ae_cf_compname );
                CopyAndFixupString( 2, LPAE_CLOSEFILE, ae_cf_username );
                CopyAndFixupString( 4, LPAE_CLOSEFILE, ae_cf_resname );
                break;

            case AE_SERVICESTAT :
                OutputVariableSize = sizeof(struct _AE_SERVICESTAT);
                CopyAndFixupString( 0, LPAE_SERVICESTAT, ae_ss_compname );
                CopyAndFixupString( 2, LPAE_SERVICESTAT, ae_ss_username );
                CopyAndFixupString( 4, LPAE_SERVICESTAT, ae_ss_svcname );
                CopyAndFixupString( 12, LPAE_SERVICESTAT, ae_ss_text );
                break;

            case AE_ACLMOD :       /*FALLTHROUGH*/
            case AE_ACLMODFAIL :
                OutputVariableSize = sizeof(struct _AE_ACLMOD);
                CopyAndFixupString( 0, LPAE_ACLMOD, ae_am_compname );
                CopyAndFixupString( 2, LPAE_ACLMOD, ae_am_username );
                CopyAndFixupString( 4, LPAE_ACLMOD, ae_am_resname );
                break;

            case AE_UASMOD :
                OutputVariableSize = sizeof(struct _AE_UASMOD);
                CopyAndFixupString( 0, LPAE_UASMOD, ae_um_compname );
                CopyAndFixupString( 2, LPAE_UASMOD, ae_um_username );
                CopyAndFixupString( 4, LPAE_UASMOD, ae_um_resname );
                break;

            case AE_NETLOGON :
                OutputVariableSize = sizeof(struct _AE_NETLOGON);
                CopyAndFixupString( 0, LPAE_NETLOGON, ae_no_compname );
                CopyAndFixupString( 2, LPAE_NETLOGON, ae_no_username );
                break;

            case AE_NETLOGOFF :
                OutputVariableSize = sizeof(struct _AE_NETLOGOFF);
                CopyAndFixupString( 0, LPAE_NETLOGOFF, ae_nf_compname );
                CopyAndFixupString( 2, LPAE_NETLOGOFF, ae_nf_username );
                break;

            case AE_ACCLIMITEXCD :
                OutputVariableSize = sizeof(struct _AE_ACCLIM);
                CopyAndFixupString( 0, LPAE_ACCLIM, ae_al_compname );
                CopyAndFixupString( 2, LPAE_ACCLIM, ae_al_username );
                CopyAndFixupString( 4, LPAE_ACCLIM, ae_al_resname );
                break;

            case AE_LOCKOUT :
                OutputVariableSize = sizeof(struct _AE_LOCKOUT);
                CopyAndFixupString( 0, LPAE_LOCKOUT, ae_lk_compname );
                CopyAndFixupString( 2, LPAE_LOCKOUT, ae_lk_username );
                break;

            case AE_GENERIC_TYPE :
                OutputVariableSize = sizeof(struct _AE_GENERIC);
                break;

            default :
                // We don't know about this type.
                // AE_NETLOGDENIED (16) falls into this category.
                DoByteCopy = TRUE;
                OutputVariableSize = InputVariableSize;
                break;

            }

            *OutputVariableSizePtr = OutputVariableSize;

        }

    }

    if (DoByteCopy == TRUE) {
        (void) MEMCPY(
                OutputVariablePtr,      // dest
                InputVariablePtr,       // src
                InputVariableSize );    // byte count
        *OutputVariableSizePtr = InputVariableSize;
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\rpcxlate\rxapi\audread.c ===
/*++

Copyright (c) 1991-1992  Microsoft Corporation

Module Name:

    AudRead.c

Abstract:

    This file contains the RpcXlate code to handle the NetAuditRead API.

Author:

    John Rogers (JohnRo) 05-Nov-1991

Environment:

    Portable to any flat, 32-bit environment.  (Uses Win32 typedefs.)
    Requires ANSI C extensions: slash-slash comments, long external names.

Notes:

    The logic in this routine is based on the logic in ErrRead.c.
    Make sure that you check both files if you find a bug in either.

Revision History:

    05-Nov-1991 JohnRo
        Created.
    20-Nov-1991 JohnRo
        Handle empty log file.
    04-Nov-1992 JohnRo
        RAID 9355: Event viewer: won't focus on LM UNIX machine.

--*/

// These must be included first:

#include <windef.h>             // IN, DWORD, etc.
#include <lmcons.h>             // DEVLEN, NET_API_STATUS, etc.
#include <lmaudit.h>            // Needed by rxaudit.h

// These may be included in any order:

#include <apinums.h>            // API_ equates.
#include <lmapibuf.h>           // NetApiBufferFree().
#include <lmerr.h>              // ERROR_ and NERR_ equates.
#include <netdebug.h>   // NetpAssert().
#include <remdef.h>             // REM16_, REM32_, REMSmb_ equates.
#include <rx.h>                 // RxRemoteApi().
#include <rxaudit.h>            // My prototype(s).



NET_API_STATUS
RxNetAuditRead (
    IN  LPTSTR  UncServerName,
    IN  LPTSTR  service OPTIONAL,
    IN  LPHLOG  auditloghandle,
    IN  DWORD   offset,
    IN  LPDWORD reserved1 OPTIONAL,
    IN  DWORD   reserved2,
    IN  DWORD   offsetflag,
    OUT LPBYTE  *BufPtr,
    IN  DWORD   prefmaxlen,
    OUT LPDWORD BytesRead,
    OUT LPDWORD totalavailable    // approximate!!!
    )
{
    const DWORD BufSize = 65535;
    NET_API_STATUS Status;
    LPBYTE UnconvertedBuffer;
    DWORD UnconvertedSize;

    UNREFERENCED_PARAMETER(prefmaxlen);

    NetpAssert(UncServerName != NULL);
    NetpAssert(*UncServerName != '\0');

    *BufPtr = NULL;  // set in case of error, and GP fault if necessary.

    Status = RxRemoteApi(
            API_WAuditRead,             // API number
            UncServerName,
            REMSmb_NetAuditRead_P,      // parm desc

            REM16_AuditLogReturnBuf,    // data desc 16
            REM16_AuditLogReturnBuf,    // data desc 32 (same as 16)
            REMSmb_AuditLogReturnBuf,   // data desc SMB

            NULL,                       // no aux desc 16
            NULL,                       // no aux desc 32
            NULL,                       // no aux desc SMB
            ALLOCATE_RESPONSE,          // flags: alloc buffer for us
            // rest of API's arguments, in 32-bit LM2.x format:
            service,                    // service name (was reserved)
            auditloghandle,             // log handle (input)
            auditloghandle,             // log handle (output)
            offset,
            reserved1,
            reserved2,
            offsetflag,
            & UnconvertedBuffer,        // buffer (alloc for us)
            BufSize,
            & UnconvertedSize,
            totalavailable);            // total available (approximate)
    if (Status != NERR_Success) {
        return (Status);
    }

    if (UnconvertedSize > 0) {

        NetpAssert( UnconvertedBuffer != NULL );

        Status = RxpConvertAuditArray(
                UnconvertedBuffer,      // input array
                UnconvertedSize,        // input byte count
                BufPtr,                 // will be alloc'ed
                BytesRead);             // output byte count

        (void) NetApiBufferFree( UnconvertedBuffer );

        if (Status == ERROR_NOT_ENOUGH_MEMORY) {
            *BufPtr = NULL;
            return (Status);
        }
        NetpAssert( Status == NERR_Success );

    } else {

        *BytesRead = 0;
        *totalavailable = 0;
        NetpAssert( *BufPtr == NULL );
        if (UnconvertedBuffer != NULL) {
            (void) NetApiBufferFree( UnconvertedBuffer );
        }
        
    }

    return (Status);

} // RxNetAuditRead
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\rpcxlate\rxapi\audarray.c ===
/*++

Copyright (c) 1991-1992  Microsoft Corporation

Module Name:

    AudArray.c

Abstract:

    This file contains RxpConvertAuditArray.

Author:

    John Rogers (JohnRo) 05-Nov-1991

Environment:

    Portable to any flat, 32-bit environment.  (Uses Win32 typedefs.)
    Requires ANSI C extensions: slash-slash comments, long external names.

Notes:

    The logic in ErrConv.c is based on the logic in AudArray.c.
    Make sure that you check both files if you find a bug in either.

Revision History:

    05-Nov-1991 JohnRo
        Created.
    08-Nov-1991 JohnRo
        Fix array increment bug.  Fixed wrong inp var ptr being passed to
        convert variable data.
    22-Nov-1991 JohnRo
        Set ae_data_size field.
    07-Feb-1992 JohnRo
        Use NetApiBufferAllocate() instead of private version.
    16-Jun-1992 JohnRo
        RAID 10311: NetAuditRead and NetErrorLogRead pointer arithmetic wrong.
        Use PREFIX_ equates.
    07-Jul-1992 JohnRo
        RAID 9933: ALIGN_WORST should be 8 for x86 builds.
    17-Aug-1992 JohnRo
        RAID 2920: Support UTC timezone in net code.
    01-Oct-1992 JohnRo
        RAID 3556: Added NetpSystemTimeToGmtTime() for DosPrint APIs.
    30-Oct-1992 JohnRo
        RAID 10218: Fixed potential trash of output record for unknown entries.

--*/

// These must be included first:

#include <windows.h>    // IN, LPTSTR, etc.
#include <lmcons.h>             // DEVLEN, NET_API_STATUS, etc.
#include <lmaudit.h>            // Needed by rxaudit.h

// These may be included in any order:

#include <align.h>      // ALIGN_ and ROUND_ equates.
#include <lmapibuf.h>           // NetApiBufferAllocate().
#include <lmerr.h>              // ERROR_ and NERR_ equates.
#include <netdebug.h>           // NetpKdPrint(()), FORMAT_ equates.
#include <prefix.h>     // PREFIX_ equates.
#include <rxaudit.h>            // RxpAudit routine prototypes.
#include <rxp.h>        // RxpEstimateLogSize().
#include <rxpdebug.h>           // IF_DEBUG().
#include <smbgtpt.h>            // Smb{Get,Put} macros.
#include <timelib.h>    // NetpLocalTimeToGmtTime().


#define DOWNLEVEL_AUDIT_FIXED_ENTRY_SIZE \
        ( 2                     /* ae_len */ \
        + 2                     /* ae_reserved */ \
        + 4                     /* ae_time */ \
        + 2                     /* ae_type */ \
        + 2 )                   /* ae_data_offset */


#define MIN_DOWNLEVEL_ENTRY_SIZE \
        ( DOWNLEVEL_AUDIT_FIXED_ENTRY_SIZE \
        + 2                    /* min variable data size */ \
        + 2 )                  /* ae_len2 */


NET_API_STATUS
RxpConvertAuditArray(
    IN LPVOID InputArray,
    IN DWORD InputByteCount,
    OUT LPBYTE * OutputArrayPtr, // will be alloc'ed (free w/ NetApiBufferFree).
    OUT LPDWORD OutputByteCountPtr
    )
{
    DWORD EntryType;
    const LPBYTE InputArrayEndPtr
            = (LPVOID) ( ((LPBYTE)InputArray) + InputByteCount );
    LPBYTE InputBytePtr;
    DWORD InputDataOffset;
    DWORD InputTotalEntrySize;
    LPBYTE InputFixedPtr;
    LPBYTE InputVariablePtr;
    DWORD InputVariableSize;
    LPVOID OutputArray;
    DWORD OutputArraySize;
    DWORD OutputBytesUsed = 0;
    DWORD OutputEntrySizeSoFar;
    LPAUDIT_ENTRY OutputFixedPtr;
    DWORD OutputVariableSize;
    LPBYTE OutputVariablePtr;
    NET_API_STATUS Status;

    //
    // Error check caller's parameters.
    // Set output parameters to make error handling easier below.
    // (Also check for memory faults while we're at it.)
    //
    if (OutputArrayPtr != NULL) {
        *OutputArrayPtr = NULL;
    }
    if (OutputByteCountPtr != NULL) {
        *OutputByteCountPtr = 0;
    }
    if ( (OutputArrayPtr == NULL) || (OutputByteCountPtr == NULL) ) {
        return (ERROR_INVALID_PARAMETER);
    }
    if ( (InputArray == NULL) || (InputByteCount == 0) ) {
        return (ERROR_INVALID_PARAMETER);
    }

    //
    // Compute size needed for output buffer, taking into account:
    //    per field expansion,
    //    per entry expansion,
    //    and alignment.
    //

    Status = RxpEstimateLogSize(
            DOWNLEVEL_AUDIT_FIXED_ENTRY_SIZE,
            InputByteCount,     // input (downlevel) array size in bytes.
            FALSE,              // no, we're not doing error log
            & OutputArraySize); // set estimated array size in bytes.
    if (Status != NO_ERROR) {
        return (Status);        // (output vars are already set.)
    }

    NetpAssert( OutputArraySize > 0 );
    NetpAssert( OutputArraySize > InputByteCount );

    *OutputByteCountPtr = OutputArraySize;

    //
    // Allocate oversize area for output; we'll realloc it to shrink it.
    //
    Status = NetApiBufferAllocate(
            OutputArraySize,
            (LPVOID *) & OutputArray );
    if (Status != NERR_Success) {
        return (Status);        // (output vars are already set.)
    }
    NetpAssert( OutputArray != NULL );
    NetpAssert( POINTER_IS_ALIGNED( OutputArray, ALIGN_WORST ) );

    //
    // Loop for each entry in the input area.
    //
    OutputFixedPtr = OutputArray;
    for (InputBytePtr = InputArray; InputBytePtr < InputArrayEndPtr; ) {

        InputFixedPtr = InputBytePtr;

        NetpAssert( POINTER_IS_ALIGNED( OutputFixedPtr, ALIGN_WORST ) );

        IF_DEBUG(AUDIT) {
            NetpKdPrint(( PREFIX_NETLIB
                    "RxpConvertAuditArray: doing input entry at "
                    FORMAT_LPVOID ", out entry at " FORMAT_LPVOID ".\n",
                    (LPVOID) InputFixedPtr, (LPVOID) OutputFixedPtr ));
        }

        //
        // Process each field in input fixed entry.
        //

        InputTotalEntrySize = (DWORD) SmbGetUshort( (LPWORD) InputBytePtr );
        if (InputTotalEntrySize < MIN_DOWNLEVEL_ENTRY_SIZE) {
            goto FileCorrupt;
        }

        {
            LPBYTE EndPos = InputBytePtr + InputTotalEntrySize;
            if (EndPos > InputArrayEndPtr) {
                goto FileCorrupt;
            }
            EndPos -= sizeof(WORD);     // the last ae_len2
            if (SmbGetUshort( (LPWORD) EndPos ) != InputTotalEntrySize) {
                goto FileCorrupt;
            }
        }
        InputBytePtr += sizeof(WORD);    // skip ae_len.

        OutputFixedPtr->ae_reserved =
                (DWORD) SmbGetUshort( (LPWORD) InputBytePtr );
        InputBytePtr += sizeof(WORD);   //  skip ae_reserved

        {
            DWORD LocalTime = (DWORD) SmbGetUlong( (LPDWORD) InputBytePtr );
            DWORD GmtTime;
            NetpLocalTimeToGmtTime( LocalTime, & GmtTime );
            OutputFixedPtr->ae_time = GmtTime;
            InputBytePtr += sizeof(DWORD);
        }

        EntryType = (DWORD) SmbGetUshort( (LPWORD) InputBytePtr );
        OutputFixedPtr->ae_type = EntryType;
        InputBytePtr += sizeof(WORD);

        InputDataOffset = (DWORD) SmbGetUshort( (LPWORD) InputBytePtr );
        NetpAssert( InputDataOffset >= DOWNLEVEL_AUDIT_FIXED_ENTRY_SIZE );
        InputBytePtr += sizeof(WORD);

        OutputEntrySizeSoFar = sizeof(AUDIT_ENTRY);


        //
        // Process variable portion (if any):
        //

        InputVariablePtr = (LPVOID)
                ( ((LPBYTE) InputFixedPtr) + InputDataOffset );
        InputVariableSize =
                (InputTotalEntrySize - InputDataOffset)
                - sizeof(WORD);  // don't include ae_len2.

        OutputVariablePtr = (LPVOID)
                ( ((LPBYTE) OutputFixedPtr) + sizeof(AUDIT_ENTRY) );

        // Align variable part.
        OutputVariablePtr = ROUND_UP_POINTER( OutputVariablePtr, ALIGN_WORST );
        OutputEntrySizeSoFar =
                ROUND_UP_COUNT( OutputEntrySizeSoFar, ALIGN_WORST );

        OutputFixedPtr->ae_data_offset = OutputEntrySizeSoFar;

        // Copy and convert the variable part.
        RxpConvertAuditEntryVariableData(
                EntryType,
                InputVariablePtr,
                OutputVariablePtr,
                InputVariableSize,
                & OutputVariableSize);

#ifdef REVISED_AUDIT_ENTRY_STRUCT
        OutputFixedPtr->ae_data_size = OutputVariableSize;
#endif

        // Account for variable area and ae_len2 in total length.
        OutputEntrySizeSoFar += (OutputVariableSize + sizeof(DWORD));

        // Round size up so next entry (if any) is worst-case aligned.
        OutputEntrySizeSoFar =
                ROUND_UP_COUNT( OutputEntrySizeSoFar, ALIGN_WORST );


#define OutputEntrySize  OutputEntrySizeSoFar


        OutputFixedPtr->ae_len = OutputEntrySize;

        {
            LPDWORD EndSizePtr = (LPVOID)
                    ( ((LPBYTE)OutputFixedPtr)
                        + OutputEntrySize - sizeof(DWORD) );
            *EndSizePtr = OutputEntrySize;   // set ae_len2.
        }

        //
        // Update for next loop iteration.
        //

        InputBytePtr = (LPVOID)
                ( ((LPBYTE) InputFixedPtr)
                    + InputTotalEntrySize);

        OutputFixedPtr = (LPVOID)
                ( ((LPBYTE) OutputFixedPtr) + OutputEntrySize );

        OutputBytesUsed += OutputEntrySize;

        NetpAssert( OutputBytesUsed <= OutputArraySize );

    }

    NetpAssert(OutputBytesUsed > 0);
    NetpAssert( OutputBytesUsed <= OutputArraySize );

    *OutputArrayPtr = OutputArray;
    *OutputByteCountPtr = OutputBytesUsed;

    return (NERR_Success);

FileCorrupt:

    NetpKdPrint(( PREFIX_NETAPI
            "RxpConvertAuditArray: corrupt audit log!\n" ));

    if (OutputArray != NULL) {
        (VOID) NetApiBufferFree( OutputArray );
    }
    if (OutputArrayPtr != NULL) {
        *OutputArrayPtr = NULL;
    }
    if (OutputByteCountPtr != NULL) {
        *OutputByteCountPtr = 0;
    }
    return (NERR_LogFileCorrupt);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\rpcxlate\rxapi\confenum.c ===
/*++

Copyright (c) 1991-1992  Microsoft Corporation

Module Name:

    ConfEnum.c

Abstract:

    This file contains the RpcXlate code to handle the NetConfigGetAll API.

Author:

    John Rogers (JohnRo) 24-Oct-1991

Environment:

    Portable to any flat, 32-bit environment.  (Uses Win32 typedefs.)
    Requires ANSI C extensions: slash-slash comments, long external names.

Revision History:

    24-Oct-1991 JohnRo
        Created.
    01-Apr-1992 JohnRo
        Use NetApiBufferAllocate() instead of private version.
    05-Jun-1992 JohnRo
        RAID 11253: NetConfigGetAll fails when remoted to downlevel.
    01-Sep-1992 JohnRo
        RAID 5016: NetConfigGetAll heap trash.

--*/

// These must be included first:

#include <windef.h>     // IN, DWORD, etc.
#include <lmcons.h>     // DEVLEN, NET_API_STATUS, etc.

// These may be included in any order:

#include <apinums.h>    // API_ equates.
#include <lmapibuf.h>   // NetApiBufferAllocate(), NetApiBufferFree().
#include <lmerr.h>      // ERROR_ and NERR_ equates.
#include <lmconfig.h>   // API's data structures.
#include <netdebug.h>   // NetpAssert().
#include <rap.h>        // LPDESC.
#include <remdef.h>     // REM16_, REM32_, REMSmb_ equates.
#include <rx.h>         // RxRemoteApi().
#include <rxconfig.h>   // My prototype(s).
#include <strarray.h>   // NetpCopyStrArrayToTStrArray.


NET_API_STATUS
RxNetConfigGetAll (
    IN LPTSTR UncServerName,
    IN LPTSTR Component,
    OUT LPBYTE *BufPtr
    )

/*++

Routine Description:

    RxNetConfigGetAll performs the same function as NetConfigGetAll,
    except that the server name is known to refer to a downlevel server.

Arguments:

    (Same as NetConfigGetAll, except UncServerName must not be null, and
    must not refer to the local computer.)

Return Value:

    (Same as NetConfigGetAll.)

--*/

{
    const DWORD BufSize = 65535;
    DWORD EntriesRead;
    NET_API_STATUS Status;
    DWORD TotalEntries;

    // Make sure caller didn't mess up.
    NetpAssert(UncServerName != NULL);
    if (BufPtr == NULL) {
        return (ERROR_INVALID_PARAMETER);
    }

    // Assume something might go wrong, and make error paths easier to
    // code.  Also, check for bad pointers before we do anything.
    *BufPtr = NULL;

    //
    // Remote the API, which will allocate the array for us.
    //

    Status = RxRemoteApi(
            API_WConfigGetAll2,         // api number
            UncServerName,              // \\servername
            REMSmb_NetConfigGetAll_P,   // parm desc (SMB version)
            REM16_configgetall_info,
            REM32_configgetall_info,
            REMSmb_configgetall_info,
            NULL,                       // no aux desc 16
            NULL,                       // no aux desc 32
            NULL,                       // no aux desc SMB
            ALLOCATE_RESPONSE,          // flags: allocate buffer for us
            // rest of API's arguments in 32-bit LM 2.x format:
            NULL,                       // pszReserved
            Component,                  // pszComponent
            BufPtr,                     // Buffer: array (alloc for us)
            BufSize,                    // Buffer: array size in bytes
            & EntriesRead,              // pcbEntriesRead
            & TotalEntries);            // pcbTotalAvail

    NetpAssert( Status != ERROR_MORE_DATA );

    if (Status == NERR_Success) {

#ifdef UNICODE

        DWORD SrcByteCount = NetpStrArraySize((LPSTR) *BufPtr);
        LPVOID TempBuff = *BufPtr;      // non-UNICODE version of array.
        LPVOID UnicodeBuff;

        //
        // Allocate space for UNICODE version of array.
        //
        Status = NetApiBufferAllocate(
                SrcByteCount * sizeof(TCHAR),
                & UnicodeBuff);
        if (Status != NERR_Success) {
            return (Status);
        }
        NetpAssert(UnicodeBuff != NULL);

        //
        // Translate result array to Unicode.
        //
        NetpCopyStrArrayToTStrArray(
                UnicodeBuff,            // dest (in UNICODE)
                TempBuff);              // src array (in codepage)

        (void) NetApiBufferFree( TempBuff );
        *BufPtr = UnicodeBuff;

#else // not UNICODE

        // BufPtr should already point at non-UNICODE array.
        NetpAssert( *BufPtr != NULL);

#endif // not UNICODE

    } else {
        *BufPtr = NULL;
    }
    return (Status);

} // RxNetConfigGetAll
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\rpcxlate\rxapi\confget.c ===
/*++

Copyright (c) 1991-1992  Microsoft Corporation

Module Name:

    ConfGet.c

Abstract:

    This file contains the RpcXlate code to handle the NetConfigGet API.

Author:

    John Rogers (JohnRo) 24-Oct-1991

Environment:

    Portable to any flat, 32-bit environment.  (Uses Win32 typedefs.)
    Requires ANSI C extensions: slash-slash comments, long external names.

Revision History:

    24-Oct-1991 JohnRo
        Created.
    28-Oct-1991 JohnRo
        Made changes suggested by PC-LINT.  (Only affects UNICODE option.)
    01-Apr-1992 JohnRo
        Use NetApiBufferAllocate() instead of private version.
    05-Jun-1992 JohnRo
        RAID 11253: NetConfigGetAll fails when remoted to downlevel.
        Use PREFIX_ equates.
    23-Oct-1992 JohnRo
        RAID 9357: server mgr: can't add to alerts list on downlevel.
        Fixed __stdcall for RpcXlate workers.

--*/


// These must be included first:

#include <windef.h>     // IN, DWORD, etc.
#include <lmcons.h>     // LM20_ equates, NET_API_STATUS, etc.

// These may be included in any order:

#include <apinums.h>    // API_ equates.
#include <lmapibuf.h>   // NetApiBufferAllocate(), NetApiBufferFree().
#include <lmerr.h>      // ERROR_ and NERR_ equates.
#include <netdebug.h>   // NetpKdPrint(()), FORMAT_ equates, etc.
#include <prefix.h>     // PREFIX_ equates.
#include <rap.h>        // LPDESC.
#include <remdef.h>     // REM16_, REM32_, REMSmb_ equates.
#include <rx.h>         // RxRemoteApi().
#include <rxpdebug.h>   // IF_DEBUG().
#include <rxconfig.h>   // My prototype.
#include <tstring.h>    // NetpCopyStrToTStr().


NET_API_STATUS
RxNetConfigGet (
    IN LPTSTR UncServerName,
    IN LPTSTR Component,
    IN LPTSTR Parameter,
    OUT LPBYTE *BufPtr
    )
/*++

Routine Description:

    RxNetConfigGet performs the same function as NetConfigGet,
    except that the server name is known to refer to a downlevel server.

Arguments:

    (Same as NetConfigGet, except UncServerName must not be null, and
    must not refer to the local computer.)

Return Value:

    (Same as NetConfigGet.)

--*/

{
    const DWORD BufSize = 65535;
    NET_API_STATUS Status;
    DWORD TotalAvail;

    IF_DEBUG(CONFIG) {
        NetpKdPrint(( PREFIX_NETAPI "RxNetConfigGet: starting, server="
                FORMAT_LPTSTR
                ", component=" FORMAT_LPTSTR ", parm=" FORMAT_LPTSTR ".\n",
                UncServerName, Component, Parameter ));
    }

    //
    // Error check DLL stub and the app.
    //
    NetpAssert(UncServerName != NULL);
    if (BufPtr == NULL) {
        return (ERROR_INVALID_PARAMETER);
    }
    *BufPtr = NULL;  // assume error; it makes error handlers easy to code.
    // This also forces possible GP fault before we allocate memory.

    //
    // Actually remote the API, which will get back the
    // data in native format.
    //
    Status = RxRemoteApi(
            API_WConfigGet2,            // API number
            UncServerName,              // Required, with \\name.
            REMSmb_NetConfigGet_P,      // parm desc
            REM16_configget_info,       // data desc 16
            REM32_configget_info,       // data desc 32
            REMSmb_configget_info,      // data desc SMB
            NULL,                       // no aux data desc 16
            NULL,                       // no aux data desc 32
            NULL,                       // no aux data desc SMB
            ALLOCATE_RESPONSE,          // Flags: alloc mem for us.
            // rest of API's arguments, in 32-bit LM 2.x format:
            NULL,                       // reserved (must be null pointer)
            Component,
            Parameter,
            BufPtr,                     // pbBuffer (will be set)
            BufSize,                    // cbBuffer
            & TotalAvail);              // total size (meaningless!)

    NetpAssert( Status != ERROR_MORE_DATA );
    NetpAssert( Status != NERR_BufTooSmall );

    if (Status == NERR_Success) {

#ifdef UNICODE

        DWORD SrcByteCount = strlen((LPSTR) *BufPtr)+1;  // Bytes for 8-bit str.
        LPVOID TempBuff = *BufPtr;      // non-UNICODE version of string.
        LPVOID UnicodeBuff;

        //
        // Allocate space for UNICODE version of string.
        //
        Status = NetApiBufferAllocate(
                SrcByteCount * sizeof(TCHAR),
                & UnicodeBuff);
        if (Status != NERR_Success) {
            return (Status);
        }
        NetpAssert(UnicodeBuff != NULL);

        //
        // Translate result string to Unicode.
        //
        NetpCopyStrToTStr(
                UnicodeBuff,            // dest (in UNICODE)
                TempBuff);              // src string (in codepage)

        (void) NetApiBufferFree( TempBuff );
        *BufPtr = UnicodeBuff;

#else // not UNICODE

        // BufPtr should already point at non-UNICODE string.
        NetpAssert( *BufPtr != NULL);

#endif // not UNICODE

    } else {
        *BufPtr = NULL;
    }

    return (Status);

} // RxNetConfigGet
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\rpcxlate\rxapi\diskenum.c ===
/*++

Copyright (c) 1991-1992  Microsoft Corporation

Module Name:

    DiskEnum.c

Abstract:

    This file supports downlevel server handling of disk enum requests.

Author:

    John Rogers (JohnRo) 03-May-1991

Environment:

    Portable to any flat, 32-bit environment.  (Uses Win32 typedefs.)
    Requires ANSI C extensions: slash-slash comments, long external names.

Revision History:

    03-May-1991 JohnRo
        Created.
    09-May-1991 JohnRo
        Fixed bug where list wasn't terminated with null string.
    09-May-1991 JohnRo
        Made changes suggested by LINT.
    14-May-1991 JohnRo
        Pass 3 aux descriptors to RxRemoteApi.
    24-Oct-1991 JohnRo
        Handle UNICODE conversion of array at end.
    07-Feb-1992 JohnRo
        Use NetApiBufferAllocate() instead of private version.
    05-Jun-1992 JohnRo
        RAID 11253: NetConfigGetAll fails when remoted to downlevel.

--*/


// These must be included first:

#include <windef.h>     // IN, LPTSTR, etc.
#include <lmcons.h>     // NET_API_STATUS, etc.

// These may be included in any order:

#include <apinums.h>    // API_WServerDiskEnum.
#include <lmapibuf.h>   // NetApiBufferAllocate(), NetApiBufferFree().
#include <lmerr.h>      // NERR_ and ERROR_ equates.
#include <netdebug.h>   // NetpAssert().
#include <remdef.h>     // REM16_, REMSmb_, REM32_ equates.
#include <rx.h>         // RxRemoteApi().
#include <rxserver.h>   // My prototype.
#include <strarray.h>   // NetpCopyStrArrayToTStrArray().


// Level 0 entries are 3 chars ("D:\0") each.
#define LEVEL_0_LENGTH 3

// Define max size of return area.  26 drives, 3 chars ("D:\0") each.
// Also include 1 null char at end of list.
#define MAX_RETURN_BUFF_SIZE  ( ((26*LEVEL_0_LENGTH)+1) * sizeof(TCHAR) )


NET_API_STATUS
RxNetServerDiskEnum (
    IN LPTSTR UncServerName,
    IN DWORD Level,
    OUT LPBYTE *BufPtr,
    IN DWORD PrefMaxSize,
    OUT LPDWORD EntriesRead,
    OUT LPDWORD TotalEntries,
    IN OUT LPDWORD Resume_Handle OPTIONAL
    )

/*++

Routine Description:

    RxNetServerDiskEnum performs the equivalent of NetServerDiskEnum,
    except that UncServerName is known to be a downlevel server.

Arguments:

    Same as NetServerDiskEnum.

Return Value:

    Same as NetServerDiskEnum.

--*/

{
    DWORD Status;
    LPVOID TempBuff = NULL;

    // This version always returns maximum amount of data available, since
    // that would only be (26 * 3) + 1 = 79 bytes.  Even in Unicode it would
    // still only be 158 bytes.  (If we do decide to use the PrefMaxSize parm,
    // then we would call NetpAdjustPreferedMaximum here.)
    DBG_UNREFERENCED_PARAMETER(PrefMaxSize);

    // This version only supports 1 call to enumerate disks, so resume handle
    // should never be set to nonzero.  But let's check, so caller finds out
    // they have a buggy program.
    if (Resume_Handle != NULL) {
        if (*Resume_Handle != 0) {
            return (ERROR_INVALID_PARAMETER);
        }
    }

    // Check for other caller's errors.
    if (Level != 0) {
        return (ERROR_INVALID_LEVEL);
    }

    //
    // Allocate space for entire area.  (Note that we can't reply on
    // RxRemoteApi's neat new ALLOCATE_RESPONSE handling because the buffer
    // sent across the wire doesn't include the null at the end of the
    // array.)
    //
    Status = NetApiBufferAllocate(MAX_RETURN_BUFF_SIZE, & TempBuff);
    if (Status != NERR_Success) {
        return (Status);
    }
    NetpAssert(TempBuff != NULL);

    //
    // Ask downlevel server to enumerate disks for us.
    //
    Status = RxRemoteApi(
            API_WServerDiskEnum,           // api number
            UncServerName,                 // where to execute the API
            REMSmb_NetServerDiskEnum_P,    // parm desc
            REM16_server_diskenum_0,       // data desc (16 bit local)
            REM16_server_diskenum_0,       // data desc (32 bit local) 
            REMSmb_server_diskenum_0,      // data desc (SMB version)
            NULL,                          // no aux desc 16
            NULL,                          // no aux desc 32
            NULL,                          // no aux desc SMB
            0,                             // flags: normal
            // rest of API's arguments in LM 2.x format:
            Level,
            TempBuff,
            (DWORD) MAX_RETURN_BUFF_SIZE,
            EntriesRead,
            TotalEntries);

    // We've allocated space for maximum data, so shouldn't get this...
    NetpAssert(Status != ERROR_MORE_DATA);

    if (Status != NERR_Success) {
        (void) NetApiBufferFree(TempBuff);
        *BufPtr = NULL;
    } else {

        LPSTR TempCharArray = TempBuff;

        //
        // For some reason, the LM 2.x support for this API doesn't send the
        // null character which terminates the list.  So, we have to force it
        // in ourselves.
        //
        TempCharArray[ (*EntriesRead) * LEVEL_0_LENGTH ] = '\0';

#ifdef UNICODE

        {
            LPVOID UnicodeBuff;

            //
            // Allocate space for UNICODE version of array.
            //
            Status = NetApiBufferAllocate(MAX_RETURN_BUFF_SIZE, & UnicodeBuff);
            if (Status != NERR_Success) {
                return (Status);
            }
            NetpAssert(UnicodeBuff != NULL);

            //
            // Translate result array to Unicode.
            //
            NetpCopyStrArrayToTStrArray(
                    UnicodeBuff,     // dest (in UNICODE)
                    TempCharArray);  // src array (in codepage)

            (void) NetApiBufferFree( TempBuff );
            *BufPtr = UnicodeBuff;
        }

#else // not UNICODE

        *BufPtr = TempBuff;

#endif // not UNICODE

    }

    return (Status);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\rpcxlate\rxapi\domain.c ===
/*++

Copyright (c) 1991-1992  Microsoft Corporation

Module Name:

    Domain.c

Abstract:

    This file contains routines to implement remote versions of the LanMan
    domain APIs on downlevel servers.  The APIs are RxNetGetDCName and
    RxNetLogonEnum.

Author:

    John Rogers (JohnRo) 18-Jul-1991

Environment:

    Portable to any flat, 32-bit environment.  (Uses Win32 typedefs.)
    Requires ANSI C extensions: slash-slash comments, long external names.

Revision History:

    18-Jul-1991 JohnRo
        Implement downlevel NetGetDCName.
    27-Jul-1991 JohnRo
        Made changes suggested by PC-LINT.
    07-Feb-1992 JohnRo
        Use NetApiBufferAllocate() instead of private version.
    01-Sep-1992 JohnRo
        RAID 5088: NetGetDCName to downlevel doesn't UNICODE translate.
        Minor debug output fix.
        Changed to use _PREFIX equates.

--*/



// These must be included first:

#include <windef.h>             // IN, LPTSTR, DWORD, TCHAR, etc.
#include <lmcons.h>             // NET_API_STATUS, UNCLEN.

// These may be included in any order:

#include <apinums.h>            // API_ equates.
#include <lmapibuf.h>           // NetApiBufferAllocate(), NetApiBufferFree().
#include <lmerr.h>              // NERR_ and ERROR_ equates.
#include <lmwksta.h>            // NetWkstaGetInfo(), LPWKSTA_INFO_100.
#include <netdebug.h>           // NetpAssert().
#include <prefix.h>     // PREFIX_ equates.
#include <remdef.h>     // REM16_, REM32_, REMSmb_ equates.
#include <rx.h>                 // RxRemoteApi().
#include <rxpdebug.h>           // IF_DEBUG().
#include <rxdomain.h>           // My prototypes.


#define MAX_DCNAME_BYTE_COUNT ( MAX_PATH * sizeof(TCHAR) )


NET_API_STATUS
RxNetGetDCName (
    IN LPTSTR UncServerName,
    IN LPTSTR OptionalDomain OPTIONAL,
    OUT LPBYTE *BufPtr
    )

/*++

Routine Description:

    RxNetGetDCName performs the same function as NetGetDCName, except that the
    server name is known to refer to a downlevel server.

Arguments:

    UncServerName - Same as NetGetDCName, except UncServerName must not be
        null, and must not refer to the local computer.

    OptionalDomain - Same as NetGetDCName.

    BufPtr - Same as NetGetDCName.

Return Value:

    NET_API_STATUS - Same as NetGetDCName.

--*/

{
    LPTSTR DCName = NULL;
    LPTSTR Domain;   // filled-in with domain name (not left NULL).
    NET_API_STATUS Status;
    LPWKSTA_INFO_100 WkstaInfo = NULL;

    // Assume something might go wrong, and make error paths easier to
    // code.  Also, check for a bad pointer before we do anything.
    *BufPtr = NULL;

    //
    // Get actual domain name.
    //

    if ( (OptionalDomain != NULL) && (*OptionalDomain != '\0') ) {
        Domain = OptionalDomain;
    } else {
        // Do NetWkstaGetInfo to get primary domain.
        Status = NetWkstaGetInfo (
                NULL,    // no server name (want LOCAL idea of primary domain)
                100,     // level
                (LPBYTE *) (LPVOID *) & WkstaInfo  // output buffer (allocated)
                );
        if (Status != NERR_Success) {
            IF_DEBUG(DOMAIN) {
                NetpKdPrint(( PREFIX_NETAPI
                        "RxNetGetDCName: wksta get info failed, stat="
                        FORMAT_API_STATUS ".\n", Status));
            }
            goto Done;
        }
        NetpAssert( WkstaInfo->wki100_langroup != NULL );
        IF_DEBUG(DOMAIN) {
            NetpKdPrint(( PREFIX_NETAPI
                    "RxNetGetDCName: wksta says domain is:\n" ));
            NetpDbgHexDump( (LPVOID) WkstaInfo->wki100_langroup, UNLEN+1 );
        }
        Domain = WkstaInfo->wki100_langroup;
    }
    NetpAssert( Domain != NULL );
    NetpAssert( *Domain != '\0' );

    //
    // Allocate memory for DCName.
    //

    Status = NetApiBufferAllocate (
            MAX_DCNAME_BYTE_COUNT,
            (LPVOID *) & DCName
            );
    if (Status != NERR_Success) {
        goto Done;
    }

    //
    // Actually remote the API to the downlevel server, to get DCName.
    //

    Status = RxRemoteApi(
            API_WGetDCName,             // API number
            UncServerName,
            REMSmb_NetGetDCName_P,      // parm desc
            REM16_dc_name,              // data desc 16
            REM32_dc_name,              // data desc 32
            REMSmb_dc_name,             // data desc SMB
            NULL,                       // no aux desc 16
            NULL,                       // no aux desc 32
            NULL,                       // no aux desc SMB
            FALSE,                      // not a null session API
            // rest of API's arguments, in LM 2.x 32-bit format:
            Domain,                     // domain name (filled-in already)
            DCName,                     // response
            MAX_DCNAME_BYTE_COUNT       // size of response buffer
            );

    // It's safe to free WkstaInfo now (we've been using it with Domain until
    // now.)

Done:

    //
    // Tell caller how things went.  Clean up as necessary.
    //

    if (Status == NERR_Success) {
        *BufPtr = (LPBYTE) DCName;
    } else {
        if (DCName != NULL) {
            (void) NetApiBufferFree ( DCName );
        }
    }

    if (WkstaInfo != NULL) {
        // Free memory which NetWkstaGetInfo allocated for us.
        (void) NetApiBufferFree ( WkstaInfo );
    }

    return (Status);

} // RxNetGetDCName
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\rpcxlate\rxapi\confset.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    ConfSet.c

Abstract:

    This file contains the RpcXlate code to handle the NetConfigSet API.

Author:

    John Rogers (JohnRo) 21-Oct-1991

Environment:

    Portable to any flat, 32-bit environment.  (Uses Win32 typedefs.)
    Requires ANSI C extensions: slash-slash comments, long external names.

Revision History:

    21-Oct-1992 JohnRo
        Created for RAID 9357: server mgr: can't add to alerts list on
        downlevel.
    24-Nov-1992 JohnRo
        RAID 3578: Lan Server 2.0 returns NERR_InternalError for this API.

--*/


// These must be included first:

#include <windef.h>     // IN, DWORD, etc.
#include <lmcons.h>     // LM20_ equates, NET_API_STATUS, etc.

// These may be included in any order:

#include <apinums.h>    // API_ equates.
#include <lmconfig.h>   // LPCONFIG_INFO_0, etc.
#include <lmerr.h>      // NO_ERROR, NERR_, and ERROR_ equates.
#include <netdebug.h>   // NetpKdPrint(()), FORMAT_ equates, etc.
#include <prefix.h>     // PREFIX_ equates.
#include <remdef.h>     // REM16_, REM32_, REMSmb_ equates.
#include <rx.h>         // RxRemoteApi().
#include <rxpdebug.h>   // IF_DEBUG().
#include <rxconfig.h>   // My prototype.
#include <tstr.h>       // STRSIZE().


NET_API_STATUS
RxNetConfigSet (
    IN  LPTSTR  UncServerName,
    IN  LPTSTR  Reserved1 OPTIONAL,
    IN  LPTSTR  Component,
    IN  DWORD   Level,
    IN  DWORD   Reserved2,
    IN  LPBYTE  Buf,
    IN  DWORD   Reserved3
    )
/*++

Routine Description:

    RxNetConfigSet performs the same function as NetConfigSet,
    except that the server name is known to refer to a downlevel server.

Arguments:

    (Same as NetConfigSet, except UncServerName must not be null, and
    must not refer to the local computer.)

Return Value:

    (Same as NetConfigSet.)

--*/

{
    NET_API_STATUS ApiStatus;
    LPCONFIG_INFO_0 ConfigStruct = (LPVOID) Buf;
    DWORD BufferSize;

    //
    // Error check DLL stub and the app.
    //
    NetpAssert(UncServerName != NULL);
    if (Component == NULL) {
        ApiStatus = ERROR_INVALID_PARAMETER;
        goto Cleanup;
    }
    if (Level != 0) {
        ApiStatus = ERROR_INVALID_LEVEL;
        goto Cleanup;
    }
    if ( (ConfigStruct->cfgi0_key) == NULL ) {
        ApiStatus = ERROR_INVALID_PARAMETER;
        goto Cleanup;
    }

    //
    // RFirth says we should be paranoid and make sure MBZ (must be zero)
    // parameters really are.  OK with me.  --JR
    //
    if (Reserved1 != NULL) {
        ApiStatus = ERROR_INVALID_PARAMETER;
        goto Cleanup;
    } else if (Reserved2 != 0) {
        ApiStatus = ERROR_INVALID_PARAMETER;
        goto Cleanup;
    } else if (Reserved3 != 0) {
        ApiStatus = ERROR_INVALID_PARAMETER;
        goto Cleanup;
    }

    IF_DEBUG(CONFIG) {
        NetpKdPrint(( PREFIX_NETAPI "RxNetConfigSet: starting, server="
                FORMAT_LPTSTR ", component=" FORMAT_LPTSTR ".\n",
                UncServerName, Component ));
    }

    //
    // Compute buffer size.
    //
    BufferSize = sizeof(CONFIG_INFO_0)
            + STRSIZE( ConfigStruct->cfgi0_key );
    if ( (ConfigStruct->cfgi0_data) != NULL ) {
        BufferSize += STRSIZE( ConfigStruct->cfgi0_data );
    }

    //
    // Actually remote the API, using the already converted data.
    //
    ApiStatus = RxRemoteApi(
            API_WConfigSet,             // API number
            UncServerName,              // Required, with \\name.
            REMSmb_NetConfigSet_P,      // parm desc
            REM16_configset_info_0,     // data desc 16
            REM32_configset_info_0,     // data desc 32
            REMSmb_configset_info_0,    // data desc SMB
            NULL,                       // no aux data desc 16
            NULL,                       // no aux data desc 32
            NULL,                       // no aux data desc SMB
            0,                          // Flags: normal
            // rest of API's arguments, in 32-bit LM 2.x format:
            // parm desc is "zzWWsTD"
            Reserved1,                  // z
            Component,                  // z
            Level,                      // W
            Reserved2,                  // W
            Buf,                        // s
            BufferSize,                 // T
            Reserved3 );                // D

    //
    // IBM LAN Server 2.0 returns NERR_InternalError.  Change this to
    // something more descriptive.
    //
    if (ApiStatus == NERR_InternalError) {
        ApiStatus = ERROR_NOT_SUPPORTED;
    }

Cleanup:

    return (ApiStatus);

} // RxNetConfigSet
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\rpcxlate\rxapi\errconv.c ===
/*++

Copyright (c) 1991-1992  Microsoft Corporation

Module Name:

    ErrConv.c

Abstract:

    This file contains RxpConvertErrorLogArray.

Author:

    John Rogers (JohnRo) 12-Nov-1991

Environment:

    Portable to any flat, 32-bit environment.  (Uses Win32 typedefs.)
    Requires ANSI C extensions: slash-slash comments, long external names.

Notes:

    The logic in this routine is based on the logic in AudArray.c.
    Make sure that you check both files if you find a bug in either.

Revision History:

    12-Nov-1991 JohnRo
        Created.
    05-Feb-1992 JohnRo
        Fix bug where zero bytes of data was mishandled.
    14-Jun-1992 JohnRo
        RAID 10311: NetAuditRead and NetErrorLogRead pointer arithmetic wrong.
        Use PREFIX_ equates.
    07-Jul-1992 JohnRo
        RAID 9933: ALIGN_WORST should be 8 for x86 builds.
        Made changes suggested by PC-LINT.
    17-Aug-1992 JohnRo
        RAID 2920: Support UTC timezone in net code.
    10-Sep-1992 JohnRo
        RAID 5174: event viewer _access violates after NetErrorRead.
    23-Sep-1992 JohnRo
        Handle many more varieties of error log corruption.
    01-Oct-1992 JohnRo
        RAID 3556: Added NetpSystemTimeToGmtTime() for DosPrint APIs.

--*/

// These must be included first:

#include <windows.h>    // IN, LPTSTR, etc.
#include <lmcons.h>     // LM20_SNLEN, NET_API_STATUS, etc.
#include <lmerrlog.h>   // Needed by rxerrlog.h

// These may be included in any order:

#include <align.h>      // ALIGN_ and related equates.
#include <lmapibuf.h>   // NetApiBufferAllocate(), NetApiBufferFree().
#include <lmerr.h>      // NERR_, ERROR_, and NO_ERROR equates.
#include <netdebug.h>   // NetpKdPrint(()), FORMAT_ equates.
#include <prefix.h>     // PREFIX_ equates.
#include <rxerrlog.h>   // My prototype.
#include <rxp.h>        // RxpEstimateLogSize().
#include <rxpdebug.h>   // IF_DEBUG().
#include <smbgtpt.h>    // Smb{Get,Put} macros.
#include <string.h>     // memcpy(), strlen().
#include <timelib.h>    // NetpLocalTimeToGmtTime().
#include <tstring.h>    // NetpCopyStrToTStr(), STRLEN().


#define DOWNLEVEL_FIXED_ENTRY_SIZE \
        ( 2                     /* el_len */ \
        + 2                     /* el_reserved */ \
        + 4                     /* el_time */ \
        + 2                     /* el_error */ \
        + LM20_SNLEN+1          /* el_name (in ASCII) */ \
        + 2                     /* el_data_offset */ \
        + 2 )                   /* el_nstrings */

#define MIN_DOWNLEVEL_ENTRY_SIZE \
        ( DOWNLEVEL_FIXED_ENTRY_SIZE \
        + 2 )                   /* el_len2 */


NET_API_STATUS
RxpConvertErrorLogArray(
    IN LPVOID InputArray,
    IN DWORD InputByteCount,
    OUT LPBYTE * OutputArrayPtr, // will be alloc'ed (free w/ NetApiBufferFree).
    OUT LPDWORD OutputByteCountPtr
    )
{
#ifdef REVISED_ERROR_LOG_STRUCT

    DWORD ErrorCode;
    const LPBYTE InputArrayEndPtr
            = (LPVOID) ( ((LPBYTE)InputArray) + InputByteCount );
    LPBYTE InputBytePtr;
    DWORD InputTextOffset;      // start of text array (from el_data_offset)
    DWORD InputTotalEntrySize;
    LPBYTE InputFixedPtr;
    LPVOID OutputArray;
    DWORD OutputBytesUsed = 0;
    DWORD OutputEntrySizeSoFar;
    LPERROR_LOG OutputFixedPtr;
    LPTSTR OutputNamePtr;
    NET_API_STATUS Status;
    DWORD StringCount;

    //
    // Error check caller's parameters.
    // Set output parameters to make error handling easier below.
    // (Also check for memory faults while we're at it.)
    //
    if (OutputArrayPtr != NULL) {
        *OutputArrayPtr = NULL;
    }
    if (OutputByteCountPtr != NULL) {
        *OutputByteCountPtr = 0;
    }
    if ( (OutputArrayPtr == NULL) || (OutputByteCountPtr == NULL) ) {
        return (ERROR_INVALID_PARAMETER); // (output variables already set.)
    }
    if ( (InputArray == NULL) || (InputByteCount == 0) ) {
        return (ERROR_INVALID_PARAMETER); // (output variables already set.)
    }

    //
    // Estimate size needed for output array (due to expansion and alignment).
    //
    Status = RxpEstimateLogSize(
            DOWNLEVEL_FIXED_ENTRY_SIZE,
            InputByteCount,     // input (downlevel) array size in bytes.
            TRUE,               // yes,  these are error log entries.
            OutputByteCountPtr);// set total number of bytes needed.
    if (Status != NO_ERROR) {
        return (Status);        // (output variables already set.)
    }
    NetpAssert( *OutputByteCountPtr > 0 );

    //
    // Allocate oversize area for output; we'll realloc it to shrink it.
    //
    Status = NetApiBufferAllocate(
            *OutputByteCountPtr,
            (LPVOID *) & OutputArray );
    if (Status != NO_ERROR) {
        return (Status);        // (output variables already set.)
    }
    NetpAssert( POINTER_IS_ALIGNED( OutputArray, ALIGN_WORST ) );

    //
    // Loop for each entry in the input area.
    //
    OutputFixedPtr = OutputArray;
    for (InputBytePtr = InputArray; InputBytePtr < InputArrayEndPtr; ) {

        InputFixedPtr = InputBytePtr;

        // Code at end of loop makes sure that next entry will be aligned.
        // Double check that here.
        NetpAssert( POINTER_IS_ALIGNED(OutputFixedPtr, ALIGN_WORST) );

        IF_DEBUG(ERRLOG) {
            NetpKdPrint(( PREFIX_NETAPI
                    "RxpConvertErrorLogArray: doing input entry at "
                    FORMAT_LPVOID ", out entry at " FORMAT_LPVOID ".\n",
                    (LPVOID) InputFixedPtr, (LPVOID) OutputFixedPtr ));
        }

        //
        // Process each field in input fixed entry.  We'll do the name
        // here as well.  (The name is in the input fixed entry, although it
        // was moved to the variable part for the new structure layout.)
        //

        OutputEntrySizeSoFar = sizeof(ERROR_LOG);

        InputTotalEntrySize = (DWORD) SmbGetUshort( (LPWORD) InputBytePtr );
        if (InputTotalEntrySize < MIN_DOWNLEVEL_ENTRY_SIZE) {
            goto FileCorrupt;
        }

        {
            LPBYTE EndPos = InputBytePtr + InputTotalEntrySize;
            if (EndPos > InputArrayEndPtr) {
                goto FileCorrupt;
            }
            EndPos -= sizeof(WORD);  // the last el_len2
            if (SmbGetUshort( (LPWORD) EndPos ) != InputTotalEntrySize) {
                goto FileCorrupt;
            }
        }
        InputBytePtr += sizeof(WORD);  // skip el_len.

        {
            WORD Reserved = SmbGetUshort( (LPWORD) InputBytePtr );
            WORD InvertedSize = ~ (WORD) InputTotalEntrySize;

            if (Reserved != InvertedSize) {
                goto FileCorrupt;
            }
            OutputFixedPtr->el_reserved = Reserved;
        }
        InputBytePtr += sizeof(WORD);  // skip el_reserved.

        {
            DWORD LocalTime = (DWORD) SmbGetUlong( (LPDWORD) InputBytePtr );
            DWORD GmtTime;
            NetpLocalTimeToGmtTime( LocalTime, & GmtTime );
            OutputFixedPtr->el_time = GmtTime;
            InputBytePtr += sizeof(DWORD);
        }

        ErrorCode = (DWORD) SmbGetUshort( (LPWORD) InputBytePtr );
        NetpAssert( ErrorCode != 0 );
        OutputFixedPtr->el_error = ErrorCode;
        InputBytePtr += sizeof(WORD);

        OutputNamePtr = (LPTSTR)
                ( ((LPBYTE)OutputFixedPtr) + sizeof(ERROR_LOG) );
        OutputNamePtr = ROUND_UP_POINTER( OutputNamePtr, ALIGN_TCHAR );
        OutputEntrySizeSoFar
                = ROUND_UP_COUNT( OutputEntrySizeSoFar, ALIGN_TCHAR );
        NetpCopyStrToTStr(
                OutputNamePtr,          // dest
                (LPVOID) InputBytePtr); // src
        OutputEntrySizeSoFar += STRSIZE(OutputNamePtr);  // string and null chr
        OutputFixedPtr->el_name = OutputNamePtr;
        InputBytePtr += LM20_SNLEN+1;

        InputTextOffset = (DWORD) SmbGetUshort( (LPWORD) InputBytePtr );
        NetpAssert( InputTextOffset >= DOWNLEVEL_FIXED_ENTRY_SIZE );
        InputBytePtr += sizeof(WORD);

        StringCount = (DWORD) SmbGetUshort( (LPWORD) InputBytePtr );
        OutputFixedPtr->el_nstrings = StringCount;
        InputBytePtr += sizeof(WORD);


        //
        // Process text portion (if any).
        //

        {
            LPTSTR NextOutputString;

            // Start text strings after (aligned) name string.
            NextOutputString = (LPVOID)
                      ( ((LPBYTE) OutputFixedPtr) + OutputEntrySizeSoFar );

            // Make sure we've processed entire input fixed entry.
            NetpAssert(
                InputBytePtr == (InputFixedPtr + DOWNLEVEL_FIXED_ENTRY_SIZE));

            // Use offset of text area (was misnamed el_data_offset).
            // InputBytePtr = InputFixedPtr + InputTextOffset;
            NetpAssert(
                InputBytePtr >= (InputFixedPtr + DOWNLEVEL_FIXED_ENTRY_SIZE));

            if (StringCount > 0) {
                OutputFixedPtr->el_text = NextOutputString;
                while (StringCount > 0) {
                    DWORD InputStringSize = strlen( (LPVOID) InputBytePtr) + 1;
                    DWORD OutputStringSize = InputStringSize * sizeof(TCHAR);
                    NetpCopyStrToTStr(
                            NextOutputString,       // dest
                            (LPSTR) InputBytePtr);  // src
                    InputBytePtr         += InputStringSize;
                    NextOutputString     += InputStringSize;
                    OutputEntrySizeSoFar += OutputStringSize;
                    --StringCount;
                }
            } else {
                OutputFixedPtr->el_text = NULL;
            }
        }
        NetpAssert( COUNT_IS_ALIGNED(OutputEntrySizeSoFar, ALIGN_TCHAR) );


        //
        // Process "data" (byte array) portion (if any).
        //

        {
            DWORD InputDataSize;        // byte count for el_data only.

            NetpAssert( InputBytePtr > InputFixedPtr );

            // Use offset of data area.
            InputBytePtr = InputFixedPtr + InputTextOffset;

            InputDataSize = (DWORD)
                    ( (InputTotalEntrySize - sizeof(WORD))
                      - (InputBytePtr - InputFixedPtr) );

            if ( InputDataSize > 0 ) {
                LPBYTE OutputDataPtr
                        = ((LPBYTE) OutputFixedPtr + OutputEntrySizeSoFar);

                NetpAssert( ALIGN_BYTE == 1 );  // align here if not.
                (void) memcpy(
                        OutputDataPtr,  // dest
                        InputBytePtr,   // src
                        InputDataSize); // byte count

                InputBytePtr += InputDataSize;

                OutputEntrySizeSoFar += InputDataSize;
                OutputFixedPtr->el_data = OutputDataPtr;

                // Store correct byte count (before padding).
                OutputFixedPtr->el_data_size = InputDataSize;

            } else {

                OutputFixedPtr->el_data = NULL;
                OutputFixedPtr->el_data_size = 0;
            }
        }


        //
        // The final thing (even after alignment padding) is el_len2.
        //
        OutputEntrySizeSoFar += sizeof(DWORD);

        // Round size up so next entry (if any) is worst-case aligned.
        OutputEntrySizeSoFar =
                ROUND_UP_COUNT( OutputEntrySizeSoFar, ALIGN_WORST );


#define OutputEntrySize  OutputEntrySizeSoFar


        //
        // That's all.  Now go back and set both lengths for this entry.
        //
        OutputFixedPtr->el_len = OutputEntrySize;

        {
            LPDWORD EndSizePtr = (LPVOID)
                    ( ((LPBYTE)OutputFixedPtr)
                        + OutputEntrySize - sizeof(DWORD) );
            *EndSizePtr = OutputEntrySize;   // set el_len2.
        }

        //
        // Update for next loop iteration.
        //

        InputBytePtr = (LPVOID)
                ( ((LPBYTE) InputFixedPtr) + InputTotalEntrySize);

        OutputFixedPtr = (LPVOID)
                ( ((LPBYTE) OutputFixedPtr) + OutputEntrySize );

        OutputBytesUsed += OutputEntrySize;

    }

    NetpAssert(OutputBytesUsed > 0);

    *OutputArrayPtr = OutputArray;
    *OutputByteCountPtr = OutputBytesUsed;

    return (NO_ERROR);

FileCorrupt:

    NetpKdPrint(( PREFIX_NETAPI
            "RxpConvertErrorLogArray: corrupt error log!\n" ));

    if (OutputArray != NULL) {
        (VOID) NetApiBufferFree( OutputArray );
    }
    if (OutputArrayPtr != NULL) {
        *OutputArrayPtr = NULL;
    }
    if (OutputByteCountPtr != NULL) {
        *OutputByteCountPtr = 0;
    }
    return (NERR_LogFileCorrupt);

#else // not REVISED_ERROR_LOG_STRUCT

    return (ERROR_NOT_SUPPORTED);

#endif
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\rpcxlate\rxapi\errread.c ===
/*++

Copyright (c) 1991-1992  Microsoft Corporation

Module Name:

    ErrRead.c

Abstract:

    This file contains the RpcXlate code to handle the NetErrorLogRead API.

Author:

    John Rogers (JohnRo) 12-Nov-1991

Environment:

    Portable to any flat, 32-bit environment.  (Uses Win32 typedefs.)
    Requires ANSI C extensions: slash-slash comments, long external names.

Notes:

    The logic in this routine is based on the logic in AudRead.c.
    Make sure that you check both files if you find a bug in either.

Revision History:

    12-Nov-1991 JohnRo
        Created.
    20-Nov-1991 JohnRo
        Handle empty log file.
        Added some assertion checks.
    10-Sep-1992 JohnRo
        RAID 5174: event viewer _access violates after NetErrorRead.
    04-Nov-1992 JohnRo
        RAID 9355: Event viewer: won't focus on LM UNIX machine.

--*/

// These must be included first:

#include <windef.h>             // IN, DWORD, etc.
#include <lmcons.h>             // NET_API_STATUS, etc.
#include <lmerrlog.h>           // Needed by rxerrlog.h

// These may be included in any order:

#include <apinums.h>            // API_ equates.
#include <lmapibuf.h>           // NetApiBufferFree().
#include <netdebug.h>           // NetpKdPrint(()), FORMAT_ equates.
#include <remdef.h>             // REM16_, REM32_, REMSmb_ equates.
#include <rx.h>                 // RxRemoteApi().
#include <rxerrlog.h>           // My prototype, RxpConvertErrorLogArray().
#include <winerror.h>   // NO_ERROR.



NET_API_STATUS
RxNetErrorLogRead (
    IN LPTSTR UncServerName,
    IN LPTSTR Reserved1 OPTIONAL,
    IN LPHLOG ErrorLogHandle,
    IN DWORD Offset,
    IN LPDWORD Reserved2 OPTIONAL,
    IN DWORD Reserved3,
    IN DWORD OffsetFlag,
    OUT LPBYTE * BufPtr,
    IN DWORD PrefMaxSize,
    OUT LPDWORD BytesRead,
    OUT LPDWORD TotalBytes
    )
{
    const DWORD BufSize = 65535;
    NET_API_STATUS Status;
    LPBYTE UnconvertedBuffer;
    DWORD UnconvertedSize;

    UNREFERENCED_PARAMETER(PrefMaxSize);

    NetpAssert(UncServerName != NULL);
    NetpAssert(*UncServerName != '\0');

    *BufPtr = NULL;  // set in case of error, and GP fault if necessary.

    Status = RxRemoteApi(
            API_WErrorLogRead,             // API number
            UncServerName,
            REMSmb_NetErrorLogRead_P,      // parm desc

            REM16_ErrorLogReturnBuf,    // data desc 16
            REM16_ErrorLogReturnBuf,    // data desc 32 (same as 16)
            REMSmb_ErrorLogReturnBuf,   // data desc SMB

            NULL,                       // no aux desc 16
            NULL,                       // no aux desc 32
            NULL,                       // no aux desc SMB
            ALLOCATE_RESPONSE,          // flags: not a null session API
            // rest of API's arguments, in 32-bit LM2.x format:
            Reserved1,
            ErrorLogHandle,             // log handle (input)
            ErrorLogHandle,             // log handle (output)
            Offset,
            Reserved2,
            Reserved3,
            OffsetFlag,
            & UnconvertedBuffer,        // buffer (alloc for us)
            BufSize,
            & UnconvertedSize,
            TotalBytes);                // total available (approximate)
    if (Status != NO_ERROR) {
        return (Status);
    }

    if (UnconvertedSize > 0) {

        NetpAssert( UnconvertedBuffer != NULL );

        Status = RxpConvertErrorLogArray(
                UnconvertedBuffer,      // input array
                UnconvertedSize,        // input byte count
                BufPtr,                 // will be alloc'ed
                BytesRead);             // output byte count

        (void) NetApiBufferFree( UnconvertedBuffer );

        if (Status != NO_ERROR) {
            *BufPtr = NULL;
            *BytesRead = 0;
            *TotalBytes = 0;
            return (Status);
        }

    } else {

        *BytesRead = 0;
        *TotalBytes = 0;
        NetpAssert( *BufPtr == NULL );
        if (UnconvertedBuffer != NULL) {
            (void) NetApiBufferFree( UnconvertedBuffer );
        }

    }

    if ( *BytesRead == 0) {
        NetpAssert( *BufPtr == NULL );
    } else {
        NetpAssert( *BufPtr != NULL );
    }
    return (Status);

} // RxNetErrorLogRead
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\rpcxlate\rxapi\conn.c ===
/*++

Copyright (c) 1991-1993  Microsoft Corporation

Module Name:

    Conn.c

Abstract:

    This file contains the RpcXlate code to handle the Connection APIs.

Author:

    John Rogers (JohnRo) 23-Jul-1991

Environment:

    Portable to any flat, 32-bit environment.  (Uses Win32 typedefs.)
    Requires ANSI C extensions: slash-slash comments, long external names.

Revision History:

    23-Jul-1991 JohnRo
        Created.
    15-Oct-1991 JohnRo
        Be paranoid about possible infinite loop.
    21-Nov-1991 JohnRo
        Removed NT dependencies to reduce recompiles.
    01-Apr-1992 JohnRo
        Use NetApiBufferAllocate() instead of private version.
    03-Feb-1993 JohnRo
        RAID 8926: NetConnectionEnum to downlevel: memory leak on error.
        Also prevent possible infinite loop.
        Also set buffer pointer to NULL if success but no entries returned.

--*/

// These must be included first:

#include <windef.h>     // IN, DWORD, etc.
#include <lmcons.h>     // DEVLEN, NET_API_STATUS, etc.

// These may be included in any order:

#include <apinums.h>    // API_ equates.
#include <lmapibuf.h>   // NetApiBufferAllocate(), NetApiBufferFree().
#include <lmerr.h>      // ERROR_ and NERR_ equates.
#include <lmshare.h>    // API's data structures.
#include <netdebug.h>   // DBGSTATIC, NetpKdPrint(), FORMAT_ equates.
#include <netlib.h>     // NetpAdjustPreferredMaximum().
#include <prefix.h>     // PREFIX_ equates.
#include <rap.h>        // LPDESC.
#include <remdef.h>     // REM16_, REM32_, REMSmb_ equates.
#include <rx.h>         // RxRemoteApi().
#include <rxp.h>        // RxpFatalErrorCode().
#include <rxconn.h>     // My prototype(s).


#define MAX_CONNECTION_INFO_0_STRING_LEN \
        0
#define MAX_CONNECTION_INFO_1_STRING_LEN \
        ( LM20_UNLEN+1 + LM20_NNLEN+1 )


#define MAX_CONNECTION_INFO_0_STRING_SIZE \
        ( MAX_CONNECTION_INFO_0_STRING_LEN * sizeof(TCHAR) )
#define MAX_CONNECTION_INFO_1_STRING_SIZE \
        ( MAX_CONNECTION_INFO_1_STRING_LEN * sizeof(TCHAR) )


#define ENUM_ARRAY_OVERHEAD_SIZE     0



DBGSTATIC NET_API_STATUS
RxpGetConnectionDataDescs(
    IN DWORD Level,
    OUT LPDESC * DataDesc16,
    OUT LPDESC * DataDesc32,
    OUT LPDESC * DataDescSmb,
    OUT LPDWORD ApiBufferSize32 OPTIONAL
    )
{
    switch (Level) {

    case 0 :
        *DataDesc16 = REM16_connection_info_0;
        *DataDesc32 = REM32_connection_info_0;
        *DataDescSmb = REMSmb_connection_info_0;
        NetpSetOptionalArg(
                ApiBufferSize32,
                sizeof(CONNECTION_INFO_0)
                        + MAX_CONNECTION_INFO_0_STRING_SIZE);
        return (NERR_Success);

    case 1 :
        *DataDesc16 = REM16_connection_info_1;
        *DataDesc32 = REM32_connection_info_1;
        *DataDescSmb = REMSmb_connection_info_1;
        NetpSetOptionalArg(
                ApiBufferSize32,
                sizeof(CONNECTION_INFO_1)
                        + MAX_CONNECTION_INFO_1_STRING_SIZE);
        return (NERR_Success);

    default :
        return (ERROR_INVALID_LEVEL);
    }
    /* NOTREACHED */

} // RxpGetConnectionDataDescs


NET_API_STATUS
RxNetConnectionEnum (
    IN LPTSTR UncServerName,
    IN LPTSTR Qualifier,
    IN DWORD Level,
    OUT LPBYTE *BufPtr,
    IN DWORD PreferedMaximumSize,
    OUT LPDWORD EntriesRead,
    OUT LPDWORD TotalEntries,
    IN OUT LPDWORD ResumeHandle OPTIONAL
    )

/*++

Routine Description:

    RxNetConnectionEnum performs the same function as NetConnectionEnum,
    except that the server name is known to refer to a downlevel server.

Arguments:

    (Same as NetConnectionEnum, except UncServerName must not be null, and
    must not refer to the local computer.)

Return Value:

    (Same as NetConnectionEnum.)

--*/

{
    LPDESC DataDesc16;
    LPDESC DataDesc32;
    LPDESC DataDescSmb;
    DWORD EntriesToAllocate;
    LPVOID InfoArray;
    DWORD InfoArraySize;
    DWORD MaxEntrySize;
    NET_API_STATUS Status;

    UNREFERENCED_PARAMETER(ResumeHandle);

    // Make sure caller didn't mess up.
    NetpAssert(UncServerName != NULL);
    if (BufPtr == NULL) {
        return (ERROR_INVALID_PARAMETER);
    }

    // Assume something might go wrong, and make error paths easier to
    // code.  Also, check for a bad pointer before we do anything.
    *BufPtr = NULL;

    Status = RxpGetConnectionDataDescs(
            Level,
            & DataDesc16,
            & DataDesc32,
            & DataDescSmb,
            & MaxEntrySize);            // API buffer size 32
    if (Status != NERR_Success) {
        return (Status);
    }

    //
    // Downlevel servers don't support resume handles, and we don't
    // have a way to say "close this resume handle" even if we wanted to
    // emulate them here.  Therefore we have to do everthing in one shot.
    // So, the first time around, we'll try using the caller's prefered
    // maximum, but we will enlarge that until we can get everything in one
    // buffer.
    //

    // First time: try caller's prefered maximum.
    NetpAdjustPreferedMaximum (
            PreferedMaximumSize,        // caller's request
            MaxEntrySize,               // byte count per array element
            ENUM_ARRAY_OVERHEAD_SIZE,   // num bytes overhead to show array end
            NULL,                       // we'll compute byte counts ourselves.
            & EntriesToAllocate);       // num of entries we can get.

    //
    // Loop until we have enough memory or we die for some other reason.
    //
    do {

        //
        // Figure out how much memory we need.
        //

        InfoArraySize = (EntriesToAllocate * MaxEntrySize)
                + ENUM_ARRAY_OVERHEAD_SIZE;

        if (InfoArraySize > MAX_TRANSACT_RET_DATA_SIZE) {
            InfoArraySize = MAX_TRANSACT_RET_DATA_SIZE;
        }

        //
        // Alloc memory for the array.
        //

        Status = NetApiBufferAllocate( InfoArraySize, & InfoArray );
        if (Status != NERR_Success) {
            NetpAssert( Status == ERROR_NOT_ENOUGH_MEMORY );
            return (Status);
        }
        NetpAssert( InfoArray != NULL );

        //
        // Remote the API, and see if we've got enough space in the array.
        //

        Status = RxRemoteApi(
                API_WConnectionEnum,    // api number
                UncServerName,          // \\servername
                REMSmb_NetConnectionEnum_P,     // parm desc (SMB version)
                DataDesc16,
                DataDesc32,
                DataDescSmb,
                NULL,                   // no aux desc 16
                NULL,                   // no aux desc 32
                NULL,                   // no aux desc SMB
                0,                      // flags: not a null session API
                // rest of API's arguments in 32-bit LM 2.x format:
                Qualifier,              // Which item to get connections for.
                Level,                  // Level: info level
                InfoArray,              // Buffer: info lvl array
                InfoArraySize,          // Buffer: info lvl array len
                EntriesRead,            // EntriesRead
                TotalEntries);          // TotalAvail


        //
        // If the server returned ERROR_MORE_DATA, free the buffer and try
        // again.  (Actually, if we already tried 64K, then forget it.)
        //

        NetpAssert( InfoArraySize <= MAX_TRANSACT_RET_DATA_SIZE );
        if (Status != ERROR_MORE_DATA) {
            break;
        } else if (InfoArraySize == MAX_TRANSACT_RET_DATA_SIZE) {
            NetpKdPrint(( PREFIX_NETAPI
                    "RxNetConnectionEnum: "
                    "**WARNING** protocol limit reached (64KB).\n" ));
            break;
        }

        (void) NetApiBufferFree( InfoArray );
        InfoArray = NULL;
        NetpAssert( EntriesToAllocate < *TotalEntries );
        EntriesToAllocate = *TotalEntries;

    } while (Status == ERROR_MORE_DATA);


    if ( (Status == NO_ERROR) && ((*EntriesRead) > 0) ) {
        *BufPtr = InfoArray;
    } else {
        (VOID) NetApiBufferFree( InfoArray );
        NetpAssert( *BufPtr == NULL );
    }

    return (Status);

} // RxNetConnectionEnum
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\rpcxlate\rxapi\downlevl.h ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    downlevl.h

Abstract:

    Includes all headers required by LM down-level functions

Author:

    Richard Firth (rfirth) 22-May-1991

Revision History:

    17-Jul-1991 JohnRo
        Extracted RxpDebug.h from Rxp.h.
    18-Sep-1991 JohnRo
        Correct UNICODE use.  (Added POSSIBLE_WCSLEN() macro.)
    21-Nov-1991 JohnRo
        Removed NT dependencies to reduce recompiles.
--*/

#include <windef.h>             // IN, LPTSTR, etc.
#include <lmcons.h>
#include <lmerr.h>
#include <rx.h>
#include <rxp.h>
#include <rxpdebug.h>
#include <remdef.h>
#include <lmremutl.h>
#include <apinums.h>
#include <netdebug.h>
#include <netlib.h>
#include <lmapibuf.h>
#include <tstring.h>
#include <stdlib.h>              // wcslen().

//
// a couple of macros to read pointer checks more easily - NULL_REFERENCE
// is TRUE if either the pointer or pointed-at thing are 0, VALID_STRING
// is TRUE if both the pointer and pointed-at thing are NOT 0
//

#define NULL_REFERENCE(p)   (!(p) || !*(p))
#define VALID_STRING(s)     ((s) && *(s))   // same as !NULL_REFERENCE(s)

//
// when working out buffer requirements, we round up to the next dword amount
//

#define DWORD_ROUNDUP(n)    ((((n) + 3) / 4) * 4)

//
// Check there is a pointer to a string before getting the size. Note that
// these return the number of BYTES required to store the string.
// Use POSSIBLE_STRSIZE() for TCHARs and POSSIBLE_WCSSIZE() for WCHARs.
//

#define POSSIBLE_STRSIZE(s) ((s) ? STRSIZE(s) : 0)
#define POSSIBLE_WCSSIZE(s) ((s) ? WCSSIZE(s) : 0)

//
// Check that there is a pointer to a string before getting the size. Note that
// these return the number of CHARACTERS required to store the string.
// Use POSSIBLE_STRLEN() for TCHARs and POSSIBLE_WCSLEN() for WCHARs.
//

#define POSSIBLE_STRLEN(s)  ((s) ? STRLEN(s) : 0)
#define POSSIBLE_WCSLEN(s)  ((s) ? wcslen(s) : 0)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\rpcxlate\rxapi\errclear.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    ErrClear.r

Abstract:

    This file contains the RpcXlate code to handle the NetErrorLogClear API.

Author:

    John Rogers (JohnRo) 12-Nov-1991

Environment:

    Portable to any flat, 32-bit environment.  (Uses Win32 typedefs.)
    Requires ANSI C extensions: slash-slash comments, long external names.

Revision History:

    12-Nov-1991 JohnRo
        Created.

--*/

// These must be included first:

#include <windef.h>             // IN, DWORD, etc.
#include <lmcons.h>             // DEVLEN, NET_API_STATUS, etc.
#include <lmerrlog.h>           // NetErrorLog APIs; needed by rxerrlog.h.

// These may be included in any order:

#include <apinums.h>            // API_ equates.
#include <lmerr.h>              // ERROR_ and NERR_ equates.
#include <netdebug.h>           // NetpKdPrint(()), FORMAT_ equates.
#include <remdef.h>             // REM16_, REM32_, REMSmb_ equates.
#include <rx.h>                 // RxRemoteApi().
#include <rxerrlog.h>           // My prototype(s).



NET_API_STATUS
RxNetErrorLogClear (
    IN LPTSTR UncServerName,
    IN LPTSTR BackupFile OPTIONAL,
    IN LPBYTE Reserved OPTIONAL
    )
{
    NetpAssert(UncServerName != NULL);
    NetpAssert(*UncServerName != '\0');

    return (RxRemoteApi(
            API_WErrorLogClear,         // API number
            UncServerName,
            REMSmb_NetErrorLogClear_P,  // parm desc
            NULL,                       // no data desc 16
            NULL,                       // no data desc 32
            NULL,                       // no data desc SMB
            NULL,                       // no aux desc 16
            NULL,                       // no aux desc 32
            NULL,                       // no aux desc SMB
            0,                          // flags: not a null session API
            // rest of API's arguments, in 32-bit LM2.x format:
            BackupFile,
            Reserved));

} // RxNetErrorLogClear
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\rpcxlate\rxapi\filclose.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    FilClose.c

Abstract:

    This file contains the RpcXlate code to handle the NetFile APIs.

Author:

    John Rogers (JohnRo) 06-Sep-1991

Environment:

    Portable to any flat, 32-bit environment.  (Uses Win32 typedefs.)
    Requires ANSI C extensions: slash-slash comments, long external names.

Revision History:

    06-Sep-1991 JohnRo
        Created.

--*/

// These must be included first:

#include <windef.h>             // IN, DWORD, etc.
#include <lmcons.h>             // NET_API_STATUS, etc.

// These may be included in any order:

#include <apinums.h>            // API_ equates.
#include <netdebug.h>           // NetpAssert().
//#include <rap.h>                // LPDESC.
#include <remdef.h>             // REM16_, REM32_, REMSmb_ equates.
#include <rx.h>                 // RxRemoteApi().
#include <rxfile.h>             // My prototype(s).
//#include <rxpdebug.h>           // IF_DEBUG().



NET_API_STATUS
RxNetFileClose (
    IN LPTSTR UncServerName,
    IN DWORD FileId
    )
{
    NetpAssert(UncServerName != NULL);
    NetpAssert(*UncServerName != '\0');

    return (RxRemoteApi(
            API_WFileClose,  // API number
            UncServerName,
            REMSmb_NetFileClose_P,  // parm desc
            NULL,  // no data desc 16
            NULL,  // no data desc 32
            NULL,  // no data desc SMB
            NULL,  // no aux desc 16
            NULL,  // no aux desc 32
            NULL,  // no aux desc SMB
            FALSE, // not a null session API
            // rest of API's arguments, in 32-bit LM2.x format:
            FileId
            ));

} // RxNetFileClose
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\rpcxlate\rxapi\filgtinf.c ===
/*++

Copyright (c) 1991-92  Microsoft Corporation

Module Name:

    FilGtInf.c

Abstract:

    This file contains the RpcXlate code to handle the NetFileGetInfo API.

Author:

    John Rogers (JohnRo) 23-Aug-1991

Environment:

    Portable to any flat, 32-bit environment.  (Uses Win32 typedefs.)
    Requires ANSI C extensions: slash-slash comments, long external names.

Revision History:

    23-Aug-1991 JohnRo
        Implement downlevel NetFile APIs.
    22-Oct-1991 JohnRo
        Free buffer on error.
    21-Nov-1991 JohnRo
        Removed NT dependencies to reduce recompiles.
    07-Feb-1992 JohnRo
        Use NetApiBufferAllocate() instead of private version.

--*/

// These must be included first:

#include <windef.h>             // IN, DWORD, etc.
#include <lmcons.h>             // LM20_ equates, NET_API_STATUS, etc.

// These may be included in any order:

#include <apinums.h>            // API_ equates.
#include <lmapibuf.h>           // NetApiBufferAllocate().
#include <lmerr.h>              // ERROR_ and NERR_ equates.
#include <netdebug.h>           // DBGSTATIC, NetpKdPrint(()), FORMAT_ equates.
#include <netlib.h>             // NetpSetParmError().
#include <rap.h>                // LPDESC.
#include <remdef.h>             // REM16_, REM32_, REMSmb_ equates.
#include <rx.h>                 // RxRemoteApi().
#include <rxp.h>                // RxpFatalErrorCode().
#include <rxpdebug.h>           // IF_DEBUG().
#include <rxfile.h>             // My prototype.
#include <strucinf.h>           // NetpFileStructureInfo().



NET_API_STATUS
RxNetFileGetInfo (
    IN LPTSTR UncServerName,
    IN DWORD FileId,
    IN DWORD Level,
    OUT LPBYTE *BufPtr
    )

/*++

Routine Description:

    RxNetFileGetInfo performs the same function as NetFileGetInfo, except
    that the server name is known to refer to a downlevel server.

Arguments:

    (Same as NetFileGetInfo, except UncServerName must not be null, and
    must not refer to the local computer.)

Return Value:

    (Same as NetFileGetInfo.)

--*/

{

    LPDESC DataDesc16, DataDesc32, DataDescSmb;
    LPBYTE ApiBuffer32;              // Buffer to be returned to caller.
    DWORD ApiBufferSize32;
    NET_API_STATUS Status;
    DWORD TotalAvail;

    IF_DEBUG(FILE) {
        NetpKdPrint(("RxNetFileGetInfo: starting, server=" FORMAT_LPTSTR
                ", lvl=" FORMAT_DWORD ".\n", UncServerName, Level));
    }

    //
    // Error check DLL stub and the app.
    //
    NetpAssert(UncServerName != NULL);
    if ( (Level != 2) && (Level != 3) ) {
        return (ERROR_INVALID_LEVEL);
    }
    if (BufPtr == NULL) {
        return (ERROR_INVALID_PARAMETER);
    }
    *BufPtr = NULL;  // assume error; it makes error handlers easy to code.
    // This also forces possible GP fault before we allocate memory.

    //
    // Learn about info level.
    //
    Status = NetpFileStructureInfo (
            Level,                   // level to learn about
            PARMNUM_ALL,                // No parmnum with this.
            TRUE,                       // Need native sizes.
            & DataDesc16,
            & DataDesc32,
            & DataDescSmb,
            & ApiBufferSize32,       // max buffer size (native)
            NULL,                       // don't need fixed size.
            NULL                        // don't need string size.
            );
    if (Status != NERR_Success) {
        return (Status);
    }

    //
    // Allocate memory for 32-bit version of info, which we'll use to get
    // data from the remote computer.
    //
    Status = NetApiBufferAllocate(
            ApiBufferSize32,
            (LPVOID *) & ApiBuffer32);
    if (Status != NERR_Success) {
        return (Status);
    }
    IF_DEBUG(FILE) {
        NetpKdPrint(( "RxNetFileGetInfo: allocated buffer at "
                FORMAT_LPVOID "\n", (LPVOID) ApiBuffer32 ));
    }

    //
    // Actually remote the API, which will get back the
    // data in native format.
    //
    Status = RxRemoteApi(
            API_WFileGetInfo,           // API number
            UncServerName,              // Required, with \\name.
            REMSmb_NetFileGetInfo_P,    // parm desc
            DataDesc16,
            DataDesc32,
            DataDescSmb,
            NULL,                       // no aux data desc 16
            NULL,                       // no aux data desc 32
            NULL,                       // no aux data desc SMB
            FALSE,                      // not a null session API
            // rest of API's arguments, in 32-bit LM 2.x format:
            FileId,
            Level,
            ApiBuffer32,
            ApiBufferSize32,
            & TotalAvail);              // total size 

    NetpAssert( Status != ERROR_MORE_DATA );
    NetpAssert( Status != NERR_BufTooSmall );

    if (Status == NERR_Success) {
        *BufPtr = ApiBuffer32;
    } else {
        (void) NetApiBufferFree( ApiBuffer32 );
    }
    return (Status);

} // RxNetFileGetInfo
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\rpcxlate\rxapi\prtq.c ===
/*++

Copyright (c) 1991-1993  Microsoft Corporation

Module Name:

    PrtQ.c

Abstract:

    This module implements the print queue APIs to remote machines using
    the Remote Admin Protocol.  In addition to the usual downlevel usage, this
    protocol is also used for the NT-to-NT print APIs.

Author:

    John Rogers (JohnRo) 16-May-1991

Environment:

    Portable to any flat, 32-bit environment.  (Uses Win32 typedefs.)
    Requires ANSI C extensions: slash-slash comments, long external names.

Notes:

    All of the RxPrint APIs are wide-character APIs, regardless of
    whether or not UNICODE is defined.  This allows the net/dosprint/dosprint.c
    code to use the winspool APIs (which are currently ANSI APIs, despite their
    prototypes using LPTSTR in some places).

Revision History:

    16-May-1991 JohnRo
        Initial version.
    17-Jun-1991 JohnRo
        Added RxPrintQ{Continue,Pause,Purge}.  Added module header.
    15-Jul-1991 JohnRo
        Added RxPrintQ{Add,Del,Enum,SetInfo}.
    16-Jul-1991 JohnRo
        Estimate bytes needed for print APIs.
    17-Jul-1991 JohnRo
        Extracted RxpDebug.h from Rxp.h.
    21-Nov-1991 JohnRo
        Removed NT dependencies to reduce recompiles.
    07-Jun-1992 JohnRo
        RAID 10324: net print vs. UNICODE.
        RAID 7243: Avoid 64KB requests (Winball servers only HAVE 64KB!)
        Use PREFIX_ equates.
    11-May-1993 JohnRo
        RAID 9942: workaround Windows For Workgroups (WFW) bug in DosPrintQEnum,
        when level=0 and multiple queues exist.
    18-May-1993 JohnRo
        RAID 10222: DosPrintQGetInfoW underestimates number of bytes needed.

--*/


#ifndef UNICODE
#error "RxPrint APIs assume RxRemoteApi uses wide characters."
#endif


// These must be included first:

#include <windows.h>    // IN, LPWSTR, etc.
#include <lmcons.h>     // NET_API_STATUS, etc.

// These may be included in any order:

#include <apinums.h>    // API_ equates.
#include <lmerr.h>      // NERR_ and ERROR_ equates.
#include <names.h>      // NetpIsUncComputerNameValid(), etc.
#include <netdebug.h>   // NetpAssert().
#include <netlib.h>     // NetpSetOptionalArg().
#include <prefix.h>     // PREFIX_ equates.
#include <remdef.h>     // REM16_, REM32_, REMSmb_, field index equates.
#include <rx.h>         // RxRemoteApi().
#include <rxp.h>        // RxpEstimatedBytesNeeded(). MAX_TRANSACT_ equates.
#include <rxpdebug.h>   // IF_DEBUG().
#include <rxprint.h>    // My prototypes, some PRQ_ equates.
#include <strucinf.h>   // NetpPrintQStructureInfo().


DBGSTATIC NET_API_STATUS
RxpGetPrintQInfoDescs(
    IN DWORD InfoLevel,
    IN BOOL AddOrSet,
    OUT LPDESC * DataDesc16 OPTIONAL,
    OUT LPDESC * DataDesc32 OPTIONAL,
    OUT LPDESC * DataDescSmb OPTIONAL,
    OUT LPDESC * AuxDesc16 OPTIONAL,
    OUT LPDESC * AuxDesc32 OPTIONAL,
    OUT LPDESC * AuxDescSmb OPTIONAL
    )
{
    switch (InfoLevel) {
    case 0 :
        if (AddOrSet) {
            return (ERROR_INVALID_LEVEL);
        }
        NetpSetOptionalArg(AuxDesc16, NULL);
        NetpSetOptionalArg(AuxDesc32, NULL);
        NetpSetOptionalArg(AuxDescSmb, NULL);
        NetpSetOptionalArg(DataDesc16, REM16_printQ_0);
        NetpSetOptionalArg(DataDesc32, REM32_printQ_0);
        NetpSetOptionalArg(DataDescSmb, REMSmb_printQ_0);
        return (NERR_Success);

    case 1 :
        NetpSetOptionalArg(AuxDesc16, NULL);
        NetpSetOptionalArg(AuxDesc32, NULL);
        NetpSetOptionalArg(AuxDescSmb, NULL);
        NetpSetOptionalArg(DataDesc16, REM16_printQ_1);
        NetpSetOptionalArg(DataDesc32, REM32_printQ_1);
        NetpSetOptionalArg(DataDescSmb, REMSmb_printQ_1);
        return (NERR_Success);

    case 2 :
        if (AddOrSet) {
            return (ERROR_INVALID_LEVEL);
        }
        NetpSetOptionalArg(AuxDesc16, REM16_print_job_1);
        NetpSetOptionalArg(AuxDesc32, REM32_print_job_1);
        NetpSetOptionalArg(AuxDescSmb, REMSmb_print_job_1);
        NetpSetOptionalArg(DataDesc16, REM16_printQ_2);
        NetpSetOptionalArg(DataDesc32, REM32_printQ_2);
        NetpSetOptionalArg(DataDescSmb, REMSmb_printQ_2);
        return (NERR_Success);

    case 3 :
        NetpSetOptionalArg(AuxDesc16, NULL);
        NetpSetOptionalArg(AuxDesc32, NULL);
        NetpSetOptionalArg(AuxDescSmb, NULL);
        NetpSetOptionalArg(DataDesc16, REM16_printQ_3);
        NetpSetOptionalArg(DataDesc32, REM32_printQ_3);
        NetpSetOptionalArg(DataDescSmb, REMSmb_printQ_3);
        return (NERR_Success);

    case 4 :
        if (AddOrSet) {
            return (ERROR_INVALID_LEVEL);
        }
        NetpSetOptionalArg(AuxDesc16, REM16_print_job_2);
        NetpSetOptionalArg(AuxDesc32, REM32_print_job_2);
        NetpSetOptionalArg(AuxDescSmb, REMSmb_print_job_2);
        NetpSetOptionalArg(DataDesc16, REM16_printQ_4);
        NetpSetOptionalArg(DataDesc32, REM32_printQ_4);
        NetpSetOptionalArg(DataDescSmb, REMSmb_printQ_4);
        return (NERR_Success);

    case 5 :
        if (AddOrSet) {
            return (ERROR_INVALID_LEVEL);
        }
        NetpSetOptionalArg(AuxDesc16, NULL);
        NetpSetOptionalArg(AuxDesc32, NULL);
        NetpSetOptionalArg(AuxDescSmb, NULL);
        NetpSetOptionalArg(DataDesc16, REM16_printQ_5);
        NetpSetOptionalArg(DataDesc32, REM32_printQ_5);
        NetpSetOptionalArg(DataDescSmb, REMSmb_printQ_5);
        return (NERR_Success);

    default :
        return (ERROR_INVALID_LEVEL);
    }
    /* NOTREACHED */
} // RxpGetPrintQInfoDescs


SPLERR SPLENTRY
RxPrintQAdd(
    IN LPWSTR UncServerName,
    IN DWORD Level,
    IN LPBYTE Buffer,
    IN DWORD BufferSize
    )
{
    LPDESC AuxDesc16,  AuxDesc32,  AuxDescSmb;
    LPDESC DataDesc16, DataDesc32, DataDescSmb;
    NET_API_STATUS Status;

    Status = RxpGetPrintQInfoDescs(
        Level,
        TRUE,    // this is an add or set API.
        & DataDesc16,
        & DataDesc32,
        & DataDescSmb,
        & AuxDesc16,
        & AuxDesc32,
        & AuxDescSmb);
    if (Status != NERR_Success) {
        return (Status);
    }
    return (RxRemoteApi(
            API_WPrintQAdd,  // API number
            (LPTSTR) UncServerName,
            REMSmb_DosPrintQAdd_P,  // parm desc
            DataDesc16,
            DataDesc32,
            DataDescSmb,
            AuxDesc16,
            AuxDesc32,
            AuxDescSmb,
            FALSE, // not a null session API
            // rest of API's arguments, in 32-bit LM2.x format:
            Level,
            Buffer,
            BufferSize));

} // RxPrintQAdd


SPLERR SPLENTRY
RxPrintQContinue(
    IN LPWSTR UncServerName,
    IN LPWSTR QueueName
    )
{
    return (RxRemoteApi(
            API_WPrintQContinue,  // API number
            (LPTSTR) UncServerName,
            REMSmb_DosPrintQContinue_P,  // parm desc
            NULL,  // no data desc 16
            NULL,  // no data desc 32
            NULL,  // no data desc SMB
            NULL,  // no aux desc 16
            NULL,  // no aux desc 32
            NULL,  // no aux desc SMB
            FALSE, // not a null session API
            // rest of API's arguments, in 32-bit LM2.x format:
            QueueName));

} // RxPrintQContinue


SPLERR SPLENTRY
RxPrintQDel(
    IN LPWSTR UncServerName,
    IN LPWSTR QueueName
    )
{
    return (RxRemoteApi(
            API_WPrintQDel,  // API number
            (LPTSTR) UncServerName,
            REMSmb_DosPrintQDel_P,  // parm desc
            NULL,  // no data desc 16
            NULL,  // no data desc 32
            NULL,  // no data desc SMB
            NULL,  // no aux desc 16
            NULL,  // no aux desc 32
            NULL,  // no aux desc SMB
            FALSE, // not a null session API
            // rest of API's arguments, in 32-bit LM2.x format:
            QueueName));

} // RxPrintQDel


SPLERR SPLENTRY
RxPrintQEnum(
    IN LPWSTR UncServerName,
    IN DWORD Level,
    OUT LPBYTE Buffer,
    IN DWORD BufferSize,
    OUT LPDWORD EntriesRead,
    OUT LPDWORD EntriesAvail
    )
{
    DWORD  ActualEntries = 0;
    LPDESC AuxDesc16,  AuxDesc32,  AuxDescSmb;
    LPDESC DataDesc16, DataDesc32, DataDescSmb;
    DWORD  SafeEntries;
    LPVOID SafeLevelBuffer = NULL;
    NET_API_STATUS Status;

    Status = RxpGetPrintQInfoDescs(
        Level,
        FALSE,    // this is not an add or set API.
        & DataDesc16,
        & DataDesc32,
        & DataDescSmb,
        & AuxDesc16,
        & AuxDesc32,
        & AuxDescSmb);
    if (Status != NERR_Success) {
        return (Status);
    }

    //
    // Assume normal call, on assumption that we won't run into WFW 3.1
    //

    Status = RxRemoteApi(
            API_WPrintQEnum,  // API number
            (LPTSTR) UncServerName,
            REMSmb_DosPrintQEnum_P,  // parm desc
            DataDesc16,
            DataDesc32,
            DataDescSmb,
            AuxDesc16,
            AuxDesc32,
            AuxDescSmb,
            0,                          // flags: not a null session API
            // rest of API's arguments, in 32-bit LM2.x format:
            Level,
            Buffer,
            BufferSize,
            &ActualEntries,
            EntriesAvail);

    //
    // Check for a nasty WFW 3.1 bug: for level 0, with multiple queues,
    // one or more queue names are garbage.  (I've seen garbage "zzzzWWzzl"
    // come back, in particular.)  If we might have gotten this,
    // then retry with a safe info level.  Since level 0 is just short queue
    // names, and level 1 is a superset of that, we can make one from the other.
    //

    if ( (!RxpFatalErrorCode(Status))
         && (Level == 0)
         && (ActualEntries > 1 ) ) {

        LPCTSTR         OutEntry = (LPVOID) Buffer;
        DWORD           SafeAvail;
        PPRQINFO        SafeEntry;
        const DWORD     SafeLevel = 1;
        DWORD           SafeLevelEntrySize;
        DWORD           SafeLevelBufferSize;

RetryTheApi:

        //
        // Avoid pointer faults below if caller's buffer isn't large enough.
        //

        if ( (ActualEntries * (LM20_QNLEN+1) * sizeof(TCHAR)) > BufferSize ) {
            Status = NERR_BufTooSmall;
            goto Cleanup;
        }

        //
        // Compute area needed for safe array, and allocate it.
        //

        (VOID) NetpPrintQStructureInfo(
                SafeLevel,
                PARMNUM_ALL,
                TRUE,                   // Yes, we need native size
                FALSE,                  // not add or setinfo API
                sizeof(TCHAR),          // size of chars wanted
                NULL,                   // don't need DataDesc16 OPTIONAL,
                NULL,                   // don't need DataDesc32 OPTIONAL,
                NULL,                   // don't need DataDescSmb OPTIONAL,
                NULL,                   // don't need AuxDesc16 OPTIONAL,
                NULL,                   // don't need AuxDesc32 OPTIONAL,
                NULL,                   // don't need AuxDescSmb OPTIONAL,
                &SafeLevelEntrySize,    // need max size
                NULL,                   // don't need size of fixed part
                NULL );                 // don't need size of string area
        NetpAssert( SafeLevelEntrySize > 0 );
        SafeLevelBufferSize = ActualEntries * SafeLevelEntrySize;
        NetpAssert( SafeLevelBufferSize > 0 );

        SafeLevelBuffer = NetpMemoryAllocate( SafeLevelBufferSize );
        if (SafeLevelBuffer == NULL) {
            Status = ERROR_NOT_ENOUGH_MEMORY;
            goto Cleanup;
        }

        //
        // Do recursive call, to get queues at safe info level.
        //

        Status = RxPrintQEnum(
                UncServerName,
                SafeLevel,              // level we want
                SafeLevelBuffer,        // buffer to fill in
                SafeLevelBufferSize,
                &SafeEntries,
                &SafeAvail );

        if ( Status == ERROR_MORE_DATA) {

            if (SafeLevelBuffer != NULL) {
                NetpMemoryFree( SafeLevelBuffer );
            }
            SafeLevelBuffer = NULL;

            if (SafeAvail > ActualEntries) {
                // Retry if queue was added.
                ActualEntries = SafeAvail;
                goto RetryTheApi;
            } else {
                // Not enough information to know what to do differently.
                NetpKdPrint(( PREFIX_NETAPI
                       "RxPrintQEnum: WFW workaround failed, error more data "
                       "but should have been enough!\n" ));
                Status = NERR_InternalError;
                goto Cleanup;
            }
        }
        if ( RxpFatalErrorCode( Status ) ) {
            NetpKdPrint(( PREFIX_NETAPI
                   "RxPrintQEnum: WFW workaround failed, API status="
                   FORMAT_API_STATUS ".\n", Status ));
            goto Cleanup;
        }

        if (SafeEntries==0) {
            // Deleted them all of a sudden?  OK, I guess.
            ActualEntries = 0;
            goto Cleanup;
        }

        //
        // Convert safe info level to desired info level.
        //

        ActualEntries = 0;
        SafeEntry = (LPVOID) SafeLevelBuffer;
        do {

            LPCTSTR SafeQueueName;
            SafeQueueName = SafeEntry->szName;
            NetpAssert( SafeQueueName != NULL );
            if ( (*SafeQueueName) == TCHAR_EOS) {
                NetpKdPrint(( PREFIX_NETAPI
                       "RxPrintQEnum: WFW workaround failed, got empty "
                       "queue name anyway.\n" ));
                Status = NERR_InternalError;
                goto Cleanup;
            }

            if ( STRLEN( SafeQueueName ) < LM20_QNLEN ) {

                if (NetpIsPrintQueueNameValid( SafeQueueName ) ) {
                    // Hey, it's short and valid.  Copy it over.

                    (VOID) STRCPY(
                            (LPTSTR) OutEntry,         // dest
                            (LPTSTR) SafeQueueName );  // src

                    OutEntry += (LM20_QNLEN+1);
                    ++ActualEntries;
                } else {
                    NetpKdPrint(( PREFIX_NETAPI
                           "RxPrintQEnum: WFW workaround failed, got bad "
                           "queue name anyway.\n" ));
                    Status = NERR_InternalError;
                    goto Cleanup;
                }

            }


            --SafeEntries;
            ++SafeEntry;

        } while (SafeEntries > 0);

    }

Cleanup:
    NetpSetOptionalArg( EntriesRead, ActualEntries );
    if (SafeLevelBuffer != NULL) {
        NetpMemoryFree( SafeLevelBuffer );
    }
    return (Status);

} // RxPrintQEnum


SPLERR SPLENTRY
RxPrintQGetInfo(
    IN LPWSTR UncServerName,
    IN LPWSTR QueueName,
    IN DWORD Level,
    OUT LPBYTE Buffer,
    IN DWORD BufferSize,
    OUT LPDWORD BytesNeeded   // estimated (probably too large).
    )
{
    LPDESC AuxDesc16,  AuxDesc32,  AuxDescSmb;
    LPDESC DataDesc16, DataDesc32, DataDescSmb;
    DWORD BytesNeeded16;
    DWORD EdittedBufferSize;
    NET_API_STATUS Status;

    NetpAssert(UncServerName != NULL);
    NetpAssert(*UncServerName != '\0');

    Status = RxpGetPrintQInfoDescs(
        Level,
        FALSE,   // not an add or set API.
        & DataDesc16,
        & DataDesc32,
        & DataDescSmb,
        & AuxDesc16,
        & AuxDesc32,
        & AuxDescSmb);
    if (Status != NERR_Success) {
        return (Status);
    }
    NetpAssert( DataDesc16 != NULL );
    NetpAssert( DataDesc32 != NULL );
    NetpAssert( DataDescSmb != NULL );

    if (BufferSize <= MAX_TRANSACT_RET_DATA_SIZE) {
        EdittedBufferSize = BufferSize;
    } else {
        EdittedBufferSize = MAX_TRANSACT_RET_DATA_SIZE;
    }

    Status = RxRemoteApi(
        API_WPrintQGetInfo,
        (LPTSTR) UncServerName,
        REMSmb_DosPrintQGetInfo_P,
        DataDesc16,
        DataDesc32,
        DataDescSmb,
        AuxDesc16,
        AuxDesc32,
        AuxDescSmb,
        FALSE,  // not a null session API.
        // rest of API's arguments in LM 2.x format:
        QueueName,
        Level,
        Buffer,
        EdittedBufferSize,
        & BytesNeeded16);  // downlevel buffer size needed.

    // If ERROR_MORE_DATA, convert BytesNeeded to native num.
    if ( (Status == ERROR_MORE_DATA) || (Status == NERR_BufTooSmall) ) {
        *BytesNeeded = RxpEstimateBytesNeeded(BytesNeeded16);
    } else {
        *BytesNeeded = BufferSize;
    }

    IF_DEBUG(PRTQ) {
        NetpKdPrint(( PREFIX_NETAPI "RxPrintQGetInfo: returned, status is "
                FORMAT_API_STATUS "\n", Status));
    }

    // Return results of RxRemoteApi call.
    return (Status);

} // RxPrintQGetInfo

SPLERR SPLENTRY
RxPrintQPause(
    IN LPWSTR UncServerName,
    IN LPWSTR QueueName
    )
{
    return (RxRemoteApi(
            API_WPrintQPause,  // API number
            (LPTSTR) UncServerName,
            REMSmb_DosPrintQPause_P,  // parm desc
            NULL,  // no data desc 16
            NULL,  // no data desc 32
            NULL,  // no data desc SMB
            NULL,  // no aux desc 16
            NULL,  // no aux desc 32
            NULL,  // no aux desc SMB
            FALSE, // not a null session API
            // rest of API's arguments, in 32-bit LM2.x format:
            QueueName));

} // RxPrintQPause

SPLERR SPLENTRY
RxPrintQPurge(
    IN LPWSTR UncServerName,
    IN LPWSTR QueueName
    )
{
    return (RxRemoteApi(
            API_WPrintQPurge,  // API number
            (LPTSTR) UncServerName,
            REMSmb_DosPrintQPurge_P,  // parm desc
            NULL,  // no data desc 16
            NULL,  // no data desc 32
            NULL,  // no data desc SMB
            NULL,  // no aux desc 16
            NULL,  // no aux desc 32
            NULL,  // no aux desc SMB
            FALSE, // not a null session API
            // rest of API's arguments, in 32-bit LM2.x format:
            QueueName));

} // RxPrintQPurge


SPLERR SPLENTRY
RxPrintQSetInfo(
    IN LPWSTR UncServerName,
    IN LPWSTR QueueName,
    IN DWORD Level,
    IN LPBYTE Buffer,
    IN DWORD BufferSize,
    IN DWORD ParmNum
    )
{
    LPDESC AuxDesc16,  AuxDesc32,  AuxDescSmb;
    LPDESC DataDesc16, DataDesc32, DataDescSmb;
    NET_API_STATUS Status;

    NetpAssert(UncServerName != NULL);
    NetpAssert(*UncServerName != '\0');

    Status = RxpGetPrintQInfoDescs(
            Level,
            TRUE,                       // This is a setinfo API.
            & DataDesc16,
            & DataDesc32,
            & DataDescSmb,
            & AuxDesc16,
            & AuxDesc32,
            & AuxDescSmb);
    if (Status != NERR_Success) {
        return (Status);
    }

    if (ParmNum == PARMNUM_ALL) {
        Status = RxRemoteApi(
                API_WPrintQSetInfo,   // API number
                (LPTSTR) UncServerName,
                REMSmb_DosPrintQSetInfo_P,  // parm desc
                DataDesc16,
                DataDesc32,
                DataDescSmb,
                AuxDesc16,
                AuxDesc32,
                AuxDescSmb,
                FALSE,                  // not a null session API
                // rest of API's arguments, in 32-bit LM 2.x format:
                QueueName,
                Level,
                Buffer,
                BufferSize,
                ParmNum);
    } else {
        DWORD FieldIndex;

        // Compute field index from parmnum and level.
        NetpAssert( (Level==1) || (Level==3) );  // Already verified.
        switch (ParmNum) {
        case PRQ_PRIORITY_PARMNUM :
            if (Level==1) {
                FieldIndex = PRQ_PRIORITY_LVL1_FIELDINDEX;
            } else {
                FieldIndex = PRQ_PRIORITY_LVL3_FIELDINDEX;
            }
            break;
        case PRQ_STARTTIME_PARMNUM :
            if (Level==1) {
                FieldIndex = PRQ_STARTTIME_LVL1_FIELDINDEX;
            } else {
                FieldIndex = PRQ_STARTTIME_LVL3_FIELDINDEX;
            }
            break;
        case PRQ_UNTILTIME_PARMNUM :
            if (Level==1) {
                FieldIndex = PRQ_UNTILTIME_LVL1_FIELDINDEX;
            } else {
                FieldIndex = PRQ_UNTILTIME_LVL3_FIELDINDEX;
            }
            break;
        case PRQ_SEPARATOR_PARMNUM :
            if (Level==1) {
                FieldIndex = PRQ_SEPARATOR_LVL1_FIELDINDEX;
            } else {
                FieldIndex = PRQ_SEPARATOR_LVL3_FIELDINDEX;
            }
            break;
        case PRQ_PROCESSOR_PARMNUM :
            if (Level==1) {
                FieldIndex = PRQ_PROCESSOR_LVL1_FIELDINDEX;
            } else {
                FieldIndex = PRQ_PROCESSOR_LVL3_FIELDINDEX;
            }
            break;
        case PRQ_DESTINATIONS_PARMNUM :
            if (Level==1) {
                FieldIndex = PRQ_DESTINATIONS_LVL1_FIELDINDEX;
            } else {
                return (ERROR_INVALID_LEVEL);
            }
            break;
        case PRQ_PARMS_PARMNUM :
            if (Level==1) {
                FieldIndex = PRQ_PARMS_LVL1_FIELDINDEX;
            } else {
                FieldIndex = PRQ_PARMS_LVL3_FIELDINDEX;
            }
            break;
        case PRQ_COMMENT_PARMNUM :
            if (Level==1) {
                FieldIndex = PRQ_COMMENT_LVL1_FIELDINDEX;
            } else {
                FieldIndex = PRQ_COMMENT_LVL3_FIELDINDEX;
            }
            break;
        case PRQ_PRINTERS_PARMNUM :
            if (Level==1) {
                return (ERROR_INVALID_LEVEL);
            } else {
                FieldIndex = PRQ_PRINTERS_LVL3_FIELDINDEX;
            }
            break;
        case PRQ_DRIVERDATA_PARMNUM :
            // Can't set driver data from NT
            /* FALLTHROUGH */

        default :
            IF_DEBUG(PRTQ) {
                NetpKdPrint(( PREFIX_NETAPI
                        "RxPrintQSetInfo: invalid (bad parmnum).\n" ));
            }
            return (ERROR_INVALID_PARAMETER);
        }

        Status = RxpSetField (
                API_WPrintQSetInfo,     // API number
                UncServerName,
                "z",                    // object's desc
                QueueName,           // object to set
                REMSmb_DosPrintQSetInfo_P,  // parm desc
                DataDesc16,
                DataDesc32,
                DataDescSmb,
                (LPVOID) Buffer,        // native info buffer
                ParmNum,                // parm num to send
                FieldIndex,             // field index
                Level);
    }

    return (Status);

} // RxPrintQSetInfo
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\rpcxlate\rxapi\prtjob.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    PrtJob.c

Abstract:

    This module provides RpcXlate support for the DosPrint APIs.

Author:

    John Rogers (JohnRo) 20-May-1991

Environment:

    Portable to any flat, 32-bit environment.  (Uses Win32 typedefs.)
    Requires ANSI C extensions: slash-slash comments, long external names.


Revision History:

    20-May-1991 JohnRo
        Created.
    21-May-1991 JohnRo
        Added RxPrintJobDel().  Added module header.  Explicitly fail enum
        attempt for level 3.
    21-May-1991 JohnRo
        Added RxPrintJobGetInfo support.
    22-May-1991 JohnRo
        Added RxPrintJobPause and RxPrintJobContinue support.
        Moved RxPrintJobDel into its place in alphabetical order.
        Added IN, OUT, and OPTIONAL where applicable.
    26-May-1991 JohnRo
        Minor parm list changes: use LPBYTE and LPTSTR where possible.
    16-Jul-1991 JohnRo
        Added RxPrintJobSetInfo support.
        Added hex dump of job info in RxPrintJobGetInfo.
    17-Jul-1991 JohnRo
        Extracted RxpDebug.h from Rxp.h.
    21-Nov-1991 JohnRo
        Removed NT dependencies to reduce recompiles.

--*/


// These must be included first:

#include <windef.h>             // IN, LPTSTR, etc.
#include <lmcons.h>             // NET_API_STATUS, etc.

// These may be included in any order:

#include <apinums.h>            // API_ equates.
#include <lmerr.h>              // NERR_ and ERROR_ equates.
#include <netdebug.h>           // DBGSTATIC, NetpAssert().
#include <netlib.h>             // NetpSetOptionalArg().
#include <rap.h>                // RapValueWouldBeTruncated().
#include <remdef.h>             // REM16_, REMSmb_, field index equates.
#include <rx.h>                 // RxRemoteApi().
#include <rxp.h>                // RxpEstimatedBytesNeeded().
#include <rxpdebug.h>           // IF_DEBUG().
#include <rxprint.h>            // My prototypes.


DBGSTATIC NET_API_STATUS
RxpGetPrintJobInfoDescs(
    IN DWORD InfoLevel,
    IN BOOL SetInfoApi,
    OUT LPDESC * DataDesc16 OPTIONAL,
    OUT LPDESC * DataDesc32 OPTIONAL,
    OUT LPDESC * DataDescSmb OPTIONAL
    )
{
    switch (InfoLevel) {
    case 0 :
        if (SetInfoApi == TRUE) {
            return (ERROR_INVALID_LEVEL);
        }
        NetpSetOptionalArg(DataDesc16, REM16_print_job_0);
        NetpSetOptionalArg(DataDesc32, REM32_print_job_0);
        NetpSetOptionalArg(DataDescSmb, REMSmb_print_job_0);
        return (NERR_Success);
    case 1 :
        NetpSetOptionalArg(DataDesc16, REM16_print_job_1);
        NetpSetOptionalArg(DataDesc32, REM32_print_job_1);
        NetpSetOptionalArg(DataDescSmb, REMSmb_print_job_1);
        return (NERR_Success);
    case 2 :
        if (SetInfoApi == TRUE) {
            return (ERROR_INVALID_LEVEL);
        }
        NetpSetOptionalArg(DataDesc16, REM16_print_job_2);
        NetpSetOptionalArg(DataDesc32, REM32_print_job_2);
        NetpSetOptionalArg(DataDescSmb, REMSmb_print_job_2);
        return (NERR_Success);
    case 3 :
        NetpSetOptionalArg(DataDesc16, REM16_print_job_3);
        NetpSetOptionalArg(DataDesc32, REM32_print_job_3);
        NetpSetOptionalArg(DataDescSmb, REMSmb_print_job_3);
        return (NERR_Success);
    default :
        return (ERROR_INVALID_LEVEL);
    }
    /* NOTREACHED */
} // RxpGetPrintJobInfoDescs


SPLERR SPLENTRY
RxPrintJobContinue(
    IN LPTSTR pszServer,
    IN DWORD uJobId
    )
{
    NET_API_STATUS Status;
    NetpAssert(pszServer != NULL);
    NetpAssert(*pszServer != '\0');

    Status = RxRemoteApi(
            API_WPrintJobContinue,
            pszServer,
            REMSmb_DosPrintJobContinue_P,    // parm desc
            NULL,                       // no data desc (16-bit)
            NULL,                       // no data desc (32-bit)
            NULL,                       // no data desc (SMB version)
            NULL,                       // no aux data desc 16
            NULL,                       // no aux data desc 32
            NULL,                       // no aux data desc SMB
            FALSE,                      // not a null session API
            // rest of LM2.x API's arguments, in 32-bit format:
            uJobId);
    return (Status);
} // RxPrintJobContinue


SPLERR SPLENTRY
RxPrintJobDel(
    IN LPTSTR pszServer,
    IN DWORD uJobId
    )
{
    NET_API_STATUS Status;
    NetpAssert(pszServer != NULL);
    NetpAssert(*pszServer != '\0');

    Status = RxRemoteApi(
            API_WPrintJobDel,
            pszServer,
            REMSmb_DosPrintJobDel_P,    // parm desc
            NULL,                       // no data desc (16-bit)
            NULL,                       // no data desc (32-bit)
            NULL,                       // no data desc (SMB version)
            NULL,                       // no aux data desc 16
            NULL,                       // no aux data desc 32
            NULL,                       // no aux data desc SMB
            FALSE,                      // not a null session API
            // rest of LM2.x API's arguments, in 32-bit format:
            uJobId);
    return (Status);
} // RxPrintJobDel


SPLERR SPLENTRY
RxPrintJobEnum(
    IN LPTSTR pszServer,
    IN LPTSTR pszQueueName,
    IN DWORD uLevel,
    OUT LPBYTE pbBuf,
    IN DWORD cbBuf,
    OUT LPDWORD pcReturned,
    OUT LPDWORD TotalEntries
    )
{
    LPDESC DataDesc16, DataDesc32, DataDescSmb;
    NET_API_STATUS Status;

    NetpAssert(pszServer != NULL);
    NetpAssert(*pszServer != '\0');

    Status = RxpGetPrintJobInfoDescs(
            uLevel,
            FALSE,                      // not a setinfo API.
            & DataDesc16,
            & DataDesc32,
            & DataDescSmb);
    if (Status != NERR_Success) {
        return (Status);
    }

    // DosPrintJobEnum does not support level 3, despite what Ralph Ryan's
    // book says.  I (JohnRo) have tried it, and DaveSn has looked at the
    // source code.  So, we might as well check for it here.
    if (uLevel == 3) {
        return (ERROR_INVALID_LEVEL);
    }

    Status = RxRemoteApi(
            API_WPrintJobEnum,
            pszServer,
            REMSmb_DosPrintJobEnum_P,
            DataDesc16,
            DataDesc32,
            DataDescSmb,
            NULL,                       // no aux desc 16
            NULL,                       // no aux desc 32
            NULL,                       // no aux desc SMB
            FALSE,                      // not a null session API.
            // rest of API's arguments, in 32-bit LM 2.x form:
            pszQueueName,
            uLevel,
            pbBuf,
            cbBuf,
            pcReturned,
            TotalEntries);
    return (Status);

} // RxPrintJobEnum


SPLERR SPLENTRY
RxPrintJobGetInfo(
    IN LPTSTR pszServer,
    IN DWORD uJobId,
    IN DWORD uLevel,
    OUT LPBYTE pbBuf,
    IN DWORD cbBuf,
    OUT LPDWORD BytesNeeded   // estimated (probably too large).
    )
{
    DWORD BytesNeeded16;
    LPDESC DataDesc16, DataDesc32, DataDescSmb;
    NET_API_STATUS Status;

    NetpAssert(pszServer != NULL);
    NetpAssert(*pszServer != '\0');

    Status = RxpGetPrintJobInfoDescs(
            uLevel,
            FALSE,                      // not a setinfo API
            & DataDesc16,
            & DataDesc32,
            & DataDescSmb);
    if (Status != NERR_Success) {
        return (Status);
    }

    Status = RxRemoteApi(
            API_WPrintJobGetInfo,
            pszServer,
            REMSmb_DosPrintJobGetInfo_P,
            DataDesc16,
            DataDesc32,
            DataDescSmb,
            NULL,                       // no aux desc 16
            NULL,                       // no aux desc 32
            NULL,                       // no aux desc SMB
            FALSE,                      // not a null session API.
            // rest of API's arguments, in LM 2.x form (32-bit version):
            uJobId,
            uLevel,
            pbBuf,
            cbBuf,
            & BytesNeeded16);  // downlevel buffer size needed.

    // If buffer too small, convert BytesNeeded to native num.
    if ( (Status == ERROR_MORE_DATA) || (Status == NERR_BufTooSmall) ) {
        *BytesNeeded = RxpEstimateBytesNeeded(BytesNeeded16);
    } else {
        *BytesNeeded = cbBuf;
    }

    IF_DEBUG(PRTJOB) {
        NetpKdPrint(( "RxPrintJobGetInfo: output (level " FORMAT_DWORD "):\n",
                uLevel ));
        NetpDbgHexDump( (LPVOID) pbBuf, *BytesNeeded );
    }
    return (Status);

} // RxPrintJobGetInfo


SPLERR SPLENTRY
RxPrintJobPause(
    IN LPTSTR pszServer,
    IN DWORD uJobId
    )
{
    NET_API_STATUS Status;
    NetpAssert(pszServer != NULL);
    NetpAssert(*pszServer != '\0');

    Status = RxRemoteApi(
            API_WPrintJobPause,
            pszServer,
            REMSmb_DosPrintJobPause_P,  // parm desc
            NULL,                       // no data desc (16-bit)
            NULL,                       // no data desc (32-bit)
            NULL,                       // no data desc (SMB version)
            NULL,                       // no aux data desc 16
            NULL,                       // no aux data desc 32
            NULL,                       // no aux data desc SMB
            FALSE,                      // not a null session API
            // rest of LM2.x API's arguments, in 32-bit format:
            uJobId);
    return (Status);

} // RxPrintJobPause


SPLERR SPLENTRY
RxPrintJobSetInfo(
    IN LPTSTR UncServerName,
    IN DWORD JobId,
    IN DWORD Level,
    IN LPBYTE Buffer,
    IN DWORD BufferSize,
    IN DWORD ParmNum
    )
{
    LPDESC DataDesc16, DataDesc32, DataDescSmb;
    NET_API_STATUS Status;

    NetpAssert(UncServerName != NULL);
    NetpAssert(*UncServerName != '\0');

    Status = RxpGetPrintJobInfoDescs(
            Level,
            TRUE,                       // This is a setinfo API.
            & DataDesc16,
            & DataDesc32,
            & DataDescSmb);
    if (Status != NERR_Success) {
        return (Status);
    }

    if (ParmNum == PARMNUM_ALL) {
        Status = RxRemoteApi(
                API_WPrintJobSetInfo,   // API number
                UncServerName,
                REMSmb_DosPrintJobSetInfo_P,  // parm desc
                DataDesc16,
                DataDesc32,
                DataDescSmb,
                NULL,                   // no aux desc 16
                NULL,                   // no aux desc 32
                NULL,                   // no aux desc SMB
                FALSE,                  // not a null session API
                // rest of API's arguments, in 32-bit LM 2.x format:
                JobId,
                Level,
                Buffer,
                BufferSize,
                ParmNum);
    } else {
        WORD DownLevelJobId;
        DWORD FieldIndex;
        if (RapValueWouldBeTruncated(JobId)) {
            IF_DEBUG(PRTJOB) {
                NetpKdPrint(( "RxPrintJobSetInfo: invalid (ID trunc).\n" ));
            }
            return (ERROR_INVALID_PARAMETER);
        }

        // Compute field index from parmnum and level.
        NetpAssert( (Level==1) || (Level==3) );  // Already verified.
        switch (ParmNum) {
        case PRJ_NOTIFYNAME_PARMNUM :
            if (Level==1) {
                FieldIndex = PRJ_NOTIFYNAME_LVL1_FIELDINDEX;
            } else {
                FieldIndex = PRJ_NOTIFYNAME_LVL3_FIELDINDEX;
            }
            break;
        case PRJ_DATATYPE_PARMNUM :
            if (Level==1) {
                FieldIndex = PRJ_DATATYPE_LVL1_FIELDINDEX;
            } else {
                FieldIndex = PRJ_DATATYPE_LVL3_FIELDINDEX;
            }
            break;
        case PRJ_PARMS_PARMNUM :
            if (Level==1) {
                FieldIndex = PRJ_PARMS_LVL1_FIELDINDEX;
            } else {
                FieldIndex = PRJ_PARMS_LVL3_FIELDINDEX;
            }
            break;
        case PRJ_POSITION_PARMNUM :
            if (Level==1) {
                FieldIndex = PRJ_POSITION_LVL1_FIELDINDEX;
            } else {
                FieldIndex = PRJ_POSITION_LVL3_FIELDINDEX;
            }
            break;
        case PRJ_COMMENT_PARMNUM :
            if (Level==1) {
                FieldIndex = PRJ_COMMENT_LVL1_FIELDINDEX;
            } else {
                FieldIndex = PRJ_COMMENT_LVL3_FIELDINDEX;
            }
            break;
        case PRJ_DOCUMENT_PARMNUM :
            if (Level==1) {
                return (ERROR_INVALID_LEVEL);
            } else {
                FieldIndex = PRJ_DOCUMENT_LVL3_FIELDINDEX;
            }
            break;
        case PRJ_PRIORITY_PARMNUM :
            if (Level==1) {
                return (ERROR_INVALID_LEVEL);
            } else {
                FieldIndex = PRJ_PRIORITY_LVL3_FIELDINDEX;
            }
            break;
        case PRJ_PROCPARMS_PARMNUM :
            if (Level==1) {
                return (ERROR_INVALID_LEVEL);
            } else {
                FieldIndex = PRJ_PROCPARMS_LVL3_FIELDINDEX;
            }
            break;
        case PRJ_DRIVERDATA_PARMNUM :
            // Can't set driver data from NT
            /* FALLTHROUGH */

        default :
            IF_DEBUG(PRTJOB) {
                NetpKdPrint(( "RxPrintJobSetInfo: invalid (bad parmnum).\n" ));
            }
            return (ERROR_INVALID_PARAMETER);
        }

        DownLevelJobId = (WORD) JobId;
        Status = RxpSetField (
                API_WPrintJobSetInfo,   // API number
                UncServerName,
                "w",                    // object's desc
                & DownLevelJobId,       // object to set
                REMSmb_DosPrintJobSetInfo_P,  // parm desc
                DataDesc16,
                DataDesc32,
                DataDescSmb,
                (LPVOID) Buffer,        // native info buffer
                ParmNum,                // parm num to send
                FieldIndex,             // field index
                Level);
    }

    return (Status);

} // RxPrintJobSetInfo
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\rpcxlate\rxapi\fileenum.c ===
/*++

Copyright (c) 1987-91  Microsoft Corporation

Module Name:

    FileEnum.c

Abstract:

    This file contains the RpcXlate code to handle the File APIs.

Author:

    John Rogers (JohnRo) 05-Sep-1991

Environment:

    Portable to any flat, 32-bit environment.  (Uses Win32 typedefs.)
    Requires ANSI C extensions: slash-slash comments, long external names.

Revision History:

    05-Sep-1991 JohnRo
        Created.
    21-Nov-1991 JohnRo
        Removed NT dependencies to reduce recompiles.

--*/

// These must be included first:

#include <windef.h>             // IN, DWORD, etc.
#include <lmcons.h>             // DEVLEN, NET_API_STATUS, etc.

// These may be included in any order:

#include <apinums.h>            // API_ equates.
#include <lmerr.h>              // ERROR_ and NERR_ equates.
#include <netdebug.h>           // NetpAssert(), NetpKdPrint(()).
#include <netlib.h>             // NetpMemoryAllocate(), NetpMemoryFree().
#include <rap.h>                // LPDESC.
#include <remdef.h>             // REM16_, REM32_, REMSmb_ equates.
#include <rx.h>                 // RxRemoteApi().
#include <rxfile.h>             // My prototype(s).
#include <rxpdebug.h>           // IF_DEBUG().
#include <string.h>             // memset().
#include <strucinf.h>           // NetpFileStructureInfo().


// Excerpts from LM 2.x Shares.h:
//
// typedef struct res_file_enum_2 FRK;
//
// #define FRK_INIT( f )
//         {
//                 (f).res_pad = 0L;
//                 (f).res_fs = 0;
//                 (f).res_pro = 0;
//         }

#define LM20_FRK_LEN                 8

#define LM20_FRK_INIT( f ) \
        { (void) memset( (f), '\0', LM20_FRK_LEN ); }


NET_API_STATUS
RxNetFileEnum (
    IN LPTSTR UncServerName,
    IN LPTSTR BasePath OPTIONAL,
    IN LPTSTR UserName OPTIONAL,
    IN DWORD Level,
    OUT LPBYTE *BufPtr,
    IN DWORD PreferedMaximumSize,
    OUT LPDWORD EntriesRead,
    OUT LPDWORD TotalEntries,
    IN OUT PDWORD_PTR ResumeHandle OPTIONAL
    )

/*++

Routine Description:

    RxNetFileEnum performs the same function as NetFileEnum,
    except that the server name is known to refer to a downlevel server.

Arguments:

    (Same as NetFileEnum, except UncServerName must not be null, and
    must not refer to the local computer.)

Return Value:

    (Same as NetFileEnum.)

--*/

{

#define DumpResumeKey( label ) \
    { \
        IF_DEBUG(FILE) { \
            NetpKdPrint(( "RxNetFileEnum: resume key " label \
            " call to RxRemoteApi:\n" )); \
        NetpDbgHexDump( DownLevelResumeKey, LM20_FRK_LEN ); \
        } \
    }

    LPDESC DataDesc16;
    LPDESC DataDesc32;
    LPDESC DataDescSmb;
    LPBYTE DownLevelResumeKey;
    NET_API_STATUS Status;

    UNREFERENCED_PARAMETER(ResumeHandle);

    // Make sure caller didn't mess up.
    NetpAssert(UncServerName != NULL);
    if (BufPtr == NULL) {
        return (ERROR_INVALID_PARAMETER);
    }

    // Assume something might go wrong, and make error paths easier to
    // code.  Also, check for a bad pointer before we do anything.
    *BufPtr = NULL;

    //
    // Set up downlevel resume handle.
    //
    NetpAssert( sizeof(DWORD) >= sizeof(LPVOID) );
    if (ResumeHandle != NULL) {

        if (*ResumeHandle == 0) {

            // First time through, so we have to allocate.
            DownLevelResumeKey = NetpMemoryAllocate( LM20_FRK_LEN );
            if (DownLevelResumeKey == NULL) {
                return (ERROR_NOT_ENOUGH_MEMORY);
            }
            *ResumeHandle = (DWORD_PTR) DownLevelResumeKey;
            LM20_FRK_INIT( DownLevelResumeKey );

        } else {

            // Use existing downlevel handle.
            DownLevelResumeKey = (LPBYTE) *ResumeHandle;
        }
    } else {

        // No resume handle, so create one temporarily.
        DownLevelResumeKey = NetpMemoryAllocate( LM20_FRK_LEN );
        if (DownLevelResumeKey == NULL) {
            return (ERROR_NOT_ENOUGH_MEMORY);
        }
        LM20_FRK_INIT( DownLevelResumeKey );
    }
    NetpAssert( DownLevelResumeKey != NULL );

    //
    // Get descriptors for this info level.
    //
    Status = NetpFileStructureInfo (
            Level,
            PARMNUM_ALL,                // want all fields.
            TRUE,                       // want native sizes (really don't care)
            & DataDesc16,
            & DataDesc32,
            & DataDescSmb,
            NULL,                       // don't need max size
            NULL,                       // don't need fixed size
            NULL                        // don't need string size
            );
    if (Status != NERR_Success) {
        *BufPtr = NULL;
        return (Status);
    }
    NetpAssert( DataDesc16 != NULL );
    NetpAssert( DataDesc32 != NULL );
    NetpAssert( DataDescSmb != NULL );
    NetpAssert( *DataDesc16 != '\0' );
    NetpAssert( *DataDesc32 != '\0' );
    NetpAssert( *DataDescSmb != '\0' );

    if (DataDesc16) {
        NetpKdPrint(( "NetpFileStructureInfo: desc 16 is " FORMAT_LPDESC ".\n",
                DataDesc16 ));
    }
    if (DataDesc32) {
        NetpKdPrint(( "NetpFileStructureInfo: desc 32 is " FORMAT_LPDESC ".\n",
                DataDesc32 ));
    }
    if (DataDescSmb) {
        NetpKdPrint(( "NetpFileStructureInfo: desc Smb is " FORMAT_LPDESC ".\n",
                DataDescSmb ));
    }


    //
    // Remote the API, which will allocate the array for us.
    //

    DumpResumeKey( "before" );
    Status = RxRemoteApi(
            API_WFileEnum2,         // api number
            UncServerName,          // \\servername
            REMSmb_NetFileEnum2_P,  // parm desc (SMB version)
            DataDesc16,
            DataDesc32,
            DataDescSmb,
            NULL,                   // no aux desc 16
            NULL,                   // no aux desc 32
            NULL,                   // no aux desc SMB
            ALLOCATE_RESPONSE,      // we want array allocated for us
            // rest of API's arguments in 32-bit LM 2.x format:
            BasePath,
            UserName,
            Level,                  // sLevel: info level
            BufPtr,                 // pbBuffer: info lvl array (alloc for us)
            PreferedMaximumSize,    // cbBuffer: info lvl array len
            EntriesRead,            // pcEntriesRead
            TotalEntries,           // pcTotalAvail
            DownLevelResumeKey,     // pResumeKey (input)
            DownLevelResumeKey);    // pResumeKey (output)
    DumpResumeKey( "after" );

    //
    // Clean up resume key if necessary.
    //
    if ( (Status != ERROR_MORE_DATA) || (ResumeHandle == NULL) ) {

        // Error or all done.
        NetpMemoryFree( DownLevelResumeKey );

        if (ResumeHandle != NULL) {
            *ResumeHandle = 0;
        }

    } else {

        // More to come, so leave handle open for caller.
        NetpAssert( (*ResumeHandle) == (DWORD_PTR) DownLevelResumeKey );

    }

    return (Status);

} // RxNetFileEnum
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\rpcxlate\rxapi\prtdest.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    PrtDest.c

Abstract:

    This module provides RpcXlate support for the RxPrintDest APIs.

Author:

    John Rogers (JohnRo) 15-Jul-1991

Environment:

    Portable to any flat, 32-bit environment.  (Uses Win32 typedefs.)
    Requires ANSI C extensions: slash-slash comments, long external names.


Revision History:

    15-Jul-1991 JohnRo
        Created.
    16-Jul-1991 JohnRo
        Estimate bytes needed for print APIs.
    17-Jul-1991 JohnRo
        Extracted RxpDebug.h from Rxp.h.
    26-Aug-1991 JohnRo
        Reduce recompiles.

--*/


// These must be included first:

#include <windef.h>             // IN, LPTSTR, etc.
#include <lmcons.h>             // NET_API_STATUS, etc.

// These may be included in any order:

#include <apinums.h>            // API_ equates.
#include <lmerr.h>              // NERR_ and ERROR_ equates.
#include <netdebug.h>           // NetpAssert().
#include <remdef.h>             // REM16_, REMSmb_, equates.
#include <rx.h>                 // RxRemoteApi().
#include <rxp.h>                // RxpEstimatedBytesNeeded().
#include <rxprint.h>            // My prototypes.


DBGSTATIC NET_API_STATUS
RxpGetPrintDestInfoDescs(
    IN DWORD InfoLevel,
    IN BOOL AddOrSetInfoApi,
    OUT LPDESC * DataDesc16,
    OUT LPDESC * DataDesc32,
    OUT LPDESC * DataDescSmb
    )
{
    switch (InfoLevel) {
    case 0 :
        if (AddOrSetInfoApi == TRUE) {
            return (ERROR_INVALID_LEVEL);
        }
        *DataDesc16 = REM16_print_dest_0;
        *DataDesc32 = REM32_print_dest_0;
        *DataDescSmb = REMSmb_print_dest_0;
        return (NERR_Success);
    case 1 :
        if (AddOrSetInfoApi == TRUE) {
            return (ERROR_INVALID_LEVEL);
        }
        *DataDesc16 = REM16_print_dest_1;
        *DataDesc32 = REM32_print_dest_1;
        *DataDescSmb = REMSmb_print_dest_1;
        return (NERR_Success);
    case 2 :
        if (AddOrSetInfoApi == TRUE) {
            return (ERROR_INVALID_LEVEL);
        }
        *DataDesc16 = REM16_print_dest_2;
        *DataDesc32 = REM32_print_dest_2;
        *DataDescSmb = REMSmb_print_dest_2;
        return (NERR_Success);
    case 3 :
        *DataDesc16 = REM16_print_dest_3;
        *DataDesc32 = REM32_print_dest_3;
        *DataDescSmb = REMSmb_print_dest_3;
        return (NERR_Success);
    default :
        return (ERROR_INVALID_LEVEL);
    }
    /* NOTREACHED */
} // RxpGetPrintDestInfoDescs


SPLERR SPLENTRY
RxPrintDestAdd(
    IN LPTSTR pszServer,
    IN DWORD uLevel,
    IN LPBYTE pbBuf,
    IN DWORD cbBuf
    )
{
    LPDESC DataDesc16, DataDesc32, DataDescSmb;
    NET_API_STATUS Status;
    NetpAssert( pszServer != NULL );
    NetpAssert( *pszServer != '\0' );

    Status = RxpGetPrintDestInfoDescs(
            uLevel,
            TRUE,  // this is an Add or SetInfo API
            & DataDesc16,
            & DataDesc32,
            & DataDescSmb);
    if (Status != NERR_Success) {
        return (Status);
    }
    return( RxRemoteApi(
            API_WPrintDestAdd,
            pszServer,
            REMSmb_DosPrintDestAdd_P,
            DataDesc16,
            DataDesc32,
            DataDescSmb,
            NULL,   // no aux 16 desc
            NULL,   // no aux 32 desc
            NULL,   // no aux SMB desc
            FALSE,  // not a null session API
            // rest of API's arguments, in 32-bit LM 2.x format:
            uLevel,
            pbBuf,
            cbBuf) );
} // RxPrintDestAdd


SPLERR SPLENTRY
RxPrintDestControl(
    IN LPTSTR pszServer,
    IN LPTSTR pszDevName,
    IN DWORD uControl
    )
{
    NetpAssert( pszServer != NULL );
    NetpAssert( *pszServer != '\0' );

    return( RxRemoteApi(
            API_WPrintDestControl,
            pszServer,
            REMSmb_DosPrintDestControl_P,
            NULL,  // no data desc 16
            NULL,  // no data desc 32
            NULL,  // no data desc SMB
            NULL,  // no aux 16 desc
            NULL,  // no aux 32 desc
            NULL,  // no aux SMB desc
            FALSE,  // not a null session API
            // rest of API's arguments, in 32-bit LM 2.x format:
            pszDevName,
            uControl) );
} // RxPrintDestControl


SPLERR SPLENTRY
RxPrintDestDel(
    IN LPTSTR pszServer,
    IN LPTSTR pszPrinterName
    )
{
    NetpAssert( pszServer != NULL );
    NetpAssert( *pszServer != '\0' );

    return( RxRemoteApi(
            API_WPrintDestDel,
            pszServer,
            REMSmb_DosPrintDestDel_P,
            NULL,  // no data desc 16
            NULL,  // no data desc 32
            NULL,  // no data desc SMB
            NULL,  // no aux 16 desc
            NULL,  // no aux 32 desc
            NULL,  // no aux SMB desc
            FALSE,  // not a null session API
            // rest of API's arguments, in 32-bit LM 2.x format:
            pszPrinterName) );
} // RxPrintDestDel


SPLERR SPLENTRY
RxPrintDestEnum(
    IN LPTSTR pszServer,
    IN DWORD uLevel,
    OUT LPBYTE pbBuf,
    IN DWORD cbBuf,
    IN LPDWORD pcReturned,
    OUT LPDWORD TotalEntries
    )
{
    LPDESC DataDesc16, DataDesc32, DataDescSmb;
    NET_API_STATUS Status;
    NetpAssert( pszServer != NULL );
    NetpAssert( *pszServer != '\0' );

    if ( (pbBuf==NULL) || (cbBuf==0) ) {
        // Avoid assertion in common code (RxRemoteApi).
        return (ERROR_MORE_DATA);
    }

    Status = RxpGetPrintDestInfoDescs(
            uLevel,
            FALSE,  // not an add or setinfo API
            & DataDesc16,
            & DataDesc32,
            & DataDescSmb);
    if (Status != NERR_Success) {
        return (Status);
    }
    return( RxRemoteApi(
            API_WPrintDestEnum,
            pszServer,
            REMSmb_DosPrintDestEnum_P,
            DataDesc16,
            DataDesc32,
            DataDescSmb,
            NULL,  // no aux 16 desc
            NULL,  // no aux 32 desc
            NULL,  // no aux SMB desc
            FALSE,  // not a null session API
            // rest of API's arguments, in 32-bit LM 2.x format:
            uLevel,
            pbBuf,
            cbBuf,
            pcReturned,
            TotalEntries) );
} // RxPrintDestEnum


SPLERR SPLENTRY
RxPrintDestGetInfo(
    IN LPTSTR pszServer,
    IN LPTSTR pszName,
    IN DWORD uLevel,
    OUT LPBYTE pbBuf,
    IN DWORD cbBuf,
    OUT LPDWORD BytesNeeded   // estimated (probably too large).
    )
{
    DWORD BytesNeeded16;
    LPDESC DataDesc16, DataDesc32, DataDescSmb;
    NET_API_STATUS Status;

    NetpAssert( pszServer != NULL );
    NetpAssert( *pszServer != '\0' );

    Status = RxpGetPrintDestInfoDescs(
            uLevel,
            FALSE,  // not an add or setinfo API
            & DataDesc16,
            & DataDesc32,
            & DataDescSmb);
    if (Status != NERR_Success) {
        return (Status);
    }

    Status = RxRemoteApi(
            API_WPrintDestGetInfo,
            pszServer,
            REMSmb_DosPrintDestGetInfo_P,
            DataDesc16,
            DataDesc32,
            DataDescSmb,
            NULL,  // no aux desc 16
            NULL,  // no aux desc 32
            NULL,  // no aux desc SMB
            FALSE,  // not a null session API
            // rest of API's arguments, in 32-bit LM 2.x format:
            pszName,
            uLevel,
            pbBuf,
            cbBuf,
            & BytesNeeded16);  // downlevel buffer size needed.

    // If buffer too small, convert BytesNeeded to native num.
    if ( (Status == ERROR_MORE_DATA) || (Status == NERR_BufTooSmall) ) {
        *BytesNeeded = RxpEstimateBytesNeeded(BytesNeeded16);
    } else {
        *BytesNeeded = cbBuf;
    }

    return (Status);

} // RxPrintDestGetInfo


SPLERR SPLENTRY
RxPrintDestSetInfo(
    IN LPTSTR pszServer,
    IN LPTSTR pszName,
    IN DWORD uLevel,
    IN LPBYTE pbBuf,
    IN DWORD cbBuf,
    IN DWORD uParmNum
    )
{
    LPDESC DataDesc16, DataDesc32, DataDescSmb;
    NET_API_STATUS Status;
    NetpAssert( pszServer != NULL );
    NetpAssert( *pszServer != '\0' );

    Status = RxpGetPrintDestInfoDescs(
            uLevel,
            TRUE,  // This is an add or setinfo API.
            & DataDesc16,
            & DataDesc32,
            & DataDescSmb);
    if (Status != NERR_Success) {
        return (Status);
    }

    if (uParmNum == PARMNUM_ALL) {
        return( RxRemoteApi(
                API_WPrintDestSetInfo,
                pszServer,
                REMSmb_DosPrintDestSetInfo_P,
                DataDesc16,
                DataDesc32,
                DataDescSmb,
                NULL,  // no aux 16 desc
                NULL,  // no aux 32 desc
                NULL,  // no aux SMB desc
                FALSE,  // not a null session API
                // rest of API's arguments, in 32-bit LM 2.x format:
                pszName,
                uLevel,
                pbBuf,
                cbBuf,
                uParmNum) );
    } else {
        // Level 3 parmnums and field indexes are identical, so no need to
        // convert here.  (Field index equates would be in remdef.h otherwise.)

        return( RxpSetField (
                API_WPrintDestSetInfo,
                pszServer,
                "z",  // object desc
                pszName,  // object to set
                REMSmb_DosPrintDestSetInfo_P,  // parm desc
                DataDesc16,
                DataDesc32,
                DataDescSmb,
                pbBuf,  // native info buffer
                uParmNum,  // parmnum to send
                uParmNum,  // field index
                uLevel
                ) );
    }

    /* NOTREACHED */

} // RxPrintDestSetInfo
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\rpcxlate\rxapi\rxaccess.c ===
/*++

Copyright (c) 1991-1993  Microsoft Corporation

Module Name:

    rxaccess.c

Abstract:

    Contains down-level remoted NetAccess routines:
        RxNetAccessAdd
        RxNetAccessDel
        RxNetAccessEnum
        RxNetAccessGetInfo
        RxNetAccessGetUserPerms
        RxNetAccessSetInfo
        (GetAccessDescriptors)
        (MapResourceName)

Author:

    Richard Firth (rfirth) 20-May-1991

Environment:

    Win-32/flat address space

Notes:

    Routines in this module assume that caller-supplied parameters have
    already been verified. No effort is made to further check the veracity
    of parms. Any actions causing exceptions must be trapped at a higher
    level. This applies to ALL parameters - strings, pointers, buffers, etc.

Revision History:

    20-May-1991 RFirth
        Created
    13-Sep-1991 JohnRo
        Use correct typedef for descriptors (LPDESC, not LPTSTR).
        Made changes as suggested by PC-LINT.
    16-Sep-1991 JohnRo
        Use DBGSTATIC for nonexported routines.
    25-Sep-1991 JohnRo
        Correct UNICODE use.  (Use POSSIBLE_WCSSIZE() for LPWSTR types.)
        Fixed MIPS build error.
    21-Nov-1991 JohnRo
        Removed NT dependencies to reduce recompiles.
    05-Dec-1991 RFirth
        Enum returns in TotalEntries (or EntriesLeft) the number of items to
        be enumerated BEFORE this call. Used to be number left after this call
    07-Feb-1992 JohnRo
        Avoid compiler warnings.
        Use NetApiBufferAllocate() instead of private version.
    11-Jan-1993 JohnRo
        Made changes suggested by PC-LINT 5.0
    30-Apr-1993 JohnRo
        Fix NET_API_FUNCTION references.  (NetAccess routines are just #define'd
        as RxNetAccess routines in lmaccess.h, so we need NET_API_FUNCTION here
        too!)

--*/

#include <nt.h>
#include <ntrtl.h>
#include "downlevl.h"
#include <lmaccess.h>

// Don't complain about "unneeded" includes of these files:
/*lint -efile(764,rxaccess.h) */
/*lint -efile(766,rxaccess.h) */
#include "rxaccess.h"

#include <lmuse.h>

//
// local prototypes
//

DBGSTATIC void
GetAccessDescriptors(
    IN  DWORD   Level,
    OUT LPDESC* pDesc16,
    OUT LPDESC* pDesc32,
    OUT LPDESC* pDescSmb,
    OUT LPDWORD pDataSize
    );

DBGSTATIC
BOOL
MapResourceName(
    IN  LPTSTR  LocalName,
    OUT LPTSTR  RemoteName
    );


//
// routines
//

NET_API_STATUS NET_API_FUNCTION
RxNetAccessAdd(
    IN  LPCWSTR  ServerName,
    IN  DWORD   Level,
    IN  LPBYTE  Buffer,
    OUT LPDWORD ParmError OPTIONAL
    )

/*++

Routine Description:

    Add a user account to a remote down-level server database. Buffer contains
    an ACCESS_INFO_1 structure followed by a list of ACCESS_LIST structures

    Assumes:
        1.  all parameters already verified at higher level

Arguments:

    ServerName  - at which server to perform this request
    Level       - of information being supplied. Must be 1
    Buffer      - pointer to user's buffer containing ACCESS_INFO_1 struct
    ParmError   - optional pointer to place to deposit parameter error

Return Value:

    NET_API_STATUS:
        Success - NERR_Success
        Failure - ERROR_INVALID_PARAMETER
                    One of the fields in the ACCESS_INFO_1 structure may blow
                    a down-level limit

--*/

{
    NET_API_STATUS  rc;
    DWORD   badparm;
    DWORD   buflen;
    DWORD   count;
    DWORD   len;
    PACCESS_LIST    aclptr;
    TCHAR   mappedName[MAX_PATH];
    LPACCESS_INFO_1 infoPtr = NULL;

    //
    // set up default for ParmError and probe writability if value given
    //

    if (ParmError == NULL) {
        ParmError = &badparm;
    }
    *ParmError = PARM_ERROR_UNKNOWN;

    //
    // Don't allow null servername
    //

    if ( ServerName == NULL || *ServerName == L'\0' ) {
        return(NERR_InvalidComputer);
    }

    //
    // Down-level servers only support 1 level of Add information - 1. If this
    // isn't it then throw out this request without further ado
    //

    if (Level != 1) {
        return ERROR_INVALID_LEVEL;
    }

    //
    // calculate the size of the buffer we are passing in (32-bit size)
    //

    //
    // How to calculate the maximum for the resource name (PATHLEN?)
    // try to blow up a down-level server by submitting eg 4K string
    //

    buflen = sizeof(ACCESS_INFO_1); // fixed part
    len = POSSIBLE_STRLEN(((ACCESS_INFO_1*)Buffer)->acc1_resource_name);

    if (!len) {
        *ParmError = ACCESS_RESOURCE_NAME_INFOLEVEL;
        return ERROR_INVALID_PARAMETER;
    }
    buflen += len;

    //
    // loop through the list of ACLs, checking the user/group name against the
    // down-level limit
    //

    //
    // STRSIZE returns the number of characters, so all
    // we need is count * sizeof(16-bit ACCESS_LIST structure) + sizeof(16-bit
    // ACCESS_INFO_1 structure) + STRSIZE(resource name)
    //

    aclptr = (PACCESS_LIST)(Buffer + sizeof(ACCESS_INFO_1));
    for (count = ((ACCESS_INFO_1*)Buffer)->acc1_count; count; --count) {
        buflen += sizeof(ACCESS_LIST);  // fixed part of access list
        if (len = POSSIBLE_STRLEN(aclptr->acl_ugname)) {
            if (len > LM20_UNLEN) {
                *ParmError = ACCESS_ACCESS_LIST_INFOLEVEL;
                return ERROR_INVALID_PARAMETER;
            }
        }
    }

    //
    // if we need to map the resource name then we have to create a new buffer
    // for the access list
    //

    if (MapResourceName(((LPACCESS_INFO_1)Buffer)->acc1_resource_name, mappedName)) {
        infoPtr = (LPACCESS_INFO_1)NetpMemoryAllocate(buflen);
        if (infoPtr == NULL) {
            return ERROR_NOT_ENOUGH_MEMORY;
        }
        RtlMoveMemory(infoPtr, Buffer, buflen);
        infoPtr->acc1_resource_name = mappedName;
        Buffer = (LPBYTE)infoPtr;
    }

    rc = RxRemoteApi(API_WAccessAdd,                // API #
                    (LPWSTR) ServerName,            // where it will run
                    REMSmb_NetAccessAdd_P,          // parameter descriptor
                    REM16_access_info_1,            // Data descriptor/16-bit
                    REM32_access_info_1,            // Data descriptor/32-bit
                    REMSmb_access_info_1,           // Data descriptor/SMB
                    REM16_access_list,              // Aux descriptor/16-bit
                    REM32_access_list,              // Aux descriptor/32-bit
                    REMSmb_access_list,             // Aux descriptor/SMB
                    FALSE,                          // this call needs user to be logged on
                    1,                              // level. Since there's only 1 push immediate
                    Buffer,                         // caller's share_info_1 struct
                    buflen                          // parameter supplied by us
                    );

    //
    // if we mapped the resource name free up the buffer
    //

    if (infoPtr) {
        NetpMemoryFree(infoPtr);
    }

    //
    // we didn't expect to get any data in return. Just pass the return
    // code back to our caller
    //

    return rc;
}



//NET_API_STATUS
//RxNetAccessCheck(
//    )
//{
//    /** CANNOT BE REMOTED **/
//}



NET_API_STATUS NET_API_FUNCTION
RxNetAccessDel(
    IN  LPCWSTR  ServerName,
    IN  LPCWSTR  ResourceName
    )

/*++

Routine Description:

    Remotely delete a resource's Access Control List entry from a down-level
    server database. The caller must have Admin privilege to successfully
    execute this routine

Arguments:

    ServerName  - at which server to perform this request
    ResourceName- name of thing to delete

Return Value:

    NET_API_STATUS:
        Success = NERR_Success
        Failure =

--*/

{
    TCHAR   mappedName[MAX_PATH];



    //
    // Don't allow null servername
    //

    if ( ServerName == NULL || *ServerName == L'\0' ) {
        return(NERR_InvalidComputer);
    }

    //
    // The ResourceName parameter must be a non-NUL(L) string
    //

    if (!VALID_STRING(ResourceName)) {
        return ERROR_INVALID_PARAMETER;
    }

    if (MapResourceName((LPWSTR)ResourceName, mappedName)) {
        ResourceName = mappedName;
    }
    return RxRemoteApi(API_WAccessDel,      // API #
                    (LPWSTR) ServerName,    // where it will run
                    REMSmb_NetAccessDel_P,  // parameter descriptor
                    NULL,                   // Data descriptor/16-bit
                    NULL,                   // Data descriptor/32-bit
                    NULL,                   // Data descriptor/SMB
                    NULL,                   // Aux descriptor/16-bit
                    NULL,                   // Aux descriptor/32-bit
                    NULL,                   // Aux descriptor/SMB
                    FALSE,                  // this call needs user to be logged on
                    ResourceName
                    );
}



NET_API_STATUS NET_API_FUNCTION
RxNetAccessEnum(
    IN  LPCWSTR  ServerName,
    IN  LPCWSTR  BasePath,
    IN  DWORD   Recursive,
    IN  DWORD   Level,
    OUT LPBYTE* Buffer,
    IN  DWORD   PrefMaxLen,
    OUT LPDWORD EntriesRead,
    OUT LPDWORD EntriesLeft,
    IN OUT LPDWORD ResumeHandle OPTIONAL
    )

/*++

Routine Description:

    Retrieves access info from a remote down-level server

    NOTE:   Assumes that calling routine (NetAccessEnum) has validated the
            caller's pointers: Buffer, EntriesRead and EntriesLeft are all
            valid, writable pointers

Arguments:

    ServerName  - at which server to perform this request
    BasePath    - for the resource(s)
    Recursive   - flag: 0 = return information only for resources identified
                  in BasePath. !0 = return information for all resources under
                  BasePath
    Level       - of information requested. Must be zero
    Buffer      - pointer to place to store pointer to returned buffer
    PrefMaxLen  - caller's preferred maximum buffer size
    EntriesRead - pointer to returned number of enum elements in buffer
    EntriesLeft - pointer to returned total enum elements available to the caller
    ResumeHandle- optional pointer to handle for resuming interrupted searches

Return Value:

    NET_API_STATUS:
        Success = NERR_Success
        Failure =

--*/

{
    NET_API_STATUS  rc;
    LPDESC  pDesc16;
    LPDESC  pDesc32;
    LPDESC  pDescSmb;
    LPBYTE  ourbuf;
    DWORD   infolen, entries_read, total_avail;
    TCHAR   mappedName[MAX_PATH];


    UNREFERENCED_PARAMETER(PrefMaxLen);

    //
    // Don't allow null servername
    //

    if ( ServerName == NULL || *ServerName == L'\0' ) {
        return(NERR_InvalidComputer);
    }


    //
    // Set the number of entries read and total available to sensible defaults.
    // Side effect of testing writability of supplied parameters
    //

    *Buffer = NULL;
    *EntriesRead = 0;
    *EntriesLeft = 0;

    //
    // Check for invalid parameters.
    // NB Assumes that DWORD is unsigned
    // NB Assume that calling routine (ie NetAccessEnum) has validated the
    // caller's pointers
    // Ensure that:
    //      Level is not >1
    //      ResumeHandle is NULL or a pointer to NULL
    //

    if (!NULL_REFERENCE(ResumeHandle)) {
        return ERROR_INVALID_PARAMETER;
    }

    if (Level > 1) {
        return ERROR_INVALID_LEVEL;
    }

    //
    // Decide which descriptors to use, based on the Level parameter
    //

    GetAccessDescriptors(Level, &pDesc16, &pDesc32, &pDescSmb, &infolen);

    //
    // allocate the buffer in which to return the enumerated info, using the
    // supplied size criteria. If we fail then return the error code to the
    // caller
    //

    ourbuf = NULL;
    if (MapResourceName((LPWSTR)BasePath, mappedName)) {
        BasePath = mappedName;
    }
    rc = RxRemoteApi(API_WAccessEnum,       // API number
                    (LPWSTR) ServerName,    // where it will run
                    REMSmb_NetAccessEnum_P, // parameter descriptor
                    pDesc16,                // Data descriptor/16-bit
                    pDesc32,                // Data descriptor/32-bit
                    pDescSmb,               // Data descriptor/SMB
                    REM16_access_list,      // Aux descriptor/16-bit
                    REM32_access_list,      // Aux descriptor/32-bit
                    REMSmb_access_list,     // Aux descriptor/SMB
                    ALLOCATE_RESPONSE,
                    BasePath,               // where to start
                    Recursive,              // get tree or not
                    Level,                  // level parameter
                    &ourbuf,
                    65535,
                    &entries_read,          // pointer to entries read variable
                    &total_avail            // pointer to total entries variable
                    );
    if (rc) {
        if (ourbuf != NULL) {
            (void) NetApiBufferFree(ourbuf);
        }
    } else {
        *Buffer = ourbuf;
        *EntriesRead = entries_read;
        *EntriesLeft = total_avail;
    }
    return rc;
}



NET_API_STATUS NET_API_FUNCTION
RxNetAccessGetInfo(
    IN  LPCWSTR  ServerName,
    IN  LPCWSTR  ResourceName,
    IN  DWORD   Level,
    OUT LPBYTE* Buffer
    )

/*++

Routine Description:

    Retrieves access information about a specific resource from a remote
    down-level server

Arguments:

    ServerName  - at which server to perform this request
    ResourceName- name of resource we are trying to get info for
    Level       - of information required: 0 or 1
    Buffer      - pointer to place to store address of buffer containing
                  requested information

Return Value:

    NET_API_STATUS:
        Success = NERR_Success
        Failure = ERROR_INVALID_LEVEL
                    Specified Level parameter can not be accepted
                  ERROR_INVALID_PARAMETER
                    ResourceName or Buffer not valid

--*/

{
    NET_API_STATUS  rc;
    LPDESC  pDesc16;        // pointer to 16-bit info descriptor for RxRemoteApi
    LPDESC  pDesc32;        // pointer to 32-bit info descriptor for RxRemoteApi
    LPDESC  pDescSmb;       // pointer to SMB info descriptor for RxRemoteApi
    LPDESC  pAuxDesc16;     // pointer to 16-bit aux info descriptor for RxRemoteApi
    LPDESC  pAuxDesc32;     // pointer to 32-bit aux info descriptor for RxRemoteApi
    LPDESC  pAuxDescSmb;    // pointer to SMB aux info descriptor for RxRemoteApi
    LPBYTE  ourbuf;         // buffer we allocate, fill, and give to the caller
    DWORD   total_avail;    // 32-bit total available if supplied buffer too small
    DWORD   infolen;        // 32-bit place to store size of required buffer
    TCHAR   mappedName[MAX_PATH];



    //
    // Don't allow null servername
    //

    if ( ServerName == NULL || *ServerName == L'\0' ) {
        return(NERR_InvalidComputer);
    }

    //
    // Perform parameter validity checks:
    //      Level must be in range 0 <= Level <= 1
    //      ResourceName must be non-NULL pointer to non-NULL string
    //      Buffer must be non-NULL pointer
    // NB. Assumes DWORD unsigned
    //

    if (Level > 1) {
        return ERROR_INVALID_LEVEL;
    }

    if (NULL_REFERENCE(ResourceName) || !Buffer) {
        return ERROR_INVALID_PARAMETER;
    }

    //
    // set Buffer to default value and catch any bad address errors
    //

    *Buffer = NULL;

    //
    // Work out the descriptor and buffer size requirements based on the
    // requested level
    //

    GetAccessDescriptors(Level, &pDesc16, &pDesc32, &pDescSmb, &infolen);
    if (Level == 1) {
        pAuxDesc16 = REM16_access_list;
        pAuxDesc32 = REM32_access_list;
        pAuxDescSmb = REMSmb_access_list;
    } else {
        pAuxDesc16 = NULL;
        pAuxDesc32 = NULL;
        pAuxDescSmb = NULL;
    }

    //
    // get a better way to allocate the buffer length
    //

    infolen = 4096;

    //
    // allocate a buffer size required to fit in 1 structure at info level
    // requested. If the allocation fails then return the error
    //

    if (rc = NetApiBufferAllocate(infolen, (LPVOID *) &ourbuf)) {
        return rc;
    }

    if (MapResourceName((LPWSTR)ResourceName, mappedName)) {
        ResourceName = mappedName;
    }
    rc = RxRemoteApi(API_WAccessGetInfo,
                    (LPWSTR) ServerName,        // where it will happen
                    REMSmb_NetAccessGetInfo_P,  // parameter descriptor
                    pDesc16,                    // Data descriptor/16-bit
                    pDesc32,                    // Data descriptor/32-bit
                    pDescSmb,                   // Data descriptor/SMB
                    pAuxDesc16,                 // Aux descriptor/16-bit
                    pAuxDesc32,                 // Aux descriptor/32-bit
                    pAuxDescSmb,                // Aux descriptor/SMB
                    FALSE,                      // this call needs user to be logged on
                    ResourceName,               // pointer to thing to get info on
                    Level,                      // level of info
                    ourbuf,                     // pointer to buffer sourced by us
                    infolen,                    // size of our sourced buffer
                    &total_avail                // pointer to total available
                    );

    //
    // If the remote NetShareGetInfo call succeeded then give the returned
    // buffer to the caller
    //

    if (rc == NERR_Success) {
        *Buffer = ourbuf;
    } else {

        //
        // if we didn't record a success then free the buffer previously allocated
        //

        (void) NetApiBufferFree(ourbuf);
    }
    return rc;
}



NET_API_STATUS NET_API_FUNCTION
RxNetAccessGetUserPerms(
    IN  LPCWSTR  ServerName,
    IN  LPCWSTR  UserName,
    IN  LPCWSTR  ResourceName,
    OUT LPDWORD Perms
    )

/*++

Routine Description:

    Retrieves the access information for a particular resource for a
    specified user or group

Arguments:

    ServerName  - at which server to perform this request
    UserName    - name of user or group which can access resource
    ResourceName- name of resource to get information for
    Perms       - pointer to place to store permissions

Return Value:

    NET_API_STATUS:
        Success = NERR_Success
        Failure = ERROR_INVALID_PARAMETER
                  (return code from remoted NetAccessGetUserPerms)

--*/

{
    TCHAR   mappedName[MAX_PATH];


    //
    // Don't allow null servername
    //

    if ( ServerName == NULL || *ServerName == L'\0' ) {
        return(NERR_InvalidComputer);
    }

    //
    // set *Perms to default value and verify writability of Perms
    //

    *Perms = 0;

    //
    // Perform parameter validity checks:
    //      UserName must be non-NULL pointer to non-NULL string
    //      ResourceName must be non-NULL pointer to non-NULL string
    //      Perms must be non-NULL pointer
    //

    if (!VALID_STRING(UserName) || !VALID_STRING(ResourceName)) {
        return ERROR_INVALID_PARAMETER;
    }
    if (MapResourceName( (LPWSTR) ResourceName, mappedName)) {
        ResourceName = mappedName;
    }
    return RxRemoteApi(API_WAccessGetUserPerms,         // API #
                        (LPWSTR) ServerName,            // where it will run
                        REMSmb_NetAccessGetUserPerms_P, // parameter descriptor
                        NULL,                           // Data descriptor/16-bit
                        NULL,                           // Data descriptor/32-bit
                        NULL,                           // Data descriptor/SMB
                        NULL,                           // Aux descriptor/16-bit
                        NULL,                           // Aux descriptor/32-bit
                        NULL,                           // Aux descriptor/SMB
                        FALSE,                          // this call needs user to be logged on
                        UserName,                       // for whom the bells toll
                        ResourceName,                   // pointer to thing to get info on
                        Perms                           // pointer to returned permissions
                        );
}



NET_API_STATUS NET_API_FUNCTION
RxNetAccessSetInfo(
    IN  LPCWSTR  ServerName,
    IN  LPCWSTR  ResourceName,
    IN  DWORD   Level,
    IN  LPBYTE  Buffer,
    OUT LPDWORD ParmError OPTIONAL
    )

/*++

Routine Description:

    Changes the access control information for a resource at a specific
    down-level remote server

Arguments:

    ServerName  - at which server to perform this request
    ResourceName- name of resource to change access information
    Level       - level of information buffer being supplied
                    - 1 or ACCESS_ATTR_INFOLEVEL
    Buffer      - pointer to buffer containing information
    ParmError   - optional pointer to place to store parameter error

Return Value:

    NET_API_STATUS:
        Success = NERR_Success
        Failure =

--*/

{
    DWORD   parmnum;
    TCHAR   mappedName[MAX_PATH];

    UNREFERENCED_PARAMETER(ParmError);

    //
    // Don't allow null servername
    //

    if ( ServerName == NULL || *ServerName == L'\0' ) {
        return(NERR_InvalidComputer);
    }

    //
    // Perform parameter validity checks:
    //      Level must be 1 or 1002
    //      ResourceName must be non-NULL pointer to non-NULL string
    //      Buffer must be non-NULL
    //      ParmNum must be in range
    // NB. Does not assume that DWORD is unsigned
    //

    if ((Level != 1) && (Level != ACCESS_ATTR_INFOLEVEL)) {
        return ERROR_INVALID_LEVEL;
    }

    if (!VALID_STRING(ResourceName) || !Buffer) {
        return ERROR_INVALID_PARAMETER;
    }

    //
    // convert the NT level information to down-level. Level must be 1 at down-
    // level server. ParmNum can be PARMNUM_ALL (0) or ACCESS_ATTR_PARMNUM (2)
    // Note that the size of the data being passed to the down-level server will
    // be calculated in RxRemoteApi. We do not need to pass in a valid buffer
    // length, although the parameter string (REMSmb_NetAccessSetInfo_P) has a
    // 'T' descriptor saying this is what the server is getting. We just need
    // a place-holder on the stack, hence 0
    //

    parmnum = (Level == 1) ? PARMNUM_ALL : ACCESS_ATTR_PARMNUM;
    if (MapResourceName( (LPWSTR) ResourceName, mappedName)) {
        ResourceName = mappedName;
    }
    return RxRemoteApi(
                API_WAccessSetInfo,             // API #
                (LPWSTR) ServerName,                     // where it will run
                REMSmb_NetAccessSetInfo_P,      // parameter descriptor
                REM16_access_info_1_setinfo,    // Data descriptor/16-bit
                REM32_access_info_1_setinfo,    // Data descriptor/32-bit
                REMSmb_access_info_1_setinfo,   // Data descriptor/SMB
                REM16_access_list,              // Aux descriptor/16-bit
                REM32_access_list,              // Aux descriptor/32-bit
                REMSmb_access_list,             // Aux descriptor/SMB
                FALSE,                          // this call needs user to be logged on
                ResourceName,                   // pointer to thing to set info on
                1,                              // level of info
                Buffer,                         // pointer to buffer sourced by caller
                0,                              // size of our buffer IGNORED!

                //
                // in this case, the field index and parm num are the
                // same value
                //

                MAKE_PARMNUM_PAIR(parmnum, parmnum)
                );
}



DBGSTATIC void
GetAccessDescriptors(
    IN  DWORD   level,
    OUT LPDESC* pDesc16,
    OUT LPDESC* pDesc32,
    OUT LPDESC* pDescSmb,
    OUT LPDWORD pDataSize
    )

/*++

Routine Description:

    A routinette to return pointers to the 16- and 32-bit access info
    structure descriptor strings for each level (0, 1). Also returns
    the size of the 16-bit structure

Arguments:

    level       - of information to be returned
    pDesc16     - pointer to returned 16-bit descriptor string
    pDesc32     - pointer to returned 32-bit descriptor string
    pDescSmb    - pointer to returned SMB descriptor string
    pDataSize   - pointer to returned size of 16-bit structure

Return Value:

    None.

--*/

{
    switch (level) {
    case 0:
        *pDesc16 = REM16_access_info_0;
        *pDesc32 = REM32_access_info_0;
        *pDescSmb = REMSmb_access_info_0;
        *pDataSize = sizeof(ACCESS_INFO_0);
        break;

    case 1:
        *pDesc16 = REM16_access_info_1;
        *pDesc32 = REM32_access_info_1;
        *pDescSmb = REMSmb_access_info_1;
        *pDataSize = sizeof(ACCESS_INFO_1);
        break;

#if DBG

    //
    // just to be completely paranoid...
    //

    default:
        NetpKdPrint(("%s.%u Unknown Level parameter: %u\n", __FILE__, __LINE__, level));
#endif
    }
}


DBGSTATIC
BOOL
MapResourceName(
    IN  LPTSTR  LocalName,
    OUT LPTSTR  RemoteName
    )

/*++

Routine Description:

    Maps a local resource name to the remote name. Only applies to resource
    names which start with a drive specification "[A-Z]:" and then only if
    the drive letter specifies a remoted drive

    ASSUMES: RemoteName is large enough to hold the mapped name

Arguments:

    LocalName   - pointer to name of local resource specification
    RemoteName  - pointer to buffer which will receive mapped resource name

Return Value:

    BOOL
        TRUE    - name was mapped
        FALSE   - name not mapped

--*/

{
    TCHAR driveName[3];
    NET_API_STATUS status;
    LPUSE_INFO_0 lpUse;
    LPTSTR resourceName;
    BOOL mapped;
    DWORD i;

    if (LocalName[1] != TCHAR_COLON) {
        (VOID) STRCPY(RemoteName, LocalName);
        return FALSE;
    }

    driveName[0] = LocalName[0];
    driveName[1] = TCHAR_COLON;
    driveName[2] = TCHAR_EOS;

    //
    // map the local drive name to the UNC name. If NetUseGetInfo returns
    // any error, then don't map
    //

    status = NetUseGetInfo(NULL, driveName, 0, (LPBYTE*)(LPVOID)&lpUse);
    if (status == NERR_Success) {
        (VOID) STRCPY(RemoteName, lpUse->ui0_remote);
        resourceName = LocalName + 2;

        //
        // if the rest of the resource name does not start with a path
        // separator (it should!) then add one
        //

        if (!IS_PATH_SEPARATOR(*resourceName) && *resourceName) {
            (VOID) STRCAT(RemoteName, (LPTSTR) TEXT("\\"));
        }
        (VOID) NetApiBufferFree((LPBYTE)lpUse);
        mapped = TRUE;
    } else {
        *RemoteName = TCHAR_EOS;
        resourceName = LocalName;
        mapped = FALSE;
    }

    //
    // concatenate the rest of the resource name to the UNC. If NetUseGetInfo
    // failed then the UNC is a NULL string and the rest of the resource name
    // is LocalName
    //

    (VOID) STRCAT(RemoteName, resourceName);

    //
    // strip trailing path separators
    //

    for (i = STRLEN(RemoteName) - 1; IS_PATH_SEPARATOR(RemoteName[i]); --i) {
        ;
    }
    RemoteName[i+1] = TCHAR_EOS;
    return mapped;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\rpcxlate\rxapi\rxcanon.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    rxcanon.c

Abstract:

    Functions which remote canonicalization routines to down-level servers

        RxNetpPathType
        RxNetpPathCanonicalize
        RxNetpPathCompare
        RxNetpNameValidate
        RxNetpNameCanonicalize
        RxNetpNameCompare
        RxNetpListCanonicalize

Author:

    Richard L Firth (rfirth) 22-Jan-1992

Revision History:

--*/

#include "downlevl.h"
#include <rxcanon.h>

NET_API_STATUS
RxNetpPathType(
    IN  LPTSTR  ServerName,
    IN  LPTSTR  PathName,
    OUT LPDWORD PathType,
    IN  DWORD   Flags
    )

/*++

Routine Description:

    Runs I_NetPathType on a down-level server

Arguments:

    ServerName  - down-level server where this routine is run
    PathName    - path to get type of
    PathType    - where path type returned
    Flags       - flags controlling server-side routine

Return Value:

    NET_API_STATUS
        Success - NERR_Success
        Failure -

--*/

{
    return RxRemoteApi(
        API_WI_NetPathType,     // API #
        ServerName,             // where we're gonna do it
        REMSmb_I_NetPathType_P, // parameter descriptor
        NULL,                   // data descriptor 16-bit
        NULL,                   // data descriptor 32-bit
        NULL,                   // data descriptor SMB
        NULL,                   // aux data descriptor 16-bit
        NULL,                   // aux data descriptor 32-bit
        NULL,                   // aux data descriptor SMB
        FALSE,                  // can use NULL session
        PathName,               // args to remote routine
        PathType,               // "
        Flags                   // "
        );
}

NET_API_STATUS
RxNetpPathCanonicalize(
    IN  LPTSTR  ServerName,
    IN  LPTSTR  PathName,
    IN  LPTSTR  Outbuf,
    IN  DWORD   OutbufLen,
    IN  LPTSTR  Prefix OPTIONAL,
    IN OUT LPDWORD PathType,
    IN  DWORD   Flags
    )

/*++

Routine Description:

    Runs I_NetPathCanonicalize on a down-level server

Arguments:

    ServerName  - down-level server where this routine is run
    PathName    - path to canonicalize
    Outbuf      - buffer where results are returned
    OutbufLen   - size of buffer
    Prefix      - optional prefix string
    PathType    - type of path
    Flags       - flags controlling server-side routine

Return Value:

    NET_API_STATUS
        Success - NERR_Success
        Failure -

--*/

{
    return RxRemoteApi(
        API_WI_NetPathCanonicalize,     // API #
        ServerName,                     // where we're gonna do it
        REMSmb_I_NetPathCanonicalize_P, // parameter descriptor
        NULL,                           // data descriptor 16-bit
        NULL,                           // data descriptor 32-bit
        NULL,                           // data descriptor SMB
        NULL,                           // aux data descriptor 16-bit
        NULL,                           // aux data descriptor 32-bit
        NULL,                           // aux data descriptor SMB
        FALSE,                          // can use NULL session
        PathName,                       // args to remote routine
        Outbuf,                         // "
        OutbufLen,                      // "
        Prefix,                         // "
        PathType,                       // "
        *PathType,                      // "
        Flags                           // "
        );
}

LONG
RxNetpPathCompare(
    IN  LPTSTR  ServerName,
    IN  LPTSTR  PathName1,
    IN  LPTSTR  PathName2,
    IN  DWORD   PathType,
    IN  DWORD   Flags
    )

/*++

Routine Description:

    Runs I_NetPathCompare on a down-level server

Arguments:

    ServerName  - down-level server where this routine is run
    PathName1   - path to compare
    PathName2   - path to compare
    PathType    - type of paths
    Flags       - flags controlling server-side routine

Return Value:

    LONG
        <0  - PathName1 < PathName2
         0  - PathName1 = PathName2
        >0  - PathName1 > PathName2

--*/

{
    return (LONG)RxRemoteApi(
        API_WI_NetPathCompare,      // API #
        ServerName,                 // where we're gonna do it
        REMSmb_I_NetPathCompare_P,  // parameter descriptor
        NULL,                       // data descriptor 16-bit
        NULL,                       // data descriptor 32-bit
        NULL,                       // data descriptor SMB
        NULL,                       // aux data descriptor 16-bit
        NULL,                       // aux data descriptor 32-bit
        NULL,                       // aux data descriptor SMB
        FALSE,                      // can use NULL session
        PathName1,                  // args to remote routine
        PathName2,                  // "
        PathType,                   // "
        Flags                       // "
        );
}

NET_API_STATUS
RxNetpNameValidate(
    IN  LPTSTR  ServerName,
    IN  LPTSTR  Name,
    IN  DWORD   NameType,
    IN  DWORD   Flags
    )

/*++

Routine Description:

    Runs I_NetNameValidate on a down-level server

Arguments:

    ServerName  - down-level server where this routine is run
    Name        - name to validate
    NameType    - type of name expected
    Flags       - flags controlling server-side routine

Return Value:

    NET_API_STATUS
        Success - NERR_Success
        Failure -

--*/

{
    return RxRemoteApi(
        API_WI_NetNameValidate,     // API #
        ServerName,                 // where we're gonna do it
        REMSmb_I_NetNameValidate_P, // parameter descriptor
        NULL,                       // data descriptor 16-bit
        NULL,                       // data descriptor 32-bit
        NULL,                       // data descriptor SMB
        NULL,                       // aux data descriptor 16-bit
        NULL,                       // aux data descriptor 32-bit
        NULL,                       // aux data descriptor SMB
        FALSE,                      // can use NULL session
        Name,                       // args to remote routine
        NameType,                   // "
        Flags                       // "
        );
}

NET_API_STATUS
RxNetpNameCanonicalize(
    IN  LPTSTR  ServerName,
    IN  LPTSTR  Name,
    OUT LPTSTR  Outbuf,
    IN  DWORD   OutbufLen,
    IN  DWORD   NameType,
    IN  DWORD   Flags
    )

/*++

Routine Description:

    Runs I_NetNameCanonicalize on a down-level server

Arguments:

    ServerName  - down-level server where this routine is run
    Name        - name to canonicalize
    Outbuf      - buffer which receives canonicalized name
    OutbufLen   - size of buffer (in bytes)
    NameType    - type of canonicalized name
    Flags       - flags controlling server-side routine

Return Value:

    NET_API_STATUS
        Success - NERR_Success
        Failure -

--*/

{
    return RxRemoteApi(
        API_WI_NetNameCanonicalize,     // API #
        ServerName,                     // where we're gonna do it
        REMSmb_I_NetNameCanonicalize_P, // parameter descriptor
        NULL,                           // data descriptor 16-bit
        NULL,                           // data descriptor 32-bit
        NULL,                           // data descriptor SMB
        NULL,                           // aux data descriptor 16-bit
        NULL,                           // aux data descriptor 32-bit
        NULL,                           // aux data descriptor SMB
        FALSE,                          // can use NULL session
        Name,                           // args to remote routine
        Outbuf,                         // "
        OutbufLen,                      // "
        NameType,                       // "
        Flags                           // "
        );
}

LONG
RxNetpNameCompare(
    IN  LPTSTR  ServerName,
    IN  LPTSTR  Name1,
    IN  LPTSTR  Name2,
    IN  DWORD   NameType,
    IN  DWORD   Flags
    )

/*++

Routine Description:

    Runs I_NetNameCompare on a down-level server

Arguments:

    ServerName  - down-level server where this routine is run
    Name1       - name to compare
    Name2       - name to compare
    NameType    - type of Name1, Name2
    Flags       - flags controlling server-side routine

Return Value:

    LONG
        <0  - Name1 < Name2
        =0  - Name1 = Name2
        >0  - Name1 > Name2

--*/

{
    return RxRemoteApi(
        API_WI_NetNameCompare,      // API #
        ServerName,                 // where we're gonna do it
        REMSmb_I_NetNameCompare_P,  // parameter descriptor
        NULL,                       // data descriptor 16-bit
        NULL,                       // data descriptor 32-bit
        NULL,                       // data descriptor SMB
        NULL,                       // aux data descriptor 16-bit
        NULL,                       // aux data descriptor 32-bit
        NULL,                       // aux data descriptor SMB
        FALSE,                      // can use NULL session
        Name1,                      // args to remote routine
        Name2,                      // "
        NameType,                   // "
        Flags                       // "
        );
}

NET_API_STATUS
RxNetpListCanonicalize(
    IN  LPTSTR  ServerName,
    IN  LPTSTR  List,
    IN  LPTSTR  Delimiters,
    OUT LPTSTR  Outbuf,
    IN  DWORD   OutbufLen,
    OUT LPDWORD OutCount,
    OUT LPDWORD PathTypes,
    IN  DWORD   PathTypesLen,
    IN  DWORD   Flags
    )

/*++

Routine Description:

    Runs I_NetListCanonicalize on a down-level server.

    NOTE: I_NetListCanonicalize is not supported as a remotable function in
    LanMan, so no action

Arguments:

    ServerName  - down-level server where this routine is run
    List        - of names/paths to canonicalize
    Delimiters  - optional string of delimiters
    Outbuf      - buffer where canonicalized results are put
    OutbufLen   - size of output buffer
    OutCount    - number of items canonicalized
    PathTypes   - array of pathtypes
    PathTypesLen- number of elements in path types array
    Flags       - flags controlling server-side routine

Return Value:

    NET_API_STATUS
        Success -
        Failure - ERROR_NOT_SUPPORTED

--*/

{
    UNREFERENCED_PARAMETER(ServerName);
    UNREFERENCED_PARAMETER(List);
    UNREFERENCED_PARAMETER(Delimiters);
    UNREFERENCED_PARAMETER(Outbuf);
    UNREFERENCED_PARAMETER(OutbufLen);
    UNREFERENCED_PARAMETER(OutCount);
    UNREFERENCED_PARAMETER(PathTypes);
    UNREFERENCED_PARAMETER(PathTypesLen);
    UNREFERENCED_PARAMETER(Flags);

    return ERROR_NOT_SUPPORTED;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\rpcxlate\rxapi\rxchdev.c ===
/*++

Copyright (c) 1991-92  Microsoft Corporation

Module Name:

    rxchdev.c

Abstract:

    Contains RxNetCharDev routines:
        RxNetCharDevControl
        RxNetCharDevEnum
        RxNetCharDevGetInfo

Author:

    Richard Firth (rfirth) 20-May-1991

Environment:

    Win-32/flat address space

Notes:

    Routines in this module assume that caller-supplied parameters have
    already been verified. No effort is made to further check the veracity
    of parms. Any actions causing exceptions must be trapped at a higher
    level. This applies to ALL parameters - strings, pointers, buffers, etc.

Revision History:

    20-May-1991 RFirth
        Created
    13-Sep-1991 JohnRo
        Made changes suggested by PC-LINT.
    25-Sep-1991 JohnRo
        Fixed MIPS build problems.
    05-Dec-1991 RFirth
        Enum returns in TotalEntries (or EntriesLeft) the number of items to
        be enumerated BEFORE this call. Used to be number left after this call
    07-Feb-1992 JohnRo
        Use NetApiBufferAllocate() instead of private version.

--*/



#include "downlevl.h"
#include <rxchdev.h>
#include <lmchdev.h>



NET_API_STATUS
RxNetCharDevControl(
    IN  LPTSTR  ServerName,
    IN  LPTSTR  DeviceName,
    IN  DWORD   Opcode
    )

/*++

Routine Description:

    Remotely applies a control action to a shared device. This particular
    routine deals with down-level Lanman servers

Arguments:

    ServerName  - Where to run the remoted API
    DeviceName  - Name of device for which to issue control
    Opcode      - Action to apply

Return Value:

    NET_API_STATUS
        Success - NERR_Success
        Failure - ERROR_INVALID_PARAMETER
                    DeviceName invalid
                  (return code from remoted API)

--*/

{
    if (STRLEN(DeviceName) > LM20_DEVLEN) {
        return ERROR_INVALID_PARAMETER;
    }

    return RxRemoteApi(API_WCharDevControl,         // API #
                        ServerName,                 // where to run the API
                        REMSmb_NetCharDevControl_P, // parameter string
                        NULL, NULL, NULL,           // no primary data structures
                        NULL, NULL, NULL,           // no aux. data structures
                        FALSE,                      // caller needs to be logged on
                        DeviceName,                 // API parameters...
                        Opcode
                        );
}



NET_API_STATUS
RxNetCharDevEnum(
    IN  LPTSTR  ServerName,
    IN  DWORD   Level,
    OUT LPBYTE* Buffer,
    IN  DWORD   PrefMaxLen,
    OUT LPDWORD EntriesRead,
    OUT LPDWORD EntriesLeft,
    IN OUT LPDWORD ResumeHandle OPTIONAL
    )

/*++

Routine Description:

    Returns a buffer containing a list of information structures detailing the
    shared communications devices at a down-level Lanman server

Arguments:

    ServerName  - Where to run the remoted API
    Level       - Of info requested - 0 or 1
    Buffer      - Pointer to returned pointer to buffer containing info
    PrefMaxLen  - Caller's preferred maximum returned buffer size
    EntriesRead - Pointer to returned number of structures in Buffer
    EntriesLeft - Pointer to returned number of structures left to enumerate
    ResumeHandle- Pointer to returned handle for continuing enumeration. IGNORED

Return Value:

    NET_API_STATUS
        Success - NERR_Success
        Failure - ERROR_INVALID_PARAMETER
                    DeviceName invalid
                    ResumeHandle not 0 or NULL
                  (return code from remoted API)

--*/

{
    DWORD   entries_read, total_avail;
    LPDESC  pDesc16, pDesc32, pDescSmb;
    LPBYTE  bufptr;
    NET_API_STATUS  rc;


    UNREFERENCED_PARAMETER(PrefMaxLen);

    //
    // test out the caller supplied arguments. This should be done at the outer
    // level
    //

    *Buffer = NULL;
    *EntriesRead = *EntriesLeft = 0;

    if (!NULL_REFERENCE(ResumeHandle)) {
        return ERROR_INVALID_PARAMETER;
    }


    switch (Level) {
    case 0:
        pDesc16 = REM16_chardev_info_0;
        pDesc32 = REM32_chardev_info_0;
        pDescSmb = REMSmb_chardev_info_0;
        break;

    case 1:
        pDesc16 = REM16_chardev_info_1;
        pDesc32 = REM32_chardev_info_1;
        pDescSmb = REMSmb_chardev_info_1;
        break;

    default:
        return ERROR_INVALID_LEVEL;
    }

    //
    // In the Enum case, since we don't know how much data will come back, we
    // leave the returned buffer allocation to the lower levels of software.
    // Thus we get back an exact amount of data, not a horrendous maximum
    //

    bufptr = NULL;
    rc = RxRemoteApi(API_NetCharDevEnum,        // API #
                    ServerName,                 // where to remote it
                    REMSmb_NetCharDevEnum_P,    // parameter descriptor
                    pDesc16, pDesc32, pDescSmb, // primary structure descriptors
                    NULL, NULL, NULL,           // no aux data structures
                    ALLOCATE_RESPONSE,
                    Level,                      // API parameters start here...
                    &bufptr,                    // RxRemoteApi will allocate buffer
                    65535,                      // maximum 16-bit SMB receive buffer
                    &entries_read,
                    &total_avail
                    );
    if (rc) {

        //
        // If a buffer was allocated on our behalf by RxRemoteApi before it
        // went under then free it
        //

        if (bufptr) {
            (void) NetApiBufferFree(bufptr);
        }
    } else {
        *Buffer = bufptr;
        *EntriesRead = entries_read;
        *EntriesLeft = total_avail;
    }
    return rc;
}



NET_API_STATUS
RxNetCharDevGetInfo(
    IN  LPTSTR  ServerName,
    IN  LPTSTR  DeviceName,
    IN  DWORD   Level,
    OUT LPBYTE* Buffer
    )

/*++

Routine Description:

    Returns an information structure detailing a particular shared comms device
    at a down-level server

Arguments:

    ServerName  - Where to run the remoted API
    DeviceName  - Name of device for which to get info
    Level       - Of info required - 0 or 1
    Buffer      - Pointer to returned pointer to buffer containing info

Return Value:

    NET_API_STATUS
        Success - NERR_Success
        Failure - ERROR_INVALID_PARAMETER
                    DeviceName too long
                  ERROR_INVALID_LEVEL
                    Level parameter not allowed
                  (return code from remoted API)

--*/

{
    DWORD   buflen, total_avail;
    LPDESC  pDesc16, pDesc32, pDescSmb;
    LPBYTE  bufptr;
    NET_API_STATUS  rc;


    //
    // test out the caller supplied arguments. This should be done at the outer
    // level
    //

    *Buffer = NULL;

    if (STRLEN(DeviceName) > LM20_DEVLEN) {
        return ERROR_INVALID_PARAMETER;
    }

    switch (Level) {
    case 0:
        pDesc16 = REM16_chardev_info_0;
        pDesc32 = REM32_chardev_info_0;
        pDescSmb = REMSmb_chardev_info_0;
        buflen = sizeof(CHARDEV_INFO_0) + STRING_SPACE_REQD(DEVLEN + 1);
        break;

    case 1:
        pDesc16 = REM16_chardev_info_1;
        pDesc32 = REM32_chardev_info_1;
        pDescSmb = REMSmb_chardev_info_1;
        buflen = sizeof(CHARDEV_INFO_1) + STRING_SPACE_REQD(DEVLEN + 1) +
            STRING_SPACE_REQD(UNLEN + 1);
        break;

    default:
        return ERROR_INVALID_LEVEL;
    }

    //
    // In the GetInfo case we are content to pre-allocate the return buffer
    // because we know how large it should be (although we actually allocate
    // the maximum size for a particular GetInfo structure level)
    //

    if (rc = NetApiBufferAllocate(buflen, (LPVOID *) &bufptr)) {
        return rc;
    }
    rc = RxRemoteApi(API_NetCharDevGetInfo,     // API #
                    ServerName,                 // where to remote it
                    REMSmb_NetCharDevGetInfo_P, // parameter descriptor
                    pDesc16, pDesc32, pDescSmb, // primary structure descriptors
                    NULL, NULL, NULL,           // no aux data structures
                    FALSE,                      // can't use NULL session
                    DeviceName,                 // API parameters start here...
                    Level,
                    bufptr,
                    buflen,                     // supplied by us
                    &total_avail                // not used by 32-bit API
                    );
    if (rc) {
        (void) NetApiBufferFree(bufptr);
    } else {
        *Buffer = bufptr;
    }
    return rc;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\rpcxlate\rxapi\rxlgenum.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    rxlgenum.c

Abstract:

    Routines in this module implement the down-level remoted NetLogon
    functions exported in NT

    Contains RxNetLogon routines:
        RxNetLogonEnum

Author:

    Richard Firth (rfirth) 20-May-1991

Environment:

    Win-32/flat address space

Notes:

    Routines in this module assume that caller-supplied parameters have
    already been verified. No effort is made to further check the veracity
    of parms. Any actions causing exceptions must be trapped at a higher
    level. This applies to ALL parameters - strings, pointers, buffers, etc.

Revision History:

    20-May-1991 RFirth
        Created
    13-Sep-1991 JohnRo
        Made changes as suggested by PC-LINT.
    05-Dec-1991 RFirth
        Enum returns in TotalEntries (or EntriesLeft) the number of items to
        be enumerated BEFORE this call. Used to be number left after this call

--*/



#include "downlevl.h"
#include <rxlgenum.h>



NET_API_STATUS
RxNetLogonEnum(
    IN  LPTSTR  ServerName,
    IN  DWORD   Level,
    OUT LPBYTE* Buffer,
    IN  DWORD   PrefMaxLen,
    OUT LPDWORD EntriesRead,
    OUT LPDWORD EntriesLeft,
    IN OUT LPDWORD ResumeHandle OPTIONAL
    )

/*++

Routine Description:

    description-of-function.

Arguments:

    ServerName  - Where the NetLogonEnum API will be remoted
    Level       - Of info to return - 0 or 2
    Buffer      - Pointer to pointer to returned buffer
    PrefMaxLen  - Caller's preferred maximum returned buffer size
    EntriesRead - Pointer to returned number of items in Buffer
    EntriesLeft - Pointer to returned number of items left to enumerate at server
    ResumeHandle- Handle used for subsequent enumerations

Return Value:

    NET_API_STATUS
        Success - NERR_Success
        Failure -

--*/

{
    LPDESC  pDesc16, pDesc32, pDescSmb;
    LPBYTE  bufptr;
    DWORD   entries_read, total_entries;
    NET_API_STATUS  rc;

    UNREFERENCED_PARAMETER(PrefMaxLen);
    UNREFERENCED_PARAMETER(ResumeHandle);

    *Buffer = NULL;
    *EntriesRead = *EntriesLeft = 0;

    switch (Level) {
    case 0:
        pDesc16 = REM16_user_logon_info_0;
        pDesc32 = REM32_user_logon_info_0;
        pDescSmb = REMSmb_user_logon_info_0;
        break;

    case 2:
        pDesc16 = REM16_user_logon_info_2;
        pDesc32 = REM32_user_logon_info_2;
        pDescSmb = REMSmb_user_logon_info_2;
        break;

    default:
        return ERROR_INVALID_LEVEL;
    }

    bufptr = NULL;
    rc = RxRemoteApi(API_WLogonEnum,
                    ServerName,
                    REMSmb_NetLogonEnum_P,
                    pDesc16,
                    pDesc32,
                    pDescSmb,
                    NULL, NULL, NULL,
                    ALLOCATE_RESPONSE,
                    Level,
                    &bufptr,
                    65535,
                    &entries_read,
                    &total_entries
                    );
    if (rc) {
        if (bufptr) {
            (void) NetApiBufferFree(bufptr);
        }
    } else {
        *EntriesRead = entries_read;
        *EntriesLeft = total_entries;
        *Buffer = bufptr;
    }
    return rc;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\rpcxlate\rxapi\rxmsg.c ===
/*++

Copyright (c) 1991-92  Microsoft Corporation

Module Name:

    rxmsg.c

Abstract:

    Routines in this module implement the functionality required to remote the
    NetMessage APIs to down-level servers

    Contains RxNetMessage routines:
        RxNetMessageBufferSend
        RxNetMessageNameAdd
        RxNetMessageNameDel
        RxNetMessageNameEnum
        RxNetMessageNameGetInfo

Author:

    Richard L Firth (rfirth) 20-May-1991

Environment:

    Win-32/flat address space

Notes:

    Routines in this module assume that caller-supplied parameters have
    already been verified. No effort is made to further check the veracity
    of parms. Any actions causing exceptions must be trapped at a higher
    level. This applies to ALL parameters - strings, pointers, buffers, etc.

Revision History:

    20-May-1991 rfirth
        Created
    16-Sep-1991 JohnRo
        Made changes as suggested by PC-LINT.
    25-Sep-1991 JohnRo
        Fixed MIPS build problems.
    05-Dec-1991 RFirth
        Enum returns in TotalEntries (or EntriesLeft) the number of items to
        be enumerated BEFORE this call. Used to be number left after this call
    01-Apr-1992 JohnRo
        Use NetApiBufferAllocate() instead of private version.

--*/



#include "downlevl.h"
#include <rxmsg.h>
#include <lmmsg.h>



NET_API_STATUS
RxNetMessageBufferSend(
    IN  LPTSTR  ServerName,
    IN  LPTSTR  Recipient,
    IN  LPTSTR  Sender OPTIONAL,
    IN  LPBYTE  Buffer,
    IN  DWORD   BufLen
    )

/*++

Routine Description:

    Allows a down-level server to send a message buffer to a registered message
    recipient

Arguments:

    ServerName  - Which down-level server to run this API on
    Recipient   - Message name to send buffer to
    Sender      - Optional name used to supply computer name, not logged on user
    Buffer      - Pointer to buffer containing message to send
    BufLen      - size of buffer being sent (bytes)

Return Value:

    NET_API_STATUS
        Success - NERR_Success
        Failure - (Return code from down-level NetMessageBufferSend)

--*/

{
    UNREFERENCED_PARAMETER(Sender);

    return RxRemoteApi(API_WMessageBufferSend,          // API #
                        ServerName,                     // where to do it
                        REMSmb_NetMessageBufferSend_P,  // parameter descriptor
                        NULL, NULL, NULL,               // no primary data descriptors
                        NULL, NULL, NULL,               // or secondaries
                        FALSE,                          // can't use NULL session
                        Recipient,                      // API params start here
                        Buffer,
                        BufLen
                        );
}



NET_API_STATUS
RxNetMessageNameAdd(
    IN  LPTSTR  ServerName,
    IN  LPTSTR  MessageName
    )

/*++

Routine Description:

    Adds a messaging name at a down-level server

Arguments:

    ServerName  - Which down-level server to run this API on
    MessageName - to add

Return Value:

    NET_API_STATUS
        Success - NERR_Success
        Failure - (Return code from down-level NetMessageNameAdd)

--*/

{
    return RxRemoteApi(API_WMessageNameAdd,             // API #
                        ServerName,                     // where to do it
                        REMSmb_NetMessageNameAdd_P,     // parameter descriptor
                        NULL, NULL, NULL,               // no primary data descriptors
                        NULL, NULL, NULL,               // or secondaries
                        FALSE,                          // can't use NULL session
                        MessageName,                    // API params start here
                        0                               // error if name forwarded
                        );
}



NET_API_STATUS
RxNetMessageNameDel(
    IN  LPTSTR  ServerName,
    IN  LPTSTR  MessageName
    )

/*++

Routine Description:

    Deletes a messaging name at a down-level server

Arguments:

    ServerName  - Which down-level server to run this API on
    MessageName - to delete

Return Value:

    NET_API_STATUS
        Success - NERR_Success
        Failure - (Return code from down-level NetMessageNameDel)

--*/

{
    return RxRemoteApi(API_WMessageNameDel,         // API #
                        ServerName,                 // where to do it
                        REMSmb_NetMessageNameDel_P, // parameter descriptor
                        NULL, NULL, NULL,           // no primary data descriptors
                        NULL, NULL, NULL,           // or secondaries
                        FALSE,                      // can't use NULL session
                        MessageName,                // API params start here
                        0                           // error if name forwarded
                        );
}



NET_API_STATUS
RxNetMessageNameEnum(
    IN  LPTSTR  ServerName,
    IN  DWORD   Level,
    OUT LPBYTE* Buffer,
    IN  DWORD   PrefMaxLen,
    OUT LPDWORD EntriesRead,
    OUT LPDWORD EntriesLeft,
    IN OUT LPDWORD ResumeHandle OPTIONAL
    )

/*++

Routine Description:

    description-of-function.

Arguments:

    ServerName  - Which down-level server to run this API on
    Level       - Of info to return - 0 or 1
    Buffer      - Pointer to returned buffer
    PrefMaxLen  - Caller's preferred maximum size of Buffer
    EntriesRead - Number of entries returned in Buffer
    EntriesLeft - Number of entries left to enumerate
    ResumeHandle- Where to resume if all entries not returned. IGNORED

Return Value:

    NET_API_STATUS
        Success - NERR_Success
        Failure - ERROR_INVALID_LEVEL
                  (return code from down-level NetMessageNameEnum)

--*/

{
    NET_API_STATUS  rc;
    LPBYTE  bufptr;
    LPDESC  pDesc16, pDesc32, pDescSmb;
    DWORD   entries_read, total_entries;


    UNREFERENCED_PARAMETER(PrefMaxLen);
    UNREFERENCED_PARAMETER(ResumeHandle);

    *Buffer = NULL;
    *EntriesRead = *EntriesLeft = 0;

    switch (Level) {
    case 0:
        pDesc16 = REM16_msg_info_0;
        pDesc32 = REM32_msg_info_0;
        pDescSmb = REMSmb_msg_info_0;
        break;

    case 1:
        pDesc16 = REM16_msg_info_1;
        pDesc32 = REM32_msg_info_1;
        pDescSmb = REMSmb_msg_info_1;
        break;

    default:
        return ERROR_INVALID_LEVEL;
    }

    bufptr = NULL;
    rc = RxRemoteApi(API_WMessageNameEnum,          // API #
                    ServerName,                     // where to do it
                    REMSmb_NetMessageNameEnum_P,    // parameter descriptor
                    pDesc16,                        // 16-bit data descriptor
                    pDesc32,                        // 32-bit data descriptor
                    pDescSmb,                       // SMB data descriptor
                    NULL, NULL, NULL,               // no secondary structures
                    ALLOCATE_RESPONSE,
                    Level,                          // API params start here
                    &bufptr,
                    65535,
                    &entries_read,
                    &total_entries
                    );
    if (rc) {
        if (bufptr) {
            (void) NetApiBufferFree(bufptr);
        }
    } else {
        *Buffer = bufptr;
        *EntriesLeft = total_entries;
        *EntriesRead = entries_read;
    }
    return rc;
}



NET_API_STATUS
RxNetMessageNameGetInfo(
    IN  LPTSTR  ServerName,
    IN  LPTSTR  MessageName,
    IN  DWORD   Level,
    OUT LPBYTE* Buffer
    )

/*++

Routine Description:

    Retrieves information about a specific message name from a down-level
    server

Arguments:

    ServerName  - Which down-level server to run this API on
    MessageName - Name to get info for
    Level       - Of info required - 0 or 1
    Buffer      - Where to return buffer containing info

Return Value:

    NET_API_STATUS
        Success - NERR_Success
        Failure - ERROR_INVALID_LEVEL
                  (return code from down-level NetMessageNameGetInfo API)

--*/

{
    NET_API_STATUS  rc;
    LPDESC  pDesc16, pDesc32, pDescSmb;
    LPBYTE  bufptr;
    DWORD   buflen, total_avail;


    *Buffer = NULL;

    switch (Level) {
    case 0:
        pDesc16 = REM16_msg_info_0;
        pDesc32 = REM32_msg_info_0;
        pDescSmb = REMSmb_msg_info_0;
        buflen = sizeof(MSG_INFO_0) + STRING_SPACE_REQD(UNLEN);
        break;

    case 1:
        pDesc16 = REM16_msg_info_1;
        pDesc32 = REM32_msg_info_1;
        pDescSmb = REMSmb_msg_info_1;
        buflen =  sizeof(MSG_INFO_1) + STRING_SPACE_REQD(2 * UNLEN);
        break;

    default:
        return ERROR_INVALID_LEVEL;
    }

    if (rc = NetApiBufferAllocate(buflen, (LPVOID *) &bufptr)) {
        return rc;
    }
    rc = RxRemoteApi(API_WMessageNameGetInfo,       // API #
                    ServerName,                     // where to do it
                    REMSmb_NetMessageNameGetInfo_P, // parameter descriptor
                    pDesc16,                        // 16-bit data descriptor
                    pDesc32,                        // 32-bit data descriptor
                    pDescSmb,                       // SMB data descriptor
                    NULL, NULL, NULL,               // no secondary structures
                    FALSE,                          // can't use NULL session
                    MessageName,                    // first parameter
                    Level,
                    bufptr,
                    buflen,
                    &total_avail                    // not used in 32-bit side
                    );
    if (rc) {
        (void) NetApiBufferFree(bufptr);
    } else {
        *Buffer = bufptr;
    }
    return rc;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\rpcxlate\rxapi\rxgroup.c ===
/*++

Copyright (c) 1991-92  Microsoft Corporation

Module Name:

    rxgroup.c

Abstract:

    Contains RxNetGroup routines:
        RxNetGroupAdd
        RxNetGroupAddUser
        RxNetGroupDel
        RxNetGroupDelUser
        RxNetGroupEnum
        RxNetGroupGetInfo
        RxNetGroupGetUsers
        RxNetGroupSetInfo
        RxNetGroupSetUsers

Author:

    Richard L Firth (rfirth) 20-May-1991

Environment:

    Win-32/flat address space

Notes:

    Routines in this module assume that caller-supplied parameters have
    already been verified. No effort is made to further check the veracity
    of parms. Any actions causing exceptions must be trapped at a higher
    level. This applies to ALL parameters - strings, pointers, buffers, etc.

Revision History:

    20-May-1991 rfirth
        Created
    13-Sep-1991 JohnRo
        Made changes suggested by PC-LINT.
    25-Sep-1991 JohnRo
        Correct UNICODE use.  (Use POSSIBLE_WCSSIZE() and wcslen() for
        LPWSTR types.)  Fixed MIPS build problems.
    21-Nov-1991 JohnRo
        Removed NT dependencies to reduce recompiles.
    05-Dec-1991 RFirth
        Enum returns in TotalEntries (or EntriesLeft) the number of items to
        be enumerated BEFORE this call. Used to be number left after this call
    01-Apr-1992 JohnRo
        Use NetApiBufferAllocate() instead of private version.

--*/



#include "downlevl.h"
#include <rxgroup.h>
#include <lmaccess.h>



DBGSTATIC
VOID
get_group_descriptors(
    DWORD   Level,
    LPDESC* pDesc16,
    LPDESC* pDesc32,
    LPDESC* pDescSmb
    );



NET_API_STATUS
RxNetGroupAdd(
    IN  LPTSTR  ServerName,
    IN  DWORD   Level,
    IN  LPBYTE  Buffer,
    OUT LPDWORD ParmError OPTIONAL
    )

/*++

Routine Description:

    Creates a group in the User Account Database at a down-level server

Arguments:

    ServerName  - at which server to perform this request
    Level       - of information to add. Can be 0 or 1
    Buffer      - containing caller's GROUP_INFO_{0|1} structure
    ParmError   - pointer to returned parameter error identifier. NOT USED

Return Value:

    NET_API_STATUS:
        Success = NERR_Success
        Failure = ERROR_INVALID_LEVEL
                    Level must be 0 or 1
                  ERROR_INVALID_PARAMETER
                    Buffer is NULL pointer
--*/

{
    DWORD   buflen;         // size of caller's buffer (we calculate it)
    LPDESC  pDesc16;        // pointer to 16-bit info descriptor for RxRemoteApi
    LPDESC  pDesc32;        // pointer to 32-bit info descriptor for RxRemoteApi
    LPDESC  pDescSmb;       // pointer to SMB info descriptor for RxRemoteApi


    UNREFERENCED_PARAMETER(ParmError);


    //
    // try to trap any basic problems
    //

    if (Level > 1) {
        return ERROR_INVALID_LEVEL;
    }

    if (!Buffer) {
        return ERROR_INVALID_PARAMETER;
    }

    //
    // Calculate the size of the buffer we are passing into the remoted API.
    // The down-level logic expects a buffer size; Nt does not. If the sizes
    // of the variable fields exceed the down-level maximums then we will get
    // some kind of invalid parameter error. Let the caller handle it
    //

    buflen = ((Level == 1) ? sizeof(GROUP_INFO_1) : sizeof(GROUP_INFO_0))
        + POSSIBLE_STRLEN(((PGROUP_INFO_0)Buffer)->grpi0_name);
    buflen += (Level == 1) ? POSSIBLE_STRLEN(((PGROUP_INFO_1)Buffer)->grpi1_comment) : 0;

    //
    // Get the data descriptor strings based on the info level then make the
    // down-level call. We expect no return data, so just return the result
    // to the caller
    //

    get_group_descriptors(Level, &pDesc16, &pDesc32, &pDescSmb);
    return RxRemoteApi(API_WGroupAdd,       // API #
                    ServerName,             // on which server
                    REMSmb_NetGroupAdd_P,   // parameter descriptor
                    pDesc16,                // Data descriptor/16-bit
                    pDesc32,                // Data descriptor/32-bit
                    pDescSmb,               // Data descriptor/SMB
                    NULL,                   // Aux descriptor/16-bit
                    NULL,                   // Aux descriptor/32-bit
                    NULL,                   // Aux descriptor/SMB
                    FALSE,                  // this call needs user to be logged on
                    Level,                  // caller supplied parameters...
                    Buffer,                 // caller's GROUP_INFO_{0|1} struct
                    buflen                  // as supplied by us
                    );
}



NET_API_STATUS
RxNetGroupAddUser(
    IN  LPTSTR  ServerName,
    IN  LPTSTR  GroupName,
    IN  LPTSTR  UserName
    )

/*++

Routine Description:

    Adds a user to a UAS group on a down-level server

Arguments:

    ServerName  - at which server to perform this request
    GroupName   - name of group to add user to
    UserName    - name of user to add

Return Value:

    NET_API_STATUS:
        Success = NERR_Success
        Failure = ERROR_INVALID_PARAMETER
                    GroupName or UserName not valid strings
--*/

{
    if (!VALID_STRING(GroupName) && !VALID_STRING(UserName)) {
        return ERROR_INVALID_PARAMETER;
    }

    return RxRemoteApi(API_WGroupAddUser,       // API #
                    ServerName,                 // where to remote it
                    REMSmb_NetGroupAddUser_P,   // parameter descriptor
                    NULL,                       // Data descriptor/16-bit
                    NULL,                       // Data descriptor/32-bit
                    NULL,                       // Data descriptor/SMB
                    NULL,                       // Aux descriptor/16-bit
                    NULL,                       // Aux descriptor/32-bit
                    NULL,                       // Aux descriptor/SMB
                    FALSE,                      // this call needs user to be logged on
                    GroupName,                  // parm 1
                    UserName                    // parm 2
                    );
}



NET_API_STATUS
RxNetGroupDel(
    IN  LPTSTR  ServerName,
    IN  LPTSTR  GroupName
    )

/*++

Routine Description:

    Deletes a group from a down-level server UAS database

Arguments:

    ServerName  - at which server to perform this request
    GroupName   - name of group to delete

Return Value:

    NET_API_STATUS:
        Success = NERR_Success
        Failure = ERROR_INVALID_PARAMETER
                    GroupName not valid string
--*/

{
    if (!VALID_STRING(GroupName)) {
        return ERROR_INVALID_PARAMETER;
    }

    return RxRemoteApi(API_WGroupDel,       // API #
                    ServerName,             // where to remote it
                    REMSmb_NetGroupDel_P,   // parameter descriptor
                    NULL,                   // Data descriptor/16-bit
                    NULL,                   // Data descriptor/32-bit
                    NULL,                   // Data descriptor/SMB
                    NULL,                   // Aux descriptor/16-bit
                    NULL,                   // Aux descriptor/32-bit
                    NULL,                   // Aux descriptor/SMB
                    FALSE,                  // this call needs user to be logged on
                    GroupName               // parm 1
                    );
}



NET_API_STATUS
RxNetGroupDelUser(
    IN  LPTSTR  ServerName,
    IN  LPTSTR  GroupName,
    IN  LPTSTR  UserName
    )

/*++

Routine Description:

    Deletes a user from a group in a down-level UAS database

Arguments:

    ServerName  - at which server to perform this request
    GroupName   - name of group to delete user from
    UserName    - name of user to delete

Return Value:

    NET_API_STATUS:
        Success = NERR_Success
        Failure = ERROR_INVALID_PARAMETER
                    GroupName or UserName not valid strings
--*/

{
    if (!VALID_STRING(GroupName) && !VALID_STRING(UserName)) {
        return ERROR_INVALID_PARAMETER;
    }

    return RxRemoteApi(API_WGroupDelUser,       // API #
                    ServerName,                 // where to remote it
                    REMSmb_NetGroupDelUser_P,   // parameter descriptor
                    NULL,                       // Data descriptor/16-bit
                    NULL,                       // Data descriptor/32-bit
                    NULL,                       // Data descriptor/SMB
                    NULL,                       // Aux descriptor/16-bit
                    NULL,                       // Aux descriptor/32-bit
                    NULL,                       // Aux descriptor/SMB
                    FALSE,                      // this call needs user to be logged on
                    GroupName,                  // parm 1
                    UserName                    // parm 2
                    );
}



NET_API_STATUS
RxNetGroupEnum(
    IN  LPTSTR  ServerName,
    IN  DWORD   Level,
    OUT LPBYTE* Buffer,
    IN  DWORD   PrefMaxLen,
    OUT LPDWORD EntriesRead,
    OUT LPDWORD EntriesLeft,
    IN OUT PDWORD_PTR ResumeHandle OPTIONAL
    )

/*++

Routine Description:

    Gets a list of GROUP_INFO_{0|1} structures from a down-level server

Arguments:

    ServerName  - at which server to perform this request
    Level       - of information to retrieve (0 or 1)
    Buffer      - pointer to pointer to returned buffer
    PrefMaxLen  - caller's maximum
    EntriedRead - pointer to returned number of structures read
    EntriesLeft - pointer to returned nunber of structures left to enumerate
    ResumeHandle- handle used to restart enums. Not used by this routine

Return Value:

    NET_API_STATUS:
        Success = NERR_Success
        Failure = ERROR_INVALID_LEVEL
                    Level parameter must be 0 or 1
                  ERROR_INVALID_PARAMETER
                    Buffer parameter NULL pointer or non-NULL ResumeHandle
--*/

{
    NET_API_STATUS  rc;
    LPDESC  pDesc16;        // pointer to 16-bit info descriptor for RxRemoteApi
    LPDESC  pDesc32;        // pointer to 32-bit info descriptor for RxRemoteApi
    LPDESC  pDescSmb;       // pointer to SMB info descriptor for RxRemoteApi
    LPBYTE  localbuf;       // pointer to buffer allocated in this routine
    DWORD   total_avail;    // returned total available entries
    DWORD   entries_read;   // returned entries in buffer


    UNREFERENCED_PARAMETER(PrefMaxLen);

    *EntriesRead = *EntriesLeft = 0;
    *Buffer = NULL;

    if (Level > 1) {
        return ERROR_INVALID_LEVEL;
    }

    //
    // Buffer must be a valid pointer. If ResumeHandle is not a NULL pointer
    // and points to a non-zero handle value then return an INVALID_PARAMETER
    // error - down-level does not supoort resume
    //

    if (!NULL_REFERENCE(ResumeHandle)) {
        return ERROR_INVALID_PARAMETER;
    }

    get_group_descriptors(Level, &pDesc16, &pDesc32, &pDescSmb);
    localbuf = NULL;
    rc = RxRemoteApi(API_WGroupEnum,        // API #
                    ServerName,             // where to remote it
                    REMSmb_NetGroupEnum_P,  // parameter descriptor
                    pDesc16,                // Data descriptor/16-bit
                    pDesc32,                // Data descriptor/32-bit
                    pDescSmb,               // Data descriptor/SMB
                    NULL,                   // Aux descriptor/16-bit
                    NULL,                   // Aux descriptor/32-bit
                    NULL,                   // Aux descriptor/SMB
                    ALLOCATE_RESPONSE,
                    Level,                  // caller supplied parameters...
                    &localbuf,
                    65535,
                    &entries_read,          // parm 4
                    &total_avail            // parm 5
                    );

    if (rc != NERR_Success) {
        if (localbuf != NULL) {
            (void) NetApiBufferFree(localbuf);
        }
    } else {
        *Buffer = localbuf;
        *EntriesRead = entries_read;
        *EntriesLeft = total_avail;
    }
    return rc;
}



NET_API_STATUS
RxNetGroupGetInfo(
    IN  LPTSTR  ServerName,
    IN  LPTSTR  GroupName,
    IN  DWORD   Level,
    OUT LPBYTE* Buffer
    )

/*++

Routine Description:

    Get information about a specific group in a down-level UAS database

Arguments:

    ServerName  - at which server to perform this request
    GroupName   - name of group to get information for
    Level       - level of information to return (0 or 1)
    Buffer      - pointer to returned pointer to info buffer

Return Value:

    NET_API_STATUS:
        Success = NERR_Success
        Failure = ERROR_INVALID_LEVEL
                    Level parameter must be 0 or 1
                  ERROR_INVALID_PARAMETER
                    Buffer parameter NULL pointer
--*/

{
    NET_API_STATUS  rc;
    LPDESC  pDesc16;        // pointer to 16-bit info descriptor for RxRemoteApi
    LPDESC  pDesc32;        // pointer to 32-bit info descriptor for RxRemoteApi
    LPDESC  pDescSmb;       // pointer to SMB info descriptor for RxRemoteApi
    LPBYTE  localbuf;       // pointer to buffer allocated in this routine
    DWORD   totalbytes;     // total available bytes returned from down-level
    DWORD   buflen;         // size of info buffer, supplied by us


    if (Level > 1) {
        return ERROR_INVALID_LEVEL;
    }

    if (!Buffer) {
        return ERROR_INVALID_PARAMETER;
    }

    //
    // calculate the size requirement for the info buffer and allocate it
    //

    buflen = ((Level == 1) ? sizeof(GROUP_INFO_1) : sizeof(GROUP_INFO_0))
        + 2 * (LM20_GNLEN + 1);
    buflen += (Level == 1) ? 2 * (LM20_MAXCOMMENTSZ + 1) : 0;
    buflen = DWORD_ROUNDUP(buflen);

    if (rc = NetApiBufferAllocate(buflen, (LPVOID *) &localbuf)) {
        return rc;
    }
    get_group_descriptors(Level, &pDesc16, &pDesc32, &pDescSmb);
    rc = RxRemoteApi(API_WGroupGetInfo,         // API #
                    ServerName,                 // where to remote it
                    REMSmb_NetGroupGetInfo_P,   // parameter descriptor
                    pDesc16,                    // Data descriptor/16-bit
                    pDesc32,                    // Data descriptor/32-bit
                    pDescSmb,                   // Data descriptor/SMB
                    NULL,                       // Aux descriptor/16-bit
                    NULL,                       // Aux descriptor/32-bit
                    NULL,                       // Aux descriptor/SMB
                    FALSE,                      // this call needs user to be logged on
                    GroupName,                  // parms to down-level start here
                    Level,                      // caller supplied parameters...
                    localbuf,                   // buffer for receiving structures
                    buflen,                     // size of buffer supplied by us
                    &totalbytes                 // returned from down-level. not used
                    );
    if (rc == NERR_Success) {
        *Buffer = localbuf;
    } else {
        (void) NetApiBufferFree(localbuf);
    }
    return rc;
}



NET_API_STATUS
RxNetGroupGetUsers(
    IN  LPTSTR  ServerName,
    IN  LPTSTR  GroupName,
    IN  DWORD   Level,
    OUT LPBYTE* Buffer,
    IN  DWORD   PrefMaxLen,
    OUT LPDWORD EntriesRead,
    OUT LPDWORD EntriesLeft,
    IN OUT PDWORD_PTR ResumeHandle OPTIONAL
    )

/*++

Routine Description:

    Get a list of all the members of a particular group

Arguments:

    ServerName  - at which server to perform this request
    GroupName   - name of group for which to retrieve member list
    Level       - level of group user information requested. Must be 0
    Buffer      - pointer to returned pointer to buffer containing info
    PrefMaxLen  - preferred maximum length of returned buffer
    EntriesRead - pointer to returned number of entries in buffer
    EntriesLeft - pointer to returned number of entries left
    ResumeHandle- pointer to handle for resume. Not used by this function

Return Value:

    NET_API_STATUS:
        Success = NERR_Success
        Failure = ERROR_INVALID_LEVEL
                    Level parameter must be 0
                  ERROR_INVALID_PARAMETER
                    Buffer parameter NULL pointer
                    or ResumeHandle not NULL pointer or pointer to non-0 value
                    or GroupName not valid string
--*/

{
    NET_API_STATUS  rc;
    LPBYTE  localbuf;       // pointer to buffer allocated in this routine
    DWORD   entries_read, total_entries;

    UNREFERENCED_PARAMETER(PrefMaxLen);

    //
    // set EntriesLeft and EntriesRead to default values. Test writability of
    // parameters
    //

    *EntriesRead = *EntriesLeft = 0;
    *Buffer = NULL;

    if (Level) {
        return ERROR_INVALID_LEVEL;
    }

    if (!NULL_REFERENCE(ResumeHandle) || !VALID_STRING(GroupName)) {
        return ERROR_INVALID_PARAMETER;
    }

    localbuf = NULL;
    rc = RxRemoteApi(API_WGroupGetUsers,        // API #
                    ServerName,                 // where to remote it
                    REMSmb_NetGroupGetUsers_P,  // parameter descriptor
                    REM16_group_users_info_0,   // Data descriptor/16-bit
                    REM32_group_users_info_0,   // Data descriptor/32-bit
                    REMSmb_group_users_info_0,  // Data descriptor/SMB
                    NULL,                       // Aux descriptor/16-bit
                    NULL,                       // Aux descriptor/32-bit
                    NULL,                       // Aux descriptor/SMB
                    ALLOCATE_RESPONSE,
                    GroupName,                  // which group
                    0,                          // Level can only be 0 - push immediate
                    &localbuf,                  // buffer for receiving structures
                    65535,
                    &entries_read,              // number of structures returned
                    &total_entries              // total number of structures
                    );

    if (rc == NERR_Success) {
        *Buffer = localbuf;
        *EntriesRead = entries_read;
        *EntriesLeft = total_entries;
    } else {
        if (localbuf != NULL) {
            (void) NetApiBufferFree(localbuf);
        }
    }
    return rc;
}



NET_API_STATUS
RxNetGroupSetInfo(
    IN  LPTSTR  ServerName,
    IN  LPTSTR  GroupName,
    IN  DWORD   Level,
    IN  LPBYTE  Buffer,
    OUT LPDWORD ParmError OPTIONAL
    )

/*++

Routine Description:

    Set information about a group in a down-level UAS database

    Assumes:
        1.  GroupName, Buffer and Level have been validated
        2.  There are only 2 possible levels - 1 & GROUP_COMMENT_INFOLEVEL (1002)

Arguments:

    ServerName  - at which server to perform this request
    GroupName   - name of group about which to set info
    Level       - level of info provided - 1 or 1002 (group comment)
    Buffer      - pointer to caller's buffer containing info to set
    ParmError   - pointer to returned parameter error

Return Value:

    NET_API_STATUS:
        Success = NERR_Success
        Failure = ERROR_INVALID_LEVEL
                    Level parameter must be 1 or 1002 (comment)
                  ERROR_INVALID_PARAMETER
                    Buffer parameter NULL pointer
                    or GroupName not valid string

--*/

{
    DWORD   parmnum;
    DWORD   buflen;
    DWORD   badparm;
    DWORD   len;
    LPTSTR  pointer;
    DWORD   field_index;


    if (ParmError == NULL) {
        ParmError = &badparm;
    }
    *ParmError = PARM_ERROR_NONE;

    if (!VALID_STRING(GroupName) || !Buffer) {
        return ERROR_INVALID_PARAMETER;
    }

    if (STRLEN(GroupName) > LM20_GNLEN) {
        return ERROR_INVALID_PARAMETER;
    }

    //
    // check the requested level and convert to down-level parmnum. Info level
    // is always 1 for down-level
    //

    if (Level == 1) {   // entire GROUP_INFO_1 structure
        buflen = sizeof(GROUP_INFO_1);
        if (len = POSSIBLE_STRLEN(((PGROUP_INFO_1)Buffer)->grpi1_name)) {
            if (len > LM20_GNLEN) {
                *ParmError = GROUP_NAME_INFOLEVEL;
                return ERROR_INVALID_PARAMETER;
            } else {
                buflen += len + 1;
            }
        }
        pointer = (LPTSTR)((PGROUP_INFO_1)Buffer)->grpi1_comment;
        parmnum = PARMNUM_ALL;
        field_index = 0;
    } else {
        pointer = (LPTSTR)Buffer;
        parmnum = GROUP_COMMENT_PARMNUM;
        buflen = 0;

        //
        // The parmnum is SUPPOSED to be the ordinal number of the field, but
        // some dope forgot that pad bytes are actually fields too, and messed
        // up the nice convention. Hence this kludge. ParmNum 2 (comment field)
        // for down-level, is actually group_info_1 structure field 3. Where
        // *does* Microsoft find its employees?
        // Note for the unenlightened: (aka disclaimer by me (basically: its not my fault))
        // If we have a structure thus:
        //      struct group_info_1 {
        //          char        grpi1_name[GNLEN + 1];
        //          char        grpi1_pad;
        //          char far*   grpi1_comment;
        //      };
        // there will be a corresponding descriptor (ie a picture of what the
        // structure looks like) thus:
        //      "B21Bz"
        // Parmnums start at 1 (0 means entire structure). Thus, it is possible,
        // knowing the format of descriptor strings, given a ParmNum, to come up
        // with the corresponding field type (and its length). This info is used
        // inside of RxRemoteApi (which if you look ahead, you'll see we're just
        // about to call).
        // In this particular case, there are 3 fields - B21 = embedded 21-byte
        // group name, B = single byte pad character (put back on WORD boundary),
        // z = pointer to ASCIZ string. There are indeed only 2 meaningful fields
        // (name & comment), but that extra B pad field is significant.
        // Therefore we have to provide a ParmNum of 2 which is put on the wire,
        // so that the down-level code knows of what we speak, and a field index
        // of 3 so that the Rap code underneath RxRemoteApi can divine that what
        // we're sending is an ASCIZ string, not a single byte
        // Messy, innit
        //

        field_index = 3;
    }

    if (len = POSSIBLE_STRLEN(pointer)) {
        if (len > LM20_MAXCOMMENTSZ) {
            *ParmError = GROUP_COMMENT_INFOLEVEL;
            return ERROR_INVALID_PARAMETER;
        } else {
            buflen += len + 1;
        }
    }

    //
    // if, by some unforeseen accident, the down-level routine returns an
    // ERROR_INVALID_PARAMETER, the caller will just have to content him/her/it
    // self (no lifeform prejudices here at MS) with an unknown parameter
    // causing the calamity
    //

    *ParmError = PARM_ERROR_UNKNOWN;
    return RxRemoteApi(API_WGroupSetInfo,       // API #
                    ServerName,                 // where to remote it
                    REMSmb_NetGroupSetInfo_P,   // parameter descriptor
                    REM16_group_info_1,         // 16-bit data descriptor
                    REM32_group_info_1,         // 32-bit data descriptor
                    REMSmb_group_info_1,        // SMB data descriptor
                    NULL,                       // 16-bit aux data descriptor
                    NULL,                       // 32-bit aux data descriptor
                    NULL,                       // SMB aux data descriptor
                    FALSE,                      // this API requires user security
                    GroupName,                  // setinfo parm 1
                    1,                          // info level must be 1
                    Buffer,                     // caller's info to set
                    buflen,                     // length of caller's info

                    //
                    // glue ParmNum and field_index together
                    //

                    MAKE_PARMNUM_PAIR(parmnum, field_index)
                    );
}



NET_API_STATUS
RxNetGroupSetUsers(
    IN  LPTSTR  ServerName,
    IN  LPTSTR  GroupName,
    IN  DWORD   Level,
    IN  LPBYTE  Buffer,
    IN  DWORD   Entries
    )

/*++

Routine Description:

    The purpose of this function is to force a group to have as its member list
    only those users that are named in <Buffer>. If the user is not currently a
    member of group <GroupName>, it is made so; if there are other users who are
    currently members of group <GroupName>, but are not named in Buffer, then
    they are removed from group <GroupName>.

    This is a somewhat "funny" function - it expects a buffer containing
    GROUP_USERS_INFO_0 structures, but has to force a in structure with an
    aux count at the head of the buffer. Why couldn't it request that the
    caller place one of these at the start of the buffer to save us the work?

Arguments:

    ServerName  - at which server to perform this request
    GroupName   - Name of group to set users for
    Level       - Must Be Zero
    Buffer      - pointer to buffer containing GROUP_USERS_INFO_0 structures
    Entries     - number of GROUP_USERS_INFO_0 structures in Buffer

Return Value:

    NET_API_STATUS:
        Success = NERR_Success
        Failure = ERROR_INVALID_LEVEL
                    Level parameter must be 0
                  ERROR_INVALID_PARAMETER
                    GroupName length exceeds LM20 maximum for type
                    user name in Buffer not valid string
                    user name in Buffer exceeds LM20 maximum for type
--*/

{
    NET_API_STATUS  rc;
    LPGROUP_USERS_INFO_0    users_info;
    DWORD   i;
    DWORD   buflen;
    LPBYTE  newbuf;
    static  LPDESC  users_0_enumerator_desc16 = "B21BN";
    static  LPDESC  users_0_enumerator_desc32 = "zQA";

    //
    // a little local structure never hurt anybody...
    // This structure is required because the remoting code (particularly down
    // level) can only handle there being >1 auxiliary structure, vs >1
    // primary. Hence we have to convert the caller's supplied buffer of
    // erstwhile primary structures to auxiliaries by forcing the structure
    // below in at the head of the buffer, hence becoming the primary and
    // providing an aux structure count (groan)
    //

    struct users_0_enumerator {
        LPTSTR  group_name;
        DWORD   user_count;     // number of GROUP_USERS_INFO_0 structures in buffer
    };

    if (Level) {
        return ERROR_INVALID_LEVEL; // MBZ, remember?
    }

    //
    // only check we can make on the group name is to ensure it is within the
    // down-level limits for length. GroupName should be already verified as
    // a pointer to a valid string
    //

    if (STRLEN(GroupName) > LM20_GNLEN) {
        return ERROR_INVALID_PARAMETER;
    }

    //
    // iterate through the buffer, checking that each GROUP_USERS_INFO_0
    // structure contains a pointer to a valid string which is in the
    // correct range
    //

    users_info = (LPGROUP_USERS_INFO_0)Buffer;
    for (i=0; i<Entries; ++i) {
        if (!VALID_STRING(users_info->grui0_name)) {
            return ERROR_INVALID_PARAMETER;
        }
        if (wcslen(users_info->grui0_name) > LM20_UNLEN) {
            return ERROR_INVALID_PARAMETER;
        }
        ++users_info;
    }

    //
    // allocate a buffer large enough to fit in <Entries> number of
    // GROUP_USERS_INFO_0 structures, and 1 users_0_enumerator structure.
    // Don't worry about string space - unfortunately the Rxp and Rap routines
    // called by RxRemoteApi will allocate yet another buffer, do yet another
    // copy and this time copy in the strings from user space. Hopefully, this
    // routine won't get called too often
    //

    buflen = Entries * sizeof(GROUP_USERS_INFO_0) + sizeof(struct users_0_enumerator);
    buflen = DWORD_ROUNDUP(buflen);

    if (rc = NetApiBufferAllocate(buflen, (LPVOID *) &newbuf)) {
        return rc;  // aieegh! Failed to allocate memory?
    }

    ((struct users_0_enumerator*)newbuf)->group_name = GroupName;
    ((struct users_0_enumerator*)newbuf)->user_count = Entries;
    if (Entries) {
        NetpMoveMemory(newbuf + sizeof(struct users_0_enumerator),
                       Buffer,
                       buflen - sizeof(struct users_0_enumerator)
                       );
    }

    rc = RxRemoteApi(API_WGroupSetUsers,        // API #
                    ServerName,                 // where to remote it
                    REMSmb_NetGroupSetUsers_P,  // parameter descriptor
                    users_0_enumerator_desc16,  // the "fudged" 16-bit data descriptor
                    users_0_enumerator_desc32,  // the "fudged" 32-bit data descriptor
                    users_0_enumerator_desc16,  // SMB desc same as 16-bit
                    REM16_group_users_info_0,   // "new" 16-bit aux descriptor
                    REM32_group_users_info_0,   // "new" 32-bit aux descriptor
                    REMSmb_group_users_info_0,  // SMB aux descriptor
                    FALSE,                      // this API requires user security
                    GroupName,                  // setinfo parm 1
                    0,                          // info level must be 0
                    newbuf,                     // "fudged" buffer
                    buflen,                     // length of "fudged" buffer
                    Entries                     // number of GROUP_USERS_INFO_0
                    );
    NetpMemoryFree(newbuf);
    return rc;
}



DBGSTATIC
VOID
get_group_descriptors(
    IN  DWORD   Level,
    OUT LPDESC* pDesc16,
    OUT LPDESC* pDesc32,
    OUT LPDESC* pDescSmb
    )

/*++

Routine Description:

    Returns the descriptor strings for the various Group Info levels (0 or 1)

Arguments:

    Level   - of info required
    pDesc16 - pointer to returned 16-bit data descriptor
    pDesc32 - pointer to returned 32-bit data descriptor
    pDescSmb - pointer to returned SMB data descriptor

Return Value:

    None.

--*/

{
    switch (Level) {
        case 0:
            *pDesc16 = REM16_group_info_0;
            *pDesc32 = REM32_group_info_0;
            *pDescSmb = REMSmb_group_info_0;
            break;

        case 1:
            *pDesc16 = REM16_group_info_1;
            *pDesc32 = REM32_group_info_1;
            *pDescSmb = REMSmb_group_info_1;
            break;

#if DBG
        default:
            NetpKdPrint(("%s.%u Unknown Level parameter: %u\n", __FILE__, __LINE__, Level));
            NetpBreakPoint();
#endif
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\rpcxlate\rxapi\rxshare.c ===
/*++

Copyright (c) 1991-92  Microsoft Corporation

Module Name:

    rxshare.c

Abstract:

    Contains down-level remoted RxNetShare routines:
        RxNetShareAdd
        RxNetShareCheck
        RxNetShareDel
        RxNetShareEnum
        RxNetShareGetInfo
        RxNetShareSetInfo
        (GetShareInfoDescriptors)
        (ConvertMaxUsesField)

Author:

    Richard Firth (rfirth) 20-May-1991

Environment:

    Win-32/flat address space

Notes:

    Routines in this module assume that caller-supplied parameters have
    already been verified. No effort is made to further check the veracity
    of parms. Any actions causing exceptions must be trapped at a higher
    level. This applies to ALL parameters - strings, pointers, buffers, etc.

Revision History:

    08-Apr-1992
        Try to avoid >1 calls to down-level server for RxNetShareEnum
        Fix problem of converting 16-bit numbers >32768 into negative 32-bit
        numbers on GetInfo and Enum: 65535 is a special value; everything
        else in unsigned 16-bit

    01-Apr-1992 JohnRo
        Prevent too large size requests.
        Use NetApiBufferAllocate() instead of private version.

    05-Dec-1991 RFirth
        Enum returns in TotalEntries (or EntriesLeft) the number of items to
        be enumerated BEFORE this call. Used to be number left after this call

    21-Nov-1991 JohnRo
        Removed NT dependencies to reduce recompiles.

    16-Sep-1991 JohnRo
        Use DBGSTATIC for nonexported routines.

    13-Sep-1991 JohnRo
        Corrected typedef used for descriptors (LPDESC, not LPTSTR).
        Made changes suggested by PC-LINT.

    20-May-1991 RFirth
        Created

--*/



#include "downlevl.h"
#include "rxshare.h"
#include <lmshare.h>    // typedefs for SHARE_INFO etc.



#define SHARE_ADD_LEVEL 2   // only level at which we can add stuff down-stream
#define INITIAL_BUFFER_SIZE 4096    // Arbitrary! But can't be integral multiple of infolen



//
// prototypes
//

DBGSTATIC void
GetShareInfoDescriptors(
    IN  DWORD   level,
    OUT LPDESC* pDesc16,
    OUT LPDESC* pDesc32,
    OUT LPDESC* pDescSmb,
    OUT LPDWORD pDatasize
    );

DBGSTATIC
VOID
ConvertMaxUsesField(
    IN  LPSHARE_INFO_2 Buffer,
    IN  DWORD NumberOfLevel2Structures
    );



NET_API_STATUS
RxNetShareAdd(
    IN  LPTSTR  ServerName,
    IN  DWORD   Level,
    IN  LPBYTE  Buffer,
    OUT LPDWORD ParmError OPTIONAL
    )

/*++

Routine Description:

    Attempts the NetShareAdd API at the named server. The server supports an
    earlier version of LanMan than that under which we are operating so we
    have to slightly modify things in order that the down-level server
    understands the request

    Note: we don't hand back any ParmError information. This level of info
    is primarily supplied by the new (NT) rouines

Arguments:

    ServerName  - at which server to perform this request
    Level       - of information being supplied. Must Be 2
    Buffer      - pointer to supplied level 2 share information buffer
    ParmError   - place to return the id of the parameter causing strife

Return Value:

    NET_API_STATUS:
        Success = NERR_Success
        Failure = ERROR_INVALID_LEVEL
                    Level must be 2
                  (return code from RxRemoteApi)
                  (return code from remoted NetShareAdd API)
--*/

{
    UNREFERENCED_PARAMETER(ParmError);
    UNREFERENCED_PARAMETER(Level);


    if ( Buffer == NULL )
        return ERROR_INVALID_PARAMETER;

#if DBG
    //
    // The ServerName parameter must be a non-NUL(L) string. We know this must
    // be so since (presumably) the server name was used as the criteria to get
    // here. Ensure that this is so (in the non-release version).
    //

    NetpAssert(ServerName != NULL);
    NetpAssert(*ServerName);
#endif

    return RxRemoteApi(API_WShareAdd,       // API #
                    ServerName,             // where it will run
                    REMSmb_NetShareAdd_P,   // parameter descriptor
                    REM16_share_info_2,     // Data descriptor/16-bit
                    REM32_share_info_2,     // Data descriptor/32-bit
                    REMSmb_share_info_2,    // Data descriptor/SMB
                    NULL,                   // Aux descriptor/16-bit
                    NULL,                   // Aux descriptor/32-bit
                    NULL,                   // Aux descriptor/SMB
                    FALSE,                  // this call needs user to be logged on
                    SHARE_ADD_LEVEL,        // level. Since there's only 1 push immediate
                    Buffer,                 // caller's SHARE_INFO_2 struct

                    //
                    // we have to supply the size of the buffer - down-level
                    // expects it, NT doesn't. Defined as the size of the fixed
                    // structure (ie a SHARE_INFO_2) plus the lengths of all
                    // the variable fields (all strings in this case)
                    //

                    sizeof(SHARE_INFO_2) +  // parameter supplied by us
                    POSSIBLE_STRSIZE(((SHARE_INFO_2*)Buffer)->shi2_netname) +
                    POSSIBLE_STRSIZE(((SHARE_INFO_2*)Buffer)->shi2_remark) +
                    POSSIBLE_STRSIZE(((SHARE_INFO_2*)Buffer)->shi2_path) +
                    POSSIBLE_STRSIZE(((SHARE_INFO_2*)Buffer)->shi2_passwd)
                    );
}



NET_API_STATUS
RxNetShareCheck(
    IN  LPTSTR  ServerName,
    IN  LPTSTR  DeviceName,
    OUT LPDWORD Type
    )

/*++

Routine Description:

    Attempts to perform the NetShareCheck API on a remote down-level server

Arguments:

    ServerName  - where this call will happen
    DeviceName  - the thing we are querying
    Type        - where we store share type in the (unlikely) event of success

Return Value:

    NET_API_STATUS
        Success = NERR_Success
        Failure =

--*/

{
#if DBG
    //
    // The ServerName parameter must be a non-NUL(L) string. We know this must
    // be so since (presumably) the server name was used as the criteria to get
    // here. Ensure that this is so (in the non-release version).
    //

    NetpAssert(ServerName != NULL);
    NetpAssert(*ServerName);
#endif

    //
    // We have to have something in the device name
    // Ensure that the caller provided us with the address of the place he/she
    // wants the type info to be left
    //

    if (!VALID_STRING(DeviceName) || Type == NULL) {
        return ERROR_INVALID_PARAMETER;
    }

    return RxRemoteApi(API_NetShareCheck,
                    ServerName,             // where it will run
                    REMSmb_NetShareCheck_P, // parameter descriptor
                    NULL,                   // Data descriptor/16-bit
                    NULL,                   // Data descriptor/32-bit
                    NULL,                   // Data descriptor/SMB
                    NULL,                   // Aux descriptor/16-bit
                    NULL,                   // Aux descriptor/32-bit
                    NULL,                   // Aux descriptor/SMB
                    FALSE,                  // this call needs user to be logged on
                    DeviceName,             // parm 1
                    Type                    // parm 2
                    );
}



NET_API_STATUS
RxNetShareDel(
    IN  LPTSTR  ServerName,
    IN  LPTSTR  NetName,
    IN  DWORD   Reserved
    )

/*++

Routine Description:

    Performs the NetShareDel API at a remote down-level server

Arguments:

    ServerName  - where to perform the request
    NetName     - to remove
    Reserved    - MBZ

Return Value:

    NET_API_STATUS
        Success = NERR_Success
        Failure = ERROR_INVALID_PARAMETER

--*/

{
#if DBG
    //
    // The ServerName parameter must be a non-NUL(L) string. We know this must
    // be so since (presumably) the server name was used as the criteria to get
    // here. Ensure that this is so (in the non-release version).
    //

    NetpAssert(ServerName != NULL);
    NetpAssert(*ServerName);
#endif

    //
    // if the NetName parameter is a NULL pointer or string OR the Reserved
    // parameter is NOT 0 then return an error
    //

    if (!VALID_STRING(NetName) || Reserved) {
        return ERROR_INVALID_PARAMETER;
    }

    //
    // Just call the RpcXlate routine to perform it and return the result
    //

    return RxRemoteApi(API_WShareDel,
                        ServerName,             // where it will run
                        REMSmb_NetShareDel_P,   // parameter descriptor
                        NULL,                   // Data descriptor/16-bit
                        NULL,                   // Data descriptor/32-bit
                        NULL,                   // Data descriptor/SMB
                        NULL,                   // Aux descriptor/16-bit
                        NULL,                   // Aux descriptor/32-bit
                        NULL,                   // Aux descriptor/SMB
                        FALSE,                  // this call needs user to be logged on
                        NetName,                // parm 1
                        0                       // parm 2 (RESERVED - MBZ)
                        );
}



NET_API_STATUS
RxNetShareEnum(
    IN  LPTSTR  ServerName,
    IN  DWORD   Level,
    OUT LPBYTE* Buffer,
    IN  DWORD   PrefMaxLen,
    OUT LPDWORD EntriesRead,
    OUT LPDWORD EntriesLeft,
    IN OUT LPDWORD ResumeHandle OPTIONAL
    )

/*++

Routine Description:

    Performs NetShareEnum API at a remote down-level server. Any returned info
    will be in 32-bit LanMan format. Information returned in buffer sourced by
    this routine. Caller must use NetApiBufferFree when returned buffer no
    longer required

Arguments:

    ServerName  - where to perform the request
    Level       - of info to return. Can be 0, 1 or 2
    Buffer      - pointer to pointer to returned info buffer
    PrefMaxLen  - caller preferred maximum size of returned buffer
    EntriesRead - pointer to number of entries being returned from this call
    EntriesLeft - pointer to total number of share info structures which could be returned
    ResumeHandle- NOT Allowed on down level versions. Must Be NULL

Return Value:

    NET_API_STATUS
        Success = NERR_Success
        Failure = ERROR_INVALID_LEVEL
                    Level parameter not in range 0 <= Level <= 2
                  ERROR_INVALID_PARAMETER
                    Non-NULL ResumeHandle. ResumeHandle can be NULL or a
                    pointer to 0
                  (return code from NetApiBufferAllocate)
                  (return code from RxRemoteApi)
--*/

{
    NET_API_STATUS  rc;
    DWORD   array_size;
    LPDESC  pDesc16;
    LPDESC  pDesc32;
    LPDESC  pDescSmb;
    LPBYTE  ourbuf;
    DWORD   infolen;
    DWORD   entries_read, total_avail;


    UNREFERENCED_PARAMETER(PrefMaxLen);

#if DBG
    //
    // The ServerName parameter must be a non-NUL(L) string. We know this must
    // be so since (presumably) the server name was used as the criteria to get
    // here. Ensure that this is so (in the non-release version).
    //

    NetpAssert(ServerName != NULL);
    NetpAssert(*ServerName);
#endif

    //
    // Set the number of entries read and total available to sensible defaults.
    // Side effect of testing writability of supplied parameters
    //

    //
    // I assume that:
    //  Buffer is a valid, non-NULL pointer
    //  EntriesRead is a valid, non-NULL pointer
    //  EntriesLeft is a valid, non-NULL pointer
    // since these should have been verified at the API level
    //

    *Buffer = NULL;
    *EntriesRead = 0;
    *EntriesLeft = 0;

    //
    // Check for invalid parameters.
    // NB Does Assume that DWORD is unsigned
    // Ensure that:
    //  Level is not >2
    //  ResumeHandle is NULL or a pointer to NULL
    //

    if ((ResumeHandle != NULL) && *ResumeHandle) {
        return ERROR_INVALID_PARAMETER;
    }

    if (Level > 2) {
        return ERROR_INVALID_LEVEL;
    }

    //
    // Decide which descriptors to use, based on the Level parameter
    //

    GetShareInfoDescriptors(Level, &pDesc16, &pDesc32, &pDescSmb, &infolen);
    ourbuf = NULL;

    //
    // here we used to let RxRemoteApi allocate a buffer (64K intermediate)
    // and do the transaction, returning us a buffer just large enough to
    // hold the returned information. WinBall server barfs if it gets a
    // request with a 64K buffer, so we have to solicit size info until we
    // get everything back. Unfortunately - as of writing - we have no way
    // of knowing the type of server we will make the transaction request to
    // so we may end up having to make >1 request to a LM 2.1 server where
    // we used to be able to get away with 1. On the other hand we can't risk
    // upsetting the WB server. Compromise time. Send a 'reasonable' sized
    // request to the other side (4K buffer). If it isn't sufficient then
    // we loop again, allocating the required buffer
    //

    //
    // what about a LRU cache which keeps the size of the buffer required
    // to satisfy an enum request to a particular down-level server?
    //

    //
    // Loop until we have enough memory or we die for some other reason.
    //

    array_size = INITIAL_BUFFER_SIZE;

    do {

        // Figure out how much memory we need.

        //
        // Remote the API, which will allocate the array for us.
        //

        rc = RxRemoteApi(API_WShareEnum,
                    ServerName,             // where it will run
                    REMSmb_NetShareEnum_P,  // parameter descriptor
                    pDesc16,                // Data descriptor/16-bit
                    pDesc32,                // Data descriptor/32-bit
                    pDescSmb,               // Data descriptor/SMB
                    NULL,                   // Aux descriptor/16-bit
                    NULL,                   // Aux descriptor/32-bit
                    NULL,                   // Aux descriptor/SMB
                    ALLOCATE_RESPONSE,      // allocate a buffer for us
                    Level,                  // level parameter
                    &ourbuf,                // pointer to allocated buffer
                    array_size,             // size of down-level buffer
                    &entries_read,          // pointer to entries read variable
                    &total_avail            // pointer to total entries variable
                    );

        if (rc == ERROR_MORE_DATA) {
            (void) NetApiBufferFree( ourbuf );
            ourbuf = NULL;

            if (array_size >= MAX_TRANSACT_RET_DATA_SIZE) {
                //
                // No point in trying with a larger buffer
                //
                break;
            }
#if DBG
            NetpAssert(array_size != total_avail * infolen);
#endif
            array_size = (total_avail * infolen);
            if (array_size > MAX_TRANSACT_RET_DATA_SIZE) {
                //
                // Try once more with the maximum-size buffer
                //
                array_size = MAX_TRANSACT_RET_DATA_SIZE;
            }
#if DBG
            NetpAssert( array_size != 0 );
#endif
        }
    } while (rc == ERROR_MORE_DATA);

    //
    // if we met with an error then free the allocated buffer and return the
    // error to the caller. If there was no error then we return the items
    // received from the down-level server
    //

    if (rc) {
        if (ourbuf != NULL) {
            (void) NetApiBufferFree(ourbuf);
        }
    } else {
        if (Level == 2) {
            ConvertMaxUsesField((LPSHARE_INFO_2)ourbuf, entries_read);
        }
        *Buffer = ourbuf;
        *EntriesRead = entries_read;
        *EntriesLeft = total_avail;
    }
    return rc;
}



NET_API_STATUS
RxNetShareGetInfo(
    IN  LPTSTR  ServerName,
    IN  LPTSTR  NetName,
    IN  DWORD   Level,
    OUT LPBYTE* Buffer
    )

/*++

Routine Description:

    Performs the NetShareGetInfo API at a remote down-level server. The returned
    information will be in 32-bit LanMan format. Returns single information
    structure in a buffer sourced in this routine. Caller must use
    NetApiBufferFree when finished with buffer

Arguments:

    ServerName  - where to perform the request
    NetName     - name of thing to get information about
    Level       - level of information requested - 0, 1, 2 are valid
    Buffer      - pointer to pointer to returned buffer

Return Value:

    NET_API_STATUS
        Success = NERR_Success
        Failure = ERROR_INVALID_LEVEL
                  ERROR_INVALID_PARAMETER
                  (return code from NetApiBufferAllocate)
                  (return code from RxRemoteApi)
--*/

{
    NET_API_STATUS  rc;
    LPDESC  pDesc16;        // pointer to 16-bit info descriptor for RxRemoteApi
    LPDESC  pDesc32;        // pointer to 32-bit info descriptor for RxRemoteApi
    LPDESC  pDescSmb;       // pointer to SMB info descriptor for RxRemoteApi
    LPBYTE  ourbuf;         // buffer we allocate, fill, and give to the caller
    DWORD   total_avail;    // 32-bit total available if supplied buffer too small
    DWORD   infolen;        // 32-bit place to store size of required buffer


#if DBG
    //
    // The ServerName parameter must be a non-NUL(L) string. We know this must
    // be so since (presumably) the server name was used as the criteria to get
    // here. Ensure that this is so (in the non-release version).
    //

    NetpAssert(ServerName != NULL);
    NetpAssert(*ServerName);
#endif

    //
    // Preset Buffer and check it is valid pointer
    //

    *Buffer = NULL;

    //
    // Perform parameter validity checks:
    //      Level must be in range 0 <= Level <= 2
    //      NetName must be non-NULL pointer to non-NULL string
    //      Buffer must be non-NULL pointer
    // NB. Assumes DWORD is unsigned quantity
    //

    if (Level > 2) {
        return ERROR_INVALID_LEVEL;
    }

    if (!VALID_STRING(NetName) || !Buffer) {
        return ERROR_INVALID_PARAMETER;
    }

    //
    // Work out the descriptor and buffer size requirements based on the
    // requested level
    //

    GetShareInfoDescriptors(Level, &pDesc16, &pDesc32, &pDescSmb, &infolen);

    //
    // allocate a buffer size required to fit in 1 structure at info level
    // requested. If the allocation fails then return the error
    // We have to allocate space for the strings too, don't forget
    //

    ourbuf = NULL;

    rc = RxRemoteApi(API_WShareGetInfo,
                    ServerName,                 // where it will happen
                    REMSmb_NetShareGetInfo_P,   // parameter descriptor
                    pDesc16,                    // Data descriptor/16-bit
                    pDesc32,                    // Data descriptor/32-bit
                    pDescSmb,                   // Data descriptor/SMB
                    NULL,                       // Aux descriptor/16-bit
                    NULL,                       // Aux descriptor/32-bit
                    NULL,                       // Aux descriptor/SMB
                    ALLOCATE_RESPONSE,          // allocate a buffer for us
                    NetName,                    // pointer to thing to get info on
                    Level,                      // level of info
                    &ourbuf,                    // pointer to buffer sourced by us
                    infolen,                    // size of our sourced buffer
                    &total_avail                // pointer to total available
                    );

    //
    // If the remote NetShareGetInfo call succeeded then give the returned
    // buffer to the caller
    //

    if (rc == NERR_Success) {
        if (Level == 2) {
            ConvertMaxUsesField((LPSHARE_INFO_2)ourbuf, 1);
        }
        *Buffer = ourbuf;
    } else if (ourbuf) {

        //
        // if we didn't record a success then free the buffer we previously allocated
        //

        (void) NetApiBufferFree(ourbuf);
    }
    return rc;
}



NET_API_STATUS
RxNetShareSetInfo(
    IN  LPTSTR  ServerName,
    IN  LPTSTR  NetName,
    IN  DWORD   Level,
    IN  LPBYTE  Buffer,
    OUT LPDWORD ParmError OPTIONAL
    )

/*++

Routine Description:

    Performs the NetShareSetInfo API at a remote down-level server

Arguments:

    ServerName  - where to perform the request
    NetName     - name of thing for which to set info
    Level       - level of information - 0, 1, 2, 1004, 1005, 1006, 1009
    Buffer      - buffer containing info at defined level
    ParmError   - pointer to invalid parameter ordinal

Return Value:

    NET_API_STATUS
        Success = NERR_Success
        Failure = ERROR_INVALID_LEVEL
                  ERROR_INVALID_PARAMETER
                  (return code from RxRemoteApi)
--*/

{
    DWORD   infolen;    // size of structure
    DWORD   parmnum;    // we have to cobble down-level parmnum from Level
    LPDESC  pDesc16;    // used in call to GetShareInfoDescriptors
    LPDESC  pDesc32;    // ditto. Only interested in length of info structure
    LPDESC  pDescSmb;   // ditto. Only interested in length of info structure


    UNREFERENCED_PARAMETER(ParmError);

#if DBG
    //
    // The ServerName parameter must be a non-NUL(L) string. We know this must
    // be so since (presumably) the server name was used as the criteria to get
    // here. Ensure that this is so (in the non-release version).
    //

    NetpAssert(ServerName != NULL);
    NetpAssert(*ServerName);
#endif

    //
    // Perform parameter validity checks:
    //      NetName must be non-NULL pointer to non-NULL string
    //      Buffer must be non-NULL pointer to non-NULL pointer
    //      Level must be in range
    // NB. Assumes that DWORD is unsigned!
    //

    if (!VALID_STRING(NetName) || !Buffer) {
        return ERROR_INVALID_PARAMETER;
    }

    if (Level < 1 || (Level > 2 && (Level < 1004 || (Level > 1006 && Level != 1009)))) {
        return ERROR_INVALID_LEVEL;
    }

    //
    // We can set individual info fields using the levels > 1000. We have to
    // create level and parmnum info for down-level
    //

    if (Level > 2) {
        //
        // Individual fields are indicated by the old (down-level) parmnum,
        // augmented by 1000. Split level and parmnum parameters
        //

        parmnum = Level - PARMNUM_BASE_INFOLEVEL;
        Level = 2;
        pDesc16 = REM16_share_info_2_setinfo;
        pDesc32 = REM32_share_info_2_setinfo;
        pDescSmb = REMSmb_share_info_2_setinfo;

        switch (parmnum) {
            case 4: // remark
            case 9: // password
                infolen = STRSIZE( (LPTSTR)Buffer );
                break;

            case 5: // permissions
            case 6: // max uses
                infolen = sizeof(WORD);
                break;
        }
    } else {
        //
        // let GetShareInfoDescriptors give us the size of the buffer
        // that NetShareSetInfo thinks its getting. We have no other way of
        // determining this (have we?). Levels 0 - 2 set the entire structure
        //

        GetShareInfoDescriptors(Level, &pDesc16, &pDesc32, &pDescSmb, &infolen);
        parmnum = PARMNUM_ALL;
    }

    return RxRemoteApi(API_WShareSetInfo,
                    ServerName,                 // where it will run
                    REMSmb_NetShareSetInfo_P,   // parameter descriptor
                    pDesc16,                    // Data descriptor/16-bit
                    pDesc32,                    // Data descriptor/32-bit
                    pDescSmb,                   // Data descriptor/SMB
                    NULL,                       // Aux descriptor/16-bit
                    NULL,                       // Aux descriptor/32-bit
                    NULL,                       // Aux descriptor/SMB
                    FALSE,                      // this call needs user to be logged on
                    NetName,                    // pointer to thing to set info on
                    Level,                      // level of info
                    Buffer,                     // pointer to buffer sourced by caller
                    infolen,                    // size of our buffer

                    //
                    // in this case, the field index and parm num are the
                    // same value
                    //

                    MAKE_PARMNUM_PAIR(parmnum, parmnum) // what we're setting
                    );
}



DBGSTATIC void
GetShareInfoDescriptors(
    DWORD   level,
    LPDESC* pDesc16,
    LPDESC* pDesc32,
    LPDESC* pDescSmb,
    LPDWORD pDataSize
    )

/*++

Routine Description:

    A routinette to return pointers to the 16- and 32-bit share info
    structure descriptor strings for each level (0, 1, 2). Also returns
    the size required for a returned 16-bit structure converted to 32-bit data

Arguments:

    level       - of information to be returned
    pDesc16     - pointer to returned 16-bit descriptor string
    pDesc32     - pointer to returned 32-bit descriptor string
    pDescSmb    - pointer to returned SMB descriptor string
    pDataSize   - pointer to returned size of 16-bit structure

Return Value:

    None.

--*/

{
    switch (level) {
        case 0:
            *pDesc16 = REM16_share_info_0;
            *pDesc32 = REM32_share_info_0;
            *pDescSmb = REMSmb_share_info_0;
            *pDataSize = DWORD_ROUNDUP(sizeof(SHARE_INFO_0) // structure size
                            + LM20_NNLEN + 1);              // + shi0_netname len
            break;

        case 1:
            *pDesc16 = REM16_share_info_1;
            *pDesc32 = REM32_share_info_1;
            *pDescSmb = REMSmb_share_info_1;
            *pDataSize = DWORD_ROUNDUP(sizeof(SHARE_INFO_1) // structure size
                            + LM20_NNLEN + 1                // + shi1_netname len
                            + LM20_MAXCOMMENTSZ + 1);       // + shi1_remark len
            break;

        case 2:
            *pDesc16 = REM16_share_info_2;
            *pDesc32 = REM32_share_info_2;
            *pDescSmb = REMSmb_share_info_2;
            *pDataSize = DWORD_ROUNDUP(sizeof(SHARE_INFO_2) // structure size
                            + LM20_NNLEN + 1                // + shi2_netname len
                            + LM20_MAXCOMMENTSZ + 1         // + shi2_remark len
                            + LM20_PATHLEN + 1              // + shi2_path len
                            + SHPWLEN + 1);                 // + shi2_passwd len
            break;

#if DBG
        //
        // just to be completely paranoid...
        //

        default:
            NetpKdPrint(("%s.%u Unknown Level parameter: %u\n", __FILE__, __LINE__, level));
#endif
    }

#if DBG
    NetpAssert(INITIAL_BUFFER_SIZE % *pDataSize);
#endif
}

DBGSTATIC
VOID
ConvertMaxUsesField(
    IN  LPSHARE_INFO_2 Buffer,
    IN  DWORD NumberOfLevel2Structures
    )

/*++

Routine Description:

    Given a buffer containing 1 or more SHARE_INFO_2 structures, converts the
    shi2_max_uses field to a sensible value. The underlying RAP code converts
    the 16-bit number as a signed value, such that 32768 => -32768L. 65535 is
    the only 16-bit value which should be sign-extended. Everything else
    should be represented as the same number in 32-bits

Arguments:

    Buffer                      - pointer to list of SHARE_INFO_2 structures
    NumberOfLevel2Structures    - how many structures in list

Return Value:

    None.

--*/

{
    while (NumberOfLevel2Structures--) {
        if (Buffer->shi2_max_uses != -1L) {
            Buffer->shi2_max_uses &= 0xffffL;
        }
        ++Buffer;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\rpcxlate\rxapi\sesscopy.c ===
/*++

Copyright (c) 1991-92  Microsoft Corporation

Module Name:

    SessCopy.c

Abstract:

    This file contains RxpCopyAndConvertSessions().

Author:

    John Rogers (JohnRo) 17-Oct-1991

Environment:

    Portable to any flat, 32-bit environment.  (Uses Win32 typedefs.)
    Requires ANSI C extensions: slash-slash comments, long external names.

Revision History:

    17-Oct-1991 JohnRo
        Created.
    21-Nov-1991 JohnRo
        Removed NT dependencies to reduce recompiles.
    07-Feb-1992 JohnRo
        Fixed the infamous NetSessionEnum bug (where 1-2 sessions OK, 3 or
        more results in first few being trashed).
        Call NetApiBufferAllocate() instead of private version.

--*/


// These must be included first:

#include <windef.h>             // IN, DWORD, etc.
#include <lmcons.h>             // NET_API_STATUS, etc.
#include <lmshare.h>            // Required by rxsess.h.
#include <rap.h>                // LPDESC.  (Needed by strucinf.h.)

// These may be included in any order:

#include <lmapibuf.h>           // NetApiBufferAllocate().
#include <lmerr.h>              // ERROR_ and NERR_ equates.
#include <netdebug.h>           // DBGSTATIC, NetpKdPrint(()), FORMAT_ equates.
#include <netlib.h>             // NetpPointerPlusSomeBytes, etc.
#include <rxpdebug.h>           // IF_DEBUG().
#include <rxsess.h>             // My prototype.
#include <strucinf.h>           // NetpSessionStructureInfo().


NET_API_STATUS
RxpCopyAndConvertSessions(
    IN LPSESSION_SUPERSET_INFO InStructureArray,
    IN DWORD InEntryCount,
    IN DWORD LevelWanted,
    IN LPTSTR ClientName OPTIONAL,
    IN LPTSTR UserName OPTIONAL,
    OUT LPVOID * OutStructureArrayPtr,  // alloc'ed by this routine
    OUT LPDWORD OutEntryCountPtr OPTIONAL
    )

{
    LPSESSION_SUPERSET_INFO InEntry = InStructureArray;
    DWORD InEntriesLeft;
    const DWORD InFixedSize = sizeof(SESSION_SUPERSET_INFO);

    LPVOID OutEntry;                    // Buffer to be returned to caller.
    DWORD OutEntryCount;
    LPBYTE OutFixedDataEnd;
    DWORD OutFixedSize;
    DWORD OutMaxSize;
    LPTSTR OutStringLocation;
    DWORD OutStringSize;
    LPVOID OutStructureArray;

    BOOL AnyMatchFound = FALSE;         // not yet.
    NET_API_STATUS Status;

    NetpAssert( InEntryCount > 0 );
    NetpAssert( InStructureArray != NULL );

    *OutStructureArrayPtr = NULL;
    NetpSetOptionalArg(OutEntryCountPtr, 0);

    //
    // Learn about info level that caller wants.
    //
    Status = NetpSessionStructureInfo (
            LevelWanted,                // level to learn about
            PARMNUM_ALL,                // No parmnum with this.
            TRUE,                       // Need native sizes.
            NULL,                       // don't need data desc 16
            NULL,                       // don't need data desc 32
            NULL,                       // don't need data desc SMB
            & OutMaxSize,               // max buffer size (native)
            & OutFixedSize,             // fixed size.
            & OutStringSize             // string size.
            );
    if (Status != NERR_Success) {
        return (Status);
    }

    //
    // Allocate memory for 32-bit version of caller's info level.
    //
    Status = NetApiBufferAllocate(
            InEntryCount * OutMaxSize,
            & OutStructureArray);
    if (Status != NERR_Success) {
        return (Status);
    }
    OutEntry = OutStructureArray;
    IF_DEBUG(SESSION) {
        NetpKdPrint(( "RxpCopyAndConvertSessions: allocated output buffer at "
                FORMAT_LPVOID "\n", (LPVOID) OutStructureArray ));
    }


    OutEntryCount = 0;
    OutStringLocation = (LPTSTR) NetpPointerPlusSomeBytes(
            OutStructureArray, InEntryCount * OutMaxSize);
    for (InEntriesLeft=InEntryCount; InEntriesLeft > 0; --InEntriesLeft) {

        OutFixedDataEnd = NetpPointerPlusSomeBytes(
                OutEntry, OutFixedSize);

        if (RxpSessionMatches(
                (LPSESSION_SUPERSET_INFO) InEntry,     // candidate structure
                ClientName,
                UserName)) {

            // Match!
            AnyMatchFound = TRUE;
            ++OutEntryCount;
            RxpConvertSessionInfo (
                    InEntry,
                    LevelWanted,
                    OutEntry,
                    OutFixedDataEnd,
                    & OutStringLocation);       // string area top (updated)

            OutEntry = (LPVOID) NetpPointerPlusSomeBytes(OutEntry,OutFixedSize);
        }

        InEntry = (LPVOID) NetpPointerPlusSomeBytes(InEntry, InFixedSize);

    }

    if (AnyMatchFound == FALSE) {

        (void) NetApiBufferFree( OutStructureArray );
        OutStructureArray = NULL;

        Status = RxpSessionMissingErrorCode( ClientName, UserName);

    } else {
        Status = NERR_Success;
    }

    //
    // Tell caller how things went.
    //
    *OutStructureArrayPtr = OutStructureArray;
    NetpSetOptionalArg(OutEntryCountPtr, OutEntryCount);
    return (Status);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\rpcxlate\rxapi\rxstats.c ===
/*++

Copyright (c) 1991-92  Microsoft Corporation

Module Name:

    rxstats.c

Abstract:

    Contains NetStatistics APIs:
        RxNetStatisticsGet

Author:

    Richard Firth (rfirth) 20-May-1991

Environment:

    Win-32/flat address space

Revision History:

    20-May-1991 RFirth
        Created
    13-Sep-1991 JohnRo
        Made changes suggested by PC-LINT.
    25-Sep-1991 JohnRo
        Fixed MIPS build problems.
    01-Apr-1992 JohnRo
        Use NetApiBufferAllocate() instead of private version.

--*/



#include "downlevl.h"
#include <rxstats.h>
#include <lmstats.h>
#include <lmsvc.h>



NET_API_STATUS
RxNetStatisticsGet(
    IN  LPTSTR  ServerName,
    IN  LPTSTR  ServiceName,
    IN  DWORD   Level,
    IN  DWORD   Options,
    OUT LPBYTE* Buffer
    )

/*++

Routine Description:

    Retrieves statistics from a designated service running at a down-level
    server. Currently, the only services recognised are:
        SERVER
        WORKSTATION

Arguments:

    ServerName  - Where to run the API
    ServiceName - Pointer to string designating service to get stats for
    Level       - At which to get info. Allowable levels are: 0
    Options     - Flags. Currently defined bits are:
                    0       Clear Statistics
                    1-31    Reserved. MBZ
    Buffer      - Pointer to pointer to returned buffer containing stats

Return Value:

    NET_API_STATUS
        Success - NERR_Success
        Failure - ERROR_NOT_SUPPORTED
                    ServiceName was not "WORKSTATION" or "SERVER"

--*/

{
    LPDESC  pDesc16, pDesc32, pDescSmb;
    LPBYTE  bufptr;
    DWORD   buflen, total_avail;
    NET_API_STATUS  rc;

    UNREFERENCED_PARAMETER(Level);

    *Buffer = NULL;

    //
    // If there are any other options set other than the CLEAR bit, return an
    // error - we may allow extra options in NT, but down-level only knows
    // about this one
    //

    if (Options & ~STATSOPT_CLR) {
        return ERROR_INVALID_PARAMETER;
    }

    //
    // get the data descriptor strings and size of the returned buffer based
    // on the service name string. If statistics for new services are made
    // available then this code must be extended to use the correct, new,
    // descriptor strings. Hence we return an error here if the string is not
    // recognised, although it may be valid under NT
    //

    if (!STRCMP(ServiceName, (LPTSTR) SERVICE_SERVER)) {
        pDesc16 = REM16_stat_server_0;
        pDesc32 = REM32_stat_server_0;
        pDescSmb = REMSmb_stat_server_0;
        buflen = sizeof(STAT_SERVER_0);
        ServiceName = SERVICE_LM20_SERVER;
    } else if (!STRCMP(ServiceName, (LPTSTR) SERVICE_WORKSTATION)) {
        pDesc16 = REM16_stat_workstation_0;
        pDesc32 = REM32_stat_workstation_0;
        pDescSmb = REMSmb_stat_workstation_0;
        buflen = sizeof(STAT_WORKSTATION_0);
        ServiceName = SERVICE_LM20_WORKSTATION;
    } else {
        return ERROR_NOT_SUPPORTED;
    }

    //
    // standard retrieve buffer from down-level server type of thing: alloc
    // buffer, do RxRemoteApi call, return buffer or throw away if error
    //

    if (rc = NetApiBufferAllocate(buflen, (LPVOID *) &bufptr)) {
        return rc;
    }
    rc = RxRemoteApi(API_WStatisticsGet2,       // API #
                    ServerName,                 // where to do it
                    REM16_NetStatisticsGet2_P,  // parameter string
                    pDesc16,                    // 16-bit data descriptor
                    pDesc32,                    // 32-bit data descriptor
                    pDescSmb,                   // SMB data descriptor
                    NULL, NULL, NULL,           // no aux structures
                    FALSE,                      // user must be logged on
                    ServiceName,                // first API parameter after ServerName
                    0,                          // RESERVED
                    0,                          // Level MBZ
                    Options,                    // whatever caller supplied
                    bufptr,                     // locally allocated stats buffer
                    buflen,                     // size of stats buffer
                    &total_avail                // not used on 32-bit side
                    );
    if (rc) {
        (void) NetApiBufferFree(bufptr);
    } else {
        *Buffer = bufptr;
    }
    return rc;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\rpcxlate\rxapi\rxuser.c ===
/*++

Copyright (c) 1991-1993  Microsoft Corporation

Module Name:

    rxuser.c

Abstract:

    Routines in this module implement the down-level User and Modals UAS _access
    functionality

    Contains RxNetUser routines:
        RxNetUserAdd
        RxNetUserDel
        RxNetUserEnum
        RxNetUserGetGroups
        RxNetUserGetInfo
        RxNetUserModalsGet
        RxNetUserModalsSet
        RxNetUserPasswordSet
        RxNetUserSetGroups
        RxNetUserSetInfo
        RxNetUserValidate2
        (GetUserDescriptors)
        (GetModalsDescriptors)
        GetLanmanSessionKey

Author:

    Richard Firth (rfirth) 20-May-1991

Environment:

    Win-32/flat address space
    Requires ANSI C extensions: slash-slash comments, long external names,
    _strupr() function.

Notes:

    Routines in this module assume that caller-supplied parameters have
    already been verified. No effort is made to further check the veracity
    of parms. Any actions causing exceptions must be trapped at a higher
    level. This applies to ALL parameters - strings, pointers, buffers, etc.

Revision History:

    20-May-1991 RFirth
        Created
    25-Sep-1991 JohnRo
        PC-LINT found a bug computing buflen for info level 11.
        Fixed UNICODE handling of buflen increments.
        Fixed MIPS build.
        Changed buflen name to bufsize to reflect NT/LAN naming convention.
        Made other changes suggested by PC-LINT.
    21-Nov-1991 JohnRo
        Removed NT dependencies to reduce recompiles.
    05-Dec-1991 RFirth
        Enum returns in TotalEntries (or EntriesLeft) the number of items to
        be enumerated BEFORE this call. Used to be number left after this call
    01-Apr-1992 JohnRo
        Use NetApiBufferAllocate() instead of private version.
    06-Apr-1992 JohnRo
        RAID 8927: usrmgr.exe: _access violation, memory corruption.
        (Fixed RxNetUserSetGroups when it called NetpMoveMemory.)
    02-Apr-1993 JohnRo
        RAID 5098: DOS app NetUserPasswordSet to downlevel gets NT return code.
        Made some changes suggested by PC-LINT 5.0

--*/

#include <nt.h>                 // Needed by NetUserPasswordSet
#include <ntrtl.h>              // Needed by NetUserPasswordSet
#include <nturtl.h>             // RtlConvertUiListToApiList
#include <crypt.h>              // Needed by NetUserPasswordSet
#include "downlevl.h"
#include <rxuser.h>
#include <lmaccess.h>
#include <stdlib.h>              // wcslen().
#include <ntddnfs.h>            // LMR_REQUEST_PACKET
#include <lmuse.h>              // USE_IPC
#include <netlibnt.h>           // NetpRdrFsControlTree
#include <loghours.h>           // NetpRotateLogonHours
#include <accessp.h>            // NetpConvertWorkstationList

//
// down-level encryption now on by default!
//

#define DOWN_LEVEL_ENCRYPTION

//
// Maximum size of the Workstation list
//

#define MAX_WORKSTATION_LIST 256

//
// local routine prototypes
//

DBGSTATIC
NET_API_STATUS
GetUserDescriptors(
    IN  DWORD   Level,
    IN  BOOL    Encrypted,
    OUT LPDESC* ppDesc16,
    OUT LPDESC* ppDesc32,
    OUT LPDESC* ppDescSmb
    );

DBGSTATIC
VOID
GetModalsDescriptors(
    IN  DWORD   Level,
    OUT LPDESC* ppDesc16,
    OUT LPDESC* ppDesc32,
    OUT LPDESC* ppDescSmb
    );

NET_API_STATUS
GetLanmanSessionKey(
    IN LPWSTR ServerName,
    OUT LPBYTE pSessionKey
    );


//
// Down-level remote API worker routines
//

NET_API_STATUS
RxNetUserAdd(
    IN  LPTSTR  ServerName,
    IN  DWORD   Level,
    IN  LPBYTE  Buffer,
    OUT LPDWORD ParmError OPTIONAL
    )

/*++

Routine Description:

    Adds a user to a down-level UAS database.

    Assumes
        1.  This code assumes that a USER_INFO_1 is a subset of a USER_INFO_2
            and that the fields in a USER_INFO_1 map 1-to-1 to a USER_INFO_2
        2.  Level has already been range-checked

Arguments:

    ServerName  - at which down-level server to run the NetUserAdd API
    Level       - of user info - 1 or 2
    Buffer      - containing info
    ParmError   - where to deposit id of failing info level

Return Value:

    NET_API_STATUS
        Success - NERR_Success
        Failure - (return code from down-level API)

--*/

{
    LPDESC  pDesc16;
    LPDESC  pDesc32;
    LPDESC  pDescSmb;
    DWORD   buflen;
    DWORD   badparm;
    DWORD   len;
    DWORD   pwdlen;
    CHAR    ansiPassword[LM20_PWLEN+1];
    DWORD   lmOwfPasswordLen;
    LPTSTR   cleartext;
    NET_API_STATUS NetStatus = NERR_Success;

#ifdef DOWN_LEVEL_ENCRYPTION

    LM_OWF_PASSWORD lmOwfPassword;
    LM_SESSION_KEY lanmanKey;
    ENCRYPTED_LM_OWF_PASSWORD encryptedLmOwfPassword;
    NTSTATUS Status;

#endif

    BYTE logonHours[21];
    PBYTE callersLogonHours = NULL;

    WCHAR Workstations[MAX_WORKSTATION_LIST+1];
    LPWSTR callersWorkstations = NULL;

    if (Level < 1 || Level > 2) {
        return ERROR_INVALID_LEVEL;
    }

    if (ParmError == NULL) {
        ParmError = &badparm;
    }
    *ParmError = PARM_ERROR_NONE;

    //
    // calculate the size of the data to be transferred on the wire. See
    // assumption in rubric. We also allow ourselves the luxury of trapping
    // any strings which may break the down-level limits so we can return a
    // nice parameter error number. If a string breaks a down-level limit, we
    // just get back an ERROR_INVALID_PARAMETER, which is not very helpful
    //

    buflen = (Level == 1) ? sizeof(USER_INFO_1) : sizeof(USER_INFO_2);

    len = POSSIBLE_WCSLEN(((PUSER_INFO_1)Buffer)->usri1_name);
    if (len > LM20_UNLEN) {
        *ParmError = USER_NAME_PARMNUM;
        return ERROR_INVALID_PARAMETER;
    }
    buflen += len + 1;

    if (len = POSSIBLE_WCSLEN(((PUSER_INFO_1)Buffer)->usri1_password)) {
        if (len > LM20_PWLEN) {
            *ParmError = USER_PASSWORD_PARMNUM;
            return ERROR_INVALID_PARAMETER;
        }
        buflen += len + 1;
    }
    pwdlen = len;

    if (len = POSSIBLE_WCSLEN(((PUSER_INFO_1)Buffer)->usri1_home_dir)) {
        if (len > LM20_PATHLEN) {
            *ParmError = USER_HOME_DIR_PARMNUM;
            return ERROR_INVALID_PARAMETER;
        }
        buflen += len + 1;
    }

    if (len = POSSIBLE_WCSLEN(((PUSER_INFO_1)Buffer)->usri1_comment)) {
        if (len > LM20_MAXCOMMENTSZ) {
            *ParmError = USER_COMMENT_PARMNUM;
            return ERROR_INVALID_PARAMETER;
        }
        buflen += len + 1;
    }

    if (len = POSSIBLE_WCSLEN(((PUSER_INFO_1)Buffer)->usri1_script_path)) {
        if (len > LM20_PATHLEN) {
            *ParmError = USER_SCRIPT_PATH_PARMNUM;
            return ERROR_INVALID_PARAMETER;
        }
        buflen += len + 1;
    }

    if (Level == 2) {
        if (len = POSSIBLE_WCSLEN(((PUSER_INFO_2)Buffer)->usri2_full_name)) {
            if (len > LM20_MAXCOMMENTSZ) {
                *ParmError = USER_FULL_NAME_PARMNUM;
                return ERROR_INVALID_PARAMETER;
            }
            buflen += len + 1;
        }

        if (len = POSSIBLE_WCSLEN(((PUSER_INFO_2)Buffer)->usri2_usr_comment)) {
            if (len > LM20_MAXCOMMENTSZ) {
                *ParmError = USER_USR_COMMENT_PARMNUM;
                return ERROR_INVALID_PARAMETER;
            }
            buflen += len + 1;
        }

        if (len = POSSIBLE_WCSLEN(((PUSER_INFO_2)Buffer)->usri2_parms)) {
            if (len > LM20_MAXCOMMENTSZ) {
                *ParmError = USER_PARMS_PARMNUM;
                return ERROR_INVALID_PARAMETER;
            }
            buflen += len + 1;
        }

        if (len = POSSIBLE_WCSLEN(((PUSER_INFO_2)Buffer)->usri2_workstations)) {

            if (len > MAX_WORKSTATION_LIST) {
                *ParmError = USER_WORKSTATIONS_PARMNUM;
                return ERROR_INVALID_PARAMETER;
            }
            buflen += len + 1;

        }
    }

    if (pwdlen) {

        //
        // copy the cleartext password out of the buffer - we will replace it with
        // the encrypted version, but need to put the cleartext back before
        // returning control to the caller
        //

        cleartext = ((PUSER_INFO_1)Buffer)->usri1_password;

        //
        // Calculate the one-way function of the password
        //

        RtlUnicodeToMultiByteN(ansiPassword,
                                sizeof(ansiPassword),
                                &lmOwfPasswordLen,
                                ((PUSER_INFO_1)Buffer)->usri1_password,
                                pwdlen * sizeof(WCHAR)
                                );
        ansiPassword[lmOwfPasswordLen] = 0;
        (VOID) _strupr(ansiPassword);

#ifdef DOWN_LEVEL_ENCRYPTION

        NetStatus = NERR_Success;
        Status = RtlCalculateLmOwfPassword(ansiPassword, &lmOwfPassword);
        if (NT_SUCCESS(Status)) {
            NetStatus = GetLanmanSessionKey((LPWSTR)ServerName, (LPBYTE)&lanmanKey);
            if (NetStatus == NERR_Success) {
                Status = RtlEncryptLmOwfPwdWithLmSesKey(&lmOwfPassword,
                                                        &lanmanKey,
                                                        &encryptedLmOwfPassword
                                                        );
                if (NT_SUCCESS(Status)) {
                    ((PUSER_INFO_1)Buffer)->usri1_password = (LPTSTR)&encryptedLmOwfPassword;
                }
            }
        }
        if (NetStatus != NERR_Success)
            return NetStatus;
        else if (!NT_SUCCESS(Status)) {
            return RtlNtStatusToDosError(Status);
        }

#else

        ((PUSER_INFO_1)Buffer)->usri1_password = (LPTSTR)ansiPassword;

#endif

    } else {
        lmOwfPasswordLen = 0;
    }

    //
    // we have checked all the parms we can. If any other parameter breaks at
    // the down-level server then we just have to be content with an unknown
    // parameter error
    //

    *ParmError = PARM_ERROR_UNKNOWN;

#ifdef DOWN_LEVEL_ENCRYPTION

    NetStatus = GetUserDescriptors(Level, TRUE, &pDesc16, &pDesc32, &pDescSmb);

#else

    NetStatus = GetUserDescriptors(Level, FALSE, &pDesc16, &pDesc32, &pDescSmb);

#endif

    if (NetStatus != NERR_Success)
    {
        //
        // Copy the original password back to the user's buffer
        //
        if (pwdlen)
        {
            ((PUSER_INFO_1) Buffer)->usri1_password = cleartext;
        }

        return NetStatus;
    }

    //
    // if this level supports logon hours, then convert the caller supplied
    // logon hours from GMT to local time
    //

    if (Level == 2 && ((PUSER_INFO_2)Buffer)->usri2_logon_hours) {
        callersLogonHours = ((PUSER_INFO_2)Buffer)->usri2_logon_hours;
        RtlCopyMemory(logonHours,
                      ((PUSER_INFO_2)Buffer)->usri2_logon_hours,
                      sizeof(logonHours)
                      );

        //
        // shuffle the bitmap and point the logon_hours field in the structure
        // at the shuffled version
        //

        NetpRotateLogonHours(logonHours, UNITS_PER_WEEK, FALSE);
        ((PUSER_INFO_2)Buffer)->usri2_logon_hours = logonHours;
    }


    //
    // Convert the list of workstations from being comma separated
    //  to being space separated.  Ditch workstation names containing
    //  spaces.
    if (Level == 2 && ((PUSER_INFO_2)Buffer)->usri2_workstations) {
        UNICODE_STRING WorkstationString;

        callersWorkstations = ((PUSER_INFO_2)Buffer)->usri2_workstations;
        wcscpy( Workstations, callersWorkstations );

        RtlInitUnicodeString( &WorkstationString, Workstations );
        NetpConvertWorkstationList( &WorkstationString );

        ((PUSER_INFO_2)Buffer)->usri2_workstations = Workstations;

    }


    NetStatus = NERR_Success;
    NetStatus =  RxRemoteApi(API_WUserAdd2,              // which API it is
                             ServerName,                 // which server its at
                             REMSmb_NetUserAdd2_P,       // parameter descriptor
                             pDesc16, pDesc32, pDescSmb, // data descriptors
                             NULL, NULL, NULL,           // no aux descriptors reqd.
                             FALSE,                      // need to be logged on
                             Level,                      // caller parms
                             Buffer,
                             buflen,                     // and one we created

#ifdef DOWN_LEVEL_ENCRYPTION

                             1,                          // encryption on
                             lmOwfPasswordLen            // length of cleartext

#else

                             0,
                             pwdlen

#endif
                             );

    //
    // copy the original password back to the user's buffer
    //

    if (pwdlen) {
        ((PUSER_INFO_1)Buffer)->usri1_password = cleartext;
    }

    //
    // and the original logon hours
    //

    if (callersLogonHours) {
        ((PUSER_INFO_2)Buffer)->usri2_logon_hours = callersLogonHours;
    }

    //
    // and the original workstation list
    //

    if ( callersWorkstations ) {
        ((PUSER_INFO_2)Buffer)->usri2_workstations = callersWorkstations;
    }

    return NetStatus;
}


NET_API_STATUS
RxNetUserDel(
    IN  LPTSTR  ServerName,
    IN  LPTSTR  UserName
    )

/*++

Routine Description:

    Removes a user from a down-level server's UAS (User Account Subsystem)
    database

    Assumes
        1.  UserName has been checked for valid pointer to valid string

Arguments:

    ServerName  - on which (down-level) server to run the API
    UserName    - which user to delete

Return Value:

    NET_API_STATUS
        Success - NERR_Success
        Failure - ERROR_INVALID_PARAMETER
                    UserName > LM20_UNLEN
                  (return code from remoted NetUserDel)

--*/

{
    if (STRLEN(UserName) > LM20_UNLEN) {
        return ERROR_INVALID_PARAMETER;
    }

    return RxRemoteApi(API_WUserDel,            // api being remoted
                        ServerName,             // where to remote it
                        REMSmb_NetUserDel_P,    // parameter descriptor
                        NULL, NULL, NULL,       // data descriptors
                        NULL, NULL, NULL,       // aux data descriptors
                        FALSE,                  // this call needs user logged on
                        UserName                // remote API parms...
                        );
}


NET_API_STATUS
RxNetUserEnum(
    IN  LPTSTR  ServerName,
    IN  DWORD   Level,
    OUT LPBYTE* Buffer,
    IN  DWORD   PrefMaxLen,
    OUT LPDWORD EntriesRead,
    OUT LPDWORD EntriesLeft,
    IN OUT LPDWORD ResumeHandle OPTIONAL
    )

/*++

Routine Description:

    Returns user information from a down-level server's UAS database

Arguments:

    ServerName  - where to run the API
    Level       - of info required - 0, 1, 2, or 10
    Buffer      - place to return a pointer to an allocated buffer
    PrefMaxLen  - caller's preferred maximum buffer size
    EntriesRead - number of <Level> info entries being returned in the buffer
    EntriesLeft - number of entries left after this one
    ResumeHandle- used to resume enumeration (Ignored)

Return Value:

    NET_API_STATUS
        Success - NERR_Success
        Failure - ERROR_INVALID_PARAMETER
                    non-NULL ResumeHandle
                  ERROR_NOT_ENOUGH_MEMORY
                    NetApiBufferAllocate failed (?!)
                  (return code from down-level API)

--*/

{
    LPDESC  pDesc16;
    LPDESC  pDesc32;
    LPDESC  pDescSmb;
    NET_API_STATUS  rc;
    LPBYTE  bufptr;
    DWORD   entries_read, total_avail;
    DWORD   last_resume_handle, new_resume_handle = 0;

    *EntriesRead = *EntriesLeft = 0;
    *Buffer = NULL;

    rc = GetUserDescriptors(Level, FALSE, &pDesc16, &pDesc32, &pDescSmb);
    if (rc != NO_ERROR) {
        return(rc);
    }
    bufptr = NULL;

    //
    // try NetUserEnum2 (supports resume handle) with the requested amount
    // of data. If the down-level server doesn't support this API then try
    // NetUserEnum
    //

    if (ARGUMENT_PRESENT(ResumeHandle)) {
        last_resume_handle = *ResumeHandle;
    } else {
        last_resume_handle = 0;
    }

    //
    // irrespective of whether we can resume the enumeration, down-level
    // servers can't generate >64K-1 bytes of data
    //

    if (PrefMaxLen > 65535) {
        PrefMaxLen = 65535;
    }
    rc = RxRemoteApi(API_WUserEnum2,
                     ServerName,
                     REMSmb_NetUserEnum2_P,
                     pDesc16, pDesc32, pDescSmb,
                     NULL, NULL, NULL,
                     ALLOCATE_RESPONSE,             // RxRemoteApi allocates buffer
                     Level,
                     &bufptr,
                     PrefMaxLen,                    // size of caller's buffer
                     last_resume_handle,            // last key returned
                     &new_resume_handle,            // returns this key
                     &entries_read,                 // number returned
                     &total_avail                   // total available at server
                     );

    //
    // WinBall returns ERROR_NOT_SUPPORTED. LM < 2.1 returns NERR_InvalidAPI?
    // WinBall returns ERROR_NOT_SUPPORTED because it is share level, so this
    // whole API fails. Therefore, no need to account (no pun intended) for
    // WinBall
    //

    //
    // RLF 10/01/92. Seemingly, IBM LAN Server returns Internal Error (2140).
    // We'll handle that one too....
    //

    if (rc == NERR_InvalidAPI || rc == NERR_InternalError) {

        //
        // the down-level server doesn't support NetUserEnum2. Fall-back to
        // NetUserEnum & try to get as much data as available
        //

        rc = RxRemoteApi(API_WUserEnum,
                         ServerName,
                         REMSmb_NetUserEnum_P,
                         pDesc16, pDesc32, pDescSmb,
                         NULL, NULL, NULL,
                         ALLOCATE_RESPONSE,     // RxRemoteApi allocates buffer
                         Level,
                         &bufptr,
                         65535,                 // get as much data as possible
                         &entries_read,
                         &total_avail
                         );
    } else if (rc == NERR_Success || rc == ERROR_MORE_DATA) {

        //
        // return the resume handle if NetUserEnum2 succeeded & the caller
        // supplied a ResumeHandle parameter
        //

        if (ARGUMENT_PRESENT(ResumeHandle)) {
            *ResumeHandle = new_resume_handle;
        }
    }
    if (rc && rc != ERROR_MORE_DATA) {
        if (bufptr != NULL) {
            (void) NetApiBufferFree(bufptr);
        }
    } else {

        //
        // if level supports logon hours, convert from local time to GMT. Level
        // 2 is the only level of user info handled by this routine that knows
        // about logon hours
        //
        // if level support workstation list, convert from blank separated to
        // comma separated list.  Level 2 is the only level of user info
        // handled by this routine that know about the workstation list.
        //

        if (Level == 2) {

            DWORD numRead;
            LPUSER_INFO_2 ptr = (LPUSER_INFO_2)bufptr;

            for (numRead = entries_read; numRead; --numRead) {
                NetpRotateLogonHours(ptr->usri2_logon_hours, UNITS_PER_WEEK, TRUE);
                if ( ptr->usri2_workstations != NULL ) {
                    UNICODE_STRING BlankSeparated;
                    UNICODE_STRING CommaSeparated;
                    NTSTATUS Status;

                    RtlInitUnicodeString( &BlankSeparated, ptr->usri2_workstations );

                    Status = RtlConvertUiListToApiList(
                                &BlankSeparated,
                                &CommaSeparated,
                                TRUE );         // Allow Blanks as delimiters

                    if ( !NT_SUCCESS(Status)) {
                        return RtlNtStatusToDosError(Status);
                    }

                    if ( CommaSeparated.Length > 0 ) {
                        NetpAssert ( wcslen( ptr->usri2_workstations ) <=
                                     wcslen( CommaSeparated.Buffer ) );
                        if ( wcslen( ptr->usri2_workstations ) <=
                             wcslen( CommaSeparated.Buffer ) ) {
                            wcscpy( ptr->usri2_workstations,
                                    CommaSeparated.Buffer );
                        }
                    }

                }
                ++ptr;
            }
        }
        *Buffer = bufptr;
        *EntriesRead = entries_read;
        *EntriesLeft = total_avail;
    }
    return rc;
}


NET_API_STATUS
RxNetUserGetGroups(
    IN  LPTSTR  ServerName,
    IN  LPTSTR  UserName,
    IN  DWORD   Level,
    OUT LPBYTE* Buffer,
    IN  DWORD   PrefMaxLen,
    OUT LPDWORD EntriesRead,
    OUT LPDWORD EntriesLeft
    )

/*++

Routine Description:

    Get the list of groups in a UAS database to which a particular user belongs

Arguments:

    ServerName  - where to run the API
    UserName    - which user to get info for
    Level       - of info requested - Must Be Zero
    Buffer      - where to deposit the buffer we allocate containing the info
    PrefMaxLen  - caller's preferred maximum buffer size
    EntriesRead - number of entries being returned in Buffer
    EntriesLeft - number of entries left to get

Return Value:

    NET_API_STATUS
        Success - NERR_Success
        Failure - ERROR_INVALID_LEVEL
                  ERROR_INVALID_PARAMETER

--*/

{
    NET_API_STATUS  rc;
    DWORD   entries_read, total_avail;
    LPBYTE  bufptr;


    UNREFERENCED_PARAMETER(Level);
    UNREFERENCED_PARAMETER(PrefMaxLen);

    *EntriesRead = *EntriesLeft = 0;
    *Buffer = NULL;

    if (STRLEN(UserName) > LM20_UNLEN) {
        return ERROR_INVALID_PARAMETER;
    }

    bufptr = NULL;
    rc = RxRemoteApi(API_WUserGetGroups,
                        ServerName,
                        REMSmb_NetUserGetGroups_P,
                        REM16_user_info_0,
                        REM32_user_info_0,
                        REMSmb_user_info_0,
                        NULL, NULL, NULL,
                        ALLOCATE_RESPONSE,
                        UserName,                   // API parameters
                        0,                          // fixed level
                        &bufptr,
                        65535,
                        &entries_read,
                        &total_avail                // supplied by us
                        );
    if (rc) {
        if (bufptr != NULL) {
            (void) NetApiBufferFree(bufptr);
        }
    } else {
        *Buffer = bufptr;
        *EntriesRead = entries_read;
        *EntriesLeft = total_avail;
    }
    return rc;
}


NET_API_STATUS
RxNetUserGetInfo(
    IN  LPTSTR  ServerName,
    IN  LPTSTR  UserName,
    IN  DWORD   Level,
    OUT LPBYTE* Buffer
    )

/*++

Routine Description:

    Get information about a particular user from a down-level server

    Assumes:
        1.  UserName is a valid pointer to a valid string

Arguments:

    ServerName  - where to run the API
    UserName    - which user to get info on
    Level       - what level of info required - 0, 1, 2, 10, 11
    Buffer      - where to return buffer containing info

Return Value:

    NET_API_STATUS
        Success - NERR_Success
        Failure - ERROR_INVALID_LEVEL
                  ERROR_INVALID_PARAMETER

--*/

{
    LPDESC  pDesc16;
    LPDESC  pDesc32;
    LPDESC  pDescSmb;
    DWORD   buflen;
    LPBYTE  bufptr;
    DWORD   total_avail;
    NET_API_STATUS  rc;


    *Buffer = NULL;

    if (STRLEN(UserName) > LM20_UNLEN) {
        return ERROR_INVALID_PARAMETER;
    }

    //
    // work out the anount of buffer space we need to return the down-level
    // structure as its 32-bit equivalent
    //

    switch (Level) {
    case 0:
        buflen = sizeof(USER_INFO_0) + STRING_SPACE_REQD(UNLEN + 1);
        break;

    case 1:
        buflen = sizeof(USER_INFO_1)
            + STRING_SPACE_REQD(UNLEN + 1)              // usri1_name
            + STRING_SPACE_REQD(ENCRYPTED_PWLEN)        // usri1_password
            + STRING_SPACE_REQD(LM20_PATHLEN + 1)       // usri1_home_dir
            + STRING_SPACE_REQD(LM20_MAXCOMMENTSZ + 1)  // usri1_comment
            + STRING_SPACE_REQD(LM20_PATHLEN + 1);      // usri1_script_path
        break;

    case 2:
        buflen = sizeof(USER_INFO_2)
            + STRING_SPACE_REQD(UNLEN + 1)              // usri2_name
            + STRING_SPACE_REQD(ENCRYPTED_PWLEN)        // usri2_password
            + STRING_SPACE_REQD(LM20_PATHLEN + 1)       // usri2_home_dir
            + STRING_SPACE_REQD(LM20_MAXCOMMENTSZ + 1)  // usri2_comment
            + STRING_SPACE_REQD(LM20_PATHLEN + 1)       // usri2_script_path
            + STRING_SPACE_REQD(LM20_MAXCOMMENTSZ + 1)  // usri2_full_name
            + STRING_SPACE_REQD(LM20_MAXCOMMENTSZ + 1)  // usri2_usr_comment
            + STRING_SPACE_REQD(LM20_MAXCOMMENTSZ + 1)  // usri2_parms
            + STRING_SPACE_REQD(MAX_WORKSTATION_LIST)   // usri2_workstations
            + STRING_SPACE_REQD(MAX_PATH + 1)        // usri2_logon_server
            + 21;                                       // usri2_logon_hours
        break;

    case 10:
        buflen = sizeof(USER_INFO_10)
            + STRING_SPACE_REQD(UNLEN + 1)              // usri10_name
            + STRING_SPACE_REQD(LM20_MAXCOMMENTSZ + 1)  // usri10_comment
            + STRING_SPACE_REQD(LM20_MAXCOMMENTSZ + 1)  // usri10_usr_comment
            + STRING_SPACE_REQD(LM20_MAXCOMMENTSZ + 1); // usri10_full_name
        break;

    case 11:
        buflen = sizeof(USER_INFO_11)
            + STRING_SPACE_REQD(UNLEN + 1)              // usri11_name
            + STRING_SPACE_REQD(LM20_MAXCOMMENTSZ + 1)  // usri11_comment
            + STRING_SPACE_REQD(LM20_MAXCOMMENTSZ + 1)  // usri11_usr_comment
            + STRING_SPACE_REQD(LM20_MAXCOMMENTSZ + 1)  // usri11_full_name
            + STRING_SPACE_REQD(LM20_PATHLEN + 1)       // usri11_home_dir
            + STRING_SPACE_REQD(LM20_MAXCOMMENTSZ + 1)  // usri11_parms
            + STRING_SPACE_REQD(MAX_PATH + 1)           // usri11_logon_server
            + STRING_SPACE_REQD(MAX_WORKSTATION_LIST)   // usri11_workstations
            + 21;                                       // usri11_logon_hours
        break;

    default:
        return(ERROR_INVALID_LEVEL);
    }
    buflen = DWORD_ROUNDUP(buflen);
    if (rc = NetApiBufferAllocate(buflen, (LPVOID *) &bufptr)) {
        return rc;
    }
    (void)GetUserDescriptors(Level, FALSE, &pDesc16, &pDesc32, &pDescSmb);
    rc = RxRemoteApi(API_WUserGetInfo,
                     ServerName,
                     REMSmb_NetUserGetInfo_P,
                     pDesc16, pDesc32, pDescSmb,
                     NULL, NULL, NULL,
                     FALSE,
                     UserName,
                     Level,
                     bufptr,
                     buflen,
                     &total_avail
                     );
    if (rc) {
        (void) NetApiBufferFree(bufptr);
    } else {

        //
        // Convert the logon hours bitmap to UTC/GMT
        // Convert the workstation list from blank separated to comma separated
        //

        if (Level == 2 || Level == 11) {

            PBYTE logonHours;
            LPWSTR Workstations;

            if (Level == 2) {
                logonHours = ((PUSER_INFO_2)bufptr)->usri2_logon_hours;
                Workstations = ((PUSER_INFO_2)bufptr)->usri2_workstations;
            } else {
                logonHours = ((PUSER_INFO_11)bufptr)->usri11_logon_hours;
                Workstations = ((PUSER_INFO_11)bufptr)->usri11_workstations;
            }
            NetpRotateLogonHours(logonHours, UNITS_PER_WEEK, TRUE);

            if ( Workstations != NULL ) {
                UNICODE_STRING BlankSeparated;
                UNICODE_STRING CommaSeparated;
                NTSTATUS Status;

                RtlInitUnicodeString( &BlankSeparated, Workstations );

                Status = RtlConvertUiListToApiList(
                            &BlankSeparated,
                            &CommaSeparated,
                            TRUE );         // Allow Blanks as delimiters

                if ( !NT_SUCCESS(Status)) {
                    return RtlNtStatusToDosError(Status);
                }

                if ( CommaSeparated.Length > 0 ) {
                    NetpAssert ( wcslen( Workstations ) <=
                                 wcslen( CommaSeparated.Buffer ) );
                    if ( wcslen(Workstations) <= wcslen(CommaSeparated.Buffer)){
                        wcscpy( Workstations, CommaSeparated.Buffer );
                    }
                }

            }
        }
        *Buffer = bufptr;
    }
    return rc;
}


NET_API_STATUS
RxNetUserModalsGet(
    IN  LPTSTR  ServerName,
    IN  DWORD   Level,
    OUT LPBYTE* Buffer
    )

/*++

Routine Description:

    Returns global information about all users and groups in a down-level UAS
    database

    Assumes
        1.  Level has been validated

Arguments:

    ServerName  - where to run the API
    Level       - of info required - 0 or 1
    Buffer      - where to deposit the returned info

Return Value:

    NET_API_STATUS
        Success - NERR_Success
        Failure - ERROR_INVALID_LEVEL
                  ERROR_INVALID_PARAMETER

--*/

{
    LPDESC  pDesc16;
    LPDESC  pDesc32;
    LPDESC  pDescSmb;
    DWORD   buflen;
    LPBYTE  bufptr;
    NET_API_STATUS  rc;
    DWORD   total_avail;

    if (Level > 1) {
        return ERROR_INVALID_LEVEL;
    }

    *Buffer = NULL;
    buflen = Level ? sizeof(USER_MODALS_INFO_1) : sizeof(USER_MODALS_INFO_0);
    buflen += Level ? STRING_SPACE_REQD(MAX_PATH + 1) : 0;
    buflen = DWORD_ROUNDUP(buflen);
    if (rc = NetApiBufferAllocate(buflen, (LPVOID *) &bufptr)) {
        return rc;
    }
    GetModalsDescriptors(Level, &pDesc16, &pDesc32, &pDescSmb);
    rc = RxRemoteApi(API_WUserModalsGet,
                        ServerName,
                        REMSmb_NetUserModalsGet_P,
                        pDesc16, pDesc32, pDescSmb,
                        NULL, NULL, NULL,
                        FALSE,
                        Level,
                        bufptr,
                        buflen,
                        &total_avail
                        );
    if (rc) {
        (void) NetApiBufferFree(bufptr);
    } else {
        *Buffer = bufptr;
    }
    return rc;
}


NET_API_STATUS
RxNetUserModalsSet(
    IN  LPTSTR  ServerName,
    IN  DWORD   Level,
    IN  LPBYTE  Buffer,
    OUT LPDWORD ParmError OPTIONAL
    )

/*++

Routine Description:

    Sets global information for all users and groups in a down-level UAS
    database

    Assumes
        1.  Level parameter already verified

Arguments:

    ServerName  - where to run the API
    Level       - level of information being supplied - 0, 1, 1001-1007
    Buffer      - pointer to buffer containing input information
    ParmError   - pointer to place to store index of failing info

Return Value:

    NET_API_STATUS
        Success - NERR_Success
        Failure - ERROR_INVALID_PARAMETER
                    One of the fields in the input structure was invalid

--*/

{
    DWORD   parmnum;
    DWORD   badparm;
    DWORD   buflen;
    LPDESC  pDesc16;
    LPDESC  pDesc32;
    LPDESC  pDescSmb;


    //
    // check for bad addresses and set ParmError to a known default
    //

    if (ParmError == NULL) {
        ParmError = &badparm;
    }
    *ParmError = PARM_ERROR_NONE;

    if (Level) {
        if (Level == 1) {
            parmnum = PARMNUM_ALL;
            buflen = sizeof(USER_MODALS_INFO_1)
                + POSSIBLE_STRLEN(((PUSER_MODALS_INFO_1)Buffer)->usrmod1_primary);
        } else {

            //
            // Convert info levels 1006, 1007 to corresponding parmnums (1, 2)
            // at old info level 1
            //

            if (Level >= MODALS_ROLE_INFOLEVEL) {
                parmnum = Level - (MODALS_ROLE_INFOLEVEL - 1);
                Level = 1;
                switch (parmnum) {
                    case 1: // MODALS_ROLE_PARMNUM
                        buflen = sizeof(DWORD);
                        break;

                    case 2: // MODALS_PRIMARY_PARMNUM
                        buflen = STRLEN( (LPTSTR) Buffer);
                        if (buflen > MAX_PATH) {
                            *ParmError = MODALS_PRIMARY_INFOLEVEL;
                            return ERROR_INVALID_PARAMETER;
                        }
                        break;

                    default:
#if DBG
                        NetpKdPrint(("error: RxNetUserModalsSet.%d: bad parmnum %d\n",
                        __LINE__,
                        parmnum
                        ));
#endif
                        return ERROR_INVALID_LEVEL;
                }
            } else if (Level >= MODALS_MIN_PASSWD_LEN_INFOLEVEL) {

                //
                // Convert info levels 1001-1005 to equivalent parmnums at
                // level 0
                //

                parmnum = Level - PARMNUM_BASE_INFOLEVEL;
                Level = 0;
                buflen = sizeof(DWORD);
            } else {
#if DBG
                NetpKdPrint(("error: RxNetUserModalsSet.%d: bad level %d\n",
                __LINE__,
                Level
                ));
#endif
                return ERROR_INVALID_LEVEL;
            }
        }
    } else {
        parmnum = PARMNUM_ALL;
        buflen = sizeof(USER_MODALS_INFO_0);
    }

    *ParmError = PARM_ERROR_UNKNOWN;
    GetModalsDescriptors(Level, &pDesc16, &pDesc32, &pDescSmb);
    return RxRemoteApi(API_WUserModalsSet,
                        ServerName,
                        REMSmb_NetUserModalsSet_P,
                        pDesc16, pDesc32, pDescSmb,
                        NULL, NULL, NULL,
                        FALSE,
                        Level,                          // API parms
                        Buffer,
                        buflen,                         // supplied by us
                        MAKE_PARMNUM_PAIR(parmnum, parmnum) // ditto
                        );
}


NET_API_STATUS
RxNetUserPasswordSet(
    IN  LPTSTR  ServerName,
    IN  LPTSTR  UserName,
    IN  LPTSTR  OldPassword,
    IN  LPTSTR  NewPassword
    )

/*++

Routine Description:

    Changes the password associated with a user account in a down-level UAS
    database

    Assumes
        1.  The pointer parameters have already been verified

Arguments:

    ServerName  - where to change the password
    UserName    - which user account to change it for
    OldPassword - the current password
    NewPassword - the new password

Return Value:

    NET_API_STATUS
        Success - NERR_Success
        Failure - ERROR_INVALID_PARAMETER
                    UserName, OldPassword or NewPassword would break down-level
                    limits

--*/

{
    NTSTATUS Status;
    NET_API_STATUS NetStatus;
    BOOL           TryNullSession = TRUE;       // Try null session first.
    ULONG BytesWritten;

#ifdef DOWN_LEVEL_ENCRYPTION

    CHAR OldAnsiPassword[LM20_PWLEN+1];
    CHAR NewAnsiPassword[LM20_PWLEN+1];
    LM_OWF_PASSWORD OldOwfPassword;
    LM_OWF_PASSWORD NewOwfPassword;
    ENCRYPTED_LM_OWF_PASSWORD OldEncryptedWithNew;
    ENCRYPTED_LM_OWF_PASSWORD NewEncryptedWithOld;

#else

    CHAR OldAnsiPassword[ENCRYPTED_PWLEN];
    CHAR NewAnsiPassword[ENCRYPTED_PWLEN];

#endif


    //
    // Reel in some easy errors before they get far.
    //

    if ((STRLEN(UserName) > LM20_UNLEN)
        || (STRLEN(OldPassword) > LM20_PWLEN)
        || (STRLEN(NewPassword) > LM20_PWLEN)) {
        return ERROR_INVALID_PARAMETER;
    }

    //
    // The passwords are sent in 16-byte ANSI buffers,
    // so convert them from Unicode to multibyte.
    //

#ifndef DOWN_LEVEL_ENCRYPTION

    //
    // this required because we always send fixed size char buffers, not strings
    //

    RtlZeroMemory(OldAnsiPassword, sizeof(OldAnsiPassword));
    RtlZeroMemory(NewAnsiPassword, sizeof(NewAnsiPassword));

#endif

    RtlUnicodeToMultiByteN(
        OldAnsiPassword,
        sizeof(OldAnsiPassword),
        &BytesWritten,
        OldPassword,
        wcslen(OldPassword) * sizeof(WCHAR)
        );
    OldAnsiPassword[BytesWritten] = 0;

    RtlUnicodeToMultiByteN(
        NewAnsiPassword,
        sizeof(NewAnsiPassword),
        &BytesWritten,
        NewPassword,
        wcslen(NewPassword) * sizeof(WCHAR)
        );
    NewAnsiPassword[BytesWritten] = 0;

    //
    // twould seem that down-level servers require passwords to be in upper
    // case (ie canonicalized) when they are decrypted. Same applies for
    // cleartext
    //

    (VOID) _strupr(OldAnsiPassword);
    (VOID) _strupr(NewAnsiPassword);

#ifdef DOWN_LEVEL_ENCRYPTION

    //
    // Calculate the one-way functions of the passwords.
    //

    Status = RtlCalculateLmOwfPassword(OldAnsiPassword, &OldOwfPassword);
    if (!NT_SUCCESS(Status)) {
        goto Cleanup;
    }
    Status = RtlCalculateLmOwfPassword(NewAnsiPassword, &NewOwfPassword);
    if (!NT_SUCCESS(Status)) {
        goto Cleanup;
    }

    //
    // Cross-encrypt the passwords.
    //

    Status = RtlEncryptLmOwfPwdWithLmOwfPwd(&OldOwfPassword,
                                            &NewOwfPassword,
                                            &OldEncryptedWithNew
                                            );
    if (!NT_SUCCESS(Status)) {
        goto Cleanup;
    }
    Status = RtlEncryptLmOwfPwdWithLmOwfPwd(&NewOwfPassword,
                                            &OldOwfPassword,
                                            &NewEncryptedWithOld
                                            );
    if (!NT_SUCCESS(Status)) {
        goto Cleanup;
    }

#else

    //
    // Status hasn't been initialized, but is tested below to determine if we
    // should pick up the NetStatus from Status.
    //

    Status = STATUS_SUCCESS;

#endif  // DOWN_LEVEL_ENCRYPTION

TryTheEncryptedApi:

    NetStatus = RxRemoteApi(API_WUserPasswordSet2,
                            ServerName,
                            REMSmb_NetUserPasswordSet2_P,
                            NULL, NULL, NULL,           // no data - just parms
                            NULL, NULL, NULL,           // no aux data
                            (TryNullSession ? NO_PERMISSION_REQUIRED : 0),
                            UserName,                   // parameters...

#ifdef DOWN_LEVEL_ENCRYPTION

                            &OldEncryptedWithNew,
                            &NewEncryptedWithOld,
                            TRUE,                       // data encrypted?

#else

                            OldAnsiPassword,
                            NewAnsiPassword,
                            FALSE,                      // passwords not encrypted

#endif

                            strlen(NewAnsiPassword)
                            );

        //
        // LarryO says null session might have wrong credentials, so we
        // should retry with non-null session.
        //

        if ( TryNullSession && (Status == ERROR_SESSION_CREDENTIAL_CONFLICT) ) {

            TryNullSession = FALSE;
            goto TryTheEncryptedApi;     // retry this one.
        }


    //
    // If the encrypted attempt fails with NERR_InvalidAPI, try plaintext
    //

    if (NetStatus == NERR_InvalidAPI) {

TryThePlainTextApi:

        TryNullSession = TRUE;           // Try null session first.

        NetStatus = RxRemoteApi(API_WUserPasswordSet,
                                ServerName,
                                REMSmb_NetUserPasswordSet_P,
                                NULL, NULL, NULL,           // no data - just parms
                                NULL, NULL, NULL,           // no aux data
                                (TryNullSession ? NO_PERMISSION_REQUIRED : 0),
                                UserName,                   // parameters...
                                OldAnsiPassword,
                                NewAnsiPassword,
                                FALSE                       // data encrypted?
                                );
        //
        // LarryO says null session might have wrong credentials, so we
        // should retry with non-null session.
        //

        if ( TryNullSession && (Status == ERROR_SESSION_CREDENTIAL_CONFLICT) ) {

            TryNullSession = FALSE;
            goto TryThePlainTextApi;     // retry this one.
        }
    }

#ifdef DOWN_LEVEL_ENCRYPTION

    Cleanup:

#endif

    if (!NT_SUCCESS(Status)) {
        NetStatus = RtlNtStatusToDosError(Status);
    }

    return NetStatus;
}


NET_API_STATUS
RxNetUserSetGroups(
    IN  LPTSTR  ServerName,
    IN  LPTSTR  UserName,
    IN  DWORD   Level,
    IN  LPBYTE  Buffer,
    IN  DWORD   Entries
    )

/*++

Routine Description:

    Makes a user a member of the listed groups. This routine is virtually
    identical to RxNetGroupSetUsers and most of the code was lifted from there

Arguments:

    ServerName  - where to run the API
    UserName    - which user to include
    Level       - Must Be Zero (MBZ)
    Buffer      - pointer to buffer containing a list of GROUP_INFO_0 structures
    Entries     - number of GROUP_INFO_0 structures in Buffer

Return Value:

    NET_API_STATUS
        Success - NERR_Success
        Failure - ERROR_INVALID_LEVEL
                  ERROR_INVALID_PARAMETER

--*/

{
    NET_API_STATUS  rc;
    LPGROUP_INFO_0  group_info;
    DWORD   i;
    DWORD   buflen;
    LPBYTE  newbuf;
    static  LPDESC  group_0_enumerator_desc16 = "B21BN";    // same as UNLEN
    static  LPDESC  group_0_enumerator_desc32 = "zQA";

    //
    // This structure is required because the remoting code (particularly down
    // level) can only handle there being >1 auxiliary structure, vs >1
    // primary. Hence we have to convert the caller's supplied buffer of
    // erstwhile primary structures to auxiliaries by forcing the structure
    // below in at the head of the buffer, hence becoming the primary and
    // providing an aux structure count (groan)
    //

    struct group_0_enumerator {
        LPTSTR  user_name;      // which user to set groups for
        DWORD   group_count;    // number of GROUP_INFO_0 structures in buffer
    };

    if (Level) {
        return ERROR_INVALID_LEVEL; // MBZ, remember?
    }

    if (STRLEN(UserName) > LM20_UNLEN) {
        return ERROR_INVALID_PARAMETER;
    }

    //
    // iterate through the buffer, checking that each GROUP_INFO_0
    // structure contains a pointer to a valid string which is in the
    // correct range
    //

    group_info = (LPGROUP_INFO_0)Buffer;
    for (i=0; i<Entries; ++i) {
        if (!VALID_STRING(group_info->grpi0_name)) {
            return ERROR_INVALID_PARAMETER;
        }
        if (wcslen(group_info->grpi0_name) > LM20_GNLEN) {
            return ERROR_INVALID_PARAMETER;
        }
        ++group_info;
    }

    //
    // allocate a buffer large enough to fit in <Entries> number of
    // GROUP_INFO_0 structures, and 1 group_0_enumerator structure.
    // Don't worry about string space - unfortunately the Rxp and Rap routines
    // called by RxRemoteApi will allocate yet another buffer, do yet another
    // copy and this time copy in the strings from user space. Hopefully, this
    // routine won't get called too often
    //

    buflen = Entries * sizeof(GROUP_INFO_0) + sizeof(struct group_0_enumerator);
    buflen = DWORD_ROUNDUP(buflen);
    if (rc = NetApiBufferAllocate(buflen, (LPVOID *) &newbuf)) {
        return rc;  // aieegh! Failed to allocate memory?
    }

    ((struct group_0_enumerator*)newbuf)->user_name = UserName;
    ((struct group_0_enumerator*)newbuf)->group_count = Entries;

    if (Entries > 0) {
        // Append the group entries to the header we just built.
        NetpMoveMemory(
                newbuf + sizeof(struct group_0_enumerator),  // dest
                Buffer,                                      // src
                buflen - sizeof(struct group_0_enumerator)); // byte count
    }

    rc = RxRemoteApi(API_WUserSetGroups,
                    ServerName,
                    REMSmb_NetUserSetGroups_P,
                    group_0_enumerator_desc16,  // the "fudged" 16-bit data descriptor
                    group_0_enumerator_desc32,  // the "fudged" 32-bit data descriptor
                    group_0_enumerator_desc16,  // SMB desc same as 16-bit
                    REM16_group_info_0,         // "new" 16-bit aux descriptor
                    REM32_group_info_0,         // "new" 32-bit aux descriptor
                    REMSmb_group_info_0,        // SMB aux descriptor
                    FALSE,                      // this API requires user security
                    UserName,                   // parm 1
                    0,                          // info level must be 0
                    newbuf,                     // "fudged" buffer
                    buflen,                     // length of "fudged" buffer
                    Entries                     // number of GROUP_USERS_INFO_0
                    );
    NetpMemoryFree(newbuf);
    return rc;
}


NET_API_STATUS
RxNetUserSetInfo(
    IN  LPTSTR  ServerName,
    IN  LPTSTR  UserName,
    IN  DWORD   Level,
    IN  LPBYTE  Buffer,
    OUT LPDWORD ParmError OPTIONAL
    )

/*++

Routine Description:

    Sets information in a user account in a down-level UAS database

    Assumes:
        1.  UserName is a valid pointer to a valid string,
            Level is in the range below,
            Buffer is a valid pointer
            ParmError is a valid pointer

Arguments:

    ServerName  - where to run the API
    UserName    - which user to change info for
    Level       - of info supplied - 1-2, 1003, 1005-1014, 1017-1018, 1020, 1023-1025
    Buffer      - if PARMNUM_ALL, pointer to buffer containing info,
                  else pointer to pointer to buffer containing info
    ParmError   - which parameter was bad

Return Value:

    NET_API_STATUS
        Success - NERR_Success
        Failure - ERROR_INVALID_LEVEL
                  ERROR_INVALID_PARAMETER

--*/

{
    DWORD   parmnum;
    DWORD   badparm;
    DWORD   buflen;
    DWORD   stringlen;
    LPWSTR  pointer;    // general pointer to string for range checking
    LPDESC  pDesc16;
    LPDESC  pDesc32;
    LPDESC  pDescSmb;
    DWORD   passwordEncrypted = FALSE;
    DWORD   originalPasswordLength = 0;
    CHAR    ansiPassword[LM20_PWLEN+1];
    DWORD   lmOwfPasswordLen;
    LPTSTR  cleartext;
    LPTSTR* lpClearText;
    NET_API_STATUS NetStatus = NERR_Success;

#ifdef DOWN_LEVEL_ENCRYPTION

    LM_OWF_PASSWORD lmOwfPassword;
    LM_SESSION_KEY lanmanKey;
    ENCRYPTED_LM_OWF_PASSWORD encryptedLmOwfPassword;
    NTSTATUS Status;

#endif

    BYTE logonHours[21];
    PBYTE callersLogonHours = NULL;
    PBYTE* lpCallersLogonHours;

    WCHAR Workstations[MAX_WORKSTATION_LIST+1];
    LPWSTR callersWorkstations = NULL;
    LPWSTR *lpCallersWorkstations;

    if (ParmError == NULL) {
        ParmError = &badparm;
    }
    *ParmError = PARM_ERROR_NONE;

    if (STRLEN(UserName) > LM20_UNLEN) {
        NetStatus = ERROR_INVALID_PARAMETER;
        goto Cleanup;
    }

    //
    // throw out invalid level parameter
    //

    if ((Level > 2 && Level < USER_PASSWORD_INFOLEVEL)

        // 2 < Level < 1003

    || (Level > USER_PASSWORD_INFOLEVEL && Level < USER_PRIV_INFOLEVEL)

        // 1003 < Level < 1005  : Check compiler generates == 1004

    || (Level > USER_WORKSTATIONS_INFOLEVEL && Level < USER_ACCT_EXPIRES_INFOLEVEL)

        // 1014 < Level < 1017

    || (Level > USER_MAX_STORAGE_INFOLEVEL && Level < USER_LOGON_HOURS_INFOLEVEL)

        // 1018 < Level < 1020  : Check compiler generates == 1019

    || (Level > USER_LOGON_HOURS_INFOLEVEL && Level < USER_LOGON_SERVER_INFOLEVEL)

        // 1020 < Level < 1023

    || (Level > USER_CODE_PAGE_INFOLEVEL)) {

        // Level < 1025

        NetStatus = ERROR_INVALID_LEVEL;
        goto Cleanup;
    }

    //
    // default to Level 2 for the descriptors (Level 2 works for level 1 also)
    //

    pDesc16 = REM16_user_info_2;
    pDesc32 = REM32_user_info_2;
    pDescSmb = REMSmb_user_info_2;

    if (Level < PARMNUM_BASE_INFOLEVEL) {
        parmnum = PARMNUM_ALL;
        if (Level == 1) {
            pDesc16 = REM16_user_info_1;
            pDesc32 = REM32_user_info_1;
            pDescSmb = REMSmb_user_info_1;
            buflen = sizeof(USER_INFO_1);
        } else {

            buflen = sizeof(USER_INFO_2) + 21;
        }
    } else {
        parmnum = Level - PARMNUM_BASE_INFOLEVEL;

        //
        // Because info level 1 is a subset of info level 2, setting the level
        // to 2 is ok for those parmnums which can be set at level 1 AND 2.
        // Set pointer = Buffer so that in the parmnum != PARMNUM_ALL case, we
        // just check the length of whatever pointer points at
        //

        Level = 2;
        pointer = *(LPWSTR*) Buffer;
        buflen = 0;
    }

    if (parmnum == PARMNUM_ALL) {
        if (pointer = ((PUSER_INFO_1)(LPVOID)Buffer)->usri1_name) {
            if ((stringlen = POSSIBLE_WCSLEN(pointer)) > LM20_UNLEN) {
                *ParmError = USER_NAME_PARMNUM;
                NetStatus = ERROR_INVALID_PARAMETER;
                goto Cleanup;
            }
            buflen += STRING_SPACE_REQD(stringlen + 1);
        }
    }

    if ((parmnum == PARMNUM_ALL) || (parmnum == USER_PASSWORD_PARMNUM)) {
        if (parmnum == PARMNUM_ALL) {
            pointer = ((PUSER_INFO_1)Buffer)->usri1_password;
        }
        if ((stringlen = POSSIBLE_WCSLEN(pointer)) > LM20_PWLEN) {
            *ParmError = USER_PASSWORD_PARMNUM;
            NetStatus = ERROR_INVALID_PARAMETER;
            goto Cleanup;
        }
        buflen += STRING_SPACE_REQD(stringlen + 1);

        //
        // original password length is length of unencrypted string in
        // characters, excluding terminating NUL
        //

        originalPasswordLength = stringlen;

        //
        // lpClearText is address of pointer to cleartext password
        //

        lpClearText = (parmnum == PARMNUM_ALL)
                        ? (LPTSTR*)&((PUSER_INFO_1)Buffer)->usri1_password
                        : (LPTSTR*)Buffer;

        //
        // copy the cleartext password out of the buffer - we will replace it with
        // the encrypted version, but need to put the cleartext back before
        // returning control to the caller
        //

        cleartext = *lpClearText;
    }

    if ((parmnum == PARMNUM_ALL) || (parmnum == USER_HOME_DIR_PARMNUM)) {
        if (parmnum == PARMNUM_ALL) {
            pointer = ((PUSER_INFO_1)Buffer)->usri1_home_dir;
        }
        if ((stringlen = POSSIBLE_WCSLEN(pointer)) > LM20_PATHLEN) {
            *ParmError = USER_HOME_DIR_PARMNUM;
            NetStatus = ERROR_INVALID_PARAMETER;
            goto Cleanup;
        }
        buflen += STRING_SPACE_REQD(stringlen + 1);
    }

    if ((parmnum == PARMNUM_ALL) || (parmnum == USER_COMMENT_PARMNUM)) {
        if (parmnum == PARMNUM_ALL) {
            pointer = ((PUSER_INFO_1)Buffer)->usri1_comment;
        }
        if ((stringlen = POSSIBLE_WCSLEN(pointer)) > LM20_MAXCOMMENTSZ) {
            *ParmError = USER_COMMENT_PARMNUM;
            NetStatus = ERROR_INVALID_PARAMETER;
            goto Cleanup;
        }
        buflen += STRING_SPACE_REQD(stringlen + 1);
    }

    if ((parmnum == PARMNUM_ALL) || (parmnum == USER_SCRIPT_PATH_PARMNUM)) {
        if (parmnum == PARMNUM_ALL) {
            pointer = ((PUSER_INFO_1)Buffer)->usri1_script_path;
        }
        if ((stringlen = POSSIBLE_WCSLEN(pointer)) > LM20_PATHLEN) {
            *ParmError = USER_SCRIPT_PATH_PARMNUM;
            NetStatus = ERROR_INVALID_PARAMETER;
            goto Cleanup;
        }
        buflen += STRING_SPACE_REQD(stringlen + 1);
    }

    //
    // the next set of checks only need to be done if we are setting PARMNUM_ALL
    // with a Level of 2 or if the parmnum implicitly requires Level 2 (ie parms
    // >= 10)
    //

    if (Level == 2) {
        if ((parmnum == PARMNUM_ALL) || (parmnum == USER_FULL_NAME_PARMNUM)) {
            if (parmnum == PARMNUM_ALL) {
                pointer = ((PUSER_INFO_2)Buffer)->usri2_full_name;
            }
            if ((stringlen = POSSIBLE_WCSLEN(pointer)) > LM20_MAXCOMMENTSZ) {
                *ParmError = USER_FULL_NAME_PARMNUM;
                NetStatus = ERROR_INVALID_PARAMETER;
                goto Cleanup;
            }
            buflen += STRING_SPACE_REQD(stringlen + 1);
        }

        if ((parmnum == PARMNUM_ALL) || (parmnum == USER_USR_COMMENT_PARMNUM)) {
            if (parmnum == PARMNUM_ALL) {
                pointer = ((PUSER_INFO_2)Buffer)->usri2_usr_comment;
            }
            if ((stringlen = POSSIBLE_WCSLEN(pointer)) > LM20_MAXCOMMENTSZ) {
                *ParmError = USER_USR_COMMENT_PARMNUM;
                NetStatus = ERROR_INVALID_PARAMETER;
                goto Cleanup;
            }
            buflen += STRING_SPACE_REQD(stringlen + 1);
        }

        if ((parmnum == PARMNUM_ALL) || (parmnum == USER_PARMS_PARMNUM)) {
            if (parmnum == PARMNUM_ALL) {
                pointer = ((PUSER_INFO_2)Buffer)->usri2_parms;
            }
            if ((stringlen = POSSIBLE_WCSLEN(pointer)) > LM20_MAXCOMMENTSZ) {
                *ParmError = USER_PARMS_PARMNUM;
                NetStatus = ERROR_INVALID_PARAMETER;
                goto Cleanup;
            }
            buflen += STRING_SPACE_REQD(stringlen + 1);
        }

        if ((parmnum == PARMNUM_ALL) || (parmnum == USER_WORKSTATIONS_PARMNUM)) {
            UNICODE_STRING WorkstationString;
            if (parmnum == PARMNUM_ALL) {
                lpCallersWorkstations = &((PUSER_INFO_2)Buffer)->usri2_workstations;
            } else {
                lpCallersWorkstations = &((PUSER_INFO_1014)Buffer)->usri1014_workstations;
            }
            callersWorkstations = *lpCallersWorkstations;

            if ((stringlen = POSSIBLE_WCSLEN(callersWorkstations)) > MAX_WORKSTATION_LIST) {
                *ParmError = USER_WORKSTATIONS_PARMNUM;
                NetStatus = ERROR_INVALID_PARAMETER;
                goto Cleanup;
            }
            buflen += STRING_SPACE_REQD(stringlen + 1);

            //
            // Convert the list of workstations from being comma separated
            //  to being space separated.  Ditch workstation names containing
            //  spaces.

            if ( callersWorkstations != NULL ) {
                wcscpy( Workstations, callersWorkstations );
                RtlInitUnicodeString( &WorkstationString, Workstations );
                NetpConvertWorkstationList( &WorkstationString );
                *lpCallersWorkstations = Workstations;
            }

        }

        if ((parmnum == PARMNUM_ALL) || (parmnum == USER_LOGON_SERVER_PARMNUM)) {
            if (parmnum == PARMNUM_ALL) {
                pointer = ((PUSER_INFO_2)Buffer)->usri2_logon_server;
            }
            if ((stringlen = POSSIBLE_WCSLEN(pointer)) > MAX_PATH) {
                *ParmError = USER_LOGON_SERVER_PARMNUM;
                NetStatus = ERROR_INVALID_PARAMETER;
                goto Cleanup;
            }
            buflen += STRING_SPACE_REQD(stringlen + 1);
        }


        //
        // if the caller is setting the logon hours then we need to substitute
        // shuffled bits for the logon hours bitmap
        //

        if ((parmnum == PARMNUM_ALL) || (parmnum == USER_LOGON_HOURS_PARMNUM)) {
            if (parmnum == PARMNUM_ALL) {
                lpCallersLogonHours = (PBYTE*)&((PUSER_INFO_2)Buffer)->usri2_logon_hours;
            } else {
                lpCallersLogonHours = (PBYTE*)&((PUSER_INFO_1020)Buffer)->usri1020_logon_hours;
            }
            callersLogonHours = *lpCallersLogonHours;
            RtlCopyMemory(logonHours, callersLogonHours, sizeof(logonHours));

            //
            // shuffle the bitmap and point the logon_hours field in the structure
            // at the shuffled version
            //

            NetpRotateLogonHours(logonHours, UNITS_PER_WEEK, FALSE);
            *lpCallersLogonHours = logonHours;
        }
    }

    //
    // we have covered all the parameters that we are able to from this end. The
    // down-level APIs don't know about the ParmError concept (it is, after all,
    // a highly developed notion, too highbrow for the LanManDerthals...) so if
    // we get back an ERROR_INVALID_PARAMETER, the caller will just have to be
    // content with PARM_ERROR_UNKNOWN, and try to figure it out from there
    //

    *ParmError = PARM_ERROR_UNKNOWN;

    //
    // if originalPasswordLength is non-zero then we must be supplying a password;
    // perform the encryption machinations
    //

    if (originalPasswordLength) {

        //
        // Calculate the one-way function of the password
        //

        RtlUnicodeToMultiByteN(ansiPassword,
                                sizeof(ansiPassword),
                                &lmOwfPasswordLen,
                                *lpClearText,
                                originalPasswordLength * sizeof(WCHAR)
                                );
        ansiPassword[lmOwfPasswordLen] = 0;
        (VOID) _strupr(ansiPassword);   // down-level wants upper-cased passwords

#ifdef DOWN_LEVEL_ENCRYPTION

        Status = RtlCalculateLmOwfPassword(ansiPassword, &lmOwfPassword);
        if (NT_SUCCESS(Status)) {
            NetStatus = GetLanmanSessionKey((LPWSTR)ServerName, (LPBYTE)&lanmanKey);
            if (NetStatus == NERR_Success) {
                Status = RtlEncryptLmOwfPwdWithLmSesKey(&lmOwfPassword,
                                                        &lanmanKey,
                                                        &encryptedLmOwfPassword
                                                        );
                if (NT_SUCCESS(Status)) {
                    *lpClearText = (LPTSTR)&encryptedLmOwfPassword;
                    passwordEncrypted = TRUE;
                    if (parmnum == USER_PASSWORD_PARMNUM) {
                        buflen = sizeof(encryptedLmOwfPassword);
                    }
                }
            }
        }
        if (NetStatus != NERR_Success) {
            goto Cleanup;
        }
        else if (!NT_SUCCESS(Status)) {
            NetStatus = RtlNtStatusToDosError(Status);
            goto Cleanup;
        }

#else

        *lpClearText = (LPTSTR)ansiPassword;

#endif

    }

    //
    // New! Improved! Now, even better, RxNetUserSetInfo will use SetInfo2
    // to fix the most stubborn user set info problems (ie password)
    //

    NetStatus = RxRemoteApi(API_WUserSetInfo2,
                        ServerName,
                        REMSmb_NetUserSetInfo2_P,
                        pDesc16, pDesc32, pDescSmb, // data descriptors
                        NULL, NULL, NULL,           // no aux data
                        FALSE,                      // must be logged on
                        UserName,                   // parameters...
                        Level,

                        //
                        // if we are sending the whole structure, then Buffer
                        // points to the structure, else Buffer points to a
                        // pointer to the field to set; RxRemoteApi expects
                        // a pointer to the data
                        //

                        parmnum == PARMNUM_ALL || parmnum == USER_PASSWORD_PARMNUM
                            ? Buffer
                            : *(LPBYTE*)Buffer,
                        buflen,                     // supplied by us

                        //
                        // in this case, the field index and parm num are the
                        // same value
                        //

                        MAKE_PARMNUM_PAIR(parmnum, parmnum),

                        //
                        // add those extraneous WWs: whether the data is
                        // encrypted and the original password length. (By
                        // deduction: password is the only data that is
                        // encrypted)
                        //

                        passwordEncrypted,
                        originalPasswordLength
                        );

Cleanup:
    //
    // copy the original password back to the user's buffer if we set a password
    //

    if (originalPasswordLength) {
        *lpClearText = cleartext;
    }

    //
    // restore the original logon hours string
    //

    if (callersLogonHours) {
        *lpCallersLogonHours = callersLogonHours;
    }

    //
    // restore the original workstation list
    //

    if ( callersWorkstations != NULL) {
        *lpCallersWorkstations = callersWorkstations;
    }
    return NetStatus;
}


//NET_API_STATUS
//RxNetUserValidate2
//    /** CANNOT BE REMOTED **/
//{
//
//}


DBGSTATIC
NET_API_STATUS
GetUserDescriptors(
    IN  DWORD   Level,
    IN  BOOL    Encrypted,
    OUT LPDESC* ppDesc16,
    OUT LPDESC* ppDesc32,
    OUT LPDESC* ppDescSmb
    )

/*++

Routine Description:

    Returns pointers to descriptor strings for user info structures based on
    level of info required for RxNetUser routines

Arguments:

    Level       - of info being requested
    Encrypted   - TRUE if info structure contains encrypted password
    ppDesc16    - where to return pointer to 16-bit data descriptor
    ppDesc32    - where to return pointer to 32-bit data descriptor
    ppDescSmb   - where to return pointer to SMB data descriptor

Return Value:

    ERROR_INVALID_LEVEL - If the level was not in the list.

    NO_ERROR - If the operation was successful.

--*/

{
    switch (Level) {
    case 0:
        *ppDesc16 = REM16_user_info_0;
        *ppDesc32 = REM32_user_info_0;
        *ppDescSmb = REMSmb_user_info_0;
        break;

    case 1:
        *ppDesc16 = REM16_user_info_1;
        *ppDesc32 = Encrypted ? REM32_user_info_1 : REM32_user_info_1_NOCRYPT;
        *ppDescSmb = REMSmb_user_info_1;
        break;

    case 2:
        *ppDesc16 = REM16_user_info_2;
        *ppDesc32 = Encrypted ? REM32_user_info_2 : REM32_user_info_2_NOCRYPT;
        *ppDescSmb = REMSmb_user_info_2;
        break;

    case 10:
        *ppDesc16 = REM16_user_info_10;
        *ppDesc32 = REM32_user_info_10;
        *ppDescSmb = REMSmb_user_info_10;
        break;

    case 11:
        *ppDesc16 = REM16_user_info_11;
        *ppDesc32 = REM32_user_info_11;
        *ppDescSmb = REMSmb_user_info_11;
        break;

    default:
        return(ERROR_INVALID_LEVEL);
    }
    return(NO_ERROR);
}


DBGSTATIC
VOID
GetModalsDescriptors(
    IN  DWORD   Level,
    OUT LPDESC* ppDesc16,
    OUT LPDESC* ppDesc32,
    OUT LPDESC* ppDescSmb
    )

/*++

Routine Description:

    Returns pointers to descriptor strings for modals info structures based on
    level of info required for RxNetUserModals routines

Arguments:

    Level       - of info being requested
    ppDesc16    - where to return pointer to 16-bit data descriptor
    ppDesc32    - where to return pointer to 32-bit data descriptor
    ppDescSmb   - where to return pointer to SMB data descriptor

Return Value:

    None.

--*/

{
    switch (Level) {
    case 0:
        *ppDesc16 = REM16_user_modals_info_0;
        *ppDesc32 = REM32_user_modals_info_0;
        *ppDescSmb = REMSmb_user_modals_info_0;
        break;

    case 1:
        *ppDesc16 = REM16_user_modals_info_1;
        *ppDesc32 = REM32_user_modals_info_1;
        *ppDescSmb = REMSmb_user_modals_info_1;
        break;
    }
}


NET_API_STATUS
GetLanmanSessionKey(
    IN LPWSTR ServerName,
    OUT LPBYTE pSessionKey
    )

/*++

Routine Description:

    Retrieves the LM session key for the connection from the redir FSD

Arguments:

    ServerName  - name of server to get session key for
    pSessionKey - pointer to where session key will be deposited

Return Value:

    NET_API_STATUS
        Success - NERR_Success
        Failure -

--*/

{
    NTSTATUS ntStatus;
    HANDLE hToken;
    TOKEN_STATISTICS stats;
    ULONG length;
    LMR_REQUEST_PACKET request;
    LMR_CONNECTION_INFO_2 connectInfo;
    NET_API_STATUS apiStatus;
    WCHAR connectionName[MAX_PATH];

    ntStatus = NtOpenProcessToken(NtCurrentProcess(), GENERIC_READ, &hToken);
    if (NT_SUCCESS(ntStatus)) {

        //
        // Get the logon id of the current thread
        //

        ntStatus = NtQueryInformationToken(hToken,
                                            TokenStatistics,
                                            (PVOID)&stats,
                                            sizeof(stats),
                                            &length
                                            );
        if (NT_SUCCESS(ntStatus)) {

            RtlCopyLuid(&request.LogonId, &stats.AuthenticationId);
            request.Type = GetConnectionInfo;
            request.Version = REQUEST_PACKET_VERSION;
            request.Level = 2;

            wcscpy(connectionName, ServerName);
            wcscat(connectionName, L"\\IPC$");

            apiStatus = NetpRdrFsControlTree(connectionName,
                                                NULL,
                                                USE_WILDCARD,
                                                FSCTL_LMR_GET_CONNECTION_INFO,
                                                NULL,
                                                (LPVOID)&request,
                                                sizeof(request),
                                                (LPVOID)&connectInfo,
                                                sizeof(connectInfo),
                                                FALSE
                                                );
            if (apiStatus == NERR_Success) {
                RtlMoveMemory(pSessionKey,
                                &connectInfo.LanmanSessionKey,
                                sizeof(connectInfo.LanmanSessionKey)
                                );
            }
        }
        NtClose(hToken);
    }
    if (!NT_SUCCESS(ntStatus)) {
        apiStatus = NetpNtStatusToApiStatus(ntStatus);
    }
    return apiStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\rpcxlate\rxapi\sessconv.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    SessConv.c

Abstract:

    This file contains RxpConvertSessionInfo().

Author:

    John Rogers (JohnRo) 17-Oct-1991

Environment:

    Portable to any flat, 32-bit environment.  (Uses Win32 typedefs.)
    Requires ANSI C extensions: slash-slash comments, long external names.

Revision History:

    17-Oct-1991 JohnRo
        Created.
    21-Nov-1991 JohnRo
        Removed NT dependencies to reduce recompiles.

--*/


// These must be included first:

#include <windef.h>             // IN, DWORD, etc.
#include <lmcons.h>             // NET_API_STATUS, etc.
#include <lmshare.h>            // Required by rxsess.h.

// These may be included in any order:

#include <netdebug.h>           // NetpAssert(), NetpKdPrint(()), etc.
#include <netlib.h>             // NetpCopyStringToBuffer().
#include <rxpdebug.h>           // IF_DEBUG().
#include <rxsess.h>             // My prototype.
#include <tstring.h>            // STRLEN().


#define DO_STRING(destField, srcField) \
    { \
        BOOL CopyOK; \
        CopyOK = NetpCopyStringToBuffer ( \
                in->srcField, \
                STRLEN(in->srcField), \
                OutFixedDataEnd, \
                StringLocation, \
                & out->destField); \
        NetpAssert(CopyOK); \
    }

VOID
RxpConvertSessionInfo (
    IN LPSESSION_SUPERSET_INFO InStructure,
    IN DWORD Level,
    OUT LPVOID OutStructure,
    IN LPVOID OutFixedDataEnd,
    IN OUT LPTSTR *StringLocation
    )

{
    LPSESSION_SUPERSET_INFO in = InStructure;

    NetpAssert(InStructure != NULL);
    NetpAssert(OutStructure != NULL);
    NetpAssert(StringLocation != NULL);

    IF_DEBUG(SESSION) {
        NetpKdPrint(( "RxpConvertSessionInfo: converting to level "
                FORMAT_DWORD ".\n", Level ));
    }

    switch (Level) {

    // 0 is subset of 1, and 1 is subset of 2.
    case 0 :
    case 1 :
    case 2 :
        {
            LPSESSION_INFO_2 out = OutStructure;

            // Field(s) common to levels 0, 1, 2.
            DO_STRING( sesi2_cname, sesi2_cname );
            if (Level == 0) {
                break;
            }

            // Field(s) common to levels 1, 2.
            DO_STRING( sesi2_username, sesi2_username );
            // Note: NT doesn't have sesiX_num_conns or sesiX_num_users.
            out->sesi2_num_opens  = in->sesi2_num_opens;
            out->sesi2_time       = in->sesi2_time;
            out->sesi2_idle_time  = in->sesi2_idle_time;
            out->sesi2_user_flags = in->sesi2_user_flags;
            if (Level == 1) {
                break;
            }

            // Field(s) unique to level 2.
            DO_STRING( sesi2_cltype_name, sesi2_cltype_name );

        }
        break;

    case 10 :
        {
            LPSESSION_INFO_10 out = OutStructure;

            DO_STRING( sesi10_cname,    sesi2_cname);
            DO_STRING( sesi10_username, sesi2_username );
            out->sesi10_time       = in->sesi2_time;
            out->sesi10_idle_time  = in->sesi2_idle_time;

        }
        break;

    default :
        NetpAssert(FALSE);
    }

} // RxpConvertSessionInfo
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\rpcxlate\rxapi\sessdel.c ===
/*++

Copyright (c) 1991-1993  Microsoft Corporation

Module Name:

    SessDel.c

Abstract:

    This file contains RxNetSessionDel().

Author:

    John Rogers (JohnRo) 18-Oct-1991

Environment:

    Portable to any flat, 32-bit environment.  (Uses Win32 typedefs.)
    Requires ANSI C extensions: slash-slash comments, long external names.

Revision History:

    18-Oct-1991 JohnRo
        Created.
    21-Oct-1991 JohnRo
        Fixed bug: RxNetSessionEnum wants BufPtr as "LPBYTE *".
        Added debug output.
    27-Jan-1993 JohnRo
        RAID 8926: NetConnectionEnum to downlevel: memory leak on error.
        Use PREFIX_ equates.

--*/

// These must be included first:

#include <windef.h>             // IN, DWORD, etc.
#include <lmcons.h>             // DEVLEN, NET_API_STATUS, etc.
#include <lmshare.h>            // Required by rxsess.h.

// These may be included in any order:

#include <apinums.h>            // API_ equates.
#include <lmapibuf.h>           // NetApiBufferFree().
#include <lmerr.h>              // ERROR_ and NERR_ equates.
#include <netdebug.h>   // NetpKdPrint(), FORMAT_ equates.
#include <prefix.h>     // PREFIX_ equates.
#include <rap.h>                // LPDESC.
#include <remdef.h>             // REM16_, REM32_, REMSmb_ equates.
#include <rx.h>                 // RxRemoteApi().
#include <rxpdebug.h>           // IF_DEBUG().
#include <rxsess.h>             // My prototype, RxpSession routines.


NET_API_STATUS
RxNetSessionDel (
    IN  LPTSTR      UncServerName,
    IN  LPTSTR      ClientName OPTIONAL,
    IN  LPTSTR      UserName OPTIONAL
    )
{
    LPSESSION_SUPERSET_INFO ArrayPtr = NULL;
    DWORD EntryCount;
    NET_API_STATUS Status;
    DWORD TotalEntries;

    NetpAssert(UncServerName != NULL);
    NetpAssert(*UncServerName != '\0');

    //
    // In LM 2.0, there's no way to delete with UserName or delete all clients,
    // so we have to do an enum and find the sessions we want to delete.
    //
    Status = RxNetSessionEnum (
            UncServerName,
            ClientName,
            UserName,
            SESSION_SUPERSET_LEVEL,
            /*lint -save -e530 */  // (We know variable isn't initialized.)
            (LPBYTE *) (LPVOID *) & ArrayPtr,
            /*lint -restore */  // (Resume uninitialized variable checking.)
            1024,                       // prefered maximum (arbitrary)
            & EntryCount,
            & TotalEntries,
            NULL);                      // no resume handle

    if (Status == NERR_Success) {

        NetpAssert( EntryCount == TotalEntries );

        IF_DEBUG(SESSION) {
            NetpKdPrint(( PREFIX_NETAPI
                    "RxNetSessionDel: enum found " FORMAT_DWORD
                    " entries in array at " FORMAT_LPVOID ".\n",
                    EntryCount, (LPVOID) ArrayPtr ));
        }
        if (EntryCount > 0) {

            LPSESSION_SUPERSET_INFO EntryPtr = ArrayPtr;
            NET_API_STATUS WorstStatus = NERR_Success;

            for ( ; EntryCount > 0; --EntryCount) {

                IF_DEBUG(SESSION) {
                    NetpKdPrint(( PREFIX_NETAPI
                            "RxNetSessionDel: checking entry at "
                            FORMAT_LPVOID ", count is " FORMAT_DWORD ".\n",
                            (LPVOID) EntryPtr, EntryCount ));
                }

                if (RxpSessionMatches( EntryPtr, ClientName, UserName) ) {

                    Status = RxRemoteApi(
                            API_WSessionDel,            // API number
                            UncServerName,
                            REMSmb_NetSessionDel_P,     // parm desc
                            NULL,                       // no data desc 16
                            NULL,                       // no data desc 32
                            NULL,                       // no data desc SMB
                            NULL,                       // no aux desc 16
                            NULL,                       // no aux desc 32
                            NULL,                       // no aux desc SMB
                            0,                          // flags: normal
                            // rest of API's arguments, in 32-bit LM2.x format:
                            ClientName,                 // client computer name
                            (DWORD) 0);                 // reserved.
                    if (Status != NERR_Success) {
                        WorstStatus = Status;
                    }
                }

                ++EntryPtr;

            }

            Status = WorstStatus;

        } else {

            // No entries found.
            Status = RxpSessionMissingErrorCode( ClientName, UserName );
        }

    }

    if (ArrayPtr != NULL ) {
        (void) NetApiBufferFree( ArrayPtr );
    }

    return (Status);

} // RxNetSessionDel
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\rpcxlate\rxapi\sessenum.c ===
/*++

Copyright (c) 1991-92  Microsoft Corporation

Module Name:

    SessEnum.c

Abstract:

    This file contains the RpcXlate code to handle the Session APIs.

Author:

    John Rogers (JohnRo) 17-Oct-1991

Environment:

    Portable to any flat, 32-bit environment.  (Uses Win32 typedefs.)
    Requires ANSI C extensions: slash-slash comments, long external names.

Revision History:

    17-Oct-1991 JohnRo
        Created.
    18-Oct-1991 JohnRo
        Removed incorrect assertion on status from RxpCopyAndConvertSessions().
    21-Nov-1991 JohnRo
        Removed NT dependencies to reduce recompiles.
    07-Feb-1992 JohnRo
        Fixed bug where temp array was often allocated too small.
        Fixed bug where temp array was freed when it might not exist.

--*/

#include "downlevl.h"
#include "rxshare.h"
#include <lmshare.h>    // typedefs for SHARE_INFO etc.
#include <rap.h>                // LPDESC.
#include <rxsess.h>             // My prototype(s).
#include <strucinf.h>           // NetpSessionStructureInfo().
#include <winerror.h>           // ERROR_, NO_ERROR equates.


#define SESSION_ARRAY_OVERHEAD_SIZE     0


NET_API_STATUS
RxNetSessionEnum (
    IN LPTSTR UncServerName,
    IN LPTSTR ClientName OPTIONAL,
    IN LPTSTR UserName OPTIONAL,
    IN DWORD LevelWanted,
    OUT LPBYTE *BufPtr,
    IN DWORD PreferedMaximumSize,
    OUT LPDWORD EntriesRead,
    OUT LPDWORD TotalEntries,
    IN OUT LPDWORD ResumeHandle OPTIONAL
    )

/*++

Routine Description:

    RxNetSessionEnum performs the same function as NetSessionEnum,
    except that the server name is known to refer to a downlevel server.

Arguments:

    (Same as NetSessionEnum, except UncServerName must not be null, and
    must not refer to the local computer.)

Return Value:

    (Same as NetSessionEnum.)

--*/

{
    NET_API_STATUS ApiStatus;
    DWORD EntriesToAllocate;

    const DWORD TempLevel = 2;          // Superset info level.
    LPBYTE TempArray = NULL;            // Buffer we'll use.
    DWORD TempArraySize;                // Byte count for TempArray.
    LPDESC TempDataDesc16, TempDataDesc32, TempDataDescSmb;
    DWORD TempMaxEntrySize;
    NET_API_STATUS TempStatus;

    UNREFERENCED_PARAMETER(ResumeHandle);

    // Make sure caller didn't mess up.
    NetpAssert(UncServerName != NULL);
    if (BufPtr == NULL) {
        return (ERROR_INVALID_PARAMETER);
    }

    // Assume something might go wrong, and make error paths easier to
    // code.  Also, check for bad pointers before we do anything.
    *BufPtr = NULL;
    *EntriesRead = 0;
    *TotalEntries = 0;

    //
    // Find out about superset info level.
    //
    TempStatus = NetpSessionStructureInfo (
            TempLevel,
            PARMNUM_ALL,                // want all fields.
            TRUE,                       // want native sizes.
            & TempDataDesc16,
            & TempDataDesc32,
            & TempDataDescSmb,
            & TempMaxEntrySize,         // total buffer size (native)
            NULL,                       // don't need fixed size
            NULL                        // don't need string size
            );
    if (TempStatus != NO_ERROR) {
        *BufPtr = NULL;
        return (TempStatus);
    }

    //
    // Downlevel servers don't support resume handles, and we don't
    // have a way to say "close this resume handle" even if we wanted to
    // emulate them here.  Therefore we have to do everthing in one shot.
    // So, the first time around, we'll try using the caller's prefered
    // maximum, but we will enlarge that until we can get everything in one
    // buffer.
    //

    // First time: try caller's prefered maximum.
    NetpAdjustPreferedMaximum (
            PreferedMaximumSize,        // caller's request
            TempMaxEntrySize,           // byte count per array element
            SESSION_ARRAY_OVERHEAD_SIZE,// num bytes to show array end
            NULL,                       // we'll compute byte counts ourselves.
            & EntriesToAllocate);       // num of entries we can get.

    //
    // Loop until we have enough memory or we die for some other reason.
    //
    do {

        // Figure out how much memory we need.
        TempArraySize = (EntriesToAllocate * TempMaxEntrySize)
                + SESSION_ARRAY_OVERHEAD_SIZE;
        if (TempArraySize > MAX_TRANSACT_RET_DATA_SIZE) {
            //
            // Try once more with the maximum-size buffer
            //
            TempArraySize = MAX_TRANSACT_RET_DATA_SIZE;
        }

        //
        // Remote the API, which will allocate the array for us.
        //

        ApiStatus = RxRemoteApi(
                API_WSessionEnum,       // api number
                UncServerName,          // \\servername
                REMSmb_NetSessionEnum_P,// parm desc (SMB version)
                TempDataDesc16,
                TempDataDesc32,
                TempDataDescSmb,
                NULL,                   // no aux desc 16
                NULL,                   // no aux desc 32
                NULL,                   // no aux desc SMB
                ALLOCATE_RESPONSE,      // flags: allocate buffer for us
                // rest of API's arguments in 32-bit LM 2.x format:
                TempLevel,              // sLevel: info level (superset!)
                & TempArray,            // Buffer: array (alloc for us)
                TempArraySize,          // Buffer: array size in bytes
                EntriesRead,            // pcEntriesRead
                TotalEntries);          // pcTotalAvail

        if (ApiStatus == ERROR_MORE_DATA) {
            (void) NetApiBufferFree( TempArray );
            TempArray = NULL;

            if (TempArraySize >= MAX_TRANSACT_RET_DATA_SIZE) {
                //
                // No point in trying with a larger buffer
                //
                break;
            }

            NetpAssert( EntriesToAllocate < *TotalEntries );
            EntriesToAllocate = *TotalEntries;
        }
    } while (ApiStatus == ERROR_MORE_DATA);


    if (ApiStatus == NO_ERROR) {

        LPVOID RealArray;
        DWORD EntriesSelected;

        //
        // Handle UserName and ClientName sematics.  Also convert to the
        // wanted info level.
        //
        TempStatus = RxpCopyAndConvertSessions(
                (LPSESSION_SUPERSET_INFO) TempArray,    // input array
                *EntriesRead,           // input entry count
                LevelWanted,            // want output in this info level
                ClientName,             // select this client optional any)
                UserName,               // select this user name (optional)
                & RealArray,            // alloc'ed, converted, selected array
                & EntriesSelected);     // count of entries selected

        //
        // Note that EntriesSelected may be 0 and RealArray may be NULL.
        //
        *BufPtr = RealArray;
        *EntriesRead = EntriesSelected;
        *TotalEntries = EntriesSelected;

        (void) NetApiBufferFree( TempArray );

    }

    return (ApiStatus);

} // RxNetSessionEnum
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\rpcxlate\rxapi\sessget.c ===
/*++

Copyright (c) 1991-92  Microsoft Corporation

Module Name:

    SessGet.c

Abstract:

    This file contains the RpcXlate code to handle the NetSession APIs
    that can't be handled by simple calls to RxRemoteApi.

Author:

    John Rogers (JohnRo) 17-Oct-1991

Environment:

    Portable to any flat, 32-bit environment.  (Uses Win32 typedefs.)
    Requires ANSI C extensions: slash-slash comments, long external names.

Revision History:

    17-Oct-1991 JohnRo
        Created.
    25-Oct-1991 JohnRo
        Fixed bug where null chars weren't treated correctly.
    20-Nov-1991 JohnRo
        NetSessionGetInfo requires UncClientName and UserName.
        This fixes the AE (application error) in NetSess.exe.
    21-Nov-1991 JohnRo
        Removed NT dependencies to reduce recompiles.
    07-Feb-1992 JohnRo
        Use NetApiBufferAllocate() instead of private version.
    08-Sep-1992 JohnRo
        Fixed __stdcall for RpcXlate workers.

--*/


// These must be included first:

#include <windef.h>             // IN, DWORD, etc.
#include <lmcons.h>             // NET_API_STATUS, etc.
#include <lmshare.h>            // Required by rxsess.h.

// These may be included in any order:

#include <apinums.h>            // API_ equates.
#include <lmapibuf.h>           // NetApiBufferAllocate().
#include <lmerr.h>              // ERROR_ and NERR_ equates.
#include <netdebug.h>           // DBGSTATIC, NetpKdPrint(()), FORMAT_ equates.
#include <netlib.h>             // NetpPointerPlusSomeBytes, etc.
#include <rap.h>                // LPDESC.
#include <remdef.h>             // REMSmb_ equates.
#include <rx.h>                 // RxRemoteApi().
#include <rxpdebug.h>           // IF_DEBUG().
#include <rxsess.h>             // My prototype.
#include <strucinf.h>           // NetpSessionStructureInfo().


// VOID
// NetpChangeNullCharToNullPtr(
//     IN OUT LPTSTR p
//     );
//
#define ChangeNullCharToNullPtr(p) \
    { \
        if ( ((p) != NULL) && (*(p) == '\0') ) { \
            (p) = NULL; \
        } \
    }


NET_API_STATUS
RxNetSessionGetInfo (
    IN LPTSTR UncServerName,
    IN LPTSTR UncClientName,
    IN LPTSTR UserName,
    IN DWORD LevelWanted,
    OUT LPBYTE *BufPtr
    )

/*++

Routine Description:

    RxNetSessionGetInfo performs the same function as NetSessionGetInfo,
    except that the server name is known to refer to a downlevel server.

Arguments:

    (Same as NetSessionGetInfo, except UncServerName must not be null, and
    must not refer to the local computer.)

Return Value:

    (Same as NetSessionGetInfo.)

--*/

{
    NET_API_STATUS ApiStatus;
    LPBYTE TempBuffer;               // Buffer we'll use.
    DWORD TempBufferSize;
    LPDESC TempDataDesc16, TempDataDesc32, TempDataDescSmb;
    NET_API_STATUS TempStatus;
    DWORD TotalAvail;

    IF_DEBUG(SESSION) {
        NetpKdPrint(("RxNetSessionGetInfo: starting, server=" FORMAT_LPTSTR
                ", lvl=" FORMAT_DWORD ".\n", UncServerName, LevelWanted));
    }

    //
    // Update pointers if they point to null chars.
    //
    ChangeNullCharToNullPtr( UncClientName );
    ChangeNullCharToNullPtr( UserName );

    //
    // Error check DLL stub and the app.
    //
    NetpAssert(UncServerName != NULL);
    if (BufPtr == NULL) {
        return (ERROR_INVALID_PARAMETER);
    }
    *BufPtr = NULL;  // assume error; it makes error handlers easy to code.
    // This also forces possible GP fault before we allocate memory.

    if ( (UncClientName == NULL) || (UserName == NULL) ) {
        return (ERROR_INVALID_PARAMETER);
    }

    //
    // Learn about temp info level (max superset of all levels).
    //
    TempStatus = NetpSessionStructureInfo (
            SESSION_SUPERSET_LEVEL,     // level to learn about
            PARMNUM_ALL,                // No parmnum with this.
            TRUE,                       // Need native sizes.
            & TempDataDesc16,
            & TempDataDesc32,
            & TempDataDescSmb,
            & TempBufferSize,           // max buffer size (native)
            NULL,                       // don't need fixed size.
            NULL                        // don't need string size.
            );
    NetpAssert(TempStatus == NERR_Success);

    //
    // Allocate memory for 32-bit version of superset info level.
    //
    TempStatus = NetApiBufferAllocate(
            TempBufferSize,
            (LPVOID *) & TempBuffer);
    if (TempStatus != NERR_Success) {
        return (TempStatus);
    }
    IF_DEBUG(SESSION) {
        NetpKdPrint(( "RxNetSessionGetInfo: allocated temp buffer at "
                FORMAT_LPVOID "\n", (LPVOID) TempBuffer ));
    }

    //
    // Actually remote the API, which will get back the superset
    // data in native format.
    //
    ApiStatus = RxRemoteApi(
            API_WSessionGetInfo,        // API number
            UncServerName,              // Required, with \\name.
            REMSmb_NetSessionGetInfo_P, // parm desc
            TempDataDesc16,
            TempDataDesc32,
            TempDataDescSmb,
            NULL,                       // no aux data desc 16
            NULL,                       // no aux data desc 32
            NULL,                       // no aux data desc SMB
            0,                          // Flags: normal
            // rest of API's arguments, in 32-bit LM 2.x format:
            UncClientName,
            SESSION_SUPERSET_LEVEL,     // level with all possible fields
            TempBuffer,
            TempBufferSize,
            & TotalAvail);              // total size 

    NetpAssert( ApiStatus != ERROR_MORE_DATA );
    NetpAssert( ApiStatus != NERR_BufTooSmall );

    if (ApiStatus == NERR_Success) {

        DWORD EntriesSelected;

        //
        // Copy and convert from temp info level to level the caller wants.
        // Check for match on UncClientName and UserName first.
        //
        TempStatus = RxpCopyAndConvertSessions(
                (LPSESSION_SUPERSET_INFO) TempBuffer,  // input "array"
                1,                      // only one "entry" this time
                LevelWanted,
                UncClientName,
                UserName,
                (LPVOID *) BufPtr,      // alloc'ed (may be NULL if no match)
                & EntriesSelected);     // output entry count
        NetpAssert(TempStatus == NERR_Success);

        if (EntriesSelected == 0) {

            ApiStatus = RxpSessionMissingErrorCode( UncClientName, UserName );
            NetpAssert( ApiStatus != NERR_Success );
        }
    }
    (void) NetApiBufferFree( TempBuffer );
    return (ApiStatus);

} // RxNetSessionGetInfo
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\rpcxlate\rxapi\sessmtch.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    SessMtch.c

Abstract:

    This file contains RxpSessionMatches().

Author:

    John Rogers (JohnRo) 17-Oct-1991

Environment:

    Portable to any flat, 32-bit environment.  (Uses Win32 typedefs.)
    Requires ANSI C extensions: slash-slash comments, long external names.

Revision History:

    17-Oct-1991 JohnRo
        Created.
    18-Oct-1991 JohnRo
        Fixed bug: sesiX_cname is not a UNC name.
    25-Oct-1991 JohnRo
        Fixed bug: allow UncClientName and UserName to point to null char.

--*/


// These must be included first:

#include <windef.h>             // IN, DWORD, etc.
#include <lmcons.h>             // NET_API_STATUS, etc.
#include <lmshare.h>            // Required by rxsess.h.

// These may be included in any order:

#include <netdebug.h>           // NetpAssert().
#include <rxsess.h>             // My prototype.
#include <tstring.h>            // STRICMP().


BOOL
RxpSessionMatches (
    IN LPSESSION_SUPERSET_INFO Candidate,
    IN LPTSTR UncClientName OPTIONAL,
    IN LPTSTR UserName OPTIONAL
    )

/*++

Routine Description:

    RxpSessionMatches is used to determine whether or not a given session
    structure (part of an array, probably) matches the given client name
    and user name.

Arguments:

    Candidate - possible match in the form of a superset info structure.

    UncClientName - an optional UNC computer name.

    UserName - an optional user name.

Return Value:

    BOOL - TRUE if structure matches client name and user name.

--*/

{

    NetpAssert(Candidate != NULL);

    NetpAssert(SESSION_SUPERSET_LEVEL == 2);  // assumed by code below.

    if ( (UncClientName != NULL) && (*UncClientName != '\0') ) {
        NetpAssert( Candidate->sesi2_cname != NULL );
        NetpAssert( UncClientName[0] == '\\' );
        NetpAssert( UncClientName[1] == '\\' );

        if (STRICMP( &UncClientName[2], Candidate->sesi2_cname) != 0) {
            return (FALSE);  // no match.
        }
    }

    if ( (UserName != NULL) && (*UserName != '\0') ) {
        NetpAssert(Candidate->sesi2_username != NULL);
        if (STRICMP(UserName, Candidate->sesi2_username) != 0) {
            return (FALSE);  // no match.
        }
    }

    return (TRUE);           // matches.

} // RxpSessionMatches
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\rpcxlate\rxapi\srvenum.c ===
/*++

Copyright (c) 1991-1993  Microsoft Corporation

Module Name:

    SrvEnum.c

Abstract:

    This module only contains RxNetServerEnum.

Author:

    John Rogers (JohnRo) 03-May-1991

Environment:

    Portable to any flat, 32-bit environment.  (Uses Win32 typedefs.)
    Requires ANSI C extensions: slash-slash comments, long external names.

Revision History:

    03-May-1991 JohnRo
        Created.
    14-May-1991 JohnRo
        Pass 3 aux descriptors to RxRemoteApi.
    22-May-1991 JohnRo
        Made LINT-suggested changes.  Got rid of tabs.
    26-May-1991 JohnRo
        Added incomplete output parm to RxGetServerInfoLevelEquivalent.
    17-Jul-1991 JohnRo
        Extracted RxpDebug.h from Rxp.h.
    15-Oct-1991 JohnRo
        Be paranoid about possible infinite loop.
    21-Nov-1991 JohnRo
        Removed NT dependencies to reduce recompiles.
    07-Feb-1992 JohnRo
        Use NetApiBufferAllocate() instead of private version.
    22-Sep-1992 JohnRo
        RAID 6739: Browser too slow when not logged into browsed domain.
        Use PREFIX_ equates.
    14-Oct-1992 JohnRo
        RAID 8844: Assert in net/netlib/convsrv.c(563) converting srvinfo
        struct (caused by bug in RxNetServerEnum).
    10-Dec-1992 JohnRo
        RAID 4999: RxNetServerEnum doesn't handle near 64K right.
    02-Apr-1993 JohnRo
        RAID 5098: DOS app NetUserPasswordSet to downlevel gets NT return code.
        Clarify design limit debug message.
    28-Apr-1993 JohnRo
        RAID 8072: Remoting NetServerEnum to WFW server hangs forever.
    05-May-1993 JohnRo
        RAID 8720: bad data from WFW can cause RxNetServerEnum GP fault.
    21-Jun-1993 JohnRo
        RAID 14180: NetServerEnum never returns (alignment bug in
        RxpConvertDataStructures).
        Also avoid infinite loop RxNetServerEnum.
        Made changes suggested by PC-LINT 5.0

--*/

// These must be included first:


#include <nt.h>                  // DbgPrint prototype
#include <ntrtl.h>                  // DbgPrint
#include <nturtl.h>                 // Needed by winbase.h

#include <windef.h>                 // DWORD
#include <winbase.h>                // LocalFree
// #include <windows.h>    // IN, LPBYTE, DWORD, etc.
#include <lmcons.h>             // NET_API_STATUS, etc.
#include <rap.h>                // LPDESC, etc.  (Needed by <RxServer.h>)
#include <lmerr.h>      // NERR_ and ERROR_ equates.  (Needed by rxp.h)

// These may be included in any order:

#include <apinums.h>            // API_ equates.
#include <dlserver.h>           // NetpConvertServerInfo().
#include <lmapibuf.h>           // API buffer alloc & free routines.
#include <lmremutl.h>   // RxRemoteApi().
#include <lmserver.h>   // SV_TYPE_DOMAIN_ENUM.
#include <netdebug.h>   // NetpAssert(), NetpKdPrint(), FORMAT_ equates.
#include <netlib.h>             // NetpAdjustPreferedMaximum().
#include <prefix.h>     // PREFIX_ equates.
#include <remdef.h>             // REMSmb_ equates.
#include <rxp.h>        // MAX_TRANSACT_RET_DATA_SIZE, RxpFatalErrorCode().
#include <rxpdebug.h>           // IF_DEBUG().
#include <rxserver.h>           // My prototype, etc.
#include <rpcutil.h>           // MIDL_user_allocate


#define OVERHEAD 0


#define INITIAL_MAX_SIZE        (1024 * 16)


VOID
ServerRelocationRoutine(
    IN DWORD Level,
    IN DWORD FixedSize,
    IN DWORD EntryCount,
    IN LPBYTE Buffer,
    IN PTRDIFF_T Offset
    )

/*++

Routine Description:

   Routine to relocate the pointers from the fixed portion of a NetServerEnum
   enumeration buffer to the string portion of an enumeration buffer.

Arguments:

    Level - Level of information in the  buffer.

    FixedSize - Size of each entry in Buffer.

    EntryCount - Number of entries in Buffer.

    Buffer - Array of SERVER_INFO_X structures.

    Offset - Offset to add to each pointer in the fixed portion.

Return Value:

    Returns the error code for the operation.

--*/

{

//
// Local macro to add a byte offset to a pointer.
//

#define RELOCATE_ONE( _fieldname, _offset ) \
    if ( (_fieldname) != NULL ) { \
        _fieldname = (PVOID) ((LPBYTE)(_fieldname) + _offset); \
    }

    DWORD EntryNumber;

    //
    // Loop relocating each field in each fixed size structure
    //

    for ( EntryNumber=0; EntryNumber<EntryCount; EntryNumber++ ) {

        LPBYTE TheStruct = Buffer + FixedSize * EntryNumber;

        switch ( Level ) {
        case 101:
            RELOCATE_ONE( ((PSERVER_INFO_101)TheStruct)->sv101_comment, Offset );

            //
            // Drop through to case 100
            //

        case 100:
            RELOCATE_ONE( ((PSERVER_INFO_100)TheStruct)->sv100_name, Offset );
            break;

        default:
            return;

        }

    }

    return;

}


NET_API_STATUS
AppendServerList(
    IN OUT LPBYTE *CurrentServerList,
    IN OUT LPDWORD CurrentEntriesRead,
    IN OUT LPDWORD CurrentTotalEntries,
    IN DWORD Level,
    IN DWORD FixedSize,
    IN LPBYTE *NewServerList,
    IN DWORD NewEntriesRead,
    IN DWORD NewTotalEntries
    )

/*++

Routine Description:

    Concatenates two ServerList Arrays.

Arguments:

    CurrentServerList -- Pointer to the current server list.  The resultant server list
        is returned here.
        Pass a pointer to NULL if there is no current list.
        The returned list should be free by MIDL_user_free().

    CurrentEntriesRead -- Pointer to the number of entries is CurrentServerList.
        Updated to reflect entries added.

    CurrentTotalEtnries -- Pointer to the total number of entries available at server.
        Updated to reflect new information.

    Level -- Info level of CurrentServerList and NewServerList.

    FixedSize -- Fixed size of each entry.

    NewServerList -- Pointer to the server list to append to CurrentServerList.
        NULL is returned if this routine deallocates the buffer.

    NewEntriesRead -- Number of entries in NewServerList.

    NewTotalEntries -- Total number of entries the server believes it has.

Return Value:

    NERR_Success -- All OK

    ERROR_NO_MEMORY -- Can't reallocate the buffer.

--*/


{
    LPBYTE TempServerList;
    LPBYTE Where;

    LPBYTE LocalCurrentServerList;
    LPBYTE LocalNewServerList;
    DWORD CurrentFixedSize;
    DWORD NewFixedSize;
    DWORD CurrentAllocatedSize;
    DWORD NewAllocatedSize;

    //
    // If this is the first list to append,
    //  simply capture this list and return it to the caller.
    //

    if ( *CurrentServerList == NULL ) {
        *CurrentServerList = *NewServerList;
        *NewServerList = NULL;
        *CurrentEntriesRead = NewEntriesRead;
        *CurrentTotalEntries = NewTotalEntries;
        return NERR_Success;
    }

    //
    // Early out if there's nothing to return.
    //

    if ( NewEntriesRead == 0 ) {
        return NERR_Success;
    }

    //
    // Handle the case where the first entry appended is equal to the current last entry.
    //

    CurrentAllocatedSize = MIDL_user_size( *CurrentServerList );
    NewAllocatedSize = MIDL_user_size( *NewServerList );

    TempServerList = *NewServerList;

    if ( NewEntriesRead != 0 &&
         *CurrentEntriesRead != 0 &&
        wcscmp( ((LPSERVER_INFO_100)(*NewServerList))->sv100_name,
                ((LPSERVER_INFO_100)((*CurrentServerList)+ ((*CurrentEntriesRead)-1) * FixedSize))->sv100_name ) == 0 ) {

        TempServerList += FixedSize;
        NewEntriesRead -= 1;
        NewAllocatedSize -= FixedSize;

        //
        // Early out if there's nothing to return.
        //

        if ( NewEntriesRead == 0 ) {
            return NERR_Success;
        }
    }

    //
    // Allocate a buffer for to return the combined data into.
    //

    LocalCurrentServerList = MIDL_user_allocate( CurrentAllocatedSize +
                                                 NewAllocatedSize );

    if ( LocalCurrentServerList == NULL ) {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    Where = LocalCurrentServerList;


    //
    // Copy the fixed part of the current buffer into the result buffer.
    //

    CurrentFixedSize = (*CurrentEntriesRead) * FixedSize;
    RtlCopyMemory( LocalCurrentServerList, *CurrentServerList, CurrentFixedSize );
    Where += CurrentFixedSize;

    //
    // Copy the fixed part of the appended buffer into the result buffer.
    //

    LocalNewServerList = Where;
    NewFixedSize = NewEntriesRead * FixedSize;

    RtlCopyMemory( LocalNewServerList, TempServerList, NewFixedSize );
    Where += NewFixedSize;

    //
    // Copy the variable portion of current buffer into the result buffer.
    //  Relocate the pointers from the fixed portion to the variable portion.
    //

    RtlCopyMemory( Where,
                   (*CurrentServerList) + CurrentFixedSize,
                   CurrentAllocatedSize - CurrentFixedSize );

    ServerRelocationRoutine( Level,
                             FixedSize,
                             *CurrentEntriesRead,
                             LocalCurrentServerList,
                             (PTRDIFF_T)(Where - ((*CurrentServerList) + CurrentFixedSize)) );

    Where += CurrentAllocatedSize - CurrentFixedSize;

    //
    // Copy the variable portion of appended buffer into the result buffer.
    //  Relocate the pointers from the fixed portion to the variable portion.
    //

    RtlCopyMemory( Where,
                   TempServerList + NewFixedSize,
                   NewAllocatedSize - NewFixedSize );

    ServerRelocationRoutine( Level,
                             FixedSize,
                             NewEntriesRead,
                             LocalNewServerList,
                             (PTRDIFF_T)(Where - (TempServerList + NewFixedSize )));

    Where += NewAllocatedSize - NewFixedSize;
    ASSERT( ((ULONG)(Where - LocalCurrentServerList)) <= CurrentAllocatedSize + NewAllocatedSize );


    //
    // Free the Old buffer passed in.
    //

    MIDL_user_free( *CurrentServerList );
    *CurrentServerList = NULL;

    //
    // Pass out the new buffer.
    //

    *CurrentServerList = LocalCurrentServerList;

    //
    // Adjust the entry counts
    //

    *CurrentEntriesRead += NewEntriesRead;

    if ( *CurrentTotalEntries < NewTotalEntries ) {
        *CurrentTotalEntries = NewTotalEntries;
    }

    return NERR_Success;

}

NET_API_STATUS
RxNetServerEnumWorker (
    IN LPCWSTR UncServerName,
    IN LPCWSTR TransportName,
    IN DWORD Level,
    OUT LPBYTE *BufPtr,
    IN DWORD PrefMaxSize,
    OUT LPDWORD EntriesRead,
    OUT LPDWORD TotalEntries,
    IN DWORD ServerType,
    IN LPCWSTR Domain OPTIONAL,
    IN LPCWSTR FirstNameToReturn OPTIONAL,
    IN BOOLEAN InternalContinuation
    )

/*++

Routine Description:

    RxNetServerEnumWorker performs a single RXACT-style API call to a specified server.
    It automatically determines whether to use the Enum2 (old) or Enum3 (new) RXACT API.
    It automatically determines whether to use a null session or an authenticated session.

    Since Enum2 is not resumable and is the only level implemented on some servers,
    this function ignores PrefMaxSize when using that level and returns ALL of the
    information available from Enum2.

    Since this routine was originally designed for Enum2 (with the above restriction), we
    always return the maximum available Enum3 also.

Arguments:

    (Same as NetServerEnum, except UncServerName must not be null, and
    must not refer to the local computer.)

    FirstNameToReturn: Must be uppercase

        Passed name must be the canonical form of the name.

    InternalContinuation: TRUE if the caller has previously called RxNetServerEnumWorker
        to return all the possible entries using Enum2. This flag is used to prevent
        an automatic fallback to using Enum2.

Return Value:

    (Same as NetServerEnum.)

--*/


{
    DWORD EntryCount;                   // entries (old & new: same).
    DWORD NewFixedSize;
    DWORD NewMaxSize;
    DWORD NewEntryStringSize;
    LPDESC OldDataDesc16;
    LPDESC OldDataDesc32;
    LPDESC OldDataDescSmb;
    DWORD OldEntriesRead;
    DWORD OldFixedSize;
    LPVOID OldInfoArray = NULL;
    DWORD OldInfoArraySize;
    DWORD OldLevel;
    DWORD OldMaxInfoSize;
    DWORD OldTotalAvail;
    NET_API_STATUS Status;              // Status of this actual API.
    NET_API_STATUS TempStatus;          // Short-term status of random stuff.
    BOOL TryNullSession = TRUE;         // Try null session (OK for Winball).
    BOOL TryEnum3;                      // Use NetServerEnum3 to remote server

    LPVOID OldInfoEntry = OldInfoArray;
    LPVOID NewInfoArray = NULL;
    DWORD NewInfoArraySize;
    LPVOID NewInfoEntry;
    LPVOID NewStringArea;

    // Make sure caller didn't get confused.
    NetpAssert(UncServerName != NULL);
    if (BufPtr == NULL) {
        return (ERROR_INVALID_PARAMETER);
    }

    // Level for enum is a subset of all possible server info levels, so
    // we have to check that here.
    if ( (Level != 100) && (Level != 101) ) {
        Status = ERROR_INVALID_LEVEL;
        goto Cleanup;
    }

    Status = RxGetServerInfoLevelEquivalent(
            Level,                      // from level
            TRUE,                       // from native
            TRUE,                       // to native
            & OldLevel,                 // output level
            & OldDataDesc16,
            & OldDataDesc32,
            & OldDataDescSmb,
            & NewMaxSize,               // "from" max length
            & NewFixedSize,             // "from" fixed length
            & NewEntryStringSize,       // "from" string length
            & OldMaxInfoSize,           // "to" max length
            & OldFixedSize,             // "to" fixed length
            NULL,                       // don't need "to" string length
            NULL);               // don't need to know if this is incomplete
    if (Status != NO_ERROR) {
        NetpAssert(Status != ERROR_INVALID_LEVEL);  // Already checked subset!
        goto Cleanup;
    }

    //
    // Because downlevel servers don't support resume handles, and we don't
    // have a way to say "close this resume handle" even if we wanted to
    // emulate them here, we have to do everthing in one shot.  So, the first
    // time around, we'll try using the caller's prefered maximum, but we
    // will enlarge that until we can get everything in one buffer.
    //

    //
    // Some downlevel servers (Sparta/WinBALL) don't like it if we ask for
    // 64K of data at a time, so we limit our initial request to 16K or so
    // and increase it if the actual data amount is larger than 16K.
    //

    // First time: try at most a reasonable amount (16K or so's worth),
    // but at least enough for one entire entry.

    NetpAdjustPreferedMaximum (
            // caller's request (for "new" strucs):
            (PrefMaxSize > INITIAL_MAX_SIZE ? INITIAL_MAX_SIZE : PrefMaxSize),

            NewMaxSize,                 // byte count per array element
            OVERHEAD,                   // zero bytes overhead at end of array
            NULL,                       // we'll compute byte counts ourselves.
            & EntryCount);              // num of entries we can get.

    NetpAssert( EntryCount > 0 );       // Code below assumes as least 1 entry.

    //
    // If a FirstNameToReturn was passed in,
    //  use the new NetServerEnum3 API.
    //
    // The assumption is that this routine will typically be called with a FirstNameToReturn
    // only if the NetServerEnum2 list is exhausted.  There's certainly no requirement
    // that's true.  So, below we revert to NetServerEnum2 if NetServerEnum3 isn't supported.
    //
    // On the other hand, we always use NetServerEnum2 to pick up the first part of the list
    // since it's supported by all servers.
    //

    TryEnum3 = (FirstNameToReturn != NULL  && *FirstNameToReturn != L'\0' );

    //
    // Loop until we have enough memory or we die for some other reason.
    // Also loop trying null session first (for speedy Winball access), then
    // non-null session (required by Lanman).
    //
    do {

        //
        // Figure out how much memory we need.
        //
        OldInfoArraySize = (EntryCount * OldMaxInfoSize) + OVERHEAD;

        //
        // adjust the size to the maximum amount a down-level server
        // can handle
        //

        if (OldInfoArraySize > MAX_TRANSACT_RET_DATA_SIZE) {
            OldInfoArraySize = MAX_TRANSACT_RET_DATA_SIZE;
        }


TryTheApi:

        //
        // Remote the API.
        // We'll let RxRemoteApi allocate the old info array for us.
        //
        Status = RxRemoteApi(
                TryEnum3 ? API_NetServerEnum3 : API_NetServerEnum2 , // api number
                (LPWSTR)UncServerName,              // \\servername
                TryEnum3 ? REMSmb_NetServerEnum3_P : REMSmb_NetServerEnum2_P,    // parm desc (SMB version)
                OldDataDesc16,
                OldDataDesc32,
                OldDataDescSmb,
                NULL,                       // no aux desc 16
                NULL,                       // no aux desc 32
                NULL,                       // no aux desc SMB
                (TryNullSession ? NO_PERMISSION_REQUIRED : 0) |
                ALLOCATE_RESPONSE |
                USE_SPECIFIC_TRANSPORT,     // Next param is Xport name.
                TransportName,
                // rest of API's arguments in LM 2.x format:
                OldLevel,                   // sLevel: info level (old)
                & OldInfoArray,             // pbBuffer: old info lvl array
                TryEnum3 ? MAX_TRANSACT_RET_DATA_SIZE : OldInfoArraySize, // cbBuffer: old info lvl array len
                & OldEntriesRead,           // pcEntriesRead
                & OldTotalAvail,            // pcTotalAvail
                ServerType,                 // flServerType
                Domain,                     // pszDomain (may be null ptr).
                FirstNameToReturn );        // Used only for NetServerEnum3

        //
        // There are a couple of situations where null session might not
        // have worked, and where it is worth retrying with non-null session.
        //

        if (TryNullSession) {

            //
            // Null session wouldn't have worked to LanMan, so try again if it
            // failed.  (Winball would succeed on null session.)
            //

            if (Status == ERROR_ACCESS_DENIED) {
                TryNullSession = FALSE;
                goto TryTheApi;

            //
            // Another situation where null session might have failed...
            // wrong credentials.   (LarryO says that the null session might
            // exhibit this, so let's give it a shot with non-null session.)
            //

            } else if (Status == ERROR_SESSION_CREDENTIAL_CONFLICT) {
                TryNullSession = FALSE;
                goto TryTheApi;
            }
        }

        //
        // If the server doesn't support the new API,
        //  Try the old API.
        //

        if ( TryEnum3 ) {

            //
            // Unfortunately, NT 3.5x servers return ERROR_ACCESS_DENIED for bogus
            //  API Numbers since they have a NULL session check prior to their API
            //  Number range check.
            //

            if ( Status == ERROR_ACCESS_DENIED ||   // NT 3.5x with NULL session checking
                 Status == ERROR_NOT_SUPPORTED ) {  // Windows 95

                //
                // If the original caller is asking for this continuation,
                //  we need to oblige him.
                //  Fall back to Enum2
                //
                if ( !InternalContinuation ) {
                    TryNullSession = TRUE;
                    TryEnum3 = FALSE;
                    goto TryTheApi;

                //
                // Otherwise, we know we've gotten all the data this server has to give.
                //
                //  Just tell the caller there is more data, but we can't return it.
                //

                } else {
                    Status = ERROR_MORE_DATA;
                    *EntriesRead = 0;
                    *TotalEntries = 0;
                    goto Cleanup;
                }
            }

            //
            // Set OldInfoArraySize to the actual value we used above.
            //
            // We couldn't set the variable before this because we wanted to use the
            // original value in the case that we had to fall back to Enum2.
            //
            OldInfoArraySize = MAX_TRANSACT_RET_DATA_SIZE;
        }

		// If there is still an error and it is ERROR_CONNECTION_ACTIVE,
		// try the call with any transport, instead of specifying the transport.
		// We are needing to do this because of a widely seen scenario where
		// there is an existing SMB connection with an outstanding exchange
		// and so the call fails over that transport
		//
		if ( Status == ERROR_CONNECTION_ACTIVE ) {
			Status = RxRemoteApi(
					TryEnum3 ? API_NetServerEnum3 : API_NetServerEnum2 , // api number
					(LPWSTR)UncServerName,              // \\servername
					TryEnum3 ? REMSmb_NetServerEnum3_P : REMSmb_NetServerEnum2_P,    // parm desc (SMB version)
					OldDataDesc16,
					OldDataDesc32,
					OldDataDescSmb,
					NULL,                       // no aux desc 16
					NULL,                       // no aux desc 32
					NULL,                       // no aux desc SMB
					(TryNullSession ? NO_PERMISSION_REQUIRED : 0) |
					ALLOCATE_RESPONSE,
					// rest of API's arguments in LM 2.x format:
					OldLevel,                   // sLevel: info level (old)
					& OldInfoArray,             // pbBuffer: old info lvl array
					TryEnum3 ? MAX_TRANSACT_RET_DATA_SIZE : OldInfoArraySize, // cbBuffer: old info lvl array len
					& OldEntriesRead,           // pcEntriesRead
					& OldTotalAvail,            // pcTotalAvail
					ServerType,                 // flServerType
					Domain,                     // pszDomain (may be null ptr).
					FirstNameToReturn );        // Used only for NetServerEnum3
		}


        //
        // If we still have an error at this point,
        //  return it to the caller.
        //

        if ( Status != NERR_Success && Status != ERROR_MORE_DATA ) {
            goto Cleanup;
        }


        if ((OldEntriesRead == EntryCount) && (Status==ERROR_MORE_DATA) ) {
            // Bug in loop, or lower level code, or remote system?
            NetpKdPrint(( PREFIX_NETAPI
                    "RxNetServerEnum: **WARNING** Got same sizes twice in "
                    "a row; returning internal error.\n" ));
            Status = NERR_InternalError;
            goto Cleanup;
        }

        EntryCount = OldEntriesRead;
        *EntriesRead = EntryCount;
        *TotalEntries = OldTotalAvail;

        //
        // If the server returned ERROR_MORE_DATA, free the buffer and try
        // again.  (Actually, if we already tried 64K, then forget it.)
        //

        NetpAssert( OldInfoArraySize <= MAX_TRANSACT_RET_DATA_SIZE );
        if (Status != ERROR_MORE_DATA) {
            break;
        } else if (OldInfoArraySize == MAX_TRANSACT_RET_DATA_SIZE ) {
            // Let the calling code handle this problem.
            break;
        } else if (OldEntriesRead == 0) {
            // We ran into WFW bug (always says ERROR_MORE_DATA, but 0 read).
            NetpKdPrint(( PREFIX_NETAPI
                    "RxNetServerEnum: Downlevel returns 0 entries and says "
                    "ERROR_MORE_DATA!  Returning NERR_InternalError.\n" ));
            Status = NERR_InternalError;
            goto Cleanup;
        }

        //
        // Various versions of Windows For Workgroups (WFW) get entry count,
        // total available, and whether or not an array is returned, confused.
        // Attempt to protect ourselves from that...
        //

        if (EntryCount >= OldTotalAvail) {
            NetpKdPrint(( PREFIX_NETAPI
                    "RxNetServerEnum: Downlevel says ERROR_MORE_DATA but "
                    "entry count (" FORMAT_DWORD ") >=  total ("
                    FORMAT_DWORD ").\n", EntryCount, OldTotalAvail ));

            *EntriesRead = EntryCount;
            *TotalEntries = EntryCount;
            Status = NO_ERROR;
            break;
        }
        NetpAssert( EntryCount < OldTotalAvail );

        //
        // Free array, as it is too small anyway.
        //

        (void) NetApiBufferFree(OldInfoArray);
        OldInfoArray = NULL;


        //
        // Try again, resizing array to total.
        //

        EntryCount = OldTotalAvail;

    } while (Status == ERROR_MORE_DATA);

    ASSERT( Status == NERR_Success || Status == ERROR_MORE_DATA );

    //
    // Some versions of Windows For Workgroups (WFW) lie about entries read,
    // total available, and what they actually return.  If we didn't get an
    // array, then the counts are useless.
    //
    if (OldInfoArray == NULL) {
        *EntriesRead = 0;
        *TotalEntries = 0;
        goto Cleanup;
    }

    if (*EntriesRead == 0) {
        goto Cleanup;
    }


    //
    // Convert array of structures from old info level to new.
    //
    // Skip any returned entries that are before the ones we want.
    //

    OldInfoEntry = OldInfoArray;

    while (EntryCount > 0) {
        IF_DEBUG(SERVER) {
            NetpKdPrint(( PREFIX_NETAPI "RxNetServerEnum: " FORMAT_DWORD
                    " entries left.\n", EntryCount ));
        }

        //
        // Break out of loop if we need to return this entry.
        //

        if ( wcscmp( FirstNameToReturn, ((LPSERVER_INFO_0)OldInfoEntry)->sv0_name) <= 0 ) {
            break;
        }

        *EntriesRead -= 1;
        *TotalEntries -= 1;
        OldInfoEntry = NetpPointerPlusSomeBytes(
                OldInfoEntry, OldFixedSize);
        --EntryCount;
    }

    //
    // If there were no entries we actually wanted,
    //  indicate so.
    //

    if ( *EntriesRead == 0 ) {
        goto Cleanup;
    }

    //
    // Compute the largest possible size of buffer we'll return.
    //
    // It is never larger than the number of entries available times the largest
    //  possible structure size.
    //
    // It is never larger than the number of entries available times the fixed structure
    // size PLUS the maximum possible text returned from the remote server. For the
    // latter case, we assume that every byte the remote server returned us is an OEM
    // character that we translate to UNICODE.
    //
    // The second limit prevents us from allocating mondo large structures
    // when a large number of entries with short strings are returned.

    NewInfoArraySize = min(
        EntryCount * NewMaxSize,
        (EntryCount * NewFixedSize) + (OldInfoArraySize * sizeof(WCHAR))) + OVERHEAD;


    //
    // Alloc memory for new info level arrays.
    //

    TempStatus = NetApiBufferAllocate( NewInfoArraySize, & NewInfoArray );
    if (TempStatus != NO_ERROR) {
        Status = TempStatus;
        goto Cleanup;
    }
    NewStringArea = NetpPointerPlusSomeBytes(NewInfoArray,NewInfoArraySize);

    NewInfoEntry = NewInfoArray;
    while (EntryCount > 0) {
        IF_DEBUG(SERVER) {
            NetpKdPrint(( PREFIX_NETAPI "RxNetServerEnum: " FORMAT_DWORD
                    " entries left.\n", EntryCount ));
        }

        TempStatus = NetpConvertServerInfo (
                OldLevel,           // from level
                OldInfoEntry,       // from info (fixed part)
                TRUE,               // from native format
                Level,              // to level
                NewInfoEntry,       // to info (fixed part)
                NewFixedSize,
                NewEntryStringSize,
                TRUE,               // to native format
                (LPTSTR *)&NewStringArea);  // to string area (ptr updated)

        if (TempStatus != NO_ERROR) {
            Status = TempStatus;

            if (NewInfoArray){
                // free NewInfoArray since allocated & returning error rather then buffer.
                (void) NetApiBufferFree(NewInfoArray);
            }
            goto Cleanup;
        }

        NewInfoEntry = NetpPointerPlusSomeBytes( NewInfoEntry, NewFixedSize);
        OldInfoEntry = NetpPointerPlusSomeBytes( OldInfoEntry, OldFixedSize);
        --EntryCount;
    }

    *BufPtr = NewInfoArray;


    //
    // Free locally used resources and exit.
    //

Cleanup:
    //
    // Reset Output parameters on error

    if ( Status != NERR_Success && Status != ERROR_MORE_DATA ) {
        *EntriesRead = 0;
        *TotalEntries = 0;
    }

    if (*EntriesRead == 0) {
        *BufPtr = NULL;
    }

    // Free old array
    if (OldInfoArray != NULL) {
        (void) NetApiBufferFree(OldInfoArray);
    }

    return (Status);

} // RxNetServerEnumWorker


NET_API_STATUS
RxNetServerEnum (
    IN LPCWSTR UncServerName,
    IN LPCWSTR TransportName,
    IN DWORD Level,
    OUT LPBYTE *BufPtr,
    IN DWORD PrefMaxSize,
    OUT LPDWORD EntriesRead,
    OUT LPDWORD TotalEntries,
    IN DWORD ServerType,
    IN LPCWSTR Domain OPTIONAL,
    IN LPCWSTR FirstNameToReturn OPTIONAL
    )

/*++

Routine Description:

    RxNetServerEnumIntoTree calls RxNetServerEnumWorker repeatedly until it returns
    all entries or until at least PrefMaxSize data has been returned.

    One of the callers is EnumServersForTransport (on behalf of NetServerEnumEx).  It
    depends on the fact that we return at least PrefMaxSize entries for this transport.
    Otherwise, NetServerEnumEx might return a last entry from a different transport even
    though there are entries on this transport with names that are less than lexically
    smaller names.  Such entries on this transport would never be returned.

Arguments:

    (Same as NetServerEnum, except UncServerName must not be null, and
    must not refer to the local computer.)

    FirstNameToReturn: Must be uppercase

        Passed name must be the canonical form of the name.

Return Value:

    (Same as NetServerEnum.)

--*/


{
    NET_API_STATUS NetStatus;
    NET_API_STATUS TempNetStatus;
    ULONG BytesGatheredSoFar = 0;
    ULONG BytesDuplicated = 0;
    LPBYTE LocalBuffer = NULL;
    DWORD LocalEntriesRead;
    DWORD LocalTotalEntries;
    WCHAR LocalFirstNameToReturn[CNLEN+1];
    BOOLEAN InternalContinuation = FALSE;

    // Variable to build the returned information into.
    LPBYTE CurrentServerList = NULL;
    DWORD CurrentEntriesRead = 0;
    DWORD CurrentTotalEntries = 0;

    DWORD MaxSize;
    DWORD FixedSize;

    //
    // Initialization.
    //

    *TotalEntries = 0;
    *EntriesRead = 0;

    if ( FirstNameToReturn == NULL) {
        LocalFirstNameToReturn[0] = L'\0';
    } else {
        wcsncpy( LocalFirstNameToReturn, FirstNameToReturn, CNLEN+1 );
        LocalFirstNameToReturn[CNLEN] = L'\0';
    }

    //
    // Get information about the array returned from RxNetServerEnumWorker.
    //

    NetStatus = RxGetServerInfoLevelEquivalent(
            Level,                      // from level
            TRUE,                       // from native
            TRUE,                       // to native
            NULL,
            NULL,
            NULL,
            NULL,
            &MaxSize,                   // "from" max length
            &FixedSize,                 // "from" fixed length
            NULL,                       // "from" string length
            NULL,                       // "to" max length
            NULL,                       // "to" fixed length
            NULL,                       // don't need "to" string length
            NULL);               // don't need to know if this is incomplete

    if (NetStatus != NO_ERROR) {
        goto Cleanup;
    }

    //
    // Loop calling the server getting more entries on each call.
    //

    for (;;) {

        //
        // Get the next chunk of data from the server.
        //  Return an extra entry to account for FirstNameToReturn being returned on the
        //  previous call.
        //

        NetStatus = RxNetServerEnumWorker(
                            UncServerName,
                            TransportName,
                            Level,
                            &LocalBuffer,
                            PrefMaxSize - BytesGatheredSoFar + BytesDuplicated,
                            &LocalEntriesRead,
                            &LocalTotalEntries,
                            ServerType,
                            Domain,
                            LocalFirstNameToReturn,
                            InternalContinuation );

        if ( NetStatus != NERR_Success && NetStatus != ERROR_MORE_DATA ) {
            goto Cleanup;
        }

        //
        // If we have as many entries as the server has to give,
        //  tell our caller.
        //
        // This is the case where the server doesn't support the ENUM3 protocol.
        //

        if ( NetStatus == ERROR_MORE_DATA && LocalEntriesRead == 0 ) {
            goto Cleanup;
        }

        //
        // If there is more data available,
        //  and we only want a limited amount of data.
        // Compute the amount of data returned on this call.
        //
        // Determine the number of bytes to ask for on the next call.
        //
        // If our caller asked for all entries,
        //  simply ask for all entries from the server.
        //

        if ( NetStatus == ERROR_MORE_DATA && PrefMaxSize != 0xFFFFFFFF ) {
            DWORD i;
            LPBYTE Current = LocalBuffer;


            //
            // Loop through the entries returned on the current call
            //  computing the size returned.
            //

            for ( i=0; i<LocalEntriesRead; i++) {

                //
                // Add the size of the current entry.
                //

                BytesGatheredSoFar += FixedSize;

                if ( ((LPSERVER_INFO_100)Current)->sv100_name != NULL ) {
                    BytesGatheredSoFar = (wcslen(((LPSERVER_INFO_100)Current)->sv100_name) + 1) * sizeof(WCHAR);
                }

                if ( Level == 101 &&
                    ((LPSERVER_INFO_101)Current)->sv101_comment != NULL ) {
                    BytesGatheredSoFar += (wcslen(((LPSERVER_INFO_101)Current)->sv101_comment) + 1) * sizeof(WCHAR);
                }

                //
                // Move to the next entry.
                //

                Current += FixedSize;
            }


            //
            // Account for the fact that the first entry returned is identical to the
            //  last entry returned on the previous call.

            BytesDuplicated = MaxSize;

        }

        //
        // Append the new server list to the one we've been collecting
        //

        TempNetStatus = AppendServerList(
                            &CurrentServerList,
                            &CurrentEntriesRead,
                            &CurrentTotalEntries,
                            Level,
                            FixedSize,
                            &LocalBuffer,
                            LocalEntriesRead,
                            LocalTotalEntries );

        if ( TempNetStatus != NERR_Success ) {
            NetStatus = TempNetStatus;
            goto Cleanup;
        }

        //
        // Free the buffer if AppendServerList didn't already.
        //
        //  Now free up the remaining parts of the list.
        //

        if (LocalBuffer != NULL) {
            NetApiBufferFree(LocalBuffer);
            LocalBuffer = NULL;
        }


        //
        // If we've returned everything from the server,
        //  simply return now.
        //

        if ( NetStatus == NERR_Success ) {
            goto Cleanup;
        }


        //
        // Handle calling the server again to get the next several entries.
        //

        //
        // Pass the name of the next server to return
        //

        wcscpy( LocalFirstNameToReturn,
                ((LPSERVER_INFO_100)(CurrentServerList + (CurrentEntriesRead-1) * FixedSize))->sv100_name );
        InternalContinuation = TRUE;

        //
        // If we've already gathered all the bytes we need,
        //  we're done.
        //
        // If the worker routine returned what we needed, it'll be a few bytes under
        // PrefMaxSize. So stop here if we're within one element of our goal.
        //

        if ( BytesGatheredSoFar + BytesDuplicated >= PrefMaxSize ) {
            NetStatus = ERROR_MORE_DATA;
            goto Cleanup;
        }

    }

Cleanup:

    //
    // Return the collected data to the caller.
    //

    if ( NetStatus == NERR_Success || NetStatus == ERROR_MORE_DATA ) {


        //
        // Return the entries.
        //

        *BufPtr = CurrentServerList;
        CurrentServerList = NULL;

        *EntriesRead = CurrentEntriesRead;

        //
        // Adjust TotalEntries returned for reality.
        //

        if ( NetStatus == NERR_Success ) {
            *TotalEntries = *EntriesRead;
        } else {
            *TotalEntries = max( CurrentTotalEntries, CurrentEntriesRead + 1 );
        }

    }

    //
    //  Free locally used resources
    //

    if (LocalBuffer != NULL) {
        NetApiBufferFree(LocalBuffer);
        LocalBuffer = NULL;
    }

    if ( CurrentServerList != NULL ) {
        NetApiBufferFree( CurrentServerList );
    }

    return NetStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\rpcxlate\rxapi\srvequiv.c ===
/*++

Copyright (c) 1991-1992  Microsoft Corporation

Module Name:

    SrvEquiv.c

Abstract:

    This file contains support code to convert between old and new server
    info levels.

Author:

    John Rogers (JohnRo) 02-May-1991

Environment:

    Portable to any flat, 32-bit environment.  (Uses Win32 typedefs.)
    Requires ANSI C extensions: slash-slash comments, long external names.

Revision History:

    02-May-1991 JohnRo
        Created.
    09-May-1991 JohnRo
        Made some LINT-suggested changes.
    28-May-1991 JohnRo
        Added incomplete output parm to RxGetServerInfoLevelEquivalent.
    14-Jun-1991 JohnRo
        Correct IncompleteOutput values.
    17-Jul-1991 JohnRo
        Extracted RxpDebug.h from Rxp.h.
    21-Nov-1991 JohnRo
        Removed NT dependencies to reduce recompiles.
    26-Aug-1992 JohnRo
        RAID 4463: NetServerGetInfo(level 3) to downlevel: assert in convert.c.
        Use PREFIX_ equates.

--*/


// These must be included first:

#include <windef.h>             // IN, LPVOID, etc.
#include <lmcons.h>             // NET_API_STATUS.

// These may be included in any order:

#include <dlserver.h>           // Old info levels, MAX_ stuff, my prototype.
#include <lmerr.h>              // NERR_ and ERROR_ equates.
#include <lmserver.h>           // New info level structures.
#include <netdebug.h>           // NetpKdPrint(()), FORMAT_ equates, etc.
#include <netlib.h>             // NetpPointerPlusSomeBytes(), etc.
#include <prefix.h>     // PREFIX_ equates.
#include <rap.h>                // LPDESC, etc.
#include <remdef.h>             // REM16_ REM32_, and REMSmb_ equates.
#include <rxpdebug.h>           // IF_DEBUG().
#include <rxserver.h>           // My prototype.


NET_API_STATUS
RxGetServerInfoLevelEquivalent (
    IN DWORD FromLevel,
    IN BOOL FromNative,
    IN BOOL ToNative,
    OUT LPDWORD ToLevel,
    OUT LPDESC * ToDataDesc16 OPTIONAL,
    OUT LPDESC * ToDataDesc32 OPTIONAL,
    OUT LPDESC * ToDataDescSmb OPTIONAL,
    OUT LPDWORD FromMaxSize OPTIONAL,
    OUT LPDWORD FromFixedSize OPTIONAL,
    OUT LPDWORD FromStringSize OPTIONAL,
    OUT LPDWORD ToMaxSize OPTIONAL,
    OUT LPDWORD ToFixedSize OPTIONAL,
    OUT LPDWORD ToStringSize OPTIONAL,
    OUT LPBOOL IncompleteOutput OPTIONAL  // incomplete (except platform ID)
    )

/*++

Routine Description:
    

Arguments:


Return Value:

    NET_API_STATUS - NERR_Success or ERROR_INVALID_LEVEL.

--*/

{
    // LPDESC FromDataDesc;                // Desc for data we've got.
    // LPBYTE ToStringArea;

    NetpAssert(FromNative == TRUE);
    UNREFERENCED_PARAMETER(FromNative);
    NetpAssert(ToNative == TRUE);
    UNREFERENCED_PARAMETER(ToNative);

    IF_DEBUG(SERVER) {
        NetpKdPrint(( PREFIX_NETAPI
                "RxGetServerInfoLevelEquivalent: starting, "
                "FromLevel=" FORMAT_DWORD ".\n", FromLevel));
    }

    //
    // Decide what to do based on the info level.  Note that normally we'd
    // be using REM16_, REM32_, and REMSmb_ descriptors here.  However,
    // the REM16_ and REM32_ ones have been modified to reflect a nonexistant
    // field (svX_platform_id).  This messes up the automatic conversions
    // done by RxRemoteApi.  So, we use "downlevel" descriptors (DL_REM16_
    // and DL_REM32_) which are defined in DlServer.h.
    //
    switch (FromLevel) {

    case 0 :
        // 0 is equivalent to level 100 (minus the platform ID).
        NetpSetOptionalArg(ToLevel,          100);
        NetpSetOptionalArg(ToDataDesc16,     NULL);
        NetpSetOptionalArg(ToDataDesc32,     REM32_server_info_100);
        NetpSetOptionalArg(ToDataDescSmb,    NULL);
        NetpSetOptionalArg(FromMaxSize,      MAX_LEVEL_0_TOTAL_SIZE);
        NetpSetOptionalArg(FromFixedSize,    sizeof(SERVER_INFO_0));
        NetpSetOptionalArg(FromStringSize,   MAX_LEVEL_0_STRING_SIZE);
        NetpSetOptionalArg(FromMaxSize,      MAX_LEVEL_0_TOTAL_SIZE);
        NetpSetOptionalArg(ToMaxSize,        MAX_LEVEL_100_TOTAL_SIZE);
        NetpSetOptionalArg(ToFixedSize,      sizeof(SERVER_INFO_100));
        NetpSetOptionalArg(ToStringSize,     MAX_LEVEL_100_STRING_SIZE);
        NetpSetOptionalArg(IncompleteOutput, FALSE);  // all but platform ID

        // FromDataDesc = REM32_server_info_0;
        // ToDataDesc = REM32_server_info_100;
        break;

    case 1 :
        // 1 is equivalent to level 101 (minus the platform ID).
        NetpSetOptionalArg(ToLevel,          101);
        NetpSetOptionalArg(ToDataDesc16,     NULL);
        NetpSetOptionalArg(ToDataDesc32,     REM32_server_info_101);
        NetpSetOptionalArg(ToDataDescSmb,    NULL);
        NetpSetOptionalArg(FromMaxSize,      MAX_LEVEL_1_TOTAL_SIZE);
        NetpSetOptionalArg(FromFixedSize,    sizeof(SERVER_INFO_1));
        NetpSetOptionalArg(FromStringSize,   MAX_LEVEL_1_STRING_SIZE);
        NetpSetOptionalArg(ToMaxSize,        MAX_LEVEL_101_TOTAL_SIZE);
        NetpSetOptionalArg(ToFixedSize,      sizeof(SERVER_INFO_101));
        NetpSetOptionalArg(ToStringSize,     MAX_LEVEL_101_STRING_SIZE);
        NetpSetOptionalArg(IncompleteOutput, FALSE);  // all but platform ID
        break;

    case 100 :
        // 100 is superset of level 0.
        NetpSetOptionalArg(ToLevel,          0);
        NetpSetOptionalArg(ToDataDesc16,     DL_REM16_server_info_0);
        NetpSetOptionalArg(ToDataDesc32,     DL_REM32_server_info_0);
        NetpSetOptionalArg(ToDataDescSmb,    REMSmb_server_info_0);
        NetpSetOptionalArg(FromMaxSize,      MAX_LEVEL_100_TOTAL_SIZE);
        NetpSetOptionalArg(FromFixedSize,    sizeof(SERVER_INFO_100));
        NetpSetOptionalArg(FromStringSize,   MAX_LEVEL_100_STRING_SIZE);
        NetpSetOptionalArg(ToMaxSize,        MAX_LEVEL_0_TOTAL_SIZE);
        NetpSetOptionalArg(ToFixedSize,      sizeof(SERVER_INFO_0));
        NetpSetOptionalArg(ToStringSize,     MAX_LEVEL_0_STRING_SIZE);
        NetpSetOptionalArg(IncompleteOutput, FALSE);

        // FromDataDesc = REM32_server_info_100;
        // ToDataDesc = REM32_server_info_0;
        break;

    case 101 :
        // 101 is superset of 1.
        NetpSetOptionalArg(ToLevel,          1);
        NetpSetOptionalArg(ToDataDesc16,     DL_REM16_server_info_1);
        NetpSetOptionalArg(ToDataDesc32,     DL_REM32_server_info_1);
        NetpSetOptionalArg(ToDataDescSmb,    REMSmb_server_info_1);
        NetpSetOptionalArg(FromMaxSize,      MAX_LEVEL_101_TOTAL_SIZE);
        NetpSetOptionalArg(FromFixedSize,    sizeof(SERVER_INFO_101));
        NetpSetOptionalArg(FromStringSize,   MAX_LEVEL_101_STRING_SIZE);
        NetpSetOptionalArg(ToMaxSize,        MAX_LEVEL_1_TOTAL_SIZE);
        NetpSetOptionalArg(ToFixedSize,      sizeof(SERVER_INFO_1));
        NetpSetOptionalArg(ToStringSize,     MAX_LEVEL_1_STRING_SIZE);
        NetpSetOptionalArg(IncompleteOutput, FALSE);

        // FromDataDesc = REM32_server_info_101;
        // ToDataDesc = REM32_server_info_1;
        break;

    case 102 :
        // Level 102 is a subset of old level 2.
        NetpSetOptionalArg(ToLevel,          2);
        NetpSetOptionalArg(ToDataDesc16,     DL_REM16_server_info_2);
        NetpSetOptionalArg(ToDataDesc32,     DL_REM32_server_info_2);
        NetpSetOptionalArg(ToDataDescSmb,    REMSmb_server_info_2);
        NetpSetOptionalArg(FromMaxSize,      MAX_LEVEL_102_TOTAL_SIZE);
        NetpSetOptionalArg(FromFixedSize,    sizeof(SERVER_INFO_102));
        NetpSetOptionalArg(FromStringSize,   MAX_LEVEL_102_STRING_SIZE);
        NetpSetOptionalArg(ToMaxSize,        MAX_LEVEL_2_TOTAL_SIZE);
        NetpSetOptionalArg(ToFixedSize,      sizeof(SERVER_INFO_2));
        NetpSetOptionalArg(ToStringSize,     MAX_LEVEL_2_STRING_SIZE);
        NetpSetOptionalArg(IncompleteOutput, TRUE);

        // FromDataDesc = REM32_server_info_102;
        // ToDataDesc = REM32_server_info_2;
        break;

    case 402 :
        // Level 402 is a subset of old level 2.
        NetpSetOptionalArg(ToLevel,          2);
        NetpSetOptionalArg(ToDataDesc16,     DL_REM16_server_info_2);
        NetpSetOptionalArg(ToDataDesc32,     DL_REM32_server_info_2);
        NetpSetOptionalArg(ToDataDescSmb,    REMSmb_server_info_2);
        NetpSetOptionalArg(FromMaxSize,      MAX_LEVEL_402_TOTAL_SIZE);
        NetpSetOptionalArg(FromFixedSize,    sizeof(SERVER_INFO_402));
        NetpSetOptionalArg(FromStringSize,   MAX_LEVEL_402_STRING_SIZE);
        NetpSetOptionalArg(ToMaxSize,        MAX_LEVEL_2_TOTAL_SIZE);
        NetpSetOptionalArg(ToFixedSize,      sizeof(SERVER_INFO_2));
        NetpSetOptionalArg(ToStringSize,     MAX_LEVEL_2_STRING_SIZE);
        NetpSetOptionalArg(IncompleteOutput, TRUE);

        // FromDataDesc = REM32_server_info_402;
        // ToDataDesc = REM32_server_info_2;
        break;

    case 403 :
        // Level 403 is a subset of old level 3.
        NetpSetOptionalArg(ToLevel,          3);
        NetpSetOptionalArg(ToDataDesc16,     DL_REM16_server_info_3);
        NetpSetOptionalArg(ToDataDesc32,     DL_REM32_server_info_3);
        NetpSetOptionalArg(ToDataDescSmb,    REMSmb_server_info_3);
        NetpSetOptionalArg(FromMaxSize,      MAX_LEVEL_403_TOTAL_SIZE);
        NetpSetOptionalArg(FromFixedSize,    sizeof(SERVER_INFO_403));
        NetpSetOptionalArg(FromStringSize,   MAX_LEVEL_403_STRING_SIZE);
        NetpSetOptionalArg(ToMaxSize,        MAX_LEVEL_3_TOTAL_SIZE);
        NetpSetOptionalArg(ToFixedSize,      sizeof(SERVER_INFO_3));
        NetpSetOptionalArg(ToStringSize,     MAX_LEVEL_3_STRING_SIZE);
        NetpSetOptionalArg(IncompleteOutput, TRUE);

        // FromDataDesc = REM32_server_info_403;
        // ToDataDesc = REM32_server_info_3;
        break;

    default :
        return (ERROR_INVALID_LEVEL);
    }

    IF_DEBUG(SERVER) {
        NetpKdPrint(( PREFIX_NETAPI
                "RxGetServerInfoLevelEquivalent: returning:\n"));
        if ( ToLevel != NULL ) {
            NetpKdPrint(("  ToLevel=" FORMAT_DWORD "\n", *ToLevel));
        }
        if (ToDataDesc16 != NULL) {
            NetpKdPrint(("  ToDataDesc16=" FORMAT_LPDESC "\n", *ToDataDesc16));
        }
        if (ToDataDesc32 != NULL) {
            NetpKdPrint(("  ToDataDesc32=" FORMAT_LPDESC "\n", *ToDataDesc32));
        }
        if (ToDataDescSmb != NULL) {
            NetpKdPrint(("  ToDataDescSmb=" FORMAT_LPDESC "\n", *ToDataDescSmb));
        }
        if (FromMaxSize != NULL) {
            NetpKdPrint(("  FromMaxSize=" FORMAT_DWORD "\n", *FromMaxSize));
        }
        if (FromFixedSize != NULL) {
            NetpKdPrint(("  FromFixedSize=" FORMAT_DWORD "\n", *FromFixedSize));
        }
        if (FromStringSize != NULL) {
            NetpKdPrint(("  FromStringSize=" FORMAT_DWORD "\n", *FromStringSize));
        }
        if (ToMaxSize != NULL) {
            NetpKdPrint(("  ToMaxSize=" FORMAT_DWORD "\n", *ToMaxSize));
        }
        if (ToFixedSize != NULL) {
            NetpKdPrint(("  ToFixedSize=" FORMAT_DWORD "\n", *ToFixedSize));
        }
        if (ToStringSize != NULL) {
            NetpKdPrint(("  ToStringSize=" FORMAT_DWORD "\n", *ToStringSize));
        }
        if (IncompleteOutput != NULL) {
            if (*IncompleteOutput) {
                NetpKdPrint(("  IncompleteOutput=TRUE.\n" ));
            } else {
                NetpKdPrint(("  IncompleteOutput=FALSE.\n" ));
            }
        }
    }

    return (NERR_Success);

} // RxGetServerInfoLevelEquivalent
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\rpcxlate\rxapi\svcctrl.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    SvcCtrl.c

Abstract:

    This file contains the RpcXlate code to handle the NetServiceControl API.

Author:

    John Rogers (JohnRo) 13-Sep-1991

Environment:

    Portable to any flat, 32-bit environment.  (Uses Win32 typedefs.)
    Requires ANSI C extensions: slash-slash comments, long external names.

Revision History:

    13-Sep-1991 JohnRo
        Created.
    25-Sep-1991 JohnRo
        Fixed bug which caused ERROR_INVALID_PARAMETER (rcv.buf.len trunc'ed).
    07-Oct-1991 JohnRo
        Made changes suggested by PC-LINT.

--*/

// These must be included first:

#include <windef.h>             // IN, DWORD, etc.
#include <lmcons.h>             // DEVLEN, NET_API_STATUS, etc.

// These may be included in any order:

#include <apinums.h>            // API_ equates.
#include <lmerr.h>              // ERROR_ and NERR_ equates.
#include <lmsvc.h>
#include <rxp.h>                // RxpFatalErrorCode().
#include <netdebug.h>           // NetpKdPrint(()), FORMAT_ equates.
#include <rap.h>                // LPDESC.
#include <remdef.h>             // REM16_, REM32_, REMSmb_ equates.
#include <rx.h>                 // RxRemoteApi().
#include <rxsvc.h>              // My prototype(s).
#include <strucinf.h>           // NetpServiceStructureInfo().



NET_API_STATUS
RxNetServiceControl (
    IN LPTSTR UncServerName,
    IN LPTSTR Service,
    IN DWORD OpCode,
    IN DWORD Arg,
    OUT LPBYTE *BufPtr
    )
{
    const DWORD BufSize = 65535;
    LPDESC DataDesc16, DataDesc32, DataDescSmb;
    const DWORD Level = 2;      // Implied by this API.
    LPSERVICE_INFO_2 serviceInfo2;
    NET_API_STATUS Status;

    NetpAssert(UncServerName != NULL);
    NetpAssert(*UncServerName != '\0');

    Status = NetpServiceStructureInfo (
            Level,
            PARMNUM_ALL,        // want entire structure
            TRUE,               // Want native sizes (actually don't care...)
            & DataDesc16,
            & DataDesc32,
            & DataDescSmb,
            NULL,               // don't care about max size
            NULL,               // don't care about fixed size
            NULL);              // don't care about string size
    NetpAssert(Status == NERR_Success);

    Status = RxRemoteApi(
            API_WServiceControl,        // API number
            UncServerName,
            REMSmb_NetServiceControl_P, // parm desc
            DataDesc16,
            DataDesc32,
            DataDescSmb,
            NULL,                       // no aux desc 16
            NULL,                       // no aux desc 32
            NULL,                       // no aux desc SMB
            ALLOCATE_RESPONSE,          // flags: alloc response buffer for us
            // rest of API's arguments, in 32-bit LM2.x format:
            Service,
            OpCode,
            Arg,
            BufPtr,
            BufSize);                  // buffer size (ignored, mostly)

    if ((! RxpFatalErrorCode(Status)) && (Level == 2)) {
        serviceInfo2 = (LPSERVICE_INFO_2)*BufPtr;
        if (serviceInfo2 != NULL) {
            DWORD   installState;

            serviceInfo2->svci2_display_name = serviceInfo2->svci2_name;
            //
            // if INSTALL or UNINSTALL is PENDING, then force the upper
            // bits to 0.  This is to prevent the upper bits of the wait
            // hint from getting accidentally set.  Downlevel should never
            // use more than FF for waithint.
            //
            installState = serviceInfo2->svci2_status & SERVICE_INSTALL_STATE;
            if ((installState == SERVICE_INSTALL_PENDING) ||
                (installState == SERVICE_UNINSTALL_PENDING)) {
                serviceInfo2->svci2_code &= SERVICE_RESRV_MASK;
            }
        }
    }
    return(Status);

} // RxNetServiceControl
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\rpcxlate\rxapi\srvgtinf.c ===
/*++

Copyright (c) 1991-92  Microsoft Corporation

Module Name:

    SrvGtInf.c

Abstract:

    This file contains the RpcXlate code to handle the NetServer APIs
    that can't be handled by simple calls to RxRemoteApi.

Author:

    John Rogers (JohnRo) 02-May-1991

Environment:

    Portable to any flat, 32-bit environment.  (Uses Win32 typedefs.)
    Requires ANSI C extensions: slash-slash comments, long external names.

Revision History:

    02-May-1991 JohnRo
        Created.
    06-May-1991 JohnRo
        Added some assertion checks.
    14-May-1991 JohnRo
        Can't always do assertion on TotalAvail.
    14-May-1991 JohnRo
        Pass 3 aux descriptors to RxRemoteApi.
    26-May-1991 JohnRo
        Added incomplete output parm to RxGetServerInfoLevelEquivalent.
    17-Jul-1991 JohnRo
        Extracted RxpDebug.h from Rxp.h.
    07-Feb-1992 JohnRo
        Use NetApiBufferAllocate() instead of private version.
    15-Apr-1992 JohnRo
        FORMAT_POINTER is obsolete.

--*/


// These must be included first:

#include <windef.h>
#include <lmcons.h>
#include <rap.h>        // LPDESC, etc (needed by rxserver.h).

// These may be included in any order:

#include <apinums.h>
#include <dlserver.h>   // Old info level structures & conv routines.
                        // Also DL_REM_ equates.
#include <lmapibuf.h>   // NetApiBufferAllocate(), NetApiBufferFree().
#include <lmerr.h>      // NERR_ and ERROR_ equates.
#include <lmserver.h>   // Real API prototypes and #defines.
#include <names.h>      // NetpIsComputerNameValid().
#include <netdebug.h>   // NetpKdPrint(()), FORMAT_ equates, etc.
#include <remdef.h>     // REM16_, REM32_, and REMSmb_ equates.
#include <rx.h>         // RxRemoteApi().
#include <rxp.h>        // RxpFatalErrorCode().
#include <rxpdebug.h>   // IF_DEBUG().
#include <rxserver.h>   // My prototype.


NET_API_STATUS
RxNetServerGetInfo (
    IN LPTSTR UncServerName,
    IN DWORD Level,
    OUT LPBYTE *BufPtr
    )

/*++

Routine Description:

    RxNetServerGetInfo performs the same function as NetServerGetInfo,
    except that the server name is known to refer to a downlevel server.

Arguments:

    (Same as NetServerGetInfo, except UncServerName must not be null, and
    must not refer to the local computer.)

Return Value:

    (Same as NetServerGetInfo.)

--*/

{

    LPBYTE NewApiBuffer;                // Buffer to be returned to caller.
    DWORD NewFixedSize;
    DWORD NewStringSize;
    LPBYTE OldApiBuffer;                // Buffer with old info level.
    DWORD OldApiBufferSize;
    LPDESC OldDataDesc16;
    LPDESC OldDataDesc32;               // Desc for 32-bit (old info level).
    LPDESC OldDataDescSmb;
    DWORD OldLevel;                     // old (LanMan 2.x) level equiv to new.
    LPDESC ParmDesc16 = REM16_NetServerGetInfo_P;
    NET_API_STATUS Status;
    DWORD TotalAvail;

    IF_DEBUG(SERVER) {
        NetpKdPrint((
                "RxNetServerGetInfo: starting, server=" FORMAT_LPTSTR
                ", lvl=" FORMAT_DWORD ".\n",
                UncServerName, Level));
    }
    NetpAssert(UncServerName != NULL);
    NetpAssert(NetpIsUncComputerNameValid(UncServerName));

    if (BufPtr == NULL) {
        return (ERROR_INVALID_PARAMETER);
    }

    //
    // Decide what to do based on the info level.  Note that normally we'd
    // be using REM16_, REM32_, and REMSmb_ descriptors here.  However,
    // the REM16_ and REM32_ ones have been modified to reflect a nonexistant
    // field (svX_platform_id).  This messes up the automatic conversions
    // done by RxRemoteApi.  So, we use the original descriptors (REMSmb_)
    // and do our own conversion later.  (RxRemoteApi does byte swapping if
    // necessary, but the rest is up to us.)
    //

    if (! NetpIsNewServerInfoLevel(Level)) {
        IF_DEBUG(SERVER) {
            NetpKdPrint(("RxNetServerGetInfo: "
                    "caller didn't ask for new level.\n"));
        }
        *BufPtr = NULL;
        return (ERROR_INVALID_LEVEL);
    }
    Status = RxGetServerInfoLevelEquivalent (
            Level,               // from level
            TRUE,                // from native
            TRUE,                // to native
            & OldLevel,          // to level
            & OldDataDesc16,     // to data desc 16
            & OldDataDesc32,     // to data desc 32
            & OldDataDescSmb,    // to data desc SMB
            NULL,                // don't need from max size
            & NewFixedSize,      // from fixed size
            & NewStringSize,     // from string size
            & OldApiBufferSize,  // to max size
            NULL,                // don't need to fixed size
            NULL,                // don't need to string size
            NULL);               // don't need to know if this is incomplete
    if (Status == ERROR_INVALID_LEVEL) {
        IF_DEBUG(SERVER) {
            NetpKdPrint(("RxNetServerGetInfo: "
                    "RxGetServerInfoLevelEquivalent says bad level.\n"));
        }
        *BufPtr = NULL;
        return (ERROR_INVALID_LEVEL);
    }
    NetpAssert(Status == NERR_Success);
    NetpAssert(NetpIsOldServerInfoLevel(OldLevel));

    //
    // Ok, we know we're dealing with a valid info level, so allocate the
    // buffer for the get-info struct (for old info level).
    //
    IF_DEBUG(SERVER) {
        NetpKdPrint(("RxNetServerGetInfo: old api buff size (32-bit) is "
                    FORMAT_DWORD "\n", OldApiBufferSize));
    }
    Status = NetApiBufferAllocate( OldApiBufferSize, (LPVOID *)&OldApiBuffer );
    if (Status != NERR_Success) {
        *BufPtr = NULL;
        return (Status);
    }

    //
    // Get old info level data from the other machine.
    //
    IF_DEBUG(SERVER) {
        TotalAvail = 11223344;  // Just some value I can see hasn't changed.
    }
    Status = RxRemoteApi(
                API_WServerGetInfo,         // API number
                UncServerName,              // server name (with \\)
                ParmDesc16,                 // parm desc (16-bit)
                OldDataDesc16,              // data desc (16-bit)
                OldDataDesc32,              // data desc (32-bit)
                OldDataDescSmb,             // data desc (SMB version)
                NULL,                       // no aux desc 16
                NULL,                       // no aux desc 32
                NULL,                       // no aux desc SMB
                FALSE,                      // not a "no perm req" API
                // LanMan 2.x args to NetServerGetInfo, in 32-bit form:
                OldLevel,                   // level (pretend)
                OldApiBuffer,               // ptr to get 32-bit old info
                OldApiBufferSize,           // size of OldApiBuffer
                & TotalAvail);              // total available (set)
    IF_DEBUG(SERVER) {
        NetpKdPrint(("RxNetServerGetInfo(" FORMAT_DWORD
                "): back from RxRemoteApi, status=" FORMAT_API_STATUS
                ", total_avail=" FORMAT_DWORD ".\n",
                Level, Status, TotalAvail));
    }
    if (RxpFatalErrorCode(Status)) {
        (void) NetApiBufferFree(OldApiBuffer);
        *BufPtr = NULL;
        return (Status);
    }

    // We allocated buffer, so we "know" it's large enough:
    NetpAssert(Status != ERROR_MORE_DATA);
    NetpAssert(Status != NERR_BufTooSmall);
    if (Status == NERR_Success) {
        NetpAssert(TotalAvail <= OldApiBufferSize);
    }


    //
    // Now we have to convert old info level stuff to new info level.
    //

    Status = NetApiBufferAllocate(
            NewFixedSize+NewStringSize,
            (LPVOID *)&NewApiBuffer);
    if (Status != NERR_Success) {
        (void) NetApiBufferFree(OldApiBuffer);
        *BufPtr = NULL;
        return (Status);
    }
    IF_DEBUG(SERVER) {
        NetpKdPrint(("RxNetServerGetInfo: alloced new buf at "
                        FORMAT_LPVOID ".\n", (LPVOID) NewApiBuffer));
    }

    Status = NetpConvertServerInfo(
            OldLevel,               // from level
            OldApiBuffer,           // from structure
            TRUE,                   // from native format
            Level,                  // to level
            NewApiBuffer,           // to info
            NewFixedSize,           // to fixed size
            NewStringSize,          // to string size
            TRUE,                   // to native format
            NULL);                  // use default string area
    if (Status != NERR_Success) {
        (void) NetApiBufferFree(OldApiBuffer);
        *BufPtr = NULL;
        return (Status);
    }
    NetpAssert(NewApiBuffer != NULL);

    (void) NetApiBufferFree(OldApiBuffer);

    *BufPtr = NewApiBuffer;
    return (Status);

} // RxNetServerGetInfo
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\rpcxlate\rxapi\srvstinf.c ===
/*++

Copyright (c) 1991-92  Microsoft Corporation

Module Name:

    SrvStInf.c

Abstract:

    This module only contains RxNetServerSetInfo.

Author:

    John Rogers (JohnRo) 05-Jun-1991

Environment:

    Portable to any flat, 32-bit environment.  (Uses Win32 typedefs.)
    Requires ANSI C extensions: slash-slash comments, long external names.

Revision History:

    05-Jun-1991 JohnRo
        Created.
    07-Jun-1991 JohnRo
        PC-LINT found a bug calling RapTotalSize().
    14-Jun-1991 JohnRo
        Call RxRemoteApi (to get old info) instead of RxNetServerGetInfo;
        this will allow incomplete info level conversions to work.
    10-Jul-1991 JohnRo
        Added more parameters to RxpSetField.
    17-Jul-1991 JohnRo
        Extracted RxpDebug.h from Rxp.h.
    21-Nov-1991 JohnRo
        Removed NT dependencies to reduce recompiles.
    04-Dec-1991 JohnRo
        Change RxNetServerSetInfo() to new-style interface.
    07-Feb-1992 JohnRo
        Use NetApiBufferAllocate() instead of private version.

--*/


// These must be included first:

#include <windef.h>
#include <lmcons.h>
#include <rap.h>                // LPDESC, etc.  (Needed by <rxserver.h>)

// These may be included in any order:

#include <apinums.h>            // API_ equates.
#include <dlserver.h>           // NetpConvertServerInfo().
#include <lmapibuf.h>           // NetApiBufferAllocate(), NetApiBufferFree().
#include <lmerr.h>              // NERR_ and ERROR_ equates.
#include <netdebug.h>           // NetpAssert(), FORMAT_ equates, etc.
#include <netlib.h>             // NetpSetParmError().
#include <remdef.h>
#include <rx.h>                 // RxRemoteApi().
#include <rxp.h>                // RxpSetField().
#include <rxpdebug.h>           // IF_DEBUG().
#include <rxserver.h>           // My prototype, etc.


NET_API_STATUS
RxNetServerSetInfo (
    IN LPTSTR UncServerName,
    IN DWORD Level,             // level and/or ParmNum.
    IN LPBYTE Buf,
    OUT LPDWORD ParmError OPTIONAL  // name required by NetpSetParmError macro.
    )

/*++

Routine Description:

    RxNetServerSetInfo performs the same function as NetServerSetInfo,
    except that the server name is known to refer to a downlevel server.

Arguments:

    (Same as NetServerSetInfo, except UncServerName must not be null, and
    must not refer to the local computer.)

Return Value:

    (Same as NetServerSetInfo.)

--*/
{
    BOOL IncompleteOutput;
    LPDESC EquivDataDesc16;
    LPDESC EquivDataDesc32;
    LPDESC EquivDataDescSmb;
    DWORD EquivLevel;
    DWORD EquivFixedSize;
    DWORD EquivMaxNativeSize;
    DWORD EquivStringSize;
    DWORD NewLevelOnly;
    DWORD ParmNum;
    NET_API_STATUS Status;

    // It's easiest to assume failure, and correct that assumption later.
    NetpSetParmError( PARM_ERROR_UNKNOWN );

    NetpAssert(UncServerName != NULL);

    if (Level < PARMNUM_BASE_INFOLEVEL) {
        NewLevelOnly = Level;
        ParmNum = PARMNUM_ALL;
    } else {
        NewLevelOnly = NEW_SERVER_SUPERSET_LEVEL;
        ParmNum = Level - PARMNUM_BASE_INFOLEVEL;
    }
    if (!NetpIsNewServerInfoLevel(NewLevelOnly)) {
        return (ERROR_INVALID_LEVEL);
    }
    if (ParmNum > 99) {
        return (ERROR_INVALID_LEVEL);
    }

    //
    // Need lots of data on the requested info level and the equivalent
    // old info level...
    //
    Status = RxGetServerInfoLevelEquivalent(
            NewLevelOnly,               // from level
            TRUE,                       // from native
            TRUE,                       // to native
            & EquivLevel,               // to level
            & EquivDataDesc16,
            & EquivDataDesc32,
            & EquivDataDescSmb,
            NULL,                       // don't need native size of from
            NULL,                       // don't need from fixed size
            NULL,                       // don't need from string size
            & EquivMaxNativeSize,       // max native size of to level
            & EquivFixedSize,           // to fixed size
            & EquivStringSize,          // to string size
            & IncompleteOutput);        // is output not fully in input?
    NetpAssert(Status == NERR_Success); // Already checked Level!
    NetpAssert( NetpIsOldServerInfoLevel( EquivLevel ) );

    if( Status != NERR_Success )
    {
        return Status;
    }


    //
    // Depending on ParmNum, either we're setting the entire thing, or just
    // one field.
    //
    if (ParmNum == PARMNUM_ALL) {

        LPVOID EquivInfo;               // Ptr to native "old" info.
        DWORD EquivActualSize32;

        if ( Buf == NULL )
            return ERROR_INVALID_PARAMETER;

        if (! IncompleteOutput) {

            // Have all the data we need, so alloc memory for conversion.
            Status = NetApiBufferAllocate( EquivMaxNativeSize, & EquivInfo );
            if (Status != NERR_Success) {
                return (Status);
            }

            // Convert caller's server info to an info level understood by
            // downlevel.
            Status = NetpConvertServerInfo (
                    NewLevelOnly,           // input level
                    Buf,                    // input structure
                    TRUE,                   // input is native format
                    EquivLevel,             // output will be equiv level
                    EquivInfo,              // output info
                    EquivFixedSize,
                    EquivStringSize,
                    TRUE,                   // want output in native format
                    NULL);                  // use default string area
            if (Status != NERR_Success) {
                NetpKdPrint(( "RxNetServerSetInfo: convert failed, stat="
                        FORMAT_API_STATUS ".\n", Status));
                (void) NetApiBufferFree( EquivInfo );
                return (Status);
            }

        } else {

            DWORD TotalAvail;

            // Don't have enough data, so we have to do a get info.  This will
            // allocate the "old" info level buffer for us.
            EquivInfo = NetpMemoryAllocate( EquivMaxNativeSize );
            if (EquivInfo == NULL) {
                return (ERROR_NOT_ENOUGH_MEMORY);
            }
            Status = RxRemoteApi(
                    API_WServerGetInfo,         // API number
                    UncServerName,              // server name (with \\)
                    REMSmb_NetServerGetInfo_P,  // parm desc (16-bit)
                    EquivDataDesc16,            // data desc (16-bit)
                    EquivDataDesc32,            // data desc (32-bit)
                    EquivDataDescSmb,           // data desc (SMB version)
                    NULL,                       // no aux desc 16
                    NULL,                       // no aux desc 32
                    NULL,                       // no aux desc SMB
                    FALSE,                      // not a "no perm req" API
                    // LanMan 2.x args to NetServerGetInfo, in 32-bit form:
                    EquivLevel,                 // level (pretend)
                    EquivInfo,                  // ptr to get 32-bit old info
                    EquivMaxNativeSize,         // size of OldApiBuffer
                    & TotalAvail);              // total available (set)
            if (Status != NERR_Success) {
                NetpKdPrint(( "RxNetServerSetInfo: get info failed, stat="
                        FORMAT_API_STATUS ".\n", Status));
                (void) NetApiBufferFree( EquivInfo );
                return (Status);
            }


            //
            // Overlay the caller's data into the equivalent info structure,
            // which contains items that we want to preserve.
            //
            // Note that this code takes advantage of the fact that a downlevel
            // server doesn't really set all of the fields just because we send
            // an entire structure.  The server just sets the settable fields
            // from that structure.  And the settable fields are defined by
            // the parmnums we can set.  So, we don't bother copying all of
            // the fields here.  (DanHi says this is OK.)  --JohnRo 26-May-1991
            //
            // Also, when we do strings like this, we just point from one buffer
            // to the other buffer.
            //
            switch (NewLevelOnly) {

            case 102 :
                {
                    LPSERVER_INFO_2   psv2   = (LPVOID) EquivInfo;
                    LPSERVER_INFO_102 psv102 = (LPVOID) Buf;
                    NetpAssert( EquivLevel == 2 );

                    psv2->sv2_comment = psv102->sv102_comment;

                    psv2->sv2_disc = psv102->sv102_disc;
                    if (psv102->sv102_hidden) {
                        psv2->sv2_hidden = SV_HIDDEN;
                    } else {
                        psv2->sv2_hidden = SV_VISIBLE;
                    }
                    psv2->sv2_announce = psv102->sv102_announce;
                    psv2->sv2_anndelta = psv102->sv102_anndelta;
                }
                break;

            case 402 :  // 402 and 403 have same settable fields...
            case 403 :
                {
                    LPSERVER_INFO_2   psv2   = (LPVOID) EquivInfo;
                    LPSERVER_INFO_402 psv402 = (LPVOID) Buf;
                    NetpAssert( (EquivLevel == 2) || (EquivLevel == 3) );

                    psv2->sv2_alerts = psv402->sv402_alerts;
                    psv2->sv2_alertsched = psv402->sv402_alertsched;
                    psv2->sv2_erroralert = psv402->sv402_erroralert;
                    psv2->sv2_logonalert = psv402->sv402_logonalert;
                    psv2->sv2_accessalert = psv402->sv402_accessalert;
                    psv2->sv2_diskalert = psv402->sv402_diskalert;
                    psv2->sv2_netioalert = psv402->sv402_netioalert;
                    psv2->sv2_maxauditsz = psv402->sv402_maxauditsz;
                }
                break;

            default :
                NetpAssert( 0==1 );
                (void) NetApiBufferFree( EquivInfo );
                return (NERR_InternalError);
            }

        }

        NetpAssert( EquivInfo != NULL );
        EquivActualSize32 = RapTotalSize(
                EquivInfo,                  // in struct
                EquivDataDesc32,            // in desc
                EquivDataDesc32,            // out desc
                FALSE,                      // no meaningless input ptrs
                Both,                       // transmission mode
                NativeToNative);            // conversion mode
        IF_DEBUG(SERVER) {
            NetpKdPrint(( "RxNetServerSetInfo(all): equiv actual size (32) is "
                    FORMAT_DWORD ".\n", EquivActualSize32 ));
        }
        NetpAssert( EquivActualSize32 <= EquivMaxNativeSize );

        // Remote the API.
        Status = RxRemoteApi(
                API_WServerSetInfo,         // api num
                UncServerName,
                REMSmb_NetServerSetInfo_P,  // parm desc (SMB version)
                EquivDataDesc16,
                EquivDataDesc32,
                EquivDataDescSmb,
                NULL,                       // no aux desc 16
                NULL,                       // no aux desc 32
                NULL,                       // no aux desc SMB
                FALSE,                      // not a null perm req API
                // rest of API's arguments in 32-bit, native, LM 2.x format:
                EquivLevel,
                EquivInfo,
                EquivActualSize32,
                ParmNum);

        (void) NetApiBufferFree( EquivInfo );

    } else {
        // ParmNum indicates only one field, so set it.
        Status = RxpSetField(
                API_WServerSetInfo,         // api number
                UncServerName,
                NULL,                       // no specific object (dest)
                NULL,                       // no specific object to set
                REMSmb_NetServerSetInfo_P,  // parm desc (SMB version)
                EquivDataDesc16,            // data desc 16
                EquivDataDesc32,            // data desc 32
                EquivDataDescSmb,           // data desc SMB version
                Buf,                        // native (old) info buffer 
                ParmNum,                    // parm num to send
                ParmNum,                    // field index
                EquivLevel);                // old info level

    }

    if (Status == NERR_Success) {
        NetpSetParmError(PARM_ERROR_NONE);
    } else if (Status == ERROR_INVALID_PARAMETER) {
        NetpSetParmError(ParmNum);
    } else {
        NetpSetParmError(PARM_ERROR_UNKNOWN);
    }

    return (Status);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\rpcxlate\rxapi\svcenum.c ===
/*++

Copyright (c) 1991-1993  Microsoft Corporation

Module Name:

    SvcEnum.c

Abstract:

    This file contains the RpcXlate code to handle the Service APIs.

Author:

    John Rogers (JohnRo) 13-Sep-1991

Environment:

    Portable to any flat, 32-bit environment.  (Uses Win32 typedefs.)
    Requires ANSI C extensions: slash-slash comments, long external names.

Revision History:

    13-Sep-1991 JohnRo
        Created.
    18-Sep-1991 JohnRo
        Handle ERROR_MORE_DATA.
    21-Nov-1991 JohnRo
        Removed NT dependencies to reduce recompiles.
    25-Nov-1991 JohnRo
        Assert to check for possible infinite loop.
    07-Feb-1992 JohnRo
        Use NetApiBufferAllocate() instead of private version.
    27-Jan-1993 JohnRo
        RAID 8926: NetConnectionEnum to downlevel: memory leak on error.
        Also prevent possible infinite loop.

--*/

// These must be included first:

#include <windef.h>             // IN, DWORD, etc.
#include <lmcons.h>             // DEVLEN, NET_API_STATUS, etc.

// These may be included in any order:

#include <apinums.h>            // API_ equates.
#include <lmapibuf.h>           // NetApiBufferFree().
#include <lmerr.h>              // ERROR_ and NERR_ equates.
#include <lmsvc.h>              // API's data structures.
#include <netdebug.h>   // NetpAssert().
#include <netlib.h>             // NetpAdjustPreferredMaximum().
#include <prefix.h>     // PREFIX_ equates.
#include <rap.h>                // LPDESC.
#include <remdef.h>             // REM16_, REM32_, REMSmb_ equates.
#include <rx.h>                 // RxRemoteApi().
#include <rxp.h>                // RxpFatalErrorCode().
#include <rxsvc.h>              // My prototype(s).
#include <strucinf.h>           // NetpServiceStructureInfo().


#define SERVICE_ARRAY_OVERHEAD_SIZE     0


NET_API_STATUS
RxNetServiceEnum (
    IN LPTSTR UncServerName,
    IN DWORD Level,
    OUT LPBYTE *BufPtr,
    IN DWORD PreferedMaximumSize,
    OUT LPDWORD EntriesRead,
    OUT LPDWORD TotalEntries,
    IN OUT LPDWORD ResumeHandle OPTIONAL
    )

/*++

Routine Description:

    RxNetServiceEnum performs the same function as NetServiceEnum,
    except that the server name is known to refer to a downlevel server.

Arguments:

    (Same as NetServiceEnum, except UncServerName must not be null, and
    must not refer to the local computer.)

Return Value:

    (Same as NetServiceEnum.)

--*/

{
    LPDESC DataDesc16;
    LPDESC DataDesc32;
    LPDESC DataDescSmb;
    DWORD EntriesToAllocate;
    LPVOID InfoArray = NULL;
    DWORD InfoArraySize;
    DWORD MaxEntrySize;
    NET_API_STATUS Status;
    LPSERVICE_INFO_2 serviceInfo2;
    LPSERVICE_INFO_1 serviceInfo1;
    DWORD i;

    UNREFERENCED_PARAMETER(ResumeHandle);

    // Make sure caller didn't mess up.
    NetpAssert(UncServerName != NULL);
    if (BufPtr == NULL) {
        return (ERROR_INVALID_PARAMETER);
    }

    // Assume something might go wrong, and make error paths easier to
    // code.  Also, check for a bad pointer before we do anything.
    *BufPtr = NULL;

    Status = NetpServiceStructureInfo (
            Level,
            PARMNUM_ALL,                // want all fields.
            TRUE,                       // want native sizes.
            & DataDesc16,
            & DataDesc32,
            & DataDescSmb,
            & MaxEntrySize,             // API buffer size 32
            NULL,                       // don't need fixed size
            NULL                        // don't need string size
            );
    if (Status != NERR_Success) {
        *BufPtr = NULL;
        return (Status);
    }

    //
    // Downlevel servers don't support resume handles, and we don't
    // have a way to say "close this resume handle" even if we wanted to
    // emulate them here.  Therefore we have to do everthing in one shot.
    // So, the first time around, we'll try using the caller's prefered
    // maximum, but we will enlarge that until we can get everything in one
    // buffer.
    //

    // First time: try caller's prefered maximum.
    NetpAdjustPreferedMaximum (
            PreferedMaximumSize,        // caller's request
            MaxEntrySize,               // byte count per array element
            SERVICE_ARRAY_OVERHEAD_SIZE,// num bytes overhead to show array end
            NULL,                       // we'll compute byte counts ourselves.
            & EntriesToAllocate);       // num of entries we can get.

    //
    // Loop until we have enough memory or we die for some other reason.
    //
    do {

        //
        // Figure out how much memory we need, within the protocol limit.
        //

        InfoArraySize = (EntriesToAllocate * MaxEntrySize)
                + SERVICE_ARRAY_OVERHEAD_SIZE;

        if (InfoArraySize > MAX_TRANSACT_RET_DATA_SIZE) {
            InfoArraySize = MAX_TRANSACT_RET_DATA_SIZE;
        }

        //
        // Remote the API, which will allocate the array for us.
        //

        Status = RxRemoteApi(
                API_WServiceEnum,       // api number
                UncServerName,          // \\servername
                REMSmb_NetServiceEnum_P,    // parm desc (SMB version)
                DataDesc16,
                DataDesc32,
                DataDescSmb,
                NULL,                   // no aux desc 16
                NULL,                   // no aux desc 32
                NULL,                   // no aux desc SMB
                ALLOCATE_RESPONSE,      // flags: not a null session API
                // rest of API's arguments in 32-bit LM 2.x format:
                Level,                  // sLevel: info level
                & InfoArray,            // Buffer: array (alloc for us)
                InfoArraySize,          // Buffer: array size in bytes
                EntriesRead,            // pcEntriesRead
                TotalEntries);          // pcTotalAvail

        //
        // If the server returned ERROR_MORE_DATA, free the buffer and try
        // again.  (Actually, if we already tried 64K, then forget it.)
        //

        NetpAssert( InfoArraySize <= MAX_TRANSACT_RET_DATA_SIZE );
        if (Status != ERROR_MORE_DATA) {
            break;
        } else if (InfoArraySize == MAX_TRANSACT_RET_DATA_SIZE) {
            NetpKdPrint(( PREFIX_NETAPI
                    "RxNetServiceEnum: "
                    "**WARNING** protocol limit reached (64KB).\n" ));
            break;
        }

        (void) NetApiBufferFree( InfoArray );
        InfoArray = NULL;
        NetpAssert( EntriesToAllocate < *TotalEntries );
        EntriesToAllocate = *TotalEntries;

    } while (Status == ERROR_MORE_DATA);

    if (! RxpFatalErrorCode(Status)) {
        DWORD   installState;
        *BufPtr = InfoArray;

        if (Level == 2) {
            //
            // Make the DisplayName pointer point to the service name.
            //
            serviceInfo2 = (LPSERVICE_INFO_2)InfoArray;
    
            for (i=0;i<*EntriesRead ;i++) {
                (serviceInfo2[i]).svci2_display_name = (serviceInfo2[i]).svci2_name;
                //
                // if INSTALL or UNINSTALL is PENDING, then force the upper
                // bits to 0.  This is to prevent the upper bits of the wait
                // hint from getting accidentally set.  Downlevel should never
                // use more than FF for waithint.
                //
                installState = (serviceInfo2[i]).svci2_status & SERVICE_INSTALL_STATE;
                if ((installState == SERVICE_INSTALL_PENDING) ||
                    (installState == SERVICE_UNINSTALL_PENDING)) {
                    (serviceInfo2[i]).svci2_code &= SERVICE_RESRV_MASK;
                }
            }
        }
        if (Level == 1) {
            serviceInfo1 = (LPSERVICE_INFO_1)InfoArray;
    
            for (i=0;i<*EntriesRead ;i++) {
                //
                // if INSTALL or UNINSTALL is PENDING, then force the upper
                // bits to 0.  This is to prevent the upper bits of the wait
                // hint from getting accidentally set.  Downlevel should never
                // use more than FF for waithint.
                //
                installState = (serviceInfo1[i]).svci1_status & SERVICE_INSTALL_STATE;
                if ((installState == SERVICE_INSTALL_PENDING) ||
                    (installState == SERVICE_UNINSTALL_PENDING)) {
                    (serviceInfo1[i]).svci1_code &= SERVICE_RESRV_MASK;
                }
            }
        }
    } else {
        if (InfoArray != NULL) {
            (VOID) NetApiBufferFree( InfoArray );
        } 
        NetpAssert( *BufPtr == NULL );
    }

    return (Status);

} // RxNetServiceEnum
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\rpcxlate\rxapi\svcgtinf.c ===
/*++

Copyright (c) 1991-92  Microsoft Corporation

Module Name:

    SvcGtInf.c

Abstract:

    This file contains the RpcXlate code to handle the NetServiceGetInfo API.

Author:

    John Rogers (JohnRo) 11-Sep-1991

Environment:

    Portable to any flat, 32-bit environment.  (Uses Win32 typedefs.)
    Requires ANSI C extensions: slash-slash comments, long external names.

Revision History:

    11-Sep-1991 JohnRo
        Implement downlevel NetService APIs.
    16-Sep-1991 JohnRo
        Fixed level check.
    22-Oct-1991 JohnRo
        Free buffer on error.
    07-Feb-1992 JohnRo
        Use NetApiBufferAllocate() instead of private version.

--*/

// These must be included first:

#include <windef.h>             // IN, DWORD, etc.
#include <lmcons.h>             // LM20_ equates, NET_API_STATUS, etc.

// These may be included in any order:

#include <apinums.h>            // API_ equates.
#include <lmapibuf.h>           // NetApiBufferAllocate().
#include <lmerr.h>              // ERROR_ and NERR_ equates.
#include <lmsvc.h>
#include <rxp.h>                // RxpFatalErrorCode().
#include <netdebug.h>           // DBGSTATIC, NetpKdPrint(()), FORMAT_ equates.
#include <rap.h>                // LPDESC.
#include <remdef.h>             // REM16_, REM32_, REMSmb_ equates.
#include <rx.h>                 // RxRemoteApi().
#include <rxpdebug.h>           // IF_DEBUG().
#include <rxsvc.h>              // My prototype.
#include <strucinf.h>           // NetpServiceStructureInfo().



NET_API_STATUS
RxNetServiceGetInfo (
    IN LPTSTR UncServerName,
    IN LPTSTR Service,
    IN DWORD Level,
    OUT LPBYTE *BufPtr
    )

/*++

Routine Description:

    RxNetServiceGetInfo performs the same function as NetServiceGetInfo, except
    that the server name is known to refer to a downlevel server.

Arguments:

    (Same as NetServiceGetInfo, except UncServerName must not be null, and
    must not refer to the local computer.)

Return Value:

    (Same as NetServiceGetInfo.)

--*/

{

    LPDESC DataDesc16, DataDesc32, DataDescSmb;
    LPBYTE ApiBuffer32;                 // Buffer to be returned to caller.
    DWORD ApiBufferSize32;
    NET_API_STATUS Status;
    DWORD TotalAvail;
    LPSERVICE_INFO_2 serviceInfo2;

    IF_DEBUG(SERVICE) {
        NetpKdPrint(("RxNetServiceGetInfo: starting, server=" FORMAT_LPTSTR
                ", lvl=" FORMAT_DWORD ".\n", UncServerName, Level));
    }

    //
    // Error check DLL stub and the app.
    //
    NetpAssert(UncServerName != NULL);
    if (BufPtr == NULL) {
        return (ERROR_INVALID_PARAMETER);
    }
    *BufPtr = NULL;  // assume error; it makes error handlers easy to code.
    // This also forces possible GP fault before we allocate memory.

    //
    // Learn about info level.
    //
    Status = NetpServiceStructureInfo (
            Level,                      // level to learn about
            PARMNUM_ALL,                // No parmnum with this.
            TRUE,                       // Need native sizes.
            & DataDesc16,
            & DataDesc32,
            & DataDescSmb,
            & ApiBufferSize32,          // max buffer size (native)
            NULL,                       // don't need fixed size.
            NULL                        // don't need string size.
            );
    if (Status != NERR_Success) {
        return (Status);
    }

    //
    // Allocate memory for 32-bit version of info, which we'll use to get
    // data from the remote computer.
    //
    Status = NetApiBufferAllocate(
            ApiBufferSize32,
            (LPVOID *) & ApiBuffer32);
    if (Status != NERR_Success) {
        return (Status);
    }
    IF_DEBUG(SERVICE) {
        NetpKdPrint(( "RxNetServiceGetInfo: allocated buffer at "
                FORMAT_LPVOID "\n", (LPVOID) ApiBuffer32 ));
    }

    //
    // Actually remote the API, which will get back the
    // data in native format.
    //
    Status = RxRemoteApi(
            API_WServiceGetInfo,        // API number
            UncServerName,              // Required, with \\name.
            REMSmb_NetServiceGetInfo_P, // parm desc
            DataDesc16,
            DataDesc32,
            DataDescSmb,
            NULL,                       // no aux data desc 16
            NULL,                       // no aux data desc 32
            NULL,                       // no aux data desc SMB
            FALSE,                      // not a null session API
            // rest of API's arguments, in 32-bit LM 2.x format:
            Service,
            Level,
            ApiBuffer32,
            ApiBufferSize32,
            & TotalAvail);              // total size 

    NetpAssert( Status != ERROR_MORE_DATA );
    NetpAssert( Status != NERR_BufTooSmall );

    if (Status == NERR_Success) {
        *BufPtr = ApiBuffer32;
        if ((! RxpFatalErrorCode(Status)) && ((Level == 2) || (Level==1 ))) {
            serviceInfo2 = (LPSERVICE_INFO_2)*BufPtr;
            if (serviceInfo2 != NULL) {
                DWORD   installState;

                if (Level == 2) {
                    serviceInfo2->svci2_display_name = serviceInfo2->svci2_name;
                }
                //
                // if INSTALL or UNINSTALL is PENDING, then force the upper
                // bits to 0.  This is to prevent the upper bits of the wait
                // hint from getting accidentally set.  Downlevel should never
                // use more than FF for waithint.
                //
                installState = serviceInfo2->svci2_status & SERVICE_INSTALL_STATE;
                if ((installState == SERVICE_INSTALL_PENDING) ||
                    (installState == SERVICE_UNINSTALL_PENDING)) {
                    serviceInfo2->svci2_code &= SERVICE_RESRV_MASK;
                }
            }
        }
    } else {
        (void) NetApiBufferFree( ApiBuffer32 );
    }
    return (Status);

} // RxNetServiceGetInfo
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\rpcxlate\rxapi\svcinst.c ===
/*++

Copyright (c) 1991-92  Microsoft Corporation

Module Name:

    SvcInst.c

Abstract:

    This file contains the RpcXlate code to handle the Service APIs.

Author:

    John Rogers (JohnRo) 13-Sep-1991

Environment:

    Portable to any flat, 32-bit environment.  (Uses Win32 typedefs.)
    Requires ANSI C extensions: slash-slash comments, long external names.

Revision History:

    13-Sep-1991 JohnRo
        Created.
    16-Sep-1991 JohnRo
        Made changes suggested by PC-LINT.
    24-Sep-1991 JohnRo
        Fixed bug when ArgC is 0.  Also changed to pass data descs to
        RxRemoteApi.  We also have to do the structure conversion here.
    21-Nov-1991 JohnRo
        Removed NT dependencies to reduce recompiles.
    18-Dec-1991 JohnRo
        Improved UNICODE handling.
    07-Feb-1992 JohnRo
        Use NetApiBufferAllocate() instead of private version.
    27-Oct-1992 JohnRo
        Fixed problem setting up string area pointer for RapConvertSingleEntry.
        Use PREFIX_ equates.

--*/

// These must be included first:

#include <windef.h>             // IN, DWORD, etc.
#include <lmcons.h>             // DEVLEN, NET_API_STATUS, etc.

// These may be included in any order:

#include <apinums.h>            // API_ equates.
#include <lmapibuf.h>           // NetApiBufferAllocate(), NetApiBufferFree().
#include <lmerr.h>              // ERROR_ and NERR_ equates.
#include <lmsvc.h>
#include <rxp.h>                // RxpFatalErrorCode().
#include <netdebug.h>           // NetpKdPrint(()), FORMAT_ equates.
#include <netlib.h>             // NetpPointerPlusSomeBytes().
#include <prefix.h>     // PREFIX_ equates.
#include <rap.h>                // LPDESC, RapConvertSingleEntry().
#include <remdef.h>             // REM16_, REM32_, REMSmb_ equates.
#include <rx.h>                 // RxRemoteApi().
#include <rxpdebug.h>           // IF_DEBUG().
#include <rxsvc.h>              // My prototype.
#include <strucinf.h>           // NetpServiceStructureInfo().
#include <tstring.h>            // STRCPY(), STRLEN().



NET_API_STATUS
RxNetServiceInstall (
    IN LPTSTR UncServerName,
    IN LPTSTR Service,
    IN DWORD ArgC,
    IN LPTSTR ArgV[],
    OUT LPBYTE *BufPtr
    )
{
    NET_API_STATUS ApiStatus;
    DWORD ArgIndex;             // Index into array of strings.
    LPSTR CmdArgs;              // ptr to alloc'ed ASCII list of strings.
    DWORD CmdArgsIndex;         // Char index into CmdArgs.
    DWORD CmdArgsLen = 0;       // Number of chars in CmdArgs (incl null).
    const DWORD Level = 2;      // Implied by this API.
    LPVOID OldInfo;             // Info structure in downlevel format.
    DWORD OldTotalSize;         // Size of struct in old (downlevel) format.
    NET_API_STATUS TempStatus;
    LPSERVICE_INFO_2 serviceInfo2;

    NetpAssert(UncServerName != NULL);
    NetpAssert(*UncServerName != '\0');

    //
    // Compute how much memory we'll need for single CmdArgs array.
    //
    for (ArgIndex = 0; ArgIndex < ArgC; ++ArgIndex) {
#if defined(UNICODE) // RxNetServiceInstall ()
        CmdArgsLen += NetpUnicodeToDBCSLen(ArgV[ArgIndex]) + 1;  // string and null.
#else
        CmdArgsLen += STRLEN(ArgV[ArgIndex]) + 1;  // string and null.
#endif // defined(UNICODE)
    }
    ++CmdArgsLen;  // include a null char at end of array.

    //
    // Allocate the array.  This is in ASCII, so we don't need to
    // add sizeof(some_char_type).
    //
    TempStatus = NetApiBufferAllocate( CmdArgsLen, (LPVOID *) & CmdArgs );
    if (TempStatus != NERR_Success) {
        return (TempStatus);
    }
    NetpAssert(CmdArgs != NULL);

    //
    // Build ASCII version of CmdArgs.
    //
    CmdArgsIndex = 0;  // start
    for (ArgIndex=0; ArgIndex<ArgC; ++ArgIndex) {
        NetpAssert( ArgV[ArgIndex] != NULL );
#if defined(UNICODE) // RxNetServiceInstall ()
        NetpCopyWStrToStrDBCS(
                & CmdArgs[CmdArgsIndex],                // dest
                ArgV[ArgIndex] );                       // src
        CmdArgsIndex += strlen(&CmdArgs[CmdArgsIndex])+1; //str and null
#else
        NetpCopyTStrToStr(
                & CmdArgs[CmdArgsIndex],                // dest
                ArgV[ArgIndex]);                        // src
        CmdArgsIndex += STRLEN(ArgV[ArgIndex]) + 1;     // str and null.
#endif // defined(UNICODE)
    }
    CmdArgs[CmdArgsIndex] = '\0';  // null char to end list.
    IF_DEBUG(SERVICE) {
        NetpKdPrint(( PREFIX_NETAPI
                "RxNetServiceInstall: cmd args (partial):\n" ));
        NetpDbgHexDump( (LPBYTE) (LPVOID) CmdArgs,
                NetpDbgReasonable(CmdArgsLen) );
    }

    //
    // Find out about the downlevel version of this data structure.
    // Allocate space for it.  (See note below as to why we have to do this
    // here rather than in RxRemoteApi.)
    //
    TempStatus = NetpServiceStructureInfo (
            Level,
            PARMNUM_ALL,        // want entire structure
            FALSE,              // Want downlevel size.
            NULL,               // don't need DataDesc16 here
            NULL,               // don't need DataDesc32 here
            NULL,               // don't need DataDescSmb here
            & OldTotalSize,     // max size (downlevel version)
            NULL,               // don't care about fixed size
            NULL);              // don't care about string size
    NetpAssert(TempStatus == NERR_Success);
    TempStatus = NetApiBufferAllocate( OldTotalSize, (LPVOID *) & OldInfo );
    if (TempStatus != NERR_Success) {
        (void) NetApiBufferFree(CmdArgs);
        return (TempStatus);
    }

    //
    // Remote the API.
    //
    // Note that this is strange because there should be descriptors for two
    // things: the cmd buffer we're sending, and the structure we're expecting
    // back.  The downlevel system is only expecting a descriptor for the
    // cmd args, so RxRemoteApi won't be able to convert the structure into
    // native format for us.  So we'll have to convert it later.
    //
    // Also, the following comment (from the LM 2.x svc_inst.c) explains
    // why we're passing something besides the expected value for cbBuffer:
    //
    /* Now for a slightly unclean fix for an oversight in the
     * parameters spec'ed for this call. The command arg buf is
     * the variable length buffer while the outbuf is actually
     * a fixed length structure (no var. length ptrs) yet the
     * parameters to the API give only the outbuflen. In order
     * to transport the API remotely the outbuflen (which has
     * already been length verified) is used to transport the
     * ca_len, and will be reset to sizeof(struct service_info_2)
     * by a remote only entry point to the API.
     */

    ApiStatus = RxRemoteApi(
            API_WServiceInstall,        // API number
            UncServerName,
            REMSmb_NetServiceInstall_P, // parm desc
            REM16_service_cmd_args,     // send cmd desc, NOT DataDesc16
            REM16_service_cmd_args,     // send cmd desc, NOT DataDesc32
            REMSmb_service_cmd_args,    // send cmd desc, NOT DataDescSmb
            NULL,                       // no aux desc 16
            NULL,                       // no aux desc 32
            NULL,                       // no aux desc SMB
            0,                          // flags: nothing special
            // rest of API's arguments, in 32-bit LM2.x format:
            Service,
            CmdArgs,                    // ASCII version of cmd args.
            OldInfo,                    // pbBuffer
            CmdArgsLen);                // cbBuffer (not OldTotalSize; see
                                        // comment above).
    IF_DEBUG(SERVICE) {
        NetpKdPrint(( PREFIX_NETAPI
                "RxNetServiceInstall: OldInfo=" FORMAT_LPVOID ".\n",
                (LPVOID) OldInfo ));
        if (OldInfo) {
            NetpKdPrint(( PREFIX_NETAPI
                    "RxNetServiceInstall: *OldInfo=" FORMAT_LPVOID ".\n",
                    *(LPVOID *) OldInfo ));
        }
    }

    NetpAssert( ApiStatus != ERROR_MORE_DATA );
    if (ApiStatus == NERR_Success) {

        DWORD BytesRequired = 0;        // 0 bytes used so far.
        LPDESC DataDesc16, DataDesc32;
        LPVOID NewInfo;
        DWORD NewTotalSize;
        LPBYTE StringLocation;

        //
        // Set up to do conversion to native format.
        //
        TempStatus = NetpServiceStructureInfo (
                Level,
                PARMNUM_ALL,        // want entire structure
                TRUE,               // want native size.
                & DataDesc16,
                & DataDesc32,
                NULL,               // don't need data desc SMB
                & NewTotalSize,     // max size (downlevel version)
                NULL,               // don't care about fixed size
                NULL);              // don't care about string size
        NetpAssert(TempStatus == NERR_Success);  // Level can't be wrong.

        TempStatus = NetApiBufferAllocate(
                NewTotalSize,
                (LPVOID *) & NewInfo );
        if (TempStatus != NERR_Success) {
            (void) NetApiBufferFree(OldInfo);
            (void) NetApiBufferFree(CmdArgs);
            return (TempStatus);
        }

        StringLocation = (LPVOID) NetpPointerPlusSomeBytes(
                NewInfo, NewTotalSize );

        //
        // Convert info structure to native format.
        //
        IF_DEBUG(SERVICE) {
            NetpKdPrint(( PREFIX_NETAPI
                    "RxNetServiceInstall: Unconverted info at "
                    FORMAT_LPVOID "\n", (LPVOID) OldInfo ));
            NetpDbgHexDump( OldInfo, OldTotalSize );
        }
        TempStatus = RapConvertSingleEntry (
                OldInfo,                // in structure
                DataDesc16,             // in structure desc
                TRUE,                   // meaningless input ptrs
                NewInfo,                // output buffer start
                NewInfo,                // output buffer
                DataDesc32,             // output structure desc
                FALSE,                  // don't set offsets (want ptrs)
                & StringLocation,       // where to start strs (updated)
                & BytesRequired,        // bytes used (will be updated)
                Both,                   // transmission mode
                RapToNative);           // conversion mode
        NetpAssert( TempStatus == NERR_Success );
        IF_DEBUG(SERVICE) {
            NetpKdPrint(( PREFIX_NETAPI
                    "RxNetServiceInstall: Converted info at "
                    FORMAT_LPVOID "\n", (LPVOID) NewInfo ));
            NetpDbgHexDump( NewInfo, NewTotalSize );
        }
        NetpAssert( BytesRequired <= NewTotalSize );

        *BufPtr = (LPBYTE) NewInfo;

        if ((! RxpFatalErrorCode(ApiStatus)) && (Level == 2)) {
            serviceInfo2 = (LPSERVICE_INFO_2)*BufPtr;
            if (serviceInfo2 != NULL) {
                DWORD   installState;

                serviceInfo2->svci2_display_name = serviceInfo2->svci2_name;
                //
                // if INSTALL or UNINSTALL is PENDING, then force the upper
                // bits to 0.  This is to prevent the upper bits of the wait
                // hint from getting accidentally set.  Downlevel should never
                // use more than FF for waithint.
                //
                installState = serviceInfo2->svci2_status & SERVICE_INSTALL_STATE;
                if ((installState == SERVICE_INSTALL_PENDING) ||
                    (installState == SERVICE_UNINSTALL_PENDING)) {
                    serviceInfo2->svci2_code &= SERVICE_RESRV_MASK;
                }
            }
        }
    } else {
        *BufPtr = NULL;
    }

    (void) NetApiBufferFree( OldInfo );

    //
    // Clean up and tell caller how things went.
    // (Caller must call NetApiBufferFree() for BufPtr.)
    //
    (void) NetApiBufferFree(CmdArgs);
    return (ApiStatus);

} // RxNetServiceInstall
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\rpcxlate\rxapi\wksequiv.c ===
/*++

Copyright (c) 1991-1992  Microsoft Corporation

Module Name:

    WksEquiv.c

Abstract:

    This file contains RxpGetWkstaInfoLevelEquivalent.

Author:

    John Rogers (JohnRo) 15-Aug-1991

Environment:

    Portable to any flat, 32-bit environment.  (Uses Win32 typedefs.)
    Requires ANSI C extensions: slash-slash comments, long external names.

Revision History:

    15-Aug-1991 JohnRo
        Implement downlevel NetWksta APIs.
    21-Nov-1991 JohnRo
        Removed NT dependencies to reduce recompiles.
    30-Oct-1992 JohnRo
        RAID 10418: NetWkstaGetInfo level 302: wrong error code.
        Use PREFIX_ equates.

--*/

// These must be included first:

#include <windef.h>             // IN, DWORD, etc.
#include <lmcons.h>             // NET_API_STATUS, etc.

// These may be included in any order:

#include <lmerr.h>              // ERROR_ and NERR_ equates.
#include <netdebug.h>           // NetpKdPrint(()).
#include <netlib.h>             // NetpSetOptionalArg().
#include <prefix.h>     // PREFIX_ equates.
#include <rxwksta.h>            // My prototypes.



NET_API_STATUS
RxpGetWkstaInfoLevelEquivalent(
    IN DWORD FromLevel,
    OUT LPDWORD ToLevel,
    OUT LPBOOL IncompleteOutput OPTIONAL  // incomplete (except platform ID)
    )
{
    switch (FromLevel) {

    case 0 :
        NetpKdPrint(( PREFIX_NETAPI
                "RxpGetWkstaInfoLevelEquivalent: 0 not supported yet\n" ));
        return (ERROR_INVALID_LEVEL);

    case 1 :
        NetpKdPrint(( PREFIX_NETAPI
                "RxpGetWkstaInfoLevelEquivalent: 1 not supported yet\n" ));
        return (ERROR_INVALID_LEVEL);

    case 10 :
        NetpKdPrint(( PREFIX_NETAPI
                "RxpGetWkstaInfoLevelEquivalent: 10 not supported yet\n" ));
        return (ERROR_INVALID_LEVEL);

    case 100 :
        // Level 100 is subset of level 10 (except platform ID).
        *ToLevel = 10;
        NetpSetOptionalArg( IncompleteOutput, FALSE );
        return (NERR_Success);

    case 101 :
        // Level 101 is subset of level 0 (except platform ID).
        *ToLevel = 0;
        NetpSetOptionalArg( IncompleteOutput, FALSE );
        return (NERR_Success);

    case 102 :
        // Level 102 is subset of level 0 (except platform ID and logged on
        // users).
        *ToLevel = 0;
        NetpSetOptionalArg( IncompleteOutput, TRUE );
        return (NERR_Success);

    case 302:
        // Info level 302 is DOS only, so isn't supported here.
        NetpKdPrint(( PREFIX_NETAPI
                "RxpGetWkstaInfoLevelEquivalent: 302 not supported\n" ));
        return (ERROR_INVALID_LEVEL);

    case 402 :
        // Level 402 is subset of level 1 (except platform ID).
        *ToLevel = 1;
        NetpSetOptionalArg( IncompleteOutput, FALSE );
        return (NERR_Success);

    case 502:
        // Info level 502 is NT only, so isn't supported here.
        NetpKdPrint(( PREFIX_NETAPI
                "RxpGetWkstaInfoLevelEquivalent: 502 not supported\n" ));
        return (ERROR_INVALID_LEVEL);

    default :
        return (ERROR_INVALID_LEVEL);
    }
    /* NOTREACHED */

} // RxpGetWkstaStructInfo
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\rpcxlate\rxapi\tod.c ===
/*++

Copyright (c) 1991-1993  Microsoft Corporation

Module Name:

    TOD.c

Abstract:

    This file contains the RpcXlate code to handle the NetRemote APIs
    that can't be handled by simple calls to RxRemoteApi.

Author:

    John Rogers (JohnRo) 02-Apr-1991

Environment:

    Portable to any flat, 32-bit environment.  (Uses Win32 typedefs.)
    Requires ANSI C extensions: slash-slash comments, long external names.

    This code assumes that time_t is expressed in seconds since 1970 (GMT).
    ANSI C does not require this, although POSIX (IEEE 1003.1) does.

Revision History:

    02-Apr-1991 JohnRo
        Created.
    13-Apr-1991 JohnRo
        Moved API handlers into per-group header files (e.g. RxServer.h).
        Quiet debug output by default.
        Reduced recompile hits from header files.
    03-May-1991 JohnRo
        Changed to use both 16-bit data desc and SMB data desc.  Use LPTSTR.
        Call RxpTransactSmb with UNC server name.
    06-May-1991 JohnRo
        Use RxpComputeRequestBufferSize().  Use correct print strings for
        server name and descriptors.
    15-May-1991 JohnRo
        Added conversion mode handling.
    19-May-1991 JohnRo
        Make LINT-suggested changes.  Got rid of tabs (again).
    17-Jul-1991 JohnRo
        Extracted RxpDebug.h from Rxp.h.
    25-Sep-1991 JohnRo
        Handle RapConvertSingleEntry's new return code.
    21-Nov-1991 JohnRo
        Removed NT dependencies to reduce recompiles.
    07-Feb-1992 JohnRo
        Use NetApiBufferAllocate() instead of private version.
    15-Apr-1992 JohnRo
        FORMAT_POINTER is obsolete.
    18-Aug-1992 JohnRo
        RAID 2920: Support UTC timezone in net code.
        Use PREFIX_ equates.
    01-Oct-1992 JohnRo
        RAID 3556: Added NetpSystemTimeToGmtTime() for DosPrint APIs.
    10-Jun-1993 JohnRo
        RAID 13081: NetRemoteTOD should return timezone info in right units.

--*/


// These must be included first:

#include <windows.h>    // IN, LPTSTR, etc.
#include <lmcons.h>

// These may be included in any order:

#include <apinums.h>
#include <lmapibuf.h>   // NetApiBufferFree().
#include <lmerr.h>      // NO_ERROR, ERROR_ and NERR_ equates.
#include <lmremutl.h>   // Real API prototypes and #defines.
#include <netdebug.h>   // NetpKdPrint(()), FORMAT_ equates, etc.
#include <prefix.h>     // PREFIX_ equates.
#include <remdef.h>     // 16-bit and 32-bit descriptor strings.
#include <rx.h>         // RxRemoteApi().
#include <rxpdebug.h>   // IF_DEBUG().
#include <rxremutl.h>   // My prototype.
#include <time.h>       // gmtime(), struct tm, time_t.
#include <timelib.h>    // NetpGmtTimeToLocalTime(), NetpLocalTimeZoneOffset().


NET_API_STATUS
RxNetRemoteTOD (
    IN LPTSTR UncServerName,
    OUT LPBYTE *BufPtr
    )

/*++

Routine Description:

    RxNetRemoteTOD performs the same function as NetRemoteTOD,
    except that the server name is known to refer to a downlevel server.

Arguments:

    (Same as NetRemoteTOD, except UncServerName must not be null, and
    must not refer to the local computer.)

Return Value:

    (Same as NetRemoteTOD.)

--*/

{
    NET_API_STATUS ApiStatus;
    time_t GmtTime;                     // seconds since 1970 (GMT).
    struct tm * pGmtTm;                 // broken down GMT time (static obj).
    PTIME_OF_DAY_INFO pGmtTod = NULL;   // TOD on remote sys, GMT timezone.
    LONG LocalTimeZoneOffsetSecs;       // offset (+ for West of GMT, etc).
    TIME_OF_DAY_INFO LocalTod;          // TOD on remote sys, local timezone.
    LONG timezone;

    NetpAssert(UncServerName != NULL);

    IF_DEBUG(REMUTL) {
        NetpKdPrint(( PREFIX_NETAPI
                "RxNetRemoteTOD: starting, server='" FORMAT_LPTSTR "'.\n",
                UncServerName));
    }

    //
    // REM32_time_of_day_info, also used by XACTSRV, translates the
    // 16-bit local time returned from the server to GMT.  Unfortunately
    // it uses the timezone of the local machine rather than the timezone
    // returned from the server.  So, we have our own define here, which
    // uses 'J'instead of 'G' so that no translation takes place.  Then
    // we do our own translation below.  This makes us work with
    // Windows 95 servers.

    #define REM32_time_of_day_info_2          "JDDDDDXDDDDD"

    //
    // Get TOD structure (with local time values) from other system.
    // Note that the "tod_elapsedt" field will be converted from local
    // timezone to GMT by RxRemoteApi.
    //


    ApiStatus = RxRemoteApi(
            API_NetRemoteTOD,           // API number
            (LPTSTR) UncServerName,
            REMSmb_NetRemoteTOD_P,      // parm desc
            REM16_time_of_day_info,     // DataDesc16
            REM32_time_of_day_info_2,     // DataDesc32
            REMSmb_time_of_day_info,    // DataDescSmb
            NULL,                       // no AuxDesc16
            NULL,                       // no AuxDesc32
            NULL,                       // no AuxDescSmb
            0,                          // flags: not a null session API
            // rest of API's arguments, in 32-bit LM2.x format:
            (LPVOID) & LocalTod,        // pbBuffer
            sizeof(LocalTod) );         // cbBuffer

    IF_DEBUG(REMUTL) {
        NetpKdPrint(( PREFIX_NETAPI
                "RxNetRemoteTOD: after RxRemoteApi, "
                "ApiStatus=" FORMAT_API_STATUS ".\n", ApiStatus));
    }

    if (ApiStatus != NO_ERROR) {
        goto Cleanup;
    }

    //
    // Get info on the timezone itself.  If target machine doesn't know, then
    // we have to fall back on the age-old policy: assume it is running in
    // same timezone that we are.
    //
    if (LocalTod.tod_timezone == -1) {
	//
	// First, get number of seconds from UTC.  (Positive values for
	// west of Greenwich, negative values for east of Greenwich.)
	// Then, convert to minutes.
        LocalTimeZoneOffsetSecs = NetpLocalTimeZoneOffset();
        timezone   = LocalTimeZoneOffsetSecs / 60;
    }
    else
    {
        timezone = LocalTod.tod_timezone;
    }
    //
    // Get GmtTime (time in seconds since 1970, GMT) for convenience.
    //
    NetpAssert( sizeof(DWORD) == sizeof(time_t) );
    GmtTime = (time_t) LocalTod.tod_elapsedt + timezone * 60;

    IF_DEBUG(REMUTL) {
        NetpKdPrint(( PREFIX_NETAPI
                "RxNetRemoteTOD: before convert, buffer:\n"));
        NetpDbgDisplayTod( "before GMT conv", & LocalTod );
        NetpDbgDisplayTimestamp( "secs since 1970 (GMT)", (DWORD) GmtTime );
    }
    NetpAssert( GmtTime != 0 );
    NetpAssert( GmtTime != (time_t) (-1) );

    //
    // Alloc area for converted time of day info.
    // API's caller will free this with NetApiBufferFree().
    //
    ApiStatus = NetApiBufferAllocate(
            sizeof(TIME_OF_DAY_INFO),
            (LPVOID *) (LPVOID) & pGmtTod );
    if (ApiStatus != NO_ERROR) {
        NetpAssert( pGmtTod == NULL );
        goto Cleanup;
    }
    NetpAssert( pGmtTod != NULL );

    //
    // Convert LocalTod fields to UTC timezone and set pGmtTod fields.
    // This depends on the POSIX semantics of gmtime().
    //
    pGmtTm = gmtime( (time_t *) &(GmtTime) );
    if (pGmtTm == NULL) {
        // UTC not available?  How can this happen?
        NetpKdPrint(( PREFIX_NETAPI
                "RxNetRemoteTOD: gmtime() failed!.\n" ));
        ApiStatus = NERR_InternalError;
        goto Cleanup;
    }

    pGmtTod->tod_elapsedt  = (DWORD) GmtTime;
    pGmtTod->tod_msecs     = LocalTod.tod_msecs;
    pGmtTod->tod_hours     = pGmtTm->tm_hour;
    pGmtTod->tod_mins      = pGmtTm->tm_min;
    if (pGmtTm->tm_sec <= 59) {
        // Normal.
        pGmtTod->tod_secs  = pGmtTm->tm_sec;
    } else {
        // Leap second.  Lie and say that it's not.  This will avoid possible
        // range problems in apps that only expect 0..59, as the
        // TIME_OF_DAY_INFO struct is documented in LM 2.x.
        pGmtTod->tod_secs  = 59;
    }
    pGmtTod->tod_hunds     = LocalTod.tod_hunds;
    pGmtTod->tod_tinterval = LocalTod.tod_tinterval;
    pGmtTod->tod_day       = pGmtTm->tm_mday;
    pGmtTod->tod_month     = pGmtTm->tm_mon + 1;    // month (0..11) to (1..12)
    pGmtTod->tod_year      = pGmtTm->tm_year + 1900;
    pGmtTod->tod_weekday   = pGmtTm->tm_wday;
    pGmtTod->tod_timezone  = timezone;

    IF_DEBUG(REMUTL) {
        NetpKdPrint(( PREFIX_NETAPI
                "RxNetRemoteTOD: after convert, buffer:\n"));
        NetpDbgDisplayTod( "after GMT conv", pGmtTod );
    }


Cleanup:

    if (ApiStatus == NO_ERROR) {
        *BufPtr = (LPBYTE) (LPVOID) pGmtTod;
    } else if (pGmtTod != NULL) {
        (VOID) NetApiBufferFree( pGmtTod );
    }

    return (ApiStatus);

} // RxNetRemoteTOD
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\rpcxlate\rxapi\wksgtinf.c ===
/*++

Copyright (c) 1991-92  Microsoft Corporation

Module Name:

    WksGtInf.c

Abstract:

    This file contains the RpcXlate code to handle the NetWkstaGetInfo API.

Author:

    John Rogers (JohnRo) 15-Aug-1991

Environment:

    Portable to any flat, 32-bit environment.  (Uses Win32 typedefs.)
    Requires ANSI C extensions: slash-slash comments, long external names.

Revision History:

    15-Aug-1991 JohnRo
        Implement downlevel NetWksta APIs.
    11-Nov-1991 JohnRo
        Moved most of the code from here to WksGtOld.c for sharing with
        RxNetWkstaUserEnum().
    21-Nov-1991 JohnRo
        Removed NT dependencies to reduce recompiles.
    07-Feb-1992 JohnRo
        Use NetApiBufferAllocate() instead of private version.

--*/

// These must be included first:

#include <windef.h>             // IN, DWORD, etc.
#include <lmcons.h>             // LM20_ equates, NET_API_STATUS, etc.
#include <rap.h>                // Needed by <strucinf.h>.

// These may be included in any order:

#include <dlwksta.h>            // NetpIsNewWkstaInfoLevel().
#include <lmapibuf.h>           // NetApiBufferAllocate(), NetApiBufferFree().
#include <lmerr.h>              // ERROR_ and NERR_ equates.
#include <netdebug.h>           // DBGSTATIC, NetpKdPrint(()), FORMAT_ equates.
#include <rxpdebug.h>           // IF_DEBUG().
#include <rxwksta.h>            // My prototypes, RxpGetWkstaInfoLevelEquivalent
#include <strucinf.h>           // NetpWkstaStructureInfo().



NET_API_STATUS
RxNetWkstaGetInfo (
    IN LPTSTR UncServerName,
    IN DWORD Level,
    OUT LPBYTE *BufPtr
    )

/*++

Routine Description:

    RxNetWkstaGetInfo performs the same function as NetWkstaGetInfo, except
    that the server name is known to refer to a downlevel server.

Arguments:

    (Same as NetWkstaGetInfo, except UncServerName must not be null, and
    must not refer to the local computer.)

Return Value:

    (Same as NetWkstaGetInfo.)

--*/

{

    LPBYTE NewApiBuffer32;              // Buffer to be returned to caller.
    DWORD NewApiBufferSize32;
    DWORD NewFixedSize;
    DWORD NewStringSize;
    LPBYTE OldApiBuffer32 = NULL;       // Buffer from remote system.
    DWORD OldLevel;
    NET_API_STATUS Status;

    IF_DEBUG(WKSTA) {
        NetpKdPrint(("RxNetWkstaGetInfo: starting, server=" FORMAT_LPTSTR
                ", lvl=" FORMAT_DWORD ".\n", UncServerName, Level));
    }

    //
    // Error check DLL stub and the app.
    //
    NetpAssert(UncServerName != NULL);
    if ( !NetpIsNewWkstaInfoLevel( Level )) {
        return (ERROR_INVALID_LEVEL);
    }
    if (BufPtr == NULL) {
        return (ERROR_INVALID_PARAMETER);
    }
    *BufPtr = NULL;  // assume error; it makes error handlers easy to code.
    // This also forces possible GP fault before we allocate memory.

    //
    // Caller must have given us a new info level.  Find matching old level.
    //
    Status = RxpGetWkstaInfoLevelEquivalent(
            Level,                      // from level
            & OldLevel,                 // to level
            NULL                        // don't care we have incomplete info
            );
    if (Status != NERR_Success) {
        return (Status);
    }

    //
    // Learn about new info level.
    //
    Status = NetpWkstaStructureInfo (
            Level,                      // level to learn about
            PARMNUM_ALL,                // No parmnum with this.
            TRUE,                       // Need native sizes.
            NULL,                       // don't need data desc16 for new level
            NULL,                       // don't need data desc32 for new level
            NULL,                       // don't need data descSMB for new level
            & NewApiBufferSize32,       // max buffer size (native)
            & NewFixedSize,             // fixed size.
            & NewStringSize             // string size.
            );
    if (Status != NERR_Success) {
        return (Status);
    }

    //
    // Actually remote the API, which will get back the (old) info level
    // data in native format.
    //
    Status = RxpWkstaGetOldInfo (
            UncServerName,
            OldLevel,
            (LPBYTE *) & OldApiBuffer32);       // alloc buffer and set ptr

    NetpAssert( Status != ERROR_MORE_DATA );
    NetpAssert( Status != NERR_BufTooSmall );

    if (Status == NERR_Success) {
        // Allocate memory for 32-bit version of new info, which we'll return to
        // caller.  (Caller must free it with NetApiBufferFree.)
        Status = NetApiBufferAllocate(
                NewApiBufferSize32,
                (LPVOID *) & NewApiBuffer32);
        if (Status != NERR_Success) {
            if ( OldApiBuffer32 != NULL ) {
                (void) NetApiBufferFree( OldApiBuffer32 );
            }
            return (Status);
        }
        IF_DEBUG(WKSTA) {
            NetpKdPrint(( "RxNetWkstaGetInfo: allocated new buffer at "
                    FORMAT_LPVOID "\n", (LPVOID) NewApiBuffer32 ));
        }

        //
        // Copy/convert data from OldApiBuffer32 to NewApiBuffer32.
        //
        Status = NetpConvertWkstaInfo (
                OldLevel,               // from level
                OldApiBuffer32,         // FromInfo,
                TRUE,                   // from native format
                Level,                  // ToLevel,
                NewApiBuffer32,         // ToInfo,
                NewFixedSize,           // ToFixedLength,
                NewStringSize,          // ToStringLength,
                TRUE,                   // to native format
                NULL                    // don't need string area top
                );
        NetpAssert(Status == NERR_Success);

        *BufPtr = NewApiBuffer32;
    }

    if ( OldApiBuffer32 != NULL ) {
        (void) NetApiBufferFree( OldApiBuffer32 );
    }

    return (Status);

} // RxNetWkstaGetInfo
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\rpcxlate\rxapi\wksstinf.c ===
/*++

Copyright (c) 1991-92  Microsoft Corporation

Module Name:

    WksStInf.c

Abstract:

    This module only contains RxNetWkstaSetInfo.

Author:

    John Rogers (JohnRo) 19-Aug-1991

Environment:

    Portable to any flat, 32-bit environment.  (Uses Win32 typedefs.)
    Requires ANSI C extensions: slash-slash comments, long external names.

Revision History:

    19-Aug-1991 JohnRo
        Implement downlevel NetWksta APIs.
    21-Nov-1991 JohnRo
        Removed NT dependencies to reduce recompiles.
    07-Feb-1992 JohnRo
        Use NetApiBufferAllocate() instead of private version.
    02-Apr-1992 JohnRo
        Fixed bug in setinfo of level 402 (was causing GP fault in strlen).
    03-Nov-1992 JohnRo
        RAID 10418: NetWkstaGetInfo level 302: wrong error code.
        Use PREFIX_ equates.

--*/


// These must be included first:

#include <windef.h>     // IN, DWORD, etc.
#include <lmcons.h>
#include <rap.h>        // LPDESC, etc.  (Needed by <rxwksta.h>)

// These may be included in any order:

#include <apinums.h>    // API_ equates.
#include <dlwksta.h>    // NetpConvertWkstaInfo().
#include <lmapibuf.h>   // NetApiBufferAllocate(), NetApiBufferFree().
#include <lmerr.h>      // NERR_ and ERROR_ equates.
#include <lmwksta.h>    // Wksta parmnum equates.
#include <netdebug.h>   // NetpAssert(), FORMAT_ equates, etc.
#include <netlib.h>     // NetpSetParmError().
#include <prefix.h>     // PREFIX_ equates.
#include <remdef.h>
#include <rx.h>         // RxRemoteApi().
#include <rxp.h>        // RxpSetField().
#include <rxpdebug.h>   // IF_DEBUG().
#include <rxwksta.h>    // My prototype, etc.
#include <strucinf.h>   // NetpWkstaStructureInfo().


NET_API_STATUS
RxNetWkstaSetInfo (
    IN LPTSTR UncServerName,
    IN DWORD Level,             // New style level or parmnum.
    IN LPBYTE Buf,
    OUT LPDWORD ParmError OPTIONAL  // name required by NetpSetParmError macro.
    )

/*++

Routine Description:

    RxNetWkstaSetInfo performs the same function as NetWkstaSetInfo,
    except that the server name is known to refer to a downlevel server.

Arguments:

    (Same as NetWkstaSetInfo, except UncServerName must not be null, and
    must not refer to the local computer.)

Return Value:

    (Same as NetWkstaSetInfo.)

--*/
{
    BOOL IncompleteOutput;
    LPDESC EquivDataDesc16;
    LPDESC EquivDataDesc32;
    LPDESC EquivDataDescSmb;
    DWORD EquivLevel;
    DWORD EquivFixedSize;
    DWORD EquivMaxNativeSize;
    DWORD EquivStringSize;
    DWORD NewLevelOnly;
    NET_API_STATUS Status;

    // It's easiest to assume failure, and correct that assumption later.
    NetpSetParmError( PARM_ERROR_UNKNOWN );

    NetpAssert(UncServerName != NULL);
    if (Level > PARMNUM_BASE_INFOLEVEL) {
        NewLevelOnly = 402;             // Only settable (new) level.
    } else if (Level == PARMNUM_BASE_INFOLEVEL) {
        return (ERROR_INVALID_LEVEL);
    } else {
        NewLevelOnly = Level;
    }
    if (NewLevelOnly != 402) {
        return (ERROR_INVALID_LEVEL);
    }

    //
    // Need lots of data on the requested info level and the equivalent
    // old info level...
    //
    Status = RxpGetWkstaInfoLevelEquivalent(
            NewLevelOnly,               // from level
            & EquivLevel,               // to level
            & IncompleteOutput);        // is output not fully in input?
    NetpAssert(Status == NERR_Success); // Already checked NewLevelOnly!
    NetpAssert( NetpIsOldWkstaInfoLevel( EquivLevel ) );

    Status = NetpWkstaStructureInfo (
            EquivLevel,
            PARMNUM_ALL,
            TRUE,                       // want native sizes
            & EquivDataDesc16,
            & EquivDataDesc32,
            & EquivDataDescSmb,
            & EquivMaxNativeSize,       // max native size of to level
            & EquivFixedSize,           // to fixed size
            & EquivStringSize);         // to string size
    NetpAssert(Status == NERR_Success); // Already checked NewLevelOnly!


    //
    // Depending on Level, either we're setting the entire thing, or just
    // one field.
    //
    if ( Level < PARMNUM_BASE_INFOLEVEL ) {     // Setting entire structure.

        LPWKSTA_INFO_1 Dest;
        LPVOID EquivInfo;               // Ptr to native "old" info.
        DWORD EquivActualSize32;
        LPWKSTA_INFO_402 Src;

        if ( Buf == NULL )
            return ERROR_INVALID_PARAMETER;

        NetpAssert( IncompleteOutput == FALSE );
        NetpAssert( NewLevelOnly == 402 );     // Assumed below.
        NetpAssert( EquivLevel == 1 );  // Assumed below.

        // Have all the data we need, so alloc memory for conversion.
        Status = NetApiBufferAllocate( EquivMaxNativeSize, & EquivInfo );
        if (Status != NERR_Success) {
            return (Status);
        }
        Dest = EquivInfo;
        Src = (LPVOID) Buf;

        // Convert caller's Wksta info to an info level understood by
        // downlevel.
        //
        // Note that this code takes advantage of the fact that a downlevel
        // server doesn't really set all of the fields just because we send
        // an entire structure.  The server just sets the settable fields
        // from that structure.  And the settable fields are defined by
        // the parmnums we can set.  So, we don't bother copying all of
        // the fields here.  (DanHi says this is OK.)  --JohnRo 26-May-1991
        //
        // Also, when we do strings like this, we just point from one buffer
        // to the other buffer.
        //
        Dest->wki1_charwait      = Src->wki402_char_wait;
        Dest->wki1_chartime      = Src->wki402_collection_time;
        Dest->wki1_charcount     = Src->wki402_maximum_collection_count;
        Dest->wki1_errlogsz      = Src->wki402_errlog_sz;
        Dest->wki1_printbuftime  = Src->wki402_print_buf_time;
        Dest->wki1_wrkheuristics = Src->wki402_wrk_heuristics;

        //
        // Just 'cos we're paranoid, let's set any "nonsettable" pointers to
        // NULL so RapConvertSingleEntry (for instance) doesn't GP fault.
        //
        Dest->wki1_root         = NULL;
        Dest->wki1_computername = NULL;
        Dest->wki1_username     = NULL;
        Dest->wki1_langroup     = NULL;
        Dest->wki1_logon_server = NULL;
        Dest->wki1_logon_domain = NULL;
        Dest->wki1_oth_domains  = NULL;

        NetpAssert( EquivInfo != NULL );
        EquivActualSize32 = RapTotalSize(
                EquivInfo,              // in struct
                EquivDataDesc32,        // in desc
                EquivDataDesc32,        // out desc
                FALSE,                  // no meaningless input ptrs
                Both,                   // transmission mode
                NativeToNative);        // conversion mode
        IF_DEBUG(WKSTA) {
            NetpKdPrint(( PREFIX_NETAPI
                    "RxNetWkstaSetInfo(all): equiv actual size (32) is "
                    FORMAT_DWORD ".\n", EquivActualSize32 ));
        }
        NetpAssert( EquivActualSize32 <= EquivMaxNativeSize );

        //
        // Remote the API to set the entire structure.
        //
        Status = RxRemoteApi(
                API_WWkstaSetInfo,      // api num
                UncServerName,
                REMSmb_NetWkstaSetInfo_P,       // parm desc (SMB version)
                EquivDataDesc16,
                EquivDataDesc32,
                EquivDataDescSmb,
                NULL,                   // no aux desc 16
                NULL,                   // no aux desc 32
                NULL,                   // no aux desc SMB
                FALSE,                  // not a null perm req API
                // rest of API's arguments in 32-bit, native, LM 2.x format:
                EquivLevel,
                EquivInfo,
                EquivActualSize32,
                (DWORD) PARMNUM_ALL);

        (void) NetApiBufferFree( EquivInfo );

        if (Status == NERR_Success) {
            NetpSetParmError(PARM_ERROR_NONE);
        } else {
            NetpSetParmError(PARM_ERROR_UNKNOWN);
        }

    } else {
        //
        // Just setting one field.
        //
        DWORD ParmNum = Level - PARMNUM_BASE_INFOLEVEL;

        NetpAssert( ParmNum > 0 );
        NetpAssert( ParmNum < 100 );
        NetpAssert( EquivLevel == 1 );  // Need level 1 for oth_domains.

        // ParmNum indicates only one field, so set it.
        Status = RxpSetField(
                API_WWkstaSetInfo,              // api number
                UncServerName,
                NULL,                           // no specific object (dest)
                NULL,                           // no specific object to set
                REMSmb_NetWkstaSetInfo_P,       // parm desc (SMB version)
                EquivDataDesc16,                // data desc 16
                EquivDataDesc32,                // data desc 32
                EquivDataDescSmb,               // data desc SMB version
                Buf,                            // native (old) info buffer
                ParmNum,                        // parm num to send
                ParmNum,                        // field index (same)
                EquivLevel);                    // old info level

        if (Status == ERROR_INVALID_PARAMETER) {
            NetpAssert( Level > PARMNUM_BASE_INFOLEVEL );
            NetpSetParmError(Level);
        }
    }

    return (Status);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\rpcxlate\rxapi\use.c ===
/*++

Copyright (c) 1991-1993  Microsoft Corporation

Module Name:

    Use.c

Abstract:

    This file contains the RpcXlate code to handle the NetUse APIs that can't
    be handled by simple calls to RxRemoteApi.

Author:

    John Rogers (JohnRo) 17-Jun-1991

Environment:

    Portable to any flat, 32-bit environment.  (Uses Win32 typedefs.)
    Requires ANSI C extensions: slash-slash comments, long external names.

Revision History:

    17-Jun-1991 JohnRo
        Created.
    18-Jun-1991 JohnRo
        Changed RxNetUse routines to use LPBYTE rather than LPVOID parameters,
        for consistency with NetUse routines.
    20-Jun-1991 JohnRo
        RitaW told me about a MIPS build error (incorrect cast).
    29-Jul-1991 JohnRo
        Level 2 is NT only, so return ERROR_NOT_SUPPORTED for it.  Also use
        LM20_ equates for lengths.
    15-Oct-1991 JohnRo
        Be paranoid about possible infinite loop.
    21-Nov-1991 JohnRo
        Removed NT dependencies to reduce recompiles.
    07-Feb-1992 JohnRo
        Use NetApiBufferAllocate() instead of private version.
    02-Sep-1992 JohnRo
        RAID 5150: NetUseAdd to downlevel fails.
        Use PREFIX_ equates.
        Quiet normal debug output.
        Avoid compiler warnings.
    27-Jan-1993 JohnRo
        RAID 8926: NetConnectionEnum to downlevel: memory leak on error.
        Also set buffer pointer to NULL if success but no entries returned.
        Use NetpKdPrint() where possible.

--*/

// These must be included first:

#include <windef.h>             // IN, DWORD, etc.
#include <lmcons.h>             // LM20_ equates, NET_API_STATUS, etc.

// These may be included in any order:

#include <apinums.h>            // API_ equates.
#include <lmapibuf.h>           // NetApiBufferAllocate().
#include <lmerr.h>              // ERROR_ and NERR_ equates.
#include <lmuse.h>              // USE_INFO_0, etc.
#include <netdebug.h>   // DBGSTATIC, NetpKdPrint(), FORMAT_ equates.
#include <netlib.h>             // NetpSetParmError().
#include <prefix.h>     // PREFIX_ equates.
#include <rap.h>                // LPDESC.
#include <remdef.h>             // REM16_, REM32_, REMSmb_ equates.
#include <rx.h>                 // RxRemoteApi().
#include <rxp.h>                // RxpFatalErrorCode().
#include <rxpdebug.h>   // IF_DEBUG().
#include <rxuse.h>              // My prototypes.


#define MAX_USE_INFO_0_STRING_LEN \
        (LM20_DEVLEN+1 + MAX_PATH+1)
#define MAX_USE_INFO_1_STRING_LEN \
        (MAX_USE_INFO_0_STRING_LEN + LM20_PWLEN+1)

#define MAX_USE_INFO_0_STRING_SIZE \
        ( MAX_USE_INFO_0_STRING_LEN * sizeof(TCHAR) )
#define MAX_USE_INFO_1_STRING_SIZE \
        ( MAX_USE_INFO_1_STRING_LEN * sizeof(TCHAR) )


#define ENUM_ARRAY_OVERHEAD_SIZE     0



DBGSTATIC NET_API_STATUS
RxpGetUseDataDescs(
    IN DWORD Level,
    OUT LPDESC * DataDesc16,
    OUT LPDESC * DataDesc32,
    OUT LPDESC * DataDescSmb,
    OUT LPDWORD ApiBufferSize32 OPTIONAL
    )
{
    switch (Level) {
    case 0 : 
        *DataDesc16 = REM16_use_info_0;
        *DataDesc32 = REM32_use_info_0;
        *DataDescSmb = REMSmb_use_info_0;
        NetpSetOptionalArg(
                ApiBufferSize32,
                sizeof(USE_INFO_0) + MAX_USE_INFO_0_STRING_SIZE);
        return (NERR_Success);

    case 1 : 
        *DataDesc16 = REM16_use_info_1;
        *DataDesc32 = REM32_use_info_1;
        *DataDescSmb = REMSmb_use_info_1;
        NetpSetOptionalArg(
                ApiBufferSize32,
                sizeof(USE_INFO_1) + MAX_USE_INFO_1_STRING_SIZE);
        return (NERR_Success);
    
    // Level 2 is NT-only (contains user name), so it doesn't get handled
    // by us.
    case 2 :
        return (ERROR_NOT_SUPPORTED);

    default :
        return (ERROR_INVALID_LEVEL);
    }
    /* NOTREACHED */

} // RxpGetUseDataDescs




NET_API_STATUS
RxNetUseAdd(
    IN LPTSTR UncServerName,
    IN DWORD Level,
    IN LPBYTE UseInfoStruct,
    OUT LPDWORD ParmError OPTIONAL   // (This name needed by NetpSetParmError.)
    )

/*++

Routine Description:

    RxNetUseAdd performs the same function as NetUseAdd, except that the
    server name is known to refer to a downlevel server.

Arguments:

    (Same as NetUseAdd, except UncServerName must not be null, and must not
    refer to the local computer.)

Return Value:

    (Same as NetUseAdd.)

--*/

{
    LPDESC DataDesc16, DataDesc32, DataDescSmb;
    DWORD MaxEntrySize;
    NET_API_STATUS Status;

    // Life is easier if we set this for failure, and change it if this API
    // call actually succeeds.
    NetpSetParmError( PARM_ERROR_UNKNOWN );

    if ( UseInfoStruct == NULL )
        return ERROR_INVALID_PARAMETER;

    Status = RxpGetUseDataDescs(
            Level,
            & DataDesc16,
            & DataDesc32,
            & DataDescSmb,
            & MaxEntrySize);            // API buffer size 32
    if (Status != NERR_Success) {
        return (Status);
    }

    NetpAssert(UncServerName != NULL);
    Status = RxRemoteApi(
        API_WUseAdd,  // API number
        UncServerName,                    // Required, with \\name.
        REMSmb_NetUseAdd_P,  // parm desc string
        DataDesc16,
        DataDesc32,
        DataDescSmb,
        NULL,  // no aux desc 16
        NULL,  // no aux desc 32
        NULL,  // no aux desc Smb
        FALSE, // not a null session API.
        // rest of API's arguments, in 32-bit LM 2.x form:
        Level,                  // sLevel
        UseInfoStruct,          // pbBuffer
        MaxEntrySize );         // cbBuffer

    if (Status == NERR_Success) {
        NetpSetParmError( PARM_ERROR_NONE );
    }

    IF_DEBUG( USE ) {
        NetpKdPrint(( PREFIX_NETAPI "RxNetUseAdd: after RxRemoteApi, Status="
                    FORMAT_API_STATUS ".\n", Status ));
    }

    return (Status);

} // RxNetUseAdd



NET_API_STATUS
RxNetUseDel(
    IN LPTSTR UncServerName,
    IN LPTSTR UseName,
    IN DWORD ForceCond
    )
{
    NetpAssert(UncServerName != NULL);
    return (RxRemoteApi(
            API_WUseDel,         // API number
            UncServerName,
            REMSmb_NetUseDel_P,  // parm desc
            NULL,  // no data desc 16
            NULL,  // no data desc 32
            NULL,  // no data desc SMB
            NULL,  // no aux desc 16
            NULL,  // no aux desc 32
            NULL,  // no aux desc SMB
            FALSE, // not a null session API
            // rest of API's arguments, in 32-bit LM 2.x format:
            UseName,
            ForceCond) );
}


NET_API_STATUS
RxNetUseEnum (
    IN LPTSTR UncServerName,
    IN DWORD Level,
    OUT LPBYTE *BufPtr,
    IN DWORD PreferedMaximumSize,
    OUT LPDWORD EntriesRead,
    OUT LPDWORD TotalEntries,
    IN OUT LPDWORD ResumeHandle OPTIONAL
    )

/*++

Routine Description:

    RxNetUseEnum performs the same function as NetUseEnum, except that the
    server name is known to refer to a downlevel server.

Arguments:

    (Same as NetUseEnum, except UncServerName must not be null, and must not
    refer to the local computer.)

Return Value:

    (Same as NetUseEnum.)

--*/

{
    LPDESC DataDesc16;
    LPDESC DataDesc32;
    LPDESC DataDescSmb;
    DWORD EntriesToAllocate;
    LPVOID InfoArray = NULL;
    DWORD InfoArraySize;
    DWORD MaxEntrySize;
    NET_API_STATUS Status;

    UNREFERENCED_PARAMETER(ResumeHandle);

    // Make sure caller didn't get confused.
    NetpAssert(UncServerName != NULL);
    if (BufPtr == NULL) {
        return (ERROR_INVALID_PARAMETER);
    }

    // Check for bad pointer before we do anything else.
    *BufPtr = NULL;

    Status = RxpGetUseDataDescs(
            Level,
            & DataDesc16,
            & DataDesc32,
            & DataDescSmb,
            & MaxEntrySize);            // API buffer size 32
    if (Status != NERR_Success) {
        return (Status);
    }

    //
    // Because downlevel servers don't support resume handles, and we don't
    // have a way to say "close this resume handle" even if we wanted to
    // emulate them here, we have to do everthing in one shot.  So, the first
    // time around, we'll try using the caller's prefered maximum, but we
    // will enlarge that until we can get everything in one buffer.
    //

    // First time: try caller's prefered maximum.
    NetpAdjustPreferedMaximum (
            PreferedMaximumSize,        // caller's request
            MaxEntrySize,               // byte count per array element
            ENUM_ARRAY_OVERHEAD_SIZE,   // num bytes overhead to show array end
            NULL,                       // we'll compute byte counts ourselves.
            & EntriesToAllocate);       // num of entries we can get.

    //
    // Loop until we have enough memory or we die for some other reason.
    //
    do {

        //
        // Figure out how much memory we need, within the protocol limit.
        //

        InfoArraySize = (EntriesToAllocate * MaxEntrySize)
                + ENUM_ARRAY_OVERHEAD_SIZE;

        if (InfoArraySize > MAX_TRANSACT_RET_DATA_SIZE) {
            InfoArraySize = MAX_TRANSACT_RET_DATA_SIZE;
        }

        //
        // Alloc memory for the array.
        //

        Status = NetApiBufferAllocate( InfoArraySize, & InfoArray );
        if (Status != NERR_Success) {
            return (Status);
        }

        //
        // Remote the API, and see if we've got enough space in the array.
        //

        Status = RxRemoteApi(
                API_WUseEnum,           // api number
                UncServerName,          // \\servername
                REMSmb_NetUseEnum_P,    // parm desc (SMB version)
                DataDesc16,
                DataDesc32,
                DataDescSmb,
                NULL,                   // no aux desc 16
                NULL,                   // no aux desc 32
                NULL,                   // no aux desc SMB
                0,                      // flags: normal
                // rest of API's arguments in 32-bit LM 2.x format:
                Level,                  // sLevel: info level
                InfoArray,              // pbBuffer: info lvl array
                InfoArraySize,          // cbBuffer: info lvl array len
                EntriesRead,            // pcEntriesRead
                TotalEntries);          // pcTotalAvail

        //
        // If the server returned ERROR_MORE_DATA, free the buffer and try
        // again.  (Actually, if we already tried 64K, then forget it.)
        //

        NetpAssert( InfoArraySize <= MAX_TRANSACT_RET_DATA_SIZE );
        if (Status != ERROR_MORE_DATA) {
            break;
        } else if (InfoArraySize == MAX_TRANSACT_RET_DATA_SIZE) {
            NetpKdPrint(( PREFIX_NETAPI
                    "RxNetUseEnum: "
                    "**WARNING** protocol limit reached (64KB).\n" ));
            break;
        }

        (void) NetApiBufferFree( InfoArray );
        InfoArray = NULL;
        NetpAssert( EntriesToAllocate < *TotalEntries );
        EntriesToAllocate = *TotalEntries;

    } while (Status == ERROR_MORE_DATA);


    if ( (Status == NO_ERROR) && ((*EntriesRead) > 0) ) {
        *BufPtr = InfoArray;
    } else {
        (VOID) NetApiBufferFree( InfoArray );
        NetpAssert( *BufPtr == NULL );
    }

    return (Status);

} // RxNetUseEnum



NET_API_STATUS
RxNetUseGetInfo (
    IN LPTSTR UncServerName,
    IN LPTSTR UseName,
    IN DWORD Level,
    OUT LPBYTE *BufPtr
    )

/*++

Routine Description:

    RxNetUseGetInfo performs the same function as NetUseGetInfo, except that the
    server name is known to refer to a downlevel server.

Arguments:

    (Same as NetUseGetInfo, except UncServerName must not be null, and must not
    refer to the local computer.)

Return Value:

    (Same as NetUseGetInfo.)

--*/

{

    LPBYTE ApiBuffer32;                 // Buffer to be returned to caller.
    DWORD ApiBufferSize32;
    LPDESC DataDesc16, DataDesc32, DataDescSmb;
    NET_API_STATUS Status;
    DWORD TotalAvail;

    IF_DEBUG( USE ) {
        NetpKdPrint(( PREFIX_NETAPI
                "RxNetUseGetInfo: starting, server=" FORMAT_LPTSTR
                ", usename=" FORMAT_LPTSTR
                ", lvl=" FORMAT_DWORD ".\n",
                UncServerName, UseName, Level ));
    }
    NetpAssert(UncServerName != NULL);
    NetpAssert(UseName != NULL);

    // Pick which descriptors to use based on the info level.
    Status = RxpGetUseDataDescs(
            Level,
            & DataDesc16,
            & DataDesc32,
            & DataDescSmb,
            & ApiBufferSize32);
    if (Status != NERR_Success) {
        return (Status);
    }

    // Allocate memory for 32-bit version of info, which we'll return to
    // caller.  (Caller must free it with NetApiBufferFree.)
    Status = NetApiBufferAllocate(
            ApiBufferSize32,
            (LPVOID *) & ApiBuffer32);
    if (Status != NERR_Success) {
        return (Status);
    }
    IF_DEBUG( USE ) {
        NetpKdPrint(( PREFIX_NETAPI
                "RxNetUseGetInfo: allocated buffer at " FORMAT_LPVOID
                "\n", (LPVOID) ApiBuffer32 ));
    }
    *BufPtr = ApiBuffer32;

    Status = RxRemoteApi(
            API_WUseGetInfo,            // API number
            UncServerName,              // Required, with \\name.
            REMSmb_NetUseGetInfo_P,     // parm desc
            DataDesc16,
            DataDesc32,
            DataDescSmb,
            NULL,                       // no aux data desc 16
            NULL,                       // no aux data desc 32
            NULL,                       // no aux data desc SMB
            FALSE,                      // not a null session API
            // rest of API's arguments, in 32-bit LM 2.x format:
            UseName,
            Level,
            ApiBuffer32,
            ApiBufferSize32,
            & TotalAvail);

    return (Status);

} // RxNetUseGetInfo
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\rpcxlate\rxapi\wksgtold.c ===
/*++

Copyright (c) 1991-1992  Microsoft Corporation

Module Name:

    WksGtOld.c

Abstract:

    This file contains RxpWkstaGetOldInfo().

Author:

    John Rogers (JohnRo) 15-Aug-1991

Environment:

    Portable to any flat, 32-bit environment.  (Uses Win32 typedefs.)
    Requires ANSI C extensions: slash-slash comments, long external names.

Revision History:

    15-Aug-1991 JohnRo
        Implement downlevel NetWksta APIs.
    11-Nov-1991 JohnRo
        Moved some code from RxNetWkstaGetInfo to RxpWkstaGetOldInfo, so it
        can be shared by RxNetWkstaUserEnum.
    22-May-1992 JohnRo
        RAID 7243: Avoid 64KB requests (Winball servers only HAVE 64KB!)
        Use PREFIX_ equates.

--*/

// These must be included first:

#include <windef.h>     // IN, DWORD, etc.
#include <lmcons.h>     // LM20_ equates, NET_API_STATUS, etc.

// These may be included in any order:

#include <apinums.h>    // API_ equates.
#include <dlwksta.h>    // NetpIsOldWkstaInfoLevel().
#include <lmerr.h>      // ERROR_ and NERR_ equates.
#include <netdebug.h>   // DBGSTATIC, NetpKdPrint(()), FORMAT_ equates.
#include <prefix.h>     // PREFIX_ equates.
#include <rap.h>        // LPDESC.
#include <remdef.h>     // REM16_, REM32_, REMSmb_ equates.
#include <rx.h>         // RxRemoteApi().
#include <rxpdebug.h>   // IF_DEBUG().
#include <rxwksta.h>    // My prototype.
#include <strucinf.h>   // NetpWkstaStructureInfo().



NET_API_STATUS
RxpWkstaGetOldInfo (
    IN LPTSTR UncServerName,
    IN DWORD Level,
    OUT LPBYTE *BufPtr
    )

/*++

Routine Description:

    RxpWkstaGetOldInfo does a WkstaGetInfo to a downlevel server for an
    old info level.

Arguments:

    (Same as NetWkstaGetInfo, except UncServerName must not be null, and
    must not refer to the local computer.)

Return Value:

    (Same as NetWkstaGetInfo.)

--*/

{
    DWORD BufSize;
    LPDESC DataDesc16, DataDesc32, DataDescSmb;
    NET_API_STATUS Status;
    DWORD TotalAvail;

    IF_DEBUG(WKSTA) {
        NetpKdPrint(( PREFIX_NETAPI "RxpWkstaGetOldInfo: starting, server="
                FORMAT_LPTSTR ", lvl=" FORMAT_DWORD ".\n",
                UncServerName, Level));
    }

    //
    // Error check caller.
    //
    NetpAssert(UncServerName != NULL);
    if ( !NetpIsOldWkstaInfoLevel( Level )) {
        return (ERROR_INVALID_LEVEL);
    }
    if (BufPtr == NULL) {
        return (ERROR_INVALID_PARAMETER);
    }
    *BufPtr = NULL;  // assume error; it makes error handlers easy to code.
    // This also forces possible GP fault before we allocate memory.

    //
    // Learn about info level.
    //
    Status = NetpWkstaStructureInfo (
            Level,                      // level to learn about
            PARMNUM_ALL,                // No parmnum with this.
            TRUE,                       // Need native sizes.
            & DataDesc16,
            & DataDesc32,
            & DataDescSmb,
            & BufSize,                  // max buffer size
            NULL,                       // don't need fixed size.
            NULL                        // don't need string size.
            );
    if (Status != NERR_Success) {
        return (Status);
    }

    //
    // Actually remote the API, which will get back the (old) info level
    // data in native format.
    //
    Status = RxRemoteApi(
            API_WWkstaGetInfo,          // API number
            UncServerName,              // Required, with \\name.
            REMSmb_NetWkstaGetInfo_P,   // parm desc
            DataDesc16,
            DataDesc32,
            DataDescSmb,
            NULL,                       // no aux data desc 16
            NULL,                       // no aux data desc 32
            NULL,                       // no aux data desc SMB
            ALLOCATE_RESPONSE,          // flags: alloc buffer for us.
            // rest of API's arguments, in 32-bit LM 2.x format:
            Level,
            BufPtr,                     // alloc buffer & set this ptr
            BufSize,
            & TotalAvail);              // total size 

    NetpAssert( Status != ERROR_MORE_DATA );
    NetpAssert( Status != NERR_BufTooSmall );

    return (Status);

} // RxpWkstaGetOldInfo
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\rpcxlate\rxcommon\data.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    Data.c

Abstract:

    Global data for RpcXlate routines.  (Debug only, so no security problems.)

Author:

    John Rogers (JohnRo) 03-Apr-1991

Environment:

    Portable to any flat, 32-bit environment.  (Uses Win32 typedefs.)
    Requires ANSI C extensions: slash-slash comments, long external names.

Revision History:

    03-Apr-1991 JohnRo
        Created.
    17-Jul-1991 JohnRo
        Extracted RxpDebug.h from Rxp.h.

--*/


#include <rxpdebug.h>           // DWORD, extern for RxpTrace.

DWORD RxpTrace = 0;

// That's all, folks!
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\rpcxlate\rxcommon\convargs.c ===
/*++

Copyright (c) 1987-1993  Microsoft Corporation

Module Name:

    ConvArgs.c

Abstract:

    This module just contains RxpConvertArgs, which is a "captive" subroutine
    of RxRemoteApi.

Author:

    John Rogers (JohnRo) and a cast of thousands.

Environment:

    Portable to any flat, 32-bit environment.  (Uses Win32 typedefs.)
    Requires ANSI C extensions: slash-slash comments, long external names.

Revision History:

    01-Apr-1991 JohnRo
        Created portable LanMan (NT) version from LanMan 2.x.
    03-May-1991 JohnRo
        Clarify that RcvData items are application's, and are 32-bit format.
        Fixed bug where aux data caused null pointer fault.
        Fixed total avail bytes count bug.
        RcvDataPtrPtr and RcvDataPresent are redundant.
        More assertion checking.
        Quiet debug output.
        Reduced recompile hits from header files.
    14-May-1991 JohnRo
        Need different kinds of data and aux descriptors.
        Use FORMAT_LPVOID instead of FORMAT_POINTER (max portability).
    05-Jun-1991 JohnRo
        Call RapConvertSingleEntry on send data (for setinfo APIs).
        Caller needs SendDataPtr and SendDataSize.
        Don't set StructSize too small (also, it's really FixedStructSize16).
        Show status when various things fail.
        Use PARMNUM_ALL equate.
        Changed to use CliffV's naming conventions (size=byte count).
        Return better error codes.
    13-Jun-1991 JohnRo
        Must call RxpPackSendBuffer after all.  (This fixes server set info
        for level 102.)  Need DataDesc16 and AuxDesc16 for that purpose.
        Also, RxpConvertSingleEntry needs to set ptrs (not offsets) for
        use by RxpPackSendBuffer.
    15-Jul-1991 JohnRo
        Changed RxpConvertDataStructures to allow ERROR_MORE_DATA, e.g. for
        print APIs.
    17-Jul-1991 JohnRo
        Extracted RxpDebug.h from Rxp.h.
    18-Jul-1991 RFirth
        SetInfo calls pass in 2 parmnums welded into a single DWORD - parmnum
        proper (which gets transmitted to down-level server) and field-index
        which RapParmNumDescriptor uses to get the type and size of the field
        that ParmNum indicates
    15-Aug-1991 JohnRo
        PC-LINT found a bug calling RxpAuxDataCount().  Changed tabs to spaces.
    19-Aug-1991 rfirth
        Added Flags parameter
    30-Sep-1991 JohnRo
        Handle REM_FILL_BYTES correctly so RxNetServiceInstall() works.
        Provide debug output indicating cause of ERROR_INVALID_PARAMETER.
        Handle possible UNICODE (LPTSTR) for REM_ASCIZ.
        Allow descriptors to be UNICODE someday.
        DBG is always defined.
    21-Nov-1991 JohnRo
        Removed NT dependencies to reduce recompiles.
    31-Mar-1992 JohnRo
        Prevent too large size requests.
    10-Dec-1992 JohnRo
        Made changes suggested by PC-LINT 5.0
    18-May-1993 JohnRo
        DosPrintQGetInfoW underestimates number of bytes needed.
        Made more changes suggested by PC-LINT 5.0
    27-May-1993 JimKel and JohnRo
        RAID 11758: Wrong error code for DosPrint APIs with NULL buffer pointer.

--*/


// These must be included first:

#include <rxp.h>                // RpcXlate private header file.

// These may be included in any order:

#include <limits.h>             // CHAR_BIT.
#include <lmerr.h>              // NERR_ and ERROR_ equates.
#include <netdebug.h>           // NetpKdPrint(()), FORMAT_ equates, etc.
#include <netlib.h>             // NetpMoveMemory(), etc.
#include <prefix.h>     // PREFIX_ equates.
#include <remtypes.h>           // REM_BYTE, etc.
#include <rxpdebug.h>           // IF_DEBUG().
#include <smbgtpt.h>            // SmbPutUshort().
#include <tstring.h>            // NetpCopy routines, STRLEN().



//
// replace this with a call to RxpFieldSize, currently in setfield.c
//

DBGSTATIC
DWORD
RxpGetFieldSize(
    IN LPBYTE Field,
    IN LPDESC FieldDesc
    );

DBGSTATIC
LPDESC
RxpGetSetInfoDescriptor(
    IN  LPDESC  Descriptor,
    IN  DWORD   FieldIndex,
    IN  BOOL    Is32BitDesc
    );



NET_API_STATUS
RxpConvertArgs(
    IN LPDESC ParmDescriptorString,
    IN LPDESC DataDesc16 OPTIONAL,
    IN LPDESC DataDesc32 OPTIONAL,
    IN LPDESC DataDescSmb OPTIONAL,
    IN LPDESC AuxDesc16 OPTIONAL,
    IN LPDESC AuxDesc32 OPTIONAL,
    IN LPDESC AuxDescSmb OPTIONAL,
    IN DWORD MaximumInputBlockSize,
    IN DWORD MaximumOutputBlockSize,
    IN OUT LPDWORD CurrentInputBlockSizePtr,
    IN OUT LPDWORD CurrentOutputBlockSizePtr,
    IN OUT LPBYTE *CurrentOutputBlockPtrPtr,
    IN va_list *FirstArgumentPtr,       // rest of API's arguments (after
                                        // server name)
    OUT LPDWORD SendDataSizePtr16,
    OUT LPBYTE *SendDataPtrPtr16,
    OUT LPDWORD RcvDataSizePtr,
    OUT LPBYTE *RcvDataPtrPtr,
    IN  DWORD   Flags
    )

/*++

Routine Description:

    RxpConvertArgs is called to convert a set of arguments to a LanMan API
    from "stdargs" format (with 32-bit data) to the Remote Admin Protocol
    format (with 16-bit data).  This routine deals with an "output block"
    (a transact SMB request) and an "input block" (a transact SMB response).

    Note that this routine assumes that RxpStartBuildingTransaction has
    already been called, as has va_start.  This routine also assumes that
    the caller will invoke va_end.

    This routine further builds the parameter buffer, which was initiated by
    RxpStartBuildingTransaction. That routine left the parameter buffer in
    the following state:

        <api_num><parameter_descriptor_string><data_descriptor_string>

    This routine adds the parameters to the end of the parameter buffer as it
    scans the parameter list as passed to RxRemoteApi and then to this routine.
    If there is auxiliary data associated with the primary data structure
    (assuming there is a primary data structure), then the auxiliary data
    descriptor is added to the end of the parameter buffer. The parameter
    buffer will look either like this:

        <api_num><parm_desc><data_desc><parms>

    or this:

        <api_num><parm_desc><data_desc><parms><aux_desc>

    depending on whether an auxiliary count was present in data_desc (again, if
    there was one). If data is being sent down-level, then it is converted from
    native (32-bit) to down-level (16-bit) format. All primary data structures
    and associated data structures are packed into a buffer allocated in this
    routine and returned to the caller. Variable data (strings/arrays/etc.) is
    packed into the buffer in the reverse order to that in which it is
    encountered in the descriptor strings. The routine RxpPackSendBuffer must
    be called to sort out this situation - the down-level server expects the
    variable data in the same order as that in the descriptor strings.

    If the parameter string contains "sT" meaning the stack contains a pointer
    to a data buffer which is sent, followed by the length of the 16-bit data
    (a word) then the 'T' value is actually ignored. We calculate the amount
    of data to send based on the descriptors and the data in the buffer

    If the parameter string contains 'P' meaning the stack contains a parameter
    number, the size of the actual data for that parameter is calculated from
    the type of the corresponding field in the data descriptor


Arguments:

    ParmDescriptorString - A pointer to a ASCIIZ string describing the API
        call parameters (other than server name).  Note that this must be the
        descriptor string which is actually IN the block being built, as the
        string will be modified before it is sent to the remote system.

    DataDesc16, DataDesc32, DataDescSmb - pointers to ASCIIZ strings describing
        the structure of the data in the call, i.e. the return data structure
        for a Enum or GetInfo call.  This string is used for adjusting pointers
        to data in the local buffers after transfer across the net.  If there
        is no structure involved in the call then the data descriptors must be
        NULL pointers.

    AuxDesc16, AuxDesc32, AuxDescSmb - Will be NULL in most cases unless a
        REM_AUX_COUNT descriptor char is present in the data descriptors in
        which case the aux descriptors define a secondary data format as the
        data descriptors define the primary.

    MaximumInputBlockSize - Gives the total number of bytes allocated
        for the input block.

    MaximumOutputBlockSize - Gives the total number of bytes allocated
        for the output block.

    CurrentInputBlockSizePtr - Points to a DWORD which indicates the number
        of bytes needed for the input block so far.  This will be updated on
        exit from this routine.

    CurrentOutputBlockSizePtr - Points to a DWORD which indicates the number
        of bytes used in the output block so far.  This will be updated on exit
        from this routine.

    CurrentOutputBlockPtrPtr - Points to a pointer to the next free byte in
        the output block.  This pointer will be updated by this routine, to
        point to the byte after the last byte placed by this routine into the
        output block.

    FirstArgumentPtr - The remainder of the parameters for the API call as
        given by the application.  The server name is not included in these
        arguments.  These arguments will be processing using the ANSI
        <stdarg.h> macros.  The caller must have called va_start for this, and
        must call va_end for RxpConvertArgs.

    SendDataSizePtr16 - Points to a DWORD which will be set to the size in
        bytes of the area allocated at SendDataSizePtr16.

    SendDataPtrPtr16 - Points to an LPBYTE which will be set to point to
        a 16-bit version of the API's send buffer (or NULL if none is given).
        The caller must free this area after it has been used.

    RcvDataSizePtr - Points to a DWORD which will be set with the size of
        the receive buffer, if any.  (This buffer is in 32-bit format, and is
        specified by the application.)

    RcvDataPtrPtr - Points to an LPBYTE which will be set with the pointer to
        a receive buffer if one was specified in the API's arguments.  (For
        instance, this will point to the return area for a get-info call.)
        This is set to NULL if no receive buffer was specified.  The buffer
        is in 32-bit native format.

    Flags - bit-mapped flags word. Currently the only flag we are interested in
        in this routine is ALLOCATE_RESPONSE. If this is set then the caller
        wants RxRemoteApi to allocate the final returned data buffer. We need
        to know this because we either pass back in RcvDataPtrPtr the address
        of the callers buffer or the address of the address of the callers
        buffer (in which case the caller must give RxRemoteApi &buffer, not
        just buffer. Confused? You will be after this episode of sope)

Return Value:

    NET_API_STATUS.

--*/

{
    DWORD ArgumentSize;                 // Size of an argument (in bytes).
    DWORD AuxSize = 0;                  // Size of aux data struct.
    DWORD AuxOffset = 0;                // aux structure expected.
    va_list CurrentArgumentPtr;         // Pointer to stack parms.
    DWORD CurrentInputBlockSize;        // Length of expected parms.
    DWORD CurrentOutputBlockSize;       // Length of send parameters.
    LPBYTE CurrentOutputBlockPtr;       // Ptr moves as we put stuff in.
    LPDESC CurrentParmDescPtr;          // Used to index ParmDescriptorString.
    DWORD ParmNum;                      // Caller's value for ParmNum.
    BOOL ParmNumPresent;                // API has a ParmNum.
    BOOL SendDataPresent;               // Send buf ptr present flag.
    LPBYTE SendDataPtrNative;
    DWORD SendDataSizeNative;
    NET_API_STATUS Status;
    DESC_CHAR   parm_desc_16[MAX_DESC_SUBSTRING+1]; // 16-bit parameter descriptor for setinfo
    DESC_CHAR   parm_desc_32[MAX_DESC_SUBSTRING+1]; // 32-bit     "          "      "     "

    //
    // create aliases for *SendDataPtrPtr16 and *SendDataSizePtr16 to remove a
    // level of indirection every time we use these values
    //

    LPBYTE  pSendData;
    DWORD   SendSize;

    //
    // convertUnstructuredDataToString - if TRUE this means that the caller is
    // supplying unstructured data which is a UNICODE string. This must be
    // converted to ANSI (or OEM)
    //

    BOOL convertUnstructuredDataToString = FALSE;

    IF_DEBUG(CONVARGS) {
        NetpKdPrint(("RxpConvertArgs: parm desc='" FORMAT_LPDESC "',\n",
                ParmDescriptorString));

        if (DataDesc32 != NULL) {
            NetpKdPrint(("  Data desc 32='" FORMAT_LPDESC "',\n",
                    DataDesc32));
            NetpAssert(DataDesc16 != NULL);
            NetpAssert(DataDescSmb != NULL);
            if (DataDescSmb != NULL) {
                NetpKdPrint(("  Data desc (SMB)='" FORMAT_LPDESC "',\n",
                        DataDescSmb));
            }
        } else {
            NetpAssert(DataDesc16 == NULL);
            NetpAssert(DataDescSmb == NULL);
        }

        if (AuxDesc32 != NULL) {
            NetpKdPrint(("  Aux desc 32='" FORMAT_LPDESC "',\n",
                    AuxDesc32));
            NetpAssert(AuxDesc16 != NULL);
            NetpAssert(AuxDescSmb != NULL);
            if (AuxDescSmb != NULL) {
                NetpKdPrint(("  Aux desc (SMB)='" FORMAT_LPDESC "',\n",
                        AuxDescSmb));
            }
        } else {
            NetpAssert(AuxDesc16 == NULL);
            NetpAssert(AuxDescSmb == NULL);
        }

        NetpKdPrint(("  max inp blk len=" FORMAT_DWORD
                ", max outp blk len=" FORMAT_DWORD ",\n",
                MaximumInputBlockSize, MaximumOutputBlockSize));

        NetpKdPrint(("  curr inp blk len=" FORMAT_DWORD
                ", curr outp blk len=" FORMAT_DWORD ".\n",
                *CurrentInputBlockSizePtr, *CurrentOutputBlockSizePtr));

        NetpAssert( SendDataPtrPtr16 != NULL );
        NetpAssert( SendDataSizePtr16 != NULL );
    }

    //
    // Code in this file depends on 16-bit words; the Remote Admin Protocol
    // demands it.
    //

    NetpAssert( ( (sizeof(WORD)) * CHAR_BIT) == 16);

    //
    // Set found parameter flags to FALSE and pointers to NULL.
    //

    SendDataPresent = FALSE;
    ParmNum = PARMNUM_ALL;
    ParmNumPresent = FALSE;
    *RcvDataSizePtr = 0;
    *RcvDataPtrPtr = NULL;
    *SendDataSizePtr16 = 0;
    *SendDataPtrPtr16 = NULL;
    SendDataSizeNative = 0;
    SendDataPtrNative = NULL;

    CurrentArgumentPtr = *FirstArgumentPtr;
    CurrentInputBlockSize = *CurrentInputBlockSizePtr;
    CurrentOutputBlockPtr = *CurrentOutputBlockPtrPtr;
    CurrentOutputBlockSize = *CurrentOutputBlockSizePtr;


    //
    // Now loop for each parameter in the variable arg list.  We're going to
    // use the COPY of the descriptor here, as we may update it as we go.
    //

    CurrentParmDescPtr = ParmDescriptorString;
    for(; *CurrentParmDescPtr; CurrentParmDescPtr++) {

        IF_DEBUG(CONVARGS) {
            NetpKdPrint(("RxpConvertArgs: "
                    "desc at " FORMAT_LPVOID " (" FORMAT_DESC_CHAR ")\n",
                    (LPVOID) CurrentParmDescPtr, *CurrentParmDescPtr));
        }

        switch(*CurrentParmDescPtr) {

        case REM_WORD:          // Word (in 16-bit desc).
            {
                DWORD Temp;        // All "words" in 32-bit APIs are now dwords.
                CurrentOutputBlockSize += sizeof(WORD);
                if (CurrentOutputBlockSize > MaximumOutputBlockSize) {
                    return (NERR_NoRoom);
                }
                Temp = va_arg(CurrentArgumentPtr, DWORD);
                if (RapValueWouldBeTruncated(Temp)) {
                    NetpKdPrint(("RxpConvertArgs: WORD would be trunc'ed.\n"));
                    return (ERROR_INVALID_PARAMETER);   // Would be truncated.
                }

                //
                // Convert endian and length.
                //

                SmbPutUshort( (LPWORD) CurrentOutputBlockPtr, (WORD) Temp);
                CurrentOutputBlockPtr += sizeof(WORD);
                break;
            }

        case REM_ASCIZ:         // pointer to send asciz
            {
                LPTSTR Temp;
                Temp = va_arg(CurrentArgumentPtr, LPTSTR);
                if (Temp == NULL) {

                    //
                    // Update parm desc string: indicate null pointer.
                    //

                    *(CurrentParmDescPtr ) = REM_NULL_PTR;
                    break;
                }
#if defined(UNICODE) // RxpConvertArgs()
                ArgumentSize = NetpUnicodeToDBCSLen(Temp) + 1;
#else
                ArgumentSize = STRLEN(Temp) + 1;
#endif // defined(UNICODE)
                CurrentOutputBlockSize += ArgumentSize;
                if (CurrentOutputBlockSize > MaximumOutputBlockSize) {
                    return (NERR_NoRoom);
                }

                //
                // Copy str to output area, converting if necessary.
                // (This handles UNICODE to default LAN codepage.)
                //

#if defined(UNICODE) // RxpConvertArgs()
                NetpCopyWStrToStrDBCS(
                                    (LPSTR) CurrentOutputBlockPtr,  // dest
                                    Temp );                         // src
#else
                NetpCopyTStrToStr(
                                (LPSTR) CurrentOutputBlockPtr,  // dest
                                Temp);                          // src
#endif // defined(UNICODE)
                CurrentOutputBlockPtr += ArgumentSize;
                break;
            }

        case REM_BYTE_PTR:              // pointer to send byte(s)
            {
                LPVOID Temp;
                Temp = va_arg(CurrentArgumentPtr, LPVOID);
                if (Temp == NULL) {

                    //
                    // Update parm desc string to indicate null pointer.
                    //

                    *(CurrentParmDescPtr) = REM_NULL_PTR;
                    break;
                }
                ArgumentSize = RapArrayLength(
                            CurrentParmDescPtr,
                            &CurrentParmDescPtr,
                            Request);
                CurrentOutputBlockSize += ArgumentSize;
                if (CurrentOutputBlockSize > MaximumOutputBlockSize) {
                    return (NERR_NoRoom);
                }

                //
                // Caller is responsible for all UNICODE-ASCII conversions, we only do ASCII
                //

                NetpMoveMemory(
                                CurrentOutputBlockPtr,          // dest
                                Temp,                           // src
                                ArgumentSize);                  // len
                CurrentOutputBlockPtr += ArgumentSize;
                break;
            }

        case REM_WORD_PTR:              // ptr to send word(s)
        case REM_DWORD_PTR:             // ptr to send Dword(s)
            {
                LPVOID Temp;
                Temp = va_arg(CurrentArgumentPtr, LPVOID);
                if (Temp == NULL) {

                    //
                    // Update parm desc string to indicate null pointer.
                    //

                    *(CurrentParmDescPtr) = REM_NULL_PTR;
                    break;
                }
                ArgumentSize = RapArrayLength(
                            CurrentParmDescPtr,
                            &CurrentParmDescPtr,
                            Request);
                CurrentOutputBlockSize += ArgumentSize;
                if (CurrentOutputBlockSize > MaximumOutputBlockSize) {
                    return (NERR_NoRoom);
                }

                NetpMoveMemory(
                                CurrentOutputBlockPtr,          // dest
                                Temp,                           // src
                                ArgumentSize);                  // len
                CurrentOutputBlockPtr += ArgumentSize;
                break;
            }

        case REM_RCV_WORD_PTR:          // pointer to rcv word(s)
        case REM_RCV_BYTE_PTR:          // pointer to rcv byte(s)
        case REM_RCV_DWORD_PTR:         // pointer to rcv Dword(s)
            {
                LPVOID Temp;
                Temp = va_arg(CurrentArgumentPtr, LPVOID);

                //
                // Added this test for a NULL pointer to allow for
                // a reserved field (currently MBN) to be a recv
                // pointer. - ERICPE 7/19/89
                //

                if (Temp == NULL) {
                    // Update parm desc string to indicate null pointer.
                    *(CurrentParmDescPtr) = REM_NULL_PTR;
                    break;
                }

                CurrentInputBlockSize
                    += RapArrayLength(
                            CurrentParmDescPtr,
                            &CurrentParmDescPtr,
                            Response);
                if ( CurrentInputBlockSize > MaximumInputBlockSize) {
                    NetpKdPrint(("RxpConvertArgs: len exceeded\n"));
                    NetpBreakPoint();
                    return (NERR_InternalError);
                }
                break;
            }

        case REM_DWORD:         // DWord
            {
                DWORD Temp;
                CurrentOutputBlockSize += sizeof(DWORD);
                if (CurrentOutputBlockSize > MaximumOutputBlockSize) {
                    return (NERR_NoRoom);
                }
                Temp = va_arg(CurrentArgumentPtr, DWORD);
                SmbPutUlong( (LPDWORD) CurrentOutputBlockPtr, Temp);
                CurrentOutputBlockPtr += sizeof(DWORD);
                break;
            }

        case REM_RCV_BUF_LEN:   // Size of 32-bit receive data buffer
            {
                DWORD Temp;
                Temp = va_arg(CurrentArgumentPtr, DWORD);

                IF_DEBUG(CONVARGS) {
                    NetpKdPrint(("RxpConvertArgs: 32-bit rcv buf len is "
                            FORMAT_DWORD "\n", Temp));
                }

                if (RapValueWouldBeTruncated(Temp)) {
                    NetpKdPrint(("RxpConvertArgs: rcv.buf.len trunc'ed.\n"));
                    return (ERROR_INVALID_PARAMETER);
                }

                //
                // If the caller of RxRemoteApi requested that we allocate the
                // 32-bit receive buffer (typically for an Enum or GetInfo call)
                // then this value is still important - it tells the other side
                // how large a buffer it should allocate. We could just stick
                // in 64K here, but we defer to the caller who might have a
                // better idea, and thus make the allocation on the down-level
                // machine more efficient. We have the potential problem that if
                // we always use 64K then we reduce efficiency at the down-level
                // server without being able to easily rectify the situation
                //

                if( Temp > MAX_TRANSACT_RET_DATA_SIZE )
                {
                    NetpBreakPoint();
                    return (ERROR_BUFFER_OVERFLOW);
                }

                *RcvDataSizePtr = Temp;
                CurrentOutputBlockSize += sizeof(WORD);
                if (CurrentOutputBlockSize > MaximumOutputBlockSize) {
                    return (NERR_NoRoom);
                }
                SmbPutUshort( (LPWORD)CurrentOutputBlockPtr, (WORD)Temp);
                CurrentOutputBlockPtr += sizeof(WORD);
                break;
            }

        case REM_RCV_BUF_PTR:   // pointer to 32-bit receive data buffer
            {
                LPVOID Temp;
                Temp = va_arg(CurrentArgumentPtr, LPBYTE *);

                //
                // NOTE: This pointer could be NULL.  For instance, someone
                // could call DosPrintQGetInfo with NULL ptr and 0 bytes in
                // buffer, to get the number of bytes needed.
                //

                if ( Flags & ALLOCATE_RESPONSE ) {

                    if (Temp == NULL) {
                        NetpKdPrint(( PREFIX_NETAPI
                                "RxpConvertArgs: NULL rcv buf ptr.\n" ));
                        return (ERROR_INVALID_PARAMETER);
                    }
                }


                //
                // If the caller of RxRemoteApi requested that we allocate the
                // 32-bit receive buffer then this value is THE ADDRESS OF THE
                // POINTER TO THE BUFFER WHICH WILL BE ALLOCATED LATER.
                // RxRemoteApi must make sense of this and do the right thing.
                // RxpConvertBlock will make the situation right and allocate a
                // buffer into which the 16-bit data will be converted
                // (hopefully). This paradigm increases buffer efficiency
                // (because after we have received the 16-bit data we know how
                // large a buffer to allocate in order to return the 32-bit
                // data. Before we receive the data, we don't know how much
                // will come back and hence allocate the largest possible
                // buffer, which is inefficient)
                //

                *RcvDataPtrPtr = Temp;
                break;
            }

        case REM_SEND_BUF_PTR:  // pointer to send data buffer
            SendDataPresent = TRUE;
            SendDataPtrNative = va_arg(CurrentArgumentPtr, LPBYTE);
            break;

        case REM_SEND_BUF_LEN:          // Size of send data buffer
            SendDataSizeNative = va_arg(CurrentArgumentPtr, DWORD);

            if ( SendDataSizeNative > MAX_TRANSACT_SEND_DATA_SIZE )
            {
                NetpBreakPoint();
                return (ERROR_BUFFER_OVERFLOW);
            }

            break;

        case REM_ENTRIES_READ:          // Entries read identifier
            CurrentInputBlockSize += sizeof(WORD);
            if (CurrentInputBlockSize > MaximumInputBlockSize) {
                NetpKdPrint(("RxpConvertArgs: entries read, len exceeded\n"));
                NetpBreakPoint();
                return (NERR_InternalError);
            }
            (void) va_arg(CurrentArgumentPtr, LPDWORD);
            break;

        case REM_PARMNUM:               // ParmNum identifier
            {
                DWORD   Temp;
                DWORD   field_index;
                LPDESC  parm_num_desc;

                CurrentOutputBlockSize += sizeof(WORD);

                if (CurrentOutputBlockSize > MaximumOutputBlockSize) {
                    return (NERR_NoRoom);
                }

                Temp = va_arg(CurrentArgumentPtr, DWORD);

#if 0
// no longer required - parmnum is a pair of words packed into a DWORD making
// the following check meaningless

                if (RapValueWouldBeTruncated(Temp)) {
                    NetpKdPrint(("RxpConvertArgs: parmnum truncated.\n"));
                    return (ERROR_INVALID_PARAMETER);
                }
#endif

                ParmNumPresent = TRUE;

                //
                // ParmNum is the actual value which is sent over the wire and
                // uniquely identifies a field. It is a sort of handle
                //

                ParmNum = PARMNUM_FROM_PARMNUM_PAIR(Temp);

                //
                // field_index is not sent over the wire but is the ordinal of
                // the field that ParmNum refers to, in the structure/descriptor
                // This is the value we must use to determine the size of the
                // field identified by ParmNum, or else RapParmNumDescriptor
                // could have a minor spasm
                //

                field_index = FIELD_INDEX_FROM_PARMNUM_PAIR(Temp);
                SmbPutUshort( (LPWORD)CurrentOutputBlockPtr, (WORD)ParmNum);
                CurrentOutputBlockPtr += sizeof(WORD);

                //
                // if ParmNum is not PARMNUM_ALL get the size of the parameter
                // from the data descriptor
                //

                if (ParmNum != PARMNUM_ALL) {

                    //
                    // This call is for a set info. We need to calculate the
                    // size of the data being passed in the buffer - the caller
                    // no longer supplies this info
                    // NOTE: RapParmNumDescriptor wants the FIELD INDEX, not
                    // the PARMNUM, hence the reason for the convolutions
                    //

                    parm_num_desc = RxpGetSetInfoDescriptor(
                                        DataDescSmb,    // 16-bit data
                                        field_index,    // which field
                                        FALSE           // not 32-bit data
                                        );
                    if (parm_num_desc == NULL) {
                        return NERR_InternalError;
                    } else {

                        NetpAssert(
                                DESCLEN(parm_num_desc) <= MAX_DESC_SUBSTRING );
                        strcpy(parm_desc_16, parm_num_desc);
                        NetpMemoryFree(parm_num_desc);
                    }

                    parm_num_desc = RxpGetSetInfoDescriptor(
                                        DataDesc32,     // 32-bit data
                                        field_index,    // which field
                                        TRUE            // 32-bit data
                                        );
                    if (parm_num_desc == NULL) {
                        return NERR_InternalError;
                    } else {

                        NetpAssert(
                                DESCLEN(parm_num_desc) <= MAX_DESC_SUBSTRING );
                        strcpy(parm_desc_32, parm_num_desc);
                        NetpMemoryFree(parm_num_desc);
                    }

                    //
                    // The following will get the size of a 16-bit parameter in
                    // SendDataSizeNative. NOTE THAT THIS ASSUMES THERE IS ONLY
                    // ONE UNSTRUCTURED PARAMETER IN THE BUFFER
                    //

                    SendDataSizeNative = RxpGetFieldSize(
                                                        SendDataPtrNative,
                                                        parm_desc_16
                                                        );

                    //
                    // HACKHACK - if this is a string, treat it as unstructured
                    // data by setting DataDescSmb to NULL. Code lower down
                    // will inspect this and skip the data conversion
                    //

                    if (*parm_desc_16 == REM_ASCIZ) {

                        //
                        // setting convertUnstructuredDataToString to TRUE will
                        // cause us to convert an input UNICODE string to ANSI.
                        // SendDataSizeNative must also be recomputed
                        //

                        convertUnstructuredDataToString = TRUE;
                        DataDescSmb = NULL;
                    }
                }
                break;
            }

        case REM_FILL_BYTES:    // Send parm pad field

            // This is a rare type but is needed to ensure that the
            // send parameters are at least as large as the return
            // parameters so that buffer management can be simplified
            // on the server.

            ArgumentSize = RapArrayLength(
                        CurrentParmDescPtr,
                        &CurrentParmDescPtr,
                        Both);                  // Lie so space gets alloc'ed.
            CurrentOutputBlockSize += ArgumentSize;
            if (CurrentOutputBlockSize > MaximumOutputBlockSize) {
                return (NERR_NoRoom);
            }
            // CurrentOutputBlockPtr += ArgumentSize;
            break;

        default:        // Could be a digit from NULL send array
            break;
        } // switch

    } // for

    //
    // The parameter buffer now contains:
    // ApiNumber - word
    // ParmDescriptorString - asciiz, (NULL c,i,f,z identifiers replaced with O)
    // DataDescSmb - asciiz
    // parameters - as identified by ParmDescriptorString.
    //
    // Now process the data descriptor string.
    //

    //
    // For the receive buffer there is no data to set up for the call, but
    // there might have been an REM_AUX_COUNT descriptor in DataDescSmb
    // which requires the AuxDescSmb string to be copied onto the end of the
    // parameter buffer.
    //

    //
    // if we have data to receive BUT its unstructured then don't check the
    // DataDescSmb descriptor
    //

// MOD 08/08/91 RLF
//    if ((*RcvDataPtrPtr != NULL && DataDescSmb) || SendDataPresent) {
    if (DataDescSmb) {
// MOD 08/08/91 RLF

        //
        // If data to be transfered...
        //

        //
        // Find the length of the fixed length portion of the data
        // buffer.
        //

// MOD 08/08/91 RLF
//        NetpAssert(DataDescSmb != NULL);
// MOD 08/08/91 RLF

        AuxOffset = RapAuxDataCountOffset(
                    DataDescSmb,            // descriptor
                    Both,                   // transmission mode
                    FALSE);                 // not native format

        if (AuxOffset != NO_AUX_DATA) {
            DWORD AuxDescSize;
            DWORD no_aux_check;                 // check flag.

            NetpAssert(AuxDescSmb != NULL);
            NetpAssert(sizeof(DESC_CHAR) == 1);  // Caller should only give us ASCII, and should handle UNICODE conversion

            AuxDescSize = DESCLEN(AuxDescSmb) + 1;      // desc str and null
            CurrentOutputBlockSize += AuxDescSize;      // Add to total len.

            if (CurrentOutputBlockSize > MaximumOutputBlockSize) {
                return (NERR_NoRoom);
            }

            IF_DEBUG(CONVARGS) {
                NetpKdPrint(( "RxpConvertArgs: copying aux desc...\n" ));
            }
            NetpMoveMemory(
                        CurrentOutputBlockPtr,          // dest
                        AuxDescSmb,                     // src
                        AuxDescSize);                   // len
            CurrentOutputBlockPtr += AuxDescSize;    // Update buffer ptr.

            AuxSize = RapStructureSize(
                        AuxDescSmb,
                        Both,
                        FALSE);                 // not native format

            NetpAssert(AuxDescSmb != NULL);

            no_aux_check = RapAuxDataCountOffset(
                        AuxDescSmb,             // descriptor
                        Both,                   // transmission mode
                        FALSE);                 // not native format

            if (no_aux_check != NO_AUX_DATA) {

                //
                // Error if N in AuxDescSmb
                //

                NetpKdPrint(("RxpConvertArgs: N in aux desc str.\n"));
                NetpBreakPoint();
                return (NERR_InternalError);
            }
        }
    }

    //
    // For a send buffer the data pointed to in the fixed structure
    // must be copied into the send buffer. Any pointers which already
    // point in the send buffer are NULLed as it is illegal to use
    // the buffer for the send data, it is our transport buffer.
    //
    // NOTE - if parmnum was specified the buffer contains only that
    // element of the structure so no length checking is needed at this
    // side. A parmnum for a pointer type means that the data is at the
    // start of the buffer so there is no copying to be done.
    //


    if (SendDataPresent) {  // If a send buffer was specified

        //
        // if there is no smb data descriptor, but there is data to send, then
        // it is unstructured (usually meaning its a string). SendDataPtrNative
        // points to the data, and SendDataSizeNative is the amount to send.
        // Don't perform any conversions, just copy it to the send data buffer
        //

        if (DataDescSmb == NULL) {
            LPBYTE  ptr;

            if ((ptr = NetpMemoryAllocate(SendDataSizeNative)) == NULL) {
                return ERROR_NOT_ENOUGH_MEMORY;
            }

            //
            //          UniCode to ASCII. The caller should have made this
            //          conversion. We only know about unstructured data
            //          (ie bytes)
            //

            IF_DEBUG(CONVARGS) {
                NetpKdPrint((
                    "RxpConvertArgs: copying unstructured (no desc)...\n" ));
            }

            //
            // we may have to convert UNICODE to ANSI
            //

            if (convertUnstructuredDataToString) {

                //
                // sleaze: the buffer we just allocated may be twice the size
                // of the buffer really required
                //

#if defined(UNICODE) // RxpConvertArgs()
                NetpCopyWStrToStrDBCS( ptr, (LPTSTR)SendDataPtrNative );
#else
                NetpCopyTStrToStr(ptr, SendDataPtrNative);
#endif // defined(UNICODE)

                //
                // recompute the data size as the length of the narrow-character
                // string
                //

                SendDataSizeNative = strlen( (LPVOID) ptr) + 1;
            } else {
                NetpMoveMemory(ptr, SendDataPtrNative, SendDataSizeNative);
            }

            *SendDataPtrPtr16 = ptr;

            if( SendDataSizeNative > MAX_TRANSACT_SEND_DATA_SIZE )
            {
                NetpBreakPoint();
                return (ERROR_BUFFER_OVERFLOW);
            }

            *SendDataSizePtr16 = SendDataSizeNative;

        } else if ((ParmNum == PARMNUM_ALL) && (*DataDesc32 != REM_DATA_BLOCK)) {

            //
            // Only process buffer if no ParmNum and this is not a block send
            // (no data structure) or an ASCIZ concatenation send
            //

            BOOL BogusAllocFlag;      
            DWORD BytesRequired = 0;
            DWORD FixedStructSize16;  
            DWORD   primary_structure_size;
            LPBYTE StringLocation;
            DWORD TotalStructSize16;
            DWORD TotalStructSize32;

            IF_DEBUG(CONVARGS) {
                NetpKdPrint(( "RxpConvertArgs: PARMNUM_ALL...\n" ));
            }

            //
            // here we calculate the TOTAL data requirement of both the 32-bit
            // and 16-bit data. This includes:
            //      - primary data structures (NOTE: We assume only 1????)
            //      - variable data for primary structure (strings, arrays, etc)
            //      - aux data structures
            //      - variable data for aux structures (strings, arrays, etc)
            //

            //
            // Compute size of 32 bit structure, and other pointers and numbers.
            //

            primary_structure_size = RapStructureSize(DataDesc32, Both, TRUE);

            TotalStructSize32 = RapTotalSize(
                    SendDataPtrNative,  // in structure
                    DataDesc32,         // in desc
                    DataDesc32,         // out desc
                    FALSE,              // no meaningless input ptrs
                    Both,               // transmission mode
                    NativeToNative);    // input and output are native

            //
            // Compute size of 16 bit structure, and other pointers and numbers.
            //

            FixedStructSize16 = RapStructureSize(DataDesc16,Both,FALSE);

            TotalStructSize16 = RapTotalSize(
                    SendDataPtrNative,  // in structure
                    DataDesc32,         // in desc
                    DataDesc16,         // out desc
                    FALSE,              // no meaningless input ptrs
                    Both,               // transmission mode
                    NativeToRap);       // input is native; output is not.

            //
            // account for any associated auxiliary structures
            //

            if (AuxDesc32) {

                DWORD   aux_size;
                DWORD   aux_count;
                DWORD   aux_structure_size;
                LPBYTE  next_structure;

                //
                // find out how many auxiliary structures are being sent along
                // with the primary
                //

                aux_count = RapAuxDataCount(SendDataPtrNative,
                                            DataDesc32,
                                            Both,
                                            TRUE  // input is native format.
                                            );

                //
                // aux_structure_size is the size of the fixed portion of the
                // auxiliary data
                // next_structure is a pointer to the next auxiliary structure
                // for which to calculate the total space requirement
                //

                aux_structure_size = RapStructureSize(AuxDesc32, Request, FALSE);
                next_structure = SendDataPtrNative + primary_structure_size;

                while (aux_count--) {

                    //
                    // get the total size of the aux data - fixed structure
                    // length (which we already know) and the variable data
                    // requirement
                    //

                    aux_size = RapTotalSize(
                                next_structure, // where the 32-bit data lives
                                AuxDesc32,      // convert 32-bit
                                AuxDesc32,      // to 32-bit
                                FALSE,          // pointers NOT meaningless
                                Both,           // ?
                                NativeToNative  // 32-bit to 32-bit
                                );

                    TotalStructSize32 += aux_size;

                    //
                    // do the same for the 16-bit version of the data
                    //

                    aux_size = RapTotalSize(
                                next_structure, // where the 32-bit data lives
                                AuxDesc32,      // convert 32-bit
                                AuxDesc16,      // to 16-bit
                                FALSE,          // pointers NOT meaningless
                                Both,           // ?
                                NativeToRap     // 32-bit to 16-bit
                                );

                    TotalStructSize16 += aux_size;

                    //
                    // point to next aux structure (probably only 1 anyway?)
                    //

                    next_structure += aux_structure_size;
                }
            }

            IF_DEBUG(CONVARGS) {
                NetpKdPrint(( "RxpConvertArgs: total size(32)="
                        FORMAT_DWORD ".\n", TotalStructSize32 ));
            }

            NetpAssert(TotalStructSize16 >= FixedStructSize16);

            IF_DEBUG(CONVARGS) {
                NetpKdPrint(( "RxpConvertArgs: total size(16)="
                        FORMAT_DWORD ".\n", TotalStructSize16 ));
            }

            if( TotalStructSize16 > MAX_TRANSACT_SEND_DATA_SIZE )
            {
                NetpBreakPoint();
                return (ERROR_BUFFER_OVERFLOW);
            }

            *SendDataSizePtr16 = SendSize = TotalStructSize16;
            *SendDataPtrPtr16 = pSendData = NetpMemoryAllocate( TotalStructSize16 );
            if (pSendData == NULL) {
                return ERROR_NOT_ENOUGH_MEMORY;
            }
            StringLocation = (pSendData) + TotalStructSize16;

            IF_DEBUG(CONVARGS) {
                NetpKdPrint(("RxpConvertArgs: initial StringLocation is "
                        FORMAT_LPVOID "\n", (LPVOID) StringLocation ));
                NetpKdPrint(("RxpConvertArgs: input data "
                        "(before CSE, partial):\n"));
                NetpDbgHexDump( SendDataPtrNative,
                        NetpDbgReasonable( TotalStructSize16 ) );

                NetpKdPrint(("RxpConvertArgs: output data area "
                        "(before CSE, partial):\n"));
                NetpDbgHexDump( pSendData,
                        NetpDbgReasonable( TotalStructSize16 ) );
            }

            //
            // This routine calls RapConvertSingleEntry to convert the primary
            // data structure, but will also convert any auxiliary structures
            //

            Status = RxpConvertDataStructures(
                DataDesc32,         // 32-bit data
                DataDesc16,         // converted from 16-bit
                AuxDesc32,          // as are the aux structures
                AuxDesc16,
                SendDataPtrNative,  // where the 32-bit lives
                pSendData,          // and its new 16-bit address
                SendSize,           // how big the buffer is
                1,                  // only 1 primary structure.
                NULL,               // don't need number of entries converted.
                Both,               // do entire structure
                NativeToRap         // explicit 32->16, implicit TCHAR->codepage
                );

            //
            // We allocated the output buffer large enough, so there's no
            // reason that conversion should fail.
            //

            NetpAssert(Status == NERR_Success);


            //
            // RxpConvertDataStructures calls RapConvertSingleEntry to pack the
            // fixed and variable parts of the data into the buffer. The down-
            // level server expects the data in the same order as that in which
            // it appears in the descriptor strings. RxpPackSendBuffer exists
            // to make this so. Do it
            //

            Status = RxpPackSendBuffer(
                        (LPVOID *) SendDataPtrPtr16, // possibly reallocated  
                        SendDataSizePtr16,   // possibly realloced
                        &BogusAllocFlag,  
                        DataDesc16,
                        AuxDesc16,
                        FixedStructSize16,
                        AuxOffset,
                        AuxSize,
                        ParmNumPresent
                        );

            if (Status != NERR_Success) {
                NetpKdPrint(("RxpConvertArgs: pack send buffer failed, stat="
                        FORMAT_API_STATUS "\n", Status));
                return (Status);
            }

            IF_DEBUG(CONVARGS) {
                NetpKdPrint(("RxpConvertArgs: data "
                        "(after RxpPackSendBuffer):\n"));
                NetpDbgHexDump( pSendData, BytesRequired );
            }

//
// MOD 06/25/91 RLF
// Remove this, since reallocation takes place. Does it have any other
// implications?
//
// MOD 08/08/91 RLF
            NetpAssert(BogusAllocFlag == FALSE);
// MOD 08/08/91 RLF
//
// MOD 06/25/91 RLF
//

        } else if (ParmNum) {

            //
            // here if there is a parameter to set. Create a buffer for the data
            // to be sent in the setinfo call. Copy the caller's data into it.
            //

            LPBYTE  ptr;
            LPBYTE  enddata;
            DWORD   bytes_required;

            IF_DEBUG(CONVARGS) {
                NetpKdPrint(( "RxpConvertArgs: parmnum (not all)...\n" ));
            }

            if ((ptr = NetpMemoryAllocate(SendDataSizeNative)) == NULL) {
                return ERROR_NOT_ENOUGH_MEMORY; // gasp!
            }

            //
            // we now convert the data for the single field from 32-bits to
            // 16. Use the descriptors which identify the single field only
            //

            enddata = ptr + SendDataSizeNative;
            bytes_required = 0;
            Status = RapConvertSingleEntry(SendDataPtrNative,
                                           parm_desc_32,
                                           FALSE,
                                           ptr,
                                           ptr,
                                           parm_desc_16,
                                           FALSE,
                                           &enddata,
                                           &bytes_required,
                                           Both,
                                           NativeToRap
                                           );
            NetpAssert( Status == NERR_Success );

#if DBG
            if (!(bytes_required <= SendDataSizeNative)) {
                NetpKdPrint(("error: RxpConvertArgs.%d: "
                "bytes_required=%d, SendDataSizeNative=%d\n"
                "parm_desc_16=%s, parm_desc_32=%s\n",
                __LINE__,
                bytes_required,
                SendDataSizeNative,
                parm_desc_16,
                parm_desc_32
                ));
            }
            NetpAssert(bytes_required <= SendDataSizeNative);
#endif
            *SendDataPtrPtr16 = ptr;

            //
            // SendDataSizeNative is either the size of the buffer in a "sT"
            // descriptor pair, or was calculated based on the descriptor type
            // and caller's data in a setinfo/parmnum ('P') case
            //

            if ( SendDataSizeNative > MAX_TRANSACT_SEND_DATA_SIZE )
            {
                NetpBreakPoint();
                return (ERROR_BUFFER_OVERFLOW);
            }

            *SendDataSizePtr16 = SendDataSizeNative;

        } else {

            LPBYTE ptr;

            //
            // send data, PARMNUM_ALL, data desc is REM_DATA_BLOCK.  This can
            // happen with the NetServiceInstall API (see RxApi/SvcInst.c).
            // cbBuffer arg is set by RxNetServiceInstall to be the OUTPUT
            // buffer size, despite the LM 2.x app passing the INPUT size.
            // (We're just propagating another LanMan kludge here.)
            //
            //          UniCode to ASCII. The caller should have made this
            //          conversion. We only know about unstructured data
            //          (ie bytes)
            //

            NetpAssert( ParmNum == PARMNUM_ALL );
            NetpAssert( *DataDesc16 == REM_DATA_BLOCK );
            NetpAssert( SendDataSizeNative > 0 );
            IF_DEBUG(CONVARGS) {
                NetpKdPrint(( "RxpConvertArgs: "
                        "copying unstructured data with desc...\n" ));
            }

            //
            // Copy unstructured data and tell caller where it is.
            //
            if ((ptr = NetpMemoryAllocate(SendDataSizeNative)) == NULL) {
                return ERROR_NOT_ENOUGH_MEMORY;
            }

            NetpMoveMemory(
                    ptr,                        // dest
                    SendDataPtrNative,          // src
                    SendDataSizeNative);        // size
            *SendDataPtrPtr16 = ptr;

            if ( SendDataSizeNative > MAX_TRANSACT_SEND_DATA_SIZE )
            {
                NetpBreakPoint();
                return (ERROR_BUFFER_OVERFLOW);
            }

            *SendDataSizePtr16 = SendDataSizeNative;
        }
    } // send buffer was specified

    //
    // The parameter buffers and data buffers are now set up for
    // sending to the API worker so tell the caller.
    //

    *CurrentInputBlockSizePtr  = CurrentInputBlockSize;
    *CurrentOutputBlockSizePtr = CurrentOutputBlockSize;
    *CurrentOutputBlockPtrPtr  = CurrentOutputBlockPtr;

    return NERR_Success;

} // RxpConvertArgs



DBGSTATIC
DWORD
RxpGetFieldSize(
    IN LPBYTE Field,
    IN LPDESC FieldDesc
    )
{
    NetpAssert(Field != NULL);
    NetpAssert(FieldDesc != NULL);

    if (*FieldDesc == REM_ASCIZ) {
        return STRSIZE((LPTSTR)Field);
    } else {
        LPDESC TempDescPtr = FieldDesc;

        return RapGetFieldSize(FieldDesc, &TempDescPtr, Both);
    }
} // RxpGetFieldSize



DBGSTATIC
LPDESC
RxpGetSetInfoDescriptor(
    IN  LPDESC  Descriptor,
    IN  DWORD   FieldIndex,
    IN  BOOL    Is32BitDesc
    )

/*++

Routine Description:

    Allocates a descriptor string which describes a single parameter element
    of a structure, for SetInfo calls (where ParmNum != PARMNUM_ALL)

Arguments:

    Descriptor  - The full descriptor string for the relevant structure
    FieldIndex  - The ORDINAL number of the field (NOT ParmNum)
    Is32BitDesc - Descriptor defines 16-bit data

Return Value:

    Pointer to allocated descriptor or NULL if error

--*/

{
    LPDESC  lpdesc;

    lpdesc = RapParmNumDescriptor(Descriptor, FieldIndex, Both, Is32BitDesc);
    if (lpdesc == NULL) {
#if DBG

        //
        // don't expect this to happen - trap it in debug version
        //

        NetpKdPrint(("error: RxpGetSetInfoDescriptor: RapParmNumDescriptor didn't allocate string\n"));
        NetpBreakPoint();
#endif
    } else if (*lpdesc == REM_UNSUPPORTED_FIELD) {
#if DBG

        //
        // don't expect this to happen - trap it in debug version
        //

        NetpKdPrint(("error: RxpGetSetInfoDescriptor: parameter defines unsupported field\n"));
        NetpBreakPoint();
#endif
        NetpMemoryFree(lpdesc);
        lpdesc = NULL;
    }

    return lpdesc;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\rpcxlate\rxapi\wksuser.c ===
/*++

Copyright (c) 1991-92  Microsoft Corporation

Module Name:

    WksUser.c

Abstract:

    This file contains the RpcXlate code to handle the NetWkstaUserEnum API.

Author:

    John Rogers (JohnRo) 19-Nov-1991

Environment:

    Portable to any flat, 32-bit environment.  (Uses Win32 typedefs.)
    Requires ANSI C extensions: slash-slash comments, long external names.

Revision History:

    19-Nov-1991 JohnRo
        Implement remote NetWkstaUserEnum().
    21-Nov-1991 JohnRo
        Removed NT dependencies to reduce recompiles.
    07-Feb-1992 JohnRo
        Use NetApiBufferAllocate() instead of private version.
    14-Oct-1992 JohnRo
        RAID 9732: NetWkstaUserEnum to downlevel: wrong EntriesRead, Total?
        Set wkui1_oth_domains field.
        Use PREFIX_ equates.
    03-Nov-1992 JohnRo
        RAID 10418: Fixed overactive assert when Status != NO_ERROR.
        Fixed memory leak if we couldn't allocate new buffer (old one got lost).
        Fixed memory leak if nobody is logged-on to target server.

--*/

// These must be included first:

#include <windef.h>             // IN, DWORD, etc.
#include <lmcons.h>             // LM20_ equates, NET_API_STATUS, etc.

// These may be included in any order:

#include <dlwksta.h>            // WKSTA_INFO_0, MAX_WKSTA_ equates, etc.
#include <lmapibuf.h>           // NetApiBufferAllocate().
#include <lmerr.h>              // ERROR_ and NERR_ equates.
#include <netdebug.h>           // DBGSTATIC, NetpKdPrint(()), FORMAT_ equates.
#include <netlib.h>             // NetpCopyStringToBuffer().
#include <prefix.h>     // PREFIX_ equates.
#include <rxpdebug.h>           // IF_DEBUG().
#include <rxwksta.h>            // My prototypes, RxpGetWkstaInfoLevelEquivalent
#include <tstring.h>            // STRLEN().



NET_API_STATUS
RxNetWkstaUserEnum (
    IN LPTSTR UncServerName,
    IN DWORD Level,
    OUT LPBYTE *BufPtr,
    IN DWORD PrefMaxSize,
    OUT LPDWORD EntriesRead,
    OUT LPDWORD TotalEntries,
    IN OUT LPDWORD ResumeHandle OPTIONAL
    )

/*++

Routine Description:

    RxNetWkstaUserEnum performs the same function as NetWkstaUserEnum, except
    that the server name is known to refer to a downlevel server.

Arguments:

    (Same as NetWkstaUserEnum, except UncServerName must not be null, and
    must not refer to the local computer.)

Return Value:

    (Same as NetWkstaUserEnum.)

--*/

{

    LPBYTE NewInfo = NULL;              // Buffer to be returned to caller.
    DWORD NewFixedSize;
    DWORD NewStringSize;

    LPWKSTA_INFO_1 OldInfo = NULL;
    const DWORD OldLevel = 1;

    NET_API_STATUS Status;

    UNREFERENCED_PARAMETER(PrefMaxSize);
    UNREFERENCED_PARAMETER(ResumeHandle);

    IF_DEBUG(WKSTA) {
        NetpKdPrint(( PREFIX_NETAPI
                "RxNetWkstaUserEnum: starting, server=" FORMAT_LPTSTR
                ", lvl=" FORMAT_DWORD ".\n", UncServerName, Level));
    }

    //
    // Error check DLL stub and the app.
    //
    NetpAssert(UncServerName != NULL);
    if (BufPtr == NULL) {
        Status = ERROR_INVALID_PARAMETER;
        goto Cleanup;
    }
    *BufPtr = NULL;  // assume error; it makes error handlers easy to code.
    // This also forces possible GP fault before we allocate memory.

    //
    // Compute size of wksta user structure (including strings)
    //
    switch (Level) {
    case 0 :
        NewFixedSize = sizeof(WKSTA_USER_INFO_0);
        NewStringSize = (LM20_UNLEN+1) * sizeof(TCHAR);
        break;
    case 1 :
        NewFixedSize = sizeof(WKSTA_USER_INFO_1);
        NewStringSize =
                (LM20_UNLEN+1 + LM20_DNLEN+1 + MAX_PATH+1) * sizeof(TCHAR);
        break;
    default:
        Status = ERROR_INVALID_LEVEL;
        goto Cleanup;
    }

    //
    // Actually remote the API, which will get back the (old) info level
    // data in native format.
    //
    Status = RxpWkstaGetOldInfo(
            UncServerName,              // Required, with \\name.
            OldLevel,
            (LPBYTE *) & OldInfo);      // buffer (alloc and set this ptr)

    NetpAssert( Status != ERROR_MORE_DATA );
    NetpAssert( Status != NERR_BufTooSmall );

    if (Status == NERR_Success) {

        NetpAssert( OldInfo != NULL );

        if ( (OldInfo->wki1_username == NULL)
                || ( (*(OldInfo->wki1_username)) == (TCHAR) '\0')) {

            //
            // Nobody logged on.
            //
            *BufPtr = NULL;
            *EntriesRead = 0;
            *TotalEntries = 0;

        } else {

            // These variables are used by the COPY_STRING macro.
            LPBYTE NewFixedEnd;
            LPTSTR NewStringTop;
            LPWKSTA_INFO_1 src = (LPVOID) OldInfo;
            LPWKSTA_USER_INFO_1 dest;  // superset info level

            //
            // Allocate memory for native version of new info, which we'll
            // return to caller.  (Caller must free it with NetApiBufferFree.)
            //

            Status = NetApiBufferAllocate(
                    NewFixedSize + NewStringSize,
                    (LPVOID *) & NewInfo);
            if (Status != NERR_Success) {
                goto Cleanup;
            }
            NetpAssert( NewInfo != NULL );
            IF_DEBUG(WKSTA) {
                NetpKdPrint(( PREFIX_NETAPI
                        "RxNetWkstaUserEnum: allocated new buffer at "
                        FORMAT_LPVOID "\n", (LPVOID) NewInfo ));
            }

            // Set up pointers for use by NetpCopyStringsToBuffer.
            dest = (LPVOID) NewInfo;
            NewStringTop = (LPTSTR) NetpPointerPlusSomeBytes(
                    dest,
                    NewFixedSize+NewStringSize);

            NewFixedEnd = NetpPointerPlusSomeBytes(NewInfo, NewFixedSize);

#define COPY_STRING( InField, OutField ) \
    { \
        BOOL CopyOK; \
        NetpAssert( dest != NULL); \
        NetpAssert( src != NULL); \
        NetpAssert( (src -> InField) != NULL); \
        CopyOK = NetpCopyStringToBuffer ( \
            src->InField, \
            STRLEN(src->InField), \
            NewFixedEnd, \
            & NewStringTop, \
            & dest->OutField); \
        NetpAssert(CopyOK); \
    }
            //
            // Downlevel server, so one user is logged on.
            //
            *EntriesRead = 1;
            *TotalEntries = 1;

            //
            // Copy/convert data from OldInfo to NewInfo.
            //

            // User name is only field in level 0.
            COPY_STRING( wki1_username, wkui1_username );

            if (Level == 1) {

                // Do fields unique to level 1.
                COPY_STRING( wki1_logon_domain, wkui1_logon_domain );
                COPY_STRING( wki1_oth_domains,  wkui1_oth_domains );
                COPY_STRING( wki1_logon_server, wkui1_logon_server );

            }

            NetpAssert( Level < 2 );  // Add code here someday?

            *BufPtr = NewInfo;
        }
    } else {
        // An error from RxpWkstaGetOldInfo()...
        NetpAssert( OldInfo == NULL );
    }

Cleanup:

    if (OldInfo != NULL) {
        (void) NetApiBufferFree( OldInfo );
    }

    return (Status);

} // RxNetWkstaUserEnum
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\rpcxlate\rxcommon\convblk.c ===
/*++

Copyright (c) 1987-1993  Microsoft Corporation

Module Name:

    ConvBlk.c

Abstract:

    This module contains RxpConvertBlock, a support routine for RxRemoteApi.

Author:

    John Rogers (JohnRo) 01-Apr-1991
        (Created portable LanMan (NT) version from LanMan 2.0)

Environment:

    Portable to any flat, 32-bit environment.  (Uses Win32 typedefs.)
    Requires ANSI C extensions: slash-slash comments, long external names.

Revision History:

    01-Apr-1991 JohnRo
        Converted from LanMan 2.x sources.
    03-May-1991 JohnRo
        Handle enum (array) correctly.
        Get 32-bit data desc and convert to receive buffer with it.
        Handle receive word correctly.
        Lots of cleanup to comments.
        RcvDataPointer and RcvDataPresent are redundant.
        Fixed receive buffer length problem.
        Added (quiet) debug output.
        Reduced recompile hits from header files.
    09-May-1991 JohnRo
        Made changes to reflect CliffV's code review.
    11-May-1991 JohnRo
        Convert pointers, and then tell convert single entry that input
        pointers are OK.  Also, let's treat Converter as DWORD locally.
        Force SmbGetUshort to get a word instead of a single byte.
    14-May-1991 JohnRo
        Pass 2 aux descriptors to RxpConvertBlock.
        Added debug print of NumStruct as it changes.
        Use FORMAT_LPVOID instead of FORMAT_POINTER (max portability).
    15-May-1991 JohnRo
        Added various "native" flags.
    17-May-1991 JohnRo
        Handle array of aux structs.
    20-May-1991 JohnRo
        Make data descriptors OPTIONAL for RxpConvertBlock.
    11-Jun-1991 rfirth
        Added extra parameter: SmbRcvByteLen which specifies the amount of
        bytes in SmbRcvBuffer
    14-Jun-1991 JohnRo
        Got rid of extraneous debug hex dump of buffer at end.
        Use NetpDbgReasonable().
    15-Jul-1991 JohnRo
        Changed RxpConvertDataStructures to allow ERROR_MORE_DATA, e.g. for
        print APIs.  Also got rid of a few unreferenced local variables.
    17-Jul-1991 JohnRo
        Extracted RxpDebug.h from Rxp.h.
    01-Aug-1991 RFirth
        Removed #if 0 block and variables which were put into convdata.c
        (RxpConvertDataStructures)
    19-Aug-1991 rfirth
        Added Flags parameter and support for ALLOCATE_RESPONSE flag
    26-Aug-1991 JohnRo
        Minor changes suggested by PC-LINT.
    20-Sep-1991 JohnRo
        Downlevel NetService APIs.  (Make sure *RcvDataBuffer gets set if
        ALLOCATE_RESPONSE is passed and *SmbRcvByteLen==0.)
    21-Nov-1991 JohnRo
        Removed NT dependencies to reduce recompiles.
    04-Nov-1992 JohnRo
        RAID 9355: Event viewer: won't focus on LM UNIX machine.
        (Added REM_DATA_BLOCK support for error log return data.)
        Use PREFIX_ equates.
    04-May-1993 JohnRo
        RAID 6167: avoid access violation or assert with WFW print server.
        Use NetpKdPrint() where possible.
    18-May-1993 JohnRo
        DosPrintQGetInfoW underestimates number of bytes needed.

--*/



// These must be included first:

#include <windef.h>             // IN, OUT, DWORD, LPBYTE, etc.
#include <lmcons.h>             // NET_API_STATUS.

// These may be included in any order:

#include <align.h>              // ALIGN_WORST
#include <apinums.h>            // API_ equates.
#include <limits.h>             // CHAR_BIT.
#include <lmapibuf.h>           // NetapipBufferAllocate, NetApiBufferFree
#include <lmerr.h>              // NERR_ and ERROR_ equates.
#include <netdebug.h>   // NetpAssert(), NetpDbg routines, FORMAT_ equates.
#include <netlib.h>             // NetpMoveMemory(), etc.
#include <prefix.h>     // PREFIX_ equates.
#include <remtypes.h>           // REM_BYTE, etc.
#include <rap.h>                // LPDESC, RapConvertSingleEntry(), etc.
#include <rx.h>                 // Flags parameter definitions
#include <rxp.h>                // My prototype.
#include <rxpdebug.h>           // IF_DEBUG().


#define DESC_IS_UNSTRUCTURED( descPtr ) \
    ( ( (descPtr)==NULL) || ( (*(descPtr)) == REM_DATA_BLOCK ) )

NET_API_STATUS
RxpConvertBlock(
    IN DWORD ApiNumber,
    IN LPBYTE ResponseBlockPointer,
    IN LPDESC ParmDescriptorString,
    IN LPDESC DataDescriptor16 OPTIONAL,
    IN LPDESC DataDescriptor32 OPTIONAL,
    IN LPDESC AuxDesc16 OPTIONAL,
    IN LPDESC AuxDesc32 OPTIONAL,
    IN va_list *FirstArgumentPointer,   // rest of API's arguments
    IN LPBYTE SmbRcvBuffer OPTIONAL,
    IN DWORD SmbRcvByteLen,
    OUT LPBYTE RcvDataBuffer OPTIONAL,
    IN DWORD RcvDataLength,
    IN DWORD Flags
    )

/*++

Routine Description:

    RxpConvertBlock translates the remote response (of a remoted API) into
    the local equivalent.  This involves converting the response (which is in
    the form of 16-bit data in the transaction response buffer) to local
    data formats, and setting them in the argument list.

Arguments:

    ApiNumber - Function number of the API required.

    ResponseBlockPointer - Points to the transaction SMB response block.

    ParmDescriptorString - A pointer to a ASCIIZ string describing the API call
        parameters (other than server name).

    DataDescriptor16 - A pointer to a ASCIIZ string describing the
        structure of the data in the call, i.e. the return data structure
        for a Enum or GetInfo call.  This string is used for adjusting pointers
        to data in the local buffers after transfer across the net.  If there
        is no structure involved in the call then DataDescriptor16 must
        be a null pointer.

    DataDescriptor32 - An optional pointer to a ASCIIZ string describing the
        32-bit structure of the return data structure.

    AuxDesc16, AuxDesc32 - Will be NULL in most cases unless a REM_AUX_COUNT
        descriptor char is present in DataDescriptor16 in which case the
        aux descriptors define a secondary data format as DataDescriptor16
        defines the primary.

    FirstArgumentPointer - Points to the va_list (variable arguments list)
        containing the API arguments (after the server name).  The caller
        must call va_start and va_end.

    SmbRcvBuffer - Optionally points to 16-bit format receive data buffer.

    SmbRcvByteLen - the number of bytes contained in SmbRcvBuffer (if not NULL)

    RcvDataBuffer - Points to the data area for the received data.  For
        instance, this may be a server info structure from NetServerGetInfo.
        This pointer will be NULL for many APIs.

        If (Flags & ALLOCATE_RESPONSE) then this pointer actually points to
        the pointer to the eventual buffer. We allocate a buffer in this routine
        and set *RcvDataBuffer to it. If we fail to get the buffer then
        *RcvDataBuffer will be set to NULL

    RcvDataLength - Length of the data area that RcvDataBuffer points to.
        If (Flags & ALLOCATE_RESPONSE) then this value will be the size that the
        caller of RxRemoteApi originally decided that the down-level server
        should use and incidentally was the original size of SmbRcvBuffer

    Flags - bit-mapped flags word. Currently defined flags are:
        NO_PERMISSION_REQUIRED  - used by RxpTransactSmb to determine whether
                                  a NULL session may be used
        ALLOCATE_RESPONSE       - used by this routine to allocate the final
                                  32-bit response data buffer based on the size
                                  of the SMB data received, multiplied by the
                                  RAP_CONVERSION_FACTOR
Return Value:

    NET_API_STATUS - return value from remote API.

--*/

{
    DWORD Converter;            // For pointer fixups.
    LPBYTE CurrentBlockPointer;
    LPDWORD        EntriesReadPtr = NULL;
    DWORD NumStruct;            // Loop count for ptr fixup.
    va_list ParmPtr;
    LPBYTE         pDataBuffer = NULL;  // pointer to returned data
    NET_API_STATUS Status;      // Return status from remote.
    DWORD TempLength;           // General purpose length.


#if DBG

    //
    // Code in this file depends on 16-bit words; the Remote Admin Protocol
    // demands it.
    //

    NetpAssert( ( (sizeof(WORD)) * CHAR_BIT) == 16);

    if (DataDescriptor16 != NULL) {
        NetpAssert(DataDescriptor32 != NULL);
    } else {
        NetpAssert(DataDescriptor32 == NULL);
    }

    if (AuxDesc16 != NULL) {
        NetpAssert(AuxDesc32 != NULL);
    } else {
        NetpAssert(AuxDesc32 == NULL);
    }
#endif


    ParmPtr = *FirstArgumentPointer;

    // The API call was successful. Now translate the return buffers
    // into the local API format.
    //
    // First copy any data from the return parameter buffer into the
    // fields pointed to by the original call parameters.
    // The return parameter buffer contains;
    //      Status,         (16 bits)
    //      Converter,      (16 bits)
    //      ...             fields described by rcv ptr types in
    //                      ParmDescriptorString


    CurrentBlockPointer = ResponseBlockPointer;
    Status = (NET_API_STATUS) SmbGetUshort( (LPWORD) CurrentBlockPointer );
    CurrentBlockPointer += sizeof(WORD);

    Converter = ((DWORD) SmbGetUshort( (LPWORD) CurrentBlockPointer )) & 0xffff;
    IF_DEBUG(CONVBLK) {
        NetpKdPrint(( PREFIX_NETAPI
                "RxpConvertBlock: Converter=" FORMAT_HEX_DWORD ".\n",
                Converter ));
    }
    CurrentBlockPointer += sizeof(WORD);

    // Set default value of NumStruct to 1, if data, 0 if no data.

    if ( (DataDescriptor16 != NULL) && (*DataDescriptor16 != '\0') ) {
        NumStruct = 1;
    } else {
        NumStruct = 0;
    }

    for( ; *ParmDescriptorString != '\0'; ParmDescriptorString++) {

        IF_DEBUG(CONVBLK) {
            NetpKdPrint(( PREFIX_NETAPI
                    "RxpConvertBlock: *parm='" FORMAT_LPDESC_CHAR
                    "', ParmPtr is:\n", *ParmDescriptorString ));
            NetpDbgHexDump((LPVOID) & ParmPtr, sizeof(va_list));
        }
        switch( *ParmDescriptorString) {
        case REM_WORD :                 // Word in old APIs (DWORD in 32-bit).
        case REM_DWORD :                // DWord.
            (void) va_arg(ParmPtr, DWORD);      // Step over this arg.
            break;

        case REM_ASCIZ :
            (void) va_arg(ParmPtr, LPSTR);      // Step over this arg.
            break;

        case REM_BYTE_PTR :
            (void) va_arg(ParmPtr, LPBYTE);     // Step over this arg.
            (void) RapArrayLength(
                        ParmDescriptorString,
                        &ParmDescriptorString,
                        Response);
            break;

        case REM_WORD_PTR :             // (WORD *) in old APIs.
        case REM_DWORD_PTR :            // (DWORD *)
            (void) va_arg(ParmPtr, LPDWORD);    // Step over this arg.
            break;

        case REM_RCV_WORD_PTR :    // pointer to rcv word(s) (DWORD in 32-bit)
            {
                LPDWORD Temp;
                DWORD ArrayCount;
                Temp = va_arg(ParmPtr, LPDWORD);

                ++ParmDescriptorString;  // point to first (possible) digit...
                ArrayCount = RapDescArrayLength(
                        ParmDescriptorString);  // updated past last.
                --ParmDescriptorString;  // point back at last digit for loop.
                IF_DEBUG(CONVBLK) {
                    NetpKdPrint(( PREFIX_NETAPI
                            "RxpConvertBlock: rcv.word.ptr, temp="
                            FORMAT_LPVOID ", ArrayCount=" FORMAT_DWORD ".\n",
                            (LPVOID) Temp, ArrayCount ));
                }

                // if the rcv buffer given to us by the user is NULL,
                // (one currently can be - it is an MBZ parameter for
                // now in the log read apis...), don't attempt to
                // copy anything. TempLength will be garbage in this
                // case, so don't update CurrentBlockPointer either.  All we
                // use RapArrayLength for is to update ParmDescriptorString if
                // the parameter was NULL.

                if ( Temp == NULL ) {
                    ;        /* NULLBODY */
                } else {

                    // Copy one or more words (expanding to DWORDS as we go).
                    DWORD WordsLeft = ArrayCount;
                    do {
                        DWORD Data;
                        // Convert byte order if necessary, and expand.
                        Data = (DWORD) SmbGetUshort(
                                (LPWORD) CurrentBlockPointer );
                        *Temp = Data;
                        Temp += sizeof(DWORD);
                        --WordsLeft;
                    } while (WordsLeft > 0);

                    // This gross hack is to fix the problem that a
                    // down level spooler (Lan Server 1.2)
                    // do not perform level checking
                    // on the w functions of the api(s):
                    // DosPrintQGetInfo
                    // and thus can return NERR_Success
                    // and bytesavail == 0.  This combination
                    // is technically illegal, and results in
                    // us attempting to unpack a buffer full of
                    // garbage.  The following code detects this
                    // condition and resets the amount of returned
                    // data to zero so we do not attempt to unpack
                    // the buffer.        Since we know the reason for the
                    // mistake at the server end is that we passed
                    // them a new level, we return ERROR_INVALID_LEVEL
                    // in this case.
                    // ERICPE, 5/16/90.

                    if ((ApiNumber == API_WPrintQGetInfo)
                    && (Status == NERR_Success)
                    && (*(LPWORD)CurrentBlockPointer == 0)
                    && (*ParmDescriptorString == REM_RCV_WORD_PTR)) {

                        Status = ERROR_INVALID_LEVEL;
                        goto ErrorExit;
                    }
                    // END OF GROSS HACK

                    CurrentBlockPointer += (ArrayCount * sizeof(WORD));
                 }
                break;
            }

        case REM_RCV_BYTE_PTR :         // pointer to rcv byte(s)
            {
                LPBYTE Temp;
                Temp = va_arg(ParmPtr, LPBYTE);
                TempLength = RapArrayLength(
                        ParmDescriptorString,
                        &ParmDescriptorString,
                        Response);

                // if the rcv buffer given to us by the user is NULL,
                // (one currently can be - it is an MBZ parameter for
                // now in the log read apis...), don't attempt to
                // copy anything. TempLength will be garbage in this
                // case, so don't update CurrentBlockPointer either.  All we
                // use RapArrayLength for is to update ParmDescriptorString if
                // the parameter was NULL.

                if ( Temp != NULL ) {
                    NetpMoveMemory(
                                Temp,                           // dest
                                CurrentBlockPointer,            // src
                                TempLength);                    // len
                    CurrentBlockPointer += TempLength;
                 }
            }
            break;

        case REM_RCV_DWORD_PTR :        // pointer to rcv Dword(s)
            {
                LPDWORD Temp;
                Temp = va_arg(ParmPtr, LPDWORD);
                TempLength = RapArrayLength(
                        ParmDescriptorString,
                        &ParmDescriptorString,
                        Response);

                // if the rcv buffer given to us by the user is NULL,
                // (one currently can be - it is an MBZ parameter for
                // now in the log read apis...), don't attempt to
                // copy anything. TempLength will be garbage in this
                // case, so don't update CurrentBlockPointer either.  All we
                // use RapArrayLength for is to update ParmDescriptorString if
                // the parameter was NULL.

                if ( Temp == NULL ) {
                    ;        /* NULLBODY */
                } else {
                    NetpMoveMemory(
                                Temp,                           // dest
                                CurrentBlockPointer,            // src
                                TempLength);                    // len
                    CurrentBlockPointer += TempLength;
                }
            }
            break;

        case REM_SEND_BUF_PTR :
            (void) va_arg(ParmPtr, LPVOID);     // Step over arg.
            break;

        case REM_SEND_BUF_LEN :
            (void) va_arg(ParmPtr, DWORD);      // Step over (32-bit) buf len.
            break;

        case REM_RCV_BUF_PTR :
            (void) va_arg(ParmPtr, LPVOID);
            break;

        case REM_RCV_BUF_LEN :
            (void) va_arg(ParmPtr, DWORD);      // Step over (32-bit) buf len.
            break;

        case REM_PARMNUM :
            (void) va_arg(ParmPtr, DWORD);      // Step over (32-bit) parm num.
            break;

        case REM_ENTRIES_READ :          // Used for NumStruct
            {
                EntriesReadPtr = va_arg(ParmPtr, LPDWORD);
                NumStruct = (DWORD) SmbGetUshort((LPWORD) CurrentBlockPointer);
                
                if (RapValueWouldBeTruncated(NumStruct))
                {
                    Status = ERROR_INVALID_PARAMETER;
                    return Status;
                }

                IF_DEBUG(CONVBLK) {
                    NetpKdPrint(( PREFIX_NETAPI
                            "RxpConvertBlock: NumStruct is now "
                            FORMAT_DWORD ".\n", NumStruct ));
                }

                // Assume all entries will fit; we'll correct this later if not.
                *EntriesReadPtr = NumStruct;

                CurrentBlockPointer += sizeof(WORD);
                break;
            }

        case REM_FILL_BYTES :
            // Special case, this was not really an input parameter so ParmPtr
            // does not get changed. However, the ParmDescriptorString
            // pointer must be advanced past the descriptor field so
            // use get RapArrayLength to do this but ignore the
            // return length.

            (void) RapArrayLength(
                        ParmDescriptorString,
                        &ParmDescriptorString,
                        Response);
            break;

        case REM_AUX_NUM :              // Can't have aux in parm desc.
        case REM_BYTE :                 // Can't push a byte, so this is bogus?
        case REM_DATA_BLOCK :           // Not in parm desc.
        case REM_DATE_TIME :            // Never used
        case REM_NULL_PTR :             // Never used
        case REM_SEND_LENBUF :          // Never used
        default :
            NetpBreakPoint();
            Status = NERR_InternalError;
            goto ErrorExit;

        } // switch
    } // for

    //
    // If no data was returned from the server, then there's no point in
    // continuing. Return early with the status code as returned from the
    // remoted function
    //

    if (!SmbRcvByteLen) {
        if (Flags & ALLOCATE_RESPONSE) {

            //
            // We failed to allocate the buffer; this in turn will cause
            // RxRemoteApi to fail, in which event, the calling function
            // (ie RxNetXxxx) may try to free the buffer allocated on its
            // behalf (ie the buffer we just failed to get). Ensure that
            // the caller doesn't try to free an invalid pointer by setting
            // the returned pointer to NULL
            //

            NetpAssert(RcvDataBuffer);  // address of the callers buffer pointer
            *(LPBYTE*)RcvDataBuffer = NULL;
        }

        return Status;
    }

    //
    // If the caller of RxRemoteApi requested that we allocate the final data
    // buffer on their behalf, then allocate it here. We use as the size
    // criterion
    //
    // (RAP_CONVERSION_FACTOR + 1/RAP_CONVERSION_FRACTION) * SmbRcvByteLen
    //
    // since this has the size of 16-bit data actually received.
    //
    // RAP_CONVERSION_FACTOR is 2 since that's the ratio for the size of
    // WCHAR to CHAR and of DWORD to WORD.  However, Lanman data structures
    // typically represents text as zero terminated array of CHAR within the
    // returned structure.  The array itself is of maximum size.  However,
    // the typical native representation has a 4-byte pointer to a zero
    // terminated WCHAR.  A factor of 2 wouldn't account for the 4-byte pointer.
    // Assuming the smallest lanman array size is 13 bytes (e.g., NNLEN+1), an
    // additional factor of 4/13 (about 1/3) is needed.  So,
    // RAP_CONVERSION_FRACTION is 3.
    //
    // Round the size to a multiple of the alignment for the system to allow
    // data to be packed at the trailing end of the buffer.
    //
    // NOTE: Since the original API caller expects to use NetApiBufferFree to
    // get rid of this buffer, we must use NetapipBufferAllocate
    //

    if (Flags & ALLOCATE_RESPONSE) {
        NET_API_STATUS  ConvertStatus;

        NetpAssert(RcvDataBuffer);  // address of the callers buffer pointer
        NetpAssert(SmbRcvByteLen);  // size of the data received

        RcvDataLength = SmbRcvByteLen * RAP_CONVERSION_FACTOR;
        RcvDataLength += (SmbRcvByteLen + RAP_CONVERSION_FRACTION - 1) /
                         RAP_CONVERSION_FRACTION;
        RcvDataLength = ROUND_UP_COUNT( RcvDataLength, ALIGN_WORST );

        if (ConvertStatus = NetapipBufferAllocate(RcvDataLength,
                                                  (PVOID *) &pDataBuffer)) {
            NetpKdPrint(( PREFIX_NETAPI
                    "Error: RxpConvertBlock cannot allocate memory ("
                    "error " FORMAT_API_STATUS ").\n", ConvertStatus ));

            Status = ConvertStatus;
            goto ErrorExit;
        }
        NetpAssert( pDataBuffer != NULL );

        IF_DEBUG(CONVBLK) {
            NetpKdPrint(( PREFIX_NETAPI
                    "RxpConvertBlock: allocated " FORMAT_DWORD " byte buffer "
                    "at " FORMAT_LPVOID " for caller\n",
                    RcvDataLength, (LPVOID) pDataBuffer ));
        }

        *(LPBYTE*)RcvDataBuffer = pDataBuffer;
    } else {
        pDataBuffer = RcvDataBuffer;
    }

    //////////////////////////////////////////////////////////////////////////
    //                                                                      //
    // NB:  From here on down, RcvDataBuffer should not be used to point to //
    //      the received data buffer. Use pDataBuffer. The reason is that   //
    //      RcvDataBuffer is ambiguous - it may point to a buffer or it may //
    //      point to a pointer to a buffer. pDataBuffer will always point   //
    //      to a buffer                                                     //
    //                                                                      //
    //////////////////////////////////////////////////////////////////////////

    //
    // Done doing arguments, so now we can do the receive buffer.
    //

    if ((pDataBuffer != NULL) && (RcvDataLength != 0)) {
        // DWORD BytesRequired = 0;
        LPBYTE EntryPtr16 = SmbRcvBuffer;
        // LPBYTE EntryPtr32 = pDataBuffer;
        DWORD NumAuxStructs;
        // LPBYTE StringAreaEnd = pDataBuffer + RcvDataLength;
        // BOOL    auxiliaries = AuxDesc32 != NULL;

//
// MOD 06/06/91 RLF
//
//        NetpAssert( DataDescriptor16 != NULL );
//
// MOD 06/06/91 RLF
//
        IF_DEBUG(CONVBLK) {
            NetpKdPrint(( PREFIX_NETAPI
                    "RxpConvertBlock: "
                    "SMB rcv buff (before rcv buff conv) (partial):\n" ));
            
            NetpDbgHexDump(SmbRcvBuffer, NetpDbgReasonable(RcvDataLength));
        }

        // Now convert all pointer fields in the receive buffer to local
        // pointers.

//
// MOD 06/06/91 RLF
//
// If we have a receive data buffer, we may or may not be receiving
// structured data. If DataDescriptor16 is NULL assume unstructured data
// else work out sizes of structs etc.
//
// When I say "unstructured data", is it okay to treat this as an array of
// bytes? What about ASCIZ-UC translation? My guess is that at this level
// unstructured data is bytes and any higher-level software which knows
// the format of received/expected data can process it
//
        if ( !DESC_IS_UNSTRUCTURED( DataDescriptor16 ) ) {

            NET_API_STATUS ConvertStatus;
            DWORD          NumCopied = 0;
//
// MOD 06/06/91 RLF
//
            ConvertStatus = RxpReceiveBufferConvert(
                    SmbRcvBuffer,               // buffer (updated in place)
                    RcvDataLength,              // buffer size in bytes
                    Converter,
                    NumStruct,
                    DataDescriptor16,
                    AuxDesc16,
                    & NumAuxStructs);
            if (ConvertStatus != NERR_Success) {
                Status = ConvertStatus;
                goto ErrorExit;
            }

            ConvertStatus = RxpConvertDataStructures(
                DataDescriptor16,   // going from 16-bit data
                DataDescriptor32,   // to 32-bit
                AuxDesc16,          // same applies for aux data
                AuxDesc32,
                EntryPtr16,         // where the 16-bit data is
                pDataBuffer,        // where the 32-bit data goes
                RcvDataLength,      // size of the output buffer (bytes)
                NumStruct,          // number of primaries
                &NumCopied,         // number of primaries copied.
                Both,               // parameter to RapConvertSingleEntry
                RapToNative         // convert 16-bit data to 32-bit
                );

            if (ConvertStatus != NERR_Success) {

                //
                // This only happens when (1) the API allows the application
                // to specify the buffer size and (2) the size is too small.
                // As part of the "switch" above, we've already set the
                // "pcbNeeded" (pointer to count of bytes needed).  Actually,
                // that value assumes that the RAP and native sizes are the
                // same.  It's up to RxRemoteApi's caller to correct that,
                // if it's even feasible.
                //

                NetpAssert( ConvertStatus == ERROR_MORE_DATA );

                if (EntriesReadPtr != NULL) {
                    // Some APIs, like DosPrintQEnum, have entries read value.
                    NetpAssert( NumCopied <= NumStruct );
                    *EntriesReadPtr = NumCopied;
                } else {
                    // APIs like DosPrintQGetInfo does not have entries read.
                    // There isn't much we can do for them.
                }

                Status = ConvertStatus;
                // Continue, treating this as "normal" status...

            } else {
                NetpAssert( NumCopied == NumStruct );
            }

            IF_DEBUG(CONVBLK) {
                NetpKdPrint(( PREFIX_NETAPI
                        "RxpConvertBlock: rcv buff (after CSE) (partial):\n" ));
                NetpDbgHexDump(pDataBuffer, NetpDbgReasonable(RcvDataLength));
            }

        } else {

            //
            // There is no 16-bit data descriptor. We take this to mean that
            // the data is unstructured - typically a string will be returned
            // An example? Why, I_NetNameCanonicalize of course!
            //

#if DBG
            NetpAssert(RcvDataLength >= SmbRcvByteLen);
#endif

            //
            // Ascii-Unicode conversion is the responsibility of the caller
            //

            NetpMoveMemory(pDataBuffer, SmbRcvBuffer, SmbRcvByteLen);
        }
    } // if pDataBuffer && RcvDataLength

    IF_DEBUG(CONVBLK) {
        NetpKdPrint(( PREFIX_NETAPI
                "RxpConvertBlock: returning (normal) status="
                FORMAT_API_STATUS "\n", Status ));
    }

    return(Status);

ErrorExit:

    NetpAssert( Status != NO_ERROR );

    if (Flags & ALLOCATE_RESPONSE) {
        //
        // If we already allocated a buffer on behalf of the caller of
        // RxRemoteApi, then free it up.
        //

        if (pDataBuffer != NULL) {
            (VOID) NetApiBufferFree(pDataBuffer);
        }

        //
        // We failed to allocate the buffer; this in turn will cause
        // RxRemoteApi to fail, in which event, the calling function
        // (ie RxNetXxxx) may try to free the buffer allocated on its
        // behalf (ie the buffer we just failed to get).  Ensure that
        // the caller doesn't try to free an invalid pointer by setting
        // the returned pointer to NULL.
        //

        NetpAssert( RcvDataBuffer != NULL );
        *(LPBYTE*)RcvDataBuffer = NULL;
    }

    NetpKdPrint(( PREFIX_NETAPI
            "RxpConvertBlock: returning error status="
            FORMAT_API_STATUS "\n", Status ));

    return (Status);

} // RxpConvertBlock
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\rpcxlate\rxcommon\logsize.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    LogSize.c

Abstract:

    This file contains RxpEstimateLogSize().

Author:

    John Rogers (JohnRo) 20-Jul-1992

Environment:

    Portable to any flat, 32-bit environment.  (Uses Win32 typedefs.)
    Requires ANSI C extensions: slash-slash comments, long external names.

Revision History:

    20-Jul-1992 JohnRo
        Created as part of fix for RAID 9933: ALIGN_WORST should be 8 for x86
        builds.

--*/

// These must be included first:

#include <windef.h>     // IN, DWORD, etc.
#include <lmcons.h>     // DEVLEN, NET_API_STATUS, etc.

// These may be included in any order:

#include <align.h>      // ALIGN_ROUND_UP(), etc.
#include <netdebug.h>   // NetpAssert().
#include <rxp.h>        // My prototype.
#include <winerror.h>   // NO_ERROR and ERROR_ equates.


#define MAX(a,b)          (((a) > (b)) ? (a) : (b))


//
// Estimate bytes needed for an audit log or error log array.
//
NET_API_STATUS
RxpEstimateLogSize(
    IN DWORD DownlevelFixedEntrySize,
    IN DWORD InputArraySize,    // input (downlevel) array size in bytes.
    IN BOOL DoingErrorLog,      // TRUE for error log, FALSE for audit log
    OUT LPDWORD OutputArraySizePtr
    )
{
    DWORD MaxEntries;
    DWORD OutputArraySize;
    DWORD PerEntryAdditionalSize;

    //
    // Error check the caller.
    //
    if (OutputArraySizePtr == NULL) {
        return (ERROR_INVALID_PARAMETER);
    } else if (DownlevelFixedEntrySize == 0) {
        return (ERROR_INVALID_PARAMETER);
    } else if (InputArraySize == 0) {
        return (ERROR_INVALID_PARAMETER);
    }


    //
    // Compute an initial size needed for output buffer, taking into account
    // per field expansion:
    //     WORDs expand into DWORDs
    //     ANSI strings expand into UNICODE
    //

#define WORD_EXPANSION_FACTOR   ( sizeof(DWORD) / sizeof(WORD) )
#define CHAR_EXPANSION_FACTOR   ( sizeof(TCHAR) / sizeof(CHAR) )

#define PER_FIELD_EXPANSION_FACTOR  \
    MAX( WORD_EXPANSION_FACTOR, CHAR_EXPANSION_FACTOR )

    OutputArraySize = InputArraySize * PER_FIELD_EXPANSION_FACTOR;


    //
    // There are several "per entry" expansions, so let's figure-out
    // the maximum number of entries we might have.
    //

    MaxEntries = ( (InputArraySize+DownlevelFixedEntrySize-1)
                          / DownlevelFixedEntrySize );
    NetpAssert( MaxEntries > 0 );


    //
    // Compute per-entry expansion specific to the kind of entry:
    //
    //     each audit entry gets:
    //
    //         DWORD  ae_data_size
    //
    //     each error log entry gets:
    //
    //         LPTSTR el_name
    //         LPTSTR el_text
    //         LPBYTE el_data
    //         DWORD  el_data_size
    //

    if (DoingErrorLog) {
        PerEntryAdditionalSize =
            sizeof(LPTSTR) + sizeof(LPTSTR) + sizeof(LPBYTE) + sizeof(DWORD);
    } else {
        PerEntryAdditionalSize = sizeof(DWORD);
    }

    OutputArraySize += (MaxEntries * PerEntryAdditionalSize);


    //
    // Compute per-entry expansion due to alignment requirements.
    //
    NetpAssert( ALIGN_WORST != 0 );
    OutputArraySize += ( MaxEntries * (ALIGN_WORST-1) );


    //
    // Double-check what we've done and tell caller.
    //

    NetpAssert( OutputArraySize > 0 );
    NetpAssert( OutputArraySize > InputArraySize );
    NetpAssert( OutputArraySize > MaxEntries );

    *OutputArraySizePtr = OutputArraySize;

    return (NO_ERROR);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\rpcxlate\rxcommon\convdata.c ===
/*++

Copyright (c) 1991-1993  Microsoft Corporation

Module Name:

    convdata.c

Abstract:

    RxpConvertDataStructures routine which converts 16- to 32-bit arrays of
    structures and vice versa.

Author:

    Richard Firth (rfirth) 03-Jul-1991

Revision History:

    03-Jul-1991 rfirth
        created
    15-Jul-1991 JohnRo
        Align each structure (e.g. in an array) if necessary.  This will,
        for instance, help print dest info level 1 handling.  Changed
        RxpConvertDataStructures to allow ERROR_MORE_DATA, e.g. for print APIs.
        Also, use DBG instead of DEBUG equate.
    17-Jul-1991 JohnRo
        Extracted RxpDebug.h from Rxp.h.
    07-Sep-1991 JohnRo
        Made changes suggested by PC-LINT.
    20-Nov-1991 JohnRo
        Clarify which routine an error message is from.
    21-Nov-1991 JohnRo
        Removed NT dependencies to reduce recompiles.
    18-May-1993 JohnRo
        DosPrintQGetInfoW underestimates number of bytes needed.
        Made changes suggested by PC-LINT 5.0
    21-Jun-1993 JohnRo
        RAID 14180: NetServerEnum never returns (alignment bug in
        RxpConvertDataStructures).

--*/



#include <windef.h>
#include <align.h>
#include <lmerr.h>
#include <rxp.h>                // My prototype.
#include <rxpdebug.h>           // IF_DEBUG().
#include <rap.h>
#include <netdebug.h>



NET_API_STATUS
RxpConvertDataStructures(
    IN  LPDESC  InputDescriptor,
    IN  LPDESC  OutputDescriptor,
    IN  LPDESC  InputAuxDescriptor OPTIONAL,
    IN  LPDESC  OutputAuxDescriptor OPTIONAL,
    IN  LPBYTE  InputBuffer,
    OUT LPBYTE  OutputBuffer,
    IN  DWORD   OutputBufferSize,
    IN  DWORD   PrimaryCount,
    OUT LPDWORD EntriesConverted OPTIONAL,
    IN  RAP_TRANSMISSION_MODE TransmissionMode,
    IN  RAP_CONVERSION_MODE ConversionMode
    )

/*++

Routine Description:

    A buffer containing 16- or 32-bit structures is converted to 32- or 16-bit
    structures resp. in a separate buffer. The structures may or may not have
    associated auxiliary structures. The output buffer is expected to be large
    enough to contain all the input data structures plus any variable length
    data items. Therefore, in the worst case, there must be enough space to
    convert all 16-bit items to 32-bits and convert ASCII strings to UNICODE.

    There may not be any auxiliary structures associated with the primaries,
    in which case the auxiliary descriptor pointers should BOTH BE NULL.

    Assumptions:

        IMPORTANT: The input buffer is assumed to have MEANINGFUL pointers.


Arguments:

    InputDescriptor - Pointer to string describing input primary data structure.

    OutputDescriptor - Pointer to string describing output primary data
        structure.

    InputAuxDescriptor - Pointer to string describing input auxiliary data
        structure.  May be NULL.

    OutputAuxDescriptor - Pointer to string describing output auxiliary data
        structure.  May be NULL.

    InputBuffer - Pointer to data area containing input structures.

    OutputBuffer - Pointer to data area where output structures will be placed.
        If the OutputBufferSize is too small, the contents of the output area
        is undefined.

    OutputBufferSize - Size of output buffer.

    PrimaryCount - Number of primary structures in InputBuffer.

    EntriesConverted - optionally points to a DWORD which will be filled-in
        with the number of entries actually converted.  This will be the same
        as PrimaryCount if we return NO_ERROR, but will be less if we return
        ERROR_MORE_DATA.

    TransmissionMode - Parameter to RapConvertSingleEntry.

    ConversionMode - Which 16- to 32-bit conversion to use.


Return Value:

    NET_API_STATUS - NERR_Success or ERROR_MORE_DATA.
        ( The callers of this routine assume these are the only two error codes.)

--*/

{
    NET_API_STATUS status;
    DWORD   input_structure_size;
    DWORD   output_structure_size;
    DWORD   input_aux_structure_size = 0;
    DWORD   output_aux_structure_size = 0;
    DWORD   input_alignment;
    DWORD   output_alignment;
    DWORD   input_aux_alignment = 0;
    DWORD   output_aux_alignment = 0;
    LPBYTE  aligned_input_buffer_start;
    LPBYTE  aligned_output_buffer_start;
    BOOL    auxiliaries = (InputAuxDescriptor != NULL);
    DWORD   aux_count_offset = 0;
    DWORD   aux_count = 0;
    DWORD   entries_fully_converted = 0;
    LPBYTE  next_input_structure;
    LPBYTE  next_output_structure;

    //
    // These next two variables are used by RapConvertSingleEntry which copies
    // stuff to the output buffer and informs us of the amount of space used or
    // required, depending on whether it has enough space to write the data; we
    // assume it will. RapConvertSingleEntry stores the fixed structures at the
    // head of the buffer and starts writing the variable parts (strings) at the
    // bottom. It uses variable_data_pointer as the next writable location for
    // the strings, and updates this variable as it writes to the area pointed to
    //

    LPBYTE  variable_data_pointer;
    DWORD   space_occupied = 0;

    //
    // if the conversion mode is NativeToRap or NativeToNative then the input
    // data is 32-bit. Same for output data
    //

    BOOL    input_is_32_bit = ConversionMode == NativeToRap || ConversionMode == NativeToNative;
    BOOL    output_is_32_bit = ConversionMode == RapToNative || ConversionMode == NativeToNative;


#if DBG
    //
    // the auxiliary data descriptors must be both NULL or both non-NULL
    //

    BOOL    aux_in, aux_out;

    aux_in = (InputAuxDescriptor != NULL);
    aux_out = (OutputAuxDescriptor != NULL);

    if (aux_in ^ aux_out)
    {
        NetpKdPrint(("RxpConvertDataStructures: "
                "InputAuxDescriptor & OutputAuxDescriptor out of sync\n"));
        NetpAssert(FALSE);
    }
#endif


    input_structure_size = RapStructureSize(InputDescriptor,
                                            TransmissionMode,
                                            input_is_32_bit
                                            );
    output_structure_size = RapStructureSize(OutputDescriptor,
                                            TransmissionMode,
                                            output_is_32_bit
                                            );
    input_alignment = RapStructureAlignment(InputDescriptor,
                                            TransmissionMode,
                                            input_is_32_bit
                                            );
    output_alignment = RapStructureAlignment(OutputDescriptor,
                                            TransmissionMode,
                                            output_is_32_bit
                                            );

    if (auxiliaries)
    {
        input_aux_structure_size = RapStructureSize(InputAuxDescriptor,
                                                    TransmissionMode,
                                                    input_is_32_bit
                                                    );
        output_aux_structure_size = RapStructureSize(OutputAuxDescriptor,
                                                    TransmissionMode,
                                                    output_is_32_bit
                                                    );
        input_aux_alignment = RapStructureAlignment(InputAuxDescriptor,
                                                    TransmissionMode,
                                                    input_is_32_bit
                                                    );
        output_aux_alignment = RapStructureAlignment(OutputAuxDescriptor,
                                                    TransmissionMode,
                                                    output_is_32_bit
                                                    );
        aux_count_offset = RapAuxDataCountOffset(InputDescriptor,
                                                TransmissionMode,
                                                input_is_32_bit
                                                );
    }

    //
    // Make sure first (only?) input and output structures are aligned.  (This
    // won't do anything for the RAP formats, but is critical for native.)
    //
    aligned_input_buffer_start = RapPossiblyAlignPointer(
            InputBuffer,
            input_alignment,
            input_is_32_bit);
    aligned_output_buffer_start = RapPossiblyAlignPointer(
            OutputBuffer,
            output_alignment,
            output_is_32_bit);

    //
    // We can't use the space we just skipped over, so update size accordingly.
    //
 
    OutputBufferSize -= (DWORD)(aligned_output_buffer_start - OutputBuffer);
    NetpAssert( OutputBufferSize >= 1 );

    //
    // Initialize roving pointers.
    //
    next_input_structure  = aligned_input_buffer_start;
    next_output_structure = aligned_output_buffer_start;
    variable_data_pointer = aligned_output_buffer_start + OutputBufferSize;

    //
    // For each primary structure, copy the input primary to the output buffer,
    // changing format as we go; copy any associated variable data at the end
    // of the output buffer. Then, if there is an aux count associated with
    // the primary, do the same action for the auxiliary structures and
    // associated strings/variable data
    //

    while (PrimaryCount--)
    {
        //
        // Convert the data for this instance of the primary structure.
        //
       status = RapConvertSingleEntryEx(
                next_input_structure,
                InputDescriptor,        // input desc
                FALSE,                  // input ptrs NOT meaningless
                aligned_output_buffer_start,
                next_output_structure,
                OutputDescriptor,
                FALSE,                  // don't set offsets (want ptrs)
                &variable_data_pointer,
                &space_occupied,
                TransmissionMode,       // as supplied in parameters
                ConversionMode,         // as supplied in parameters
                (ULONG_PTR)InputBuffer
                );
        NetpAssert( status == NERR_Success );

        if (space_occupied > OutputBufferSize)
        {
            IF_DEBUG(CONVDATA) {
                NetpKdPrint(("RxpConvertDataStructures: "
                        "output buffer size blown by primary\n"));
            }
            status = ERROR_MORE_DATA;
            goto Cleanup;
        }

        //
        // if we have auxiliary structs, pull out the number associated
        // with this primary struct from the primary struct itself
        // before pointing to the next copy location (this allows us to
        // handle the case where there are a variable number of aux
        // structs per each primary. There may not be such a case, but
        // this is defensive programming)
        //

        if (auxiliaries)
        {
            if (input_is_32_bit)
            {
                aux_count = *(LPDWORD)(next_input_structure + aux_count_offset);
            }
            else
            {
                aux_count = *(LPWORD)(next_input_structure + aux_count_offset);
            }
        }

        //
        // Bump to next element of each array (or just beyond end, if we're
        // done).
        //
        next_input_structure  += input_structure_size;
        next_output_structure += output_structure_size;

        //
        // Make sure each primary structure is aligned.  (This won't do anything
        // for the RAP formats, but is critical for native.)
        //
        next_input_structure = RapPossiblyAlignPointer(
                next_input_structure, input_alignment, input_is_32_bit);

        {
            DWORD NextOutputAlignment =
                    (DWORD)((LPBYTE) (RapPossiblyAlignPointer(
                            next_output_structure,
                                    output_alignment,
                                    output_is_32_bit))
                    -  next_output_structure);

            NetpAssert( NextOutputAlignment < ALIGN_WORST );
            if (NextOutputAlignment > 0) {
                next_output_structure += NextOutputAlignment;
                space_occupied        += NextOutputAlignment;
            }
        }

        //
        // use aux_count to determine whether loop should be performed
        //

        while (aux_count)
        {
            //
            // Convert the data for this instance of the secondary structure.
            //
            status = RapConvertSingleEntryEx(
                    next_input_structure,
                    InputAuxDescriptor,
                    FALSE,                  // input ptrs NOT meaningless
                    aligned_output_buffer_start,
                    next_output_structure,
                    OutputAuxDescriptor,
                    FALSE,                  // don't set offsets (want ptrs)
                    &variable_data_pointer,
                    &space_occupied,
                    TransmissionMode,       // as supplied in parameters
                    ConversionMode,         // as supplied in parameters
                    (ULONG_PTR)InputBuffer
                    );
            NetpAssert( status == NERR_Success );

            if (space_occupied > OutputBufferSize)
            {
                IF_DEBUG(CONVDATA) {
                    NetpKdPrint(("RxpConvertDataStructures: "
                            "output buffer size blown by secondary\n"));
                }
                status = ERROR_MORE_DATA;
                goto Cleanup;
            }

            next_input_structure += input_aux_structure_size;
            next_output_structure += output_aux_structure_size;
            --aux_count;

            //
            // Make sure next structure (if any) is aligned.  (This won't do
            // anything for the RAP formats, but is critical for native.)
            //
            next_input_structure = RapPossiblyAlignPointer(
                    next_input_structure,
                    input_aux_alignment,
                    input_is_32_bit);
            next_output_structure = RapPossiblyAlignPointer(
                    next_output_structure,
                    output_aux_alignment,
                    output_is_32_bit);
            space_occupied = RapPossiblyAlignCount(
                    space_occupied,
                    output_aux_alignment,
                    output_is_32_bit);

        } // while (aux_count)

        ++entries_fully_converted;

    } // while (primary_count--)

    status = NERR_Success;

Cleanup:

    if (EntriesConverted != NULL) {
        *EntriesConverted = entries_fully_converted;
    }

    return (status);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\rpcxlate\rxcommon\pack.c ===
/*++

Copyright (c) 1987-91  Microsoft Corporation

Module Name:

    Pack.c

Abstract:

    This module just contains RxpPackSendBuffer.

Author:

    John Rogers (JohnRo) 01-Apr-1991

Environment:

    Portable to any flat, 32-bit environment.  (Uses Win32 typedefs.)
    Requires ANSI C extensions: slash-slash comments, long external names.

Revision History:

    (various NBU people)
        LanMan 2.x code
    01-Apr-1991 JohnRo
        Created portable version from LanMan 2.x sources.
    13-Apr-1991 JohnRo
        Reduced recompile hits from header files.
    03-May-1991 JohnRo
        Don't use NET_API_FUNCTION for non-APIs.
    14-May-1991 JohnRo
        Clarify that descriptors are 32-bit versions.  Use more typedefs.
    19-May-1991 JohnRo
        Make LINT-suggested changes.
    13-Jun-1991 JohnRo
        Allow setinfo when pointers point to current structure.
        Added debug code.  Descriptors are really 16-bit versions.
    03-Jul-1991 rfirth
        Extensive reworking to get variable data area copy working correctly
        and also remove some code which resulted from bogus assumptions
    17-Jul-1991 JohnRo
        Extracted RxpDebug.h from Rxp.h.
    13-Sep-1991 JohnRo
        Made changes suggested by PC-LINT.
    01-Oct-1991 JohnRo
        More work toward UNICODE.
    21-Nov-1991 JohnRo
        Removed NT dependencies to reduce recompiles.
    06-Dec-1991 JohnRo
        Avoid alignment error on MIPS.

--*/



// These must be included first:

#include <windef.h>             // IN, DWORD, LPTSTR, etc.
#include <rxp.h>                // RpcXlate private header file.

// These may be included in any order:

#include <apiworke.h>           // RANGE_F(), BUF_INC.
#include <lmerr.h>              // NERR_ and ERROR_ equates.
#include <netdebug.h>           // NetpAssert(), FORMAT_ equates.
#include <netlib.h>             // NetpMemoryAllocate(), etc.
#include <remtypes.h>           // REM_BYTE, etc.
#include <rxpdebug.h>           // IF_DEBUG().
#include <smbgtpt.h>            // SmbGetUlong(), SmbGetUshort().
#include <string.h>             // strlen()


// LPVOID
// RxpGetUnalignedPointer(
//     IN LPVOID * Input
//     );
//
// This macro may have to change if we run on a big-endian machine.
#if defined(_WIN64)
LPVOID RxpGetUnalignedPointer( LPBYTE Input ) 
{
    LARGE_INTEGER pointer;

    pointer.LowPart = SmbGetUlong( (LPDWORD)Input );
    pointer.HighPart = SmbGetUlong( (LPDWORD)(Input+4) );

    return (LPVOID)pointer.QuadPart;
}
#else
#define RxpGetUnalignedPointer(Input) \
    ( (LPVOID) SmbGetUlong( (LPDWORD) (Input) ) )
#endif


NET_API_STATUS
RxpPackSendBuffer(
    IN OUT LPVOID *SendBufferPointerPointer,
    IN OUT LPDWORD SendBufferLengthPointer,
    OUT LPBOOL AllocFlagPointer,
    IN LPDESC DataDesc16,
    IN LPDESC AuxDesc16,
    IN DWORD FixedSize16,
    IN DWORD AuxOffset,
    IN DWORD AuxLength,
    IN BOOL SetInfo
    )

/*++

Routine Description:

    RxpPackSendBuffer - set up the send buffer for transport across the net.

    This routine exists specifically to 'undo' some of the work done by
    RapConvertSingleEntry. The input buffer contains structures and variable
    data which are to be transmitted to a down-level server. The buffer
    contains 16-bit data with 32-bit pointers to variable data items WHICH ARE
    CONTAINED IN THE SAME BUFFER. RapConvertSingleEntry puts variable data in
    the buffer in the wrong order (see picture). Down-level servers expect
    variable data to be in the same order as described in the data descriptor
    strings. They assume this because they fix-up the pointers to the variable
    data based on knowing the start of the variable data, its type and length.
    It is for this reason that we must put the strings in the right order and
    it is this reason which mandates that WE DO NOT HAVE TO SUPPLY GOOD
    POINTERS OR OFFSETS in the pointer fields, since after this routine, nobody
    else cares about them

    We may get this:                        But down-level needs this:

      ----------------------                 ----------------------
      | Primary structure  |                 | Primary structure  |
      |     string pointer -------           |     string pointer -------
      |     string pointer ------|           |     string pointer ------|
      |--------------------|    ||           |--------------------|    ||
      | aux structure      |    ||           | aux structure      |    ||
      |     string pointer -----||           |     string pointer -----||
      |     string pointer ----|||           |     string pointer ----|||
      |--------------------|  ||||           |--------------------|  ||||
      |     string # 4     | <-|||           |     string # 1     | <----
      |--------------------|   |||           |--------------------|  |||
      |     string # 3     | <--||           |     string # 2     | <---
      |--------------------|    ||           |--------------------|  ||
      |     string # 2     | <---|           |     string # 3     | <--
      |--------------------|     |           |--------------------|  |
      |     string # 1     | <----           |     string # 4     | <-
      ----------------------                 ----------------------

    Assumes:

        1.  Only 1 primary structure in the send buffer

        2.  The down-level code DOES NOT ACTUALLY USE the pointer fields, but
            rather, performs its own-fixups & pointer generation based on the
            data descriptor and RELATIVE POSITION of variable data within the
            buffer, hence the need for re-ordering

            * IF THIS ASSUMPTION IS NOT VALID, THIS CODE IS POTENTIALLY BROKEN *

        3.  The action this routine performs is SPECIFICALLY to re-order the
            strings in the buffer as shown above. The routine
            RapConvertSingleEntry was used to pack the structures and variable
            data into the buffer. There is no spare space in the buffer

        4.  No other routines after this expect the pointer fields to be valid

        5.  Strings have already been converted from TCHARs to the correct
            codepage.

        6.  The pointers in the structure need not be on DWORD boundaries.


Arguments:

    SendBufferPointerPointer - Points to pointer to the send data.  This area
        will be reallocated if necessary, and the pointer updated.

    SendBufferLengthPointer - Points to the send data length.  The caller sets
        this to the length of the area at SendBufferPointerPointer.  If
        RxPackSendBuffer reallocates that memory, SendBufferLengthPointer will
        be updated to reflect the new length.

    AllocFlagPointer - Points to a BOOL which is set by this routine.  To
        indicate that the send buffer memory has been reallocated.

    DataDesc16 - Gives descriptor string for data.

    AuxDesc16 - Gives descriptor string for aux structure.

    FixedSize16 - Gives size of fixed data structure, in bytes.

    AuxOffset - Gives position (offset) of N in data structure.  (May be
        NO_AUX_DATA.)

    AuxLength - Gives size of aux structure in bytes.

    SetInfo - Indicates whether the API is a setinfo-type (or add-type).

Return Value:

    NET_API_STATUS.

--*/


{
    LPBYTE  struct_ptr;
    LPBYTE  c_send_buf; // Caller's (original) send buffer.
    DWORD   c_send_len; // Caller's (original) send buffer size.
    DWORD   buf_length;
    DWORD   to_send_len;
    DWORD   num_aux;
    LPBYTE  data_ptr;
    BOOL    Reallocated;
    DWORD   i,j;
    LPDESC  l_dsc;      // Pointer to each field's desc.
    LPDESC  l_str;      // Pointer to each desc (DataDesc16, then AuxDesc16).
    DWORD   num_struct;
    DWORD   len;
    DWORD   num_its;
    DESC_CHAR c;

    //
    // we can't perform the string/variable data re-ordering in situ because
    // one or more of the strings will get trampled. We try and create a copy
    // of the input buffer to copy the variable data out of
    //

    LPBYTE  duplicate_buffer = NULL;
    LPBYTE  source_address;     // source for copy


    DBG_UNREFERENCED_PARAMETER(SetInfo);


    //
    // Make local copies of the original start and length of the caller's
    // buffer as the originals may change if NetpMemoryReallocate is used but
    // they will still be needed for the RANGE_F check.
    //

    c_send_buf = *SendBufferPointerPointer; // caller's original buffer
    c_send_len = *SendBufferLengthPointer;  // caller's original buffer length

    Reallocated = FALSE;

    //
    // Due to the specific nature of this routine, these checks should be
    // redundant since we have already worked out beforehand the requirements
    // for buffer size. PROVE THIS THEN DELETE THIS CODE
    //

    if ((c_send_len < FixedSize16) || (AuxOffset == FixedSize16)) {
        return NERR_BufTooSmall;
    }

    if (AuxOffset != NO_AUX_DATA) {
        num_aux = (WORD) SmbGetUshort( (LPWORD) (c_send_buf + AuxOffset) );
        to_send_len = FixedSize16 + (num_aux * AuxLength);

        //
        // see above about redundant code
        //

        if (c_send_len < to_send_len) {
            return NERR_BufTooSmall;
        }
        num_its = 2;
    } else {
        to_send_len = FixedSize16;
        num_aux = AuxLength = 0;
        num_its = 1;                /* One structure type to look at */
    }

    IF_DEBUG(PACK) {
        NetpKdPrint(( "RxpPackSendBuffer: initial (fixed) buffer at "
                FORMAT_LPVOID ":\n", (LPVOID)c_send_buf));
        NetpDbgHexDump(c_send_buf, to_send_len);
    }

    //
    // get a duplicate copy of the original buffer. We will use this to copy
    // the variable data into. This buffer will be returned to the caller, not
    // the original!
    //

    buf_length = c_send_len;    // buf_length may be reallocated (?)
    duplicate_buffer = NetpMemoryAllocate(buf_length);
    if (duplicate_buffer == NULL) {
        return ERROR_NOT_ENOUGH_MEMORY; // gasp!
    }

    //
    // Now copy the contents of the original buffer to the duplicate. The
    // duplicate will have pointers to the data in the original data buffer
    // that's why we copy from the original to the duplicate, fix up pointers
    // in the duplicate (even though we don't need to?) and return the
    // duplicate to the caller
    //

    NetpMoveMemory(duplicate_buffer, c_send_buf, c_send_len);

    //
    // struct_ptr point into duplicate_buffer. struct_ptr is updated to point
    // to the next field in the structure for every descriptor token in the
    // descriptor string
    //

    struct_ptr = duplicate_buffer;

    //
    // Set up the data pointer to point past fixed length structures. Note this
    // is in the duplicate structure - that's where we're going to copy the
    // data
    //

    data_ptr = duplicate_buffer + to_send_len;

    //
    // for the primary and aux structures, check any pointer designations
    // in the respective descriptor string and if not NULL copy the data
    // into the duplicate buffer
    //

    l_str = DataDesc16;
    num_struct = 1;                /* Only one primary structure allowed */

    for (i = 0;  i < num_its; l_str = AuxDesc16, num_struct = num_aux, i++) {
        for (j = 0 , l_dsc = l_str; j < num_struct; j++, l_dsc = l_str) {
            for (; (c = *l_dsc) != '\0'; l_dsc++) {
                IF_DEBUG(PACK) {
                    NetpKdPrint(( "RxpPackSendBuffer: processing desc char '"
                            FORMAT_DESC_CHAR "', struct ptr="
                            FORMAT_LPVOID ".\n", c, struct_ptr ));
                }

                //
                // if the next field in the structure is a pointer type then
                // if it is not NULL, copy the data into the buffer
                //

                if (RapIsPointer(c)) {

                    //
                    // Get pointer value.  Note that it may not be aligned!
                    //

                    source_address =
                            (LPBYTE) RxpGetUnalignedPointer( struct_ptr );
                    IF_DEBUG(PACK) {
                        NetpKdPrint(( "RxpPackSendBuffer: "
                                "got source address " FORMAT_LPVOID "\n",
                                (LPVOID) source_address ));
                    }

                    //
                    // Check for NULL pointer.  If so then skip over this
                    // field and continue
                    //

                    if (source_address == NULL) {
                        struct_ptr += sizeof(LPBYTE *);

                        IF_DEBUG(PACK) {
                            NetpKdPrint(( "RxpPackSendBuffer: "
                                    "getting array len\n" ));
                        }

                        //
                        // wind descriptor string forward to next field or
                        // end of string
                        //

                        (void) RapArrayLength(l_dsc, &l_dsc, Both);

                        IF_DEBUG(PACK) {
                            NetpKdPrint(( "RxpPackSendBuffer: "
                                    "done getting array len\n" ));
                        }
                    } else {

                        //
                        // here if non-NULL pointer
                        //

                        switch( c ) {
                        case REM_ASCIZ :
                        case REM_ASCIZ_TRUNCATABLE:
                            IF_DEBUG(PACK) {
                                NetpKdPrint(( "RxpPackSendBuffer: "
                                                "getting string len\n" ));
                            }

                            //
                            // Note: we don't have to handle UNICODE here,
                            // as our caller has already done that.
                            //

                            len = strlen( (LPSTR) source_address ) + 1;

                            //
                            // Skip over maximum length count.
                            //

                            (void) RapArrayLength(l_dsc, &l_dsc, Both);

                            IF_DEBUG(PACK) {
                                NetpKdPrint(( "RxpPackSendBuffer: "
                                        "done getting string len\n" ));
                            }
                            break;

                        case REM_SEND_LENBUF :
                            len = *(LPWORD)source_address;
                            break;

                        default:
                            len = RapArrayLength(l_dsc, &l_dsc, Both);
                        }

                        /* There is data to be copied into the send
                         * buffer so check that it will fit.
                         */

                        //
                        // This shouldn't happen (I think). If it does,
                        // it suggests we made a miscalculation somewhere. IF
                        // THAT'S THE CASE, FIND THE MISCALCULATION AND REMOVE
                        // THIS CODE
                        //

                        if ((to_send_len += len) > buf_length) {
                            LPBYTE  ptr;

                    #ifdef DBG
                            //
                            // let me know what's going on. Again, if this
                            // happens then we should check other code to
                            // ensure it can't be helped. In theory, before
                            // we got here (this routine), we calculated all
                            // the data requirements and allocated a buffer
                            // sufficient to hold everything. Hence we should
                            // not need to re-allocate
                            //

                            NetpKdPrint(("WARNING: attempting re-allocation of "
                                        "data buffer. Shouldn't be doing this?\n"
                                        ));
                            NetpBreakPoint();
                    #endif

                            buf_length = to_send_len + BUF_INC;

                            //
                            // note: if this fails then I assume the
                            // original pointer in *SendBufferPointerPointer
                            // is still valid and the caller will still
                            // free it
                            //

                            ptr = (LPBYTE)NetpMemoryReallocate(duplicate_buffer,
                                                                buf_length);
                            if (!ptr) {
                                NetpMemoryFree(duplicate_buffer);
                                return ERROR_NOT_ENOUGH_MEMORY; // gasp!
                            }

                            //
                            // let caller know buffer he gets back may not
                            // be same as that passed in. Although, this
                            // shouldn't be a problem.
                            // Footnote: *Why* do we indicate this fact?
                            //

                            Reallocated = TRUE;

                            //
                            // re-fix various pointers. We can't make any
                            // assumptions about ptr (can we?)
                            //

                            duplicate_buffer = ptr;
                            struct_ptr = ptr + (struct_ptr - duplicate_buffer);
                            data_ptr = ptr + (data_ptr - duplicate_buffer);
                        }

                        /* There is room for new data in buffer so copy
                         * it and and update the struct and data ptrs
                         */

                        IF_DEBUG(PACK) {
                            NetpKdPrint(( "RxpPackSendBuffer: moving...\n"));
                        }

                        NetpMoveMemory(data_ptr, source_address, len);

                        IF_DEBUG(PACK) {
                            NetpKdPrint(( "RxpPackSendBuffer: moved.\n"));
                        }

                        //
                        // update data_ptr to point to the next place to copy
                        // data in duplicate_buffer. Bump the fixed structure
                        // pointer to the next field
                        //

                        data_ptr += len;
                        struct_ptr += sizeof(LPBYTE*);
                    }
                } else {

                    //
                    // here if the next thing in the descriptor does not identify
                    // a pointer
                    //

                    //
                    // adjust the structure pointer to the next field
                    //

                    struct_ptr += RapGetFieldSize(l_dsc, &l_dsc, Both);
                }
            }
        }
    }

    /* Finished process send data, avoid sending the free space at
     * the end of the buffer by reducing send_data_length to
     * send_length.
     */

    IF_DEBUG(PACK) {
        NetpKdPrint(( "RxpPackSendBuffer: final buffer at "
                FORMAT_LPVOID ":\n", (LPVOID) struct_ptr ));
        NetpDbgHexDump(duplicate_buffer, to_send_len );
    }

    //
    // return to the caller the new address of his buffer - this will always
    // be duplicate_buffer. If we had to reallocate (and we shouldn't!) return
    // the size of the new buffer
    //

    *SendBufferPointerPointer = duplicate_buffer;   // May have been reallocated.
    *SendBufferLengthPointer = to_send_len;
    *AllocFlagPointer = Reallocated;    // caller doesn't need to know this!

    //
    // free the caller's original buffer. We now have a buffer which has the
    // strings in the correct order. However, it is not the same buffer as that
    // which the user passed in, nor are any of the pointer fields valid. See
    // assumption 2 above
    //

    NetpMemoryFree(c_send_buf);

    return NERR_Success;

} // RxpPackSendBuffer
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\rpcxlate\rxcommon\rcvconv.c ===
/*++

Copyright (c) 1987-1993  Microsoft Corporation

Module Name:

    RcvConv.c

Abstract:

    This module contains support routines for the RpcXlate code.

Author:

    John Rogers (JohnRo) 01-Apr-1991  (NT version)
    (unknown Microsoft programmer)    (original LM 2.x version)

Environment:

    Portable to any flat, 32-bit environment.  (Uses Win32 typedefs.)
    Requires ANSI C extensions: slash-slash comments, long external names.

Revision History:

    (various NBU people)
        LanMan 2.x code
    01-Apr-1991 JohnRo
        Created portable version from LanMan 2.x sources.
    13-Apr-1991 JohnRo
        Added some (quiet) debug output.
        Reduced recompile hits from header files.
    03-May-1991 JohnRo
        Don't use NET_API_FUNCTION for non-APIs.
    11-May-1991 JohnRo
        Fixed string ptr bug in RxpSetPointer().  Added assertions and.
        debug output.
    13-May-1991 JohnRo
        Use DESC_CHAR typedef.  Print num_aux for debugging.
    17-May-1991 JohnRo
        Handle array of aux structs.
    19-May-1991 JohnRo
        Make LINT-suggested changes (use DBGSTATIC).
    20-May-1991 JohnRo
        Cast expression in RxpSetPointer more carefully.
    02-Jun-1991 JohnRo
        Allow use on big-endian machines.  (PC-LINT discovered a portability
        problem.)
    17-Jul-1991 JohnRo
        Extracted RxpDebug.h from Rxp.h.
    10-Sep-1991 JohnRo
        Made changes suggested by PC-LINT.
    13-Nov-1991 JohnRo
        RAID 4408: Fixed MIPS alignment problems.
    21-Nov-1991 JohnRo
        Removed NT dependencies to reduce recompiles.
    07-May-1993 JohnRo
        RAID 6167: avoid access violation or assert with WFW print server.
        Corrected copyright and authorship.
        Use NetpKdPrint() where possible.
        Use PREFIX_ equates.

--*/


// These must be included first:

#include <windef.h>             // IN, DWORD, VOID, etc.
#include <rxp.h>                // Private header file.

// These may be included in any order:

#include <netdebug.h>           // NetpKdPrint(), FORMAT_ equates, etc.
#include <netlib.h>             // NetpPointerPlusSomeBytes(), etc.
#include <prefix.h>     // PREFIX_ equates.
#include <remtypes.h>           // REM_BYTE, etc.
#include <rxpdebug.h>           // IF_DEBUG().
#include <rapgtpt.h>            // RapGetWord(), etc.
#include <winbase.h>


// Inputs to this function haven't been converted to 32-bit yet.
#define INPUTS_ARE_NATIVE   FALSE


DBGSTATIC NET_API_STATUS
RxpSetPointer(
    IN     LPBYTE   RcvBufferStart,
    IN     DWORD    RcvDataSize,
    IN OUT LPBYTE * RcvPointerPointer,
    IN     DWORD    Converter
    );

DWORD
RxpGetFieldSizeDl(
    IN     LPDESC   TypePointer,
    IN OUT LPDESC * TypePointerAddress,
    IN RAP_TRANSMISSION_MODE TransmissionMode
    );

NET_API_STATUS
RxpReceiveBufferConvert(
    IN OUT LPVOID  RcvDataPointer,
    IN     DWORD   RcvDataSize,
    IN     DWORD   Converter,
    IN     DWORD   NumberOfStructures,
    IN     LPDESC  DataDescriptorString,
    IN     LPDESC  AuxDescriptorString,
    OUT    LPDWORD NumAuxStructs
    )

/*++

Routine Description:

    RxpReceiveBufferConvert corrects all pointer fields present in a receive
    buffer.  All pointers in the receive buffer are returned from the API
    worker as pointers into the buffer position given to the API on the API
    worker's station.

    This routine steps through the receive buffer and calls RxpSetPointer to
    perform the pointer conversions.  On exit, all pointers (except NULL
    pointers) in receive buffer converted to local format.

Arguments:

    RcvDataPointer - Pointer to receive buffer.  This will be updated in place.

    RcvDataSize - Length of the data area that RcvDataPointer points to.

    Converter - Converter word from API worker.

    NumberOfStructures - Entries read parm (or 1 for GetInfo).

    DataDescriptorString - Descriptor string for data format.

    AuxDescriptorString - Descriptor string for aux format.

    NumAuxStructs - Points to a DWORD which will be set with the number
        of entries in the aux array.  (This will be set to 0 if none.)

Return Value:

    NET_API_STATUS (NO_ERROR or ERROR_INVALID_PARAMETER).

--*/

{
    NET_API_STATUS ApiStatus;
    DESC_CHAR c;
    DWORD i,j;
    LPBYTE data_ptr;
    LPBYTE end_of_data;
    LPDESC l_data;
    LPDESC l_aux;

    NetpAssert( RcvDataPointer != NULL );
    NetpAssert( RcvDataSize != 0 );
    NetpAssert( NumAuxStructs != NULL );

    data_ptr = RcvDataPointer;                  /* start of rcv data buffer */
    end_of_data = NetpPointerPlusSomeBytes( RcvDataPointer, RcvDataSize );

    IF_DEBUG(RCVCONV) {
        NetpKdPrint(( PREFIX_NETAPI
                "RxpReceiveBufferConvert: starting, Converter="
                FORMAT_HEX_DWORD "...\n", Converter ));
    }

    *NumAuxStructs = 0;

    for (i = 0; i < NumberOfStructures; i++) {  /* For each entries read */

        for (l_data=DataDescriptorString; (c = *l_data) != '\0'; l_data++) {
            if (c == REM_AUX_NUM) {
                *NumAuxStructs = RapGetWord( data_ptr, INPUTS_ARE_NATIVE );
                IF_DEBUG(RCVCONV) {
                    NetpKdPrint(( PREFIX_NETAPI
                            "RxpReceiveBufferConvert: num aux is now "
                            FORMAT_DWORD ".\n", *NumAuxStructs ));
                }
            }

            if (RapIsPointer(c)) {        /* If field is pointer */
                ApiStatus = RxpSetPointer(
                        RcvDataPointer,
                        RcvDataSize,
                        (LPBYTE *) data_ptr,
                        Converter);
                if (ApiStatus != NO_ERROR) {
                    goto Cleanup;
                }
            }
            data_ptr += RxpGetFieldSizeDl( l_data, &l_data, Both);
            if (data_ptr > end_of_data) {
                ApiStatus = ERROR_INVALID_PARAMETER;
                goto Cleanup;
            }
        }

        for (j = 0; j < *NumAuxStructs; j++) {        /* For each aux struct */
            for (l_aux = AuxDescriptorString; (c = *l_aux) != '\0'; l_aux++) {
                if (RapIsPointer(c)) { /* If field is pointer */
                    ApiStatus = RxpSetPointer(
                            RcvDataPointer,
                            RcvDataSize,
                            (LPBYTE *) data_ptr,
                            Converter);
                    if (ApiStatus != NO_ERROR) {
                        goto Cleanup;
                    }
                }
                data_ptr += RxpGetFieldSizeDl( l_aux, &l_aux, Both);
                if (data_ptr > end_of_data) {
                    ApiStatus = ERROR_INVALID_PARAMETER;
                    goto Cleanup;
                }
            }
        }
    }

    ApiStatus = NO_ERROR;

Cleanup:

    IF_DEBUG(RCVCONV) {
        NetpKdPrint(( PREFIX_NETAPI
                "RxpReceiveBufferConvert: done, status="
                FORMAT_API_STATUS ".\n", ApiStatus ));
    }
    return (ApiStatus);

} // RxpReceiveBufferConvert


DBGSTATIC NET_API_STATUS
RxpSetPointer(
    IN     LPBYTE   RcvBufferStart,
    IN     DWORD    RcvDataSize,
    IN OUT LPBYTE * RcvPointerPointer,
    IN     DWORD    Converter
    )

/*++

Routine Description:

    RxpSetPointer corrects a pointer field in the rcv buffer.  All pointers in
    the receive buffer are returned from the API worker as
    pointers into the buffer position given to the API on the API worker's
    station.  The pointer will be set to:

        addr(rcv buffer) + pointer - converter word.

    This routine performs the above conversion on a rcv buffer pointer.  On
    exit, the pointer (unless NULL) in receive buffer will be converted to
    local format.

Arguments:

    RcvBufferStart - pointer to start of receive buffer.

    RcvDataSize - Length of the data area that RcvBufferStart points to.

    RcvPointerPointer - pointer to pointer to convert.

    Converter - Converter word from API worker.

Return Value:

    NET_API_STATUS (NO_ERROR or ERROR_INVALID_PARAMETER).

--*/

{
    DWORD BufferOffsetToData;   // offset within buffer
    DWORD OldOffset;            // offset within segment

    NetpAssert( ! RapValueWouldBeTruncated(Converter) );
    NetpAssert(RcvBufferStart != NULL);
    NetpAssert(RcvPointerPointer != NULL);
    NetpAssert(
            ((LPBYTE)(LPVOID)RcvPointerPointer)     // First byte of pointer
            >= RcvBufferStart );                    // can't be before buffer.
    NetpAssert(
            (((LPBYTE)(LPVOID)RcvPointerPointer) + sizeof(NETPTR)-1)
                                                    // Last byte of pointer
            <= (RcvBufferStart+RcvDataSize) );      // can't be after buffer.

    //
    // Null pointer is (segment:offset) 0:0, which just appears as 4 bytes
    // of zeros.  Check for that here.
    //

    if (RapGetDword( RcvPointerPointer, INPUTS_ARE_NATIVE ) == 0) {
        return (NO_ERROR);
    }

    // OK, this gets fun.  What's in the buffer is a 2 byte offset followed
    // by a 2 byte (useless) segment number.  So, we cast to LPWORD to get
    // the offset.  We'll adjust the offset by the converter to 

    OldOffset = (DWORD) RapGetWord( RcvPointerPointer, INPUTS_ARE_NATIVE );
    IF_DEBUG(RCVCONV) {
        NetpKdPrint(( PREFIX_NETAPI
                "RxpSetPointer: OldOffset is " FORMAT_HEX_DWORD
                ".\n", OldOffset ));
    }

    BufferOffsetToData = (DWORD) (( OldOffset - (WORD) Converter ) & 0xffff);

    IF_DEBUG(RCVCONV) {
        NetpKdPrint(( PREFIX_NETAPI
                "RxpSetPointer: BufferOffsetToData is " FORMAT_HEX_DWORD
                ".\n", BufferOffsetToData ));
    }

    //
    // Make sure that what we point to is still in the buffer.
    //

    if (BufferOffsetToData >= RcvDataSize) {
        NetpKdPrint(( PREFIX_NETAPI
                "RxpSetPointer: *** BUFFER OFFSET TOO LARGE *** "
                "(conv=" FORMAT_HEX_DWORD ", "
                "offset=" FORMAT_HEX_DWORD ", "
                "size=" FORMAT_HEX_DWORD ").\n",
                Converter, BufferOffsetToData, RcvDataSize ));
        return (ERROR_INVALID_PARAMETER);
    }

#if defined (_WIN64)

    //
    // Store only the 32-bit buffer offset.  Later, RapGetPointer() will
    // add the buffer start address.
    //

    RapPutDword( RcvPointerPointer,
                 BufferOffsetToData,
                 INPUTS_ARE_NATIVE );

#else

    //
    // For 32-bit, the pointers are stored directly, and will be retrieved
    // directly from RapGetPointer().
    // 

    RapPutDword(RcvPointerPointer,
            NetpPointerPlusSomeBytes( RcvBufferStart, BufferOffsetToData ),
            INPUTS_ARE_NATIVE);

#endif

    return (NO_ERROR);

} // RxpSetPointer


DWORD
RxpGetFieldSizeDl(
    IN     LPDESC   TypePointer,
    IN OUT LPDESC * TypePointerAddress,
    IN RAP_TRANSMISSION_MODE TransmissionMode
    )
/*++

Routine Description:

    This is a wrapper for RapGetFieldSize().

    The pointer fields in the downlevel buffers that this module deals with
    are always 32 bits in width.  RapGetFieldSize(<somepointertype>) will
    return the size of a native pointer, which is not necessarily 32 bits
    in width.

    This wrapper overrides the result of RapGetFieldSize() with sizeof(DWORD)
    for all pointer types.

    See the description of RapGetFieldSize() for additional info.

--*/
{
    DWORD fieldSize;
    BOOL  isPointer;

    fieldSize = RapGetFieldSize( TypePointer,
                                 TypePointerAddress,
                                 TransmissionMode );
#if defined (_WIN64)

    isPointer = RapIsPointer(*TypePointer);
    if (isPointer != FALSE){

        fieldSize = sizeof(DWORD);
    }

#endif

    return fieldSize;

} // RxpGetFieldSizeDl
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\rpcxlate\rxcommon\reqsize.c ===
/*++

Copyright (c) 1991-92  Microsoft Corporation

Module Name:

    ReqSize.c

Abstract:

    This contains RxpComputeRequestBufferSize.  This returns the size (in
    bytes) necessary to hold the request buffer.

Author:

    John Rogers (JohnRo) 20-Aug-1991

Revision History:

    11-May-1991 JohnRo
        Created.
    20-Aug-1991 JohnRo
        Changed to move toward UNICODE possibility.  Added this header.
    31-Mar-1992 JohnRo
        Prevent too large size requests.

--*/


// These must be included first:

#include <windef.h>     // DWORD, IN, OPTIONAL, WORD, etc.
#include <lmcons.h>     // NET_API_STATUS

// These may be included in any order:

#include <netdebug.h>   // NetpAssert().
#include <rap.h>        // DESC_CHAR, LPDESC, etc.
#include <rxp.h>        // My prototype, MAX_TRANSACT_ equates.


DWORD
RxpComputeRequestBufferSize(
    IN LPDESC ParmDesc,
    IN LPDESC DataDescSmb OPTIONAL,
    IN DWORD DataSize
    )
{
    DWORD BytesNeeded;

    NetpAssert( ParmDesc != NULL );
    NetpAssert( RapIsValidDescriptorSmb( ParmDesc ) );
    if (DataDescSmb != NULL) {
        NetpAssert( RapIsValidDescriptorSmb( DataDescSmb ) );
    }

    BytesNeeded = sizeof(WORD)  // api number
            + DESCLEN( ParmDesc ) + 1;
    if (DataDescSmb != NULL) {
        BytesNeeded += DESCLEN( DataDescSmb ) + 1;
    } else {
        BytesNeeded += 1;  // just null char
    }

    BytesNeeded += DataSize;

    NetpAssert( BytesNeeded <= MAX_TRANSACT_SEND_PARM_SIZE );

    return (BytesNeeded);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\rpcxlate\rxcommon\remote.c ===
/*++

Copyright (c) 1987-1993  Microsoft Corporation

Module Name:

    Remote.c

Abstract:

    Provides a support routine, RxRemoteAPI, for transporting
    an API request to a remote API worker and translating its response.

Author:

    John Rogers (JohnRo) and a cast of thousands.

Environment:

    Portable to any flat, 32-bit environment.  (Uses Win32 typedefs.)
    Requires ANSI C extensions: slash-slash comments, long external names.

Revision History:

    01-Apr-1991 JohnRo
        Created portable LanMan (NT) version from LanMan 2.x.
    03-May-1991 JohnRo
        Really pass COPY of parm desc to convert args, like it expects.
        Also pass it UNC server name (\\stuff) for ease of use.
        Add check for valid computer name.
        Use Unicode transitional types.
        Changed to use three data descs: 16-bit, 32-bit and SMB versions.
        Fixed receive buffer length problem.
        RcvDataPresent flag is not needed.
        Use RxpFatalErrorCode() rather than checking for specific errors.
        Quiet debug output by default.
        Reduced recompile hits from header files.
        Don't use NET_API_FUNCTION for non-APIs.
    07-May-1991 JohnRo
        Made changes to reflect CliffV's code review.
        Add validation of parm desc.
    09-May-1991 JohnRo
        Made LINT-suggested changes.
    14-May-1991 JohnRo
        Pass 3 aux descriptors to RxRemoteApi.
    29-May-1991 JohnRo
        Handle SendDataPtr16 and SendDataSize16 correctly for setinfo.
        Print status if ConvertArgs failed.
    13-Jun-1991 JohnRo
        RxpConvertArgs needs DataDesc16 and AuxDesc16 to fix server set info
        for level 102.
    16-Jul-1991 JohnRo
        Allow receive data buffer to be zero bytes long with nonnull pointer.
    17-Jul-1991 JohnRo
        Extracted RxpDebug.h from Rxp.h.
    16-Aug-1991 rfirth
        Changed interface (NoPermissionRequired => Flags)
    25-Sep-1991 JohnRo
        Quiet normal debug messages.
    21-Nov-1991 JohnRo
        Removed NT dependencies to reduce recompiles.
    27-Nov-1991 JohnRo
        Do some checking of ApiNumber.
    31-Mar-1992 JohnRo
        Prevent too large size requests.
    06-May-1993 JohnRo
        RAID 8849: Export RxRemoteApi for DEC and others.
        Use NetpKdPrint() where possible.
        Use PREFIX_ equates.

--*/


// These must be included first:

#include <windef.h>             // IN, DWORD, LPTSTR, etc.
#include <rxp.h>                // Private header file.

// These may be included in any order:

#include <apiworke.h>           // REM_MAX_PARMS.
#include <limits.h>             // CHAR_BIT.
#include <lmerr.h>              // NERR_ and ERROR_ equates.
#include <names.h>              // NetpIsComputerNameValid().
#include <netdebug.h>   // NetpKdPrint(), FORMAT_ equates, etc.
#include <netlib.h>             // NetpMemoryFree(), etc.
#include <prefix.h>     // PREFIX_ equates.
#include <rap.h>                // RapIsValidDescriptorSmb().
#include <rx.h>                 // My prototype, etc.
#include <rxpdebug.h>           // IF_DEBUG().


NET_API_STATUS
RxRemoteApi(
    IN DWORD ApiNumber,
    IN LPCWSTR UncServerName,                // this is not OPTIONAL!
    IN LPDESC ParmDescString,
    IN LPDESC DataDesc16 OPTIONAL,
    IN LPDESC DataDesc32 OPTIONAL,
    IN LPDESC DataDescSmb OPTIONAL,
    IN LPDESC AuxDesc16 OPTIONAL,
    IN LPDESC AuxDesc32 OPTIONAL,
    IN LPDESC AuxDescSmb OPTIONAL,
    IN DWORD  Flags,
    ...                                         // rest of API's arguments
    )

// Define equate for last named (non-variable) argument, for use with
// va_start macro.
#define LAST_NAMED_ARGUMENT     Flags

/*++

Routine Description:

    RxRemoteApi (which is analogous to LanMan's NetIRemoteAPI) formats
    parameter and data buffers for transporting a local API request to a
    remote API worker and translates the remote response into the local
    equivalent.

Arguments:

    ApiNumber - Function number of the API required.

    ServerName - Points to the name of server this API is to be executed on.
        This MUST begin with "\\".

    ParmDescString - A pointer to a ASCIIZ string describing the API call
        parameters (other than server name).

    DataDesc16 - A pointer to a ASCIIZ string describing the
        structure of the data in the call, i.e. the return data structure
        for a Enum or GetInfo call.  This string is used for adjusting pointers
        to data in the local buffers after transfer across the net.  If there
        is no structure involved in the call then DataDesc16 must be
        a NULL pointer.  DataDesc16 is a "modified" 16-bit descriptor,
        which may contain "internal use only" characters.

    DataDesc32 - A pointer to the 32-bit version of DataDesc16.  Must be NULL
        iff DataDesc16 is NULL.

    DataDescSmb - An optional pointer to the SMB version of DataDesc16.
        This must not contain any "internal use only" characters.  Must be NULL
        iff DataDesc16 is NULL.

    AuxDesc16, AuxDesc32, AuxDescSmb - Will be NULL in most cases unless a
        REM_AUX_COUNT descriptor char is present in the data descriptors in
        which case these descriptors define a secondary data format as
        DataDesc16/DataDescSmb define the primary.

    Flags - bitmap of various control flags. Currently defined are:
        NO_PERMISSION_REQUIRED (0x1) - This flag is TRUE if this API does not
        require any permission on the remote machine, and that a null session
        is to be used for this request.

        ALLOCATE_RESPONSE (0x2) - Set if this routine and its subordinates
        (viz RxpConvertArgs, RxpConvertBlock) allocate a response buffer.
        We do this because at this level we know how much data is returned
        from the down-level server in an Enum or GetInfo call. We can therefore
        better estimate the size of buffer to allocate and return to the caller
        with 32-bit data than can the individual RxNet routines. The upshot of
        this is that we waste less space

    ... - The remainder of the parameters for the API call as given by the
        application.  (The "..." notation is from ANSI C, and refers to a
        variable argument list.  These arguments will be processing using the
        ANSI <stdarg.h> macros.)

Return Value:

    NET_API_STATUS.

--*/

{
    BYTE parm_buf[REM_MAX_PARMS];       // Parameter buffer
    LPDESC ParmDescCopy;                // Copy of parm desc in buffer.
    LPBYTE parm_pos;                    // Pointer into parm_buf
    va_list ParmPtr;                    // Pointer to stack parms.
    DWORD parm_len;                     // Length of send parameters
    DWORD ret_parm_len;                 // Length of expected parms
    DWORD rcv_data_length;              // Length of caller's rcv buf
    LPVOID rcv_data_ptr;                // Pointer to callers rcv buf
    LPVOID SendDataPtr16;               // Ptr to send buffer to use
    DWORD SendDataSize16;               // Size of caller's send buf
    LPBYTE SmbRcvBuffer = NULL;         // Rcv buffer, 16-bit version.
    DWORD SmbRcvBufferLength;           // Length of the above.
    NET_API_STATUS Status;              // Return status from remote.
    LPTSTR TransportName = NULL;        // Optional transport name.

    IF_DEBUG(REMOTE) {
        NetpKdPrint(( PREFIX_NETAPI
                "RxRemoteApi: entered, api num " FORMAT_DWORD "...\n",
                ApiNumber ));
    }

    //
    // Make sure API number doesn't get truncated.
    // Note that we can't check against the MAX_API equate anymore, as
    // that only includes APIs which we know about.  Now that RxRemoteApi is
    // being exported for use by anyone, we don't know the maximum API number
    // which the app might be using.
    //

    if ( ((DWORD)(WORD)ApiNumber) != ApiNumber ) {
        NetpKdPrint(( PREFIX_NETAPI
                "RxpStartBuildingTransaction: API NUMBER "
                "(" FORMAT_HEX_DWORD ") TOO LARGE, "
                "returning ERROR_INVALID_PARAMETER.\n",
                ApiNumber ));
        return (ERROR_INVALID_PARAMETER);
    }

#if DBG
    // Code in this file depends on 16-bit words; the Remote Admin Protocol
    // demands it.
    NetpAssert( ( (sizeof(WORD)) * CHAR_BIT) == 16);

    // We are removing these for the time being because the delay load handler for this
    // function returns FALSE by default, so the ASSERT will fire incorrectly.  For a future
    // release, we should change our delayload handler.
    //NetpAssert(RapIsValidDescriptorSmb(ParmDescString));
    if (DataDescSmb != NULL) {
        //NetpAssert(RapIsValidDescriptorSmb(DataDescSmb));
        NetpAssert(DataDesc16 != NULL);
        NetpAssert(DataDesc32 != NULL);
    } else {
        NetpAssert(DataDesc16 == NULL);
        NetpAssert(DataDesc32 == NULL);
    }
    if (AuxDescSmb != NULL) {
        //NetpAssert(RapIsValidDescriptorSmb(AuxDescSmb));
        NetpAssert(AuxDesc16 != NULL);
        NetpAssert(AuxDesc32 != NULL);
    } else {
        NetpAssert(AuxDesc16 == NULL);
        NetpAssert(AuxDesc32 == NULL);
    }
#endif

    if (! NetpIsUncComputerNameValid((LPWSTR)UncServerName)) {
        return (NERR_InvalidComputer);
    }

    //
    // Set found parameter flags to FALSE and pointers to NULL.
    //

    rcv_data_length = 0;
    rcv_data_ptr = NULL;


    //
    // First build the parameter block which will be sent to the API
    // worker. This consists of the two descriptor strings, ParmDescString
    // and DataDescSmb, followed by the parameters (or the data pointed
    // to by the parameters) that were passed to RxRemoteApi.
    //

    parm_pos = parm_buf;                // Start of parameter buffer.
    parm_len = 0;
    ret_parm_len = 2* sizeof(WORD);     // Allow for return status & converter.
    Status = RxpStartBuildingTransaction(
                parm_buf,                       // buffer start
                REM_MAX_PARMS,                  // buffer len
                ApiNumber,                      // API number
                ParmDescString,                 // parm desc (original)
                DataDescSmb,                    // data desc (SMB version)
                (LPVOID *)&parm_pos,                // roving output ptr
                & parm_len,                     // curr output len (updated)
                NULL,                           // last string ptr (don't care)
                & ParmDescCopy);                // ptr to parm desc copy
    if (Status != NERR_Success) {

        //
        // Consider increasing REM_MAX_PARMS...
        //

        NetpKdPrint(( PREFIX_NETAPI
                "RxRemoteApi: Buffer overflow!\n" ));
        NetpBreakPoint();
        return (Status);
    }

    //
    // Set up ParmPtr to point to first of the caller's parameters.
    //

    va_start(ParmPtr, LAST_NAMED_ARGUMENT);

    //
    //  If this API has specified a transport name, load the transport
    //  name from the first parameter.
    //

    if (Flags & USE_SPECIFIC_TRANSPORT) {

        //
        // Set up ParmPtr to point to first of the caller's parameters.
        //

        TransportName = va_arg(ParmPtr, LPTSTR);
    }

    //
    // Build the rest of the transaction by converting the rest of the
    // 32-bit arguments.
    //

    Status = RxpConvertArgs(
                ParmDescCopy,     // copy of desc, in SMB buf, will be updated.
                DataDesc16,
                DataDesc32,
                DataDescSmb,
                AuxDesc16,
                AuxDesc32,
                AuxDescSmb,
                REM_MAX_PARMS,                  // MaximumInputBlockLength
                REM_MAX_PARMS,                  // MaximumOutputBlockLength
                & ret_parm_len,                 // curr inp blk len (updated)
                & parm_len,                     // curr output len (updated)
                & parm_pos,                     // curr output ptr (updated)
                & ParmPtr,        // rest of API's arguments (after server name)
                & SendDataSize16,               // caller's send buff siz (set)
                (LPBYTE *) & SendDataPtr16,     // caller's send buff (set)
                & rcv_data_length,              // caller's rcv buff len (set)

                //
                // WARNING: Added complexity. Unfortunate, but there you go.
                // If we are to allocate the 32-bit received data buffer for
                // the caller then the value passed back in rcv_data_ptr will
                // be the address of the caller's pointer to the buffer.
                // Although this makes things more difficult to understand
                // down here, it simplifies life for the caller. Such is the
                // lot of the (put upon) systems programmer...
                //

                (LPBYTE *)&rcv_data_ptr,        // caller's rcv buff (set)
                Flags
                );
    va_end(ParmPtr);
    //NetpAssert(RapIsValidDescriptorSmb(ParmDescCopy));
    if (Status != NERR_Success) {

        NetpKdPrint(( PREFIX_NETAPI
                "RxRemoteApi: RxpConvertArgs failed, status="
                FORMAT_API_STATUS "\n", Status ));
        return (Status);
    }

    IF_DEBUG(REMOTE) {
        NetpKdPrint(( PREFIX_NETAPI
                "RxRemoteApi: RxpConvertArgs says r.data.len=" FORMAT_DWORD
                "\n", rcv_data_length ));
        NetpKdPrint(( PREFIX_NETAPI
                "RxRemoteApi: RxpConvertArgs says r.parm.len=" FORMAT_DWORD
                "\n", ret_parm_len ));
    }

    //
    // Set SmbRcvBuffer, and SmbRcvBufferLength to some appropriate values.
    // Because we now allow the final 32-bit receive buffer to be allocated
    // somewhere along the codepath of this routine, it is legal to have a
    // non-zero receive data length with a meaningless receive data pointer
    // (which could be NULL)
    //

    if (rcv_data_length != 0) {

        //
        // Allocate the SMB receive buffer.
        //

        SmbRcvBufferLength = rcv_data_length;
        SmbRcvBuffer = NetpMemoryAllocate( SmbRcvBufferLength );
        if (SmbRcvBuffer == NULL) {
            return ERROR_NOT_ENOUGH_MEMORY;
        }

#if DBG
        IF_DEBUG(REMOTE) {
            NetpKdPrint(( PREFIX_NETAPI
                    "RxRemoteApi: allocated " FORMAT_DWORD
                    " bytes as SmbRcvBuffer @ " FORMAT_LPVOID "\n",
                    SmbRcvBufferLength, (LPVOID) SmbRcvBuffer ));
        }
#endif
    } else {

        //
        // Allow zero-length receive data buffer with nonnull addr.
        //

        SmbRcvBufferLength = 0;
        SmbRcvBuffer = NULL;

        //
        // Don't understand the commentary here: its not a nonnull addr., and
        // as far as I can tell never has been. JR?
        // RLF 8-19
        //

        IF_DEBUG(REMOTE) {
            NetpKdPrint(( PREFIX_NETAPI
                    "RxRemoteApi: using 0 len buffer w/ nonnull addr.\n" ));
        }
    }

    //
    // The parameter buffers and data buffers are now set up for
    // sending to the API worker so call RxpTransactSmb to send them.
    //
    NetpAssert( parm_len           <= MAX_TRANSACT_SEND_PARM_SIZE );
    NetpAssert( SendDataSize16     <= MAX_TRANSACT_SEND_DATA_SIZE );
    NetpAssert( ret_parm_len       <= MAX_TRANSACT_RET_PARM_SIZE );
    NetpAssert( SmbRcvBufferLength <= MAX_TRANSACT_RET_DATA_SIZE );

    Status = RxpTransactSmb(
                        (LPWSTR)UncServerName,          // computer name
                        TransportName,
                        parm_buf,               // Send parm buffer
                        parm_len,               // Send parm length
                        SendDataPtr16,          // Send data buffer
                        SendDataSize16,         // Send data size
                        parm_buf,               // Rcv prm buffer
                        ret_parm_len,           // Rcv parm length
                        SmbRcvBuffer,           // Rcv data buffer
                        &SmbRcvBufferLength,    // Rcv data length (returned actual bytes read)

                        //
                        // NoPermissionRequired is now a bit in the Flags word
                        //

                        (BOOL)(Flags & NO_PERMISSION_REQUIRED)
                        );

#if DBG
    IF_DEBUG(REMOTE) {
        NetpKdPrint(( PREFIX_NETAPI
                "RxRemoteApi: back from RxpTransactSmb, status="
                FORMAT_API_STATUS "\n", Status ));
    }
    NetpAssert( SmbRcvBufferLength <= rcv_data_length );
    if (SmbRcvBuffer == NULL) {
        NetpAssert( SmbRcvBufferLength == 0 );
    }
#endif

    if (Status != NERR_Success) {

        switch (Status) {
        case NERR_BufTooSmall:  // No data returned from API worker
            rcv_data_length = 0;
            break;
        case ERROR_MORE_DATA:   // Just a warning for the caller
            break;
        case NERR_TooMuchData:  // Just a warning for the caller
            break;
        default:
            rcv_data_length = 0;
            break;
        }
    }
    NetpAssert( SmbRcvBufferLength <= MAX_TRANSACT_RET_DATA_SIZE );

    // The API call was successful. Now translate the return buffers
    // into the local API format.

    //
    // If we didn't have some fatal error (e.g. unable to talk to the remote
    // machine at all), then convert back...  Note that fatal errors don't
    // include statuses returned by the remote machine.
    //

    if (! RxpFatalErrorCode(Status)) {

        //
        // Set up ParmPtr to point to first of the caller's parameters.
        //

        va_start(ParmPtr, LAST_NAMED_ARGUMENT);

        if (Flags & USE_SPECIFIC_TRANSPORT) {

            //
            // Skip over the first argument - it's the transport.
            //

            (VOID) va_arg(ParmPtr, LPTSTR);
        }

        Status = RxpConvertBlock(
                    ApiNumber,
                    parm_buf,                   // response blk
                    ParmDescString,             // parm desc (original)
                    DataDesc16,
                    DataDesc32,
                    AuxDesc16,
                    AuxDesc32,
                    & ParmPtr,                  // rest of API's args
                    SmbRcvBuffer,               // 16-bit version of rcv buff
                    SmbRcvBufferLength,         // amount of BYTES in SmbRcvBuffer

                    //
                    // WARNING: Increased complexity. If the ALLOCATE_RESPONSE
                    // flag is set, then the caller supplied us with the address
                    // of the pointer to the buffer (which is about to be
                    // allocated in RxpConvertBlock). Else, rcv_data_ptr is
                    // the address of the buffer that the caller has already
                    // allocated before calling this routine
                    //

                    rcv_data_ptr,               // native version of rcv buff
                    rcv_data_length,            // length of the above
                    Flags                       // allocate a 32-bit response buffer?
                    );
        va_end(ParmPtr);

        //
        // Don't check Status; we'll just return it to caller.
        //
    }

    if (SendDataPtr16 != NULL) {
        NetpMemoryFree(SendDataPtr16);        // If add'l mem alloc'ed, free it.
    }

    if (SmbRcvBuffer != NULL) {
        NetpMemoryFree(SmbRcvBuffer);
    }

    return(Status);             // Return status from RxpConvertBlock or
                                // RxpTransactSmb.
} // RxRemoteApi
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\rpcxlate\rxcommon\setfield.c ===
/*++

Copyright (c) 1991-92  Microsoft Corporation

Module Name:

    SetField.c

Abstract:

    This module consists of the routine RxpSetField and its helpers
    (RxpIsFieldSettable and RxpFieldSize).

Author:

    John Rogers (JohnRo) 29-May-1991

Environment:

    Portable to any flat, 32-bit environment.  (Uses Win32 typedefs.)
    Requires ANSI C extensions: slash-slash comments, long external names.

Revision History:

    29-May-1991 JohnRo
        Created.
    06-Jun-1991 JohnRo
        Fixed bug handling buffer size (it shouldn't be sent).
        Fixed off-by-one error in string size handling in RxpFieldSize.
        Added debug output.
    12-Jul-1991 JohnRo
        Added more parameters to RxpSetField(), to support RxPrintJobSetInfo().
        Still more debug output.
    17-Jul-1991 JohnRo
        Extracted RxpDebug.h from Rxp.h.
    01-Oct-1991 JohnRo
        More work toward UNICODE.
    21-Nov-1991 JohnRo
        Removed NT dependencies to reduce recompiles.
    31-Mar-1992 JohnRo
        Prevent too large size requests.

--*/


// These must be included first:

#include <windef.h>             // IN, DWORD, etc.
#include <lmcons.h>             // PARMNUM_ALL, NET_API_STATUS, etc.

// These may be included in any order:

#include <lmerr.h>              // NERR_Success, etc.
#include <netdebug.h>           // NetpAssert().
#include <netlib.h>             // NetpMemoryAllocate(), NetpMemoryFree().
#include <remtypes.h>           // REM_UNSUPPORTED_FIELD.
#include <rxp.h>                // My prototype, MAX_TRANSACT_ equates.
#include <rxpdebug.h>           // IF_DEBUG().
#include <smbgtpt.h>            // SmbGetUshort().
#include <string.h>             // strcpy().
#include <tstring.h>            // STRLEN(), NetpCopy string functions.


// Size (in bytes) of SMB return parameters (status & converter):
#define RETURN_AREA_SIZE  (sizeof(WORD) + sizeof(WORD))



DBGSTATIC DWORD
RxpFieldSize(
    IN LPBYTE Field,
    IN LPDESC FieldDesc
    )
{
    NetpAssert(Field != NULL);
    NetpAssert(FieldDesc != NULL);

    if (*FieldDesc == REM_ASCIZ || *FieldDesc == REM_ASCIZ_TRUNCATABLE) {
        // Compute string len (assuming conversion to correct code page).
#if defined(UNICODE) // RxpFieldSize()
        return ( NetpUnicodeToDBCSLen((LPTSTR)Field) + 1 );
#else
        return (STRLEN( (LPTSTR) Field ) + sizeof(char) );
#endif // defined(UNICODE)
    } else {
        LPDESC TempDescPtr = FieldDesc;
        return ( RapGetFieldSize(
                FieldDesc,
                & TempDescPtr,  // updated
                Both ) );       // transmission mode

    }
    /* NOTREACHED */
} // RxpFieldSize


DBGSTATIC NET_API_STATUS
RxpIsFieldSettable(
    IN LPDESC DataDesc,
    IN DWORD FieldIndex
    )
{
    LPDESC FieldDesc;
    NET_API_STATUS Status;

    // Analyze descriptor to find data type for this FieldIndex.
    FieldDesc = RapParmNumDescriptor(
            DataDesc,
            FieldIndex,
            Both,               // Transmission mode.
            TRUE);              // native mode
    if (FieldDesc == NULL) {
        return (ERROR_NOT_ENOUGH_MEMORY);
    }
    // Check for errors detected by RapParmNumDescriptor().
    if (*FieldDesc == REM_UNSUPPORTED_FIELD) {
        IF_DEBUG(SETFIELD) {
            NetpKdPrint(( "RxpIsFieldSettable: invalid parameter "
                    "(ParmNumDesc).\n" ));
        }
        Status = ERROR_INVALID_PARAMETER;
    } else {
        Status = NERR_Success;
    }

    NetpMemoryFree(FieldDesc);

    return (Status);

} // RxpIsFieldSettable


NET_API_STATUS
RxpSetField (
    IN DWORD ApiNumber,
    IN LPTSTR UncServerName,
    IN LPDESC ObjectDesc OPTIONAL,
    IN LPVOID ObjectToSet OPTIONAL,
    IN LPDESC ParmDesc,
    IN LPDESC DataDesc16,
    IN LPDESC DataDesc32,
    IN LPDESC DataDescSmb,
    IN LPVOID NativeInfoBuffer,
    IN DWORD ParmNumToSend,
    IN DWORD FieldIndex,
    IN DWORD Level
    )

{
    LPBYTE CurrentBufferPointer;
    DWORD CurrentSize;
    DWORD ExtraParmSize;
    LPDESC FieldDesc;
    DWORD FieldSize16;
    LPBYTE SendDataBuffer;
    DWORD SendDataBufferSize;
    DWORD SendParmBufferSize;
    NET_API_STATUS Status;
    LPBYTE StringEnd;
    LPBYTE TransactSmbBuffer;
    DWORD TransactSmbBufferSize;
//
// MOD 06/11/91 RLF
//
    DWORD   ReturnedDataLength = 0;
//
// MOD 06/11/91 RLF
//

    // Double-check caller.
    NetpAssert(DataDesc16 != NULL);
    NetpAssert(DataDesc32 != NULL);
    NetpAssert(DataDescSmb != NULL);
    if (RapValueWouldBeTruncated(Level)) {
        // Can't use 16-bit protocol if level won't even fit in 16 bits!
        return (ERROR_INVALID_LEVEL);
    }
    NetpAssert(ParmNumToSend != PARMNUM_ALL);
    NetpAssert(FieldIndex != PARMNUM_ALL);
    if (RapValueWouldBeTruncated(ParmNumToSend)) {
        IF_DEBUG(SETFIELD) {
            NetpKdPrint(( "RxpSetField: invalid parameter (trunc).\n" ));
        }
        return (ERROR_INVALID_PARAMETER);
    }

    //
    // Analyze descriptors to make sure this parm num is settable.
    //

    Status = RxpIsFieldSettable( DataDesc16, FieldIndex );
    if (Status != NERR_Success) {
        return (Status);
    }
    Status = RxpIsFieldSettable( DataDesc32, FieldIndex );
    if (Status != NERR_Success) {
        return (Status);
    }

    NetpKdPrint(( "RxpSetField: ParmNumToSend=" FORMAT_DWORD ", Level="
            FORMAT_DWORD ", FieldIndex=" FORMAT_DWORD ".\n",
            ParmNumToSend, Level, FieldIndex ));

    //
    // Analyze SMB version of descriptor to find data type for this ParmNum.
    // Use it to build send data buffer
    //

    FieldDesc = RapParmNumDescriptor(
            DataDescSmb,        
            FieldIndex,
            Both,               // Transmission mode.
            TRUE);              // native version
    if (FieldDesc == NULL) {
        return (ERROR_NOT_ENOUGH_MEMORY);
    }
    // Check for errors detected by RapParmNumDescriptor().
    if (*FieldDesc == REM_UNSUPPORTED_FIELD) {
        NetpMemoryFree( FieldDesc );
        IF_DEBUG(SETFIELD) {
            NetpKdPrint(( "RxpSetField: invalid parameter (parmNumDesc).\n" ));
        }
        return (ERROR_INVALID_PARAMETER);
    }

    // How much memory will we need for send data buffer?
    FieldSize16 = RxpFieldSize( NativeInfoBuffer, FieldDesc );
    NetpAssert( FieldSize16 >= 1 );
    SendDataBufferSize = FieldSize16;
    if( SendDataBufferSize > MAX_TRANSACT_SEND_DATA_SIZE )
    {
        NetpBreakPoint();
        return (ERROR_BUFFER_OVERFLOW);
    }

    // Allocate send data buffer.
    SendDataBuffer = NetpMemoryAllocate( SendDataBufferSize );
    if (SendDataBuffer == NULL) {
        NetpMemoryFree( FieldDesc );
        return (ERROR_NOT_ENOUGH_MEMORY);
    }
    NetpKdPrint(( "RxpSetField: allocated " FORMAT_DWORD " bytes at "
            FORMAT_LPVOID ".\n", SendDataBufferSize, SendDataBuffer ));

    // Convert this field (and copy it to the send data buffer while we're
    // at it).
    if ( (*FieldDesc != REM_ASCIZ) && (*FieldDesc != REM_ASCIZ_TRUNCATABLE) ) {
        DWORD BytesNeeded = 0;
        LPBYTE BogusStringEnd = SendDataBuffer + SendDataBufferSize;
        NetpKdPrint(( "RxpSetField: converting...\n" ));
        Status = RapConvertSingleEntry (
                NativeInfoBuffer,       // input data
                FieldDesc,              // input descriptor
                FALSE,                  // no meaningless input pointers
                SendDataBuffer,         // output buffer start
                SendDataBuffer,         // output data
                FieldDesc,              // output descriptor
                TRUE,                   // set offsets
                & BogusStringEnd,       // string area end (updated)
                & BytesNeeded,          // bytes required (updated)
                Both,                   // transmission mode
                NativeToRap);           // conversion mode
        NetpAssert( Status == NERR_Success );
        NetpAssert( BytesNeeded == FieldSize16 );
    } else {
        // Can't use RapConvertSingleEntry for setinfo strings, because
        // they're not sent with a pointer (or offset).  So, we just copy data.
#if defined(UNICODE) // RxpSetField()
        NetpAssert(
            SendDataBufferSize >=  NetpUnicodeToDBCSLen((LPTSTR)NativeInfoBuffer)+1);
#else
        NetpAssert(
            SendDataBufferSize >= (STRLEN(NativeInfoBuffer)+sizeof(char)) );
#endif // defined(UNICODE)
        NetpKdPrint(( "RxpSetField: copying string...\n" ));
#if defined(UNICODE) // RxpSetField()
        NetpCopyWStrToStrDBCS(
                (LPSTR) SendDataBuffer,         // dest
                (LPTSTR)NativeInfoBuffer );             // src
#else
        NetpCopyTStrToStr(
                (LPSTR) SendDataBuffer,         // dest
                NativeInfoBuffer);              // src
#endif // defined(UNICODE)
    }
    NetpMemoryFree( FieldDesc );


    //
    // OK, now let's work on the transact SMB buffer, which we'll use as the
    // send parm buffer and return parm buffer.
    //

    // Figure-out how many bytes of parameters we'll need.
    ExtraParmSize =
            sizeof(WORD)    // level,
            + sizeof(WORD); // parmnum.
    if (ObjectDesc != NULL) {
        NetpAssert( ObjectToSet != NULL );
        NetpAssert( DESCLEN(ObjectDesc) == 1 );

        if (*ObjectDesc == REM_ASCIZ) {
            // Add size of ASCII version of object to set.
            ExtraParmSize += STRLEN(ObjectToSet) + sizeof(char);
        } else if (*ObjectDesc == REM_WORD_PTR) {
            ExtraParmSize += sizeof(WORD);
        } else {
            NetpAssert(FALSE);
        }
    } else {
        NetpAssert(ObjectToSet == NULL);
    }

    // Allocate SMB transaction request buffer.
    NetpAssert(ExtraParmSize >= 1);
    SendParmBufferSize = RxpComputeRequestBufferSize(
            ParmDesc,
            DataDescSmb,
            ExtraParmSize);
    NetpAssert( SendParmBufferSize <= MAX_TRANSACT_SEND_PARM_SIZE );
    if (SendParmBufferSize > RETURN_AREA_SIZE) {
        TransactSmbBufferSize = SendParmBufferSize;
    } else {
        TransactSmbBufferSize = RETURN_AREA_SIZE;
    }
    NetpAssert( TransactSmbBufferSize <= MAX_TRANSACT_SEND_PARM_SIZE );
    TransactSmbBuffer = NetpMemoryAllocate( TransactSmbBufferSize );
    if (TransactSmbBuffer == NULL) {
        return (ERROR_NOT_ENOUGH_MEMORY);
    }

    // Start filling-in parm buffer and set pointers and counters.
    Status = RxpStartBuildingTransaction(
            TransactSmbBuffer,          // SMB buffer (will be built)
            SendParmBufferSize,
            ApiNumber,
            ParmDesc,
            DataDescSmb,
            (LPVOID *) & CurrentBufferPointer, // first avail byte to use (set)
            & CurrentSize,      // bytes used so far (set)
            (LPVOID *) & StringEnd, // ptr to string area end (set)
            NULL);          // don't need ptr to parm desc copy
    NetpAssert(Status == NERR_Success);

    // Fill in parameters.
    if (ObjectToSet != NULL) {
        if (*ObjectDesc == REM_ASCIZ) {
            // Copy string to output area, converting as necessary.
            RxpAddTStr(
                    (LPTSTR) ObjectToSet,       // input
                    & CurrentBufferPointer,     // updated
                    & StringEnd,                // updated
                    & CurrentSize);             // updated
        } else if (*ObjectDesc == REM_WORD_PTR) {
            RxpAddWord(
                    * (LPWORD) ObjectToSet,
                    & CurrentBufferPointer,     // updated
                    & CurrentSize);             // updated
        } else {
            NetpAssert(FALSE);
        }
    }
    RxpAddWord(
            (WORD) Level,
            & CurrentBufferPointer,     // updated
            & CurrentSize);             // updated
    RxpAddWord(
            (WORD) ParmNumToSend,
            & CurrentBufferPointer,     // updated
            & CurrentSize);             // updated

    Status = RxpTransactSmb(
            UncServerName,
            NULL,               // Transport name
            TransactSmbBuffer,
            SendParmBufferSize,
            SendDataBuffer,
            SendDataBufferSize,
            TransactSmbBuffer,  // will be set with status and converter word.
            RETURN_AREA_SIZE,
            NULL,               // no return data
//
// MOD 06/11/91 RLF
//
//            0,                  // 0 bytes of return data
            &ReturnedDataLength,
//
// MOD 06/11/91 RLF
//
            FALSE);             // not a null session API.
    // Don't process RxpTransactSmb status just yet...
    NetpMemoryFree(SendDataBuffer);
    if (Status != NERR_Success) {
        NetpMemoryFree(TransactSmbBuffer);
        return (Status);  // status of transact, e.g. net not started.
    }

    Status = SmbGetUshort( (LPWORD) TransactSmbBuffer );
    NetpMemoryFree(TransactSmbBuffer);

    return (Status);      // status of actual remote API.

} // RxpSetField
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\rpcxlate\rxcommon\transact.c ===
/*++

Copyright (c) 1987-92  Microsoft Corporation

Module Name:

    Transact.c

Abstract:

    RxpTransactSmb (analogous to the LanMan 2.x transact routine) performs a
    transaction FSCTL to the redirector.

Author:

    John Rogers (JohnRo) 01-Apr-1991  (NT version only)

Environment:

    Only runs under NT, although the interface is portable (Win/32).
    Requires ANSI C extensions: slash-slash comments, long external names.

Revision History:

    various
        Original code (from LanMan 2.x).
    01-Apr-91 JohnRo
        Converted code from LanMan (OS/2) to NT.
    02-Apr-1991 JohnRo
        Moved NetpRdrFsControlTree to <netlibnt.h>.
    17-Apr-1991 JohnRo
        Fixed memory leaks (especially with pipe name).
        Quiet debug output by default.
        Reduced recompile hits from header files.
    03-May-1991 JohnRo
        Pass UNC server name for ease of use.  Use Unicode transitional types.
        Use UNREFERENCED_PARAMETER() macro.
    15-May-1991 JohnRo
        Use FORMAT_LPVOID instead of FORMAT_POINTER, for maximum portability.
    22-May-1991 JohnRo
        Use correct string handling functions to allow UNICODE.
        Use NetpDbgReasonable().
    14-Jul-1991 JohnRo
        Don't do assert on server name.
    17-Jul-1991 JohnRo
        Extracted RxpDebug.h from Rxp.h.
    04-Oct-1991 JohnRo
        Generate NERR_BadTransactConfig when IPC$ isn't shared.
        Clarified a debug output message.  Use TEXT() macro.
    01-Nov-1991 JohnRo
        Don't let the new (paranoid) RxpFatalErrorCode() prevent debug output.
    16-Jan-1992 JohnRo
        The redirector always expects UNICODE for the transact parm name.
    31-Mar-1992 JohnRo
        Prevent too large size requests.
    22-Sep-1992 JohnRo
        RAID 6739: Browser too slow when not logged into browsed domain.

--*/

// These must be included first:

#include <nt.h>                 // Needed by netlibnt.h.
#include <rxp.h>                // RpcXlate's private header file.

// These may be included in any order:

#include <apiworke.h>           // REM_APITXT, APIEXTR.
#include <lmerr.h>              // NERR_ and ERROR_ equates.
#include <names.h>              // NetpIsComputerNameValid().
#include <netdebug.h>   // NetpAssert(), NetpKdPrint(()), FORMAT_ equates.
#include <netlib.h>             // NetpMoveMemory(), etc.
#include <ntddnfs.h>            // TRANSACTION_REQUEST, etc.
#include <prefix.h>     // PREFIX_ equates.
#include <rxpdebug.h>           // IF_DEBUG().
#include <tstring.h>            // STRCAT(), STRCPY(), STRLEN().
#include <lmuse.h>

#ifdef CDEBUG
#include <apinums.h>            // API_WServerGetInfo, etc.
#include <netlib.h>             // NetpPackString().
#include <smbgtpt.h>            // SmbGetUshort().
#include <server.h>             // SERVER_INFO_100.
#endif // CDEBUG

#include <netlibnt.h>           // NetpRdrFsControlTree().


NET_API_STATUS
RxpTransactSmb(
    IN LPTSTR UncServerName,
    IN LPTSTR TransportName OPTIONAL,
    IN LPVOID SendParmPtr,
    IN DWORD SendParmLen,
    IN LPVOID SendDataPtr OPTIONAL,
    IN DWORD SendDataLen,
    OUT LPVOID RetParmPtr OPTIONAL,
    IN DWORD RetParmLen,
    OUT LPVOID RetDataPtr OPTIONAL,
    IN OUT LPDWORD RetDataLen,
    IN BOOL NoPermissionRequired
    )

/*++

Routine Description:

    RxpTransactSmb takes the caller's parameters and builds a transaction
    SMB which is sent to a remote machine.  This routine waits for the
    response to this SMB and returns the status from it.

Arguments:

    UncServerName - Server name to transact with (including \\).

    SendParmPtr - Pointer to send parameters.

    SendParmLen - Length of send parameters.

    SendDataPtr - Optional pointer to send data.

    SendDataLen - Send data length.

    RetParmPtr - Optional pointer to buffer for return parameters.

    RetParmLen - Expected length of return parameters.

    RetDataPtr - Optional pointer to buffer for return data.

    RetDataLen - IN: Expected length of return data.
                 OUT: Received length of return data.

    NoPermissionRequired - TRUE if this is a no permission required API.  (I.e.
        TRUE if the null session may be used.)

Return Value:

    (various values as returned by the remote API, plus values which can
    be generated by this routine)

--*/

/*
 * Note 1: how the packet is build and sized.
 *
 *      The paramater buffer for the transaction consists of the
 *      transaction parameter structure, followed by the name of the
 *      target pipe and the password, which is always NULL.  The pipe
 *      name and password are ASCIZ strings.
 *
 *      We build the pipe by taking the canonicalized server name, and
 *      appending the text REM_APITXT (see net/inc/apiworke.h).  This text
 *      contains the pipe suffix (\pipe\lanman) plus TWO nulls, one to
 *      terminate the pipe name and one to terminate the (empty) password.
 *
 *      So, the maximum buffer size is as shown below for the allocation
 *      of ioctl_buf.  UNCLEN is the max len of the canonicalized
 *      UncServerName and includes the two leading slashes, but not any
 *      terminating NUL.  The terminating NUL, as well as the pipe suffix
 *      and the emptry password, are accounted for in APIEXTR.
 *
 *      Our actual size is the same, except substitute the length of the
 *      canonicalized UncServerName for UNCLEN.  This is how ParmRktLen is
 *      calculated.
 *
 */

{
#ifndef CDEBUG
    PLMR_TRANSACTION FsctlParms;        // Parms to tell redir what to do.
    DWORD FsctlParmSize;                // Size of FsctlParms and strings.
    LPTSTR TreeConnName;                // LM-style server & share name.
#endif // ndef CDEBUG
    NET_API_STATUS Status;

//
// MOD 06/11/91 RLF
// Create DWORD variable to avoid indirection every time RetDataLen accessed
//
    DWORD   InputRetDataLen = *RetDataLen;
//
// MOD 06/11/91 RLF
//

    IF_DEBUG(TRANSACT) {
        NetpKdPrint(( PREFIX_NETAPI
                "RxpTransactSmb: entered, servername='"
                FORMAT_LPTSTR "'...\n", UncServerName));
        NetpKdPrint(( PREFIX_NETAPI
                "RxpTransactSmb: SendParm at " FORMAT_LPVOID
                ", len=" FORMAT_DWORD " (partial):\n",
                (LPVOID) SendParmPtr, SendParmLen));
        if (SendParmPtr != NULL) {
            NetpDbgHexDump(SendParmPtr, NetpDbgReasonable(SendParmLen));
        }
        NetpKdPrint(( PREFIX_NETAPI
                "RxpTransactSmb: SendData at " FORMAT_LPVOID
                ", len=" FORMAT_DWORD " (partial):\n",
                (LPVOID) SendDataPtr, SendDataLen));
        if (SendDataPtr != NULL) {
            NetpDbgHexDump(SendDataPtr, NetpDbgReasonable(SendDataLen));
        }
        NetpKdPrint(( PREFIX_NETAPI
                "RxpTransactSmb: RetParmPtr at " FORMAT_LPVOID
                ", len=" FORMAT_DWORD ".\n", (LPVOID) RetParmPtr, RetParmLen));

        NetpKdPrint(( PREFIX_NETAPI
                "RxpTransactSmb: (old) RetData at " FORMAT_LPVOID ", "
                "len=" FORMAT_DWORD " (partial):\n",
                (LPVOID) RetDataPtr, InputRetDataLen));
        if (RetDataPtr != NULL) {
            NetpDbgHexDump(RetDataPtr, NetpDbgReasonable(InputRetDataLen));
        }
    }

    NetpAssert( SendParmLen     <= MAX_TRANSACT_SEND_PARM_SIZE );
    NetpAssert( SendDataLen     <= MAX_TRANSACT_SEND_DATA_SIZE );
    NetpAssert( RetParmLen      <= MAX_TRANSACT_RET_PARM_SIZE );
    NetpAssert( InputRetDataLen <= MAX_TRANSACT_RET_DATA_SIZE );

    // Assumes that isremote(UncServerName) has already checked for
    // a NULL and empty string.

    if ((UncServerName == NULL) || (UncServerName[0] == 0)) {
        NetpBreakPoint();
        return (NERR_InternalError);
    }

    if (! NetpIsUncComputerNameValid(UncServerName)) {
        return (NERR_InvalidComputer);
    }

    IF_DEBUG(TRANSACT) {
        NetpKdPrint(( PREFIX_NETAPI
                "RxpTransactSmb: pipe name is '" FORMAT_LPWSTR
                "'.\n", REM_APITXT));
    }

#ifndef CDEBUG
    //
    // Build NT-style name for what we're connecting to.  Note that there is
    // NOT a pair of backslashes anywhere in this name.
    //

    {
        DWORD NameSize =

            // /Device/LanManRedirector    /server                  /IPC$\0
            ( strlen(DD_NFS_DEVICE_NAME) + STRLEN(UncServerName)-1 + 6 )
            * sizeof(TCHAR);

        TreeConnName = NetpMemoryAllocate( NameSize );
    }

    if (TreeConnName == NULL) {
        return (ERROR_NOT_ENOUGH_MEMORY);
    }

    //
    // Build the tree connect name.
    //

    (void) STRCPY(TreeConnName, UncServerName);           // copy "\\server",
    (void) STRCAT(TreeConnName, (LPTSTR) TEXT("\\IPC$")); // then "\share".
    IF_DEBUG(TRANSACT) {
        NetpKdPrint(( PREFIX_NETAPI
                "RxpTransactSmb: TreeConnName is '" FORMAT_LPTSTR
                "'.\n", TreeConnName));
    }

    // Set FsctlParmSize and allocate fsctl structure.
    FsctlParmSize = sizeof(LMR_TRANSACTION) + (APIEXTR);
    FsctlParms = NetpMemoryAllocate(FsctlParmSize);
    if (FsctlParms == NULL) {
        NetpMemoryFree(TreeConnName);
        return (ERROR_NOT_ENOUGH_MEMORY);
    }
    IF_DEBUG(TRANSACT) {
        NetpKdPrint(( PREFIX_NETAPI
                "RxpTransactSmb: allocated " FORMAT_DWORD
                " bytes for fsctl parms at "
                FORMAT_LPVOID ".\n", FsctlParmSize, (LPVOID) FsctlParms));
    }

    FsctlParms->Type = TRANSACTION_REQUEST;
    FsctlParms->Size = FsctlParmSize;
    FsctlParms->Version = TRANSACTION_VERSION;
    FsctlParms->NameLength = APIEXTR-sizeof(WCHAR);
    FsctlParms->NameOffset = sizeof(LMR_TRANSACTION);
    NetpMoveMemory(
                NetpPointerPlusSomeBytes(
                        FsctlParms,
                        sizeof(LMR_TRANSACTION)),      // dest
                REM_APITXT,                            // src (always UNICODE)
                APIEXTR-sizeof(WCHAR));                // len (don't copy null)

    FsctlParms->ResponseExpected = TRUE;
    FsctlParms->Timeout = REM_API_TIMEOUT;     // Timeout time in milliseconds.
    FsctlParms->SetupWords = 0;
    FsctlParms->SetupOffset = 0;
    FsctlParms->MaxSetup = 0;

    FsctlParms->ParmLength = SendParmLen;
    FsctlParms->ParmPtr = SendParmPtr;
    FsctlParms->MaxRetParmLength = RetParmLen;
    NetpAssert(SendParmPtr == RetParmPtr);

    FsctlParms->DataLength = SendDataLen;
    FsctlParms->DataPtr = SendDataPtr;

    FsctlParms->MaxRetDataLength = InputRetDataLen;
    FsctlParms->RetDataPtr = RetDataPtr;

    //
    // Do the FSCTL!
    //
    Status = NetpRdrFsControlTree(
                TreeConnName,                      // tree connect name
                TransportName,                     // Transport name.
                USE_IPC,                           // Connection type
                FSCTL_LMR_TRANSACT,                // fsctl function code
                NULL,                              // security descriptor
                FsctlParms,                        // input buffer
                FsctlParmSize,                     // input buffer length
                FsctlParms,                        // output buffer
                FsctlParmSize,                     // output buffer length
                NoPermissionRequired);

    if (Status == ERROR_BAD_NET_NAME) {
        Status = NERR_BadTransactConfig;
    }
    if (RxpFatalErrorCode(Status)) {
        IF_DEBUG(TRANSACT) {
            NetpKdPrint(( PREFIX_NETAPI
                    "RxpTransactSmb: returning fatal status="
                    FORMAT_API_STATUS ".\n", Status));
        }
        NetpMemoryFree(FsctlParms);
        NetpMemoryFree(TreeConnName);
        return (Status);
    }

//
// MOD 06/11/91 RLF
// Return the received data length in *RetDataLen
//
    *RetDataLen = FsctlParms->MaxRetDataLength;
    NetpAssert( *RetDataLen <= MAX_TRANSACT_RET_DATA_SIZE );
//
// MOD 06/11/91 RLF
//

    NetpMemoryFree(FsctlParms);
    NetpMemoryFree(TreeConnName);

#else // def CDEBUG

    {
        DWORD ApiNumber;

        ApiNumber = (DWORD) SmbGetUshort((LPWORD) SendParmPtr);
        IF_DEBUG(TRANSACT) {
            NetpKdPrint(( PREFIX_NETAPI
                    "RxpTransactSmb: pretending success for API "
                    FORMAT_DWORD ".\n", ApiNumber));
        }
        SmbPutUshort((LPWORD) RetParmPtr, (WORD) NERR_Success);

        switch (ApiNumber) {
        case API_NetRemoteTOD :
            {
                UCHAR BogusTime[] = {
                        0xD0, 0xAE, 0xB2, 0x28,   // 21-Aug-1991 (6:20PM)
                        0x44, 0x33, 0x22, 0x11,   // msec (anything)
                        3,                        // hours
                        30,                       // minutes
                        15,                       // seconds
                        55,                       // hundredths of seconds
                        0xFF, 0xFF,               // timezone (unknown)
                        0xA6, 0x00,               // clock interval (60 Hz)
                        10,                       // day
                        1,                        // month
                        0xC7, 0x07,               // year
                        4};                       // weekday
                NetpAssert(RetDataPtr != NULL);
                NetpAssert(InputRetDataLen != 0);
                NetpMoveMemory(
                            RetDataPtr,                       // dest
                            BogusTime,                        // src (bogus)
                            InputRetDataLen);                      // len
                break;
            }
        case API_WServerGetInfo :
            {
                LPVOID FixedDataEnd = NetpPointerPlusSomeBytes(
                                RetDataPtr,
                                sizeof(SERVER_INFO_100));
                LPBYTE LastString = NetpPointerPlusSomeBytes(
                                RetDataPtr,
                                InputRetDataLen);
                LPSERVER_INFO_100 p = RetDataPtr;

                NetpAssert(RetDataPtr != NULL);
                NetpAssert(InputRetDataLen != 0);
                p->sv100_name = (LPTSTR) TEXT("\\\\bogus\\name");
                if (NetpPackString(
                                & p->sv100_name,                // in out
                                FixedDataEnd,                   // in
                                & LastString) == 0) {           // in out
                    NetpBreakPoint();
                    return (NERR_InternalError);
                }
                break;
            }
        }

    }

#endif // def CDEBUG

    Status = (DWORD) SmbGetUshort((LPWORD) RetParmPtr);

    IF_DEBUG(TRANSACT) {
        NetpKdPrint(( PREFIX_NETAPI
                "RxpTransactSmb: returning status="
                FORMAT_API_STATUS ".\n", Status));
        NetpKdPrint(( PREFIX_NETAPI
                "RxpTransactSmb: RetParm at " FORMAT_LPVOID
                ", len=" FORMAT_DWORD " (partial):\n",
                (LPVOID) RetParmPtr, RetParmLen));
        if (RetParmPtr != NULL) {
            NetpDbgHexDump(RetParmPtr, NetpDbgReasonable(RetParmLen));
        }
        NetpKdPrint(( PREFIX_NETAPI
                "RxpTransactSmb: (new) RetData at " FORMAT_LPVOID ", "
                "len=" FORMAT_DWORD " (partial):\n",
                (LPVOID) RetDataPtr, InputRetDataLen));
        if (RetDataPtr != NULL) {
            NetpDbgHexDump(RetDataPtr, NetpDbgReasonable(InputRetDataLen));
        }
    }
    return (Status);

} // RxpTransactSmb
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcctrl\client\svcstub.c ===
/*++

Copyright (c) 1991-1992  Microsoft Corporation

Module Name:

    SvcStub.c (was scstub.c)

Abstract:

    These are the Service Controller API RPC client stubs.

    These stubs contain RPC work-around code due to the fact that RPC
    does not support unions yet.  Therefore, a remote entry point must be
    created for every info-level.  This results in messy looking switch
    statements that are used to determine which entry point to call.

    These switch statements include default paths that can currently cause
    an error.  When unions are available, the case statements will be
    removed, and this side of the API will not make any assumptions as to
    what a valid info level is for a given API.

Author:

    Dan Lafferty    (danl)  06-Feb-1991

Environment:

    User Mode - Win32

Revision History:

    06-Feb-1991     Danl
        Created
    12-Sep-1991 JohnRo
        Downlevel NetService APIs.
    06-Nov-1991 JohnRo
        RAID 4186: Fix assert in RxNetShareAdd and other MIPS problems.
        Use NetpRpcStatusToApiStatus, not NetpNtStatusToApiStatus.
        Make sure API name is in every debug message.
    08-Nov-1991 JohnRo
        RAID 4186: assert in RxNetShareAdd and other DLL stub problems.
    30-Mar-1992 JohnRo
        Extracted DanL's code from /nt/private project back to NET project.
    29-Apr-1992 JohnRo
        Use FORMAT_ equates where possible.
    08-May-1992 JohnRo
        Translate service names on the fly.
    14-May-1992 JohnRo
        winsvc.h and related file cleanup.
    06-Aug-1992 JohnRo
        RAID 3021: NetService APIs don't always translate svc names.
    09-Sep-1992 JohnRo
        RAID 1090: net start/stop "" causes assertion.
        Oops, NetServiceControl forgot to translate one more svc name.
    05-Nov-1992 JohnRo
        RAID 7780: Corrected error code for invalid level.
        Also fixed overactive assert in NetServiceEnum with no services.
        Also fixed rare memory leaks.

--*/

//
// INCLUDES
//

#define NOSERVICE       // Avoid <winsvc.h> vs. <lmsvc.h> conflicts.
#include <windows.h>    // DWORD, etc.

#include <lmcons.h>     // NET_API_STATUS
#include <rpcutil.h>    // NetRpc utils, GENERIC_ENUM_STRUC, etc.

#include <netdebug.h>   // Needed by NetRpc.h; FORMAT_ equates.
#include <lmapibuf.h>   // NetApiBufferAllocate(), etc.
#include <lmerr.h>      // NetError codes
#include <lmremutl.h>   // NetRemoteComputerSupports(), SUPPORTS_RPC
#include <lmsvc.h>
#include <rxsvc.h>      // RxNetService routines.

#include <netlib.h>     // NetpTranslateServiceName().
#include <svcdebug.h>   // SCC_LOG
#include <svcmap.h>     // MapService() routines.

//
// Globals
//
#ifdef SC_DEBUG
    DWORD   SvcctrlDebugLevel = DEBUG_ALL;
#else
    DWORD   SvcctrlDebugLevel = DEBUG_ERROR;
#endif


DBGSTATIC BOOL
MachineSupportsNt(
    IN LPWSTR UncServerName OPTIONAL
    );



NET_API_STATUS NET_API_FUNCTION
NetServiceControl (
    IN  LPCWSTR servername OPTIONAL,
    IN  LPCWSTR service,
    IN  DWORD   opcode,
    IN  DWORD   arg,
    OUT LPBYTE  *bufptr
    )
/*++

Routine Description:

    This is the DLL entrypoint for NetServiceControl.

Arguments:

    servername - Pointer to a string containing the name of the computer
        that is to execute the API function.

    service - Pointer to a string containing the name of the service
        that is to receive the control request.

    opcode - The control request code.

    arg - An additional (user defined) code that will be passed to the
        service.

    bufptr - pointer to a location where the service status is to
        be returned.  If this pointer is invalid, it will be set to NULL
        upon return.

Return Value:

    The returned InfoStruct2 structure is valid as long as the returned
    error is NOT NERR_ServiceNotInstalled or NERR_ServiceBadServiceName.

    NERR_Success - The operation was successful.

    NERR_InternalError - LocalAlloc or TransactNamedPipe failed, or
        TransactNamedPipe returned fewer bytes than expected.

    NERR_ServiceNotInstalled - The service record was not found in the
        installed list.

    NERR_BadServiceName - The service name pointer was NULL.

    NERR_ServiceCtlTimeout - The service did not respond with a status
        message within the fixed timeout limit (RESPONSE_WAIT_TIMEOUT).

    NERR_ServiceKillProcess - The service process had to be killed because
        it wouldn't terminate when requested.

    NERR_ServiceNotCtrl - The service cannot accept control messages.
        The install state indicates that start-up or shut-down is pending.

    NERR_ServiceCtrlNotValid - The request is not valid for this service.
        For instance, a PAUSE request is not valid for a service that
        lists itself as NOT_PAUSABLE.

    ERROR_ACCESS_DENIED - This is a status response from the service
        security check.


--*/
{
    NET_API_STATUS          apiStatus;
    LPWSTR                  translatedServiceName;
    LPBYTE                  untranslatedBuffer = NULL;

    if (MachineSupportsNt( (LPWSTR) servername )) {

        apiStatus = NetpTranslateServiceName(
                (LPWSTR) service,   // untranslated.
                TRUE,               // yes, we want new style name
                & translatedServiceName );
        NetpAssert( apiStatus == NO_ERROR );

        apiStatus = MapServiceControl (
                (LPWSTR) servername,
                (LPWSTR) service,
                opcode,
                arg,
                & untranslatedBuffer);

    } else {

        apiStatus = NetpTranslateServiceName(
                (LPWSTR) service,  // untranslated.
                FALSE,             // no, we don't want new style name
                & translatedServiceName );
        NetpAssert( apiStatus == NO_ERROR );

        //
        // Call downlevel...
        //
        apiStatus = RxNetServiceControl(
                (LPWSTR) servername,
                translatedServiceName,
                opcode,
                arg,
                & untranslatedBuffer);

    }

    //
    // Translate service name in returned buffer.
    //
    if (apiStatus == NO_ERROR) {

        NetpAssert( untranslatedBuffer != NULL );
        apiStatus = NetpTranslateNamesInServiceArray(
                2,  // level 2 by definition
                untranslatedBuffer,
                1,     // only one entry
                TRUE,  // yes, caller wants new style names
                (LPVOID *) (LPVOID) bufptr);

    }

    if (untranslatedBuffer != NULL) {
        (VOID) NetApiBufferFree( untranslatedBuffer );
    }

    return(apiStatus);
}


NET_API_STATUS NET_API_FUNCTION
NetServiceEnum (
    IN  LPCWSTR     servername OPTIONAL,
    IN  DWORD       level,
    OUT LPBYTE      *bufptr,
    IN  DWORD       prefmaxlen,
    OUT LPDWORD     entriesread,
    OUT LPDWORD     totalentries,
    IN OUT LPDWORD  resume_handle OPTIONAL
    )
/*++

Routine Description:

    This is the DLL entrypoint for NetSeviceEnum.

Arguments:

    servername - Pointer to a string containing the name of the computer
        that is to execute the API function.

    level - This indicates the level of information that is desired.

    bufptr - A pointer to the location where the pointer to the returned
        array of info structures is to be placed.

    prefmaxlen - Indicates a maximum size limit that the caller will allow
        for the return buffer.

    entriesread - A pointer to the location where the number of entries
        (data structures)read is to be returned.

    totalentries - A pointer to the location which upon return indicates
        the total number of entries in the "active" database.

    resumehandle - Pointer to a value that indicates where to resume
        enumerating data.

Return Value:

    Nerr_Success - The operation was successful.

    ERROR_MORE_DATA - Not all of the data in the active database could be
        returned.

    ERROR_INVALID_LEVEL - An illegal info Level was passed in.

Note:


--*/
{
    NET_API_STATUS          apiStatus;
    LPBYTE                  untranslatedBuffer = NULL;


    if (MachineSupportsNt( (LPWSTR) servername )) {

        apiStatus = MapServiceEnum (
                (LPWSTR) servername,
                level,
                & untranslatedBuffer,
                prefmaxlen,
                entriesread,
                totalentries,
                resume_handle);

    } else {

        //
        // Call downlevel...
        //
        apiStatus = RxNetServiceEnum(
                (LPWSTR) servername,
                level,
                & untranslatedBuffer,
                prefmaxlen,
                entriesread,
                totalentries,
                resume_handle);

    }

    //
    // Translate service names in returned buffer.
    //
    if ( (apiStatus == NO_ERROR) || (apiStatus == ERROR_MORE_DATA) ) {

        if ( (*entriesread) > 0 ) {    // One or more services returned.
            NetpAssert( untranslatedBuffer != NULL );
            NetpAssert( (*totalentries) > 0 );

            apiStatus = NetpTranslateNamesInServiceArray(
                    level,
                    untranslatedBuffer,
                    *entriesread,
                    TRUE,  // yes, caller wants new style names
                    (LPVOID *) (LPVOID) bufptr);

        } else {          // Zero services returned.
            NetpAssert( untranslatedBuffer == NULL );
            // Note: total entries may be > 0, if this is ERROR_MORE_DATA...
            *bufptr = NULL;
        }
    }

    if (untranslatedBuffer != NULL) {
        (VOID) NetApiBufferFree( untranslatedBuffer );
    }

    return(apiStatus);

} // NetServiceEnum



NET_API_STATUS NET_API_FUNCTION
NetServiceGetInfo (
    IN  LPCWSTR servername OPTIONAL,
    IN  LPCWSTR service,
    IN  DWORD   level,
    OUT LPBYTE  *bufptr
    )
/*++

Routine Description:

    This is the DLL entrypoint for NetServiceGetInfo.

Arguments:

    servername - Pointer to a string containing the name of the computer
        that is to execute the API function.  Since this function is
        executing on that computer, this information is not useful
        by the time it gets here.  It is really only useful on the RPC
        client side.

    service - Pointer to a string containing the name of the service
        for which information is desired.

    level - This indicates the level of information that is desired.

    bufptr - Pointer to a Location where the pointer to the returned
        information structure is to be placed.

Return Value:

    NERR_Success - The operation was successful.

    NERR_ServiceNotInstalled - if the service record was not found in
        either the installed or uninstalled lists.

    NERR_BadServiceName - The service name pointer was NULL.

    ERROR_INVALID_LEVEL - An illegal info level was passed in.

    ERROR_NOT_ENOUGH_MEMORY - The memory allocation for the returned
        Info Record failed.

    other - Any error returned by the following base API:
                RPC Runtime API


--*/

{
    NET_API_STATUS          apiStatus;
    LPWSTR                  translatedServiceName;
    LPBYTE                  untranslatedBuffer = NULL;

    if (MachineSupportsNt( (LPWSTR) servername )) {

        apiStatus = NetpTranslateServiceName(
                (LPWSTR) service,  // untranslated.
                TRUE,              // yes, we want new style name
                & translatedServiceName );
        NetpAssert( apiStatus == NO_ERROR );

        apiStatus = MapServiceGetInfo (
                (LPWSTR) servername,
                (LPWSTR) service,
                level,
                & untranslatedBuffer);

    } else {

        apiStatus = NetpTranslateServiceName(
                (LPWSTR) service,  // untranslated.
                FALSE,             // no, we don't want new style name
                & translatedServiceName );
        NetpAssert( apiStatus == NO_ERROR );

        //
        // Call downlevel...
        //
        apiStatus = RxNetServiceGetInfo(
                (LPWSTR) servername,
                translatedServiceName,
                level,
                & untranslatedBuffer);

    }

    //
    // Translate service name in returned buffer.
    //
    if (apiStatus == NO_ERROR) {

        NetpAssert( untranslatedBuffer != NULL );
        apiStatus = NetpTranslateNamesInServiceArray(
                level,
                untranslatedBuffer,
                1,     // only one entry
                TRUE,  // yes, caller wants new style names
                (LPVOID *) (LPVOID) bufptr);

    }

    if (untranslatedBuffer != NULL) {
        (VOID) NetApiBufferFree( untranslatedBuffer );
    }

    return(apiStatus);
}


NET_API_STATUS NET_API_FUNCTION
NetServiceInstall (
    IN  LPCWSTR servername OPTIONAL,
    IN  LPCWSTR service,
    IN  DWORD   argc,
    IN  LPCWSTR argv[],
    OUT LPBYTE  *bufptr
    )
/*++

Routine Description:

    This is the DLL entrypoint for NetServiceInstall.

Arguments:

    servername - Points to a string containing the name of the computer
        that is to execute the API function.

    service- Points to a string containing the name of the service
        that is to be started.

    argc - Indicates the number or argument vectors in argv.

    argv - A pointer to an array of pointers to strings.  These
        are command line arguments that are to be passed to the service.

    bufptr - This is the address where a pointer to the service's
        information buffer (SERVICE_INFO_2) is to be placed.

Return Value:

    NERR_Success - The operation was successful

    NERR_InternalError - There is a bug in this program somewhere.

    NERR_ServiceInstalled - The service is already running - we do not
        yet allow multiple instances of the same service.

    NERR_CfgCompNotFound - The configuration component could not be found.
        The Image File could not be found for this service.

    NERR_ServiceTableFull - The maximum number of running services has
        already been reached.

    NERR_ServiceCtlTimeout - The service program did not respond to the
        start-up request within the timeout period.  If this was the
        only service in the service process, the service process was
        killed.

    ERROR_NOT_ENOUGH_MEMORY - If this error occurs early in the
        start-up procedure, the start-up will fail.  If it occurs at the
        end (allocating the return status buffer), the service will still
        be started and allowed to run.

    other - Any error returned by the following base API:
                CreateNamedPipe
                ConnectNamedPipe
                CreateProcess
                TransactNamedPipe
                RPC Runtime API


--*/
{
    NET_API_STATUS          apiStatus;
    LPWSTR                  translatedServiceName;
    LPBYTE                  untranslatedBuffer = NULL;


    if (MachineSupportsNt( (LPWSTR) servername )) {

        apiStatus = NetpTranslateServiceName(
                (LPWSTR) service,  // untranslated.
                TRUE,              // yes, we want new style name
                & translatedServiceName );
        NetpAssert( apiStatus == NO_ERROR );

        apiStatus = MapServiceInstall (
                (LPWSTR) servername,
                (LPWSTR) service,
                argc,
                (LPWSTR *) argv,
                & untranslatedBuffer);

    } else {

        apiStatus = NetpTranslateServiceName(
                (LPWSTR) service,  // untranslated.
                FALSE,             // no, we don't want new style name
                & translatedServiceName );
        NetpAssert( apiStatus == NO_ERROR );

        //
        // Call downlevel....
        //
        apiStatus = RxNetServiceInstall(
                (LPWSTR) servername,
                translatedServiceName,
                argc,
                (LPWSTR *) argv,
                & untranslatedBuffer);

    }

    //
    // Translate service name in returned buffer.
    //
    if (apiStatus == NO_ERROR) {

        NetpAssert( untranslatedBuffer != NULL );
        apiStatus = NetpTranslateNamesInServiceArray(
                2,  // level 2 by definition
                untranslatedBuffer,
                1,     // only one entry
                TRUE,  // yes, caller wants new style names
                (LPVOID *) (LPVOID) bufptr);

    }

    if (untranslatedBuffer != NULL) {
        (VOID) NetApiBufferFree( untranslatedBuffer );
    }

    return(apiStatus);
}


DBGSTATIC BOOL
MachineSupportsNt(
    IN LPWSTR UncServerName OPTIONAL
    )
{
    NET_API_STATUS ApiStatus;
    DWORD ActualSupports;

    ApiStatus = NetRemoteComputerSupports(
            UncServerName,
            SUPPORTS_RPC,                        // Set SUPPORT_ bits wanted.
            & ActualSupports );

    if (ApiStatus != NO_ERROR) {
        return (FALSE);   // Error; say it doesn't support NT, and someone else
                          // will set the correct error code.
    }
    if (ActualSupports & SUPPORTS_RPC) {
        return (TRUE);
    }
    return (FALSE);

} // MachineSupportsNt
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\rpcxlate\rxcommon\start.c ===
/*++

Copyright (c) 1991-1993  Microsoft Corporation

Module Name:

    Start.c

Abstract:

    RxpStartBuildingTransaction builds the first part of the transaction
    SMB which will be used with the Remote Admin Protocol to perform an
    API on a downlevel server.

Author:

    John Rogers (JohnRo) 01-Apr-1991

Environment:

    Portable to any flat, 32-bit environment.  (Uses Win32 typedefs.)
    Requires ANSI C extensions: slash-slash comments, long external names.

Revision History:

    01-Apr-1991 JohnRo
        Created.
    04-Apr-1991 JohnRo
        Quiet debug output by default.
    03-May-1991 JohnRo
        Indicate that data descriptor is SMB version (no Q's or U's).
        Added test for valid SMB descriptor.  Reduced recompile hits from
        header files.  Fix transaction SMB when no data desc is present.
        Clarify that buffer is really used as OUT.
    15-May-1991 JohnRo
        Added native vs. RAP handling.
    28-May-1991 JohnRo
        Don't be so aggressive checking buffer size, because this may be
        a set info API.  Also, use DESCLEN() instead of strlen().
    17-Jul-1991 JohnRo
        Extracted RxpDebug.h from Rxp.h.
    21-Nov-1991 JohnRo
        Removed NT dependencies to reduce recompiles.
    27-Nov-1991 JohnRo
        Do some checking of ApiNumber.
    31-Mar-1992 JohnRo
        Prevent too large size requests.
    06-May-1993 JohnRo
        RAID 8849: Export RxRemoteApi for DEC and others.
        Use NetpKdPrint() where possible.
        Use PREFIX_ equates.
        Made some changes suggested by CliffV way back when.

--*/


// These must be included first:

#include <windef.h>     // IN, DWORD, LPTSTR, etc.
#include <rxp.h>        // My prototype, MAX_TRANSACT_ equates, etc.

// These may be included in any order:

#include <lmerr.h>      // NERR_ and ERROR_ equates.
#include <netdebug.h>   // NetpKdPrint(), FORMAT_ equates, etc.
#include <netlib.h>     // NetpMoveMemory(), etc.
#include <prefix.h>     // PREFIX_ equates.
#include <rap.h>        // LPDESC, DESC_CHAR, DESC_LEN().
#include <rxpdebug.h>   // IF_DEBUG().


NET_API_STATUS
RxpStartBuildingTransaction(
    OUT LPVOID Buffer,
    IN DWORD BufferLength,
    IN DWORD ApiNumber,
    IN LPDESC ParmDesc,
    IN LPDESC DataDescSmb OPTIONAL,
    OUT LPVOID *RovingOutputPointer,
    OUT LPDWORD LengthSoFarPointer,
    OUT LPVOID *LastStringPointer OPTIONAL,
    OUT LPDESC *ParmDescCopyPointer OPTIONAL
    )

/*++

Routine Description:

    RxpStartBuildingTransaction builds the initial part of a transaction
    SMB for RpcXlate.

Arguments:

    Buffer - Address of the buffer to be built.  There should be nothing in
        this area before calling this routine.

    BufferLength - Size of the area at Buffer (in bytes).

    ApiNumber - The number of the API.

    ParmDesc - The descriptor string for the API's parameters (16-bit version).

    DataDescSmb - The optional descriptor string for the API's data (SMB
        version).

    RovingOutputPointer - This will be set to point to the first available
        location after the items which this routine places in the buffer.

    LengthSoFarPointer - Points to a DWORD which will be updated with the
        number of bytes used by this routine.

    LastStringPointer - Optionally points to a pointer which will be set to
        point to an area (at the end of the buffer) to be filled-in with
        variable-length data (e.g. strings).

    ParmDescCopyPointer - Optionally points to a pointer which will be set with
        the location of the copy of ParmDesc in the buffer.

Return Value:

    NET_API_STATUS - NERR_Success or NERR_NoRoom.

--*/

{
    DWORD CurrentLength;
    LPVOID CurrentPointer;
    DWORD DescSize;
    DWORD FixedLengthRequired;

    //
    // Make sure API number doesn't get truncated.
    // Note that we can't check against the MAX_API equate anymore, as
    // that only includes APIs which we know about.  Now that RxRemoteApi is
    // being exported for use by anyone, we don't know the maximum API number
    // which the app might be using.
    //

    if ( ((DWORD)(WORD)ApiNumber) != ApiNumber ) {
        NetpKdPrint(( PREFIX_NETAPI
                "RxpStartBuildingTransaction: API NUMBER "
                "(" FORMAT_HEX_DWORD ") TOO LARGE, "
                "returning ERROR_INVALID_PARAMETER.\n",
                ApiNumber ));
        return (ERROR_INVALID_PARAMETER);
    }

    //
    // Check for other caller errors.
    //

    NetpAssert( Buffer != NULL );
    // BufferLength checked below.
    NetpAssert( ParmDesc != NULL );
    NetpAssert( RovingOutputPointer != NULL);
    NetpAssert( LengthSoFarPointer != NULL);

    //
    // Make sure caller has allocated enough room.
    //
    FixedLengthRequired = sizeof(WORD)                  // api number
            + DESCLEN(ParmDesc) + sizeof(char);         // parm str and null
    if (DataDescSmb != NULL) {
        // Make sure data descriptor and null will fit in buffer.
        FixedLengthRequired += DESCLEN(DataDescSmb) + sizeof(char);

        // Note that we used to check that the entire structure defined by
        // the data descriptor would fit in the buffer.  However, this could
        // be a set info API, which passes the entire descriptor but might
        // only need space for one field.  So we just do a minimal check now.
        FixedLengthRequired += sizeof(BYTE);            // smallest field.

    } else {
        FixedLengthRequired += sizeof(char);            // null (no data desc)
    }
    IF_DEBUG(START) {
        NetpKdPrint(( PREFIX_NETAPI
                "RxpStartBuildingTransaction: fixed len=" FORMAT_DWORD
                ", buff len=" FORMAT_DWORD ".\n",
                FixedLengthRequired, BufferLength ));
    }
    if (FixedLengthRequired > BufferLength) {
        return (NERR_NoRoom);
    }
    NetpAssert( BufferLength <= MAX_TRANSACT_SEND_PARM_SIZE );

    //
    // Initialize current variables, which we'll update as we go along.
    //
    CurrentPointer = Buffer;            /* Start of parameter buffer */
    CurrentLength = 0;

    //
    // Copy the API number into the first word.
    //
    SmbPutUshort( (LPWORD) CurrentPointer, (WORD) ApiNumber );
    CurrentLength += sizeof(WORD);              // Update buffer ptr & length.
    CurrentPointer = NetpPointerPlusSomeBytes(CurrentPointer, sizeof(WORD));
    IF_DEBUG(START) {
        NetpKdPrint(( PREFIX_NETAPI
                "RxpStartBuildingTransaction: Done API number.\n" ));
    }

    //
    // Copy the 16-bit version of the parm descriptor string next.
    //
    NetpAssert(RapIsValidDescriptorSmb(ParmDesc));
    DescSize = DESCLEN(ParmDesc) + 1;           // Length of parm desc.
    NetpAssert(sizeof(DESC_CHAR) == 1);
    NetpMoveMemory(
                CurrentPointer,                         // dest
                ParmDesc,                               // src
                DescSize);                              // byte count
    if (ParmDescCopyPointer != NULL) {
        *ParmDescCopyPointer = CurrentPointer;
    }
    CurrentLength += DescSize;                  // Add to total length.
    CurrentPointer = NetpPointerPlusSomeBytes(CurrentPointer, DescSize);
    IF_DEBUG(START) {
        NetpKdPrint(( PREFIX_NETAPI
                "RxpStartBuildingTransaction: Done parm desc.\n" ));
    }

    //
    // Copy the SMB version of the data descriptor string next.
    //
    if (DataDescSmb != NULL) {
        NetpAssert(RapIsValidDescriptorSmb(DataDescSmb));
        DescSize = strlen(DataDescSmb) + 1;     // Length of data desc.
        NetpMoveMemory(
                    CurrentPointer,             // dest
                    DataDescSmb,                // src
                    DescSize);                  // byte count
    } else {
        DescSize = 1;                           // Only end of string.
        * (LPBYTE) CurrentPointer = '\0';       // Null at end of string.
    }
    CurrentLength += DescSize;                  // Add to total length.
    CurrentPointer = NetpPointerPlusSomeBytes(CurrentPointer, DescSize);
    IF_DEBUG(START) {
        NetpKdPrint(( PREFIX_NETAPI
                "RxpStartBuildingTransaction: Done data desc (if any).\n" ));
    }

    //
    // Tell caller what we did.
    //
    *RovingOutputPointer = CurrentPointer;
    *LengthSoFarPointer = CurrentLength;
    if (LastStringPointer != NULL) {
        *LastStringPointer =
                NetpPointerPlusSomeBytes(
                        Buffer,
                        BufferLength);
    }
    IF_DEBUG(START) {
        NetpKdPrint(( PREFIX_NETAPI
                "RxpStartBuildingTransaction: Done setting outputs.\n" ));
    }

    return (NERR_Success);

} // RxpStartBuildingTransaction
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcctrl\svcdebug.h ===
/*++

Copyright (c) 1991-92  Microsoft Corporation

Module Name:

    SvcDebug.h

Abstract:

    Contains debug macros used by the Net Service Controller APIs.

Author:

    Dan Lafferty (danl)     22-Apr-1991

Environment:

    User Mode -Win32

Revision History:

    30-Mar-1992 JohnRo
        Extracted DanL's code from /nt/private project back to NET project.
        Use NetpDbgPrint instead of DbgPrint.
    08-May-1992 JohnRo
        Use <prefix.h> equates.
    02-Nov-1992 JohnRo
        RAID 7780: added IF_DEBUG() macro.  Added TRANSLATE trace bit.

--*/

#ifndef _SVCDEBUG_
#define _SVCDEBUG_


#include <netdebug.h>   // NetpDbgPrint(), etc.
#include <prefix.h>     // PREFIX_ equates.


//
// Debug macros and constants.
//
/*lint -e767 */  // Don't complain about different definitions
#if DBG


#define DEBUG_STATE 1
#define IF_DEBUG(Function) if (SvcctrlDebugLevel & DEBUG_ ## Function)

#else

#define DEBUG_STATE 0
#define IF_DEBUG(Function) if (FALSE)

#endif // DBG
/*lint +e767 */  // Resume checking for different macro definitions


extern DWORD    SvcctrlDebugLevel;

//
// The following allow debug print syntax to look like:
//
//   SC_LOG(DEBUG_TRACE, "An error occured %x\n",status)
//

#if DBG

//
// Client-side debugging macro.
//
#define SCC_LOG(level,string,var)                \
    if( SvcctrlDebugLevel & (DEBUG_ ## level)){  \
        NetpDbgPrint(PREFIX_NETAPI "[SCSTUB] "); \
        NetpDbgPrint(string,var);                \
    }

#else

#define SC_LOG(level,string,var)
#define SCC_LOG(level,string,var)

#endif

#define DEBUG_NONE      0x00000000
#define DEBUG_ERROR     0x00000001
#define DEBUG_TRACE     0x00000002
#define DEBUG_LOCKS     0x00000004
#define DEBUG_HANDLE    0x00000008
#define DEBUG_SECURITY  0x00000010
#define DEBUG_TRANSLATE 0x00000020

#define DEBUG_ALL       0xffffffff

#endif // _SVCDEBUG_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcctrl\client\svcmap.h ===
/*++

Copyright (c) 1991-92  Microsoft Corporation

Module Name:

    SvcMap.h

Abstract:

    These are the API entry points for the NetService API.
    These mapping routines implement old-style APIs on new (NT/RPC) machines.
    The following funtions are in this file:

        MapServiceControl
        MapServiceEnum
        MapServiceGetInfo
        MapServiceInstall
        MapServiceStartCtrlDispatcher
        MapServiceStatus
        MapServiceRegisterCtrlHandler

Author:

    Dan Lafferty    (danl)  05-Feb-1992

Environment:

    User Mode - Win32 

Revision History:

    05-Feb-1992     Danl
        Created
    30-Mar-1992 JohnRo
        Extracted DanL's code from /nt/private project back to NET project.

--*/


#ifndef _SVCMAP_
#define _SVCMAP_

NET_API_STATUS
MapServiceControl (
    IN  LPTSTR  servername OPTIONAL,
    IN  LPTSTR  service,
    IN  DWORD   opcode,
    IN  DWORD   arg,
    OUT LPBYTE  *bufptr
    );

NET_API_STATUS
MapServiceEnum (
    IN  LPTSTR      servername OPTIONAL,
    IN  DWORD       level,
    OUT LPBYTE      *bufptr,
    IN  DWORD       prefmaxlen,
    OUT LPDWORD     entriesread,
    OUT LPDWORD     totalentries,
    IN OUT LPDWORD  resume_handle OPTIONAL
    );

NET_API_STATUS
MapServiceGetInfo (
    IN  LPTSTR  servername OPTIONAL,
    IN  LPTSTR  service,
    IN  DWORD   level,
    OUT LPBYTE  *bufptr
    );

NET_API_STATUS
MapServiceInstall (
    IN  LPTSTR  servername OPTIONAL,
    IN  LPTSTR  service,
    IN  DWORD   argc,
    IN  LPTSTR  argv[],
    OUT LPBYTE  *bufptr
    );

#endif // _SVCMAP_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\alrsvc\al.h ===
/*++

Copyright (c) 1991 Microsoft Corporation

Module Name:

    al.h

Abstract:

    Private header file for the NT Alerter service included by every module
    of the Alerter service.

Author:

    Rita Wong (ritaw) 01-July-1991

Revision History:

--*/

#ifndef _AL_INCLUDED_
#define _AL_INCLUDED_

#include <nt.h>                   // NT definitions
#include <ntrtl.h>                // NT runtime library definitions
#include <nturtl.h>

#include <windef.h>               // Win32 type definitions
#include <winbase.h>              // Win32 base API prototypes

#include <lmcons.h>               // LAN Manager common definitions
#include <lmerr.h>                // LAN Manager network error definitions
#include <lmapibuf.h>             // NetApiBufferFree
#include <lmerrlog.h>             // NELOG_

#include <lmalert.h>              // LAN Manager alert structures
#include <icanon.h>               // I_NetXxxCanonicalize routines

#include <netlib.h>               // LAN Man utility routines
#include <netlibnt.h>             // NetpNtStatusToApiStatus
#include <netdebug.h>             // NetpDbgPrint
#include <tstring.h>              // Transitional string functions


#define AL_NULL_CHAR    '\0'
#define AL_SPACE_CHAR   ' '

//
// Debug trace level bits for turning on/off trace statements in the
// Alerter service
//

//
// Utility trace statements
//
#define ALERTER_DEBUG_UTIL         0x00000001

//
// Configuration trace statements
//
#define ALERTER_DEBUG_CONFIG       0x00000002

//
// Main service functionality
//
#define ALERTER_DEBUG_MAIN         0x00000004

//
// Format message trace statements
//
#define ALERTER_DEBUG_FORMAT       0x00000008

//
// All debug flags on
//
#define ALERTER_DEBUG_ALL          0xFFFFFFFF


#if DBG

#define STATIC

extern DWORD AlerterTrace;

#define DEBUG if (TRUE)

#define IF_DEBUG(Function) if (AlerterTrace & ALERTER_DEBUG_ ## Function)

#else

#define STATIC static

#define DEBUG if (FALSE)

#define IF_DEBUG(Function) if (FALSE)

#endif // DBG


//-------------------------------------------------------------------//
//                                                                   //
// Type definitions                                                  //
//                                                                   //
//-------------------------------------------------------------------//

typedef enum _AL_ERROR_CONDITION {
    AlErrorRegisterControlHandler = 0,
    AlErrorCreateMailslot,
    AlErrorGetComputerName,
    AlErrorNotifyServiceController,
    AlErrorSendMessage
} AL_ERROR_CONDITION, *PAL_ERROR_CONDITION;


//-------------------------------------------------------------------//
//                                                                   //
// Function prototypes                                               //
//                                                                   //
//-------------------------------------------------------------------//

//
// From almain.c
//
VOID
AlHandleError(
    IN AL_ERROR_CONDITION FailingCondition,
    IN NET_API_STATUS Status,
    IN LPTSTR MessageAlias OPTIONAL
    );

//
// From alformat.c
//
VOID
AlAdminFormatAndSend(
    IN  PSTD_ALERT Alert
    );

VOID
AlUserFormatAndSend(
    IN  PSTD_ALERT Alert
    );

VOID
AlPrintFormatAndSend(
    IN  PSTD_ALERT Alert
    );

VOID
AlFormatErrorMessage(
    IN  NET_API_STATUS Status,
    IN  LPTSTR MessageAlias,
    OUT LPTSTR ErrorMessage,
    IN  DWORD ErrorMessageBufferSize
    );

NET_API_STATUS
AlCanonicalizeMessageAlias(
    LPTSTR MessageAlias
    );

#if DBG
VOID
AlHexDump(
    LPBYTE Buffer,
    DWORD BufferSize
    );
#endif


//
// From alconfig.c
//
NET_API_STATUS
AlGetAlerterConfiguration(
    VOID
    );

VOID
AlLogEvent(
    DWORD MessageId,
    DWORD NumberOfSubStrings,
    LPWSTR *SubStrings
    );


//-------------------------------------------------------------------//
//                                                                   //
// Global variables                                                  //
//                                                                   //
//-------------------------------------------------------------------//

extern LPSTR AlertNamesA;
extern LPTSTR AlertNamesW;
extern LPSTR AlLocalComputerNameA;
extern LPTSTR AlLocalComputerNameW;

#endif // ifdef _AL_INCLUDED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcctrl\client\svcmap.c ===
/*++

Copyright (c) 1991-1992  Microsoft Corporation

Module Name:

    SvcMap.c (was DanL's OldWrap.c)

Abstract:

    These are the API entry points for the NetService API.
    These mapping routines implement old-style APIs on new (NT/RPC) machines.
    The following functions are in this file:

    Exported:
        MapServiceControl
        MapServiceEnum
        MapServiceGetInfo
        MapServiceInstall

    Local:
        TranslateStatus
        MakeStatus
        MakeCode

Author:

    Dan Lafferty    (danl)  05-Feb-1992

Environment:

    User Mode - Win32

Revision History:

    05-Feb-1992     Danl
        Created
    30-Mar-1992 JohnRo
        Extracted DanL's code from /nt/private project back to NET project.
    30-Apr-1992 JohnRo
        Use FORMAT_ equates where possible.
    14-May-1992 JohnRo
        winsvc.h and related file cleanup.
    22-May-1992 JohnRo
        RAID 9829: winsvc.h and related file cleanup.
    02-Jun-1992 JohnRo
        RAID 9829: Avoid winsvc.h compiler warnings.
    05-Aug-1992 JohnRo
        RAID 3021: NetService APIs don't always translate svc names.
        (Actually just avoid compiler warnings.)
    14-OCt-1992 Danl
        Close handles that were left open by using CleanExit.
    05-Nov-1992 JohnRo
        RAID 7780: netcmd: assertion 'net start' w/ only 2 present services.
        Corrected error code for invalid level.

--*/

//
// INCLUDES
//

// These must be included first:

#include <windows.h>    // IN, DWORD, LocalFree(), SERVICE_ equates, etc.
#include <lmcons.h>     // NET_API_STATUS

// These may be included in any order:

#include <lmerr.h>      // NetError codes
#include <lmsvc.h>      // LM20_SERVICE_ equates.
#include <netdebug.h>   // NetpAssert(), DBGSTATIC, FORMAT_ equates.
#include <prefix.h>     // PREFIX_ equates.
#include <svcmap.h>     // MapService() routines.
#include <rpcutil.h>    // MIDL_user_allocate(), etc.
#include <svcdebug.h>   // IF_DEBUG(), SCC_LOG, etc.
#include <tstr.h>       // STRCPY(), TCHAR_EOS.


//
// Range for OEM defined control opcodes
//
#define SVC_FUDGE_FACTOR    1024

#define OEM_LOWER_LIMIT     128
#define OEM_UPPER_LIMIT     255

#ifndef LEVEL_2
#define LEVEL_0    0L
#define LEVEL_1    1L
#define LEVEL_2    2L
#endif


//
// Globals
//


//
// LOCAL FUNCTIONS
//

DBGSTATIC DWORD
TranslateStatus(
    OUT LPBYTE              BufPtr,
    IN  LPSERVICE_STATUS    ServiceStatus,
    IN  LPTSTR              ServiceName,
    IN  DWORD               Level,
    IN  LPTSTR              DisplayName,
    OUT LPTSTR              DestString
    );

DBGSTATIC DWORD
MakeStatus(
    IN  DWORD   CurrentState,
    IN  DWORD   ControlsAccepted
    );

DBGSTATIC DWORD
MakeCode(
    IN  DWORD   ExitCode,
    IN  DWORD   CheckPoint,
    IN  DWORD   WaitHint
    );

DBGSTATIC NET_API_STATUS
MapError(
    DWORD WinSvcError
    );


NET_API_STATUS
MapServiceControl (
    IN  LPTSTR  servername OPTIONAL,
    IN  LPTSTR  service,
    IN  DWORD   opcode,
    IN  DWORD   arg,
    OUT LPBYTE  *bufptr
    )
/*++

Routine Description:

    This is the DLL entrypoint for NetServiceControl.

Arguments:

    servername - Pointer to a string containing the name of the computer
        that is to execute the API function.

    service - Pointer to a string containing the name of the service
        that is to receive the control request.

    opcode - The control request code.

    arg - An additional (user defined) code that will be passed to the
        service.

    bufptr - pointer to a location where the service status is to
        be returned.  If this pointer is invalid, it will be set to NULL
        upon return.

Return Value:

    The returned InfoStruct2 structure is valid as long as the returned
    error is NOT NERR_ServiceNotInstalled or NERR_ServiceBadServiceName.

    NERR_Success - The operation was successful.

    NERR_InternalError - LocalAlloc or TransactNamedPipe failed, or
        TransactNamedPipe returned fewer bytes than expected.

    NERR_ServiceNotInstalled - The service record was not found in the
        installed list.

    NERR_BadServiceName - The service name pointer was NULL.

    NERR_ServiceCtlTimeout - The service did not respond with a status
        message within the fixed timeout limit (RESPONSE_WAIT_TIMEOUT).

    NERR_ServiceKillProcess - The service process had to be killed because
        it wouldn't terminate when requested.

    NERR_ServiceNotCtrl - The service cannot accept control messages.
        The install state indicates that start-up or shut-down is pending.

    NERR_ServiceCtlNotValid - The request is not valid for this service.
        For instance, a PAUSE request is not valid for a service that
        lists itself as NOT_PAUSABLE.

    ERROR_ACCESS_DENIED - This is a status response from the service
        security check.


--*/
{
    NET_API_STATUS      status = NERR_Success;
    SC_HANDLE           hServiceController = NULL;
    SC_HANDLE           hService = NULL;
    DWORD               control;
    DWORD               desiredAccess = 0;
    SERVICE_STATUS      serviceStatus;
    LPTSTR              stringPtr;

    UNREFERENCED_PARAMETER( arg );

    *bufptr = NULL;  // Null output so error cases are easy to handle.

    //
    // Get a handle to the service controller.
    //
    hServiceController = OpenSCManager(
                            servername,
                            NULL,
                            SC_MANAGER_CONNECT);

    if (hServiceController == NULL) {
        status = MapError(GetLastError());
        SCC_LOG(ERROR,"NetServiceControl:OpenSCManager failed "
                FORMAT_API_STATUS "\n",status);
        return(status);
    }

    //
    // Translate the control opcode from the ancient variety to the
    // new and improved NT variety.
    //

    switch(opcode) {
    case SERVICE_CTRL_INTERROGATE:
        control = SERVICE_CONTROL_INTERROGATE;
        desiredAccess = SERVICE_INTERROGATE | SERVICE_QUERY_STATUS;
        break;
    case SERVICE_CTRL_PAUSE:
        control = SERVICE_CONTROL_PAUSE;
        desiredAccess = SERVICE_PAUSE_CONTINUE;
        break;
    case SERVICE_CTRL_CONTINUE:
        control = SERVICE_CONTROL_CONTINUE;
        desiredAccess = SERVICE_PAUSE_CONTINUE;
        break;
    case SERVICE_CTRL_UNINSTALL:
        control = SERVICE_CONTROL_STOP;
        desiredAccess = SERVICE_STOP;
        break;
    default:
        if ((opcode >= OEM_LOWER_LIMIT) &&
            (opcode <= OEM_UPPER_LIMIT))
        {
            control = opcode;
            desiredAccess = SERVICE_USER_DEFINED_CONTROL;
        }
        else
        {
            status = NERR_ServiceCtlNotValid;
            goto CleanExit;
        }
    }

    //
    // Get a handle to the service
    //

    hService = OpenService(
                hServiceController,
                service,
                desiredAccess);

    if (hService == NULL) {
        status = MapError(GetLastError());
        SCC_LOG(ERROR,"NetServiceControl:OpenService failed "
                FORMAT_API_STATUS "\n",status);

        goto CleanExit;
    }


    //
    // Send the control
    //

    if (!ControlService(hService,control,&serviceStatus)) {

        status = MapError(GetLastError());

        //
        // Convert an interrogate control to query service status
        // if the service happens to be in an uncontrollable state.
        //
        if ((status == NERR_ServiceNotCtrl || status == NERR_ServiceNotInstalled) &&
            (opcode == SERVICE_CTRL_INTERROGATE)) {

            if (!QueryServiceStatus(hService,&serviceStatus)) {
                status = MapError(GetLastError());
            }
            else {
                status = NERR_Success;
            }
        }

        if (status != NERR_Success) {
            SCC_LOG(ERROR,"NetServiceControl:ControlService failed "
                    FORMAT_API_STATUS "\n",status);
            goto CleanExit;
        }
    }

    //
    // Translate the status from the old - ancient variety to the new
    // and improved NT variety.
    //
    *bufptr = MIDL_user_allocate(
                    sizeof(SERVICE_INFO_2) + STRSIZE(service));

    if (*bufptr == NULL) {
        SCC_LOG(ERROR,"NetServiceControl:Allocation Failure\n",0);
        status = ERROR_NOT_ENOUGH_MEMORY;
        goto CleanExit;
    }

    stringPtr = (LPTSTR)((*bufptr) + sizeof(SERVICE_INFO_2));

    status = TranslateStatus(
                *bufptr,
                &serviceStatus,
                service,
                LEVEL_2,
                NULL,           // DisplayName
                stringPtr);     // dest for name string

CleanExit:

    if(hServiceController != NULL) {
        (VOID) CloseServiceHandle(hServiceController);
    }
    if(hService != NULL) {
        (VOID) CloseServiceHandle(hService);
    }
    return(status);

}


NET_API_STATUS
MapServiceEnum (
    IN  LPTSTR      servername OPTIONAL,
    IN  DWORD       level,
    OUT LPBYTE      *bufptr,
    IN  DWORD       prefmaxlen,
    OUT LPDWORD     entriesread,
    OUT LPDWORD     totalentries,
    IN OUT LPDWORD  resume_handle OPTIONAL
    )
/*++

Routine Description:

    This is the DLL entrypoint for NetSeviceEnum.

Arguments:

    servername - Pointer to a string containing the name of the computer
        that is to execute the API function.

    level - This indicates the level of information that is desired.

    bufptr - A pointer to the location where the pointer to the returned
        array of info structures is to be placed.

    prefmaxlen - Indicates a maximum size limit that the caller will allow
        for the return buffer.

    entriesread - A pointer to the location where the number of entries
        (data structures)read is to be returned.

    totalentries - A pointer to the location which upon return indicates
        the total number of entries in the "active" database.

    resumehandle - Pointer to a value that indicates where to resume
        enumerating data.

Return Value:

    Nerr_Success - The operation was successful.

    ERROR_MORE_DATA - Not all of the data in the active database could be
        returned.

    ERROR_INVALID_LEVEL - An illegal info Level was passed in.

Note:


--*/
{
    NET_API_STATUS          status = NERR_Success;
    SC_HANDLE               hServiceController = NULL;
    LPENUM_SERVICE_STATUS   enumStatus;
    ENUM_SERVICE_STATUS     dummybuf;
    DWORD                   bufSize;
    DWORD                   structSize;
    LPBYTE                  buffer = NULL;
    LPBYTE                  tempPtr;
    DWORD                   bytesNeeded;
    DWORD                   i;

    *bufptr = NULL;  // Null output so error cases are easy to handle.

    //
    // Get a handle to the service controller.
    //
    hServiceController = OpenSCManager(
                            servername,
                            NULL,
                            SC_MANAGER_CONNECT | SC_MANAGER_ENUMERATE_SERVICE);

    if (hServiceController == NULL) {
        status = MapError(GetLastError());
        SCC_LOG(ERROR,"NetServiceEnum:OpenSCManager failed (dec) "
                FORMAT_API_STATUS "\n", status);
        SCC_LOG(ERROR,"NetServiceEnum:OpenSCManager failed (hex) "
                FORMAT_HEX_DWORD "\n", (DWORD) status);
        return(status);
    }

    if (!EnumServicesStatus(
            hServiceController,
            SERVICE_WIN32,
            SERVICE_ACTIVE,
            (LPENUM_SERVICE_STATUS) &dummybuf,
            sizeof(dummybuf),
            &bytesNeeded,
            entriesread,
            NULL)) {

        status = MapError(GetLastError());

        if (status != ERROR_MORE_DATA) {

            (VOID) CloseServiceHandle(hServiceController);

            SCC_LOG(ERROR,"NetServiceEnum:EnumServiceStatus failed "
                    FORMAT_API_STATUS "\n",status);
            return status;
        }

    }
    else {
        //
        // No entries to enumerate.
        //
        *totalentries = *entriesread = 0;
        *bufptr = NULL;

        if (resume_handle != NULL) {
            *resume_handle = 0;
        }

        (VOID) CloseServiceHandle(hServiceController);

        return NERR_Success;
    }

    //
    // Initialize entriesread so that we can free the output buffer
    // based on this value.
    //
    *entriesread = 0;

    //
    // In order to get the totalentries value, we have to allocate a
    // buffer large enough to hold all entries.  Since we are getting
    // all entries anyway, we ignore the prefmaxlen input parameter
    // and return everything.  Add fudge factor in case other services
    // got started in between our two EnumServicesStatus calls.
    //
    bufSize = bytesNeeded + SVC_FUDGE_FACTOR;
    buffer = MIDL_user_allocate(bufSize);

    if (buffer == NULL) {
        SCC_LOG(ERROR,"NetServiceEnum: Allocation Failure "
                FORMAT_API_STATUS "\n", (NET_API_STATUS) GetLastError());
        status = ERROR_NOT_ENOUGH_MEMORY;
        goto CleanExit;
    }

    //
    // Enumerate the status
    //

    if (!EnumServicesStatus(
            hServiceController,
            SERVICE_WIN32,
            SERVICE_ACTIVE,
            (LPENUM_SERVICE_STATUS)buffer,
            bufSize,
            &bytesNeeded,
            entriesread,
            resume_handle)) {

        status = MapError(GetLastError());

        if (status == ERROR_MORE_DATA) {

            //
            // If output buffer allocated is still too small we give
            // up and return nothing.
            //
            *entriesread = 0;
            status = ERROR_NOT_ENOUGH_MEMORY;
        }

        SCC_LOG(ERROR,"NetServiceEnum:EnumServiceStatus failed "
                FORMAT_API_STATUS "\n",status);
        goto CleanExit;
    }

    //
    // Translate the status from the old - ancient (lanman) variety to the
    // new and improved NT variety.
    //
    switch(level) {
    case LEVEL_0:
        structSize = sizeof(SERVICE_INFO_0);
        break;
    case LEVEL_1:
        structSize = sizeof(SERVICE_INFO_1);
        break;
    case LEVEL_2:
        structSize = sizeof(SERVICE_INFO_2);
        break;
    default:
        status = ERROR_INVALID_LEVEL;
        goto CleanExit;
    }

    //
    // CHANGE FORMAT OF RETURN BUFFER TO LANMAN-STYLE.
    //
    // It should be noted that the new ENUM_SERVICE_STATUS structure
    // is larger than any of the old lanman structures.  We can count
    // on the fact that the strings are in the later portion of the
    // buffer.  Therefore, we can write over the old structures - one
    // by one.
    //

    tempPtr = buffer;
    enumStatus = (LPENUM_SERVICE_STATUS)buffer;

    for (i=0; i < *entriesread; i++) {
        status = TranslateStatus (
                    tempPtr,                      // dest fixed structure
                    &(enumStatus->ServiceStatus),
                    enumStatus->lpServiceName,
                    level,
                    enumStatus->lpDisplayName,    // pointer to display name
                    enumStatus->lpServiceName);   // dest for name string

        if (status != NERR_Success) {
            (VOID) LocalFree(buffer);
            goto CleanExit;
        }
        tempPtr += structSize;
        enumStatus++;
    }

    //
    // We've read all entries.
    //
    *totalentries = *entriesread;

    *bufptr = buffer;

CleanExit:

    if(hServiceController != NULL) {
        (VOID) CloseServiceHandle(hServiceController);
    }

    if (*entriesread == 0) {
        if (buffer != NULL) {
            MIDL_user_free(buffer);
        }
        *bufptr = NULL;
    }

    return(status);

}



NET_API_STATUS
MapServiceGetInfo (
    IN  LPTSTR  servername OPTIONAL,
    IN  LPTSTR  service,
    IN  DWORD   level,
    OUT LPBYTE  *bufptr
    )
/*++

Routine Description:

    This is the DLL entrypoint for NetServiceGetInfo.

Arguments:

    servername - Pointer to a string containing the name of the computer
        that is to execute the API function.  Since this function is
        executing on that computer, this information is not useful
        by the time it gets here.  It is really only useful on the RPC
        client side.

    service - Pointer to a string containing the name of the service
        for which information is desired.

    level - This indicates the level of information that is desired.

    bufptr - Pointer to a Location where the pointer to the returned
        information structure is to be placed.

Return Value:

    NERR_Success - The operation was successful.

    NERR_ServiceNotInstalled - if the service record was not found in
        either the installed or uninstalled lists.

    NERR_BadServiceName - The service name pointer was NULL.

    ERROR_INVALID_LEVEL - An illegal info level was passed in.

    ERROR_NOT_ENOUGH_MEMORY - The memory allocation for the returned
        Info Record failed.

    other - Any error returned by the following base API:
                RPC Runtime API


--*/

{
    NET_API_STATUS      status = NERR_Success;
    SC_HANDLE           hServiceController = NULL;
    SC_HANDLE           hService = NULL;
    SERVICE_STATUS      serviceStatus;
    LPTSTR              stringPtr;
    DWORD               bufSize;
    DWORD               structSize;

    *bufptr = NULL;  // Null output so error cases are easy to handle.

    //
    // Get a handle to the service controller.
    //
    hServiceController = OpenSCManager(
                            servername,
                            NULL,
                            SC_MANAGER_CONNECT);

    if (hServiceController == NULL) {
        status = MapError(GetLastError());
        SCC_LOG(ERROR,"NetServiceGetInfo:OpenSCManager failed "
                FORMAT_API_STATUS "\n",status);
        return(status);
    }

    //
    // Get a handle to the service
    //

    hService = OpenService(
                hServiceController,
                service,
                SERVICE_QUERY_STATUS);

    if (hService == NULL) {
        status = MapError(GetLastError());
        SCC_LOG(ERROR,"NetServiceGetInfo:OpenService failed "
                FORMAT_API_STATUS "\n",status);

        goto CleanExit;
    }


    //
    // Query the status
    //

    if (!QueryServiceStatus(hService,&serviceStatus)) {
        status = MapError(GetLastError());
        SCC_LOG(ERROR,"NetServiceGetInfo:QueryServiceStatus failed "
                FORMAT_API_STATUS "\n",status);
        goto CleanExit;
    }

    //
    // Translate the status from the old - ancient variety to the new
    // and improved NT variety.
    //
    switch(level) {
    case LEVEL_0:
        structSize = sizeof(SERVICE_INFO_0);
        break;
    case LEVEL_1:
        structSize = sizeof(SERVICE_INFO_1);
        break;
    case LEVEL_2:
        structSize = sizeof(SERVICE_INFO_2);
        break;
    default:
        status = ERROR_INVALID_LEVEL;
        goto CleanExit;
    }

    bufSize = structSize + STRSIZE(service);

    *bufptr = MIDL_user_allocate(bufSize);

    if (*bufptr == NULL) {
        SCC_LOG(ERROR,"NetServiceGetInfo:Allocation Failure\n",0);
        status = ERROR_NOT_ENOUGH_MEMORY;
        goto CleanExit;
    }

    stringPtr = (LPTSTR)(*bufptr + structSize);

    status = TranslateStatus(
                *bufptr,
                &serviceStatus,
                service,
                level,
                NULL,           // DisplayName
                stringPtr);     // dest for name string

CleanExit:

    if(hServiceController != NULL) {
        (VOID) CloseServiceHandle(hServiceController);
    }
    if(hService != NULL) {
        (VOID) CloseServiceHandle(hService);
    }
    return(status);

}


NET_API_STATUS
MapServiceInstall (
    IN  LPTSTR  servername OPTIONAL,
    IN  LPTSTR  service,
    IN  DWORD   argc,
    IN  LPTSTR  argv[],
    OUT LPBYTE  *bufptr
    )
/*++

Routine Description:

    This is the DLL entrypoint for NetServiceInstall.

Arguments:

    servername - Points to a string containing the name of the computer
        that is to execute the API function.

    service- Points to a string containing the name of the service
        that is to be started.

    argc - Indicates the number or argument vectors in argv.

    argv - A pointer to an array of pointers to strings.  These
        are command line arguments that are to be passed to the service.

    bufptr - This is the address where a pointer to the service's
        information buffer (SERVICE_INFO_2) is to be placed.

Return Value:

    NERR_Success - The operation was successful

    NERR_InternalError - There is a bug in this program somewhere.

    NERR_ServiceInstalled - The service is already running - we do not
        yet allow multiple instances of the same service.

    NERR_CfgCompNotFound - The configuration component could not be found.
        The Image File could not be found for this service.

    NERR_ServiceTableFull - The maximum number of running services has
        already been reached.

    NERR_ServiceCtlTimeout - The service program did not respond to the
        start-up request within the timeout period.  If this was the
        only service in the service process, the service process was
        killed.

    ERROR_NOT_ENOUGH_MEMORY - If this error occurs early in the
        start-up procedure, the start-up will fail.  If it occurs at the
        end (allocating the return status buffer), the service will still
        be started and allowed to run.

    other - Any error returned by the following base API:
                CreateNamedPipe
                ConnectNamedPipe
                CreateProcess
                TransactNamedPipe
                RPC Runtime API


--*/

{
    NET_API_STATUS      status = NERR_Success;
    SC_HANDLE           hServiceController = NULL;
    SC_HANDLE           hService = NULL;
    SERVICE_STATUS      serviceStatus;
    LPTSTR              stringPtr;

    *bufptr = NULL;  // Null output so error cases are easy to handle.

    //
    // Get a handle to the service controller.
    //
    hServiceController = OpenSCManager(
                            servername,
                            NULL,
                            SC_MANAGER_CONNECT);

    if (hServiceController == NULL) {
        status = MapError(GetLastError());
        SCC_LOG(ERROR,"NetServiceInstall:OpenSCManager failed "
                FORMAT_API_STATUS "\n",status);
        return(status);
    }

    //
    // Get a handle to the service
    //

    hService = OpenService(
                hServiceController,
                service,
                SERVICE_QUERY_STATUS | SERVICE_START);

    if (hService == NULL) {
        status = MapError(GetLastError());
        SCC_LOG(ERROR,"NetServiceInstall:OpenService failed "
                FORMAT_API_STATUS "\n",status);

        goto CleanExit;
    }

    //
    // Call StartService
    //

    if (!StartService(hService,argc,(LPCTSTR *)argv)) {

        status = MapError(GetLastError());
        SCC_LOG(ERROR,"NetServiceInstall:StartService failed "
                FORMAT_API_STATUS "\n",status);
        goto CleanExit;
    }

    //
    // Get the service status since StartService does not return it
    //

    if (!QueryServiceStatus(hService,&serviceStatus)) {

        status = MapError(GetLastError());
        SCC_LOG(ERROR,"NetServiceInstall:QueryServiceStatus failed "
                FORMAT_API_STATUS "\n",status);
        goto CleanExit;
    }

    //
    // Translate the status from the old - ancient variety to the new
    // and improved NT variety.
    //
    *bufptr = MIDL_user_allocate(
                    sizeof(SERVICE_INFO_2) + STRSIZE(service));

    if (*bufptr == NULL) {
        SCC_LOG(ERROR,"NetServiceInstall:Allocation Failure\n",0);
        status = ERROR_NOT_ENOUGH_MEMORY;
        goto CleanExit;
    }

    stringPtr = (LPTSTR)((*bufptr) + sizeof(SERVICE_INFO_2));

    status = TranslateStatus(
                *bufptr,
                &serviceStatus,
                service,
                LEVEL_2,
                NULL,           // DisplayName
                stringPtr);     // dest for name string

CleanExit:

    if(hServiceController != NULL) {
        (VOID) CloseServiceHandle(hServiceController);
    }
    if(hService != NULL) {
        (VOID) CloseServiceHandle(hService);
    }
    return(status);
}

DBGSTATIC DWORD
TranslateStatus(
    OUT LPBYTE              BufPtr,
    IN  LPSERVICE_STATUS    ServiceStatus,
    IN  LPTSTR              ServiceName,
    IN  DWORD               Level,
    IN  LPTSTR              DisplayName,
    OUT LPTSTR              DestString
    )
/*++

Routine Description:

    This function translates the new-style ServiceStatus structure into
    the old-style service info structures.  The Info level of the output
    structure is stated on entry.  Since we cannot obtain PID values from
    the new Service Controller, zero is always returned.  Since
    the new Service Controller will never return text as part of the status,
    The text field is always set to NULL.

    NOTE:
        Since it is possible for this function to get called with
        ServiceName and BufPtr pointing to the same location, we must
        be careful to not write to the BufPtr location until we have
        finished reading all the information from the ServiceStatus
        structure.

Arguments:

    BufPtr - This is a pointer to a buffer that has already been allocated
        for the returned information.  The buffer must be of a size that
        matches the info level.

    ServiceStatus - This is a pointer to the new-style ServiceStatus
        structure.

    ServiceName - This is a pointer to the service name.

    Level - This indicates the desired info level to be output.

    DisplayName - If non-NULL, this points to a string that is to be
        the internationalized display name for the service.

    DestString - This is the buffer where the ServiceName is to be copied.
        All info levels require a ServiceName.


Return Value:


Note:


--*/
{
    LPSERVICE_INFO_0    serviceInfo0;
    LPSERVICE_INFO_1    serviceInfo1;
    LPSERVICE_INFO_2    serviceInfo2;
    DWORD               currentState;
    DWORD               exitCode;
    DWORD               checkPoint;
    DWORD               waitHint;
    DWORD               controlsAccepted;
    DWORD               specificError;

    NetpAssert( BufPtr != NULL );
    NetpAssert( ServiceName != NULL );
    NetpAssert( (*ServiceName) != TCHAR_EOS );

    //
    // Read all the important information into a temporary holding place.
    //
    exitCode        = ServiceStatus->dwWin32ExitCode;
    checkPoint      = ServiceStatus->dwCheckPoint;
    currentState    = ServiceStatus->dwCurrentState;
    waitHint        = ServiceStatus->dwWaitHint;
    controlsAccepted= ServiceStatus->dwControlsAccepted;
    specificError   = ServiceStatus->dwServiceSpecificExitCode;

    //
    // Sometimes, (in the case of enum)  the name string is already in
    // the correct location.  In that case we skip the copy, and just
    // put the pointer in the correct place.
    //
    if (DestString != ServiceName) {
        (VOID) STRCPY(DestString, ServiceName);
    }

    switch(Level) {
    case LEVEL_0:
        serviceInfo0 = (LPSERVICE_INFO_0)BufPtr;
        serviceInfo0->svci0_name = DestString;
        break;

    case LEVEL_1:
        serviceInfo1 = (LPSERVICE_INFO_1)BufPtr;
        serviceInfo1->svci1_name = DestString;
        serviceInfo1->svci1_status= MakeStatus(currentState,controlsAccepted);
        serviceInfo1->svci1_code  = MakeCode(exitCode,checkPoint,waitHint);
        serviceInfo1->svci1_pid   = 0L;
        break;

    case LEVEL_2:
        serviceInfo2 = (LPSERVICE_INFO_2)BufPtr;
        serviceInfo2->svci2_name = DestString;
        serviceInfo2->svci2_status= MakeStatus(currentState,controlsAccepted);
        serviceInfo2->svci2_code  = MakeCode(exitCode,checkPoint,waitHint);
        serviceInfo2->svci2_pid   = 0L;
        serviceInfo2->svci2_text  = NULL;
        serviceInfo2->svci2_specific_error = specificError;
        //
        // If DisplayName is present, use it.  Otherwise, use the
        // ServiceName for the DisplayName.
        //
        if (DisplayName != NULL) {
            serviceInfo2->svci2_display_name = DisplayName;
        }
        else {
            serviceInfo2->svci2_display_name = DestString;
        }
        break;

    default:
        return(ERROR_INVALID_LEVEL);
    }

    NetpAssert( (*DestString) != TCHAR_EOS );
    return(NERR_Success);

} // TranslateStatus


DBGSTATIC DWORD
MakeStatus (
    IN  DWORD   CurrentState,
    IN  DWORD   ControlsAccepted
    )

/*++

Routine Description:

    Makes an old-style (lanman) status word out of the service's
    currentState and ControlsAccepted information.

Arguments:



Return Value:



--*/
{
    DWORD               state = 0;

    //
    // Determine the correct "old-style" service status to return.
    //
    switch(CurrentState) {
    case SERVICE_STOPPED:
        state = SERVICE_UNINSTALLED;
        break;
    case SERVICE_START_PENDING:
        state = SERVICE_INSTALL_PENDING;
        break;
    case SERVICE_STOP_PENDING:
        state = SERVICE_UNINSTALL_PENDING;
        break;
    case SERVICE_RUNNING:
        state = SERVICE_INSTALLED;
        break;
    case SERVICE_CONTINUE_PENDING:
        state = LM20_SERVICE_CONTINUE_PENDING | SERVICE_INSTALLED;
        break;
    case SERVICE_PAUSE_PENDING:
        state = LM20_SERVICE_PAUSE_PENDING | SERVICE_INSTALLED;
        break;
    case SERVICE_PAUSED:
        state = LM20_SERVICE_PAUSED | SERVICE_INSTALLED;
        break;
    default:

        break;
    }

    //
    // Modify that service status to include information about the
    // type of controls accepted.
    //

    if (ControlsAccepted & SERVICE_ACCEPT_STOP) {
        state |= SERVICE_UNINSTALLABLE;
    }

    if (ControlsAccepted & SERVICE_ACCEPT_PAUSE_CONTINUE) {
        state |= SERVICE_PAUSABLE;
    }

    return(state);
}

DBGSTATIC DWORD
MakeCode(
    IN  DWORD   ExitCode,
    IN  DWORD   CheckPoint,
    IN  DWORD   WaitHint
    )
{
    DWORD   exitState=0;
    DWORD   time=0;

    if ((WaitHint !=0 ) || (CheckPoint != 0)) {

        if (WaitHint != 0) {

            //
            // Convert the time in milliseconds to time in 10ths of seconds
            //
            time = WaitHint;
            if (time > 100) {
                time = time / 100;
            }
            else {
                time = 0;
            }
        }
        //
        // Limit the wait hint to the SERVICE_NT_MAXTIME.
        // ( currently 6553.5 seconds (1.82 hours) or 0x0000FFFF ).
        //
        if (time > SERVICE_NT_MAXTIME) {
            time = SERVICE_NT_MAXTIME;
        }
        exitState = SERVICE_NT_CCP_CODE(time,CheckPoint);
    }
    else {

        //
        // Otherwise, the exitState should be whatever is in the
        // ExitCode field.
        //
        exitState = 0;

        if (ExitCode != NO_ERROR) {
            exitState = SERVICE_UIC_CODE(SERVICE_UIC_SYSTEM, ExitCode);
        }
    }
    return(exitState);
}


DBGSTATIC NET_API_STATUS
MapError(
    IN DWORD WinSvcError
    )
{

    switch(WinSvcError) {

        case ERROR_INVALID_SERVICE_CONTROL:
            return NERR_ServiceCtlNotValid;

        case ERROR_SERVICE_REQUEST_TIMEOUT:
            return NERR_ServiceCtlTimeout;

        case ERROR_SERVICE_NO_THREAD:
            return NERR_ServiceNotStarting;

        case ERROR_SERVICE_DATABASE_LOCKED:
            return NERR_ServiceTableLocked;

        case ERROR_SERVICE_ALREADY_RUNNING:
            return NERR_ServiceInstalled;

        case ERROR_SERVICE_CANNOT_ACCEPT_CTRL:
            return NERR_ServiceNotCtrl;

        case ERROR_SERVICE_DOES_NOT_EXIST:
            return NERR_BadServiceName;

        case ERROR_SERVICE_NOT_ACTIVE:
            return NERR_ServiceNotInstalled;

        default:
            SCC_LOG( TRACE, "MapError: unmapped error code (dec) "
                    FORMAT_API_STATUS ".\n", WinSvcError );
            SCC_LOG( TRACE, "MapError: unmapped error code (hex) "
                    FORMAT_HEX_DWORD ".\n", (DWORD) WinSvcError );

            return WinSvcError;               // not mapped
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\alrsvc\almain.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    almain.c

Abstract:

    This is the main routine for the NT LAN Manager Alerter service

Author:

    Rita Wong (ritaw)  01-July-1991

Environment:

    User Mode - Win32

Revision History:

--*/

#include "almain.h"               // Main module definitions

#include <svcs.h>                 // SVCS_ENTRY_POINT
#include <secobj.h>               // ACE_DATA

//-------------------------------------------------------------------//
//                                                                   //
// Global variables                                                  //
//                                                                   //
//-------------------------------------------------------------------//

AL_GLOBAL_DATA        AlGlobalData;
PSVCHOST_GLOBAL_DATA  AlLmsvcsGlobalData;

STATIC BOOL AlDone = FALSE;

//
// Debug trace flag for selecting which trace statements to output
//
#if DBG

DWORD AlerterTrace = 0;

#endif


//-------------------------------------------------------------------//
//                                                                   //
// Function prototypes                                               //
//                                                                   //
//-------------------------------------------------------------------//

STATIC
NET_API_STATUS
AlInitializeAlerter(
    VOID
    );

STATIC
VOID
AlProcessAlertNotification(
    VOID
    );

STATIC
VOID
AlShutdownAlerter(
    IN NET_API_STATUS ErrorCode
    );

STATIC
NET_API_STATUS
AlUpdateStatus(
    VOID
    );

VOID
AlerterControlHandler(
    IN DWORD Opcode
    );


VOID
SvchostPushServiceGlobals(
    PSVCHOST_GLOBAL_DATA  pGlobals
    )
{
    AlLmsvcsGlobalData = pGlobals;
}


VOID
ServiceMain(
    DWORD NumArgs,
    LPTSTR *ArgsArray
    )

/*++

Routine Description:

    This is the main routine of the Alerter Service which registers
    itself as an RPC server and notifies the Service Controller of the
    Alerter service control entry point.

Arguments:

    NumArgs - Supplies the number of strings specified in ArgsArray.

    ArgsArray -  Supplies string arguments that are specified in the
        StartService API call.  This parameter is ignored by the
        Alerter service.

Return Value:

    None.

--*/
{
    DWORD AlInitState = 0;


    UNREFERENCED_PARAMETER(NumArgs);
    UNREFERENCED_PARAMETER(ArgsArray);

    //
    // Make sure svchost.exe gave us the global data.
    //
    ASSERT(AlLmsvcsGlobalData != NULL);

    IF_DEBUG(MAIN) {
        NetpKdPrint(("In the alerter service!!\n"));
    }

    AlDone = FALSE;

    if (AlInitializeAlerter() != NERR_Success) {
        return;
    }

    AlProcessAlertNotification();

    return;
}


STATIC
NET_API_STATUS
AlInitializeAlerter(
    VOID
    )
/*++

Routine Description:

    This routine initializes the Alerter service.

Arguments:

    AlInitState - Returns a flag to indicate how far we got with initializing
        the Alerter service before an error occured.

Return Value:

    NET_API_STATUS - NERR_Success or reason for failure.

--*/
{
    NET_API_STATUS status;
    NTSTATUS ntstatus;
    PSECURITY_DESCRIPTOR Sd;
    SECURITY_ATTRIBUTES Sa;
    ACE_DATA AceData[1] = {
        {ACCESS_ALLOWED_ACE_TYPE, 0, 0,
               GENERIC_READ | GENERIC_WRITE, &AlLmsvcsGlobalData->WorldSid}
        };



    AlGlobalData.MailslotHandle = INVALID_HANDLE_VALUE;

    //
    // Initialize Alerter to receive service requests by registering the
    // control handler.
    //
    if ((AlGlobalData.StatusHandle = RegisterServiceCtrlHandler(
                                         SERVICE_ALERTER,
                                         AlerterControlHandler
                                         )) == 0) {

        status = GetLastError();
        AlHandleError(AlErrorRegisterControlHandler, status, NULL);
        return status;
    }

    //
    // Initialize all the status fields so that subsequent calls to
    // SetServiceStatus need to only update fields that changed.
    //
    AlGlobalData.Status.dwServiceType      = SERVICE_WIN32;
    AlGlobalData.Status.dwCurrentState     = SERVICE_START_PENDING;
    AlGlobalData.Status.dwControlsAccepted = 0;
    AlGlobalData.Status.dwCheckPoint       = 1;
    AlGlobalData.Status.dwWaitHint         = 10000;  // 10 secs

    SET_SERVICE_EXITCODE(
        NO_ERROR,
        AlGlobalData.Status.dwWin32ExitCode,
        AlGlobalData.Status.dwServiceSpecificExitCode
        );

    //
    // Tell the Service Controller that we are start-pending
    //
    if ((status = AlUpdateStatus()) != NERR_Success) {

        AlHandleError(AlErrorNotifyServiceController, status, NULL);
        return status;
    }

    //
    // Get the configured alert names
    //
    if ((status = AlGetAlerterConfiguration()) != NERR_Success) {

        AlHandleError(AlErrorGetComputerName, status, NULL);
        return status;
    }

    //
    // Create the security descriptor for the security attributes structure
    //
    ntstatus = NetpCreateSecurityDescriptor(
                   AceData,
                   1,
                   AlLmsvcsGlobalData->LocalServiceSid,
                   AlLmsvcsGlobalData->LocalServiceSid,
                   &Sd
                   );

    if (! NT_SUCCESS(ntstatus)) {
        status = NetpNtStatusToApiStatus(ntstatus);
        AlHandleError(AlErrorCreateMailslot, status, NULL);
        return status;
    }

    Sa.nLength = sizeof(SECURITY_ATTRIBUTES);
    Sa.lpSecurityDescriptor = Sd;
    Sa.bInheritHandle = FALSE;

    //
    // Create mailslot to listen on alert notifications from the Server
    // service and the Spooler.
    //
    AlGlobalData.MailslotHandle = CreateMailslot(
                                      ALERTER_MAILSLOT,
                                      MAX_MAILSLOT_MESSAGE_SIZE,
                                      MAILSLOT_WAIT_FOREVER,
                                      &Sa
                                      );

    NetpMemoryFree(Sd);

    if (AlGlobalData.MailslotHandle == INVALID_HANDLE_VALUE) {
        status = GetLastError();
        AlHandleError(AlErrorCreateMailslot, status, NULL);
        return status;
    }
    else {
        IF_DEBUG(MAIN) {
            NetpKdPrint(("Mailslot %ws created, handle=x%08lx\n",
                         ALERTER_MAILSLOT, AlGlobalData.MailslotHandle));
        }
    }

    //
    // Tell the Service Controller that we are started.
    //
    AlGlobalData.Status.dwCurrentState     = SERVICE_RUNNING;
    AlGlobalData.Status.dwControlsAccepted = SERVICE_ACCEPT_STOP;
    AlGlobalData.Status.dwCheckPoint       = 0;
    AlGlobalData.Status.dwWaitHint         = 0;

    if ((status = AlUpdateStatus()) != NERR_Success) {

        AlHandleError(AlErrorNotifyServiceController, status, NULL);
        return status;
    }

    IF_DEBUG(MAIN) {
        NetpKdPrint(("[Alerter] Successful Initialization\n"));
    }

    return NERR_Success;
}


STATIC
VOID
AlProcessAlertNotification(
    VOID
    )
/*++

Routine Description:

    This routine processes incoming mailslot alert notifications, which is
    the core function of the Alerter service.

Arguments:

    AlUicCode - Supplies the termination code to the Service Controller.

Return Value:

    None.

--*/
{
    NET_API_STATUS status = NERR_Success;
    TCHAR AlertMailslotBuffer[MAX_MAILSLOT_MESSAGE_SIZE];
    DWORD NumberOfBytesRead;

    PSTD_ALERT Alert;


    //
    // Loop reading the Alerter mailslot; it will terminate when the mailslot
    // is destroyed by closing the one and only handle to it.
    //
    do {

        //
        // Zero out the buffer before getting a new alert notification
        //
        RtlZeroMemory(AlertMailslotBuffer, MAX_MAILSLOT_MESSAGE_SIZE *
                      sizeof(TCHAR));

        if (ReadFile(
                AlGlobalData.MailslotHandle,
                (LPVOID) AlertMailslotBuffer,
                MAX_MAILSLOT_MESSAGE_SIZE * sizeof(TCHAR),
                &NumberOfBytesRead,
                NULL
                ) == FALSE) {

            //
            // Failed in reading mailslot
            //
            status = GetLastError();

            if  (status == ERROR_HANDLE_EOF) {
                while (! AlDone) {
                    Sleep(2000);
                }
                return;
            }

            NetpKdPrint(("[Alerter] Error reading from mailslot %lu\n", status));
        }
        else {

            //
            // Successfully received a mailslot alert notification
            //

            IF_DEBUG(MAIN) {
                NetpKdPrint(("[Alerter] Successfully read %lu bytes from mailslot\n",
                             NumberOfBytesRead));
            }

            try {

                //
                // Handle alert notification for admin, print, and user alerts.
                //
                Alert = (PSTD_ALERT) AlertMailslotBuffer;

                //
                // Make sure structure fields are properly terminated
                //
                Alert->alrt_eventname[EVLEN] = L'\0';
                Alert->alrt_servicename[SNLEN] = L'\0';

                if (! I_NetNameCompare(
                          NULL,
                          Alert->alrt_eventname,
                          ALERT_ADMIN_EVENT,
                          NAMETYPE_EVENT,
                          0
                          )) {

                    AlAdminFormatAndSend(Alert);
                }
                else if (! I_NetNameCompare(
                               NULL,
                               Alert->alrt_eventname,
                               ALERT_PRINT_EVENT,
                               NAMETYPE_EVENT,
                               0
                               )) {

                    AlPrintFormatAndSend(Alert);
                }
                else if (! I_NetNameCompare(
                               NULL,
                               Alert->alrt_eventname,
                               ALERT_USER_EVENT,
                               NAMETYPE_EVENT,
                               0L
                               )) {

                    AlUserFormatAndSend(Alert);
                }

            }
            except (EXCEPTION_EXECUTE_HANDLER) {
                NetpKdPrint(("[Alerter] Exception occurred processing alerts\n"));
            }
        }

    }  while (TRUE);

}


STATIC
VOID
AlShutdownAlerter(
    IN NET_API_STATUS ErrorCode
    )
/*++

Routine Description:

    This routine shuts down the Alerter service.

Arguments:

    ErrorCode - Supplies the error for terminating the Alerter service.

Return Value:

    None.

--*/
{
    //
    // Free memory allocated to hold the computer name
    //
    if (AlLocalComputerNameA != NULL) {
        (void) NetApiBufferFree(AlLocalComputerNameA);
        AlLocalComputerNameA = NULL;
    }
    if (AlLocalComputerNameW != NULL) {
        (void) NetApiBufferFree(AlLocalComputerNameW);
        AlLocalComputerNameW = NULL;
    }

    //
    // Free memory allocated for alert names
    //
    if (AlertNamesA != NULL) {
        (void) LocalFree(AlertNamesA);
        AlertNamesA = NULL;
    }
    if (AlertNamesW != NULL) {
        (void) NetApiBufferFree(AlertNamesW);
        AlertNamesW = NULL;
    }

    //
    // Destroy Alerter mailslot if created.
    //
    if (AlGlobalData.MailslotHandle != INVALID_HANDLE_VALUE) {

        if (! CloseHandle(AlGlobalData.MailslotHandle)) {
            NetpKdPrint(("[Alerter]] Could not remove mailslot %lu\n",
                         GetLastError()));
        }

        AlGlobalData.MailslotHandle = INVALID_HANDLE_VALUE;
    }

    //
    // We are done with cleaning up.  Tell Service Controller that we are
    // stopped.
    //
    AlGlobalData.Status.dwCurrentState = SERVICE_STOPPED;
    AlGlobalData.Status.dwCheckPoint   = 0;
    AlGlobalData.Status.dwWaitHint     = 0;

    SET_SERVICE_EXITCODE(
        ErrorCode,
        AlGlobalData.Status.dwWin32ExitCode,
        AlGlobalData.Status.dwServiceSpecificExitCode
        );

    (void) AlUpdateStatus();

    AlDone = TRUE;
}


VOID
AlHandleError(
    IN AL_ERROR_CONDITION FailingCondition,
    IN NET_API_STATUS Status,
    IN LPTSTR MessageAlias OPTIONAL
    )
/*++

Routine Description:

    This routine handles a Alerter service error condition.  I*f the error
    condition is fatal, then it shuts down the Alerter service.

Arguments:

    FailingCondition - Supplies a value which indicates what the failure is.

    Status - Supplies the status code for the failure.

    MessageAlias - Supplies the message alias name which the alert message
        failed in sending.  This only applies to the message send error.

Return Value:

    None.

--*/
{
    LPWSTR SubString[3];
    TCHAR StatusString[STRINGS_MAXIMUM + 1];
    DWORD NumberOfStrings;

    switch (FailingCondition) {

        case AlErrorRegisterControlHandler:

            NetpKdPrint(("[Alerter] Cannot register control handler "
                        FORMAT_API_STATUS "\n", Status));

            SubString[0] = ultow(Status, StatusString, 10);
            AlLogEvent(
                NELOG_FailedToRegisterSC,
                1,
                SubString
                );

            AlShutdownAlerter(Status);
            break;

        case AlErrorCreateMailslot:

            NetpKdPrint(("[Alerter] Cannot create mailslot " FORMAT_API_STATUS "\n",
                         Status));
            SubString[0] = ultow(Status, StatusString, 10);
            AlLogEvent(
                NELOG_Mail_Slt_Err,
                1,
                SubString
                );

            AlShutdownAlerter(Status);
            break;

        case AlErrorNotifyServiceController:

            NetpKdPrint(("[Alerter] SetServiceStatus error %lu\n", Status));

            SubString[0] = ultow(Status, StatusString, 10);
            AlLogEvent(
                NELOG_FailedToSetServiceStatus,
                1,
                SubString
                );

            AlShutdownAlerter(Status);
            break;

        case AlErrorGetComputerName:

            NetpKdPrint(("[Alerter] Error in getting computer name %lu.\n", Status));

            SubString[0] = ultow(Status, StatusString, 10);
            AlLogEvent(
                NELOG_FailedToGetComputerName,
                1,
                SubString
                );

            AlShutdownAlerter(Status);
            break;

        case AlErrorSendMessage :

            AlFormatErrorMessage(
                Status,
                MessageAlias,
                StatusString,
                (STRINGS_MAXIMUM + 1) * sizeof(TCHAR)
                );

            SubString[0] = StatusString;
            SubString[1] = StatusString + STRLEN(StatusString) + 1;
            SubString[2] = SubString[1] + STRLEN(SubString[1]) + 1;

            AlLogEvent(
                NELOG_Message_Send,
                3,
                SubString
                );

            break;

        default:
            NetpKdPrint(("[Alerter] AlHandleError: unknown error condition %lu\n",
                         FailingCondition));

            NetpAssert(FALSE);
    }

}


STATIC
NET_API_STATUS
AlUpdateStatus(
    VOID
    )
/*++

Routine Description:

    This routine updates the Alerter service status with the Service
    Controller.

Arguments:

    None.

Return Value:

    NET_API_STATUS - NERR_Success or reason for failure.

--*/
{
    NET_API_STATUS status = NERR_Success;


    if (AlGlobalData.StatusHandle == 0) {
        NetpKdPrint((
            "[Alerter] Cannot call SetServiceStatus, no status handle.\n"
            ));

        return ERROR_INVALID_HANDLE;
    }

    if (! SetServiceStatus(AlGlobalData.StatusHandle, &AlGlobalData.Status)) {

        status = GetLastError();

        IF_DEBUG(MAIN) {
            NetpKdPrint(("[Alerter] SetServiceStatus error %lu\n", status));
        }
    }

    return status;
}



VOID
AlerterControlHandler(
    IN DWORD Opcode
    )
/*++

Routine Description:

    This is the service control handler of the Alerter service.

Arguments:

    Opcode - Supplies a value which specifies the action for the Alerter
        service to perform.

Return Value:

    None.

--*/
{
    IF_DEBUG(MAIN) {
        NetpKdPrint(("[Alerter] In Control Handler\n"));
    }

    switch (Opcode) {

        case SERVICE_CONTROL_STOP:

            if (AlGlobalData.Status.dwCurrentState != SERVICE_STOP_PENDING) {

                IF_DEBUG(MAIN) {
                    NetpKdPrint(("[Alerter] Stopping alerter...\n"));
                }

                AlShutdownAlerter(NERR_Success);

            }

            return;

        case SERVICE_CONTROL_INTERROGATE:
            break;

        default:
            IF_DEBUG(MAIN) {
                NetpKdPrint(("Unknown alerter opcode " FORMAT_HEX_DWORD
                             "\n", Opcode));
            }
    }

    //
    // Send the status response.
    //
    (void) AlUpdateStatus();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\alrsvc\alformat.c ===
/*++

Copyright (c) 1987-1991  Microsoft Corporation

Module Name:

    alformat.c

Abstract:

    This module contains routines to format alert messages sent out by the
    Alerter service.

Author:

    Ported from LAN Man 2.0

Environment:

    User mode only.
    Contains NT-specific code.
    Requires ANSI C extensions: slash-slash comments, long external names.

Revision History:

    08-July-1991 (ritaw)
        Ported to NT.  Converted to NT style.

--*/

#include "alformat.h"             // Constant definitions
#include <windows.h>              // GetDateFormat/GetTimeFormat

//-------------------------------------------------------------------//
//                                                                   //
// Global variables                                                  //
//                                                                   //
//-------------------------------------------------------------------//

CHAR MessageBuffer[MAX_ALERTER_MESSAGE_SIZE];

//-------------------------------------------------------------------//
//                                                                   //
// Local function prototypes                                         //
//                                                                   //
//-------------------------------------------------------------------//

STATIC
NET_API_STATUS
AlMakeMessageHeader(
    IN  LPTSTR From,
    IN  LPTSTR To,
    IN  DWORD MessageSubjectId,
    IN  DWORD AlertNotificationTime,
    IN  BOOL IsAdminAlert
    );

STATIC
NET_API_STATUS
AlAppendMessage(
    IN  DWORD MessageId,
    OUT LPSTR MessageBuffer,
    IN  LPSTR *SubstituteStrings,
    IN  DWORD NumberOfSubstituteStrings
    );

STATIC
NET_API_STATUS
AlMakeMessageBody(
    IN  DWORD MessageId,
    IN  LPTSTR MergeStrings,
    IN  DWORD NumberOfMergeStrings
    );

STATIC
VOID
AlMakePrintMessage(
    IN  DWORD PrintMessageID,
    IN  LPTSTR DocumentName,
    IN  LPTSTR PrinterName,
    IN  LPTSTR ServerName,
    IN  LPTSTR StatusString
    );

STATIC
NET_API_STATUS
AlSendMessage(
   IN  LPTSTR MessageAlias
   );

VOID
AlMakeTimeString(
    DWORD   * Time,
    PCHAR   String,
    int     StringLength
    );

STATIC
BOOL
IsDuplicateReceiver(
    LPTSTR Name
    );


STATIC
NET_API_STATUS
AlMakeMessageHeader(
    IN  LPTSTR From,
    IN  LPTSTR To,
    IN  DWORD MessageSubjectId,
    IN  DWORD AlertNotificationTime,
    IN  BOOL IsAdminAlert
    )
/*++

Routine Description:

    This function creates the header of an alert message, and puts it in the
    MessageBuffer.  A message header takes the following form:

        From: SPOOLER at \\PRT41130
        To:   DAISY
        Subj: ** PRINTING NOTIFICATION **
        Date: 06-23-91 01:16am

Arguments:

    From - Supplies the component that raised the alert.

    To - Supplies the message alias name of the recipient.

    MessageSubjectId - Supplies an id which indicates the subject of the
        alert.

    AlertNotificationTime - Supplies the time of the alert notification.

    IsAdminAlert - Supplies a flag which if TRUE indicates that the To line
        should be created for multiple recipients.

Return Value:

    ERROR_NOT_ENOUGH_MEMORY - if Unicode to ANSI conversion buffer cannot
        be allocated.

    NERR_Success - if successful.

--*/
{
    //
    // Array of subtitution strings for an alert message
    //
    LPSTR SubstituteStrings[2];

    //
    // Tab read in from the message file
    //
    static CHAR TabMessage[80] = "";

    LPSTR AnsiTo;
    DWORD ToLineLength;                // Number of chars on the To line
    WORD MessageLength;                // Returned by DosGetMessage

    LPSTR AnsiAlertNames;

    LPSTR FormatPointer1;
    LPSTR FormatPointer2;
    CHAR  SaveChar;

    CHAR  szAlertTime[MAX_DATE_TIME_LEN];

    LPSTR PlaceHolder = "X";
    LPSTR PointerToPlaceHolder = NULL;


    //
    // Read in the message tab, if necessary
    //
    if (*TabMessage == AL_NULL_CHAR) {

        if (DosGetMessage(
                NULL,                     // String substitution table
                0,                        // Number of entries in table above
                (LPBYTE) TabMessage,      // Buffer receiving message
                sizeof(TabMessage),       // Size of buffer receiving message
                APE2_ALERTER_TAB,         // Message number to retrieve
                MESSAGE_FILENAME,         // Name of message file
                &MessageLength            // Number of bytes returned
                )) {

            *TabMessage = AL_NULL_CHAR;
        }

    }

    //
    // Creating a new alert message
    //
    MessageBuffer[0] = AL_NULL_CHAR;

    //
    // "From: <From> at \\<AlLocalComputerName>"
    //
    // Alerts received by the Alerter service all come from the local server.
    //
    SubstituteStrings[0] = NetpAllocStrFromWStr(From);

    if (SubstituteStrings[0] == NULL) {
        return ERROR_NOT_ENOUGH_MEMORY;
    }


    if (AlLocalComputerNameA != NULL) {
        SubstituteStrings[1] = AlLocalComputerNameA;
    }
    else {
        NetApiBufferFree(SubstituteStrings[0]);
        return ERROR_GEN_FAILURE;
    }

    //
    // Put the from line into the message buffer
    //
    AlAppendMessage(
        APE2_ALERTER_FROM,
        MessageBuffer,
        SubstituteStrings,
        2                      // Number of strings to substitute into message
        );

    NetApiBufferFree(SubstituteStrings[0]);

    //
    // "To: X"
    //
    // The 'X' is a place holder for the To message so that DosGetMessage
    // can perform the substitution.  We are not putting the real string
    // because the message can either be sent to one recipient (non-admin
    // alerts or to many recipient (admin alert).
    //
    SubstituteStrings[0] = PlaceHolder;

    AlAppendMessage(
        APE2_ALERTER_TO,
        MessageBuffer,
        SubstituteStrings,
        1                      // Number of strings to substitute into message
        );

    //
    // Search for the place holder character and replace with zero terminator
    //
    PointerToPlaceHolder = strrchr(MessageBuffer, *PlaceHolder);

    //
    // If PointerToPlaceHolder == NULL, we have a big problem, but rather than
    // choke, we'll just continue.  The resulting message will be
    // mis-formated (the place holder will still be there and the To name(s)
    // will be on the next line) but it will still be sent.
    //

    if (PointerToPlaceHolder != NULL) {
        *PointerToPlaceHolder = AL_NULL_CHAR;
    }

    if (To != NULL) {
        AnsiTo = NetpAllocStrFromWStr(To);
        if (AnsiTo == NULL) {
            return ERROR_NOT_ENOUGH_MEMORY;
        }
    }
    else {
        AnsiTo = NULL;
    }

    if (IsAdminAlert) {

        //
        // Do not send the message to the same person twice, since it is
        // possible that the person is on the alert names list, as well as
        // specified by To.
        //

        if (To != NULL && ! IsDuplicateReceiver(To)) {

            //
            // Print admin alerts, like printer is offline or out of paper,
            // will be sent to the person who's printing as well as admins
            // on the alertnames list.
            //

            strcat(MessageBuffer, AnsiTo);
            strcat(MessageBuffer, " ");
            ToLineLength = strlen(TabMessage) + strlen(AnsiTo) + sizeof(CHAR);

        }
        else {

            //
            // All admin alerts will have a NULL To field, except print admin
            // alerts, e.g. ran out of paper while printing.
            //

            ToLineLength = strlen(TabMessage);
        }

        if (AlertNamesA != NULL) {

            //
            // AlertNamesA is space-separated.
            //

            AnsiAlertNames = AlertNamesA;

            //
            // Wrap the names to the next line if width of all alert names exceeds
            // screen display width.
            //
            while ((strlen(AnsiAlertNames) + ToLineLength) > MESSAGE_WIDTH) {

                FormatPointer1 = AnsiAlertNames + 1 +
                                 (MESSAGE_WIDTH - ToLineLength);
                SaveChar = *FormatPointer1;
                *FormatPointer1 = AL_NULL_CHAR;
                FormatPointer2 = strrchr(AnsiAlertNames, AL_SPACE_CHAR);
                *FormatPointer2 = AL_NULL_CHAR;
                strcat(MessageBuffer, AnsiAlertNames);
                *FormatPointer2++ = AL_SPACE_CHAR;
                *FormatPointer1 = SaveChar;
                strcat(MessageBuffer, AL_EOL_STRING);
                strcat(MessageBuffer, TabMessage);
                AnsiAlertNames = FormatPointer2;
                ToLineLength = strlen(TabMessage);
            }

            strcat(MessageBuffer, AnsiAlertNames);
        }
    }
    else {

        //
        // Non-admin alert
        //

        if (To != NULL) {
            strcat(MessageBuffer, AnsiTo);
        }
    }

    if (AnsiTo != NULL) {
        NetApiBufferFree(AnsiTo);
    }

    strcat(MessageBuffer, AL_EOL_STRING);

    //
    // Append subject line to MessageBuffer
    //
    // "Subj:  <Message string of MessageSubjectId>"
    //
    AlAppendMessage(
        MessageSubjectId,
        MessageBuffer,
        SubstituteStrings,
        0                         // No substitution strings
        );

    AlMakeTimeString(
        &AlertNotificationTime,
        szAlertTime,
        sizeof(szAlertTime)
        );

    SubstituteStrings[0] = szAlertTime;

    //
    // "Date:  <mm/dd/yy hh:mm>"
    //
    AlAppendMessage(
        APE2_ALERTER_DATE,
        MessageBuffer,
        SubstituteStrings,
        1
        );

    strcat(MessageBuffer, AL_EOL_STRING);

    return NERR_Success;
}


VOID
AlAdminFormatAndSend(
    IN  PSTD_ALERT Alert
    )
/*++

Routine Description:

    This function takes an admin alert notification, formats it into an alert
    message, and sends it to the admins with message aliases that are listed
    on the alert names entry in the configuration.

    An admin alert notification (arrived via the mailslot) has the following
    form:

        Timestamp of the alert event
        "ADMIN"
        "SERVER"

        Message id of message
        Number of merge strings which will be substituted into message
        Merge strings, each separated by a zero terminator.

Arguments:

    Alert - Supplies a pointer to the alert notification structure.

Return Value:

    None.

--*/
{
    NET_API_STATUS status;

    LPTSTR AdminToAlert;
    PADMIN_OTHER_INFO AdminInfo = (PADMIN_OTHER_INFO) ALERT_OTHER_INFO(Alert);


    AdminToAlert = AlertNamesW;


    IF_DEBUG(FORMAT) {
        NetpKdPrint(("[Alerter] Got admin alert\n"));
    }

    while (AdminToAlert != NULL && *AdminToAlert != TCHAR_EOS) {


        //
        // Format the message for this alert name
        //
        status = AlMakeMessageHeader(
                         Alert->alrt_servicename,
                         NULL,                    // The To field is always NULL
                         APE2_ALERTER_ADMN_SUBJ,
                         Alert->alrt_timestamp,
                         TRUE                     // Admin alert
                         );

        if (status != NERR_Success) {
            NetpKdPrint((
                "[Alerter] Alert not sent.  Error making message header %lu\n",
                status
                ));
            return;
        }

        AlMakeMessageBody(
                AdminInfo->alrtad_errcode,
                (LPTSTR) ALERT_VAR_DATA(AdminInfo),
                AdminInfo->alrtad_numstrings
                );


       //
        // Send the message
        //
        (void) AlSendMessage(AdminToAlert);

        AdminToAlert += (STRLEN(AdminToAlert) + 1);
    }
}




STATIC
NET_API_STATUS
AlMakeMessageBody(
    IN  DWORD MessageId,
    IN  LPTSTR MergeStrings,
    IN  DWORD NumberOfMergeStrings
    )
/*++

Routine Description:

    This function creates the body of an alert message and append it to the
    header already in MessageBuffer.

Arguments:

    MessageId - Supplies a message id of the core message to be sent.

    MergeStrings - Supplies a pointer to strings that would make up the message
        to be sent.  The strings are separated by zero terminators.

    NumberOfMergeStrings - Supplies the number of strings pointed to by
        MergeStrings.

Return Value:

    NET_API_STATUS - NERR_Success or reason for failure.

--*/

{

    NET_API_STATUS status = NERR_Success;
    DWORD i;

    LPSTR AdminMessage;
    LPSTR MergeTable[9];
    CHAR String[34];
    LPSTR SubstituteStrings[2];

    LPSTR CRPointer;
    LPSTR EndPointer;


    //
    // Message utility can only handle substitution of up to 9 strings.
    //
    if (NumberOfMergeStrings > 9) {
        return ERROR_INVALID_PARAMETER;
    }

    //
    // Allocate memory for the buffer which receives the message from the
    // message file.
    //
    if ((AdminMessage = (LPSTR) LocalAlloc(
                                    LMEM_ZEROINIT,
                                    MAX_ALERTER_MESSAGE_SIZE
                            )) == NULL) {
       return GetLastError();
    }

    if (MessageId == NO_MESSAGE) {

        //
        // Merge strings are the literal message (don't format).  Print one
        // per line.
        //
        for (i = 0; i < NumberOfMergeStrings; i++) {

            SubstituteStrings[0] = NetpAllocStrFromWStr(MergeStrings);
            if (SubstituteStrings[0] == NULL) {
                (void) LocalFree(AdminMessage);
                return ERROR_NOT_ENOUGH_MEMORY;
            }
            strcat(MessageBuffer, SubstituteStrings[0]);

            NetApiBufferFree(SubstituteStrings[0]);
            strcat(MessageBuffer, AL_EOL_STRING);
            MergeStrings = STRCHR(MergeStrings, TCHAR_EOS);
            MergeStrings++;
        }

    }
    else {

        //
        // Set up the MergeStrings table for the call to AlAppendMessage
        //
        for (i = 0; i < NumberOfMergeStrings; i++) {

            IF_DEBUG(FORMAT) {
                NetpKdPrint(("Merge string #%lu: " FORMAT_LPTSTR "\n", i, MergeStrings));
            }

            MergeTable[i] = NetpAllocStrFromWStr(MergeStrings);
            if (MergeTable[i] == NULL) {
                DWORD j;

                (void) LocalFree(AdminMessage);
                for (j = 0; j < i; j++) {
                    (void) LocalFree(MergeTable[j]);
                }
                return ERROR_NOT_ENOUGH_MEMORY;
            }
            MergeStrings = STRCHR(MergeStrings, TCHAR_EOS);
            MergeStrings++;
        }


        status = AlAppendMessage(
                   MessageId,
                   AdminMessage,
                   MergeTable,
                   NumberOfMergeStrings
                   );

        //
        // Free memory allocated for Unicode to ANSI conversion
        //
        for (i = 0; i < NumberOfMergeStrings; i++) {
            (void) LocalFree(MergeTable[i]);
        }

        if (status != NERR_Success) {

            //
            // Could not find message of MessageId in message file.  An error
            // message will be sent.
            //
            _itoa(MessageId, String, 10);
            SubstituteStrings[0] = String;
            AlAppendMessage(
                APE2_ALERTER_ERROR_MSG,
                MessageBuffer,
                SubstituteStrings,
                1
                );

            status = NERR_Success;

        }
        else {

            //
            // Got the message
            //

            //
            // Process the message from DosGetMessage to replace the CR and
            // LF with equivalent display characters.
            //
            CRPointer = strchr(AdminMessage, AL_CR_CHAR);
            EndPointer = CRPointer;

            while (CRPointer) {

                *CRPointer = '\040';
                CRPointer++;

                //
                // Check for end of message
                //
                if (*CRPointer != AL_NULL_CHAR) {

                    //
                    // Use display end-of-line character
                    //
                    *CRPointer = AL_EOL_CHAR;
                }

                EndPointer = CRPointer;
                CRPointer = strchr(CRPointer, AL_CR_CHAR);
            }

            //
            // Wipe out rest of garbage in the message
            //
            if (EndPointer) {
                *EndPointer = AL_EOL_CHAR;
                *(EndPointer + 1) = AL_NULL_CHAR;
            }

            strcat(MessageBuffer, AdminMessage);
        }
    }
    (void) LocalFree(AdminMessage);
    return status;
}



VOID
AlUserFormatAndSend(
    IN  PSTD_ALERT Alert
    )
/*++

Routine Description:

    This function takes a user alert notification, formats it into an alert
    message, and sends it to the user.  If there is an error sending to the
    user message alias, the message is send to the computer name.

    A user alert notification (arrived via the mailslot) has the following
    form:

        Timestamp of the alert event
        "USER"
        "SERVER"

        Message id of message
        Number of merge strings which will be substituted into message
        Merge strings, each separated by a zero terminator.

        Username
        \\ComputerNameOfUser

Arguments:

    Alert - Supplies a pointer to the alert notification structure.

Return Value:

    None.

--*/
{
    NET_API_STATUS status;

    PUSER_OTHER_INFO UserInfo  = (PUSER_OTHER_INFO) ALERT_OTHER_INFO(Alert);

    DWORD i;

    LPTSTR MergeStrings;
    LPTSTR Username;
    LPTSTR ComputerNameOfUser;
    LPTSTR To = NULL;


    IF_DEBUG(FORMAT) {
        NetpKdPrint(("[Alerter] Got user alert\n"));
    }

    MergeStrings = (LPTSTR) ALERT_VAR_DATA(UserInfo);

    //
    // Name of user to be notified of the alert is found after the merge
    // strings.
    //
    for (Username = MergeStrings, i = 0; i < UserInfo->alrtus_numstrings; i++) {
        Username += STRLEN(Username) + 1;
    }

    //
    // Computer name of user is in the alert structure after the user name.
    //
    ComputerNameOfUser = Username + STRLEN(Username) + 1;

    //
    // If both username and computer name are not specified, cannot send the
    // message
    //
    if (*Username == TCHAR_EOS && *ComputerNameOfUser == TCHAR_EOS) {
        NetpKdPrint((
            "[Alerter] Alert not sent.  Username or computername not specified.\n"
            ));
        return;
    }

    //
    // Setup the To pointer to point to the message alias that canonicalize
    // properly.  If there's a problem with the username, we will send the
    // message to the computer name.
    //

    if (AlCanonicalizeMessageAlias(Username) == NERR_Success) {
        To = Username;
    }

    //
    // Computer name may or may not be preceeded by backslashes
    //
    if (*ComputerNameOfUser == TCHAR_BACKSLASH &&
        *(ComputerNameOfUser + 1) == TCHAR_BACKSLASH) {
        ComputerNameOfUser += 2;
    }

    if (AlCanonicalizeMessageAlias(ComputerNameOfUser) == NERR_Success &&
        To == NULL) {
        To = ComputerNameOfUser;
    }

    //
    // Both username and computer name are not acceptable.
    //
    if (To == NULL) {
        NetpKdPrint((
            "[Alerter] Alert not sent.  Username & computername are not acceptable.\n"
            ));
        return;
    }

    status = AlMakeMessageHeader(
                 Alert->alrt_servicename,
                 To,
                 APE2_ALERTER_USER_SUBJ,
                 Alert->alrt_timestamp,
                 FALSE                        // Not an admin alert
                 );

    if (status != NERR_Success) {
        NetpKdPrint((
            "[Alerter] Alert not sent.  Error making message header %lu\n",
            status
            ));
        return;
    }

    AlMakeMessageBody(
        UserInfo->alrtus_errcode,
        MergeStrings,
        UserInfo->alrtus_numstrings
        );

    //
    // Send the message
    //
    if (AlSendMessage(To) == NERR_Success) {
        return;
    }

    //
    // If To points to the Username and the send was not successful, try
    // sending to the computer name of user.
    //
    if (To == Username) {
        (void) AlSendMessage(ComputerNameOfUser);
    }
}



VOID
AlPrintFormatAndSend(
    IN  PSTD_ALERT Alert
    )
/*++

Routine Description:

    This function takes a print alert notification, formats it into an alert
    message, and sends it to the computer name which the print job submitter
    is on.  If the print alert is for certain type of printing error, like
    the printer is offline, the admins on the alert names list gets the alert
    message as well.

Arguments:

    Alert - Supplies a pointer to the alert notification structure.

Return Value:

    None.

--*/
{
    PPRINT_OTHER_INFO PrintInfo = (PPRINT_OTHER_INFO) ALERT_OTHER_INFO(Alert);

    LPTSTR ComputerName = NULL;
    LPTSTR Username = NULL;
    LPTSTR DocumentName = NULL;
    LPTSTR PrinterName = NULL;
    LPTSTR ServerName = NULL;
    LPTSTR StatusString = NULL;

    DWORD PrintMessageID = APE2_ALERTER_PRINTING_SUCCESS;

    BOOL AdminAlso;

    LPTSTR AdminToAlert;


    IF_DEBUG(FORMAT) {
        NetpKdPrint(("[Alerter] Got print alert\n"));
    }

    ComputerName = (LPTSTR) ALERT_VAR_DATA(PrintInfo);
    Username = ComputerName + STRLEN(ComputerName) + 1;
    DocumentName = Username + STRLEN(Username) + 1;
    PrinterName = DocumentName + STRLEN(DocumentName) + 1;
    ServerName = PrinterName + STRLEN(PrinterName) + 1;
    StatusString = ServerName + STRLEN(ServerName) + 1;

    if ( ((PrintInfo->alrtpr_status & PRJOB_QSTATUS) == PRJOB_QS_PRINTING)
        && (PrintInfo->alrtpr_status & PRJOB_COMPLETE) ) {
        PrintMessageID = APE2_ALERTER_PRINTING_SUCCESS;
    }
    else {
        if ( *StatusString == '\0' ) {
            PrintMessageID = APE2_ALERTER_PRINTING_FAILURE;
        }
        else {
            PrintMessageID = APE2_ALERTER_PRINTING_FAILURE2;
        }
    }

    //
    // If error, notify admins on the alert names list also, besides the print
    // job submitter.
    //
    AdminAlso = (PrintInfo->alrtpr_status &
                 (PRJOB_DESTOFFLINE | PRJOB_INTERV | PRJOB_ERROR));

    //
    // Computer name may or may not be preceeded by backslashes
    //
    if (*ComputerName == TCHAR_BACKSLASH &&
        *(ComputerName + 1) == TCHAR_BACKSLASH) {
        ComputerName += 2;
    }

    (VOID) AlCanonicalizeMessageAlias(ComputerName);

    //
    // Format message for the print job submitter
    //
    MessageBuffer[0] = AL_NULL_CHAR;
    AlMakePrintMessage( PrintMessageID,
                        DocumentName,
                        PrinterName,
                        ServerName,
                        StatusString );

    //
    // If the print job submitter is one of admins specified on the alert
    // names list, don't send the message to the submitter yet.  All the
    // admins on alert names list will receive the message during admin
    // processing below.
    //
    if ((AdminAlso && !IsDuplicateReceiver(ComputerName) ) ||
        ! AdminAlso) {

        if ( AlSendMessage(ComputerName) != NERR_Success ) {
            (void) AlSendMessage(Username);
        }
    }

    //
    // We are done if this is not an admin related alert.
    //
    if (! AdminAlso) {
        return;
    }

    AdminToAlert = AlertNamesW;

    //
    // Send alert message to every admin on the alert names list.
    //
    while (AdminToAlert != NULL && *AdminToAlert != TCHAR_EOS) {

        MessageBuffer[0] = AL_NULL_CHAR;
        AlMakePrintMessage( PrintMessageID,
                            DocumentName,
                            PrinterName,
                            ServerName,
                            StatusString );

        //
        // Send message to the admin.
        //
        (void) AlSendMessage(AdminToAlert);

        AdminToAlert += (STRLEN(AdminToAlert) + 1);
    }
}




STATIC
VOID
AlMakePrintMessage(
    IN  DWORD PrintMessageID,
    IN  LPTSTR DocumentName,
    IN  LPTSTR PrinterName,
    IN  LPTSTR ServerName,
    IN  LPTSTR StatusString
    )
/*++

Routine Description:


    PrintMessageID - ID of message string to use

    DocumentName, PrinterName, ServerName, StatusString(Optional) - insert strings passed by spooler.

Return Value:

    None.

--*/
{
    LPSTR SubstituteStrings[4];


    SubstituteStrings[0] = NetpAllocStrFromWStr(DocumentName);
    if (SubstituteStrings[0] == NULL) {
            return;
    }
    SubstituteStrings[1] = NetpAllocStrFromWStr(PrinterName);
    if (SubstituteStrings[1] == NULL) {
            NetApiBufferFree(SubstituteStrings[0]);
            return;
    }
    SubstituteStrings[2] = NetpAllocStrFromWStr(ServerName);
    if (SubstituteStrings[2] == NULL) {
            NetApiBufferFree(SubstituteStrings[0]);
            NetApiBufferFree(SubstituteStrings[1]);
            return;
    }
    SubstituteStrings[3] = NULL;
    if ( *StatusString != '\0' ) {
        SubstituteStrings[3] = NetpAllocStrFromWStr(StatusString);
        if (SubstituteStrings[3] == NULL) {
            NetApiBufferFree(SubstituteStrings[0]);
            NetApiBufferFree(SubstituteStrings[1]);
            NetApiBufferFree(SubstituteStrings[2]);
            return;
        }
    }
    AlAppendMessage(
        PrintMessageID,
        MessageBuffer,
        SubstituteStrings,
        *StatusString == '\0' ? 3 : 4
        );

    NetApiBufferFree(SubstituteStrings[0]);
    NetApiBufferFree(SubstituteStrings[1]);
    NetApiBufferFree(SubstituteStrings[2]);
    if ( SubstituteStrings[3] )
        NetApiBufferFree(SubstituteStrings[3]);

}




STATIC
NET_API_STATUS
AlSendMessage(
   IN  LPTSTR MessageAlias
   )
/*++

Routine Description:

    This function sends the message in MessageBuffer to the specified
    message alias.  If an error occurs while sending the message, it will
    be logged to the error log file.

Arguments:

    MessageAlias - Supplies the message alias of recipient of the message.

Return Value:

    NET_API_STATUS - NERR_Success or reason for failure.

--*/
{
    static NET_API_STATUS PreviousStatus = NERR_Success;
    NET_API_STATUS Status;

    LPWSTR MessageW;
    DWORD MessageSize;

    MessageW = NetpAllocWStrFromStr(MessageBuffer);
    if (MessageW == NULL) {
        NetpKdPrint(("[Alerter] AlSendMessage: NetpAllocWStrFromStr failed\n"));
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    // fixes alterts to DOS clients and garbage in NT to NT altert message
    MessageSize = wcslen( MessageW ) * sizeof(WCHAR) ;
    //
    // Send a directed message to the specified message alias
    //

    IF_DEBUG(FORMAT) {
        NetpKdPrint(("\n\nMessage To " FORMAT_LPTSTR "\n\n", MessageAlias));
        NetpDbgHexDump((LPBYTE) MessageW, MessageSize);
    }

    if ((Status = NetMessageBufferSend(
                     NULL,
                     MessageAlias,
                     AlLocalComputerNameW,
                     (LPBYTE) MessageW,
                     MessageSize
                     )) != NERR_Success) {

        NetpKdPrint(("[Alerter] Error sending message to "
                     FORMAT_LPTSTR " %lu\n", MessageAlias, Status));

        if (Status != NERR_NameNotFound &&
            Status != NERR_BadReceive &&
            Status != NERR_UnknownServer &&
            Status != PreviousStatus) {

            AlHandleError(AlErrorSendMessage, Status, MessageAlias);
            PreviousStatus = Status;
        }

    }

    NetApiBufferFree(MessageW);

    return Status;
}



STATIC
NET_API_STATUS
AlAppendMessage(
    IN  DWORD MessageId,
    OUT LPSTR MessageBuffer,
    IN  LPSTR *SubstituteStrings,
    IN  DWORD NumberOfSubstituteStrings
    )
/*++

Routine Description:

    This function gets the message, as specified by the message id, from a
    predetermined message file.  It then appends the message to the
    MessageBuffer.

Arguments:

    MessageId - Supplies the message id of message to get from message file.

    MessageBuffer - Supplies a pointer to the buffer which the message is
        appended to.

    SubstituteStrings - Supplies an array of strings to substitute into the
        message.

    NumberOfSubstituteStrings - Supplies the number of strings in array of
        SunstituteStrings

Return Value:

    NET_API_STATUS - NERR_Success or reason for failure.

--*/
{
    WORD MessageLength = 0;
    NET_API_STATUS status;

    LPBYTE RetrievedMessage;
    LPBYTE ResultMessage = NULL;


    //
    // Allocate memory for the buffer which receives the message from the
    // message file.
    //
    if ((RetrievedMessage = (LPBYTE) LocalAlloc(
                                         0,
                                         MAX_ALERTER_MESSAGE_SIZE+1
                                         )) == NULL) {
       return GetLastError();
    }


    if ((status = (NET_API_STATUS) DosGetMessage(
                                       SubstituteStrings,
                                       (WORD) NumberOfSubstituteStrings,
                                       RetrievedMessage,
                                       MAX_ALERTER_MESSAGE_SIZE,
                                       (WORD) MessageId,
                                       MESSAGE_FILENAME,
                                       &MessageLength
                                       )) != 0) {
        goto CleanUp;
    }

    RetrievedMessage[MessageLength] = AL_NULL_CHAR;

    //
    // Set the result message to the beginning of message
    // if there are no spaces in the message.
    //
    if (ResultMessage == NULL) {
        ResultMessage = RetrievedMessage;
    }

    strcat(MessageBuffer, ResultMessage);

CleanUp:

    LocalFree(RetrievedMessage);

    return status;
}


STATIC
BOOL
IsDuplicateReceiver(
    LPTSTR Name
    )
/*++

Routine Description:

    This function compares the specified name with the names on the alert
    names list and returns TRUE if there is a match; FALSE otherwise.

Arguments:

    Name - Supplies a name to compare with the alert names list.

Return Value:

    TRUE if match any name; FALSE otherwise.

--*/
{
    LPTSTR AdminToAlert = AlertNamesW;


    while (AdminToAlert != NULL && *AdminToAlert != TCHAR_EOS) {

        if (STRICMP(Name, AdminToAlert) == 0) {
            return TRUE;
        }

        AdminToAlert = STRCHR(AdminToAlert, TCHAR_EOS);
        AdminToAlert++;
    }

    return FALSE;
}


VOID
AlFormatErrorMessage(
    IN  NET_API_STATUS Status,
    IN  LPTSTR MessageAlias,
    OUT LPTSTR ErrorMessage,
    IN  DWORD ErrorMessageBufferSize
    )
/*++

Routine Description:

    This function formats 3 strings and place them, NULL separated, into
    the supplied ErrorMessage buffer.  The strings appear in the following
    order:
        Status
        MessageAlias
        Message which was not send

Arguments:

    Status - Supplies the status code of the error.

    MessageAlias - Supplies the message alias of the intended recipient.

    ErrorMessage - Returns the formatted error message in this buffer.

    ErrorMessageBufferSize - Supplies the size of the error message buffer
        in bytes.

Return Value:

    None.

--*/
{
    LPTSTR MessageBufferPointer;
    LPTSTR MBPtr;
    LPTSTR MBPtr2;

    DWORD SizeOfString;

    LPTSTR MessageBufferW;

    CHAR MessageBufferTmp[MAX_ALERTER_MESSAGE_SIZE];


    RtlZeroMemory(ErrorMessage, ErrorMessageBufferSize);

    //
    // Don't muck with the actual message buffer itself because it
    // may still be in use.
    //
    strcpy(MessageBufferTmp, MessageBuffer);

    //
    // Put status in error message buffer
    //
    ultow(Status, ErrorMessage, 10);

    MBPtr = &ErrorMessage[STRLEN(ErrorMessage) + 1];

    //
    // Put message alias in error message buffer
    //
    STRCPY(MBPtr, MessageAlias);
    MBPtr += (STRLEN(MessageAlias) + 1);

    //
    // Put the message that failed to send in error message buffer
    //

    MessageBufferW = NetpAllocWStrFromStr(MessageBufferTmp);
    if (MessageBufferW == NULL) {
        return;
    }

    MessageBufferPointer = MessageBufferW;

    while (MBPtr2 = STRCHR(MessageBufferPointer, AL_EOL_WCHAR)) {

        *MBPtr2++ = TCHAR_EOS;
        SizeOfString = (DWORD) ((LPBYTE)MBPtr2 - (LPBYTE)MessageBufferPointer) + sizeof(TCHAR);

        //
        // Check for error message buffer overflow
        //
        if ((LPBYTE)MBPtr - (LPBYTE)ErrorMessage + SizeOfString >=
            ErrorMessageBufferSize) {
            break;
        }

        STRCPY(MBPtr, MessageBufferPointer);
        STRCAT(MBPtr, AL_CRLF_STRING);
        MBPtr += SizeOfString / sizeof(TCHAR);

        MessageBufferPointer = MBPtr2;
    }

    if (((LPBYTE)MBPtr - (LPBYTE)ErrorMessage +
        STRLEN(MessageBufferPointer) * sizeof(TCHAR)) >
        ErrorMessageBufferSize) {

        //
        // Put as much info into the error message buffer as possible
        //
        STRNCPY(MBPtr,
                MessageBufferPointer,
                ErrorMessageBufferSize/sizeof(TCHAR) - (int)(MBPtr - ErrorMessage));
        ErrorMessage[(ErrorMessageBufferSize/sizeof(TCHAR))-1] = TCHAR_EOS;

    } else {
        STRCPY(MBPtr, MessageBufferPointer);
    }

    NetApiBufferFree(MessageBufferW);
}



NET_API_STATUS
AlCanonicalizeMessageAlias(
    LPTSTR MessageAlias
    )
/*++

Routine Description:

    This function canonicalizes the message alias by calling
    I_NetNameCanonicalize.

Arguments:

    MessageAlias - Supplies the message alias of an intended recipient for
        the alert message.

Return Value:

    NET_API_STATUS - NERR_Success or reason for failure.

--*/
{
    NET_API_STATUS Status;


    //
    // Canonicalize message alias which will receive message
    //
    Status = I_NetNameCanonicalize(
                 NULL,
                 MessageAlias,
                 MessageAlias,
                 (STRLEN(MessageAlias) + 1) * sizeof(TCHAR),
                 NAMETYPE_USER,
                 0
                 );

    if (Status != NERR_Success) {

        NetpKdPrint(("[Alerter] Error canonicalizing message alias " FORMAT_LPTSTR " %lu\n",
                     MessageAlias, Status));
        AlHandleError(AlErrorSendMessage, Status, MessageAlias);
    }

    return Status;
}


VOID
AlMakeTimeString(
    DWORD   * Time,
    PCHAR   String,
    int     StringLength
    )

/*++

Routine Description:

    This function converts the UTC time expressed in seconds since 1/1/70
    to an ASCII String.

Arguments:

    Time         - Pointer to the number of seconds since 1970 (UTC).

    String       - Pointer to the buffer to place the ASCII representation.

    StringLength - The length of String in bytes.

Return Value:

    None.

--*/
{
    time_t LocalTime;
    DWORD  dwTimeTemp;
    struct tm TmTemp;
    SYSTEMTIME st;
    int	cchT=0, cchD;

    NetpGmtTimeToLocalTime(*Time, &dwTimeTemp);

    //
    // Cast the DWORD returned by NetpGmtTimeToLocalTime up to
    // a time_t.  On 32-bit, this is a no-op.  On 64-bit, this
    // ensures the high DWORD of LocalTime is zeroed out.
    //
    LocalTime = (time_t) dwTimeTemp;

    net_gmtime(&LocalTime, &TmTemp);

    st.wYear         = (WORD)(TmTemp.tm_year + 1900);
    st.wMonth        = (WORD)(TmTemp.tm_mon + 1);
    st.wDay          = (WORD)(TmTemp.tm_mday);
    st.wHour         = (WORD)(TmTemp.tm_hour);
    st.wMinute       = (WORD)(TmTemp.tm_min);
    st.wSecond       = (WORD)(TmTemp.tm_sec);
    st.wMilliseconds = 0;

    cchD = GetDateFormatA(GetThreadLocale(),
                          0,
                          &st,
                          NULL,
                          String,
                          StringLength);

    if (cchD != 0)
    {
        *(String + cchD - 1) = ' ';    /* replace NULLC with blank */

        cchT = GetTimeFormatA(GetThreadLocale(),
                              TIME_NOSECONDS,
                              &st,
                              NULL,
                              String + cchD,
                              StringLength - cchD);

        if (cchT == 0)
        {
            //
            // If this gets hit, MAX_DATE_TIME_LEN (in netapi\inc\timelib.h)
            // needs to be increased
            //
            ASSERT(FALSE);
            *(String + cchD - 1) = '\0';
        }
    }

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\alrsvc\almain.h ===
/*++

Copyright (c) 1991 Microsoft Corporation

Module Name:

    almain.h

Abstract:

    Private header file which defines the global data used for communication
    between the service control handler and the rest of the Alerter service.

Author:

    Rita Wong (ritaw) 01-July-1991

Revision History:

--*/

#ifndef _ALMAIN_INCLUDED_
#define _ALMAIN_INCLUDED_

#include "al.h"                   // Common include file for Alerter service
#include <winsvc.h>               // Service control APIs
#include <lmsname.h>              // SERVICE_ALERTER
#include <lmerrlog.h>             // Error log codes

//
// Maximum incoming mailslot message size in number of bytes
//
#define MAX_MAILSLOT_MESSAGE_SIZE       512

//
// Size of error message buffer
//
#define STRINGS_MAXIMUM                 256

//
// Call AlHandleError with the appropriate error condition
//
#define AL_HANDLE_ERROR(ErrorCondition)                        \
    AlHandleError(                                             \
        ErrorCondition,                                        \
        status                                                 \
        );

//
// Call AlShutdownWorkstation with the appropriate termination code
//
#define AL_SHUTDOWN_WORKSTATION(TerminationCode)               \
    AlShutdownWorkstation(                                     \
        TerminationCode                                        \
        );


//-------------------------------------------------------------------//
//                                                                   //
// Type definitions                                                  //
//                                                                   //
//-------------------------------------------------------------------//

typedef struct _AL_GLOBAL_DATA {

    //
    // Alerter service status
    //
    SERVICE_STATUS Status;

    //
    // Handle to set service status
    //
    SERVICE_STATUS_HANDLE StatusHandle;

    //
    // Handle to the Alerter service mailslot which receives alert
    // notifications from the Server service and Spooler
    //
    HANDLE MailslotHandle;

} AL_GLOBAL_DATA, *PAL_GLOBAL_DATA;


#endif // ifndef _ALMAIN_INCLUDED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\alrsvc\altest.c ===
/*++

Copyright (c) 1991-92 Microsoft Corporation

Module Name:

    altest.c

Abstract:

    Test program for the Alerter service.

Author:

    Rita Wong (ritaw) 17-July-1991

Revision History:

--*/

#include <stdio.h>
#include <string.h>

#include <nt.h>                // NT definitions
#include <ntrtl.h>                // NT runtime library definitions
#include <nturtl.h>

#include <windef.h>               // Win32 type definitions
#include <winbase.h>              // Win32 base API prototypes

#include <alertmsg.h>             // ALERT_ equates.
#include <lmcons.h>               // LAN Manager common definitions
#include <lmalert.h>              // LAN Manager alert structures and APIs
#include <lmerr.h>                // LAN Manager network error definitions
#include <netdebug.h>             // FORMAT_ equates.

#include <tstring.h>              // Transitional string functions
#include <conio.h>
#include <time.h>
//#include "lmspool.h"

//
// Global buffer
//
TCHAR VariableInfo[1024];


//------------------------------------------------------------------------//

VOID __cdecl
main(
    int argc,
    char *argv[]
    )
{
    NET_API_STATUS      ApiStatus;
    PADMIN_OTHER_INFO   Admin;
    PUSER_OTHER_INFO    User;
    PPRINT_OTHER_INFO   Print;
    LPWSTR              pString;
    DWORD               dwTime;

    DWORD VariableInfoSize;
    DWORD TmpSize;             // Size of var portion plus 1 mergestring

    CHAR response;
    DWORD i;

    UNREFERENCED_PARAMETER(argc);
    UNREFERENCED_PARAMETER(argv);

    (VOID) printf( "AlTest: starting up...\n" );
    
    //
    // Alerter service should not crash if username and computer name are
    // not part of the mailslot message
    //
    User = (PUSER_OTHER_INFO) VariableInfo;
    User->alrtus_errcode = ALERT_CloseBehindError;
    User->alrtus_numstrings = 1;

    VariableInfoSize = sizeof(USER_OTHER_INFO);

    //
    // Write the mergestring into buffer.  In the case of a close behind error
    // it is the name of the file which failed to close.
    //
#define FILENAME TEXT("PLUTO.TXT")
    STRCPY((LPTSTR) ((DWORD) User + VariableInfoSize), FILENAME);
    VariableInfoSize += ((STRLEN(FILENAME) + 1) * sizeof(TCHAR));

    TmpSize = VariableInfoSize;

    //
    // This should not cause a message to be sent because neither the user
    // nor computer name is specified.
    //
    ApiStatus = NetAlertRaise(
            ALERT_USER_EVENT,            // alert event name
            VariableInfo,
            VariableInfoSize );

    (VOID) printf( "AlTest 1(USER_ALERT): done NetAlertRaise, status=" FORMAT_API_STATUS
            ", expect=" FORMAT_API_STATUS ".\n",
            ApiStatus, ERROR_INVALID_PARAMETER );

    for (i = 1; i < 3; i ++) {

        VariableInfoSize = TmpSize;

        //
        // Now include username and computer name
        //
#define USERNAME     TEXT("DANL")

#define COMPUTERNAME TEXT("danl1")

        STRCPY((LPTSTR) ((DWORD) User + VariableInfoSize), USERNAME);
        VariableInfoSize += ((STRLEN(USERNAME) + 1) * sizeof(TCHAR));

        //
        // Put a sequence number at the end of the username
        //
        //VariableInfo[STRLEN(USERNAME) - 1] = i + '1';

        STRCPY((LPTSTR) ((DWORD) User + VariableInfoSize), COMPUTERNAME);
        VariableInfoSize += ((STRLEN(COMPUTERNAME) + 1) * sizeof(TCHAR));

        //
        // User alert should be raised successfully.
        //
        ApiStatus = NetAlertRaiseEx(
                ALERT_USER_EVENT,
                VariableInfo,
                VariableInfoSize,
                TEXT("SERVER") );    // service name

        (VOID) printf( "AlTest 2(USER_ALERT): done NetAlertRaiseEx, status=" FORMAT_API_STATUS
                ".\n", ApiStatus );

    }

    //--------------------------
    // Raise an admin alert
    //  (audit log full)
    //--------------------------
    Admin = (PADMIN_OTHER_INFO) VariableInfo;
    Admin->alrtad_errcode = ALERT_AuditLogFull;
    Admin->alrtad_numstrings = 0;

    ApiStatus = NetAlertRaiseEx(
            ALERT_ADMIN_EVENT,
            VariableInfo,
            sizeof(ADMIN_OTHER_INFO),
            TEXT("SERVER") );         // service name

    (VOID) printf( "AlTest 3(ADMIN_ALERT): done NetAlertRaiseEx(admin), status="
            FORMAT_API_STATUS ".\n", ApiStatus );

    //--------------------------
    // Raise an admin alert
    //  (user-defined text)
    //--------------------------
    Admin = (PADMIN_OTHER_INFO) VariableInfo;
    Admin->alrtad_errcode = MAXULONG;
    Admin->alrtad_numstrings = 1;
    pString = (LPWSTR)((LPBYTE)VariableInfo+sizeof(ADMIN_OTHER_INFO));
    wcscpy(pString,L"This is a User-Defined Message");

    ApiStatus = NetAlertRaiseEx(
            ALERT_ADMIN_EVENT,
            VariableInfo,
            sizeof(ADMIN_OTHER_INFO)+WCSSIZE(pString),
            TEXT("SERVER") );         // service name

    (VOID) printf( "AlTest 3.5(ADMIN_ALERT): done NetAlertRaiseEx(admin), status="
            FORMAT_API_STATUS ".\n", ApiStatus );

    //---------------------------------
    // Raise an alert  (NON-EX version)
    //  (user-defined text)
    //---------------------------------
    {
        LPSTD_ALERT     pStdAlert = (LPSTD_ALERT)VariableInfo;

        pStdAlert->alrt_timestamp = 1;
        wcscpy(pStdAlert->alrt_eventname,ALERT_ADMIN_EVENT);
        wcscpy(pStdAlert->alrt_servicename, L"Dan'sSvc");
        Admin = (LPADMIN_OTHER_INFO)((LPBYTE)VariableInfo + sizeof(STD_ALERT));
        pString = (LPWSTR)((LPBYTE)VariableInfo + sizeof(STD_ALERT) +
                    sizeof(ADMIN_OTHER_INFO));
        Admin->alrtad_errcode = MAXULONG;
        Admin->alrtad_numstrings = 1;
        wcscpy(pString, L"Some User Data");
        VariableInfoSize = sizeof(STD_ALERT)+ sizeof(ADMIN_OTHER_INFO) +
                            STRSIZE(pString);

        ApiStatus = NetAlertRaise(
                ALERT_ADMIN_EVENT,            // alert event name
                VariableInfo,
                VariableInfoSize );

        (VOID) printf( "AlTest 3.6(ADMIN_ALERT): done NetAlertRaise(admin), status="
            FORMAT_API_STATUS ".\n", ApiStatus );

    }
    //---------------------------------
    // PRINT ALERT:   PRINTER OFFLINE
    //  (queued for printing)
    //---------------------------------
    time((time_t *)&dwTime);
    printf("time=%d\n",dwTime);
    Print = (PPRINT_OTHER_INFO) VariableInfo;
    Print->alrtpr_jobid = 626;
    Print->alrtpr_status = PRJOB_DESTOFFLINE;
    Print->alrtpr_submitted = dwTime;
    Print->alrtpr_size = 72496;

    //
    // All print Alerts have the PRINT_OTHER_INFO structure
    // followed by these same strings in this order...
    //
    VariableInfoSize = sizeof(PRINT_OTHER_INFO);

    // Computername
    STRCPY((LPTSTR) ((DWORD) Print + VariableInfoSize), TEXT("DANL2-SHAUNAB"));
    VariableInfoSize += ((STRLEN(TEXT("DANL2-SHAUNAB")) + 1) * sizeof(TCHAR));

    // username
    STRCPY((LPTSTR) ((DWORD) Print + VariableInfoSize), TEXT("DANL1"));
    VariableInfoSize += ((STRLEN(TEXT("DANL1")) + 1) * sizeof(TCHAR));

    // queuename
    STRCPY((LPTSTR) ((DWORD) Print + VariableInfoSize), TEXT("8/1154 CORPA 14DBDE"));
    VariableInfoSize += ((STRLEN(TEXT("8/1154 CORPA 14DBDE")) + 1) * sizeof(TCHAR));

    // destination
    STRCPY((LPTSTR) ((DWORD) Print + VariableInfoSize), TEXT("8/1154 CORPA 14DBDE(CORPA)"));
    VariableInfoSize += ((STRLEN(TEXT("8/1154 CORPA 14DBDE(CORPA)")) + 1) * sizeof(TCHAR));

    // status string
    STRCPY((LPTSTR) ((DWORD) Print + VariableInfoSize), TEXT("ERROR"));
    VariableInfoSize += ((STRLEN(TEXT("ERROR")) + 1) * sizeof(TCHAR));

#ifdef REMOVE
    ApiStatus = NetAlertRaiseEx(
            ALERT_PRINT_EVENT,
            VariableInfo,
            VariableInfoSize,
            TEXT("SPOOLER") );         // service name

    (VOID) printf( "AlTest 4(PRINT_ALERT): done NetAlertRaiseEx(print), status="
            FORMAT_API_STATUS ".\n", ApiStatus );

    //
    // Wait for user reponse before continuing.
    //
    printf("continue?....\n");
    response = _getch();
    if ((response == 'n') || (response == 'N')) {
        return;
    }
#endif //REMOVE
    //---------------------------------------
    // PRINT ALERT:   JOB_COMPLETE
    //---------------------------------------
    Print->alrtpr_status = PRJOB_COMPLETE | PRJOB_QS_PRINTING;
    Print->alrtpr_jobid = 2434;

    ApiStatus = NetAlertRaiseEx(
            ALERT_PRINT_EVENT,
            VariableInfo,
            VariableInfoSize,
            TEXT("SPOOLER") );         // service name

    (VOID) printf( "AlTest 4.5(PRINT_ALERT): done NetAlertRaiseEx(print), status="
            FORMAT_API_STATUS ".\n", ApiStatus );

    //---------------------------------------
    // PRINT ALERT:   NO PAPER - JOB_QUEUED
    //---------------------------------------
    Print->alrtpr_status = PRJOB_DESTNOPAPER;
    Print->alrtpr_jobid = 628;

    ApiStatus = NetAlertRaiseEx(
            ALERT_PRINT_EVENT,
            VariableInfo,
            VariableInfoSize,
            TEXT("SPOOLER") );         // service name

    (VOID) printf( "AlTest 5(PRINT_ALERT): done NetAlertRaiseEx(print), status="
            FORMAT_API_STATUS ".\n", ApiStatus );

    //------------------------------------------
    // PRINT ALERT:   NO PAPER - JOB PRINTING
    //------------------------------------------
    Print->alrtpr_status = PRJOB_DESTNOPAPER | PRJOB_QS_PRINTING;
    Print->alrtpr_jobid = 629;

    ApiStatus = NetAlertRaiseEx(
            ALERT_PRINT_EVENT,
            VariableInfo,
            VariableInfoSize,
            TEXT("SPOOLER") );         // service name

    (VOID) printf( "AlTest 5(PRINT_ALERT): done NetAlertRaiseEx(print), status="
            FORMAT_API_STATUS ".\n", ApiStatus );

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\at\atnames.h ===
/*++

Copyright (c) 1992 Microsoft Corporation

Module Name:

    atnames.h

Abstract:

    Private header file which defines the SCHEDULE service names.

Author:

    Vladimir Z. Vulovic     (vladimv)       06 - November - 1992

Revision History:

    06-Nov-1992     vladimv
        Created

--*/

#define AT_INTERFACE_NAME    TEXT("atsvc")

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\alrsvc\alconfig.h ===
/*++

Copyright (c) 1991-92  Microsoft Corporation

Module Name:

    alconfig.h

Abstract:

    Private header file for the Alerter service module that reads in
    configuration information.

Author:

    Rita Wong (ritaw) 16-July-1991

Revision History:

--*/


#ifndef _ALCONFIG_INCLUDED_
#define _ALCONFIG_INCLUDED_

#include "al.h"                     // Common include file for Alerter service
#include <config.h>                 // Net config helpers in netlib.
#include <confname.h>               // SECT_NT_ALERTER, ALERT_KEYWORD_ stuff.
#include <lmserver.h>
#include <lmwksta.h>
#include <lmapibuf.h>

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\alrsvc\alformat.h ===
/*++

Copyright (c) 1991 Microsoft Corporation

Module Name:

    alformat.h

Abstract:

    Private header file which defines the values used for formatting alert
    messages.

Author:

    Rita Wong (ritaw) 09-July-1991

Revision History:

--*/

#ifndef _ALFORMAT_INCLUDED_
#define _ALFORMAT_INCLUDED_

#include "al.h"                   // Common include file for Alerter service
#include <lmmsg.h>                // NetMessageBufferSend

#include <alertmsg.h>
#include <apperr2.h>

#include <timelib.h>              // time functions in netlib

//
// Maximum size of a message send by the Alerter service in number of bytes
//
#define MAX_ALERTER_MESSAGE_SIZE        600

#define FILENAME_SIZE                   128

//
// Maximum message width.  Text will wrap around if exceed this width.
//
#define MESSAGE_WIDTH                    55

#define NO_MESSAGE                       MAXULONG

#define AL_CR_CHAR      '\r'
#define AL_EOL_CHAR     '\024'         // hex 14, decimal 20, USE \024 !
#define AL_EOL_WCHAR    TEXT('\024')   // hex 14, decimal 20, USE \024 !
#define AL_EOL_STRING   "\024"
#define AL_CRLF_STRING  TEXT("\r\n")


#endif // ifndef _ALFORMAT_INCLUDED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\alrsvc\alconfig.c ===
/*++

Copyright (c) 1991-92  Microsoft Corporation

Module Name:

    alconfig.c

Abstract:

    This module contains the Alerter service configuration routines.

Author:

    Rita Wong (ritaw) 16-July-1991

Revision History:

--*/

#include "alconfig.h"
#include <tstr.h>               // STRCPY(), etc.

STATIC
NET_API_STATUS
AlGetLocalComputerName(
    VOID
    );

//-------------------------------------------------------------------//
//                                                                   //

// Global variables                                                  //
//                                                                   //
//-------------------------------------------------------------------//

//
// Alert names
//
LPSTR AlertNamesA;     // For inclusion into message text (space-separated)
LPTSTR AlertNamesW;    // For sending message to (NULL-separated)

//
// Local computer name
//
LPSTR AlLocalComputerNameA;
LPTSTR AlLocalComputerNameW;



NET_API_STATUS
AlGetAlerterConfiguration(
    VOID
    )
/*++

Routine Description:

    This routine reads in alerter configuration info which is the alert names.
    If a failure occurs, or alert names could not be found, the error is
    logged but it will not prevent the Alerter service from starting up.

Arguments:

    AlUicCode - Supplies the termination code to the Service Controller.

Return Value:

    NERR_Success or error getting the computer name.

--*/
{
    NET_API_STATUS status;
    LPNET_CONFIG_HANDLE AlerterSection;
    LPTSTR UnicodeAlertNames;
    LPSTR AnsiAlertNames;
#ifdef UNICODE
    LPSTR Name;      // for conversion from Unicode to ANSI
#endif
    DWORD AlertNamesSize;
    LPWSTR SubString[1];
    TCHAR StatusString[25];


    AlertNamesA = NULL;
    AlertNamesW = NULL;

    //
    // Get the computer name.
    //
    if ((status = AlGetLocalComputerName()) != NERR_Success) {
        return status;
    }

    //
    // Open config file and get handle to the Alerter section
    //
    if ((status = NetpOpenConfigData(
                      &AlerterSection,
                      NULL,            // local server
                      SECT_NT_ALERTER,
                      TRUE             // read-only
                      )) != NERR_Success) {
        NetpKdPrint(("[Alerter] Could not open config section %lu\n", status));

        SubString[0] = ultow(status, StatusString, 10);
        AlLogEvent(
            NELOG_Build_Name,
            1,
            SubString
            );
        return NO_ERROR;
    }

    //
    // Get the alert names from the configuration file
    //
    if ((status = NetpGetConfigTStrArray(
                      AlerterSection,

                                      ALERTER_KEYWORD_ALERTNAMES,
                      &AlertNamesW         // alloc and set ptr
                      )) != NERR_Success) {
        NetpKdPrint(("[Alerter] Could not get alert names %lu\n", status));

        SubString[0] = ultow(status, StatusString, 10);
        AlLogEvent(
            NELOG_Build_Name,
            1,
            SubString
            );

        AlertNamesW = NULL;
        goto CloseConfigFile;
    }

    AlertNamesSize = NetpTStrArraySize(AlertNamesW) / sizeof(TCHAR) * sizeof(CHAR);

    if ((AlertNamesA = (LPSTR) LocalAlloc(
                                   LMEM_ZEROINIT,
                                   AlertNamesSize
                                   )) == NULL) {
        NetpKdPrint(("[Alerter] Error allocating AlertNamesA %lu\n", GetLastError()));
        NetApiBufferFree(AlertNamesW);
        AlertNamesW = NULL;
        goto CloseConfigFile;
    }

    AnsiAlertNames = AlertNamesA;
    UnicodeAlertNames = AlertNamesW;

    //
    // Canonicalize alert names, and convert the unicode names to ANSI
    //
    while (*UnicodeAlertNames != TCHAR_EOS) {

        AlCanonicalizeMessageAlias(UnicodeAlertNames);

#ifdef UNICODE
        Name = NetpAllocStrFromWStr(UnicodeAlertNames);
        if (Name != NULL) {
            (void) strcpy(AnsiAlertNames, Name);
            AnsiAlertNames += (strlen(AnsiAlertNames) + 1);
        }
        (void) NetApiBufferFree(Name);
#else
        (void) strcpy(AnsiAlertNames, UnicodeAlertNames);
        AnsiAlertNames += (strlen(AnsiAlertNames) + 1);
#endif

        UnicodeAlertNames += (STRLEN(UnicodeAlertNames) + 1);
    }


    //
    // Substitute the NULL terminators, which separate the alert names,
    // in AlertNamesA with spaces.  There's a space after the last alert
    // name.
    //
    AnsiAlertNames = AlertNamesA;
    while (*AnsiAlertNames != AL_NULL_CHAR) {
        AnsiAlertNames = strchr(AnsiAlertNames, AL_NULL_CHAR);
        *AnsiAlertNames++ = AL_SPACE_CHAR;
    }

CloseConfigFile:
    (void) NetpCloseConfigData( AlerterSection );

    //
    // Errors from reading AlertNames should be ignored so we always
    // return success here.
    //
    return NERR_Success;
}


STATIC
NET_API_STATUS
AlGetLocalComputerName(
    VOID
    )
/*++

Routine Description:

    This function gets the local computer name and stores both the ANSI
    and Unicode versions of it.

Arguments:

    None.  Sets the global pointers AlLocalComputerNameA and
    AlLocalComputerNameW.

Return Value:

    NERR_Success or error getting the local computer name.

--*/
{
    NET_API_STATUS status;


    AlLocalComputerNameA = NULL;
    AlLocalComputerNameW = NULL;

    if ((status = NetpGetComputerName(
                      &AlLocalComputerNameW
                      )) != NERR_Success) {
        AlLocalComputerNameW = NULL;
        return status;
    }

    AlCanonicalizeMessageAlias(AlLocalComputerNameW);

    //
    // Convert the computer name into ANSI
    //
#ifdef UNICODE
    AlLocalComputerNameA = NetpAllocStrFromWStr(AlLocalComputerNameW);

    if (AlLocalComputerNameA == NULL) {
        status = ERROR_NOT_ENOUGH_MEMORY;
    }
#else
    status = NetApiBufferAllocate(
                 STRSIZE(AlLocalComputerNameW),
                 &AlLocalComputerNameA
                 );
    if (status == NERR_Success) {
        (void) strcpy(AlLocalComputerNameA, AlLocalComputerNameW);
    }
    else {
        AlLocalComputerNameA = NULL;
    }
#endif

    return status;
}


VOID
AlLogEvent(
    DWORD MessageId,
    DWORD NumberOfSubStrings,
    LPWSTR *SubStrings
    )
{
    HANDLE LogHandle;


    LogHandle = RegisterEventSourceW (
                    NULL,
                    SERVICE_ALERTER
                    );

    if (LogHandle == NULL) {
        NetpKdPrint(("[Alerter] RegisterEventSourceW failed %lu\n",
                     GetLastError()));
        return;
    }

    (void) ReportEventW(
               LogHandle,
               EVENTLOG_ERROR_TYPE,
               0,                   // event category
               MessageId,
               (PSID) NULL,         // no SID
               (WORD)NumberOfSubStrings,
               0,
               SubStrings,
               (PVOID) NULL
               );

    DeregisterEventSource(LogHandle);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\at\client\atsvc_c_stub.c ===
#include "atsvc_c.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\at\client\handle.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    handle.c

Abstract:

    Example of a test code for detached, background, no-window command
    exectution.

Author:

    Vladimir Z. Vulovic     (vladimv)       06 - November - 1992

Environment:

    User Mode - Win32

Revision History:

    06-Nov-1992     vladimv
        Created

--*/

#include "atclient.h"
#include <stdlib.h>         //  exit()
#include <stdio.h>          //  printf
#include <wincon.h>         //  FreeConsole()



WCHAR *
AsciizToUnicode(
    IN      CHAR *      Asciiz
    )
/*++
    No attempt is made to clean up if we fail half way along.  Cleanup
    will be done at the exit process time.
--*/
{
    UNICODE_STRING          UnicodeString;
    BOOL                    success;

    RtlInitUnicodeString(
            &UnicodeString,
            NULL
            );

    //
    //  This call will attempt to allocate memory for UNICODE string.
    //

    success = RtlCreateUnicodeStringFromAsciiz(
            &UnicodeString,
            Asciiz
            );

    if ( success != TRUE) {
        printf( "Failed to make unicode string out of %s\n", Asciiz);
        return( NULL);
    }

    return( UnicodeString.Buffer);
}


WCHAR **
ArgvToUnicode(
    IN      int         argc,
    IN      CHAR **     charArgv
    )
/*++
    No attempt is made to clean up if we fail half way along.  Cleanup
    will be done at the exit process time.
--*/
{
    WCHAR **                argv;
    int                     index;

    argv = (WCHAR **)LocalAlloc(
            LMEM_FIXED,
            argc * sizeof( WCHAR *)
            );
    if ( argv == NULL) {
        return( NULL);
    }

    for ( index = 0;  index < argc;  index++ ) {

        if (  ( argv[ index] = AsciizToUnicode( charArgv[ index])) == NULL) {
            return( NULL);
        }
    }

    return( argv);
}


VOID __cdecl
main(
    int         argc,
    CHAR **     charArgv
    )
{
#define THIRTY_SECONDS      (30 * 1000)

    PROCESS_INFORMATION     ProcessInformation;
    STARTUPINFO             StartupInfo;
    HANDLE                  FileHandle;
    WCHAR **                argv;

    if ( argc < 2 || argc > 3) {
        printf(" Usage: handle command_to_execute [log_file_to_open]\n");
        exit( -1);
    }
    if ( ( argv = ArgvToUnicode( argc, charArgv)) == NULL) {
        printf( "Failed to map input strings to unicode.\n");
        exit( -1);
    }

    if ( !FreeConsole()) {
        KdPrint(( " FreeConsole() fails with WinError = %d\n", GetLastError()));
        exit( -1);
    }

    FileHandle = CreateFile(
        argc > 2 ? argv[ 2] : L"out.txt",           //  lpszName
        GENERIC_READ | GENERIC_WRITE,               //  fdwAccess
        FILE_SHARE_READ | FILE_SHARE_WRITE,         //  fdwShareMode
        NULL,                                       //  lpsa
        OPEN_ALWAYS,                                //  fdwCreate
        FILE_ATTRIBUTE_NORMAL,                      //  fdwAttrAndFlags
        NULL                                        //  hTemplateFile
        );

    if ( FileHandle == INVALID_HANDLE_VALUE) {
        KdPrint(( " CreateFile() fails with WinError = %d\n", GetLastError()));
        exit( -1);
    }

    if ( !SetStdHandle( STD_INPUT_HANDLE, FileHandle)) {
        KdPrint(( " SetStdHandle( STDIN) fails with WinError = %d\n", GetLastError()));
        exit( -1);
    }

    if ( !SetStdHandle( STD_OUTPUT_HANDLE, FileHandle)) {
        KdPrint(( " SetStdHandle( STDOUT) fails with WinError = %d\n", GetLastError()));
        exit( -1);
    }

    if ( !SetStdHandle( STD_ERROR_HANDLE, FileHandle)) {
        KdPrint(( " SetStdHandle( STDERR) fails with WinError = %d\n", GetLastError()));
        exit( -1);
    }

    GetStartupInfo( &StartupInfo);
    StartupInfo.lpTitle = NULL;

    if ( !CreateProcess(
            NULL,               //  image name is imbedded in the command line
            argv[ 1],           //  command line
            NULL,               //  pSecAttrProcess
            NULL,               //  pSecAttrThread
            TRUE,               //  this process will not inherit our handles
            DETACHED_PROCESS | CREATE_NO_WINDOW,   //  we have no access to the console either
            NULL,               //  pEnvironment
            NULL,               //  pCurrentDirectory
            &StartupInfo,
            &ProcessInformation
            )) {
        KdPrint(( " CreateProcess() fails with winError = %d\n", GetLastError()));
        exit( -1);
    }

    WaitForSingleObject( ProcessInformation.hProcess, THIRTY_SECONDS);

    exit( 0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\at\client\atstub.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    atstub.c

Abstract:

    Client stubs of the Schedule service APIs.

Author:

    Vladimir Z. Vulovic     (vladimv)       06 - November - 1992

Environment:

    User Mode - Win32

Revision History:

    06-Nov-1992     vladimv
        Created

--*/

#include "atclient.h"
#undef IF_DEBUG                 // avoid wsclient.h vs. debuglib.h conflicts.
#include <debuglib.h>           // IF_DEBUG() (needed by netrpc.h).
#include <lmserver.h>
#include <lmsvc.h>
#include <netlib.h>             // NetpServiceIsStarted() (needed by netrpc.h).
#include <netrpc.h>             // NET_REMOTE macros.
#include <lmstats.h>



NET_API_STATUS
NetScheduleJobAdd(
    IN      LPCWSTR         ServerName      OPTIONAL,
    IN      LPBYTE          Buffer,
    OUT     LPDWORD         pJobId
    )
/*++

Routine Description:

    This is the DLL entrypoint for NetScheduleJobAdd.  This API adds a job
    to the schedule.

Arguments:

    ServerName - Pointer to a string containing the name of the computer
        that is to execute the API function.

    Buffer - Pointer to a buffer containing information about the job

    pJobId - Pointer to JobId of a newly added job.


Return Value:

    NET_API_STATUS

--*/
{
    NET_API_STATUS          status;

    NET_REMOTE_TRY_RPC

        //
        // Try RPC (local or remote) version of API.
        //
        status = NetrJobAdd(
                     ServerName,
                     (LPAT_INFO)Buffer,
                     pJobId
                     );

    NET_REMOTE_RPC_FAILED(
            "NetScheduleJobAdd",
            ServerName,
            status,
            NET_REMOTE_FLAG_NORMAL,
            SERVICE_SCHEDULE
            )

        status = ERROR_NOT_SUPPORTED;

    NET_REMOTE_END

    return( status);

}  //  NetScheduleJobAdd


NET_API_STATUS
NetScheduleJobDel(
    IN      LPCWSTR         ServerName      OPTIONAL,
    IN      DWORD           MinJobId,
    IN      DWORD           MaxJobId
    )
/*++

Routine Description:

    This is the DLL entrypoint for NetScheduleJobDel.  This API removes
    from the schedule all jobs whose job ids are:

    -   greater than or equal to the minimum job id

            and

    -   less than or equal to the maximum job id

Arguments:

    ServerName - Pointer to a string containing the name of the computer
        that is to execute the API function.

    MinJobId - minumum job id

    MaxJobId - maxumum job id

Return Value:

    NET_API_STATUS

--*/
{
    NET_API_STATUS          status;

    NET_REMOTE_TRY_RPC

        //
        // Try RPC (local or remote) version of API.
        //
        status = NetrJobDel(
                     ServerName,
                     MinJobId,
                     MaxJobId
                     );

    NET_REMOTE_RPC_FAILED(
            "NetScheduleJobDel",
            ServerName,
            status,
            NET_REMOTE_FLAG_NORMAL,
            SERVICE_SCHEDULE
            )

        status = ERROR_NOT_SUPPORTED;

    NET_REMOTE_END

    return( status);

}  //  NetScheduleJobDel


NET_API_STATUS
NetScheduleJobEnum(
    IN      LPCWSTR         ServerName              OPTIONAL,
    OUT     LPBYTE *        PointerToBuffer,
    IN      DWORD           PreferredMaximumLength,
    OUT     LPDWORD         EntriesRead,
    OUT     LPDWORD         TotalEntries,
    IN OUT  LPDWORD         ResumeHandle
    )
/*++

Routine Description:

    This is the DLL entrypoint for NetScheduleJobEnum.  This API enumarates
    all jobs in the schedule.

Arguments:

    ServerName - Pointer to a string containing the name of the computer
        that is to execute the API function.

    PointerToBuffer - Pointer to location where pointer to returned data will
        be stored

    PreferredMaximumLength - Indicates a maximum size limit that the caller
        will allow for the return buffer.

    EntriesRead - A pointer to the location where the number of entries
        (data structures)read is to be returned.

    TotalEntries - A pointer to the location which upon return indicates
        the total number of entries in the table.

    ResumeHandle - Pointer to a value that indicates where to resume
        enumerating data.

Return Value:

    NET_API_STATUS

--*/
{
    NET_API_STATUS          status;
    AT_ENUM_CONTAINER       EnumContainer;

    EnumContainer.EntriesRead = 0;
    EnumContainer.Buffer = NULL;

    NET_REMOTE_TRY_RPC

        //
        // Try RPC (local or remote) version of API.
        //
        status = NetrJobEnum(
                     ServerName,
                     &EnumContainer,
                     PreferredMaximumLength,
                     TotalEntries,
                     ResumeHandle
                     );

        if ( status == NERR_Success || status == ERROR_MORE_DATA) {
            *EntriesRead = EnumContainer.EntriesRead;
            *PointerToBuffer = (LPBYTE)EnumContainer.Buffer;
        }

    NET_REMOTE_RPC_FAILED(
            "NetScheduleJobEnum",
            ServerName,
            status,
            NET_REMOTE_FLAG_NORMAL,
            SERVICE_SCHEDULE
            )

        status = ERROR_NOT_SUPPORTED;

    NET_REMOTE_END

    return( status);

}  //  NetScheduleJobEnum


NET_API_STATUS
NetScheduleJobGetInfo(
    IN      LPCWSTR         ServerName              OPTIONAL,
    IN      DWORD           JobId,
    OUT     LPBYTE *        PointerToBuffer
    )
/*++

Routine Description:

    This is the DLL entrypoint for NetScheduleGetInfo.  This API obtains
    information about a particular job in the schedule.

Arguments:

    ServerName - Pointer to a string containing the name of the computer
        that is to execute the API function.

    JobId - Id of job of interest.

    PointerToBuffer - Pointer to location where pointer to returned data will
        be stored

Return Value:

    NET_API_STATUS

--*/
{
    NET_API_STATUS          status;

    NET_REMOTE_TRY_RPC

        //
        // Try RPC (local or remote) version of API.
        //
        status = NetrJobGetInfo(
                     ServerName,
                     JobId,
                     (LPAT_INFO *)PointerToBuffer
                     );

    NET_REMOTE_RPC_FAILED(
            "NetScheduleJobGetInfo",
            ServerName,
            status,
            NET_REMOTE_FLAG_NORMAL,
            SERVICE_SCHEDULE
            )

        status = ERROR_NOT_SUPPORTED;

    NET_REMOTE_END

    return( status);

}  //  NetScheduleJobGetInfo

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\at\idl\imports.h ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    imports.h

Abstract:

    This file allows us to include standard system header files in the
    .idl file.  The main .idl file imports a file called import.idl.
    This allows the .idl file to use the types defined in these header
    files.  It also causes the following line to be added in the
    MIDL generated header file:

    #include "imports.h"

    Thus these types are available to the RPC stub routines as well.

Author:

    Dan Lafferty (danl)     07-May-1991

Revision History:


--*/


#include <windef.h>
#include <lmcons.h>

#ifdef MIDL_PASS
#define LPSTR   [string] LPSTR
#define LPTSTR  [string] wchar_t *
#define LPWSTR  [string] wchar_t *
#define BOOL    DWORD
#endif // MIDL_PASS

#include <lmat.h>

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\at\client\atclient.h ===
/*++

Copyright (c) 1991 Microsoft Corporation

Module Name:

    atclient.h

Abstract:

    Private header file for the client end of the schedule service
    modules.

Author:

    Vladimir Z. Vulovic     (vladimv)       06 - November - 1992

Revision History:

    06-Nov-1992     vladimv
        Created

--*/

#include <nt.h>                     //  DbgPrint prototype
#include <ntrtl.h>                  //  DbgPrint
#include <nturtl.h>                 //  Needed by winbase.h
                                       
#include <windef.h>                 //  DWORD
#include <winbase.h>                //  LocalFree
                                       
#include <rpc.h>                    //  DataTypes and runtime APIs
#include <rpcutil.h>                //  GENERIC_ENUM_STRUCT
                                       
#include <lmcons.h>                 //  NET_API_STATUS
#include <lmerr.h>                  //  NetError codes
#include <lmremutl.h>               //  SUPPORTS_RPC
                                       
#include <netlibnt.h>               //  NetpNtStatusToApiStatus
#include <netdebug.h>               //  NetpDbgPrint
                                       
#include <atsvc.h>                  //  generated by the MIDL complier
#include <atnames.h>                //  Service and interface names


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\at\client\fmt.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    fmt.c

Abstract:

    Example of a test code using FormatMessage() api.

Author:

    Vladimir Z. Vulovic     (vladimv)       06 - November - 1992

Environment:

    User Mode - Win32

Revision History:

    06-Nov-1992     vladimv
        Created

--*/

#include "atclient.h"
#include <stdlib.h>         //  exit()
#include <stdio.h>          // printf
#include <wchar.h>      //  wcslen
//  #include <tstring.h>        //  wcslen
#include <apperr.h>         //  APE_AT_USAGE
#include <apperr2.h>        //  APE2_GEN_MONDAY + APE2_*
#include <lmapibuf.h>       //  NetApiBufferFree


BOOL
DecimalStringToDword(
    IN  CHAR *      pDecimalString,
    OUT PDWORD      pNumber
    )
/*++

    This routine converts a string into a DWORD if it possibly can.
    The conversion is successful if string is decimal numeric and
    does not lead to an overflow.

    pDecimalString      ptr to decimal string
    pNumber             ptr to number
  
    FALSE       invalid number
    TRUE        valid number

--*/
{
    DWORD           Value;
    DWORD           OldValue;
    DWORD           digit;

    if ( pDecimalString == NULL  ||  *pDecimalString == 0) {
        return( FALSE);
    }

    Value = 0;

    while ( (digit = *pDecimalString++) != 0) {

        if ( digit < L'0' || digit > L'9') {
            return( FALSE);     //  not a decimal string
        }

        OldValue = Value;
        Value = digit - L'0' + 10 * Value;
        if ( Value < OldValue) {
            return( FALSE);     //  overflow
        }
    }

    *pNumber = Value;
    return( TRUE);
}


VOID __cdecl
main(
    int         argc,
    CHAR **     argv
    )
{
    LPVOID              lpSource;
    DWORD               length;
    WCHAR               buffer[ 256];
    BOOL                success;
    DWORD               number;
    WCHAR *             strings[ 1];

    if ( argc != 2) {
        printf( "%s", "Usage: fmt error_number\n");
        exit( -1);
    }


    success = DecimalStringToDword( argv[ 1], &number);
    if ( success != TRUE) {
        printf( "Usage: fmt decimal_string_for_error_number\n");
        exit( -1);
    }

    lpSource = LoadLibrary( L"netmsg.dll");
    if ( lpSource == NULL) {
        printf( " LoadLibrary() fails with winError = %d\n", GetLastError());
        exit( -1);
    }

    length = FormatMessage(
            FORMAT_MESSAGE_FROM_HMODULE |   //  dwFlags
                FORMAT_MESSAGE_ARGUMENT_ARRAY,
            lpSource,
            number,                         //  MessageId
            0,                              //  dwLanguageId
            buffer,                         //  lpBuffer
            sizeof( buffer),                //  nSize
            NULL
            );

    if ( length == 0) {
        printf( " FormatMessage() fails with winError = %d\n", GetLastError());
    }

    printf( "%s", buffer);

    if ( number != APE2_GEN_DEFAULT_NO) {
        goto exit;
    }

    strings[ 0] = buffer;

    printf( "\nSpecial case of APE_GEN_DEFAULT_NO inserted in APE_OkToProceed\n");

    length = FormatMessage(
            FORMAT_MESSAGE_FROM_HMODULE |   //  dwFlags
                FORMAT_MESSAGE_ARGUMENT_ARRAY,
            lpSource,
            APE_OkToProceed,                //  MessageId
            0,                              //  dwLanguageId
            buffer,                         //  lpBuffer
            sizeof( buffer),                //  nSize
            (va_list *)strings              //  lpArguments
            );

    if ( length == 0) {
        printf( " FormatMessage() fails with winError = %d\n", GetLastError());
    }

    printf( "%s", buffer);

exit:
    success = FreeLibrary( lpSource);
    if ( success != TRUE) {
        printf( " FreeLibrary() fails with winError = %d\n", GetLastError());
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\at\client\atbind.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    atbind.c

Abstract:

    Routines which use RPC to bind and unbind the client to the schedule
    service.

Author:

    Vladimir Z. Vulovic     (vladimv)       06 - November - 1992

Environment:

    User Mode -Win32

Revision History:

    06-Nov-1992     vladimv
        Created

--*/

#include "atclient.h"


handle_t
ATSVC_HANDLE_bind(
    ATSVC_HANDLE    ServerName
    )

/*++

Routine Description:

    This routine calls a common bind routine that is shared by all services.
    This routine is called from the schedule service client stubs when
    it is necessary to bind to a server.

Arguments:

    ServerName - A pointer to a string containing the name of the server
        to bind with.

Return Value:

    The binding handle is returned to the stub routine.  If the bind is
    unsuccessful, a NULL will be returned.

--*/
{
    handle_t    BindingHandle;
    RPC_STATUS  RpcStatus;

    RpcStatus = NetpBindRpc (
                    (LPTSTR)ServerName,
                    AT_INTERFACE_NAME,
                    0,
                    &BindingHandle
                    );

#ifdef DEBUG
    if ( RpcStatus != ERRROR_SUCCESS) {
        DbgPrint("ATSVC_HANDLE_bind:NetpBindRpc RpcStatus=%d\n",RpcStatus);
    }
    DbgPrint("ATSVC_HANDLE_bind: handle=%d\n", BindingHandle);
#endif

    return( BindingHandle);
}



void
ATSVC_HANDLE_unbind(
    ATSVC_HANDLE    ServerName,
    handle_t        BindingHandle
    )

/*++

Routine Description:

    This routine calls a common unbind routine that is shared by all services.
    This routine is called from the Workstation service client stubs when it is
    necessary to unbind from the server end.

Arguments:

    ServerName - This is the name of the server from which to unbind.

    BindingHandle - This is the binding handle that is to be closed.

Return Value:

    None.

--*/
{
    UNREFERENCED_PARAMETER( ServerName);

#ifdef DEBUG
    DbgPrint(" ATSVC_HANDLE_unbind: handle= 0x%x\n", BindingHandle);
#endif // DEBUG

    NetpUnbindRpc( BindingHandle);
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\at\atcmd\atcmd.c ===
/*++

Copyright (c) 1987-1992  Microsoft Corporation

Module Name:

    atcmd.c

Abstract:

    Code for AT command, to be used with SCHEDULE service on Windows NT.

    The module was taken from LanManager\at.c and then modified considerably
    to work with NT Schedule service.

Author:

    Vladimir Z. Vulovic     (vladimv)       06 - November - 1992

Environment:

    User Mode - Win32

Revision History:

    06-Nov-1992     vladimv
        Created

    20-Feb-1993     yihsins
        Get rid of hard coded strings and parse/print time according
        to user profile

    25-May-1993     RonaldM
        Convert strings to OEM before printing to the console, since
        the console doesn't yet support unicode.

    28-Jun-1993     RonaldM
        Added the "confirm" yes and no strings, which are meant to be
        localised.  The original yes and no strings cannot be localised,
        because this would create batch file incompatibilities.

    07-Jul-1994     vladimv
        Added support for interactive switch.  Replaced "confirm" strings
        with APE2_GEN_* strings - to eliminate redundancy.  The rule is
        that switches are not internationalizable while switch values are.

--*/

#include <nt.h>                 //  DbgPrint prototype
#include <ntrtl.h>              //  DbgPrint
#include <nturtl.h>             //  Needed by winbase.h

#include <windows.h>
#include <winnls.h>
#include <shellapi.h>

#include <lmcons.h>             //  NET_API_STATUS
#include <lmerr.h>              //  NetError codes
#include <icanon.h>             //  NetpNameValidate

#include "lmatmsg.h"            //  private AT error codes & messages
#include <lmat.h>               //  AT_INFO
#include <stdlib.h>             //  exit()
#include <stdio.h>              //  printf
#include <wchar.h>              //  wcslen
#include <apperr.h>             //  APE_AT_USAGE
#include <apperr2.h>            //  APE2_GEN_MONDAY + APE2_*
#include <lmapibuf.h>           //  NetApiBufferFree
#include <timelib.h>            //  NetpGetTimeFormat
#include <luidate.h>            //  LUI_ParseTimeSinceStartOfDay


#define YES_FLAG                0
#define NO_FLAG                 1
#define INVALID_FLAG            -1

#define DUMP_ALL                0
#define DUMP_ID                 1
#define ADD_TO_SCHEDULE         2
#define ADD_ONETIME             3
#define DEL_ID                  4
#define DEL_ALL                 5
#define ACTION_USAGE            6
#define MAX_COMMAND_LEN         (MAX_PATH - 1) // == 259, based on value used in scheduler service for manipulating AT jobs
#define MAX_SCHED_FIELD_LENGTH  24


#define PutNewLine()            GenOutput( TEXT("\n"))
#define PutNewLine2()           GenOutput( TEXT("\n\n"))

#define MAX_MSG_BUFFER      1024

WCHAR   ConBuf[MAX_MSG_BUFFER];

#define GenOutput(fmt)      \
    {wcscpy(ConBuf, fmt);   \
     ConsolePrint(ConBuf, wcslen(ConBuf));}

#define GenOutputArg(fmt, a1)       \
    {wsprintf(ConBuf, fmt, a1); \
     ConsolePrint(ConBuf, wcslen(ConBuf));}
//
//  Formats used by printf.
//
#define DUMP_FMT1       TEXT("%-7.7ws")

//
//  DUMP_FMT2 is chosen so that the most common case (id numbers less than 100)
//  looks good:  two spaces for a number, three spaces for blanks.
//  Larger numbers just like in LM21 will result to shifted display.
//
#define DUMP_FMT2       TEXT("%2d   ")
#define MAX_TIME_FIELD_LENGTH  14
#define DUMP_FMT3       TEXT("%ws")       // for printing JobTime

#define NULLC           L'\0'
#define BLANK           L' '
#define SLASH           L'/'
#define BACKSLASH       L'\\'
#define ELLIPSIS        L"..."

#define QUESTION_SW     L"/?"
#define QUESTION_SW_TOO L"-?"
#define SCHED_TOK_DELIM L","    // string of valid delimiters for days & dates
#define ARG_SEP_CHR     L':'

typedef struct _SEARCH_LIST {
    WCHAR *     String;
    DWORD       MessageId;
    DWORD       Value;
} SEARCH_LIST, *PSEARCH_LIST, *LPSEARCH_LIST;

//
//  All of the values below must be bitmasks.  MatchString() depends on that!
//
#define AT_YES_VALUE         0x0001
#define AT_DELETE_VALUE      0x0002
#define AT_EVERY_VALUE       0x0004
#define AT_NEXT_VALUE        0x0008
#define AT_NO_VALUE          0x0010
#define AT_CONFIRM_YES_VALUE 0x0020
#define AT_CONFIRM_NO_VALUE  0x0040
#define AT_INTERACTIVE       0x0080

SEARCH_LIST    GlobalListTable[] = {
    { NULL,    IDS_YES,         AT_YES_VALUE},
    { NULL,    IDS_DELETE,      AT_DELETE_VALUE},
    { NULL,    IDS_EVERY,       AT_EVERY_VALUE},
    { NULL,    IDS_NEXT,        AT_NEXT_VALUE},
    { NULL,    IDS_NO,          AT_NO_VALUE},
    { NULL,    APE2_GEN_YES,    AT_CONFIRM_YES_VALUE},
    { NULL,    APE2_GEN_NO,     AT_CONFIRM_NO_VALUE},
    { NULL,    IDS_INTERACTIVE, AT_INTERACTIVE},
    { NULL,    0,               0 }
};

SEARCH_LIST    DaysOfWeekSearchList[] = {
    { NULL,    APE2_GEN_MONDAY_ABBREV,     0},
    { NULL,    APE2_GEN_TUESDAY_ABBREV,    1},
    { NULL,    APE2_GEN_WEDNSDAY_ABBREV,   2},
    { NULL,    APE2_GEN_THURSDAY_ABBREV,   3},
    { NULL,    APE2_GEN_FRIDAY_ABBREV,     4},
    { NULL,    APE2_GEN_SATURDAY_ABBREV,   5},
    { NULL,    APE2_TIME_SATURDAY_ABBREV2, 5},
    { NULL,    APE2_GEN_SUNDAY_ABBREV,     6},
    { NULL,    APE2_GEN_MONDAY,            0},
    { NULL,    APE2_GEN_TUESDAY,           1},
    { NULL,    APE2_GEN_WEDNSDAY,          2},
    { NULL,    APE2_GEN_THURSDAY,          3},
    { NULL,    APE2_GEN_FRIDAY,            4},
    { NULL,    APE2_GEN_SATURDAY,          5},
    { NULL,    APE2_GEN_SUNDAY,            6},
    { NULL,    APE2_GEN_NONLOCALIZED_MONDAY_ABBREV,     0},
    { NULL,    APE2_GEN_NONLOCALIZED_TUESDAY_ABBREV,    1},
    { NULL,    APE2_GEN_NONLOCALIZED_WEDNSDAY_ABBREV,   2},
    { NULL,    APE2_GEN_NONLOCALIZED_THURSDAY_ABBREV,   3},
    { NULL,    APE2_GEN_NONLOCALIZED_FRIDAY_ABBREV,     4},
    { NULL,    APE2_GEN_NONLOCALIZED_SATURDAY_ABBREV,   5},
    { NULL,    APE2_GEN_NONLOCALIZED_SATURDAY_ABBREV2,  5},
    { NULL,    APE2_GEN_NONLOCALIZED_SUNDAY_ABBREV,     6},
    { NULL,    APE2_GEN_NONLOCALIZED_MONDAY,            0},
    { NULL,    APE2_GEN_NONLOCALIZED_TUESDAY,           1},
    { NULL,    APE2_GEN_NONLOCALIZED_WEDNSDAY,          2},
    { NULL,    APE2_GEN_NONLOCALIZED_THURSDAY,          3},
    { NULL,    APE2_GEN_NONLOCALIZED_FRIDAY,            4},
    { NULL,    APE2_GEN_NONLOCALIZED_SATURDAY,          5},
    { NULL,    APE2_GEN_NONLOCALIZED_SUNDAY,            6},
    { NULL,    0,             0 }
    };

BOOL
AreYouSure(
    VOID
    );
BOOL
ArgIsServerName(
    WCHAR *     string
    );
BOOL
ArgIsTime(
    IN      WCHAR *     timestr,
    OUT     DWORD_PTR      *pJobTime
    );
BOOL
ArgIsDecimalString(
    IN  WCHAR *  pDecimalString,
    OUT PDWORD   pNumber
    );
DWORD
ConsolePrint(
    IN      LPWSTR  pch,
    IN      int     cch
    );
int
FileIsConsole(
    int     fh
    );
BOOL
IsDayOfMonth(
    IN      WCHAR *     pToken,
    OUT     PDWORD      pDay
    );
BOOL
IsDayOfWeek(
    IN      WCHAR *     pToken,
    OUT     PDWORD      pDay
    );
NET_API_STATUS
JobAdd(
    VOID
    );
NET_API_STATUS
JobEnum(
    VOID
    );
NET_API_STATUS
JobGetInfo(
    VOID
    );
DWORD
MatchString(
    WCHAR *     name,
    DWORD       mask
    );
DWORD
MessageGet(
    IN      DWORD       MessageId,
    IN      LPWSTR      *buffer,
    IN      DWORD       Size
    );
DWORD
MessagePrint(
    IN      DWORD       MessageId,
    ...
    );
BOOL
ParseJobIdArgs(
    WCHAR   **  argv,
    int         argc,
    int         argno,
    PBOOL       pDeleteFound
    );
BOOL
ParseTimeArgs(
    WCHAR **    argv,
    int         argc,
    int         argno,
    int *       pargno
    );
VOID
PrintDay(
    int         type,
    DWORD       DaysOfMonth,
    UCHAR       DaysOfWeek,
    UCHAR       Flags
    );
VOID
PrintLine(
    VOID
    );
VOID
PrintTime(
    DWORD_PTR    JobTime
    );
BOOL
TraverseSearchList(
    PWCHAR          String,
    PSEARCH_LIST    SearchList,
    PDWORD          pValue
    );
VOID
Usage(
    BOOL    GoodCommand
    );
BOOL
ValidateCommand(
    IN  int         argc,
    IN  WCHAR **    argv,
    OUT int *       pCommand
    );

VOID
GetTimeString(
    DWORD_PTR Time,
    WCHAR *Buffer,
    int BufferLength
    );

BOOL
InitList(
    PSEARCH_LIST  SearchList
    );

VOID
TermList(
    PSEARCH_LIST  SearchList
    );

DWORD
GetStringColumn(
    WCHAR *
    );

AT_INFO     GlobalAtInfo;           //  buffer for scheduling new jobs
WCHAR       GlobalAtInfoCommand[ MAX_COMMAND_LEN + 1];

DWORD       GlobalJobId;            //  id of job in question
PWSTR       GlobalServerName;
HANDLE      GlobalMessageHandle;
BOOL        GlobalYes;
BOOL        GlobalDeleteAll;
BOOL        GlobalErrorReported;
BOOL        bDBCS;

CHAR **     GlobalCharArgv;         // keeps original input

NET_TIME_FORMAT GlobalTimeFormat = {0};

//  In OS/2 it used to be OK to call "exit()" with a negative number.  In
//  NT however, "exit()" should be called with a positive number only (a
//  valid windows error code?!).  Note that OS/2 AT command used to call
//  exit(+1) for bad user input, and exit(-1) where -1 would get mapped to
//  255 for other errors.  To keep things simple and to avoid calling exit()
//  with a negative number, NT AT command calls exit(+1) for all possible
//  errors.

#define     AT_GENERIC_ERROR        1


VOID __cdecl
main(
    int         argc,
    CHAR **     charArgv
    )
/*++

Routine Description:

    Main module.  Note that strings (for now) arrive as asciiz even
    if you compile app for UNICODE.

Arguments:

    argc        -   argument count
    charArgv    -   array of ascii strings

Return Value:

    None.

--*/
{
    NET_API_STATUS      status = NERR_Success;
    int                 command;    // what to do
    WCHAR **            argv;
    DWORD               cp;
    CPINFO              CurrentCPInfo;

    GlobalYes = FALSE;
    GlobalDeleteAll = FALSE;
    GlobalErrorReported = FALSE;
    GlobalCharArgv = charArgv;

    /*
       Added for bilingual message support.  This is needed for FormatMessage
       to work correctly.  (Called from DosGetMessage).
       Get current CodePage Info.  We need this to decide whether
       or not to use half-width characters.
    */


    GetCPInfo(cp=GetConsoleOutputCP(), &CurrentCPInfo);
    switch ( cp ) {
	case 932:
	case 936:
	case 949:
	case 950:
	    SetThreadLocale(
		MAKELCID(
		    MAKELANGID(
			    PRIMARYLANGID(GetSystemDefaultLangID()),
			    SUBLANG_ENGLISH_US ),
		    SORT_DEFAULT
		    )
		);
        bDBCS = TRUE;
	    break;

	default:
	    SetThreadLocale(
		MAKELCID(
		    MAKELANGID( LANG_ENGLISH, SUBLANG_ENGLISH_US ),
		    SORT_DEFAULT
		    )
		);
        bDBCS = FALSE;
	    break;
	}

    GlobalMessageHandle = LoadLibrary( L"netmsg.dll");
    if ( GlobalMessageHandle == NULL) {
        MessagePrint( IDS_LOAD_LIBRARY_FAILURE, GetLastError());
        exit( AT_GENERIC_ERROR);
    }

    if ( ( argv = CommandLineToArgvW( GetCommandLineW(), &argc)) == NULL) {
        MessagePrint( IDS_UNABLE_TO_MAP_TO_UNICODE );
        exit( AT_GENERIC_ERROR);
    }

    if ( ValidateCommand( argc, argv, &command) == FALSE) {
        Usage( FALSE);
        exit( AT_GENERIC_ERROR);
    }

    switch( command) {

    case DUMP_ALL:
        status = JobEnum();
        break;

    case DUMP_ID:
        status = JobGetInfo();
        break;

    case ADD_TO_SCHEDULE:
        status = JobAdd();
        break;

    case DEL_ALL:
        if ( AreYouSure() == FALSE) {
            break;
        }
        status = NetScheduleJobDel(
                GlobalServerName,
                0,
                (DWORD)-1
                );
        if ( status == NERR_Success || status == APE_AT_ID_NOT_FOUND) {
            break;
        }
        MessagePrint( status );
        break;

    case DEL_ID:
        status = NetScheduleJobDel(
                GlobalServerName,
                GlobalJobId,
                GlobalJobId
                );
        if ( status == NERR_Success) {
            break;
        }
        MessagePrint( status );
        break;

    case ACTION_USAGE:
        Usage( TRUE);
        status = NERR_Success;
        break;
    }

    TermList( GlobalListTable);
    TermList( DaysOfWeekSearchList);
    LocalFree( GlobalTimeFormat.AMString );
    LocalFree( GlobalTimeFormat.PMString );
    LocalFree( GlobalTimeFormat.DateFormat );
    LocalFree( GlobalTimeFormat.TimeSeparator );
    exit( status == NERR_Success ? ERROR_SUCCESS : AT_GENERIC_ERROR);
}



BOOL
AreYouSure(
    VOID
    )
/*++

Routine Description:

    Make sure user really wants to delete all jobs.

Arguments:

    None.

Return Value:

    TRUE    if user really wants to go ahead.
    FALSE   otherwise.

--*/
{
    register int            retries = 0;
    WCHAR                   rbuf[ 16];
    WCHAR *                 smallBuffer = NULL;
    DWORD                   Value;
    int             cch;
    int             retc;

    if ( GlobalYes == TRUE) {
        return( TRUE);
    }

    if ( MessagePrint( APE2_AT_DEL_WARNING ) == 0) {
        exit( AT_GENERIC_ERROR);
    }

    for ( ; ;) {

        if ( MessageGet(
                    APE2_GEN_DEFAULT_NO,            //  MessageId
                    &smallBuffer,                   //  lpBuffer
                    0
                    ) == 0) {
            exit( AT_GENERIC_ERROR);
        }

        if ( MessagePrint( APE_OkToProceed, smallBuffer) == 0) {
            exit( AT_GENERIC_ERROR);
        }

        LocalFree( smallBuffer );

        if (FileIsConsole(STD_INPUT_HANDLE)) {
            retc = ReadConsole(GetStdHandle(STD_INPUT_HANDLE),rbuf,16,&cch,0);
            if (retc) {
                //
                // Get rid of cr/lf
                //
                if (wcschr(rbuf, TEXT('\r')) == NULL) {
                    if (wcschr(rbuf, TEXT('\n')))
                    *wcschr(rbuf, TEXT('\n')) = NULLC;
                }
                else
                    *wcschr(rbuf, TEXT('\r')) = NULLC;
            }
        }
        else {
            CHAR oemBuf[ 16 ];

            retc = (fgets(oemBuf, 16, stdin) != 0);
#if DBG
            fprintf(stderr, "got >%s<\n", oemBuf);
#endif
            cch = 0;
            if (retc) {
                if (strchr(oemBuf, '\n')) {
                    *strchr(oemBuf, '\n') = '\0';
                }
                cch = MultiByteToWideChar(CP_OEMCP, MB_PRECOMPOSED,
                            oemBuf, strlen(oemBuf)+1, rbuf, 16);
            }
        }

#if DBG
        fprintf(stderr, "cch = %d, retc = %d\n", cch, retc);
#endif
        if (!retc || cch == 0)
            return( FALSE);
#if DBG
        fprintf(stderr, "converted to >%ws<\n", rbuf);
#endif

        Value = MatchString(_wcsupr(rbuf), AT_CONFIRM_NO_VALUE | AT_CONFIRM_YES_VALUE);

        if ( Value == AT_CONFIRM_NO_VALUE) {
            return( FALSE);
        } else if ( Value == AT_CONFIRM_YES_VALUE) {
            break;
        }

        if ( ++retries >= 3) {
            MessagePrint( APE_NoGoodResponse );
            return( FALSE);
        }

        if ( MessagePrint( APE_UtilInvalidResponse ) == 0) {
            exit( AT_GENERIC_ERROR);
        }
    }
    return( TRUE);
}



BOOL
ArgIsServerName(
    WCHAR *     string
    )
/*++

Routine Description:

    Checks if string is a server name.  Validation is really primitive, eg
    strings like "\\\threeslashes" pass the test.

Arguments:

    string  -   pointer to string that may represent a server name

Return Value:

    TRUE    -   string is (or might be) a valid server name
    FALSE   -   string is not a valid server name

--*/
{

    NET_API_STATUS ApiStatus;

    if (string[0] == BACKSLASH && string[1] == BACKSLASH && string[2] != 0) {
        ApiStatus = NetpNameValidate(
                NULL,               // no server name.
                &string[2],         // name to validate
                NAMETYPE_COMPUTER,
                LM2X_COMPATIBLE);       // flags
        if (ApiStatus != NO_ERROR) {
            return (FALSE);
        }
        GlobalServerName = string;
        return( TRUE);
    }

    return( FALSE); // GlobalServerName is NULL at load time
}



BOOL
ArgIsTime(
    IN      WCHAR *     timestr,
    OUT     DWORD_PTR     *pJobTime
    )
/*++

Routine Description:

    Determines whether string is a time or not.  Validates that string
    passed into it is in the form of HH:MM.  It searches the string for
    a ":" and then validates that the preceeding data is numeric & in a
    valid range for hours.  It then validates the string after the ":"
    is numeric & in a validate range for minutes.  If all the tests are
    passed the TRUE is returned.

Arguments:

    timestr     -   string to check whether it is a time
    JobTime     -   ptr to number of miliseconds

Return Value:

    TRUE        -   timestr was a time in HH:MM format
    FALSE       -   timestr wasn't at time

--*/
{
    CHAR        buffer[MAX_TIME_SIZE];
    USHORT      ParseLen;
    BOOL        fDummy;

    if ( timestr == NULL )
        return FALSE;

    if (  !WideCharToMultiByte( CP_ACP,
                                0,
                                timestr,
                                -1,
                                buffer,
                                sizeof( buffer )/sizeof(CHAR),
                                NULL,
                                &fDummy ))
    {
        return FALSE;
    }

    if ( LUI_ParseTimeSinceStartOfDay( buffer, pJobTime, &ParseLen, 0) )
        return FALSE;

    // LUI_ParseTimeSinceStartOfDay returns the time in seconds.
    // Hence, we need to convert it to microseconds.
    *pJobTime *= 1000;

    return( TRUE);
}



BOOL
ArgIsDecimalString(
    IN  WCHAR *     pDecimalString,
    OUT PDWORD      pNumber
    )
/*++

Routine Description:

    This routine converts a string into a DWORD if it possibly can.
    The conversion is successful if string is decimal numeric and
    does not lead to an overflow.

Arguments:

    pDecimalString      ptr to decimal string
    pNumber             ptr to number

Return Value:

    FALSE       invalid number
    TRUE        valid number

--*/
{
    DWORD           Value;
    DWORD           OldValue;
    DWORD           digit;

    if ( pDecimalString == NULL  ||  *pDecimalString == 0) {
        return( FALSE);
    }

    Value = 0;

    while ( (digit = *pDecimalString++) != 0) {

        if ( digit < L'0' || digit > L'9') {
            return( FALSE);     //  not a decimal string
        }

        OldValue = Value;
        Value = digit - L'0' + 10 * Value;
        if ( Value < OldValue) {
            return( FALSE);     //  overflow
        }
    }

    *pNumber = Value;
    return( TRUE);
}



BOOL
IsDayOfMonth(
    IN      WCHAR *     pToken,
    OUT     PDWORD      pDay
    )
/*++

Routine Description:

    Converts a string into a number for the day of the month, if it can
    possibly do so.  Note that "first" == 1, ...

Arguments:

    pToken      pointer to schedule token for the day of the month
    pDay        pointer to index of day in a month

Return Value:

    TRUE        if a valid schedule token
    FALSE       otherwise

--*/
{
    return ( ArgIsDecimalString( pToken, pDay) == TRUE  &&  *pDay >= 1
                &&  *pDay <= 31);
}



BOOL
IsDayOfWeek(
    WCHAR *     pToken,
    PDWORD      pDay
    )
/*++

Routine Description:

    This routine converts a string day of the week into a integer
    offset into the week if it possibly can.  Note that Monday==0,
    ..., Sunday == 6.

Arguments:

    pToken      pointer to schedule token for the day of a week
    pDay        pointer to index of day in a month

Return Value:

    TRUE        if a valid schedule token
    FALSE       otherwise

--*/
{
    if ( !InitList( DaysOfWeekSearchList ) )
    {
        // Error already reported
        exit( -1 );
    }

    return( TraverseSearchList(
                pToken,
                DaysOfWeekSearchList,
                pDay
                ));
}



NET_API_STATUS
JobAdd(
    VOID
    )
/*++

Routine Description:

    Adds a new item to schedule.

Arguments:

    None.  Uses globals.

Return Value:

    NET_API_STATUS return value of remote api call

--*/
{
    NET_API_STATUS          status;

    for ( ; ; ) {
        status = NetScheduleJobAdd(
                GlobalServerName,
                (LPBYTE)&GlobalAtInfo,
                &GlobalJobId
                );
        if ( status == ERROR_INVALID_PARAMETER  &&
                GlobalAtInfo.Flags & JOB_NONINTERACTIVE) {
            //
            //  We may have failed because we are talking to a down level
            //  server that does not know about JOB_NONINTERACTIVE bit.
            //  Clear the bit, and try again.
            //  A better approach would be to check the version of the
            //  server before making NetScheduleJobAdd() call, adjust the
            //  bit appropriately and only then call NetScheduleJobAdd().
            //
            GlobalAtInfo.Flags &= ~JOB_NONINTERACTIVE;
        } else {
            break;
        }

    }
    if ( status == NERR_Success) {
        MessagePrint( IDS_ADD_NEW_JOB, GlobalJobId );
    } else {
        if ( MessagePrint( status ) == 0) {
            exit( AT_GENERIC_ERROR);
        }
    }

    return( status);
}



NET_API_STATUS
JobEnum(
    VOID
    )
/*++

Routine Description:

    This does all of the processing necessary to dump out the entire
    schedule file.  It loops through on each record and formats its
    information for printing and then goes to the next.

Arguments:

    None.  Uses globals.

Return Value:

    ERROR_SUCCESS                       if everything enumerated OK
    error returned by remote api        otherwise

--*/
{
    BOOL            first = TRUE;
    DWORD           ResumeJobId = 0;
    NET_API_STATUS  status = NERR_Success;
    PAT_ENUM        pAtEnum;
    DWORD           EntriesRead;
    DWORD           TotalEntries;
    LPVOID          EnumBuffer;
    DWORD           length;
    WCHAR *         smallBuffer = NULL;

    for ( ; ;) {

        status = NetScheduleJobEnum(
                GlobalServerName,
                (LPBYTE *)&EnumBuffer,
                (DWORD)-1,
                &EntriesRead,
                &TotalEntries,
                &ResumeJobId
                );

        if ( status != ERROR_SUCCESS  &&  status != ERROR_MORE_DATA) {
            length = MessagePrint( status );
            if ( length == 0) {
                exit( AT_GENERIC_ERROR);
            }
            return( status);
        }

        ASSERT( status == ERROR_SUCCESS ? TotalEntries == EntriesRead
                    : TotalEntries > EntriesRead);

        if ( TotalEntries == 0) {
            break;  //  no items found
        }

        if ( first == TRUE) {
            length = MessagePrint( APE2_AT_DUMP_HEADER );
            if ( length == 0) {
                exit( AT_GENERIC_ERROR);
            }
            PrintLine();    //  line across screen
            first = FALSE;
        }

        for ( pAtEnum = EnumBuffer;  EntriesRead-- > 0;  pAtEnum++) {
            if ( pAtEnum->Flags & JOB_EXEC_ERROR) {
                if ( MessageGet( APE2_GEN_ERROR, &smallBuffer, 0 ) == 0) {
                    // error reported already
                    exit( AT_GENERIC_ERROR);
                }
                GenOutputArg( DUMP_FMT1, smallBuffer );
                LocalFree( smallBuffer );
            } else {
                GenOutputArg( DUMP_FMT1, L"");
            }
            GenOutputArg( DUMP_FMT2, pAtEnum->JobId);
            PrintDay( DUMP_ALL, pAtEnum->DaysOfMonth, pAtEnum->DaysOfWeek,
                            pAtEnum->Flags);
            PrintTime( pAtEnum->JobTime);
            GenOutputArg( TEXT("%ws\n"), pAtEnum->Command);
        }

        if ( EnumBuffer != NULL) {
            (VOID)NetApiBufferFree( (LPVOID)EnumBuffer);
            EnumBuffer = NULL;
        }

        if ( status == ERROR_SUCCESS) {
            break;  //  we have read & displayed all the items
        }
    }

    if ( first == TRUE) {
        MessagePrint( APE_EmptyList );
    }

    return( ERROR_SUCCESS);
}



NET_API_STATUS
JobGetInfo(
    VOID
    )
/*++

Routine Description:

    This prints out the schedule of an individual items schedule.

Arguments:

    None.  Uses globals.

Return Value:

    NET_API_STATUS value returned by remote api

--*/

{
    PAT_INFO                pAtInfo = NULL;
    NET_API_STATUS          status;

    status = NetScheduleJobGetInfo(
            GlobalServerName,
            GlobalJobId,
            (LPBYTE *)&pAtInfo
            );
    if ( status != NERR_Success) {
        MessagePrint( status );
        return( status);
    }

    PutNewLine();
    MessagePrint( APE2_AT_DI_TASK );
    GenOutputArg( TEXT("%d"), GlobalJobId);
    PutNewLine();

    MessagePrint( APE2_AT_DI_STATUS );
    MessagePrint( (pAtInfo->Flags & JOB_EXEC_ERROR) != 0 ?
                  APE2_GEN_ERROR : APE2_GEN_OK );
    PutNewLine();

    MessagePrint( APE2_AT_DI_SCHEDULE );
    PrintDay( DUMP_ID, pAtInfo->DaysOfMonth, pAtInfo->DaysOfWeek,
                    pAtInfo->Flags);
    PutNewLine();

    MessagePrint( APE2_AT_DI_TIMEOFDAY );
    PrintTime( pAtInfo->JobTime);
    PutNewLine();

    MessagePrint( APE2_AT_DI_INTERACTIVE);
    MessagePrint( (pAtInfo->Flags & JOB_NONINTERACTIVE) == 0 ?
                  APE2_GEN_YES : APE2_GEN_NO );
    PutNewLine();

    MessagePrint( APE2_AT_DI_COMMAND );
    GenOutputArg( TEXT("%ws\n"), pAtInfo->Command);
    PutNewLine2();

    (VOID)NetApiBufferFree( (LPVOID)pAtInfo);

    return( NERR_Success);
}



DWORD
MatchString(
    WCHAR *     name,
    DWORD       Values
    )
/*++
Routine Description:

    Parses switch string and returns NULL for an invalid switch,
    and -1 for an ambiguous switch.

Arguments:

    name    -   pointer to string we need to examine
    Values  -   bitmask of values of interest

Return Value:

    Pointer to command, or NULL or -1.
--*/
{
    WCHAR *         String;
    PSEARCH_LIST    pCurrentList;
    WCHAR *         CurrentString;
    DWORD           FoundValue;
    int             nmatches;
    int             longest;

    if ( !InitList( GlobalListTable ) )
    {
        // Error already reported
        exit( -1 );
    }

    for ( pCurrentList = GlobalListTable,
          longest = nmatches = 0,
          FoundValue = 0;
                (CurrentString = pCurrentList->String) != NULL;
                        pCurrentList++) {

        if ( (Values & pCurrentList->Value) == 0) {
            continue; // skip this List
        }

        for ( String = name; *String == *CurrentString++; String++) {
            if ( *String == 0) {
                return( pCurrentList->Value); // exact match
            }
        }

        if ( !*String) {

            if ( String - name > longest) {

                longest = (int)(String - name);
                nmatches = 1;
                FoundValue = pCurrentList->Value;

            } else if ( String - name == longest) {

                nmatches++;
            }
        }
    }

    //  0 corresponds to no match at all (invalid List)
    //  while -1 corresponds to multiple match (ambiguous List).

    if ( nmatches != 1) {
        return ( (nmatches == 0) ? 0 : -1);
    }

    return( FoundValue);
}


DWORD
MessageGet(
    IN      DWORD        MessageId,
    OUT     LPWSTR      *buffer,
    IN      DWORD        Size
    )
/*++

Routine Description:

    Fills in the unicode message corresponding to a given message id,
    provided that a message can be found and that it fits in a supplied
    buffer.

Arguments:

    MessageId   -   message id
    buffer      -   pointer to caller supplied buffer
    Size        -   size (always in bytes) of supplied buffer,
                    If size is 0, buffer will be allocated by FormatMessage.

Return Value:

    Count of characters, not counting the terminating null character,
    returned in the buffer.  Zero return value indicates failure.

--*/
{
    DWORD               length;
    LPVOID              lpSource;
    DWORD               dwFlags;

    if ( MessageId < NERR_BASE) {
        //
        //  Get message from system.
        //
        lpSource = NULL; // redundant step according to FormatMessage() spec
        dwFlags = FORMAT_MESSAGE_FROM_SYSTEM;

    } else if (  ( MessageId >= APE2_AT_DEL_WARNING
                    &&  MessageId <= APE2_AT_DI_INTERACTIVE)
              || ( MessageId >= IDS_LOAD_LIBRARY_FAILURE
                    &&  MessageId <= IDS_INTERACTIVE )) {
        //
        //  Get message from this module.
        //
        lpSource = NULL;
        dwFlags = FORMAT_MESSAGE_FROM_HMODULE;

    } else {
        //
        //  Get message from netmsg.dll.
        //
        lpSource = GlobalMessageHandle;
        dwFlags = FORMAT_MESSAGE_FROM_HMODULE;
    }

    if ( Size == 0 )
        dwFlags |= FORMAT_MESSAGE_ALLOCATE_BUFFER;

    length = FormatMessage(
            dwFlags,                        //  dwFlags
            lpSource,                       //  lpSource
            MessageId,                      //  MessageId
            0,                              //  dwLanguageId
            (LPWSTR) buffer,                //  lpBuffer
            Size,                           //  nSize
            NULL                            //  lpArguments
            );

    if ( length == 0) {
        MessagePrint( IDS_MESSAGE_GET_ERROR, MessageId, GetLastError());
    }
    return( length);

} // MessageGet()



int
FileIsConsole(
    int     fh
    )
{
    unsigned htype ;

    htype = GetFileType(GetStdHandle(fh));
    htype &= ~FILE_TYPE_REMOTE;
    return htype == FILE_TYPE_CHAR;
}



DWORD
ConsolePrint(
    LPWSTR  pch,
    int     cch
    )
{
    int     cchOut;
    int     err;
    CHAR    *pchOemBuffer;

    if (FileIsConsole(STD_OUTPUT_HANDLE)) {
    err = WriteConsole(
            GetStdHandle(STD_OUTPUT_HANDLE),
            pch, cch,
            &cchOut, NULL);
    if (!err || cchOut != cch)
        goto try_again;
    }
    else if ( cch != 0) {
try_again:
    cchOut = WideCharToMultiByte(CP_OEMCP, 0, pch, cch, NULL, 0, NULL,NULL);
    if (cchOut == 0)
        return 0;

    if ((pchOemBuffer = (CHAR *)malloc(cchOut)) != NULL) {
        WideCharToMultiByte(CP_OEMCP, 0, pch, cch,
            pchOemBuffer, cchOut, NULL, NULL);
        WriteFile(GetStdHandle(STD_OUTPUT_HANDLE),
            pchOemBuffer, cchOut, &cch, NULL);
        free(pchOemBuffer);
    }
    }
    return cchOut;
}



DWORD
MessagePrint(
    IN      DWORD       MessageId,
    ...
    )
/*++

Routine Description:

    Finds the unicode message corresponding to the supplied message id,
    merges it with caller supplied string(s), and prints the resulting
    string.

Arguments:

    MessageId       -   message id

Return Value:

    Count of characters, not counting the terminating null character,
    printed by this routine.  Zero return value indicates failure.

--*/
{
    va_list             arglist;
    WCHAR *             buffer = NULL;
    DWORD               length;
    LPVOID              lpSource;
    DWORD               dwFlags = FORMAT_MESSAGE_ALLOCATE_BUFFER;


    va_start( arglist, MessageId );

    if ( MessageId < NERR_BASE) {
        //
        //  Get message from system.
        //
        lpSource = NULL; // redundant step according to FormatMessage() spec
        dwFlags |= FORMAT_MESSAGE_FROM_SYSTEM;

    } else if (  ( MessageId >= APE2_AT_DEL_WARNING
                    &&  MessageId <= APE2_AT_DI_INTERACTIVE)
              || ( MessageId >= IDS_LOAD_LIBRARY_FAILURE
                    &&  MessageId <= IDS_INTERACTIVE )) {
        //
        //  Get message from this module.
        //
        lpSource = NULL;
        dwFlags |= FORMAT_MESSAGE_FROM_HMODULE;

    } else {
        //
        //  Get message from netmsg.dll.
        //
        lpSource = GlobalMessageHandle;
        dwFlags |= FORMAT_MESSAGE_FROM_HMODULE;
    }

    length = FormatMessage(
            dwFlags,                                          //  dwFlags
            lpSource,                                         //  lpSource
            MessageId,                                        //  MessageId
            0L,                                               //  dwLanguageId
            (LPTSTR)&buffer,                                  //  lpBuffer
            0,                                                //  size
            &arglist                                          //  lpArguments
            );

    length = ConsolePrint(buffer, length);

    LocalFree(buffer);

    return( length);

} // MessagePrint()



BOOL
ParseJobIdArgs(
    WCHAR   **  argv,
    int         argc,
    int         argno,
    PBOOL       pDeleteFound
    )
/*++

Routine Description:

    Parses arguments for commands containing JobId (these can be JobGetInfo
    and JobDel commands).  It loops through JobId arguments making sure that
    we have at most one "yes-no" switch and at most one "delete" switch and
    nothing else.

Arguments:

    argv            argument list
    argc            number of arguments to parse
    argno           index of argument to begin parsing from
    pDeleteFound    did we find a delete switch or not

Return Value:

    FALSE          invalid argument found
    TRUE           valid arguments

--*/
{
    BOOL        FoundDeleteSwitch;

    for (  FoundDeleteSwitch = FALSE;  argno < argc;  argno++) {

        WCHAR *     argp;
        DWORD       length;
        DWORD       Value;

        argp = argv[ argno];

        if ( *argp++ != SLASH) {
            return( FALSE);     //  not a switch
        }

        _wcsupr( argp);
        length = wcslen( argp);

        Value = MatchString( argp, AT_YES_VALUE | AT_DELETE_VALUE);

        if ( Value == AT_YES_VALUE) {

            if ( GlobalYes == TRUE) {
                return( FALSE);        // multiple instances of yes switch
            }

            GlobalYes = TRUE;
            continue;
        }

        if ( Value == AT_DELETE_VALUE) {

            if ( FoundDeleteSwitch == TRUE) {
                return( FALSE);     //  duplicate delete switch
            }
            FoundDeleteSwitch = TRUE;
            continue;
        }

        return( FALSE);     // an unknown switch
    }

    *pDeleteFound = FoundDeleteSwitch;
    return( TRUE);
} // ParseJobIdArgs()



BOOL
ParseTimeArgs(
    WCHAR **    argv,
    int         argc,
    int         argno,
    int *       pargno
    )
/*++

Routine Description:

    Parses arguments for command addition.

Arguments:

    argv    argument list
    argc    count of args
    argno   index of the first arg to validate
    pargno  ptr to the index of the first non-switch arg

Return Value:

    TRUE            all arguments are valid
    FALSE           otherwise

--*/
{
    DWORD       day_no;             //  day number for scheduling
    DWORD       NextCount = 0;      //  count of next switches
    DWORD       EveryCount = 0;     //  count of every switches
    WCHAR *     argp;               //  ptr to arg string
    WCHAR *     schedp;             //  work ptr to arg string
    DWORD       Value;              //  bitmask

    for (  NOTHING;  argno < argc;  argno++) {

        argp = argv[ argno];

        if ( *argp++ != SLASH) {
            break; // found non-switch, we are done
        }


        schedp = wcschr( argp, ARG_SEP_CHR);

        if ( schedp == NULL) {
            return( FALSE);
        }

        _wcsupr( argp); // upper case entire input, not just the switch name

        *schedp = 0;

        Value = MatchString( argp, AT_NEXT_VALUE | AT_EVERY_VALUE);

        if ( Value == AT_NEXT_VALUE) {

            NextCount++;

        } else if ( Value == AT_EVERY_VALUE) {

            EveryCount++;
            GlobalAtInfo.Flags |= JOB_RUN_PERIODICALLY;

        } else {

            return( FALSE); // an unexpected switch
        }

        if ( NextCount + EveryCount > 1) {
            return( FALSE); // repeated switch option
        }

        *schedp++ = ARG_SEP_CHR;

        schedp = wcstok( schedp, SCHED_TOK_DELIM);

        if ( schedp == NULL) {
            GlobalAtInfo.Flags |= JOB_ADD_CURRENT_DATE;
            continue;
        }

        while( schedp != NULL) {

            if ( IsDayOfMonth( schedp, &day_no) == TRUE) {

                GlobalAtInfo.DaysOfMonth |= (1 << (day_no - 1));

            } else if ( IsDayOfWeek( schedp, &day_no) == TRUE) {

                GlobalAtInfo.DaysOfWeek |= (1 << day_no);

            } else {
                MessagePrint( APE_InvalidSwitchArg );
                GlobalErrorReported = TRUE;
                return( FALSE);
            }

            schedp = wcstok( NULL, SCHED_TOK_DELIM);
        }
    }

    if ( argno == argc) {
        return( FALSE); // all switches, no command
    }

    *pargno = argno;
    return( TRUE);
}



BOOL
ParseInteractiveArg(
    IN  OUT     WCHAR *     argp
    )
/*++

Routine Description:

    Returns TRUE if argp is an interactive switch.

--*/
{
    DWORD       Value;              //  bitmask

    if ( *argp++ != SLASH) {
        return( FALSE);     // not a switch
    }

    _wcsupr( argp); // all AT command switches can be safely uppercased

    Value = MatchString( argp, AT_INTERACTIVE);

    if ( Value == AT_INTERACTIVE) {
        GlobalAtInfo.Flags &= ~JOB_NONINTERACTIVE;  // clear noninteractive flag
        return( TRUE);
    }

    return( FALSE); // some other switch
}



VOID
PrintDay(
    int         type,
    DWORD       DaysOfMonth,
    UCHAR       DaysOfWeek,
    UCHAR       Flags
    )
/*++

Routine Description:

    Print out schedule days.  This routine converts a schedule bit map
    to the literals that  represent the schedule.

Arguments:

    type            whether this is for JobEnum or not
    DaysOfMonth     bitmask for days of month
    DaysOfWeek      bitmaks for days of week
    Flags           extra info about the job

Return Value:

    None.

--*/
{
    int             i;
    WCHAR           Buffer[ 128];
    DWORD           BufferLength;
    DWORD           Length;
    DWORD           TotalLength = 0;
    DWORD           TotalColumnLength = 0;
    WCHAR *         LastSpace;
    DWORD           MessageId;
    BOOL            OverFlow = TRUE;
    static int      Ape2GenWeekdayLong[] = {
        APE2_GEN_MONDAY,
        APE2_GEN_TUESDAY,
        APE2_GEN_WEDNSDAY,
        APE2_GEN_THURSDAY,
        APE2_GEN_FRIDAY,
        APE2_GEN_SATURDAY,
        APE2_GEN_SUNDAY
    };
    static int      Ape2GenWeekdayAbbrev[] = {
        APE2_GEN_MONDAY_ABBREV,
        APE2_GEN_TUESDAY_ABBREV,
        APE2_GEN_WEDNSDAY_ABBREV,
        APE2_GEN_THURSDAY_ABBREV,
        APE2_GEN_FRIDAY_ABBREV,
        APE2_GEN_SATURDAY_ABBREV,
        APE2_GEN_SUNDAY_ABBREV
    };

    //
    //  Subtract 4 to guard against days of week or days of month overflow.
    //
    BufferLength = sizeof( Buffer)/ sizeof( WCHAR) - 4;
    if ( type == DUMP_ALL  &&  BufferLength > MAX_SCHED_FIELD_LENGTH) {
        BufferLength = MAX_SCHED_FIELD_LENGTH;
    }

    //
    //  First do the descriptive bit (eg. EACH, NEXT, etc) with the days.
    //

    if ( Flags & JOB_RUN_PERIODICALLY) {

        MessageId = APE2_AT_EACH;

    } else if ( (DaysOfWeek != 0) || (DaysOfMonth != 0)) {

        MessageId = APE2_AT_NEXT;

    } else if ( Flags & JOB_RUNS_TODAY) {

        MessageId = APE2_AT_TODAY;

    } else {

        MessageId = APE2_AT_TOMORROW;
    }

    Length = MessageGet(
            MessageId,
            (LPWSTR *) &Buffer[TotalLength],
            BufferLength
            );
    if ( Length == 0) {
        goto PrintDay_exit; // Assume this is due to lack of space
    }
    TotalColumnLength = GetStringColumn( &Buffer[TotalLength] );
    TotalLength = Length;

    if ( DaysOfWeek != 0) {

        for ( i = 0; i < 7; i++) {

            if ( ( DaysOfWeek & (1 << i)) != 0) {

                if( bDBCS ) {
                    Length = MessageGet(
                                Ape2GenWeekdayLong[ i],
                                (LPWSTR *) &Buffer[TotalLength],
                                BufferLength - TotalLength
                                );
                } else {
                    Length = MessageGet(
                                Ape2GenWeekdayAbbrev[ i],
                                (LPWSTR *) &Buffer[TotalLength],
                                BufferLength - TotalLength
                                );
                }
                if ( Length == 0) {
                    //
                    //  Not enough room for WeekDay symbol
                    //
                    goto PrintDay_exit;

                }
                //
                // Get how many columns will be needed for display.
                //
                TotalColumnLength += GetStringColumn( &Buffer[TotalLength] );

                if ( TotalColumnLength >= BufferLength) {
                    //
                    //  Not enough room for space following WeekDay symbol
                    //
                    goto PrintDay_exit;
                }
                TotalLength +=Length;
                Buffer[ TotalLength++] = BLANK;
                TotalColumnLength++;
            }
        }
    }

    if ( DaysOfMonth != 0) {

        for ( i = 0; i < 31; i++) {

            if ( ( DaysOfMonth & (1L << i)) != 0) {

                Length = swprintf(
                        &Buffer[ TotalLength],
                        L"%d ",
                        i + 1
                        );
                if ( TotalLength + Length > BufferLength) {
                    //
                    //  Not enough room for MonthDay symbol followed by space
                    //
                    goto PrintDay_exit;
                }
                TotalLength +=Length;
                TotalColumnLength +=Length;
            }
        }
    }

    OverFlow = FALSE;

PrintDay_exit:

    Buffer[ TotalLength] = NULLC;

    if ( OverFlow == TRUE) {

        if ( TotalLength > 0  &&  Buffer[ TotalLength - 1] == BLANK) {
            //
            //  Eliminate trailing space if there is one.
            //
            Buffer[ TotalLength - 1] = NULLC;
        }

        //
        //  Then get rid of the rightmost token (or even whole thing).
        //

        LastSpace = wcsrchr( Buffer, BLANK);

        wcscpy( LastSpace != NULL ? LastSpace : Buffer, ELLIPSIS);

        TotalLength = wcslen( Buffer);

    }

    if ( type == DUMP_ALL) {
        while( TotalColumnLength++ < MAX_SCHED_FIELD_LENGTH) {
            Buffer[ TotalLength++] = BLANK;
        }
        Buffer[ TotalLength] = UNICODE_NULL;
    }

    GenOutputArg( TEXT("%ws"), Buffer);
}


VOID
PrintLine(
    VOID
    )
/*++

Routine Description:

    Prints a line accross screen.

Arguments:

    None.

Return Value:

    None.

Note:

    BUGBUG  Is this treatment valid for UniCode?  See also LUI_PrintLine()
    BUGBUG  in ui\common\src\lui\lui\border.c

--*/
#define SINGLE_HORIZONTAL       L'\x02d'
#define SCREEN_WIDTH            79
{
    WCHAR       string[ SCREEN_WIDTH + 1];
    DWORD       offset;


    for (  offset = 0;  offset < SCREEN_WIDTH;  offset++) {
        string[ offset] = SINGLE_HORIZONTAL;
    }

    string[ SCREEN_WIDTH] = NULLC;
    GenOutputArg(TEXT("%ws\n"), string);
}


VOID
PrintTime(
    DWORD_PTR      JobTime
    )
/*++

Routine Description:

    Prints time of a job in HH:MM{A,P}M format.

Arguments:

    JobTime     -   time in miliseconds (measured from midnight)

Return Value:

    None.

Note:

    BUGBUG      this does not make sure that JobTime is within the bounds.
    BUGBUG      Also, there is nothing unicode about printing this output.

--*/
{
    WCHAR       Buffer[15];

    GetTimeString( JobTime, Buffer, sizeof( Buffer)/sizeof( WCHAR) );
    GenOutputArg( DUMP_FMT3, Buffer );
}



BOOL
TraverseSearchList(
    IN      PWCHAR          String,
    IN      PSEARCH_LIST    SearchList,
    OUT     PDWORD          pValue
    )
/*++

Routine Description:

    Examines search list until it find the correct entry, then returns
    the value corresponding to this entry.

Arguments:

    String          -   string to match
    SearchList      -   array of entries containing valid strings
    pValue          -   value corresponding to a matching valid string

Return Value:

    TRUE        a matching entry was found
    FALSE       otherwise

--*/
{
    if ( SearchList != NULL) {

        for ( NOTHING;  SearchList->String != NULL;  SearchList++) {

            if ( _wcsicmp( String, SearchList->String) == 0) {
                *pValue = SearchList->Value;
                return( TRUE) ;
            }
        }
    }
    return( FALSE) ;
}



VOID
Usage(
    BOOL    GoodCommand
    )
/*++

Routine Description:

    Usage of AT command.

Arguments:

    GoodCommand -   TRUE if we have a good command input (request for help)
                    FALSE if we have a bad command input

Return Value:

    None.

--*/
{
    if ( GlobalErrorReported == TRUE) {
        PutNewLine();
    } else if ( GoodCommand == FALSE) {
        MessagePrint( IDS_INVALID_COMMAND );
    }

    MessagePrint( IDS_USAGE );
}

#define REG_SCHEDULE_PARMS TEXT("System\\CurrentControlSet\\Services\\Schedule\\Parameters")

#define REG_SCHEDULE_USE_OLD TEXT("UseOldParsing")

BOOL
UseOldParsing()
/*++

Routine Description:

    Checks the registry for

    HKLM\CurrentControlSet\Services\Schedule\parameters\UseOldParsing

    If present and equal to 1, then revert to 3.51 level of command line
    parsing.  Spaces in filenames will not work with this option.  This is
    intended as a migration path for customers who cannot change all their
    command scripts that use AT.EXE right away.

--*/
{
    BOOL fUseOld = FALSE;
    LONG err = 0;

    do { // Error breakout loop

        HKEY hkeyScheduleParms;
        DWORD dwType;
        DWORD dwData = 0;
        DWORD cbData = sizeof(dwData);

        // Break out on any error and use the default, FALSE.

        if (err = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                               REG_SCHEDULE_PARMS,
                               0,
                               KEY_READ,
                               &hkeyScheduleParms))
        {
            break;
        }
        if (err = RegQueryValueEx(hkeyScheduleParms,
                                  REG_SCHEDULE_USE_OLD,
                                  NULL,
                                  &dwType,
                                  (LPBYTE)&dwData,
                                  &cbData ))
        {
            RegCloseKey( hkeyScheduleParms );
            break;
        }

        if ( dwType == REG_DWORD && dwData == 1 )
        {
            fUseOld = TRUE;
        }

        RegCloseKey( hkeyScheduleParms );


    } while (FALSE) ;

    return fUseOld;

}



BOOL
ValidateCommand(
    IN  int         argc,
    IN  WCHAR **    argv,
    OUT int *       pCommand
    )
/*++

Routine Description:

    Examines command line to see what to do.  This validates the command
    line passed into the AT command processor.  If this routine finds any
    invalid data, the program exits with an appropriate error message.

Arguments:

    pCommand    -   pointer to command
    argc        -   count of arguments
    argv        -   pointer to table of arguments

Return Value:

    FALSE    -     if failure, i.e. command will not be executed
    TRUE     -     if success

Comment:

    Parsing assumes:

    non-switch (positional) parameters come first and order among these
        parameters is important

    switch parameters come second and order among these parameters is
        NOT important

    command (if present) comes last

--*/
{
    int     i;                  //  loop index
    int     next;               //  index of Time or JobId argument
    int     argno;              //  where to start in arg string
    BOOL    DeleteFound;        //  did we find a delete switch
    WCHAR * recdatap;           //  ptr used to build atr_command
    DWORD   recdata_len;        //  len of arg to put in atr_command
    DWORD_PTR   JobTime;
    BOOL    fUseOldParsing = FALSE;

    if (argc == 1) {
       *pCommand = DUMP_ALL;
       return( TRUE);
    }

    //  First look for a help switch on the command line.

    for ( i = 1; i < argc; i++ ) {

        if ( !_wcsicmp( argv[i], QUESTION_SW)
                    ||  !_wcsicmp( argv[i], QUESTION_SW_TOO)) {

            *pCommand = ACTION_USAGE;
            return( TRUE);
        }
    }

    next = ( ArgIsServerName( argv[ 1]) == TRUE) ? 2 : 1;
    if ( argc == next) {
       *pCommand = DUMP_ALL;
       return( TRUE);
    }

    if ( (ArgIsDecimalString( argv[ next], &GlobalJobId)) == TRUE) {

        if ( argc == next + 1) {
            *pCommand = DUMP_ID;
            return( TRUE);
        }

        if ( ParseJobIdArgs( argv, argc, next + 1, &DeleteFound) == FALSE) {
            return( FALSE);     // an invalid argument
        }

        *pCommand = (DeleteFound == FALSE) ? DUMP_ID : DEL_ID;
        return( TRUE);
    }

    //
    //  Try some variation of "AT [\\ServerName [/DELETE]"
    //
    if ( ParseJobIdArgs( argv, argc, next, &DeleteFound) == TRUE) {
        *pCommand = (DeleteFound == FALSE) ? DUMP_ALL : DEL_ALL;
        return( TRUE);
    }

    if ( ArgIsTime( argv[ next], &JobTime) == TRUE) {

        *pCommand = ADD_TO_SCHEDULE;

        if ( argc < next + 2) {
            return( FALSE); // need something to do, not just time
        }

        memset( (PBYTE)&GlobalAtInfo, '\0', sizeof(GlobalAtInfo));    // initialize
        GlobalAtInfo.Flags |= JOB_NONINTERACTIVE;   //  the default

        if ( ParseInteractiveArg( argv[ next + 1])) {
            next++;
        }
        if ( argc < next + 2) {
            return( FALSE); // once more with feeling
        }

        if ( ParseTimeArgs( argv, argc, next + 1, &argno) == FALSE) {
            return( FALSE);
        }

        //  Copy argument strings to record.

        recdatap = GlobalAtInfo.Command = GlobalAtInfoCommand;
        recdata_len = 0;

        fUseOldParsing = UseOldParsing();

        for ( i = argno; i < argc; i++) {

            DWORD temp;

            //
            // Fix for bug 22068 "AT command does not handle filenames with
            // spaces." The command processor takes a quoted command line arg
            // and puts everything between the quotes into one argv string.
            // The quotes are stripped out. Thus, if any of the string args
            // contain whitespace, then they must be requoted before being
            // concatenated into the command value.
            //
            BOOL fQuote = (!fUseOldParsing && wcschr(argv[i], L' ') != NULL);

            temp = wcslen(argv[i]) + (fQuote ? 3 : 1);  // add 2 for quotes

            recdata_len += temp;

            if ( recdata_len > MAX_COMMAND_LEN) {
                MessagePrint( APE_AT_COMMAND_TOO_LONG );
                return( FALSE);
            }

            if (fQuote)
            {
                wcscpy(recdatap, L"\"");
                wcscat(recdatap, argv[i]);
                wcscat(recdatap, L"\"");
            }
            else
            {
                wcscpy(recdatap, argv[i]);
            }

            recdatap += temp;

            //  To construct lpszCommandLine argument to CreateProcess call
            //  we replace nuls with spaces.

            *(recdatap - 1) = BLANK;

        }

        //  Reset space back to null on last argument in string.

        *(recdatap - 1) = NULLC;
        GlobalAtInfo.JobTime = JobTime;
        return( TRUE);
    }

    return( FALSE);
}


VOID
GetTimeString(
    DWORD_PTR  Time,
    WCHAR *Buffer,
    int    BufferLength
    )
/*++

Routine Description:

    This function converts a dword time to an ASCII string.

Arguments:

    Time         - Time difference in dword from start of the day (i.e. 12am
                   midnight ) in milliseconds

    Buffer       - Pointer to the buffer to place the ASCII representation.

    BufferLength - The length of buffer in bytes.

Return Value:

    None.

--*/
#define MINUTES_IN_HOUR       60
#define SECONDS_IN_MINUTE     60
{
    WCHAR szTimeString[MAX_TIME_SIZE];
    WCHAR *p = &szTimeString[1];
    DWORD_PTR seconds, minutes, hours;
    int numChars;
    DWORD flags;
    SYSTEMTIME st;

    GetSystemTime(&st);
    *p = NULLC;

    // Check if the time format is initialized. If not, initialize it.
    if ( GlobalTimeFormat.AMString == NULL )
        NetpGetTimeFormat( &GlobalTimeFormat );

    // Convert the time to hours, minutes, seconds
    seconds = (Time/1000);
    hours   = seconds / (MINUTES_IN_HOUR * SECONDS_IN_MINUTE );
    seconds -= hours * MINUTES_IN_HOUR * SECONDS_IN_MINUTE;
    minutes = seconds / SECONDS_IN_MINUTE;
    seconds -= minutes * SECONDS_IN_MINUTE;

    st.wHour   = (WORD)(hours);
    st.wMinute = (WORD)(minutes);
    st.wSecond = (WORD)(seconds);
    st.wMilliseconds = 0;

    flags = TIME_NOSECONDS;
    if (!GlobalTimeFormat.TwelveHour)
    flags |= TIME_FORCE24HOURFORMAT;

    numChars = GetTimeFormatW(GetThreadLocale(),
        flags, &st, NULL, p, MAX_TIME_SIZE-1);

    if ( numChars > BufferLength )
        numChars = BufferLength;

    if (*(p+1) == ARG_SEP_CHR && GlobalTimeFormat.LeadingZero) {
    *(--p) = TEXT('0');
    numChars++;
    }
    wcsncpy( Buffer, p, numChars );
    // Append spece for align print format. column based.
    {
        DWORD ColumnLength;

        // character counts -> array index.
        numChars--;

        ColumnLength = GetStringColumn( Buffer );

        while( ColumnLength++ < MAX_TIME_FIELD_LENGTH) {
            Buffer[ numChars++] = BLANK;
        }
        Buffer[ numChars] = UNICODE_NULL;
    }
}


BOOL
InitList( PSEARCH_LIST SearchList )
{
    if ( SearchList != NULL) {

        if ( SearchList->String != NULL ) // Already initialized
            return TRUE;

        for ( NOTHING;  SearchList->MessageId != 0;  SearchList++) {
             if ( MessageGet( SearchList->MessageId,
                              &SearchList->String,
                              0 ) == 0 )
             {
                 return FALSE;
             }
        }
    }

    return TRUE;
}


VOID
TermList( PSEARCH_LIST SearchList )
{
    if ( SearchList != NULL) {

        if ( SearchList->String == NULL ) // Not initialized
            return;

        for ( NOTHING;  SearchList->String != NULL;  SearchList++) {
             LocalFree( SearchList->String );
        }
    }
}


DWORD
GetStringColumn( WCHAR *lpwstr )
{
    int cchNeed;

    cchNeed = WideCharToMultiByte( GetConsoleOutputCP() , 0 ,
                                   lpwstr , -1 ,
                                   NULL , 0 ,
                                   NULL , NULL );

    return( (DWORD) cchNeed - 1 ); // - 1 : remove NULL
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\browser\client\bowser_c_stub.c ===
#include "bowser_c.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\browser\client\browstat.c ===
#define _PSS_RELEASE

#include "browdeb.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\browser\client\browbind.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    wksbind.c

Abstract:

    Routines which use RPC to bind and unbind the client to the Browser
    service.

Author:

    Rita Wong (ritaw)  14-May-1991
    Larry Osterman (larryo)  23-Mar-1992

Environment:

    User Mode -Win32

Revision History:

--*/

#include "brclient.h"


handle_t
BROWSER_IMPERSONATE_HANDLE_bind(
    BROWSER_IMPERSONATE_HANDLE ServerName
    )

/*++

Routine Description:

    This routine is called from the Browser service client stubs when
    it is necessary create an RPC binding to the server end with
    impersonation level of impersonation.

Arguments:

    ServerName - A pointer to a string containing the name of the server
        to bind with.

Return Value:

    The binding handle is returned to the stub routine.  If the bind is
    unsuccessful, a NULL will be returned.

--*/
{
    handle_t BindHandle;
    RPC_STATUS RpcStatus;

    RpcStatus = NetpBindRpc (
                    ServerName,
                    BROWSER_INTERFACE_NAME,
                    TEXT("Security=Impersonation Dynamic False"),
                    &BindHandle
                    );

    if (RpcStatus != RPC_S_OK) {
        KdPrint((
            "BROWSER_IMPERSONATE_HANDLE_bind failed: " FORMAT_NTSTATUS "\n",
            RpcStatus
            ));
    }

    return BindHandle;
}



handle_t
BROWSER_IDENTIFY_HANDLE_bind(
    BROWSER_IDENTIFY_HANDLE ServerName
    )

/*++

Routine Description:

    This routine is called from the Browser service client stubs when
    it is necessary create an RPC binding to the server end with
    identification level of impersonation.

Arguments:

    ServerName - A pointer to a string containing the name of the server
        to bind with.

Return Value:

    The binding handle is returned to the stub routine.  If the bind is
    unsuccessful, a NULL will be returned.

--*/
{
    handle_t BindHandle;
    RPC_STATUS RpcStatus;

    RpcStatus = NetpBindRpc (
                    ServerName,
                    BROWSER_INTERFACE_NAME,
                    TEXT("Security=Identification Dynamic False"),
                    &BindHandle
                    );

    if (RpcStatus != RPC_S_OK) {
        KdPrint((
            "BROWSER_IDENTIFY_HANDLE_bind failed: " FORMAT_NTSTATUS "\n",
            RpcStatus
            ));
    }

    return BindHandle;
}



void
BROWSER_IMPERSONATE_HANDLE_unbind(
    BROWSER_IMPERSONATE_HANDLE ServerName,
    handle_t BindHandle
    )

/*++

Routine Description:

    This routine calls a common unbind routine that is shared by all services.
    This routine is called from the Browser service client stubs when it is
    necessary to unbind from the server end.

Arguments:

    ServerName - This is the name of the server from which to unbind.

    BindingHandle - This is the binding handle that is to be closed.

Return Value:

    None.

--*/
{
    UNREFERENCED_PARAMETER(ServerName);

    NetpUnbindRpc(BindHandle);
}



void
BROWSER_IDENTIFY_HANDLE_unbind(
    BROWSER_IDENTIFY_HANDLE ServerName,
    handle_t BindHandle
    )

/*++

Routine Description:

    This routine calls a common unbind routine that is shared by all services.
    This routine is called from the server service client stubs when it is
    necessary to unbind from a server.

Arguments:

    ServerName - This is the name of the server from which to unbind.

    BindingHandle - This is the binding handle that is to be closed.

Return Value:

    None.

--*/
{
    UNREFERENCED_PARAMETER(ServerName);

    NetpUnbindRpc(BindHandle);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\browser\client\browstub.c ===
/*++

Copyright (c) 1991-1992  Microsoft Corporation

Module Name:

    wksstub.c

Abstract:

    Client stubs of the Browser service APIs.

Author:

    Rita Wong (ritaw) 10-May-1991
    Larry Osterman (LarryO) 23-Mar-1992

Environment:

    User Mode - Win32

Revision History:

    18-Jun-1991 JohnRo
        Remote NetUse APIs to downlevel servers.
    24-Jul-1991 JohnRo
        Use NET_REMOTE_TRY_RPC etc macros for NetUse APIs.
        Moved NetpIsServiceStarted() into NetLib.
    25-Jul-1991 JohnRo
        Quiet DLL stub debug output.
    19-Aug-1991 JohnRo
        Implement downlevel NetWksta APIs.  Use NetRpc.h for NetWksta APIs.
    07-Nov-1991 JohnRo
        RAID 4186: assert in RxNetShareAdd and other DLL stub problems.
    19-Nov-1991 JohnRo
        Make sure status is correct for APIs not supported on downlevel.
        Implement remote NetWkstaUserEnum().
    09-Nov-1992 JohnRo
        Fix NET_API_FUNCTION references.
        Avoid compiler warnings.
--*/

#include "brclient.h"
#undef IF_DEBUG                 // avoid wsclient.h vs. debuglib.h conflicts.
#include <debuglib.h>           // IF_DEBUG() (needed by netrpc.h).
#include <lmserver.h>
#include <lmsvc.h>
#include <rxuse.h>              // RxNetUse APIs.
#include <rxwksta.h>            // RxNetWksta and RxNetWkstaUser APIs.
#include <rap.h>                // Needed by rxserver.h
#include <rxserver.h>           // RxNetServerEnum API.
#include <netlib.h>             // NetpServiceIsStarted() (needed by netrpc.h).
#include <ntddbrow.h>           // Browser definitions
#include <netrpc.h>             // NET_REMOTE macros.
#include <align.h>
#include <tstr.h>
#include <tstring.h>            // NetpInitOemString().
#include <brcommon.h>           // Routines common between client & server
#include <lmapibuf.h>           // NetApiBufferFree().
#include <lmbrowsr.h>           // Definition of I_BrowserServerEnum
#include <icanon.h>
#include <lmapibuf.h>
#include "cscp.h"

//-------------------------------------------------------------------//
//                                                                   //
// Global variables                                                  //
//                                                                   //
//-------------------------------------------------------------------//

#define API_SUCCESS(x)  ((x) == NERR_Success || (x) == ERROR_MORE_DATA)


//-------------------------------------------------------------------//
//                                                                   //
// Global types                                                      //
//                                                                   //
//-------------------------------------------------------------------//



//-------------------------------------------------------------------//
//                                                                   //
// Private routines                                                  //
//                                                                   //
//-------------------------------------------------------------------//


NET_API_STATUS
GetBrowserTransportList(
    OUT PLMDR_TRANSPORT_LIST *TransportList
    );

NET_API_STATUS
EnumServersForTransport(
    IN PUNICODE_STRING TransportName,
    IN LPCWSTR DomainName OPTIONAL,
    IN ULONG level,
    IN ULONG prefmaxlen,
    IN ULONG servertype,
    IN LPTSTR CurrentComputerName,
    OUT PINTERIM_SERVER_LIST InterimServerList,
    OUT PULONG TotalEntriesOnThisTransport,
    IN LPCWSTR FirstNameToReturn,
    IN BOOLEAN WannishTransport,
    IN BOOLEAN RasTransport,
    IN BOOLEAN IPXTransport
    );

#if DBG
void
ValidateServerList(
    IN      PVOID   ServerList,
    IN      ULONG   ulLevel,
    IN      ULONG   ulEntries
    );
#else
#define ValidateServerList(x,y,z)
#endif

NET_API_STATUS NET_API_FUNCTION
NetServerEnum(
    IN  LPCWSTR      servername OPTIONAL,
    IN  DWORD       level,
    OUT LPBYTE      *bufptr,
    IN  DWORD       prefmaxlen,
    OUT LPDWORD     entriesread,
    OUT LPDWORD     totalentries,
    IN  DWORD       servertype,
    IN  LPCWSTR      domain OPTIONAL,
    IN OUT LPDWORD  resume_handle OPTIONAL
    )
/*++

Routine Description:

    This is the DLL entrypoint for NetServerEnum.

Arguments:

    servername - Supplies the name of server to execute this function

    level - Supplies the requested level of information.

    bufptr - Returns a pointer to a buffer which contains the
        requested transport information.

    prefmaxlen - Supplies the number of bytes of information
        to return in the buffer.  If this value is MAXULONG, we will try
        to return all available information if there is enough memory
        resource.

    entriesread - Returns the number of entries read into the buffer.  This
        value is returned only if the return code is NERR_Success or
        ERROR_MORE_DATA.

    totalentries - Returns the total number of entries available.  This value
        is returned only if the return code is NERR_Success or ERROR_MORE_DATA.

    servertype - Supplies the type of server to enumerate.

    domain - Supplies the name of one of the active domains to enumerate the
        servers from.  If NULL, servers from the primary domain, logon domain
        and other domains are enumerated.

    resume_handle - Supplies and returns the point to continue with enumeration.

Return Value:

    NET_API_STATUS - NERR_Success or reason for failure.

--*/
{
    NET_API_STATUS NetStatus;


    //
    // NetServerEnum is simply a wrapper to NetServerEnumEx
    //

    NetStatus = NetServerEnumEx(
                    servername,
                    level,
                    bufptr,
                    prefmaxlen,
                    entriesread,
                    totalentries,
                    servertype,
                    domain,
                    NULL );     // NULL FirstNameToReturn

    if (ARGUMENT_PRESENT(resume_handle)) {
        *resume_handle = 0;
    }

    return NetStatus;

}


NET_API_STATUS NET_API_FUNCTION
NetServerEnumEx(
    IN  LPCWSTR     servername OPTIONAL,
    IN  DWORD       level,
    OUT LPBYTE      *bufptr,
    IN  DWORD       prefmaxlen,
    OUT LPDWORD     entriesread,
    OUT LPDWORD     totalentries,
    IN  DWORD       servertype,
    IN  LPCWSTR     domain OPTIONAL,
    IN  LPCWSTR     FirstNameToReturnArg OPTIONAL
    )
/*++

Routine Description:

    This is the DLL entrypoint for NetServerEnum.

Arguments:

    servername - Supplies the name of server to execute this function

    level - Supplies the requested level of information.

    bufptr - Returns a pointer to a buffer which contains the
        requested transport information.

    prefmaxlen - Supplies the number of bytes of information
        to return in the buffer.  If this value is MAXULONG, we will try
        to return all available information if there is enough memory
        resource.

    entriesread - Returns the number of entries read into the buffer.  This
        value is returned only if the return code is NERR_Success or
        ERROR_MORE_DATA.

    totalentries - Returns the total number of entries available.  This value
        is returned only if the return code is NERR_Success or ERROR_MORE_DATA.

    servertype - Supplies the type of server to enumerate.

    domain - Supplies the name of one of the active domains to enumerate the
        servers from.  If NULL, servers from the primary domain, logon domain
        and other domains are enumerated.

    FirstNameToReturnArg - Supplies the name of the first domain or server entry to return.
        The caller can use this parameter to implement a resume handle of sorts by passing
        the name of the last entry returned on a previous call.  (Notice that the specified
        entry will, also, be returned on this call unless it has since been deleted.)
        Pass NULL (or a zero length string) to start with the first entry available.


Return Value:

    NET_API_STATUS - NERR_Success or reason for failure.

    ERROR_MORE_DATA - More servers are available to be enumerated.

        It is possible to return ERROR_MORE_DATA and zero entries in the case
        where the browser server used doesn't support enumerating all the entries
        it has. (e.g., an NT 3.5x Domain Master Browser that downloaded a domain
        list from WINS and the WINS list is more than 64Kb long.) The caller
        should simply ignore the additional data.

        It is possible to fail to return ERROR_MORE_DATA and return a truncated
        list.  (e.g., an NT 3.5x Backup browser or WIN 95 backup browser in the
        above mentioned domain.  Such a backup browser replicates only 64kb
        of data from the DMB (PDC) then represents that list as the entire list.)
        The caller should ignore this problem.  The site should upgrade its
        browser servers.

--*/
{
    PLMDR_TRANSPORT_LIST TransportList = NULL;
    PLMDR_TRANSPORT_LIST TransportEntry = NULL;
    INTERIM_SERVER_LIST InterimServerList;
    NET_API_STATUS Status;
    DWORD DomainNameSize = 0;
    TCHAR DomainName[DNLEN + 1];
    WCHAR FirstNameToReturn[DNLEN+1];
    DWORD LocalTotalEntries;
    BOOLEAN AnyTransportHasMoreData = FALSE;

    //
    //
    //  The workstation has to be started for the NetServerEnum API to work.
    //
    //

    if ((Status = CheckForService(SERVICE_WORKSTATION, NULL)) != NERR_Success) {
        return Status;
    }

#ifdef ENABLE_PSEUDO_BROWSER
    //
    // Disabled NetServerEnum check
    //
    if ( !IsEnumServerEnabled() ||
         GetBrowserPseudoServerLevel() == BROWSER_PSEUDO ) {
        // NetServerEnum is disabled or pseudo server is
        // enabled on box ==> return no entries.
        *entriesread = 0;
        *totalentries = 0;
        *bufptr = NULL;
        return NERR_Success;
    }
#endif


    //
    // Canonicalize the input parameters to make later comparisons easier.
    //

    if (ARGUMENT_PRESENT(domain)) {

        if ( I_NetNameCanonicalize(
                          NULL,
                          (LPWSTR) domain,
                          DomainName,
                          (DNLEN + 1) * sizeof(TCHAR),
                          NAMETYPE_WORKGROUP,
                          LM2X_COMPATIBLE
                          ) != NERR_Success) {
            return ERROR_INVALID_PARAMETER;
        }

        DomainNameSize = STRLEN(DomainName) * sizeof(WCHAR);

        domain = DomainName;
    }

    if (ARGUMENT_PRESENT(FirstNameToReturnArg)  && *FirstNameToReturnArg != L'\0') {

        if ( I_NetNameCanonicalize(
                          NULL,
                          (LPWSTR) FirstNameToReturnArg,
                          FirstNameToReturn,
                          sizeof(FirstNameToReturn),
                          NAMETYPE_WORKGROUP,
                          LM2X_COMPATIBLE
                          ) != NERR_Success) {
            return ERROR_INVALID_PARAMETER;
        }

    } else {
        FirstNameToReturn[0] = L'\0';
    }

    if ((servername != NULL) &&
        ( *servername != TCHAR_EOS)) {

        //
        // Call downlevel version of the API
        //

        Status = RxNetServerEnum(
                     servername,
                     NULL,
                     level,
                     bufptr,
                     prefmaxlen,
                     entriesread,
                     totalentries,
                     servertype,
                     domain,
                     FirstNameToReturn );

        return Status;
    }

    //
    // Only levels 100 and 101 are valid
    //

    if ((level != 100) && (level != 101)) {
        return ERROR_INVALID_LEVEL;
    }

    if (servertype != SV_TYPE_ALL) {
        if (servertype & SV_TYPE_DOMAIN_ENUM) {
            if (servertype != SV_TYPE_DOMAIN_ENUM) {
                return ERROR_INVALID_FUNCTION;
            }
        }
    }

    //
    //  Initialize the buffer to a known value.
    //

    *bufptr = NULL;

    *entriesread = 0;

    *totalentries = 0;

    //
    // If we are off-line, give CSC a chance to do the enumeration
    //
    if( !ARGUMENT_PRESENT( servername ) &&
        (servertype & SV_TYPE_SERVER) &&
        CSCIsOffline() ) {

        Status = CSCNetServerEnumEx( level,
                                     bufptr,
                                     prefmaxlen,
                                     entriesread,
                                     totalentries
                                   );
        if( Status == NERR_Success ) {
            return Status;
        }
    }

    Status = InitializeInterimServerList(&InterimServerList, NULL, NULL, NULL, NULL);

    try {
        BOOL AnyEnumServersSucceeded = FALSE;
        LPTSTR MyComputerName = NULL;

        Status = NetpGetComputerName( &MyComputerName);

        if ( Status != NERR_Success ) {
            goto try_exit;
        }

        //
        //  Retrieve the list of transports from the browser.
        //

        Status = GetBrowserTransportList(&TransportList);

        if (Status != NERR_Success) {
            goto try_exit;
        }

        TransportEntry = TransportList;

        while (TransportEntry != NULL) {
            UNICODE_STRING TransportName;

            TransportName.Buffer = TransportEntry->TransportName;
            TransportName.Length = (USHORT)TransportEntry->TransportNameLength;
            TransportName.MaximumLength = (USHORT)TransportEntry->TransportNameLength;

            Status = EnumServersForTransport(&TransportName,
                                             domain,
                                             level,
                                             prefmaxlen,
                                             servertype,
                                             MyComputerName,
                                             &InterimServerList,
                                             &LocalTotalEntries,
                                             FirstNameToReturn,
                                             (BOOLEAN)((TransportEntry->Flags & LMDR_TRANSPORT_WANNISH) != 0),
                                             (BOOLEAN)((TransportEntry->Flags & LMDR_TRANSPORT_RAS) != 0),
                                             (BOOLEAN)((TransportEntry->Flags & LMDR_TRANSPORT_IPX) != 0));

            if (API_SUCCESS(Status)) {
                if ( Status == ERROR_MORE_DATA ) {
                    AnyTransportHasMoreData = TRUE;
                }
                AnyEnumServersSucceeded = TRUE;
                if ( LocalTotalEntries > *totalentries ) {
                    *totalentries = LocalTotalEntries;
                }
            }

            if (TransportEntry->NextEntryOffset == 0) {
                TransportEntry = NULL;
            } else {
                TransportEntry = (PLMDR_TRANSPORT_LIST)((PCHAR)TransportEntry+TransportEntry->NextEntryOffset);
            }

        }

        if ( MyComputerName != NULL ) {
            (void) NetApiBufferFree( MyComputerName );
        }

        if (AnyEnumServersSucceeded) {

            //
            //  Pack the interim server list into its final form.
            //

            Status = PackServerList(&InterimServerList,
                            level,
                            servertype,
                            prefmaxlen,
                            (PVOID *)bufptr,
                            entriesread,
                            &LocalTotalEntries,  // Pack thinks it has ALL the entries
                            NULL ); // The server has already returned us the right entries

            if ( API_SUCCESS( Status ) ) {
                if ( LocalTotalEntries > *totalentries ) {
                    *totalentries = LocalTotalEntries;
                }
            }
        }

try_exit:NOTHING;
    } finally {
        if (TransportList != NULL) {
            MIDL_user_free(TransportList);
        }

        UninitializeInterimServerList(&InterimServerList);
    }

    if ( API_SUCCESS( Status )) {

        //
        // At this point,
        //  *totalentries is the largest of:
        //      The TotalEntries returned from any transport.
        //      The actual number of entries read.
        //
        // Adjust TotalEntries returned for reality.
        //

        if ( Status == NERR_Success ) {
            *totalentries = *entriesread;
        } else {
            if ( *totalentries <= *entriesread ) {
                *totalentries = *entriesread + 1;
            }
        }

        //
        // Ensure we return ERROR_MORE_DATA if any transport has more data.
        //

        if ( AnyTransportHasMoreData ) {
            Status = ERROR_MORE_DATA;
        }
    }

    return Status;
}

NET_API_STATUS
EnumServersForTransport(
    IN PUNICODE_STRING TransportName,
    IN LPCWSTR DomainName OPTIONAL,
    IN ULONG level,
    IN ULONG prefmaxlen,
    IN ULONG servertype,
    IN LPTSTR CurrentComputerName,
    OUT PINTERIM_SERVER_LIST InterimServerList,
    OUT PULONG TotalEntriesOnThisTransport,
    IN LPCWSTR FirstNameToReturn,
    IN BOOLEAN WannishTransport,
    IN BOOLEAN RasTransport,
    IN BOOLEAN IpxTransport
    )
{
    PWSTR *BrowserList = NULL;
    ULONG BrowserListLength = 0;
    NET_API_STATUS Status;
    PVOID ServerList = NULL;
    ULONG EntriesInList = 0;
    ULONG ServerIndex = 0;

    //
    //  Skip over IPX transports - we can't contact machines over them anyway.
    //

    *TotalEntriesOnThisTransport = 0;

    if (IpxTransport) {
        return NERR_Success;
    }

    //
    //  Retrieve a new browser list.  Do not force a revalidation.
    //

    Status = GetBrowserServerList(TransportName,
                                    DomainName,
                                    &BrowserList,
                                    &BrowserListLength,
                                    FALSE);

    //
    //  If a domain name was specified and we were unable to find the browse
    //  master for the domain and we are running on a wannish transport,
    //  invoke the "double hop" code and allow a local browser server
    //  remote the API to the browse master for that domain (we assume that
    //  this means that the workgroup is on a different subnet of a WAN).
    //

    if (!API_SUCCESS(Status) &&
        DomainName != NULL) {

       Status = GetBrowserServerList(TransportName,
                                    NULL,
                                    &BrowserList,
                                    &BrowserListLength,
                                    FALSE);


    }


    //
    //  If we were able to retrieve the list, remote the API.  Otherwise
    //  return.
    //

    if (API_SUCCESS(Status) && BrowserList) {

        do {
            LPTSTR Transport;
            LPTSTR ServerName;
            BOOL AlreadyInTree;

            //
            // Remote the API to that server.
            //

            Transport = TransportName->Buffer;
            ServerName = BrowserList[0];
            *TotalEntriesOnThisTransport = 0;

            // add 2 to skip double backslash at start of ServerName

            if ( STRICMP(ServerName + 2, CurrentComputerName ) == 0 ) {

                //
                //  If we are going to remote the API to ourselves,
                //  and we are running the browser service, simply
                //  use RPC to get the information we need, don't
                //  bother using the redirector.  This allows us to
                //  avoid tying up RPCXLATE thread.
                //

                Status = I_BrowserServerEnumEx (
                                NULL,
                                Transport,
                                CurrentComputerName,
                                level,
                                (LPBYTE *)&ServerList,
                                prefmaxlen,
                                &EntriesInList,
                                TotalEntriesOnThisTransport,
                                servertype,
                                DomainName,
                                FirstNameToReturn );


            } else {

                Status = RxNetServerEnum(
                             ServerName,
                             Transport,
                             level,
                             (LPBYTE *)&ServerList,
                             prefmaxlen,
                             &EntriesInList,
                             TotalEntriesOnThisTransport,
                             servertype,
                             DomainName,
                             FirstNameToReturn );


            }

            if ( !API_SUCCESS(Status)) {
                NET_API_STATUS GetBListStatus;

                //
                //  If we failed to remote the API for some reason,
                //  we want to regenerate the bowsers list of browser
                //  servers.
                //

                if (BrowserList != NULL) {

                    MIDL_user_free(BrowserList);

                    BrowserList = NULL;
                }


                GetBListStatus = GetBrowserServerList(TransportName,
                                                            DomainName,
                                                            &BrowserList,
                                                            &BrowserListLength,
                                                            TRUE);
                if (GetBListStatus != NERR_Success) {

                    //
                    //  If we were unable to reload the list,
                    //  try the next transport.
                    //

                    break;
                }

                ServerIndex += 1;

                //
                //  If we've looped more times than we got servers
                //  in the list, we're done.
                //

                if ( ServerIndex > BrowserListLength ) {
                    break;
                }

            } else {

                NET_API_STATUS TempStatus;

                TempStatus = MergeServerList(
                                        InterimServerList,
                                        level,
                                        ServerList,
                                        EntriesInList,
                                        *TotalEntriesOnThisTransport );

                if ( TempStatus != NERR_Success ) {
                    Status = TempStatus;
                }

                //
                //  The remote API succeeded.
                //
                //  Now free up the remaining parts of the list.
                //

                if (ServerList != NULL) {
                    NetApiBufferFree(ServerList);
                    ServerList = NULL;
                }

                // We're done regardless of the success or failure of MergeServerList.
                break;

            }

        } while ( !API_SUCCESS(Status) );

    }

    //
    //  Free up the browser list.
    //

    if (BrowserList != NULL) {
        MIDL_user_free(BrowserList);
        BrowserList = NULL;
    }

    return Status;
}


NET_API_STATUS
GetBrowserTransportList(
    OUT PLMDR_TRANSPORT_LIST *TransportList
    )

/*++

Routine Description:

    This routine returns the list of transports bound into the browser.

Arguments:

    OUT PLMDR_TRANSPORT_LIST *TransportList - Transport list to return.

Return Value:

    NET_API_STATUS - NERR_Success or reason for failure.

--*/

{

    NET_API_STATUS Status;
    HANDLE BrowserHandle;
    LMDR_REQUEST_PACKET RequestPacket;

    Status = OpenBrowser(&BrowserHandle);

    if (Status != NERR_Success) {
        return Status;
    }

    ZeroMemory(&RequestPacket, sizeof(RequestPacket));
    RequestPacket.Version = LMDR_REQUEST_PACKET_VERSION_DOM;

    RequestPacket.Type = EnumerateXports;

    RtlInitUnicodeString(&RequestPacket.TransportName, NULL);
    RtlInitUnicodeString(&RequestPacket.EmulatedDomainName, NULL);

    Status = DeviceControlGetInfo(
                BrowserHandle,
                IOCTL_LMDR_ENUMERATE_TRANSPORTS,
                &RequestPacket,
                sizeof(RequestPacket),
                (PVOID *)TransportList,
                0xffffffff,
                4096,
                NULL);

    NtClose(BrowserHandle);

    return Status;
}

NET_API_STATUS
I_BrowserServerEnum (
    IN  LPCWSTR      servername OPTIONAL,
    IN  LPCWSTR      transport OPTIONAL,
    IN  LPCWSTR      clientname OPTIONAL,
    IN  DWORD       level,
    OUT LPBYTE      *bufptr,
    IN  DWORD       prefmaxlen,
    OUT LPDWORD     entriesread,
    OUT LPDWORD     totalentries,
    IN  DWORD       servertype,
    IN  LPCWSTR      domain OPTIONAL,
    IN OUT LPDWORD  resume_handle OPTIONAL
    )

/*++

Routine Description:

    This is the DLL entrypoint for NetWkstaSetInfo.

Arguments:

    servername - Supplies the name of server to execute this function

    level - Supplies the level of information.

    buf - Supplies a buffer which contains the information structure of fields
        to set.  The level denotes the structure in this buffer.

    parm_err - Returns the identifier to the invalid parameter in buf if this
        function returns ERROR_INVALID_PARAMETER.

Return Value:

    NET_API_STATUS - NERR_Success or reason for failure.

--*/
{
    NET_API_STATUS status;
    GENERIC_INFO_CONTAINER GenericInfoContainer;
    GENERIC_ENUM_STRUCT InfoStruct;

    GenericInfoContainer.Buffer = NULL;
    GenericInfoContainer.EntriesRead = 0;

    InfoStruct.Container = &GenericInfoContainer;
    InfoStruct.Level = level;

    NET_REMOTE_TRY_RPC

        //
        // Try RPC (local or remote) version of API.
        //

        status = I_BrowserrServerEnum(
                     (LPWSTR) servername,
                     (LPWSTR) transport,
                     (LPWSTR) clientname,
                     (LPSERVER_ENUM_STRUCT)&InfoStruct,
                     prefmaxlen,
                     totalentries,
                     servertype,
                     (LPWSTR) domain,
                     resume_handle
                     );

        if (status == NERR_Success || status == ERROR_MORE_DATA) {
            *bufptr = (LPBYTE) GenericInfoContainer.Buffer;
            *entriesread = GenericInfoContainer.EntriesRead;

#if 0
            if (((servertype == SV_TYPE_ALL || servertype == SV_TYPE_DOMAIN_ENUM)) &&
                (STRICMP(transport, L"\\Device\\Streams\\NBT"))) {
                if (*entriesread <= 20) {
                    KdPrint(("RPC API Returned EntriesRead == %ld on transport %ws\n", *entriesread, transport));
                }
                if (*totalentries <= 20) {
                    KdPrint(("RPC API Returned TotalEntries == %ld on transport %ws\n", *totalentries, transport));
                }
            }
#endif
        }

    NET_REMOTE_RPC_FAILED("I_BrServerEnum",
            servername,
            status,
            NET_REMOTE_FLAG_NORMAL,
            SERVICE_BROWSER )

        //
        // There is no downlevel version of api.
        //
        status = ERROR_NOT_SUPPORTED;

    NET_REMOTE_END

#if 0
    if ((servertype == SV_TYPE_ALL || servertype == SV_TYPE_DOMAIN_ENUM) &&
        (STRICMP(transport, L"\\Device\\Streams\\NBT"))) {
        if (*entriesread <= 20) {
            KdPrint(("Client API Returned EntriesRead == %ld on transport %ws\n", *entriesread, transport));
        }
        if (*totalentries <= 20) {
            KdPrint(("Client API Returned TotalEntries == %ld on transport %ws\n", *totalentries, transport));
        }
    }
#endif

    return status;
}

NET_API_STATUS
I_BrowserServerEnumEx (
    IN  LPCWSTR      servername OPTIONAL,
    IN  LPCWSTR      transport OPTIONAL,
    IN  LPCWSTR      clientname OPTIONAL,
    IN  DWORD       level,
    OUT LPBYTE      *bufptr,
    IN  DWORD       prefmaxlen,
    OUT LPDWORD     entriesread,
    OUT LPDWORD     totalentries,
    IN  DWORD       servertype,
    IN  LPCWSTR      domain OPTIONAL,
    IN  LPCWSTR     FirstNameToReturn OPTIONAL
    )

/*++

Routine Description:

    This is the DLL entrypoint for NetWkstaSetInfo.

Arguments:

    servername - Supplies the name of server to execute this function

    level - Supplies the level of information.

    buf - Supplies a buffer which contains the information structure of fields
        to set.  The level denotes the structure in this buffer.

    parm_err - Returns the identifier to the invalid parameter in buf if this
        function returns ERROR_INVALID_PARAMETER.

    FirstNameToReturn - Supplies the name of the first domain or server entry to return.
        The caller can use this parameter to implement a resume handle of sorts by passing
        the name of the last entry returned on a previous call.  (Notice that the specified
        entry will, also, be returned on this call unless it has since been deleted.)
        Pass NULL to start with the first entry available.

Return Value:

    NET_API_STATUS - NERR_Success or reason for failure.

--*/
{
    NET_API_STATUS status;
    GENERIC_INFO_CONTAINER GenericInfoContainer;
    GENERIC_ENUM_STRUCT InfoStruct;

    GenericInfoContainer.Buffer = NULL;
    GenericInfoContainer.EntriesRead = 0;

    InfoStruct.Container = &GenericInfoContainer;
    InfoStruct.Level = level;

    NET_REMOTE_TRY_RPC

        //
        // Try RPC (local or remote) version of API.
        //

        status = I_BrowserrServerEnumEx(
                     (LPWSTR) servername,
                     (LPWSTR) transport,
                     (LPWSTR) clientname,
                     (LPSERVER_ENUM_STRUCT)&InfoStruct,
                     prefmaxlen,
                     totalentries,
                     servertype,
                     (LPWSTR) domain,
                     (LPWSTR) FirstNameToReturn );

        if (status == NERR_Success || status == ERROR_MORE_DATA) {
            *bufptr = (LPBYTE) GenericInfoContainer.Buffer;
            *entriesread = GenericInfoContainer.EntriesRead;

#if 0
            if (((servertype == SV_TYPE_ALL || servertype == SV_TYPE_DOMAIN_ENUM)) &&
                (STRICMP(transport, L"\\Device\\Streams\\NBT"))) {
                if (*entriesread <= 20) {
                    KdPrint(("RPC API Returned EntriesRead == %ld on transport %ws\n", *entriesread, transport));
                }
                if (*totalentries <= 20) {
                    KdPrint(("RPC API Returned TotalEntries == %ld on transport %ws\n", *totalentries, transport));
                }
            }
#endif
        }

    NET_REMOTE_RPC_FAILED("I_BrServerEnum",
            servername,
            status,
            NET_REMOTE_FLAG_NORMAL,
            SERVICE_BROWSER )

        //
        // There is no downlevel version of api.
        //
        status = ERROR_NOT_SUPPORTED;

    NET_REMOTE_END

#if 0
    if ((servertype == SV_TYPE_ALL || servertype == SV_TYPE_DOMAIN_ENUM) &&
        (STRICMP(transport, L"\\Device\\Streams\\NBT"))) {
        if (*entriesread <= 20) {
            KdPrint(("Client API Returned EntriesRead == %ld on transport %ws\n", *entriesread, transport));
        }
        if (*totalentries <= 20) {
            KdPrint(("Client API Returned TotalEntries == %ld on transport %ws\n", *totalentries, transport));
        }
    }
#endif

    return status;
}


NET_API_STATUS NET_API_FUNCTION
I_BrowserQueryOtherDomains (
    IN  LPCWSTR      servername OPTIONAL,
    OUT LPBYTE      *bufptr,
    OUT LPDWORD     entriesread,
    OUT LPDWORD     totalentries
    )

/*++

Routine Description:

    This is the DLL entrypoint for NetWkstaSetInfo.

Arguments:

    servername - Supplies the name of server to execute this function

    buf - Supplies a buffer which contains the information structure of fields
        to set.  The level denotes the structure in this buffer.

Return Value:

    NET_API_STATUS - NERR_Success or reason for failure.

--*/
{
    NET_API_STATUS status;
    GENERIC_INFO_CONTAINER GenericInfoContainer;
    GENERIC_ENUM_STRUCT InfoStruct;

    GenericInfoContainer.Buffer = NULL;
    GenericInfoContainer.EntriesRead = 0;

    InfoStruct.Container = &GenericInfoContainer;
    InfoStruct.Level = 100;

    NET_REMOTE_TRY_RPC

        //
        // Try RPC (local or remote) version of API.
        //

        status = I_BrowserrQueryOtherDomains (
                     (LPWSTR) servername,
                     (LPSERVER_ENUM_STRUCT)&InfoStruct,
                     totalentries
                     );

        if (status == NERR_Success || status == ERROR_MORE_DATA) {
            *bufptr = (LPBYTE) GenericInfoContainer.Buffer;
            *entriesread = GenericInfoContainer.EntriesRead;
        }

    NET_REMOTE_RPC_FAILED("I_BrowserQueryOtherDomains",
            servername,
            status,
            NET_REMOTE_FLAG_NORMAL,
            SERVICE_BROWSER )

        //
        // There is no downlevel version of api.
        //
        status = ERROR_NOT_SUPPORTED;

    NET_REMOTE_END

    return status;
}
NET_API_STATUS
I_BrowserResetNetlogonState (
    IN  LPCWSTR      servername OPTIONAL
    )

/*++

Routine Description:

    This is the DLL entrypoint for NetWkstaSetInfo.

Arguments:

    servername - Supplies the name of server to execute this function

    buf - Supplies a buffer which contains the information structure of fields
        to set.  The level denotes the structure in this buffer.

Return Value:

    NET_API_STATUS - NERR_Success or reason for failure.

--*/
{
    NET_API_STATUS status;

    NET_REMOTE_TRY_RPC

        //
        // Try RPC (local or remote) version of API.
        //

        status = I_BrowserrResetNetlogonState (
                     (LPWSTR) servername );

    NET_REMOTE_RPC_FAILED("I_BrowserResetNetlogonState",
            servername,
            status,
            NET_REMOTE_FLAG_NORMAL,
            SERVICE_BROWSER )

        //
        // There is no downlevel version of api.
        //
        status = ERROR_NOT_SUPPORTED;

    NET_REMOTE_END

    return status;
}


NET_API_STATUS
I_BrowserDebugCall (
    IN  LPTSTR      servername OPTIONAL,
    IN  DWORD DebugCode,
    IN  DWORD Options
    )
{
    NET_API_STATUS status;

    NET_REMOTE_TRY_RPC

        //
        // Try RPC (local or remote) version of API.
        //

        status = I_BrowserrDebugCall(
                     servername,
                     DebugCode,
                     Options
                     );


    NET_REMOTE_RPC_FAILED("I_BrowserDebugCall",
            servername,
            status,
            NET_REMOTE_FLAG_NORMAL,
            SERVICE_BROWSER )

        //
        // There is no downlevel version of api.
        //
        status = ERROR_NOT_SUPPORTED;

    NET_REMOTE_END

    return status;

}

NET_API_STATUS
I_BrowserDebugTrace (
    IN  LPTSTR      servername OPTIONAL,
    IN  PCHAR DebugString
    )
{
    NET_API_STATUS status;

    NET_REMOTE_TRY_RPC

        //
        // Try RPC (local or remote) version of API.
        //

        status = I_BrowserrDebugTrace(
                     servername,
                     DebugString
                     );


    NET_REMOTE_RPC_FAILED("I_BrowserDebugTrace",
            servername,
            status,
            NET_REMOTE_FLAG_NORMAL,
            SERVICE_BROWSER )

        //
        // There is no downlevel version of api.
        //
        status = ERROR_NOT_SUPPORTED;

    NET_REMOTE_END

    return status;

}


NET_API_STATUS
I_BrowserQueryStatistics (
    IN  LPCWSTR      servername OPTIONAL,
    IN  OUT LPBROWSER_STATISTICS *Statistics
    )
{
    NET_API_STATUS status;

    NET_REMOTE_TRY_RPC

        //
        // Try RPC (local or remote) version of API.
        //

        status = I_BrowserrQueryStatistics(
                     (LPWSTR) servername,
                     Statistics
                     );


    NET_REMOTE_RPC_FAILED("I_BrowserQueryStatistics",
            servername,
            status,
            NET_REMOTE_FLAG_NORMAL,
            SERVICE_BROWSER )

        //
        // There is no downlevel version of api.
        //
        status = ERROR_NOT_SUPPORTED;

    NET_REMOTE_END

    return status;

}

NET_API_STATUS
I_BrowserResetStatistics (
    IN  LPCWSTR      servername OPTIONAL
    )
{
    NET_API_STATUS status;

    NET_REMOTE_TRY_RPC

        //
        // Try RPC (local or remote) version of API.
        //

        status = I_BrowserrResetStatistics(
                     (LPWSTR) servername );


    NET_REMOTE_RPC_FAILED("I_BrowserResetStatistics",
            servername,
            status,
            NET_REMOTE_FLAG_NORMAL,
            SERVICE_BROWSER )

        //
        // There is no downlevel version of api.
        //
        status = ERROR_NOT_SUPPORTED;

    NET_REMOTE_END

    return status;

}


NET_API_STATUS
NetBrowserStatisticsGet(
    IN  LPTSTR  ServerName,
    IN  DWORD   Level,
    OUT LPBYTE* Buffer
    )

/*++

Routine Description:

    Wrapper for workstation statistics retrieval routine - either calls the
    client-side RPC function or calls RxNetStatisticsGet to retrieve the
    statistics from a down-level workstation service

Arguments:

    ServerName  - where to remote this function
    Level       - of information required (100, or 101)
    Buffer      - pointer to pointer to returned buffer

Return Value:

    NET_API_STATUS
        Success - NERR_Success
        Failure - ERROR_INVALID_LEVEL
                    Level not 0
                  ERROR_INVALID_PARAMETER
                    Unsupported options requested
                  ERROR_NOT_SUPPORTED
                    Service is not SERVER or WORKSTATION
                  ERROR_ACCESS_DENIED
                    Caller doesn't have necessary access rights for request

--*/

{
    NET_API_STATUS  status;
    GENERIC_INFO_CONTAINER GenericInfoContainer;
    GENERIC_ENUM_STRUCT InfoStruct;

    //
    // set the caller's buffer pointer to known value. This will kill the
    // calling app if it gave us a bad pointer and didn't use try...except
    //

    *Buffer = NULL;

    //
    // validate parms
    //

    if (Level != 100 && Level != 101) {
        return ERROR_INVALID_LEVEL;
    }

    GenericInfoContainer.Buffer = NULL;
    GenericInfoContainer.EntriesRead = 0;

    InfoStruct.Container = &GenericInfoContainer;
    InfoStruct.Level = Level;


    NET_REMOTE_TRY_RPC
        status = NetrBrowserStatisticsGet(ServerName,
                                                Level,
                                                (PBROWSER_STATISTICS_STRUCT)&InfoStruct
                                                );

        if (status == NERR_Success || status == ERROR_MORE_DATA) {
            *Buffer = (LPBYTE) GenericInfoContainer.Buffer;
        }

    NET_REMOTE_RPC_FAILED("NetBrowserStatisticsGet",
                            ServerName,
                            status,
                            NET_REMOTE_FLAG_NORMAL,
                            SERVICE_BROWSER
                            )

        status = ERROR_NOT_SUPPORTED;

    NET_REMOTE_END

    return status;
}


NET_API_STATUS
I_BrowserSetNetlogonState(
    IN LPWSTR ServerName,
    IN LPWSTR DomainName,
    IN LPWSTR EmulatedComputerName,
    IN DWORD Role
    )
/*++

Routine Description:

    This is the DLL entrypoint for I_BrowserSetNetlogonState.

Arguments:

    servername - Supplies the name of server to execute this function

    DomainName - name of the domain who's role is to be updated.

    EmulatedComputerName - Name of the computer within DomainName

    Role - Role of the specified domain.

Return Value:

    NET_API_STATUS - NERR_Success or reason for failure.

--*/
{
    NET_API_STATUS status;

    NET_REMOTE_TRY_RPC

        //
        // Try RPC (local or remote) version of API.
        //

        status = I_BrowserrSetNetlogonState (
                     ServerName,
                     DomainName,
                     EmulatedComputerName,
                     Role );

    NET_REMOTE_RPC_FAILED("I_BrowserSetNetlogonState",
            ServerName,
            status,
            NET_REMOTE_FLAG_NORMAL,
            SERVICE_BROWSER )

        //
        // There is no downlevel version of api.
        //
        status = ERROR_NOT_SUPPORTED;

    NET_REMOTE_END

    return status;
}

NET_API_STATUS NET_API_FUNCTION
I_BrowserQueryEmulatedDomains (
    IN LPTSTR ServerName OPTIONAL,
    OUT PBROWSER_EMULATED_DOMAIN *EmulatedDomains,
    OUT LPDWORD EntriesRead
    )

/*++

Routine Description:

    This is the DLL entrypoint for I_BrowserQueryEmulatedDomains.

Arguments:

    ServerName - Supplies the name of server to execute this function

    EmulatedDomains - Returns a pointer to a an allocated array of emulated domain
        information.

    EntriesRead - Returns the number of entries in 'EmulatedDomains'

Return Value:

    NET_API_STATUS - NERR_Success or reason for failure.

--*/
{
    NET_API_STATUS NetStatus;
    BROWSER_EMULATED_DOMAIN_CONTAINER Container;

    // Force RPC to allocate the buffer
    Container.Buffer = NULL;
    Container.EntriesRead = 0;
    *EmulatedDomains = NULL;
    *EntriesRead = 0;

    NET_REMOTE_TRY_RPC

        //
        // Try RPC (local or remote) version of API.
        //

        NetStatus = I_BrowserrQueryEmulatedDomains (
                     ServerName,
                     &Container );

        if ( NetStatus == NERR_Success ) {
            *EmulatedDomains = (PBROWSER_EMULATED_DOMAIN) Container.Buffer;
            *EntriesRead = Container.EntriesRead;
        }


    NET_REMOTE_RPC_FAILED("I_BrowserQueryEmulatedDomains",
            ServerName,
            NetStatus,
            NET_REMOTE_FLAG_NORMAL,
            SERVICE_BROWSER )

        //
        // There is no downlevel version of api.
        //
        NetStatus = ERROR_NOT_SUPPORTED;

    NET_REMOTE_END

    return NetStatus;
}




#if DBG
void
ValidateServerList(
    IN      PVOID   ServerList,
    IN      ULONG   ulLevel,
    IN      ULONG   ulEntries
    )
/*++

Routine Description (ValidateServerList):

    Cycle through servers. Validate the content in the list of server


Arguments:



Return Value:




Remarks:
    None.


--*/
{

    LONG i;
    ULONG ServerElementSize;
    PSERVER_INFO_101 ServerInfo = (PSERVER_INFO_101)ServerList;
    static BOOL bDisplayEntries = FALSE;

    ASSERT (ulLevel == 100 || ulLevel == 101);

    //
    //  Figure out the size of each element.
    //

    if (ulLevel == 100) {
        ServerElementSize = sizeof(SERVER_INFO_100);
    } else {
        ASSERT( ulLevel == 101 );
        ServerElementSize = sizeof(SERVER_INFO_101);
    }

    //
    //  Next check to see if the input list is sorted.
    //

    if ( bDisplayEntries ) {
        DbgPrint("Server List:\n");
    }
    for (i = 0 ; i < (LONG)ulEntries ; i++ ) {

        if ( bDisplayEntries ) {
            DbgPrint("<%d>: [0x%x] %S\n",
                     i,
                     ServerInfo->sv101_platform_id,
                     ServerInfo->sv101_name);
        }

        ASSERT (ServerInfo->sv101_name &&
                wcslen(ServerInfo->sv101_name) > 0);
        ServerInfo = (PSERVER_INFO_101)((PCHAR)ServerInfo + ServerElementSize);
    }
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\browser\client\brtsenum.c ===
/*++

Copyright (c) 1991-1992  Microsoft Corporation

Module Name:

    wstsend.c

Abstract:

    Test program for the NetServerEnum API.  Run this test after
    starting the Workstation service.

        wstenum [domain]

Author:

    Rita Wong (ritaw) 24-Oct-1991

Revision History:

--*/

#include <stdio.h>
#include <string.h>
#include <stdlib.h>

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include <winerror.h>
#include <windef.h>              // Win32 type definitions
#include <winbase.h>             // Win32 base API prototypes

#include <lm.h>                  // LAN Man definitions
#include <lmserver.h>

#include <tstring.h>
#include <netdebug.h>            // NetpDbgDisplay routines.
#include <dlserver.h>

#define FIXED_WIDTH_STRING "%-30ws: "
#define INDENT "  "

VOID
DisplayServerInfo(
    IN DWORD Level,
    IN LPVOID Info
    );

VOID
DisplayDword(
    IN LPTSTR Tag,
    IN DWORD Value
    );

VOID
DisplayBool(
    IN LPTSTR Tag,
    IN BOOL Value
    );

VOID
TestServerEnum(
    IN LPTSTR DomainName OPTIONAL,
    IN DWORD PreferedMaximumLength,
    IN OUT LPDWORD ResumeHandle OPTIONAL
    );



VOID
_cdecl
main(
    int argc,
    char *argv[]
    )
{
    LPTSTR DomainName = NULL;

    if (argc > 2) {
        printf("Usage: wstenum [domain].\n");
        return;
    }

    if (argc == 2) {
#ifdef UNICODE
        OEM_STRING AString;
        UNICODE_STRING UString;

        NetpInitOemString(&AString, argv[1]);
        RtlOemStringToUnicodeString(&UString, &AString, TRUE);
        DomainName = UString.Buffer;
#else
        DomainName = argv[1];

#endif
    }

    //
    // Enumerate all servers
    //
    TestServerEnum(DomainName, MAXULONG, NULL);
}





VOID
TestServerEnum(
    IN LPTSTR DomainName OPTIONAL,
    IN DWORD PreferedMaximumLength,
    IN OUT LPDWORD ResumeHandle OPTIONAL
    )
{
    DWORD i;
    NET_API_STATUS status;
    DWORD EntriesRead,
         TotalEntries;

    PSERVER_INFO_101 ServerInfo, saveptr;


    if (ARGUMENT_PRESENT(ResumeHandle)) {
       printf("\nInput ResumeHandle=x%08lx\n", *ResumeHandle);
    }

    status = NetServerEnum(
                 NULL,
                 101,
                 (LPBYTE *) &ServerInfo,
                 PreferedMaximumLength,
                 &EntriesRead,
                 &TotalEntries,
                 SV_TYPE_ALL,
                 DomainName,
                 ResumeHandle
                 );

    saveptr = ServerInfo;

    if (status != NERR_Success && status != ERROR_MORE_DATA) {
        printf("NetServerEnum FAILED %lu\n", status);
    }
    else {
        printf("Return code from NetServerEnum %lu\n", status);

        printf("EntriesRead=%lu, TotalEntries=%lu\n",
               EntriesRead, TotalEntries);

        if (ARGUMENT_PRESENT(ResumeHandle)) {
           printf("Output ResumeHandle=x%08lx\n", *ResumeHandle);
        }

        for (i = 0; i < EntriesRead; i++, ServerInfo++) {
            DisplayServerInfo(101, ServerInfo);
        }

        //
        // Free buffer allocated for us.
        //
        NetApiBufferFree(saveptr);
    }
}
VOID
DisplayTag(
    IN LPTSTR Tag
    )
{
    printf(INDENT FIXED_WIDTH_STRING, Tag);

} // NetpDbgDisplayTag
VOID
DisplayString(
    IN LPTSTR Tag,
    IN LPTSTR Value
    )
{
    DisplayTag( Tag );
    if (Value != NULL) {
        printf(FORMAT_LPTSTR "\n", Value);
    } else {
        printf("(none)\n");
    }

} // NetpDbgDisplayString

VOID
DisplayDwordHex(
    IN LPTSTR Tag,
    IN DWORD Value
    )
{
    DisplayTag( Tag );
    printf(FORMAT_HEX_DWORD, Value);
    printf("\n");

} // NetpDbgDisplayDwordHex

DBGSTATIC VOID
DisplayServerType(
    IN DWORD Type
    )
{
    // Longest name is "POTENTIAL_BROWSER" (14 chars)
    TCHAR str[(17+2)*17];  // 17 chars per name, 2 spaces, for 17 names.
    str[0] = '\0';

#define DO(name)                     \
    if (Type & SV_TYPE_ ## name) {   \
        (void) STRCAT(str, TEXT(#name));  \
        (void) STRCAT(str, TEXT("  "));    \
        Type &= ~(SV_TYPE_ ## name); \
    }

    NetpAssert(Type != 0);
    DO(WORKSTATION)
    DO(SERVER)
    DO(SQLSERVER)
    DO(DOMAIN_CTRL)
    DO(DOMAIN_BAKCTRL)
    DO(TIME_SOURCE)
    DO(AFP)
    DO(NOVELL)
    DO(DOMAIN_MEMBER)
    DO(PRINTQ_SERVER)
    DO(DIALIN_SERVER)
    DO(XENIX_SERVER)
    DO(NT)
    DO(POTENTIAL_BROWSER)
    DO(BACKUP_BROWSER)
    DO(MASTER_BROWSER)
    DO(DOMAIN_MASTER)

    DisplayString(TEXT("Server Type"), str);
    if (Type != 0) {
        DisplayDwordHex( TEXT("UNEXPECTED TYPE BIT(S)"), Type );
    }

} // DisplayServerType
VOID
DisplayLanManVersion(
    IN DWORD MajorVersion,
    IN DWORD MinorVersion
    )
{
    DisplayTag( TEXT("LanMan version") );
    printf(FORMAT_DWORD "." FORMAT_DWORD "\n",
            (DWORD) (MajorVersion & (MAJOR_VERSION_MASK)),
            (DWORD) (MinorVersion) );

} // DisplayLanManVersion

DBGSTATIC VOID
DisplayDisconnectTime(
    IN LONG DiscTime
    )
{
    DisplayTag( TEXT("Idle session time (min)") );
    if (DiscTime == SV_NODISC) {
        printf("infinite\n" );
    } else {
        printf(FORMAT_LONG "\n", DiscTime );
    }
} // NetpDbgDisplayDisconnectTime

DBGSTATIC VOID
DisplayLicenses(
    IN DWORD MajorVersion,
    IN DWORD Licenses
    )
{
    UNREFERENCED_PARAMETER( MajorVersion );

    DisplayDword( TEXT("Licenses (NOT users)"), Licenses );
}

VOID
DisplayPlatformId(
    IN DWORD Value
    )
{
    LPTSTR String;

    switch (Value) {
    case PLATFORM_ID_DOS : String = TEXT("DOS");     break;
    case PLATFORM_ID_OS2 : String = TEXT("OS2");     break;
    case PLATFORM_ID_NT  : String = TEXT("NT");      break;
    default              : String = TEXT("unknown"); break;
    }

    DisplayString( TEXT("Platform ID"), String );
}
VOID
DisplayBool(
    IN LPTSTR Tag,
    IN BOOL Value
    )
{
    DisplayTag( Tag );
    printf(Value ? "Yes" : "No");
    printf("\n");

}

VOID
DisplayDword(
    IN LPTSTR Tag,
    IN DWORD Value
    )
{
    DisplayTag( Tag );
    printf(FORMAT_DWORD, Value);
    printf("\n");

} // DbgDisplayDword
VOID
DisplayServerInfo(
    IN DWORD Level,
    IN LPVOID Info
    )
{
    printf("server info (level " FORMAT_DWORD ") at "
                FORMAT_LPVOID ":\n", Level, (LPVOID) Info);
    NetpAssert(Info != NULL);

    switch (Level) {
    case 0 :
        {
            LPSERVER_INFO_0 psv0 = Info;
            DisplayString(TEXT("name"), psv0->sv0_name);
        }
        break;

    case 1 :
        {
            LPSERVER_INFO_1 psv1 = Info;
            DisplayString(TEXT("name"), psv1->sv1_name);
            DisplayLanManVersion(
                        psv1->sv1_version_major,
                        psv1->sv1_version_minor);
            DisplayServerType( psv1->sv1_type );
            DisplayString(TEXT("comment"), psv1->sv1_comment);
        }
        break;

    case 2 :
        {
            LPSERVER_INFO_2 psv2 = Info;
            DisplayString(TEXT("name"), psv2->sv2_name);
            DisplayLanManVersion(
                        psv2->sv2_version_major,
                        psv2->sv2_version_minor);
            DisplayServerType( psv2->sv2_type );
            DisplayString(TEXT("comment"), psv2->sv2_comment);
            DisplayDword(TEXT("ulist_mtime"), psv2->sv2_ulist_mtime);
            DisplayDword(TEXT("glist_mtime"), psv2->sv2_glist_mtime);
            DisplayDword(TEXT("alist_mtime"), psv2->sv2_alist_mtime);
            DisplayDword(TEXT("users"), psv2->sv2_users);
            DisplayDisconnectTime( psv2->sv2_disc);
            DisplayString(TEXT("alerts"), psv2->sv2_alerts);
            DisplayDword(TEXT("security"), psv2->sv2_security);
            DisplayDword(TEXT("auditing"), psv2->sv2_auditing);
            DisplayDword(TEXT("numadmin"), psv2->sv2_numadmin);
            DisplayDword(TEXT("lanmask"), psv2->sv2_lanmask);
            DisplayDword(TEXT("hidden"), psv2->sv2_hidden);
            DisplayDword(TEXT("announce"), psv2->sv2_announce);
            DisplayDword(TEXT("anndelta"), psv2->sv2_anndelta);
            DisplayString(TEXT("guestacct"), psv2->sv2_guestacct);
            DisplayLicenses(
                    psv2->sv2_version_major,
                    psv2->sv2_licenses );
            DisplayString(TEXT("userpath"), psv2->sv2_userpath);
            DisplayDword(TEXT("chdevs"), psv2->sv2_chdevs);
            DisplayDword(TEXT("chdevq"), psv2->sv2_chdevq);
            DisplayDword(TEXT("chdevjobs"), psv2->sv2_chdevjobs);
            DisplayDword(TEXT("connections"), psv2->sv2_connections);
            DisplayDword(TEXT("shares"), psv2->sv2_shares);
            DisplayDword(TEXT("openfiles"), psv2->sv2_openfiles);
            DisplayDword(TEXT("sessopens"), psv2->sv2_sessopens);
            DisplayDword(TEXT("sessvcs"), psv2->sv2_sessvcs);
            DisplayDword(TEXT("sessreqs"), psv2->sv2_sessreqs);
            DisplayDword(TEXT("opensearch"), psv2->sv2_opensearch);
            DisplayDword(TEXT("activelocks"), psv2->sv2_activelocks);
            DisplayDword(TEXT("numreqbuf"), psv2->sv2_numreqbuf);
            DisplayDword(TEXT("sizreqbuf"), psv2->sv2_sizreqbuf);
            DisplayDword(TEXT("numbigbuf"), psv2->sv2_numbigbuf);
            DisplayDword(TEXT("numfiletasks"), psv2->sv2_numfiletasks);
            DisplayDword(TEXT("alertsched"), psv2->sv2_alertsched);
            DisplayDword(TEXT("erroralert"), psv2->sv2_erroralert);
            DisplayDword(TEXT("logonalert"), psv2->sv2_logonalert);
            DisplayDword(TEXT("accessalert"), psv2->sv2_accessalert);
            DisplayDword(TEXT("diskalert"), psv2->sv2_diskalert);
            DisplayDword(TEXT("netioalert"), psv2->sv2_netioalert);
            DisplayDword(TEXT("maxauditsz"), psv2->sv2_maxauditsz);
            DisplayString(TEXT("srvheuristics"), psv2->sv2_srvheuristics);
        }
        break;

    case 3 :
        {
            LPSERVER_INFO_3 psv3 = Info;
            DisplayString(TEXT("name"), psv3->sv3_name);
            DisplayLanManVersion(
                        psv3->sv3_version_major,
                        psv3->sv3_version_minor);
            DisplayServerType( psv3->sv3_type );
            DisplayString(TEXT("comment"), psv3->sv3_comment);
            DisplayDword(TEXT("ulist_mtime"), psv3->sv3_ulist_mtime);
            DisplayDword(TEXT("glist_mtime"), psv3->sv3_glist_mtime);
            DisplayDword(TEXT("alist_mtime"), psv3->sv3_alist_mtime);
            DisplayDword(TEXT("users"), psv3->sv3_users);
            DisplayDisconnectTime( psv3->sv3_disc );
            DisplayString(TEXT("alerts"), psv3->sv3_alerts);
            DisplayDword(TEXT("security"), psv3->sv3_security);
            DisplayDword(TEXT("auditing"), psv3->sv3_auditing);
            DisplayDword(TEXT("numadmin"), psv3->sv3_numadmin);
            DisplayDword(TEXT("lanmask"), psv3->sv3_lanmask);
            DisplayDword(TEXT("hidden"), psv3->sv3_hidden);
            DisplayDword(TEXT("announce"), psv3->sv3_announce);
            DisplayDword(TEXT("anndelta"), psv3->sv3_anndelta);
            DisplayString(TEXT("guestacct"), psv3->sv3_guestacct);
            DisplayLicenses(
                    psv3->sv3_version_major,
                    psv3->sv3_licenses );
            DisplayString(TEXT("userpath"), psv3->sv3_userpath);
            DisplayDword(TEXT("chdevs"), psv3->sv3_chdevs);
            DisplayDword(TEXT("chdevq"), psv3->sv3_chdevq);
            DisplayDword(TEXT("chdevjobs"), psv3->sv3_chdevjobs);
            DisplayDword(TEXT("connections"), psv3->sv3_connections);
            DisplayDword(TEXT("shares"), psv3->sv3_shares);
            DisplayDword(TEXT("openfiles"), psv3->sv3_openfiles);
            DisplayDword(TEXT("sessopens"), psv3->sv3_sessopens);
            DisplayDword(TEXT("sessvcs"), psv3->sv3_sessvcs);
            DisplayDword(TEXT("sessreqs"), psv3->sv3_sessreqs);
            DisplayDword(TEXT("opensearch"), psv3->sv3_opensearch);
            DisplayDword(TEXT("activelocks"), psv3->sv3_activelocks);
            DisplayDword(TEXT("numreqbuf"), psv3->sv3_numreqbuf);
            DisplayDword(TEXT("sizreqbuf"), psv3->sv3_sizreqbuf);
            DisplayDword(TEXT("numbigbuf"), psv3->sv3_numbigbuf);
            DisplayDword(TEXT("numfiletasks"), psv3->sv3_numfiletasks);
            DisplayDword(TEXT("alertsched"), psv3->sv3_alertsched);
            DisplayDword(TEXT("erroralert"), psv3->sv3_erroralert);
            DisplayDword(TEXT("logonalert"), psv3->sv3_logonalert);
            DisplayDword(TEXT("accessalert"), psv3->sv3_accessalert);
            DisplayDword(TEXT("diskalert"), psv3->sv3_diskalert);
            DisplayDword(TEXT("netioalert"), psv3->sv3_netioalert);
            DisplayDword(TEXT("maxauditsz"), psv3->sv3_maxauditsz);
            DisplayString(TEXT("srvheuristics"), psv3->sv3_srvheuristics);
            DisplayDword(TEXT("auditedevents"), psv3->sv3_auditedevents);
            DisplayDword(TEXT("autoprofile"), psv3->sv3_autoprofile);
            DisplayString(TEXT("autopath"), psv3->sv3_autopath);
        }
        break;

    case 100 :
        {
            LPSERVER_INFO_100 psv100 = Info;
            DisplayPlatformId( psv100->sv100_platform_id );
            DisplayString(TEXT("Server Name"), psv100->sv100_name);
        }
        break;

    case 101 :
        {
            LPSERVER_INFO_101 psv101 = Info;
            DisplayPlatformId( psv101->sv101_platform_id );
            DisplayString(TEXT("Server Name"), psv101->sv101_name);
            DisplayLanManVersion(
                        psv101->sv101_version_major,
                        psv101->sv101_version_minor);
            DisplayServerType( psv101->sv101_type );
            DisplayString(TEXT( "Server Comment"), psv101->sv101_comment);
        }
        break;

    case 102 :
        {
            LPSERVER_INFO_102 psv102 = Info;
            DisplayPlatformId( psv102->sv102_platform_id );
            DisplayString(TEXT("Server Name"), psv102->sv102_name);
            DisplayLanManVersion(
                        psv102->sv102_version_major,
                        psv102->sv102_version_minor );
            DisplayServerType( psv102->sv102_type );
            DisplayString(TEXT( "Server Comment"), psv102->sv102_comment );
            DisplayDword(TEXT( "users"), psv102->sv102_users );
            DisplayBool(TEXT( "Server hidden"), psv102->sv102_hidden );
            DisplayDword(TEXT( "announce"), psv102->sv102_announce );
            DisplayDword(TEXT( "announce delta"), psv102->sv102_anndelta );
            DisplayLicenses(
                    psv102->sv102_version_major,
                    psv102->sv102_licenses );
            DisplayString(TEXT( "user path"), psv102->sv102_userpath );
        }
        break;

    case 402 :
        {
            LPSERVER_INFO_402 psv402 = Info;
            DisplayDword(TEXT("ulist mtime"), psv402->sv402_ulist_mtime);
            DisplayDword(TEXT("glist mtime"), psv402->sv402_glist_mtime);
            DisplayDword(TEXT("alist mtime"), psv402->sv402_alist_mtime);
            DisplayString(TEXT("alerts"), psv402->sv402_alerts);
            DisplayDword(TEXT("security"), psv402->sv402_security);
            DisplayDword(TEXT("numadmin"), psv402->sv402_numadmin);
            DisplayDwordHex(TEXT("lanmask"), psv402->sv402_lanmask);
            DisplayString(TEXT("guestacct"), psv402->sv402_guestacct);
            DisplayDword(TEXT("chdevs"), psv402->sv402_chdevs);
            DisplayDword(TEXT("chdevq"), psv402->sv402_chdevq);
            DisplayDword(TEXT("chdevjobs"), psv402->sv402_chdevjobs);
            DisplayDword(TEXT("connections"), psv402->sv402_connections);
            DisplayDword(TEXT("shares"), psv402->sv402_shares);
            DisplayDword(TEXT("openfiles"), psv402->sv402_openfiles);
            DisplayDword(TEXT("sessopens"), psv402->sv402_sessopens);
            DisplayDword(TEXT("sessvcs"), psv402->sv402_sessvcs);
            DisplayDword(TEXT("sessreqs"), psv402->sv402_sessreqs);
            DisplayDword(TEXT("opensearch"), psv402->sv402_opensearch);
            DisplayDword(TEXT("activelocks"), psv402->sv402_activelocks);
            DisplayDword(TEXT("numreqbuf"), psv402->sv402_numreqbuf);
            DisplayDword(TEXT("sizreqbuf"), psv402->sv402_sizreqbuf);
            DisplayDword(TEXT("numbigbuf"), psv402->sv402_numbigbuf);
            DisplayDword(TEXT("numfiletasks"), psv402->sv402_numfiletasks);
            DisplayDword(TEXT("alertsched"), psv402->sv402_alertsched);
            DisplayDword(TEXT("erroralert"), psv402->sv402_erroralert);
            DisplayDword(TEXT("logonalert"), psv402->sv402_logonalert);
            DisplayDword(TEXT("diskalert"), psv402->sv402_diskalert);
            DisplayDword(TEXT("accessalert"), psv402->sv402_accessalert);
            DisplayDword(TEXT("diskalert"), psv402->sv402_diskalert);
            DisplayDword(TEXT("netioalert"), psv402->sv402_netioalert);
            DisplayDword(TEXT("maxauditsz"), psv402->sv402_maxauditsz);
            DisplayString(TEXT("srvheuristics"), psv402->sv402_srvheuristics);
        }
        break;

    case 403 :
        {
            LPSERVER_INFO_403 psv403 = Info;
            DisplayDword(TEXT("ulist mtime"), psv403->sv403_ulist_mtime);
            DisplayDword(TEXT("glist mtime"), psv403->sv403_glist_mtime);
            DisplayDword(TEXT("alist mtime"), psv403->sv403_alist_mtime);
            DisplayString(TEXT("alerts"), psv403->sv403_alerts);
            DisplayDword(TEXT("security"), psv403->sv403_security);
            DisplayDword(TEXT("numadmin"), psv403->sv403_numadmin);
            DisplayDwordHex(TEXT("lanmask"), psv403->sv403_lanmask);
            DisplayString(TEXT("guestacct"), psv403->sv403_guestacct);
            DisplayDword(TEXT("chdevs"), psv403->sv403_chdevs);
            DisplayDword(TEXT("chdevq"), psv403->sv403_chdevq);
            DisplayDword(TEXT("chdevjobs"), psv403->sv403_chdevjobs);
            DisplayDword(TEXT("connections"), psv403->sv403_connections);
            DisplayDword(TEXT("shares"), psv403->sv403_shares);
            DisplayDword(TEXT("openfiles"), psv403->sv403_openfiles);
            DisplayDword(TEXT("sessopens"), psv403->sv403_sessopens);
            DisplayDword(TEXT("sessvcs"), psv403->sv403_sessvcs);
            DisplayDword(TEXT("sessreqs"), psv403->sv403_sessreqs);
            DisplayDword(TEXT("opensearch"), psv403->sv403_opensearch);
            DisplayDword(TEXT("activelocks"), psv403->sv403_activelocks);
            DisplayDword(TEXT("numreqbuf"), psv403->sv403_numreqbuf);
            DisplayDword(TEXT("sizreqbuf"), psv403->sv403_sizreqbuf);
            DisplayDword(TEXT("numbigbuf"), psv403->sv403_numbigbuf);
            DisplayDword(TEXT("numfiletasks"), psv403->sv403_numfiletasks);
            DisplayDword(TEXT("alertsched"), psv403->sv403_alertsched);
            DisplayDword(TEXT("erroralert"), psv403->sv403_erroralert);
            DisplayDword(TEXT("logonalert"), psv403->sv403_logonalert);
            DisplayDword(TEXT("diskalert"), psv403->sv403_diskalert);
            DisplayDword(TEXT("accessalert"), psv403->sv403_accessalert);
            DisplayDword(TEXT("diskalert"), psv403->sv403_diskalert);
            DisplayDword(TEXT("netioalert"), psv403->sv403_netioalert);
            DisplayDword(TEXT("maxauditsz"), psv403->sv403_maxauditsz);
            DisplayString(TEXT("srvheuristics"), psv403->sv403_srvheuristics);
            DisplayDword(TEXT("auditedevents"), psv403->sv403_auditedevents);
            DisplayDword(TEXT("autoprofile"), psv403->sv403_autoprofile);
            DisplayString(TEXT("autopath"), psv403->sv403_autopath);
        }
        break;

    default :
        NetpAssert(FALSE);
    }

} // DisplayServerInfo
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\browser\client\brclient.h ===
/*++

Copyright (c) 1991 Microsoft Corporation

Module Name:

    brclient.h

Abstract:

    Private header file for the client end of the Browser service
    modules.

Author:

    Rita Wong (ritaw) 10-May-1991

Revision History:

--*/

#include <nt.h>                  // DbgPrint prototype
#include <ntrtl.h>                  // DbgPrint
#include <nturtl.h>                 // Needed by winbase.h

#include <windef.h>                 // DWORD
#include <winbase.h>                // LocalFree

#include <rpc.h>                    // DataTypes and runtime APIs
#include <rpcutil.h>                // GENERIC_ENUM_STRUCT

#include <lmcons.h>                 // NET_API_STATUS
#include <lmerr.h>                  // NetError codes
#include <lmremutl.h>               // SUPPORTS_RPC

#include <netlibnt.h>               // NetpNtStatusToApiStatus
#include <netdebug.h>               // NetpDbgPrint

#include <bowser.h>                 // generated by the MIDL complier
#include <brnames.h>                // Service and interface names

//
// Debug trace level bits for turning on/off trace statements in the client
// end of the Browser service
//

//
// Client stub trace output
//
#define BROWSER_DEBUG_CLIENTSTUBS    0x00000001

//
// Client RPC binding trace output
//
#define BROWSER_DEBUG_RPCBIND        0x00000002

//
// All debug flags on
//
#define BROWSER_DEBUG_ALL            0xFFFFFFFF


#if DBG

#define STATIC

#else

#define STATIC static

#endif // DBG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\browser\client\browdeb.c ===
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <lm.h>
#include <ntddbrow.h>
#include <brcommon.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <hostannc.h>
#include <lmbrowsr.h>
#include <nb30.h>
#include <rap.h>
#include <rxserver.h>
#include <srvann.h>
#include <time.h>
#include <tstring.h>
#include <netlib.h>
#include <icanon.h>
#include "..\server\brwins.h"

static char ProgramName[MAX_PATH+1] ;

struct {
    LPSTR SwitchName;
    LPSTR ShortName;
    ULONG SwitchValue;
    LPSTR SwitchInformation;
    int MinArgc;
    int MaxArgc;
    LPSTR Syntax;
} CommandSwitchList[] = {
    { "ELECT", "EL", BROWSER_DEBUG_ELECT,
          "Force election on remote domain",
          4, 5, "<Transport> <Domain> [<EmulatedDomain>]" },
    { "GETBLIST", "GB", BROWSER_DEBUG_GET_BACKUP_LIST,
          "Get backup list for domain",
          3, 5, "<Transport> [[<Domain>] REFRESH]" },
    { "GETMASTER", "GM", BROWSER_DEBUG_GET_MASTER,
          "Get remote Master Browser name (using NetBIOS)",
          4, 4, "<Transport> <Domain>" },
    { "GETPDC", "GP", BROWSER_DEBUG_GETPDC,
          "Get PDC name (using NetBIOS)",
          4, 4, "<Transport> <Domain>" },
    { "LISTWFW", "WFW", BROWSER_DEBUG_LIST_WFW,
          "List WFW servers that are actually running browser",
          3, 3, "<Domain>" },
    { "STATS", "STS", BROWSER_DEBUG_STATISTICS,
          "Dump browser statistics",
          2, 4, "[\\\\<Computer> [RESET]]" },
    { "STATUS", "STA", BROWSER_DEBUG_STATUS,
          "Display status about a domain",
          2, 4, "[-V] [<Domain>]" },
    { "TICKLE", "TIC", BROWSER_DEBUG_TICKLE,
          "Force remote master to stop",
          4, 5, "<Transport> <Domain> | \\\\<Server> [<EmulatedDomain>]" },
    { "VIEW", "VW", BROWSER_DEBUG_VIEW,
          "Remote NetServerEnum to a server or domain on transport",
#ifndef _PSS_RELEASE
          3, 7, "Transport [<Domain>|\\\\<Server> [<Flags>|/DOMAIN [<DomainToQuery> [Forever]]]]" },
#else
          3, 6, "Transport [<Domain>|\\\\<Server> [<Flags>|/DOMAIN [<DomainToQuery>]]]" },
#endif
    { "DUMPNET", "DN", BROWSER_DEBUG_DUMP_NETWORKS,
          "Display the list of transports bound to browser",
          2, 2, "" },
//
// NOTE: Any Option below and including "BREAK" will not be displayed
// with _PSS_RELEASE Defined
//
    { "BREAK", "BRK", BROWSER_DEBUG_BREAK_POINT,
          "Break into debugger in browser service",
          2, 2, "" },
    { "RPCLIST", "RPC", BROWSER_DEBUG_RPCLIST,
          "Retrieve the remote server list using RPC",
          3, 6, "<Transport> [<Domain> || \\\\<Server>] [ServerFlags] [GoForever]" },
    { "MASTERNAME", "MN", BROWSER_DEBUG_ADD_MASTERNAME,
          "Add the <Domain>[1D] Netbios unique name for a transport",
          4, 5, "<Transport> <Domain> [PAUSE]" },
    { "WKSTADOM", "WD", BROWSER_DEBUG_ADD_DOMAINNAME,
          "Add the <Domain>[00] Netbios unique name for a transport",
          4, 5, "<Transport> <Domain> [PAUSE]" },
    { "ENABLE", "EN", BROWSER_DEBUG_ENABLE_BROWSER,
          "Enable the browser service",
          2, 2, "" },
    { "DEBUG", "DBG", BROWSER_DEBUG_SET_DEBUG,
          "Change browser service debug options",
          3, 4, "[[+-]DebugFlag|<Value>] [\\\\<Computer>]" },
    { "FINDMASTER", "FM", BROWSER_DEBUG_FIND_MASTER,
          "Find master of current domain",
          3, 4, "<Transport> [<EmulatedDomain>]" },
    { "MASTERANNOUNCE", "MA", BROWSER_DEBUG_ANNOUNCE_MASTER,
          "Send a master announcement with this machine as master",
          4, 5, "<Transport> <Master> [<EmulatedDomain>]" },
    { "ILLEGAL", "ILL", BROWSER_DEBUG_ILLEGAL_DGRAM,
          "Send an illegal datagram to workstation",
          4, 5, "<Transport> <Computer> [<EmulatedDomain>]" },
    { "FORCEANNOUNCE", "FA", BROWSER_DEBUG_FORCE_ANNOUNCE,
          "Force all browsers in domain to announce to master browser",
          4, 5, "<Transport> <Domain> [<EmulatedDomain>]" },
    { "LOCALLIST", "LL", BROWSER_DEBUG_LOCAL_BRLIST,
          "Retrieve the local browser list",
          3, 5, "<Transport> [<ServerFlags>] [<EmulatedDomain>]" },
    { "ANNOUNCE", "ANN", BROWSER_DEBUG_ANNOUNCE,
          "Send server announcement w/this machine member of domain",
          4, 6, "<Transport> <Domain> [<EmulatedDomainName>] [ASMASTER]" },
    { "RPCCMP", "RC", BROWSER_DEBUG_RPCCMP,
          "Compare the RPC generated list with the Rx list",
          3, 6, "<Transport> [<Domain> || \\\\<Server>] [<ServerFlags>] [GoForever]" },
    { "TRUNCLOG", "TLG", BROWSER_DEBUG_TRUNCATE_LOG,
          "Truncate the browser log",
          2, 2, "" },
    { "BOWDEBUG", "SD", BROWSER_DEBUG_BOWSERDEBUG,
          "Set debug info in the bowser",
          3, 4, "TRUNCATE" },
    { "POPSERVER", "PS", BROWSER_DEBUG_POPULATE_SERVER,
          "Populate a workgroup with random server names",
          5, 7, "<Transport> <Domain> <NumberOfMachines> [<EmulatedDomain>] [AnnouncementFrequency]" },
    { "POPDOMAIN", "PD", BROWSER_DEBUG_POPULATE_DOMAIN,
          "Populate a workgroup with random domain names",
          5, 7, "<Transport> <Domain> <NumberOfMachines> [<EmulatedDomain>] [AnnouncementFrequency]" },
    { "OTHERDOMAIN", "OTH", BROWSER_DEBUG_GET_OTHLIST,
          "Retrieve list of otherdomains that computer listens to",
          3, 3, "<Computer>" },
    { "GETWINS", "GW", BROWSER_DEBUG_GET_WINSSERVER,
          "Retrieve the primary and backup WINS server",
          3, 3, "<Transport>" },
    { "GETDOMAIN", "GWD", BROWSER_DEBUG_GET_DOMAINLIST,
          "Retrieve the domain list from a WINS server",
          3, 3, "<Ip Address>" },
    { "GETNETBIOS", "GN", BROWSER_DEBUG_GET_NETBIOSNAMES,
          "Get Netbios names for a transport",
          3, 4, "<Transport> [<EmulatedDomain>]" },
    { "ADDALTCOMP", "AAC", BROWSER_DEBUG_ADD_ALTERNATE,
          "Add an alternate computer name",
          4, 5, "<Transport> <AlternateComptureName> [<EmulatedDomain>]" },
    { "BIND", "BND", BROWSER_DEBUG_BIND_TRANSPORT,
          "Bind a transport to the bowser",
          5, 5, "<Transport> <EmulatedDomain> <AlternateComputenanme>" },
    { "UNBIND", "UNB", BROWSER_DEBUG_UNBIND_TRANSPORT,
          "Unbind a transport from the bowser",
          3, 4, "<Transport> [<EmulatedDomain>]" },
    { "EMULATEDOMAIN", "ED", BROWSER_DEBUG_SET_EMULATEDDOMAIN,
          "Create/Set/Delete emulated domain",
          4, 5, "<EmulatedDomain> PDC|BDC|DELETE [<EmulatedComputerName>]" },
    { "EMULATEDOMAINENUM", "EDE", BROWSER_DEBUG_SET_EMULATEDDOMAINENUM,
          "Enumerate emulated domains",
          2, 2, "" },
    { "RENAME", "REN", BROWSER_DEBUG_RENAME_DOMAIN,
          "Rename the primary domain or an emulated domain",
          4, 5, "<OldDomainName> <NewDomainName> [VALIDATE_ONLY]" },
    { NULL, NULL, 0, NULL }

};


struct {
    LPSTR SwitchName;
    ULONG SwitchValue;
} DebugSwitchList[] = {
    { "INIT",        BR_INIT },
    { "CRITICAL",    BR_CRITICAL },
    { "ENUM",        BR_SERVER_ENUM },
    { "UTIL",        BR_UTIL },
    { "CONFIG",      BR_CONFIG },
    { "MAIN",        BR_MAIN },
    { "BACKUP",      BR_BACKUP },
    { "MASTER",      BR_MASTER },
    { "DOMAIN",      BR_DOMAIN },
    { "NETWORK",     BR_NETWORK },
    { "TIMER",       BR_TIMER },
    { "QUEUE",       BR_QUEUE },
    { "LOCKS",       BR_LOCKS },
    { "COMMON",      BR_COMMON },
    { "ALL",         BR_ALL },
    { NULL,          0 }

};

typedef struct _BIT_NAME {
    DWORD dwValue ;
    LPSTR lpString ;
    LPSTR Comment;
} BIT_NAME ;

BIT_NAME BitToStringTable[] = {
    { SV_TYPE_WORKSTATION, "W", "Workstation" },
    { SV_TYPE_SERVER, "S", "Server" },
    { SV_TYPE_SQLSERVER, "SQL", "SQLServer" } ,
    { SV_TYPE_DOMAIN_CTRL, "PDC", "PrimaryDomainController" } ,
    { SV_TYPE_DOMAIN_BAKCTRL, "BDC", "BackupDomainController" } ,
    { SV_TYPE_TIME_SOURCE, "TS", "TimeSource" } ,
    { SV_TYPE_AFP, "AFP", "AFPServer" } ,
    { SV_TYPE_NOVELL, "NV", "Novell" } ,
    { SV_TYPE_DOMAIN_MEMBER, "MBC", "MemberServer" } ,
    { SV_TYPE_PRINTQ_SERVER, "PQ", "PrintServer" } ,
    { SV_TYPE_DIALIN_SERVER, "DL", "DialinServer" } ,
    { SV_TYPE_XENIX_SERVER, "XN", "Xenix" } ,
    { SV_TYPE_NT, "NT", "Windows NT" } ,
    { SV_TYPE_WFW, "WFW", "WindowsForWorkgroups" } ,
    { SV_TYPE_SERVER_MFPN, "MFPN", "MS Netware" } ,
    { SV_TYPE_SERVER_NT, "SS", "StandardServer" } ,
    { SV_TYPE_POTENTIAL_BROWSER, "PBR", "PotentialBrowser" } ,
    { SV_TYPE_BACKUP_BROWSER, "BBR", "BackupBrowser" } ,
    { SV_TYPE_MASTER_BROWSER, "MBR", "MasterBrowser" } ,
    // { SV_TYPE_DOMAIN_MASTER, "DMB", "DomainMasterBrowser" } ,
    { SV_TYPE_SERVER_OSF, "OSF", "OSFServer" } ,
    { SV_TYPE_SERVER_VMS, "VMS", "VMSServer" } ,
    { SV_TYPE_WINDOWS, "W95", "Windows95" } ,
    { SV_TYPE_DFS, "DFS", "DistributedFileSystem" } ,
    { SV_TYPE_CLUSTER_NT, "CLUS", "NTCluster" },
    { SV_TYPE_DCE, "DCE", "IBM DSS" },
    { 0, "", NULL }
} ;

#include <bowdbg.h>

#ifdef notdef
struct {
    LPSTR SwitchName;
    ULONG SwitchValue;
} BowserSwitchList[] = {
    { "DOMAIN", DPRT_DOMAIN },
    { "ANNOUNCE", DPRT_ANNOUNCE },
    { "TDI", DPRT_TDI },
    { "FSPDISP", DPRT_FSPDISP },
    { "BROWSER", DPRT_BROWSER },
    { "ELECT", DPRT_ELECT },
    { "CLIENT", DPRT_CLIENT },
    { "MASTER", DPRT_MASTER },
    { "SRVENUM", DPRT_SRVENUM },
    { "NETLOGON", DPRT_NETLOGON },
    { "FSCTL", DPRT_FSCTL },
    { "INIT", DPRT_INIT },
    { "REF", DPRT_REF },
    { "SCAVTHRD", DPRT_SCAVTHRD },
    { "TIMER", DPRT_TIMER },
    { "PACK", DPRT_PACK },
    { "ALL",     0xffffffff },
    { NULL, 0 }
};
#endif // notdef

//
// forward declarations
//

NET_API_STATUS
GetBrowserTransportList(
    OUT PLMDR_TRANSPORT_LIST *TransportList
    );

VOID
BrowserStatus(
    IN BOOL Verbose,
    OUT PCHAR Domain OPTIONAL
    );

NET_API_STATUS
GetMasterServerNames(
    IN PUNICODE_STRING NetworkName,
    IN PUNICODE_STRING EmulatedDomainName,
    OUT LPWSTR *MasterName
    );

PCHAR
UnicodeToPrintfString(
    PWCHAR WideChar
    );
PCHAR
UnicodeToPrintfString2(
    PWCHAR WideChar
    );

NET_API_STATUS
GetLocalBrowseList(
    IN PUNICODE_STRING Network,
    IN PUNICODE_STRING EmulatedDomainName,
    IN ULONG Level,
    IN ULONG ServerType,
    OUT PVOID *ServerList,
    OUT PULONG EntriesRead,
    OUT PULONG TotalEntries
    );

VOID
View(
    IN PCHAR Transport,
    IN PCHAR ServerOrDomain,
    IN PCHAR Flags,
    IN PCHAR Domain,
    IN BOOL GoForever
    );

VOID
ListWFW(
    IN PCHAR Domain
    );

VOID
RpcList(
    IN PCHAR Transport,
    IN PCHAR ServerOrDomain,
    IN PCHAR Flags,
    IN BOOL GoForever
    );

VOID
RpcCmp(
    IN PCHAR Transport,
    IN PCHAR ServerOrDomain,
    IN PCHAR Flags,
    IN BOOL GoForever
    );

VOID
GetLocalList(
    IN PCHAR Transport,
    IN PCHAR FlagsString,
    IN PCHAR EmulatedDomain
    );

VOID
PrintNetbiosNames(
    IN PCHAR Transport,
    IN PCHAR EmulatedDomain OPTIONAL
    );

NET_API_STATUS
GetNetbiosNames(
    IN PUNICODE_STRING Network,
    IN PUNICODE_STRING EmulatedDomainName,
    OUT PVOID *NameList,
    OUT PULONG EntriesRead,
    OUT PULONG TotalEntries
    );

NET_API_STATUS
AddAlternateComputerName(
    IN PCHAR Transport,
    IN PCHAR ComputerName,
    IN PCHAR EmulatedDomain
    );

NET_API_STATUS
BindTransport(
    IN BOOL IsBind,
    IN PCHAR Transport,
    IN PCHAR EmulatedDomain,
    IN PCHAR ComputerName
    );

VOID
DumpTransportList(
    VOID
    );

VOID
GetOtherdomains(
    IN PCHAR ServerName
    );

VOID
IllegalDatagram(
    IN PCHAR Transport,
    IN PCHAR ServerName,
    IN PCHAR EmulatedDomain
    );
VOID
AnnounceMaster(
    IN PCHAR Transport,
    IN PCHAR ServerName,
    IN PCHAR EmulatedDomain
    );

VOID
Announce(
    IN PCHAR Transport,
    IN PCHAR Domain,
    IN PCHAR EmulatedDomain,
    IN BOOL AsMaster
    );

VOID
Populate(
    IN BOOL PopulateDomains,
    IN PCHAR Transport,
    IN PCHAR Domain,
    IN PCHAR EmulatedDomain,
    IN PCHAR NumberOfMachinesString,
    IN PCHAR PeriodicityString OPTIONAL
    );

VOID
AddMasterName(
    IN PCHAR Transport,
    IN PCHAR Domain,
    IN BOOL Pause
    );

VOID
AddDomainName(
    IN PCHAR Transport,
    IN PCHAR Domain,
    IN BOOL Pause
    );

VOID
GetMaster(
    IN PCHAR Transport,
    IN PCHAR Domain
    );

VOID
GetPdc(
    IN PCHAR Transport,
    IN PCHAR Domain
    );

VOID
FindMaster(
    IN PCHAR Transport,
    IN PCHAR EmulatedDomain
    );

VOID
Elect(
    IN PCHAR Transport,
    IN PCHAR Domain,
    IN PCHAR EmulatedDomain
    );

VOID
Tickle(
    IN PCHAR Transport,
    IN PCHAR Domain,
    IN PCHAR EmulatedDomain
    );

VOID
ForceAnnounce(
    IN PCHAR Transport,
    IN PCHAR Domain,
    IN PCHAR EmulatedDomain
    );

VOID
GetBlist(
    IN PCHAR TransportName,
    IN PCHAR DomainName,
    IN BOOLEAN ForceRescan
    );

NET_API_STATUS
EnableService(
    IN LPTSTR ServiceName
    );

VOID
DumpStatistics(
    IN ULONG NArgs,
    IN PCHAR Arg1
    );

VOID
TruncateBowserLog();

VOID
CloseBowserLog();

VOID
OpenBowserLog(PCHAR FileName);

VOID
SetBowserDebug(PCHAR DebugBits);

VOID
usage( char *details ) ;

VOID
help( char *details ) ;

BOOL
look_for_help(int argc, char **argv) ;

VOID
qualify_transport(CHAR *old_name, PUNICODE_STRING new_name, BOOL AllowNonExistent );

VOID
DisplayServerInfo101(
    PSERVER_INFO_101 Server,
    BOOL DomainEnumeration
    );

DWORD
display_sv_bits(DWORD dwBits) ;

CHAR *
get_error_text(DWORD dwErr) ;

VOID
GetWinsServer(
    IN PCHAR Transport
    );

VOID
GetDomainList(
    IN PCHAR IpAddress
    );

VOID
SetEmulatedDomain(
    IN PCHAR EmulatedDomain,
    IN PCHAR Role,
    IN PCHAR EmulatedComputer
    );

VOID
EnumEmulatedDomains(
    );

//
// functions
//

VOID
usage(
    char *details
    )
{
    ULONG i = 0;
    DWORD LineLength;
#ifndef _PSS_RELEASE
    printf("Usage: %s Command [Options]\n", ProgramName);
#else
    printf("Usage: %s Command [Options | /HELP]\n", ProgramName);
#endif
    printf("Where <Command> is one of:\n\n");


#ifndef _PSS_RELEASE
    while (CommandSwitchList[i].SwitchName != NULL)
#else
    while (CommandSwitchList[i].SwitchValue != BROWSER_DEBUG_BREAK_POINT )
#endif
    {
        printf(" %-14.14s(%3.3s) - %s\n",
               CommandSwitchList[i].SwitchName,
               CommandSwitchList[i].ShortName,
               CommandSwitchList[i].SwitchInformation);
        i += 1;
    }


    if (details)
        printf(details);

    //
    // Print the descriptions of server type bits
    //
    printf("\nIn server (or domain) list displays, the following flags are used:\n");

    LineLength = 0;
    i=0;
    while ( BitToStringTable[i].dwValue != 0 ) {
        DWORD ItemLength;

        ItemLength = strlen(BitToStringTable[i].lpString) +
                     1 +
                     strlen(BitToStringTable[i].Comment);

        if ( LineLength + ItemLength >= 77 ) {
            LineLength = 0;
            printf(",\n");
        }
        if ( LineLength == 0) {
            printf("     ");
            LineLength = 5;
        } else {
            printf(", ");
            LineLength += 2;
        }

        printf( "%s=%s", BitToStringTable[i].lpString, BitToStringTable[i].Comment);
        LineLength += ItemLength;
        i++;

    }
    printf("\n");


}

VOID
CommandUsage(
    ULONG ControlCode
    )
/*++

Routine Description:

    Print the usage description for a single command

Arguments:

    ControlCode - Control code of the command who's usage is to be printed.

Return Value:

    None

--*/
{
    ULONG Index;
    ULONG i;

    //
    // Look up the command in the list of commands.
    //

    Index = 0;
    while (CommandSwitchList[Index].SwitchName != NULL) {
        if ( ControlCode == CommandSwitchList[Index].SwitchValue ) {
            break;
        }
        Index += 1;
    }

    if (CommandSwitchList[Index].SwitchName == NULL) {
        usage("Unknown switch specified");
        return;
    }


    //
    // Print command usage.
    //

    printf( "Usage: %s %s %s\n",
            ProgramName,
            CommandSwitchList[Index].SwitchName,
            CommandSwitchList[Index].Syntax );

    //
    // Print additional command specific information.
    //
    switch (ControlCode) {
    case BROWSER_DEBUG_VIEW:
        printf("       %s VIEW <transport>\n"
              "       %s VIEW <transport> <domain>|\\\\<Server> [/DOMAIN]\n"
              "       %s VIEW <transport> <server> /DOMAIN <domain>\n",
              ProgramName,
              ProgramName,
              ProgramName );

        break;

    case BROWSER_DEBUG_SET_DEBUG:

        printf("where DebugFlag is one of the following:\n");

        i = 0;
        while (DebugSwitchList[i].SwitchName != NULL) {
            printf("\t%s\n", DebugSwitchList[i].SwitchName);
            i += 1;
        }
        break;


    case BROWSER_DEBUG_BOWSERDEBUG:
        printf("       %s BOWDEBUG CLOSE\n"
              "       %s BOWDEBUG OPEN <FileName>\n"
              "       %s BOWDEBUG DEBUG <Flags>\n",
              ProgramName,
              ProgramName,
              ProgramName );

#ifdef notdef
        printf("where Flags is one of the following:\n");

        i = 0;
        while (BowserSwitchList[i].SwitchName != NULL) {
            printf("\t%s\n", BowserSwitchList[i].SwitchName);
            i += 1;
        }
#endif // notdef

        break;
    }

    printf( "%s.\n",
            CommandSwitchList[Index].SwitchInformation );

    help("");
    exit(4);
}

VOID
help(
    char *details
    )
{
    printf("%s\nType \"%s\" to list all switches.\n", details, ProgramName);
}

VOID
qualify_transport(CHAR *old_name, PUNICODE_STRING new_name, BOOL AllowNonExistent )
{
    int len = strlen(old_name) ;
    char *devicestring = "\\device\\" ;
    int devicelen = strlen(devicestring) ;
    CHAR  QualifiedTransport[MAX_PATH] ;
    ANSI_STRING AString;
    ULONG TransportIndex;
    NET_API_STATUS Status;
    PLMDR_TRANSPORT_LIST TransportList, TransportEntry;

    //
    // Get a list of all the transports supported by the browser.
    //

    Status = GetBrowserTransportList(&TransportList);

    if (Status != NERR_Success) {
        printf("Unable to retrieve transport list: %s\n", get_error_text(Status));
        exit(Status);
    }


    //
    // Handle a transport number
    //

    if ( (TransportIndex = strtoul(old_name, NULL, 0))  != 0 ) {
        ULONG TransportNumber = 0;

        TransportEntry = TransportList;
        while (TransportEntry != NULL) {
            UNICODE_STRING TransportName;

            TransportName.Buffer = TransportEntry->TransportName;
            TransportName.Length = (USHORT)TransportEntry->TransportNameLength;
            TransportName.MaximumLength = (USHORT)TransportEntry->TransportNameLength;

            TransportNumber ++;

            //
            // If we've reached the right transport,
            //  return the transport name to the caller.
            //

            if ( TransportNumber == TransportIndex ) {
                if (!RtlCreateUnicodeString( new_name, TransportEntry->TransportName )){
                    printf("Error: Failed to create string (out of memory?)\n");
                    exit(1);
                }
                // we have a valid transport
                return;
            }

            if (TransportEntry->NextEntryOffset == 0) {
                TransportEntry = NULL;
            } else {
                TransportEntry = (PLMDR_TRANSPORT_LIST)((PCHAR)TransportEntry+TransportEntry->NextEntryOffset);
            }
        }


        printf("Browser only has %ld transports and you asked for transport %s\n", TransportNumber, old_name );

    //
    // Handle a transport name.
    //

    } else {

        // Handle transport not preceeded by \device\.
        if (_strnicmp(old_name, devicestring, devicelen) != 0) {
            strcpy(QualifiedTransport, devicestring) ;
            strcat(QualifiedTransport, (*old_name == '\\') ? old_name+1 : old_name) ;

        // Handle all other transport values.
        } else {
            strcpy(QualifiedTransport, old_name) ;
        }


        //
        // Convert it to a UNICODE_STRING
        //
        RtlInitString(&AString, QualifiedTransport);
        Status = RtlAnsiStringToUnicodeString(new_name, &AString, TRUE);
        if (ERROR_SUCCESS != Status) {
            printf("Error: Failed to create string (out of memory?)\n");
            exit(1);
        }


        //
        // Ensure the specified transport is on the list of supported transports.
        //

        TransportEntry = TransportList;
        while (TransportEntry != NULL) {
            UNICODE_STRING TransportName;

            TransportName.Buffer = TransportEntry->TransportName;
            TransportName.Length = (USHORT)TransportEntry->TransportNameLength;
            TransportName.MaximumLength = (USHORT)TransportEntry->TransportNameLength;

            //
            // If we've reached the right transport,
            //  return the transport name to the caller.
            //

            if ( RtlEqualUnicodeString( new_name, &TransportName, TRUE ) ) {
                return;
            }

            if (TransportEntry->NextEntryOffset == 0) {
                TransportEntry = NULL;
            } else {
                TransportEntry = (PLMDR_TRANSPORT_LIST)((PCHAR)TransportEntry+TransportEntry->NextEntryOffset);
            }
        }


        if (AllowNonExistent) {
            return;
        }
        printf("The browser is not bound to transport %s\n", old_name );
    }

    //
    // The transport specified was invalid.  Display the list of
    //  valid transports.
    //

    DumpTransportList();

    printf("\n%s accepts any of the following forms for transport name:\n", ProgramName );
    printf("    1, \\device\\XXX, XXX\n\n" );

    exit(0);
}



NET_API_STATUS
EnableService(
    IN LPTSTR ServiceName
    )
{
    SC_HANDLE ServiceControllerHandle;
    SC_HANDLE ServiceHandle;

    ServiceControllerHandle = OpenSCManager(NULL, NULL, SC_MANAGER_ENUMERATE_SERVICE);

    if (ServiceControllerHandle == NULL) {

        return GetLastError();
    }

    ServiceHandle = OpenService(ServiceControllerHandle, ServiceName, SERVICE_CHANGE_CONFIG);

    if (ServiceHandle == NULL) {

        CloseServiceHandle(ServiceControllerHandle);
        return GetLastError();
    }

    if (!ChangeServiceConfig(ServiceHandle, SERVICE_NO_CHANGE,
                                            SERVICE_DEMAND_START,
                                            SERVICE_NO_CHANGE,
                                            NULL,
                                            NULL,
                                            NULL,
                                            NULL,
                                            NULL,
                                            NULL,
                                            NULL)) {
        CloseServiceHandle(ServiceHandle);
        CloseServiceHandle(ServiceControllerHandle);

        return GetLastError();
    }


    CloseServiceHandle(ServiceHandle);

    CloseServiceHandle(ServiceControllerHandle);

    return NERR_Success;
}


VOID
GetBlist(
    IN PCHAR TransportName,
    IN PCHAR DomainName,
    IN BOOLEAN ForceRescan
    )
{
    NET_API_STATUS Status;
    UNICODE_STRING UTransportName;
    LPTSTR Domain;
    PWSTR *BrowserList;
    ULONG BrowserListLength;
    ULONG i;

    qualify_transport(TransportName, &UTransportName, FALSE ) ;

    Domain = NULL;

    if (DomainName != NULL) {
        UNICODE_STRING UDomainName;
        ANSI_STRING ADomainName;

        RtlInitString(&ADomainName, DomainName);

        RtlAnsiStringToUnicodeString(&UDomainName, &ADomainName, TRUE);

        Domain = UDomainName.Buffer;
    }

    Status = GetBrowserServerList(&UTransportName, Domain,
                    &BrowserList,
                    &BrowserListLength,
                    ForceRescan);

    if (Status != NERR_Success) {
        printf("Unable to get backup list: %s\n", get_error_text(Status));
        exit(1);
    }

    for (i = 0; i < BrowserListLength ; i ++ ) {
        printf("Browser: %s\n", UnicodeToPrintfString(BrowserList[i]));
    }

}

NET_API_STATUS
SendDatagramA(
    IN PCHAR Transport,
    IN PCHAR EmulatedDomain OPTIONAL,
    IN PCHAR NetbiosName,
    IN DGRECEIVER_NAME_TYPE NameType,
    IN PVOID Buffer,
    IN ULONG BufferSize
    )
/*++

Routine Description:

    Send a datagram on the specified transport.

    The arguments are in the OEM character set.

Arguments:

    Transport - Transport to send on (might not be qualified yet.)

    EmulatedDomain - Emulated Domain name. NULL implies primary domain.

#endif
    NetbiosName - Name to send the datagram to.  (If Netbios name begins with
        leading \\, they are removed.)

    NameType - Type of 'Name'

    Buffer - data to send

    BufferSize - Number of byte in 'Buffer'

Return Value:

    NET_API_STATUS - NERR_Success or reason for failure.

--*/

{
    NET_API_STATUS NetStatus;

    UNICODE_STRING TransportName;

    UNICODE_STRING EmulatedDomainName;
    ANSI_STRING AEmulatedDomainName;

    UNICODE_STRING UNetbiosName;
    ANSI_STRING ANetbiosName;

    HANDLE BrowserHandle;

    //
    // Qualify the transport name and convert it to unicode
    //
    qualify_transport(Transport, &TransportName, FALSE) ;

    //
    // Convert the emulated domain name to unicode
    //
    RtlInitString(&AEmulatedDomainName, EmulatedDomain);
    RtlAnsiStringToUnicodeString(&EmulatedDomainName, &AEmulatedDomainName, TRUE);

    //
    // Convert the destination Netbios name to unicode
    //

    if (NetbiosName[0] == '\\' && NetbiosName[1] == '\\') {
        RtlInitString(&ANetbiosName, &NetbiosName[2]);
    } else {
        RtlInitString(&ANetbiosName, NetbiosName );
    }
    RtlAnsiStringToUnicodeString(&UNetbiosName, &ANetbiosName, TRUE);


    //
    // Send the datagram
    //

    OpenBrowser(&BrowserHandle);

    NetStatus = SendDatagram( BrowserHandle,
                              &TransportName,
                              &EmulatedDomainName,
                              UNetbiosName.Buffer,
                              NameType,
                              Buffer,
                              BufferSize );

    CloseHandle(BrowserHandle);

    return NetStatus;
}

VOID
Elect(
    IN PCHAR Transport,
    IN PCHAR Domain,
    IN PCHAR EmulatedDomain
    )
{
    REQUEST_ELECTION ElectionRequest;

    ElectionRequest.Type = Election;

    ElectionRequest.ElectionRequest.Version = 0;
    ElectionRequest.ElectionRequest.Criteria = 0;
    ElectionRequest.ElectionRequest.TimeUp = 0;
    ElectionRequest.ElectionRequest.MustBeZero = 0;
    ElectionRequest.ElectionRequest.ServerName[0] = '\0';

    SendDatagramA( Transport,
                   EmulatedDomain,
                   Domain,
                   BrowserElection,
                   &ElectionRequest,
                   sizeof(ElectionRequest) );

}

VOID
Tickle(
    IN PCHAR Transport,
    IN PCHAR Domain,
    IN PCHAR EmulatedDomain
    )
{
    RESET_STATE ResetState;

    ResetState.Type = ResetBrowserState;

    ResetState.ResetStateRequest.Options = RESET_STATE_STOP_MASTER;

    SendDatagramA( Transport,
                   EmulatedDomain,
                   Domain,
                   ((Domain[0] == '\\' && Domain[1] == '\\') ?
                        ComputerName : MasterBrowser),
                   &ResetState,
                   sizeof(ResetState));

}

VOID
GetMaster(
    IN PCHAR Transport,
    IN PCHAR Domain
    )
{
    NET_API_STATUS Status;
    UNICODE_STRING TransportName;
    ANSI_STRING AString;
    WCHAR MasterName[256];
    UNICODE_STRING DomainName;

    qualify_transport(Transport, &TransportName, FALSE ) ;

    RtlInitString(&AString, Domain);
    RtlAnsiStringToUnicodeString(&DomainName, &AString, TRUE);

    Status = GetNetBiosMasterName(
                    TransportName.Buffer,
                    DomainName.Buffer,
                    MasterName,
                    NULL);

    if (Status != NERR_Success) {
        printf("Unable to get Master: %s\n", get_error_text(Status));
        exit(1);
    }

    printf("Master Browser: %s\n", UnicodeToPrintfString(MasterName));

}

#define SPACES "                "

#define ClearNcb( PNCB ) {                                          \
    RtlZeroMemory( PNCB , sizeof (NCB) );                           \
    RtlCopyMemory( (PNCB)->ncb_name,     SPACES, sizeof(SPACES)-1 );\
    RtlCopyMemory( (PNCB)->ncb_callname, SPACES, sizeof(SPACES)-1 );\
    }


VOID
AddMasterName(
    IN PCHAR Transport,
    IN PCHAR Domain,
    IN BOOL Pause
    )
{
    NET_API_STATUS Status;
    UNICODE_STRING TransportName;
    CCHAR LanaNum;
    NCB AddNameNcb;

    qualify_transport(Transport, &TransportName, FALSE) ;

    Status = BrGetLanaNumFromNetworkName(TransportName.Buffer, &LanaNum);

    if (Status != NERR_Success) {
        printf("Unable to get transport: %lx\n", Status);
        return;
    }

    ClearNcb(&AddNameNcb)

    AddNameNcb.ncb_command = NCBRESET;
    AddNameNcb.ncb_lsn = 0;           // Request resources
    AddNameNcb.ncb_lana_num = LanaNum;
    AddNameNcb.ncb_callname[0] = 0;   // 16 sessions
    AddNameNcb.ncb_callname[1] = 0;   // 16 commands
    AddNameNcb.ncb_callname[2] = 0;   // 8 names
    AddNameNcb.ncb_callname[3] = 0;   // Don't want the reserved address
    Netbios( &AddNameNcb );

    ClearNcb( &AddNameNcb );

    //
    //  Uppercase the remote name.
    //

    _strupr(Domain);

    AddNameNcb.ncb_command = NCBADDNAME;

    RtlCopyMemory( AddNameNcb.ncb_name, Domain, strlen(Domain));

    AddNameNcb.ncb_name[15] = MASTER_BROWSER_SIGNATURE;

    AddNameNcb.ncb_lana_num = LanaNum;
    AddNameNcb.ncb_length = 0;
    AddNameNcb.ncb_buffer = NULL;
    Netbios( &AddNameNcb );

    if ( AddNameNcb.ncb_retcode == NRC_GOODRET ) {
        printf("Successfully added master name!!!!!\n");
    } else {
        printf("Unable to add master name: %lx\n", AddNameNcb.ncb_retcode);
    }

    if (Pause) {
        printf("Press any key to continue...");
        getchar();
    }


}

VOID
AddDomainName(
    IN PCHAR Transport,
    IN PCHAR Domain,
    IN BOOL Pause
    )
{
    NET_API_STATUS Status;
    UNICODE_STRING TransportName;
    CCHAR LanaNum;
    NCB AddNameNcb;

    qualify_transport(Transport, &TransportName, FALSE ) ;

    Status = BrGetLanaNumFromNetworkName(TransportName.Buffer, &LanaNum);

    if (Status != NERR_Success) {
        printf("Unable to get transport: %lx\n", Status);
        return;
    }

    ClearNcb(&AddNameNcb)

    AddNameNcb.ncb_command = NCBRESET;
    AddNameNcb.ncb_lsn = 0;           // Request resources
    AddNameNcb.ncb_lana_num = LanaNum;
    AddNameNcb.ncb_callname[0] = 0;   // 16 sessions
    AddNameNcb.ncb_callname[1] = 0;   // 16 commands
    AddNameNcb.ncb_callname[2] = 0;   // 8 names
    AddNameNcb.ncb_callname[3] = 0;   // Don't want the reserved address
    Netbios( &AddNameNcb );

    ClearNcb( &AddNameNcb );

    //
    //  Uppercase the remote name.
    //

    _strupr(Domain);

    AddNameNcb.ncb_command = NCBADDNAME;

    RtlCopyMemory( AddNameNcb.ncb_name, Domain, strlen(Domain));

    AddNameNcb.ncb_name[15] = PRIMARY_DOMAIN_SIGNATURE;

    AddNameNcb.ncb_lana_num = LanaNum;
    AddNameNcb.ncb_length = 0;
    AddNameNcb.ncb_buffer = NULL;
    Netbios( &AddNameNcb );

    if ( AddNameNcb.ncb_retcode == NRC_GOODRET ) {
        printf("Successfully added master name!!!!!\n");
    } else {
        printf("Unable to add master name: %lx\n", AddNameNcb.ncb_retcode);
    }

    if (Pause) {
        printf("Press any key to continue...");
        getchar();
    }


}

VOID
FindMaster(
    IN PCHAR Transport,
    IN PCHAR EmulatedDomain
    )
{
    NET_API_STATUS Status;
    UNICODE_STRING TransportName;
    UNICODE_STRING EmulatedDomainName;
    ANSI_STRING AEmulatedDomainName;
    LPWSTR MasterName;

    qualify_transport(Transport, &TransportName, FALSE) ;

    RtlInitString(&AEmulatedDomainName, EmulatedDomain);
    Status = RtlAnsiStringToUnicodeString(&EmulatedDomainName, &AEmulatedDomainName, TRUE);
    if (ERROR_SUCCESS != Status) {
        printf("Error: Unable to create string (out of memory?)\n");
        exit(1);
    }

    Status = GetMasterServerNames(&TransportName, &EmulatedDomainName, &MasterName);

    if (Status != NERR_Success) {
        printf("Unable to get Master: %s\n", get_error_text(Status));
        exit(1);
    }

    printf("Master Browser: %s\n", UnicodeToPrintfString(MasterName));

}


NET_API_STATUS
GetMasterServerNames(
    IN PUNICODE_STRING NetworkName,
    IN PUNICODE_STRING EmulatedDomainName,
    OUT LPWSTR *MasterName
    )
/*++

Routine Description:

    This function is the worker routine called to determine the name of the
    master browser server for a particular network.

Arguments:

    None.

Return Value:

    Status - The status of the operation.

--*/
{
    NET_API_STATUS Status;
    HANDLE BrowserHandle;
    NET_API_STATUS status = NERR_Success;
    PLMDR_REQUEST_PACKET RequestPacket = NULL;


    RequestPacket = malloc(sizeof(LMDR_REQUEST_PACKET)+MAXIMUM_FILENAME_LENGTH*sizeof(WCHAR));

    if (RequestPacket == NULL) {
        return(ERROR_NOT_ENOUGH_MEMORY);
    }

    Status = OpenBrowser(&BrowserHandle);

    if (Status != NERR_Success) {
        goto cleanup;
    }

    RequestPacket->Version = LMDR_REQUEST_PACKET_VERSION_DOM;

    RequestPacket->TransportName = *NetworkName;
    RequestPacket->EmulatedDomainName = *EmulatedDomainName;

    //
    //  Reference the network while the I/O is pending.
    //

    Status = BrDgReceiverIoControl(BrowserHandle,
                    IOCTL_LMDR_GET_MASTER_NAME,
                    RequestPacket,
                    sizeof(LMDR_REQUEST_PACKET)+NetworkName->Length,
                    RequestPacket,
                    sizeof(LMDR_REQUEST_PACKET)+MAXIMUM_FILENAME_LENGTH*sizeof(WCHAR),
                    NULL);

    if (Status != NERR_Success) {

        printf("Browser: Unable to determine master for network %s: %ld\n", UnicodeToPrintfString(NetworkName->Buffer), Status);
        goto cleanup;
    }

    *MasterName = malloc(RequestPacket->Parameters.GetMasterName.MasterNameLength+sizeof(WCHAR));

    if ( *MasterName == NULL ) {
        status =  ERROR_NOT_ENOUGH_MEMORY;
        goto cleanup;
    }

    RtlCopyMemory(*MasterName,  RequestPacket->Parameters.GetMasterName.Name,
                    RequestPacket->Parameters.GetMasterName.MasterNameLength+sizeof(WCHAR));

cleanup:

    if (RequestPacket) {
        free(RequestPacket);
    }
    return Status;
}

VOID
AnnounceMaster(
    IN PCHAR Transport,
    IN PCHAR ServerName,
    IN PCHAR EmulatedDomain
    )
{
    CHAR Buffer[sizeof(MASTER_ANNOUNCEMENT)+MAX_COMPUTERNAME_LENGTH+1];
    PMASTER_ANNOUNCEMENT MasterAnnouncementp = (PMASTER_ANNOUNCEMENT)Buffer;
    ULONG ComputerNameSize = MAX_COMPUTERNAME_LENGTH+1;


    //
    // Get the computer name of this machine and put it in the announcement
    //

    GetComputerNameA( MasterAnnouncementp->MasterAnnouncement.MasterName,
                      &ComputerNameSize);


    //
    // Send the announcement
    //

    MasterAnnouncementp->Type = MasterAnnouncement;

    SendDatagramA( Transport,
                   EmulatedDomain,
                   ServerName,
                   ComputerName,
                   MasterAnnouncementp,
                   FIELD_OFFSET(MASTER_ANNOUNCEMENT, MasterAnnouncement.MasterName) + ComputerNameSize+sizeof(CHAR));

    return;
}

VOID
IllegalDatagram(
    IN PCHAR Transport,
    IN PCHAR ServerName,
    IN PCHAR EmulatedDomain
    )
{
    REQUEST_ELECTION ElectRequest;

    ElectRequest.Type = Election;

    SendDatagramA( Transport,
                   EmulatedDomain,
                   ServerName,
                   ComputerName,
                   &ElectRequest,
                   FIELD_OFFSET(REQUEST_ELECTION, ElectionRequest.TimeUp) );

    return;
}

VOID
GetOtherdomains(
    IN PCHAR ServerName
    )
{
    NET_API_STATUS Status;
    ANSI_STRING AServerName;
    UNICODE_STRING UServerName;
    PVOID Buffer;
    PSERVER_INFO_100 ServerInfo;
    ULONG i;
    ULONG EntriesRead;
    ULONG TotalEntries;
    NTSTATUS status;

    RtlInitString(&AServerName, ServerName);

    status = RtlAnsiStringToUnicodeString(&UServerName, &AServerName, TRUE);
    if (NT_ERROR(status) || !UServerName.Buffer) {
        return;
    }

    if ((wcslen(UServerName.Buffer) < 3) ||
        wcsncmp(UServerName.Buffer, TEXT("\\\\"), 2) != 0 ||
        I_NetNameValidate(NULL,
                          ((LPWSTR)UServerName.Buffer)+2,
                          NAMETYPE_COMPUTER,
                          0L))
    {
        printf("Unable to query otherdomains: Invalid computer name\n") ;
        return;
    }

    Status = I_BrowserQueryOtherDomains(UServerName.Buffer, (LPBYTE *)&Buffer, &EntriesRead, &TotalEntries);

    if (Status != NERR_Success) {
        printf("Unable to query otherdomains: %s\n", get_error_text(Status));
        return;
    }

    printf("Other domains:\n");

    ServerInfo = Buffer;

    for (i = 0 ; i < EntriesRead; i++) {
        printf("    %s\n", UnicodeToPrintfString(ServerInfo->sv100_name));
        ServerInfo ++;
    }

    return;
}

VOID
View(
    IN PCHAR Transport,
    IN PCHAR ServerOrDomain,
    IN PCHAR FlagsString,
    IN PCHAR Domain,
    IN BOOL GoForever
    )
{
    NET_API_STATUS Status;
    UNICODE_STRING TransportName;
    ANSI_STRING AServerName;
    UNICODE_STRING UServerName;
    ANSI_STRING ADomainName;
    UNICODE_STRING UDomainName;
    ULONG Flags ;
    PVOID ServerList;
    PSERVER_INFO_101 Server;
    ULONG EntriesInList;
    ULONG TotalEntries;
    unsigned int i;

    if ((ServerOrDomain && _stricmp(ServerOrDomain,"/domain")==0) ||
        (Domain && _stricmp(Domain,"/domain")==0) )
    {
        CommandUsage( BROWSER_DEBUG_VIEW );
        exit(4);
    }

    if (FlagsString)
    {
        if (_stricmp(FlagsString,"/domain")==0)
            Flags = SV_TYPE_DOMAIN_ENUM ;
    else
            Flags = strtoul(FlagsString, NULL, 0);
    }
    else
        Flags = SV_TYPE_ALL ;

    qualify_transport(Transport, &TransportName, FALSE) ;

    RtlInitString(&AServerName, ServerOrDomain);

    RtlAnsiStringToUnicodeString(&UServerName, &AServerName, TRUE);

    if (ARGUMENT_PRESENT(Domain)) {
        RtlInitString(&ADomainName, Domain);

        RtlAnsiStringToUnicodeString(&UDomainName, &ADomainName, TRUE);

        //
        // if domain is present, this must be computername
        //
        if ((wcslen(UServerName.Buffer) < 3) ||
            wcsncmp(UServerName.Buffer, TEXT("\\\\"), 2) != 0 ||
            I_NetNameValidate(NULL,
                              ((LPWSTR)UServerName.Buffer)+2,
                              NAMETYPE_COMPUTER,
                              0L))
        {
            printf("Invalid computer name: %s\n", ServerOrDomain) ;
            exit(1);
        }

    }

    if (UServerName.Buffer[0] != L'\\' || UServerName.Buffer[1] != L'\\') {
        PWSTR *BrowserList;
        ULONG BrowserListLength;

        Status = GetBrowserServerList(&TransportName, UServerName.Buffer,
                 &BrowserList, &BrowserListLength, FALSE);

        if (Status != NERR_Success) {
            printf("Unable to get backup list for %s on transport %s: %s\n", UnicodeToPrintfString(UServerName.Buffer), UnicodeToPrintfString2(TransportName.Buffer), get_error_text(Status));
            exit(1);
        }

        if (BrowserListLength == 0) {
            printf("Unable to get backup list for %s", UnicodeToPrintfString(UServerName.Buffer));
            printf(" on transport %s: %s\n", UnicodeToPrintfString(TransportName.Buffer), get_error_text(Status));
            exit(1);
        }

        UServerName.Buffer = *BrowserList;

    }

    printf("Remoting NetServerEnum to %s", UnicodeToPrintfString(UServerName.Buffer));
    printf(" on transport %s with flags %lx\n", UnicodeToPrintfString(TransportName.Buffer), Flags);

    do {

    DWORD StartTime = GetTickCount();
    DWORD EndTime;

    Status = RxNetServerEnum(UServerName.Buffer,
                             TransportName.Buffer,
                             101,
                             (LPBYTE *)&ServerList,
                             0xffffffff,
                             &EntriesInList,
                             &TotalEntries,
                             Flags,
                             ARGUMENT_PRESENT(Domain) ? UDomainName.Buffer : NULL,
                             NULL
                             );

    EndTime = GetTickCount();

    if (Status != NERR_Success) {
        printf("Unable to remote API to %s ", UnicodeToPrintfString(UServerName.Buffer));
        printf("on transport %s: %s (%d milliseconds)\n", UnicodeToPrintfString(TransportName.Buffer), get_error_text(Status), EndTime - StartTime);

        if (Status != ERROR_MORE_DATA) {
            exit(1);
        }
    }

    printf("%ld entries returned.  %ld total. %ld milliseconds\n\n", EntriesInList, TotalEntries, EndTime-StartTime);

    if (!GoForever) {
        Server = ServerList;

        for (i = 0; i < EntriesInList ; i ++ ) {
            DisplayServerInfo101( &Server[i], Flags==SV_TYPE_DOMAIN_ENUM );
            printf("\n");
        }
    }

    NetApiBufferFree(ServerList);

    } while ( GoForever );


    return;

}

VOID
ListWFW(
    IN PCHAR Domain
    )
{
    NET_API_STATUS Status;
    ANSI_STRING ADomainName;
    UNICODE_STRING UDomainName;
    PVOID ServerList;
    PSERVER_INFO_101 Server;
    ULONG EntriesInList;
    ULONG TotalEntries;
    unsigned int i;

    RtlInitString(&ADomainName, Domain);
    RtlAnsiStringToUnicodeString(&UDomainName, &ADomainName, TRUE);

    printf("Calling NetServerEnum to enumerate WFW servers.\n") ;

    Status = NetServerEnum(NULL,
                           101,
                           (LPBYTE *)&ServerList,
                           0xffffffff,
                           &EntriesInList,
                           &TotalEntries,
                           SV_TYPE_WFW,
                           UDomainName.Buffer,
                           NULL) ;

    if (Status != NERR_Success)
    {
        printf("Unable to enumerate WFW servers. Error: %s\n",
               get_error_text(Status));
        exit(1);
    }

    printf("%ld WFW servers returned. %ld total.\n",
           EntriesInList,
           TotalEntries);
    if (EntriesInList == 0)
        printf("There are WFW servers with an active Browser.\n") ;
    else
    {
        printf("The following are running the browser:\n\n") ;
        Server = ServerList;
        for (i = 0; i < EntriesInList ; i ++ ) {
            DWORD ServerType = Server[i].sv101_type ;

            if (!(ServerType & (SV_TYPE_POTENTIAL_BROWSER |
                                SV_TYPE_BACKUP_BROWSER |
                                SV_TYPE_MASTER_BROWSER ))) {
                continue ;
            }

            DisplayServerInfo101( &Server[i], FALSE );
            printf( "\n" );

        }
    }

    NetApiBufferFree(ServerList);

    return;
}


VOID
ForceAnnounce(
    IN PCHAR Transport,
    IN PCHAR Domain,
    IN PCHAR EmulatedDomain
    )
{
    REQUEST_ANNOUNCE_PACKET RequestAnnounce;
    ULONG NameSize = sizeof(RequestAnnounce.RequestAnnouncement.Reply);

    //
    // Build the request
    //

    RequestAnnounce.Type = AnnouncementRequest;

    RequestAnnounce.RequestAnnouncement.Flags = 0;

    GetComputerNameA(RequestAnnounce.RequestAnnouncement.Reply, &NameSize);

    //
    // Send the request
    //

    SendDatagramA( Transport,
                   EmulatedDomain,
                   Domain,
                   BrowserElection,
                   &RequestAnnounce,
                   FIELD_OFFSET(REQUEST_ANNOUNCE_PACKET, RequestAnnouncement.Reply) + NameSize + sizeof(CHAR));

}

VOID
GetLocalList(
    IN PCHAR Transport,
    IN PCHAR FlagsString,
    IN PCHAR EmulatedDomain
    )
{
    NET_API_STATUS Status;
    UNICODE_STRING TransportName;
    ANSI_STRING AEmulatedDomainName;
    UNICODE_STRING EmulatedDomainName;
    ULONG Flags = (FlagsString == NULL ? SV_TYPE_ALL : strtoul(FlagsString, NULL, 0));
    PVOID ServerList;
    PSERVER_INFO_101 Server;
    ULONG EntriesInList;
    ULONG TotalEntries;
    unsigned int i;

    qualify_transport(Transport, &TransportName, FALSE) ;

    RtlInitString(&AEmulatedDomainName, EmulatedDomain );
    RtlAnsiStringToUnicodeString(&EmulatedDomainName, &AEmulatedDomainName, TRUE);

    printf("Retrieving local browser list on transport %ws\\%s with flags %lx\n", EmulatedDomainName.Buffer, UnicodeToPrintfString(TransportName.Buffer), Flags);

    Status = GetLocalBrowseList (&TransportName,
                             &EmulatedDomainName,
                             101,
                             Flags,
                             (LPBYTE *)&ServerList,
                             &EntriesInList,
                             &TotalEntries
                             );

    if (Status != NERR_Success) {
        printf("Unable to retrieve local list on transport %s: %lx\n", UnicodeToPrintfString(TransportName.Buffer), Status);

        exit(1);
    }

    Server = ServerList;

    printf("%ld entries returned.  %ld total.\n", EntriesInList, TotalEntries);

    for (i = 0; i < EntriesInList ; i ++ ) {

        DisplayServerInfo101( &Server[i], Flags==SV_TYPE_DOMAIN_ENUM );

        if (Flags == SV_TYPE_BACKUP_BROWSER) {
            PUSHORT BrowserVersion = (PUSHORT)Server[i].sv101_comment - 1;
            printf("  V:%4.4x", *BrowserVersion);
        }

        printf("\n") ;

    }



    return;

}

NET_API_STATUS
GetLocalBrowseList(
    IN PUNICODE_STRING Network,
    IN PUNICODE_STRING EmulatedDomainName,
    IN ULONG Level,
    IN ULONG ServerType,
    OUT PVOID *ServerList,
    OUT PULONG EntriesRead,
    OUT PULONG TotalEntries
    )
{
    NET_API_STATUS status;
    PLMDR_REQUEST_PACKET Drp;            // Datagram receiver request packet
    ULONG DrpSize;
    HANDLE BrowserHandle;
    LPBYTE Where;

    OpenBrowser(&BrowserHandle);

    //
    // Allocate the request packet large enough to hold the variable length
    // domain name.
    //

    DrpSize = sizeof(LMDR_REQUEST_PACKET) +
                Network->Length + sizeof(WCHAR) +
                EmulatedDomainName->Length + sizeof(WCHAR);

    if ((Drp = malloc(DrpSize)) == NULL) {

        return GetLastError();
    }

    //
    // Set up request packet.  Output buffer structure is of enumerate
    // servers type.
    //

    Drp->Version = LMDR_REQUEST_PACKET_VERSION_DOM;
    Drp->Type = EnumerateServers;

    Drp->Level = Level;

    Drp->Parameters.EnumerateServers.ServerType = ServerType;
    Drp->Parameters.EnumerateServers.ResumeHandle = 0;
    Drp->Parameters.EnumerateServers.DomainNameLength = 0;
    Drp->Parameters.EnumerateServers.DomainName[0] = '\0';

    Where = ((PCHAR)Drp+sizeof(LMDR_REQUEST_PACKET));
    wcscpy( (LPWSTR)Where, Network->Buffer );
    RtlInitUnicodeString( &Drp->TransportName, (LPWSTR) Where );

    Where += Drp->TransportName.MaximumLength;
    wcscpy( (LPWSTR)Where, EmulatedDomainName->Buffer );
    RtlInitUnicodeString( &Drp->EmulatedDomainName, (LPWSTR) Where );
#ifdef notdef
    Where += Drp->EmulatedDomainName.MaximumLength;
#endif // notdef

    //
    // Ask the datagram receiver to enumerate the servers
    //

    status = DeviceControlGetInfo(
                 BrowserHandle,
                 IOCTL_LMDR_ENUMERATE_SERVERS,
                 Drp,
                 DrpSize,
                 ServerList,
                 0xffffffff,
                 4096,
                 NULL
                 );

    *EntriesRead = Drp->Parameters.EnumerateServers.EntriesRead;
    *TotalEntries = Drp->Parameters.EnumerateServers.TotalEntries;

    (void) free(Drp);

    return status;

}

VOID
PrintNetbiosNames(
    IN PCHAR Transport,
    IN PCHAR EmulatedDomain OPTIONAL
    )
/*++

Routine Description:

    Prints the list of Netbios names registered on a particular transport

Arguments:

    Transport - Transport to query

    EmulatedDomain - Emulated domain to query

#endif
Return Value:

    None

--*/
{
    NET_API_STATUS Status;
    UNICODE_STRING TransportName;
    ANSI_STRING AEmulatedDomainName;
    UNICODE_STRING EmulatedDomainName;
    PVOID NameList;
    PDGRECEIVE_NAMES Names;
    ULONG EntriesInList;
    ULONG TotalEntries;
    unsigned int i;

    //
    // Get the netbios names
    //
    qualify_transport(Transport, &TransportName, FALSE ) ;

    RtlInitString(&AEmulatedDomainName, EmulatedDomain );
    RtlAnsiStringToUnicodeString(&EmulatedDomainName, &AEmulatedDomainName, TRUE);

    printf("Retrieving browser Netbios names on transport %ws\\%ws\n", EmulatedDomainName.Buffer, TransportName.Buffer);

    Status = GetNetbiosNames(&TransportName,
                             &EmulatedDomainName,
                             &NameList,
                             &EntriesInList,
                             &TotalEntries
                             );

    if (Status != NERR_Success) {
        printf("Unable to retrieve Netbios names on transport %ws: %lx\n", TransportName.Buffer, Status);
        exit(1);
    }

    //
    // Print the netbios names.
    //

    Names = NameList;

    printf("%ld entries returned.  %ld total.\n", EntriesInList, TotalEntries);

    for (i = 0; i < EntriesInList ; i ++ ) {
        if ( Names[i].Type == DomainAnnouncement ) {
            printf("%-16.16s", "__MSBROWSE__" );
        } else {
            printf("%-16.16wZ", &Names[i].DGReceiverName );
        }
        switch ( Names[i].Type ) {
        case ComputerName:
            printf("<00> ComputerName"); break;
        case AlternateComputerName:
            printf("<00> AlternateComputerName"); break;
        case PrimaryDomain:
            printf("<00> PrimaryDomain"); break;
        case LogonDomain:
            printf("<00> LogonDomain"); break;
        case OtherDomain:
            printf("<00> OtherDomain"); break;
        case DomainAnnouncement:
            printf("DomainAnnouncement"); break;
        case MasterBrowser:
            printf("<1D> MasterBrowser"); break;
        case BrowserElection:
            printf("<1E> BrowserElection"); break;
        case BrowserServer:
            printf("<20> BrowserServer"); break;
        case DomainName:
            printf("<1C> DomainName"); break;
        case PrimaryDomainBrowser:
            printf("<1B> DomainMasterBrowser"); break;
        default:
            printf("<Unknown>"); break;
        }
        printf("\n") ;

    }

    return;

}

NET_API_STATUS
GetNetbiosNames(
    IN PUNICODE_STRING Network,
    IN PUNICODE_STRING EmulatedDomainName,
    OUT PVOID *NameList,
    OUT PULONG EntriesRead,
    OUT PULONG TotalEntries
    )
{
    NET_API_STATUS status;
    PLMDR_REQUEST_PACKET Drp;            // Datagram receiver request packet
    ULONG DrpSize;
    HANDLE BrowserHandle;
    LPBYTE Where;

    OpenBrowser(&BrowserHandle);

    //
    // Allocate the request packet large enough to hold the variable length
    // domain name.
    //

    DrpSize = sizeof(LMDR_REQUEST_PACKET) +
                Network->Length + sizeof(WCHAR) +
                EmulatedDomainName->Length + sizeof(WCHAR);

    if ((Drp = malloc(DrpSize)) == NULL) {
        return GetLastError();
    }

    //
    // Set up request packet.  Output buffer structure is of enumerate
    // servers type.
    //

    Drp->Version = LMDR_REQUEST_PACKET_VERSION_DOM;
    Drp->Type = EnumerateNames;

    Drp->Level = 0;

    Drp->Parameters.EnumerateNames.ResumeHandle = 0;

    Where = ((PCHAR)Drp+sizeof(LMDR_REQUEST_PACKET));
    wcscpy( (LPWSTR)Where, Network->Buffer );
    RtlInitUnicodeString( &Drp->TransportName, (LPWSTR) Where );

    Where += Drp->TransportName.MaximumLength;
    wcscpy( (LPWSTR)Where, EmulatedDomainName->Buffer );
    RtlInitUnicodeString( &Drp->EmulatedDomainName, (LPWSTR) Where );
#ifdef notdef
    Where += Drp->EmulatedDomainName.MaximumLength;
#endif // notdef

    //
    // Ask the datagram receiver to enumerate the names
    //

    status = DeviceControlGetInfo(
                 BrowserHandle,
                 IOCTL_LMDR_ENUMERATE_NAMES,
                 Drp,
                 DrpSize,
                 NameList,
                 0xffffffff,
                 4096,
                 NULL );

    *EntriesRead = Drp->Parameters.EnumerateNames.EntriesRead;
    *TotalEntries = Drp->Parameters.EnumerateNames.TotalEntries;

    (void) free(Drp);

    return status;

}

NET_API_STATUS
AddAlternateComputerName(
    IN PCHAR Transport,
    IN PCHAR ComputerName,
    IN PCHAR EmulatedDomain
    )
/*++

Routine Description:

    This function adds an alternate compture name on the specified transport.

Arguments:

    Transport - Transport to add the computer name on.

    ComputerName - Alternate computer name to add

    EmulatedDomain - Emulated Domain to add computer name on

Return Value:

    Status - The status of the operation.

--*/
{
    NET_API_STATUS Status;
    HANDLE BrowserHandle;
    LPBYTE Where;

    PLMDR_REQUEST_PACKET RequestPacket = NULL;

    UNICODE_STRING TransportName;
    WCHAR UnicodeComputerName[CNLEN+1];

    UNICODE_STRING EmulatedDomainName;
    ANSI_STRING AEmulatedDomainName;

    //
    // Qualify the transport name and convert it to unicode
    //
    qualify_transport(Transport, &TransportName, FALSE) ;
    NetpCopyStrToWStr( UnicodeComputerName, ComputerName );

    //
    // Convert the emulated domain name to unicode
    //
    RtlInitString(&AEmulatedDomainName, EmulatedDomain);
    RtlAnsiStringToUnicodeString(&EmulatedDomainName, &AEmulatedDomainName, TRUE);

    RequestPacket = malloc(sizeof(LMDR_REQUEST_PACKET)+(LM20_CNLEN+1)*sizeof(WCHAR));

    if (RequestPacket == NULL) {
        return(ERROR_NOT_ENOUGH_MEMORY);
    }

    Status = OpenBrowser(&BrowserHandle);

    if (Status != NERR_Success) {
        free(RequestPacket);
        return(Status);
    }

    RequestPacket->Version = LMDR_REQUEST_PACKET_VERSION;

    RequestPacket->TransportName = TransportName;
    RequestPacket->EmulatedDomainName = EmulatedDomainName;

    RequestPacket->Parameters.AddDelName.Type = AlternateComputerName;
    RequestPacket->Parameters.AddDelName.DgReceiverNameLength =
        wcslen(UnicodeComputerName)*sizeof(WCHAR);
    wcscpy(RequestPacket->Parameters.AddDelName.Name, UnicodeComputerName);
    Where = ((LPBYTE)(RequestPacket->Parameters.AddDelName.Name)) +
        RequestPacket->Parameters.AddDelName.DgReceiverNameLength +
        sizeof(WCHAR);

    //
    //  Reference the network while the I/O is pending.
    //

    Status = BrDgReceiverIoControl(BrowserHandle,
                    IOCTL_LMDR_ADD_NAME_DOM,
                    RequestPacket,
                    (DWORD)(Where - (LPBYTE)RequestPacket),
                    NULL,
                    0,
                    NULL);

    if (Status != NERR_Success) {

        printf("Browser: Unable to add name for network %s: %ld\n", UnicodeToPrintfString(TransportName.Buffer), Status);

        free(RequestPacket);

        return(Status);
    }

    free(RequestPacket);

    return Status;
}

NET_API_STATUS
BrBindToTransport(
    IN BOOL IsBind,
    IN HANDLE BrowserHandle,
    IN LPWSTR TransportName,
    IN LPWSTR EmulatedDomainName,
    IN LPWSTR EmulatedComputerName
    )
{
    NET_API_STATUS Status;
    UCHAR PacketBuffer[sizeof(LMDR_REQUEST_PACKET)+(MAXIMUM_FILENAME_LENGTH+1+CNLEN+1)*sizeof(WCHAR)];
    PLMDR_REQUEST_PACKET RequestPacket = (PLMDR_REQUEST_PACKET)PacketBuffer;


    RequestPacket->Version = LMDR_REQUEST_PACKET_VERSION_DOM;

    RequestPacket->TransportName.Length = 0;
    RequestPacket->TransportName.MaximumLength = 0;
    RtlInitUnicodeString( &RequestPacket->EmulatedDomainName, EmulatedDomainName );

    RequestPacket->Parameters.Bind.TransportNameLength = STRLEN(TransportName)*sizeof(TCHAR);

    STRCPY(RequestPacket->Parameters.Bind.TransportName, TransportName);

    if ( IsBind ) {
        RequestPacket->Level = TRUE;    // EmulatedComputerName follows transport name
        STRCAT(RequestPacket->Parameters.Bind.TransportName, EmulatedComputerName );
    }

    //
    //  This is a simple IoControl - It just updates the status.
    //

    Status = BrDgReceiverIoControl(
                    BrowserHandle,
                    IsBind ? IOCTL_LMDR_BIND_TO_TRANSPORT_DOM : IOCTL_LMDR_UNBIND_FROM_TRANSPORT_DOM,
                    RequestPacket,
                    FIELD_OFFSET(LMDR_REQUEST_PACKET, Parameters.Bind.TransportName) +
                        RequestPacket->Parameters.Bind.TransportNameLength +
                        wcslen(EmulatedComputerName) * sizeof(WCHAR) + sizeof(WCHAR),
                    NULL,
                    0,
                    NULL);

    return Status;
}

NET_API_STATUS
BindTransport(
    IN BOOL IsBind,
    IN PCHAR Transport,
    IN PCHAR EmulatedDomain,
    IN PCHAR ComputerName
    )
/*++

Routine Description:

    This function binds the bowser to a particular transport.

Arguments:

    IsBind - True for a bind.  False for an unbind.

    Transport - Transport to bind to.

    EmulatedDomain - Emulated Domain to add computer name on

    ComputerName - Alternate computer name to add

Return Value:

    Status - The status of the operation.

--*/
{
    NET_API_STATUS Status;
    HANDLE BrowserHandle;
    LPBYTE Where;

    PLMDR_REQUEST_PACKET RequestPacket = NULL;

    UNICODE_STRING TransportName;
    WCHAR UnicodeComputerName[CNLEN+1];
    WCHAR UnicodeDomainName[DNLEN+1];

    //
    // Qualify the transport name and convert it to unicode
    //
    qualify_transport(Transport, &TransportName, IsBind) ;
    if ( ComputerName == NULL ) {
        *UnicodeComputerName = L'\0';
    } else {
        NetpCopyStrToWStr( UnicodeComputerName, ComputerName );
    }
    if ( EmulatedDomain == NULL ) {
        *UnicodeDomainName = L'\0';
    } else {
        NetpCopyStrToWStr( UnicodeDomainName, EmulatedDomain );
    }


    //
    // Open the browser driver.
    Status = OpenBrowser(&BrowserHandle);

    if (Status != NERR_Success) {
        return(Status);
    }

    //
    //
    Status = BrBindToTransport(
                            IsBind,
                            BrowserHandle,
                            TransportName.Buffer,
                            UnicodeDomainName,
                            UnicodeComputerName );
    if (Status != NERR_Success) {
        printf("Browser: Unable to bind to network %s: %ld\n", UnicodeToPrintfString(TransportName.Buffer), Status);
    }

    return Status;
}

VOID
Announce(
    IN PCHAR Transport,
    IN PCHAR Domain,
    IN PCHAR EmulatedDomain,
    IN BOOL AsMaster
    )
{

    NET_API_STATUS NetStatus;
    PSERVER_INFO_101 ServerInfo;
    PWKSTA_INFO_101 WkstaInfo;
    UNICODE_STRING TransportName;
    LPBYTE Buffer;
    ULONG BrowserType;
    ULONG OriginalBrowserType;
    WCHAR UDomain[256];
    WCHAR ServerComment[256];
    WCHAR ServerName[256];
    BOOLEAN IsLocalDomain;
    SERVICE_STATUS ServiceStatus;
    DWORD VersionMajor;
    DWORD VersionMinor;
    BOOL UsedDefaultChar;

#define ANN_BITS_OF_INTEREST (SV_TYPE_BACKUP_BROWSER | SV_TYPE_POTENTIAL_BROWSER | SV_TYPE_MASTER_BROWSER)
    qualify_transport(Transport, &TransportName, FALSE ) ;


    MultiByteToWideChar(CP_ACP, 0, Domain, strlen(Domain)+1, UDomain, 255);

    NetServerGetInfo(NULL, 101, &Buffer);

    ServerInfo = (PSERVER_INFO_101 )Buffer;

    BrowserType = ServerInfo->sv101_type & ANN_BITS_OF_INTEREST;

    wcscpy(ServerComment, ServerInfo->sv101_comment);

    wcscpy(ServerName, ServerInfo->sv101_name);

    VersionMajor = ServerInfo->sv101_version_major;

    VersionMinor = ServerInfo->sv101_version_minor;

    NetApiBufferFree(Buffer);

    NetWkstaGetInfo(NULL, 101, &Buffer);

    WkstaInfo = (PWKSTA_INFO_101 )Buffer;

    IsLocalDomain = !_wcsicmp(UDomain, WkstaInfo->wki101_langroup);

    NetApiBufferFree(Buffer);

    OriginalBrowserType = BrowserType;

    if (AsMaster) {
        BrowserType |= SV_TYPE_MASTER_BROWSER;
    }

    //
    //  If the browser is running, and this is our local domain, have the
    //  server do the announcing.
    //

    if (IsLocalDomain &&
        CheckForService(SERVICE_BROWSER, &ServiceStatus) == NERR_Success ) {

        printf("Toggling local server status bits to %lx and then to %lx\n",
                    BrowserType, OriginalBrowserType);

        I_NetServerSetServiceBitsEx(NULL, NULL, TransportName.Buffer, ANN_BITS_OF_INTEREST, BrowserType, TRUE);

        I_NetServerSetServiceBitsEx(NULL, NULL, TransportName.Buffer, ANN_BITS_OF_INTEREST, OriginalBrowserType, TRUE);

    } else {
        BROWSE_ANNOUNCE_PACKET BrowseAnnouncement;

        printf("Announcing to domain %s by hand\n", UnicodeToPrintfString(UDomain));

        BrowseAnnouncement.BrowseType = (AsMaster ? LocalMasterAnnouncement : HostAnnouncement);

        BrowseAnnouncement.BrowseAnnouncement.UpdateCount = 0;

        WideCharToMultiByte(CP_OEMCP, 0,
                            ServerName,
                            wcslen(ServerName)+1,
                            BrowseAnnouncement.BrowseAnnouncement.ServerName,
                            LM20_CNLEN+1,
                            "?",
                            &UsedDefaultChar
                            );

        BrowseAnnouncement.BrowseAnnouncement.VersionMajor = (UCHAR)VersionMajor;
        BrowseAnnouncement.BrowseAnnouncement.VersionMinor = (UCHAR)VersionMinor;
        BrowseAnnouncement.BrowseAnnouncement.Type = BrowserType;

        WideCharToMultiByte(CP_OEMCP, 0,
                            ServerComment,
                            wcslen(ServerComment),
                            BrowseAnnouncement.BrowseAnnouncement.Comment,
                            LM20_MAXCOMMENTSZ+1,
                            "?",
                            &UsedDefaultChar
                            );

        BrowseAnnouncement.BrowseAnnouncement.CommentPointer = NULL;


        //
        // Send the request
        //

        NetStatus = SendDatagramA(
                       Transport,
                       EmulatedDomain,
                       Domain,
                       (AsMaster ? BrowserElection : MasterBrowser),
                       &BrowseAnnouncement,
                       sizeof(BrowseAnnouncement));

        if ( NetStatus != NO_ERROR ) {
            printf( "Couldn't send datagram: %s\n", get_error_text(NetStatus) );
        }

    }

    return;
}

VOID
RpcList(
    IN PCHAR Transport,
    IN PCHAR ServerOrDomain,
    IN PCHAR FlagsString,
    IN BOOL GoForever
    )
{
    NET_API_STATUS Status;
    UNICODE_STRING TransportName;
    ANSI_STRING AServerName;
    UNICODE_STRING UServerName;
    ULONG Flags = (FlagsString == NULL ? SV_TYPE_ALL : strtoul(FlagsString, NULL, 0));
    PVOID ServerList;
    PSERVER_INFO_101 Server;
    ULONG EntriesInList;
    ULONG TotalEntries;
    unsigned int i;

    qualify_transport(Transport, &TransportName, FALSE) ;

    RtlInitString(&AServerName, ServerOrDomain);
    Status = RtlAnsiStringToUnicodeString(&UServerName, &AServerName, TRUE);
    if (ERROR_SUCCESS != Status) {
        printf("Error: Failed to create string (out of memory?)\n");
        exit(1);
    }

    if (UServerName.Buffer[0] != L'\\' || UServerName.Buffer[1] != L'\\') {
        PWSTR *BrowserList;
        ULONG BrowserListLength;

        Status = GetBrowserServerList(&TransportName, UServerName.Buffer,
                 &BrowserList, &BrowserListLength, FALSE);

        if (Status != NERR_Success) {
            printf("Unable to get backup list for %s", UnicodeToPrintfString(UServerName.Buffer));
            printf(" on transport %s: %s\n", UnicodeToPrintfString(TransportName.Buffer), get_error_text(Status));
            exit(1);
        }

        if (BrowserListLength == 0) {
            printf("Unable to get backup list for %s", UnicodeToPrintfString(UServerName.Buffer));
            printf(" on transport %s: %s\n",
                   UnicodeToPrintfString(TransportName.Buffer), get_error_text(Status));
            exit(1);
        }

        UServerName.Buffer = *BrowserList;

    }

    printf("Remoting I_BrowserServerEnum to %s", UnicodeToPrintfString(UServerName.Buffer));
    printf(" on transport %s with flags %lx\n", UnicodeToPrintfString(TransportName.Buffer), Flags);

    do {

    Status = I_BrowserServerEnum(UServerName.Buffer,
                             TransportName.Buffer,
                             NULL,
                             101,
                             (LPBYTE *)&ServerList,
                             0xffffffff,
                             &EntriesInList,
                             &TotalEntries,
                             Flags,
                             NULL,
                             NULL
                             );

    if (Status != NERR_Success) {

        printf("Unable to remote API to %s", UnicodeToPrintfString(UServerName.Buffer));
        printf(" on transport %s: %s\n",UnicodeToPrintfString(TransportName.Buffer), get_error_text(Status));
        if (Status != ERROR_MORE_DATA) {
            exit(1);
        }
    }

    printf("%ld entries returned.  %ld total.\n", EntriesInList, TotalEntries);

    if (!GoForever) {
        Server = ServerList;

        for (i = 0; i < EntriesInList ; i ++ ) {

            DisplayServerInfo101( &Server[i], Flags==SV_TYPE_DOMAIN_ENUM );
            printf( "\n" );
        }
    }

    NetApiBufferFree(ServerList);

    } while ( GoForever );



    return;

}

VOID
RpcCmp(
    IN PCHAR Transport,
    IN PCHAR ServerOrDomain,
    IN PCHAR FlagsString,
    IN BOOL GoForever
    )
{
    NET_API_STATUS Status;
    UNICODE_STRING TransportName;
    ANSI_STRING AServerName;
    UNICODE_STRING UServerName;
    ULONG Flags = (FlagsString == NULL ? SV_TYPE_ALL : strtoul(FlagsString, NULL, 0));
    PVOID RpcServerList;
    PVOID RxServerList;
    PSERVER_INFO_101 RpcServer;
    PSERVER_INFO_101 RxServer;
    ULONG RpcEntriesInList;
    ULONG RpcTotalEntries;
    ULONG RxEntriesInList;
    ULONG RxTotalEntries;
    unsigned int i;
    unsigned int j;

    qualify_transport(Transport, &TransportName, FALSE) ;

    RtlInitString(&AServerName, ServerOrDomain);

    Status = RtlAnsiStringToUnicodeString(&UServerName, &AServerName, TRUE);
    if (ERROR_SUCCESS != Status) {
        printf("Error: Unable to create string (out of memory?)\n");
        exit(1);
    }

    if (UServerName.Buffer[0] != L'\\' || UServerName.Buffer[1] != L'\\') {
        PWSTR *BrowserList;
        ULONG BrowserListLength;

        Status = GetBrowserServerList(&TransportName, UServerName.Buffer,
                 &BrowserList, &BrowserListLength, FALSE);

        if (Status != NERR_Success) {
            printf("Unable to get backup list for %s on transport %s: %lx\n", UnicodeToPrintfString(UServerName.Buffer), UnicodeToPrintfString2(TransportName.Buffer), Status);
            exit(1);
        }

        if (BrowserListLength == 0) {
            printf("Unable to get backup list for %s on transport %s: %lx\n", UnicodeToPrintfString(UServerName.Buffer), UnicodeToPrintfString2(TransportName.Buffer), Status);
            exit(1);
        }

        UServerName.Buffer = *BrowserList;

    }

    printf("Remoting I_BrowserServerEnum to %s on transport %s with flags %lx\n", UnicodeToPrintfString(UServerName.Buffer), UnicodeToPrintfString2(TransportName.Buffer), Flags);

    do {

    Status = I_BrowserServerEnum(UServerName.Buffer,
                             TransportName.Buffer,
                             NULL,
                             101,
                             (LPBYTE *)&RpcServerList,
                             0xffffffff,
                             &RpcEntriesInList,
                             &RpcTotalEntries,
                             Flags,
                             NULL,
                             NULL
                             );

    if (Status != NERR_Success) {
        printf("Unable to remote API to %s on transport %s: %ld\n", UnicodeToPrintfString(UServerName.Buffer), UnicodeToPrintfString2(TransportName.Buffer), Status);

        exit(1);
    }

    printf("%ld entries returned from RPC.  %ld total.\n", RpcEntriesInList, RpcTotalEntries);

    if (RpcEntriesInList != RpcTotalEntries) {
        printf("EntriesRead != TotalEntries from remoted server enum\n");
    }

    if (RpcEntriesInList <= 20) {
        printf("EntriesInList returned %ld from remoted server enum\n", RpcEntriesInList);
    }


    Status = RxNetServerEnum(UServerName.Buffer,
                             TransportName.Buffer,
                             101,
                             (LPBYTE *)&RxServerList,
                             0xffffffff,
                             &RxEntriesInList,
                             &RxTotalEntries,
                             Flags,
                             NULL,
                             NULL
                             );


    if (Status != NERR_Success) {
        printf("Unable to remote API to %s on transport %s: %ld\n", UnicodeToPrintfString(UServerName.Buffer), UnicodeToPrintfString2(TransportName.Buffer), Status);
        exit(1);
    }

    printf("%ld entries returned from RX.   %ld total.\n", RxEntriesInList, RxTotalEntries);

    if (RxEntriesInList != RxTotalEntries) {
        printf("RxEntriesRead != RxEntriesInList from remoted server enum\n");
    }

    if (RxEntriesInList <= 20) {
        printf("RxEntriesInList returned %ld from remoted server enum\n", RxEntriesInList);
    }

    if (RxEntriesInList != RpcEntriesInList) {
        printf("RxEntriesRead (%ld) != RpcTotalEntries (%ld) from remoted server enum\n", RxEntriesInList, RpcEntriesInList);
    }

    RxServer = RxServerList;
    RpcServer = RpcServerList;

    for (i = 0; i < RxEntriesInList ; i ++ ) {

        for (j = 0; j < RpcEntriesInList ; j++) {

            if (RxServer[i].sv101_name != NULL &&
                RpcServer[j].sv101_name != NULL) {

                if (!wcscmp(RxServer[i].sv101_name, RpcServer[j].sv101_name)) {
                    RxServer[i].sv101_name = NULL;
                    RpcServer[j].sv101_name = NULL;
                    break;
                }
            }
        }
    }

    for (i = 0; i < RpcEntriesInList ; i++ ) {
        if (RpcServer[i].sv101_name != NULL) {
            printf("Rpc Server not in Rx List: %s\n", UnicodeToPrintfString(RpcServer[i].sv101_name));
        }
    }

    for (i = 0; i < RxEntriesInList ; i++ ) {
        if (RxServer[i].sv101_name != NULL) {
            printf("Rx Server not in Rpc List: %s\n", UnicodeToPrintfString(RxServer[i].sv101_name));
        }
    }

    NetApiBufferFree(RxServerList);
    NetApiBufferFree(RpcServerList);

    } while ( GoForever );

    return;

}

CHAR * format_dlword(ULONG high, ULONG low, CHAR * buf);

VOID
revstr_add(CHAR * target, CHAR * source);

VOID
DumpStatistics(
    IN ULONG NArgs,
    IN PCHAR Arg1
    )
{
    PBROWSER_STATISTICS Statistics = NULL;
    NET_API_STATUS Status;
    CHAR Buffer[256];
    WCHAR ServerName[256];
    LPTSTR Server = NULL;
    BOOL ResetStatistics = FALSE;

    if (NArgs == 2) {
        Server = NULL;
        ResetStatistics = FALSE;
    } else if (NArgs == 3) {
        if (*Arg1 == '\\') {
            MultiByteToWideChar(CP_ACP, 0, Arg1, strlen(Arg1)+1, ServerName, 255);

            Server = ServerName;
            ResetStatistics = FALSE;
        } else {
            Server = NULL;
            ResetStatistics = TRUE;
        }
    } else if (*Arg1 == '\\') {
        MultiByteToWideChar(CP_ACP, 0, Arg1, strlen(Arg1)+1, ServerName, 255);
        Server = ServerName;
        ResetStatistics = TRUE;
    }

    if (ResetStatistics) {
        Status = I_BrowserResetStatistics(Server);

        if (Status != NERR_Success) {
            printf("Unable to reset browser statistics: %ld\n", Status);
            exit(1);
        }
    } else {
        FILETIME LocalFileTime;
        SYSTEMTIME LocalSystemTime;

        Status = I_BrowserQueryStatistics(Server, &Statistics);

        if (Status != NERR_Success) {
            printf("Unable to query browser statistics: %ld\n", Status);
            exit(1);
        }

        if (!FileTimeToLocalFileTime((LPFILETIME)&Statistics->StatisticsStartTime, &LocalFileTime)) {
            printf("Unable to convert statistics start time: %ld\n", GetLastError());
            exit(1);
        }

        if (!FileTimeToSystemTime(&LocalFileTime, &LocalSystemTime)) {
            printf("Unable to convert statistics start time to system time: %ld\n", GetLastError());
            exit(1);
        }

        printf("Browser statistics since %ld:%ld:%ld.%ld on %ld/%d/%d\n",
                                LocalSystemTime.wHour,
                                LocalSystemTime.wMinute,
                                LocalSystemTime.wSecond,
                                LocalSystemTime.wMilliseconds,
                                LocalSystemTime.wMonth,
                                LocalSystemTime.wDay,
                                LocalSystemTime.wYear);

        printf("NumberOfServerEnumerations:\t\t\t%d\n", Statistics->NumberOfServerEnumerations);
        printf("NumberOfDomainEnumerations:\t\t\t%d\n", Statistics->NumberOfDomainEnumerations);
        printf("NumberOfOtherEnumerations:\t\t\t%d\n", Statistics->NumberOfOtherEnumerations);
        printf("NumberOfMailslotWrites:\t\t\t\t%d\n", Statistics->NumberOfMailslotWrites);
        printf("NumberOfServerAnnouncements:\t\t\t%s\n", format_dlword(Statistics->NumberOfServerAnnouncements.HighPart, Statistics->NumberOfServerAnnouncements.LowPart, Buffer));
        printf("NumberOfDomainAnnouncements:\t\t\t%s\n", format_dlword(Statistics->NumberOfDomainAnnouncements.HighPart, Statistics->NumberOfDomainAnnouncements.LowPart, Buffer));
        printf("NumberOfElectionPackets:\t\t\t%d\n", Statistics->NumberOfElectionPackets);
        printf("NumberOfGetBrowserServerListRequests:\t\t%d\n", Statistics->NumberOfGetBrowserServerListRequests);
        printf("NumberOfMissedGetBrowserServerListRequests:\t%d\n", Statistics->NumberOfMissedGetBrowserServerListRequests);
        printf("NumberOfDroppedServerAnnouncements:\t\t%d\n", Statistics->NumberOfMissedServerAnnouncements);
        printf("NumberOfDroppedMailslotDatagrams:\t\t%d\n", Statistics->NumberOfMissedMailslotDatagrams);
//        printf("NumberOfFailedMailslotAllocations:\t\t%d\n", Statistics->NumberOfFailedMailslotAllocations);
        printf("NumberOfFailedMailslotReceives:\t\t\t%d\n", Statistics->NumberOfFailedMailslotReceives);
//        printf("NumberOfFailedMailslotWrites:\t\t\t%d\n", Statistics->NumberOfFailedMailslotWrites);
//        printf("NumberOfFailedMailslotOpens:\t\t\t%d\n", Statistics->NumberOfFailedMailslotOpens);
//        printf("NumberOfFailedServerAnnounceAllocations:\t%d\n", Statistics->NumberOfFailedServerAnnounceAllocations);
        printf("NumberOfMasterAnnouncements:\t\t\t%d\n", Statistics->NumberOfDuplicateMasterAnnouncements);
        printf("NumberOfIllegalDatagrams:\t\t\t%s\n",  format_dlword(Statistics->NumberOfIllegalDatagrams.HighPart, Statistics->NumberOfIllegalDatagrams.LowPart, Buffer));
    }
}

#define DLWBUFSIZE  22  /* buffer big enough to represent a 64-bit unsigned int


/*
 * format_dlword --
 *
 * This function takes a 64-bit number and writes its base-10 representation
 * into a string.
 *
 * Much magic occurs within this function, so beware. We do a lot of string-
 * reversing and addition-by-hand in order to get it to work.
 *
 *  ENTRY
 *      high    - high 32 bits
 *      low     - low 32 bits
 *      buf     - buffer to put it into
 *
 *  RETURNS
 *      pointer to buffer if successful
 */

CHAR * format_dlword(ULONG high, ULONG low, CHAR * buf)
{
    CHAR addend[DLWBUFSIZE];  /* REVERSED power of two */
    CHAR copy[DLWBUFSIZE];
    int i = 0;

    _ultoa(low, buf, 10);    /* the low part is easy */
    _strrev(buf);       /* and reverse it */

    /* set up addend with rep. of 2^32 */
    _ultoa(0xFFFFFFFF, addend, 10);  /* 2^32 -1 */
    _strrev(addend);            /* reversed, and will stay this way */
    revstr_add(addend, "1");        /* and add one == 2^32 */

    /* addend will contain the reverse-ASCII base-10 rep. of 2^(i+32) */

    /* now, we loop through each digit of the high longword */
    while (TRUE) {
        /* if this bit is set, add in its base-10 rep */
        if (high & 1)
            revstr_add(buf,addend);

        /* move on to next bit */
        high >>= 1;

        /* if no more digits in high, bag out */
        if (!high)
            break;

        /* we increment i, and double addend */
        i++;
        strcpy(copy, addend);
        revstr_add(addend,copy); /* i.e. add it to itself */

    }

    _strrev(buf);
    return buf;
}



/*
 * revstr_add --
 *
 *  This function will add together reversed ASCII representations of
 *  base-10 numbers.
 *
 *  Examples:   "2" + "2" = "4" "9" + "9" = "81"
 *
 *  This handles arbitrarily large numbers.
 *
 *  ENTRY
 *
 *  source  - number to add in
 *  target  - we add source to this
 *
 *  EXIT
 *  target  - contains sum of entry values of source and target
 *
 */

VOID
revstr_add(CHAR FAR * target, CHAR FAR * source)
{
    register CHAR   accum;
    register CHAR   target_digit;
    unsigned int    carrybit = 0;
    unsigned int    srcstrlen;
    unsigned int    i;

    srcstrlen = strlen(source);

    for (i = 0; (i < srcstrlen) || carrybit; ++i) {

        /* add in the source digit */
        accum =  (i < srcstrlen) ? (CHAR) (source[i] - '0') : (CHAR) 0;

        /* add in the target digit, or '0' if we hit null term */
        target_digit = target[i];
        accum += (target_digit) ? target_digit : '0';

        /* add in the carry bit */
        accum += (CHAR) carrybit;

        /* do a carry out, if necessary */
        if (accum > '9') {
            carrybit = 1;
            accum -= 10;
        }
        else
            carrybit = 0;

        /* if we're expanding the string, must put in a new null term */
        if (!target_digit)
            target[i+1] = '\0';

        /* and write out the digit */
        target[i] = accum;
    }

}

VOID
TruncateBowserLog()
{
    LMDR_REQUEST_PACKET RequestPacket;
    DWORD BytesReturned;
    HANDLE BrowserHandle;

    RtlZeroMemory(&RequestPacket, sizeof(RequestPacket));

    OpenBrowser(&BrowserHandle);

    RequestPacket.Version = LMDR_REQUEST_PACKET_VERSION_DOM;

    RequestPacket.Parameters.Debug.TruncateLog = TRUE;

    if (!DeviceIoControl(BrowserHandle, IOCTL_LMDR_DEBUG_CALL,
                                &RequestPacket, sizeof(RequestPacket),
                                NULL, 0, &BytesReturned, NULL)) {
        printf("Unable to truncate browser log: %ld\n", GetLastError());
    }

    CloseHandle(BrowserHandle);

}

VOID
CloseBowserLog()
{
    LMDR_REQUEST_PACKET RequestPacket;
    DWORD BytesReturned;
    HANDLE BrowserHandle;

    RtlZeroMemory(&RequestPacket, sizeof(RequestPacket));

    OpenBrowser(&BrowserHandle);

    RequestPacket.Version = LMDR_REQUEST_PACKET_VERSION_DOM;

    RequestPacket.Parameters.Debug.CloseLog = TRUE;

    if (!DeviceIoControl(BrowserHandle, IOCTL_LMDR_DEBUG_CALL,
                                &RequestPacket, sizeof(RequestPacket),
                                NULL, 0, &BytesReturned, NULL)) {
        printf("Unable to close browser log: %ld\n", GetLastError());
    }

    CloseHandle(BrowserHandle);

}

VOID
OpenBowserLog(PCHAR FileName)
{

    CHAR Buffer[sizeof(LMDR_REQUEST_PACKET)+4096];
    PLMDR_REQUEST_PACKET RequestPacket = (PLMDR_REQUEST_PACKET)Buffer;
    DWORD BytesReturned;
    HANDLE BrowserHandle;
    UNICODE_STRING UString;
    UNICODE_STRING NtString;
    ANSI_STRING AString;

    RtlZeroMemory(RequestPacket, sizeof(Buffer));

    OpenBrowser(&BrowserHandle);

    RtlInitString(&AString, FileName);

    UString.Buffer = RequestPacket->Parameters.Debug.TraceFileName;
    UString.MaximumLength = 4096;

    RtlAnsiStringToUnicodeString(&UString, &AString, TRUE );

    if (!RtlDosPathNameToNtPathName_U( UString.Buffer, &NtString, NULL, NULL )) {
        printf( "Invalid file name: %ws\n", UString.Buffer );
        return;
    }

    RtlCopyMemory( RequestPacket->Parameters.Debug.TraceFileName,
                   NtString.Buffer,
                   NtString.MaximumLength );

    RequestPacket->Version = LMDR_REQUEST_PACKET_VERSION_DOM;

    RequestPacket->Parameters.Debug.OpenLog = TRUE;

    if (!DeviceIoControl(BrowserHandle, IOCTL_LMDR_DEBUG_CALL,
                                RequestPacket, sizeof(Buffer),
                                NULL, 0, &BytesReturned, NULL)) {
        printf("Unable to open browser log: %ld\n", GetLastError());
    }

    CloseHandle(BrowserHandle);

}

VOID
SetBowserDebug(PCHAR DebugBits)
{
    LMDR_REQUEST_PACKET RequestPacket;
    DWORD BytesReturned;
    HANDLE BrowserHandle;
    char *end;

    RtlZeroMemory(&RequestPacket, sizeof(RequestPacket));

    OpenBrowser(&BrowserHandle);

    RequestPacket.Version = LMDR_REQUEST_PACKET_VERSION_DOM;

    RequestPacket.Parameters.Debug.DebugTraceBits = strtoul( DebugBits, &end, 16 );

    if (!DeviceIoControl(BrowserHandle, IOCTL_LMDR_DEBUG_CALL,
                                &RequestPacket, sizeof(RequestPacket),
                                NULL, 0, &BytesReturned, NULL)) {
        printf("Unable to truncate browser log: %ld\n", GetLastError());
    }

    CloseHandle(BrowserHandle);
}

#define NAME_MIN_LENGTH 4
#define NAME_LENGTH (CNLEN-NAME_MIN_LENGTH)

VOID
Populate(
    IN BOOL PopulateDomains,
    IN PCHAR Transport,
    IN PCHAR Domain,
    IN PCHAR EmulatedDomain,
    IN PCHAR NumberOfMachinesString,
    IN PCHAR PeriodicityString OPTIONAL
    )
{

    PSERVER_INFO_101 ServerInfo;
    LPBYTE Buffer;
    ULONG NumberOfMachines = strtoul(NumberOfMachinesString, NULL, 0);
    ULONG Periodicity = (PeriodicityString == NULL ? 60000 : strtoul(PeriodicityString, NULL, 0));
    ULONG ServerType;
    WCHAR ServerComment[256];
    WCHAR ComputerName[CNLEN+1];
    CHAR ServerName[256];
    DWORD VersionMajor;
    DWORD VersionMinor;
    BOOL UsedDefaultChar;
    ULONG i;
    BROWSE_ANNOUNCE_PACKET BrowseAnnouncement;
    static char ServerCharacters[] = {"ABCDEFGHIJKLMNOPQRSTUVWXYZ 1234567890.-_"};
    DWORD Seed;
    NET_API_STATUS Status;
    UNICODE_STRING TransportName;

    //
    // Sanity check the transport name
    //
    qualify_transport(Transport, &TransportName, FALSE) ;


    if (Periodicity == 0) {
        Periodicity = 60000;
    }

    NetServerGetInfo(NULL, 101, &Buffer);

    ServerInfo = (PSERVER_INFO_101 )Buffer;

    ServerType = ServerInfo->sv101_type;

    wcscpy(ServerComment, ServerInfo->sv101_comment);

    wcscpy(ComputerName, ServerInfo->sv101_name);

    VersionMajor = ServerInfo->sv101_version_major;

    VersionMinor = ServerInfo->sv101_version_minor;

    NetApiBufferFree(Buffer);

    if (PopulateDomains) {
        printf("Populating all domains on transport %s with %ld domains.  Periodicity = %ld\n", Transport, NumberOfMachines, Periodicity);
    } else {
        printf("Populating workgroup %s on transport %s with %ld servers. Periodicity = %ld\n", Domain, Transport, NumberOfMachines, Periodicity);
    }

    Seed = (DWORD) time(NULL);

    for (i = 0 ; i < NumberOfMachines; i += 1) {
        LONG NL1 = RtlRandom(&Seed) % (NAME_LENGTH-1);
        LONG NameLength;
        LONG NL2;
        LONG j;

        NL2 = NAME_LENGTH/2 - NL1;

        NameLength = NAME_LENGTH/2 + NL2 + NAME_MIN_LENGTH;

        for (j = 0; j < NameLength ; j += 1) {
            ServerName[j] = ServerCharacters[RtlRandom(&Seed) % (sizeof(ServerCharacters) - 1)];
        }

        ServerName[j] = '\0';

        //
        //  Build an announcement packet.
        //

        if (PopulateDomains) {
            BrowseAnnouncement.BrowseType = WkGroupAnnouncement;
        } else {
            BrowseAnnouncement.BrowseType = HostAnnouncement;
        }

        BrowseAnnouncement.BrowseAnnouncement.UpdateCount = 0;

        BrowseAnnouncement.BrowseAnnouncement.Periodicity = Periodicity;

        strcpy(BrowseAnnouncement.BrowseAnnouncement.ServerName, ServerName);

        BrowseAnnouncement.BrowseAnnouncement.VersionMajor = (UCHAR)VersionMajor;
        BrowseAnnouncement.BrowseAnnouncement.VersionMinor = (UCHAR)VersionMinor;
        BrowseAnnouncement.BrowseAnnouncement.Type = (ServerType & ~(SV_TYPE_BACKUP_BROWSER | SV_TYPE_MASTER_BROWSER));

        if (PopulateDomains) {
            WideCharToMultiByte(CP_OEMCP, 0,
                                ComputerName,
                                wcslen(ComputerName)+1,
                                BrowseAnnouncement.BrowseAnnouncement.Comment,
                                CNLEN+1,
                                "?",
                                &UsedDefaultChar
                                );
        } else {

            WideCharToMultiByte(CP_OEMCP, 0,
                                ServerComment,
                                wcslen(ServerComment)+1,
                                BrowseAnnouncement.BrowseAnnouncement.Comment,
                                LM20_MAXCOMMENTSZ+1,
                                "?",
                                &UsedDefaultChar
                                );
        }

        BrowseAnnouncement.BrowseAnnouncement.CommentPointer = NULL;

        //
        // Send the request
        //

        Status = SendDatagramA( Transport,
                                EmulatedDomain,
                                Domain,
                                (PopulateDomains ? DomainAnnouncement : MasterBrowser),
                                &BrowseAnnouncement,
                                sizeof(BrowseAnnouncement));

        if (Status != NERR_Success) {
            printf("Unable to send datagram: %ld\n", Status);
        }

        Sleep(50);

    }


    return;
}

NET_API_STATUS
GetBuildNumber(
    LPWSTR Server,
    LPWSTR BuildNumber
    );



NET_API_STATUS
GetStatusForTransport(
    IN BOOL Verbose,
    IN PUNICODE_STRING Transport,
    IN PUNICODE_STRING Domain
    );


VOID
BrowserStatus(
    IN BOOL Verbose,
    IN PCHAR Domain OPTIONAL
    )
{
    NET_API_STATUS Status;
    UNICODE_STRING DomainName;
    PVOID Buffer;
    PWKSTA_INFO_101 WkstaInfo;
    PLMDR_TRANSPORT_LIST TransportList, TransportEntry;

    if (Domain == NULL) {
        PWCHAR DomainBuffer = NULL;
        UNICODE_STRING TDomainName;
        Status = NetWkstaGetInfo(NULL, 101, (LPBYTE *)&Buffer);

        if (Status != NERR_Success) {
            printf("Unable to retrieve workstation information: %s\n", get_error_text(Status));
            exit(Status);
        }
        WkstaInfo = (PWKSTA_INFO_101 )Buffer;

        DomainBuffer = malloc((wcslen(WkstaInfo->wki101_langroup)+1)*sizeof(WCHAR));

        if ( DomainBuffer == NULL) {
            printf("Not enough memory\n");
            exit( ERROR_NOT_ENOUGH_MEMORY );
        }

        DomainName.Buffer = DomainBuffer;

        DomainName.MaximumLength = (wcslen(WkstaInfo->wki101_langroup)+1)*sizeof(WCHAR);

        RtlInitUnicodeString(&TDomainName, WkstaInfo->wki101_langroup);

        RtlCopyUnicodeString(&DomainName, &TDomainName);

        NetApiBufferFree(Buffer);
    } else {
        ANSI_STRING AString;

        RtlInitAnsiString(&AString, Domain);

        RtlAnsiStringToUnicodeString(&DomainName, &AString, TRUE);
    }

    //
    //  We now know the domain to query.  Iterate through the transports and
    //  get status for each of them.
    //

    Status = GetBrowserTransportList(&TransportList);

    if (Status != NERR_Success) {
        printf("Unable to retrieve transport list: %s\n", get_error_text(Status));
        exit(Status);
    }

    TransportEntry = TransportList;

    while (TransportEntry != NULL) {
        UNICODE_STRING TransportName;

        TransportName.Buffer = TransportEntry->TransportName;
        TransportName.Length = (USHORT)TransportEntry->TransportNameLength;
        TransportName.MaximumLength = (USHORT)TransportEntry->TransportNameLength;

        Status = GetStatusForTransport(Verbose, &TransportName, &DomainName);

        if (TransportEntry->NextEntryOffset == 0) {
            TransportEntry = NULL;
        } else {
            TransportEntry = (PLMDR_TRANSPORT_LIST)((PCHAR)TransportEntry+TransportEntry->NextEntryOffset);
        }
    }


    NetApiBufferFree(TransportList);

    exit(0);
}

VOID
DumpTransportList(
    VOID
    )
{
    NET_API_STATUS Status;
    PLMDR_TRANSPORT_LIST TransportList, TransportEntry;
    ULONG TransportNumber = 1;

    printf("\nList of transports currently bound to the browser\n\n" );

    //
    //  We now know the domain to query.  Iterate through the transports and
    //  get status for each of them.
    //

    Status = GetBrowserTransportList(&TransportList);

    if (Status != NERR_Success) {
        printf("Unable to retrieve transport list: %s\n", get_error_text(Status));
        exit(Status);
    }

    TransportEntry = TransportList;

    while (TransportEntry != NULL) {
        UNICODE_STRING TransportName;

        TransportName.Buffer = TransportEntry->TransportName;
        TransportName.Length = (USHORT)TransportEntry->TransportNameLength;
        TransportName.MaximumLength = (USHORT)TransportEntry->TransportNameLength;

        printf("%6.0d %-16.16wZ\n", TransportNumber, &TransportName );
        TransportNumber ++;

        if (TransportEntry->NextEntryOffset == 0) {
            TransportEntry = NULL;
        } else {
            TransportEntry = (PLMDR_TRANSPORT_LIST)((PCHAR)TransportEntry+TransportEntry->NextEntryOffset);
        }
    }


    NetApiBufferFree(TransportList);
}

NET_API_STATUS
GetBrowserTransportList(
    OUT PLMDR_TRANSPORT_LIST *TransportList
    )

/*++

Routine Description:

    This routine returns the list of transports bound into the browser.

Arguments:

    OUT PLMDR_TRANSPORT_LIST *TransportList - Transport list to return.

Return Value:

    NET_API_STATUS - NERR_Success or reason for failure.

--*/

{

    NET_API_STATUS Status;
    HANDLE BrowserHandle;
    LMDR_REQUEST_PACKET RequestPacket;

    Status = OpenBrowser(&BrowserHandle);

    if (Status != NERR_Success) {
        return Status;
    }

    RequestPacket.Version = LMDR_REQUEST_PACKET_VERSION_DOM;

    RequestPacket.Type = EnumerateXports;

    RtlInitUnicodeString(&RequestPacket.TransportName, NULL);
    RtlInitUnicodeString(&RequestPacket.EmulatedDomainName, NULL);

    Status = DeviceControlGetInfo(
                BrowserHandle,
                IOCTL_LMDR_ENUMERATE_TRANSPORTS,
                &RequestPacket,
                sizeof(RequestPacket),
                (PVOID *)TransportList,
                0xffffffff,
                4096,
                NULL);

    NtClose(BrowserHandle);

    return Status;
}

NET_API_STATUS
GetStatusForTransport(
    IN BOOL Verbose,
    IN PUNICODE_STRING Transport,
    IN PUNICODE_STRING Domain
    )
{
    WCHAR MasterName[256];
    WCHAR MasterServerName[256+2];
    NET_API_STATUS Status;
    PVOID Buffer;
    PSERVER_INFO_101 ServerInfo;
    DWORD EntriesInList;
    DWORD TotalEntries;
    DWORD BrowserListLength;
    PWSTR *BrowserList;
    DWORD i;
    DWORD NumberNTASMachines = 0;
    DWORD NumberOS2DCs = 0;
    DWORD NumberWfWMachines = 0;
    DWORD NumberOfNTMachines = 0;
    DWORD NumberWfWBrowsers = 0;
    DWORD NumberOfOs2Machines = 0;
    DWORD NumberOfBrowsers = 0;
    DWORD NumberOfBackupBrowsers = 0;
    DWORD NumberOfMasterBrowsers = 0;
    WCHAR BuildNumber[512];

    printf("\n\nStatus for domain %s on transport %s\n", UnicodeToPrintfString(Domain->Buffer), UnicodeToPrintfString2(Transport->Buffer));

    Status = GetBrowserServerList(Transport, Domain->Buffer, &BrowserList, &BrowserListLength, TRUE);

    if (Status == NERR_Success) {

        printf("    Browsing is active on domain.\n");

    } else {
        printf("    Browsing is NOT active on domain.\n", Status);

        Status = GetNetBiosMasterName(
                    Transport->Buffer,
                    Domain->Buffer,
                    MasterName,
                    NULL);

        if (Status == NERR_Success) {

            wcscpy(MasterServerName, L"\\\\");
            wcscat(MasterServerName, MasterName);

            printf("    Master browser name is held by: %s\n", UnicodeToPrintfString(MasterName));

            Status = GetBuildNumber(MasterServerName, BuildNumber);

            if (Status == NERR_Success) {
                printf("        Master browser is running build %s\n", UnicodeToPrintfString(BuildNumber));
            } else {
                PSERVER_INFO_101 pSV101;

                printf("        Unable to determine build of browser master: %d\n", Status);

                Status = NetServerGetInfo(MasterServerName, 101, (LPBYTE *)&pSV101);

                if (Status != NERR_Success) {
                    printf("   Unable to determine server information for browser master: %d\n", Status);

                    return Status;
                }

                printf("    %-16.16s.  Version:%2.2d.%2.2d  Flags: %lx ", UnicodeToPrintfString(MasterServerName), pSV101->sv101_version_major, pSV101->sv101_version_minor, pSV101->sv101_type);

                if (pSV101->sv101_type & SV_TYPE_WFW) {
                    printf("WFW ");
                }

                if (pSV101->sv101_type & SV_TYPE_NT) {
                    printf("NT ");
                }

                if (pSV101->sv101_type & SV_TYPE_POTENTIAL_BROWSER) {
                    printf("POTENTIAL ");
                }

                if (pSV101->sv101_type & SV_TYPE_BACKUP_BROWSER) {
                    printf("BACKUP ");
                }

                if (pSV101->sv101_type & SV_TYPE_MASTER_BROWSER) {
                    printf("MASTER ");
                }

                if (pSV101->sv101_type & SV_TYPE_DOMAIN_CTRL) {
                    printf("CONTROLLER ");
                }

                if (pSV101->sv101_type & SV_TYPE_DOMAIN_BAKCTRL) {
                    printf("BACKUP CONTROLLER ");
                }

                if (pSV101->sv101_type & SV_TYPE_SERVER_NT) {
                    printf("SERVER ");
                }


            }

        } else {
            printf("    Master name cannot be determined from GetAdapterStatus.\n");
        }
        return Status;
    }

    Status = GetNetBiosMasterName(
                Transport->Buffer,
                Domain->Buffer,
                MasterName,
                NULL);

    if (Status == NERR_Success) {

        wcscpy(MasterServerName, L"\\\\");
        wcscat(MasterServerName, MasterName);

        printf("    Master browser name is: %s\n", UnicodeToPrintfString(MasterName));


    } else {
        printf("    Master name cannot be determined from GetAdapterStatus.  Using %s\n", UnicodeToPrintfString(BrowserList[0]));

        wcscpy(MasterServerName, BrowserList[0]);
        wcscpy(MasterName, (BrowserList[0])+2);
    }

    //
    // Print the build number or whatever else you can find out about the master
    //

    Status = GetBuildNumber(MasterServerName, BuildNumber);

    if (Status == NERR_Success) {
        printf("        Master browser is running build %s\n", UnicodeToPrintfString(BuildNumber));
    } else {
        PSERVER_INFO_101 pSV101;

        printf("        Unable to determine build of browser master: %d\n", Status);

        Status = NetServerGetInfo(MasterServerName, 101, (LPBYTE *)&pSV101);

        if (Status != NERR_Success) {
            printf("   Unable to determine server information for browser master: %d\n", Status);
        }

        if (Status == NERR_Success) {

            printf("    \\\\%-16.16s.  Version:%2.2d.%2.2d  Flags: %lx ", UnicodeToPrintfString(MasterServerName), pSV101->sv101_version_major, pSV101->sv101_version_minor, pSV101->sv101_type);

            if (pSV101->sv101_type & SV_TYPE_WFW) {
                printf("WFW ");
            }

            if (pSV101->sv101_type & SV_TYPE_NT) {
                printf("NT ");
            }

            if (pSV101->sv101_type & SV_TYPE_POTENTIAL_BROWSER) {
                printf("POTENTIAL ");
            }

            if (pSV101->sv101_type & SV_TYPE_BACKUP_BROWSER) {
                printf("BACKUP ");
            }

            if (pSV101->sv101_type & SV_TYPE_MASTER_BROWSER) {
                printf("MASTER ");
            }

            if (pSV101->sv101_type & SV_TYPE_DOMAIN_CTRL) {
                printf("CONTROLLER ");
            }

            if (pSV101->sv101_type & SV_TYPE_DOMAIN_BAKCTRL) {
                printf("BACKUP CONTROLLER ");
            }

            if (pSV101->sv101_type & SV_TYPE_SERVER_NT) {
                printf("SERVER ");
            }

            printf("\n");
        }
    }

    printf("    %ld backup servers retrieved from master %s\n", BrowserListLength, UnicodeToPrintfString(MasterName));

    for (i = 0; i < BrowserListLength ; i++ ) {
        printf("        %s\n", UnicodeToPrintfString(BrowserList[i]));
    }


    Status = RxNetServerEnum(MasterServerName,
                             Transport->Buffer,
                             101,
                             (LPBYTE *)&Buffer,
                             0xffffffff,    // PreferedMaxLength
                             &EntriesInList,
                             &TotalEntries,
                             SV_TYPE_ALL,
//                             Domain->Buffer,
                             NULL,
                             NULL
                             );
    if (Status != NERR_Success) {
        printf("    Unable to retrieve server list from %s: %ld\n", UnicodeToPrintfString(MasterName), Status);
        return Status;
    } else {

        printf("    There are %ld servers in domain %s on transport %s\n", EntriesInList, UnicodeToPrintfString(Domain->Buffer), UnicodeToPrintfString2(Transport->Buffer));

        if (Verbose) {
            if (EntriesInList != 0) {
                ServerInfo = (PSERVER_INFO_101)Buffer;

                for (i = 0 ; i < EntriesInList ; i += 1) {
                    if (ServerInfo->sv101_type & (SV_TYPE_DOMAIN_BAKCTRL | SV_TYPE_DOMAIN_CTRL)) {

                        if (ServerInfo->sv101_type & SV_TYPE_NT) {
                            NumberNTASMachines += 1;
                        } else {
                            NumberOS2DCs += 1;
                        }

                    }

                    if (ServerInfo->sv101_type & SV_TYPE_WFW) {
                        NumberWfWMachines += 1;

                        if (ServerInfo->sv101_type & (SV_TYPE_BACKUP_BROWSER | SV_TYPE_POTENTIAL_BROWSER | SV_TYPE_MASTER_BROWSER)) {
                            NumberWfWBrowsers += 1;
                        }
                    } else if (ServerInfo->sv101_type & SV_TYPE_NT) {
                        NumberOfNTMachines += 1;
                    } else {
                        NumberOfOs2Machines += 1;
                    }

                    if (ServerInfo->sv101_type & (SV_TYPE_BACKUP_BROWSER | SV_TYPE_POTENTIAL_BROWSER | SV_TYPE_MASTER_BROWSER)) {
                        NumberOfBrowsers += 1;

                        if (ServerInfo->sv101_type & SV_TYPE_BACKUP_BROWSER) {
                            NumberOfBackupBrowsers += 1;
                        }

                        if (ServerInfo->sv101_type & SV_TYPE_MASTER_BROWSER) {
                            NumberOfMasterBrowsers += 1;
                        }
                    }

                    ServerInfo += 1;
                }

                printf("        Number of NT Advanced Servers:\t\t\t%ld\n", NumberNTASMachines);
                printf("        Number of OS/2 Domain controllers:\t\t%ld\n", NumberOS2DCs);
                printf("        Number of Windows For Workgroups machines:\t%ld\n", NumberWfWMachines);
                printf("        Number of Os/2 machines:\t\t\t%ld\n", NumberOfOs2Machines);
                printf("        Number of NT machines:\t\t\t\t%ld\n", NumberOfNTMachines);
                printf("\n");
                printf("        Number of active WfW browsers:\t\t\t%ld\n", NumberWfWBrowsers);
                printf("        Number of browsers:\t\t\t\t%ld\n", NumberOfBrowsers);
                printf("        Number of backup browsers:\t\t\t%ld\n", NumberOfBackupBrowsers);
                printf("        Number of master browsers:\t\t\t%ld\n", NumberOfMasterBrowsers);

            }
        }

    }
    Status = RxNetServerEnum(MasterServerName,
                             Transport->Buffer,
                             101,
                             (LPBYTE *)&Buffer,
                             0xffffffff,    // PreferedMaxLength
                             &EntriesInList,
                             &TotalEntries,
                             SV_TYPE_DOMAIN_ENUM,
//                             Domain->Buffer,
                             NULL,
                             NULL
                             );
    if ( Status == ERROR_MORE_DATA ) {
        printf("    Only %ld out of %ld domains could be returned\n", EntriesInList, TotalEntries );
    } else if (Status != NERR_Success) {
        printf("    Unable to retrieve server list from %s: %ld\n", UnicodeToPrintfString(MasterName), Status);
        return Status;
    }
    printf("    There are %ld domains in domain %s on transport %s\n", EntriesInList, UnicodeToPrintfString(Domain->Buffer), UnicodeToPrintfString2(Transport->Buffer));

    return NERR_Success;
}

#define BUILD_NUMBER_KEY L"SOFTWARE\\MICROSOFT\\WINDOWS NT\\CURRENTVERSION"
#define BUILD_NUMBER_BUFFER_LENGTH 80

NET_API_STATUS
GetBuildNumber(
    LPWSTR Server,
    LPWSTR BuildNumber
    )
{
    HKEY RegKey;
    HKEY RegKeyBuildNumber;
    DWORD WinStatus;
    DWORD BuildNumberLength;
    DWORD KeyType;

    WinStatus = RegConnectRegistry(Server, HKEY_LOCAL_MACHINE,
        &RegKey);
    if (WinStatus == RPC_S_SERVER_UNAVAILABLE) {
//        printf("%15ws no longer accessable", Server+2);
        return(WinStatus);
    }
    else if (WinStatus != ERROR_SUCCESS) {
        printf("Could not connect to registry, error = %d", WinStatus);
        return(WinStatus);
    }

    WinStatus = RegOpenKeyEx(RegKey, BUILD_NUMBER_KEY,0, KEY_READ,
        & RegKeyBuildNumber);
    if (WinStatus != ERROR_SUCCESS) {
        printf("Could not open key in registry, error = %d", WinStatus);
        return(WinStatus);
    }

    BuildNumberLength = BUILD_NUMBER_BUFFER_LENGTH * sizeof(WCHAR);

    WinStatus = RegQueryValueEx(RegKeyBuildNumber, L"CurrentBuildNumber",
        (LPDWORD) NULL, & KeyType, (LPBYTE) BuildNumber, & BuildNumberLength);

    if (WinStatus != ERROR_SUCCESS) {

        WinStatus = RegQueryValueEx(RegKeyBuildNumber, L"CurrentBuild",
            (LPDWORD) NULL, & KeyType, (LPBYTE) BuildNumber, & BuildNumberLength);
        if (WinStatus != ERROR_SUCCESS) {
            RegCloseKey(RegKeyBuildNumber);
            RegCloseKey(RegKey);
            return WinStatus;
        }
    }

    WinStatus = RegCloseKey(RegKeyBuildNumber);

    if (WinStatus != ERROR_SUCCESS) {
        printf("Could not close registry key, error = %d", WinStatus);
    }

    WinStatus = RegCloseKey(RegKey);

    if (WinStatus != ERROR_SUCCESS) {
        printf("Could not close registry connection, error = %d", WinStatus);
    }

    return(WinStatus);
}
NET_API_STATUS
GetNetBiosPdcName(
    IN LPWSTR NetworkName,
    IN LPWSTR PrimaryDomain,
    OUT LPWSTR MasterName
    );

VOID
GetPdc(
    IN PCHAR Transport,
    IN PCHAR Domain
    )
{
    NET_API_STATUS Status;
    UNICODE_STRING TransportName;
    ANSI_STRING AString;
    WCHAR MasterName[256];
    UNICODE_STRING DomainName;

    qualify_transport(Transport, &TransportName, FALSE ) ;

    RtlInitString(&AString, Domain);
    RtlAnsiStringToUnicodeString(&DomainName, &AString, TRUE);

    Status = GetNetBiosPdcName(TransportName.Buffer, DomainName.Buffer, MasterName);

    if (Status != NERR_Success) {
        printf("Unable to get PDC: %s\n", get_error_text(Status));
        exit(1);
    }

    printf("PDC: %s\n", UnicodeToPrintfString(MasterName));

}
NET_API_STATUS
GetNetBiosPdcName(
    IN LPWSTR NetworkName,
    IN LPWSTR PrimaryDomain,
    OUT LPWSTR MasterName
    )
{
    CCHAR LanaNum;
    NCB AStatNcb;
    struct {
        ADAPTER_STATUS AdapterInfo;
        NAME_BUFFER Names[32];
    } AdapterStatus;
    WORD i;
    CHAR remoteName[CNLEN+1];
    NET_API_STATUS Status;
    BOOL UsedDefaultChar;

    Status = BrGetLanaNumFromNetworkName(NetworkName, &LanaNum);

    if (Status != NERR_Success) {
        return Status;
    }

    ClearNcb(&AStatNcb)

    AStatNcb.ncb_command = NCBRESET;
    AStatNcb.ncb_lsn = 0;           // Request resources
    AStatNcb.ncb_lana_num = LanaNum;
    AStatNcb.ncb_callname[0] = 0;   // 16 sessions
    AStatNcb.ncb_callname[1] = 0;   // 16 commands
    AStatNcb.ncb_callname[2] = 0;   // 8 names
    AStatNcb.ncb_callname[3] = 0;   // Don't want the reserved address
    Netbios( &AStatNcb );

    ClearNcb( &AStatNcb );

    if (WideCharToMultiByte( CP_OEMCP, 0,
                                    PrimaryDomain,
                                    -1,
                                    remoteName,
                                    sizeof(remoteName),
                                    "?",
                                    &UsedDefaultChar) == 0) {
        return GetLastError();
    }

    //
    //  Uppercase the remote name.
    //

    _strupr(remoteName);

    AStatNcb.ncb_command = NCBASTAT;

    RtlCopyMemory( AStatNcb.ncb_callname, remoteName, strlen(remoteName));

    AStatNcb.ncb_callname[15] = PRIMARY_CONTROLLER_SIGNATURE;

    AStatNcb.ncb_lana_num = LanaNum;
    AStatNcb.ncb_length = sizeof( AdapterStatus );
    AStatNcb.ncb_buffer = (CHAR *)&AdapterStatus;
    Netbios( &AStatNcb );

    if ( AStatNcb.ncb_retcode == NRC_GOODRET ) {
        for ( i=0 ; i < AdapterStatus.AdapterInfo.name_count ; i++ ) {
            if (AdapterStatus.Names[i].name[NCBNAMSZ-1] == SERVER_SIGNATURE) {
//                LPWSTR SpacePointer;
                DWORD j;

                if (MultiByteToWideChar(CP_OEMCP,
                                            0,
                                            AdapterStatus.Names[i].name,
                                            CNLEN,
                                            MasterName,
                                            CNLEN) == 0) {
                    return(GetLastError());
                }

                for (j = CNLEN - 1; j ; j -= 1) {
                    if (MasterName[j] != L' ') {
                        MasterName[j+1] = UNICODE_NULL;
                        break;
                    }
                }

                return NERR_Success;
            }
        }
        return AStatNcb.ncb_retcode;
    } else {
        return AStatNcb.ncb_retcode;
    }
}

VOID
DisplayServerInfo101(
    PSERVER_INFO_101 Server,
    BOOL DomainEnumeration
    )
{
    DWORD MajorVersion, MinorVersion ;
    DWORD CharactersPrinted = 0;

    if ( DomainEnumeration ) {
        printf( "%-16.16ws", Server->sv101_name);
        CharactersPrinted += 16;
    } else {
        printf( "\\\\%-16.16ws", Server->sv101_name);
        CharactersPrinted += 18;
    }

    printf("  %s",
        (Server->sv101_platform_id == PLATFORM_ID_DOS ? "DOS" :
        (Server->sv101_platform_id == PLATFORM_ID_OS2 ?
            ((Server->sv101_type & SV_TYPE_WINDOWS) ? "W95" :
            ((Server->sv101_type & SV_TYPE_WFW) ? "WFW": "OS2" )) :
        (Server->sv101_platform_id == PLATFORM_ID_NT ? "NT " :
        "Unk") ) ) );
    CharactersPrinted += 5;

    MajorVersion = Server->sv101_version_major ;
    MinorVersion = Server->sv101_version_minor ;
    if ((MajorVersion == 1) && (MinorVersion >= 50)) {
        printf("  %2.2d.%2.2d", MajorVersion+2, MinorVersion-40);
    } else {
        printf("  %2.2d.%2.2d", MajorVersion, MinorVersion);
    }
    CharactersPrinted += 5;

    CharactersPrinted += display_sv_bits(Server->sv101_type);

    if ( Server->sv101_comment != NULL  && wcslen(Server->sv101_comment) > 0 ) {
        printf( " " );
        CharactersPrinted ++;

        while ( CharactersPrinted < 48 ) {
            printf( " " );
            CharactersPrinted ++;
        }
        while ( CharactersPrinted % 4 != 0 ) {
            printf( " " );
            CharactersPrinted ++;
        }

        printf( "%ws", Server->sv101_comment );
    }

}

//
// display server bits as defined in BitsToStringTable
//
// Returns the number of characters printed.

DWORD
display_sv_bits(DWORD dwBits)
{
    BIT_NAME *lpEntry = BitToStringTable ;
    BOOL fFirst = TRUE ;
    DWORD CharactersPrinted = 0;

    printf(" (") ;
    CharactersPrinted += 2;
    while (1)
    {
        if (lpEntry->dwValue & dwBits)
        {
            if (lpEntry != BitToStringTable && !fFirst) {
                printf(",") ;
                CharactersPrinted += 1;
            }

            dwBits &= ~lpEntry->dwValue;
            printf("%s",lpEntry->lpString) ;
            CharactersPrinted += strlen(lpEntry->lpString);
            fFirst = FALSE ;
        }
        lpEntry++ ;
        if ( !(lpEntry->dwValue) ) {
            dwBits &= ~(SV_TYPE_DOMAIN_ENUM|SV_TYPE_LOCAL_LIST_ONLY);
            if ( dwBits != 0 ) {
                if ( !fFirst ) {
                    printf(",") ;
                    CharactersPrinted += 1;
                }
                printf( "%8.8X", dwBits );
                CharactersPrinted += 8;
            }
            printf(")") ;
            CharactersPrinted += 1;
            break ;
        }
    }
    return CharactersPrinted;
}

//
// map an error number to its error message string. note, uses static,
// not reentrant.
//
CHAR *
get_error_text(DWORD dwErr)
{
    static CHAR text[512] ;
    WORD err ;
    WORD msglen ;

    memset(text,0, sizeof(text));

    //
    // get error message
    //
    err = DosGetMessage(NULL,
                        0,
                        text,
                        sizeof(text),
                        (WORD)dwErr,
                        (dwErr<NERR_BASE)||(dwErr>MAX_LANMAN_MESSAGE_ID) ?
                            TEXT("BASE"):TEXT("NETMSG"),
                        &msglen) ;

    if (err != NERR_Success)
    {
        // use number instead. if looks like NTSTATUS then use hex.
        sprintf(text, (dwErr & 0xC0000000)?"(%lx)":"(%ld)", dwErr) ;
    }

    return text ;
}

BOOL
look_for_help(int argc, char **argv)
{
    int i ;

    for (i = 2; i < argc;  i++)
    {
        if (_stricmp(argv[i],"/help") == 0)
            return TRUE ;
        if (_stricmp(argv[i],"-help") == 0)
            return TRUE ;
        if (strcmp(argv[i],"/?") == 0)
            return TRUE ;
        if (strcmp(argv[i],"-?") == 0)
            return TRUE ;
    }
    return FALSE ;
}

CHAR
PrintfBuffer[256];

PCHAR
UnicodeToPrintfString(
    PWCHAR WideChar
    )
{
    UNICODE_STRING UString;
    ANSI_STRING AString;
    AString.Buffer = PrintfBuffer;
    AString.MaximumLength = sizeof(PrintfBuffer);
    RtlInitUnicodeString(&UString, WideChar);

    RtlUnicodeStringToOemString(&AString, &UString, FALSE);

    return PrintfBuffer;
}


CHAR
PrintfBuffer2[256];

PCHAR
UnicodeToPrintfString2(
    PWCHAR WideChar
    )
{
    UNICODE_STRING UString;
    ANSI_STRING AString;

    AString.Buffer = PrintfBuffer2;

    AString.MaximumLength = sizeof(PrintfBuffer2);

    RtlInitUnicodeString(&UString, WideChar);

    RtlUnicodeStringToOemString(&AString, &UString, FALSE);

    return PrintfBuffer2;
}

VOID
GetWinsServer(
    IN PCHAR Transport
    )
{
    NET_API_STATUS Status;
    UNICODE_STRING TransportName;
    LPTSTR PrimaryWinsServerAddress;
    LPTSTR SecondaryWinsServerAddress;

    qualify_transport(Transport, &TransportName, FALSE) ;

    Status = BrGetWinsServerName(&TransportName, &PrimaryWinsServerAddress, &SecondaryWinsServerAddress);

    if (Status != NERR_Success) {
        printf("Unable to query WINS server address: %ld\n", Status);
        exit(1);
    }

    printf("Primary Wins server address: %ws\n", PrimaryWinsServerAddress);
    printf("Secondary Wins server address: %ws\n", SecondaryWinsServerAddress);

    exit(0);
}

VOID
GetDomainList(
    IN PCHAR IpAddress
    )
{
    NET_API_STATUS Status;
    PSERVER_INFO_101 WinsServerList;
    DWORD EntriesInList;
    DWORD TotalEntriesInList;
    UNICODE_STRING IpAddressString;
    ANSI_STRING IpAddressAString;
    DWORD i;

    RtlInitString(&IpAddressAString, IpAddress);

    RtlAnsiStringToUnicodeString(&IpAddressString, &IpAddressAString, TRUE);

    Status = BrQuerySpecificWinsServer(IpAddressString.Buffer, &WinsServerList, &EntriesInList, &TotalEntriesInList);

    if (Status != NERR_Success) {
        printf("Unable to query domain list from WINS server: %ld\n", Status);
        exit(1);
    }

    PrepareServerListForMerge( WinsServerList, 101, EntriesInList );

    for (i = 0; i < EntriesInList ; i ++ ) {
        printf("%-16.16s\n", UnicodeToPrintfString(WinsServerList[i].sv101_name));
    }

    exit(0);
}

NET_API_STATUS
BrMapStatus(
    IN NTSTATUS Status
    )
{
    return RtlNtStatusToDosError(Status);
}


VOID
EnumEmulatedDomains(
    )
/*++

Routine Description:

    Enumerate emulated domains.

Arguments:

    None.

Return Value:

    None.

--*/

{
    NET_API_STATUS NetStatus;
    LPWSTR EmulatedDomainName;
    LPWSTR EmulatedComputerName;
    DWORD RoleBits;

    PBROWSER_EMULATED_DOMAIN Domains;
    DWORD EntriesRead;
    DWORD i;

    //
    // Enumerate the emulated domains.
    //

    NetStatus = I_BrowserQueryEmulatedDomains(
                    NULL,
                    &Domains,
                    &EntriesRead );

    if ( NetStatus != NERR_Success ) {
        printf( "Can't enumerate EmulatedDomains: %s\n", get_error_text(NetStatus) );
        return;
    }

    if ( EntriesRead == 0 ) {
        printf( "There are no emulated domains\n" );
        return;
    }

    //
    // Print the enumerated information
    //

    for ( i=0 ; i<EntriesRead; i++ ) {
        printf( "%-16.16ws %3.3s \\\\%-16.16ws\n",
                Domains[i].DomainName,
                (Domains[i].Role & BROWSER_ROLE_PDC) ? "PDC" : "BDC",
                Domains[i].EmulatedServerName );
    }


}


VOID
SetEmulatedDomain(
    IN PCHAR EmulatedDomain,
    IN PCHAR Role,
    IN PCHAR EmulatedComputer
    )
/*++

Routine Description:

    Create and/or set role on emulated domain

Arguments:

    EmulatedDomain - Emulated Domain name.

    Role - Role this machine plays in the domain.

    EmulatedComputerName - Name of this computer in the emulated domain.
        (Need only be specified when the domain is being created.)

Return Value:

    NET_API_STATUS - NERR_Success or reason for failure.

--*/

{
    NET_API_STATUS NetStatus;
    LPWSTR EmulatedDomainName;
    LPWSTR EmulatedComputerName;
    DWORD RoleBits;

    //
    // Comvert strings to unicode.
    //

    EmulatedDomainName = NetpAllocWStrFromStr( EmulatedDomain );
    if ( EmulatedComputer != NULL ) {
        EmulatedComputerName = NetpAllocWStrFromStr( EmulatedComputer );
    } else {
        EmulatedComputerName = NULL;
    }

    //
    // Convert Role to binary
    //

    if ( _stricmp( Role, "PDC") == 0 ) {
        RoleBits = BROWSER_ROLE_PDC;
    } else if ( _stricmp( Role, "BDC") == 0 ) {
        RoleBits = BROWSER_ROLE_BDC;
    } else if ( _strnicmp( Role, "DELETE", 3) == 0 ) {
        RoleBits = 0;
    } else {
        printf( "Invalid Role: %s\n\n", Role );
        CommandUsage(BROWSER_DEBUG_SET_EMULATEDDOMAIN);
        return;
    }

    NetStatus = I_BrowserSetNetlogonState(
                    NULL,
                    EmulatedDomainName,
                    EmulatedComputerName,
                    RoleBits );

    if ( NetStatus != NERR_Success ) {
        printf( "Can't set domain role: %s\n", get_error_text(NetStatus));
    }

}

NET_API_STATUS
RenameDomain(
    IN PCHAR OldDomain,
    IN PCHAR NewDomain,
    IN BOOL ValidateOnly
    )
/*++

Routine Description:

    This function rename the primary domain or emulated domain.

Arguments:

    OldDomain - existing name of the domain

    NewDomain - new name of the domain

Return Value:

    Status - The status of the operation.

--*/
{
    NET_API_STATUS Status;
    HANDLE BrowserHandle;
    LPBYTE Where;

    UCHAR PacketBuffer[sizeof(LMDR_REQUEST_PACKET)+(DNLEN+1)*sizeof(WCHAR)];
    PLMDR_REQUEST_PACKET RequestPacket = (PLMDR_REQUEST_PACKET)PacketBuffer;

    WCHAR NewUnicodeDomainName[DNLEN+1];
    WCHAR OldUnicodeDomainName[DNLEN+1];

    //
    // Convert the names to unicode
    //
    if ( OldDomain == NULL ) {
        *OldUnicodeDomainName = L'\0';
    } else {
        NetpCopyStrToWStr( OldUnicodeDomainName, OldDomain );
    }
    if ( NewDomain == NULL ) {
        *NewUnicodeDomainName = L'\0';
    } else {
        NetpCopyStrToWStr( NewUnicodeDomainName, NewDomain );
    }


    //
    // Open the browser driver.
    Status = OpenBrowser(&BrowserHandle);

    if (Status != NERR_Success) {
        return(Status);
    }



    //
    // Build the request to pass to the browser.
    //

    RequestPacket->Version = LMDR_REQUEST_PACKET_VERSION_DOM;
    RequestPacket->Parameters.DomainRename.ValidateOnly = ValidateOnly;

    RtlInitUnicodeString( &RequestPacket->TransportName, NULL );
    RtlInitUnicodeString( &RequestPacket->EmulatedDomainName, OldUnicodeDomainName );

    RequestPacket->Parameters.DomainRename.DomainNameLength = wcslen( NewUnicodeDomainName ) * sizeof(WCHAR);
    wcscpy( RequestPacket->Parameters.DomainRename.DomainName,
            NewUnicodeDomainName );

    //
    //  This is a simple IoControl - It just sends down the packet.
    //

    Status = BrDgReceiverIoControl(
                    BrowserHandle,
                    IOCTL_LMDR_RENAME_DOMAIN,
                    RequestPacket,
                    FIELD_OFFSET(LMDR_REQUEST_PACKET, Parameters.DomainRename.DomainName) +
                        RequestPacket->Parameters.DomainRename.DomainNameLength,
                    NULL,
                    0,
                    NULL);

    if (Status != NERR_Success) {
        printf("Unable rename domain from %s to %s : %s\n",
                OldDomain,
                NewDomain,
                get_error_text(Status));
        exit(Status);
    }

    return Status;
}

VOID
_cdecl
main (argc, argv)
    int argc;
    char *argv[];
{
    NET_API_STATUS Status;
    ULONG ControlCode;
    ULONG Options = 0;
    LPTSTR Server = NULL;
    TCHAR ServerBuffer[CNLEN+1];
    ULONG i = 0;
    DWORD status;

    strcpy(ProgramName,argv[0]) ; // cannot overflow, since buffer > MAXPATH
    _strupr(ProgramName) ;

    if (argc < 2) {
        usage(NULL);
        exit(1);
    }


    //
    // Look up the command in the list of commands.
    //

    while (CommandSwitchList[i].SwitchName != NULL) {
        if (!_stricmp(argv[1], CommandSwitchList[i].SwitchName) ||
            !_stricmp(argv[1], CommandSwitchList[i].ShortName)) {
            ControlCode = CommandSwitchList[i].SwitchValue;
            break;
        }

        i += 1;
    }

    if (CommandSwitchList[i].SwitchName == NULL) {
        usage("Unknown switch specified");
        exit(5);
    }

    //
    // If an incorrect number of arguments were supplied,
    //  complain.
    //

    if ( look_for_help(argc, argv) ||
         argc < CommandSwitchList[i].MinArgc ||
         argc > CommandSwitchList[i].MaxArgc ) {

        CommandUsage( ControlCode );
        exit(4);

    }

    //
    // Do command specific processing.
    //
    switch (ControlCode) {
    case BROWSER_DEBUG_SET_DEBUG:
        {
            ULONG i = 0;


            if ((Options = atol(argv[2])) == 0) {
                PCHAR SwitchText;

                if (argv[2][0] == '+') {
                    SwitchText = &argv[2][1];
                    ControlCode = BROWSER_DEBUG_SET_DEBUG;
                } else if (argv[2][0] == '-') {
                    SwitchText = &argv[2][1];
                    ControlCode = BROWSER_DEBUG_CLEAR_DEBUG;
                } else {
                    CommandUsage( ControlCode );
                    exit(4);
                }

                while (DebugSwitchList[i].SwitchName != NULL) {
                    if (!_stricmp(SwitchText, DebugSwitchList[i].SwitchName)) {
                        Options = DebugSwitchList[i].SwitchValue;
                        break;
                    }

                    i += 1;
                }

                if (DebugSwitchList[i].SwitchName == NULL) {
                    CommandUsage( ControlCode );
                    exit(4);
                }

                if (argc == 4) {
                    status = MultiByteToWideChar(
                                CP_ACP,
                                0,
                                argv[3],
                                strlen(argv[3])+1,
                                ServerBuffer,
                                CNLEN
                                );
                    if ( ERROR_SUCCESS != status ) {
                        CommandUsage( ControlCode );
                        exit(4);
                    }
                    Server = ServerBuffer;
                }

            }

        }
        break;
    case BROWSER_DEBUG_DUMP_NETWORKS:
        DumpTransportList();
        exit(0);
        break;
    case BROWSER_DEBUG_BREAK_POINT:
    case BROWSER_DEBUG_TRUNCATE_LOG:
        break;

    case BROWSER_DEBUG_ENABLE_BROWSER:
        {
            NET_API_STATUS Status;

            Status = EnableService(TEXT("BROWSER"));

            if (Status != NERR_Success) {
                printf("Unable to enable browser service - %ld\n", Status);
            }

            exit(Status);
        }
        break;
    case BROWSER_DEBUG_BOWSERDEBUG:
        if (argc == 3) {
            if (_stricmp(argv[2], "TRUNCATE") == 0) {
                TruncateBowserLog();
            } else if (_stricmp(argv[2], "CLOSE") == 0) {
                CloseBowserLog();
            } else {
                CommandUsage( BROWSER_DEBUG_BOWSERDEBUG );
            }
        } else if (argc == 4) {
            if (_stricmp(argv[2], "OPEN") == 0) {
                OpenBowserLog(argv[3]);
            } else if (_stricmp(argv[2], "DEBUG") == 0) {
                SetBowserDebug(argv[3]);
            } else {
                CommandUsage( BROWSER_DEBUG_BOWSERDEBUG );
            }

        }
        exit(0);

    case BROWSER_DEBUG_ELECT:
        Elect(argv[2], argv[3], (argc == 5) ? argv[4] : NULL );
        exit(0);
        break;
    case BROWSER_DEBUG_GET_MASTER:
        GetMaster(argv[2], argv[3]);
        exit(0);
        break;
    case BROWSER_DEBUG_TICKLE:
        Tickle(argv[2], argv[3], (argc == 5) ? argv[4] : NULL );
        exit(0);
        break;
    case BROWSER_DEBUG_FORCE_ANNOUNCE:
        ForceAnnounce(argv[2], argv[3], (argc == 5) ? argv[4] : NULL );
        exit(0);
        break;
    case BROWSER_DEBUG_GETPDC:
        GetPdc(argv[2], argv[3]);
        exit(0);
        break;

    case BROWSER_DEBUG_ADD_MASTERNAME:
        AddMasterName(argv[2], argv[3], (argc==5 ? TRUE : FALSE));

        exit(0);
        break;

    case BROWSER_DEBUG_ADD_DOMAINNAME:
        AddDomainName(argv[2], argv[3], (argc==5 ? TRUE : FALSE));

        exit(0);
        break;

    case BROWSER_DEBUG_FIND_MASTER:
        FindMaster(argv[2], (argc==3 ? NULL : argv[3]) );
        exit(0);
        break;
    case BROWSER_DEBUG_GET_BACKUP_LIST:
        GetBlist(argv[2], (argc == 3 ? NULL : argv[3]), (BOOLEAN)(argc==5? TRUE : FALSE));

        exit(0);
        break;

    case BROWSER_DEBUG_ANNOUNCE_MASTER:
        AnnounceMaster(argv[2], argv[3], (argc == 5) ? argv[4] : NULL );

        exit(0);
        break;

    case BROWSER_DEBUG_ILLEGAL_DGRAM:
        IllegalDatagram(argv[2], argv[3], (argc == 5) ? argv[4] : NULL );

        exit(0);
        break;

    case BROWSER_DEBUG_GET_OTHLIST:
        GetOtherdomains(argv[2]);

        exit(0);
        break;

    case BROWSER_DEBUG_VIEW:
        View(argv[2],
             (argc >= 4 ? argv[3] : NULL),
             (argc >= 5 ? argv[4] : NULL),
             (argc >= 6 ? argv[5] : NULL),
#ifndef _PSS_RELEASE
             (argc == 7 ? TRUE : FALSE));
#else
             FALSE);
#endif

        exit(0);
        break;

    case BROWSER_DEBUG_LIST_WFW:
        ListWFW(argv[2]) ;
        exit(0);
        break;

    case BROWSER_DEBUG_RPCLIST:
        RpcList(argv[2], (argc >= 4 ? argv[3] : NULL), (argc >= 5 ? argv[4] : NULL), (argc == 6 ? TRUE : FALSE));

        exit(0);
        break;

    case BROWSER_DEBUG_RPCCMP:
        RpcCmp(argv[2], (argc >= 4 ? argv[3] : NULL), (argc >= 5 ? argv[4] : NULL), (argc == 6 ? TRUE : FALSE));

        exit(0);
        break;

    case BROWSER_DEBUG_LOCAL_BRLIST:
        GetLocalList(argv[2], (argc >= 4 ? argv[3] : NULL), (argc >= 5 ? argv[4] : NULL) );

        exit(0);
        break;

    case BROWSER_DEBUG_GET_NETBIOSNAMES:
        PrintNetbiosNames(argv[2], (argc >= 4 ? argv[3] : NULL));
        exit(0);
        break;

    case BROWSER_DEBUG_ADD_ALTERNATE:
        AddAlternateComputerName(argv[2], argv[3], (argc >= 5 ? argv[4] : NULL));

        exit(0);
        break;

    case BROWSER_DEBUG_BIND_TRANSPORT:
        BindTransport( TRUE, argv[2], (argc >= 4 ? argv[3] : NULL), (argc >= 5 ? argv[4] : NULL) );

        exit(0);
        break;

    case BROWSER_DEBUG_UNBIND_TRANSPORT:
        BindTransport( FALSE, argv[2], (argc >= 4 ? argv[3] : NULL), (argc >= 5 ? argv[4] : NULL) );

        exit(0);
        break;

    case BROWSER_DEBUG_STATISTICS:
        DumpStatistics(argc, argv[2]);

        exit(0);
        break;

    case BROWSER_DEBUG_ANNOUNCE:
        Announce(argv[2], argv[3], (argc >= 5 ? argv[4] : NULL ), (argc >= 6 ? TRUE : FALSE));

        exit(0);
        break;
    case BROWSER_DEBUG_POPULATE_DOMAIN:
    case BROWSER_DEBUG_POPULATE_SERVER:
        Populate((ControlCode == BROWSER_DEBUG_POPULATE_DOMAIN ? TRUE : FALSE),
                 argv[2],
                 argv[3],
                 (argc >= 6 ? argv[5] : NULL),
                 argv[4],
                 (argc >= 7 ? argv[6] : NULL));

        exit(0);
        break;

    case BROWSER_DEBUG_GET_WINSSERVER:
        GetWinsServer(argv[2]);
        exit(0);
        break;

    case BROWSER_DEBUG_GET_DOMAINLIST:
        GetDomainList(argv[2]);
        exit(0);
        break;

    case BROWSER_DEBUG_STATUS:
        {
            PCHAR Domain;
            BOOL Verbose = FALSE;

            if (argc == 4) {
                if (_stricmp(argv[2], "-v") == 0) {
                    Verbose = TRUE;
                    Domain = argv[3];
                } else {
                    CommandUsage( ControlCode );
                    exit(4);
                }
            } else if (argc == 3) {
                if (_stricmp(argv[2], "-v") == 0) {
                    Verbose = TRUE;
                    Domain = NULL;
                } else {
                    Domain = argv[2];
                }
            } else {
                Domain = NULL;
            }

            BrowserStatus(Verbose, Domain);
        }

        exit(0);
        break;

    case BROWSER_DEBUG_RENAME_DOMAIN:
        RenameDomain(argv[2], argv[3], (argc >= 5));

        exit(0);
        break;

    case BROWSER_DEBUG_SET_EMULATEDDOMAIN:
        SetEmulatedDomain(argv[2], argv[3], (argc >= 5 ? argv[4] : NULL) );

        exit(0);
        break;


    case BROWSER_DEBUG_SET_EMULATEDDOMAINENUM:
        EnumEmulatedDomains();

        exit(0);
        break;

    }

    Status = I_BrowserDebugCall(Server, ControlCode, Options);

    printf("Api call returned %ld\n", Status);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\browser\client\csc.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    csc.c

Abstract:

    These are the browser service API RPC client stubs for CSC

--*/

#include    <nt.h>
#include    <ntrtl.h>
#include    <nturtl.h>
#include    <windows.h>
#include    <stdio.h>
#include    <stdlib.h>
#include    <string.h>
#include    <time.h>
#include    <rpcutil.h>
#include    <lmcons.h>
#include    <lmerr.h>
#include    <lmapibuf.h>
#include    <lmserver.h>
#include    "cscp.h"

static FARPROC pCSCFindFirstFile = NULL;
static FARPROC pCSCFindNextFile = NULL;
static FARPROC pCSCFindClose = NULL;
static FARPROC pCSCIsServerOffline = NULL;

BrowserGetCSCEntryPoints()
{
    HANDLE hMod;

    if( pCSCFindFirstFile == NULL ) {

        //
        // Get the entry points in reverse order for multithread protection
        //
        hMod = LoadLibrary(L"cscdll.dll");
        if( hMod == NULL ) {
            return 0;
        }

        pCSCFindClose = GetProcAddress(hMod,"CSCFindClose");
        if( pCSCFindClose == NULL ) {
            return 0;
        }

        pCSCFindNextFile = GetProcAddress(hMod,"CSCFindNextFileW" );
        if( pCSCFindNextFile == NULL ) {
            return 0;
        }

        pCSCIsServerOffline = GetProcAddress(hMod, "CSCIsServerOfflineW" );
        if( pCSCIsServerOffline == NULL ) {
            return 0;
        }

        pCSCFindFirstFile = GetProcAddress(hMod,"CSCFindFirstFileW" );
    }
    return pCSCFindFirstFile != 0;
}

BOOLEAN NET_API_FUNCTION
CSCIsOffline()
{
    BOOL isOffline;

    if( BrowserGetCSCEntryPoints() &&
        pCSCIsServerOffline( NULL, &isOffline ) &&
        isOffline == TRUE ) {

        return TRUE;
    }

    return FALSE;
}

NET_API_STATUS NET_API_FUNCTION
CSCNetServerEnumEx(
    IN  DWORD       level,
    OUT LPBYTE      *bufptr,
    IN  DWORD       prefmaxlen,
    OUT LPDWORD     entriesread,
    OUT LPDWORD     totalentries
    )
/*++

Arguments:

    level - Supplies the requested level of information.

    bufptr - Returns a pointer to a buffer which contains the
        requested transport information.

    prefmaxlen - Supplies the number of bytes of information to return in the buffer.
        Ignored for this case.

    entriesread - Returns the number of entries read into the buffer.

    totalentries - Returns the total number of entries available.

--*/
{
    HANDLE hFind = INVALID_HANDLE_VALUE;
    WIN32_FIND_DATAW    sFind32;
    DWORD dwError, dwStatus, dwPinCount, dwHintFlags;
    FILETIME ftOrgTime;
    NET_API_STATUS apiStatus;
    LPWSTR server, share;
    PBYTE outbuf = NULL, endp;
    DWORD count, numFound, serverlen;

    try {

        count = 1024;

retry:
        numFound = 0;

        //
        // Allocate space for the results
        //
        if( outbuf != NULL ) {
            NetApiBufferFree( outbuf );
            outbuf = NULL;
            count *= 2;
        }
        apiStatus = NetApiBufferAllocate( count, &outbuf );

        if( apiStatus != NO_ERROR ) {
            goto try_exit;
        }
        endp = outbuf + count;

        RtlZeroMemory( outbuf, count );

        //
        // See if we can enumerate the cached servers and shares
        //
        if( hFind != INVALID_HANDLE_VALUE ) {
            pCSCFindClose( hFind );
            hFind = INVALID_HANDLE_VALUE;
        }
        hFind = (HANDLE)pCSCFindFirstFile(  NULL,
                                            &sFind32,
                                            &dwStatus,
                                            &dwPinCount,
                                            &dwHintFlags,
                                            &ftOrgTime
                                        );

        if( hFind == INVALID_HANDLE_VALUE ) {
            NetApiBufferFree( outbuf );
            apiStatus = ERROR_NOT_SUPPORTED;
            goto try_exit;
        }

        do {
            //
            // For each entry, take a look to see if it's one that we want.  If
            //   it is one, pack the results into the output buffer.  If the output
            //   buffer is too small, grow the buffer and start over again.
            //

            //
            // The name returned should be \\server\sharename
            //
            if( sFind32.cFileName[0] != L'\\' || sFind32.cFileName[1] != L'\\' ||
                sFind32.cFileName[2] == L'\0' ) {

                //
                // We got a strange server name entry
                //
                continue;
            }

            server = &sFind32.cFileName[2];

            for( share = server; *share && *share != '\\'; share++ );

            if( share[0] != '\\' ) {
                //
                // No share component?
                //
                continue;
            }

            //
            // NULL terminate the servername
            //
            *share++ = L'\0';

            serverlen = (DWORD)(share - server) * sizeof( WCHAR ) ;

            //
            // We've found a server entry!
            //

            if( level == 0 ) {
                PSERVER_INFO_100 s100 = (PSERVER_INFO_100)outbuf + numFound;
                PSERVER_INFO_100 s;

                if( (PBYTE)(endp - serverlen) < (PBYTE)(s100 + sizeof( s100 )) ) {
                    goto retry;
                }

                //
                // If we've already gotten this server, skip it
                //
                for( s = (PSERVER_INFO_100)outbuf; s < s100; s++ ) {
                    if( !lstrcmpiW( s->sv100_name, server ) ) {
                        break;
                    }
                }

                if( s != s100 ) {
                    continue;
                }

                endp -= serverlen;
                RtlCopyMemory( endp, server, serverlen );
                s100->sv100_name = (LPWSTR)endp;
                s100->sv100_platform_id = SV_PLATFORM_ID_NT;

            } else {
                PSERVER_INFO_101 s101 = (PSERVER_INFO_101)outbuf + numFound;
                PSERVER_INFO_101 s;

                if( (PBYTE)(endp - serverlen) < (PBYTE)(s101 + sizeof( s101 )) ) {
                    goto retry;
                }

                //
                // If we've already gotten this server, skip it
                //
                for( s = (PSERVER_INFO_101)outbuf; s < s101; s++ ) {
                    if( !lstrcmpiW( s->sv101_name, server ) ) {
                        break;
                    }
                }

                if( s != s101 ) {
                    continue;
                }

                endp -= serverlen;
                RtlCopyMemory( endp, server, serverlen );

                s101->sv101_name = (LPWSTR)endp;
                s101->sv101_platform_id = SV_PLATFORM_ID_NT;
                s101->sv101_version_major = 5;
                s101->sv101_version_minor = 0;
                s101->sv101_type = SV_TYPE_SERVER;
                s101->sv101_comment = (LPWSTR)(endp + serverlen - sizeof(WCHAR));
            }

            numFound++;

        } while( pCSCFindNextFile(hFind, &sFind32, &dwStatus, &dwPinCount, &dwHintFlags, &ftOrgTime) );

        pCSCFindClose(hFind);

        if( numFound != 0 ) {

            apiStatus = NERR_Success;

        } else {

            NetApiBufferFree( outbuf );
            outbuf = NULL;
            apiStatus = NERR_BrowserTableIncomplete;
        }

        *bufptr = outbuf;

        *entriesread = numFound;

        *totalentries = numFound;


try_exit:;
    } except( EXCEPTION_EXECUTE_HANDLER ) {

        if( outbuf != NULL ) {
            NetApiBufferFree( outbuf );
        }

        if( hFind != INVALID_HANDLE_VALUE ) {
            pCSCFindClose( hFind );
        }

        apiStatus = ERROR_INVALID_PARAMETER;
    }

    return apiStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\browser\client\makefile.inc ===
$(O)\browdeb.res: browdeb.rc

$(O)\browstat.res: browstat.rc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\browser\client\cscp.h ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    cscp.h

Abstract:

    Private header file for the client end of the Browser service
    modules when CSC is involved

Revision History:

--*/

NET_API_STATUS NET_API_FUNCTION
CSCNetServerEnumEx(
    IN  DWORD       level,
    OUT LPBYTE      *bufptr,
    IN  DWORD       prefmaxlen,
    OUT LPDWORD     entriesread,
    OUT LPDWORD     totalentries
    );

BOOLEAN NET_API_FUNCTION
CSCIsOffline( void );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\browser\idl\brnames.h ===
/*++

Copyright (c) 1991 Microsoft Corporation

Module Name:

    wsnames.h

Abstract:

    Private header file which defines the Workstation names.

Author:

    Rita Wong (ritaw) 06-May-1991

Revision History:

--*/

#define BROWSER_INTERFACE_NAME    TEXT("browser")

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\browser\common\interim.c ===
#include <nt.h>                  // DbgPrint prototype
#include <ntrtl.h>                  // DbgPrint
#include <nturtl.h>                 // Needed by winbase.h

#include <windef.h>                 // DWORD
#include <winbase.h>                // LocalFree

#include <rpcutil.h>                // GENERIC_ENUM_STRUCT

#include <lmcons.h>                 // NET_API_STATUS
#include <lmerr.h>                  // NetError codes
#include <lmremutl.h>               // SUPPORTS_RPC

#include <bowser.h>                 // generated by the MIDL complier
#include <brnames.h>                // Service and interface names

#include <netlib.h>
#include <netdebug.h>

#include <winsvc.h>

#include <lmserver.h>
#include <tstr.h>

#include <ntddbrow.h>
#include <brcommon.h>               // Routines common between client & server

VOID
UpdateInterimServerListElement(
    IN PINTERIM_SERVER_LIST ServerList,
    IN PINTERIM_ELEMENT Element,
    IN ULONG Level,
    IN BOOLEAN NewElement
    );

PINTERIM_ELEMENT
AllocateInterimServerListEntry(
    IN PSERVER_INFO_101 ServerInfo,
    IN ULONG Level
    );

NET_API_STATUS
MergeServerList(
    IN OUT PINTERIM_SERVER_LIST InterimServerList,
    IN ULONG Level,
    IN PVOID NewServerList,
    IN ULONG NewEntriesRead,
    IN ULONG NewTotalEntries
    )
/*++

Routine Description:

    This function will merge two server lists.  It will reallocate the buffer
    for the old list if appropriate.

Arguments:

    IN OUT PINTERIM_SERVER_LIST InterimServerList - Supplies an interim server list to merge into.

    IN ULONG Level - Supplies the level of the list (100 or 101).  Special
        level 1010 is really level 101 with the special semantic that no
        fields from this the NewServerList override existing fields in the
        InterimServerList.

    IN ULONG NewServerList - Supplies the list to merge into the interim list

    IN ULONG NewEntriesRead - Supplies the entries read in the list.

    IN ULONG NewTotalEntries - Supplies the total entries available in the list.

Return Value:

    NET_API_STATUS - NERR_Success or reason for failure.

--*/
{
    ULONG i;
    ULONG ServerElementSize;
    PSERVER_INFO_101 ServerInfo = NewServerList;
    PINTERIM_ELEMENT InterimEntry = NULL;
    PLIST_ENTRY InterimList;
    PINTERIM_ELEMENT NewElement = NULL;


    if (Level == 100) {
        ServerElementSize = sizeof(SERVER_INFO_100);
    } else if ( Level == 101 || Level == 1010 ) {
        ServerElementSize = sizeof(SERVER_INFO_101);
    } else {
        return(ERROR_INVALID_LEVEL);
    }

    //
    //  Early out if no entries in list.
    //

    if (NewEntriesRead == 0) {
        return NERR_Success;
    }

    PrepareServerListForMerge(NewServerList, Level, NewEntriesRead);

    InterimList = InterimServerList->ServerList.Flink;

    //
    //  Walk the existing structure, packing it into an interim element, and
    //  sticking the element into the interim table.
    //

    for (i = 0; i < NewEntriesRead; i ++) {
        BOOLEAN EntryInserted = FALSE;

        //
        //  Walk forward in the interim element and find the appropriate place
        //  to insert this element.
        //

        while (InterimList != &InterimServerList->ServerList) {

            LONG CompareResult;

            InterimEntry = CONTAINING_RECORD(InterimList, INTERIM_ELEMENT, NextElement);

//            KdPrint(("MergeServerList: Compare %ws and %ws\n", NewElement->Name, InterimEntry->Name));

#if DBG
            //
            //  Make sure that this entry is lexically less than the next
            //  entry.
            //

            {
                PLIST_ENTRY NextList = InterimList->Flink;
                PINTERIM_ELEMENT NextEntry = CONTAINING_RECORD(NextList, INTERIM_ELEMENT, NextElement);

                if (NextList != &InterimServerList->ServerList) {
                    ASSERT (wcscmp(InterimEntry->Name, NextEntry->Name) < 0);
                }

                //
                //  Now make sure that the input buffer also doesn't contain
                //  duplicate entries.
                //

                if (i < (NewEntriesRead-1)) {
                    PSERVER_INFO_101 NextServerInfo = (PSERVER_INFO_101)((PCHAR)ServerInfo+ServerElementSize);

                    ASSERT (wcscmp(ServerInfo->sv101_name, NextServerInfo->sv101_name) <= 0);
                }

            }
#endif

            CompareResult = wcscmp(ServerInfo->sv101_name, InterimEntry->Name);

            if (CompareResult == 0) {

//                KdPrint(("MergeServerList: Elements equal - update\n"));

                //
                // If the new information should override the old information,
                //  copy it on top of the new info.
                //
                if ( Level != 1010 ) {
                    InterimEntry->PlatformId = ServerInfo->sv101_platform_id;

                    if (Level >= 101) {
                        InterimEntry->MajorVersionNumber = ServerInfo->sv101_version_major;

                        InterimEntry->MinorVersionNumber = ServerInfo->sv101_version_minor;

                        InterimEntry->Type = ServerInfo->sv101_type;

                        InterimServerList->TotalBytesNeeded -= wcslen(InterimEntry->Comment) * sizeof(WCHAR) + sizeof(WCHAR);

                        wcscpy(InterimEntry->Comment, ServerInfo->sv101_comment);

                        InterimServerList->TotalBytesNeeded += wcslen(InterimEntry->Comment) * sizeof(WCHAR) + sizeof(WCHAR);

                    }
                }

                UpdateInterimServerListElement(InterimServerList, InterimEntry, Level, FALSE);

                EntryInserted = TRUE;

                break;

            } else if (CompareResult > 0) {

//                KdPrint(("MergeServerList: Elements greater.  Skip element\n"));

                InterimList = InterimList->Flink;

            } else {

                NewElement = AllocateInterimServerListEntry(ServerInfo, Level);

                if (NewElement == NULL) {
                    return ERROR_NOT_ENOUGH_MEMORY;
                }
//                KdPrint(("MergeServerList: Elements less.  Insert at end\n"));

                //
                //  The new entry is < than the previous entry.  Insert it
                //  before this entry.
                //

                InsertTailList(&InterimEntry->NextElement, &NewElement->NextElement);

                //
                //  Skip to the next element in the list.
                //

                InterimList = &NewElement->NextElement;

                UpdateInterimServerListElement(InterimServerList, NewElement, Level, TRUE);

                EntryInserted = TRUE;

                break;
            }
        }

        if (!EntryInserted &&
            (InterimList == &InterimServerList->ServerList)) {

            NewElement = AllocateInterimServerListEntry(ServerInfo, Level);

            if (NewElement == NULL) {
                return ERROR_NOT_ENOUGH_MEMORY;
            }
//            KdPrint(("MergeServerList: Insert %ws at end of list\n", NewElement->Name));

            InsertTailList(&InterimServerList->ServerList, &NewElement->NextElement);

            InterimList = &NewElement->NextElement;

            UpdateInterimServerListElement(InterimServerList, NewElement, Level, TRUE);

        }

        ServerInfo = (PSERVER_INFO_101)((PCHAR)ServerInfo+ServerElementSize);
    }

#if 0
    {
        PLIST_ENTRY InterimList;
        ULONG TotalNeededForList = 0;

        for (InterimList = InterimServerList->ServerList.Flink ;
             InterimList != &InterimServerList->ServerList ;
             InterimList = InterimList->Flink ) {
             ULONG ServerElementSize;

             InterimEntry = CONTAINING_RECORD(InterimList, INTERIM_ELEMENT, NextElement);

             if (Level == 100) {
                 ServerElementSize = sizeof(SERVER_INFO_100);
             } else {
                 ServerElementSize = sizeof(SERVER_INFO_101);
             }

             ServerElementSize += wcslen(InterimEntry->Name)*sizeof(WCHAR)+sizeof(WCHAR);

             ServerElementSize += wcslen(InterimEntry->Comment)*sizeof(WCHAR)+sizeof(WCHAR);

//             KdPrint(("MergeInterimServerList: %ws.  %ld needed\n", InterimEntry->Name, ServerElementSize));

             TotalNeededForList += ServerElementSize;
         }

         if (TotalNeededForList != InterimServerList->TotalBytesNeeded) {
             KdPrint(("UpdateInterimServerList:  Wrong number of bytes (%ld) for interim server list.  %ld needed\n", InterimServerList->TotalBytesNeeded, TotalNeededForList));
         }
     }

#endif
//    KdPrint(("%lx bytes needed to hold server list\n", InterimServerList->TotalBytesNeeded));

    //
    //  Also, we had better have the whole table locally.
    //

    ASSERT (InterimServerList->EntriesRead == InterimServerList->TotalEntries);

    return(NERR_Success);
}

ULONG
__cdecl
CompareServerInfo(
    const void * Param1,
    const void * Param2
    )
{
    const SERVER_INFO_100 * ServerInfo1 = Param1;
    const SERVER_INFO_100 * ServerInfo2 = Param2;

    return wcscmp(ServerInfo1->sv100_name, ServerInfo2->sv100_name);
}

VOID
PrepareServerListForMerge(
    IN PVOID ServerInfoList,
    IN ULONG Level,
    IN ULONG EntriesInList
    )
/*++

Routine Description:

    MergeServerList requires that the inputs to the list be in a strictly
    sorted order.  This routine guarantees that this list will be of
    an "appropriate" form to be merged.

Arguments:

    IN PVOID ServerInfoList - Supplies the list to munge.

    IN ULONG Level - Supplies the level of the list (100 or 101).
        (Or level 1010 which is identical to level 101.)

    IN ULONG EntriesInList - Supplies the number of entries in the list.

Return Value:

    None.

Note:
    In 99% of the cases, the list passed in will already be sorted.  We want to
    take the input list and first check to see if it is sorted.  If it is,
    we can return immediately.  If it is not, we need to sort the list.

    We don't just unilaterally sort the list, because the input is mostly
    sorted anyway, and there are no good sorting algorithms that handle mostly
    sorted inputs.  Since we will see unsorted input only rarely (basically,
    we will only see it from WfW machines), we just take the penalty of a worst
    case quicksort if the input is unsorted.

--*/

{
    LONG i;
    ULONG ServerElementSize;
    PSERVER_INFO_101 ServerInfo = ServerInfoList;
    BOOLEAN MisOrderedList = FALSE;

    ASSERT (Level == 100 || Level == 101 || Level == 1010);

    //
    //  Figure out the size of each element.
    //

    if (Level == 100) {
        ServerElementSize = sizeof(SERVER_INFO_100);
    } else {
        ServerElementSize = sizeof(SERVER_INFO_101);
    }

    //
    //  Next check to see if the input list is sorted.
    //

    for (i = 0 ; i < ((LONG)EntriesInList - 1) ; i += 1 ) {
        PSERVER_INFO_101 NextServerInfo = (PSERVER_INFO_101)((PCHAR)ServerInfo+ServerElementSize);

        if (wcscmp(ServerInfo->sv101_name, NextServerInfo->sv101_name) >= 0) {
            MisOrderedList = TRUE;
            break;
        }

        ServerInfo = NextServerInfo;
    }

    //
    //  This list is sorted.  Return right away, it's fine.
    //

    if (!MisOrderedList) {
        return;
    }

    //
    //  This list isn't sorted.  We need to sort it.
    //

    qsort(ServerInfoList, EntriesInList, ServerElementSize, CompareServerInfo);


}

PINTERIM_ELEMENT
AllocateInterimServerListEntry(
    IN PSERVER_INFO_101 ServerInfo,
    IN ULONG Level
    )
{
    PINTERIM_ELEMENT NewElement;

    NewElement = MIDL_user_allocate(sizeof(INTERIM_ELEMENT));

    if (NewElement == NULL) {
        return NULL;
    }

    //
    //  Initialize TimeLastSeen and Periodicity.
    //

    NewElement->TimeLastSeen = 0;

    NewElement->Periodicity = 0;

    NewElement->PlatformId = ServerInfo->sv101_platform_id;

    ASSERT (wcslen(ServerInfo->sv101_name) <= CNLEN);

    wcscpy(NewElement->Name, ServerInfo->sv101_name);

    if (Level == 100) {
        NewElement->MajorVersionNumber = 0;
        NewElement->MinorVersionNumber = 0;
        *NewElement->Comment = L'\0';
        NewElement->Type = SV_TYPE_ALL;
    } else {
        NewElement->MajorVersionNumber = ServerInfo->sv101_version_major;

        NewElement->MinorVersionNumber = ServerInfo->sv101_version_minor;

        NewElement->Type = ServerInfo->sv101_type;

        ASSERT (wcslen(ServerInfo->sv101_comment) <= LM20_MAXCOMMENTSZ);

        wcscpy(NewElement->Comment, ServerInfo->sv101_comment);

    }

    return NewElement;
}


VOID
UpdateInterimServerListElement(
    IN PINTERIM_SERVER_LIST InterimServerList,
    IN PINTERIM_ELEMENT InterimElement,
    IN ULONG Level,
    IN BOOLEAN NewElement
    )
{
#if 0
    PINTERIM_ELEMENT InterimEntry;
    ULONG TotalNeededForList = 0;
#endif

    //
    //  If this is a new element, update the size of the table to match.
    //

    if (NewElement) {
        ULONG ServerElementSize;

        if (Level == 100) {
            ServerElementSize = sizeof(SERVER_INFO_100);
        } else {
            ServerElementSize = sizeof(SERVER_INFO_101);
        }

        InterimServerList->EntriesRead += 1;

        ServerElementSize += wcslen(InterimElement->Name)*sizeof(WCHAR)+sizeof(WCHAR);

        if (Level == 100) {
            ServerElementSize += sizeof(WCHAR);
        } else {
            ServerElementSize += wcslen(InterimElement->Comment)*sizeof(WCHAR)+sizeof(WCHAR);
        }

        InterimServerList->TotalBytesNeeded += ServerElementSize;

        InterimServerList->TotalEntries += 1;

        if (InterimServerList->NewElementCallback != NULL) {
            InterimServerList->NewElementCallback(InterimServerList,
                                                            InterimElement);
        } else {
            InterimElement->Periodicity = 0xffffffff;
            InterimElement->TimeLastSeen = 0xffffffff;
        }


    } else {
        if (InterimServerList->ExistingElementCallback != NULL) {
            InterimServerList->ExistingElementCallback(InterimServerList,
                                                       InterimElement);
        } else {
            InterimElement->Periodicity = 0xffffffff;
            InterimElement->TimeLastSeen = 0xffffffff;
        }

    }

#if 0
    {
        PLIST_ENTRY InterimList;
        ULONG TotalNeededForList = 0;

        for (InterimList = InterimServerList->ServerList.Flink ;
             InterimList != &InterimServerList->ServerList ;
             InterimList = InterimList->Flink ) {
             ULONG ServerElementSize;

             InterimEntry = CONTAINING_RECORD(InterimList, INTERIM_ELEMENT, NextElement);

             if (Level == 100) {
                 ServerElementSize = sizeof(SERVER_INFO_100);
             } else {
                 ServerElementSize = sizeof(SERVER_INFO_101);
             }

             ServerElementSize += wcslen(InterimEntry->Name)*sizeof(WCHAR)+sizeof(WCHAR);

             ServerElementSize += wcslen(InterimEntry->Comment)*sizeof(WCHAR)+sizeof(WCHAR);

             TotalNeededForList += ServerElementSize;
         }

         if (TotalNeededForList != InterimServerList->TotalBytesNeeded) {
             KdPrint(("UpdateInterimServerList:  Wrong number of bytes (%ld) for interim server list.  %ld needed\n", InterimServerList->TotalBytesNeeded, TotalNeededForList));
         }
     }

#endif

    return;

}

NET_API_STATUS
PackServerList(
    IN PINTERIM_SERVER_LIST InterimServerList,
    IN ULONG Level,
    IN ULONG ServerType,
    IN ULONG PreferedMaximumLength,
    OUT PVOID *ServerList,
    OUT PULONG EntriesRead,
    OUT PULONG TotalEntries,
    IN LPCWSTR FirstNameToReturn
    )
/*++

Routine Description:

    This function will take an interim server list and "pack" it into an array
    of server_info_xxx structures.

Arguments:

    IN PINTERIM_SERVER_LIST InterimServerList - Supplies an interim server list to merge into.

    IN ULONG Level - Supplies the level of the list (100 or 101).

    IN ULONG ServerType - Supplies the type to filter on the list.

    IN ULONG PreferedMaximumLength - Supplies the prefered size of the list.

    OUT PVOID *ServerList - Where to put the destination list.

    OUT PULONG EntriesEntries - Receives the entries packed in the list.

    OUT PULONG TotalEntries - Receives the total entries available in the list.

    FirstNameToReturn - Supplies the name of the first domain or server entry to return.
        The caller can use this parameter to implement a resume handle of sorts by passing
        the name of the last entry returned on a previous call.  (Notice that the specified
        entry will, also, be returned on this call unless it has since been deleted.)
        Pass NULL to start with the first entry available.

        Passed name must be the canonical form of the name.

Return Value:

    NET_API_STATUS - NERR_Success or reason for failure.

--*/
{
    ULONG EntriesPacked = 0;
    PLIST_ENTRY InterimList;
    PSERVER_INFO_101 ServerEntry;
    ULONG EntrySize = 0;
    LPWSTR BufferEnd;
    BOOLEAN ReturnWholeList = FALSE;
    BOOLEAN TrimmingNames;
    BOOLEAN BufferFull = FALSE;

    if (Level == 100) {
        EntrySize = sizeof(SERVER_INFO_100);
    } else if (Level == 101) {
        EntrySize = sizeof(SERVER_INFO_101);
    } else {
        return(ERROR_INVALID_LEVEL);
    }

    //
    //  Set the entries read based on the information we collected before.
    //

    *TotalEntries = 0;

    if (PreferedMaximumLength == 0xffffffff) {
        *ServerList = MIDL_user_allocate(InterimServerList->TotalBytesNeeded);

        BufferEnd = (LPWSTR)((ULONG_PTR)(*ServerList)+InterimServerList->TotalBytesNeeded);

    } else {
        *ServerList = MIDL_user_allocate(PreferedMaximumLength);

        BufferEnd = (LPWSTR)((ULONG_PTR)(*ServerList)+PreferedMaximumLength);
    }

    if (ServerType == SV_TYPE_ALL || ServerType == SV_TYPE_DOMAIN_ENUM) {
        ReturnWholeList = TRUE;
    }

    if ( *ServerList == NULL ) {
        return(ERROR_NOT_ENOUGH_MEMORY);

    }

    TrimmingNames = (FirstNameToReturn != NULL && *FirstNameToReturn != L'\0');
    ServerEntry = *ServerList;

    for (InterimList = InterimServerList->ServerList.Flink ;
         InterimList != &InterimServerList->ServerList ;
         InterimList = InterimList->Flink ) {

        PINTERIM_ELEMENT InterimEntry = CONTAINING_RECORD(InterimList, INTERIM_ELEMENT, NextElement);

#if DBG
        //
        //  Make sure that this entry is lexically less than the next
        //  entry.
        //

        {
            PLIST_ENTRY NextList = InterimList->Flink;
            PINTERIM_ELEMENT NextEntry = CONTAINING_RECORD(NextList, INTERIM_ELEMENT, NextElement);

            if (NextList != &InterimServerList->ServerList) {
                ASSERT (wcscmp(InterimEntry->Name, NextEntry->Name) < 0);
            }

        }
#endif

        //
        // Trim the first several names from the list.
        //

        if ( TrimmingNames ) {
            if ( wcscmp( InterimEntry->Name, FirstNameToReturn ) < 0 ) {
                continue;
            }
            TrimmingNames = FALSE;
        }

        //
        //  If the server's type matches the type filter, pack it into the buffer.
        //

        if (InterimEntry->Type & ServerType) {

            (*TotalEntries) += 1;

            //
            //  If this entry will fit into the buffer, pack it in.
            //
            //  Please note that we only count an entry if the entire entry
            //  (server and comment) fits in the buffer.  This is NOT
            //  strictly Lan Manager compatible.
            //

            if ( !BufferFull &&
                 ((ULONG_PTR)ServerEntry+EntrySize <= (ULONG_PTR)BufferEnd)) {

                ServerEntry->sv101_platform_id = InterimEntry->PlatformId;

                ServerEntry->sv101_name = InterimEntry->Name;

                if (NetpPackString(&ServerEntry->sv101_name,
                                    (LPBYTE)((PCHAR)ServerEntry)+EntrySize,
                                    &BufferEnd)) {

                    if (Level == 101) {

                        ServerEntry->sv101_version_major = InterimEntry->MajorVersionNumber;;

                        ServerEntry->sv101_version_minor = InterimEntry->MinorVersionNumber;;

                        ServerEntry->sv101_type = InterimEntry->Type;

                        ServerEntry->sv101_comment = InterimEntry->Comment;

                        if (NetpPackString(&ServerEntry->sv101_comment,
                                    (LPBYTE)((PCHAR)ServerEntry)+EntrySize,
                                    &BufferEnd)) {
                            EntriesPacked += 1;
                        } else {
                            BufferFull = TRUE;
                        }
                    } else {
                        EntriesPacked += 1;
                    }
#if DBG
                    {
                        PSERVER_INFO_101 PreviousServerInfo = (PSERVER_INFO_101)((PCHAR)ServerEntry-EntrySize);
                        if (PreviousServerInfo >= (PSERVER_INFO_101)*ServerList) {
                            ASSERT (wcscmp(ServerEntry->sv101_name, PreviousServerInfo->sv101_name) > 0);
                        }

                    }
#endif
                } else {
                    BufferFull = TRUE;
                }

            } else {

                //
                //  If we're returning the entire list and we have exceeded
                //  the amount that fits in the list, we can early out
                //  now.
                //

                if (ReturnWholeList) {

                    *TotalEntries = InterimServerList->TotalEntries;

                    break;
                }

                BufferFull = TRUE;
            }

            //
            //  Step to the next server entry.
            //

            ServerEntry = (PSERVER_INFO_101)((PCHAR)ServerEntry+EntrySize);
        }
    }

    ASSERT (InterimServerList->EntriesRead >= EntriesPacked);

    *EntriesRead = EntriesPacked;

    if (EntriesPacked != *TotalEntries) {
        return ERROR_MORE_DATA;
    } else {
        return NERR_Success;
    }

}


NET_API_STATUS
InitializeInterimServerList(
    IN PINTERIM_SERVER_LIST InterimServerList,
    IN PINTERIM_NEW_CALLBACK NewCallback,
    IN PINTERIM_EXISTING_CALLBACK ExistingCallback,
    IN PINTERIM_DELETE_CALLBACK DeleteElementCallback,
    IN PINTERIM_AGE_CALLBACK AgeElementCallback
    )
{

    InitializeListHead(&InterimServerList->ServerList);

    InterimServerList->TotalBytesNeeded = 0;
    InterimServerList->TotalEntries = 0;
    InterimServerList->EntriesRead = 0;

    InterimServerList->NewElementCallback = NewCallback;
    InterimServerList->ExistingElementCallback = ExistingCallback;
    InterimServerList->DeleteElementCallback = DeleteElementCallback;
    InterimServerList->AgeElementCallback = AgeElementCallback;
    return(NERR_Success);
}

NET_API_STATUS
UninitializeInterimServerList(
    IN PINTERIM_SERVER_LIST InterimServerList
    )
{
    PINTERIM_ELEMENT InterimElement;


//    KdPrint(("BROWSER: Uninitialize Interim Server List %lx\n", InterimServerList));

    //
    //  Enumerate the elements in the table, deleting them as we go.
    //

    while (!IsListEmpty(&InterimServerList->ServerList)) {
        PLIST_ENTRY Entry;

        Entry = RemoveHeadList(&InterimServerList->ServerList);

        InterimElement = CONTAINING_RECORD(Entry, INTERIM_ELEMENT, NextElement);

        if (InterimServerList->DeleteElementCallback != NULL) {
            InterimServerList->DeleteElementCallback(InterimServerList, InterimElement);
        }

        //
        //  There is one less element in the list.
        //

        InterimServerList->EntriesRead -= 1;

        InterimServerList->TotalEntries -= 1;

        MIDL_user_free(InterimElement);
    }

    ASSERT (InterimServerList->EntriesRead == 0);

    return(NERR_Success);
}

ULONG
NumberInterimServerListElements(
    IN PINTERIM_SERVER_LIST InterimServerList
    )
{
    PLIST_ENTRY InterimList;
    ULONG NumberOfEntries = 0;

    for (InterimList = InterimServerList->ServerList.Flink ;
         InterimList != &InterimServerList->ServerList ;
         InterimList = InterimList->Flink ) {
        NumberOfEntries += 1;

    }

    return NumberOfEntries;
}

NET_API_STATUS
AgeInterimServerList(
    IN PINTERIM_SERVER_LIST InterimServerList
    )
{
    PLIST_ENTRY InterimList, NextElement;
    PINTERIM_ELEMENT InterimElement;

    if (InterimServerList->AgeElementCallback != NULL) {

        //
        //  Enumerate the elements in the table, aging them as we go.
        //


        for (InterimList = InterimServerList->ServerList.Flink ;
             InterimList != &InterimServerList->ServerList ;
             InterimList = NextElement) {
            InterimElement = CONTAINING_RECORD(InterimList, INTERIM_ELEMENT, NextElement);

            //
            //  Call into the aging routine and if this entry is too old,
            //  remove it from the interim list.
            //

            if (InterimServerList->AgeElementCallback(InterimServerList, InterimElement)) {
                ULONG ElementSize = sizeof(SERVER_INFO_101) + ((wcslen(InterimElement->Comment) + 1) * sizeof(WCHAR)) + ((wcslen(InterimElement->Name) + 1) * sizeof(WCHAR));

                ASSERT (ElementSize <= InterimServerList->TotalBytesNeeded);

                NextElement = InterimList->Flink;

                //
                //  Remove this entry from the list.
                //

                RemoveEntryList(&InterimElement->NextElement);

                if (InterimServerList->DeleteElementCallback != NULL) {
                    InterimServerList->DeleteElementCallback(InterimServerList, InterimElement);
                }

                //
                //  There is one less element in the list.
                //

                InterimServerList->EntriesRead -= 1;

                InterimServerList->TotalEntries -= 1;

                //
                //  Since this element isn't in the table any more, we don't
                //  need to allocate memory for it.
                //

                InterimServerList->TotalBytesNeeded -= ElementSize;

                MIDL_user_free(InterimElement);

            } else {
                NextElement = InterimList->Flink;
            }
        }
#if 0
    {
        PINTERIM_ELEMENT InterimEntry;
        ULONG TotalNeededForList = 0;

        for (InterimList = InterimServerList->ServerList.Flink ;
             InterimList != &InterimServerList->ServerList ;
             InterimList = InterimList->Flink ) {
             ULONG ServerElementSize;

             InterimEntry = CONTAINING_RECORD(InterimList, INTERIM_ELEMENT, NextElement);

             ServerElementSize = sizeof(SERVER_INFO_101);

             ServerElementSize += wcslen(InterimEntry->Name)*sizeof(WCHAR)+sizeof(WCHAR);

             ServerElementSize += wcslen(InterimEntry->Comment)*sizeof(WCHAR)+sizeof(WCHAR);

             TotalNeededForList += ServerElementSize;
         }

         if (TotalNeededForList != InterimServerList->TotalBytesNeeded) {
             KdPrint(("AgeInterimServerList:  Too few bytes (%ld) for interim server list.  %ld needed\n", InterimServerList->TotalBytesNeeded, TotalNeededForList));
         }
     }
#endif

    }

    return(NERR_Success);
}

PINTERIM_ELEMENT
LookupInterimServerList(
    IN PINTERIM_SERVER_LIST InterimServerList,
    IN LPWSTR ServerNameToLookUp
    )
{
    PLIST_ENTRY InterimList;

    for (InterimList = InterimServerList->ServerList.Flink ;
         InterimList != &InterimServerList->ServerList ;
         InterimList = InterimList->Flink ) {

        PINTERIM_ELEMENT InterimEntry = CONTAINING_RECORD(InterimList, INTERIM_ELEMENT, NextElement);
        LONG CompareResult;

        if ((CompareResult = _wcsicmp(InterimEntry->Name, ServerNameToLookUp) == 0)) {
            return InterimEntry;
        }

        //
        //  If we went past this guy, return an error.
        //

        if (CompareResult > 0) {
            return NULL;
        }

    }

    return NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\browser\common\makefile.inc ===
$(O)\setup_browser.c : utils.c
    type << > $@
/*++ BUILD Version: ????    // Increment this if a change has global effects

$(COPYRIGHT_STRING)

Module Name:

    setup_browser.c

Abstract:

    This is used by syssetup to enable net browser.  It's generated from various files under
    ds\netapi\svcdlls\bworser\common.  Do not edit by hand.

Revision History:

--*/

#include <lmcons.h>                 // NET_API_STATUS
#include <lmerr.h>                  // NetError codes
#include <ntddbrow.h>
#include <netlibnt.h>               // NetpNtStatusToApiStatus
#include <align.h>

#define NetpAssert(x)

<<
    hextract -o $@ -lt setup -bt begin_setup end_setup utils.c
    $(PUBLISH_CMD) {$@=$(PROJECT_INC_PATH)\setup_browser.c}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\browser\server\bowqueue.h ===
/*++

Copyright (c) 1991 Microsoft Corporation

Module Name:

    bowqueue.h

Abstract:

    Private header file for the NT Browser service.  This file describes
    the bowser thread queue interfaces.

Author:

    Larry Osterman (larryo) 15-Feb-1991

Revision History:

--*/

#ifndef _BOWQUEUE_
#define _BOWQUEUE_


typedef
VOID
(*PBROWSER_WORKER_ROUTINE) (
    IN PVOID Parameter
    );


typedef struct _WORKER_ITEM {
    LIST_ENTRY List;
    PBROWSER_WORKER_ROUTINE WorkerRoutine;
    PVOID Parameter;
    BOOLEAN Inserted;
} WORKER_ITEM, *PWORKER_ITEM;

typedef struct _BROWSER_TIMER {
    HANDLE TimerHandle;
    WORKER_ITEM WorkItem;
} BROWSER_TIMER, *PBROWSER_TIMER;


VOID
BrWorkerThread(
    IN PVOID Context
    );


VOID
BrQueueWorkItem(
    IN PWORKER_ITEM WorkItem
    );

NET_API_STATUS
BrWorkerInitialization(
    VOID
    );

VOID
BrWorkerKillThreads(
    VOID
    );

VOID
BrWorkerCreateThread(
    ULONG NetworkCount
    );

NET_API_STATUS
BrWorkerTermination (
    VOID
    );

NET_API_STATUS
BrSetTimer(
    IN PBROWSER_TIMER Timer,
    IN ULONG MilliSecondsToExpire,
    IN PBROWSER_WORKER_ROUTINE WorkerFunction,
    IN PVOID Context
    );

NET_API_STATUS
BrCancelTimer(
    IN PBROWSER_TIMER Timer
    );

NET_API_STATUS
BrDestroyTimer(
    IN PBROWSER_TIMER Timer
    );

NET_API_STATUS
BrCreateTimer(
    IN PBROWSER_TIMER Timer
    );

VOID
BrInitializeWorkItem(
    IN  PWORKER_ITEM  Item,
    IN  PBROWSER_WORKER_ROUTINE Routine,
    IN  PVOID   Context);



#endif // ifdef _BOWQUEUE_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\browser\idl\imports.h ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    imports.h

Abstract:

    This file allows us to include standard system header files in the
    .idl file.  The main .idl file imports a file called import.idl.
    This allows the .idl file to use the types defined in these header
    files.  It also causes the following line to be added in the
    MIDL generated header file:

    #include "imports.h"

    Thus these types are available to the RPC stub routines as well.

Author:

    Dan Lafferty (danl)     07-May-1991

Revision History:


--*/


#include <windef.h>
#include <lmcons.h>

#ifdef MIDL_PASS
#ifdef UNICODE
#define LPTSTR [string] wchar_t*
#else
#define LPTSTR [string] LPTSTR
#endif
#define LPSTR [string] LPSTR
#define LPWSTR [string] wchar_t*
#define BOOL DWORD
#endif

#include <lmserver.h>
#include <lmbrowsr.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\browser\common\utils.c ===
/*++

Copyright (c) 1991-1992  Microsoft Corporation

Module Name:

    utils.c

Abstract:

    Utility routines for the browser service.

Author:

    Larry Osterman (LarryO) 23-Mar-1992

Environment:

    User Mode - Win32

Revision History:

--*/

#undef IF_DEBUG                 // avoid wsclient.h vs. debuglib.h conflicts.
#include <nt.h>                  // DbgPrint prototype
#include <ntrtl.h>                  // DbgPrint
#include <nturtl.h>                 // Needed by winbase.h

#include <windef.h>                 // DWORD
#include <winbase.h>                // LocalFree
#include <winreg.h>

#include <rpc.h>                    // DataTypes and runtime APIs
#include <rpcutil.h>                // GENERIC_ENUM_STRUCT

#include <lmcons.h>                 // NET_API_STATUS
#include <lmerr.h>                  // NetError codes
#include <lmremutl.h>               // SUPPORTS_RPC

#include <netlib.h>               // NetpNtStatusToApiStatus
#include <netlibnt.h>               // NetpNtStatusToApiStatus
#include <netdebug.h>

#include <bowser.h>                 // generated by the MIDL complier
#include <brnames.h>                // Service and interface names

#include <winsvc.h>

#include <debuglib.h>           // IF_DEBUG() (needed by netrpc.h).
#include <lmserver.h>
#include <align.h>
#include <tstr.h>

#include <ntddbrow.h>
#include <brcommon.h>               // Routines common between client & server

#include <nb30.h>
#include <hostannc.h>

#include <winnls.h>


#ifdef ENABLE_PSEUDO_BROWSER
#include <config.h>             // for LPNET_CONFIG_HANDLE & friends
#include <confname.h>           // for SECT_NT_BROWSER
#endif

// begin_setup


//
// Buffer allocation size for enumeration output buffer.
//
#define INITIAL_ALLOCATION_SIZE  48*1024  // First attempt size (48K)
#define FUDGE_FACTOR_SIZE        1024  // Second try TotalBytesNeeded
                                       //     plus this amount

//
// prototypes
//

#ifdef ENABLE_PSEUDO_BROWSER
DWORD
IsBrowserEnabled(
    IN  OPTIONAL    LPTSTR  Section,
    IN              LPTSTR  Key,
    IN              BOOL    fDefault
    );

DWORD
GetBrowserValue(
    IN  OPTIONAL    LPTSTR  Section,
    IN              LPTSTR  Key,
    OUT             PDWORD pdwValue
    );
#endif


//
// Implementation
//

NET_API_STATUS
BrDgReceiverIoControl(
    IN  HANDLE FileHandle,
    IN  ULONG DgReceiverControlCode,
    IN  PLMDR_REQUEST_PACKET Drp,
    IN  ULONG DrpSize,
    IN  PVOID SecondBuffer OPTIONAL,
    IN  ULONG SecondBufferLength,
    OUT PULONG Information OPTIONAL
    )
/*++

Routine Description:

Arguments:

    FileHandle - Supplies a handle to the file or device on which the service
        is being performed.

    DgReceiverControlCode - Supplies the NtDeviceIoControlFile function code
        given to the datagram receiver.

    Drp - Supplies the datagram receiver request packet.

    DrpSize - Supplies the length of the datagram receiver request packet.

    SecondBuffer - Supplies the second buffer in call to NtDeviceIoControlFile.

    SecondBufferLength - Supplies the length of the second buffer.

    Information - Returns the information field of the I/O status block.

Return Value:

    NET_API_STATUS - NERR_Success or reason for failure.

--*/

{
    NTSTATUS ntstatus;
    IO_STATUS_BLOCK IoStatusBlock;
    PLMDR_REQUEST_PACKET RealDrp;
    HANDLE CompletionEvent;
    LPBYTE Where;

    if (FileHandle == NULL) {
        return ERROR_NOT_SUPPORTED;
    }

    //
    // Allocate a copy of the request packet where we can put the transport and
    //  emulated domain name in the packet itself.
    //
    RealDrp = (PLMDR_REQUEST_PACKET) MIDL_user_allocate(DrpSize+
                                 Drp->TransportName.Length+sizeof(WCHAR)+
                                 Drp->EmulatedDomainName.Length+sizeof(WCHAR) );

    if (RealDrp == NULL) {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    //
    // Copy the request packet into the local copy.
    //
    RtlCopyMemory(RealDrp, Drp, DrpSize);

    Where = (LPBYTE)RealDrp+DrpSize;
    if (Drp->TransportName.Length != 0) {
        RealDrp->TransportName.Buffer = (LPWSTR)Where;
        RealDrp->TransportName.MaximumLength = Drp->TransportName.Length+sizeof(WCHAR);
        RtlCopyUnicodeString(&RealDrp->TransportName, &Drp->TransportName);
        Where += RealDrp->TransportName.MaximumLength;
    }

    if (Drp->EmulatedDomainName.Length != 0) {
        RealDrp->EmulatedDomainName.Buffer = (LPWSTR)Where;
        RealDrp->EmulatedDomainName.MaximumLength = Drp->EmulatedDomainName.Length+sizeof(WCHAR);
        RtlCopyUnicodeString(&RealDrp->EmulatedDomainName, &Drp->EmulatedDomainName);
        Where += RealDrp->EmulatedDomainName.MaximumLength;
    }



    //
    // Create a completion event
    //
    CompletionEvent = CreateEvent(NULL, TRUE, FALSE, NULL);

    if (CompletionEvent == NULL) {

        MIDL_user_free(RealDrp);

        return(GetLastError());
    }

    //
    // Send the request to the Datagram Receiver DD.
    //

    ntstatus = NtDeviceIoControlFile(
                   FileHandle,
                   CompletionEvent,
                   NULL,
                   NULL,
                   &IoStatusBlock,
                   DgReceiverControlCode,
                   RealDrp,
                   (ULONG)(Where-(LPBYTE)RealDrp),
                   SecondBuffer,
                   SecondBufferLength
                   );

    if (NT_SUCCESS(ntstatus)) {

        //
        //  If pending was returned, then wait until the request completes.
        //

        if (ntstatus == STATUS_PENDING) {

            do {
                ntstatus = WaitForSingleObjectEx(CompletionEvent, 0xffffffff, TRUE);
            } while ( ntstatus == WAIT_IO_COMPLETION );
        }


        if (NT_SUCCESS(ntstatus)) {
            ntstatus = IoStatusBlock.Status;
        }
    }

    if (ARGUMENT_PRESENT(Information)) {
        *Information = (ULONG)IoStatusBlock.Information;
    }

    MIDL_user_free(RealDrp);

    CloseHandle(CompletionEvent);

    return NetpNtStatusToApiStatus(ntstatus);
}

NET_API_STATUS
DeviceControlGetInfo(
    IN  HANDLE FileHandle,
    IN  ULONG DeviceControlCode,
    IN  PVOID RequestPacket,
    IN  ULONG RequestPacketLength,
    OUT LPVOID *OutputBuffer,
    IN  ULONG PreferedMaximumLength,
    IN  ULONG BufferHintSize,
    OUT PULONG Information OPTIONAL
    )
/*++

Routine Description:

    This function allocates the buffer and fill it with the information
    that is retrieved from the datagram receiver.

Arguments:

    DeviceDriverType - Supplies the value which indicates whether to call
        the datagram receiver.

    FileHandle - Supplies a handle to the file or device of which to get
        information about.

    DeviceControlCode - Supplies the NtFsControlFile or NtIoDeviceControlFile
        function control code.

    RequestPacket - Supplies a pointer to the device request packet.

    RrequestPacketLength - Supplies the length of the device request packet.

    OutputBuffer - Returns a pointer to the buffer allocated by this routine
        which contains the use information requested.  This pointer is set to
         NULL if return code is not NERR_Success.

    PreferedMaximumLength - Supplies the number of bytes of information to
        return in the buffer.  If this value is MAXULONG, we will try to
        return all available information if there is enough memory resource.

    BufferHintSize - Supplies the hint size of the output buffer so that the
        memory allocated for the initial buffer will most likely be large
        enough to hold all requested data.

    Information - Returns the information code from the NtFsControlFile or
        NtIoDeviceControlFile call.

Return Value:

    NET_API_STATUS - NERR_Success or reason for failure.

--*/
{
    NET_API_STATUS status;
    NTSTATUS ntstatus;
    DWORD OutputBufferLength;
    DWORD TotalBytesNeeded = 1;
    ULONG OriginalResumeKey;
    IO_STATUS_BLOCK IoStatusBlock;
    PLMDR_REQUEST_PACKET Drrp = (PLMDR_REQUEST_PACKET) RequestPacket;
    HANDLE CompletionEvent;

    OriginalResumeKey = Drrp->Parameters.EnumerateNames.ResumeHandle;

    //
    // If PreferedMaximumLength is MAXULONG, then we are supposed to get all
    // the information, regardless of size.  Allocate the output buffer of a
    // reasonable size and try to use it.  If this fails, the Redirector FSD
    // will say how much we need to allocate.
    //
    if (PreferedMaximumLength == MAXULONG) {
        OutputBufferLength = (BufferHintSize) ?
                             BufferHintSize :
                             INITIAL_ALLOCATION_SIZE;
    }
    else {
        OutputBufferLength = PreferedMaximumLength;
    }

    OutputBufferLength = ROUND_UP_COUNT(OutputBufferLength, ALIGN_WCHAR);

    if ((*OutputBuffer = MIDL_user_allocate(OutputBufferLength)) == NULL) {
        return ERROR_NOT_ENOUGH_MEMORY;
    }
    RtlZeroMemory((PVOID) *OutputBuffer, OutputBufferLength);

    CompletionEvent = CreateEvent(NULL, TRUE, FALSE, NULL);

    if (CompletionEvent == NULL) {
        MIDL_user_free(*OutputBuffer);
        *OutputBuffer = NULL;
        return(GetLastError());
    }

    Drrp->Parameters.EnumerateServers.EntriesRead = 0;

    //
    // Make the request of the Datagram Receiver
    //

    ntstatus = NtDeviceIoControlFile(
                     FileHandle,
                     CompletionEvent,
                     NULL,              // APC routine
                     NULL,              // APC context
                     &IoStatusBlock,
                     DeviceControlCode,
                     Drrp,
                     RequestPacketLength,
                     *OutputBuffer,
                     OutputBufferLength
                     );

    if (NT_SUCCESS(ntstatus)) {

        //
        //  If pending was returned, then wait until the request completes.
        //

        if (ntstatus == STATUS_PENDING) {
            do {
                ntstatus = WaitForSingleObjectEx(CompletionEvent, 0xffffffff, TRUE);
            } while ( ntstatus == WAIT_IO_COMPLETION );
        }

        if (NT_SUCCESS(ntstatus)) {
            ntstatus = IoStatusBlock.Status;
        }
    }

    //
    // Map NT status to Win error
    //
    status = NetpNtStatusToApiStatus(ntstatus);

    if (status == ERROR_MORE_DATA) {

        NetpAssert(
                FIELD_OFFSET(
                    LMDR_REQUEST_PACKET,
                    Parameters.EnumerateNames.TotalBytesNeeded
                    ) ==
                FIELD_OFFSET(
                    LMDR_REQUEST_PACKET,
                    Parameters.EnumerateServers.TotalBytesNeeded
                    )
                );

        NetpAssert(
                FIELD_OFFSET(
                    LMDR_REQUEST_PACKET,
                    Parameters.GetBrowserServerList.TotalBytesNeeded
                    ) ==
                FIELD_OFFSET(
                    LMDR_REQUEST_PACKET,
                    Parameters.EnumerateServers.TotalBytesNeeded
                    )
                );

        TotalBytesNeeded = Drrp->Parameters.EnumerateNames.TotalBytesNeeded;
    }

    if ((TotalBytesNeeded > OutputBufferLength) &&
        (PreferedMaximumLength == MAXULONG)) {
        PLMDR_REQUEST_PACKET Drrp = (PLMDR_REQUEST_PACKET) RequestPacket;

        //
        // Initial output buffer allocated was too small and we need to return
        // all data.  First free the output buffer before allocating the
        // required size plus a fudge factor just in case the amount of data
        // grew.
        //

        MIDL_user_free(*OutputBuffer);

        OutputBufferLength =
            ROUND_UP_COUNT((TotalBytesNeeded + FUDGE_FACTOR_SIZE),
                           ALIGN_WCHAR);

        if ((*OutputBuffer = MIDL_user_allocate(OutputBufferLength)) == NULL) {
            return ERROR_NOT_ENOUGH_MEMORY;
        }
        RtlZeroMemory((PVOID) *OutputBuffer, OutputBufferLength);


        NetpAssert(
                FIELD_OFFSET(
                    LMDR_REQUEST_PACKET,
                    Parameters.EnumerateNames.ResumeHandle
                    ) ==
                FIELD_OFFSET(
                    LMDR_REQUEST_PACKET,
                    Parameters.EnumerateServers.ResumeHandle
                    )
                );

        NetpAssert(
                FIELD_OFFSET(
                    LMDR_REQUEST_PACKET,
                    Parameters.EnumerateNames.ResumeHandle
                    ) ==
                FIELD_OFFSET(
                    LMDR_REQUEST_PACKET,
                    Parameters.GetBrowserServerList.ResumeHandle
                    )
                );

        Drrp->Parameters.EnumerateNames.ResumeHandle = OriginalResumeKey;
        Drrp->Parameters.EnumerateServers.EntriesRead = 0;

        //
        //  Make the request of the Datagram Receiver
        //

        ntstatus = NtDeviceIoControlFile(
                         FileHandle,
                         CompletionEvent,
                         NULL,              // APC routine
                         NULL,              // APC context
                         &IoStatusBlock,
                         DeviceControlCode,
                         Drrp,
                         RequestPacketLength,
                         *OutputBuffer,
                         OutputBufferLength
                         );

        if (NT_SUCCESS(ntstatus)) {

            //
            //  If pending was returned, then wait until the request completes.
            //

            if (ntstatus == STATUS_PENDING) {
                do {
                    ntstatus = WaitForSingleObjectEx(CompletionEvent, 0xffffffff, TRUE);
                } while ( ntstatus == WAIT_IO_COMPLETION );
            }

            if (NT_SUCCESS(ntstatus)) {
                ntstatus = IoStatusBlock.Status;
            }
        }

        status = NetpNtStatusToApiStatus(ntstatus);

    }


    //
    // If not successful in getting any data, or if the caller asked for
    // all available data with PreferedMaximumLength == MAXULONG and
    // our buffer overflowed, free the output buffer and set its pointer
    // to NULL.
    //
    if ((status != NERR_Success && status != ERROR_MORE_DATA) ||
        (TotalBytesNeeded == 0) ||
        (PreferedMaximumLength == MAXULONG && status == ERROR_MORE_DATA) ||
        (Drrp->Parameters.EnumerateServers.EntriesRead == 0)) {

        MIDL_user_free(*OutputBuffer);
        *OutputBuffer = NULL;

        //
        // PreferedMaximumLength == MAXULONG and buffer overflowed means
        // we do not have enough memory to satisfy the request.
        //
        if (status == ERROR_MORE_DATA) {
            status = ERROR_NOT_ENOUGH_MEMORY;
        }
    }

    CloseHandle(CompletionEvent);

    return status;

    UNREFERENCED_PARAMETER(Information);
}

// end_setup

NET_API_STATUS
GetBrowserServerList(
    IN PUNICODE_STRING TransportName,
    IN LPCWSTR Domain,
    OUT LPWSTR *BrowserList[],
    OUT PULONG BrowserListLength,
    IN BOOLEAN ForceRescan
    )
/*++

Routine Description:

    This function will return a list of browser servers.

Arguments:

    IN PUNICODE_STRING TransportName - Transport to return list.


Return Value:

    NET_API_STATUS - NERR_Success or reason for failure.

--*/
{


    NET_API_STATUS Status;
    HANDLE BrowserHandle;
    PLMDR_REQUEST_PACKET RequestPacket = NULL;

//    DbgPrint("Getting browser server list for transport %wZ\n", TransportName);

    Status = OpenBrowser(&BrowserHandle);

    if (Status != NERR_Success) {
        return Status;
    }

    RequestPacket = MIDL_user_allocate(sizeof(LMDR_REQUEST_PACKET)+(DNLEN*sizeof(WCHAR))+TransportName->MaximumLength);

    if (RequestPacket == NULL) {
        NtClose(BrowserHandle);
        return(GetLastError());
    }

    RequestPacket->Version = LMDR_REQUEST_PACKET_VERSION_DOM;

    RequestPacket->Level = 0;

    RequestPacket->Parameters.GetBrowserServerList.ForceRescan = ForceRescan;

    if (Domain != NULL) {
        STRCPY(RequestPacket->Parameters.GetBrowserServerList.DomainName, Domain);

        RequestPacket->Parameters.GetBrowserServerList.DomainNameLength = (USHORT)STRLEN(Domain) * sizeof(TCHAR);
    } else {
        RequestPacket->Parameters.GetBrowserServerList.DomainNameLength = 0;
        RequestPacket->Parameters.GetBrowserServerList.DomainName[0] = L'\0';

    }

    RequestPacket->TransportName.Buffer = (PWSTR)((PCHAR)RequestPacket+sizeof(LMDR_REQUEST_PACKET)+DNLEN*sizeof(WCHAR));
    RequestPacket->TransportName.MaximumLength = TransportName->MaximumLength;

    RtlCopyUnicodeString(&RequestPacket->TransportName, TransportName);
    RtlInitUnicodeString( &RequestPacket->EmulatedDomainName, NULL );

    RequestPacket->Parameters.GetBrowserServerList.ResumeHandle = 0;

    Status = DeviceControlGetInfo(
                BrowserHandle,
                IOCTL_LMDR_GET_BROWSER_SERVER_LIST,
                RequestPacket,
                sizeof(LMDR_REQUEST_PACKET)+
                    (DNLEN*sizeof(WCHAR))+TransportName->MaximumLength,
                (PVOID *)BrowserList,
                0xffffffff,
                4096,
                NULL);

    if (Status == NERR_Success) {
        if ( NULL == *BrowserList ) {
            Status = ERROR_NO_BROWSER_SERVERS_FOUND;
        }
        else {
            *BrowserListLength = RequestPacket->Parameters.GetBrowserServerList.EntriesRead;
        }
    }

    NtClose(BrowserHandle);
    MIDL_user_free(RequestPacket);

    return Status;
}
NET_API_STATUS
OpenBrowser(
    OUT PHANDLE BrowserHandle
    )
/*++

Routine Description:

    This function opens a handle to the bowser device driver.

Arguments:

    OUT PHANDLE BrowserHandle - Returns the handle to the browser.

Return Value:

    NET_API_STATUS - NERR_Success or reason for failure.

--*/
{
    NTSTATUS ntstatus;

    UNICODE_STRING DeviceName;

    IO_STATUS_BLOCK IoStatusBlock;
    OBJECT_ATTRIBUTES ObjectAttributes;


    //
    // Open the redirector device.
    //
    RtlInitUnicodeString(&DeviceName, DD_BROWSER_DEVICE_NAME_U);

    InitializeObjectAttributes(
        &ObjectAttributes,
        &DeviceName,
        OBJ_CASE_INSENSITIVE,
        NULL,
        NULL
        );

    ntstatus = NtOpenFile(
                   BrowserHandle,
                   SYNCHRONIZE | GENERIC_READ | GENERIC_WRITE,
                   &ObjectAttributes,
                   &IoStatusBlock,
                   FILE_SHARE_READ | FILE_SHARE_WRITE,
                   FILE_SYNCHRONOUS_IO_NONALERT
                   );

    if (NT_SUCCESS(ntstatus)) {
        ntstatus = IoStatusBlock.Status;
    }

    return NetpNtStatusToApiStatus(ntstatus);

}

NET_API_STATUS
CheckForService(
    IN LPTSTR ServiceName,
    OUT LPSERVICE_STATUS ServiceStatus OPTIONAL
    )
{
    NET_API_STATUS NetStatus;
    SC_HANDLE ServiceControllerHandle;
    SC_HANDLE ServiceHandle;
    SERVICE_STATUS Status;

    if (!ARGUMENT_PRESENT(ServiceStatus)) {
        ServiceStatus = &Status;
    }

    ServiceControllerHandle = OpenSCManager(NULL, NULL, SC_MANAGER_ENUMERATE_SERVICE);

    if (ServiceControllerHandle == NULL) {

        return GetLastError();
    }

    ServiceHandle = OpenService(ServiceControllerHandle, ServiceName, SERVICE_QUERY_STATUS);

    if (ServiceHandle == NULL) {

        NetStatus = GetLastError();
        CloseServiceHandle(ServiceControllerHandle);
        return NetStatus;
    }


    if (!QueryServiceStatus(ServiceHandle, ServiceStatus)) {
        NetStatus = GetLastError();
        CloseServiceHandle(ServiceHandle);
        CloseServiceHandle(ServiceControllerHandle);

        return NetStatus;
    }

    if ((ServiceStatus->dwCurrentState != SERVICE_RUNNING) &&
        (ServiceStatus->dwCurrentState != SERVICE_START_PENDING)) {
        CloseServiceHandle(ServiceHandle);
        CloseServiceHandle(ServiceControllerHandle);
        return(NERR_ServiceNotInstalled);
    }

    CloseServiceHandle(ServiceHandle);

    CloseServiceHandle(ServiceControllerHandle);

    return NERR_Success;
}

NET_API_STATUS
BrGetLanaNumFromNetworkName(
    IN PWCHAR TransportName,
    OUT CCHAR *LanaNum
    )
/*++

    NOTE: THIS CODE WILL NOT WORK IN THE FUTURE!!!!!!!!!!!!!!

--*/

{

    HKEY Key;
    LPWSTR BindInformation = NULL;
    LPWSTR DevicePointer;
    ULONG BindInfoSize = 0;
    struct {
        CHAR    Enumerated;
        CHAR    LanaNum;
    } *LanaMap = NULL;

    ULONG LanaMapSize = 0;
    NET_API_STATUS Status = ERROR_SUCCESS;
    DWORD Type;
    DWORD LanaIndex;

    LanaIndex = 0;

    if (Status = RegOpenKeyEx(
                     HKEY_LOCAL_MACHINE,
                     L"System\\CurrentControlSet\\Services\\Netbios\\Linkage",
                     0,
                     KEY_QUERY_VALUE,
                     &Key))
    {
        return Status;
    }

    //
    // Get buffers length
    //

    Status = RegQueryValueEx(
                Key,
                L"Bind",
                0,
                NULL,
                NULL,
                &BindInfoSize
                );
    if ( Status != ERROR_SUCCESS ||
         BindInfoSize == 0 )
    {
        goto Cleanup;
    }

    Status = RegQueryValueEx(
                 Key,
                 L"LanaMap",
                 0,
                 NULL,
                 NULL,
                 &LanaMapSize
                 );

    if ( Status != ERROR_SUCCESS ||
         LanaMapSize == 0 )
    {
        goto Cleanup;
    }

    //
    // Allocate buffers for data.
    //

    BindInformation = MIDL_user_allocate(BindInfoSize);
    if ( !BindInformation )
    {
        Status = ERROR_OUTOFMEMORY;
        goto Cleanup;
    }

    LanaMap = MIDL_user_allocate(LanaMapSize);
    if ( !LanaMap )
    {
        Status = ERROR_OUTOFMEMORY;
        goto Cleanup;
    }


    //
    // Load values from registry
    //

    if (Status = RegQueryValueEx(
                     Key,
                     L"Bind",
                     0,
                     &Type,
                     (LPBYTE)BindInformation,
                     &BindInfoSize))
    {
          goto Cleanup;
    }

    if (Status = RegQueryValueEx(
                     Key,
                     L"LanaMap",
                     0,
                     &Type,
                     (LPBYTE)LanaMap,
                     &LanaMapSize))
    {
        goto Cleanup;
    }


    //
    // Calculate buffer size
    //


    DevicePointer = BindInformation;

    while (*DevicePointer != UNICODE_NULL) {
        if (!_wcsicmp(TransportName, DevicePointer)) {
            // found transport
            if (LanaMap[LanaIndex].Enumerated != 0) {
                *LanaNum = LanaMap[LanaIndex].LanaNum;
                Status = NERR_Success;

            } else {
                Status = ERROR_FILE_NOT_FOUND;
            }

            goto Cleanup;
        }

        LanaIndex += 1;

        DevicePointer += wcslen(DevicePointer)+1;
    }

Cleanup:

    if ( BindInformation )
    {
        MIDL_user_free( BindInformation );
    }
    if ( LanaMap )
    {
        MIDL_user_free( LanaMap );
    }
    RegCloseKey(Key);
    return( Status );
}

//              1234567890123456
#define SPACES "                "

#define ClearNcb( PNCB ) {                                          \
    RtlZeroMemory( PNCB , sizeof (NCB) );                           \
    RtlCopyMemory( (PNCB)->ncb_name,     SPACES, sizeof(SPACES)-1 );\
    RtlCopyMemory( (PNCB)->ncb_callname, SPACES, sizeof(SPACES)-1 );\
    }

NET_API_STATUS
GetNetBiosMasterName(
    IN LPWSTR NetworkName,
    IN LPWSTR PrimaryDomain,
    OUT LPWSTR MasterName,
    IN PSVCS_NET_BIOS_RESET SvcsNetBiosReset OPTIONAL
    )
{
    CCHAR LanaNum;
    NCB AStatNcb;
#define MAX_NETBIOS_NAMES 256
    struct {
        ADAPTER_STATUS AdapterInfo;
        NAME_BUFFER Names[MAX_NETBIOS_NAMES];
    } AdapterStatus;
    WORD i;
    CHAR remoteName[CNLEN+1];
    NET_API_STATUS Status;
    OEM_STRING OemString;
    UNICODE_STRING UnicodeString;

    Status = BrGetLanaNumFromNetworkName(NetworkName, &LanaNum);

    if (Status != NERR_Success) {
        return Status;
    }

    //
    // If the SvcsNetBiosReset argument is present, then this routine is
    // being called from the service.  In this case it needs to synchronize
    // its NetBios Reset with the workstation and the messenger.
    //
    if (ARGUMENT_PRESENT(SvcsNetBiosReset)) {
        SvcsNetBiosReset(LanaNum);
    }
    else {
        ClearNcb(&AStatNcb)

        AStatNcb.ncb_command = NCBRESET;
        AStatNcb.ncb_lsn = 0;           // Request resources
        AStatNcb.ncb_lana_num = LanaNum;
        AStatNcb.ncb_callname[0] = 0;   // 16 sessions
        AStatNcb.ncb_callname[1] = 0;   // 16 commands
        AStatNcb.ncb_callname[2] = 0;   // 8 names
        AStatNcb.ncb_callname[3] = 0;   // Don't want the reserved address
        Netbios( &AStatNcb );
    }
    ClearNcb( &AStatNcb );

    //
    //  Uppercase the remote name.
    //

    RtlInitUnicodeString(&UnicodeString, PrimaryDomain);

    OemString.Buffer=remoteName;

    OemString.MaximumLength=sizeof(remoteName);

    Status = RtlUpcaseUnicodeStringToOemString(&OemString,
                                        &UnicodeString,
                                        FALSE);

    if (!NT_SUCCESS(Status)) {
        return RtlNtStatusToDosError(Status);
    }

    AStatNcb.ncb_command = NCBASTAT;

    RtlCopyMemory( AStatNcb.ncb_callname, remoteName, strlen(remoteName));

    AStatNcb.ncb_callname[15] = MASTER_BROWSER_SIGNATURE;

    AStatNcb.ncb_lana_num = LanaNum;
    AStatNcb.ncb_length = sizeof( AdapterStatus );
    AStatNcb.ncb_buffer = (CHAR *)&AdapterStatus;
    Netbios( &AStatNcb );

    if ( AStatNcb.ncb_retcode == NRC_GOODRET ||
         AStatNcb.ncb_retcode == NRC_INCOMP ) {
        for ( i=0 ; i < min(AdapterStatus.AdapterInfo.name_count, MAX_NETBIOS_NAMES) ; i++ ) {
            if (AdapterStatus.Names[i].name[NCBNAMSZ-1] == SERVER_SIGNATURE) {
                DWORD j;

                //
                // Ignore malformed netbios names.
                //
                // Some transports have strange netbios names.  For instance,
                //  netbt registers a netbios name where the first 12 bytes
                //  are 0 and the last 4 bytes are the IP address.
                //
                for ( j = 0 ; j < CNLEN ; j++ ) {
                    if (AdapterStatus.Names[i].name[j] == '\0') {
                        break;
                    }
                }

                if ( j != CNLEN ) {
                    continue;
                }

                //
                // Convert to unicode
                //

                if (MultiByteToWideChar(CP_OEMCP,
                                            0,
                                            AdapterStatus.Names[i].name,
                                            CNLEN,
                                            MasterName,
                                            CNLEN) == 0) {
                    return(GetLastError());
                }

                for (j = CNLEN - 1; j ; j -= 1) {
                    if (MasterName[j] != L' ') {
                        MasterName[j+1] = UNICODE_NULL;
                        break;
                    }
                }

                return NERR_Success;
            }
        }
        return AStatNcb.ncb_retcode;
    } else {
        return AStatNcb.ncb_retcode;
    }
}

NET_API_STATUS
SendDatagram(
    IN HANDLE DgReceiverHandle,
    IN PUNICODE_STRING Network,
    IN PUNICODE_STRING EmulatedDomainName,
    IN PWSTR ResponseName,
    IN DGRECEIVER_NAME_TYPE NameType,
    IN PVOID Buffer,
    IN ULONG BufferLength
    )
{
    NET_API_STATUS Status;
    UCHAR PacketBuffer[sizeof(LMDR_REQUEST_PACKET)+(LM20_CNLEN+1)*sizeof(WCHAR)];
    PLMDR_REQUEST_PACKET RequestPacket = (PLMDR_REQUEST_PACKET)PacketBuffer;


    RequestPacket->Version = LMDR_REQUEST_PACKET_VERSION_DOM;

    RequestPacket->TransportName = *Network;
    RequestPacket->EmulatedDomainName = *EmulatedDomainName;

    RequestPacket->Type = Datagram;

    RequestPacket->Parameters.SendDatagram.DestinationNameType = NameType;

    RequestPacket->Parameters.SendDatagram.MailslotNameLength = 0;

    //
    //  The domain announcement name is special, so we don't have to specify
    //  a destination name for it.
    //

    RequestPacket->Parameters.SendDatagram.NameLength = wcslen(ResponseName)*sizeof(WCHAR);

    wcscpy(RequestPacket->Parameters.SendDatagram.Name, ResponseName);

    //
    //  This is a simple IoControl - It just sends the datagram.
    //

    Status = BrDgReceiverIoControl(DgReceiverHandle,
                    IOCTL_LMDR_WRITE_MAILSLOT,
                    RequestPacket,
                    FIELD_OFFSET(LMDR_REQUEST_PACKET, Parameters.SendDatagram.Name)+
                            RequestPacket->Parameters.SendDatagram.NameLength,
                    Buffer,
                    BufferLength,
                    NULL);

    return Status;
}



#ifdef ENABLE_PSEUDO_BROWSER
DWORD
GetBrowserValue(
    IN  OPTIONAL    LPTSTR  Section,
    IN              LPTSTR  Key,
    OUT             PDWORD pdwValue
    )
/*++
Routine Description:

    Query Registry for browser DWORD value.

Arguments:

    Section: registry section to query
    Key: Key to query value.

Return Value:

    ERROR_SUCCESS: Got value
    Win32 error: failed to get value
--*/
{
    DWORD status = NERR_Success;
    LPNET_CONFIG_HANDLE BrowserSection;
    const DWORD dwDefault = 0;

    NetpAssert(pdwValue);

    if ( Section ) {
        //
        // Open specified section
        // (usually used for policy propagation & such)
        //
        if (NetpOpenConfigDataWithPath(
                &BrowserSection,
                NULL,
                Section,
                TRUE) != NERR_Success) {
            return ERROR_CANTREAD;
        }
    }
    else {
        //
        // Open default browser section
        //
        if (NetpOpenConfigData(
                &BrowserSection,
                NULL,
                SECT_NT_BROWSER,
                TRUE) != NERR_Success) {
            return ERROR_CANTREAD;
        }
    }

    //
    // Get config value
    //
    if ( NetpGetConfigDword(
                BrowserSection,
                Key,
                dwDefault,
                pdwValue ) ) {
        // free handle & return failure (default's assigned already)
        NetpCloseConfigData(BrowserSection);
        return (ERROR_CANTREAD);
    }

    // free handle
    NetpCloseConfigData(BrowserSection);

    //
    // Hack: Net api missing key fixup
    //
    if ( Section ){
        //
        // If explicit path was specified we distinguish missing key
        // from when the key is set. However Net api return
        // success (assuming default) if the key is missing.
        // Thus, upon success we query below for the key's existance.
        // Justification: We need to know when a policy key was
        // specified or not. However for default net section we can
        // accept default value. That is, we assume proper call order:
        // 1. query policy --> if specified accept, if missing -->
        // 2. query net default location --> if missing or error accept
        //    default.
        // So why don't we just use our own? Cause net api has it standards
        // such as [yes|no] equiv to [DWORD(1)|DWORD(0)], default locations
        // and more.
        //
        HKEY SectionKey = NULL;
        DWORD cbData;
        LPWSTR pwszSection;
        const LPWSTR wszParameters = L"\\Parameters";


        // alloc & copy fixed up section name
        cbData = (wcslen(Section) + wcslen(wszParameters) + 1) * sizeof(WCHAR);
        pwszSection = MIDL_user_allocate(cbData);
        if (!pwszSection) {
            return (ERROR_CANTREAD);
        }
        wcscpy(pwszSection, Section);
        wcscat(pwszSection, wszParameters);


        status = RegOpenKeyEx (
                     HKEY_LOCAL_MACHINE,
                     pwszSection,
                     REG_OPTION_NON_VOLATILE,
                     KEY_READ,
                     &SectionKey );
        if (status) {
            //
            // Can't even open the key.
            //
            MIDL_user_free( pwszSection );
            return (ERROR_CANTREAD);
        }

        // free mem & query value.
        MIDL_user_free( pwszSection );
        cbData = 0;
        status = RegQueryValueEx(
                     SectionKey,
                     Key,
                     0,
                     NULL,
                     NULL,
                     &cbData );

        if ( status != ERROR_SUCCESS ||
             cbData == 0) {
                //
                // Key's not there or failed to get it
                //
                RegCloseKey(SectionKey);
                return (ERROR_CANTREAD);
        }

        RegCloseKey(SectionKey);
    }

    // Got value
    return (ERROR_SUCCESS);
}


DWORD
IsBrowserEnabled(
    IN  OPTIONAL    LPTSTR  Section,
    IN              LPTSTR  Key,
    IN              BOOL    fDefault
    )
/*++
Routine Description:

    Query Registry for browser boolean state.

Arguments:

    Section: registry section to query
    Key: Key to query value.

Return Value:

    ERROR_SUCCESS: Browser marked enabled.
    ERROR_SERVICE_DISABLED: Browser marked disabled.
    ERROR_CANTREAD: No regkey found or can't open.
--*/
{
    DWORD status = NERR_Success;
    LPNET_CONFIG_HANDLE BrowserSection;
    BOOL fEnabled = fDefault;


    if ( Section ) {
        //
        // Open specified section
        // (usually used for policy propagation & such)
        //
        if (NetpOpenConfigDataWithPath(
                &BrowserSection,
                NULL,
                Section,
                TRUE) != NERR_Success) {
            return ERROR_CANTREAD;
        }
    }
    else {
        //
        // Open default browser section
        //
        if (NetpOpenConfigData(
                &BrowserSection,
                NULL,
                SECT_NT_BROWSER,
                TRUE) != NERR_Success) {
            return ERROR_CANTREAD;
        }
    }

    //
    // Get config value
    //
    if ( NetpGetConfigBool(
                BrowserSection,
                Key,
                fDefault,
                &fEnabled
                ) ) {
        // free handle & return failure (default's assigned already)
        NetpCloseConfigData(BrowserSection);
        return (ERROR_CANTREAD);
    }

    // free handle
    NetpCloseConfigData(BrowserSection);

    //
    // Hack: Net api missing key fixup
    //
    if ( Section ){
        //
        // If explicit path was specified we distinguish missing key
        // from when the key is set. However Net api return
        // success (assuming default) if the key is missing.
        // Thus, upon success we query below for the key's existance.
        // Justification: We need to know when a policy key was
        // specified or not. However for default net section we can
        // accept default value. That is, we assume proper call order:
        // 1. query policy --> if specified accept, if missing -->
        // 2. query net default location --> if missing or error accept
        //    default.
        // So why don't we just use our own? Cause net api has it standards
        // such as [yes|no] equiv to [DWORD(1)|DWORD(0)], default locations
        // and more.
        //
        HKEY SectionKey = NULL;
        DWORD cbData;
        LPWSTR pwszSection;
        const LPWSTR wszParameters = L"\\Parameters";


        // alloc & copy fixed up section name
        cbData = (wcslen(Section) + wcslen(wszParameters) + 1) * sizeof(WCHAR);
        pwszSection = MIDL_user_allocate(cbData);
        if (!pwszSection) {
            return (ERROR_CANTREAD);
        }
        wcscpy(pwszSection, Section);
        wcscat(pwszSection, wszParameters);


        status = RegOpenKeyEx (
                     HKEY_LOCAL_MACHINE,
                     pwszSection,
                     REG_OPTION_NON_VOLATILE,
                     KEY_READ,
                     &SectionKey );
        if (status) {
            //
            // Can't even open the key.
            //
            MIDL_user_free( pwszSection );
            return (ERROR_CANTREAD);
        }

        // free mem & query value.
        MIDL_user_free( pwszSection );
        cbData = 0;
        status = RegQueryValueEx(
                     SectionKey,
                     Key,
                     0,
                     NULL,
                     NULL,
                     &cbData );

        if ( status != ERROR_SUCCESS ||
             cbData == 0) {
                //
                // Key's not there or failed to get it
                //
                RegCloseKey(SectionKey);
                return (ERROR_CANTREAD);
        }

        RegCloseKey(SectionKey);
    }

    // got value, return state.
    return ( fEnabled ? ERROR_SUCCESS :
                        ERROR_SERVICE_DISABLED);
}

BOOL
IsEnumServerEnabled(
    VOID
    )
/*++

Routine Description:

   Query the Registry to find if NetServerEnum functionality has
   been disabled by an admin.

Arguments:
    None.

Return Value:

    FALSE: service is marked disabled.
    TRUE: default or service is marked enabled

Remarks:
None.
--*/
{

    DWORD status;
    const BOOL fDefault = TRUE;

    //
    // Query default section
    //
    status = IsBrowserEnabled(
                BROWSER_POLICY_REGPATH_W,
                BROWSER_SEND_SERVER_ENUM_REGKEY_W,
                fDefault);
    if ( status == ERROR_SUCCESS ) {
        // policy marked enabled.
        return TRUE;
    }
    else if ( status == ERROR_SERVICE_DISABLED ) {
        // policy marked disabled
        return FALSE;
    }
    // else failed to read, thus try default (local) service location.

    //
    // Query default section
    //
    status = IsBrowserEnabled(
                NULL,
                BROWSER_SEND_SERVER_ENUM_REGKEY_W,
                fDefault);
    if ( status == ERROR_SERVICE_DISABLED ) {
        // marked disabled
        return FALSE;
    }
    // else either ERROR_SUCCESS (i.e. enabled)
    // or error (default to enabled)

    NetpAssert(fDefault);
    // default is enabled.
    return fDefault;
}




DWORD
GetBrowserPseudoServerLevel(
    VOID
    )
/*++

Routine Description:

   Query the Registry to find if this machine should act
   as a Pseudo Server (in case it's a master browser)

Arguments:
    None.

Return Value:

    FALSE: default or server is not a Pseudo Server.
    TRUE: service is marked as Pseudo Server.

Remarks:
None.
--*/
{

    DWORD status;
    const DWORD dwDefault = BROWSER_NON_PSEUDO;
    DWORD dwLevel = dwDefault;

    //
    // Query policy & then browser sections
    //
    if ( ERROR_SUCCESS == GetBrowserValue(
                                BROWSER_POLICY_REGPATH_W,
                                BROWSER_PSEUDO_SERVER_REGKEY_W,
                                &dwLevel)      ||
         ERROR_SUCCESS == GetBrowserValue(
                                NULL,
                                BROWSER_PSEUDO_SERVER_REGKEY_W,
                                &dwLevel) ) {

        // policy level exits
        if ( dwLevel != BROWSER_NON_PSEUDO &&
             dwLevel != BROWSER_SEMI_PSEUDO_NO_DMB &&
             dwLevel != BROWSER_PSEUDO ) {
            NetpAssert(!"Regkey browser pseudo level set to invalid value");
            return dwDefault;
        }
        return dwLevel;
    }
    // else failed to read all sections, use default.

    return dwDefault;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\browser\server\bowser_s_stub.c ===
#include "precomp.h"
#pragma hdrstop

#include "bowser_s.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\browser\server\bowqueue.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    bowqueue.c

Abstract:

    This module implements a worker thread and a set of functions for
    passing work to it.

Author:

    Larry Osterman (LarryO) 13-Jul-1992


Revision History:

--*/

#include "precomp.h"
#pragma hdrstop

// defines

// Thread start definition helpers. Taken from article in URL below.
// mk:@MSITStore:\\INFOSRV2\MSDN_OCT99\MSDN\period99.chm::/html/msft/msj/0799/win32/win320799.htm
//
typedef unsigned (__stdcall *PTHREAD_START) (void *);
#define chBEGINTHREADEX(psa, cbStack, pfnStartAddr, \
     pvParam, fdwCreate, pdwThreadID)               \
       ((HANDLE) _beginthreadex(                    \
          (void *) (psa),                           \
          (unsigned) (cbStack),                     \
          (PTHREAD_START) (pfnStartAddr),           \
          (void *) (pvParam),                       \
          (unsigned) (fdwCreate),                   \
          (unsigned *) (pdwThreadID)))

//
// Limit the number of created worker threads.
//
//  This count doesn't include the main thread.
//
#define BR_MAX_NUMBER_OF_WORKER_THREADS 10
ULONG BrNumberOfCreatedWorkerThreads = 0;

ULONG BrNumberOfActiveWorkerThreads = 0;

//
// Usage count array for determining how often each thread is used.
//
// Allow for the main thread.
//
ULONG BrWorkerThreadCount[BR_MAX_NUMBER_OF_WORKER_THREADS+1];

//
// Handles of created worker threads.
//
PHANDLE BrThreadArray[BR_MAX_NUMBER_OF_WORKER_THREADS];

//
// CritSect guard the WorkQueue list.
//

CRITICAL_SECTION BrWorkerCritSect;
BOOL BrWorkerCSInitialized = FALSE;

#define LOCK_WORK_QUEUE() EnterCriticalSection(&BrWorkerCritSect);
#define UNLOCK_WORK_QUEUE() LeaveCriticalSection(&BrWorkerCritSect);

//
// Head of singly linked list of work items queued to the worker thread.
//

LIST_ENTRY
BrWorkerQueueHead = {0};

//
// Event that is signal whenever a work item is put in the queue.  The
// worker thread waits on this event.
//

HANDLE
BrWorkerSemaphore = NULL;

//
// Synchronization mechanisms for shutdown
//
extern HANDLE           BrDgAsyncIOShutDownEvent;
extern HANDLE           BrDgAsyncIOThreadShutDownEvent;
extern BOOL             BrDgShutDownInitiated;
extern DWORD            BrDgAsyncIOsOutstanding;
extern DWORD             BrDgWorkerThreadsOutstanding;
extern CRITICAL_SECTION BrAsyncIOCriticalSection;


VOID
BrTimerRoutine(
    IN PVOID TimerContext,
    IN ULONG TImerLowValue,
    IN LONG TimerHighValue
    );

NET_API_STATUS
BrWorkerInitialization(
    VOID
    )
{
    ULONG Index;
    NET_API_STATUS NetStatus;

    try {
        //
        // Perform initialization that allows us to call BrWorkerTermination
        //

        try{
            InitializeCriticalSection( &BrWorkerCritSect );
        }
        except ( EXCEPTION_EXECUTE_HANDLER ) {
            return NERR_NoNetworkResource;
        }
        BrWorkerCSInitialized = TRUE;

        InitializeListHead( &BrWorkerQueueHead );
        BrNumberOfCreatedWorkerThreads = 0;
        BrNumberOfActiveWorkerThreads = 0;


        //
        // Initialize the work queue semaphore.
        //

        BrWorkerSemaphore = CreateSemaphore(NULL, 0, 0x7fffffff, NULL);

        if (BrWorkerSemaphore == NULL) {
            try_return ( NetStatus = GetLastError() );
        }

        NetStatus = NERR_Success;

        //
        // Done
        //
try_exit:NOTHING;
    } finally {

        if (NetStatus != NERR_Success) {
            (VOID) BrWorkerTermination();
        }
    }

    return NetStatus;
}

VOID
BrWorkerCreateThread(
    ULONG NetworkCount
    )

/*++

Routine Description:

    Ensure there are enough worker threads to handle the current number of
    networks.

    Worker threads are created but are never deleted until the browser terminates.
    Each worker thread has pending I/O.  We don't keep track of which thread has
    which I/O pending.  Thus, we can't delete any threads.

Arguments:

    NetworkCount - Current number of networks.

Return Value:

    None.

--*/
{
    ULONG ThreadId;

    //
    // Create 1 thread for every 2 networks.
    //  (round up)
    LOCK_WORK_QUEUE();
    while ( BrNumberOfCreatedWorkerThreads < (NetworkCount+1)/2 &&
            BrNumberOfCreatedWorkerThreads < BR_MAX_NUMBER_OF_WORKER_THREADS ) {

        BrThreadArray[BrNumberOfCreatedWorkerThreads] = chBEGINTHREADEX(NULL,   // CreateThread
                                   0,
                                   (LPTHREAD_START_ROUTINE)BrWorkerThread,
                                   ULongToPtr(BrNumberOfCreatedWorkerThreads),
                                   0,
                                   &ThreadId
                                 );

        if (BrThreadArray[BrNumberOfCreatedWorkerThreads] == NULL) {
            break;
        }

        //
        //  Set the browser threads to time critical priority.
        //

        SetThreadPriority(BrThreadArray[BrNumberOfCreatedWorkerThreads], THREAD_PRIORITY_ABOVE_NORMAL);

        //
        // Indicate we now have another thread.
        //

        BrNumberOfCreatedWorkerThreads++;


    }
    UNLOCK_WORK_QUEUE();
}

VOID
BrWorkerKillThreads(
    VOID
    )

/*++

Routine Description:

    Terminate all worker threads.

Arguments:

    None.

Return Value:

    None.

--*/
{
    ULONG Index;
    HANDLE ThreadHandle;

    //
    //  Make sure the terminate now event is in the signalled state to unwind
    //  all our threads.
    //

    SetEvent( BrGlobalData.TerminateNowEvent );

    //
    // Loop waiting for all the threads to stop.
    //
    LOCK_WORK_QUEUE();
    for ( Index = 0 ; Index < BrNumberOfCreatedWorkerThreads ; Index += 1 ) {
        if ( BrThreadArray[Index] != NULL ) {
            ThreadHandle = BrThreadArray[Index];
            UNLOCK_WORK_QUEUE();

            WaitForSingleObject( ThreadHandle, 0xffffffff );
            CloseHandle( ThreadHandle );

            LOCK_WORK_QUEUE();
            BrThreadArray[Index] = NULL;
        }

    }
    UNLOCK_WORK_QUEUE();

    return;
}

NET_API_STATUS
BrWorkerTermination(
    VOID
    )

/*++

Routine Description:

    Undo initialization of the worker threads.

Arguments:

    None.

Return Value:

    Status value -

--*/
{
    //
    // Ensure the threads have been terminated.
    //

    BrWorkerKillThreads();

    if ( BrWorkerSemaphore != NULL ) {
        CloseHandle( BrWorkerSemaphore );

        BrWorkerSemaphore = NULL;
    }

    BrNumberOfActiveWorkerThreads = 0;
    BrNumberOfCreatedWorkerThreads = 0;

    //
    // BrWorkerCSInit is set upon successfull CS initialization.
    // (see BrWorkerInitialization)
    //
    if ( BrWorkerCSInitialized ) {
        DeleteCriticalSection( &BrWorkerCritSect );
    }

    return NERR_Success;
}

VOID
BrQueueWorkItem(
    IN PWORKER_ITEM WorkItem
    )

/*++

Routine Description:

    This function queues a work item to a queue that is processed by
    a worker thread.  This thread runs at low priority, at IRQL 0

Arguments:

    WorkItem - Supplies a pointer to the work item to add the the queue.
        This structure must be located in NonPagedPool.  The work item
        structure contains a doubly linked list entry, the address of a
        routine to call and a parameter to pass to that routine.  It is
        the routine's responsibility to reclaim the storage occupied by
        the WorkItem structure.

Return Value:

    Status value -

--*/

{
    //
    // Acquire the worker thread spinlock and insert the work item in the
    // list and release the worker thread semaphore if the work item is
    // not already in the list.
    //

    LOCK_WORK_QUEUE();

    if (WorkItem->Inserted == FALSE) {

        BrPrint(( BR_QUEUE, "Inserting work item %lx (%lx)\n",WorkItem, WorkItem->WorkerRoutine));

        InsertTailList( &BrWorkerQueueHead, &WorkItem->List );

        WorkItem->Inserted = TRUE;

        ReleaseSemaphore( BrWorkerSemaphore,
                            1,
                            NULL
                          );
    }

    UNLOCK_WORK_QUEUE();

    return;
}

VOID
BrWorkerThread(
    IN PVOID StartContext
    )

{
    NET_API_STATUS NetStatus;

#define WORKER_SIGNALED      0
#define TERMINATION_SIGNALED 1
#define REG_CHANGE_SIGNALED  2
#define NUMBER_OF_EVENTS     3
    HANDLE WaitList[NUMBER_OF_EVENTS];
    ULONG WaitCount = 0;

    PWORKER_ITEM WorkItem;
    ULONG ThreadIndex = PtrToUlong(StartContext);

    HKEY RegistryHandle = NULL;
    HANDLE EventHandle = NULL;

    WaitList[WORKER_SIGNALED] = BrWorkerSemaphore;
    WaitCount ++;
    WaitList[TERMINATION_SIGNALED] = BrGlobalData.TerminateNowEvent;
    WaitCount ++;

    //
    // Primary thread waits on registry changes, too.
    //
    if ( ThreadIndex == 0xFFFFFFFF ) {
        DWORD RegStatus;
        NET_API_STATUS NetStatus;

        //
        // Register for notifications of changes to Parameters
        //
        // Failure doesn't affect normal operation of the browser.
        //

        RegStatus = RegOpenKeyExA( HKEY_LOCAL_MACHINE,
                                   "System\\CurrentControlSet\\Services\\Browser\\Parameters",
                                   0,
                                   KEY_NOTIFY,
                                   &RegistryHandle );

        if ( RegStatus != ERROR_SUCCESS ) {
            BrPrint(( BR_CRITICAL, "BrWorkerThead: Can't RegOpenKey %ld\n", RegStatus ));
        } else {

            EventHandle = CreateEvent(
                                       NULL,     // No security attributes
                                       TRUE,     // Automatically reset
                                       FALSE,    // Initially not signaled
                                       NULL );   // No name

            if ( EventHandle == NULL ) {
                BrPrint(( BR_CRITICAL, "BrWorkerThead: Can't CreateEvent %ld\n", GetLastError() ));
            } else {
                 NetStatus = RegNotifyChangeKeyValue(
                                RegistryHandle,
                                FALSE,                      // Ignore subkeys
                                REG_NOTIFY_CHANGE_LAST_SET, // Notify of value changes
                                EventHandle,
                                TRUE );                     // Signal event upon change

                if ( NetStatus != NERR_Success ) {
                    BrPrint(( BR_CRITICAL, "BrWorkerThead: Can't RegNotifyChangeKeyValue %ld\n", NetStatus ));
                } else {
                    WaitList[REG_CHANGE_SIGNALED] = EventHandle;
                    WaitCount ++;
                }
            }
        }
    }
    else
    {
        EnterCriticalSection( &BrAsyncIOCriticalSection );

        BrDgWorkerThreadsOutstanding++;

        LeaveCriticalSection( &BrAsyncIOCriticalSection );
    }

    BrPrint(( BR_QUEUE, "Starting new work thread, Context: %lx\n", StartContext));

    //
    // Set the thread priority to the lowest realtime level.
    //

    while( TRUE ) {
        ULONG WaitItem;

        //
        // Wait until something is put in the queue (semaphore is
        // released), remove the item from the queue, mark it not
        // inserted, and execute the specified routine.
        //

        BrPrint(( BR_QUEUE, "%lx: worker thread waiting\n", StartContext));

        do {
            WaitItem = WaitForMultipleObjectsEx( WaitCount, WaitList, FALSE, 0xffffffff, TRUE );
        } while ( WaitItem == WAIT_IO_COMPLETION );

        if (WaitItem == 0xffffffff) {
            BrPrint(( BR_CRITICAL, "WaitForMultipleObjects in browser queue returned %ld\n", GetLastError()));
            break;
        }

        if (WaitItem == TERMINATION_SIGNALED) {
            break;

        //
        // If the registry has changed,
        //  process the changes.
        //

        } else if ( WaitItem == REG_CHANGE_SIGNALED ) {

            //
            // Setup for future notifications.
            //
            NetStatus = RegNotifyChangeKeyValue(
                           RegistryHandle,
                           FALSE,                      // Ignore subkeys
                           REG_NOTIFY_CHANGE_LAST_SET, // Notify of value changes
                           EventHandle,
                           TRUE );                     // Signal event upon change

           if ( NetStatus != NERR_Success ) {
               BrPrint(( BR_CRITICAL, "BrWorkerThead: Can't RegNotifyChangeKeyValue %ld\n", NetStatus ));
           }


           NetStatus = BrReadBrowserConfigFields( FALSE );

           if ( NetStatus != NERR_Success) {
               BrPrint(( BR_CRITICAL, "BrWorkerThead: Can't BrReadConfigFields %ld\n", NetStatus ));
           }

           continue;

        }

        BrPrint(( BR_QUEUE, "%lx: Worker thread waking up\n", StartContext));

        LOCK_WORK_QUEUE();

        BrWorkerThreadCount[BrNumberOfActiveWorkerThreads++] += 1;

        ASSERT (!IsListEmpty(&BrWorkerQueueHead));

        if (!IsListEmpty(&BrWorkerQueueHead)) {
            WorkItem = (PWORKER_ITEM)RemoveHeadList( &BrWorkerQueueHead );

            ASSERT (WorkItem->Inserted);

            WorkItem->Inserted = FALSE;

        } else {
            WorkItem = NULL;
        }

        UNLOCK_WORK_QUEUE();

        BrPrint(( BR_QUEUE, "%lx: Pulling off work item %lx (%lx)\n", StartContext, WorkItem, WorkItem->WorkerRoutine));

        //
        // Execute the specified routine.
        //

        if (WorkItem != NULL) {
            (WorkItem->WorkerRoutine)( WorkItem->Parameter );
        }

        LOCK_WORK_QUEUE();
        BrNumberOfActiveWorkerThreads--;
        UNLOCK_WORK_QUEUE();

    }

    BrPrint(( BR_QUEUE, "%lx: worker thread exitting\n", StartContext));

    if ( ThreadIndex != 0xFFFFFFFF ) {
        IO_STATUS_BLOCK IoSb;
        DWORD waitResult;
        BOOL SetThreadEvent = FALSE;

        //
        //  Cancel the I/O operations outstanding on the browser.
        //  Then wait for the shutdown event to be signalled, but allow
        //  APC's to be called to call our completion routine.
        //

        NtCancelIoFile(BrDgReceiverDeviceHandle, &IoSb);

        do {
            waitResult = WaitForSingleObjectEx(BrDgAsyncIOShutDownEvent,0xffffffff, TRUE);
        }
        while( waitResult == WAIT_IO_COMPLETION );

        EnterCriticalSection( &BrAsyncIOCriticalSection );

        BrDgWorkerThreadsOutstanding--;
        if( BrDgWorkerThreadsOutstanding == 0 )
        {
            SetThreadEvent = TRUE;
        }

        LeaveCriticalSection( &BrAsyncIOCriticalSection );

        if( SetThreadEvent )
        {
            SetEvent( BrDgAsyncIOThreadShutDownEvent );
        }

    } else {
        if( RegistryHandle ) CloseHandle( RegistryHandle );
        if( EventHandle ) CloseHandle( EventHandle );
    }

}

NET_API_STATUS
BrCreateTimer(
    IN PBROWSER_TIMER Timer
    )
{
    OBJECT_ATTRIBUTES ObjA;
    NTSTATUS Status;

    InitializeObjectAttributes(&ObjA, NULL, 0, NULL, NULL);

    Status = NtCreateTimer(&Timer->TimerHandle,
                           TIMER_ALL_ACCESS,
                           &ObjA,
                           NotificationTimer);

    if (!NT_SUCCESS(Status)) {
        BrPrint(( BR_CRITICAL, "Failed to create timer %lx: %X\n", Timer, Status));
        return(BrMapStatus(Status));
    }

    BrPrint(( BR_TIMER, "Creating timer %lx: Handle: %lx\n", Timer, Timer->TimerHandle));

    return(NERR_Success);
}

NET_API_STATUS
BrDestroyTimer(
    IN PBROWSER_TIMER Timer
    )
{
    HANDLE Handle;

    //
    // Avoid destroying a timer twice.
    //

    if ( Timer->TimerHandle == NULL ) {
        return NERR_Success;
    }

    // Closing doesn't automatically cancel the timer.
    (VOID) BrCancelTimer( Timer );

    //
    // Close the handle and prevent future uses.
    //

    Handle = Timer->TimerHandle;
    Timer->TimerHandle = NULL;

    BrPrint(( BR_TIMER, "Destroying timer %lx\n", Timer));
    return BrMapStatus(NtClose(Handle));

}

NET_API_STATUS
BrCancelTimer(
    IN PBROWSER_TIMER Timer
    )
{
    //
    // Avoid cancelling a destroyed timer.
    //

    if ( Timer->TimerHandle == NULL ) {
        BrPrint(( BR_TIMER, "Canceling destroyed timer %lx\n", Timer));
        return NERR_Success;
    }

    BrPrint(( BR_TIMER, "Canceling timer %lx\n", Timer));
    return BrMapStatus(NtCancelTimer(Timer->TimerHandle, NULL));
}

NET_API_STATUS
BrSetTimer(
    IN PBROWSER_TIMER Timer,
    IN ULONG MillisecondsToExpire,
    IN PBROWSER_WORKER_ROUTINE WorkerFunction,
    IN PVOID Context
    )
{
    LARGE_INTEGER TimerDueTime;
    NTSTATUS NtStatus;
    //
    // Avoid setting a destroyed timer.
    //

    if ( Timer->TimerHandle == NULL ) {
        BrPrint(( BR_TIMER, "Setting a destroyed timer %lx\n", Timer));
        return NERR_Success;
    }

    BrPrint(( BR_TIMER, "Setting timer %lx to %ld milliseconds, WorkerFounction %lx, Context: %lx\n", Timer, MillisecondsToExpire, WorkerFunction, Context));

    //
    //  Figure out the timeout.
    //

    TimerDueTime.QuadPart = Int32x32To64( MillisecondsToExpire, -10000 );

    BrInitializeWorkItem(&Timer->WorkItem, WorkerFunction, Context);

    //
    //  Set the timer to go off when it expires.
    //

    NtStatus = NtSetTimer(Timer->TimerHandle,
                            &TimerDueTime,
                            BrTimerRoutine,
                            Timer,
                            FALSE,
                            0,
                            NULL
                            );

    if (!NT_SUCCESS(NtStatus)) {
#if DBG
        BrPrint(( BR_CRITICAL, "Unable to set browser timer expiration: %X (%lx)\n", NtStatus, Timer));
        DbgBreakPoint();
#endif

        return(BrMapStatus(NtStatus));
    }

    return NERR_Success;


}

VOID
BrTimerRoutine(
    IN PVOID TimerContext,
    IN ULONG TImerLowValue,
    IN LONG TimerHighValue
    )
{
    PBROWSER_TIMER Timer = TimerContext;

    BrPrint(( BR_TIMER, "Timer %lx fired\n", Timer));

    BrQueueWorkItem(&Timer->WorkItem);
}




VOID
BrInitializeWorkItem(
    IN  PWORKER_ITEM  Item,
    IN  PBROWSER_WORKER_ROUTINE Routine,
    IN  PVOID   Context)
/*++

Routine Description:

    Initializes fields in Item under queue lock

Arguments:

    Item -- worker item to init
    Routine -- routine to set
    Context -- work context to set

Return Value:
    none.

--*/
{
    LOCK_WORK_QUEUE();

    Item->WorkerRoutine = Routine;
    Item->Parameter = Context;
    Item->Inserted = FALSE;

    UNLOCK_WORK_QUEUE();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\browser\server\brbackup.h ===
/*++

Copyright (c) 1991 Microsoft Corporation

Module Name:

    brmain.h

Abstract:

    Private header file which defines the global data which is used for
    communication between the service control handler and the
    rest of the NT Workstation service.

Author:

    Rita Wong (ritaw) 06-May-1991

Revision History:

--*/

#ifndef _BRBACKUP_INCLUDED_
#define _BRBACKUP_INCLUDED_

NET_API_STATUS
BecomeBackup(
    IN PNETWORK Network,
    IN PVOID Context
    );

NET_API_STATUS
BrBecomeBackup(
    IN PNETWORK Network
    );

NET_API_STATUS
PostBecomeBackup(
    PNETWORK Network
    );

NET_API_STATUS
BrStopBackup (
    IN PNETWORK Network
    );

NET_API_STATUS
PostWaitForRoleChange (
    PNETWORK Network
    );

NET_API_STATUS
BrStopMaster(
    IN PNETWORK Network
    );

NET_API_STATUS
StartBackupBrowserTimer(
    IN PNETWORK Network
    );

NET_API_STATUS
BackupBrowserTimerRoutine (
    IN PVOID TimerContext
    );

#endif // ifndef _BRBACKUP_INCLUDED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\browser\server\br.h ===
/*++

Copyright (c) 1991 Microsoft Corporation

Module Name:

    br.h

Abstract:

    Private header file for the NT Browser service included by every
    module of the Workstation service.

Author:

    Rita Wong (ritaw) 15-Feb-1991

Revision History:

--*/

#ifndef _BR_INCLUDED_
#define _BR_INCLUDED_


#include <nt.h>                   // NT definitions
#include <ntrtl.h>                // NT runtime library definitions
#include <nturtl.h>

#include <windef.h>               // Win32 type definitions
#include <winbase.h>              // Win32 base API prototypes
#include <winsvc.h>               // Win32 service control APIs

#include <lmcons.h>               // LAN Manager common definitions
#include <lmerr.h>                // LAN Manager network error definitions
#include <lmsname.h>              // LAN Manager service names
#include <lmapibuf.h>             // NetApiBufferFree
#include <lmserver.h>

#include <netlib.h>               // LAN Man utility routines
#include <netlibnt.h>             // NetpNtStatusToApiStatus
#include <netdebug.h>             // NetpDbgPrint
#include <tstring.h>              // Transitional string functions
#include <icanon.h>               // I_Net canonicalize functions
#include <align.h>                // ROUND_UP_COUNT macro
#include <svcs.h>                 // Intrinsic service definitions
#include <strarray.h>

#include <rpc.h>                  // DataTypes and runtime APIs
#include <rpcutil.h>              // Prototypes for MIDL user functions
#include <bowser.h>               // Generated by the MIDL complier
#include <winsvc.h>
#include <srvann.h>
#include <lmbrowsr.h>

#include <ntddbrow.h>
#include <brcommon.h>               // Common browser routines.
#include <rx.h>
#include <rxserver.h>

#include <brconst.h>
#include "bowqueue.h"
#include "brdomain.h"
#include "browsnet.h"
#include "browslst.h"
#include "brutil.h"
#include "brwan.h"
#include "brmain.h"
#include "brdevice.h"
#include "brconfig.h"
#include "browsdom.h"
#include "brbackup.h"
#include "brmaster.h"
#include "srvenum.h"

//
//  The following macros are used to establish the semantics needed
//  to do a return from within a try-finally clause.  As a rule every
//  try clause must end with a label call try_exit.  For example,
//
//      try {
//              :
//              :
//
//      try_exit: NOTHING;
//      } finally {
//
//              :
//              :
//      }
//
//  Every return statement executed inside of a try clause should use the
//  try_return macro.  If the compiler fully supports the try-finally construct
//  then the macro should be
//
//      #define try_return(S)  { return(S); }
//
//  If the compiler does not support the try-finally construct then the macro
//  should be
//

#define try_return(S)  { S; goto try_exit; }




#if DBG

#define BrPrint(_x_) BrowserTrace _x_


#else

#define BrPrint(_x_)

#endif // DBG


#endif // ifdef _BR_INCLUDED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\browser\server\brconst.h ===
/*++

Copyright (c) 1991 Microsoft Corporation

Module Name:

    brconst.h

Abstract:

    Private header file which defines assorted mainifest constants for
    the browser service

Author:

    Rita Wong (ritaw) 06-May-1991

Revision History:

--*/

#ifndef _BRCONST_INCLUDED_
#define _BRCONST_INCLUDED_

//
//  Age the masters server list cache every MASTER_PERIODICITY times.
//
#define MASTER_PERIODICITY 12*60

//
//  Refresh the backup browsers server list every BACKUP_PERIODICITY
//
#define BACKUP_PERIODICITY 12*60

//
//  Buffer size used for GetBrowserServerList responses (in bytes).
//

#define BROWSER_BACKUP_LIST_RESPONSE_SIZE 400

//
//  If we failed to retrieve the server list, retry in BACKUP_ERROR_PERIODICITY
//  seconds
//

#define BACKUP_ERROR_PERIODICITY 30

//
//  If we failed to retrieve the server (or domain) list BACKUP_ERROR_FAILURE
//  times in a row, stop being a backup browser.
//

#define BACKUP_ERROR_FAILURE 5

//
//  Once we have stopped being a backup browser, we will not become a backup
//  until at least BACKUP_BROWSER_RECOVERY_TIME milliseconds have elapsed.
//

#define BACKUP_BROWSER_RECOVERY_TIME 30*60*1000

//
//  If we receive fewer than this # of domains or servers, we treat it as an
//  error.
//

#define BROWSER_MINIMUM_DOMAIN_NUMBER   1
#define BROWSER_MINIMUM_SERVER_NUMBER   2

//
//  Wait for this many minutes after each failed promotion before
//  continuing.
//

#define FAILED_PROMOTION_PERIODICITY    5*60

//
//  Run the master browser timer for 3 times (45 minutes) before
//  tossing the list in the service.
//

#define MASTER_BROWSER_LAN_TIMER_LIMIT  3

//
//  A browse request has to have a hit count of at least this value before
//  it is retained in the cache.
//

#define CACHED_BROWSE_RESPONSE_HIT_LIMIT    1

//
//  The maximum number of cache responses we will allow.
//

#define CACHED_BROWSE_RESPONSE_LIMIT        10

#endif // ifndef _BRCONST_INCLUDED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\browser\server\brconfig.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    brconfig.c

Abstract:

    This module contains the Browser service configuration routines.

Author:

    Rita Wong (ritaw) 22-May-1991

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop



//-------------------------------------------------------------------//
//                                                                   //
// Global variables                                                  //
//                                                                   //
//-------------------------------------------------------------------//

//
// Browser configuration information structure which holds the
// computername, primary domain, browser config buffer, and a resource
// to serialize access to the whole thing.
//
BRCONFIGURATION_INFO BrInfo = {0};

BR_BROWSER_FIELDS BrFields[] = {

    {WKSTA_KEYWORD_MAINTAINSRVLST, (LPDWORD) &BrInfo.MaintainServerList,
        1,(DWORD)-1,  0,         TriValueType, 0, NULL},

    {BROWSER_CONFIG_BACKUP_RECOVERY_TIME, &BrInfo.BackupBrowserRecoveryTime,
        BACKUP_BROWSER_RECOVERY_TIME, 0,  0xffffffff,         DWordType, 0, NULL},

    {L"CacheHitLimit", &BrInfo.CacheHitLimit,
//    {BROWSER_CONFIG_CACHE_HIT_LIMIT, &BrInfo.CacheHitLimit,
        CACHED_BROWSE_RESPONSE_HIT_LIMIT, 0, 0x100, DWordType, 0, NULL },

    {L"CacheResponseSize", &BrInfo.NumberOfCachedResponses,
//    {BROWSER_CONFIG_CACHE_HIT_LIMIT, &BrInfo.CacheHitLimit,
        CACHED_BROWSE_RESPONSE_LIMIT, 0, MAXULONG, DWordType, 0, NULL },

    {L"QueryDriverFrequency", &BrInfo.DriverQueryFrequency,
        BROWSER_QUERY_DRIVER_FREQUENCY, 0, 15*60, DWordType, 0, NULL },

    {L"DirectHostBinding", (LPDWORD)&BrInfo.DirectHostBinding,
       0, 0, 0, MultiSzType, 0, BrChangeDirectHostBinding },

    {L"UnboundBindings", (LPDWORD)&BrInfo.UnboundBindings,
        0, 0, 0, MultiSzType, 0, NULL },

    {L"MasterPeriodicity", (LPDWORD)&BrInfo.MasterPeriodicity,
        MASTER_PERIODICITY, 5*60, 0x7fffffff/1000, DWordType, 0, BrChangeMasterPeriodicity },

    {L"BackupPeriodicity", (LPDWORD)&BrInfo.BackupPeriodicity,
        BACKUP_PERIODICITY, 5*60, 0x7fffffff/1000, DWordType, 0, NULL },

#if DBG
    {L"BrowserDebug", (LPDWORD) &BrInfo.BrowserDebug,
        0,       0,  0xffffffff,DWordType, 0, NULL},
    {L"BrowserDebugLimit", (LPDWORD) &BrInfo.BrowserDebugFileLimit,
        10000*1024, 0,  0xffffffff,DWordType, 0, NULL},
#endif

    {NULL, NULL, 0, 0, 0, BooleanType, 0, NULL}

    };


ULONG
NumberOfServerEnumerations = {0};

ULONG
NumberOfDomainEnumerations = {0};

ULONG
NumberOfOtherEnumerations = {0};

ULONG
NumberOfMissedGetBrowserListRequests = {0};

CRITICAL_SECTION
BrowserStatisticsLock = {0};



NET_API_STATUS
BrGetBrowserConfiguration(
    VOID
    )
{
    NET_API_STATUS status;
    NT_PRODUCT_TYPE NtProductType;

    try {
        //
        // Initialize the resource for serializing access to configuration
        // information.
        //
        try{
            InitializeCriticalSection(&BrInfo.ConfigCritSect);
        }
        except ( EXCEPTION_EXECUTE_HANDLER ){
            return NERR_NoNetworkResource;
        }

        //
        // Lock config information structure for write access since we are
        // initializing the data in the structure.
        //
        EnterCriticalSection( &BrInfo.ConfigCritSect );

        //
        // Set pointer to configuration fields structure
        //
        BrInfo.BrConfigFields = BrFields;

        //
        //  Determine our product type.
        //

        RtlGetNtProductType(&NtProductType);

        BrInfo.IsLanmanNt = (NtProductType == NtProductLanManNt);


        //
        // Read from the config file the browser configuration fields
        //

        status = BrReadBrowserConfigFields( TRUE );

        if (status != NERR_Success) {
            try_return ( status );
        }

        if (BrInfo.IsLanmanNt) {
            BrInfo.MaintainServerList = 1;
        }


#ifdef ENABLE_PSEUDO_BROWSER
        BrInfo.PseudoServerLevel = GetBrowserPseudoServerLevel();
#endif
        //
        // Don't let the user define define an incompatible master/backup periodicity.
        //

        if ( BrInfo.MasterPeriodicity > BrInfo.BackupPeriodicity ) {
            BrInfo.BackupPeriodicity = BrInfo.MasterPeriodicity;
        }


try_exit:NOTHING;
    } finally {

        // else
        // Leave config file open because we need to read transport names from it.
        //

        LeaveCriticalSection(&BrInfo.ConfigCritSect);
    }
    return status;
}

#define REPORT_KEYWORD_IGNORED( lptstrKeyword ) \
    { \
        LPWSTR SubString[1]; \
        SubString[0] = lptstrKeyword; \
        BrLogEvent(EVENT_BROWSER_ILLEGAL_CONFIG, NERR_Success, 1, SubString); \
        NetpKdPrint(( \
                "[Browser] *ERROR* Tried to set keyword '" FORMAT_LPTSTR \
                "' with invalid value.\n" \
                "This error is ignored.\n", \
                lptstrKeyword )); \
    }


NET_API_STATUS
BrReadBrowserConfigFields(
    IN BOOL InitialCall
    )
/*++

Routine Description:

    This function assigns each browser/redir configuration field to the default
    value if it is not specified in the configuration file or if the value
    specified in the configuration file is invalid.  Otherwise it overrides
    the default value with the value found in the configuration file.

Arguments:


    InitialCall - True if this call was made during initialization

Return Value:

    None.

--*/
{
    NET_API_STATUS status;
    LPNET_CONFIG_HANDLE BrowserSection;
    DWORD i;

    LPTSTR KeywordValueBuffer;
    DWORD KeywordValueStringLength;
    DWORD KeywordValue;
    DWORD OldKeywordValue;

    //
    // Open config file and get handle to the [LanmanBrowser] section
    //

    if ((status = NetpOpenConfigData(
                      &BrowserSection,
                      NULL,         // Local
                      SECT_NT_BROWSER,
                      TRUE          // want read-only access
                      )) != NERR_Success) {
        return status;
    }

    for (i = 0; BrInfo.BrConfigFields[i].Keyword != NULL; i++) {
        BOOL ParameterChanged = FALSE;

        //
        // Skip this parameter if it can't change dynamically and
        //  this isn't the initial call.
        //

        if ( !InitialCall && BrInfo.BrConfigFields[i].DynamicChangeRoutine == NULL ) {
            continue;
        }

        switch (BrInfo.BrConfigFields[i].DataType) {

            case MultiSzType:
                status = NetpGetConfigTStrArray(
                                BrowserSection,
                                BrInfo.BrConfigFields[i].Keyword,
                                (LPTSTR_ARRAY *)(BrInfo.BrConfigFields[i].FieldPtr));
                if ((status != NO_ERROR) && (status != NERR_CfgParamNotFound)) {
                    REPORT_KEYWORD_IGNORED( BrInfo.BrConfigFields[i].Keyword );
                }
                break;

            case BooleanType:

                status = NetpGetConfigBool(
                                BrowserSection,
                                BrInfo.BrConfigFields[i].Keyword,
                                BrInfo.BrConfigFields[i].Default,
                                (LPBOOL)(BrInfo.BrConfigFields[i].FieldPtr)
                                );

                if ((status != NO_ERROR) && (status != NERR_CfgParamNotFound)) {

                    REPORT_KEYWORD_IGNORED( BrInfo.BrConfigFields[i].Keyword );

                }

                break;

            case TriValueType:

                //
                // Assign default configuration value
                //

                *(BrInfo.BrConfigFields[i].FieldPtr) = BrInfo.BrConfigFields[i].Default;

                if (NetpGetConfigValue(
                        BrowserSection,
                        BrInfo.BrConfigFields[i].Keyword,
                        &KeywordValueBuffer
                        ) != NERR_Success) {
                    continue;
                }

                KeywordValueStringLength = STRLEN(KeywordValueBuffer);

                if (STRICMP(KeywordValueBuffer, KEYWORD_YES) == 0) {
                    *(BrInfo.BrConfigFields[i].FieldPtr) = 1;
                } else if (STRICMP(KeywordValueBuffer, KEYWORD_TRUE) == 0) {
                    *(BrInfo.BrConfigFields[i].FieldPtr) = 1;
                } else if (STRICMP(KeywordValueBuffer, KEYWORD_NO) == 0) {
                    *(BrInfo.BrConfigFields[i].FieldPtr) = (DWORD) -1;
                } else if (STRICMP(KeywordValueBuffer, KEYWORD_FALSE) == 0) {
                    *(BrInfo.BrConfigFields[i].FieldPtr) = (DWORD) -1;
                } else if (STRICMP(KeywordValueBuffer, TEXT("AUTO")) == 0) {
                    *(BrInfo.BrConfigFields[i].FieldPtr) = 0;
                }
                else {
                    REPORT_KEYWORD_IGNORED( BrInfo.BrConfigFields[i].Keyword );
                }

                NetApiBufferFree(KeywordValueBuffer);

                break;


            case DWordType:

                OldKeywordValue = *(LPDWORD)BrInfo.BrConfigFields[i].FieldPtr;
                if (NetpGetConfigDword(
                        BrowserSection,
                        BrInfo.BrConfigFields[i].Keyword,
                        BrInfo.BrConfigFields[i].Default,
                        (LPDWORD)(BrInfo.BrConfigFields[i].FieldPtr)
                        ) != NERR_Success) {
                    continue;
                }

                KeywordValue = *(LPDWORD)BrInfo.BrConfigFields[i].FieldPtr;

                //
                // Don't allow too large or small a value.
                //

                if (KeywordValue < BrInfo.BrConfigFields[i].Minimum) {
                        BrPrint(( BR_CRITICAL, "%ws value out of range %lu (%lu-%lu)\n",
                                BrInfo.BrConfigFields[i].Keyword, KeywordValue,
                                BrInfo.BrConfigFields[i].Minimum,
                                BrInfo.BrConfigFields[i].Maximum
                                ));
                    KeywordValue =
                        *(LPDWORD)BrInfo.BrConfigFields[i].FieldPtr =
                        BrInfo.BrConfigFields[i].Minimum;
                }

                if (KeywordValue > BrInfo.BrConfigFields[i].Maximum) {
                        BrPrint(( BR_CRITICAL, "%ws value out of range %lu (%lu-%lu)\n",
                                BrInfo.BrConfigFields[i].Keyword, KeywordValue,
                                BrInfo.BrConfigFields[i].Minimum,
                                BrInfo.BrConfigFields[i].Maximum
                                ));
                    KeywordValue =
                        *(LPDWORD)BrInfo.BrConfigFields[i].FieldPtr =
                        BrInfo.BrConfigFields[i].Maximum;
                }

                //
                // Test if the parameter has actually changed
                //

                if ( OldKeywordValue != KeywordValue ) {
                    ParameterChanged = TRUE;
                }

                break;

            default:
                NetpAssert(FALSE);

            }

            //
            // If this is a dynamic parameter change,
            //  and this isn't the initial call.
            //  notify that this parameter changed.
            //

            if ( !InitialCall && ParameterChanged ) {
                BrInfo.BrConfigFields[i].DynamicChangeRoutine();
            }
    }

    status = NetpCloseConfigData(BrowserSection);

    if (BrInfo.DirectHostBinding != NULL &&
        !NetpIsTStrArrayEmpty(BrInfo.DirectHostBinding)) {
        BrPrint(( BR_INIT,"DirectHostBinding length: %ld\n",NetpTStrArrayEntryCount(BrInfo.DirectHostBinding)));

        if (NetpTStrArrayEntryCount(BrInfo.DirectHostBinding) % 2 != 0) {
            status = ERROR_INVALID_PARAMETER;
        }
    }

    return status;
}


VOID
BrDeleteConfiguration (
    DWORD BrInitState
    )
{

    if (BrInfo.DirectHostBinding != NULL) {
        NetApiBufferFree(BrInfo.DirectHostBinding);
    }

    if (BrInfo.UnboundBindings != NULL) {
        NetApiBufferFree(BrInfo.UnboundBindings);
    }

    DeleteCriticalSection(&BrInfo.ConfigCritSect);

    UNREFERENCED_PARAMETER(BrInitState);
}


NET_API_STATUS
BrChangeDirectHostBinding(
    VOID
    )
/*++

Routine Description (BrChnageDirectHostBinding):

    Handle a change in DirectHostBinding entry in the registry based on
    Registry notification.
    This is used so that when NwLnkNb transport is created via PnP, we should
    also create NwLnkIpx (current usage).
    The binding is refreshed in BrReadBrowserConfigFields above.

Arguments:

    None.

Return Value:

    None.

--*/
{
    NET_API_STATUS NetStatus = NERR_Success;


    NetStatus = BrChangeConfigValue(
                    L"DirectHostBinding",
                    MultiSzType,
                    NULL,
                    &(BrInfo.DirectHostBinding),
                    TRUE );

    if ( NetStatus == NERR_Success ) {

        //
        // DirectHostBinding sepcified. Verify consistency
        //

        EnterCriticalSection ( &BrInfo.ConfigCritSect );
        if (BrInfo.DirectHostBinding != NULL &&
            !NetpIsTStrArrayEmpty(BrInfo.DirectHostBinding)) {
            BrPrint(( BR_INIT,"DirectHostBinding length: %ld\n",NetpTStrArrayEntryCount(BrInfo.DirectHostBinding)));

            if (NetpTStrArrayEntryCount(BrInfo.DirectHostBinding) % 2 != 0) {
                NetApiBufferFree(BrInfo.DirectHostBinding);
                BrInfo.DirectHostBinding = NULL;
                // we fail on invalid specifications
                NetStatus = ERROR_INVALID_PARAMETER;
            }
        }
        LeaveCriticalSection ( &BrInfo.ConfigCritSect );
    }

    return NetStatus;
}


NET_API_STATUS
BrChangeConfigValue(
    LPWSTR      pszKeyword      IN,
    DATATYPE    dataType        IN,
    PVOID       pDefault        IN,
    PVOID       *ppData         OUT,
    BOOL        bFree           IN
    )
/*++

Routine Description:

    Reads in the registry value for browser registry Entry

Arguments:

    pszKeyword -- keyword relative to browser param section
    dataType -- the type of the data to get from netapi lib.
    pDefault -- Default value (to pass to reg calls).
    pData -- data read from the registry.
Return Value:

    Net api error code


--*/
{
    NET_API_STATUS status = STATUS_SUCCESS;

    LPNET_CONFIG_HANDLE BrowserSection = NULL;
    LPTSTR KeywordValueBuffer;
    DWORD KeywordValueStringLength;
    PVOID pData = NULL;

    ASSERT ( ppData );


    EnterCriticalSection ( &BrInfo.ConfigCritSect );

    //
    // Open config file and get handle to the [LanmanBrowser] section
    //

    if ((status = NetpOpenConfigData(
                      &BrowserSection,
                      NULL,         // Local
                      SECT_NT_BROWSER,
                      TRUE          // want read-only access
                      )) != NERR_Success) {
        goto Cleanup;
    }


    switch (dataType) {

        case MultiSzType:

            {
                LPTSTR_ARRAY lpValues = NULL;

                status = NetpGetConfigTStrArray(
                                BrowserSection,
                                pszKeyword,
                                (LPTSTR_ARRAY *)(&lpValues));
                if ((status != NO_ERROR) && (status != NERR_CfgParamNotFound)) {
                    REPORT_KEYWORD_IGNORED( pszKeyword );
                }
                else {
                    pData = (PVOID)lpValues;
                }
                break;
            }

        case BooleanType:

            {
                //
                // Note : This case is unused at the moment.
                //

                BOOL bData;
                status = NetpGetConfigBool(
                                BrowserSection,
                                pszKeyword,
                                *(LPBOOL)pDefault,
                                &bData
                                );

                if ((status != NO_ERROR) && (status != NERR_CfgParamNotFound)) {
                    REPORT_KEYWORD_IGNORED( pszKeyword );
                }
                else
                {
                    // store bool value in ptr.
                    // caller is responsible for consistent semantics translation.
                    pData = IntToPtr((int)bData);
                }

                break;
            }

        case TriValueType:

            {
                //
                // Assign default configuration value
                //
                if (NetpGetConfigValue(
                        BrowserSection,
                        pszKeyword,
                        &KeywordValueBuffer
                        ) != NERR_Success) {
                    REPORT_KEYWORD_IGNORED( pszKeyword );
                }

                KeywordValueStringLength = STRLEN(KeywordValueBuffer);

                if (STRICMP(KeywordValueBuffer, KEYWORD_YES) == 0) {
                    pData = (LPVOID)1;
                } else if (STRICMP(KeywordValueBuffer, KEYWORD_TRUE) == 0) {
                    pData = (LPVOID)1;
                } else if (STRICMP(KeywordValueBuffer, KEYWORD_NO) == 0) {
                    pData = (LPVOID) -1;
                } else if (STRICMP(KeywordValueBuffer, KEYWORD_FALSE) == 0) {
                    pData = (LPVOID) -1;
                } else if (STRICMP(KeywordValueBuffer, TEXT("AUTO")) == 0) {
                    pData = (LPVOID)0;
                }
                else {
                    // assign the value pointed by pDefault to pData
                    pData = ULongToPtr((*(LPDWORD)pDefault));
                    REPORT_KEYWORD_IGNORED( pszKeyword );
                }

                NetApiBufferFree(KeywordValueBuffer);

                break;
            }



        case DWordType:

            {
                DWORD dwTmp;

                if (NetpGetConfigDword(
                        BrowserSection,
                        pszKeyword,
                        *(LPDWORD)pDefault,
                        &dwTmp
                        ) != NERR_Success) {
                    REPORT_KEYWORD_IGNORED( pszKeyword );
                }
                else {
                    pData = ULongToPtr(dwTmp);
                }

                break;
            }

        default:
            NetpAssert(FALSE);
    }


Cleanup:

    // Close config, & leave CS
    NetpCloseConfigData(BrowserSection);

    // optionaly free data & set return buffer
    if ( status == STATUS_SUCCESS )
    {
        if ( bFree && *ppData )
        {
            NetApiBufferFree( *ppData );
        }
        *ppData = pData;
    }
    LeaveCriticalSection ( &BrInfo.ConfigCritSect );

    return status;
}




#if DBG
NET_API_STATUS
BrUpdateDebugInformation(
    IN LPWSTR SystemKeyName,
    IN LPWSTR ValueName,
    IN LPTSTR TransportName,
    IN LPTSTR ServerName OPTIONAL,
    IN DWORD ServiceStatus
    )
/*++

Routine Description:

    This routine will stick debug information in the registry about the last
    time the browser retrieved information from the remote server.

Arguments:


Return Value:

    None.

--*/

{
    WCHAR TotalKeyName[MAX_PATH];
    ULONG Disposition;
    HKEY Key;
    ULONG Status;
    SYSTEMTIME LocalTime;
    WCHAR LastUpdateTime[100];

    //
    //  Build the key name:
    //
    //  HKEY_LOCAL_MACHINE:System\CurrentControlSet\Services\Browser\Debug\<Transport>\SystemKeyName
    //

    wcscpy(TotalKeyName, L"System\\CurrentControlSet\\Services\\Browser\\Debug");

    wcscat(TotalKeyName, TransportName);

    wcscat(TotalKeyName, L"\\");

    wcscat(TotalKeyName, SystemKeyName);

    if ((Status = RegCreateKeyEx(HKEY_LOCAL_MACHINE, TotalKeyName, 0,
                        L"BrowserDebugInformation",
                        REG_OPTION_NON_VOLATILE,
                        KEY_WRITE,
                        NULL,
                        &Key,
                        &Disposition)) != ERROR_SUCCESS) {
        BrPrint(( BR_CRITICAL,"Unable to create key to log debug information: %lx\n", Status));
        return Status;
    }

    if (ARGUMENT_PRESENT(ServerName)) {
        if ((Status = RegSetValueEx(Key, ValueName, 0, REG_SZ, (LPBYTE)ServerName, (wcslen(ServerName)+1) * sizeof(WCHAR))) != ERROR_SUCCESS) {
            BrPrint(( BR_CRITICAL,
                      "Unable to set value of ServerName value to %ws: %lx\n",
                      ServerName, Status));
            RegCloseKey(Key);
            return Status;
        }
    } else {
        if ((Status = RegSetValueEx(Key, ValueName, 0, REG_DWORD, (LPBYTE)&ServiceStatus, sizeof(ULONG))) != ERROR_SUCCESS) {
            BrPrint(( BR_CRITICAL,"Unable to set value of ServerName value to %ws: %lx\n", ServerName, Status));
            RegCloseKey(Key);
            return Status;
        }
    }


    GetLocalTime(&LocalTime);

    swprintf(LastUpdateTime, L"%d/%d/%d %d:%d:%d:%d", LocalTime.wDay,
                                                    LocalTime.wMonth,
                                                    LocalTime.wYear,
                                                    LocalTime.wHour,
                                                    LocalTime.wMinute,
                                                    LocalTime.wSecond,
                                                    LocalTime.wMilliseconds);

    if ((Status = RegSetValueEx(Key, L"LastUpdateTime", 0, REG_SZ, (LPBYTE)&LastUpdateTime, (wcslen(LastUpdateTime) + 1)*sizeof(WCHAR))) != ERROR_SUCCESS) {
        BrPrint(( BR_CRITICAL,"Unable to set value of LastUpdateTime value to %s: %lx\n", LastUpdateTime, Status));
    }

    RegCloseKey(Key);
    return Status;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\browser\server\brdevice.c ===
/*++

Copyright (c) 1991-1992  Microsoft Corporation

Module Name:

    brdevice.c

Abstract:

    This module contains the support routines for the APIs that call
    into the browser or the datagram receiver.

Author:

    Rita Wong (ritaw) 20-Feb-1991
    Larry Osterman (larryo) 23-Mar-1992

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop

//-------------------------------------------------------------------//
//                                                                   //
// Local Function Prototypes                                         //
//                                                                   //
//-------------------------------------------------------------------//


//-------------------------------------------------------------------//
//                                                                   //
// Global variables                                                  //
//                                                                   //
//-------------------------------------------------------------------//

// Event for synchronization of asynchronous I/O completion against the
// datagram receiver

HANDLE           BrDgAsyncIOShutDownEvent;
HANDLE           BrDgAsyncIOThreadShutDownEvent;
BOOL             BrDgShutDownInitiated = FALSE;
DWORD            BrDgAsyncIOsOutstanding = 0;
DWORD            BrDgWorkerThreadsOutstanding = 0;
CRITICAL_SECTION BrAsyncIOCriticalSection;


//
// Handle to the Datagram Receiver DD
//
HANDLE BrDgReceiverDeviceHandle = NULL;

VOID
CompleteAsyncBrowserIoControl(
                             IN PVOID ApcContext,
                             IN PIO_STATUS_BLOCK IoStatusBlock,
                             IN ULONG Reserved
                             );

VOID
BrDecrementOutstandingIos()
/*++

Routine Description:

    Decrements the outstanding IO count, and signals the event if necessary

Arguments:

    None.

Return Value:

    VOID

--*/
{
    BOOL SignalAsyncIOShutDownEvent = FALSE;

    EnterCriticalSection(&BrAsyncIOCriticalSection);

    BrDgAsyncIOsOutstanding -= 1;

    if (BrDgAsyncIOsOutstanding == 0 &&
        BrDgShutDownInitiated) {
        SignalAsyncIOShutDownEvent = TRUE;
    }

    LeaveCriticalSection(&BrAsyncIOCriticalSection);

    if (SignalAsyncIOShutDownEvent) {
        SetEvent(BrDgAsyncIOShutDownEvent);
    }
}

NET_API_STATUS
BrOpenDgReceiver (
                 VOID
                 )
/*++

Routine Description:

    This routine opens the NT LAN Man Datagram Receiver driver.

Arguments:

    None.

Return Value:

    NET_API_STATUS - NERR_Success or reason for failure.

--*/
{
    NET_API_STATUS  Status;
    NTSTATUS ntstatus;

    UNICODE_STRING DeviceName;

    IO_STATUS_BLOCK IoStatusBlock;
    OBJECT_ATTRIBUTES ObjectAttributes;

    //
    // Open the redirector device.
    //
    RtlInitUnicodeString(&DeviceName, DD_BROWSER_DEVICE_NAME_U);

    InitializeObjectAttributes(
                              &ObjectAttributes,
                              &DeviceName,
                              OBJ_CASE_INSENSITIVE,
                              NULL,
                              NULL
                              );

    ntstatus = NtOpenFile(
                         &BrDgReceiverDeviceHandle,
                         SYNCHRONIZE,
                         &ObjectAttributes,
                         &IoStatusBlock,
                         0,
                         0
                         );

    if (NT_SUCCESS(ntstatus)) {
        ntstatus = IoStatusBlock.Status;
    }

    if (! NT_SUCCESS(ntstatus)) {
        BrPrint(( BR_CRITICAL,"NtOpenFile browser driver failed: 0x%08lx\n",
                  ntstatus));
    }

    Status = NetpNtStatusToApiStatus(ntstatus);

    if (NT_SUCCESS(ntstatus)) {
        // Initialize the event and the critical section used for async I/O

        try {
            BrDgShutDownInitiated = FALSE;
            BrDgAsyncIOsOutstanding = 0;
            BrDgWorkerThreadsOutstanding = 0;

            InitializeCriticalSection( &BrAsyncIOCriticalSection );

            BrDgAsyncIOShutDownEvent =
            CreateEvent(
                       NULL,                // Event attributes
                       TRUE,                // Event must be manually reset
                       FALSE,
                       NULL             // Initial state not signalled
                       );

            if (BrDgAsyncIOShutDownEvent == NULL) {
                DeleteCriticalSection(&BrAsyncIOCriticalSection);
                Status = GetLastError();
            }

            BrDgAsyncIOThreadShutDownEvent =
            CreateEvent(
                       NULL,
                       TRUE,
                       FALSE,
                       NULL
                       );
            if( BrDgAsyncIOThreadShutDownEvent == NULL ) {
                CloseHandle( BrDgAsyncIOShutDownEvent );
                BrDgAsyncIOShutDownEvent = NULL;
                DeleteCriticalSection(&BrAsyncIOCriticalSection);
                Status = GetLastError();
            }
        }
        except ( EXCEPTION_EXECUTE_HANDLER ) {
            Status = ERROR_NO_SYSTEM_RESOURCES;
        }
    }

    return Status;
}



VOID
BrShutdownDgReceiver(
                    VOID
                    )
/*++

Routine Description:

    This routine close the LAN Man Redirector device.

Arguments:

    None.

Return Value:

    None.

--*/
{
    IO_STATUS_BLOCK IoSb;
    LARGE_INTEGER   timeout;
    BOOL            WaitForAsyncIOCompletion = FALSE;
    DWORD           waitResult = 0;

    EnterCriticalSection(&BrAsyncIOCriticalSection);

    BrDgShutDownInitiated = TRUE;

    if (BrDgAsyncIOsOutstanding != 0) {
        WaitForAsyncIOCompletion = TRUE;
    }

    LeaveCriticalSection(&BrAsyncIOCriticalSection);

    if (WaitForAsyncIOCompletion) {
        //
        //  Cancel the I/O operations outstanding on the browser.
        //  Then wait for the shutdown event to be signalled, but allow
        //  APC's to be called to call our completion routine.
        //

        NtCancelIoFile(BrDgReceiverDeviceHandle, &IoSb);

        do {
            waitResult = WaitForSingleObjectEx(BrDgAsyncIOShutDownEvent,0xffffffff, TRUE);
        }
        while( waitResult == WAIT_IO_COMPLETION );
    }

    ASSERT(BrDgAsyncIOsOutstanding == 0);

    EnterCriticalSection(&BrAsyncIOCriticalSection);

    // Wait for the final worker thread to exit if necessary
    if( BrDgWorkerThreadsOutstanding > 0 )
    {
        WaitForAsyncIOCompletion = TRUE;
    }
    else
    {
        WaitForAsyncIOCompletion = FALSE;
    }
        
    LeaveCriticalSection(&BrAsyncIOCriticalSection);

    if( WaitForAsyncIOCompletion )
    {
        // This will either be signalled from before, or the final worker thread will signal it.
        WaitForSingleObject( BrDgAsyncIOThreadShutDownEvent, 0xffffffff );
    }

    if (BrDgAsyncIOShutDownEvent != NULL) {
        CloseHandle(BrDgAsyncIOShutDownEvent);
        CloseHandle(BrDgAsyncIOThreadShutDownEvent);

        DeleteCriticalSection(&BrAsyncIOCriticalSection);
    }
}


//
//  Retreive the list of bound transports from the bowser driver.
//

NET_API_STATUS
BrGetTransportList(
                  OUT PLMDR_TRANSPORT_LIST *TransportList
                  )
{
    NET_API_STATUS Status;
    LMDR_REQUEST_PACKET RequestPacket;

    //
    //  If we have a previous buffer that was too small, free it up.
    //

    RequestPacket.Version = LMDR_REQUEST_PACKET_VERSION_DOM;

    RequestPacket.Type = EnumerateXports;

    RtlInitUnicodeString(&RequestPacket.TransportName, NULL);
    RtlInitUnicodeString(&RequestPacket.EmulatedDomainName, NULL);

    Status = DeviceControlGetInfo(
                                 BrDgReceiverDeviceHandle,
                                 IOCTL_LMDR_ENUMERATE_TRANSPORTS,
                                 &RequestPacket,
                                 sizeof(RequestPacket),
                                 (LPVOID *)TransportList,
                                 0xffffffff,
                                 4096,
                                 NULL
                                 );

    return Status;
}

NET_API_STATUS
BrAnnounceDomain(
                IN PNETWORK Network,
                IN ULONG Periodicity
                )
{
    NET_API_STATUS Status;
    UCHAR AnnounceBuffer[sizeof(BROWSE_ANNOUNCE_PACKET)+LM20_CNLEN+1];
    PBROWSE_ANNOUNCE_PACKET Announcement = (PBROWSE_ANNOUNCE_PACKET )AnnounceBuffer;

    //
    //  We don't announce domains on direct host IPX.
    //

    if (Network->Flags & NETWORK_IPX) {
        return NERR_Success;
    }

    Announcement->BrowseType = WkGroupAnnouncement;

    Announcement->BrowseAnnouncement.Periodicity = Periodicity;

    Announcement->BrowseAnnouncement.UpdateCount = 0;

    Announcement->BrowseAnnouncement.VersionMajor = BROWSER_CONFIG_VERSION_MAJOR;

    Announcement->BrowseAnnouncement.VersionMinor = BROWSER_CONFIG_VERSION_MINOR;

    Announcement->BrowseAnnouncement.Type = SV_TYPE_DOMAIN_ENUM | SV_TYPE_NT;

    if (Network->Flags & NETWORK_PDC ) {
        Announcement->BrowseAnnouncement.Type |= SV_TYPE_DOMAIN_CTRL;
    }

    lstrcpyA(Announcement->BrowseAnnouncement.ServerName, Network->DomainInfo->DomOemDomainName);

    lstrcpyA(Announcement->BrowseAnnouncement.Comment, Network->DomainInfo->DomOemComputerName );

    Status = SendDatagram(BrDgReceiverDeviceHandle,
                          &Network->NetworkName,
                          &Network->DomainInfo->DomUnicodeDomainNameString,
                          Network->DomainInfo->DomUnicodeDomainName,
                          DomainAnnouncement,
                          Announcement,
                          FIELD_OFFSET(BROWSE_ANNOUNCE_PACKET, BrowseAnnouncement.Comment)+
                          Network->DomainInfo->DomOemComputerNameLength+sizeof(UCHAR)
                         );

    if (Status != NERR_Success) {

        BrPrint(( BR_CRITICAL,
                  "%ws: Unable to announce domain for network %wZ: %X\n",
                  Network->DomainInfo->DomUnicodeDomainName,
                  &Network->NetworkName,
                  Status));

    }

    return Status;

}



NET_API_STATUS
BrUpdateBrowserStatus (
                      IN PNETWORK Network,
                      IN DWORD ServiceStatus
                      )
{
    NET_API_STATUS Status;
    UCHAR PacketBuffer[sizeof(LMDR_REQUEST_PACKET)+(LM20_CNLEN+1)*sizeof(WCHAR)];
    PLMDR_REQUEST_PACKET RequestPacket = (PLMDR_REQUEST_PACKET)PacketBuffer;


    RequestPacket->Version = LMDR_REQUEST_PACKET_VERSION_DOM;

    RequestPacket->TransportName = Network->NetworkName;
    RequestPacket->EmulatedDomainName = Network->DomainInfo->DomUnicodeDomainNameString;

    RequestPacket->Parameters.UpdateStatus.NewStatus = ServiceStatus;

    RequestPacket->Parameters.UpdateStatus.IsLanmanNt = (BrInfo.IsLanmanNt != FALSE);

#ifdef ENABLE_PSEUDO_BROWSER
    RequestPacket->Parameters.UpdateStatus.PseudoServerLevel = (BOOL)(BrInfo.PseudoServerLevel);
#endif

    // RequestPacket->Parameters.UpdateStatus.IsMemberDomain = TRUE; // Not used
    // RequestPacket->Parameters.UpdateStatus.IsPrimaryDomainController = Network->DomainInfo->IsPrimaryDomainController;
    // RequestPacket->Parameters.UpdateStatus.IsDomainMaster = Network->DomainInfo->IsDomainMasterBrowser;

    RequestPacket->Parameters.UpdateStatus.MaintainServerList = (BrInfo.MaintainServerList == 1);

    //
    //  Tell the bowser the number of servers in the server table.
    //

    RequestPacket->Parameters.UpdateStatus.NumberOfServersInTable =
    NumberInterimServerListElements(&Network->BrowseTable) +
    NumberInterimServerListElements(&Network->DomainList) +
    Network->TotalBackupServerListEntries +
    Network->TotalBackupDomainListEntries;

    //
    //  This is a simple IoControl - It just updates the status.
    //

    Status = BrDgReceiverIoControl(BrDgReceiverDeviceHandle,
                                   IOCTL_LMDR_UPDATE_STATUS,
                                   RequestPacket,
                                   sizeof(LMDR_REQUEST_PACKET),
                                   NULL,
                                   0,
                                   NULL);

    return Status;
}

NET_API_STATUS
BrIssueAsyncBrowserIoControl(
                            IN PNETWORK Network OPTIONAL,
                            IN ULONG ControlCode,
                            IN PBROWSER_WORKER_ROUTINE CompletionRoutine,
                            IN PVOID OptionalParameter
                            )
/*++

Routine Description:

    Issue an asynchronous Io Control to the browser.  Call the specified
    completion routine when the IO finishes.

Arguments:

    Network - Network the function applies to
        If this parameter is not supplied, the operation is not related to a
            particular network..

    ControlCode - IoControl function code

    CompletionRoutine - Routine to be called when the IO finishes.

    OptionalParameter - Function code specific information

Return Value:

    Status of the operation.

--*/

{
    ULONG PacketSize;
    PLMDR_REQUEST_PACKET RequestPacket = NULL;
    NTSTATUS NtStatus;

    PBROWSERASYNCCONTEXT Context = NULL;

    BOOL    IssueAsyncRequest = FALSE;

    // Check to see if it is OK to issue an async IO request. We do not want to
    // issue these request can be issued.

    EnterCriticalSection(&BrAsyncIOCriticalSection);

    if (!BrDgShutDownInitiated) {
        BrDgAsyncIOsOutstanding += 1;
        IssueAsyncRequest = TRUE;
    }

    LeaveCriticalSection(&BrAsyncIOCriticalSection);

    if (!IssueAsyncRequest) {
        return ERROR_REQ_NOT_ACCEP;
    }


    //
    // Allocate a buffer for the context and the request packet.
    //

    PacketSize = sizeof(LMDR_REQUEST_PACKET) +
                 MAXIMUM_FILENAME_LENGTH * sizeof(WCHAR);
    if ( ARGUMENT_PRESENT(Network) ) {
        PacketSize +=
        Network->NetworkName.MaximumLength +
        Network->DomainInfo->DomUnicodeDomainNameString.Length;
    }

    Context = MIDL_user_allocate(sizeof(BROWSERASYNCCONTEXT) + PacketSize );

    if (Context == NULL) {

        BrDecrementOutstandingIos();
        return(ERROR_NOT_ENOUGH_MEMORY);
    }

    RequestPacket = (PLMDR_REQUEST_PACKET)(Context + 1);

    RequestPacket->Version = LMDR_REQUEST_PACKET_VERSION_DOM;

    //
    //  Set level to FALSE to indicate that find master should not initiate
    //  a findmaster request, simply complete when a new master announces
    //  itself.
    //

    RequestPacket->Level = 0;

    //
    // Fill in the network specific information if it is specified.
    //
    if ( ARGUMENT_PRESENT(Network) ) {

        //
        //  Stick the name of the transport associated with this request at the
        //  end of the request packet.
        //

        RequestPacket->TransportName.MaximumLength = Network->NetworkName.MaximumLength;

        RequestPacket->TransportName.Buffer = (PWSTR)((PCHAR)RequestPacket+sizeof(LMDR_REQUEST_PACKET)+(MAXIMUM_FILENAME_LENGTH*sizeof(WCHAR)));

        RtlCopyUnicodeString(&RequestPacket->TransportName, &Network->NetworkName);

        //
        //  Stick the domain name associated with this request at the
        //  end of the request packet.
        //

        RequestPacket->EmulatedDomainName.MaximumLength = Network->DomainInfo->DomUnicodeDomainNameString.Length;
        RequestPacket->EmulatedDomainName.Length = 0;
        RequestPacket->EmulatedDomainName.Buffer = (PWSTR)(((PCHAR)RequestPacket->TransportName.Buffer) + RequestPacket->TransportName.MaximumLength);

        RtlAppendUnicodeToString(&RequestPacket->EmulatedDomainName, Network->DomainInfo->DomUnicodeDomainName );
    }


    //
    // Do opcode dependent initialization of the request packet.
    //

    switch ( ControlCode ) {
    case IOCTL_LMDR_NEW_MASTER_NAME:
        if (ARGUMENT_PRESENT(OptionalParameter)) {
            LPWSTR MasterName = (LPWSTR) OptionalParameter;

            RequestPacket->Parameters.GetMasterName.MasterNameLength =
            wcslen(MasterName+2)*sizeof(WCHAR);

            wcscpy( RequestPacket->Parameters.GetMasterName.Name, MasterName+2);

        } else {

            RequestPacket->Parameters.GetMasterName.MasterNameLength = 0;

        }
        break;
    }


    //
    // Send the request to the bowser.
    //

    BrInitializeWorkItem(&Context->WorkItem, CompletionRoutine, Context);

    Context->Network = Network;

    Context->RequestPacket = RequestPacket;

    NtStatus = NtDeviceIoControlFile(BrDgReceiverDeviceHandle,
                                     NULL,
                                     CompleteAsyncBrowserIoControl,
                                     Context,
                                     &Context->IoStatusBlock,
                                     ControlCode,
                                     RequestPacket,
                                     PacketSize,
                                     RequestPacket,
                                     sizeof(LMDR_REQUEST_PACKET)+MAXIMUM_FILENAME_LENGTH*sizeof(WCHAR)
                                    );

    if (NT_ERROR(NtStatus)) {

        BrPrint(( BR_CRITICAL,
                  "Unable to issue browser IoControl: %X\n", NtStatus));

        MIDL_user_free(Context);

        BrDecrementOutstandingIos();

        return(BrMapStatus(NtStatus));
    }

    return NERR_Success;

}

VOID
CompleteAsyncBrowserIoControl(
                             IN PVOID ApcContext,
                             IN PIO_STATUS_BLOCK IoStatusBlock,
                             IN ULONG Reserved
                             )
{

    PBROWSERASYNCCONTEXT Context = ApcContext;

    //
    //  If this request was canceled, we're stopping the browser, so we
    //  want to clean up our allocated pool.  In addition, don't bother
    //  calling into the routine - the threads are gone by now.
    //

    if (IoStatusBlock->Status == STATUS_CANCELLED) {

        MIDL_user_free(Context);

        // Signal the thread waiting on the completion in case of shut down
        // and reset the flag.

        BrDecrementOutstandingIos();

        return;

    }

    //
    //  Timestamp when this request was completed.  This allows us to tell
    //  where a request spent its time.
    //

    NtQueryPerformanceCounter(&Context->TimeCompleted, NULL);

    BrQueueWorkItem(&Context->WorkItem);

    // Signal the thread waiting on the completion in case of shut down
    // and reset the flag.

    BrDecrementOutstandingIos();
}

NET_API_STATUS
BrGetLocalBrowseList(
                    IN PNETWORK Network,
                    IN LPWSTR DomainName OPTIONAL,
                    IN ULONG Level,
                    IN ULONG ServerType,
                    OUT PVOID *ServerList,
                    OUT PULONG EntriesRead,
                    OUT PULONG TotalEntries
                    )
{
    NET_API_STATUS status;
    PLMDR_REQUEST_PACKET Drp;            // Datagram receiver request packet
    ULONG DrpSize;
    ULONG DomainNameSize;

    //
    // Allocate the request packet large enough to hold the variable length
    // domain name.
    //

    DomainNameSize = ARGUMENT_PRESENT(DomainName) ? (wcslen(DomainName) + 1) * sizeof(WCHAR) : 0;


    DrpSize = sizeof(LMDR_REQUEST_PACKET) +
              DomainNameSize +
              Network->NetworkName.MaximumLength +
              Network->DomainInfo->DomUnicodeDomainNameString.Length;

    if ((Drp = MIDL_user_allocate(DrpSize)) == NULL) {

        return GetLastError();
    }

    //
    // Set up request packet.  Output buffer structure is of enumerate
    // servers type.
    //

    Drp->Version = LMDR_REQUEST_PACKET_VERSION_DOM;
    Drp->Type = EnumerateServers;

    Drp->Level = Level;

    Drp->Parameters.EnumerateServers.ServerType = ServerType;
    Drp->Parameters.EnumerateServers.ResumeHandle = 0;

    //
    // Copy the transport name into the buffer.
    //
    Drp->TransportName.Buffer = (PWSTR)((PCHAR)Drp+
                                        sizeof(LMDR_REQUEST_PACKET) +
                                        DomainNameSize);

    Drp->TransportName.MaximumLength = Network->NetworkName.MaximumLength;

    RtlCopyUnicodeString(&Drp->TransportName, &Network->NetworkName);

    //
    // Copy the enumalated domain name into the buffer.
    //

    Drp->EmulatedDomainName.MaximumLength = Network->DomainInfo->DomUnicodeDomainNameString.Length;
    Drp->EmulatedDomainName.Length = 0;
    Drp->EmulatedDomainName.Buffer = (PWSTR)(((PCHAR)Drp->TransportName.Buffer) + Drp->TransportName.MaximumLength);

    RtlAppendUnicodeToString(&Drp->EmulatedDomainName, Network->DomainInfo->DomUnicodeDomainName );

    //
    // Copy the queried domain name into the buffer.
    //

    if (ARGUMENT_PRESENT(DomainName)) {

        Drp->Parameters.EnumerateServers.DomainNameLength = DomainNameSize - sizeof(WCHAR);
        wcscpy(Drp->Parameters.EnumerateServers.DomainName, DomainName);

    } else {
        Drp->Parameters.EnumerateServers.DomainNameLength = 0;
        Drp->Parameters.EnumerateServers.DomainName[0] = '\0';
    }

    //
    // Ask the datagram receiver to enumerate the servers
    //

    status = DeviceControlGetInfo(
                                 BrDgReceiverDeviceHandle,
                                 IOCTL_LMDR_ENUMERATE_SERVERS,
                                 Drp,
                                 DrpSize,
                                 ServerList,
                                 0xffffffff,
                                 4096,
                                 NULL
                                 );

    *EntriesRead = Drp->Parameters.EnumerateServers.EntriesRead;
    *TotalEntries = Drp->Parameters.EnumerateServers.TotalEntries;

    (void) MIDL_user_free(Drp);

    return status;

}

NET_API_STATUS
BrRemoveOtherDomain(
                   IN PNETWORK Network,
                   IN LPTSTR ServerName
                   )
{
    NET_API_STATUS Status;
    UCHAR PacketBuffer[sizeof(LMDR_REQUEST_PACKET)+(LM20_CNLEN+1)*sizeof(WCHAR)];
    PLMDR_REQUEST_PACKET RequestPacket = (PLMDR_REQUEST_PACKET)PacketBuffer;


    RequestPacket->Version = LMDR_REQUEST_PACKET_VERSION_DOM;

    RequestPacket->TransportName = Network->NetworkName;
    RequestPacket->EmulatedDomainName = Network->DomainInfo->DomUnicodeDomainNameString;

    RequestPacket->Parameters.AddDelName.DgReceiverNameLength = STRLEN(ServerName)*sizeof(TCHAR);

    RequestPacket->Parameters.AddDelName.Type = OtherDomain;

    STRCPY(RequestPacket->Parameters.AddDelName.Name,ServerName);

    //
    //  This is a simple IoControl - It just updates the status.
    //

    Status = BrDgReceiverIoControl(BrDgReceiverDeviceHandle,
                                   IOCTL_LMDR_DELETE_NAME_DOM,
                                   RequestPacket,
                                   sizeof(LMDR_REQUEST_PACKET),
                                   NULL,
                                   0,
                                   NULL);

    return Status;
}

NET_API_STATUS
BrAddName(
         IN PNETWORK Network,
         IN LPTSTR Name,
         IN DGRECEIVER_NAME_TYPE NameType
         )
/*++

Routine Description:

    Add a single name to a single transport.

Arguments:

    Network - Transport to add the name to

    Name - Name to add

    NameType - Type of the name to add

Return Value:

    None.

--*/
{
    NET_API_STATUS Status;
    UCHAR PacketBuffer[sizeof(LMDR_REQUEST_PACKET)+(LM20_CNLEN+1)*sizeof(WCHAR)];
    PLMDR_REQUEST_PACKET RequestPacket = (PLMDR_REQUEST_PACKET)PacketBuffer;


    RequestPacket->Version = LMDR_REQUEST_PACKET_VERSION_DOM;

    RequestPacket->TransportName = Network->NetworkName;
    RequestPacket->EmulatedDomainName = Network->DomainInfo->DomUnicodeDomainNameString;

    RequestPacket->Parameters.AddDelName.DgReceiverNameLength = STRLEN(Name)*sizeof(TCHAR);

    RequestPacket->Parameters.AddDelName.Type = NameType;

    STRCPY(RequestPacket->Parameters.AddDelName.Name,Name);

    //
    //  This is a simple IoControl - It just updates the status.
    //

    Status = BrDgReceiverIoControl(BrDgReceiverDeviceHandle,
                                   IOCTL_LMDR_ADD_NAME_DOM,
                                   RequestPacket,
                                   sizeof(LMDR_REQUEST_PACKET),
                                   NULL,
                                   0,
                                   NULL);

    return Status;
}


NET_API_STATUS
BrQueryOtherDomains(
                   OUT LPSERVER_INFO_100 *ReturnedBuffer,
                   OUT LPDWORD TotalEntries
                   )

/*++

Routine Description:

    This routine returns the list of "other domains" configured for this
    machine.

Arguments:

    ReturnedBuffer - Returns the list of other domains as a SERVER_INFO_100 structure.

    TotalEntries - Returns the total number of other domains.

Return Value:

    NET_API_STATUS - The status of this request.

--*/

{
    NET_API_STATUS Status;
    LMDR_REQUEST_PACKET RequestPacket;
    PDGRECEIVE_NAMES NameTable;
    PVOID Buffer;
    LPTSTR BufferEnd;
    PSERVER_INFO_100 ServerInfo;
    ULONG NumberOfOtherDomains;
    ULONG BufferSizeNeeded;
    ULONG i;

    RequestPacket.Type = EnumerateNames;
    RequestPacket.Version = LMDR_REQUEST_PACKET_VERSION_DOM;
    RequestPacket.Level = 0;
    RequestPacket.TransportName.Length = 0;
    RequestPacket.TransportName.Buffer = NULL;
    RtlInitUnicodeString( &RequestPacket.EmulatedDomainName, NULL );
    RequestPacket.Parameters.EnumerateNames.ResumeHandle = 0;

    Status = DeviceControlGetInfo(BrDgReceiverDeviceHandle,
                                  IOCTL_LMDR_ENUMERATE_NAMES,
                                  &RequestPacket,
                                  sizeof(RequestPacket),
                                  (LPVOID *)&NameTable,
                                  0xffffffff,
                                  0,
                                  NULL);
    if (Status != NERR_Success) {
        return Status;
    }

    NumberOfOtherDomains = 0;
    BufferSizeNeeded = 0;

    for (i = 0;i < RequestPacket.Parameters.EnumerateNames.EntriesRead ; i++) {
        if (NameTable[i].Type == OtherDomain) {
            NumberOfOtherDomains += 1;
            BufferSizeNeeded += sizeof(SERVER_INFO_100)+NameTable[i].DGReceiverName.Length+sizeof(TCHAR);
        }
    }

    *TotalEntries = NumberOfOtherDomains;

    Buffer = MIDL_user_allocate(BufferSizeNeeded);

    if (Buffer == NULL) {
        MIDL_user_free(NameTable);
        return(ERROR_NOT_ENOUGH_MEMORY);
    }

    ServerInfo = Buffer;
    BufferEnd = (LPTSTR)((PCHAR)Buffer+BufferSizeNeeded);

    for (i = 0;i < RequestPacket.Parameters.EnumerateNames.EntriesRead ; i++) {

        // Copy only OtherDomain names.
        // Protect from empty entries (in case transport name is empty).
        if (NameTable[i].Type == OtherDomain &&
            NameTable[i].DGReceiverName.Length != 0) {
            WCHAR NameBuffer[DNLEN+1];

            //
            //  The name from the browser is not null terminated, so copy it
            //  to a local buffer and null terminate it.
            //

            RtlCopyMemory(NameBuffer, NameTable[i].DGReceiverName.Buffer, NameTable[i].DGReceiverName.Length);

            NameBuffer[(NameTable[i].DGReceiverName.Length) / sizeof(TCHAR)] = UNICODE_NULL;

            ServerInfo->sv100_platform_id = PLATFORM_ID_OS2;

            ServerInfo->sv100_name = NameBuffer;

            if (!NetpPackString(&ServerInfo->sv100_name,
                                (LPBYTE)(ServerInfo+1),
                                &BufferEnd)) {
                MIDL_user_free(NameTable);
                return(NERR_InternalError);
            }
            ServerInfo += 1;
        }
    }

    MIDL_user_free(NameTable);

    *ReturnedBuffer = (LPSERVER_INFO_100) Buffer;

    Status = NERR_Success;

    return Status;

}

NET_API_STATUS
BrAddOtherDomain(
                IN PNETWORK Network,
                IN LPTSTR ServerName
                )
{
    return BrAddName( Network, ServerName, OtherDomain );
}

NET_API_STATUS
BrBindToTransport(
                 IN LPWSTR TransportName,
                 IN LPWSTR EmulatedDomainName,
                 IN LPWSTR EmulatedComputerName
                 )
{
    NET_API_STATUS Status;
    UCHAR PacketBuffer[sizeof(LMDR_REQUEST_PACKET)+(MAXIMUM_FILENAME_LENGTH+1+CNLEN+1)*sizeof(WCHAR)];
    PLMDR_REQUEST_PACKET RequestPacket = (PLMDR_REQUEST_PACKET)PacketBuffer;


    RequestPacket->Version = LMDR_REQUEST_PACKET_VERSION_DOM;
    RequestPacket->Level = TRUE;    // EmulatedComputerName follows transport name

    RequestPacket->TransportName.Length = 0;
    RequestPacket->TransportName.MaximumLength = 0;
    RtlInitUnicodeString( &RequestPacket->EmulatedDomainName, EmulatedDomainName );

    RequestPacket->Parameters.Bind.TransportNameLength = STRLEN(TransportName)*sizeof(TCHAR);

    STRCPY(RequestPacket->Parameters.Bind.TransportName, TransportName);
    STRCAT(RequestPacket->Parameters.Bind.TransportName, EmulatedComputerName );

    BrPrint(( BR_NETWORK,
              "%ws: %ws: bind from transport sent to bowser driver\n",
              EmulatedDomainName,
              TransportName));

    //
    //  This is a simple IoControl - It just updates the status.
    //

    Status = BrDgReceiverIoControl(BrDgReceiverDeviceHandle,
                                   IOCTL_LMDR_BIND_TO_TRANSPORT_DOM,
                                   RequestPacket,
                                   FIELD_OFFSET(LMDR_REQUEST_PACKET, Parameters.Bind.TransportName) +
                                   RequestPacket->Parameters.Bind.TransportNameLength +
                                   wcslen(EmulatedComputerName) * sizeof(WCHAR) + sizeof(WCHAR),
                                   NULL,
                                   0,
                                   NULL);

    return Status;
}

NET_API_STATUS
BrUnbindFromTransport(
                     IN LPWSTR TransportName,
                     IN LPWSTR EmulatedDomainName
                     )
{
    NET_API_STATUS Status;
    UCHAR PacketBuffer[sizeof(LMDR_REQUEST_PACKET)+(MAXIMUM_FILENAME_LENGTH+1)*sizeof(WCHAR)];
    PLMDR_REQUEST_PACKET RequestPacket = (PLMDR_REQUEST_PACKET)PacketBuffer;


    RequestPacket->Version = LMDR_REQUEST_PACKET_VERSION_DOM;

    RequestPacket->TransportName.Length = 0;
    RequestPacket->TransportName.MaximumLength = 0;
    RtlInitUnicodeString( &RequestPacket->EmulatedDomainName, EmulatedDomainName );

    RequestPacket->Parameters.Unbind.TransportNameLength = STRLEN(TransportName)*sizeof(TCHAR);

    STRCPY(RequestPacket->Parameters.Unbind.TransportName, TransportName);

    BrPrint(( BR_NETWORK,
              "%ws: %ws: unbind from transport sent to bowser driver\n",
              EmulatedDomainName,
              TransportName));

    //
    //  This is a simple IoControl - It just updates the status.
    //

    Status = BrDgReceiverIoControl(BrDgReceiverDeviceHandle,
                                   IOCTL_LMDR_UNBIND_FROM_TRANSPORT_DOM,
                                   RequestPacket,
                                   FIELD_OFFSET(LMDR_REQUEST_PACKET, Parameters.Bind.TransportName) +
                                   RequestPacket->Parameters.Bind.TransportNameLength,
                                   NULL,
                                   0,
                                   NULL);

    if (Status != NERR_Success) {

        BrPrint(( BR_CRITICAL,
                  "%ws: %ws: unbind from transport failed %ld\n",
                  EmulatedDomainName,
                  TransportName,
                  Status ));
    }
    return Status;
}

NET_API_STATUS
BrEnablePnp(
           BOOL Enable
           )
/*++

Routine Description:

    This routine enables or disables PNP messages from the bowser.

Arguments:

    Enable - TRUE if messages are to be enabled.

Return Value:

    None.

--*/
{
    NET_API_STATUS Status;
    UCHAR PacketBuffer[sizeof(LMDR_REQUEST_PACKET)];
    PLMDR_REQUEST_PACKET RequestPacket = (PLMDR_REQUEST_PACKET)PacketBuffer;


    RequestPacket->Version = LMDR_REQUEST_PACKET_VERSION_DOM;

    RtlInitUnicodeString( &RequestPacket->EmulatedDomainName, NULL );
    RtlInitUnicodeString( &RequestPacket->TransportName, NULL );

    RequestPacket->Parameters.NetlogonMailslotEnable.MaxMessageCount = Enable;

    //
    //  This is a simple IoControl - It just updates the status.
    //

    Status = BrDgReceiverIoControl(
                                  BrDgReceiverDeviceHandle,
                                  IOCTL_LMDR_BROWSER_PNP_ENABLE,
                                  RequestPacket,
                                  sizeof(LMDR_REQUEST_PACKET),
                                  NULL,
                                  0,
                                  NULL);

    if (Status != NERR_Success) {
        BrPrint(( BR_CRITICAL, "Enable PNP failed: %ld %ld\n", Enable, Status));
    }
    return Status;
}

VOID
HandlePnpMessage (
                 IN PVOID Ctx
                 )
/*++

Routine Description:

    This function handles a PNP message from the bowser driver.

Arguments:

    Ctx - Context block for request.

Return Value:

    None.

--*/


{
    NET_API_STATUS NetStatus;
    PBROWSERASYNCCONTEXT Context = Ctx;

    PNETLOGON_MAILSLOT NetlogonMailslot =
    (PNETLOGON_MAILSLOT) Context->RequestPacket;

    LPWSTR Transport;
    UNICODE_STRING TransportName;

    LPWSTR HostedDomain;
    UNICODE_STRING HostedDomainName;

    NETLOGON_PNP_OPCODE PnpOpcode;
    ULONG TransportFlags;

    PLIST_ENTRY DomainEntry;
    PDOMAIN_INFO DomainInfo;
    PNETWORK Network;


    try {

        //
        //  The request failed for some reason - just return immediately.
        //

        if (!NT_SUCCESS(Context->IoStatusBlock.Status)) {
            //
            // Sleep for a second to avoid consuming entire system.
            Sleep( 1000 );
            try_return(NOTHING);
        }

        //
        // If the message isn't a PNP message,
        //  someone is really confused.
        //

        if ( NetlogonMailslot->MailslotNameSize != 0 ) {
            BrPrint(( BR_CRITICAL,
                      "Got malformed PNP message\n" ));
            //
            // Sleep for a second to avoid consuming entire system.
            Sleep( 1000 );
            try_return(NOTHING);
        }


        //
        // Parse the message
        //

        PnpOpcode = NetlogonMailslot->MailslotNameOffset;
        TransportFlags = NetlogonMailslot->MailslotMessageOffset;

        if( NetlogonMailslot->TransportNameSize > 0 )
        {
            Transport = (LPWSTR) &(((LPBYTE)NetlogonMailslot)[
                                                             NetlogonMailslot->TransportNameOffset]);
            RtlInitUnicodeString( &TransportName, Transport );
        }
        else
        {
            RtlInitUnicodeString( &TransportName, NULL );
        }

        if( NetlogonMailslot->DestinationNameSize > 0 )
        {
            HostedDomain = (LPWSTR) &(((LPBYTE)NetlogonMailslot)[
                                                                NetlogonMailslot->DestinationNameOffset]);
            RtlInitUnicodeString( &HostedDomainName, HostedDomain );
        }
        else
        {
            RtlInitUnicodeString( &HostedDomainName, NULL );
        }

        //
        // Handle binding to a new network.
        //
        switch (PnpOpcode ) {
        case NlPnpTransportBind:
            BrPrint(( BR_NETWORK,
                      "Received bind PNP opcode 0x%lx on transport: %ws\n",
                      TransportFlags,
                      Transport ));

            //
            // Ignore the direct host IPX transport.
            //  The browser service created it so we don't need PNP notification.
            //

            if ( TransportFlags & LMDR_TRANSPORT_IPX ) {
                BrPrint(( BR_NETWORK,
                          "Ignoring PNP bind of direct host IPX transport\n" ));
                break;
            }

            NetStatus = BrChangeConfigValue(
                                           L"DirectHostBinding",
                                           MultiSzType,
                                           NULL,
                                           &(BrInfo.DirectHostBinding),
                                           TRUE );

            if ( NetStatus != NERR_Success ) {
                BrPrint(( BR_CRITICAL,
                          "Unbind failed to read Registry DirectHostBinding: %ws %ld\n",
                          Transport,
                          NetStatus ));
                //
                // Don't abort binding on failure to read DirectHostBinding, Our internal binding
                // info hasn't change so we'll use whatever we have.
                // Ignore error.
                //

                NetStatus = NERR_Success;
            } else {
                //
                // DirectHostBinding sepcified. Verify consistency & fail on
                // inconsistent setup (since it was setup, there was an intention resulted w/
                // a failure here).
                //

                EnterCriticalSection ( &BrInfo.ConfigCritSect );
                if (BrInfo.DirectHostBinding != NULL &&
                    !NetpIsTStrArrayEmpty(BrInfo.DirectHostBinding)) {
                    BrPrint(( BR_INIT,"DirectHostBinding length: %ld\n",NetpTStrArrayEntryCount(BrInfo.DirectHostBinding)));

                    if (NetpTStrArrayEntryCount(BrInfo.DirectHostBinding) % 2 != 0) {
                        NetApiBufferFree(BrInfo.DirectHostBinding);
                        BrInfo.DirectHostBinding = NULL;
                        // we fail on invalid specifications
                        NetStatus = ERROR_INVALID_PARAMETER;
                    }
                }
                LeaveCriticalSection ( &BrInfo.ConfigCritSect );
            }

            //
            // Loop creating the network for each emulated domain.
            //

            EnterCriticalSection(&NetworkCritSect);
            for (DomainEntry = ServicedDomains.Flink ;
                DomainEntry != &ServicedDomains;
                DomainEntry = DomainEntry->Flink ) {

                DomainInfo = CONTAINING_RECORD(DomainEntry, DOMAIN_INFO, Next);
                DomainInfo->PnpDone = FALSE;
            }

            for (DomainEntry = ServicedDomains.Flink ;
                DomainEntry != &ServicedDomains;
                ) {

                DomainInfo = CONTAINING_RECORD(DomainEntry, DOMAIN_INFO, Next);

                //
                // If this domain has already been processed,
                //  skip it.
                //

                if ( DomainInfo->PnpDone ) {
                    DomainEntry = DomainEntry->Flink;
                    continue;
                }
                DomainInfo->PnpDone = TRUE;


                //
                // Drop the crit sect while doing the lenghty PNP operation.
                //

                DomainInfo->ReferenceCount++;
                LeaveCriticalSection(&NetworkCritSect);

                //
                // Finally create the transport.
                //

                NetStatus = BrCreateNetwork(
                                           &TransportName,
                                           TransportFlags,
                                           NULL,
                                           DomainInfo );

                if ( NetStatus != NERR_Success ) {
                    BrPrint(( BR_CRITICAL,
                              "%ws: Bind failed on transport: %ws %ld\n",
                              DomainInfo->DomUnicodeDomainName,
                              Transport,
                              NetStatus ));
                    // ?? Anything else to do on failure
                }

                //
                // Finish process the emulated domains
                //  Start at the front of the list since we dropped the lock.
                //
                BrDereferenceDomain(DomainInfo);
                EnterCriticalSection(&NetworkCritSect);
                DomainEntry = ServicedDomains.Flink;
            }
            LeaveCriticalSection(&NetworkCritSect);

            break;


            //
            // Handle Unbinding from a network.
            //
        case NlPnpTransportUnbind:
            BrPrint(( BR_NETWORK,
                      "Received unbind PNP opcode 0x%lx on transport: %ws\n",
                      TransportFlags,
                      Transport ));

            //
            // Ignore the direct host IPX transport.
            //  The browser service created it so we don't need PNP notification.
            //

            if ( TransportFlags & LMDR_TRANSPORT_IPX ) {
                BrPrint(( BR_NETWORK,
                          "Ignoring PNP unbind of direct host IPX transport\n" ));
                break;
            }

            //
            // Loop deleting the network for each emulated domain.
            //

            EnterCriticalSection(&NetworkCritSect);
            for (DomainEntry = ServicedDomains.Flink ;
                DomainEntry != &ServicedDomains;
                DomainEntry = DomainEntry->Flink ) {

                DomainInfo = CONTAINING_RECORD(DomainEntry, DOMAIN_INFO, Next);
                DomainInfo->PnpDone = FALSE;
            }

            for (DomainEntry = ServicedDomains.Flink ;
                DomainEntry != &ServicedDomains;
                ) {

                DomainInfo = CONTAINING_RECORD(DomainEntry, DOMAIN_INFO, Next);

                //
                // If this domain has already been processed,
                //  skip it.
                //

                if ( DomainInfo->PnpDone ) {
                    DomainEntry = DomainEntry->Flink;
                    continue;
                }
                DomainInfo->PnpDone = TRUE;


                //
                // Drop the crit sect while doing the lenghty PNP operation.
                //

                DomainInfo->ReferenceCount++;
                LeaveCriticalSection(&NetworkCritSect);

                //
                // Finally delete the transport.
                //

                Network = BrFindNetwork( DomainInfo, &TransportName );

                if ( Network == NULL ) {
                    BrPrint(( BR_CRITICAL,
                              "%ws: Unbind cannot find transport: %ws\n",
                              DomainInfo->DomUnicodeDomainName,
                              Transport ));
                } else {
                    //
                    // If the network has an alternate network,
                    //  delete it first.
                    //

                    if ( Network->AlternateNetwork != NULL ) {
                        PNETWORK AlternateNetwork;


                        AlternateNetwork = BrReferenceNetwork( Network->AlternateNetwork );

                        if ( AlternateNetwork != NULL) {
                            BrPrint(( BR_NETWORK,
                                      "%ws: %ws: Unbind from alternate transport: %ws\n",
                                      DomainInfo->DomUnicodeDomainName,
                                      Transport,
                                      AlternateNetwork->NetworkName.Buffer ));

                            NetStatus = BrDeleteNetwork(
                                                       AlternateNetwork,
                                                       NULL );

                            if ( NetStatus != NERR_Success ) {
                                BrPrint(( BR_CRITICAL,
                                          "%ws: Unbind failed on transport: %ws %ld\n",
                                          DomainInfo->DomUnicodeDomainName,
                                          AlternateNetwork->NetworkName.Buffer,
                                          NetStatus ));
                                // ?? Anything else to do on failure
                            }

                            BrDereferenceNetwork( AlternateNetwork );
                        }

                    }

                    //
                    // Delete the network.
                    //
                    NetStatus = BrDeleteNetwork(
                                               Network,
                                               NULL );

                    if ( NetStatus != NERR_Success ) {
                        BrPrint(( BR_CRITICAL,
                                  "%ws: Unbind failed on transport: %ws %ld\n",
                                  DomainInfo->DomUnicodeDomainName,
                                  Transport,
                                  NetStatus ));
                        // ?? Anything else to do on failure
                    }

                    BrDereferenceNetwork( Network );
                }


                //
                // Finish process the emulated domains
                //  Start at the front of the list since we dropped the lock.
                //
                BrDereferenceDomain(DomainInfo);
                EnterCriticalSection(&NetworkCritSect);
                DomainEntry = ServicedDomains.Flink;
            }
            LeaveCriticalSection(&NetworkCritSect);
            break;

            //
            // Handle domain rename
            //
        case NlPnpDomainRename:
            BrPrint(( BR_NETWORK,
                      "Received Domain Rename PNP for domain: %ws\n", HostedDomain ));

            //
            // See if we're handling the specified domain.
            //

            DomainInfo = BrFindDomain( HostedDomain, FALSE );

            if ( DomainInfo == NULL ) {
                BrPrint(( BR_CRITICAL, "%ws: Renamed domain doesn't exist\n",
                          HostedDomain ));
            } else {

                //
                // If so,
                //  rename it.
                //
                BrRenameDomain( DomainInfo );
                BrDereferenceDomain( DomainInfo );
            }

            break;

            //
            // Handle PDC/BDC role change.
            //
        case NlPnpNewRole:
            BrPrint(( BR_NETWORK,
                      "%ws: Received role change PNP opcode 0x%lx on transport: %ws\n",
                      HostedDomain,
                      TransportFlags,
                      Transport ));

            //
            // Role can only change on lanman NT systems
            //
            if (!BrInfo.IsLanmanNt) {
                break;
            }

            //
            // See if we're handling the specified domain.
            //

            DomainInfo = BrFindDomain( HostedDomain, FALSE );

            if ( DomainInfo == NULL ) {
                BrPrint(( BR_CRITICAL, "%ws: Hosted domain doesn't exist\n",
                          HostedDomain ));
            } else {

                //
                // Find the specified network
                //

                Network = BrFindNetwork( DomainInfo, &TransportName );

                if ( Network == NULL ) {
                    BrPrint(( BR_CRITICAL,
                              "%ws: Unbind cannot find transport: %ws\n",
                              DomainInfo->DomUnicodeDomainName,
                              Transport ));
                } else {

                    if (LOCK_NETWORK(Network)) {

                        //
                        // Set the role to be PDC.
                        //
                        if ( TransportFlags & LMDR_TRANSPORT_PDC ) {

                            //
                            // If we think we're a BDC.  Update our information.
                            //
                            if ( (Network->Flags & NETWORK_PDC) == 0 ) {
                                Network->Flags |= NETWORK_PDC;

                                //
                                //  Make sure a GetMasterAnnouncement request is pending.
                                //

                                (VOID) PostGetMasterAnnouncement ( Network );

                                // Force an election to let the PDC win
                                (VOID) BrElectMasterOnNet( Network, (PVOID)EVENT_BROWSER_ELECTION_SENT_ROLE_CHANGED );
                            }


                            //
                            // Set the role to BDC.
                            //

                        } else {

                            //
                            // We think we're the PDC.  Update our information.
                            //

                            if ( Network->Flags & NETWORK_PDC ) {
                                Network->Flags &= ~NETWORK_PDC;

                                // Force an election to let the PDC win
                                (VOID) BrElectMasterOnNet( Network, (PVOID)EVENT_BROWSER_ELECTION_SENT_ROLE_CHANGED );
                            }
                        }

                        UNLOCK_NETWORK(Network);
                    }

                    BrDereferenceNetwork( Network );
                }

                BrDereferenceDomain( DomainInfo );
            }
            break;

            //
            // Ignore new Ip Addresses
            //
        case NlPnpNewIpAddress:
            BrPrint(( BR_NETWORK,
                      "Received IP address change PNP opcode 0x%lx on transport: %ws\n",
                      TransportFlags,
                      Transport ));
            break;

        default:
            BrPrint(( BR_CRITICAL,
                      "Received invalid PNP opcode 0x%x on transport: %ws\n",
                      PnpOpcode,
                      Transport ));
            break;
        }


        try_exit:NOTHING;
    } finally {

        MIDL_user_free(Context);

        //
        // Always finish by asking for another PNP message.
        //
        // For PNP, it is fine to only process a single PNP message at a time.
        // If this message mechanism starts being used for other purposes,
        //  we may want to immediately ask for another message upon receipt
        //  of this one.
        //

        while ((NetStatus = PostWaitForPnp()) != NERR_Success ) {
            BrPrint(( BR_CRITICAL,
                      "Unable to re-issue PostWaitForPnp request (waiting): %ld\n",
                      NetStatus));

            //
            // On error, wait a second before returning.  This ensures we don't
            //  consume the system in an infinite loop.  We don't shutdown
            //  because the error might be a temporary low memory condition.
            //

            NetStatus = WaitForSingleObject( BrGlobalData.TerminateNowEvent, 1000 );
            if ( NetStatus != WAIT_TIMEOUT ) {
                BrPrint(( BR_CRITICAL,
                          "Not re-issuing PostWaitForPnp request since we're terminating: %ld\n",
                          NetStatus));
                break;
            }
        }

    }

    return;

}

NET_API_STATUS
PostWaitForPnp (
               VOID
               )
/*++

Routine Description:

    This function issues and async call to the bowser driver asking
    it to inform us of PNP events.

Arguments:

    None.

Return Value:

    Status - The status of the operation.

--*/
{
    return BrIssueAsyncBrowserIoControl(
                                       NULL,
                                       IOCTL_LMDR_BROWSER_PNP_READ,
                                       HandlePnpMessage,
                                       NULL );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\browser\server\brdevice.h ===
/*++

Copyright (c) 1991 Microsoft Corporation

Module Name:

    brdevice.h

Abstract:

    Private header file to be included by Workstation service modules that
    need to call into the NT Redirector and the NT Datagram Receiver.

Author:

    Rita Wong (ritaw) 15-Feb-1991

Revision History:

--*/

#ifndef _BRDEVICE_INCLUDED_
#define _BRDEVICE_INCLUDED_

#include <ntddbrow.h>                 // Datagram receiver include file

//-------------------------------------------------------------------//
//                                                                   //
// Type definitions                                                  //
//                                                                   //
//-------------------------------------------------------------------//

typedef enum _DDTYPE {
    DatagramReceiver
} DDTYPE, *PDDTYPE;

typedef struct _BROWSERASYNCCONTEXT {
    WORKER_ITEM WorkItem;

    PNETWORK Network;

    IO_STATUS_BLOCK IoStatusBlock;

    PLMDR_REQUEST_PACKET RequestPacket;

    //
    //  Timestamp when request was completed.
    //

    LARGE_INTEGER TimeCompleted;

} BROWSERASYNCCONTEXT, *PBROWSERASYNCCONTEXT;

//-------------------------------------------------------------------//
//                                                                   //
// Function prototypes of support routines found in wsdevice.c       //
//                                                                   //
//-------------------------------------------------------------------//

NET_API_STATUS
BrOpenDgReceiver (
    VOID
    );

NET_API_STATUS
BrAnnounceDomain(
    IN PNETWORK Network,
    IN ULONG Periodicty
    );

NET_API_STATUS
BrGetTransportList(
    OUT PLMDR_TRANSPORT_LIST *TransportList
    );

NET_API_STATUS
BrIssueAsyncBrowserIoControl(
    IN PNETWORK Network,
    IN ULONG ControlCode,
    IN PBROWSER_WORKER_ROUTINE CompletionRoutine,
    IN PVOID OptionalParamter
    );

NET_API_STATUS
BrGetLocalBrowseList(
    IN PNETWORK Network,
    IN LPWSTR DomainName,
    IN ULONG Level,
    IN ULONG ServerType,
    OUT PVOID *ServerList,
    OUT PULONG EntriesRead,
    OUT PULONG TotalEntries
    );

NET_API_STATUS
BrUpdateBrowserStatus (
    IN PNETWORK Network,
    IN DWORD ServiceStatus
    );

VOID
BrShutdownDgReceiver(
    VOID
    );

NET_API_STATUS
BrRemoveOtherDomain(
    IN PNETWORK Network,
    IN LPTSTR ServerName
    );

NET_API_STATUS
BrQueryOtherDomains(
    OUT LPSERVER_INFO_100 *ReturnedBuffer,
    OUT LPDWORD TotalEntries
    );

NET_API_STATUS
BrAddOtherDomain(
    IN PNETWORK Network,
    IN LPTSTR ServerName
    );

NET_API_STATUS
BrBindToTransport(
    IN LPWSTR TransportName,
    IN LPWSTR EmulatedDomainName,
    IN LPWSTR EmulatedComputerName
    );

NET_API_STATUS
BrUnbindFromTransport(
    IN LPWSTR TransportName,
    IN LPWSTR EmulatedDomainName
    );

NET_API_STATUS
BrEnablePnp(
    BOOL Enable
    );

NET_API_STATUS
PostWaitForPnp (
    VOID
    );

//-------------------------------------------------------------------//
//                                                                   //
// Global variables                                                  //
//                                                                   //
//-------------------------------------------------------------------//

//
// Handle to the Datagram Receiver DD
//
extern HANDLE BrDgReceiverDeviceHandle;

#endif   // ifndef _BRDEVICE_INCLUDED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\browser\server\brconfig.h ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    brconfig.h

Abstract:

    Private header file to be included by Workstation service modules that
    need to load Workstation configuration information.

Author:

    Rita Wong (ritaw) 22-May-1991

Revision History:

--*/


#ifndef _BRCONFIG_INCLUDED_
#define _BRCONFIG_INCLUDED_

#define BROWSER_CONFIG_VERSION_MAJOR    3
#define BROWSER_CONFIG_VERSION_MINOR    10

typedef enum _DATATYPE {
    BooleanType,
    DWordType,
    MultiSzType,
    TriValueType        // Yes, No, Auto
} DATATYPE, *PDATATYPE;

typedef struct _BR_BROWSER_FIELDS {
    LPTSTR Keyword;
    LPDWORD FieldPtr;
    DWORD Default;
    DWORD Minimum;
    DWORD Maximum;
    DATATYPE DataType;
    DWORD Parmnum;
    VOID (*DynamicChangeRoutine) ( VOID );
} BR_BROWSER_FIELDS, *PBR_BROWSER_FIELDS;

//
// Configuration information.  Reading and writing to this global
// structure requires that the resource be acquired first.
//

typedef struct _BRCONFIGURATION_INFO {

    CRITICAL_SECTION ConfigCritSect;  // To serialize access to config fields.

    DWORD MaintainServerList;       // -1, 0, or 1 (No, Auto, Yes)
    DWORD BackupBrowserRecoveryTime;
    DWORD CacheHitLimit;            // Browse response Cache hit limit.
    DWORD NumberOfCachedResponses;  // Browse response cache size.
    DWORD DriverQueryFrequency;     // Browser driver query frequency.
    DWORD MasterPeriodicity;        // Master announce frequency (seconds)
    DWORD BackupPeriodicity;        // Backup scavange frequency (seconds)
    BOOL  IsLanmanNt;               // True if is on LM NT machine

#ifdef ENABLE_PSEUDO_BROWSER
    DWORD PseudoServerLevel;        // How much of a phase-out server it is.
#endif
    LPTSTR_ARRAY DirectHostBinding; // Direct host equivalence map.
    LPTSTR_ARRAY UnboundBindings;   // Redir bindings that aren't bound to browser
    PBR_BROWSER_FIELDS BrConfigFields;
#if DBG
    DWORD BrowserDebug;             // If non zero, indicates debug info.
    DWORD BrowserDebugFileLimit;    // File size limit on browser log size.
#endif
} BRCONFIGURATION_INFO, *PBRCONFIGURATION_INFO;

extern BRCONFIGURATION_INFO BrInfo;

#define BRBUF      BrInfo.BrConfigBuf

extern
ULONG
NumberOfServerEnumerations;

extern
ULONG
NumberOfDomainEnumerations;

extern
ULONG
NumberOfOtherEnumerations;

extern
ULONG
NumberOfMissedGetBrowserListRequests;

extern
CRITICAL_SECTION
BrowserStatisticsLock;



NET_API_STATUS
BrGetBrowserConfiguration(
    VOID
    );

VOID
BrDeleteConfiguration (
    DWORD BrInitState
    );

NET_API_STATUS
BrReadBrowserConfigFields(
    BOOL InitialCall
    );

NET_API_STATUS
BrChangeDirectHostBinding(
    VOID
    );

NET_API_STATUS
BrChangeConfigValue(
    LPWSTR      pszKeyword      IN,
    DATATYPE    dataType        IN,
    PVOID       pDefault        IN,
    PVOID       *ppData         OUT,
    BOOL        bFree           IN
    );



#if DEVL
NET_API_STATUS
BrUpdateDebugInformation(
    IN LPWSTR SystemKeyName,
    IN LPWSTR ValueName,
    IN LPTSTR TransportName,
    IN LPTSTR ServerName OPTIONAL,
    IN DWORD ServiceStatus
    );

#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\browser\server\brdomain.c ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    brdomain.c

Abstract:

    Code to manage primary and emulated networks.

Author:

    Cliff Van Dyke (CliffV) 11-Jan-1995

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop

//
// Module specific globals
//

// Serialized by NetworkCritSect
LIST_ENTRY ServicedDomains = {0};

//
// Local procedure forwards.
//

NET_API_STATUS
BrCreateDomain(
    LPWSTR DomainName,
    LPWSTR ComputerName,
    BOOLEAN IsEmulatedDomain
    );

VOID
BrCreateDomainWorker(
    IN PVOID Ctx
    );



NET_API_STATUS
BrInitializeDomains(
    VOID
    )

/*++

Routine Description:

    Initialize brdomain.c and create the primary domain.

Arguments:

    None

Return Value:

    Status of operation.

--*/
{
    NET_API_STATUS NetStatus;
    LPWSTR ComputerName = NULL;
    LPWSTR DomainName = NULL;

    //
    // Initialize globals
    //

    InitializeListHead(&ServicedDomains);

    //
    // Initialize actual domain of this machine.
    //
    // Get the configured computer name.  NetpGetComputerName allocates
    // the memory to hold the computername string using LocalAlloc.
    //

    NetStatus = NetpGetComputerName( &ComputerName );

    if ( NetStatus != NERR_Success ) {
        goto Cleanup;
    }

    NetStatus = NetpGetDomainName( &DomainName );

    if ( NetStatus != NERR_Success ) {
        goto Cleanup;
    }

    NetStatus = BrCreateDomain( DomainName,
                                ComputerName,
                                FALSE );

    if ( NetStatus != NERR_Success ) {
        goto Cleanup;
    }


    NetStatus = NERR_Success;

    //
    // Free locally used resources
    //
Cleanup:
    if ( ComputerName != NULL ) {
        (VOID)LocalFree( ComputerName );
    }
    if ( DomainName != NULL ) {
        (VOID)LocalFree( DomainName );
    }

    return NetStatus;
}


NET_API_STATUS
BrCreateDomain(
    LPWSTR DomainName,
    LPWSTR ComputerName,
    BOOLEAN IsEmulatedDomain
    )

/*++

Routine Description:

    Create a new domain to browse on.

Arguments:

    DomainName - Name of the domain to browse on

    ComputerName - Name of this computer in the specified domain.

    IsEmulatedDomain - TRUE iff this domain is an emulated domain of this machine.

Return Value:

    Status of operation.

--*/
{
    NTSTATUS Status;
    NET_API_STATUS NetStatus;

    BOOLEAN CanCallBrDeleteDomain = FALSE;

    PDOMAIN_INFO DomainInfo = NULL;
    ULONG AComputerNameLength;

    BrPrint(( BR_DOMAIN, "%ws: Added new domain and computer: %ws\n",
                     DomainName,
                     ComputerName ));

    //
    // Allocate a structure describing the new domain.
    //

    DomainInfo = LocalAlloc( LMEM_ZEROINIT, sizeof(DOMAIN_INFO) );

    if ( DomainInfo == NULL ) {
        NetStatus = GetLastError();
        goto Cleanup;
    }

    //
    // Create an interim reference count for this domain.
    //

    DomainInfo->ReferenceCount = 1;

    DomainInfo->IsEmulatedDomain = IsEmulatedDomain;



    //
    // Copy the computer name into the structure.
    //

    NetStatus = I_NetNameCanonicalize(
                      NULL,
                      ComputerName,
                      DomainInfo->DomUnicodeComputerName,
                      sizeof(DomainInfo->DomUnicodeComputerName),
                      NAMETYPE_COMPUTER,
                      0 );


    if ( NetStatus != NERR_Success ) {
        BrPrint(( BR_CRITICAL,
                  "ComputerName " FORMAT_LPWSTR " is invalid\n",
                  ComputerName ));
        goto Cleanup;
    }

    DomainInfo->DomUnicodeComputerNameLength = wcslen(DomainInfo->DomUnicodeComputerName);

    Status = RtlUpcaseUnicodeToOemN( DomainInfo->DomOemComputerName,
                                     sizeof(DomainInfo->DomOemComputerName),
                                     &DomainInfo->DomOemComputerNameLength,
                                     DomainInfo->DomUnicodeComputerName,
                                     DomainInfo->DomUnicodeComputerNameLength*sizeof(WCHAR));

    if (!NT_SUCCESS(Status)) {
        BrPrint(( BR_CRITICAL, "Unable to convert computer name to OEM %ws %lx\n", ComputerName, Status ));
        NetStatus = ERROR_NOT_ENOUGH_MEMORY;
        goto Cleanup;
    }

    DomainInfo->DomOemComputerName[DomainInfo->DomOemComputerNameLength] = '\0';


    //
    // Copy the domain name into the structure
    // Note: Use workgroup type rather then domain since
    // we have no notion of domain/workgroup in the browser (all are "groups")
    // an workgroup is less restrictive (see bug 348606)
    //

    NetStatus = I_NetNameCanonicalize(
                      NULL,
                      DomainName,
                      DomainInfo->DomUnicodeDomainName,
                      sizeof(DomainInfo->DomUnicodeDomainName),
                      NAMETYPE_WORKGROUP,
                      0 );


    if ( NetStatus != NERR_Success ) {
        BrPrint(( BR_CRITICAL, "%ws: DomainName is invalid\n", DomainName ));
        goto Cleanup;
    }

    RtlInitUnicodeString( &DomainInfo->DomUnicodeDomainNameString,
                          DomainInfo->DomUnicodeDomainName );

    Status = RtlUpcaseUnicodeToOemN( DomainInfo->DomOemDomainName,
                                     sizeof(DomainInfo->DomOemDomainName),
                                     &DomainInfo->DomOemDomainNameLength,
                                     DomainInfo->DomUnicodeDomainNameString.Buffer,
                                     DomainInfo->DomUnicodeDomainNameString.Length);

    if (!NT_SUCCESS(Status)) {
        BrPrint(( BR_CRITICAL, "%ws: Unable to convert Domain name to OEM\n", DomainName ));
        NetStatus = ERROR_NOT_ENOUGH_MEMORY;
        goto Cleanup;
    }

    DomainInfo->DomOemDomainName[DomainInfo->DomOemDomainNameLength] = '\0';

    //
    // Create the domain rename timer
    //

    NetStatus = BrCreateTimer( &DomainInfo->DomainRenameTimer );

    if ( NetStatus != NERR_Success ) {
        BrPrint(( BR_CRITICAL, "%ws: Cannot create domain rename timer %ld\n", DomainName, NetStatus ));
        goto Cleanup;
    }


    //
    // Link the domain into the list of domains
    //  (And mark that any future cleanup can be done by calling BrDeleteDomain)

    EnterCriticalSection(&NetworkCritSect);
    InsertTailList(&ServicedDomains, &DomainInfo->Next);
    LeaveCriticalSection(&NetworkCritSect);
    CanCallBrDeleteDomain = TRUE;

    //
    // Create the various networks for this domain.
    //

    NetStatus = BrCreateNetworks( DomainInfo );

    if ( NetStatus != NERR_Success ) {
        goto Cleanup;
    }


    //
    // Free Locally used resources
    //
Cleanup:

    if (NetStatus != NERR_Success) {

        if (DomainInfo != NULL) {

            //
            // If we've initialized to the point where we can call
            //  we can call BrDeleteDomain, do so.
            //

            if ( CanCallBrDeleteDomain ) {
                (VOID) BrDeleteDomain( DomainInfo );

            //
            // Otherwise, just delete what we've created.
            //
            } else {

                (VOID) LocalFree(DomainInfo);
            }

        }

    }

    return NetStatus;
}

typedef struct _BROWSER_CREATE_DOMAIN_CONTEXT {
    LPWSTR DomainName;
    LPWSTR ComputerName;
    BOOLEAN IsEmulatedDomain;
    HANDLE EventHandle;
    NET_API_STATUS NetStatus;
} BROWSER_CREATE_DOMAIN_CONTEXT, *PBROWSER_CREATE_DOMAIN_CONTEXT;

NET_API_STATUS
BrCreateDomainInWorker(
    LPWSTR DomainName,
    LPWSTR ComputerName,
    BOOLEAN IsEmulatedDomain
    )

/*++

Routine Description:

    Wrapper for BrCreateDomain.  Since BrCreateDomain starts several pending
    IO's to the browser driver, the thread that calls BrCreateDomain must
    remain around forever.  This wrapper can be called by any transient thread
    (e.g., an RPC thread).  It simply causes BrCreateDomain to be called in a
    worker thread.

Arguments:

    DomainName - Name of the domain to browse on

    ComputerName - Name of this computer in the specified domain.

    IsEmulatedDomain - TRUE iff this domain is an emulated domain of this machine.

Return Value:

    Status of operation.

--*/
{
    NET_API_STATUS NetStatus;
    DWORD WaitStatus;

    WORKER_ITEM WorkItem;
    BROWSER_CREATE_DOMAIN_CONTEXT Context;

    //
    // Copy our arguments into a context block for the worker thread
    //

    Context.DomainName = DomainName;
    Context.ComputerName = ComputerName;
    Context.IsEmulatedDomain = IsEmulatedDomain;

    //
    // Create an event which we use to wait on the worker thread.
    //

    Context.EventHandle = CreateEvent(
                 NULL,                // Event attributes
                 TRUE,                // Event must be manually reset
                 FALSE,               // Initial state not signalled
                 NULL );              // Event name

    if ( Context.EventHandle == NULL ) {
        NetStatus = GetLastError();
        return NetStatus;
    }

    //
    // Queue the request to the worker thread.
    //

    BrInitializeWorkItem( &WorkItem,
                          BrCreateDomainWorker,
                          &Context );

    BrQueueWorkItem( &WorkItem );

    //
    // Wait for the worker thread to finish
    //

    WaitStatus = WaitForSingleObject( Context.EventHandle, INFINITE );

    if ( WaitStatus == WAIT_OBJECT_0 ) {
        NetStatus = Context.NetStatus;
    } else {
        NetStatus = GetLastError();
    }

    CloseHandle( Context.EventHandle );

    return NetStatus;
}

VOID
BrCreateDomainWorker(
    IN PVOID Ctx
    )
/*++

Routine Description:

    Worker routine for BrCreateDomainInWorker.

    This routine executes in the context of a worker thread.

Arguments:

    Context - Context containing the workitem and the description of the
        domain to create.

Return Value:

    None

--*/
{
    PBROWSER_CREATE_DOMAIN_CONTEXT Context = (PBROWSER_CREATE_DOMAIN_CONTEXT) Ctx;

    //
    // Create the domain.
    //

    Context->NetStatus = BrCreateDomain(
             Context->DomainName,
             Context->ComputerName,
             Context->IsEmulatedDomain );

    //
    // Let the caller know we're done.
    //
    SetEvent( Context->EventHandle );

}

PDOMAIN_INFO
BrFindDomain(
    LPWSTR DomainName,
    BOOLEAN DefaultToPrimary
    )
/*++

Routine Description:

    This routine will look up a domain given a name.

Arguments:

    DomainName - The name of the domain to look up.

    DefaultToPrimary - Return the primary domain if DomainName is NULL or
        can't be found.

Return Value:

    NULL - No such domain exists

    A pointer to the domain found.  The found domain should be dereferenced
    using BrDereferenceDomain.

--*/
{
    NTSTATUS Status;
    PLIST_ENTRY DomainEntry;

    PDOMAIN_INFO DomainInfo = NULL;

    CHAR OemDomainName[DNLEN+1];
    DWORD OemDomainNameLength;

    EnterCriticalSection(&NetworkCritSect);


    //
    // If domain was specified,
    //  try to return primary domain.
    //

    if ( DomainName != NULL ) {



        //
        // Convert the domain name to OEM for faster comparison
        //
        Status = RtlUpcaseUnicodeToOemN( OemDomainName,
                                         sizeof(OemDomainName),
                                         &OemDomainNameLength,
                                         DomainName,
                                         wcslen(DomainName)*sizeof(WCHAR));

        if (!NT_SUCCESS(Status)) {
            BrPrint(( BR_CRITICAL, "%ws: Unable to convert Domain name to OEM\n", DomainName ));
            DomainInfo = NULL;
            goto Cleanup;
        }


        //
        // Loop trying to find this domain name.
        //

        for (DomainEntry = ServicedDomains.Flink ;
             DomainEntry != &ServicedDomains;
             DomainEntry = DomainEntry->Flink ) {

            DomainInfo = CONTAINING_RECORD(DomainEntry, DOMAIN_INFO, Next);

            if ( DomainInfo->DomOemDomainNameLength == OemDomainNameLength &&
                 RtlCompareMemory( DomainInfo->DomOemDomainName,
                                   OemDomainName,
                                   OemDomainNameLength ) == OemDomainNameLength ) {
                break;
            }

            DomainInfo = NULL;

        }
    }

    //
    // If we're to default to the primary domain,
    //  do so.
    //

    if ( DefaultToPrimary && DomainInfo == NULL ) {
        if ( !IsListEmpty( &ServicedDomains ) ) {
            DomainInfo = CONTAINING_RECORD(ServicedDomains.Flink, DOMAIN_INFO, Next);
        }
    }

    //
    // Reference the domain.
    //

    if ( DomainInfo != NULL ) {
        DomainInfo->ReferenceCount ++;
    }

Cleanup:
    LeaveCriticalSection(&NetworkCritSect);

    return DomainInfo;
}


PDOMAIN_INFO
BrReferenceDomain(
    PDOMAIN_INFO PotentialDomainInfo
    )
/*++

Routine Description:

    This routine will look up a domain given a potential pointer to the domain

    This routine is useful if a caller has a pointer to a domain but
    hasn't incremented the reference count.  For instance,
    a timer completion routine has such a pointer.

Arguments:

    PotentialDomainInfo - Pointer to the DomainInfo to be verified.

Return Value:

    NULL - No such domain exists

    A pointer to the domain found.  The found domain should be dereferenced
    using BrDereferenceDomain.

--*/
{
    NTSTATUS Status;
    PLIST_ENTRY ListEntry;

    EnterCriticalSection(&NetworkCritSect);

    for (ListEntry = ServicedDomains.Flink ;
         ListEntry != &ServicedDomains;
         ListEntry = ListEntry->Flink ) {
        PDOMAIN_INFO DomainInfo = CONTAINING_RECORD(ListEntry, DOMAIN_INFO, Next);

        if ( PotentialDomainInfo == DomainInfo ) {

            DomainInfo->ReferenceCount ++;
            BrPrint(( BR_LOCKS,
                      "%ws: reference domain: %ld\n",
                      DomainInfo->DomUnicodeDomainName,
                      DomainInfo->ReferenceCount ));
            LeaveCriticalSection(&NetworkCritSect);

            return DomainInfo;
        }

    }

    LeaveCriticalSection(&NetworkCritSect);

    return NULL;
}


VOID
BrDereferenceDomain(
    IN PDOMAIN_INFO DomainInfo
    )
/*++

Routine Description:

    Decrement the reference count on a domain.

    If the reference count goes to 0, remove the domain.

    On entry, the global NetworkCritSect may not be locked

Arguments:

    DomainInfo - The domain to dereference

Return Value:

    None

--*/
{
    NTSTATUS Status;
    ULONG ReferenceCount;

    //
    // Decrement the reference count
    //

    EnterCriticalSection(&NetworkCritSect);
    ReferenceCount = -- DomainInfo->ReferenceCount;
    LeaveCriticalSection(&NetworkCritSect);

    if ( ReferenceCount != 0 ) {
        return;
    }


    //
    // Ditch the rename timer
    //

    BrDestroyTimer( &DomainInfo->DomainRenameTimer );

    //
    // Free the Domain Info structure.
    //
    (VOID) LocalFree( DomainInfo );

}


NET_API_STATUS
BrRenameDomainForNetwork(
    PNETWORK Network,
    PVOID Context
    )
/*++

Routine Description:

    Handle domain rename for a particular network.

    Reset the network indicating this machine plays no special role.
    Then, re-enable any role we're currently playing.

Arguments:

    Network - Network to reset (Referenced)

Return Value:

    Status - The status of the operation.

--*/
{
    NET_API_STATUS NetStatus;

    //
    // Lock the network
    //
    if (LOCK_NETWORK(Network)) {

        //
        // Stop it from being a master.
        //
        if (Network->Role & ROLE_MASTER) {

            NetStatus = BrStopMaster(Network);

            if ( NetStatus != NERR_Success ) {
                BrPrint(( BR_CRITICAL,
                          "%ws: %ws: BrRenameDomainForNetwork: Cannot BrStopMaster %ld\n",
                          Network->DomainInfo->DomUnicodeDomainName,
                          Network->NetworkName.Buffer,
                          NetStatus ));
            }
        }

        //
        //  Stop being a backup as well.
        //

        NetStatus = BrStopBackup(Network);

        if ( NetStatus != NERR_Success ) {
            BrPrint(( BR_CRITICAL,
                      "%ws: %ws: BrRenameDomainForNetwork: Cannot BrStopBackup %ld\n",
                      Network->DomainInfo->DomUnicodeDomainName,
                      Network->NetworkName.Buffer,
                      NetStatus ));
        }

        //
        // Stop even being a potential browser.
        //  Close the <DomainName>[1E] name
        //

        NetStatus = BrUpdateNetworkAnnouncementBits(Network, (PVOID)(BR_SHUTDOWN|BR_PARANOID) );

        if ( NetStatus != NERR_Success ) {
            BrPrint(( BR_CRITICAL,
                      "%ws: %ws: BrRenameDomainForNetwork: Cannot BrUpdateNetworkAnnouncementBits %ld\n",
                      Network->DomainInfo->DomUnicodeDomainName,
                      Network->NetworkName.Buffer,
                      NetStatus ));
        }

        //
        // Register the new <DomainName>[1E] name
        //

        NetStatus = BrUpdateNetworkAnnouncementBits(Network, (PVOID)BR_PARANOID );

        if ( NetStatus != NERR_Success ) {
            BrPrint(( BR_CRITICAL,
                      "%ws: %ws: BrRenameDomainForNetwork: Cannot BrUpdateNetworkAnnouncementBits %ld\n",
                      Network->DomainInfo->DomUnicodeDomainName,
                      Network->NetworkName.Buffer,
                      NetStatus ));
        }


        //
        //  If we are on either a domain master, or on a lanman/NT machine,
        //  force an election on all our transports to make sure that we're
        //  the master
        //

        if ( (Network->Flags & NETWORK_PDC) != 0 || BrInfo.IsLanmanNt) {
            NetStatus = BrElectMasterOnNet( Network, (PVOID)EVENT_BROWSER_ELECTION_SENT_LANMAN_NT_STARTED );

            if (NetStatus != NERR_Success) {
                BrPrint(( BR_CRITICAL,
                          "%ws: %ws: BrRenameDomainForNetwork: Can't Elect Master.\n",
                          Network->DomainInfo->DomUnicodeDomainName,
                          Network->NetworkName.Buffer,
                          NetStatus ));
                // This isn't fatal.
            } else {
                BrPrint(( BR_NETWORK, "%ws: %ws: Election forced on domain rename.\n",
                              Network->DomainInfo->DomUnicodeDomainName,
                              Network->NetworkName.Buffer ));
            }

        }

        //
        // If forced to MaintainServerList, become a backup again
        //

        EnterCriticalSection(&BrInfo.ConfigCritSect);
        if (BrInfo.MaintainServerList == 1){

            //
            //  Become a backup server now.
            //

            NetStatus = BrBecomeBackup( Network );

            if (NetStatus != NERR_Success) {
                BrPrint(( BR_CRITICAL,
                          "%ws: %ws: BrRenameDomainForNetwork: Can't BecomeBackup.\n",
                          Network->DomainInfo->DomUnicodeDomainName,
                          Network->NetworkName.Buffer,
                          NetStatus ));
                // This isn't fatal.
            } else {
                BrPrint(( BR_NETWORK, "%ws: %ws: Became Backup.\n",
                              Network->DomainInfo->DomUnicodeDomainName,
                              Network->NetworkName.Buffer ));
            }

        }
        LeaveCriticalSection(&BrInfo.ConfigCritSect);

        UNLOCK_NETWORK(Network);

    }

    //
    // Always return success so allow the caller to continue to the next network.
    //
    return NERR_Success;

}

VOID
BrRenameDomain(
    IN PVOID Context
    )
/*++

Routine Description:

    Rename the domain from the specified name to the currently register named
    for the domain.

Arguments:

    OldDomainName - Name that the domain is currently known by.

Return Value:

    None

--*/
{
    NET_API_STATUS NetStatus;
    NTSTATUS Status;
    PDOMAIN_INFO DomainInfo = NULL;
    LPWSTR NewDomainName = NULL;


    //
    // Reference the domain.
    //  This routine can be called as a timer routine.  In that case, the
    //  domain might not exist any more.
    //

    DomainInfo = BrReferenceDomain( Context );

    if ( DomainInfo == NULL ) {
        BrPrint(( BR_CRITICAL, "%lx: Renamed domain no longer exists\n", Context ));
        NetStatus = ERROR_INTERNAL_ERROR;
        goto Cleanup;
    }

    BrPrint(( BR_DOMAIN, "%ws: BrRenameDomain called\n",
                     DomainInfo->DomUnicodeDomainName ));

    //
    // Determine the new domain name
    //

    NetStatus = NetpGetDomainName( &NewDomainName );

    if ( NetStatus != NERR_Success ) {
        BrPrint(( BR_CRITICAL, "%ws: Cannot determine the new domain name %ld\n",
                         DomainInfo->DomUnicodeDomainName,
                         NetStatus ));
        goto Cleanup;
    }

    //
    // Put the new domain name into the domain structure
    // Note: Use workgroup type rather then domain since
    // we have no notion of domain/workgroup in the browser (all are "groups")
    // an workgroup is less restrictive (see bug 348606)
    //

    EnterCriticalSection(&NetworkCritSect);
    NetStatus = I_NetNameCanonicalize(
                      NULL,
                      NewDomainName,
                      DomainInfo->DomUnicodeDomainName,
                      sizeof(DomainInfo->DomUnicodeDomainName),
                      NAMETYPE_WORKGROUP,
                      0 );


    if ( NetStatus != NERR_Success ) {
        LeaveCriticalSection(&NetworkCritSect);
        BrPrint(( BR_CRITICAL, "%ws: DomainName is invalid %ld\n",
                  NewDomainName,
                  NetStatus ));
        goto Cleanup;
    }

    RtlInitUnicodeString( &DomainInfo->DomUnicodeDomainNameString,
                          DomainInfo->DomUnicodeDomainName );

    Status = RtlUpcaseUnicodeToOemN( DomainInfo->DomOemDomainName,
                                     sizeof(DomainInfo->DomOemDomainName),
                                     &DomainInfo->DomOemDomainNameLength,
                                     DomainInfo->DomUnicodeDomainNameString.Buffer,
                                     DomainInfo->DomUnicodeDomainNameString.Length);

    if (!NT_SUCCESS(Status)) {
        LeaveCriticalSection(&NetworkCritSect);
        BrPrint(( BR_CRITICAL, "%ws: Unable to convert Domain name to OEM\n", DomainName ));
        NetStatus = ERROR_NOT_ENOUGH_MEMORY;
        goto Cleanup;
    }

    DomainInfo->DomOemDomainName[DomainInfo->DomOemDomainNameLength] = '\0';
    LeaveCriticalSection(&NetworkCritSect);


    //
    // Reset all of the networks telling them of the new domain name
    //

    NetStatus = BrEnumerateNetworksForDomain(DomainInfo, BrRenameDomainForNetwork, NULL);

    if ( NetStatus != NERR_Success ) {
        BrPrint(( BR_CRITICAL, "%ws: Cannot do rename on all networks %ld\n",
                  NewDomainName,
                  NetStatus ));
        goto Cleanup;
    }

    NetStatus = NERR_Success;

    //
    // Free locally used resources
    //
Cleanup:

    if ( NewDomainName != NULL ) {
        (VOID)LocalFree( NewDomainName );
    }

    if ( DomainInfo != NULL ) {

        //
        // If the domain rename failed,
        //  try it again in 15 minutes.
        //

        if ( NetStatus != NERR_Success ) {
            BrSetTimer(&DomainInfo->DomainRenameTimer, 15 * 1000 * 60, BrRenameDomain, DomainInfo);
        }

        BrDereferenceDomain( DomainInfo );
    }
    return;
}

VOID
BrDeleteDomain(
    IN PDOMAIN_INFO DomainInfo
    )
/*++

Routine Description:

    Force a domain to be deleted.

Arguments:

    DomainInfo - The domain to delete

Return Value:

    None

--*/
{
    //
    // Delete each of the networks for this domain.
    //

    BrEnumerateNetworksForDomain(DomainInfo, BrDeleteNetwork, NULL );

    //
    // Delink the domain from the global list and remove the final reference.
    //

    EnterCriticalSection(&NetworkCritSect);
    RemoveEntryList(&DomainInfo->Next);
    LeaveCriticalSection(&NetworkCritSect);

    BrDereferenceDomain( DomainInfo );

}

VOID
BrUninitializeDomains(
    VOID
    )
/*++

Routine Description:

    Delete all of the domains.

Arguments:

    None.

Return Value:

    None

--*/
{
    //
    // Loop through the domains deleting each of them
    //

    EnterCriticalSection(&NetworkCritSect);

    while (!IsListEmpty(&ServicedDomains)) {

        PDOMAIN_INFO DomainInfo = CONTAINING_RECORD(ServicedDomains.Flink, DOMAIN_INFO, Next);

        DomainInfo->ReferenceCount ++;

        LeaveCriticalSection(&NetworkCritSect);

        //
        // Clean up the domain.
        //

        BrDeleteDomain( DomainInfo );

        //
        // Actually delete the delinked structure by removing the last reference
        //

        ASSERT( DomainInfo->ReferenceCount == 1 );
        BrDereferenceDomain( DomainInfo );


        EnterCriticalSection(&NetworkCritSect);

    }
    LeaveCriticalSection(&NetworkCritSect);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\browser\server\brdomain.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    brdomain.h

Abstract:

    Header file for code to manage primary and emulated networks.

Author:

    Cliff Van Dyke (CliffV) 13-Jan-1995

Revision History:

--*/

//
// Description of a single domain.
//

typedef struct _DOMAIN_INFO {

    //
    // Link to next domain in 'ServicedDomains'
    //  (Serialized by NetworkCritSect)
    //

    LIST_ENTRY Next;

    //
    // Name of the domain being handled
    //

    UNICODE_STRING DomUnicodeDomainNameString;
    WCHAR DomUnicodeDomainName[DNLEN+1];

    CHAR DomOemDomainName[DNLEN+1];
    DWORD DomOemDomainNameLength;

    //
    // Computer name of this computer in this domain.
    //
    WCHAR DomUnicodeComputerName[CNLEN+1];
    DWORD DomUnicodeComputerNameLength;

    CHAR  DomOemComputerName[CNLEN+1];
    DWORD DomOemComputerNameLength;

    //
    // Number of outstanding pointers to the domain structure.
    //  (Serialized by NetworkCritSect)
    //

    DWORD ReferenceCount;

    //
    // DomainScavenger Timer
    //

    BROWSER_TIMER DomainRenameTimer;

    //
    // Misc flags.
    //

    BOOLEAN IsEmulatedDomain;           // True if this is an emulated domain
    BOOLEAN PnpDone;                    // True if PNP was processed on this domain

} DOMAIN_INFO, *PDOMAIN_INFO;

//
// List of all domains.  The primary domain is at the front of the list.
//
extern LIST_ENTRY ServicedDomains;


//
// brdomain.c procedure forwards.
//

NET_API_STATUS
BrInitializeDomains(
    VOID
    );

NET_API_STATUS
BrCreateDomainInWorker(
    LPWSTR DomainName,
    LPWSTR ComputerName,
    BOOLEAN IsEmulatedDomain
    );

VOID
BrRenameDomain(
    IN PVOID Context
    );

PDOMAIN_INFO
BrFindDomain(
    LPWSTR DomainName,
    BOOLEAN DefaultToPrimary
    );

VOID
BrDereferenceDomain(
    IN PDOMAIN_INFO DomainInfo
    );

VOID
BrDeleteDomain(
    IN PDOMAIN_INFO DomainInfo
    );

VOID
BrUninitializeDomains(
    VOID
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\browser\server\brdmmstr.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    brdmmstr.c

Abstract:

    This module contains the routines to manage a domain master browser server

Author:

    Rita Wong (ritaw) 20-Feb-1991

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop

//-------------------------------------------------------------------//
//                                                                   //
// Local structure definitions                                       //
//                                                                   //
//-------------------------------------------------------------------//

//-------------------------------------------------------------------//
//                                                                   //
// Local function prototypes                                         //
//                                                                   //
//-------------------------------------------------------------------//

VOID
GetMasterAnnouncementCompletion (
    IN PVOID Ctx
    );

typedef struct _BROWSER_GET_MASTER_ANNOUNCEMENT_CONTEXT {
    PDOMAIN_INFO DomainInfo;
    HANDLE EventHandle;
    NET_API_STATUS NetStatus;
} BROWSER_GET_MASTER_ANNOUNCEMENT_CONTEXT, *PBROWSER_GET_MASTER_ANNOUNCEMENT_CONTEXT;

NET_API_STATUS
PostGetMasterAnnouncement (
    PNETWORK Network
    )
/*++

Routine Description:

    Ensure the GetMasterAnnouncement request is posted for a particular network.

Arguments:

    None.

Return Value:

    Status - The status of the operation.

--*/
{
    NET_API_STATUS NetStatus = NERR_Success;

#ifdef ENABLE_PSEUDO_BROWSER
    if ( BrInfo.PseudoServerLevel == BROWSER_PSEUDO ) {
        // No master announcement handling for a phase out server
        return NERR_Success;
    }
#endif

    if (!LOCK_NETWORK(Network)) {
        return NERR_InternalError;
    }

    if ( (Network->Flags & NETWORK_PDC) != 0  &&
         (Network->Flags & NETWORK_WANNISH) != 0 ) {

        if (!(Network->Flags & NETWORK_GET_MASTER_ANNOUNCE_POSTED)) {

            BrPrint(( BR_MASTER,
                      "%ws: %ws: Doing PostGetMasterAnnouncement\n",
                      Network->DomainInfo->DomUnicodeDomainName,
                      Network->NetworkName.Buffer));

            NetStatus = BrIssueAsyncBrowserIoControl(Network,
                                        IOCTL_LMDR_WAIT_FOR_MASTER_ANNOUNCE,
                                        GetMasterAnnouncementCompletion,
                                        NULL
                                        );

            if ( NetStatus == NERR_Success ) {
                Network->Flags |= NETWORK_GET_MASTER_ANNOUNCE_POSTED;
            }
        } else {
            BrPrint(( BR_MASTER,
                      "%ws: %ws: PostGetMasterAnnouncement already posted.\n",
                      Network->DomainInfo->DomUnicodeDomainName,
                      Network->NetworkName.Buffer));
        }
    }

    UNLOCK_NETWORK(Network);
    return NetStatus;
}


VOID
GetMasterAnnouncementCompletion (
    IN PVOID Ctx
    )
/*++

Routine Description:

    This function is the completion routine for a master announcement.  It is
    called whenever a master announcement is received for a particular network.

Arguments:

    Ctx - Context block for request.

Return Value:

    None.

--*/


{
    PVOID ServerList = NULL;
    ULONG EntriesRead;
    ULONG TotalEntries;
    NET_API_STATUS Status = NERR_Success;
    PBROWSERASYNCCONTEXT Context = Ctx;
    PLMDR_REQUEST_PACKET MasterAnnouncement = Context->RequestPacket;
    PNETWORK Network = Context->Network;
    LPTSTR RemoteMasterName = NULL;
    BOOLEAN NetLocked = FALSE;
    BOOLEAN NetReferenced = FALSE;


    try {
        //
        // Ensure the network wasn't deleted from under us.
        //
        if ( BrReferenceNetwork( Network ) == NULL ) {
            try_return(NOTHING);
        }
        NetReferenced = TRUE;

        if (!LOCK_NETWORK(Network)){
            try_return(NOTHING);
        }
        NetLocked = TRUE;

        Network->Flags &= ~NETWORK_GET_MASTER_ANNOUNCE_POSTED;

        //
        //  The request failed for some reason - just return immediately.
        //

        if (!NT_SUCCESS(Context->IoStatusBlock.Status)) {
            try_return(NOTHING);
        }

        Status = PostGetMasterAnnouncement(Network);

        if (Status != NERR_Success) {
            BrPrint(( BR_CRITICAL,
                      "%ws: %ws: Unable to re-issue GetMasterAnnouncement request: %lx\n",
                      Network->DomainInfo->DomUnicodeDomainName,
                      Network->NetworkName.Buffer,
                      Status));

            try_return(NOTHING);

        }


        RemoteMasterName = MIDL_user_allocate(MasterAnnouncement->Parameters.WaitForMasterAnnouncement.MasterNameLength+3*sizeof(TCHAR));

        if (RemoteMasterName == NULL) {
            try_return(NOTHING);
        }

        RemoteMasterName[0] = TEXT('\\');
        RemoteMasterName[1] = TEXT('\\');

        STRNCPY(&RemoteMasterName[2],
                MasterAnnouncement->Parameters.WaitForMasterAnnouncement.Name,
                MasterAnnouncement->Parameters.WaitForMasterAnnouncement.MasterNameLength/sizeof(TCHAR));

        RemoteMasterName[(MasterAnnouncement->Parameters.WaitForMasterAnnouncement.MasterNameLength/sizeof(TCHAR))+2] = UNICODE_NULL;

        BrPrint(( BR_MASTER,
                  "%ws: %ws: GetMasterAnnouncement: Got a master browser announcement from %ws\n",
                  Network->DomainInfo->DomUnicodeDomainName,
                  Network->NetworkName.Buffer,
                  RemoteMasterName));

        UNLOCK_NETWORK(Network);

        NetLocked = FALSE;

        //
        //  Remote the api and pull the browse list from the remote server.
        //

        Status = RxNetServerEnum(RemoteMasterName,
                                     Network->NetworkName.Buffer,
                                     101,
                                     (LPBYTE *)&ServerList,
                                     0xffffffff,
                                     &EntriesRead,
                                     &TotalEntries,
                                     SV_TYPE_LOCAL_LIST_ONLY,
                                     NULL,
                                     NULL
                                     );

        if ((Status == NERR_Success) || (Status == ERROR_MORE_DATA)) {

            if (!LOCK_NETWORK(Network)) {
                try_return(NOTHING);
            }

            NetLocked = TRUE;

            Status = MergeServerList(&Network->BrowseTable,
                                     101,
                                     ServerList,
                                     EntriesRead,
                                     TotalEntries
                                     );

            UNLOCK_NETWORK(Network);

            NetLocked = FALSE;

            (void) NetApiBufferFree( ServerList );
            ServerList = NULL;

        } else {

            BrPrint(( BR_MASTER,
                      "%ws: %ws: GetMasterAnnouncement: Cannot get server list from %ws (%ld)\n",
                      Network->DomainInfo->DomUnicodeDomainName,
                      Network->NetworkName.Buffer,
                      RemoteMasterName,
                      Status ));
        }

        //
        //  Remote the api and pull the browse list from the remote server.
        //

        Status = RxNetServerEnum(RemoteMasterName,
                                     Network->NetworkName.Buffer,
                                     101,
                                     (LPBYTE *)&ServerList,
                                     0xffffffff,
                                     &EntriesRead,
                                     &TotalEntries,
                                     SV_TYPE_LOCAL_LIST_ONLY | SV_TYPE_DOMAIN_ENUM,
                                     NULL,
                                     NULL
                                     );

        if ((Status == NERR_Success) || (Status == ERROR_MORE_DATA)) {

            if (!LOCK_NETWORK(Network)) {
                try_return(NOTHING);
            }

            NetLocked = TRUE;

            Status = MergeServerList(&Network->DomainList,
                                     101,
                                     ServerList,
                                     EntriesRead,
                                     TotalEntries
                                     );

        } else {

            BrPrint(( BR_MASTER,
                      "%ws: %ws: GetMasterAnnouncement: Cannot get domain list from %ws (%ld)\n",
                      Network->DomainInfo->DomUnicodeDomainName,
                      Network->NetworkName.Buffer,
                      RemoteMasterName,
                      Status ));
        }

try_exit:NOTHING;
    } finally {

        if (NetLocked) {
            UNLOCK_NETWORK(Network);
        }

        if ( NetReferenced ) {
            BrDereferenceNetwork( Network );
        }

        if (RemoteMasterName != NULL) {
            MIDL_user_free(RemoteMasterName);
        }

        MIDL_user_free(Context);

        if ( ServerList != NULL ) {
            (void) NetApiBufferFree( ServerList );
        }

    }

    return;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\browser\server\brmaster.h ===
/*++

Copyright (c) 1991 Microsoft Corporation

Module Name:

    brmaster.h

Abstract:

    Private header file which defines the global data which is used for
    communication between the service control handler and the
    rest of the NT Workstation service.

Author:

    Rita Wong (ritaw) 06-May-1991

Revision History:

--*/

#ifndef _BRMASTER_INCLUDED_
#define _BRMASTER_INCLUDED_

NET_API_STATUS
PostBecomeMaster(
    PNETWORK Network
    );

NET_API_STATUS
PostGetMasterAnnouncement (
    PNETWORK Network
    );

NET_API_STATUS
BrStopMaster(
    IN PNETWORK Network
    );

VOID
BrGetMasterServerNameAysnc(
    IN PNETWORK Network
    );

NET_API_STATUS
GetMasterServerNames(
    IN PNETWORK Network
    );

VOID
BrMasterAnnouncement(
    IN PVOID Context
    );

VOID
MasterBrowserTimerRoutine (
    IN PVOID TimerContext
    );

VOID
BrChangeMasterPeriodicity (
    VOID
    );

VOID
BrBrowseTableInsertRoutine(
    IN PINTERIM_SERVER_LIST InterimTable,
    IN PINTERIM_ELEMENT InterimElement
    );

VOID
BrBrowseTableDeleteRoutine(
    IN PINTERIM_SERVER_LIST InterimTable,
    IN PINTERIM_ELEMENT InterimElement
    );

VOID
BrBrowseTableUpdateRoutine(
    IN PINTERIM_SERVER_LIST InterimTable,
    IN PINTERIM_ELEMENT InterimElement
    );

BOOLEAN
BrBrowseTableAgeRoutine(
    IN PINTERIM_SERVER_LIST InterimTable,
    IN PINTERIM_ELEMENT InterimElement
    );

VOID
BrDomainTableInsertRoutine(
    IN PINTERIM_SERVER_LIST InterimTable,
    IN PINTERIM_ELEMENT InterimElement
    );

VOID
BrDomainTableDeleteRoutine(
    IN PINTERIM_SERVER_LIST InterimTable,
    IN PINTERIM_ELEMENT InterimElement
    );

VOID
BrDomainTableUpdateRoutine(
    IN PINTERIM_SERVER_LIST InterimTable,
    IN PINTERIM_ELEMENT InterimElement
    );

BOOLEAN
BrDomainTableAgeRoutine(
    IN PINTERIM_SERVER_LIST InterimTable,
    IN PINTERIM_ELEMENT InterimElement
    );




#ifdef ENABLE_PSEUDO_BROWSER
//
// Pseudo Server Helper Routines
//

VOID
BrFreeNetworkTables(
    IN  PNETWORK        Network
    );
#endif




#endif // ifndef _BRBACKUP_INCLUDED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\browser\server\brmaster.c ===
/*++

Copyright (c) 1991-1992  Microsoft Corporation

Module Name:

    browser.c

Abstract:

    This module contains the worker routines for the NetWksta APIs
    implemented in the Workstation service.

Author:

    Rita Wong (ritaw) 20-Feb-1991

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop


//-------------------------------------------------------------------//
//                                                                   //
// Local structure definitions                                       //
//                                                                   //
//-------------------------------------------------------------------//

ULONG
DomainAnnouncementPeriodicity[] = {1*60*1000, 1*60*1000, 5*60*1000, 5*60*1000, 10*60*1000, 10*60*1000, 15*60*1000};

ULONG
DomainAnnouncementMax = (sizeof(DomainAnnouncementPeriodicity) / sizeof(ULONG)) - 1;

//-------------------------------------------------------------------//
//                                                                   //
// Local function prototypes                                         //
//                                                                   //
//-------------------------------------------------------------------//


VOID
BrGetMasterServerNameForNet(
    IN PVOID Context
    );


VOID
BecomeMasterCompletion (
    IN PVOID Ctx
    );

NET_API_STATUS
StartMasterBrowserTimer(
    IN PNETWORK Network
    );

NET_API_STATUS
AnnounceMasterToDomainMaster(
    IN PNETWORK Network,
    IN LPWSTR ServerName
    );

//-------------------------------------------------------------------//
//                                                                   //
// Global function prototypes                                        //
//                                                                   //
//-------------------------------------------------------------------//

NET_API_STATUS
PostBecomeMaster(
    PNETWORK Network
    )
/*++

Routine Description:

    This function is the worker routine called to actually issue a BecomeMaster
    FsControl to the bowser driver on all the bound transports.  It will
    complete when the machine becomes a master browser server.

    Please note that this might never complete.

Arguments:

    None.

Return Value:

    Status - The status of the operation.

--*/
{
    NTSTATUS Status = NERR_Success;

    if (!LOCK_NETWORK(Network)) {
        return NERR_InternalError;
    }

    if (!(Network->Flags & NETWORK_BECOME_MASTER_POSTED)) {

        //
        //  Make certain that we have the browser election name added
        //  before we allow ourselves to become a master.  This is a NOP
        //  if we already have the election name added.
        //

        (VOID) BrUpdateNetworkAnnouncementBits(Network, (PVOID)BR_PARANOID );

        Status = BrIssueAsyncBrowserIoControl(Network,
                            IOCTL_LMDR_BECOME_MASTER,
                            BecomeMasterCompletion,
                            NULL );

        if ( Status == NERR_Success ) {
            Network->Flags |= NETWORK_BECOME_MASTER_POSTED;
        }
    }

    UNLOCK_NETWORK(Network);

    return Status;
}

NET_API_STATUS
BrRecoverFromFailedPromotion(
    IN PVOID Ctx
    )
/*++

Routine Description:

    When we attempt to promote a machine to master browser and fail, we will
    effectively shut down the browser for a period of time.  When that period
    of time expires, we will call BrRecoverFromFailedPromotion to recover
    from the failure.

    This routine will do one of the following:
        1) Force the machine to become a backup browser,
    or  2) Attempt to discover the name of the master.

Arguments:

    IN PVOID Ctx - The network structure we failed on.

Return Value:

    Status - The status of the operation (usually ignored).

--*/


{
    PNETWORK Network = Ctx;
    NET_API_STATUS Status;
    BOOL NetworkLocked = FALSE;

    //
    // Prevent the network from being deleted while we're in this timer routine.
    //
    if ( BrReferenceNetwork( Network ) == NULL ) {
        return NERR_InternalError;
    }

    try {

        if (!LOCK_NETWORK(Network)) {
            try_return( Status = NERR_InternalError);
        }

        BrPrint(( BR_MASTER,
                  "%ws: %ws: BrRecoverFromFailedPromotion.\n",
                  Network->DomainInfo->DomUnicodeDomainName,
                  Network->NetworkName.Buffer ));

        NetworkLocked = TRUE;
            //
        //  We had better not be the master now.
        //

        ASSERT (!(Network->Role & ROLE_MASTER));

        //
        //  If we're configured to become a backup by default, then become
        //  a backup now.
        //

        if (BrInfo.MaintainServerList == 1) {

            BrPrint(( BR_MASTER,
                      "%ws: %ws: BrRecoverFromFailedPromotion. Become backup.\n",
                      Network->DomainInfo->DomUnicodeDomainName,
                      Network->NetworkName.Buffer ));
            Status = BecomeBackup(Network, NULL);

            if (Status != NERR_Success) {
                BrPrint(( BR_CRITICAL,
                          "%ws: %ws: Could not become backup: %lx\n",
                          Network->DomainInfo->DomUnicodeDomainName,
                          Network->NetworkName.Buffer,
                          Status));

            }
        } else {
            BrPrint(( BR_MASTER,
                      "%ws: %ws: BrRecoverFromFailedPromotion. FindMaster.\n",
                      Network->DomainInfo->DomUnicodeDomainName,
                      Network->NetworkName.Buffer));

            UNLOCK_NETWORK(Network);

            NetworkLocked = FALSE;

            //
            //  Now try to figure out who is the master.
            //

            Status = GetMasterServerNames(Network);

            //
            //  Ignore the status from this and re-lock the network to
            //  recover cleanly.
            //

            if (!LOCK_NETWORK(Network)) {
                try_return( Status = NERR_InternalError);
            }

            NetworkLocked = TRUE;

        }

        Status = NO_ERROR;
        //
        //  Otherwise, just let sleeping dogs lie.
        //
try_exit:NOTHING;
    } finally {
        if (NetworkLocked) {
            UNLOCK_NETWORK(Network);
        }

        BrDereferenceNetwork( Network );
    }

    return Status;
}


VOID
BecomeMasterCompletion (
    IN PVOID Ctx
    )
/*++

Routine Description:

    This function is called by the I/O system when the request to become a
    master completes.

    Please note that it is possible that the request may complete with an
    error.

Arguments:

    None.

Return Value:

    Status - The status of the operation.

--*/
{
    NET_API_STATUS Status;
    PBROWSERASYNCCONTEXT Context = Ctx;
    PNETWORK Network = Context->Network;
    BOOLEAN NetworkLocked = FALSE;
    BOOLEAN NetReferenced = FALSE;


    try {
        //
        // Ensure the network wasn't deleted from under us.
        //
        if ( BrReferenceNetwork( Network ) == NULL ) {
            try_return(NOTHING);
        }
        NetReferenced = TRUE;

        //
        //  Lock the network structure.
        //

        if (!LOCK_NETWORK(Network)) {
            try_return(NOTHING);
        }
        NetworkLocked = TRUE;

        Network->Flags &= ~NETWORK_BECOME_MASTER_POSTED;

        if (!NT_SUCCESS(Context->IoStatusBlock.Status)) {
            BrPrint(( BR_CRITICAL,
                      "%ws: %ws: Failure in BecomeMaster: %X\n",
                      Network->DomainInfo->DomUnicodeDomainName,
                      Network->NetworkName.Buffer,
                      Context->IoStatusBlock.Status));

            try_return(NOTHING);

        }

        BrPrint(( BR_MASTER,
                  "%ws: BecomeMasterCompletion. Now master on network %ws\n",
                  Network->DomainInfo->DomUnicodeDomainName,
                  Network->NetworkName.Buffer));

        //
        //  If we're already a master, ignore this request.
        //

        if (Network->Role & ROLE_MASTER) {
            try_return(NOTHING);
        }

        //
        //  Cancel any outstanding backup timers - we don't download the list
        //  anymore.
        //

        Status = BrCancelTimer(&Network->BackupBrowserTimer);

        if (!NT_SUCCESS(Status)) {
            BrPrint(( BR_CRITICAL,
                      "%ws: %ws: Could not stop backup timer: %lx\n",
                      Network->DomainInfo->DomUnicodeDomainName,
                      Network->NetworkName.Buffer,
                      Status));
        }

        //
        //  Figure out what service bits we should be using when announcing ourselves
        //

        Network->Role |= ROLE_MASTER;


        Status = BrUpdateNetworkAnnouncementBits(Network, 0 );

        if (Status != NERR_Success) {
            BrPrint(( BR_MASTER,
                      "%ws: %ws: Unable to set master announcement bits in browser: %ld\n",
                      Network->DomainInfo->DomUnicodeDomainName,
                      Network->NetworkName.Buffer,
                      Status));

            //
            //  When we're in this state, we can't rely on our being a backup
            //  browser - we may not be able to retrieve a valid list of
            //  browsers from the master.
            //

            Network->Role &= ~ROLE_BACKUP;

            Network->NumberOfFailedPromotions += 1;

            //
            //  Log every 5 failed promotion attempts, and after having logged 5
            //  promotion events, stop logging them, this means that it's been
            //  25 times that we've tried to promote, and it's not likely to get
            //  any better.  We'll keep on trying, but we won't complain any more.
            //

            if ((Network->NumberOfFailedPromotions % 5) == 0) {
                ULONG AStatStatus;
                LPWSTR SubString[1];
                WCHAR CurrentMasterName[CNLEN+1];

                if (Network->NumberOfPromotionEventsLogged < 5) {

                    AStatStatus = GetNetBiosMasterName(
                                    Network->NetworkName.Buffer,
                                    Network->DomainInfo->DomUnicodeDomainName,
                                    CurrentMasterName,
                                    BrLmsvcsGlobalData->NetBiosReset
                                    );

                    if (AStatStatus == NERR_Success) {
                        SubString[0] = CurrentMasterName;

                        BrLogEvent(EVENT_BROWSER_MASTER_PROMOTION_FAILED, Status, 1, SubString);
                    } else {
                        BrLogEvent(EVENT_BROWSER_MASTER_PROMOTION_FAILED_NO_MASTER, Status, 0, NULL);
                    }

                    Network->NumberOfPromotionEventsLogged += 1;

                    if (Network->NumberOfPromotionEventsLogged == 5) {
                        BrLogEvent(EVENT_BROWSER_MASTER_PROMOTION_FAILED_STOPPING, Status, 0, NULL);
                    }
                }
            }

            //
            //  We were unable to promote ourselves to master.
            //
            //  We want to set our role back to browser, and re-issue the become
            //  master request.
            //

            BrStopMaster(Network);

            BrSetTimer(&Network->MasterBrowserTimer, FAILED_PROMOTION_PERIODICITY*1000, BrRecoverFromFailedPromotion, Network);

        } else {

            //
            //  Initialize the number of times the master timer has run.
            //

            Network->MasterBrowserTimerCount = 0;

            Status = StartMasterBrowserTimer(Network);

            if (Status != NERR_Success) {
                BrPrint(( BR_CRITICAL,
                          "%ws: %ws: Could not start browser master timer: %ld\n",
                          Network->DomainInfo->DomUnicodeDomainName,
                          Network->NetworkName.Buffer,
                          Status ));
            }

            Network->NumberOfFailedPromotions = 0;

            Network->NumberOfPromotionEventsLogged = 0;

            Network->MasterAnnouncementIndex = 0;


            //
            //  We successfully became the master.
            //
            //  Now announce ourselves as the new master for this domain.
            //

            BrMasterAnnouncement(Network);

            //
            //  Populate the browse list with the information retrieved
            //  while we were a backup browser.
            //

            if (Network->TotalBackupServerListEntries != 0) {
                MergeServerList(&Network->BrowseTable,
                                101,
                                Network->BackupServerList,
                                Network->TotalBackupServerListEntries,
                                Network->TotalBackupServerListEntries
                                );
                MIDL_user_free(Network->BackupServerList);

                Network->BackupServerList = NULL;

                Network->TotalBackupServerListEntries = 0;
            }

            if (Network->TotalBackupDomainListEntries != 0) {
                MergeServerList(&Network->DomainList,
                                101,
                                Network->BackupDomainList,
                                Network->TotalBackupDomainListEntries,
                                Network->TotalBackupDomainListEntries
                                );
                MIDL_user_free(Network->BackupDomainList);

                Network->BackupDomainList = NULL;

                Network->TotalBackupDomainListEntries = 0;
            }



            //
            //  Unlock the network before calling BrWanMasterInitialize.
            //
            UNLOCK_NETWORK(Network);
            NetworkLocked = FALSE;


            //
            //  Run the master browser timer routine to get the entire domains
            //  list of servers.
            //

            if (Network->Flags & NETWORK_WANNISH) {
                BrWanMasterInitialize(Network);
                MasterBrowserTimerRoutine(Network);
            }

            try_return(NOTHING);

        }
try_exit:NOTHING;
    } finally {

        //
        //  Make sure there's a become master oustanding.
        //

        if ( NetReferenced ) {
            PostBecomeMaster(Network);
        }

        if (NetworkLocked) {
            UNLOCK_NETWORK(Network);
        }

        if ( NetReferenced ) {
            BrDereferenceNetwork( Network );
        }

        MIDL_user_free(Context);
    }

}




NET_API_STATUS
ChangeMasterPeriodicityWorker(
    PNETWORK Network,
    PVOID Ctx
    )
/*++

Routine Description:

    This function changes the master periodicity for a single network.

Arguments:

    None.

Return Value:

    Status - The status of the operation.

--*/
{

    //
    // Lock the network
    //

    if (LOCK_NETWORK(Network)) {

        //
        //  Ensure we're the master.
        //

        if ( Network->Role & ROLE_MASTER ) {
            NET_API_STATUS NetStatus;

            //
            // Cancel the timer to ensure it doesn't go off while we're
            //  processing this change.
            //

            NetStatus = BrCancelTimer(&Network->MasterBrowserTimer);
            ASSERT (NetStatus == NERR_Success);

            //
            // Unlock the network while we execute the timer routine.
            //
            UNLOCK_NETWORK( Network );

            //
            // Call the timer routine immediately.
            //
            MasterBrowserTimerRoutine(Network);

        } else {
            UNLOCK_NETWORK( Network );
        }

    }

    UNREFERENCED_PARAMETER(Ctx);

    return NERR_Success;
}



VOID
BrChangeMasterPeriodicity (
    VOID
    )
/*++

Routine Description:

    This function is called when the master periodicity is changed in the
    registry.

Arguments:

    None.

Return Value:

    None.

--*/
{
    (VOID)BrEnumerateNetworks(ChangeMasterPeriodicityWorker, NULL);
}

NET_API_STATUS
StartMasterBrowserTimer(
    IN PNETWORK Network
    )
{
    NET_API_STATUS Status;

    Status = BrSetTimer( &Network->MasterBrowserTimer,
                         BrInfo.MasterPeriodicity*1000,
                         MasterBrowserTimerRoutine,
                         Network);

    return Status;

}


typedef struct _BROWSER_GETNAMES_CONTEXT {
    WORKER_ITEM WorkItem;

    PNETWORK Network;

} BROWSER_GETNAMES_CONTEXT, *PBROWSER_GETNAMES_CONTEXT;

VOID
BrGetMasterServerNameAysnc(
    PNETWORK Network
    )
/*++

Routine Description:

    Queue a workitem to asynchronously get the master browser names for a
    transport.

Arguments:

    Network - Identifies the network to query.

Return Value:

    None

--*/
{
    PBROWSER_GETNAMES_CONTEXT Context;

    //
    // Allocate context for this async call.
    //

    Context = LocalAlloc( 0, sizeof(BROWSER_GETNAMES_CONTEXT) );

    if ( Context == NULL ) {
        return;
    }

    //
    // Just queue this for later execution.
    //  We're doing this for information purposes only.  In the case that
    //  the master can't be found, we don't want to wait for completion.
    //  (e.g., on a machine with multiple transports and the net cable is
    //  pulled)
    //

    BrReferenceNetwork( Network );
    Context->Network = Network;

    BrInitializeWorkItem( &Context->WorkItem,
                          BrGetMasterServerNameForNet,
                          Context );

    BrQueueWorkItem( &Context->WorkItem );

    return;

}

VOID
BrGetMasterServerNameForNet(
    IN PVOID Context
    )
/*++

Routine Description:

    Routine to get the master browser name for a particular network.

Arguments:

    Context - Context containing the workitem and the description of the
        network to query.

Return Value:

    None

--*/
{
    PNETWORK Network = ((PBROWSER_GETNAMES_CONTEXT)Context)->Network;

    BrPrint(( BR_NETWORK,
              "%ws: %ws: FindMaster during startup\n",
              Network->DomainInfo->DomUnicodeDomainName,
              Network->NetworkName.Buffer));

    //
    //  We only call this on startup, so on IPX networks, don't bother to
    //  find out the master.
    //

    if (!(Network->Flags & NETWORK_IPX)) {
        GetMasterServerNames(Network);
    }

    BrDereferenceNetwork( Network );
    (VOID) LocalFree( Context );

    return;

}

NET_API_STATUS
GetMasterServerNames(
    IN PNETWORK Network
    )
/*++

Routine Description:

    This function is the worker routine called to determine the name of the
    master browser server for a particular network.

Arguments:

    None.

Return Value:

    Status - The status of the operation.

--*/
{
    NET_API_STATUS Status;

    PLMDR_REQUEST_PACKET RequestPacket = NULL;

    BrPrint(( BR_NETWORK,
              "%ws: %ws: FindMaster started\n",
              Network->DomainInfo->DomUnicodeDomainName,
              Network->NetworkName.Buffer));

    //
    //  This request could cause an election. Make sure that if we win
    //  the election that we can handle it.
    //

    PostBecomeMaster( Network);

    RequestPacket = MIDL_user_allocate(
                        (UINT) sizeof(LMDR_REQUEST_PACKET)+
                               MAXIMUM_FILENAME_LENGTH*sizeof(WCHAR)
                        );

    if (RequestPacket == NULL) {
        return(ERROR_NOT_ENOUGH_MEMORY);
    }

    RequestPacket->Version = LMDR_REQUEST_PACKET_VERSION_DOM;

    //
    //  Set level to TRUE to indicate that find master should initiate
    //  a findmaster request.
    //

    RequestPacket->Level = 1;

    RequestPacket->TransportName = Network->NetworkName;
    RequestPacket->EmulatedDomainName = Network->DomainInfo->DomUnicodeDomainNameString;

    //
    //  Reference the network while the I/O is pending.
    //

    Status = BrDgReceiverIoControl(BrDgReceiverDeviceHandle,
                    IOCTL_LMDR_GET_MASTER_NAME,
                    RequestPacket,
                    sizeof(LMDR_REQUEST_PACKET)+Network->NetworkName.Length,
                    RequestPacket,
                    sizeof(LMDR_REQUEST_PACKET)+MAXIMUM_FILENAME_LENGTH*sizeof(WCHAR),
                    NULL);

    if (Status != NERR_Success) {

        BrPrint(( BR_CRITICAL,
                  "%ws: %ws: FindMaster failed: %ld\n",
                  Network->DomainInfo->DomUnicodeDomainName,
                  Network->NetworkName.Buffer,
                  Status));
        MIDL_user_free(RequestPacket);

        return(Status);
    }

    if (!LOCK_NETWORK(Network)) {
        MIDL_user_free(RequestPacket);

        return NERR_InternalError;
    }


    //
    // Copy the master browser name into the network structure
    //

    wcsncpy( Network->UncMasterBrowserName,
             RequestPacket->Parameters.GetMasterName.Name,
             UNCLEN+1 );

    Network->UncMasterBrowserName[UNCLEN] = L'\0';

    ASSERT ( NetpIsUncComputerNameValid( Network->UncMasterBrowserName ) );

    BrPrint(( BR_NETWORK, "%ws: %ws: FindMaster succeeded.  Master: %ws\n",
                  Network->DomainInfo->DomUnicodeDomainName,
                  Network->NetworkName.Buffer,
                  Network->UncMasterBrowserName));

    UNLOCK_NETWORK(Network);

    MIDL_user_free(RequestPacket);

    return Status;
}

VOID
MasterBrowserTimerRoutine (
    IN PVOID TimerContext
    )
{
    IN PNETWORK Network = TimerContext;
    NET_API_STATUS Status;
    PVOID ServerList = NULL;
    PVOID WinsServerList = NULL;
    ULONG EntriesInList;
    ULONG TotalEntriesInList;
    LPWSTR TransportName;
    BOOLEAN NetLocked = FALSE;
    LPWSTR PrimaryDomainController = NULL;
    LPWSTR PrimaryWinsServerAddress = NULL;
    LPWSTR SecondaryWinsServerAddress = NULL;
    PDOMAIN_CONTROLLER_INFO  pDcInfo=NULL;

    //
    // Prevent the network from being deleted while we're in this timer routine.
    //
    if ( BrReferenceNetwork( Network ) == NULL ) {
        return;
    }

    try {

        //
        //  If we're not a master any more, blow away this request.
        //

        if (!(Network->Role & ROLE_MASTER)) {
            try_return(NOTHING);
        }



#ifdef ENABLE_PSEUDO_BROWSER
        if (BrInfo.PseudoServerLevel == BROWSER_PSEUDO) {
            BrFreeNetworkTables(Network);
            try_return(NOTHING);
        }
#endif


        if (!LOCK_NETWORK(Network)) {
            try_return(NOTHING);
        }

        NetLocked = TRUE;



        TransportName = Network->NetworkName.Buffer;


        //
        //  Now that we have the network locked, re-test to see if we are
        //  still the master.
        //

        if (!(Network->Role & ROLE_MASTER)) {
            try_return(NOTHING);
        }

        Network->MasterBrowserTimerCount += 1;

        //
        //  If this is a wannish network, we always want to run the master
        //  timer because we might have information about other subnets
        //  in our list.
        //

        if (Network->Flags & NETWORK_WANNISH) {

            //
            //  Age out servers and domains from the server list.
            //

            AgeInterimServerList(&Network->BrowseTable);

            AgeInterimServerList(&Network->DomainList);

            //
            //  If we're not the PDC, then we need to retrieve the list
            //  from the PDC....
            //
            // Skip processing if we're a semi-pseudo server (no dmb
            // communications
            //


#ifdef ENABLE_PSEUDO_BROWSER
            if ( (Network->Flags & NETWORK_PDC) == 0  &&
                 BrInfo.PseudoServerLevel != BROWSER_SEMI_PSEUDO_NO_DMB) {
#else
                if ( (Network->Flags & NETWORK_PDC) == 0 ) {
#endif

                ASSERT (NetLocked);

                UNLOCK_NETWORK(Network);

                NetLocked = FALSE;

                Status = DsGetDcName( NULL, NULL, NULL, NULL,
                                      DS_PDC_REQUIRED    |
                                      DS_BACKGROUND_ONLY |
                                      DS_RETURN_FLAT_NAME,
                                      &pDcInfo );

                //
                // If the PDC can be found,
                //  Exchange server lists with it.
                //

                if (Status == NERR_Success) {

                    PrimaryDomainController = pDcInfo->DomainControllerName;

                    //
                    //  Tell the Domain Master (PDC) that we're a master browser.
                    //

                    (VOID) AnnounceMasterToDomainMaster (Network, &PrimaryDomainController[2]);


                    //
                    //  Retrieve the list of all the servers from the PDC.
                    //

                    Status = RxNetServerEnum(PrimaryDomainController,
                                         TransportName,
                                         101,
                                         (LPBYTE *)&ServerList,
                                         0xffffffff,
                                         &EntriesInList,
                                         &TotalEntriesInList,
                                         SV_TYPE_ALL,
                                         NULL,
                                         NULL
                                         );

                    if ((Status == NERR_Success) || (Status == ERROR_MORE_DATA)) {

                        ASSERT (!NetLocked);

                        if (LOCK_NETWORK(Network)) {

                            NetLocked = TRUE;

                            if (Network->Role & ROLE_MASTER) {
                                (VOID) MergeServerList(&Network->BrowseTable,
                                                 101,
                                                 ServerList,
                                                 EntriesInList,
                                                 TotalEntriesInList );
                            }
                        }

                    }

                    if (ServerList != NULL) {
                        MIDL_user_free(ServerList);
                        ServerList = NULL;
                    }

                    if (NetLocked) {
                        UNLOCK_NETWORK(Network);
                        NetLocked = FALSE;
                    }

                    //
                    //  Retrieve the list of all the domains from the PDC.
                    //

                    Status = RxNetServerEnum(PrimaryDomainController,
                                         TransportName,
                                         101,
                                         (LPBYTE *)&ServerList,
                                         0xffffffff,
                                         &EntriesInList,
                                         &TotalEntriesInList,
                                         SV_TYPE_DOMAIN_ENUM,
                                         NULL,
                                         NULL
                                         );

                    if ((Status == NERR_Success) || (Status == ERROR_MORE_DATA)) {

                        ASSERT (!NetLocked);

                        if (LOCK_NETWORK(Network)) {

                            NetLocked = TRUE;

                            if (Network->Role & ROLE_MASTER) {
                                (VOID) MergeServerList(&Network->DomainList,
                                                 101,
                                                 ServerList,
                                                 EntriesInList,
                                                 TotalEntriesInList );
                            }
                        }

                    }

                    if (ServerList != NULL) {
                        MIDL_user_free(ServerList);
                        ServerList = NULL;
                    }


                    //
                    //  Unlock the network before calling BrWanMasterInitialize.
                    //

                    if (NetLocked) {
                        UNLOCK_NETWORK(Network);
                        NetLocked = FALSE;
                    }

                    BrWanMasterInitialize(Network);

                }   // dsgetdc


            //
            //  If we're on the PDC, we need to get the list of servers from
            //  the WINS server.
            //

#ifdef ENABLE_PSEUDO_BROWSER
            } else if ((Network->Flags & NETWORK_PDC) != 0) {
#else
            } else {
#endif
                //
                //  Ensure a GetMasterAnnouncement request is posted to the bowser.
                //

                (VOID) PostGetMasterAnnouncement ( Network );

                //
                //  We want to contact the WINS server now, so we figure out the
                //  IP address of our primary WINS server
                //

                Status = BrGetWinsServerName(&Network->NetworkName,
                                        &PrimaryWinsServerAddress,
                                        &SecondaryWinsServerAddress);
                if (Status == NERR_Success) {

                    //
                    //  Don't keep the network locked during the WINS query
                    //

                    if (NetLocked) {
                        UNLOCK_NETWORK(Network);
                        NetLocked = FALSE;
                    }

                    //
                    //  This transport supports WINS queries, so query the WINS
                    //  server to retrieve the list of domains on this adapter.
                    //

                    Status = BrQueryWinsServer(PrimaryWinsServerAddress,
                                            SecondaryWinsServerAddress,
                                            &WinsServerList,
                                            &EntriesInList,
                                            &TotalEntriesInList
                                            );

                    if (Status == NERR_Success) {

                        //
                        // Lock the network to merge the server list
                        //

                        ASSERT (!NetLocked);

                        if (LOCK_NETWORK(Network)) {
                            NetLocked = TRUE;

                            if (Network->Role & ROLE_MASTER) {

                                //
                                // Merge the list of domains from WINS into the one collected elsewhere
                                //
                                (VOID) MergeServerList(
                                            &Network->DomainList,
                                            1010,   // Special level to not overide current values
                                            WinsServerList,
                                            EntriesInList,
                                            TotalEntriesInList );
                            }
                        }
                    }

                }
            }


            //
            //  Restart the timer for this domain.
            //
            // Wait to restart it until we're almost done with this iteration.
            // Otherwise, we could end up with two copies of this routine
            // running.
            //

            Status = StartMasterBrowserTimer(Network);

            if (Status != NERR_Success) {
                BrPrint(( BR_CRITICAL,
                          "%ws: %ws: Unable to restart browser backup timer: %lx\n",
                          Network->DomainInfo->DomUnicodeDomainName,
                          Network->NetworkName.Buffer,
                          Status));
                try_return(NOTHING);
            }

        } else {

            //
            //  If it is a lan-ish transport, and we have run the master
            //  timer for enough times (ie. we've been a master
            //  for "long enough", we can toss the interim server list in the
            //  master, because the bowser driver will have enough data in its
            //  list by now.
            //

            if (Network->MasterBrowserTimerCount >= MASTER_BROWSER_LAN_TIMER_LIMIT) {

                ASSERT (NetLocked);

                //
                //  Make all the servers and domains in the interim server list
                //  go away - they aren't needed any more for a LAN-ish transport.
                //

                UninitializeInterimServerList(&Network->BrowseTable);

                ASSERT (Network->BrowseTable.EntriesRead == 0);

                ASSERT (Network->BrowseTable.TotalEntries == 0);

                UninitializeInterimServerList(&Network->DomainList);

                ASSERT (Network->DomainList.EntriesRead == 0);

                ASSERT (Network->DomainList.TotalEntries == 0);

            } else {

                //
                //  Age out servers and domains from the server list.
                //

                AgeInterimServerList(&Network->BrowseTable);

                AgeInterimServerList(&Network->DomainList);

                //
                //  Restart the timer for this domain.
                //

                Status = StartMasterBrowserTimer(Network);

                if (Status != NERR_Success) {
                    BrPrint(( BR_CRITICAL,
                              "%ws: %ws: Unable to restart browser backup timer: %lx\n",
                              Network->DomainInfo->DomUnicodeDomainName,
                              Network->NetworkName.Buffer,
                              Status));
                    try_return(NOTHING);
                }
            }

        }
try_exit:NOTHING;
    } finally {


        if (pDcInfo != NULL) {
            NetApiBufferFree((LPVOID)pDcInfo);
        }

        if (PrimaryWinsServerAddress) {
            MIDL_user_free(PrimaryWinsServerAddress);
        }

        if (SecondaryWinsServerAddress) {
            MIDL_user_free(SecondaryWinsServerAddress);
        }

        if (WinsServerList) {
            MIDL_user_free(WinsServerList);
        }

        if (NetLocked) {
            UNLOCK_NETWORK(Network);
        }

        BrDereferenceNetwork( Network );
    }
}


VOID
BrMasterAnnouncement(
    IN PVOID TimerContext
    )
/*++

Routine Description:

    This routine is called to announce the domain on the local sub-net.

Arguments:

    None.

Return Value:

    None

--*/

{
    PNETWORK Network = TimerContext;
    ULONG Periodicity;
    NET_API_STATUS Status;

#ifdef ENABLE_PSEUDO_BROWSER
    if ( BrInfo.PseudoServerLevel == BROWSER_PSEUDO ) {
        // cancel announcements for phase out black hole server
        return;
    }
#endif

    //
    // Prevent the network from being deleted while we're in this timer routine.
    //
    if ( BrReferenceNetwork( Network ) == NULL ) {
        return;
    }

    if (!LOCK_NETWORK(Network)) {
        BrDereferenceNetwork( Network );
        return;
    }


    //
    //  Make absolutely certain that the server thinks that the browser service
    //  bits for this transport are up to date.  We do NOT have to force an
    //  announcement, since theoretically, the status didn't change.
    //

    (VOID) BrUpdateNetworkAnnouncementBits( Network, (PVOID) BR_PARANOID );


    //
    // Setup the timer for the next announcement.
    //

    Periodicity = DomainAnnouncementPeriodicity[Network->MasterAnnouncementIndex];

    BrSetTimer(&Network->MasterBrowserAnnouncementTimer, Periodicity, BrMasterAnnouncement, Network);

    if (Network->MasterAnnouncementIndex != DomainAnnouncementMax) {
        Network->MasterAnnouncementIndex += 1;
    }

    //
    //  Announce this domain to the world using the current periodicity.
    //

    BrAnnounceDomain(Network, Periodicity);

    UNLOCK_NETWORK(Network);
    BrDereferenceNetwork( Network );
}


NET_API_STATUS
BrStopMaster(
    IN PNETWORK Network
    )
{
    NET_API_STATUS Status;

    //
    //  This guy is shutting down - set his role to 0 and announce.
    //

    if (!LOCK_NETWORK(Network)) {
        return NERR_InternalError;
    }

    try {

        BrPrint(( BR_MASTER,
                  "%ws: %ws: Stopping being master.\n",
                  Network->DomainInfo->DomUnicodeDomainName,
                  Network->NetworkName.Buffer));

        //
        //  When we stop being a master, we can no longer be considered a
        //  backup either, since backups maintain their server list
        //  differently than the master.
        //


        Network->Role &= ~(ROLE_MASTER | ROLE_BACKUP);

        Status = BrUpdateNetworkAnnouncementBits(Network, 0);

        if (Status != NERR_Success) {
            BrPrint(( BR_MASTER,
                      "%ws: %ws: Unable to clear master announcement bits in browser: %ld\n",
                      Network->DomainInfo->DomUnicodeDomainName,
                      Network->NetworkName.Buffer,
                      Status));

             try_return(Status);
        }


        //
        //  Stop our master related timers.
        //

        Status = BrCancelTimer(&Network->MasterBrowserAnnouncementTimer);

        ASSERT (Status == NERR_Success);

        Status = BrCancelTimer(&Network->MasterBrowserTimer);

        ASSERT (Status == NERR_Success);

try_exit:NOTHING;
    } finally {
        UNLOCK_NETWORK(Network);
    }

    return Status;

}

NET_API_STATUS
AnnounceMasterToDomainMaster(
    IN PNETWORK Network,
    IN LPWSTR ServerName
    )
{
    NET_API_STATUS Status;
    UNICODE_STRING EmulatedDomainName;
    CHAR Buffer[sizeof(MASTER_ANNOUNCEMENT)+CNLEN+1];
    PMASTER_ANNOUNCEMENT MasterAnnouncementp = (PMASTER_ANNOUNCEMENT)Buffer;

    lstrcpyA( MasterAnnouncementp->MasterAnnouncement.MasterName,
              Network->DomainInfo->DomOemComputerName );

    MasterAnnouncementp->Type = MasterAnnouncement;

    Status = SendDatagram(  BrDgReceiverDeviceHandle,
                            &Network->NetworkName,
                            &Network->DomainInfo->DomUnicodeDomainNameString,
                            ServerName,
                            ComputerName,
                            MasterAnnouncementp,
                            FIELD_OFFSET(MASTER_ANNOUNCEMENT, MasterAnnouncement.MasterName) + Network->DomainInfo->DomOemComputerNameLength+sizeof(CHAR)
                            );

    return Status;
}

NET_API_STATUS NET_API_FUNCTION
I_BrowserrResetNetlogonState(
    IN BROWSER_IDENTIFY_HANDLE ServerName
    )

/*++

Routine Description:

    This routine will reset the bowser's concept of the state of the netlogon
    service.  It is called by the UI when it promotes or demotes a DC.


Arguments:

    IN BROWSER_IDENTIFY_HANDLE ServerName - Ignored.

Return Value:

    NET_API_STATUS - The status of this request.

--*/

{
    //
    // This routine has been superceeded by I_BrowserrSetNetlogonState
    //
    return ERROR_NOT_SUPPORTED;

    UNREFERENCED_PARAMETER( ServerName );
}


NET_API_STATUS NET_API_FUNCTION
I_BrowserrSetNetlogonState(
    IN BROWSER_IDENTIFY_HANDLE ServerName,
    IN LPWSTR DomainName,
    IN LPWSTR EmulatedComputerName,
    IN DWORD Role
    )

/*++

Routine Description:

    This routine will reset the bowser's concept of the state of the netlogon
    service.  It is called by the Netlogon service when it promotes or demotes a DC.

Arguments:

    ServerName - Ignored.

    DomainName - Name of the domain whose role has changed. If the domain name specified
        isn't the primary domain or an emulated domain, an emulated domain is added.

    EmulatedComputerName - Name of the server within DomainName that's being emulated.

    Role - New role of the machine.
        Zero implies emulated domain is to be deleted.

Return Value:

    NET_API_STATUS - The status of this request.

--*/

{
    NET_API_STATUS NetStatus = NERR_Success;
    PDOMAIN_INFO DomainInfo = NULL;
    BOOLEAN ConfigCritSectLocked = FALSE;

#ifdef notdef

    // This routine no longer sets the role.

    //
    // This routine is currently disabled since it doesn't work well with
    //  the PNP logic.  Specifically,
    //
    //      When a hosted domain is created, this routine calls BrCreateNetwork.
    //      That creates a network in the bowser.  The bowser PNPs that up.
    //      HandlePnpMessage tries to create the transport on all hosted domains.
    //      Of course, that fails since all the transports exist.
    //      This is just wasted effort.
    //
    //  However,
    //      When a hosted domain is deleted, we delete the transport. The bowser
    //      PNPs that up to us.  HandlePnpMessage then deletes the transport for
    //      all hosted domains.
    //
    // I think the best solution to this would be for the browser to flag
    // the IOCTL_LMDR_BIND_TO_TRANSPORT_DOM calls it makes to the bowser.  The
    // bowser would NOT PNP such creations up to the browser or netlogon.
    // (Be careful.  Netlogon depends on getting the notification that NwLnkIpx
    // was created by the browser.  Perhaps we can let that one through.)
    //



    //
    // Perform access validation on the caller.
    //

    NetStatus = NetpAccessCheck(
            BrGlobalBrowserSecurityDescriptor,     // Security descriptor
            BROWSER_CONTROL_ACCESS,                // Desired access
            &BrGlobalBrowserInfoMapping );         // Generic mapping

    if ( NetStatus != NERR_Success) {

        BrPrint((BR_CRITICAL,
                "I_BrowserrSetNetlogonState failed NetpAccessCheck\n" ));
        return ERROR_ACCESS_DENIED;
    }


    if (!BrInfo.IsLanmanNt) {
        NetStatus = NERR_NotPrimary;
        goto Cleanup;
    }

    //
    // See if we're handling the specified domain.
    //

    DomainInfo = BrFindDomain( DomainName, FALSE );

    if ( DomainInfo == NULL ) {

        //
        // Try to create the domain.
        //

        if ( EmulatedComputerName == NULL ||
             Role == 0 ||
             (Role & BROWSER_ROLE_AVOID_CREATING_DOMAIN) != 0 ) {
            NetStatus = ERROR_NO_SUCH_DOMAIN;
            goto Cleanup;
        }

        NetStatus = BrCreateDomainInWorker(
                        DomainName,
                        EmulatedComputerName,
                        TRUE );

        if ( NetStatus != NERR_Success ) {
            goto Cleanup;
        }

        //
        // Find the newly created domain
        //
        DomainInfo = BrFindDomain( DomainName, FALSE );

        if ( DomainInfo == NULL ) {
            NetStatus = ERROR_NO_SUCH_DOMAIN;
            goto Cleanup;
        }
    }

    //
    // Delete the Emulated domain.
    //

    EnterCriticalSection(&BrInfo.ConfigCritSect);
    ConfigCritSectLocked = TRUE;

    if ( Role == 0 ) {

        //
        // Don't allow the primary domain to be deleted.
        //

        if ( !DomainInfo->IsEmulatedDomain ) {
            NetStatus = ERROR_NO_SUCH_DOMAIN;
            goto Cleanup;
        }

        BrDeleteDomain( DomainInfo );

    }

    LeaveCriticalSection(&BrInfo.ConfigCritSect);
    ConfigCritSectLocked = FALSE;


    //
    // Free locally used resources
    //
Cleanup:

    if ( ConfigCritSectLocked ) {
        LeaveCriticalSection(&BrInfo.ConfigCritSect);
    }

    if ( DomainInfo != NULL ) {
        BrDereferenceDomain( DomainInfo );
    }
    return NetStatus;
#endif // notdef
    return ERROR_NOT_SUPPORTED;

}


NET_API_STATUS NET_API_FUNCTION
I_BrowserrQueryEmulatedDomains (
    IN LPTSTR ServerName OPTIONAL,
    IN OUT PBROWSER_EMULATED_DOMAIN_CONTAINER EmulatedDomains
    )

/*++

Routine Description:

    Enumerate the emulated domain list.

Arguments:

    ServerName - Supplies the name of server to execute this function

    EmulatedDomains - Returns a pointer to a an allocated array of emulated domain
        information.

Return Value:

    NET_API_STATUS - NERR_Success or reason for failure.

--*/
{
    NET_API_STATUS NetStatus;

    PBROWSER_EMULATED_DOMAIN Domains = NULL;
    PLIST_ENTRY DomainEntry;
    PDOMAIN_INFO DomainInfo;
    DWORD BufferSize;
    DWORD Index;
    LPBYTE Where;
    DWORD EntryCount;

    //
    // Perform access validation on the caller.
    //

    NetStatus = NetpAccessCheck(
            BrGlobalBrowserSecurityDescriptor,     // Security descriptor
            BROWSER_QUERY_ACCESS,                  // Desired access
            &BrGlobalBrowserInfoMapping );         // Generic mapping

    if ( NetStatus != NERR_Success) {

        BrPrint((BR_CRITICAL,
                "I_BrowserrQueryEmulatedDomains failed NetpAccessCheck\n" ));
        return ERROR_ACCESS_DENIED;
    }

    // Do not accept pre-allocated IN param, since
    // we overwrite the pointer & this can lead to a mem leak.
    // (security attack defence).
    if ( EmulatedDomains->EntriesRead != 0 ||
         EmulatedDomains->Buffer ) {
        return ERROR_INVALID_PARAMETER;
    }
    ASSERT ( EmulatedDomains->EntriesRead == 0 );
    ASSERT ( EmulatedDomains->Buffer == NULL );

    //
    // Initialization
    //

    EnterCriticalSection(&NetworkCritSect);

    //
    // Loop through the list of emulated domains determining the size of the
    //  return buffer.
    //

    BufferSize = 0;
    EntryCount = 0;

    for (DomainEntry = ServicedDomains.Flink ;
         DomainEntry != &ServicedDomains;
         DomainEntry = DomainEntry->Flink ) {

        DomainInfo = CONTAINING_RECORD(DomainEntry, DOMAIN_INFO, Next);

        if ( DomainInfo->IsEmulatedDomain ) {
            BufferSize += sizeof(BROWSER_EMULATED_DOMAIN) +
                          DomainInfo->DomUnicodeDomainNameString.Length + sizeof(WCHAR) +
                          DomainInfo->DomUnicodeComputerNameLength * sizeof(WCHAR) + sizeof(WCHAR);
            EntryCount ++;
        }

    }

    //
    // Allocate the return buffer.
    //

    Domains = MIDL_user_allocate( BufferSize );

    if ( Domains == NULL ) {
        NetStatus = ERROR_NOT_ENOUGH_MEMORY;
        goto Cleanup;
    }


    //
    // Copy the information into the buffer
    //

    Index = 0;
    Where = (LPBYTE)(Domains+EntryCount);

    for (DomainEntry = ServicedDomains.Flink ;
         DomainEntry != &ServicedDomains;
         DomainEntry = DomainEntry->Flink ) {

        DomainInfo = CONTAINING_RECORD(DomainEntry, DOMAIN_INFO, Next);

        if ( DomainInfo->IsEmulatedDomain ) {

            Domains[Index].DomainName = (LPWSTR)Where;
            wcscpy( (LPWSTR) Where, DomainInfo->DomUnicodeDomainNameString.Buffer );
            Where += DomainInfo->DomUnicodeDomainNameString.Length + sizeof(WCHAR);

            Domains[Index].EmulatedServerName = (LPWSTR)Where;
            wcscpy( (LPWSTR) Where, DomainInfo->DomUnicodeComputerName );
            Where += DomainInfo->DomUnicodeComputerNameLength * sizeof(WCHAR) + sizeof(WCHAR);

            Index ++;
        }

    }

    //
    // Success
    //

    EmulatedDomains->Buffer = (PVOID) Domains;
    EmulatedDomains->EntriesRead = EntryCount;
    NetStatus = NERR_Success;


Cleanup:
    LeaveCriticalSection(&NetworkCritSect);

    return NetStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\browser\server\browsdom.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    browslst.c

Abstract:

    This module contains the worker routines for managing domain lists
    for the browser service

Author:

    Larry Osterman (larryo) 25-Mar-1992

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop

//-------------------------------------------------------------------//
//                                                                   //
// Local function prototypes                                         //
//                                                                   //
//-------------------------------------------------------------------//




=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\browser\server\brmain.h ===
/*++

Copyright (c) 1991 Microsoft Corporation

Module Name:

    brmain.h

Abstract:

    Private header file which defines the global data which is used for
    communication between the service control handler and the
    rest of the NT Workstation service.

Author:

    Rita Wong (ritaw) 06-May-1991

Revision History:

--*/

#ifndef _BRMAIN_INCLUDED_
#define _BRMAIN_INCLUDED_

#include <brnames.h>              // Service interface names

//
// Time for the sender of a start or stop request to the Workstation
// service to wait (in milliseconds) before checking on the
// Workstation service again to see if it is done.
//
#define BR_WAIT_HINT_TIME                    45000  // 45 seconds

//
// Defines to indicate how far we managed to initialize the Browser
// service before an error is encountered and the extent of clean up needed
//

#define BR_TERMINATE_EVENT_CREATED           0x00000001
#define BR_DEVICES_INITIALIZED               0x00000002
#define BR_RPC_SERVER_STARTED                0x00000004
#define BR_THREADS_STARTED                   0x00000008
#define BR_NETWORKS_INITIALIZED              0x00000010
#define BR_BROWSER_INITIALIZED               0x00000020
#define BR_CONFIG_INITIALIZED                0x00000040
#define BR_NETBIOS_INITIALIZED               0x00000100
#define BR_DOMAINS_INITIALIZED               0x00000200



//-------------------------------------------------------------------//
//                                                                   //
// Type definitions                                                  //
//                                                                   //
//-------------------------------------------------------------------//

typedef struct _BR_GLOBAL_DATA {

    //
    // Workstation service status
    //
    SERVICE_STATUS Status;

    //
    // Service status handle
    //
    SERVICE_STATUS_HANDLE StatusHandle;

    //
    // When the control handler is asked to stop the Workstation service,
    // it signals this event to notify all threads of the Workstation
    // service to terminate.
    //
    HANDLE TerminateNowEvent;

    HANDLE EventHandle;

} BR_GLOBAL_DATA, *PBR_GLOBAL_DATA;

extern BR_GLOBAL_DATA BrGlobalData;

extern PSVCHOST_GLOBAL_DATA BrLmsvcsGlobalData;

extern HANDLE BrGlobalEventlogHandle;

extern
ULONG
BrDefaultRole;

#define BROWSER_SERVICE_BITS_OF_INTEREST \
            ( SV_TYPE_POTENTIAL_BROWSER | \
              SV_TYPE_BACKUP_BROWSER | \
              SV_TYPE_MASTER_BROWSER | \
              SV_TYPE_DOMAIN_MASTER )

ULONG
BrGetBrowserServiceBits(
    IN PNETWORK Network
    );

NET_API_STATUS
BrUpdateAnnouncementBits(
    IN PDOMAIN_INFO DomainInfo OPTIONAL,
    IN ULONG Flags
    );


//
// Flags to BrUpdateNetworkAnnouncementBits
//
#define BR_SHUTDOWN 0x00000001
#define BR_PARANOID 0x00000002

NET_API_STATUS
BrUpdateNetworkAnnouncementBits(
    IN PNETWORK Network,
    IN PVOID Context
    );

NET_API_STATUS
BrGiveInstallHints(
    DWORD NewState
    );

NET_API_STATUS
BrShutdownBrowserForNet(
    IN PNETWORK Network,
    IN PVOID Context
    );

NET_API_STATUS
BrElectMasterOnNet(
    IN PNETWORK Network,
    IN PVOID Context
    );

#endif // ifndef _BRMAIN_INCLUDED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\browser\server\brmain.c ===
/*++

Copyright (c) 1990-1992  Microsoft Corporation

Module Name:

    brmain.c

Abstract:

    This is the main routine for the NT LAN Manager Browser service.

Author:

    Larry Osterman (LarryO)  3-23-92

Environment:

    User Mode - Win32

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop
#if DBG
#endif

//-------------------------------------------------------------------//
//                                                                   //
// Local structure definitions                                       //
//                                                                   //
//-------------------------------------------------------------------//

ULONG
UpdateAnnouncementPeriodicity[] = {1*60*1000, 2*60*1000, 5*60*1000, 10*60*1000, 15*60*1000, 30*60*1000, 60*60*1000};

ULONG
UpdateAnnouncementMax = (sizeof(UpdateAnnouncementPeriodicity) / sizeof(ULONG)) - 1;

//-------------------------------------------------------------------//
//                                                                   //
// Global variables                                                  //
//                                                                   //
//-------------------------------------------------------------------//

BR_GLOBAL_DATA
BrGlobalData = {0};

ULONG
BrDefaultRole = {0};

PSVCHOST_GLOBAL_DATA     BrLmsvcsGlobalData;

HANDLE BrGlobalEventlogHandle;

//-------------------------------------------------------------------//
//                                                                   //
// Function prototypes                                               //
//                                                                   //
//-------------------------------------------------------------------//

NET_API_STATUS
BrInitializeBrowser(
    OUT LPDWORD BrInitState
    );

NET_API_STATUS
BrInitializeBrowserService(
    OUT LPDWORD BrInitState
    );

VOID
BrUninitializeBrowser(
    IN DWORD BrInitState
    );
VOID
BrShutdownBrowser(
    IN NET_API_STATUS ErrorCode,
    IN DWORD BrInitState
    );

VOID
BrowserControlHandler(
    IN DWORD Opcode
    );


VOID
SvchostPushServiceGlobals (
    PSVCHOST_GLOBAL_DATA    pGlobals
    )
{
    BrLmsvcsGlobalData = pGlobals;
}



VOID
ServiceMain (     // (BROWSER_main)
    DWORD NumArgs,
    LPTSTR *ArgsArray
    )
/*++

Routine Description:

    This is the main routine of the Browser Service which registers
    itself as an RPC server and notifies the Service Controller of the
    Browser service control entry point.

Arguments:

    NumArgs - Supplies the number of strings specified in ArgsArray.

    ArgsArray -  Supplies string arguments that are specified in the
        StartService API call.  This parameter is ignored by the
        Browser service.

Return Value:

    None.

--*/
{
    NET_API_STATUS NetStatus;
    DWORD BrInitState = 0;
    BrGlobalBrowserSecurityDescriptor = NULL;

    UNREFERENCED_PARAMETER(NumArgs);
    UNREFERENCED_PARAMETER(ArgsArray);

    //
    // Make sure svchost.exe gave us the global data
    //
    ASSERT(BrLmsvcsGlobalData != NULL);

    NetStatus = BrInitializeBrowserService(&BrInitState);


    //
    //  Process requests in this thread, and wait for termination.
    //
    if ( NetStatus == NERR_Success) {

        //
        //  Set the browser threads to time critical priority.
        //

        SetThreadPriority(GetCurrentThread(), THREAD_PRIORITY_ABOVE_NORMAL);


        BrWorkerThread((PVOID)-1);
    }

    BrShutdownBrowser(
        NetStatus,
        BrInitState
        );

    return;
}



NET_API_STATUS
BrInitializeBrowserService(
    OUT LPDWORD BrInitState
    )
/*++

Routine Description:

    This function initializes the Browser service.

Arguments:

    BrInitState - Returns a flag to indicate how far we got with initializing
        the Browser service before an error occured.

Return Value:

    NET_API_STATUS - NERR_Success or reason for failure.

--*/
{
    NET_API_STATUS Status;
    NTSTATUS NtStatus;

    //
    // Initialize event logging
    //

    BrGlobalEventlogHandle = NetpEventlogOpen ( SERVICE_BROWSER,
                                                2*60*60*1000 ); // 2 hours

    if ( BrGlobalEventlogHandle == NULL ) {
        BrPrint((BR_CRITICAL, "Cannot NetpEventlogOpen\n" ));
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    //
    // Initialize all the status fields so that subsequent calls to
    // SetServiceStatus need to only update fields that changed.
    //
    BrGlobalData.Status.dwServiceType = SERVICE_WIN32;
    BrGlobalData.Status.dwCurrentState = SERVICE_START_PENDING;
    BrGlobalData.Status.dwControlsAccepted = 0;
    BrGlobalData.Status.dwCheckPoint = 0;
    BrGlobalData.Status.dwWaitHint = BR_WAIT_HINT_TIME;

    SET_SERVICE_EXITCODE(
        NO_ERROR,
        BrGlobalData.Status.dwWin32ExitCode,
        BrGlobalData.Status.dwServiceSpecificExitCode
        );

#if DBG
    BrInitializeTraceLog();
#endif

    BrPrint(( BR_INIT, "Browser starting\n"));

    //
    // Initialize Browser to receive service requests by registering the
    // control handler.
    //
    if ((BrGlobalData.StatusHandle = RegisterServiceCtrlHandler(
                                         SERVICE_BROWSER,
                                         BrowserControlHandler
                                         )) == (SERVICE_STATUS_HANDLE) 0) {

        Status = GetLastError();
        BrPrint(( BR_CRITICAL, "Cannot register control handler "
                     FORMAT_API_STATUS "\n", Status));

        return Status;
    }

    //
    // Create an event which is used by the service control handler to notify
    // the Browser service that it is time to terminate.
    //

    if ((BrGlobalData.TerminateNowEvent =
             CreateEvent(
                 NULL,                // Event attributes
                 TRUE,                // Event must be manually reset
                 FALSE,
                 NULL                 // Initial state not signalled
                 )) == NULL) {

        Status = GetLastError();

        BrPrint(( BR_CRITICAL, "Cannot create termination event "
                     FORMAT_API_STATUS "\n", Status));

        return Status;
    }
    (*BrInitState) |= BR_TERMINATE_EVENT_CREATED;

    //
    // Notify the Service Controller for the first time that we are alive
    // and we are start pending
    //

    if ((Status = BrGiveInstallHints( SERVICE_START_PENDING )) != NERR_Success) {
        BrPrint(( BR_CRITICAL, "SetServiceStatus error "
                     FORMAT_API_STATUS "\n", Status));

        return Status;
    }





    //
    // Create well known SIDs for browser.dll
    //

    NtStatus =  NetpCreateWellKnownSids( NULL );

    if( !NT_SUCCESS( NtStatus ) ) {
        Status = NetpNtStatusToApiStatus( NtStatus );
        BrPrint(( BR_CRITICAL, "NetpCreateWellKnownSids error "
                     FORMAT_API_STATUS "\n", Status));

        return Status;
    }


    //
    // Create the security descriptors we'll use for the APIs
    //

    NtStatus = BrCreateBrowserObjects();

    if( !NT_SUCCESS( NtStatus ) ) {
        Status = NetpNtStatusToApiStatus( NtStatus );
        BrPrint(( BR_CRITICAL, "BrCreateBrowserObjects error "
                     FORMAT_API_STATUS "\n", Status));

        return Status;
    }


    //
    // Open a handle to the driver.
    //
    if ((Status = BrOpenDgReceiver()) != NERR_Success) {
        BrPrint(( BR_CRITICAL, "BrOpenDgReceiver error "
                     FORMAT_API_STATUS "\n", Status));

        return Status;
    }

    BrPrint(( BR_INIT, "Devices initialized.\n"));
    (*BrInitState) |= BR_DEVICES_INITIALIZED;

    //
    // Enable PNP to start queueing PNP notifications in the bowser driver.
    //  We won't actually get any notifications until we later call
    //  PostWaitForPnp ().
    //

    if ((Status = BrEnablePnp( TRUE )) != NERR_Success) {
        BrPrint(( BR_CRITICAL, "BrEnablePnp error "
                     FORMAT_API_STATUS "\n", Status));

        return Status;
    }

    BrPrint(( BR_INIT, "PNP initialized.\n"));

    //
    // Initialize NetBios synchronization with the service controller.
    //

    BrLmsvcsGlobalData->NetBiosOpen();
    (*BrInitState) |= BR_NETBIOS_INITIALIZED;

    //
    //  Read the configuration information to initialize the browser service.
    //

    if ((Status = BrInitializeBrowser(BrInitState)) != NERR_Success) {

        BrPrint(( BR_CRITICAL, "Cannot start browser "
                     FORMAT_API_STATUS "\n", Status));

        if (Status == NERR_ServiceInstalled) {
            Status = NERR_WkstaInconsistentState;
        }
        return Status;
    }

    BrPrint(( BR_INIT, "Browser initialized.\n"));
    (*BrInitState) |= BR_BROWSER_INITIALIZED;

    //
    // Service install still pending.
    //
    (void) BrGiveInstallHints( SERVICE_START_PENDING );


    //
    // Initialize the browser service to receive RPC requests
    //
    if ((Status = BrLmsvcsGlobalData->StartRpcServer(
                      BROWSER_INTERFACE_NAME,
                      browser_ServerIfHandle
                      )) != NERR_Success) {

        BrPrint(( BR_CRITICAL, "Cannot start RPC server "
                     FORMAT_API_STATUS "\n", Status));

        return Status;
    }

    (*BrInitState) |= BR_RPC_SERVER_STARTED;

    //
    //  Update our announcement bits based on our current role.
    //
    //  This will force the server to announce itself.  It will also update
    //  the browser information in the driver.
    //
    //

    if ((Status = BrUpdateAnnouncementBits( NULL, BR_PARANOID )) != NERR_Success) {
        BrPrint(( BR_CRITICAL, "BrUpdateAnnouncementBits error "
                     FORMAT_API_STATUS "\n", Status));
        return Status;
    }

    BrPrint(( BR_INIT, "Network status updated.\n"));

    //
    // We are done with starting the browser service.  Tell Service
    // Controller our new status.
    //


    if ((Status = BrGiveInstallHints( SERVICE_RUNNING )) != NERR_Success) {
        BrPrint(( BR_CRITICAL, "SetServiceStatus error "
                     FORMAT_API_STATUS "\n", Status));
        return Status;
    }

    if ((Status = PostWaitForPnp()) != NERR_Success) {
        BrPrint(( BR_CRITICAL, "PostWaitForPnp error "
                     FORMAT_API_STATUS "\n", Status));
        return Status;
    }

    BrPrint(( BR_MAIN, "Successful Initialization\n"));

    return NERR_Success;
}

NET_API_STATUS
BrInitializeBrowser(
    OUT LPDWORD BrInitState
    )

/*++

Routine Description:

    This function shuts down the Browser service.

Arguments:

    ErrorCode - Supplies the error code of the failure

    BrInitState - Supplies a flag to indicate how far we got with initializing
        the Browser service before an error occured, thus the amount of
        clean up needed.

Return Value:

    None.

--*/
{
    NET_API_STATUS NetStatus;
    SERVICE_STATUS ServiceStatus;

    //
    //  The browser depends on the following services being started:
    //
    //      WORKSTATION (to initialize the bowser driver)
    //      SERVER (to receive remote APIs)
    //
    //  Check to make sure that the services are started.
    //

    try{

        if ((NetStatus = CheckForService(SERVICE_WORKSTATION, &ServiceStatus)) != NERR_Success) {
            LPWSTR SubStrings[2];
            CHAR ServiceStatusString[10];
            WCHAR ServiceStatusStringW[10];

            SubStrings[0] = SERVICE_WORKSTATION;

            _ultoa(ServiceStatus.dwCurrentState, ServiceStatusString, 10);

            mbstowcs(ServiceStatusStringW, ServiceStatusString, 10);

            SubStrings[1] = ServiceStatusStringW;

            BrLogEvent(EVENT_BROWSER_DEPENDANT_SERVICE_FAILED, NetStatus, 2, SubStrings);

            try_return ( NetStatus );
        }

        if ((NetStatus = CheckForService(SERVICE_SERVER, &ServiceStatus)) != NERR_Success) {
            LPWSTR SubStrings[2];
            CHAR ServiceStatusString[10];
            WCHAR ServiceStatusStringW[10];

            SubStrings[0] = SERVICE_SERVER;
            _ultoa(ServiceStatus.dwCurrentState, ServiceStatusString, 10);

            mbstowcs(ServiceStatusStringW, ServiceStatusString, 10);

            SubStrings[1] = ServiceStatusStringW;

            BrLogEvent(EVENT_BROWSER_DEPENDANT_SERVICE_FAILED, NetStatus, 2, SubStrings);

            try_return ( NetStatus );
        }

        BrPrint(( BR_INIT, "Dependant services are running.\n"));

        //
        //  We now know that our dependant services are started.
        //
        //  Look up our configuration information.
        //

        if ((NetStatus = BrGetBrowserConfiguration()) != NERR_Success) {
            try_return ( NetStatus );
        }

        BrPrint(( BR_INIT, "Configuration read.\n"));

        (*BrInitState) |= BR_CONFIG_INITIALIZED;

        //
        //  Initialize the browser statistics now.
        //

        NumberOfServerEnumerations = 0;

        NumberOfDomainEnumerations = 0;

        NumberOfOtherEnumerations = 0;

        NumberOfMissedGetBrowserListRequests = 0;

        InitializeCriticalSection(&BrowserStatisticsLock);

        //
        // MaintainServerList == -1 means No
        //

        if (BrInfo.MaintainServerList == -1) {
            BrPrint(( BR_CRITICAL, "MaintainServerList value set to NO.  Stopping\n"));

            try_return ( NetStatus = NERR_BrowserConfiguredToNotRun );
        }


        //
        // Initialize the worker threads.
        //

        (void) BrGiveInstallHints( SERVICE_START_PENDING );
        if ((NetStatus = BrWorkerInitialization()) != NERR_Success) {
            try_return ( NetStatus );
        }

        BrPrint(( BR_INIT, "Worker threads created.\n"));

        (*BrInitState) |= BR_THREADS_STARTED;

        //
        // Initialize the networks module
        //

        (void) BrGiveInstallHints( SERVICE_START_PENDING );
        BrInitializeNetworks();
        (*BrInitState) |= BR_NETWORKS_INITIALIZED;


        //
        // Initialize the Domains module (and create networks for primary domain)
        //

        (void) BrGiveInstallHints( SERVICE_START_PENDING );
        NetStatus = BrInitializeDomains();
        if ( NetStatus != NERR_Success ) {
            try_return ( NetStatus );
        }
        (*BrInitState) |= BR_DOMAINS_INITIALIZED;

        NetStatus = NERR_Success;
try_exit:NOTHING;
    } finally {

#if DBG
        if ( NetStatus != NERR_Success ) {
            KdPrint( ("[Browser.dll]: Error <%lu>. Failed to initialize browser\n",
                      NetStatus ) );
        }
#endif
    }
    return NetStatus;
}

VOID
BrUninitializeBrowser(
    IN DWORD BrInitState
    )
/*++

Routine Description:

    This function shuts down the parts of the browser service started by
    BrInitializeBrowser.

Arguments:

    BrInitState - Supplies a flag to indicate how far we got with initializing
        the Browser service before an error occured, thus the amount of
        clean up needed.

Return Value:

    None.

--*/
{
    if (BrInitState & BR_CONFIG_INITIALIZED) {
        BrDeleteConfiguration(BrInitState);
    }

    if (BrInitState & BR_DOMAINS_INITIALIZED) {
        BrUninitializeDomains();
    }

    if (BrInitState & BR_NETWORKS_INITIALIZED) {
        BrUninitializeNetworks(BrInitState);
    }

    DeleteCriticalSection(&BrowserStatisticsLock);

}

NET_API_STATUS
BrElectMasterOnNet(
    IN PNETWORK Network,
    IN PVOID Context
    )
{
    DWORD Event = PtrToUlong(Context);
    PWSTR SubString[1];
    REQUEST_ELECTION ElectionRequest;

    if (!LOCK_NETWORK(Network)) {
        return NERR_InternalError;
    }

    if (!(Network->Flags & NETWORK_RAS)) {

        //
        //  Indicate we're forcing an election in the event log.
        //

        SubString[0] = Network->NetworkName.Buffer;

        BrLogEvent(Event,
                   STATUS_SUCCESS,
                   1 | NETP_ALLOW_DUPLICATE_EVENTS,
                   SubString);

        //
        //  Force an election on this net.
        //

        ElectionRequest.Type = Election;

        ElectionRequest.ElectionRequest.Version = 0;
        ElectionRequest.ElectionRequest.Criteria = 0;
        ElectionRequest.ElectionRequest.TimeUp = 0;
        ElectionRequest.ElectionRequest.MustBeZero = 0;
        ElectionRequest.ElectionRequest.ServerName[0] = '\0';

        SendDatagram( BrDgReceiverDeviceHandle,
                      &Network->NetworkName,
                      &Network->DomainInfo->DomUnicodeDomainNameString,
                      Network->DomainInfo->DomUnicodeDomainName,
                      BrowserElection,
                      &ElectionRequest,
                      sizeof(ElectionRequest));

    }
    UNLOCK_NETWORK(Network);

    return NERR_Success;
}


NET_API_STATUS
BrShutdownBrowserForNet(
    IN PNETWORK Network,
    IN PVOID Context
    )
{
    NET_API_STATUS NetStatus;

    if (!LOCK_NETWORK(Network)) {
        return NERR_InternalError;
    }

    NetStatus = BrUpdateNetworkAnnouncementBits(Network, (PVOID)BR_SHUTDOWN );

    if ( NetStatus != NERR_Success ) {
        BrPrint(( BR_CRITICAL,
                  "%ws: %ws: BrShutdownBrowserForNet: Cannot BrUpdateNetworkAnnouncementBits %ld\n",
                  Network->DomainInfo->DomUnicodeDomainName,
                  Network->NetworkName.Buffer,
                  NetStatus ));
    }

    //
    //  Force an election if we are the master for this network - this will
    //  cause someone else to become master.
    //

    if ( Network->Role & ROLE_MASTER ) {
        BrElectMasterOnNet(Network, (PVOID)EVENT_BROWSER_ELECTION_SENT_LANMAN_NT_STOPPED);
    }

    UNLOCK_NETWORK(Network);

    //
    // Continue with next network regardless of success or failure of this one.
    //
    return NERR_Success;
}

VOID
BrShutdownBrowser (
    IN NET_API_STATUS ErrorCode,
    IN DWORD BrInitState
    )
/*++

Routine Description:

    This function shuts down the Browser service.

Arguments:

    ErrorCode - Supplies the error code of the failure

    BrInitState - Supplies a flag to indicate how far we got with initializing
        the Browser service before an error occured, thus the amount of
        clean up needed.

Return Value:

    None.

--*/
{
    if (BrInitState & BR_RPC_SERVER_STARTED) {
        //
        // Stop the RPC server
        //
        BrLmsvcsGlobalData->StopRpcServer(browser_ServerIfHandle);
    }


    //
    // Don't need to ask redirector to unbind from its transports when
    // cleaning up because the redirector will tear down the bindings when
    // it stops.
    //

    if (BrInitState & BR_DEVICES_INITIALIZED) {

        //
        // Disable PNP to prevent any new networks from being created.
        //

        BrEnablePnp( FALSE );

        //
        // Delete any networks.
        //

        if (BrInitState & BR_NETWORKS_INITIALIZED) {
            BrEnumerateNetworks(BrShutdownBrowserForNet, NULL );
        }

        //
        // Shut down the datagram receiver.
        //
        //  This will cancel all I/O outstanding on the browser for this
        //  handle.
        //

        BrShutdownDgReceiver();
    }

    //
    //  Clean up the browser threads.
    //
    //  This will guarantee that there are no operations outstanding in
    //  the browser when it is shut down.
    //

    if (BrInitState & BR_THREADS_STARTED) {
        BrWorkerKillThreads();
    }

    if (BrInitState & BR_BROWSER_INITIALIZED) {
        //
        //  Shut down the browser (including removing networks).
        //
        BrUninitializeBrowser(BrInitState);
    }

    //
    //  Now that we're sure no one will try to use the worker threads,
    //      Unitialize the subsystem.
    //

    if (BrInitState & BR_THREADS_STARTED) {
        BrWorkerTermination();
    }


    if (BrInitState & BR_TERMINATE_EVENT_CREATED) {
        //
        // Close handle to termination event
        //
        CloseHandle(BrGlobalData.TerminateNowEvent);
    }

    if (BrInitState & BR_DEVICES_INITIALIZED) {
        NtClose(BrDgReceiverDeviceHandle);

        BrDgReceiverDeviceHandle = NULL;
    }

    //
    // Tell service controller we are done using NetBios.
    //
    if (BrInitState & BR_NETBIOS_INITIALIZED) {
        BrLmsvcsGlobalData->NetBiosClose();
    }



    //
    // Delete well known SIDs if they are allocated already.
    //

    NetpFreeWellKnownSids();


    if ( BrGlobalBrowserSecurityDescriptor != NULL ) {
        NetpDeleteSecurityObject( &BrGlobalBrowserSecurityDescriptor );
        BrGlobalBrowserSecurityDescriptor = NULL;
    }

#if DBG
    BrUninitializeTraceLog();
#endif


    //
    // Free the list of events that have already been logged.
    //

    NetpEventlogClose ( BrGlobalEventlogHandle );
    BrGlobalEventlogHandle = NULL;

    //
    // We are done with cleaning up.  Tell Service Controller that we are
    // stopped.
    //

    SET_SERVICE_EXITCODE(
        ErrorCode,
        BrGlobalData.Status.dwWin32ExitCode,
        BrGlobalData.Status.dwServiceSpecificExitCode
        );

    (void) BrGiveInstallHints( SERVICE_STOPPED );
}


NET_API_STATUS
BrGiveInstallHints(
    DWORD NewState
    )
/*++

Routine Description:

    This function updates the Browser service status with the Service
    Controller.

Arguments:

    NewState - State to tell the service contoller

Return Value:

    NET_API_STATUS - NERR_Success or reason for failure.

--*/
{
    NET_API_STATUS status = NERR_Success;

    //
    // If we're not starting,
    //  we don't need this install hint.
    //

    if ( BrGlobalData.Status.dwCurrentState != SERVICE_START_PENDING &&
         NewState == SERVICE_START_PENDING ) {
        return NERR_Success;
    }


    //
    // Update our state for the service controller.
    //

    BrGlobalData.Status.dwCurrentState = NewState;
    switch ( NewState ) {
    case SERVICE_RUNNING:
        BrGlobalData.Status.dwControlsAccepted = SERVICE_ACCEPT_STOP;
        //
        // On DCs, shut down cleanly.
        //
        if (BrInfo.IsLanmanNt) {
            BrGlobalData.Status.dwControlsAccepted |= SERVICE_ACCEPT_SHUTDOWN;
        }
        BrGlobalData.Status.dwCheckPoint = 0;
        BrGlobalData.Status.dwWaitHint = 0;
        break;

    case SERVICE_START_PENDING:
        BrGlobalData.Status.dwCheckPoint++;
        break;

    case SERVICE_STOPPED:
        BrGlobalData.Status.dwCurrentState = SERVICE_STOPPED;
        BrGlobalData.Status.dwControlsAccepted = 0;
        BrGlobalData.Status.dwCheckPoint = 0;
        BrGlobalData.Status.dwWaitHint = 0;
        break;

    case SERVICE_STOP_PENDING:
        BrGlobalData.Status.dwCurrentState = SERVICE_STOP_PENDING;
        BrGlobalData.Status.dwCheckPoint = 1;
        BrGlobalData.Status.dwWaitHint = BR_WAIT_HINT_TIME;
        break;
    }


    //
    // Tell the service controller our current state.
    //

    if (BrGlobalData.StatusHandle == (SERVICE_STATUS_HANDLE) 0) {
        BrPrint(( BR_CRITICAL,
            "Cannot call SetServiceStatus, no status handle.\n"
            ));

        return ERROR_INVALID_HANDLE;
    }

    if (! SetServiceStatus(BrGlobalData.StatusHandle, &BrGlobalData.Status)) {

        status = GetLastError();

        BrPrint(( BR_CRITICAL, "SetServiceStatus error %lu\n", status));
    }

    return status;
}



NET_API_STATUS
BrUpdateAnnouncementBits(
    IN PDOMAIN_INFO DomainInfo OPTIONAL,
    IN ULONG Flags
    )
/*++

Routine Description:

    This will update the service announcement bits appropriately depending on
    the role of the browser server.

Arguments:

    DomainInfo - Domain the announcement is to be made for
        NULL implies the primary domain.

    Flags - Control flags to pass to BrUpdateNetworkAnnouncement

Return Value:

    Status - Status of the update..

--*/
{
    NET_API_STATUS Status;

    Status = BrEnumerateNetworksForDomain(DomainInfo, BrUpdateNetworkAnnouncementBits, ULongToPtr(Flags));

    return Status;
}

ULONG
BrGetBrowserServiceBits(
    IN PNETWORK Network
    )
{
    DWORD ServiceBits = 0;
    if (Network->Role & ROLE_POTENTIAL_BACKUP) {
        ServiceBits |= SV_TYPE_POTENTIAL_BROWSER;
    }

    if (Network->Role & ROLE_BACKUP) {
        ServiceBits |= SV_TYPE_BACKUP_BROWSER;
    }

    if (Network->Role & ROLE_MASTER) {
        ServiceBits |= SV_TYPE_MASTER_BROWSER;
    }

    if (Network->Role & ROLE_DOMAINMASTER) {
        ServiceBits |= SV_TYPE_DOMAIN_MASTER;

        ASSERT (ServiceBits & SV_TYPE_BACKUP_BROWSER);

    }

    return ServiceBits;

}

VOID
BrUpdateAnnouncementTimerRoutine(
    IN PVOID TimerContext
    )
/*++

Routine Description:

    This routine is called periodically until we've successfully updated
    our announcement status.

Arguments:

    None.

Return Value:

    None

--*/

{
    PNETWORK Network = TimerContext;
    ULONG Periodicity;
    NET_API_STATUS Status;

    //
    // Prevent the network from being deleted while we're in this timer routine.
    //
    if ( BrReferenceNetwork( Network ) == NULL ) {
        return;
    }

    if (!LOCK_NETWORK(Network)) {
        return;
    }

    BrPrint(( BR_NETWORK,
              "%ws: %ws: Periodic try to BrUpdateNetworkAnnouncementBits\n",
              Network->DomainInfo->DomUnicodeDomainName,
              Network->NetworkName.Buffer ));

    //
    // If we still need an announcement,
    //  do it now.
    //

    if ( Network->Flags & NETWORK_ANNOUNCE_NEEDED ) {
        (VOID) BrUpdateNetworkAnnouncementBits( Network, (PVOID) BR_PARANOID );
    }


    UNLOCK_NETWORK(Network);
    BrDereferenceNetwork( Network );
}

NET_API_STATUS
BrUpdateNetworkAnnouncementBits(
    IN PNETWORK Network,
    IN PVOID Context
    )
/*++

Routine Description:

    This is the informs the bowser driver and the SMB server the current status
    of this transport.

Arguments:

    Network - Network being updated

    Context - Flags describing the circumstance of the call.

        BR_SHUTDOWN - Transport is being shutdown.
        BR_PARANOID - This is a superfluous call ensuring the services are
            in sync with us.

Return Value:

    None.

--*/

{
    NET_API_STATUS NetStatus;
    NET_API_STATUS NetStatusToReturn = NERR_Success;
    ULONG Flags = PtrToUlong(Context);
    ULONG Periodicity;
    BOOL fUpdateNow;

    ULONG ServiceBits;

    if (!LOCK_NETWORK(Network)) {
        return NERR_InternalError;
    }


    ServiceBits = BrGetBrowserServiceBits(Network);

    //
    //  Have the browser update it's information.
    //

    //
    //  Don't ever tell the browser to turn off the potential bit - this
    //  has the side effect of turning off the election name.
    //

    NetStatus = BrUpdateBrowserStatus(
                Network,
                (Flags & BR_SHUTDOWN) ? 0 : ServiceBits | SV_TYPE_POTENTIAL_BROWSER);

    if (NetStatus != NERR_Success) {
        BrPrint(( BR_CRITICAL,
                  "%ws: %ws: BrUpdateNetworkAnnouncementBits: Cannot BrUpdateBrowserStatus %ld\n",
                  Network->DomainInfo->DomUnicodeDomainName,
                  Network->NetworkName.Buffer,
                  NetStatus ));
        NetStatusToReturn = NetStatus;
    }

#if DBG
    BrUpdateDebugInformation(L"LastServiceStatus", L"LastServiceBits", Network->NetworkName.Buffer, NULL, ServiceBits);
#endif

    //
    // Tell the SMB server what the status is.
    //
    // On shutdown, tell it that we have no services.
    // When paranoid (or pseudo), don't force an announcement.
    //


#ifdef ENABLE_PSEUDO_BROWSER
    if ( (Flags & BR_PARANOID) &&
         BrInfo.PseudoServerLevel != BROWSER_PSEUDO ) {
        fUpdateNow = TRUE;
    }
    else {
        fUpdateNow = FALSE;
    }
#else
    fUpdateNow = (Flags & BR_PARANOID) ? TRUE : FALSE;
#endif

    NetStatus = I_NetServerSetServiceBitsEx(
                    NULL,
                    Network->DomainInfo->DomUnicodeComputerName,
                    Network->NetworkName.Buffer,
                    BROWSER_SERVICE_BITS_OF_INTEREST,
                    ( Flags & BR_SHUTDOWN) ? 0 : ServiceBits,
                    fUpdateNow );

    if ( NetStatus != NERR_Success) {

        BrPrint(( BR_CRITICAL,
                  "%ws: %ws: BrUpdateNetworkAnnouncementBits: Cannot I_NetServerSetServiceBitsEx %ld\n",
                  Network->DomainInfo->DomUnicodeDomainName,
                  Network->NetworkName.Buffer,
                  NetStatus ));

        //
        // If the only problem is that the transport doesn't exist in
        // the SMB server, don't even bother reporting the problem.
        // Or if it's a shutdown, filter out log failures. In some cases the
        // smb svr is already unavailable & we get unexpected failures. Reporting
        // to event log can mislead the admin.
        //

        if ( NetStatus != ERROR_PATH_NOT_FOUND &&
             NetStatus != NERR_NetNameNotFound &&
             !(Flags & BR_SHUTDOWN) ) {
            BrLogEvent(EVENT_BROWSER_STATUS_BITS_UPDATE_FAILED, NetStatus, 0, NULL);
            NetStatusToReturn = NetStatus;
#if 0
            // debugging when we get service update bit failures
            OutputDebugStringA("\nBrowser.dll: Update service bits tracing.\n");
            ASSERT( NetStatus != NERR_Success );
#endif
        }

        //
        // Either way.  Mark that we need to announce again later.
        //

        Network->Flags |= NETWORK_ANNOUNCE_NEEDED;


        Periodicity = UpdateAnnouncementPeriodicity[Network->UpdateAnnouncementIndex];

        BrSetTimer(&Network->UpdateAnnouncementTimer, Periodicity, BrUpdateAnnouncementTimerRoutine, Network);

        if (Network->UpdateAnnouncementIndex != UpdateAnnouncementMax) {
            Network->UpdateAnnouncementIndex += 1;
        }


    //
    // If we successfully informed the server,
    //  mark it.
    //

    } else {
        Network->Flags &= ~NETWORK_ANNOUNCE_NEEDED;
        Network->UpdateAnnouncementIndex = 0;
    }


    UNLOCK_NETWORK(Network);

    return NetStatusToReturn;
}


VOID
BrowserControlHandler(
    IN DWORD Opcode
    )
/*++

Routine Description:

    This is the service control handler of the Browser service.

Arguments:

    Opcode - Supplies a value which specifies the action for the Browser
        service to perform.

    Arg - Supplies a value which tells a service specifically what to do
        for an operation specified by Opcode.

Return Value:

    None.

--*/
{
    BrPrint(( BR_MAIN, "In Control Handler\n"));

    switch (Opcode) {

        case SERVICE_CONTROL_STOP:
        case SERVICE_CONTROL_SHUTDOWN:

            if (BrGlobalData.Status.dwCurrentState != SERVICE_STOP_PENDING) {

                BrPrint(( BR_MAIN, "Stopping Browser...\n"));


                if (! SetEvent(BrGlobalData.TerminateNowEvent)) {

                    //
                    // Problem with setting event to terminate Browser
                    // service.
                    //
                    BrPrint(( BR_CRITICAL, "Error setting TerminateNowEvent "
                                 FORMAT_API_STATUS "\n", GetLastError()));
                    NetpAssert(FALSE);
                }
            }

            //
            // Send the status response.
            //
            (void) BrGiveInstallHints( SERVICE_STOP_PENDING );

            return;

        case SERVICE_CONTROL_INTERROGATE:
            break;

        default:
            BrPrint(( BR_CRITICAL, "Unknown Browser opcode " FORMAT_HEX_DWORD
                             "\n", Opcode));
    }

    //
    // Send the status response.
    //
    (void) BrGiveInstallHints( SERVICE_START_PENDING );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\browser\server\browsdom.h ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    browsdom.h

Abstract:

    Private header file to be included by Browser service modules that
    need to deal with the browser list.

Author:

    Larry Osterman (larryo) 3-Mar-1992

Revision History:

--*/


#ifndef _BROWSDOM_INCLUDED_
#define _BROWSDOM_INCLUDED_

RTL_GENERIC_COMPARE_RESULTS
BrCompareDomainListEntry(
    PRTL_GENERIC_TABLE Table,
    PVOID FirstStruct,
    PVOID SecondStruct
    );

PVOID
BrAllocateDomainListEntry(
    PRTL_GENERIC_TABLE Table,
    CLONG ByteSize
    );

PVOID
BrFreeDomainListEntry(
    PRTL_GENERIC_TABLE Table,
    CLONG ByteSize
    );

#endif // _BROWSDOM_INCLUDED_

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\browser\server\browser.c ===
/*++

Copyright (c) 1991-1992  Microsoft Corporation

Module Name:

    browser.c

Abstract:

    This module contains the worker routines for the NetWksta APIs
    implemented in the Workstation service.

Author:

    Rita Wong (ritaw) 20-Feb-1991

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop
#include <lmuse.h>  // NetUseDel


//-------------------------------------------------------------------//
//                                                                   //
// Local structure definitions                                       //
//                                                                   //
//-------------------------------------------------------------------//

//-------------------------------------------------------------------//
//                                                                   //
// Local function prototypes                                         //
//                                                                   //
//-------------------------------------------------------------------//


VOID
CompleteAsyncBrowserIoControl(
    IN PVOID ApcContext,
    IN PIO_STATUS_BLOCK IoStatusBlock,
    IN ULONG Reserved
    );

VOID
BecomeBackupCompletion (
    IN PVOID Ctx
    );


VOID
ChangeBrowserRole (
    IN PVOID Ctx
    );

NET_API_STATUS
PostWaitForNewMasterName(
    PNETWORK Network,
    LPWSTR MasterName OPTIONAL
    );

VOID
NewMasterCompletionRoutine(
    IN PVOID Ctx
    );

NET_API_STATUS
BrRetrieveInterimServerList(
    IN PNETWORK Network,
    IN ULONG ServerType
    );

//-------------------------------------------------------------------//
//                                                                   //
// Global function prototypes                                        //
//                                                                   //
//-------------------------------------------------------------------//

NET_API_STATUS
BrBecomeBackup(
    IN PNETWORK Network
    )
/*++

Routine Description:

    This function performs all the operations needed to make a browser server
    a backup browser server when starting the browser from scratch.

Arguments:

    Network - Network to become backup browser for

Return Value:

    Status - The status of the operation.

--*/
{
    NET_API_STATUS Status;

    //
    // Checkpoint the service controller - this gives us 30 seconds/transport
    //  before the service controller gets unhappy.
    //

    (void) BrGiveInstallHints( SERVICE_START_PENDING );

    if (!LOCK_NETWORK(Network)) {
        return NERR_InternalError;
    }

    //
    //  We want to ignore any failures from becoming a backup browser.
    //
    //  We do this because we will fail to become a backup on a disconnected
    //  (or connected) RAS link, and if we failed this routine, we would
    //  fail to start at all.
    //
    //  We will handle failure to become a backup in a "reasonable manner"
    //  inside BecomeBackup.
    //

    BecomeBackup(Network, NULL);

    UNLOCK_NETWORK(Network);

    return NERR_Success;

}

NET_API_STATUS
BecomeBackup(
    IN PNETWORK Network,
    IN PVOID Context
    )
/*++

Routine Description:

    This function performs all the operations needed to make a browser server
    a backup browser server

Arguments:

    None.

Return Value:

    Status - The status of the operation.


NOTE:::: THIS ROUTINE IS CALLED WITH THE NETWORK STRUCTURE LOCKED!!!!!


--*/
{
    NET_API_STATUS Status = NERR_Success;
    PUNICODE_STRING MasterName = Context;

    BrPrint(( BR_BACKUP,
              "%ws: %ws: BecomeBackup called\n",
              Network->DomainInfo->DomUnicodeDomainName,
              Network->NetworkName.Buffer));

    if (Network->TimeStoppedBackup != 0 &&
        (BrCurrentSystemTime() - Network->TimeStoppedBackup) <= (BrInfo.BackupBrowserRecoveryTime / 1000)) {

        //
        //  We stopped being a backup too recently for us to restart being
        //  a backup again, so just return a generic error.
        //

        //
        //  Before we return, make sure we're not a backup in the eyes of
        //  the browser.
        //

        BrPrint(( BR_BACKUP,
                  "%ws: %ws: can't BecomeBackup since we were backup recently.\n",
                  Network->DomainInfo->DomUnicodeDomainName,
                  Network->NetworkName.Buffer));
        BrStopBackup(Network);

        return ERROR_ACCESS_DENIED;

    }

    //
    //  If we know the name of the master, then we must have become a backup
    //  after being a potential, in which case we already have a
    //  becomemaster request outstanding.
    //

    if (MasterName == NULL) {

        //
        //  Post a BecomeMaster request for each server.  This will complete
        //  when the machine becomes the master browser server (ie. it wins an
        //  election).
        //

        //
        //  Please note that we only post it if the machine is a backup -
        //  if it's a potential master, then the become master will have
        //  already been posted.
        //

        Status = PostBecomeMaster(Network);

        if (Status != NERR_Success) {

            return(Status);
        }

        //
        //  Find out the name of the master on each network.  This will force an
        //  election if necessary.  Please note that we must post the BecomeMaster
        //  IoControl first to allow us to handle an election.
        //

        //
        //  We unlock the network, because this may cause us to become promoted
        //  to a master.
        //

        BrPrint(( BR_BACKUP,
                  "%ws: %ws: FindMaster called from BecomeBackup\n",
                  Network->DomainInfo->DomUnicodeDomainName,
                  Network->NetworkName.Buffer));

        UNLOCK_NETWORK(Network);

        Status = GetMasterServerNames(Network);

        if (Status != NERR_Success) {

            //
            //  Re-lock the network structure so we will return with the
            //  network locked.
            //

            if (!LOCK_NETWORK(Network)) {
                return NERR_InternalError;
            }

            //
            //  We couldn't find who the master is.  Stop being a backup now.
            //

            BrPrint(( BR_BACKUP,
                      "%ws: %ws: can't BecomeBackup since we can't find master.\n",
                      Network->DomainInfo->DomUnicodeDomainName,
                      Network->NetworkName.Buffer));

            BrStopBackup(Network);

            //
            //  If we're a master now, we should return success.  We've not
            //  become a backup, but it wasn't an error.
            //
            //  ERROR_MORE_DATA is the mapping for
            //  STATUS_MORE_PROCESSING_REQUIRED which is returned when this
            //  situation happens.
            //

            if ((Status == ERROR_MORE_DATA) || (Network->Role & ROLE_MASTER)) {
                Status = NERR_Success;
            }

            return(Status);
        }

        if (!LOCK_NETWORK(Network)) {
            return NERR_InternalError;
        }

        //
        //  We managed to become a master.  We want to return right away.
        //

        if (Network->Role & ROLE_MASTER) {

            return NERR_Success;
        }

    }

#ifdef notdef
    //
    // ?? For now, we'll always PostForRoleChange on all transports regardless
    //  of role.
    // We not only need to do it here.  But we need to do it when we become
    // the master so we can find out when we loose an election.
    //


    //
    //  We're now a backup, we need to issue an API that will complete if the
    //  browse master doesn't like us (and thus forces us to shutdown).
    //
    //

    PostWaitForRoleChange ( Network );
#endif // notdef

    PostWaitForNewMasterName(Network, Network->UncMasterBrowserName );

    //
    //  Unlock the network structure before calling BackupBrowserTimerRoutine.
    //

    UNLOCK_NETWORK(Network);

    //
    //  Run the timer that causes the browser to download a new browse list
    //  from the master.  This will seed our server and domain lists to
    //  guarantee that any clients have a reasonable list.  It will also
    //  restart the timer to announce later on.
    //

    Status = BackupBrowserTimerRoutine(Network);

    if (!LOCK_NETWORK(Network)) {
        return NERR_InternalError;
    }

    if (Status == NERR_Success) {

        // Might not be since we dropped the lock.
        // ASSERT (Network->Role & ROLE_BACKUP);

        //
        //  We're now a backup server, announce ourselves as such.
        //

        Status = BrUpdateNetworkAnnouncementBits(Network, 0);

        if (Status != NERR_Success) {

            BrPrint(( BR_CRITICAL,
                      "%ws: %ws: Unable to become backup: %ld\n",
                      Network->DomainInfo->DomUnicodeDomainName,
                      Network->NetworkName.Buffer,
                      Status));

            if (Network->Role & ROLE_BACKUP) {

                //
                // We were unable to become a backup.
                //
                //  We need to back out and become a potential browser now.
                //
                //

                BrPrint(( BR_BACKUP,
                          "%ws: %ws: can't BecomeBackup since we can't update announce bits.\n",
                          Network->DomainInfo->DomUnicodeDomainName,
                          Network->NetworkName.Buffer));
                BrStopBackup(Network);

                //
                //  Make sure that we're going to become a potential browser
                //  (we might not if we're an advanced server).
                //

                PostBecomeBackup(Network);

            }
        }

        return Status;

    }

    return Status;
}


NET_API_STATUS
BrBecomePotentialBrowser (
    IN PVOID TimerContext
    )
/*++

Routine Description:

    This routine is called when a machine has stopped being a backup browser.

    It runs after a reasonable timeout period has elapsed, and marks the
    machine as a potential browser.

Arguments:

    None.

Return Value:

    Status - The status of the operation.


--*/

{
    IN PNETWORK Network = TimerContext;
    NET_API_STATUS Status;

    //
    // Prevent the network from being deleted while we're in this timer routine.
    //
    if ( BrReferenceNetwork( Network ) == NULL ) {
        return NERR_InternalError;
    }


    //
    //  Mark this guy as a potential browser.
    //

    try {

        if (!LOCK_NETWORK(Network)) {
            try_return(Status = NERR_InternalError );
        }

        BrPrint(( BR_BACKUP,
                  "%ws: %ws: BrBecomePotentialBrowser called\n",
                  Network->DomainInfo->DomUnicodeDomainName,
                  Network->NetworkName.Buffer));

        //
        //  Reset that we've stopped being a backup, since it's been long
        //  enough.
        //

        Network->TimeStoppedBackup = 0;

        if (BrInfo.MaintainServerList == 0) {
            Network->Role |= ROLE_POTENTIAL_BACKUP;

            Status = BrUpdateNetworkAnnouncementBits(Network, 0);

            if (Status != NERR_Success) {
                BrPrint(( BR_BACKUP,
                          "%ws: %ws: Unable to reset backup announcement bits: %ld\n",
                          Network->DomainInfo->DomUnicodeDomainName,
                          Network->NetworkName.Buffer,
                          Status));
                try_return(Status);
            }
        } else {

            //
            //  If we're configured to be a backup browser, then we want to
            //  become a backup once again.
            //

            BecomeBackup(Network, NULL);
        }


        Status = NO_ERROR;
try_exit:NOTHING;
    } finally {
        UNLOCK_NETWORK(Network);
        BrDereferenceNetwork( Network );
    }

    return Status;
}

NET_API_STATUS
BrStopBackup (
    IN PNETWORK Network
    )
/*++

Routine Description:

    This routine is called to stop a machine from being a backup browser.

    It is typically called after some form of error has occurred while
    running as a browser to make sure that we aren't telling anyone that
    we're a backup browser.

    We are also called when we receive a "reset state" tickle packet.

Arguments:

    Network - The network being shut down.

Return Value:

    Status - The status of the operation.

--*/
{
    NET_API_STATUS Status;

    //
    //  This guy is shutting down - set his role to 0 and announce.
    //

    if (!LOCK_NETWORK(Network)) {
        return NERR_InternalError;
    }

    try {

        BrPrint(( BR_BACKUP,
                  "%ws: %ws: BrStopBackup called\n",
                  Network->DomainInfo->DomUnicodeDomainName,
                  Network->NetworkName.Buffer));

        Network->Role &= ~(ROLE_BACKUP|ROLE_POTENTIAL_BACKUP);

        Status = BrUpdateNetworkAnnouncementBits( Network, 0 );

        if (Status != NERR_Success) {
            BrPrint(( BR_CRITICAL,
                      "%ws: %ws: Unable to clear backup announcement bits: %ld\n",
                      Network->DomainInfo->DomUnicodeDomainName,
                      Network->NetworkName.Buffer,
                      Status));
            try_return(Status);
        }


        Status = BrCancelTimer(&Network->BackupBrowserTimer);

        if (Status != NERR_Success) {
            BrPrint(( BR_CRITICAL,
                      "%ws: %ws: Unable to clear backup browser timer: %ld\n",
                      Network->DomainInfo->DomUnicodeDomainName,
                      Network->NetworkName.Buffer,
                      Status));
            try_return(Status);
        }

        if (Network->BackupDomainList != NULL) {

            NetApiBufferFree(Network->BackupDomainList);

            Network->BackupDomainList = NULL;

            Network->TotalBackupDomainListEntries = 0;
        }

        if (Network->BackupServerList != NULL) {
            NetApiBufferFree(Network->BackupServerList);

            Network->BackupServerList = NULL;

            Network->TotalBackupServerListEntries = 0;
        }

        BrDestroyResponseCache(Network);

        //
        //  After our recovery time, we can become a potential browser again.
        //

        Status = BrSetTimer(&Network->BackupBrowserTimer, BrInfo.BackupBrowserRecoveryTime, BrBecomePotentialBrowser, Network);

        if (Status != NERR_Success) {
            BrPrint(( BR_CRITICAL,
                      "%ws: %ws: Unable to clear backup browser timer: %ld\n",
                      Network->DomainInfo->DomUnicodeDomainName,
                      Network->NetworkName.Buffer,
                      Status));
            try_return(Status);
        }


try_exit:NOTHING;
    } finally {
        //
        //  Remember when we were asked to stop being a backup browser.
        //

        Network->TimeStoppedBackup = BrCurrentSystemTime();

        UNLOCK_NETWORK(Network);
    }

    return Status;

}


NET_API_STATUS
BackupBrowserTimerRoutine (
    IN PVOID TimerContext
    )
{
    IN PNETWORK Network = TimerContext;
    NET_API_STATUS Status;
    PVOID ServerList = NULL;
    BOOLEAN NetworkLocked = FALSE;

#ifdef ENABLE_PSEUDO_BROWSER
    if ( BrInfo.PseudoServerLevel == BROWSER_PSEUDO ) {
        //
        // No-op for Pseudo server
        //
        BrFreeNetworkTables(Network);
        return NERR_Success;
    }
#endif
    //
    // Prevent the network from being deleted while we're in this timer routine.
    //
    if ( BrReferenceNetwork( Network ) == NULL ) {
        return NERR_InternalError;
    }

    try {

        if (!LOCK_NETWORK(Network)) {
            try_return(Status = NERR_InternalError );
        }

        NetworkLocked = TRUE;

        ASSERT (Network->LockCount == 1);

        ASSERT ( NetpIsUncComputerNameValid( Network->UncMasterBrowserName ) );

        BrPrint(( BR_BACKUP,
                  "%ws: %ws: BackupBrowserTimerRoutine called\n",
                  Network->DomainInfo->DomUnicodeDomainName,
                  Network->NetworkName.Buffer));

        //
        //  Make sure there's a become master oustanding.
        //

        PostBecomeMaster(Network);

        //
        //  We managed to become a master by the time we locked the structure.
        //  We want to return right away.
        //

        if (Network->Role & ROLE_MASTER) {
            try_return(Status = NERR_Success);
        }

        Status = BrRetrieveInterimServerList(Network, SV_TYPE_ALL);

        //
        //  Bail out if we didn't get any new servers.
        //

        if (Status != NERR_Success && Status != ERROR_MORE_DATA) {

            //
            //  Try again after an appropriate error delay.
            //

            try_return(Status);
        }

        //
        //  Now do everything that we did above for the server list for the
        //  list of domains.
        //

        Status = BrRetrieveInterimServerList(Network, SV_TYPE_DOMAIN_ENUM);

        //
        //  We successfully updated the server and domain lists for this
        //  server.  Now age all the cached domain entries out of the cache.
        //

        if (Status == NERR_Success || Status == ERROR_MORE_DATA) {
            BrAgeResponseCache(Network);
        }

        try_return(Status);

try_exit:NOTHING;
    } finally {
        NET_API_STATUS NetStatus;

        if (!NetworkLocked) {
            if (!LOCK_NETWORK(Network)) {
                Status = NERR_InternalError;
                goto finally_exit;
            }

            NetworkLocked = TRUE;
        }

        //
        //  If the API succeeded, Mark that we're a backup and
        //  reset the timer.
        //

        if (Status == NERR_Success || Status == ERROR_MORE_DATA ) {

            if ((Network->Role & ROLE_BACKUP) == 0) {

                //
                //  If we weren't a backup, we are one now.
                //

                Network->Role |= ROLE_BACKUP;

                Status = BrUpdateNetworkAnnouncementBits(Network, 0);

            }

            Network->NumberOfFailedBackupTimers = 0;

            Network->TimeStoppedBackup = 0;

            //
            //  Restart the timer for this domain.
            //

            NetStatus = BrSetTimer(&Network->BackupBrowserTimer, BrInfo.BackupPeriodicity*1000, BackupBrowserTimerRoutine, Network);

            if (NetStatus != NERR_Success) {
                BrPrint(( BR_CRITICAL,
                          "%ws: %ws: Unable to restart browser backup timer: %lx\n",
                          Network->DomainInfo->DomUnicodeDomainName,
                          Network->NetworkName.Buffer,
                          Status));
            }

        } else {

            //
            //  We failed to retrieve a backup list, remember the failure and
            //  decide if it's been too many failures. If not, just log
            //  the error, if it has, stop being a backup browser.
            //

            Network->NumberOfFailedBackupTimers += 1;

            if (Network->NumberOfFailedBackupTimers >= BACKUP_ERROR_FAILURE) {
                LPWSTR SubStrings[1];

                SubStrings[0] = Network->NetworkName.Buffer;

                //
                //  This guy can't be a backup any more, bail out now.
                //

                BrLogEvent(EVENT_BROWSER_BACKUP_STOPPED, Status, 1, SubStrings);

                BrPrint(( BR_BACKUP,
                          "%ws: %ws: BackupBrowserTimerRoutine retrieve backup list so stop being backup.\n",
                          Network->DomainInfo->DomUnicodeDomainName,
                          Network->NetworkName.Buffer));
                BrStopBackup(Network);
            } else {
                //
                //  Restart the timer for this domain.
                //

                NetStatus = BrSetTimer(&Network->BackupBrowserTimer, BACKUP_ERROR_PERIODICITY*1000, BackupBrowserTimerRoutine, Network);

                if (NetStatus != NERR_Success) {
                    BrPrint(( BR_CRITICAL,
                              "%ws: %ws: Unable to restart browser backup timer: %lx\n",
                              Network->DomainInfo->DomUnicodeDomainName,
                              Network->NetworkName.Buffer,
                              Status));
                }

            }

        }

        if (NetworkLocked) {
            UNLOCK_NETWORK(Network);
        }

        BrDereferenceNetwork( Network );
finally_exit:;
    }

    return Status;

}

NET_API_STATUS
BrRetrieveInterimServerList(
    IN PNETWORK Network,
    IN ULONG ServerType
    )
{
    ULONG EntriesInList;
    ULONG TotalEntriesInList;
    ULONG RetryCount = 2;
    TCHAR ServerName[UNCLEN+1];
    WCHAR ShareName[UNCLEN+1+LM20_NNLEN];
    LPTSTR TransportName;
    BOOLEAN NetworkLocked = TRUE;
    NET_API_STATUS Status;
    PVOID Buffer = NULL;
    ULONG ModifiedServerType = ServerType;
    LPTSTR ModifiedTransportName;

    ASSERT (Network->LockCount == 1);


#ifdef ENABLE_PSEUDO_BROWSER
    if ( BrInfo.PseudoServerLevel == BROWSER_PSEUDO ) {
        //
        // No-op for Pseudo black hole server.
        //
        return NERR_Success;
    }
#endif

    wcscpy(ServerName, Network->UncMasterBrowserName );

    BrPrint(( BR_BACKUP,
              "%ws: %ws: BrRetrieveInterimServerList: UNC servername is %ws\n",
              Network->DomainInfo->DomUnicodeDomainName,
              Network->NetworkName.Buffer,
              ServerName));

    try {

        TransportName = Network->NetworkName.Buffer;
        ModifiedTransportName = TransportName;
        //
        // If this is direct host IPX,
        //  we remote the API over the Netbios IPX transport since
        //  the NT redir doesn't support direct host IPX.
        //

        if ( (Network->Flags & NETWORK_IPX) &&
             Network->AlternateNetwork != NULL) {

            //
            //  Use the alternate transport
            //

            ModifiedTransportName = Network->AlternateNetwork->NetworkName.Buffer;

            //
            // Tell the server to use it's alternate transport.
            //

            if ( ServerType == SV_TYPE_ALL ) {
                ModifiedServerType = SV_TYPE_ALTERNATE_XPORT;
            } else {
                ModifiedServerType |= SV_TYPE_ALTERNATE_XPORT;
            }

        }

        while (RetryCount--) {

            //
            //  If we are promoted to master and fail to become the master,
            //  we will still be marked as being the master in our network
            //  structure, thus we should bail out of the loop in order
            //  to prevent us from looping back on ourselves.
            //

            if (STRICMP(&ServerName[2], Network->DomainInfo->DomUnicodeComputerName) == 0) {

                if (NetworkLocked) {
                    UNLOCK_NETWORK(Network);

                    NetworkLocked = FALSE;

                }

                //
                //  We were unable to find the master.  Attempt to find out who
                //  the master is.  If there is none, this will force an
                //  election.
                //

                BrPrint(( BR_BACKUP,
                          "%ws: %ws: FindMaster called from BrRetrieveInterimServerList\n",
                          Network->DomainInfo->DomUnicodeDomainName,
                          Network->NetworkName.Buffer));

                Status = GetMasterServerNames(Network);

                if (Status != NERR_Success) {
                    try_return(Status);
                }

                ASSERT (!NetworkLocked);

                if (!LOCK_NETWORK(Network)) {
                    try_return(Status = NERR_InternalError);
                }

                NetworkLocked = TRUE;

                break;
            }

            //
            //  If we somehow became the master, we don't want to try to
            //  retrieve the list from ourselves either.
            //

            if (Network->Role & ROLE_MASTER) {
                try_return(Status = NERR_Success);
            }

            ASSERT (Network->LockCount == 1);

            if (NetworkLocked) {
                UNLOCK_NETWORK(Network);

                NetworkLocked = FALSE;

            }

            EntriesInList = 0;

            Status = RxNetServerEnum(ServerName,        // Server name
                             ModifiedTransportName,     // Transport name
                             101,                       // Level
                             (LPBYTE *)&Buffer,         // Buffer
                             0xffffffff,                // Prefered Max Length
                             &EntriesInList,            // EntriesRead
                             &TotalEntriesInList,       // TotalEntries
                             ModifiedServerType,        // Server type
                             NULL,                      // Domain (use default)
                             NULL                       // Resume key
                             );

            //
            // If the redir is being possesive of some other transport,
            //  urge it to behave.
            //

            if ( Status == ERROR_CONNECTION_ACTIVE ) {

                BrPrint(( BR_BACKUP,
                          "%ws: %ws: Failed to retrieve %s list from server %ws: Connection is active (Try NetUseDel)\n",
                          Network->DomainInfo->DomUnicodeDomainName,
                          TransportName,
                          (ServerType == SV_TYPE_ALL ? "server" : "domain"),
                          ServerName ));

                //
                // Delete the IPC$ share.
                //

                Status = NetUseDel( NULL,
                                    ShareName,
                                    USE_FORCE );

                if ( Status != NO_ERROR ) {

                    BrPrint(( BR_BACKUP,
                              "%ws: %ws: Failed to retrieve %s list from server %ws: NetUseDel failed: %ld\n",
                              Network->DomainInfo->DomUnicodeDomainName,
                              TransportName,
                              (ServerType == SV_TYPE_ALL ? "server" : "domain"),
                              ServerName,
                              Status));

                    Status = ERROR_CONNECTION_ACTIVE;

                //
                // That worked so try it again.
                //
                } else {

                    EntriesInList = 0;

                    Status = RxNetServerEnum(ServerName,        // Server name
                                     ModifiedTransportName,     // Transport name
                                     101,                       // Level
                                     (LPBYTE *)&Buffer,         // Buffer
                                     0xffffffff,                // Prefered Max Length
                                     &EntriesInList,            // EntriesRead
                                     &TotalEntriesInList,       // TotalEntries
                                     ModifiedServerType,        // Server type
                                     NULL,                      // Domain (use default)
                                     NULL                       // Resume key
                                     );
                }


            }

            if (Status != NERR_Success && Status != ERROR_MORE_DATA) {
                LPWSTR SubStrings[2];

                SubStrings[0] = ServerName;
                SubStrings[1] = TransportName;

                BrLogEvent((ServerType == SV_TYPE_DOMAIN_ENUM ?
                                            EVENT_BROWSER_DOMAIN_LIST_FAILED :
                                            EVENT_BROWSER_SERVER_LIST_FAILED),
                           Status,
                           2,
                           SubStrings);

                BrPrint(( BR_BACKUP,
                          "%ws: %ws: Failed to retrieve %s list from server %ws: %ld\n",
                          Network->DomainInfo->DomUnicodeDomainName,
                          TransportName,
                          (ServerType == SV_TYPE_ALL ? "server" : "domain"),
                          ServerName,
                          Status));
            } else {
                BrPrint(( BR_BACKUP,
                          "%ws: %ws: Retrieved %s list from server %ws: E:%ld, T:%ld\n",
                          Network->DomainInfo->DomUnicodeDomainName,
                          TransportName,
                          (ServerType == SV_TYPE_ALL ? "server" : "domain"),
                          ServerName,
                          EntriesInList,
                          TotalEntriesInList));
            }

            //
            //  If we succeeded in retrieving the list, but we only got
            //  a really small number of either servers or domains,
            //  we want to turn this into a failure.
            //

            if (Status == NERR_Success) {
                if (((ServerType == SV_TYPE_DOMAIN_ENUM) &&
                     (EntriesInList < BROWSER_MINIMUM_DOMAIN_NUMBER)) ||
                    ((ServerType == SV_TYPE_ALL) &&
                     (EntriesInList < BROWSER_MINIMUM_SERVER_NUMBER))) {

                    Status = ERROR_INSUFFICIENT_BUFFER;
                }
            }

            if ((Status == NERR_Success) || (Status == ERROR_MORE_DATA)) {

                ASSERT (!NetworkLocked);

                if (!LOCK_NETWORK(Network)) {
                    Status = NERR_InternalError;

                    if ((EntriesInList != 0) && (Buffer != NULL)) {
                        NetApiBufferFree(Buffer);
                        Buffer = NULL;
                    }

                    break;
                }

                NetworkLocked = TRUE;

                ASSERT (Network->LockCount == 1);

#if DBG
                BrUpdateDebugInformation((ServerType == SV_TYPE_DOMAIN_ENUM ?
                                                        L"LastDomainListRead" :
                                                        L"LastServerListRead"),
                                          L"BrowserServerName",
                                          TransportName,
                                          ServerName,
                                          0);
#endif

                //
                //  We've retrieved a new list from the browse master, save
                //  the new list away in the "appropriate" spot.
                //

                //
                //  Of course, we free up the old buffer before we do this..
                //

                if (ServerType == SV_TYPE_DOMAIN_ENUM) {
                    if (Network->BackupDomainList != NULL) {
                        NetApiBufferFree(Network->BackupDomainList);
                    }

                    Network->BackupDomainList = Buffer;

                    Network->TotalBackupDomainListEntries = EntriesInList;
                } else {
                    if (Network->BackupServerList != NULL) {
                        NetApiBufferFree(Network->BackupServerList);
                    }

                    Network->BackupServerList = Buffer;

                    Network->TotalBackupServerListEntries = EntriesInList;
                }

                break;
            } else {
                NET_API_STATUS GetMasterNameStatus;

                if ((EntriesInList != 0) && (Buffer != NULL)) {
                    NetApiBufferFree(Buffer);
                    Buffer = NULL;
                }

                BrPrint(( BR_BACKUP,
                          "%ws: %ws: Unable to contact browser server %ws: %lx\n",
                          Network->DomainInfo->DomUnicodeDomainName,
                          TransportName,
                          ServerName,
                          Status));

                if (NetworkLocked) {

                    //
                    //  We were unable to find the master.  Attempt to find out who
                    //  the master is.  If there is none, this will force an
                    //  election.
                    //

                    ASSERT (Network->LockCount == 1);

                    UNLOCK_NETWORK(Network);

                    NetworkLocked = FALSE;
                }

                BrPrint(( BR_BACKUP,
                          "%ws: %ws: FindMaster called from BrRetrieveInterimServerList for failure\n",
                          Network->DomainInfo->DomUnicodeDomainName,
                          Network->NetworkName.Buffer));

                GetMasterNameStatus = GetMasterServerNames(Network);

                //
                //  We were able to find out who the master is.
                //
                //  Retry and retrieve the server/domain list.
                //

                if (GetMasterNameStatus == NERR_Success) {

                    ASSERT (!NetworkLocked);

                    if (!LOCK_NETWORK(Network)) {
                        try_return(Status = NERR_InternalError);
                    }

                    NetworkLocked = TRUE;

                    ASSERT (Network->LockCount == 1);

                    //
                    //  We managed to become a master.  We want to return right away.
                    //

                    if (Network->Role & ROLE_MASTER) {

                        try_return(Status = NERR_InternalError);
                    }

                    wcscpy(ServerName, Network->UncMasterBrowserName );

                    ASSERT ( NetpIsUncComputerNameValid( ServerName ) );

                    ASSERT (STRICMP(&ServerName[2], Network->DomainInfo->DomUnicodeComputerName) != 0);

                    BrPrint(( BR_BACKUP,
                              "%ws: %ws: New master name is %ws\n",
                              Network->DomainInfo->DomUnicodeDomainName,
                              Network->NetworkName.Buffer,
                              ServerName));

                } else {
                    try_return(Status);
                }
            }
        }
try_exit:NOTHING;
    } finally {
        if (!NetworkLocked) {
            if (!LOCK_NETWORK(Network)) {
                Status = NERR_InternalError;
            }

            ASSERT (Network->LockCount == 1);

        }
    }

    return Status;
}


NET_API_STATUS
PostBecomeBackup(
    PNETWORK Network
    )
/*++

Routine Description:

    This function is the worker routine called to actually issue a BecomeBackup
    FsControl to the bowser driver on all the bound transports.  It will
    complete when the machine becomes a backup browser server.

    Please note that this might never complete.

Arguments:

    None.

Return Value:

    Status - The status of the operation.

--*/
{
    NET_API_STATUS Status;

    if (!LOCK_NETWORK(Network)) {
        return NERR_InternalError;
    }

    Network->Role |= ROLE_POTENTIAL_BACKUP;

    Status = BrIssueAsyncBrowserIoControl(Network,
                            IOCTL_LMDR_BECOME_BACKUP,
                            BecomeBackupCompletion,
                            NULL );
    UNLOCK_NETWORK(Network);

    return Status;
}

VOID
BecomeBackupCompletion (
    IN PVOID Ctx
    )
{
    NET_API_STATUS Status;
    PBROWSERASYNCCONTEXT Context = Ctx;
    PNETWORK Network = Context->Network;

    if (NT_SUCCESS(Context->IoStatusBlock.Status)) {

        //
        // Ensure the network wasn't deleted from under us.
        //
        if ( BrReferenceNetwork( Network ) != NULL ) {

            if (LOCK_NETWORK(Network)) {

                BrPrint(( BR_BACKUP,
                          "%ws: %ws: BecomeBackupCompletion.  We are now a backup server\n",
                          Network->DomainInfo->DomUnicodeDomainName,
                          Network->NetworkName.Buffer ));

                Status = BecomeBackup(Context->Network, NULL);

                UNLOCK_NETWORK(Network);
            }

            BrDereferenceNetwork( Network );
        }

    }

    MIDL_user_free(Context);

}

VOID
BrBrowseTableInsertRoutine(
    IN PINTERIM_SERVER_LIST InterimTable,
    IN PINTERIM_ELEMENT InterimElement
    )
{
    //
    //  We need to miss 3 retrievals of the browse list for us to toss the
    //  server.
    //

    InterimElement->Periodicity = BrInfo.BackupPeriodicity * 3;

    if (InterimElement->TimeLastSeen != 0xffffffff) {
        InterimElement->TimeLastSeen = BrCurrentSystemTime();
    }
}

VOID
BrBrowseTableDeleteRoutine(
    IN PINTERIM_SERVER_LIST InterimTable,
    IN PINTERIM_ELEMENT InterimElement
    )
{
//    BrPrint(( BR_CRITICAL, "Deleting element for server %ws\n", InterimElement->Name));
}

VOID
BrBrowseTableUpdateRoutine(
    IN PINTERIM_SERVER_LIST InterimTable,
    IN PINTERIM_ELEMENT InterimElement
    )
{
    if (InterimElement->TimeLastSeen != 0xffffffff) {
        InterimElement->TimeLastSeen = BrCurrentSystemTime();
    }
}

BOOLEAN
BrBrowseTableAgeRoutine(
    IN PINTERIM_SERVER_LIST InterimTable,
    IN PINTERIM_ELEMENT InterimElement
    )
/*++

Routine Description:

    This routine is called when we are scanning an interim server list trying
    to age the elements in the list.  It returns TRUE if the entry is too
    old.

Arguments:

    PINTERIM_SERVER_LIST InterimTable - A pointer to the interim server list.
    PINTERIM_ELEMENT InterimElement - A pointer to the element to check.

Return Value:

    TRUE if the element should be deleted.

--*/

{
    if (InterimElement->TimeLastSeen == 0xffffffff) {
        return FALSE;
    }

    if ((InterimElement->TimeLastSeen + InterimElement->Periodicity) < BrCurrentSystemTime()) {
//        BrPrint(( BR_CRITICAL, "Aging out element for server %ws\n", InterimElement->Name));

        return TRUE;
    } else {
        return FALSE;
    }
}

VOID
BrDomainTableInsertRoutine(
    IN PINTERIM_SERVER_LIST InterimTable,
    IN PINTERIM_ELEMENT InterimElement
    )
{
    InterimElement->Periodicity = BrInfo.BackupPeriodicity * 3;
    InterimElement->TimeLastSeen = BrCurrentSystemTime();

}

VOID
BrDomainTableDeleteRoutine(
    IN PINTERIM_SERVER_LIST InterimTable,
    IN PINTERIM_ELEMENT InterimElement
    )
{
//    BrPrint(( BR_CRITICAL, "Deleting element for domain %ws\n", InterimElement->Name));
}

VOID
BrDomainTableUpdateRoutine(
    IN PINTERIM_SERVER_LIST InterimTable,
    IN PINTERIM_ELEMENT InterimElement
    )
{
    InterimElement->TimeLastSeen = BrCurrentSystemTime();
}

BOOLEAN
BrDomainTableAgeRoutine(
    IN PINTERIM_SERVER_LIST InterimTable,
    IN PINTERIM_ELEMENT InterimElement
    )
/*++

Routine Description:

    This routine is called when we are scanning an interim server list trying
    to age the elements in the list.  It returns TRUE if the entry is too
    old.

Arguments:

    PINTERIM_SERVER_LIST InterimTable - A pointer to the interim server list.
    PINTERIM_ELEMENT InterimElement - A pointer to the element to check.

Return Value:

    TRUE if the element should be deleted.

--*/

{
    if ((InterimElement->TimeLastSeen + InterimElement->Periodicity) < BrCurrentSystemTime()) {
//        BrPrint(( BR_CRITICAL, "Aging out element for domain %ws\n", InterimElement->Name));
        return TRUE;
    } else {
        return FALSE;
    }
}


NET_API_STATUS
PostWaitForRoleChange (
    PNETWORK Network
    )
/*++

Routine Description:

    This function is the worker routine called to actually issue a WaitForRoleChange
    FsControl to the bowser driver on all the bound transports.  It will
    complete when the machine becomes a backup browser server.

    Please note that this might never complete.

Arguments:

    None.

Return Value:

    Status - The status of the operation.

--*/
{
    NET_API_STATUS Status;

    if (!LOCK_NETWORK(Network)) {
        return NERR_InternalError;
    }

    Status = BrIssueAsyncBrowserIoControl(Network,
                            IOCTL_LMDR_CHANGE_ROLE,
                            ChangeBrowserRole,
                            NULL );
    UNLOCK_NETWORK(Network);

    return Status;
}

VOID
ChangeBrowserRole (
    IN PVOID Ctx
    )
{
    PBROWSERASYNCCONTEXT Context = Ctx;
    PNETWORK Network = Context->Network;

    if (NT_SUCCESS(Context->IoStatusBlock.Status)) {
        PWSTR MasterName = NULL;
        PLMDR_REQUEST_PACKET Packet = Context->RequestPacket;

        //
        // Ensure the network wasn't deleted from under us.
        //
        if ( BrReferenceNetwork( Network ) != NULL ) {

            if (LOCK_NETWORK(Network)) {

                PostWaitForRoleChange(Network);

                if (Packet->Parameters.ChangeRole.RoleModification & RESET_STATE_CLEAR_ALL) {
                    BrPrint(( BR_MASTER,
                              "%ws: %ws: Reset state request to clear all\n",
                              Network->DomainInfo->DomUnicodeDomainName,
                              Network->NetworkName.Buffer ));

                    if (Network->Role & ROLE_MASTER) {
                        BrStopMaster(Network);
                    }

                    //
                    //  Stop being a backup as well.
                    //

                    BrStopBackup(Network);

                }

                if ((Network->Role & ROLE_MASTER) &&
                    (Packet->Parameters.ChangeRole.RoleModification & RESET_STATE_STOP_MASTER)) {

                    BrPrint(( BR_MASTER,
                              "%ws: %ws: Reset state request to stop master\n",
                              Network->DomainInfo->DomUnicodeDomainName,
                              Network->NetworkName.Buffer ));

                    BrStopMaster(Network);

                    //
                    //  If we are configured to be a backup, then become a backup
                    //  again.
                    //

                    if (BrInfo.MaintainServerList == 1) {
                        BecomeBackup(Network, NULL);
                    }
                }

                //
                //  Make sure there's a become master oustanding.
                //

                PostBecomeMaster(Network);

                UNLOCK_NETWORK(Network);

            }

            BrDereferenceNetwork( Network );
        }
    }

    MIDL_user_free(Context);

}


NET_API_STATUS
PostWaitForNewMasterName(
    PNETWORK Network,
    LPWSTR MasterName OPTIONAL
    )
{
    //
    // Can't wait for new master on direct host IPC
    //
    if (Network->Flags & NETWORK_IPX) {
        return STATUS_SUCCESS;
    }

    return BrIssueAsyncBrowserIoControl(
                Network,
                IOCTL_LMDR_NEW_MASTER_NAME,
                NewMasterCompletionRoutine,
                MasterName );


}

VOID
NewMasterCompletionRoutine(
    IN PVOID Ctx
    )
{
    PBROWSERASYNCCONTEXT Context = Ctx;
    PNETWORK Network = Context->Network;
    BOOLEAN NetLocked = FALSE;
    BOOLEAN NetReferenced = FALSE;


    try {
        UNICODE_STRING NewMasterName;

        //
        // Ensure the network wasn't deleted from under us.
        //
        if ( BrReferenceNetwork( Network ) == NULL ) {
            try_return(NOTHING);
        }
        NetReferenced = TRUE;

        BrPrint(( BR_MASTER,
                  "%ws: %ws: NewMasterCompletionRoutine: Got master changed\n",
                  Network->DomainInfo->DomUnicodeDomainName,
                  Network->NetworkName.Buffer ));

        if (!LOCK_NETWORK(Network)){
            try_return(NOTHING);
        }
        NetLocked = TRUE;

        //
        //  The request failed for some other reason - just return immediately.
        //

        if (!NT_SUCCESS(Context->IoStatusBlock.Status)) {

            try_return(NOTHING);

        }

        //  Remove new master name & put in transport

        if ( Network->Role & ROLE_MASTER ) {

            try_return(NOTHING);

        }

        BrPrint(( BR_BACKUP,
                  "%ws: %ws: NewMasterCompletionRoutin: New:%ws Old %ws\n",
                  Network->DomainInfo->DomUnicodeDomainName,
                  Network->NetworkName.Buffer,
                  Context->RequestPacket->Parameters.GetMasterName.Name,
                  Network->UncMasterBrowserName ));

        //
        // Copy the master browser name into the network structure
        //

        wcsncpy( Network->UncMasterBrowserName,
                 Context->RequestPacket->Parameters.GetMasterName.Name,
                 UNCLEN+1 );

        Network->UncMasterBrowserName[UNCLEN] = L'\0';

        ASSERT ( NetpIsUncComputerNameValid ( Network->UncMasterBrowserName ) );

        PostWaitForNewMasterName( Network, Network->UncMasterBrowserName );

try_exit:NOTHING;
    } finally {

        if (NetLocked) {
            UNLOCK_NETWORK(Network);
        }

        if ( NetReferenced ) {
            BrDereferenceNetwork( Network );
        }

        MIDL_user_free(Context);

    }

    return;
}




#ifdef ENABLE_PSEUDO_BROWSER
//
// Pseudo Server
// Phase out black hole Helper routines
//





VOID
BrFreeNetworkTables(
    IN  PNETWORK        Network
    )
/*++

Routine Description:

    Free network tables

Arguments:

    Network to operate upon

Return Value:
    None.

Remarks:
    Acquire & release network locks
--*/
{

    BOOL NetLocked = FALSE;

    //
    // Prevent the network from being deleted while we're in this timer routine.
    //
    if ( BrReferenceNetwork( Network ) == NULL ) {
        return;
    }

    try{

        // lock network
        if (!LOCK_NETWORK(Network)) {
            try_return(NOTHING);
        }
        NetLocked = TRUE;

        //
        // Delete tables
        //

        UninitializeInterimServerList(&Network->BrowseTable);

        UninitializeInterimServerList(&Network->DomainList);

        if (Network->BackupServerList != NULL) {
            MIDL_user_free(Network->BackupServerList);
            Network->BackupServerList = NULL;
            Network->TotalBackupServerListEntries = 0;
        }

        if (Network->BackupDomainList != NULL) {
            MIDL_user_free(Network->BackupDomainList);
            Network->BackupDomainList = NULL;
            Network->TotalBackupDomainListEntries = 0;
        }

        BrDestroyResponseCache(Network);

try_exit:NOTHING;
    } finally {

        //
        // Release network
        //

        if (NetLocked) {
            UNLOCK_NETWORK(Network);
        }

        BrDereferenceNetwork( Network );
    }
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\browser\server\browslst.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    browslst.c

Abstract:

    This module contains the worker routines for managing browse lists
    for the browser service

Author:

    Larry Osterman (larryo) 25-Mar-1992

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop

//-------------------------------------------------------------------//
//                                                                   //
// Local function prototypes                                         //
//                                                                   //
//-------------------------------------------------------------------//


RTL_GENERIC_COMPARE_RESULTS
BrCompareBrowseEntry(
    PRTL_GENERIC_TABLE Table,
    PVOID FirstStruct,
    PVOID SecondStruct
    )
{
    PDOMAIN_ENTRY Entry1 = FirstStruct;
    PDOMAIN_ENTRY Entry2 = SecondStruct;

    LONG CompareResult;

    if ((CompareResult = RtlCompareUnicodeString(Entry1->HostName, Entry2->HostName, TRUE) == 0) {
        return GenericEqual;
    } else if (CompareResult  < 0) {
        return GenericLessThan;
    } else {
        return GenericGreaterThan;
    }

}

PVOID
BrAllocateBrowseEntry(
    PRTL_GENERIC_TABLE Table,
    CLONG ByteSize
    )
{
    return((PVOID) MIDL_user_allocate(LMEM_ZEROINIT, (UINT) ByteSize+sizeof(BROWSE_ENTRY)));
}

PVOID
BrFreeBrowseEntry(
    PRTL_GENERIC_TABLE Table,
    CLONG ByteSize
    )
{
    return(MIDL_user_free(ByteSize+sizeof(BROWSE_ENTRY)));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\browser\server\browslst.h ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    browselst.h

Abstract:

    Private header file to be included by Browser service modules that
    need to deal with the browser list.

Author:

    Larry Osterman (larryo) 3-Mar-1992

Revision History:

--*/


#ifndef _BROWSELST_INCLUDED_
#define _BROWSELST_INCLUDED_


//
//  The possible roles of this browser server.
//


#define ROLE_POTENTIAL_BACKUP   0x00000001
#define ROLE_BACKUP             0x00000002
#define ROLE_MASTER             0x00000004
#define ROLE_DOMAINMASTER       0x00000008


//
//  The HOST_ENTRY structure holds the announcement inside a per-network
//  table.
//


typedef struct _HOST_ENTRY {

    //
    //  The HostName is the name of the server.
    //

    UNICODE_STRING HostName;

    //
    //  The HostComment is the comment associated with the server
    //

    UNICODE_STRING HostComment;

    //
    //  Services is a bitmask that indicates the services running on the
    //  server (See LMSERVER.H for details).
    //

    ULONG Services;

    //
    //  The Periodicity is the frequency that the server announces itself.
    //

    ULONG Periodicity;

    //
    //  The MajorVersion and MinorVersion number of the software running on
    //  the server.
    //

    UCHAR MajorVersion;
    UCHAR MinorVersion;

    //
    //  If this server is a backup server, then this links the backup server
    //  into the network block.
    //

    LIST_ENTRY BackupChain;

} HOST_ENTRY, *PHOST_ENTRY;

#endif // _BROWSELST_INCLUDED_

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\browser\server\browsnet.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    browsenet.c

Abstract:

    Code to manage network requests.

Author:

    Larry Osterman (LarryO) 24-Mar-1992

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop


CRITICAL_SECTION NetworkCritSect = {0};

LIST_ENTRY
ServicedNetworks = {0};

ULONG
NumberOfServicedNetworks = 0;


NET_API_STATUS
BrDumpNetworksWorker(
    IN PNETWORK Network,
    IN PVOID Context
    );



VOID
BrInitializeNetworks(
    VOID
    )

/*++

Routine Description:

    Initialization for this source file.

Arguments:

    None.

Return Value:

    Status of operation.

Note: no need to wrap in try-finally since caller is.

--*/
{
    InitializeListHead(&ServicedNetworks);
    InitializeCriticalSection(&NetworkCritSect);

    return;
}


BOOL
BrMapToDirectHost(
    IN PUNICODE_STRING InputNetbiosTransportName,
    OUT WCHAR DirectHostTransportName[MAX_PATH+1]
    )

/*++

Routine Description:

    This routine maps from a Netbios transport and the corresponding
        direct host transport.

    The Netbios transport is PNPed since the redir binds to it.  The direct host
    transport is not PNPed since the redir doesn't bind to it.  This routine
    maps from on to the other to allow both transports to be bound from the
    same PNP event.

Arguments:

    InputNetbiosTransportName - Transport name to map.

    DirectHostTransportName - Corresponding mapped transport name

Return Value:


    TRUE iff there is a mapped equivalent name.

--*/
{

    //
    //  Only mapp if mapping is configured.
    //

    EnterCriticalSection(&BrInfo.ConfigCritSect);

    if (BrInfo.DirectHostBinding != NULL ) {
        LPTSTR_ARRAY TStrArray = BrInfo.DirectHostBinding;
        UNICODE_STRING IpxTransportName;
        UNICODE_STRING NetbiosTransportName;

        while (!NetpIsTStrArrayEmpty(TStrArray)) {

            RtlInitUnicodeString(&IpxTransportName, TStrArray);

            TStrArray = NetpNextTStrArrayEntry(TStrArray);

            ASSERT (!NetpIsTStrArrayEmpty(TStrArray));

            if (!NetpIsTStrArrayEmpty(TStrArray)) {

                RtlInitUnicodeString(&NetbiosTransportName, TStrArray);

                //
                // If the current name matches the one passed,
                //  return the mapped name to the caller.
                //

                if ( RtlEqualUnicodeString( &NetbiosTransportName,
                                            InputNetbiosTransportName,
                                            TRUE )) {
                    wcscpy( DirectHostTransportName,
                            IpxTransportName.Buffer );
                    LeaveCriticalSection(&BrInfo.ConfigCritSect);
                    return TRUE;
                }


                TStrArray = NetpNextTStrArrayEntry(TStrArray);

            }
        }

    }

    LeaveCriticalSection(&BrInfo.ConfigCritSect);
    return FALSE;
}


NET_API_STATUS
BrCreateNetworks(
    PDOMAIN_INFO DomainInfo
    )

/*++

Routine Description:

    Create all of the networks for a particular domain.

Arguments:

    DomainInfo - Specifies the domain being browsed.

Return Value:

    Status of operation.

--*/
{
    NET_API_STATUS NetStatus;
    PLMDR_TRANSPORT_LIST TransportList = NULL ;
    PLMDR_TRANSPORT_LIST TransportEntry;
    BOOLEAN ConfigCritSectLocked = FALSE;

    BrPrint(( BR_NETWORK, "%ws: Creating networks for domain\n", DomainInfo->DomUnicodeDomainName ));

    //
    // Get the list of transports from the datagram receiver.
    //
    NetStatus = BrGetTransportList(&TransportList);

    if ( NetStatus != NERR_Success ) {
        goto Cleanup;
    }

    //
    // Create a Network for each of the transports.
    //
    TransportEntry = TransportList;

    while (TransportEntry != NULL) {

        //
        // Don't do the Direct Host IPX transport here.
        //

        if ( (TransportEntry->Flags & LMDR_TRANSPORT_IPX) == 0 ) {
            UNICODE_STRING TransportName;

            TransportName.Buffer = TransportEntry->TransportName;
            TransportName.Length = (USHORT)TransportEntry->TransportNameLength;
            //
            //  We know the bowser sticks in a null at the end, so the max length
            //  is the length + 1.
            //
            TransportName.MaximumLength = (USHORT)TransportEntry->TransportNameLength+sizeof(WCHAR);

            NetStatus = BrCreateNetwork(
                            &TransportName,
                            TransportEntry->Flags,
                            NULL,
                            DomainInfo );

            if ( NetStatus != NERR_Success ) {
                goto Cleanup;
            }
        }

        if (TransportEntry->NextEntryOffset == 0) {
            TransportEntry = NULL;
        } else {
            TransportEntry = (PLMDR_TRANSPORT_LIST)((PCHAR)TransportEntry+TransportEntry->NextEntryOffset);
        }

    }

    NetStatus = NERR_Success;

Cleanup:

    if ( ConfigCritSectLocked ) {
        LeaveCriticalSection(&BrInfo.ConfigCritSect);
    }
    if ( TransportList != NULL ) {
        MIDL_user_free(TransportList);
    }

    return NetStatus;
}

NET_API_STATUS
BrCreateNetwork(
    IN PUNICODE_STRING TransportName,
    IN ULONG TransportFlags,
    IN PUNICODE_STRING AlternateTransportName OPTIONAL,
    IN PDOMAIN_INFO DomainInfo
    )
/*++

Routine Description:

    This routine allocates memory to hold a network structure, and initializes
    all of its associated data structures.

Arguments:

    TransportName - The name of the transport to add.

    TransportFlags - Flags describing characteristics of the transport

    AlternateTransportName - If specified, this is the name of an alternate
        transport similar to the one being created.

    DomainInfo - Specifies the domain being browsed.


Return Value:

    Status of operation (mostly status of allocations).

--*/
{
    NET_API_STATUS NetStatus;
    PNETWORK Network;
    BOOLEAN NetworkLockInitialized = FALSE;
    BOOLEAN ResponseCacheLockInitialized = FALSE;
    BOOLEAN CanCallBrDestroyNetwork = FALSE;

    BOOLEAN ConfigCritSectLocked = FALSE;

    BrPrint(( BR_NETWORK,
              "%ws: %ws: Creating network.\n",
              DomainInfo->DomUnicodeDomainName,
              TransportName->Buffer ));


    //
    // Check to see if the transport already exists.
    //

    if ((Network = BrFindNetwork( DomainInfo, TransportName)) != NULL) {
        BrDereferenceNetwork( Network );
        return NERR_AlreadyExists;
    }

    //
    // If this transport is explicitly on our list of transports to unbind,
    //  simply ignore the transport.
    //

    if (BrInfo.UnboundBindings != NULL) {
        LPTSTR_ARRAY TStrArray = BrInfo.UnboundBindings;

        while (!NetpIsTStrArrayEmpty(TStrArray)) {
            LPWSTR NewTransportName;

#define NAME_PREFIX L"\\Device\\"
#define NAME_PREFIX_LENGTH 8

            //
            // The transport name in the registry is only optionally prefixed with \device\
            //

            if ( _wcsnicmp( NAME_PREFIX, TStrArray, NAME_PREFIX_LENGTH) == 0 ) {
                NewTransportName = TransportName->Buffer;
            } else {
                NewTransportName = TransportName->Buffer + NAME_PREFIX_LENGTH;
            }

            if ( _wcsicmp( TStrArray, NewTransportName ) == 0 ) {
                BrPrint(( BR_NETWORK, "Binding is marked as unbound: %s (Silently ignoring)\n", TransportName->Buffer ));
                return NERR_Success;
            }

            TStrArray = NetpNextTStrArrayEntry(TStrArray);

        }

    }




    //
    // Create the transport.
    //

    try {

        //
        // Allocate the NETWORK structure.
        //

        Network = MIDL_user_allocate(sizeof(NETWORK));

        if (Network == NULL) {
            try_return(NetStatus = ERROR_NOT_ENOUGH_MEMORY);
        }

        RtlZeroMemory( Network, sizeof(NETWORK) );



        //
        // Initialize those fields that must be initialized before we can call
        // BrDeleteNetwork (on failure).
        //

        RtlInitializeResource(&Network->Lock);

        NetworkLockInitialized = TRUE;
        Network->Role = BrDefaultRole;

        // One for being in ServiceNetworks.  One for this routine's reference.
        Network->ReferenceCount = 2;


        Network->NetworkName.Buffer = MIDL_user_allocate(TransportName->MaximumLength);

        if (Network->NetworkName.Buffer == NULL) {
            try_return(NetStatus = ERROR_NOT_ENOUGH_MEMORY);
        }

        Network->NetworkName.MaximumLength = TransportName->MaximumLength;
        RtlCopyUnicodeString(&Network->NetworkName, TransportName);
        Network->NetworkName.Buffer[Network->NetworkName.Length/sizeof(WCHAR)] = UNICODE_NULL;


        RtlZeroMemory( Network->UncMasterBrowserName, sizeof( Network->UncMasterBrowserName ));

        if ( TransportFlags & LMDR_TRANSPORT_WANNISH ) {
            Network->Flags |= NETWORK_WANNISH;
        }

        if ( TransportFlags & LMDR_TRANSPORT_RAS ) {
            Network->Flags |= NETWORK_RAS;
        }

        if ( TransportFlags & LMDR_TRANSPORT_PDC ) {
            Network->Flags |= NETWORK_PDC;
        }

        InitializeInterimServerList(&Network->BrowseTable,
                                    BrBrowseTableInsertRoutine,
                                    BrBrowseTableUpdateRoutine,
                                    BrBrowseTableDeleteRoutine,
                                    BrBrowseTableAgeRoutine);

        Network->LastBowserDomainQueried = 0;

        InitializeInterimServerList(&Network->DomainList,
                                    BrDomainTableInsertRoutine,
                                    BrDomainTableUpdateRoutine,
                                    BrDomainTableDeleteRoutine,
                                    BrDomainTableAgeRoutine);

        InitializeListHead(&Network->OtherDomainsList);

        InitializeCriticalSection(&Network->ResponseCacheLock);
        ResponseCacheLockInitialized = TRUE;

        InitializeListHead(&Network->ResponseCache);

        Network->TimeCacheFlushed = 0;

        Network->NumberOfCachedResponses = 0;

        EnterCriticalSection(&NetworkCritSect);
        Network->DomainInfo = DomainInfo;
        DomainInfo->ReferenceCount ++;
        InsertHeadList(&ServicedNetworks, &Network->NextNet);
        NumberOfServicedNetworks += 1;

        //
        // Create a worker thread for this network
        //
        BrWorkerCreateThread( NumberOfServicedNetworks );

        LeaveCriticalSection(&NetworkCritSect);


        //
        // Mark that we can now call BrDeleteNetwork upon failure.
        //
        // Continue initializing the network.
        //

        CanCallBrDestroyNetwork = TRUE;

        NetStatus = BrCreateTimer(&Network->UpdateAnnouncementTimer);

        if (NetStatus != NERR_Success) {
            try_return(NetStatus);
        }

        NetStatus = BrCreateTimer(&Network->BackupBrowserTimer);

        if (NetStatus != NERR_Success) {
            try_return(NetStatus);
        }

        NetStatus = BrCreateTimer(&Network->MasterBrowserTimer);

        if (NetStatus != NERR_Success) {
            try_return(NetStatus);
        }

        NetStatus = BrCreateTimer(&Network->MasterBrowserAnnouncementTimer);

        if (NetStatus != NERR_Success) {
            try_return(NetStatus);
        }


        //
        // Handle the alternate transport.
        //

        if (ARGUMENT_PRESENT(AlternateTransportName)) {
            PNETWORK AlternateNetwork = BrFindNetwork( DomainInfo, AlternateTransportName);

            //
            //  If we didn't find an alternate network, or if that network
            //  already has an alternate network, return an error.
            //

            if ( AlternateNetwork == NULL ) {
                BrPrint(( BR_CRITICAL,
                          "%ws: %ws: Creating network. Can't find alternate net %ws\n",
                          DomainInfo->DomUnicodeDomainName,
                          TransportName->Buffer,
                          AlternateTransportName ));
                try_return(NetStatus = NERR_InternalError);
            }

            if (AlternateNetwork->AlternateNetwork != NULL) {
                BrDereferenceNetwork( AlternateNetwork );
                try_return(NetStatus = NERR_InternalError);
            }

            Network->Flags |= NETWORK_IPX;

            //
            //  Link the two networks together.
            //

            Network->AlternateNetwork = AlternateNetwork;

            AlternateNetwork->AlternateNetwork = Network;
            BrDereferenceNetwork( AlternateNetwork );

        } else {
            Network->AlternateNetwork = NULL;
        }

        //
        // Since the Rdr doesn't support this transport,
        //  we actually have to bind ourselves.
        //
        // Bind for Direct host IPX and for emulated domains.
        //

        if ( (Network->Flags & NETWORK_IPX) || DomainInfo->IsEmulatedDomain ) {
            NetStatus = BrBindToTransport( TransportName->Buffer,
                                           DomainInfo->DomUnicodeDomainName,
                                           DomainInfo->DomUnicodeComputerName );

            if ( NetStatus != NERR_Success ) {
                BrPrint(( BR_CRITICAL,
                          "%ws: %ws: Creating network. Can't bind to transport\n",
                          DomainInfo->DomUnicodeDomainName,
                          TransportName->Buffer ));
                try_return( NetStatus );
            }


            Network->Flags |= NETWORK_BOUND;

        }

        //
        //  Post a WaitForRoleChange FsControl on each network the bowser
        //  driver supports.  This FsControl will complete when a "tickle"
        //  packet is received on the machine, or when a master browser loses
        //  an election.
        //

        NetStatus = PostWaitForRoleChange(Network);

        if (NetStatus != NERR_Success) {
            BrPrint(( BR_CRITICAL,
                      "%ws: %ws: Creating network. Can't post wait for role change: %ld\n",
                      DomainInfo->DomUnicodeDomainName,
                      TransportName->Buffer,
                      NetStatus ));
            try_return(NetStatus);
        }

        EnterCriticalSection(&BrInfo.ConfigCritSect);
        ConfigCritSectLocked = TRUE;

        //
        // If MaintainServerList says to automatically determine mastership,
        //   post queryies to the driver.
        //

        if (BrInfo.MaintainServerList == 0) {

            //
            //  Post a BecomeBackup FsControl API on each network the bowser
            //  driver supports.  This FsControl will complete when the master
            //  for the net wants this client to become a backup server.
            //

            NetStatus = PostBecomeBackup( Network );

            if (NetStatus != NERR_Success) {
                BrPrint(( BR_CRITICAL,
                          "%ws: %ws: Creating network. Can't post become backup.\n",
                          DomainInfo->DomUnicodeDomainName,
                          TransportName->Buffer,
                          NetStatus ));
                try_return(NetStatus);
            }

            //
            //  Post a BecomeMaster FsControl on each network the bowser driver
            //  supports.  This FsControl will complete when this machine becomes
            //  a master browser server.
            //

            NetStatus = PostBecomeMaster( Network );

            if (NetStatus != NERR_Success) {
                BrPrint(( BR_CRITICAL,
                          "%ws: %ws: Creating network. Can't post become master.\n",
                          DomainInfo->DomUnicodeDomainName,
                          TransportName->Buffer,
                          NetStatus ));
                try_return(NetStatus);
            }

        }


        //
        //  If this machine is running as domain master browser server, post an
        //  FsControl to retreive master browser announcements.
        //

        if ( Network->Flags & NETWORK_PDC ) {
            NetStatus = PostGetMasterAnnouncement ( Network );

            if (NetStatus != NERR_Success) {
                BrPrint(( BR_CRITICAL,
                          "%ws: %ws: Creating network. Can't post get master announcment.\n",
                          DomainInfo->DomUnicodeDomainName,
                          TransportName->Buffer,
                          NetStatus ));
                // This isn't fatal.  We automatically try again later.
            } else {
                BrPrint(( BR_NETWORK, "%ws: %ws: GetMasterAnnouncement posted.\n",
                              DomainInfo->DomUnicodeDomainName,
                              TransportName->Buffer ));
            }

        }


        //
        //  If we are on either a domain master, or on a lanman/NT machine,
        //  force an election on all our transports to make sure that we're
        //  the master
        //

        if ( (Network->Flags & NETWORK_PDC) != 0 || BrInfo.IsLanmanNt) {
            NetStatus = BrElectMasterOnNet( Network, (PVOID)EVENT_BROWSER_ELECTION_SENT_LANMAN_NT_STARTED );

            if (NetStatus != NERR_Success) {
                BrPrint(( BR_CRITICAL,
                          "%ws: %ws: Creating network. Can't Elect Master.\n",
                          DomainInfo->DomUnicodeDomainName,
                          TransportName->Buffer,
                          NetStatus ));
                // This isn't fatal.
            } else {
                BrPrint(( BR_NETWORK, "%ws: %ws: Election forced on startup.\n",
                              DomainInfo->DomUnicodeDomainName,
                              TransportName->Buffer ));
            }

        }

        //
        //  This machine's browser has MaintainServerList set to either 0 or 1.
        //
        //
        // If MaintainServerList = Auto,
        //  then asynchronously get the master server name for each network
        //  to ensure someone is the master.
        //
        // Ignore failures since this is just priming the domain.
        //

        EnterCriticalSection(&BrInfo.ConfigCritSect);
        if (BrInfo.MaintainServerList == 0) {

            BrGetMasterServerNameAysnc( Network );

            BrPrint(( BR_NETWORK, "%ws: %ws: Find Master queued.\n",
                          DomainInfo->DomUnicodeDomainName,
                          TransportName->Buffer ));

        //
        //  if we're a Lan Manager/NT machine, then we need to always be a backup
        //  browser.
        //

        //
        // MaintainServerList == 1 means Yes
        //

        } else if (BrInfo.MaintainServerList == 1){

            //
            //  Become a backup server now.
            //

            NetStatus = BrBecomeBackup( Network );

            if (NetStatus != NERR_Success) {
                BrPrint(( BR_CRITICAL,
                          "%ws: %ws: Creating network. Can't BecomeBackup.\n",
                          DomainInfo->DomUnicodeDomainName,
                          TransportName->Buffer,
                          NetStatus ));
                // This isn't fatal.
            } else {
                BrPrint(( BR_NETWORK, "%ws: %ws: Became Backup.\n",
                              DomainInfo->DomUnicodeDomainName,
                              TransportName->Buffer ));
            }

        }
        LeaveCriticalSection(&BrInfo.ConfigCritSect);


        //
        // If this isn't already an alternate transport,
        //  and there is a configured alternate transport for this transport,
        //  create the alternate transport now.
        //

        if (!ARGUMENT_PRESENT(AlternateTransportName)) {
            WCHAR DirectHostName[MAX_PATH+1];
            UNICODE_STRING DirectHostNameString;

            if ( BrMapToDirectHost( TransportName, DirectHostName ) ) {

                RtlInitUnicodeString(&DirectHostNameString, DirectHostName );

                BrPrint(( BR_NETWORK, "%ws: %ws: Try adding alternate transport %ws.\n",
                              DomainInfo->DomUnicodeDomainName,
                              TransportName->Buffer,
                              DirectHostName ));

                //
                //  There is a direct host binding on this machine.  We want to add
                //  the direct host transport to the browser.
                //

                NetStatus = BrCreateNetwork(
                            &DirectHostNameString,
                            0,  // No special flags
                            TransportName,
                            DomainInfo );

                if (NetStatus != NERR_Success) {
                    BrPrint(( BR_CRITICAL, "%ws: %ws: Couldn't add alternate transport %ws. %ld\n",
                                  DomainInfo->DomUnicodeDomainName,
                                  TransportName->Buffer,
                                  DirectHostName,
                                  NetStatus ));
                    try_return(NetStatus);
                }
            }
        }



        NetStatus = NERR_Success;

try_exit:NOTHING;
    } finally {

        if ( AbnormalTermination() ) {
            NetStatus = NERR_InternalError;
        }

        if ( ConfigCritSectLocked ) {
            LeaveCriticalSection(&BrInfo.ConfigCritSect);
            ConfigCritSectLocked = FALSE;
        }

        if (NetStatus != NERR_Success) {

            if (Network != NULL) {

                //
                // If we've initialized to the point where we can call
                //  we can call BrDeleteNetwork, do so.
                //

                if ( CanCallBrDestroyNetwork ) {
                    (VOID) BrDeleteNetwork( Network, NULL );

                //
                // Otherwise, just delete what we've created.
                //
                } else {

                    if (ResponseCacheLockInitialized) {
                        DeleteCriticalSection(&Network->ResponseCacheLock);
                    }

                    if (NetworkLockInitialized) {
                        RtlDeleteResource(&Network->Lock);
                    }

                    if (Network->NetworkName.Buffer != NULL) {
                        MIDL_user_free(Network->NetworkName.Buffer);
                    }

                    MIDL_user_free(Network);
                }

            }

        //
        // We're done creating the network.
        // Remove this routines reference to it.
        //

        } else {

            BrDereferenceNetwork( Network );
        }

    }
    return NetStatus;
}

VOID
BrUninitializeNetworks(
    IN DWORD BrInitState
    )
{
    DeleteCriticalSection(&NetworkCritSect);

    NumberOfServicedNetworks = 0;

}

PNETWORK
BrReferenceNetwork(
    PNETWORK PotentialNetwork
    )
/*++

Routine Description:

    This routine will look up a network given a potential pointer to the network.

    This routine is useful if a caller has a pointer to a network but
    hasn't incremented the reference count.  For instance,
    BrIssueAsyncBrowserIoControl calls the async completion routines like that.

Arguments:

    PotentialNetwork - Pointer to the network structure to be verified.

Return Value:

    NULL - No such network exists

    A pointer to the network found.  The found network should be dereferenced
    using BrDereferenceNetwork.

--*/
{
    NTSTATUS Status;
    PLIST_ENTRY NetEntry;

    EnterCriticalSection(&NetworkCritSect);

    for (NetEntry = ServicedNetworks.Flink ;
         NetEntry != &ServicedNetworks;
         NetEntry = NetEntry->Flink ) {
        PNETWORK Network = CONTAINING_RECORD(NetEntry, NETWORK, NextNet);

        if ( PotentialNetwork == Network ) {

            Network->ReferenceCount ++;
            BrPrint(( BR_LOCKS,
                      "%ws: %ws: reference network: %ld\n",
                      Network->DomainInfo->DomUnicodeDomainName,
                      Network->NetworkName.Buffer,
                      Network->ReferenceCount ));
            LeaveCriticalSection(&NetworkCritSect);

            return Network;
        }

    }

    LeaveCriticalSection(&NetworkCritSect);

    return NULL;
}


VOID
BrDereferenceNetwork(
    IN PNETWORK Network
    )
/*++

Routine Description:

    This routine decrements the reference to a network.  If the network reference
    count goes to 0, remove the network.

    On entry, the global NetworkCritSect crit sect may not be locked

Arguments:

    Network - The network to dereference

Return Value:

    None

--*/
{
    NTSTATUS Status;
    ULONG ReferenceCount;

    EnterCriticalSection(&NetworkCritSect);
    ReferenceCount = -- Network->ReferenceCount;
    LeaveCriticalSection(&NetworkCritSect);
    BrPrint(( BR_LOCKS,
              "%ws: %ws: Dereference network: %ld\n",
              Network->DomainInfo->DomUnicodeDomainName,
              Network->NetworkName.Buffer,
              ReferenceCount ));

    if ( ReferenceCount != 0 ) {
        return;
    }

    //
    // The alternate network still has a pointer to this network,
    //  ditch it.
    //

    if ( Network->AlternateNetwork != NULL ) {
        Network->AlternateNetwork->AlternateNetwork = NULL;
    }


    //
    // Tell everyone that this net is going away.
    //

    BrShutdownBrowserForNet( Network, NULL );


    //
    //  If this service did the bind, do the unbind.
    //
    // True for IPX and for emulated domains.
    //

    if (Network->Flags & NETWORK_BOUND) {
        NET_API_STATUS NetStatus;

        NetStatus = BrUnbindFromTransport( Network->NetworkName.Buffer,
                                           Network->DomainInfo->DomUnicodeDomainName );

        if (NetStatus != NERR_Success) {
            BrPrint(( BR_CRITICAL,
                      "%ws: %ws: Unable to unbind from IPX transport\n",
                      Network->DomainInfo->DomUnicodeDomainName,
                      Network->NetworkName.Buffer ));
        }

    }

    UninitializeInterimServerList(&Network->BrowseTable);

    UninitializeInterimServerList(&Network->DomainList);

    if (Network->BackupServerList != NULL) {
        MIDL_user_free(Network->BackupServerList);
    }

    if (Network->BackupDomainList != NULL) {
        MIDL_user_free(Network->BackupDomainList);
    }

    if (Network->NetworkName.Buffer != NULL) {
        MIDL_user_free(Network->NetworkName.Buffer);
    }

    RtlDeleteResource(&Network->Lock);


    BrDestroyResponseCache(Network);

    DeleteCriticalSection(&Network->ResponseCacheLock);

    BrDereferenceDomain( Network->DomainInfo );

    MIDL_user_free(Network);

    return;

}

NET_API_STATUS
BrDeleteNetwork(
    IN PNETWORK Network,
    IN PVOID Context
    )
/*++

Routine Description:

    This routine prevents any new references to the network.  It then removes
    the global reference to the Network allowing it to be deleted.

    Finally, it sleeps until the only reference left is the one held by the caller.
    This ensures the Network will be deleted when the caller Dereferences the
    network.

Arguments:

    Network - The network to remove
        The caller must have a reference to the Network.

    Context - not used.

Return Value:

    NERR_Success - always

--*/
{
    BrPrint(( BR_NETWORK,
              "%ws: %ws: Delete network\n",
              Network->DomainInfo->DomUnicodeDomainName,
              Network->NetworkName.Buffer ));
    //
    // Remove this network from the list to prevent any new references.
    //

    EnterCriticalSection(&NetworkCritSect);
    RemoveEntryList(&Network->NextNet);
    NumberOfServicedNetworks -= 1;
    LeaveCriticalSection(&NetworkCritSect);

    //
    // Prevent new references by the timer routines
    //

    BrDestroyTimer(&Network->MasterBrowserAnnouncementTimer);

    BrDestroyTimer(&Network->MasterBrowserTimer);

    BrDestroyTimer(&Network->BackupBrowserTimer);

    BrDestroyTimer(&Network->UpdateAnnouncementTimer);

    //
    // Decrement the global reference due to being is 'ServicedNetworks'
    //

    BrDereferenceNetwork( Network );


    //
    // Loop until the caller has the last reference.
    //

    EnterCriticalSection(&NetworkCritSect);
    while ( Network->ReferenceCount != 1 ) {
        LeaveCriticalSection(&NetworkCritSect);
        Sleep(1000);
        EnterCriticalSection(&NetworkCritSect);
    }
    LeaveCriticalSection(&NetworkCritSect);

    UNREFERENCED_PARAMETER(Context);

    return NERR_Success;

}


PNETWORK
BrFindNetwork(
    PDOMAIN_INFO DomainInfo,
    PUNICODE_STRING TransportName
    )
/*++

Routine Description:

    This routine will look up a network given a name.

Arguments:

    DomainInfo - Specifies the domain this network is specific to

    TransportName - The name of the transport to look up.

Return Value:

    NULL - No such network exists

    A pointer to the network found.  The found network should be dereferenced
    using BrDereferenceNetwork.

--*/
{
    NTSTATUS Status;
    PLIST_ENTRY NetEntry;

    EnterCriticalSection(&NetworkCritSect);

    for (NetEntry = ServicedNetworks.Flink ;
         NetEntry != &ServicedNetworks;
         NetEntry = NetEntry->Flink ) {
        PNETWORK Network = CONTAINING_RECORD(NetEntry, NETWORK, NextNet);

        if ( Network->DomainInfo == DomainInfo &&
             RtlEqualUnicodeString(&Network->NetworkName, TransportName, TRUE)) {

            Network->ReferenceCount ++;
            BrPrint(( BR_LOCKS,
                      "%ws: %ws: find network: %ld\n",
                      Network->DomainInfo->DomUnicodeDomainName,
                      Network->NetworkName.Buffer,
                      Network->ReferenceCount ));
            LeaveCriticalSection(&NetworkCritSect);

            return Network;
        }

    }

    LeaveCriticalSection(&NetworkCritSect);

    return NULL;
}


PNETWORK
BrFindWannishMasterBrowserNetwork(
    PDOMAIN_INFO DomainInfo
    )
/*++

Routine Description:

    This routine will look up a network that is running IP and is
        a master browser.

Arguments:

    DomainInfo - Specifies the domain this network is specific to

Return Value:

    NULL - No such network exists

    A pointer to the network found.  The found network should be dereferenced
    using BrDereferenceNetwork.

--*/
{
    NTSTATUS Status;
    PLIST_ENTRY NetEntry;

    EnterCriticalSection(&NetworkCritSect);

    for (NetEntry = ServicedNetworks.Flink ;
         NetEntry != &ServicedNetworks;
         NetEntry = NetEntry->Flink ) {
        PNETWORK Network = CONTAINING_RECORD(NetEntry, NETWORK, NextNet);

        //
        // Find a network that is:
        //  for this domain, and
        //  is wannish, and
        //  is a master browser.
        //
        if ( Network->DomainInfo == DomainInfo &&
             (Network->Flags & NETWORK_WANNISH) != 0 &&
             (Network->Role & ROLE_MASTER) != 0 ) {

            Network->ReferenceCount ++;
            BrPrint(( BR_LOCKS,
                      "%ws: %ws: find wannish master network: %ld\n",
                      Network->DomainInfo->DomUnicodeDomainName,
                      Network->NetworkName.Buffer,
                      Network->ReferenceCount ));
            LeaveCriticalSection(&NetworkCritSect);

            return Network;
        }

    }

    LeaveCriticalSection(&NetworkCritSect);

    return NULL;
}

NET_API_STATUS
BrEnumerateNetworks(
    PNET_ENUM_CALLBACK Callback,
    PVOID Context
    )
/*++

Routine Description:

    This routine enumerates all the networks and calls back the specified
    callback routine with the specified context.

Arguments:

    Callback - The callback routine to call.
    Context - Context for the routine.

Return Value:

    Status of operation (mostly status of allocations).

--*/
{
    NET_API_STATUS NetStatus = NERR_Success;
    PLIST_ENTRY NetEntry;
    PNETWORK Network;
    PNETWORK NetworkToDereference = NULL;

    EnterCriticalSection(&NetworkCritSect);


    for (NetEntry = ServicedNetworks.Flink ;
         NetEntry != &ServicedNetworks;
         NetEntry = NetEntry->Flink ) {

        //
        // Reference the next network in the list
        //

        Network = CONTAINING_RECORD(NetEntry, NETWORK, NextNet);
        Network->ReferenceCount ++;
        BrPrint(( BR_LOCKS,
                  "%ws: %ws: enumerate network: %ld\n",
                  Network->DomainInfo->DomUnicodeDomainName,
                  Network->NetworkName.Buffer,
                  Network->ReferenceCount ));

        LeaveCriticalSection(&NetworkCritSect);

        //
        // Dereference any network previously referenced.
        //
        if ( NetworkToDereference != NULL) {
            BrDereferenceNetwork( NetworkToDereference );
            NetworkToDereference = NULL;
        }


        //
        //  Call into the callback routine with this network.
        //

        NetStatus = (Callback)(Network, Context);

        EnterCriticalSection(&NetworkCritSect);

        NetworkToDereference = Network;

        if (NetStatus != NERR_Success) {
            break;
        }

    }

    LeaveCriticalSection(&NetworkCritSect);

     //
     // Dereference the last network
     //
     if ( NetworkToDereference != NULL) {
         BrDereferenceNetwork( NetworkToDereference );
     }

    return NetStatus;

}

NET_API_STATUS
BrEnumerateNetworksForDomain(
    PDOMAIN_INFO DomainInfo OPTIONAL,
    PNET_ENUM_CALLBACK Callback,
    PVOID Context
    )
/*++

Routine Description:

    This routine enumerates all the networks for a specified domain
    and calls back the specified callback routine with the specified context.

Arguments:

    DomainInfo - Specifies the Domain to limit the enumeration to.
        NULL implies the primary domain.

    Callback - The callback routine to call.

    Context - Context for the routine.

Return Value:

    Status of operation (mostly status of allocations).

--*/
{

    NTSTATUS NetStatus = NERR_Success;
    PLIST_ENTRY NetEntry;
    PNETWORK Network;
    PNETWORK NetworkToDereference = NULL;

    //
    // Default to the primary domain.
    //
    if ( DomainInfo == NULL && !IsListEmpty( &ServicedDomains ) ) {
        DomainInfo = CONTAINING_RECORD(ServicedDomains.Flink, DOMAIN_INFO, Next);
    }

    EnterCriticalSection(&NetworkCritSect);


    for (NetEntry = ServicedNetworks.Flink ;
         NetEntry != &ServicedNetworks;
         NetEntry = NetEntry->Flink ) {


        //
        // If the entry isn't for the specified domain,
        //  skip it.
        //
        Network = CONTAINING_RECORD(NetEntry, NETWORK, NextNet);
        if ( Network->DomainInfo != DomainInfo ) {
            continue;
        }

        //
        // Reference the next network in the list
        //
        Network->ReferenceCount ++;
        BrPrint(( BR_LOCKS,
                  "%ws: %ws: enumerate network for domain: %ld\n",
                  Network->DomainInfo->DomUnicodeDomainName,
                  Network->NetworkName.Buffer,
                  Network->ReferenceCount ));

        LeaveCriticalSection(&NetworkCritSect);

        //
        // Dereference any network previously referenced.
        //
        if ( NetworkToDereference != NULL) {
            BrDereferenceNetwork( NetworkToDereference );
            NetworkToDereference = NULL;
        }


        //
        //  Call into the callback routine with this network.
        //

        NetStatus = (Callback)(Network, Context);

        EnterCriticalSection(&NetworkCritSect);

        NetworkToDereference = Network;

        if (NetStatus != NERR_Success) {
            break;
        }

    }

    LeaveCriticalSection(&NetworkCritSect);

     //
     // Dereference the last network
     //
     if ( NetworkToDereference != NULL) {
         BrDereferenceNetwork( NetworkToDereference );
     }

    return NERR_Success;

}

#if DBG

BOOL
BrLockNetwork(
    IN PNETWORK Network,
    IN PCHAR FileName,
    IN ULONG LineNumber
    )
{
    PCHAR File;

    File = strrchr(FileName, '\\');

    if (File == NULL) {
        File = FileName;
    }

    BrPrint(( BR_LOCKS,
              "%ws: %ws: Acquiring network lock %s:%d\n",
              Network->DomainInfo->DomUnicodeDomainName,
              Network->NetworkName.Buffer,
              File,
              LineNumber ));

    if (!RtlAcquireResourceExclusive(&(Network)->Lock, TRUE)) {
        BrPrint(( BR_CRITICAL,
                  "%ws: %ws: Failed to acquire network %s:%d\n",
                  Network->DomainInfo->DomUnicodeDomainName,
                  Network->NetworkName.Buffer,
                  File, LineNumber ));
        return FALSE;

    } else {

        InterlockedIncrement( &Network->LockCount );

        BrPrint(( BR_LOCKS,
                  "%ws: %ws: network lock %s:%d acquired\n",
                  Network->DomainInfo->DomUnicodeDomainName,
                  Network->NetworkName.Buffer,
                  File, LineNumber ));
    }

    return TRUE;

}

BOOL
BrLockNetworkShared(
    IN PNETWORK Network,
    IN PCHAR FileName,
    IN ULONG LineNumber
    )
{
    PCHAR File;

    File = strrchr(FileName, '\\');

    if (File == NULL) {
        File = FileName;
    }

    BrPrint(( BR_LOCKS,
              "%ws: %ws: Acquiring network lock %s:%d\n",
              Network->DomainInfo->DomUnicodeDomainName,
              Network->NetworkName.Buffer,
              File, LineNumber ));

    if (!RtlAcquireResourceShared(&(Network)->Lock, TRUE)) {
        BrPrint(( BR_CRITICAL,
                  "%ws: %ws: failed to acquire network lock %s:%d\n",
                  Network->DomainInfo->DomUnicodeDomainName,
                  Network->NetworkName.Buffer,
                  File, LineNumber ));

        return FALSE;

    } else {

        // Use InterlockedIncrement since we only have a shared lock on the
        // resource.
        InterlockedIncrement( &Network->LockCount );

        BrPrint(( BR_LOCKS,
                  "%ws: %ws: Network lock %s:%d acquired\n",
                  Network->DomainInfo->DomUnicodeDomainName,
                  Network->NetworkName.Buffer,
                  File, LineNumber ));
    }

    return TRUE;

}

VOID
BrUnlockNetwork(
    IN PNETWORK Network,
    IN PCHAR FileName,
    IN ULONG LineNumber
    )
{
    PCHAR File;
    LONG ReturnValue;

    File = strrchr(FileName, '\\');

    if (File == NULL) {
        File = FileName;
    }


    BrPrint(( BR_LOCKS,
              "%ws: %ws: Releasing network lock %s:%d\n",
              Network->DomainInfo->DomUnicodeDomainName,
              Network->NetworkName.Buffer,
              File, LineNumber ));

    //
    //  Decrement the lock count.
    //

    ReturnValue = InterlockedDecrement( &Network->LockCount );

    if ( ReturnValue < 0) {
        BrPrint(( BR_CRITICAL,
                  "%ws: %ws: Over released network lock %s:%d\n",
                  Network->DomainInfo->DomUnicodeDomainName,
                  Network->NetworkName.Buffer,
                  File, LineNumber ));
    }

    RtlReleaseResource(&(Network)->Lock);

    return;
}
#endif



#if DBG
VOID
BrDumpNetworks(
    VOID
    )
/*++

Routine Description:

    This routine will dump the contents of each of the browser network
    structures.

Arguments:

    None.

Return Value:

    None.

--*/
{
    BrEnumerateNetworks(BrDumpNetworksWorker, NULL);
}


NET_API_STATUS
BrDumpNetworksWorker(
    IN PNETWORK Network,
    IN PVOID Context
    )
{
    if (!LOCK_NETWORK(Network))  {
        return NERR_InternalError;
    }

    BrPrint(( BR_CRITICAL,
              "%ws: %ws: Network at %lx\n",
              Network->DomainInfo->DomUnicodeDomainName,
              Network->NetworkName.Buffer,
              Network ));
    BrPrint(( BR_CRITICAL, "    Reference Count: %lx\n", Network->ReferenceCount));
    BrPrint(( BR_CRITICAL, "    Flags: %lx\n", Network->Flags));
    BrPrint(( BR_CRITICAL, "    Role: %lx\n", Network->Role));
    BrPrint(( BR_CRITICAL, "    Master Browser Name: %ws\n", Network->UncMasterBrowserName ));

    UNLOCK_NETWORK(Network);

    return(NERR_Success);
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\browser\server\browsnet.h ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    browsenet.h

Abstract:

    Private header file to be included by Browser service modules that
    need to deal with the network specific browser tables.

Author:

    Rita Wong (ritaw) 22-May-1991

Revision History:

--*/


#ifndef _BROWSENET_INCLUDED_
#define _BROWSENET_INCLUDED_

#define NETWORK_BECOME_MASTER_POSTED        0x00000001
#define NETWORK_ANNOUNCE_NEEDED             0x00000002
#define NETWORK_GET_MASTER_ANNOUNCE_POSTED  0x00000008
#define NETWORK_WANNISH                     0x80000000
#define NETWORK_RAS                         0x40000000
#define NETWORK_IPX                         0x20000000
#define NETWORK_BOUND                       0x10000000
#define NETWORK_PDC                         0x08000000

#define OTHERDOMAIN_INVALID                 0x00000001

typedef struct _NET_OTHER_DOMAIN {
    LIST_ENTRY  Next;
    ULONG       Flags;
    WCHAR       Name[DNLEN+1];
} NET_OTHER_DOMAIN, *PNET_OTHER_DOMAIN;

//
//  Network.
//
//  Almost all of the browser data structures are tied to the "Network"
//  structure.
//
//  It contains the browse list for the network and information about the
//  domain (including the name of the master, etc).
//

typedef struct _NETWORK {
    //
    //  The Lock protects the contents of the network structure, including
    //  the browse list, backup list and domain list.
    //

    RTL_RESOURCE Lock;

    LONG LockCount;

    ULONG Flags;

    //
    //  The NextNet list links the structure to other networks.
    //

    LIST_ENTRY NextNet;

    //
    // Domain this network is specific to
    //

    PDOMAIN_INFO DomainInfo;

    //
    //  The ReferenceCount indicates the number of threads accessing this
    //  network structure.
    //

    ULONG ReferenceCount;

    //
    //  The NetworkName is the name of the network driver that is used
    //  to access the network.  This is used to identify the network
    //  to the bowser driver so it can return the correct network list.
    //

    UNICODE_STRING NetworkName;         // Name of network (\Device\Nbf)

    struct _NETWORK *AlternateNetwork;  // Alternate name for network (if IPX).

    //
    //  This is a bitmask indicating the role of this browser server.
    //

    ULONG Role;

    ULONG MasterAnnouncementIndex;

    ULONG UpdateAnnouncementIndex;

    ULONG NumberOfFailedBackupTimers;

    ULONG NumberOfFailedPromotions;

    ULONG NumberOfPromotionEventsLogged;

    LONG LastBackupBrowserReturned;

    LONG LastDomainControllerBrowserReturned;

    //
    //  The time we stopped being a backup browser.
    //

    ULONG TimeStoppedBackup;

    //
    //  The UncMasterBrowserName contains the name of the master browser server
    //  for this network.
    //

    WCHAR UncMasterBrowserName[UNCLEN+1];   // Name of master browser server

    //
    //  Timer used when server is a backup browser server.
    //
    //  When it expires, the browser downloads a new browser server
    //  list from the master browser server.
    //

    BROWSER_TIMER BackupBrowserTimer;

    //
    // Timer used if SMB server refuses an announcement
    //

    BROWSER_TIMER UpdateAnnouncementTimer;

    //
    //  Server and domain list for backup browser (and # of entries in each).
    //

    PSERVER_INFO_101    BackupServerList;
    DWORD               TotalBackupServerListEntries;
    DWORD               BytesToHoldBackupServerList;

    PSERVER_INFO_101    BackupDomainList;
    DWORD               TotalBackupDomainListEntries;
    DWORD               BytesToHoldBackupDomainList;

    //
    //  Lock protecting MasterFlags section of Network structure.
    //

    ULONG   MasterFlags;
    ULONG   MasterBrowserTimerCount;    //  # of times we've run the master timer.

    //
    //  Master browsers maintain their server list in an "interim server
    //  list", not as raw data from the server.
    //

    ULONG               LastBowserServerQueried;
    INTERIM_SERVER_LIST BrowseTable;    // Browse list for network.

    ULONG               LastBowserDomainQueried;
    INTERIM_SERVER_LIST DomainList;     // List of domains active on network

    //
    //  If the browser's role is MasterBrowserServer, then the
    //  OtherDomainsList contains the list of other domains.
    //

    LIST_ENTRY OtherDomainsList; // List of domain master browser.

    //
    //  Timer used when server is a master browser server.
    //
    //  When it expires, the master browser downloads a new browser
    //  server list from the domain master browser server
    //

    BROWSER_TIMER MasterBrowserTimer;

    //
    //  Timer used to announce the domain.
    //

    BROWSER_TIMER MasterBrowserAnnouncementTimer;

    //
    //  List of cached browser responses.
    //

    CRITICAL_SECTION ResponseCacheLock;

    LIST_ENTRY ResponseCache;

    //
    //  For browse masters, this is the time the cache was last flushed.
    //
    //  Every <n> seconds, we will age the cache on the master and refresh
    //  the list with the list from the driver.
    //

    DWORD   TimeCacheFlushed;

    DWORD   NumberOfCachedResponses;

} NETWORK, *PNETWORK;

#if DBG
BOOL
BrLockNetwork(
    IN PNETWORK Network,
    IN PCHAR FileName,
    IN ULONG LineNumber
    );

BOOL
BrLockNetworkShared(
    IN PNETWORK Network,
    IN PCHAR FileName,
    IN ULONG LineNumber
    );

VOID
BrUnlockNetwork(
    IN PNETWORK Network,
    IN PCHAR FileName,
    IN ULONG LineNumber
    );

#define LOCK_NETWORK(Network)   BrLockNetwork(Network, __FILE__, __LINE__)

#define LOCK_NETWORK_SHARED(Network)   BrLockNetworkShared(Network, __FILE__, __LINE__)

#define UNLOCK_NETWORK(Network)   BrUnlockNetwork(Network, __FILE__, __LINE__)

#else

#define LOCK_NETWORK(Network)   RtlAcquireResourceExclusive(&(Network)->Lock, TRUE)

#define LOCK_NETWORK_SHARED(Network)   RtlAcquireResourceShared(&(Network)->Lock, TRUE)

#define UNLOCK_NETWORK(Network)   RtlReleaseResource(&(Network)->Lock)

#endif

//
//  The NET_ENUM_CALLBACK is a callback for BrEnumerateNetworks.
//
//  It defines a routine that takes two parameters, the first is a network
//  structure, the second is a context for that network.
//


typedef
NET_API_STATUS
(*PNET_ENUM_CALLBACK)(
    PNETWORK Network,
    PVOID Context
    );


VOID
BrInitializeNetworks(
    VOID
    );

VOID
BrUninitializeNetworks(
    IN ULONG BrInitState
    );

PNETWORK
BrReferenceNetwork(
    PNETWORK PotentialNetwork
    );

VOID
BrDereferenceNetwork(
    IN PNETWORK Network
    );

PNETWORK
BrFindNetwork(
    PDOMAIN_INFO DomainInfo,
    PUNICODE_STRING TransportName
    );

PNETWORK
BrFindWannishMasterBrowserNetwork(
    PDOMAIN_INFO DomainInfo
    );

VOID
BrDumpNetworks(
    VOID
    );

NET_API_STATUS
BrEnumerateNetworks(
    PNET_ENUM_CALLBACK Callback,
    PVOID Context
    );

NET_API_STATUS
BrEnumerateNetworksForDomain(
    PDOMAIN_INFO DomainInfo,
    PNET_ENUM_CALLBACK Callback,
    PVOID Context
    );

NET_API_STATUS
BrCreateNetworks(
    PDOMAIN_INFO DomainInfo
    );

NET_API_STATUS
BrCreateNetwork(
    PUNICODE_STRING TransportName,
    IN ULONG TransportFlags,
    IN PUNICODE_STRING AlternateTransportName OPTIONAL,
    IN PDOMAIN_INFO DomainInfo
    );

NET_API_STATUS
BrDeleteNetwork(
    IN PNETWORK Network,
    IN PVOID Context
    );

extern ULONG NumberOfServicedNetworks;

extern CRITICAL_SECTION NetworkCritSect;

#endif  // _BROWSENET_INCLUDED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\browser\server\brsec.h ===
/*++

Copyright (c) 1991-1996 Microsoft Corporation

Module Name:

    brsec.h

Abstract:

    Private header file to be included by Browser service modules that
    need to enforce security.

Author:

    Cliff Van Dyke (CliffV) 22-Aug-1991

Revision History:

--*/

//
// brsecure.c will #include this file with BRSECURE_ALLOCATE defined.
// That will cause each of these variables to be allocated.
//
#ifdef BRSECURE_ALLOCATE
#define EXTERN
#else
#define EXTERN extern
#endif

//-------------------------------------------------------------------//
//                                                                   //
// Object specific access masks                                      //
//                                                                   //
//-------------------------------------------------------------------//

//
// ConfigurationInfo specific access masks
//
#define BROWSER_CONTROL_ACCESS       0x0001
#define BROWSER_QUERY_ACCESS         0x0002

#define BROWSER_ALL_ACCESS           (STANDARD_RIGHTS_REQUIRED    | \
                                      BROWSER_CONTROL_ACCESS      | \
                                      BROWSER_QUERY_ACCESS )


//
// Object type names for audit alarm tracking
//
#define BROWSER_SERVICE_OBJECT       TEXT("BrowserService")

//
// Security descriptors of Browser Service objects to control user accesses.
//

EXTERN PSECURITY_DESCRIPTOR BrGlobalBrowserSecurityDescriptor;

//
// Generic mapping for each Browser Service object object
//

EXTERN GENERIC_MAPPING BrGlobalBrowserInfoMapping
#ifdef BRSECURE_ALLOCATE
    = {
    STANDARD_RIGHTS_READ,                  // Generic read
    STANDARD_RIGHTS_WRITE,                 // Generic write
    STANDARD_RIGHTS_EXECUTE,               // Generic execute
    BROWSER_ALL_ACCESS                     // Generic all
    }
#endif // BRSECURE_ALLOCATE
    ;


NTSTATUS
BrCreateBrowserObjects(
    VOID
    );

#undef EXTERN
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\browser\server\brsec.c ===
/*++

Copyright (c) 1991-1996  Microsoft Corporation

Module Name:

    brsec.c

Abstract:

    This module contains the Browser service support routines
    which create security objects and enforce security _access checking.

Author:

    Cliff Van Dyke (CliffV) 22-Aug-1991

Revision History:

--*/


#include "precomp.h"
#pragma hdrstop


//
// Include brsec.h again allocating the actual variables
// this time around.
//

#define BRSECURE_ALLOCATE
#include "brsec.h"
#undef BRSECURE_ALLOCATE


NTSTATUS
BrCreateBrowserObjects(
    VOID
    )
/*++

Routine Description:

    This function creates the workstation user-mode objects which are
    represented by security descriptors.

Arguments:

    None.

Return Value:

    NT status code

--*/
{
    NTSTATUS Status;

    //
    // Order matters!  These ACEs are inserted into the DACL in the
    // following order.  Security access is granted or denied based on
    // the order of the ACEs in the DACL.
    //
    //
    // Members of Group SECURITY_LOCAL aren't allowed to do a UAS logon
    // to force it to be done remotely.
    //

    ACE_DATA AceData[] = {

        {ACCESS_ALLOWED_ACE_TYPE, 0, 0,
               GENERIC_ALL,                &AliasAdminsSid},

        {ACCESS_ALLOWED_ACE_TYPE, 0, 0,
               BROWSER_CONTROL_ACCESS,     &AliasSystemOpsSid},

        {ACCESS_ALLOWED_ACE_TYPE, 0, 0,
               BROWSER_CONTROL_ACCESS,     &LocalSystemSid},

        {ACCESS_ALLOWED_ACE_TYPE, 0, 0,
               BROWSER_QUERY_ACCESS,       &WorldSid}
    };

    //
    // Actually create the security descriptor.
    //

    Status = NetpCreateSecurityObject(
               AceData,
               sizeof(AceData)/sizeof(AceData[0]),
               AliasAdminsSid,
               AliasAdminsSid,
               &BrGlobalBrowserInfoMapping,
               &BrGlobalBrowserSecurityDescriptor );

    return Status;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\browser\server\brwan.h ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    brwan.h

Abstract:

    This module contains definitions for WAN support routines used by the
    Browser service.

Author:

    Larry Osterman (LarryO) 22-Nov-1992

Revision History:

--*/

#ifndef _BRWAN_
#define _BRWAN_

NET_API_STATUS NET_API_FUNCTION
I_BrowserrQueryOtherDomains(
    IN BROWSER_IDENTIFY_HANDLE ServerName,
    IN OUT LPSERVER_ENUM_STRUCT    InfoStruct,
    OUT LPDWORD                TotalEntries
    );

NET_API_STATUS NET_API_FUNCTION
I_BrowserrQueryPreConfiguredDomains(
    IN BROWSER_IDENTIFY_HANDLE  ServerName,
    IN OUT LPSERVER_ENUM_STRUCT InfoStruct,
    OUT LPDWORD                 TotalEntries
    );

NET_API_STATUS
BrWanMasterInitialize(
    IN PNETWORK Network
    );

#endif // _BRWAN_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\browser\server\brwan.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    brwan.c

Abstract:

    This module contains WAN support routines used by the
    Browser service.

Author:

    Larry Osterman (LarryO) 22-Nov-1992

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop

//-------------------------------------------------------------------//
//                                                                   //
// Local function prototypes                                         //
//                                                                   //
//-------------------------------------------------------------------//

NET_API_STATUS
BrAddDomainEntry(
    IN PINTERIM_SERVER_LIST InterimServerList,
    IN LPTSTR ConfigEntry
    );


//-------------------------------------------------------------------//
//                                                                   //
// Global variables                                                  //
//                                                                   //
//-------------------------------------------------------------------//


//-------------------------------------------------------------------//
//                                                                   //
// Global routines                                                   //
//                                                                   //
//-------------------------------------------------------------------//
NET_API_STATUS NET_API_FUNCTION
I_BrowserrQueryOtherDomains(
    IN BROWSER_IDENTIFY_HANDLE ServerName,
    IN OUT LPSERVER_ENUM_STRUCT    InfoStruct,
    OUT LPDWORD                TotalEntries
    )

/*++

Routine Description:

    This routine returns the list of "other domains" configured for this
    machine.  It is only valid on primary domain controllers.  If it is called
    on a machine that is not a PDC, it will return NERR_NotPrimary.


Arguments:

    IN BROWSER_IDENTIFY_HANDLE ServerName - Ignored.
    IN LPSERVER_ENUM_STRUCT InfoStruct - Returns the list of other domains
                                        as a SERVER_INFO_100 structure.
    OUT LPDWORD TotalEntries - Returns the total number of other domains.

Return Value:

    NET_API_STATUS - The status of this request.

--*/

{
    NET_API_STATUS Status;
    PSERVER_INFO_100 ServerInfo;
    ULONG NumberOfOtherDomains;

    if ( InfoStruct == NULL ) {
        return ERROR_INVALID_PARAMETER;
    }

    if (InfoStruct->Level != 100) {
        return(ERROR_INVALID_LEVEL);
    }

    if ( InfoStruct->ServerInfo.Level100 == NULL ) {
        return ERROR_INVALID_PARAMETER;
    }

    //
    // Use the worker routine to do the actual work.
    //

    Status = BrQueryOtherDomains( &ServerInfo, &NumberOfOtherDomains );

    if ( Status == NERR_Success ) {
        *TotalEntries = NumberOfOtherDomains;

        InfoStruct->ServerInfo.Level100->Buffer = ServerInfo;
        InfoStruct->ServerInfo.Level100->EntriesRead = NumberOfOtherDomains;
    }

    return Status;

}


NET_API_STATUS
BrWanMasterInitialize(
    IN PNETWORK Network
    )
/*++

Routine Description:
    This routine initializes the wan information for a new master.

--*/
{
    LPBYTE Buffer = NULL;
    PSERVER_INFO_100 ServerInfo;
    NET_API_STATUS Status;
    ULONG i;
    ULONG EntriesRead;
    ULONG TotalEntries;
    PDOMAIN_CONTROLLER_INFO  pDcInfo=NULL;


    //
    //  If we're on the PDC, then all our initialization has been done.
    //  Or, if we're semi-pseudo server, we don't contact the PDC/BDC
    //


#ifdef ENABLE_PSEUDO_BROWSER
    if ( (Network->Flags & NETWORK_PDC) ||
         BrInfo.PseudoServerLevel == BROWSER_SEMI_PSEUDO_NO_DMB ) {
#else
    if ( Network->Flags & NETWORK_PDC ) {
#endif
        return NERR_Success;
    }

    Status = DsGetDcName( NULL, NULL, NULL, NULL,
                          DS_PDC_REQUIRED    |
                          DS_BACKGROUND_ONLY |
                          DS_RETURN_FLAT_NAME,
                          &pDcInfo );

    //
    //  It is not an error to not be able to contact the PDC.
    //

    if (Status != NERR_Success) {
        return NERR_Success;
    }

    ASSERT ( pDcInfo &&
             pDcInfo->DomainControllerName );

    Status = I_BrowserQueryOtherDomains(pDcInfo->DomainControllerName,
                                        &Buffer,
                                        &EntriesRead,
                                        &TotalEntries);

    //
    //  We don't need the PDC name any more.
    //
    NetApiBufferFree((LPVOID)pDcInfo);
    pDcInfo = NULL;

    if (Status != NERR_Success) {

        //
        // We failed to get the list from supposedly the PDC.
        // It could be that the role has changed & DsGetDcName's cache
        // hasn't got refreshed.
        //
        // Force PDC discovery so that next time around we're sure
        // to get the real PDC.
        //

        Status = DsGetDcName( NULL, NULL, NULL, NULL,
                           DS_PDC_REQUIRED    |
                           DS_FORCE_REDISCOVERY |       // Note FORCE option
                           DS_RETURN_FLAT_NAME,
                           &pDcInfo );

        if (Status != NERR_Success) {
            return NERR_Success;
        }

        ASSERT ( pDcInfo &&
                 pDcInfo->DomainControllerName );

        Status = I_BrowserQueryOtherDomains(pDcInfo->DomainControllerName,
                                            &Buffer,
                                            &EntriesRead,
                                            &TotalEntries);

        //
        //  We don't need the PDC name any more.
        //
        NetApiBufferFree((LPVOID)pDcInfo);

        if (Status != NERR_Success) {
            return NERR_Success;
        }
    }


    if (!LOCK_NETWORK(Network)) {
        return NERR_InternalError;
    }

    try {
        PLIST_ENTRY Entry;
        PLIST_ENTRY NextEntry;

        //
        //  Scan the other domains list and turn on the active bit for each
        //  other domain.
        //

        for (Entry = Network->OtherDomainsList.Flink;
             Entry != &Network->OtherDomainsList ;
             Entry = Entry->Flink) {
             PNET_OTHER_DOMAIN OtherDomain = CONTAINING_RECORD(Entry, NET_OTHER_DOMAIN, Next);

             OtherDomain->Flags |= OTHERDOMAIN_INVALID;
        }

        ServerInfo = (PSERVER_INFO_100)Buffer;

        for (i = 0; i < EntriesRead; i++ ) {

            //
            //  Add this as an other domain.
            //
            for (Entry = Network->OtherDomainsList.Flink;
                 Entry != &Network->OtherDomainsList ;
                 Entry = Entry->Flink) {
                PNET_OTHER_DOMAIN OtherDomain = CONTAINING_RECORD(Entry, NET_OTHER_DOMAIN, Next);

                //
                //  If this name is in the other domains list, it's not invalid
                //  and we should flag that we've seen the domain name.
                //
                // The list we're getting is over the net. Make sure serverinfo
                // contains a valid name for comparison (see bug 377078)
                // Skip processing if NULL.
                // If ServerInfo got NULLED out in prev run, we shouldn't
                // get into _wcsicmp.

                if (ServerInfo->sv100_name &&
                    !_wcsicmp(OtherDomain->Name, ServerInfo->sv100_name)) {
                    OtherDomain->Flags &= ~OTHERDOMAIN_INVALID;
                    ServerInfo->sv100_name = NULL;
                }
            }

            ServerInfo ++;
        }

        //
        //  Scan the other domains list and remove any domains that are
        //  still marked as invalid.
        //

        for (Entry = Network->OtherDomainsList.Flink;
             Entry != &Network->OtherDomainsList ;
             Entry = NextEntry) {
             PNET_OTHER_DOMAIN OtherDomain = CONTAINING_RECORD(Entry, NET_OTHER_DOMAIN, Next);

             if (OtherDomain->Flags & OTHERDOMAIN_INVALID) {
                 NextEntry = Entry->Flink;

                 //
                 //  Remove this entry from the list.
                 //

                 RemoveEntryList(Entry);

                 BrRemoveOtherDomain(Network, OtherDomain->Name);

                 MIDL_user_free(OtherDomain);

             } else {
                 NextEntry = Entry->Flink;
             }
        }

        //
        //  Now scan the domain list from the PDC and add any entries that
        //  weren't there already.
        //

        ServerInfo = (PSERVER_INFO_100)Buffer;

        for (i = 0; i < EntriesRead; i++ ) {

            if (ServerInfo->sv100_name != NULL) {
                PNET_OTHER_DOMAIN OtherDomain = MIDL_user_allocate(sizeof(NET_OTHER_DOMAIN));

                if (OtherDomain != NULL) {

                    Status = BrAddOtherDomain(Network, ServerInfo->sv100_name);

                    //
                    //  If we were able to add the other domain, add it to our
                    //  internal structure.
                    //

                    if (Status == NERR_Success) {
                        wcscpy(OtherDomain->Name, ServerInfo->sv100_name);
                        OtherDomain->Flags = 0;
                        InsertHeadList(&Network->OtherDomainsList, &OtherDomain->Next);
                    } else {
                        LPWSTR SubString[1];

                        SubString[0] = ServerInfo->sv100_name;

                        BrLogEvent(EVENT_BROWSER_OTHERDOMAIN_ADD_FAILED, Status, 1, SubString);
                    }
                }
            }

            ServerInfo ++;
        }




    } finally {
        UNLOCK_NETWORK(Network);

        if (Buffer != NULL) {
            MIDL_user_free(Buffer);
        }

    }
    return NERR_Success;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\browser\server\brutil.h ===
/*++

Copyright (c) 1991 Microsoft Corporation

Module Name:

    brutil.h

Abstract:

    Private header file for the NT Workstation service included by every module
    module of the Workstation service.

Author:

    Rita Wong (ritaw) 15-Feb-1991

Revision History:

--*/

#ifndef _BRUTIL_INCLUDED_
#define _BRUTIL_INCLUDED_

//
// This include file will be included by tstring.h if Unicode
// is defined.
//
#ifndef UNICODE
#include <stdlib.h>                     // Unicode string functions
#endif

#include "br.h"


//
// An invalid parameter is encountered.  Return the value to identify
// the parameter at fault.
//
#define RETURN_INVALID_PARAMETER(ErrorParameter, ParameterId) \
    if (ARGUMENT_PRESENT(ErrorParameter)) {                   \
        *ErrorParameter = ParameterId;                        \
    }                                                         \
    return ERROR_INVALID_PARAMETER;



//-------------------------------------------------------------------//
//                                                                   //
// Type definitions                                                  //
//                                                                   //
//-------------------------------------------------------------------//


//-------------------------------------------------------------------//
//                                                                   //
// Function prototypes of utility routines found in wsutil.c         //
//                                                                   //
//-------------------------------------------------------------------//

NET_API_STATUS
BrMapStatus(
    IN  NTSTATUS NtStatus
    );

ULONG
BrCurrentSystemTime(VOID);

VOID
BrLogEvent(
    IN ULONG MessageId,
    IN ULONG ErrorCode,
    IN ULONG NumberOfSubStrings,
    IN LPWSTR *SubStrings
    );

#if DBG
VOID
BrOpenTraceLogFile(
    VOID
    );

VOID
BrowserTrace(
    ULONG DebugFlag,
    PCHAR FormatString,
    ...
    );

VOID
BrInitializeTraceLog(
    VOID
    );

VOID
BrUninitializeTraceLog(
    VOID
    );

NET_API_STATUS
BrTruncateLog(
    VOID
    );

#endif
#endif // ifndef _WSUTIL_INCLUDED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\browser\server\brutil.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    brutil.c

Abstract:

    This module contains miscellaneous utility routines used by the
    Browser service.

Author:

    Rita Wong (ritaw) 01-Mar-1991

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop

//-------------------------------------------------------------------//
//                                                                   //
// Local function prototypes                                         //
//                                                                   //
//-------------------------------------------------------------------//


//-------------------------------------------------------------------//
//                                                                   //
// Global variables                                                  //
//                                                                   //
//-------------------------------------------------------------------//



NET_API_STATUS
BrMapStatus(
    IN  NTSTATUS NtStatus
    )
/*++

Routine Description:

    This function takes an NT status code and maps it to the appropriate
    error code expected from calling a LAN Man API.

Arguments:

    NtStatus - Supplies the NT status.

Return Value:

    Returns the appropriate LAN Man error code for the NT status.

--*/
{
    //
    // A small optimization for the most common case.
    //
    if (NT_SUCCESS(NtStatus)) {
        return NERR_Success;
    }

    switch (NtStatus) {
        case STATUS_OBJECT_NAME_COLLISION:
            return ERROR_ALREADY_ASSIGNED;

        case STATUS_OBJECT_NAME_NOT_FOUND:
            return NERR_UseNotFound;

        case STATUS_REDIRECTOR_STARTED:
            return NERR_ServiceInstalled;

        default:
            return NetpNtStatusToApiStatus(NtStatus);
    }

}


ULONG
BrCurrentSystemTime()
{
    NTSTATUS Status;
    SYSTEM_TIMEOFDAY_INFORMATION TODInformation;
    LARGE_INTEGER CurrentTime;
    ULONG TimeInSecondsSince1980 = 0;       // happy prefix 112576
    ULONG BootTimeInSecondsSince1980 = 0;   //        ""

    Status = NtQuerySystemInformation(SystemTimeOfDayInformation,
                            &TODInformation,
                            sizeof(TODInformation),
                            NULL);

    if (!NT_SUCCESS(Status)) {
        return(0);
    }

    Status = NtQuerySystemTime(&CurrentTime);

    if (!NT_SUCCESS(Status)) {
        return(0);
    }

    RtlTimeToSecondsSince1980(&CurrentTime, &TimeInSecondsSince1980);
    RtlTimeToSecondsSince1980(&TODInformation.BootTime, &BootTimeInSecondsSince1980);

    return(TimeInSecondsSince1980 - BootTimeInSecondsSince1980);

}


VOID
BrLogEvent(
    IN ULONG MessageId,
    IN ULONG ErrorCode,
    IN ULONG NumberOfSubStrings,
    IN LPWSTR *SubStrings
    )
{
    DWORD Severity;
    WORD Type;
    PVOID RawData;
    ULONG RawDataSize;


    //
    // Log the error code specified
    //

    Severity = (MessageId & 0xc0000000) >> 30;

    if (Severity == STATUS_SEVERITY_WARNING) {
        Type = EVENTLOG_WARNING_TYPE;
    } else if (Severity == STATUS_SEVERITY_SUCCESS) {
        Type = EVENTLOG_SUCCESS;
    } else if (Severity == STATUS_SEVERITY_INFORMATIONAL) {
        Type = EVENTLOG_INFORMATION_TYPE;
    } else if (Severity == STATUS_SEVERITY_ERROR) {
        Type = EVENTLOG_ERROR_TYPE;
    } else {
        // prefix uninit var consistency.
        ASSERT(!"Unknown event log type!!");
        return;
    }

    if (ErrorCode == NERR_Success) {
        RawData = NULL;
        RawDataSize = 0;
    } else {
        RawData = &ErrorCode;
        RawDataSize = sizeof(DWORD);
    }

    //
    // Use netlogon's routine to write eventlog messages.
    //  (It ditches duplicate events.)
    //

    NetpEventlogWrite (
        BrGlobalEventlogHandle,
        MessageId,
        Type,
        RawData,
        RawDataSize,
        SubStrings,
        NumberOfSubStrings );

}

#if DBG

#define TRACE_FILE_SIZE 256

VOID
BrResetTraceLogFile(
    VOID
    );

CRITICAL_SECTION
BrowserTraceLock = {0};

HANDLE
BrowserTraceLogHandle = NULL;

DWORD
BrTraceLogFileSize = 0;

BOOLEAN BrowserTraceInitialized = {0};

VOID
BrowserTrace(
    ULONG DebugFlag,
    PCHAR FormatString,
    ...
    )
#define LAST_NAMED_ARGUMENT FormatString

{
    CHAR OutputString[4096];
    ULONG length;
    ULONG BytesWritten;
    static BeginningOfLine = TRUE;

    va_list ParmPtr;                    // Pointer to stack parms.

    if (!BrowserTraceInitialized) {
        return;
    }

    //
    // If we aren't debugging this functionality, just return.
    //
    if ( DebugFlag != 0 && (BrInfo.BrowserDebug & DebugFlag) == 0 ) {
        return;
    }

    EnterCriticalSection(&BrowserTraceLock);
    length = 0;

    try {

        if (BrowserTraceLogHandle == NULL) {
            //
            // We've not opened the trace log file yet, so open it.
            //

            BrOpenTraceLogFile();
        }

        if (BrowserTraceLogHandle == INVALID_HANDLE_VALUE) {
            LeaveCriticalSection(&BrowserTraceLock);
            return;
        }

        //
        //  Attempt to catch bad trace.
        //

        for (BytesWritten = 0; BytesWritten < strlen(FormatString) ; BytesWritten += 1) {
            if (FormatString[BytesWritten] > 0x7f) {
                DbgBreakPoint();
            }
        }


        //
        // Handle the beginning of a new line.
        //
        //

        if ( BeginningOfLine ) {
            SYSTEMTIME SystemTime;

            //
            // Put the timestamp at the begining of the line.
            //
            GetLocalTime( &SystemTime );
            length += (ULONG) sprintf( &OutputString[length],
                                  "%02u/%02u %02u:%02u:%02u ",
                                  SystemTime.wMonth,
                                  SystemTime.wDay,
                                  SystemTime.wHour,
                                  SystemTime.wMinute,
                                  SystemTime.wSecond );


            //
            // Indicate the type of message on the line
            //
            {
                char *Text;

                switch (DebugFlag) {
                case BR_CRITICAL:
                    Text = "[CRITICAL]"; break;
                case BR_INIT:
                    Text = "[INIT]   "; break;
                case BR_SERVER_ENUM:
                    Text = "[ENUM]   "; break;
                case BR_UTIL:
                    Text = "[UTIL]   "; break;
                case BR_CONFIG:
                    Text = "[CONFIG] "; break;
                case BR_MAIN:
                    Text = "[MAIN]   "; break;
                case BR_BACKUP:
                    Text = "[BACKUP] "; break;
                case BR_MASTER:
                    Text = "[MASTER] "; break;
                case BR_DOMAIN:
                    Text = "[DOMAIN] "; break;
                case BR_NETWORK:
                    Text = "[NETWORK]"; break;
                case BR_TIMER:
                    Text = "[TIMER]"; break;
                case BR_QUEUE:
                    Text = "[QUEUE]"; break;
                case BR_LOCKS:
                    Text = "[LOCKS]"; break;
                default:
                    Text = "[UNKNOWN]"; break;
                }
                length += (ULONG) sprintf( &OutputString[length], "%s ", Text );
            }
        }

        //
        // Put a the information requested by the caller onto the line
        //

        va_start(ParmPtr, FormatString);

        length += (ULONG) vsprintf(&OutputString[length], FormatString, ParmPtr);
        BeginningOfLine = (length > 0 && OutputString[length-1] == '\n' );
        if ( BeginningOfLine ) {
            OutputString[length-1] = '\r';
            OutputString[length] = '\n';
            OutputString[length+1] = '\0';
            length++;
        }

        va_end(ParmPtr);

        ASSERT(length <= sizeof(OutputString));


        //
        // Actually write the bytes.
        //

        if (!WriteFile(BrowserTraceLogHandle, OutputString, length, &BytesWritten, NULL)) {
            KdPrint(("Error writing to Browser log file: %ld\n", GetLastError()));
            KdPrint(("%s", OutputString));
            return;
        }

        if (BytesWritten != length) {
            KdPrint(("Error writing time to Browser log file: %ld\n", GetLastError()));
            KdPrint(("%s", OutputString));
            return;
        }

        //
        // If the file has grown too large,
        //  truncate it.
        //

        BrTraceLogFileSize += BytesWritten;

        if (BrTraceLogFileSize > BrInfo.BrowserDebugFileLimit) {
            BrResetTraceLogFile();
        }

    } finally {
        LeaveCriticalSection(&BrowserTraceLock);
    }
}


VOID
BrInitializeTraceLog()
{

    try {
        InitializeCriticalSection(&BrowserTraceLock);
        BrowserTraceInitialized = TRUE;
    } except ( EXCEPTION_EXECUTE_HANDLER ) {
#if DBG
        KdPrint( ("[Browser.dll]: Exception <%lu>. Failed to initialize trace log\n",
                 _exception_code() ) );
#endif
    }

}

VOID
BrGetTraceLogRoot(
    IN PWCHAR TraceFile
    )
{
    PSHARE_INFO_502 ShareInfo;

    //
    //  If the DEBUG share exists, put the log file in that directory,
    //  otherwise, use the system root.
    //
    //  This way, if the browser is running on an NTAS server, we can always
    //  get access to the log file.
    //

    if (NetShareGetInfo(NULL, L"DEBUG", 502, (PCHAR *)&ShareInfo) != NERR_Success) {

        if (GetSystemDirectory(TraceFile, TRACE_FILE_SIZE*sizeof(WCHAR)) == 0)  {
            KdPrint(("Unable to get system directory: %ld\n", GetLastError()));
        }

        if (TraceFile[wcslen(TraceFile)] != L'\\') {
            TraceFile[wcslen(TraceFile)+1] = L'\0';
            TraceFile[wcslen(TraceFile)] = L'\\';
        }

    } else {
        //
        //  Seed the trace file buffer with the local path of the netlogon
        //  share if it exists.
        //

        wcscpy(TraceFile, ShareInfo->shi502_path);

        TraceFile[wcslen(ShareInfo->shi502_path)] = L'\\';
        TraceFile[wcslen(ShareInfo->shi502_path)+1] = L'\0';

        NetApiBufferFree(ShareInfo);
    }

}

VOID
BrResetTraceLogFile(
    VOID
    )
{
    WCHAR OldTraceFile[TRACE_FILE_SIZE];
    WCHAR NewTraceFile[TRACE_FILE_SIZE];

    if (BrowserTraceLogHandle != NULL) {
        CloseHandle(BrowserTraceLogHandle);
    }

    BrowserTraceLogHandle = NULL;

    BrGetTraceLogRoot(OldTraceFile);

    wcscpy(NewTraceFile, OldTraceFile);

    wcscat(OldTraceFile, L"Browser.Log");

    wcscat(NewTraceFile, L"Browser.Bak");

    //
    //  Delete the old log
    //

    DeleteFile(NewTraceFile);

    //
    //  Rename the current log to the new log.
    //

    MoveFile(OldTraceFile, NewTraceFile);

    BrOpenTraceLogFile();

}

VOID
BrOpenTraceLogFile(
    VOID
    )
{
    WCHAR TraceFile[TRACE_FILE_SIZE];

    BrGetTraceLogRoot(TraceFile);

    wcscat(TraceFile, L"Browser.Log");

    BrowserTraceLogHandle = CreateFile(TraceFile,
                                        GENERIC_WRITE,
                                        FILE_SHARE_READ,
                                        NULL,
                                        OPEN_ALWAYS,
                                        FILE_ATTRIBUTE_NORMAL,
                                        NULL);


    if (BrowserTraceLogHandle == INVALID_HANDLE_VALUE) {
        KdPrint(("Error creating trace file %ws: %ld\n", TraceFile, GetLastError()));

        return;
    }

    BrTraceLogFileSize = SetFilePointer(BrowserTraceLogHandle, 0, NULL, FILE_END);

    if (BrTraceLogFileSize == 0xffffffff) {
        KdPrint(("Error setting trace file pointer: %ld\n", GetLastError()));

        return;
    }
}

VOID
BrUninitializeTraceLog()
{
    DeleteCriticalSection(&BrowserTraceLock);

    if (BrowserTraceLogHandle != NULL) {
        CloseHandle(BrowserTraceLogHandle);
    }

    BrowserTraceLogHandle = NULL;

    BrowserTraceInitialized = FALSE;

}

NET_API_STATUS
BrTruncateLog()
{
    if (BrowserTraceLogHandle == NULL) {
        BrOpenTraceLogFile();
    }

    if (BrowserTraceLogHandle == INVALID_HANDLE_VALUE) {
        return ERROR_GEN_FAILURE;
    }

    if (SetFilePointer(BrowserTraceLogHandle, 0, NULL, FILE_BEGIN) == 0xffffffff) {
        return GetLastError();
    }

    if (!SetEndOfFile(BrowserTraceLogHandle)) {
        return GetLastError();
    }

    return NO_ERROR;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\browser\server\brwins.c ===
/*++

Copyright (c) 1991-1992  Microsoft Corporation

Module Name:

    brwins.c

Abstract:

    This module contains the routines to interface with the WINS name server.

Author:

    Larry Osterman

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop

//
// Addresses of procedures in winsrpc.dll
//

DWORD (__RPC_API *BrWinsGetBrowserNames)( PWINSINTF_BIND_DATA_T, PWINSINTF_BROWSER_NAMES_T);
VOID (__RPC_API *BrWinsFreeMem)(LPVOID);
CHAR BrWinsScopeId[256];

NET_API_STATUS
BrOpenNetwork (
    IN PUNICODE_STRING NetworkName,
    OUT PHANDLE NetworkHandle
    )
/*++

Routine Description:

    This routine opens the NT LAN Man Datagram Receiver driver.

Arguments:

    None.

Return Value:

    NET_API_STATUS - NERR_Success or reason for failure.

--*/
{
    NTSTATUS ntstatus;

    IO_STATUS_BLOCK IoStatusBlock;
    OBJECT_ATTRIBUTES ObjectAttributes;

    //
    // Open the transport device directly.
    //
    InitializeObjectAttributes(
        &ObjectAttributes,
        NetworkName,
        OBJ_CASE_INSENSITIVE,
        NULL,
        NULL
        );

    ntstatus = NtOpenFile(
                   NetworkHandle,
                   SYNCHRONIZE,
                   &ObjectAttributes,
                   &IoStatusBlock,
                   0,
                   0
                   );

    if (NT_SUCCESS(ntstatus)) {
        ntstatus = IoStatusBlock.Status;
    }

    if (! NT_SUCCESS(ntstatus)) {
        KdPrint(("NtOpenFile network driver failed: 0x%08lx\n",
                     ntstatus));
    }

    return NetpNtStatusToApiStatus(ntstatus);
}

NET_API_STATUS
BrGetWinsServerName(
    IN PUNICODE_STRING NetworkName,
    OUT LPWSTR *PrimaryWinsServerAddress,
    OUT LPWSTR *SecondaryWinsServerAddress
    )
{
    NET_API_STATUS status;
    HANDLE netHandle;
    tWINS_ADDRESSES winsAddresses;
    DWORD bytesReturned;
    PCHAR p;
    DWORD count;

    status = BrOpenNetwork(NetworkName, &netHandle);

    if (status != NERR_Success) {
        return status;
    }

    if (!DeviceIoControl(netHandle,
                        IOCTL_NETBT_GET_WINS_ADDR,
                        NULL, 0,
                        &winsAddresses, sizeof(winsAddresses),
                        &bytesReturned, NULL)) {
        status = GetLastError();

        CloseHandle(netHandle);
        return status;
    }

    CloseHandle(netHandle);

    *PrimaryWinsServerAddress = MIDL_user_allocate((3+1+3+1+3+1+3+1) * sizeof(TCHAR));

    if (*PrimaryWinsServerAddress == NULL) {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    p = (PCHAR)&winsAddresses.PrimaryWinsServer;

    count = swprintf(*PrimaryWinsServerAddress, L"%d.%d.%d.%d", p[3] & 0xff, p[2] & 0xff, p[1] & 0xff, p[0] & 0xff);

    ASSERT (count < 3 + 1 + 3 + 1 + 3 + 1 + 3 + 1);

    *SecondaryWinsServerAddress = MIDL_user_allocate((3+1+3+1+3+1+3+1) * sizeof(TCHAR));

    if (*SecondaryWinsServerAddress == NULL) {
        MIDL_user_free(*PrimaryWinsServerAddress);

        *PrimaryWinsServerAddress = NULL;

        return ERROR_NOT_ENOUGH_MEMORY;
    }

    p = (PCHAR)&winsAddresses.BackupWinsServer;

    count = swprintf(*SecondaryWinsServerAddress, L"%d.%d.%d.%d", p[3] & 0xff, p[2] & 0xff, p[1] & 0xff, p[0] & 0xff);

    ASSERT (count < 3 + 1 + 3 + 1 + 3 + 1 + 3 + 1);

    return NERR_Success;
}




VOID
BrWinsGetScopeId(
    VOID
    )

/*++

Routine Description:

    This code was stolen from the nbtstat command.

    This procedure save the netbt scope id in the global variable BrWinsScopeId.
    On any error, a NULL scope ID will be used.

Arguments:


Return Value:

    0 if successful, -1 otherwise.

--*/

{
    DWORD WinStatus;

    HKEY Key;
    DWORD BufferSize;
    DWORD Type;



    //
    // Open the registry key containing the scope id.
    //
    WinStatus = RegOpenKeyExA(
                     HKEY_LOCAL_MACHINE,
                     "system\\currentcontrolset\\services\\netbt\\parameters",
                     0,
                     KEY_READ,
                     &Key);

    if ( WinStatus != ERROR_SUCCESS) {
        *BrWinsScopeId = '\0';
        return;
    }


    //
    // Read the scope id value.
    //
    BufferSize = sizeof(BrWinsScopeId)-1;

    WinStatus = RegQueryValueExA(
                    Key,
                    "ScopeId",
                    NULL,
                    &Type,
                    (LPBYTE) &BrWinsScopeId[1],
                    &BufferSize );

    (VOID) RegCloseKey( Key );

    if ( WinStatus != ERROR_SUCCESS) {
        *BrWinsScopeId = '\0';
        return;
    }

    //
    // If there is no scope id (just a zero byte),
    //  just return an empty string.
    // otherise
    //  return a '.' in front of the scope id.
    //
    // This matches what WINS returns from WinsGetBrowserNames.
    //

    if ( BufferSize == 0 || BrWinsScopeId[1] == '\0' ) {
        *BrWinsScopeId = '\0';
    } else {
        *BrWinsScopeId = '.';
    }

    return;

}

DWORD
BrLoadWinsrpcDll(
    VOID
    )
/*++

Routine Description:

    This routine loads the WinsRpc DLL and locates all the procedures the browser calls

Arguments:

    None.

Return Value:

    Status of the operation

--*/
{
    DWORD WinStatus;
    HANDLE hModule;

    //
    // If the library is already loaded,
    //  just return.
    //

    if (BrWinsGetBrowserNames != NULL) {
        return NERR_Success;
    }

    //
    // Load the library.
    //

    hModule = LoadLibraryA("winsrpc");

    if (NULL == hModule) {
        WinStatus = GetLastError();
        return WinStatus;
    }

    //
    // Locate all of the procedures needed.
    //

    BrWinsGetBrowserNames =
        (DWORD (__RPC_API *)( PWINSINTF_BIND_DATA_T, PWINSINTF_BROWSER_NAMES_T))
        GetProcAddress( hModule, "WinsGetBrowserNames" );

    if (BrWinsGetBrowserNames == NULL) {
        WinStatus = GetLastError();
        FreeLibrary( hModule );
        return WinStatus;
    }


    BrWinsFreeMem =
        (VOID (__RPC_API *)(LPVOID))
        GetProcAddress( hModule, "WinsFreeMem" );

    if (BrWinsFreeMem == NULL) {
        WinStatus = GetLastError();
        FreeLibrary( hModule );
        return WinStatus;
    }

    //
    // Initialize BrWinsScopeId
    //

    BrWinsGetScopeId();

    return NERR_Success;
}

NET_API_STATUS
BrQuerySpecificWinsServer(
    IN  LPWSTR WinsServerAddress,
    OUT PVOID *WinsServerList,
    OUT PDWORD EntriesInList,
    OUT PDWORD TotalEntriesInList
    )
{
    WINSINTF_BIND_DATA_T bindData;
    NET_API_STATUS status;
    PVOID winsDomainInformation = NULL;
    PSERVER_INFO_101 serverInfo;
    WINSINTF_BROWSER_NAMES_T names;
    DWORD i,j;
    LPWSTR serverInfoEnd;
    LPWSTR SavedServerInfoEnd;
    DWORD bufferSize;

    //
    // Load winsrpc.dll
    //

    status = BrLoadWinsrpcDll();

    if (status != NERR_Success) {
        return status;
    }

    //
    // Get the list of domain names from WINS
    //

    bindData.fTcpIp = TRUE;
    bindData.pServerAdd = (LPSTR)WinsServerAddress;
    names.pInfo = NULL;

    status = (*BrWinsGetBrowserNames)(&bindData, &names);

    if ( status != NERR_Success ) {
        return status;
    }


    //
    // Convert the WINS domain list into server list format.
    //
    bufferSize = (sizeof(SERVER_INFO_101) + ((CNLEN + 1) *sizeof(WCHAR))) * names.EntriesRead;

    (*WinsServerList) = winsDomainInformation = MIDL_user_allocate( bufferSize );

    if (winsDomainInformation == NULL) {
        (*BrWinsFreeMem)(names.pInfo);

        return ERROR_NOT_ENOUGH_MEMORY;
    }

    serverInfo = winsDomainInformation;
    serverInfoEnd = (LPWSTR)((PCHAR)winsDomainInformation + bufferSize);

    *TotalEntriesInList = names.EntriesRead;
    *EntriesInList = 0;

    for (i = 0; i < names.EntriesRead ; i += 1) {
        OEM_STRING OemString;
        UNICODE_STRING UnicodeString;
        CHAR WinsName[CNLEN+1];
        WCHAR UnicodeWinsName[CNLEN+1];

        //
        // Make up information about this domain.
        //
        serverInfo->sv101_platform_id = PLATFORM_ID_NT;
        serverInfo->sv101_version_major = 0;
        serverInfo->sv101_version_minor = 0;
        serverInfo->sv101_type = SV_TYPE_DOMAIN_ENUM | SV_TYPE_NT;

        //
        // Ignore entries that don't have a 1B as the 16th byte.
        //  (They really do, but they have a zero byte in the name.  So,
        //  it probably isn't a domain name, just a name that happens to have a
        //  1B in the sixteenth byte.)
        //

        if ( lstrlenA(names.pInfo[i].pName) < NETBIOS_NAME_LEN ) {
            continue;
        }


        //
        // Filter out those entries whose scope id doesn't match ours
        //

        if ( lstrcmpA( &names.pInfo[i].pName[NETBIOS_NAME_LEN], BrWinsScopeId) != 0 ) {
            continue;
        }



        //
        // Truncate the 0x1b and spaces from the domain name.
        //
        lstrcpynA(WinsName, names.pInfo[i].pName, sizeof(WinsName) );
        WinsName[CNLEN] = '\0';

        for (j = CNLEN-1 ; j ; j -= 1 ) {
            if (WinsName[j] != ' ') {
                break;
            }
        }
        WinsName[j+1] = '\0';

        RtlInitString(&OemString, WinsName);
        UnicodeString.Buffer = UnicodeWinsName;
        UnicodeString.MaximumLength = sizeof(UnicodeWinsName);

        status = RtlOemStringToUnicodeString(&UnicodeString, &OemString, FALSE);

        if (!NT_SUCCESS(status)) {

            //
            // Ignore bogus entries
            //
            continue;
        }

        serverInfo->sv101_name = UnicodeString.Buffer;

        SavedServerInfoEnd = serverInfoEnd;
        if (NetpPackString(&serverInfo->sv101_name,
                        (PCHAR)(serverInfo+1),
                        &serverInfoEnd)) {

            // Set an empty comment simply by using the existing 0 on the end
            // of the server name.
            serverInfo->sv101_comment = SavedServerInfoEnd - 1;

            *EntriesInList += 1;

        }

        serverInfo += 1;

    }

    (*BrWinsFreeMem)(names.pInfo);

    return NERR_Success;
}


NET_API_STATUS
BrQueryWinsServer(
    IN LPWSTR PrimaryWinsServerAddress,
    IN LPWSTR SecondaryWinsServerAddress,
    OUT PVOID WinsServerList,
    OUT PDWORD EntriesInList,
    OUT PDWORD TotalEntriesInList
    )
{
    NET_API_STATUS status;
    status = BrQuerySpecificWinsServer(PrimaryWinsServerAddress,
                                        WinsServerList,
                                        EntriesInList,
                                        TotalEntriesInList);

    if (status == NERR_Success) {
        return status;
    }

    status = BrQuerySpecificWinsServer(SecondaryWinsServerAddress,
                                        WinsServerList,
                                        EntriesInList,
                                        TotalEntriesInList);

    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\browser\server\brwins.h ===
/*++

Copyright (c) 1991-1992  Microsoft Corporation

Module Name:

    brwins.c

Abstract:

    This module contains the routines to interface with the WINS name server.

Author:

    Larry Osterman

Revision History:

--*/
#ifndef _BRWINS_
#define _BRWINS_

NET_API_STATUS
BrGetWinsServerName(
    IN PUNICODE_STRING Network,
    OUT LPTSTR *PrimaryWinsServerAddress,
    OUT LPTSTR *SecondaryWinsServerAddress
    );

NET_API_STATUS
BrQueryWinsServer(
    IN LPTSTR PrimaryWinsServerAddress,
    IN LPTSTR SecondaryWinsServerAddress,
    OUT PVOID WinsServerList,
    OUT PDWORD EntriesInList,
    OUT PDWORD TotalEntriesInList
    );

NET_API_STATUS
BrQuerySpecificWinsServer(
    IN LPTSTR WinsServerAddress,
    OUT PVOID *WinsServerList,
    OUT PDWORD EntriesInList,
    OUT PDWORD TotalEntriesInList
    );
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\browser\server\precomp.h ===
#include "br.h"
#include <string.h>
#include "bowser.h"
#include <stdlib.h>
#include <ctype.h>
#include "brdevice.h"
#include "brwins.h"
#include <lmaccess.h>
#include <dsgetdc.h>
#include <ntlsa.h>
#include "config.h"
#include "confname.h"
#include <winreg.h>
#include <netevent.h>
#include "brutil.h"
#include "hostannc.h"
#include "tstring.h"
#include "brsec.h"
#include <svcs.h>
#include "srvann.h"
#include "names.h"
#include "browsdom.h"
#include "netlib.h"
#include <time.h>
#include <stdarg.h>
#include <stdio.h>
#include <lmshare.h>
#include <lmapibuf.h>
#include <lmserver.h>
#include "xstypes.h"
#include "xsprocsp.h"
#include <process.h>
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <nb30.h>
#include <winsintf.h>
#include <nbtioctl.h>
#include <secobj.h>     // NetpAccessCheck
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\dfs\import.h ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    import.h

Abstract:

    This file allows us to include standard system header files in the
    .idl file.  The main .idl file imports a file called import.idl.
    This allows the .idl file to use the types defined in these header
    files.  It also causes the following line to be added in the
    MIDL generated header file:

    #include "import.h"

    Thus these types are available to the RPC stub routines as well.

Author:

    Dan Lafferty (danl)     07-May-1991

Revision History:


--*/

#include <windef.h>
#include <lmcons.h>

#ifdef MIDL_PASS
#define LPWSTR [string] LPWSTR
#endif

#include <lmdfs.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\browser\server\srvenum.h ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    srvenum.h

Abstract:

    Private header file to be included by Browser service modules that need
    to know about server enumeration routines (including the browse cache
    modules).


Author:

    Larry Osterman (larryo) 23-Jun-1993

Revision History:

--*/


#ifndef _SRVENUM_INCLUDED_
#define _SRVENUM_INCLUDED_

//
//  Cached browse response.
//
//  The cached browse request structure is used to hold the response to
//  a NetServerEnum request.
//
//  If a NetServerEnum request comes in through Xactsrv, the browser will
//  look up to see if there is a cached browse that matches this request,
//  and if there is, it will simply return that request to the caller.
//
//
//  In a nutshell, this is how the response cache works:
//
//    The browser keeps a list of all of the browse requests that come into the
//    browser.  This list is keyed by Level, ServerType, and buffer size.  The
//    actual chain is protected by a CriticalSection called the
//    ResponseCacheLock.  Entries in the list are protected by the global
//    network lock.
//
//    When a browse request is received from Xactsrv, the browser looks up
//    the request in the response cache, and if it finds a matching response,
//    it increments 2 hit counters.  The first hit counter indicates he number
//    of hits the request has seen since the last time the cache was aged.
//    The second indicates the total number of hits over the lifetime of the
//    browser for this response.
//
//    If the lifetime hit count is over the configurable hit limit, the
//    browser will save a copy of the response buffer associated with the
//    request.  Any and all subsequent browse requests will use this buffer
//    for their response instead of converting the response.
//
//    When a call is made to BrAgeResponseCache, the browser will scan the
//    cache and free up all of the cached responses.  It will also delete
//    any responses that have a hit count less than the hit limit.
//

typedef struct _CACHED_BROWSE_RESPONSE {
    LIST_ENTRY  Next;           // Pointer to next request.
    DWORD       HitCount;       // Hitcount for this cached request.
    DWORD       TotalHitCount;  // Total hit count for this request.
    DWORD       LowHitCount;    // Number of passes with a low hit count.
    DWORD       ServerType;     // Server type.
    DWORD       Level;          // Level of request
    WORD        Size;           // Request size
    WORD        Converter;      // Converter (used by client to get strings right).

    PVOID       Buffer;         // Response buffer.
    DWORD       EntriesRead;    // Number of entries in cached list
    DWORD       TotalEntries;   // Total # of entries available.
    WORD        Status;         // Status of request.
    WCHAR       FirstNameToReturn[CNLEN+1]; // Name of first entry in buffer
} CACHED_BROWSE_RESPONSE, *PCACHED_BROWSE_RESPONSE;




PCACHED_BROWSE_RESPONSE
BrLookupAndAllocateCachedEntry(
    IN PNETWORK Network,
    IN DWORD ServerType,
    IN WORD Size,
    IN ULONG Level,
    IN LPCWSTR FirstNameToReturn
    );

NET_API_STATUS
BrDestroyResponseCache(
    IN PNETWORK Network
    );

NET_API_STATUS
BrDestroyCacheEntry(
    IN PCACHED_BROWSE_RESPONSE CacheEntry
    );

VOID
BrAgeResponseCache(
    IN PNETWORK Network
    );

PCACHED_BROWSE_RESPONSE
BrAllocateResponseCacheEntry(
    IN PNETWORK Network,
    IN DWORD ServerType,
    IN WORD Size,
    IN ULONG Level,
    IN LPCWSTR FirstNameToReturn
    );

extern LIST_ENTRY
ServicedNetworks;

#endif  // _SRVENUM_INCLUDED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\dfs\client\dfsacl.h ===
//+----------------------------------------------------------------------------
//
//  Copyright (C) 1998, Microsoft Corporation
//
//  File:       dfsacl.h
//
//  Contents:   Functions to add/remove entries (ACEs) from DS ACL lists
//
//  Classes:    None
//
//  History:    Nov 6, 1998 JHarper created
//
//-----------------------------------------------------------------------------

#ifndef _DFS_ACL_
#define _DFS_ACL_

DWORD
DfsAddMachineAce(
    LDAP *pldap,
    LPWSTR wszDcName,
    LPWSTR wszObjectName,
    LPWSTR wszRootName);

DWORD
DfsRemoveMachineAce(
    LDAP *pldap,
    LPWSTR wszDcName,
    LPWSTR wszObjectName,
    LPWSTR wszRootName);

#endif // _DFS_ACL_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\browser\server\srvenum.c ===
/*++

Copyright (c) 1991-1992  Microsoft Corporation

Module Name:

    srvenum.c

Abstract:

    This module contains the worker routine for the NetServerEnum API
    implemented by the Workstation service.

Author:

    Rita Wong (ritaw) 25-Mar-1991

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop

NET_API_STATUS NET_API_FUNCTION
BrNetServerEnum(
    IN PNETWORK Network OPTIONAL,
    IN LPCWSTR ClientName OPTIONAL,
    IN ULONG Level,
    IN DWORD PreferedMaximumLength,
    OUT PVOID *Buffer,
    OUT LPDWORD EntriesRead,
    OUT LPDWORD TotalEntries,
    IN DWORD ServerType,
    IN LPCWSTR Domain,
    IN LPCWSTR FirstNameToReturn OPTIONAL
    );

NET_API_STATUS
BrRetrieveServerListForMaster(
    IN PNETWORK Network,
    IN OUT PVOID *Buffer,
    OUT PDWORD EntriesRead,
    OUT PDWORD TotalEntries,
    IN DWORD Level,
    IN DWORD ServerType,
    IN DWORD PreferedMaximumLength,
    IN BOOLEAN LocalListOnly,
    IN LPTSTR ClientName,
    IN LPTSTR DomainName,
    IN LPCWSTR FirstNameToReturn
    );

NET_API_STATUS
BrRetrieveServerListForBackup(
    IN PNETWORK Network,
    IN OUT PVOID *Buffer,
    OUT PDWORD EntriesRead,
    OUT PDWORD TotalEntries,
    IN DWORD Level,
    IN DWORD ServerType,
    IN DWORD PreferedMaximumLength,
    IN LPCWSTR FirstNameToReturn
    );

//
// This points to XsConvertServerEnumBuffer, which is dynamically loaded from
//  xactsrv.dll when required
//
XS_CONVERT_SERVER_ENUM_BUFFER_FUNCTION *pXsConvertServerEnumBuffer = NULL;


NET_API_STATUS NET_API_FUNCTION
I_BrowserrServerEnum(
    IN  LPTSTR ServerName OPTIONAL,
    IN  LPTSTR TransportName OPTIONAL,
    IN  LPTSTR ClientName OPTIONAL,
    IN  OUT LPSERVER_ENUM_STRUCT InfoStruct,
    IN  DWORD PreferedMaximumLength,
    OUT LPDWORD TotalEntries,
    IN  DWORD ServerType,
    IN  LPTSTR Domain,
    IN  OUT LPDWORD ResumeHandle OPTIONAL
    )
/*++

Routine Description:

    This function is the NetServerEnum entry point in the Workstation service.

Arguments:

    ServerName - Supplies the name of server to execute this function

    TransportName - Supplies the name of xport on which to enumerate servers

    InfoStruct - This structure supplies the level of information requested,
        returns a pointer to the buffer allocated by the Workstation service
        which contains a sequence of information structure of the specified
        information level, and returns the number of entries read.  The buffer
        pointer is set to NULL if return code is not NERR_Success or
        ERROR_MORE_DATA, or if EntriesRead returned is 0.  The EntriesRead
        value is only valid if the return code is NERR_Success or
        ERROR_MORE_DATA.

    PreferedMaximumLength - Supplies the number of bytes of information
        to return in the buffer.  If this value is MAXULONG, we will try
        to return all available information if there is enough memory
        resource.

    TotalEntries - Returns the total number of entries available.  This value
        is returned only if the return code is NERR_Success or ERROR_MORE_DATA.

    ServerType - Supplies the type of server to enumerate.

    Domain - Supplies the name of one of the active domains to enumerate the
        servers from.  If NULL, servers from the primary domain, logon domain
        and other domains are enumerated.

    ResumeHandle - Supplies and returns the point to continue with enumeration.

Return Value:

    NET_API_STATUS - NERR_Success or reason for failure.

--*/
{
    NET_API_STATUS NetStatus;

    NetStatus = I_BrowserrServerEnumEx(
                    ServerName,
                    TransportName,
                    ClientName,
                    InfoStruct,
                    PreferedMaximumLength,
                    TotalEntries,
                    ServerType,
                    Domain,
                    NULL );     // NULL FirstNameToReturn

    if (ARGUMENT_PRESENT(ResumeHandle)) {
        *ResumeHandle = 0;
    }

    return NetStatus;
}


NET_API_STATUS NET_API_FUNCTION
I_BrowserrServerEnumEx(
    IN  LPTSTR ServerName OPTIONAL,
    IN  LPTSTR TransportName OPTIONAL,
    IN  LPTSTR ClientName OPTIONAL,
    IN  OUT LPSERVER_ENUM_STRUCT InfoStruct,
    IN  DWORD PreferedMaximumLength,
    OUT LPDWORD TotalEntries,
    IN  DWORD ServerType,
    IN  LPTSTR Domain,
    IN  LPTSTR FirstNameToReturnArg
    )
/*++

Routine Description:

    This function is the NetServerEnum entry point in the Workstation service.

Arguments:

    ServerName - Supplies the name of server to execute this function

    TransportName - Supplies the name of xport on which to enumerate servers

    InfoStruct - This structure supplies the level of information requested,
        returns a pointer to the buffer allocated by the Workstation service
        which contains a sequence of information structure of the specified
        information level, and returns the number of entries read.  The buffer
        pointer is set to NULL if return code is not NERR_Success or
        ERROR_MORE_DATA, or if EntriesRead returned is 0.  The EntriesRead
        value is only valid if the return code is NERR_Success or
        ERROR_MORE_DATA.

    PreferedMaximumLength - Supplies the number of bytes of information
        to return in the buffer.  If this value is MAXULONG, we will try
        to return all available information if there is enough memory
        resource.

    TotalEntries - Returns the total number of entries available.  This value
        is returned only if the return code is NERR_Success or ERROR_MORE_DATA.

    ServerType - Supplies the type of server to enumerate.

    Domain - Supplies the name of one of the active domains to enumerate the
        servers from.  If NULL, servers from the primary domain, logon domain
        and other domains are enumerated.

    FirstNameToReturnArg - Supplies the name of the first domain or server entry to return.
        The caller can use this parameter to implement a resume handle of sorts by passing
        the name of the last entry returned on a previous call.  (Notice that the specified
        entry will, also, be returned on this call unless it has since been deleted.)
        Pass NULL to start with the first entry available.

Return Value:

    NET_API_STATUS - NERR_Success or reason for failure.

--*/
{
    NET_API_STATUS status;
    PVOID Buffer = NULL;
    ULONG EntriesRead;
    BOOLEAN NetworkLocked = FALSE;
    PNETWORK Network = NULL;
    UNICODE_STRING NetworkName;
    WCHAR FirstNameToReturn[DNLEN+1];
    PDOMAIN_INFO DomainInfo = NULL;
#if DBG
    DWORD StartTickCount, EndTickCount;
#endif

    UNREFERENCED_PARAMETER(ServerName);

#if DBG
    StartTickCount = GetTickCount();
#endif

    if (!ARGUMENT_PRESENT(TransportName)) {
        status = ERROR_INVALID_PARAMETER;
        goto Cleanup;
    }
    if (!ARGUMENT_PRESENT(InfoStruct)) {
        status = ERROR_INVALID_PARAMETER;
        goto Cleanup;
    }

    if ( InfoStruct->Level == 101 &&
         !InfoStruct->ServerInfo.Level101 ) {
        status = ERROR_INVALID_PARAMETER;
        goto Cleanup;
    } else if ( InfoStruct->Level == 100 &&
                !InfoStruct->ServerInfo.Level100 ) {
        status = ERROR_INVALID_PARAMETER;
        goto Cleanup;
    }

#ifdef ENABLE_PSEUDO_BROWSER
    //
    // Pseudo Server returns nothing
    //
    if (BrInfo.PseudoServerLevel == BROWSER_PSEUDO) {
        if (InfoStruct->Level == 101) {
            InfoStruct->ServerInfo.Level101->Buffer = NULL;
            InfoStruct->ServerInfo.Level101->EntriesRead = 0;
        } else {
            InfoStruct->ServerInfo.Level100->Buffer = NULL;
            InfoStruct->ServerInfo.Level100->EntriesRead = 0;
        }
        status = ERROR_SUCCESS;
        goto Cleanup;
    }
#endif


    //
    // Find the requested domain.
    //

    DomainInfo = BrFindDomain( Domain, TRUE );

    if ( DomainInfo == NULL) {
        status = ERROR_NO_SUCH_DOMAIN;
        goto Cleanup;
    }

    //
    // Find the requested network
    //

    RtlInitUnicodeString(&NetworkName, TransportName);

    Network = BrFindNetwork( DomainInfo, &NetworkName);

    if (Network == NULL) {
        BrPrint(( BR_CRITICAL,
                  "%ws: %ws: BrowserrServerEnum: Network not found.\n",
                  Domain,
                  TransportName));
        status = ERROR_FILE_NOT_FOUND;
        goto Cleanup;
    }

    //
    // If the caller has asked us to use the alternate transport,
    //  do so.
    //

    if ((ServerType != SV_TYPE_ALL) &&
        (ServerType & SV_TYPE_ALTERNATE_XPORT) ) {

        //
        //  If this transport has an alternate network, then actually
        //  query the alternate name, not the real one.
        //

        if (Network->AlternateNetwork != NULL) {
            PNETWORK TempNetwork = Network;
            Network = Network->AlternateNetwork;
            if ( !BrReferenceNetwork( Network )) {
                Network = TempNetwork;
                status = ERROR_INVALID_PARAMETER;
                goto Cleanup;
            }
            BrDereferenceNetwork( TempNetwork );
        } else {
            status = ERROR_INVALID_PARAMETER;
            goto Cleanup;
        }

        ServerType &= ~SV_TYPE_ALTERNATE_XPORT;

        if (ServerType == 0) {
            ServerType = SV_TYPE_ALL;
        }

    }

    if (!LOCK_NETWORK_SHARED(Network)) {
        status = NERR_InternalError;
        goto Cleanup;
    }

    NetworkLocked = TRUE;

    if (!(Network->Role & (ROLE_BACKUP | ROLE_MASTER))) {

        //
        // If this is a wannish transport,
        //  and the caller is asking for "local list",
        //  try to find another wannish transport that is a master browser.
        //
        // The domain master browser doesn't have any control over which
        // transport he comes in on.  If he picks a disabled transport,
        // this code will find the enabled transport.
        //
        // There are cases where there is more than one wannish master browser
        // transport on this machine.  In that case, BrNetServerEnum merges the
        // local lists for all wannish transports to ensure that all list are returned
        // to the domain master browser
        //

        if ( (Network->Flags & NETWORK_WANNISH) != 0 &&
             (ServerType == SV_TYPE_LOCAL_LIST_ONLY ||
              ServerType == (SV_TYPE_LOCAL_LIST_ONLY|SV_TYPE_DOMAIN_ENUM) ) ) {

            PNETWORK TempNetwork;

            TempNetwork = BrFindWannishMasterBrowserNetwork( DomainInfo );

            if ( TempNetwork == NULL ) {
                BrPrint(( BR_CRITICAL,
                          "%ws: %ws: Browse request received from %ws, but not backup or master\n",
                          Network->DomainInfo->DomUnicodeDomainName,
                          Network->NetworkName.Buffer,
                          ClientName));

                status = ERROR_REQ_NOT_ACCEP;
                goto Cleanup;
            }


            //
            // Ditch the old network.
            //
            UNLOCK_NETWORK(Network);
            NetworkLocked = FALSE;

            BrDereferenceNetwork( Network );

            Network = TempNetwork;

            //
            // Use the new network
            //
            if (!LOCK_NETWORK_SHARED(Network)) {
                status = NERR_InternalError;
                goto Cleanup;
            }

            NetworkLocked = TRUE;

            BrPrint(( BR_SERVER_ENUM,
                      "%ws: %ws: Is wannish IP Network found for %ws\n",
                      Network->DomainInfo->DomUnicodeDomainName,
                      Network->NetworkName.Buffer,
                      ClientName));

        } else {
            BrPrint(( BR_CRITICAL,
                      "%ws: %ws: Browse request received from %ws, but not backup or master\n",
                      Network->DomainInfo->DomUnicodeDomainName,
                      Network->NetworkName.Buffer,
                      ClientName));

            status = ERROR_REQ_NOT_ACCEP;
            goto Cleanup;
        }
    }

    //
    // Canonicalize the FirstNameToReturn.
    //

   if (ARGUMENT_PRESENT(FirstNameToReturnArg)  && *FirstNameToReturnArg != L'\0') {

        if ( I_NetNameCanonicalize(
                          NULL,
                          (LPWSTR) FirstNameToReturnArg,
                          FirstNameToReturn,
                          sizeof(FirstNameToReturn),
                          NAMETYPE_WORKGROUP,
                          LM2X_COMPATIBLE
                          ) != NERR_Success) {
            status = ERROR_INVALID_PARAMETER;
            goto Cleanup;
        }

    } else {
        FirstNameToReturn[0] = L'\0';
    }

    status = BrNetServerEnum(Network,
                                ClientName,
                                InfoStruct->Level,
                                PreferedMaximumLength,
                                &Buffer,
                                &EntriesRead,
                                TotalEntries,
                                ServerType,
                                Domain,
                                FirstNameToReturn );

    //
    // Return output parameters other than output buffer from request packet.
    //

    if (status == NERR_Success || status == ERROR_MORE_DATA) {

        if (InfoStruct->Level == 101) {
            InfoStruct->ServerInfo.Level101->Buffer = (PSERVER_INFO_101) Buffer;
            InfoStruct->ServerInfo.Level101->EntriesRead = EntriesRead;
        } else {
            InfoStruct->ServerInfo.Level100->Buffer = (PSERVER_INFO_100) Buffer;
            InfoStruct->ServerInfo.Level100->EntriesRead = EntriesRead;
        }

    }

Cleanup:
    if (NetworkLocked) {
        UNLOCK_NETWORK(Network);
    }

    if ( Network != NULL ) {

#if DBG
        EndTickCount = GetTickCount();

        BrPrint(( BR_SERVER_ENUM,
                  "%ws: %ws: Browse request for %ws took %ld milliseconds\n",
                  Network->DomainInfo->DomUnicodeDomainName,
                  Network->NetworkName.Buffer,
                  ClientName,
                  EndTickCount - StartTickCount));
#endif
        BrDereferenceNetwork( Network );
    }

    if ( DomainInfo != NULL ) {
        BrDereferenceDomain( DomainInfo );
    }

    return status;

}

WORD
I_BrowserServerEnumForXactsrv(
    IN LPCWSTR TransportName OPTIONAL,
    IN LPCWSTR ClientName OPTIONAL,

    IN ULONG Level,
    IN USHORT ClientLevel,

    IN PVOID ClientBuffer,
    IN WORD BufferLength,
    IN DWORD PreferedMaximumLength,

    OUT LPDWORD EntriesFilled,
    OUT LPDWORD TotalEntries,

    IN DWORD ServerType,
    IN LPCWSTR Domain,
    IN LPCWSTR FirstNameToReturnArg OPTIONAL,

    OUT PWORD Converter
    )
/*++

Routine Description:

    This function is a private entrypoint for Xactsrv that bypasses RPC
    entirely.

Arguments:

    TransportName - Supplies the name of xport on which to enumerate servers

    ClientName - Supplies the name of the client that requested the data

    Level - Level of data requested.
    ClientLevel - Level requested by the client.

    ClientBuffer - Output buffer allocated to hold the buffer.
    BufferLength - Size of ClientBuffer
    PreferedMaximumLength - Prefered maximum size of Client buffer if we are
                            going to use the NT form of the buffer

    OUT LPDWORD EntriesFilled - The entries packed into ClientBuffer
    OUT LPDWORD TotalEntries - The total # of entries available.

    IN DWORD ServerType - Server type mask.
    IN LPTSTR Domain    - Domain to query

    OUT PWORD Converter - Magic constant from Xactsrv that allows the client
                            to convert the response buffer.

Return Value:

    WORD - NERR_Success or reason for failure.

--*/
{
    NET_API_STATUS status;
    BOOLEAN networkLocked = FALSE;
    PNETWORK network = NULL;
    UNICODE_STRING networkName;
    PDOMAIN_INFO DomainInfo = NULL;
    PVOID buffer = NULL;
    DWORD entriesRead;
    PCACHED_BROWSE_RESPONSE response = NULL;
    WCHAR FirstNameToReturn[DNLEN+1];

#if DBG
    DWORD startTickCount, endTickCount;

    startTickCount = GetTickCount();

#endif


    try {



        //
        //  If the browser isn't up and we get one of these calls, fail the API
        //  immediately.
        //

        if (BrGlobalData.Status.dwCurrentState != SERVICE_RUNNING) {
            BrPrint(( BR_CRITICAL,
                      "Browse request from %ws received, but browser not running\n", ClientName));
            try_return(status = NERR_ServiceNotInstalled);
        }

        if (!ARGUMENT_PRESENT(TransportName)) {
            try_return(status = ERROR_INVALID_PARAMETER);
        }

        //
        // Find the requested domain.
        //

        DomainInfo = BrFindDomain( (LPWSTR) Domain, TRUE );

        if ( DomainInfo == NULL) {
            try_return(status = ERROR_NO_SUCH_DOMAIN);
        }

        //
        // Look up the transport.
        //
        RtlInitUnicodeString(&networkName, TransportName);

        BrPrint(( BR_SERVER_ENUM,
                  "%ws: %ws: NetServerEnum: Look up network for %ws\n",
                  Domain,
                  TransportName,
                  ClientName));
        network = BrFindNetwork( DomainInfo, &networkName);

		//
		// If it returns NULL, the network was not found.
		// In that case just pick a network randomly and enumerate for that network
		// This is a workaround for RAID bug 614688.
		// The situation is that the request comes over NetbiosSMB and so 
		// networkName points to that, and browser is not registered on that transport.
		//
		if ( network == NULL) {
			EnterCriticalSection(&NetworkCritSect);

			if ( ServicedNetworks.Flink != &ServicedNetworks ) {
				// If the list is not empty, just pick the first network
				network = CONTAINING_RECORD(ServicedNetworks.Flink, NETWORK, NextNet);
				network->ReferenceCount ++;
			}
			LeaveCriticalSection(&NetworkCritSect);
		}

        if (network == NULL) {
            BrPrint(( BR_CRITICAL,
                      "%ws: %ws: Network not found.\n",
                      Domain,
                      TransportName));
            try_return(status = ERROR_FILE_NOT_FOUND);
        }


        //
        // If the caller has asked us to use the alternate transport,
        //  do so.
        //

        if ((ServerType != SV_TYPE_ALL) &&
            (ServerType & SV_TYPE_ALTERNATE_XPORT) ) {

            //
            //  If this transport has an alternate network, then actually
            //  query the alternate name, not the real one.
            //

            if (network->AlternateNetwork != NULL) {
                PNETWORK TempNetwork = network;
                network = network->AlternateNetwork;
                if ( !BrReferenceNetwork( network )) {
                    network = TempNetwork;
                    try_return(status = ERROR_INVALID_PARAMETER);
                }
                BrDereferenceNetwork( TempNetwork );
            } else {
                try_return(status = ERROR_INVALID_PARAMETER);
            }

            ServerType &= ~SV_TYPE_ALTERNATE_XPORT;

            if (ServerType == 0) {
                ServerType = SV_TYPE_ALL;
            }

        }

        if (!LOCK_NETWORK_SHARED(network)) {
            try_return(status = NERR_InternalError);
        }

        networkLocked = TRUE;

        BrPrint(( BR_SERVER_ENUM,
                  "%ws: %ws: Network found for %ws\n",
                  network->DomainInfo->DomUnicodeDomainName,
                  network->NetworkName.Buffer,
                  ClientName));

        if (!(network->Role & (ROLE_BACKUP | ROLE_MASTER))) {

            //
            // If this is a wannish transport,
            //  and the caller is asking for "local list",
            //  try to find another wannish transport that is a master browser.
            //
            // The domain master browser doesn't have any control over which
            // transport he comes in on.  If he picks a disabled transport,
            // this code will find the enabled transport.
            //
            // There are cases where there is more than one wannish master browser
            // transport on this machine.  In that case, BrNetServerEnum merges the
            // local lists for all wannish transports to ensure that all list are returned
            // to the domain master browser
            //

            if ( (network->Flags & NETWORK_WANNISH) != 0 &&
                 (ServerType == SV_TYPE_LOCAL_LIST_ONLY ||
                  ServerType == (SV_TYPE_LOCAL_LIST_ONLY|SV_TYPE_DOMAIN_ENUM) ) ) {

                PNETWORK TempNetwork;

                TempNetwork = BrFindWannishMasterBrowserNetwork( DomainInfo );

                if ( TempNetwork == NULL ) {
                    BrPrint(( BR_CRITICAL,
                              "%ws: %ws: Browse request received from %ws, but not backup or master\n",
                              network->DomainInfo->DomUnicodeDomainName,
                              network->NetworkName.Buffer,
                              ClientName));

                    try_return(status = ERROR_REQ_NOT_ACCEP);
                }


                //
                // Ditch the old network.
                //
                UNLOCK_NETWORK(network);
                networkLocked = FALSE;

                BrDereferenceNetwork( network );

                network = TempNetwork;

                //
                // Use the new network
                //
                if (!LOCK_NETWORK_SHARED(network)) {
                    try_return(status = NERR_InternalError);
                }

                networkLocked = TRUE;

                BrPrint(( BR_SERVER_ENUM,
                          "%ws: %ws: Is wannish IP Network found for %ws\n",
                          network->DomainInfo->DomUnicodeDomainName,
                          network->NetworkName.Buffer,
                          ClientName));

            } else {
                BrPrint(( BR_CRITICAL,
                          "%ws: %ws: Browse request received from %ws, but not backup or master\n",
                          network->DomainInfo->DomUnicodeDomainName,
                          network->NetworkName.Buffer,
                          ClientName));

                try_return(status = ERROR_REQ_NOT_ACCEP);
            }
        }

        //
        //  If we weren't able to find a cached response buffer, or
        //  if the cached response didn't have a buffer allocated for it,
        //  we need to process the browse request.
        //

        if (network->Role & ROLE_MASTER) {

            //
            //  Check to see if we should flush the cache at this time.  If
            //  we should, we need to release the network and re-acquire it
            //  exclusively, because we use the network lock to protect
            //  enumerations from flushes.
            //


            if ((BrCurrentSystemTime() - network->TimeCacheFlushed) > BrInfo.DriverQueryFrequency) {

                UNLOCK_NETWORK(network);

                networkLocked = FALSE;

                if (!LOCK_NETWORK(network)) {
                    try_return(status = NERR_InternalError);
                }

                networkLocked = TRUE;

                //
                //  We're running on a master browser, and we found a cached browse
                //  request.  See if we can safely use this cached value, or if we
                //  should go to the driver for it.
                //

                EnterCriticalSection(&network->ResponseCacheLock);

                if ((BrCurrentSystemTime() - network->TimeCacheFlushed) > BrInfo.DriverQueryFrequency) {

                    BrPrint(( BR_SERVER_ENUM,
                              "%ws: %ws: Flushing cache\n",
                              network->DomainInfo->DomUnicodeDomainName,
                              network->NetworkName.Buffer ));

                    network->TimeCacheFlushed = BrCurrentSystemTime();

                    BrAgeResponseCache( network );
                }

                LeaveCriticalSection(&network->ResponseCacheLock);
            }
        }

        //
        // Canonicalize the FirstNameToReturn.
        //

        if (ARGUMENT_PRESENT(FirstNameToReturnArg)  && *FirstNameToReturnArg != L'\0') {

            if ( I_NetNameCanonicalize(
                              NULL,
                              (LPWSTR) FirstNameToReturnArg,
                              FirstNameToReturn,
                              sizeof(FirstNameToReturn),
                              NAMETYPE_WORKGROUP,
                              LM2X_COMPATIBLE
                              ) != NERR_Success) {
                try_return(status = ERROR_INVALID_PARAMETER);
            }

        } else {
            FirstNameToReturn[0] = L'\0';
        }

        if (!ARGUMENT_PRESENT(Domain) ||
            !STRICMP(Domain, network->DomainInfo->DomUnicodeDomainName)) {

            BrPrint(( BR_SERVER_ENUM,
                      "%ws: %ws: Look up 0x%x/%d/%x.\n",
                      Domain, TransportName, ServerType, ClientLevel, BufferLength));

            //
            //  This request is for our primary domain.  Look up a cached response
            //  entry.  If none is found for this request, allocate a new one and
            //  return it.
            //

            response = BrLookupAndAllocateCachedEntry(
                                    network,
                                    ServerType,
                                    BufferLength,
                                    ClientLevel,
                                    FirstNameToReturn
                                    );


        }

        EnterCriticalSection(&network->ResponseCacheLock);
        if ((response == NULL)

                    ||

            (response->Buffer == NULL)) {
            LeaveCriticalSection(&network->ResponseCacheLock);

            BrPrint(( BR_SERVER_ENUM,
                      "%ws: %ws: Cached entry not found, or hit count too low.  Retrieve actual list for %ws\n",
                      Domain, TransportName, ClientName));

            status = BrNetServerEnum(network,
                                    ClientName,
                                    Level,
                                    PreferedMaximumLength,
                                    &buffer,
                                    &entriesRead,
                                    TotalEntries,
                                    ServerType,
                                    Domain,
                                    FirstNameToReturn
                                    );

            if (status == NERR_Success || status == ERROR_MORE_DATA) {

                BrPrint(( BR_SERVER_ENUM,
                          "%ws: %ws: Convert NT buffer to Xactsrv buffer for %ws\n",
                          Domain,
                          TransportName,
                          ClientName ));

                if( pXsConvertServerEnumBuffer == NULL ) {
                    //
                    // It doesn't really matter if several threads do this simultaneously.
                    //   We are never going to unload this library anyway.  But we are delaying
                    //   the load of the library until now to speed up system boot and init.
                    //

                    HMODULE hLibrary = LoadLibrary( L"xactsrv.dll" );
                    if( hLibrary != NULL ) {
                        pXsConvertServerEnumBuffer = (XS_CONVERT_SERVER_ENUM_BUFFER_FUNCTION *)GetProcAddress(
                                                        hLibrary, "XsConvertServerEnumBuffer" );
                    }
                }

                if( pXsConvertServerEnumBuffer != NULL ) {
                    status = pXsConvertServerEnumBuffer(
                                  buffer,
                                  entriesRead,
                                  TotalEntries,
                                  ClientLevel,
                                  ClientBuffer,
                                  BufferLength,
                                  EntriesFilled,
                                  Converter);
                } else {
                    status = GetLastError();
                }


                if (status == NERR_Success || status == ERROR_MORE_DATA) {

                    BrPrint(( BR_SERVER_ENUM,
                              "%ws: %ws: Conversion done for %ws\n",
                              Domain,
                              TransportName,
                              ClientName ));

                    EnterCriticalSection(&network->ResponseCacheLock);

                    if ((response != NULL) &&

                        (response->Buffer == NULL) &&

                        (response->TotalHitCount >= BrInfo.CacheHitLimit)) {

                        BrPrint(( BR_SERVER_ENUM,
                                  "%ws: %ws: Save contents of server list for 0x%x/%d/%x.\n",
                                  Domain,
                                  TransportName,
                                  ServerType, ClientLevel, BufferLength));

                        response->Buffer = MIDL_user_allocate(BufferLength);

                        if ( response->Buffer != NULL ) {

                            //
                            //  We successfully allocated the buffer, now copy
                            //  our response into the buffer and save away the
                            //  other useful stuff about the request.
                            //

                            RtlCopyMemory(response->Buffer, ClientBuffer, BufferLength);

                            response->EntriesRead = *EntriesFilled;
                            response->TotalEntries = *TotalEntries;
                            response->Converter = *Converter;
                            response->Status = (WORD)status;
                        }
                    }

                    LeaveCriticalSection(&network->ResponseCacheLock);
                }
            }
        } else {

            ASSERT (response);

            ASSERT (response->Buffer);

            ASSERT (response->Size == BufferLength);

            BrPrint(( BR_SERVER_ENUM,
                      "Cache hit.  Use contents of server list for 0x%x/%d/%x.\n",
                      Domain,
                      TransportName,
                      ServerType, ClientLevel, BufferLength));

            //
            //  Copy over the cached response from the response cache into the
            //  users response buffer.
            //

            RtlCopyMemory(ClientBuffer, response->Buffer, BufferLength);

            //
            //  Also copy over the other useful stuff that the client will
            //  want to know about.
            //

            *EntriesFilled = response->EntriesRead;

            *TotalEntries = response->TotalEntries;

            *Converter = response->Converter;

            status = response->Status;
            LeaveCriticalSection(&network->ResponseCacheLock);

        }

try_exit:NOTHING;
    } finally {
        if (networkLocked) {
            UNLOCK_NETWORK(network);
        }

        //
        // If a buffer was allocated, free it.
        //

        if (buffer != NULL) {
            MIDL_user_free(buffer);
        }


        if ( network != NULL ) {
    #if DBG
            endTickCount = GetTickCount();

            BrPrint(( BR_SERVER_ENUM,
                      "%ws: %ws: Browse request for %ws took %ld milliseconds\n",
                      network->DomainInfo->DomUnicodeDomainName,
                      network->NetworkName.Buffer,
                      ClientName,
                      endTickCount - startTickCount));
    #endif
            BrDereferenceNetwork( network );
        }

        if ( DomainInfo != NULL ) {
            BrDereferenceDomain( DomainInfo );
        }
    }

    return (WORD)status;
}



NET_API_STATUS NET_API_FUNCTION
BrNetServerEnum(
    IN PNETWORK Network OPTIONAL,
    IN LPCWSTR ClientName OPTIONAL,
    IN ULONG Level,
    IN DWORD PreferedMaximumLength,
    OUT PVOID *Buffer,
    OUT LPDWORD EntriesRead,
    OUT LPDWORD TotalEntries,
    IN DWORD ServerType,
    IN LPCWSTR Domain,
    IN LPCWSTR FirstNameToReturn OPTIONAL
    )
/*++

Routine Description:

    This function is the real worker for the NetServerEnum entry point in the
    Workstation service.

Arguments:

    ServerName - Supplies the name of server to execute this function

    TransportName - Supplies the name of xport on which to enumerate servers

    InfoStruct - This structure supplies the level of information requested,
        returns a pointer to the buffer allocated by the Workstation service
        which contains a sequence of information structure of the specified
        information level, and returns the number of entries read.  The buffer
        pointer is set to NULL if return code is not NERR_Success or
        ERROR_MORE_DATA, or if EntriesRead returned is 0.  The EntriesRead
        value is only valid if the return code is NERR_Success or
        ERROR_MORE_DATA.

    PreferedMaximumLength - Supplies the number of bytes of information
        to return in the buffer.  If this value is MAXULONG, we will try
        to return all available information if there is enough memory
        resource.

    TotalEntries - Returns the total number of entries available.  This value
        is returned only if the return code is NERR_Success or ERROR_MORE_DATA.

    ServerType - Supplies the type of server to enumerate.

    Domain - Supplies the name of one of the active domains to enumerate the
        servers from.  If NULL, servers from the primary domain, logon domain
        and other domains are enumerated.

    FirstNameToReturn - Supplies the name of the first server or domain to return
        to the caller.  If NULL, enumeration begins with the very first entry.

        Passed name must be the canonical form of the name.

Return Value:

    NET_API_STATUS - NERR_Success or reason for failure.

--*/
{
    NET_API_STATUS status;
    DWORD DomainNameSize = 0;
    TCHAR DomainName[DNLEN + 1];
    BOOLEAN NetworkLocked = TRUE;
    BOOLEAN LocalListOnly = FALSE;
    PVOID DoubleHopLocalList = NULL;

    BrPrint(( BR_SERVER_ENUM,
              "%ws: %ws: Retrieve browse list for %lx for client %ws\n",
              Domain,
              Network->NetworkName.Buffer,
              ServerType,
              ClientName));

    EnterCriticalSection(&BrowserStatisticsLock);

    if (ServerType == SV_TYPE_DOMAIN_ENUM) {
        NumberOfDomainEnumerations += 1;
    } else if (ServerType == SV_TYPE_ALL) {
        NumberOfServerEnumerations += 1;
    } else {
        NumberOfOtherEnumerations += 1;
    }

    LeaveCriticalSection(&BrowserStatisticsLock);

    //
    // Only levels 100 and 101 are valid
    //

    if ((Level != 100) && (Level != 101)) {
        return ERROR_INVALID_LEVEL;
    }

#ifdef ENABLE_PSEUDO_BROWSER
    //
    // Pseudo Server shortcut
    //
    if ( BrInfo.PseudoServerLevel == BROWSER_PSEUDO ) {
        *Buffer = NULL;
        *EntriesRead = 0;
        *TotalEntries = 0;
        return NERR_Success;
    }
#endif



    if (ARGUMENT_PRESENT(Domain)) {

        //
        // NAMETYPE_WORKGROUP allows spaces.
        //

        if ( I_NetNameCanonicalize(
                          NULL,
                          (LPWSTR) Domain,
                          DomainName,
                          (DNLEN + 1) * sizeof(TCHAR),
                          NAMETYPE_WORKGROUP,
                          0
                          ) != NERR_Success) {
            return ERROR_INVALID_DOMAINNAME;
        }

        DomainNameSize = STRLEN(DomainName) * sizeof(WCHAR);
    }

    try {

        if (ServerType != SV_TYPE_ALL) {

            //
            //  If the user has specified SV_TYPE_LOCAL_LIST_ONLY, we
            //  will only accept SV_TYPE_DOMAIN_ENUM or 0 as legal bits
            //  otherwise, we return an error.
            //

            if (ServerType & SV_TYPE_LOCAL_LIST_ONLY) {

                LocalListOnly = TRUE;

//                BrPrint(( BR_SERVER_ENUM, "Retrieve local list for %ws\n", ClientName));


                //
                //  Turn off the LOCAL_LIST_ONLY bit.
                //

                ServerType &= ~SV_TYPE_LOCAL_LIST_ONLY;

                //
                //  Check the remaining bits.  The only two legal values
                //  are SV_TYPE_DOMAIN_ENUM and 0
                //

                if (ServerType != SV_TYPE_DOMAIN_ENUM) {

                    if (ServerType == 0) {
                        ServerType = SV_TYPE_ALL;
                    } else {
                        try_return(status = ERROR_INVALID_FUNCTION);
                    }
                }

                //
                //  If we aren't a master browser, blow this request
                //  off, since we don't have a local list.
                //

                if (!(Network->Role & ROLE_MASTER)) {
                    BrPrint(( BR_CRITICAL,
                              "%ws: %ws: Local list request received from %ws, but not master\n",
                              Domain,
                              Network->NetworkName.Buffer,
                              ClientName));
                    try_return(status = ERROR_REQ_NOT_ACCEP);
                }

            } else if (ServerType & SV_TYPE_DOMAIN_ENUM) {
                if (ServerType != SV_TYPE_DOMAIN_ENUM) {
                    try_return(status = ERROR_INVALID_FUNCTION);
                }
            }
        }

        if (ARGUMENT_PRESENT(Domain) &&
            STRICMP(Domain, Network->DomainInfo->DomUnicodeDomainName)) {
            PINTERIM_ELEMENT DomainEntry;
            LPWSTR MasterName = NULL;

            BrPrint(( BR_SERVER_ENUM,
                      "Non local domain %ws - Check for double hop\n",
                      Domain));

            if ( Network->Role & ROLE_MASTER ) {
                if ( Network->DomainList.EntriesRead != 0 )  {

                    DomainEntry = LookupInterimServerList(&Network->DomainList, (LPWSTR) Domain);

                    if (DomainEntry != NULL) {
                        MasterName = DomainEntry->Comment;
                    }
                } else {
                    ULONG i;
                    PSERVER_INFO_101 DomainInfo;
                    DWORD DoubleHopEntriesRead = 0;
                    DWORD DoubleHopTotalEntries = 0;

                    status = BrGetLocalBrowseList(Network,
                                                    NULL,
                                                    101,
                                                    SV_TYPE_DOMAIN_ENUM,
                                                    &DoubleHopLocalList,
                                                    &DoubleHopEntriesRead,
                                                    &DoubleHopTotalEntries);

                    for (i = 0 , DomainInfo = DoubleHopLocalList ;

                         i < DoubleHopEntriesRead ;

                         i += 1) {

                        if (!_wcsicmp(Domain, DomainInfo->sv101_name)) {
                            MasterName = DomainInfo->sv101_comment;
                            break;
                        }

                        DomainInfo += 1;
                    }
                }

            } else {
                ULONG i;
                PSERVER_INFO_101 DomainInfo;

                //
                //  We're running on a backup browser.  We want to find the
                //  name of the master browser by looking in the backup
                //  server list for this network.
                //

                for (i = 0 , DomainInfo = Network->BackupDomainList ;

                     i < Network->TotalBackupDomainListEntries ;

                     i += 1) {

                    if (!_wcsicmp(Domain, DomainInfo->sv101_name)) {
                        MasterName = DomainInfo->sv101_comment;
                        break;
                    }

                    DomainInfo += 1;
                }

            }

            //
            //  If we couldn't find a master name, bail out right now.
            //

            if (MasterName == NULL || *MasterName == UNICODE_NULL) {
                try_return(status = ERROR_NO_BROWSER_SERVERS_FOUND);
            }

            //
            //  If the master for this domain isn't listed as our
            //  current machine, remote the API to that server.
            //

            if (STRICMP(MasterName, Network->DomainInfo->DomUnicodeComputerName)) {
                WCHAR RemoteComputerName[UNLEN+1];

                //
                //  Build the name of the remote computer.
                //

                STRCPY(RemoteComputerName, TEXT("\\\\"));

                STRCAT(RemoteComputerName, MasterName);

                ASSERT (NetworkLocked);

                UNLOCK_NETWORK(Network);

                NetworkLocked = FALSE;

                BrPrint(( BR_SERVER_ENUM,
                          "Double hop to %ws on %ws\n",
                          RemoteComputerName,
                          Network->NetworkName.Buffer));

                status = RxNetServerEnum(RemoteComputerName,
                                        Network->NetworkName.Buffer,
                                        Level,
                                        (LPBYTE *)Buffer,
                                        PreferedMaximumLength,
                                        EntriesRead,
                                        TotalEntries,
                                        ServerType,
                                        Domain,
                                        FirstNameToReturn );
                BrPrint(( BR_SERVER_ENUM, "Double hop done\n"));

                if (!LOCK_NETWORK_SHARED (Network)) {
                    try_return(status = NERR_InternalError);
                }

                NetworkLocked = TRUE;

                try_return(status);
            }
        }

        ASSERT (NetworkLocked);

        if (!ARGUMENT_PRESENT(Domain)) {
            STRCPY(DomainName, Network->DomainInfo->DomUnicodeDomainName);
        }

        //
        //  If we are running on the master browser, we want to retrieve the
        //  local list, merge it with our interim server list, and
        //  return that to the user.
        //

        if (Network->Role & ROLE_MASTER) {
            status = BrRetrieveServerListForMaster(Network,
                                            Buffer,
                                            EntriesRead,
                                            TotalEntries,
                                            Level,
                                            ServerType,
                                            PreferedMaximumLength,
                                            LocalListOnly,
                                            (LPWSTR) ClientName,
                                            DomainName,
                                            FirstNameToReturn );



        } else {

            status = BrRetrieveServerListForBackup(Network,
                                            Buffer,
                                            EntriesRead,
                                            TotalEntries,
                                            Level,
                                            ServerType,
                                            PreferedMaximumLength,
                                            FirstNameToReturn );


        }

        try_return(status);

try_exit:NOTHING;
    } finally {

#if DBG
        if (status == NERR_Success || status == ERROR_MORE_DATA) {
            BrPrint(( BR_SERVER_ENUM,
                      "%ws: %ws: Returning Browse list for %lx with %ld entries for %ws\n",
                      Domain,
                      Network->NetworkName.Buffer,
                      ServerType,
                      *EntriesRead,
                      ClientName));
        } else {
            BrPrint(( BR_CRITICAL,
                      "%ws: %ws: Failing I_BrowserServerEnum: %ld for client %ws\n",
                      Domain,
                      Network->NetworkName.Buffer,
                      status, ClientName));
        }
#endif

        //
        //  If we used the local driver's list to retrieve the list of
        //  domains, free up the buffer.
        //

        if (DoubleHopLocalList != NULL) {
            MIDL_user_free(DoubleHopLocalList);

        }

        ASSERT (NetworkLocked);
    }

    return status;
}


VOID
TrimServerList(
    IN DWORD Level,
    IN OUT LPBYTE *Buffer,
    IN OUT LPDWORD EntriesRead,
    IN OUT LPDWORD TotalEntries,
    IN LPCWSTR FirstNameToReturn
)

/*++

Routine Description:

   This routine trims any name from Buffer that's less than FirstNameToReturn.

   The routine is implemented by moving the fixed part of the kept entries to the beginning
   of the allocated buffer.  Thay way, the pointer contained in the entries need not be
   relocated and the original buffer can still be used.

Arguments:

    Level - Level of information in the buffer.

    Buffer - Pointer to address of buffer to trim.
        Returns null (and deallocates the buffer) if all the entries are trimmed.

    EntriesRead - Pointer to number of entries in the buffer.
        Returns the number of entries remaining in the buffer after triming.

    TotalEntries - Pointer to number of entries available from server.
        Returns a number reduced by the number of trimmed entries.

    FirstNameToReturn - Supplies the name of the first server or domain to return
        to the caller.  If NULL, enumeration begins with the very first entry.

        Passed name must be the canonical form of the name.

Return Value:

    Returns the error code for the operation.

--*/

{
    DWORD EntryCount;
    DWORD EntryNumber;
    DWORD FixedSize;

    LPBYTE CurrentEntry;

    //
    // Early out if there's nothing to do.
    //

    if ( FirstNameToReturn == NULL || *FirstNameToReturn == L'\0' || *EntriesRead == 0 ) {
        return;
    }


    //
    // Compute the size of each entry.
    //

    switch (Level) {
    case 100:
        FixedSize = sizeof(SERVER_INFO_100);
        break;
    case 101:
        FixedSize = sizeof(SERVER_INFO_101);
        break;
    default:
        NetpAssert( FALSE );
        return;

    }

    //
    // Finding the first entry to return
    //

    EntryCount = *EntriesRead;

    for ( EntryNumber=0; EntryNumber< EntryCount; EntryNumber++ ) {

        LPSERVER_INFO_100 ServerEntry =
            (LPSERVER_INFO_100)( *Buffer + FixedSize * EntryNumber);

        //
        // Found the first entry to return.
        //

        if ( STRCMP( ServerEntry->sv100_name, FirstNameToReturn ) >= 0 ) {

            //
            // If we're returning the whole list,
            //  simply return.
            //

            if ( ServerEntry == (LPSERVER_INFO_100)(*Buffer) ) {
                return;
            }

            //
            // Copy the remaining entries to the beginning of the buffer.
            //  (Yes, this is an overlapping copy)
            //

            RtlMoveMemory( *Buffer, ServerEntry, (*EntriesRead) * FixedSize );
            return;

        }

        //
        // Account for skipped entries.
        //

        *EntriesRead -= 1;
        *TotalEntries -= 1;
    }

    //
    // If no entries should be returned,
    //  deallocate the buffer.
    //

    NetApiBufferFree( *Buffer );
    *Buffer = NULL;

    ASSERT ( *EntriesRead == 0 );

    return;

} // TrimServerList

//
// Context for building a local list of all the Wannish transports.
//

typedef struct _BR_LOCAL_LIST_CONTEXT {
    LPWSTR DomainName;
    DWORD Level;
    DWORD ServerType;
    PVOID Buffer;
    NET_API_STATUS NetStatus;
    DWORD EntriesRead;
    DWORD TotalEntries;
    BOOLEAN AtLeastOneWorked;

    INTERIM_SERVER_LIST InterimServerList;
} BR_LOCAL_LIST_CONTEXT, *PBR_LOCAL_LIST_CONTEXT;


NET_API_STATUS
BrGetWannishLocalList(
    IN PNETWORK Network,
    IN PVOID Context
    )
/*++

Routine Description:

    Worker function to get the local list for all WANNISH networks and
        merge them together.

Arguments:

    Network - The current network to do.

    Context - Context that the accumulated list is built into.

Return Value:

    NET_API_STATUS - NERR_Success or reason for failure.

--*/

{
    NET_API_STATUS NetStatus;
    PBR_LOCAL_LIST_CONTEXT LocalListContext = (PBR_LOCAL_LIST_CONTEXT) Context;

    PVOID Buffer = NULL;
    DWORD EntriesRead;
    DWORD TotalEntries;

    //
    // If this isn't a wannish network,
    //  ignore it.

    if ((Network->Flags & NETWORK_WANNISH) == 0 ) {
        BrPrint(( BR_SERVER_ENUM,
                  "%ws: %ws: isn't a wannish network. (ignored)\n",
                  Network->DomainInfo->DomUnicodeDomainName,
                  Network->NetworkName.Buffer ));

        return NO_ERROR;
    }

    //
    // Get the local list from this transport.
    //

    BrPrint(( BR_SERVER_ENUM,
              "%ws: %ws: Get local list from wannish network.\n",
              Network->DomainInfo->DomUnicodeDomainName,
              Network->NetworkName.Buffer ));

    NetStatus = BrGetLocalBrowseList(
                        Network,
                        LocalListContext->DomainName,
                        LocalListContext->Level,
                        LocalListContext->ServerType,
                        &Buffer,
                        &EntriesRead,
                        &TotalEntries);

    if ( NetStatus != NO_ERROR && NetStatus != ERROR_MORE_DATA ) {

        BrPrint(( BR_CRITICAL,
                  "%ws: %ws: Get local list from wannish network failed: %ld.\n",
                  Network->DomainInfo->DomUnicodeDomainName,
                  Network->NetworkName.Buffer,
                  NetStatus ));
        //
        // If no transport has worked yet, save this as the new default status.
        //  (But keep on going)
        //
        if ( !LocalListContext->AtLeastOneWorked ) {
            LocalListContext->NetStatus = NetStatus;
        }
        NetStatus = NO_ERROR;
        goto Cleanup;
    }

    LocalListContext->AtLeastOneWorked = TRUE;
    LocalListContext->NetStatus = NetStatus;

    //
    // If no data was returned,
    //  we're done.
    //

    if ( EntriesRead == 0 ) {

        BrPrint(( BR_SERVER_ENUM,
                  "%ws: %ws: Get local list from wannish network got zero entries.\n",
                  Network->DomainInfo->DomUnicodeDomainName,
                  Network->NetworkName.Buffer ));
        NetStatus = NO_ERROR;
        goto Cleanup;
    }

    //
    // If a prior network already returned some entries,
    //  build an interim list to merge both lists into.
    //

    if ( LocalListContext->Buffer != NULL ) {
        NetStatus = MergeServerList(
                        &LocalListContext->InterimServerList,
                        LocalListContext->Level,
                        LocalListContext->Buffer,
                        LocalListContext->EntriesRead,
                        LocalListContext->TotalEntries );

        MIDL_user_free(LocalListContext->Buffer);
        LocalListContext->Buffer = NULL;
        LocalListContext->EntriesRead = 0;
        LocalListContext->TotalEntries = 0;;

        if ( NetStatus != NO_ERROR ) {

            BrPrint(( BR_CRITICAL,
                      "%ws: %ws: merge local list from wannish network failed: %ld.\n",
                      Network->DomainInfo->DomUnicodeDomainName,
                      Network->NetworkName.Buffer,
                      NetStatus ));
            goto Cleanup;

        }
    }

    //
    // If there is an interim server list,
    //  add the new entries to it.
    //

    if ( LocalListContext->InterimServerList.TotalEntries != 0 ) {
        NetStatus = MergeServerList(
                        &LocalListContext->InterimServerList,
                        LocalListContext->Level,
                        Buffer,
                        EntriesRead,
                        TotalEntries );

        if ( NetStatus != NO_ERROR ) {

            BrPrint(( BR_CRITICAL,
                      "%ws: %ws: merge local list from wannish network failed: %ld.\n",
                      Network->DomainInfo->DomUnicodeDomainName,
                      Network->NetworkName.Buffer,
                      NetStatus ));
            goto Cleanup;

        }

    //
    // If this is the first network to return entries,
    //  simply save the list.
    //
    // This saves us from having to convert a list to an interim list just
    //  to have to convert it back in those cases where we have a single wannish
    //  network.
    //
    } else {
        LocalListContext->Buffer = Buffer;
        LocalListContext->EntriesRead = EntriesRead;
        LocalListContext->TotalEntries = TotalEntries;
        Buffer = NULL;
    }

    NetStatus = NO_ERROR;



Cleanup:
    if ( Buffer != NULL ) {
        MIDL_user_free(Buffer);
    }

    return NetStatus;
}


NET_API_STATUS
BrRetrieveServerListForMaster(
    IN PNETWORK Network,
    IN OUT PVOID *Buffer,
    OUT PDWORD EntriesRead,
    OUT PDWORD TotalEntries,
    IN DWORD Level,
    IN DWORD ServerType,
    IN DWORD PreferedMaximumLength,
    IN BOOLEAN LocalListOnly,
    IN LPTSTR ClientName,
    IN LPTSTR DomainName,
    IN LPCWSTR FirstNameToReturn
    )
{
    BOOLEAN GetLocalList = FALSE;
    NET_API_STATUS status;
    BOOLEAN EarlyOut = FALSE;

    //
    //  Determine if it is appropriate that we should early out after retrieving
    //  the list of servers (or domains) from the bowser.
    //
    //  We will early out on the following critieria:
    //
    //      1) If we are requested to retrieve the local list on a Wannish xport
    //      2) If the transport isn't a wannish transport, or
    //      3) If this domain isn't our primary domain (in which case it's an
    //          "otherdomain" request).
    //

    if (LocalListOnly || STRICMP(DomainName, Network->DomainInfo->DomUnicodeDomainName)) {
        EarlyOut = TRUE;
    } else if (!(Network->Flags & NETWORK_WANNISH)) {

        //
        //  This isn't a wannish transport.  We need to see if we've been
        //  master long enough for the driver to have retrieved a reasonable
        //  list.
        //
        //  The server and domain table will be emptied when the first master
        //  browser timer is run.  This will happen 15 minutes after we
        //  become the master, so we will use our services list for the
        //  first 15 minutes the browser is master.
        //

        if (ServerType == SV_TYPE_DOMAIN_ENUM) {
            if (Network->DomainList.EntriesRead == 0) {
                EarlyOut = TRUE;
            }
        } else {
            if (Network->BrowseTable.EntriesRead == 0) {
                EarlyOut = TRUE;
            }
        }

    }

    if (EarlyOut) {

        GetLocalList = TRUE;

    } else if (ServerType == SV_TYPE_ALL) {

        if ((BrCurrentSystemTime() - Network->LastBowserServerQueried) > BrInfo.DriverQueryFrequency ) {

            GetLocalList = TRUE;
        }

    } else if (ServerType == SV_TYPE_DOMAIN_ENUM) {

        if ((BrCurrentSystemTime() - Network->LastBowserDomainQueried) > BrInfo.DriverQueryFrequency ) {

            GetLocalList = TRUE;
        }

    } else {

        GetLocalList = TRUE;
    }

    if (GetLocalList && !EarlyOut) {

        //
        //  If we're retriving the list from the driver, and can't early out
        //  this request, this means that we will be merging this server list
        //  with an interim server list.  This means that we will be modifying
        //  the network structure, and thus that we need to re-lock the network
        //  structure.
        //

        UNLOCK_NETWORK(Network);

        if (!LOCK_NETWORK(Network)) {
            return NERR_InternalError;
        }

        //
        //  Now re-test to see if another thread came in and retrieved the
        //  list from the driver while we had the network unlocked.  If so,
        //  we don't want to get the local list any more.
        //
        //  Otherwise, we want to update the last query time.
        //

        if (ServerType == SV_TYPE_ALL) {

            if ((BrCurrentSystemTime() - Network->LastBowserServerQueried) > BrInfo.DriverQueryFrequency ) {
                Network->LastBowserServerQueried = BrCurrentSystemTime();
            } else {
                GetLocalList = FALSE;
            }

        } else if (ServerType == SV_TYPE_DOMAIN_ENUM) {

            if ((BrCurrentSystemTime() - Network->LastBowserDomainQueried) > BrInfo.DriverQueryFrequency ) {
                Network->LastBowserDomainQueried = BrCurrentSystemTime();
            } else {
                GetLocalList = FALSE;
            }

        } else {

            Network->LastBowserServerQueried = BrCurrentSystemTime();

        }

    }

    //
    //  If we're supposed to retrieve the local server list, retrieve it.
    //

    if (GetLocalList) {
        DWORD ServerTypeForLocalList;

        //
        //  Calculate the server type to use when retrieving the list from
        //  the driver.
        //

        if (LocalListOnly ||

            (ServerType == SV_TYPE_DOMAIN_ENUM) ||

            !(Network->Flags & NETWORK_WANNISH)) {

            //
            //  If we are retrieving the local list, or this is a non-wannish
            //  transport, or we are asking for domains, we want to
            //  keep the callers server type.
            //

            ServerTypeForLocalList = ServerType;

        } else {

            //
            //  This must be a wannish transport, ask for all servers (we know
            //  that we're not asking for domains, since we checked that
            //  above).
            //
            //  We ask for all the servers because it's possible that a servers
            //  role has changed.
            //

            ASSERT (Network->Flags & NETWORK_WANNISH);

            ServerTypeForLocalList = SV_TYPE_ALL;
        }

        BrPrint(( BR_SERVER_ENUM,
                  "%ws: %ws: Get local browse list for %ws\n",
                  Network->DomainInfo->DomUnicodeDomainName,
                  Network->NetworkName.Buffer,
                  ClientName));

        //
        // If this is a call from the Domain Master Browser to get the local list,
        //  and this is a wannish transport,
        //  get the local list on all wannish transports.
        //

        if ( LocalListOnly &&
             (Network->Flags & NETWORK_WANNISH) != 0 ) {
            BR_LOCAL_LIST_CONTEXT LocalListContext;
            //
            // Build a context to use to gather the server lists from all
            //  wannish transports
            //
            LocalListContext.DomainName = DomainName;
            LocalListContext.Level = Level;
            LocalListContext.ServerType = ServerTypeForLocalList;
            LocalListContext.Buffer = NULL;
            LocalListContext.NetStatus = NO_ERROR;
            LocalListContext.EntriesRead = 0;
            LocalListContext.TotalEntries = 0;
            LocalListContext.AtLeastOneWorked = FALSE;

            (VOID) InitializeInterimServerList(&LocalListContext.InterimServerList, NULL, NULL, NULL, NULL);

            //
            // Gather the lists
            //

            status = BrEnumerateNetworks( BrGetWannishLocalList, &LocalListContext );

            if ( status == NO_ERROR ) {

                //
                // If multiple networks were found,
                //  pack the interim list.
                //

                if ( LocalListContext.InterimServerList.TotalEntries != 0 ) {
                    status = PackServerList( &LocalListContext.InterimServerList,
                                             LocalListContext.Level,
                                             LocalListContext.ServerType,
                                             PreferedMaximumLength,
                                             Buffer,
                                             EntriesRead,
                                             TotalEntries,
                                             (LPWSTR)FirstNameToReturn );

                //
                // If just a single network was found,
                //  just use it.
                //
                } else {
                    status = LocalListContext.NetStatus;
                    *Buffer = LocalListContext.Buffer;
                    *EntriesRead = LocalListContext.EntriesRead;
                    *TotalEntries = LocalListContext.TotalEntries;
                }

            }

            (VOID) UninitializeInterimServerList( &LocalListContext.InterimServerList );


        } else {
            status = BrGetLocalBrowseList(
                                Network,
                                DomainName,
                                ( EarlyOut ? Level : 101 ),
                                ServerTypeForLocalList,
                                Buffer,
                                EntriesRead,
                                TotalEntries);
        }

//        BrPrint(( BR_SERVER_ENUM, "List retrieved. %ld entries, %ld total\n", *EntriesRead, *TotalEntries));


        //
        //  If we're supposed to early-out this request (or if there was
        //  an error), do so now.
        //

        if (EarlyOut ||
            (status != NERR_Success && status != ERROR_MORE_DATA)) {

            //
            // If we're returning an early out list,
            //  truncate the complete list returned from the kernel.
            //
            // This saves us from having to modify the kernel interface and untangle
            //  the code above.
            //

            if ( status == NERR_Success || status == ERROR_MORE_DATA ) {

                TrimServerList( Level,
                                (LPBYTE *)Buffer,
                                EntriesRead,
                                TotalEntries,
                                FirstNameToReturn );

            }

            BrPrint(( BR_SERVER_ENUM, "Early out for %ws with %ld servers.  Don't merge server list.\n", ClientName, *EntriesRead));

            return status;
        }

        if (status == NERR_Success || status == ERROR_MORE_DATA) {

            if (*EntriesRead != 0) {

                //
                //  Merge the local list with the list we got from the
                //  master or from the domain master.
                //

                BrPrint(( BR_SERVER_ENUM,
                          "%ws: %ws: Merge %d entries in server list for %ws \n",
                          Network->DomainInfo->DomUnicodeDomainName,
                          Network->NetworkName.Buffer,
                          *EntriesRead,
                          ClientName));

                status = MergeServerList((ServerType == SV_TYPE_DOMAIN_ENUM ?
                                                        &Network->DomainList :
                                                        &Network->BrowseTable),
                                    101,
                                    *Buffer,
                                    *EntriesRead,
                                    *TotalEntries
                                    );
            }
        }
    }

    //
    //  We've merged the local list into the appropriate interim table,
    //  now free it up.
    //

    if (*EntriesRead != 0) {
        MIDL_user_free(*Buffer);
    }

    status = PackServerList((ServerType == SV_TYPE_DOMAIN_ENUM ?
                                                    &Network->DomainList :
                                                    &Network->BrowseTable),
                                Level,
                                ServerType,
                                PreferedMaximumLength,
                                Buffer,
                                EntriesRead,
                                TotalEntries,
                                FirstNameToReturn
                                );
    return status;
}

NET_API_STATUS
BrRetrieveServerListForBackup(
    IN PNETWORK Network,
    IN OUT PVOID *Buffer,
    OUT PDWORD EntriesRead,
    OUT PDWORD TotalEntries,
    IN DWORD Level,
    IN DWORD ServerType,
    IN DWORD PreferedMaximumLength,
    IN LPCWSTR FirstNameToReturn
    )
{
    PSERVER_INFO_101 ServerList, ClientServerInfo;
    ULONG EntriesInList;
    ULONG TotalEntriesInList;
    ULONG EntrySize;
    ULONG BufferSize;
    LPTSTR BufferEnd;
    BOOLEAN ReturnWholeList = FALSE;
    BOOLEAN TrimmingNames;
    BOOLEAN BufferFull = FALSE; // see bug 427656

    //
    //  If we are not running as a master, we want to use our stored
    //  server list to figure out what the client gets.
    //

    if (ServerType == SV_TYPE_DOMAIN_ENUM) {

        ServerList = Network->BackupDomainList;

        TotalEntriesInList = EntriesInList = Network->TotalBackupDomainListEntries;

        ReturnWholeList = TRUE;

    } else {
        ServerList = Network->BackupServerList;

        TotalEntriesInList = EntriesInList = Network->TotalBackupServerListEntries;

        if (ServerType == SV_TYPE_ALL) {
            ReturnWholeList = TRUE;
        }
    }

    //
    //  Figure out the largest buffer we have to allocate to hold this
    //  server info.
    //

    if (Level == 101) {
        if (PreferedMaximumLength == MAXULONG) {

            if (ServerType == SV_TYPE_DOMAIN_ENUM) {
                BufferSize = (sizeof(SERVER_INFO_101) + (CNLEN+1 + CNLEN+1)*sizeof(TCHAR)) * EntriesInList;
            } else {
                BufferSize = (sizeof(SERVER_INFO_101) + (CNLEN+1 + LM20_MAXCOMMENTSZ+1)*sizeof(TCHAR)) * EntriesInList;
            }
        } else {
            BufferSize = PreferedMaximumLength;
        }

        EntrySize = sizeof(SERVER_INFO_101);
    } else {
        if (PreferedMaximumLength == MAXULONG) {
            BufferSize = (sizeof(SERVER_INFO_100) + (CNLEN+1)*sizeof(TCHAR)) * EntriesInList;
        } else {
            BufferSize = PreferedMaximumLength;
        }

        EntrySize = sizeof(SERVER_INFO_100);
    }

    *Buffer = MIDL_user_allocate(BufferSize);

    if (*Buffer == NULL) {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    BufferEnd = (LPTSTR)((ULONG_PTR)*Buffer+BufferSize);

    ClientServerInfo = *Buffer;

    *TotalEntries = 0;

    *EntriesRead = 0;

    //
    //  While there are still entries to process....
    //

    TrimmingNames = (FirstNameToReturn != NULL && *FirstNameToReturn != L'\0');
    while (EntriesInList) {

        EntriesInList -= 1;

        //
        //  If this entry is appropriate to be packed,
        //

        if ( (ServerList->sv101_type & ServerType) &&
             (!TrimmingNames ||
              STRCMP( ServerList->sv101_name, FirstNameToReturn ) >= 0 ) ) {

            TrimmingNames = FALSE;

            //
            //  Indicate one more entry in the list.
            //

            *TotalEntries += 1;

            //
            //  If we can fit this entry before the buffer end,
            //  pack in the information into the buffer.
            //

            if ( !BufferFull &&
                 (ULONG_PTR)ClientServerInfo+EntrySize <= (ULONG_PTR)BufferEnd) {

                //
                //  Copy over the platform ID and computer name.
                //

                ClientServerInfo->sv101_platform_id = ServerList->sv101_platform_id;

                ClientServerInfo->sv101_name = ServerList->sv101_name;

                if (NetpPackString(&ClientServerInfo->sv101_name,
                                    (LPBYTE)((PCHAR)ClientServerInfo)+EntrySize,
                                    &BufferEnd)) {

                    if (Level == 101) {

                        ClientServerInfo->sv101_version_major = ServerList->sv101_version_major;

                        ClientServerInfo->sv101_version_minor = ServerList->sv101_version_minor;

                        ClientServerInfo->sv101_type = ServerList->sv101_type;

                        ClientServerInfo->sv101_comment = ServerList->sv101_comment;

                        if (NetpPackString(&ClientServerInfo->sv101_comment,
                                            (LPBYTE)((PCHAR)ClientServerInfo)+EntrySize,
                                            &BufferEnd)) {
                            *EntriesRead += 1;
                        }
                        else {
                            BufferFull = TRUE;
                        }
                    } else {
                        *EntriesRead += 1;
                    }
                }
                else {
                    BufferFull = TRUE;
                }

                ClientServerInfo = (PSERVER_INFO_101)((PCHAR)ClientServerInfo+EntrySize);
            } else {
                //
                //  If we're returning the entire list, we can
                //  early out now, since there's no point in continuing.
                //

                if (ReturnWholeList) {

                    *TotalEntries = TotalEntriesInList;

                    break;
                }
                BufferFull = TRUE;
            }

        }

        ServerList += 1;
    }

    //
    //  If we weren't able to pack all the entries into the list,
    //  return ERROR_MORE_DATA
    //

    if (*EntriesRead != *TotalEntries) {
        return ERROR_MORE_DATA;
    } else {
        return NERR_Success;
    }

}



NET_API_STATUS
I_BrowserrResetStatistics (
    IN  LPTSTR      servername OPTIONAL
    )
{
    NET_API_STATUS Status = NERR_Success;
    ULONG BufferSize;





    //
    // Perform access validation on the caller.
    //

    Status = NetpAccessCheck(
            BrGlobalBrowserSecurityDescriptor,     // Security descriptor
            BROWSER_CONTROL_ACCESS,                // Desired access
            &BrGlobalBrowserInfoMapping );         // Generic mapping

    if ( Status != NERR_Success) {

        BrPrint((BR_CRITICAL,
                "I_BrowserrResetStatistics failed NetpAccessCheck\n" ));
        return ERROR_ACCESS_DENIED;
    }

    EnterCriticalSection(&BrowserStatisticsLock);

    NumberOfServerEnumerations = 0;

    NumberOfDomainEnumerations = 0;

    NumberOfOtherEnumerations = 0;

    NumberOfMissedGetBrowserListRequests = 0;

    //
    //  Reset the driver's statistics as well.
    //

    if (!DeviceIoControl(BrDgReceiverDeviceHandle, IOCTL_LMDR_RESET_STATISTICS, NULL, 0, NULL, 0, &BufferSize, NULL)) {

        //
        // The API failed, return the error.
        //

        Status = GetLastError();
    }

    LeaveCriticalSection(&BrowserStatisticsLock);

    return Status;
}

NET_API_STATUS
I_BrowserrQueryStatistics (
    IN  LPTSTR      servername OPTIONAL,
    OUT LPBROWSER_STATISTICS *Statistics
    )
{
    NET_API_STATUS Status = NERR_Success;
    BOWSER_STATISTICS BowserStatistics;
    ULONG BufferSize;





    //
    // Perform access validation on the caller.
    //

    Status = NetpAccessCheck(
            BrGlobalBrowserSecurityDescriptor,     // Security descriptor
            BROWSER_QUERY_ACCESS,                  // Desired access
            &BrGlobalBrowserInfoMapping );         // Generic mapping

    if ( Status != NERR_Success) {

        BrPrint((BR_CRITICAL,
                "I_BrowserrQueryStatistics failed NetpAccessCheck\n" ));
        return ERROR_ACCESS_DENIED;
    }


    *Statistics = MIDL_user_allocate(sizeof(BROWSER_STATISTICS));

    if (*Statistics == NULL) {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    EnterCriticalSection(&BrowserStatisticsLock);

    if (!DeviceIoControl(BrDgReceiverDeviceHandle, IOCTL_LMDR_QUERY_STATISTICS, NULL, 0, &BowserStatistics, sizeof(BowserStatistics), &BufferSize, NULL)) {

        //
        // The API failed, return the error.
        //

        Status = GetLastError();
    } else {

        if (BufferSize != sizeof(BOWSER_STATISTICS)) {
            Status = ERROR_INSUFFICIENT_BUFFER;
        } else {
            (*Statistics)->StatisticsStartTime = BowserStatistics.StartTime;

            (*Statistics)->NumberOfServerAnnouncements = BowserStatistics.NumberOfServerAnnouncements;
            (*Statistics)->NumberOfDomainAnnouncements = BowserStatistics.NumberOfDomainAnnouncements;
            (*Statistics)->NumberOfElectionPackets = BowserStatistics.NumberOfElectionPackets;
            (*Statistics)->NumberOfMailslotWrites = BowserStatistics.NumberOfMailslotWrites;
            (*Statistics)->NumberOfGetBrowserServerListRequests = BowserStatistics.NumberOfGetBrowserServerListRequests;
            (*Statistics)->NumberOfMissedServerAnnouncements = BowserStatistics.NumberOfMissedServerAnnouncements;
            (*Statistics)->NumberOfMissedMailslotDatagrams = BowserStatistics.NumberOfMissedMailslotDatagrams;
            (*Statistics)->NumberOfMissedGetBrowserServerListRequests = BowserStatistics.NumberOfMissedGetBrowserServerListRequests +
                                                                            NumberOfMissedGetBrowserListRequests;
            (*Statistics)->NumberOfFailedServerAnnounceAllocations = BowserStatistics.NumberOfFailedServerAnnounceAllocations;
            (*Statistics)->NumberOfFailedMailslotAllocations = BowserStatistics.NumberOfFailedMailslotAllocations;
            (*Statistics)->NumberOfFailedMailslotReceives = BowserStatistics.NumberOfFailedMailslotReceives;
            (*Statistics)->NumberOfFailedMailslotWrites = BowserStatistics.NumberOfFailedMailslotWrites;
            (*Statistics)->NumberOfFailedMailslotOpens = BowserStatistics.NumberOfFailedMailslotOpens;
            (*Statistics)->NumberOfDuplicateMasterAnnouncements = BowserStatistics.NumberOfDuplicateMasterAnnouncements;
            (*Statistics)->NumberOfIllegalDatagrams = BowserStatistics.NumberOfIllegalDatagrams;

            //
            //  Now fill in the local statistics.
            //

            (*Statistics)->NumberOfServerEnumerations = NumberOfServerEnumerations;
            (*Statistics)->NumberOfDomainEnumerations = NumberOfDomainEnumerations;
            (*Statistics)->NumberOfOtherEnumerations = NumberOfOtherEnumerations;

        }
    }

    LeaveCriticalSection(&BrowserStatisticsLock);

    return Status;
}



//
//  Browser request response cache management logic.
//



PCACHED_BROWSE_RESPONSE
BrLookupAndAllocateCachedEntry(
    IN PNETWORK Network,
    IN DWORD ServerType,
    IN WORD Size,
    IN DWORD Level,
    IN LPCWSTR FirstNameToReturn
    )
/*++

Routine Description:

    This function will look up (and allocate if appropriate) a cached
    browse response for this browse.

    Enter with the Network Locked shared or exclusive.

Arguments:
    IN PNETWORK Network - Network to allocate entry on.
    IN DWORD ServerType - Server type bits for request.
    IN WORD Size,       - Users buffer size for request.
    IN WORD Level       - Level of request.

    FirstNameToReturn - Supplies the name of the first domain or server entry to return.
        The caller can use this parameter to implement a resume handle of sorts by passing
        the name of the last entry returned on a previous call.  (Notice that the specified
        entry will, also, be returned on this call unless it has since been deleted.)

        Passed name must be the canonical form of the name.

        This entry is never NULL.  It may be a pointer to an empty string to indicate
        the enumeration starts at the beginning of the list.


Return Value:

    PCACHED_BROWSE_RESPONSE - NULL or a cached response for the request.

--*/

{
    PLIST_ENTRY entry;
    PCACHED_BROWSE_RESPONSE response;

    //
    // If we have more cached responses than we are allowed,
    //  remove the last entry from the list and free it.
    //

    if (Network->NumberOfCachedResponses > BrInfo.NumberOfCachedResponses) {

        //
        // We need to release the network and re-acquire it
        // exclusively, because we use the network lock to protect
        // enumerations from deletions.
        //

        UNLOCK_NETWORK(Network);

        if (LOCK_NETWORK(Network)) {

            EnterCriticalSection(&Network->ResponseCacheLock);
            if (Network->NumberOfCachedResponses > BrInfo.NumberOfCachedResponses) {

                PLIST_ENTRY LastEntry = RemoveTailList(&Network->ResponseCache);

                response = CONTAINING_RECORD(LastEntry, CACHED_BROWSE_RESPONSE, Next);

                Network->NumberOfCachedResponses -= 1;

                response->Next.Flink = NULL;
                response->Next.Blink = NULL;

                //
                //  Free the last cached entry.
                //

                BrDestroyCacheEntry( response );

                response = NULL;
            }
            LeaveCriticalSection(&Network->ResponseCacheLock);
        }
    }

    //
    // Search the list of responses for this one.
    //

    EnterCriticalSection(&Network->ResponseCacheLock);

    for (entry = Network->ResponseCache.Flink ;
         entry != &Network->ResponseCache ;
         entry = entry->Flink ) {

        response = CONTAINING_RECORD(entry, CACHED_BROWSE_RESPONSE, Next);

        //
        //  If this response cache entry matches the incoming request,
        //  we can increment the hit count for this entry and return it.
        //

        if (response->Level == Level
                &&
            response->ServerType == ServerType
                &&
            response->Size == Size
                &&
            wcscmp( response->FirstNameToReturn, FirstNameToReturn ) == 0) {

            //
            //  This response exactly matches the request.
            //
            //  Bump its hit count and move it to the head of the cache.
            //

            response->HitCount += 1;

            response->TotalHitCount += 1;

            //
            //  Remove this entry from its current location in the list and
            //  move it to the head of the list.
            //

            RemoveEntryList(&response->Next);

            InsertHeadList(&Network->ResponseCache, &response->Next);

            BrPrint(( BR_SERVER_ENUM,
                      "%ws: %ws: Found cache entry 0x%x/%d/%x H:%d T:%d\n",
                      Network->DomainInfo->DomUnicodeDomainName,
                      Network->NetworkName.Buffer,
                      response->ServerType,
                      response->Level,
                      response->Size,
                      response->HitCount,
                      response->TotalHitCount ));

            LeaveCriticalSection(&Network->ResponseCacheLock);

            return response;
        }
    }

    //
    //  We've walked our entire cache and have been unable to find
    //  a response that matches our request.
    //
    //  Allocate a new response cache entry and hook it into the cache.
    //

    response = BrAllocateResponseCacheEntry(Network, ServerType, Size, Level, FirstNameToReturn );

    LeaveCriticalSection(&Network->ResponseCacheLock);

    return response;

}

VOID
BrAgeResponseCache(
    IN PNETWORK Network
    )
/*++

Routine Description:

    This function will age response cache entries for a network.

    We scan the response cache, and every entry that has a cached response
    will be tossed.  In addition, any entry that has had less than the
    cache hit limit number of hits since the past scan will also be removed.

Arguments:
    IN PNETWORK Network - Network to age entries on.

Return Value:

    None.


--*/
{
    PLIST_ENTRY entry;

    EnterCriticalSection(&Network->ResponseCacheLock);

    try {

        for (entry = Network->ResponseCache.Flink ;
             entry != &Network->ResponseCache ;
             entry = entry->Flink ) {
            PCACHED_BROWSE_RESPONSE response = CONTAINING_RECORD(entry, CACHED_BROWSE_RESPONSE, Next);

            //
            //  If this response didn't have a hit count high enough during
            //  the previous run to justify keeping it around, blow it away.
            //

            if (response->HitCount < BrInfo.CacheHitLimit) {
                response->LowHitCount += 1;
            }

            //
            //  If we have CacheHitLimit iterations of low hits, then
            //  flush the entry from the cache.
            //

            if (response->LowHitCount > BrInfo.CacheHitLimit) {
                PLIST_ENTRY nextentry = entry->Blink;

                BrPrint(( BR_SERVER_ENUM,
                          "%ws: %ws: Flush cache entry for 0x%x/%d/%x H:%d T:%d\n",
                          Network->DomainInfo->DomUnicodeDomainName,
                          Network->NetworkName.Buffer,
                          response->ServerType,
                          response->Level,
                          response->Size,
                          response->HitCount,
                          response->TotalHitCount ));

                Network->NumberOfCachedResponses -= 1;

                RemoveEntryList(entry);

                entry->Flink = NULL;
                entry->Blink = NULL;

                BrDestroyCacheEntry(response);

                entry = nextentry;

                //
                //  Null out the pointer to make sure we don't use it again.
                //

                response = NULL;

            } else {
                BrPrint(( BR_SERVER_ENUM,
                          "%ws: %ws: Retain cache entry 0x%x/%d/%x H:%d T:%d\n",
                          Network->DomainInfo->DomUnicodeDomainName,
                          Network->NetworkName.Buffer,
                          response->ServerType, response->Level, response->Size, response->HitCount, response->TotalHitCount ));

                //
                //  We ALWAYS blow away the response buffer during an age pass.
                //

                MIDL_user_free( response->Buffer );

                response->Buffer = NULL;

                //
                //  Reset the hit count for this entry for this pass.
                //

                response->HitCount = 0;
            }

        }

    } finally {
        LeaveCriticalSection(&Network->ResponseCacheLock);
    }
}


PCACHED_BROWSE_RESPONSE
BrAllocateResponseCacheEntry(
    IN PNETWORK Network,
    IN DWORD ServerType,
    IN WORD Size,
    IN DWORD Level,
    IN LPCWSTR FirstNameToReturn
    )
/*++

Routine Description:

    This function will allocate a new browse response cache entry.

Arguments:
    IN PNETWORK Network - Network to allocate entry on.
    IN DWORD ServerType - Server type bits for request.
    IN WORD Size,       - Users buffer size for request.
    IN WORD Level       - Level of request.

    FirstNameToReturn   - FirstNameCached

Return Value:

    PCACHED_BROWSE_RESPONSE - NULL or a cached response for the request.

NOTE:  This is called with the network response cache locked.

--*/

{
    PCACHED_BROWSE_RESPONSE response;

    response = MIDL_user_allocate( sizeof( CACHED_BROWSE_RESPONSE ) );

    if ( response == NULL ) {
        return NULL;
    }

    //
    //  Flag the information for this response.
    //

    response->ServerType = ServerType;
    response->Size = Size;
    response->Level = Level;

    //
    //  Initialize the other fields in the response.
    //

    response->Buffer = NULL;
    response->HitCount = 0;
    response->TotalHitCount = 0;
    response->LowHitCount = 0;
    response->Status = NERR_Success;
    wcscpy( response->FirstNameToReturn, FirstNameToReturn );

    Network->NumberOfCachedResponses += 1;

    //
    //  We hook this response into the tail of the cache.  We do this
    //  because we assume that this request won't be used frequently.  If
    //  it is, it will move to the head of the cache naturally.
    //

    InsertTailList(&Network->ResponseCache, &response->Next);

    return response;
}

NET_API_STATUS
BrDestroyCacheEntry(
    IN PCACHED_BROWSE_RESPONSE CacheEntry
    )
/*++

Routine Description:

    This routine destroys an individual response cache entry.

Arguments:
    IN PCACHED_BROWSE_RESPONSE CacheEntry - Entry to destroy.

Return Value:

    NET_API_STATUS - NERR_Success

--*/
{
    ASSERT (CacheEntry->Next.Flink == NULL);
    ASSERT (CacheEntry->Next.Blink == NULL);

    if (CacheEntry->Buffer != NULL) {
        MIDL_user_free(CacheEntry->Buffer);
    }

    MIDL_user_free(CacheEntry);

    return NERR_Success;
}

NET_API_STATUS
BrDestroyResponseCache(
    IN PNETWORK Network
    )
/*++

Routine Description:

    This routine destroys the entire response cache for a supplied network.

Arguments:
    IN PNETWORK Network - Network to allocate entry on.

Return Value:

    NET_API_STATUS - NERR_Success

--*/

{
    while (!IsListEmpty(&Network->ResponseCache)) {
        PCACHED_BROWSE_RESPONSE cacheEntry;
        PLIST_ENTRY entry = RemoveHeadList(&Network->ResponseCache);

        entry->Flink = NULL;
        entry->Blink = NULL;

        cacheEntry = CONTAINING_RECORD(entry, CACHED_BROWSE_RESPONSE, Next);

        Network->NumberOfCachedResponses -= 1;

        BrDestroyCacheEntry(cacheEntry);

    }

    ASSERT (Network->NumberOfCachedResponses == 0);

    return NERR_Success;
}

NET_API_STATUS
NetrBrowserStatisticsGet (
    IN  LPTSTR      servername OPTIONAL,
    IN  DWORD Level,
    IN OUT LPBROWSER_STATISTICS_STRUCT InfoStruct
    )
{
    //
    //  And return success.
    //

    return(NERR_Success);

}

NET_API_STATUS
NetrBrowserStatisticsClear (
    IN  LPTSTR      servername OPTIONAL
    )
{
    //
    //  And return success.
    //

    return(NERR_Success);

}

#if DBG

NET_API_STATUS
I_BrowserrDebugCall (
    IN  LPTSTR      servername OPTIONAL,
    IN DWORD DebugCode,
    IN DWORD OptionalValue
    )
{
    NET_API_STATUS Status = STATUS_SUCCESS;




    //
    // Perform access validation on the caller.
    //

    Status = NetpAccessCheck(
            BrGlobalBrowserSecurityDescriptor,     // Security descriptor
            BROWSER_CONTROL_ACCESS,                // Desired access
            &BrGlobalBrowserInfoMapping );         // Generic mapping

    if ( Status != NERR_Success) {

        BrPrint((BR_CRITICAL,
                "I_BrowserrDebugCall failed NetpAccessCheck\n" ));
        return ERROR_ACCESS_DENIED;
    }

    switch (DebugCode) {
    case BROWSER_DEBUG_BREAK_POINT:
        DbgBreakPoint();
        break;

    case BROWSER_DEBUG_DUMP_NETWORKS:
        BrDumpNetworks();
        break;
    case BROWSER_DEBUG_SET_DEBUG:
        BrInfo.BrowserDebug |= OptionalValue;
        BrPrint(( BR_INIT, "Setting browser trace to %lx\n", BrInfo.BrowserDebug));
        break;

    case BROWSER_DEBUG_CLEAR_DEBUG:
        BrInfo.BrowserDebug &= ~OptionalValue;
        BrPrint(( BR_INIT, "Setting browser trace to %lx\n", BrInfo.BrowserDebug));
        break;
    case BROWSER_DEBUG_TRUNCATE_LOG:
        Status = BrTruncateLog();
        break;

    default:
        BrPrint(( BR_CRITICAL, "Unknown debug callout %lx\n", DebugCode));
        DbgBreakPoint();
        break;
    }

    return Status;

}

NET_API_STATUS
I_BrowserrDebugTrace (
    IN  LPTSTR      servername OPTIONAL,
    IN  LPSTR String
    )
{
    NET_API_STATUS Status;


    //
    // Perform access validation on the caller.
    //

    Status = NetpAccessCheck(
            BrGlobalBrowserSecurityDescriptor,     // Security descriptor
            BROWSER_CONTROL_ACCESS,                // Desired access
            &BrGlobalBrowserInfoMapping );         // Generic mapping

    if ( Status != NERR_Success) {

        BrPrint((BR_CRITICAL,
                "I_BrowserrDebugTrace failed NetpAccessCheck\n" ));
        return ERROR_ACCESS_DENIED;
    }

    //
    //  Stick the string parameter into the browser log.
    //

    BrowserTrace( BR_UTIL, "%s", String);

    //
    //  And return success.
    //

    return(NERR_Success);

}
#else

NET_API_STATUS
I_BrowserrDebugCall (
    IN  LPTSTR      servername OPTIONAL,
    IN DWORD DebugCode,
    IN DWORD OptionalValue
    )
{
    return(ERROR_NOT_SUPPORTED);

}
NET_API_STATUS
I_BrowserrDebugTrace (
    IN  LPTSTR      servername OPTIONAL,
    IN LPSTR String
    )
{
    return(ERROR_NOT_SUPPORTED);

}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\dfs\client\makefile.inc ===
$(O)\netdfs_c.c : ..\$(O)\netdfs_c.c
    copy $? $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\dfs\client\dfsacl.c ===
//-----------------------------------------------------------------------------
//
//  Copyright (C) 1998, Microsoft Corporation
//
//  File:       dfsacl.c

//  Contents:   Functions to add/remove entries from ACL list(s).
//
//  History:    Nov 6, 1998 JHarper created
//
//-----------------------------------------------------------------------------

#include <stdio.h>
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <winldap.h>
#include <ntldap.h>
#include <stdlib.h>
#include <dsgetdc.h>
#include <lm.h>
#include <sddl.h>

#include "dfsacl.h"

DWORD
ReadDSObjSecDesc(
    PLDAP pLDAP,
    PWSTR pwszObject,
    SECURITY_INFORMATION SeInfo,
    PSECURITY_DESCRIPTOR *ppSD,
    PULONG pcSDSize);

DWORD
DfsGetObjSecurity(
    LDAP *pldap,
    LPWSTR pwszObjectName,
    LPWSTR *pwszStringSD);

DWORD
DfsStampSD(
    PWSTR pwszObject,
    ULONG cSDSize,
    SECURITY_INFORMATION SeInfo,
    PSECURITY_DESCRIPTOR pSD,
    PLDAP pLDAP);

DWORD
DfsAddAce(
    LDAP *pldap,
    LPWSTR wszObjectName,
    LPWSTR wszStringSD,
    LPWSTR wszwszStringSid);

DWORD
DfsRemoveAce(
    LDAP *pldap,
    LPWSTR wszObjectName,
    LPWSTR wszStringSD,
    LPWSTR wszwszStringSid);

BOOL
DfsFindSid(
    LPWSTR DcName,
    LPWSTR Name,
    PSID *Sid);

BOOLEAN
DfsSidInAce(
    LPWSTR wszAce,
    LPWSTR wszStringSid);

#define ACTRL_SD_PROP_NAME  L"nTSecurityDescriptor"

//
// Name of the attribute holding the ACL/ACE list
//

#define ACTRL_SD_PROP_NAME  L"nTSecurityDescriptor"

//
// The sddl description of the ACE we will be adding
//
LPWSTR wszAce = L"(A;;RPWP;;;";

#if DBG
extern ULONG DfsDebug;
#endif

//+---------------------------------------------------------------------------
//
//  Function:   DfsAddMachineAce
//
//  Synopsis:   Adds an ACE representing this machine to the ACL list of the
//              object.
//
//  Arguments:  [pldap]         --  The open LDAP connection
//              [wszDcName]     --  The DC whose DS we are to use.
//              [wszObjectName] --  The fully-qualified name of the DS object
//              [wszRootName]   --  The name of the machine/root we want to add
//
//  Returns:    ERROR_SUCCESS       --  The object is reachable
//              ERROR_NOT_ENOUGH_MEMORY A memory allocation failed
//
//----------------------------------------------------------------------------
DWORD
DfsAddMachineAce(
    LDAP *pldap,
    LPWSTR wszDcName,
    LPWSTR wszObjectName,
    LPWSTR wszRootName)
{
    ULONG dwErr = ERROR_SUCCESS;
    PSID Sid = NULL;
    BOOL Result;
    ULONG i;
    ULONG Len = 0;
    LPWSTR wszStringSD = NULL;
    LPWSTR wszStringSid = NULL;
    LPWSTR wszNewRootName = NULL;
    UNICODE_STRING DnsName;
    UNICODE_STRING NetBiosName;

#if DBG
    if (DfsDebug)
        DbgPrint("DfsAddMachineAce(%ws,%ws)\n", wszObjectName, wszRootName);
#endif
    //
    // Get Security Descriptor on the FtDfs object
    //
    dwErr = DfsGetObjSecurity(pldap, wszObjectName, &wszStringSD);
    if (dwErr != ERROR_SUCCESS)
        goto Cleanup;

#if DBG
    if (DfsDebug)
        DbgPrint("ACL=[%ws]\n", wszStringSD);
#endif

    Len = wcslen(wszRootName);
    wszNewRootName = malloc((Len + 2) * sizeof(WCHAR));
    if (wszNewRootName == NULL) {
        dwErr = ERROR_OUTOFMEMORY;
        goto Cleanup;
    }

    NetBiosName.Buffer = wszNewRootName;
    NetBiosName.MaximumLength = (USHORT)((Len + 2) * sizeof(WCHAR));
    NetBiosName.Length = 0;
    DnsName.Buffer = wszRootName;
    DnsName.Length = (USHORT)(Len * sizeof(WCHAR));
    DnsName.MaximumLength = DnsName.Length + sizeof(WCHAR);
    dwErr = RtlDnsHostNameToComputerName(
                                      &NetBiosName,
                                      &DnsName,
                                      FALSE);
    NetBiosName.Buffer[NetBiosName.Length/sizeof(WCHAR)] = L'\0';
    wcscat(wszNewRootName, L"$");

    //
    // Get SID representing root machine
    //
    Result = DfsFindSid(wszDcName,wszNewRootName, &Sid);
    if (Result != TRUE) {
        dwErr = ERROR_OBJECT_NOT_FOUND;
        goto Cleanup;
    }
#if DBG
    if (DfsDebug)
        DbgPrint("Got SID for %ws\n", wszRootName);
#endif
    //
    // Convert the machine SID to a string
    //
    Result = ConvertSidToStringSid(Sid, &wszStringSid);
    if (Result != TRUE) {
        dwErr = ERROR_OBJECT_NOT_FOUND;
        goto Cleanup;
    }
#if DBG
    if (DfsDebug)
        DbgPrint("Sid=[%ws]\n", wszStringSid);
#endif
    //
    // Now update the ACL list on the FtDfs object
    //
    dwErr = DfsAddAce(
                pldap,
                wszObjectName,
                wszStringSD,
                wszStringSid);

Cleanup:
    if (wszNewRootName != NULL)
        free(wszNewRootName);
    if (wszStringSD != NULL)
        LocalFree(wszStringSD);
    if (wszStringSid != NULL)
        LocalFree(wszStringSid);
    if (Sid != NULL) {
	LocalFree(Sid);
    }

#if DBG
    if (DfsDebug)
        DbgPrint("DfsAddMachineAce returning %d\n", dwErr);
#endif
    return dwErr;

}

//+---------------------------------------------------------------------------
//
//  Function:   DfsRemoveMachineAce
//
//  Synopsis:   Removes an ACE representing this machine from the ACL list of the
//              object.
//
//  Arguments:  [pldap]         --  The open LDAP connection
//              [wszDcName]     --  The DC whose DS we are to use.
//              [wszObjectName] --  The fully-qualified name of the DS object
//              [wszRootName]   --  The name of the machine/root we want to remove
//
//  Returns:    ERROR_SUCCESS       --  The object is reachable
//              ERROR_NOT_ENOUGH_MEMORY A memory allocation failed
//
//----------------------------------------------------------------------------
DWORD
DfsRemoveMachineAce(
    LDAP *pldap,
    LPWSTR wszDcName,
    LPWSTR wszObjectName,
    LPWSTR wszRootName)
{
    ULONG dwErr = ERROR_SUCCESS;
    PSID Sid = NULL;
    BOOL Result;
    LPWSTR wszStringSD = NULL;
    LPWSTR wszStringSid = NULL;
    LPWSTR wszNewRootName = NULL;
    ULONG i;
    ULONG Len = 0;
    UNICODE_STRING DnsName;
    UNICODE_STRING NetBiosName;

#if DBG
    if (DfsDebug)
        DbgPrint("DfsRemoveMachineAce(%ws,%ws)\n", wszObjectName, wszRootName);
#endif
    //
    // Get Security Descriptor on the FtDfs object
    //
    dwErr = DfsGetObjSecurity(pldap, wszObjectName, &wszStringSD);
    if (dwErr != ERROR_SUCCESS)
        goto Cleanup;

#if DBG
    if (DfsDebug)
        DbgPrint("ACL=[%ws]\n", wszStringSD);
#endif
    Len = wcslen(wszRootName);
    wszNewRootName = malloc((Len + 2) * sizeof(WCHAR));
    if (wszNewRootName == NULL) {
        dwErr = ERROR_OUTOFMEMORY;
        goto Cleanup;
    }

    NetBiosName.Buffer = wszNewRootName;
    NetBiosName.MaximumLength = (USHORT)((Len + 2) * sizeof(WCHAR));
    NetBiosName.Length = 0;
    DnsName.Buffer = wszRootName;
    DnsName.Length = (USHORT)(Len * sizeof(WCHAR));
    DnsName.MaximumLength = DnsName.Length + sizeof(WCHAR);
    dwErr = RtlDnsHostNameToComputerName(
                                      &NetBiosName,
                                      &DnsName,
                                      FALSE);
    NetBiosName.Buffer[NetBiosName.Length/sizeof(WCHAR)] = L'\0';
    wcscat(wszNewRootName, L"$");

    //
    // Get SID representing root machine
    //
    Result = DfsFindSid(wszDcName,wszNewRootName, &Sid);
    if (Result != TRUE) {
        dwErr = ERROR_OBJECT_NOT_FOUND;
        goto Cleanup;
    }
#if DBG
    if (DfsDebug)
        DbgPrint("Got SID for %ws\n", wszRootName);
#endif
    //
    // Convert the machine SID to a string
    //
    Result = ConvertSidToStringSid(Sid, &wszStringSid);
    if (Result != TRUE) {
        dwErr = ERROR_OBJECT_NOT_FOUND;
        goto Cleanup;
    }
#if DBG
    if (DfsDebug)
        DbgPrint("Sid=[%ws]\n", wszStringSid);
#endif
    //
    // Now update the ACL list on the FtDfs object
    //
    dwErr = DfsRemoveAce(
                pldap,
                wszObjectName,
                wszStringSD,
                wszStringSid);

Cleanup:
    if (wszNewRootName != NULL)
        free(wszNewRootName);
    if (wszStringSD != NULL)
        LocalFree(wszStringSD);
    if (wszStringSid != NULL)
        LocalFree(wszStringSid);
    if (Sid != NULL) {
	LocalFree(Sid);
    }

#if DBG
    if (DfsDebug)
        DbgPrint("DfsRemoveMachineAce exit %d\n", dwErr);
#endif
    return dwErr;

}

//+---------------------------------------------------------------------------
//
//  Function:   ReadDSObjSecDesc
//
//  Synopsis:   Reads the security descriptor from the specied object via
//              the open ldap connection
//
//  Arguments:  [pLDAP]         --  The open LDAP connection
//              [pwszDSObj]     --  The DSObject to get the security
//                                      descriptor for
//              [SeInfo]        --  Parts of the security descriptor to
//                                      read.
//              [ppSD]          --  Where the security descriptor is
//                                      returned
//              [pcSDSize       -- Size of the security descriptor
//
//  Returns:    ERROR_SUCCESS       --  The object is reachable
//              ERROR_NOT_ENOUGH_MEMORY A memory allocation failed
//
//  Notes:      The returned security descriptor must be freed with LocalFree
//
//----------------------------------------------------------------------------
DWORD
ReadDSObjSecDesc(
    PLDAP pLDAP,
    PWSTR pwszObject,
    SECURITY_INFORMATION SeInfo,
    PSECURITY_DESCRIPTOR *ppSD,
    PULONG pcSDSize)
{
    DWORD dwErr = ERROR_SUCCESS;
    PLDAPMessage pMsg = NULL;
    PWSTR rgAttribs[2];
    BYTE berValue[8];

    LDAPControl SeInfoControl =
                    {
                        LDAP_SERVER_SD_FLAGS_OID_W,
                        {
                            5, (PCHAR)berValue
                        },
                        TRUE
                    };

    PLDAPControl ServerControls[2] =
                    {
                        &SeInfoControl,
                        NULL
                    };

#if DBG
    if (DfsDebug)
        DbgPrint("ReadDSObjSecDesc(%ws)\n", pwszObject);
#endif

    berValue[0] = 0x30;
    berValue[1] = 0x03;
    berValue[2] = 0x02;
    berValue[3] = 0x01;
    berValue[4] = (BYTE)((ULONG)SeInfo & 0xF);


    rgAttribs[0] = ACTRL_SD_PROP_NAME;
    rgAttribs[1] = NULL;

    dwErr = ldap_search_ext_s(
                    pLDAP,
                    pwszObject,
                    LDAP_SCOPE_BASE,
                    L"(objectClass=*)",
                    rgAttribs,
                    0,
                    (PLDAPControl *)&ServerControls,
                    NULL,
                    NULL,
                    10000,
                    &pMsg);

    dwErr = LdapMapErrorToWin32( dwErr );
    if(dwErr == ERROR_SUCCESS) {

        LDAPMessage *pEntry = NULL;
        PWSTR *ppwszValues = NULL;
        PLDAP_BERVAL *pSize = NULL;

        pEntry = ldap_first_entry(pLDAP, pMsg);
        if(pEntry != NULL) {
            //
            // Now, we'll have to get the values
            //
            ppwszValues = ldap_get_values(pLDAP, pEntry, rgAttribs[0]);
            if(ppwszValues != NULL) {
                pSize = ldap_get_values_len(pLDAP, pMsg, rgAttribs[0]);
                if(pSize != NULL) {
                    //
                    // Allocate the security descriptor to return
                    //
                    *ppSD = (PSECURITY_DESCRIPTOR)malloc((*pSize)->bv_len);
                    if(*ppSD != NULL) {
                        memcpy(*ppSD, (PBYTE)(*pSize)->bv_val, (*pSize)->bv_len);
                        *pcSDSize = (*pSize)->bv_len;
                    } else {
                        dwErr = ERROR_NOT_ENOUGH_MEMORY;
                    }
                    ldap_value_free_len(pSize);
                } else {
                    dwErr = LdapMapErrorToWin32( pLDAP->ld_errno );
                }
                ldap_value_free(ppwszValues);
            } else {
                dwErr = LdapMapErrorToWin32( pLDAP->ld_errno );
            }
        } else {
            dwErr = LdapMapErrorToWin32( pLDAP->ld_errno );
        }
    }
    if (pMsg != NULL)
        ldap_msgfree(pMsg);
#if DBG
    if (DfsDebug)
        DbgPrint("ReadDSObjSecDesc returning %d\n", dwErr);
#endif
    return(dwErr);
}

//+---------------------------------------------------------------------------
//
//  Function:   DfsGetObjSecurity
//
//  Synopsis:   Gets the ACL list of an object in sddl stringized form
//
//  Arguments:  [pldap]         --  The open LDAP connection
//              [wszObjectName] --  The fully-qualified name of the DS object
//              [pwszStringSD]  --  Pointer to pointer to SD in string form (sddl)
//
//  Returns:    ERROR_SUCCESS   --  The object is reachable
//
//----------------------------------------------------------------------------
DWORD
DfsGetObjSecurity(
    LDAP *pldap,
    LPWSTR pwszObjectName,
    LPWSTR *pwszStringSD)
{
    DWORD dwErr;
    SECURITY_INFORMATION si;
    PSECURITY_DESCRIPTOR pSD = NULL;
    ULONG cSDSize;

#if DBG
    if (DfsDebug)
        DbgPrint("DfsGetObjSecurity(%ws)\n",  pwszObjectName);
#endif

    si = DACL_SECURITY_INFORMATION;

    dwErr = ReadDSObjSecDesc(
                pldap,
                pwszObjectName,
                si,
                &pSD,
                &cSDSize);

    if (dwErr == ERROR_SUCCESS) {
        if (!ConvertSecurityDescriptorToStringSecurityDescriptor(
                                                            pSD,
                                                            SDDL_REVISION_1,
                                                            DACL_SECURITY_INFORMATION,
                                                            pwszStringSD,
                                                            NULL)
        ) {
            dwErr = GetLastError();
#if DBG
            if (DfsDebug)
                DbgPrint("ConvertSecurityDescriptorToStringSecurityDescriptor FAILED %d:\n", dwErr);
#endif
        }

    }

#if DBG
    if (DfsDebug)
        DbgPrint("DfsGetObjSecurity returning %d\n", dwErr);
#endif

    return(dwErr);

}

//+---------------------------------------------------------------------------
//
//  Function:   DfsFindSid
//
//  Synopsis:   Gets the SID for a name
//
//              [DcName]  --  The DC to remote to
//              [Name]    --  The Name of the object
//              [Sid]     --  Pointer to pointer to returned SID, which must be freed
//                            using LocalFree
//
//  Returns:    TRUE or FALSE
//
//----------------------------------------------------------------------------
BOOL
DfsFindSid(
    LPWSTR DcName,
    LPWSTR Name,
    PSID *Sid
    )
{
    DWORD SidLength = 0;
    WCHAR DomainName[256];
    DWORD DomainNameLength = 256;
    SID_NAME_USE Use;
    BOOL Result;

#if DBG
    if (DfsDebug)
        DbgPrint("DfsFindSid(%ws,%ws)\n", DcName,Name);
#endif

    Result = LookupAccountName(
                 DcName,
                 Name,
                 (PSID)NULL,
                 &SidLength,
                 DomainName,
                 &DomainNameLength,
                 &Use);

    if ( !Result && (GetLastError() == ERROR_INSUFFICIENT_BUFFER) ) {

        *Sid = LocalAlloc( 0, SidLength );

        Result = LookupAccountName(
                     DcName,
                     Name,
                     *Sid,
                     &SidLength,
                     DomainName,
                     &DomainNameLength,
                     &Use);

    }

#if DBG
    if (DfsDebug)
        DbgPrint("DfsFindSid returning %s\n", Result == TRUE ? "TRUE" : "FALSE");
#endif

    return( Result );
}

//+---------------------------------------------------------------------------
//
//  Function:   DfsAddAce
//
//  Synopsis:   Adds a string ACE to a string version of an objects SD
//              object.  This is a string manipulation routine.
//
//  Arguments:  [pldap]         --  The open LDAP connection
//              [wszObjectName] --  The fully-qualified name of the DS object
//              [wszStringSD]   --  String version of SD
//              [wszStringSid]  --  String version of SID to add
//
//  Returns:    ERROR_SUCCESS   --  ACE was added
//
//----------------------------------------------------------------------------
DWORD
DfsAddAce(
    LDAP *pldap,
    LPWSTR wszObjectName,
    LPWSTR wszStringSD,
    LPWSTR wszStringSid)
{
    DWORD dwErr = ERROR_SUCCESS;
    LPWSTR wszNewStringSD = NULL;
    SECURITY_INFORMATION si;
    PSECURITY_DESCRIPTOR pSD = NULL;
    BOOL Result;
    ULONG Size = 0;
    ULONG cSDSize = 0;

#if DBG
    if (DfsDebug)
        DbgPrint("DfsAddAce(%ws)\n",  wszObjectName);
#endif

    Size = wcslen(wszStringSD) * sizeof(WCHAR) +
            wcslen(wszAce) * sizeof(WCHAR) +
                wcslen(wszStringSid) * sizeof(WCHAR) +
                    wcslen(L")") * sizeof(WCHAR) +
                        sizeof(WCHAR);

    wszNewStringSD = malloc(Size);

    if (wszNewStringSD != NULL) {
        wcscpy(wszNewStringSD,wszStringSD);
        wcscat(wszNewStringSD,wszAce);
        wcscat(wszNewStringSD,wszStringSid);
        wcscat(wszNewStringSD,L")");
#if DBG
        if (DfsDebug)
            DbgPrint("NewSD=[%ws]\n", wszNewStringSD);
#endif
        Result = ConvertStringSecurityDescriptorToSecurityDescriptor(
                                    wszNewStringSD,
                                    SDDL_REVISION_1,
                                    &pSD,
                                    &cSDSize);
        if (Result == TRUE) {
            si = DACL_SECURITY_INFORMATION;
            dwErr = DfsStampSD(
                        wszObjectName,
                        cSDSize,
                        si,
                        pSD,
                        pldap);
            LocalFree(pSD);
        } else {
            dwErr = GetLastError();
#if DBG
            if (DfsDebug)
                DbgPrint("Convert returned %d\n", dwErr);
#endif
        }
        free(wszNewStringSD);
    } else {
        dwErr = ERROR_OUTOFMEMORY;
    }

#if DBG
    if (DfsDebug)
        DbgPrint("DfsAddAce returning %d\n", dwErr);
#endif
    return(dwErr);

}

//+---------------------------------------------------------------------------
//
//  Function:   DfsRemoveAce
//
//  Synopsis:   Finds and removes a string ACE from the string SD of an
//              object.  This is a string manipulation routine.
//
//  Arguments:  [pldap]         --  The open LDAP connection
//              [wszObjectName] --  The fully-qualified name of the DS object
//              [wszStringSD]   --  String version of SD
//              [wszStringSid]  --  String version of SID to remove
//
//  Returns:    ERROR_SUCCESS  --  ACE was removed or was not present
//
//----------------------------------------------------------------------------
DWORD
DfsRemoveAce(
    LDAP *pldap,
    LPWSTR wszObjectName,
    LPWSTR wszStringSD,
    LPWSTR wszStringSid)
{
    DWORD dwErr = ERROR_SUCCESS;
    LPWSTR wszNewStringSD = NULL;
    SECURITY_INFORMATION si;
    PSECURITY_DESCRIPTOR pSD = NULL;
    BOOL Result;
    ULONG Size = 0;
    ULONG cSDSize = 0;
    BOOLEAN fCopying;
    ULONG s1, s2;

#if DBG
    if (DfsDebug)
        DbgPrint("DfsRemoveAce(%ws)\n",  wszObjectName);
#endif

    Size = wcslen(wszStringSD) * sizeof(WCHAR) + sizeof(WCHAR);

    wszNewStringSD = malloc(Size);

    if (wszNewStringSD != NULL) {

        RtlZeroMemory(wszNewStringSD, Size);

        //
        // We have to find the ACEs containing this SID, and remove them.
        //

        fCopying = TRUE;
        for (s1 = s2 = 0; wszStringSD[s1]; s1++) {

            //
            // If this is the start of an ACE that has this SID, stop copying
            //
            if (wszStringSD[s1] == L'(' && DfsSidInAce(&wszStringSD[s1],wszStringSid) == TRUE) {
                fCopying = FALSE;
                continue;
            }

            //
            // If this is the end of SID we are not copying, start copying again
            //
            if (wszStringSD[s1] == L')' && fCopying == FALSE) {
                fCopying = TRUE;
                continue;
            }

            //
            // If we are copying, do so.
            //
            if (fCopying == TRUE)
                wszNewStringSD[s2++] = wszStringSD[s1];
        }

#if DBG
        if (DfsDebug)
            DbgPrint("NewSD=[%ws]\n", wszNewStringSD);
#endif
        Result = ConvertStringSecurityDescriptorToSecurityDescriptor(
                                    wszNewStringSD,
                                    SDDL_REVISION_1,
                                    &pSD,
                                    &cSDSize);
        if (Result == TRUE) {
            si = DACL_SECURITY_INFORMATION;
            dwErr = DfsStampSD(
                        wszObjectName,
                        cSDSize,
                        si,
                        pSD,
                        pldap);
            LocalFree(pSD);
        } else {
            dwErr = GetLastError();
#if DBG
            if (DfsDebug)
                DbgPrint("Convert returned %d\n", dwErr);
#endif
        }
        free(wszNewStringSD);
    } else {
        dwErr = ERROR_OUTOFMEMORY;
    }

#if DBG
    if (DfsDebug)
        DbgPrint("DfsRemoveAce returning %d\n", dwErr);
#endif
    return(dwErr);

}

//+---------------------------------------------------------------------------
//
//  Function:   DfsSidInAce
//
//  Synopsis:   Scans an ACE to see if the string SID is in it.
//
//  Arguments:  [wszAce]         --  ACE to scan
//              [wszStringSid]   --  SID to scan for
//
//  Returns:    TRUE -- SID is in this ACE
//              FALSE -- SID is not in this ACE
//
//----------------------------------------------------------------------------
BOOLEAN
DfsSidInAce(
    LPWSTR wszAce,
    LPWSTR wszStringSid)
{
    ULONG i;
    ULONG SidLen = wcslen(wszStringSid);
    ULONG AceLen;
    WCHAR Oldcp;

    for (AceLen = 0; wszAce[AceLen] && wszAce[AceLen] != L')'; AceLen++)
        /* NOTHING */;

    Oldcp = wszAce[AceLen];
    wszAce[AceLen] = L'\0';
#if DBG
    if (DfsDebug)
        DbgPrint("DfsSidInAce(%ws),%ws)\n", wszAce, wszStringSid);
#endif
    wszAce[AceLen] = Oldcp;

    if (SidLen > AceLen || wszAce[0] != L'(') {
#if DBG
        if (DfsDebug)
            DbgPrint("DfsSidInAce returning FALSE(1)\n");
#endif
        return FALSE;
    }

    for (i = 0; i <= (AceLen - SidLen); i++) {

        if (wszAce[i] == wszStringSid[0] && wcsncmp(&wszAce[i],wszStringSid,SidLen) == 0) {
#if DBG
            if (DfsDebug)
                DbgPrint("DfsSidInAce returning TRUE\n");
#endif
            return TRUE;
        }

    }

#if DBG
    if (DfsDebug)
        DbgPrint("DfsSidInAce returning FALSE(2)\n");
#endif
    return FALSE;
}

//+---------------------------------------------------------------------------
//
//  Function:   DfsStampSD
//
//  Synopsis:   Actually stamps the security descriptor on the object.
//
//  Arguments:  [pwszObject]        --      The object to stamp the SD on
//              [cSDSize]           --      The size of the security descriptor
//              [SeInfo]            --      SecurityInformation about the security
//                                              descriptor
//              [pSD]               --      The SD to stamp
//              [pLDAP]             --      The LDAP connection to use
//
//  Returns:    ERROR_SUCCESS           --      Success
//
//----------------------------------------------------------------------------
DWORD
DfsStampSD(
    PWSTR pwszObject,
    ULONG cSDSize,
    SECURITY_INFORMATION SeInfo,
    PSECURITY_DESCRIPTOR pSD,
    PLDAP pLDAP)
{
    DWORD dwErr = ERROR_SUCCESS;
    PLDAPMod rgMods[2];
    PLDAP_BERVAL pBVals[2];
    LDAPMod Mod;
    LDAP_BERVAL BVal;
    BYTE ControlBuffer[ 5 ];

    LDAPControl     SeInfoControl =
                    {
                        LDAP_SERVER_SD_FLAGS_OID_W,
                        {
                            5, (PCHAR) &ControlBuffer
                        },
                        TRUE
                    };

    PLDAPControl    ServerControls[2] =
                    {
                        &SeInfoControl,
                        NULL
                    };

#if DBG
    if (DfsDebug)
        DbgPrint("DfsStampSD(%ws,%d)\n", pwszObject, cSDSize);
#endif

    ASSERT(*(PULONG)pSD > 0xF );

    ControlBuffer[0] = 0x30;
    ControlBuffer[1] = 0x3;
    ControlBuffer[2] = 0x02;    // Denotes an integer;
    ControlBuffer[3] = 0x01;    // Size
    ControlBuffer[4] = (BYTE)((ULONG)SeInfo & 0xF);

    ASSERT(IsValidSecurityDescriptor( pSD ) );

    rgMods[0] = &Mod;
    rgMods[1] = NULL;

    pBVals[0] = &BVal;
    pBVals[1] = NULL;

    BVal.bv_len = cSDSize;
    BVal.bv_val = (PCHAR)pSD;

    Mod.mod_op      = LDAP_MOD_REPLACE | LDAP_MOD_BVALUES;
    Mod.mod_type    = ACTRL_SD_PROP_NAME;
    Mod.mod_values  = (PWSTR *)pBVals;

    //
    // Now, we'll do the write...
    //
    dwErr = ldap_modify_ext_s(pLDAP,
                              pwszObject,
                              rgMods,
                              (PLDAPControl *)&ServerControls,
                              NULL);

    dwErr = LdapMapErrorToWin32(dwErr);

#if DBG
    if (DfsDebug)
        DbgPrint("DfsStampSD returning %d\n", dwErr);
#endif

    return(dwErr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\idl\imports.h ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    imports.h

Abstract:

    This file allows us to include standard system header files in the
    .idl file.  The main .idl file imports a file called import.idl.
    This allows the .idl file to use the types defined in these header
    files.  It also causes the following line to be added in the
    MIDL generated header file:

    #include "imports.h"

    Thus these types are available to the RPC stub routines as well.

Author:

    Dan Lafferty (danl)     07-May-1991

Revision History:


--*/


#include <windef.h>
#include <lmcons.h>

#ifdef MIDL_PASS
#ifdef UNICODE
#define LPTSTR [string] wchar_t*
#else
#define LPTSTR [string] LPTSTR
#endif
#define LPSTR [string] LPSTR
#define BOOL DWORD
#endif

#include <lmwksta.h>
#include <lmuse.h>
#include <lmstats.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\svcdlls\dfs\client\dfsstub.c ===
//-----------------------------------------------------------------------------
//
//  Copyright (C) 1995, Microsoft Corporation
//
//  File:       dfsstub.c
//
//  Contents:   Stub file for the NetDfsXXX APIs. The stubs turn around and
//              call the NetrDfsXXX APIs on the appropriate server, or (in the
//              case of NetDfs[G/S]etClientXXX, go directly to the driver on the
//              local machine.
//
//  Classes:
//
//  Functions:  NetDfsXXX
//
//  History:    01-10-96        Milans created
//
//-----------------------------------------------------------------------------

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <stdlib.h>
#include <lm.h>
#include <lmdfs.h>
#include <dfsp.h>
#include <netdfs.h>
#include <dfsfsctl.h>
#include <dsrole.h>
#include <ntdsapi.h>
#include <dsgetdc.h>

#include <winldap.h>

#include <aclapi.h>
#include <permit.h>

#include "dfsacl.h"


#define MAX_DFS_LDAP_RETRY 20


#define IS_UNC_PATH(wsz, cw)                                    \
    ((cw) > 2 && (wsz)[0] == L'\\' && (wsz)[1] == L'\\')

#define IS_VALID_PREFIX(wsz, cw)                                \
    ((cw) > 1 && (wsz)[0] == L'\\' && (wsz)[1] != L'\\')

#define IS_VALID_DFS_PATH(wsz, cw)                              \
    ((cw) > 0 && (wsz)[0] != L'\\')

#define IS_VALID_STRING(wsz)                                    \
    ((wsz) != NULL && (wsz)[0] != UNICODE_NULL)

#define POINTER_TO_OFFSET(field, buffer)  \
    ( ((PCHAR)field) -= ((ULONG_PTR)buffer) )

#define OFFSET_TO_POINTER(field, buffer)  \
        ( ((PCHAR)field) += ((ULONG_PTR)buffer) )

NET_API_STATUS
DfspGetDfsNameFromEntryPath(
    LPWSTR wszEntryPath,
    DWORD cwEntryPath,
    LPWSTR *ppwszDfsName);

NET_API_STATUS
DfspGetMachineNameFromEntryPath(
    LPWSTR wszEntryPath,
    DWORD cwEntryPath,
    LPWSTR *ppwszMachineName);

NET_API_STATUS
DfspBindRpc(
    IN  LPWSTR DfsName,
    OUT RPC_BINDING_HANDLE *BindingHandle);

NET_API_STATUS
DfspBindToServer(
    IN  LPWSTR DfsName,
    OUT RPC_BINDING_HANDLE *BindingHandle);

VOID
DfspFreeBinding(
    RPC_BINDING_HANDLE BindingHandle);

NET_API_STATUS
DfspVerifyBinding();

VOID
DfspFlushPkt(
    LPWSTR DfsEntryPath);

NTSTATUS
DfspIsThisADfsPath(
    LPWSTR pwszPathName);

DWORD
DfspDfsPathToRootMachine(
    LPWSTR pwszDfsName,
    LPWSTR *ppwszMachineName);

DWORD
DfspCreateFtDfs(
    LPWSTR ServerName,
    LPWSTR DcName,
    BOOLEAN IsPdc,
    LPWSTR RootShare,
    LPWSTR FtDfsName,
    LPWSTR Comment,
    DWORD  Flags);

DWORD
DfspTearDownFtDfs(
    IN LPWSTR wszServerName,
    IN LPWSTR wszDsAddress,
    IN LPWSTR wszRootShare,
    IN LPWSTR wszFtDfsName,
    IN DWORD  dwFlags);

VOID
DfspFlushFtTable(
    LPWSTR wszDcName,
    LPWSTR wszFtDfsName);


NTSTATUS
DfspSetDomainToDc(
    LPWSTR DomainName,
    LPWSTR DcName);

DWORD
I_NetDfsIsThisADomainName(
    LPWSTR wszDomain);

DWORD
DfspIsThisADomainName(
    LPWSTR wszName,
    PWCHAR *List);

VOID
DfspNotifyFtRoot(
    LPWSTR wszServerShare,
    LPWSTR wszDcName);

DWORD
NetpDfsAdd2(
    LPWSTR RootName,
    LPWSTR EntryPath,
    LPWSTR ServerName,
    LPWSTR ShareName,
    LPWSTR Comment,
    DWORD Flags);

DWORD
DfspAdd2(
    LPWSTR RootName,
    LPWSTR EntryPath,
    LPWSTR DcName,
    LPWSTR ServerName,
    LPWSTR ShareName,
    LPWSTR Comment,
    DWORD Flags);

DWORD
NetpDfsSetInfo2(
    LPWSTR RootName,
    LPWSTR EntryPath,
    LPWSTR ServerName,
    LPWSTR ShareName,
    DWORD  Level,
    LPDFS_INFO_STRUCT pDfsInfo);

DWORD
DfspSetInfo2(
    LPWSTR RootName,
    LPWSTR EntryPath,
    LPWSTR DcName,
    LPWSTR ServerName,
    LPWSTR ShareName,
    DWORD  Level,
    LPDFS_INFO_STRUCT pDfsInfo);

DWORD
NetpDfsRemove2(
    LPWSTR RootName,
    LPWSTR EntryPath,
    LPWSTR ServerName,
    LPWSTR ShareName);

DWORD
DfspRemove2(
    LPWSTR RootName,
    LPWSTR EntryPath,
    LPWSTR DcName,
    LPWSTR ServerName,
    LPWSTR ShareName);

DWORD
DfspLdapOpen(
    LPWSTR wszDcName,
    LDAP **ppldap,
    LPWSTR *pwszDfsConfigDN);



INT
_cdecl
DfspCompareDsDomainControllerInfo1(
    const void *p1,
    const void *p2);

BOOLEAN
DfspIsInvalidName(
    LPWSTR ShareName);

static LPWSTR InvalidNames[] = {
    L"SYSVOL",
    L"PIPE",
    L"IPC$",
    L"ADMIN$",
    L"MAILSLOT",
    L"NETLOGON",
    NULL};

//
// The APIs are all single-threaded - only 1 can be outstanding at a time in
// any one process. The following critical section is used to gate the calls.
// The critical section is initialized at DLL Load time.
//

CRITICAL_SECTION NetDfsApiCriticalSection;

#define ENTER_NETDFS_API EnterCriticalSection( &NetDfsApiCriticalSection );
#define LEAVE_NETDFS_API LeaveCriticalSection( &NetDfsApiCriticalSection );

//
// The name of the Dfs configuration container
//
static WCHAR DfsConfigContainer[] = L"CN=Dfs-Configuration,CN=System";

#if DBG
ULONG DfsDebug = 0;
#endif

VOID
NetDfsApiInitialize(void)
{
#if DBG
    DWORD dwErr;
    DWORD dwType;
    DWORD cbData;
    HKEY hkey;

    dwErr = RegOpenKey( HKEY_LOCAL_MACHINE, L"SYSTEM\\CurrentControlSet\\Services\\Dfs", &hkey );

    if (dwErr == ERROR_SUCCESS) {

        cbData = sizeof(DfsDebug);

        dwErr = RegQueryValueEx(
                    hkey,
                    L"NetApiDfsDebug",
                    NULL,
                    &dwType,
                    (PBYTE) &DfsDebug,
                    &cbData);

        if (!(dwErr == ERROR_SUCCESS && dwType == REG_DWORD)) {

            DfsDebug = 0;

        }

        RegCloseKey(hkey);

    }

#endif
}
    


//+----------------------------------------------------------------------------
//
//  Function:   NetDfsAdd
//
//  Synopsis:   Creates a new volume, adds a replica to an existing volume,
//              or creates a link to another Dfs.
//
//  Arguments:  [DfsEntryPath] -- Name of volume/link to create/add replica
//                      to.
//              [ServerName] -- Name of server hosting the storage, or for
//                      link, name of Dfs root.
//              [ShareName] -- Name of share hosting the storage.
//              [Flags] -- Describes what is being added.
//
//  Returns:    [NERR_Success] -- Successfully completed operation.
//
//              [ERROR_INVALID_PARAMETER] -- DfsEntryPath and/or ServerName
//                      and/or ShareName and/or Flags are incorrect.
//
//              [ERROR_INVALID_NAME] -- Unable to locate server or domain.
//
//              [ERROR_DCNotFound] -- Unable to locate DC for DfsName.
//
//              [ERROR_NOT_ENOUGH_MEMORY] -- Out of memory condition.
//
//              [NERR_DfsNoSuchVolume] -- DfsEntryPath does not correspond to a
//                      existing Dfs volume.
//
//              [NERR_DfsVolumeAlreadyExists] -- DFS_ADD_VOLUME was specified
//                      and a volume with DfsEntryPath already exists.
//
//              [NERR_DfsInternalCorruption] -- Corruption of Dfs data
//                      encountered at the server.
//
//-----------------------------------------------------------------------------

NET_API_STATUS
NetDfsAdd(
    IN LPWSTR DfsEntryPath,
    IN LPWSTR ServerName,
    IN LPWSTR ShareName,
    IN LPWSTR Comment,
    IN DWORD Flags)
{
    NET_API_STATUS dwErr;
    DWORD cwDfsEntryPath;
    LPWSTR pwszDfsName = NULL;

#if DBG
    if (DfsDebug)
        DbgPrint("NetDfsAdd(%ws,%ws,%ws,%ws,%d)\n",
                        DfsEntryPath,
                        ServerName,
                        ShareName,
                        Comment,
                        Flags);
#endif

    //
    // Validate the string arguments so RPC won't complain...
    //

    if (!IS_VALID_STRING(DfsEntryPath) ||
            !IS_VALID_STRING(ServerName) ||
                !IS_VALID_STRING(ShareName)) {
        return( ERROR_INVALID_PARAMETER );
    }

    cwDfsEntryPath = wcslen(DfsEntryPath);

    if (!IS_UNC_PATH(DfsEntryPath, cwDfsEntryPath) &&
            !IS_VALID_PREFIX(DfsEntryPath, cwDfsEntryPath) &&
                !IS_VALID_DFS_PATH(DfsEntryPath, cwDfsEntryPath)) {
        return( ERROR_INVALID_PARAMETER );
    }

    dwErr = DfspGetMachineNameFromEntryPath(
                DfsEntryPath,
                cwDfsEntryPath,
                &pwszDfsName);

    ENTER_NETDFS_API

    if (dwErr == NERR_Success) {

        //
        // By now, we should have a valid pwszDfsName. Lets try to bind to it,
        // and call the server.
        //

        dwErr = DfspBindRpc( pwszDfsName, &netdfs_bhandle );

        if (dwErr == NERR_Success) {

            RpcTryExcept {

                dwErr = NetrDfsAdd(
                            DfsEntryPath,
                            ServerName,
                            ShareName,
                            Comment,
                            Flags);

            } RpcExcept(1) {

                dwErr = RpcExceptionCode();

            } RpcEndExcept;

            DfspFreeBinding( netdfs_bhandle );

        }

    }

    LEAVE_NETDFS_API

    //
    // If we failed with ERROR_NOT_SUPPORTED, this is an NT5+ server,
    // so we use the NetrDfsAdd2() call instead.
    //

    if (dwErr == ERROR_NOT_SUPPORTED) {

        dwErr = NetpDfsAdd2(
                        pwszDfsName,
                        DfsEntryPath,
                        ServerName,
                        ShareName,
                        Comment,
                        Flags);
                    
    }

    if (pwszDfsName != NULL)
        free(pwszDfsName);

#if DBG
    if (DfsDebug)
        DbgPrint("NetDfsAdd returning %d\n", dwErr);
#endif

    return( dwErr );

}

DWORD
NetpDfsAdd2(
    LPWSTR RootName,
    LPWSTR DfsEntryPath,
    LPWSTR ServerName,
    LPWSTR ShareName,
    LPWSTR Comment,
    DWORD Flags)
{
    NET_API_STATUS dwErr;
    ULONG i;
    ULONG NameCount;
    PDSROLE_PRIMARY_DOMAIN_INFO_BASIC pPrimaryDomainInfo = NULL;
    PDOMAIN_CONTROLLER_INFO pDomainControllerInfo = NULL;

#if DBG
    if (DfsDebug)
        DbgPrint("NetpDfsAdd2(%ws,%ws,%ws,%ws,%ws,%d)\n",
                 RootName,
                 DfsEntryPath,
                 ServerName,
                 ShareName,
                 Comment,
                 Flags);
#endif

    //
    // Contact the server and ask for its domain name
    //

    dwErr = DsRoleGetPrimaryDomainInformation(
                RootName,
                DsRolePrimaryDomainInfoBasic,
                (PBYTE *)&pPrimaryDomainInfo);

    if (dwErr != ERROR_SUCCESS) {
#if DBG
        if (DfsDebug)
            DbgPrint("DsRoleGetPrimaryDomainInformation returned %d\n", dwErr);
#endif
        goto Cleanup;
    }

    if (pPrimaryDomainInfo->DomainNameDns == NULL) {
#if DBG
        if (DfsDebug)
            DbgPrint(" DomainNameDns is NULL\n", NULL);
#endif
        dwErr = ERROR_CANT_ACCESS_DOMAIN_INFO;
        goto Cleanup;
    }

    //
    // Get the PDC in that domain
    //

    dwErr = DsGetDcName(
                NULL,
                pPrimaryDomainInfo->DomainNameDns,
                NULL,
                NULL,
                DS_PDC_REQUIRED | DS_FORCE_REDISCOVERY,
                &pDomainControllerInfo);

   
    if (dwErr != ERROR_SUCCESS) {
#if DBG
        if (DfsDebug)
            DbgPrint(" NetpDfsAdd2:DsGetDcName(%ws) returned %d\n",
                        pPrimaryDomainInfo->DomainNameDns,
                        dwErr);
#endif
        goto Cleanup;
    }

    ENTER_NETDFS_API

    //
    // Call the server
    //

    dwErr = DfspAdd2(
                RootName,
                DfsEntryPath,
                &pDomainControllerInfo->DomainControllerName[2],
                ServerName,
                ShareName,
                Comment,
                Flags);

    LEAVE_NETDFS_API

Cleanup:

    if (pPrimaryDomainInfo != NULL)
        DsRoleFreeMemory(pPrimaryDomainInfo);

    if (pDomainControllerInfo != NULL)
        NetApiBufferFree(pDomainControllerInfo);

#if DBG
    if (DfsDebug)
        DbgPrint("NetpDfsAdd2 returning %d\n", dwErr);
#endif

    return( dwErr );

}

DWORD
DfspAdd2(
    LPWSTR RootName,
    LPWSTR EntryPath,
    LPWSTR DcName,
    LPWSTR ServerName,
    LPWSTR ShareName,
    LPWSTR Comment,
    DWORD Flags)
{
    DWORD dwErr;
    PDFSM_ROOT_LIST RootList = NULL;

#if DBG
    if (DfsDebug)
        DbgPrint("DfspAdd2(%ws,%ws,%ws,%ws,%ws,%ws,%d)\n",
            RootName,
            EntryPath,
            DcName,
            ServerName,
            ShareName,
            Comment,
            Flags);
#endif

    dwErr = DfspBindRpc( RootName, &netdfs_bhandle );

    if (dwErr == NERR_Success) {

        RpcTryExcept {

            dwErr = NetrDfsAdd2(
                        EntryPath,
                        DcName,
                        ServerName,
                        ShareName,
                        Comment,
                        Flags,
                        &RootList);

        } RpcExcept(1) {

            dwErr = RpcExceptionCode();

        } RpcEndExcept;

        DfspFreeBinding( netdfs_bhandle );

    }

#if DBG
    if (DfsDebug) {
        if (dwErr == ERROR_SUCCESS && RootList != NULL) {
            ULONG n;

            DbgPrint("cEntries=%d\n", RootList->cEntries);
            for (n = 0; n < RootList->cEntries; n++)
                DbgPrint("[%d]%ws\n", n, RootList->Entry[n].ServerShare);
        }
    }
#endif

    if (dwErr == ERROR_SUCCESS && RootList != NULL) {

        ULONG n;

        for (n = 0; n < RootList->cEntries; n++) {

            DfspNotifyFtRoot(
                RootList->Entry[n].ServerShare,
                DcName);

        }

        NetApiBufferFree(RootList);

    }
#if DBG
    if (DfsDebug)
        DbgPrint("DfspAdd2 returning %d\n", dwErr);
#endif

    return dwErr;

}


//+----------------------------------------------------------------------------
//
//  Function:   NetDfsAddFtRoot
//
//  Synopsis:   Creates a new FtDfs, adds a new server to an existing FtDfs.
//
//  Arguments:  [ServerName] -- Name of server to make a root, or to join to an existing FtDfs.
//              [RootShare] -- Name of share hosting the storage.
//              [FtDfsName] -- Name of FtDfs to join or create.
//              [Comment] -- Optional comment
//              [Flags] -- Flags to operation
//
//  Returns:    [NERR_Success] -- Successfully completed operation.
//
//              [ERROR_INVALID_PARAMETER] -- ServerName and/or RootShare are incorrect.
//
//              [ERROR_INVALID_NAME] -- Unable to locate server or domain.
//
//              [ERROR_DCNotFound] -- Unable to locate DC for DfsName.
//
//              [ERROR_NOT_ENOUGH_MEMORY] -- Out of memory condition.
//
//              [NERR_DfsInternalCorruption] -- Corruption of Dfs data
//                      encountered at the server.
//
//-----------------------------------------------------------------------------

NET_API_STATUS
NetDfsAddFtRoot(
    IN LPWSTR ServerName,
    IN LPWSTR RootShare,
    IN LPWSTR FtDfsName,
    IN LPWSTR Comment,
    IN DWORD  Flags)
{
    NET_API_STATUS dwErr;
    BOOLEAN IsRoot = FALSE;
    ULONG Timeout = 0;
    ULONG i;
    ULONG NameCount;
    LPWSTR DcName = NULL;
    PDSROLE_PRIMARY_DOMAIN_INFO_BASIC pPrimaryDomainInfo = NULL;
    PDOMAIN_CONTROLLER_INFO pDomainControllerInfo = NULL;
    PDFSM_ROOT_LIST RootList = NULL;
#if DBG
    if (DfsDebug)
        DbgPrint("NetDfsAddFtRoot(%ws,%ws,%ws,%ws,%d)\n",
            ServerName,
            RootShare,
            FtDfsName,
            Comment,
            Flags);
#endif

    //
    // Validate the string arguments so RPC won't complain...
    //

    if (!IS_VALID_STRING(ServerName) ||
        !IS_VALID_STRING(RootShare) ||
        !IS_VALID_STRING(FtDfsName)) {
        return( ERROR_INVALID_PARAMETER );
    }

    if (FtDfsName[0] == L' ' || DfspIsInvalidName(FtDfsName) == TRUE) {
        return( ERROR_INVALID_PARAMETER );
    }

    //
    // WE let the server add the root for us. If this fails,
    // with invalid parameter, we then get the dc name
    // and get the root list for NT5 DFS servers.
    //
    ENTER_NETDFS_API
    dwErr = DfspBindToServer( ServerName, &netdfs_bhandle );
    if (dwErr == NERR_Success) {

        RpcTryExcept {

            dwErr = NetrDfsAddFtRoot(
                        ServerName,
                        L"",
                        RootShare,
                        FtDfsName,
                        (Comment != NULL) ? Comment : L"",
                        L"",
                        0,
                        Flags,
                        &RootList );
#if DBG
            if (DfsDebug)
                DbgPrint("NetrDfsAddFtRoot returned %d\n", dwErr);
#endif

        } RpcExcept(1) {

            dwErr = RpcExceptionCode();

        } RpcEndExcept;

        DfspFreeBinding( netdfs_bhandle );
    }
    LEAVE_NETDFS_API

    if (dwErr != ERROR_INVALID_PARAMETER)
    {
        goto Cleanup;
    }
    //
    // Contact the server and ask for the DC to work with
    //

    dwErr = NetDfsGetDcAddress(
                ServerName,
                &DcName,
                &IsRoot,
                &Timeout);

    if (dwErr != ERROR_SUCCESS) {
#if DBG
        if (DfsDebug)
            DbgPrint("NetDfsGetDcAddress returned %d\n", dwErr);
#endif
        goto Cleanup;
    }

    if (IsRoot == TRUE) {
#if DBG
        if (DfsDebug)
            DbgPrint("Root already exists!\n");
#endif
        dwErr = ERROR_ALREADY_EXISTS;
        goto Cleanup;
    }

    //
    // Now get its domain name
    //

    dwErr = DsRoleGetPrimaryDomainInformation(
                ServerName,
                DsRolePrimaryDomainInfoBasic,
                (PBYTE *)&pPrimaryDomainInfo);

    if (dwErr != ERROR_SUCCESS) {
#if DBG
        if (DfsDebug)
            DbgPrint("DsRoleGetPrimaryDomainInformation returned %d\n", dwErr);
#endif
        goto Cleanup;
    }

    if (pPrimaryDomainInfo->DomainNameDns == NULL) {
#if DBG
        if (DfsDebug)
            DbgPrint(" DsRoleGetPrimaryDomainInformation returned NULL domain name\n");
#endif
        dwErr = ERROR_CANT_ACCESS_DOMAIN_INFO;
        goto Cleanup;
    }

    //
    // Get the PDC in that domain
    //

    dwErr = DsGetDcName(
                NULL,
                pPrimaryDomainInfo->DomainNameDns,
                NULL,
                NULL,
                DS_PDC_REQUIRED | DS_FORCE_REDISCOVERY,
                &pDomainControllerInfo);

   
    if (dwErr != ERROR_SUCCESS) {
#if DBG
        if (DfsDebug)
            DbgPrint("DsGetDcName(%ws) returned %d\n", pPrimaryDomainInfo->DomainNameDns, dwErr);
#endif
        goto Cleanup;
    }

    ENTER_NETDFS_API

    //
    // Add the Ds object and tell the server to join itself
    //

    dwErr = DfspCreateFtDfs(
                ServerName,
                &pDomainControllerInfo->DomainControllerName[2],
                TRUE,
                RootShare,
                FtDfsName,
                Comment,
                Flags);

    if (dwErr != ERROR_SUCCESS) {
#if DBG
        if (DfsDebug)
            DbgPrint(" DfspCreateFtDfs returned %d\n", dwErr);
#endif
        LEAVE_NETDFS_API
        goto Cleanup;
    }

    //
    // Tell the local MUP to crack ftdfs names using the selected DC
    //

    DfspSetDomainToDc(
        pPrimaryDomainInfo->DomainNameDns,
        &pDomainControllerInfo->DomainControllerName[2]);

    if (pPrimaryDomainInfo->DomainNameFlat != NULL) {
        PWCHAR wCp = &pDomainControllerInfo->DomainControllerName[2];

        for (; *wCp != L'\0' && *wCp != L'.'; wCp++)
            /* NOTHING */;
        *wCp =  (*wCp == L'.') ? L'\0' : *wCp;
        DfspSetDomainToDc(
            pPrimaryDomainInfo->DomainNameFlat,
            &pDomainControllerInfo->DomainControllerName[2]);
    }

    LEAVE_NETDFS_API

Cleanup:

    if (pPrimaryDomainInfo != NULL)
        DsRoleFreeMemory(pPrimaryDomainInfo);

    if (pDomainControllerInfo != NULL)
        NetApiBufferFree(pDomainControllerInfo);

    if (DcName != NULL)
        NetApiBufferFree(DcName);

#if DBG
    if (DfsDebug)
        DbgPrint("NetDfsAddFtRoot returning %d\n", dwErr);
#endif

    return( dwErr );

}

//+----------------------------------------------------------------------------
//
//  Function:   DfspCompareDsDomainControllerInfo1
//
//  Synopsis:   Helper/compare func for qsort of DsGetDomainControllerInfo's results
//
//-----------------------------------------------------------------------------

INT
_cdecl
DfspCompareDsDomainControllerInfo1(
    const void *p1,
    const void *p2)
{
    PDS_DOMAIN_CONTROLLER_INFO_1 pInfo1 = (PDS_DOMAIN_CONTROLLER_INFO_1)p1;
    PDS_DOMAIN_CONTROLLER_INFO_1 pInfo2 = (PDS_DOMAIN_CONTROLLER_INFO_1)p2;
    UNICODE_STRING s1;
    UNICODE_STRING s2;

    if (pInfo1->DnsHostName == NULL || pInfo2->DnsHostName == NULL)
        return 0;

    RtlInitUnicodeString(&s1, pInfo1->DnsHostName);
    RtlInitUnicodeString(&s2, pInfo2->DnsHostName);

    return RtlCompareUnicodeString(&s1,&s2,TRUE);

}

//+----------------------------------------------------------------------------
//
//  Function:   NetDfsAddStdRoot
//
//  Synopsis:   Creates a new Std Dfs.
//
//  Arguments:  [ServerName] -- Name of server to make a root.
//                      existing Dfs.
//              [RootShare] -- Name of share hosting the storage.
//              [Comment] -- Optional comment
//              [Flags] -- Flags
//
//  Returns:    [NERR_Success] -- Successfully completed operation.
//
//              [ERROR_INVALID_PARAMETER] -- ServerName and/or RootShare are incorrect.
//
//              [ERROR_INVALID_NAME] -- Unable to locate server or domain.
//
//              [ERROR_NOT_ENOUGH_MEMORY] -- Out of memory condition.
//
//              [NERR_DfsInternalCorruption] -- Corruption of Dfs data
//                      encountered at the server.
//
//-----------------------------------------------------------------------------

NET_API_STATUS
NetDfsAddStdRoot(
    IN LPWSTR ServerName,
    IN LPWSTR RootShare,
    IN LPWSTR Comment,
    IN DWORD  Flags)
{
    NET_API_STATUS dwErr;

#if DBG
    if (DfsDebug)
        DbgPrint("NetDfsAddStdRoot(%ws,%ws,%ws,%d)\n",
                    ServerName,
                    RootShare,
                    Comment,
                    Flags);
#endif

    //
    // Validate the string arguments so RPC won't complain...
    //

    if (!IS_VALID_STRING(ServerName) ||
            !IS_VALID_STRING(RootShare)) {
        return( ERROR_INVALID_PARAMETER );
    }

    ENTER_NETDFS_API

    //
    // We should have a valid ServerName. Lets try to bind to it,
    // and call the server.
    //

    dwErr = DfspBindToServer( ServerName, &netdfs_bhandle );

    if (dwErr == NERR_Success) {

        RpcTryExcept {

            dwErr = NetrDfsAddStdRoot(
                        ServerName,
                        RootShare,
                        (Comment != NULL) ? Comment : L"",
                        Flags);

        } RpcExcept(1) {

            dwErr = RpcExceptionCode();

        } RpcEndExcept;

        DfspFreeBinding( netdfs_bhandle );

    }

    LEAVE_NETDFS_API

#if DBG
    if (DfsDebug)
        DbgPrint("NetDfsAddStdRoot returning %d\n", dwErr);
#endif

    return( dwErr );

}

//+----------------------------------------------------------------------------
//
//  Function:   NetDfsAddStdRootForced
//
//  Synopsis:   Creates a new Std Dfs, also specifying the share
//
//  Arguments:  [ServerName] -- Name of server to make a root.
//                      existing Dfs.
//              [RootShare] -- Name of share hosting the storage.
//              [Comment] -- Optional comment
//              [Share] -- Name of drive:\dir hosting the share
//
//  Returns:    [NERR_Success] -- Successfully completed operation.
//
//              [ERROR_INVALID_PARAMETER] -- ServerName and/or RootShare are incorrect.
//
//              [ERROR_INVALID_NAME] -- Unable to locate server or domain.
//
//              [ERROR_NOT_ENOUGH_MEMORY] -- Out of memory condition.
//
//              [NERR_DfsInternalCorruption] -- Corruption of Dfs data
//                      encountered at the server.
//
//-----------------------------------------------------------------------------

NET_API_STATUS
NetDfsAddStdRootForced(
    IN LPWSTR ServerName,
    IN LPWSTR RootShare,
    IN LPWSTR Comment,
    IN LPWSTR Share)
{
    NET_API_STATUS dwErr;

#if DBG
    if (DfsDebug)
        DbgPrint("NetDfsAddStdRootForced(%ws,%ws,%ws,%ws)\n",
            ServerName,
            RootShare,
            Comment,
            Share);
#endif

    //
    // Validate the string arguments so RPC won't complain...
    //

    if (!IS_VALID_STRING(ServerName) ||
            !IS_VALID_STRING(RootShare) ||
                !IS_VALID_STRING(Share)) {
        return( ERROR_INVALID_PARAMETER );
    }

    ENTER_NETDFS_API

    //
    // We should have a valid ServerName. Lets try to bind to it,
    // and call the server.
    //

    dwErr = DfspBindToServer( ServerName, &netdfs_bhandle );

    if (dwErr == NERR_Success) {

        RpcTryExcept {

            dwErr = NetrDfsAddStdRootForced(
                        ServerName,
                        RootShare,
                        (Comment != NULL) ? Comment : L"",
                        Share);

        } RpcExcept(1) {

            dwErr = RpcExceptionCode();

        } RpcEndExcept;

        DfspFreeBinding( netdfs_bhandle );

    }

    LEAVE_NETDFS_API

#if DBG
    if (DfsDebug)
        DbgPrint("NetDfsAddStdRootForced returning %d\n", dwErr);
#endif

    return( dwErr );

}


//+----------------------------------------------------------------------------
//
//  Function:   NetDfsGetDcAddress
//
//  Synopsis:   Asks a server for its DC to use to place the dfs blob to make
//              the server a root.
//
//  Arguments:  [ServerName] -- Name of server we will be making an FtDfs root
//              [DcName] -- DC Name
//              [IsRoot] -- TRUE if Server is a root, FALSE otherwise
//              [Timeout] -- Timeout the server is using
//
//  Returns:    [NERR_Success] -- Successfully completed operation.
//
//              [ERROR_INVALID_PARAMETER] -- ServerName incorrect.
//
//              [ERROR_INVALID_NAME] -- Unable to locate server or domain.
//
//              [ERROR_NOT_ENOUGH_MEMORY] -- Out of memory condition.
//
//              [NERR_DfsInternalCorruption] -- Corruption of Dfs data
//                      encountered at the server.
//
//-----------------------------------------------------------------------------

NET_API_STATUS
NetDfsGetDcAddress(
    IN LPWSTR ServerName,
    IN OUT LPWSTR *DcName,
    IN OUT BOOLEAN *IsRoot,
    IN OUT ULONG *Timeout)
{
    NET_API_STATUS dwErr;

#if DBG
    if (DfsDebug)
        DbgPrint("NetDfsGetDcAddress(%ws)\n", ServerName);
#endif

    //
    // Validate the string arguments so RPC won't complain...
    //

    if (!IS_VALID_STRING(ServerName)|| DcName == NULL || IsRoot == NULL || Timeout == NULL) {
        return( ERROR_INVALID_PARAMETER );
    }

    ENTER_NETDFS_API

    //
    // We should have a valid ServerName. Lets try to bind to it,
    // and call the server.
    //

    dwErr = DfspBindToServer( ServerName, &netdfs_bhandle );

    if (dwErr == NERR_Success) {

        RpcTryExcept {

            dwErr = NetrDfsGetDcAddress(
                        ServerName,
                        DcName,
                        IsRoot,
                        Timeout);

        } RpcExcept(1) {

            dwErr = RpcExceptionCode();

        } RpcEndExcept;

        DfspFreeBinding( netdfs_bhandle );

    }

    LEAVE_NETDFS_API

#if DBG
    if (DfsDebug)
        DbgPrint("NetDfsGetDcAddress: returned %d\n", dwErr);
#endif

    return( dwErr );

}


//+----------------------------------------------------------------------------
//
//  Function:   NetDfsRemove
//
//  Synopsis:   Deletes a Dfs volume, removes a replica from an existing
//              volume, or removes a link to another Dfs.
//
//  Arguments:  [DfsEntryPath] -- Name of volume/link to remove.
//              [ServerName] -- Name of server hosting the storage. Must be
//                      NULL if removing Link.
//              [ShareName] -- Name of share hosting the storage. Must be
//                      NULL if removing Link.
//
//  Returns:    [NERR_Success] -- Successfully completed operation.
//
//              [ERROR_INVALID_PARAMETER] -- DfsEntryPath is incorrect.
//
//              [ERROR_INVALID_NAME] -- Unable to locate server or domain.
//
//              [ERROR_DCNotFound] -- Unable to locate DC for DfsName.
//
//              [ERROR_NOT_ENOUGH_MEMORY] -- Out of memory condition.
//
//              [NERR_DfsNoSuchVolume] -- DfsEntryPath does not correspond to
//                      a valid entry path.
//
//              [NERR_DfsNotALeafVolume] -- Unable to delete the volume
//                      because it is not a leaf volume.
//
//              [NERR_DfsInternalCorruption] -- Corruption of Dfs data
//                      encountered at the server.
//
//-----------------------------------------------------------------------------

NET_API_STATUS
NetDfsRemove(
    IN LPWSTR DfsEntryPath,
    IN LPWSTR ServerName,
    IN LPWSTR ShareName)
{
    NET_API_STATUS dwErr;
    DWORD cwDfsEntryPath;
    LPWSTR pwszDfsName = NULL;

#if DBG
    if (DfsDebug)
        DbgPrint("NetDfsRemove(%ws,%ws,%ws)\n",
                DfsEntryPath,
                ServerName,
                ShareName);
#endif

    //
    // Validate the string arguments so RPC won't complain...
    //

    if (!IS_VALID_STRING(DfsEntryPath)) {
        return( ERROR_INVALID_PARAMETER );
    }

    cwDfsEntryPath = wcslen(DfsEntryPath);

    if (!IS_UNC_PATH(DfsEntryPath, cwDfsEntryPath) &&
            !IS_VALID_PREFIX(DfsEntryPath, cwDfsEntryPath) &&
                !IS_VALID_DFS_PATH(DfsEntryPath, cwDfsEntryPath)) {
        return( ERROR_INVALID_PARAMETER );
    }

    dwErr = DfspGetMachineNameFromEntryPath(
                DfsEntryPath,
                cwDfsEntryPath,
                &pwszDfsName);

    ENTER_NETDFS_API

    if (dwErr == NERR_Success) {

        dwErr = DfspBindRpc(pwszDfsName, &netdfs_bhandle);

        if (dwErr == NERR_Success) {

            RpcTryExcept {

                dwErr = NetrDfsRemove(
                            DfsEntryPath,
                            ServerName,
                            ShareName);

            } RpcExcept(1) {

                dwErr = RpcExceptionCode();

            } RpcEndExcept;

            DfspFreeBinding( netdfs_bhandle );

        }

    }

    LEAVE_NETDFS_API

    //
    // If we failed with ERROR_NOT_SUPPORTED, this is an NT5+ server,
    // so we use the NetrDfsRemove2() call instead.
    //

    if (dwErr == ERROR_NOT_SUPPORTED) {

        dwErr = NetpDfsRemove2(
                        pwszDfsName,
                        DfsEntryPath,
                        ServerName,
                        ShareName);
                    
    }

    //
    // If we removed things from a dfs, the local pkt
    // may now be out of date.  [92216]
    // Flush the local pkt
    //
    if (dwErr == NERR_Success) {

        DfspFlushPkt(DfsEntryPath);

    }

    if (pwszDfsName != NULL)
        free( pwszDfsName );

#if DBG
    if (DfsDebug)
        DbgPrint("NetDfsRemove returning %d\n", dwErr);
#endif

    return( dwErr );

}

DWORD
NetpDfsRemove2(
    LPWSTR RootName,
    LPWSTR DfsEntryPath,
    LPWSTR ServerName,
    LPWSTR ShareName)
{
    NET_API_STATUS dwErr;
    ULONG i;
    ULONG NameCount;
    PDSROLE_PRIMARY_DOMAIN_INFO_BASIC pPrimaryDomainInfo = NULL;
    PDS_DOMAIN_CONTROLLER_INFO_1 pDsDomainControllerInfo1 = NULL;
    PDOMAIN_CONTROLLER_INFO pDomainControllerInfo = NULL;
    HANDLE hDs = NULL;

#if DBG
    if (DfsDebug)
        DbgPrint("NetpDfsRemove2(%ws,%ws,%ws,%ws)\n",
                    RootName,
                    DfsEntryPath,
                    ServerName,
                    ShareName);
#endif

    //
    // Ask for its domain name
    //
    dwErr = DsRoleGetPrimaryDomainInformation(
                RootName,
                DsRolePrimaryDomainInfoBasic,
                (PBYTE *)&pPrimaryDomainInfo);

    if (dwErr != ERROR_SUCCESS) {
#if DBG
        if (DfsDebug)
            DbgPrint(" DsRoleGetPrimaryDomainInformation returned %d\n", dwErr);
#endif
        goto Cleanup;
    }

    if (pPrimaryDomainInfo->DomainNameDns == NULL) {
#if DBG
        if (DfsDebug)
            DbgPrint(" DomainNameDns is NULL\n");
#endif
        dwErr = ERROR_CANT_ACCESS_DOMAIN_INFO;
        goto Cleanup;
    }

    //
    // Get the PDC in that domain
    //

    dwErr = DsGetDcName(
                NULL,
                pPrimaryDomainInfo->DomainNameDns,
                NULL,
                NULL,
                DS_PDC_REQUIRED | DS_FORCE_REDISCOVERY,
                &pDomainControllerInfo);

    if (dwErr != ERROR_SUCCESS) {
#if DBG
        if (DfsDebug)
            DbgPrint(" DsGetDcName(%ws) returned %d\n", pPrimaryDomainInfo->DomainNameDns);
#endif
        goto Cleanup;
    }

    ENTER_NETDFS_API

    //
    // Tell the root server to remove this server/share
    //

    dwErr = DfspRemove2(
                RootName,
                DfsEntryPath,
                &pDomainControllerInfo->DomainControllerName[2],
                ServerName,
                ShareName);

    LEAVE_NETDFS_API

    if (dwErr != ERROR_SUCCESS) {
#if DBG
        if (DfsDebug)
            DbgPrint(" DfspRemove2 returned %d\n");
#endif
        goto Cleanup;
    }

Cleanup:



    if (pDomainControllerInfo != NULL)
        NetApiBufferFree(pDomainControllerInfo);

    if (pPrimaryDomainInfo != NULL)
        DsRoleFreeMemory(pPrimaryDomainInfo);

#if DBG
    if (DfsDebug)
        DbgPrint("NetpDfsRemove2 returning %d\n", dwErr);
#endif

    return( dwErr );

}

DWORD
DfspRemove2(
    LPWSTR RootName,
    LPWSTR EntryPath,
    LPWSTR DcName,
    LPWSTR ServerName,
    LPWSTR ShareName)
{
    DWORD dwErr;
    PDFSM_ROOT_LIST RootList = NULL;

#if DBG
    if (DfsDebug)
        DbgPrint("DfspRemove2(%ws,%ws,%ws,%ws,%ws)\n",
                RootName,
                EntryPath,
                DcName,
                ServerName,
                ShareName);
#endif

    dwErr = DfspBindRpc( RootName, &netdfs_bhandle );

    if (dwErr == NERR_Success) {

        RpcTryExcept {

            dwErr = NetrDfsRemove2(
                        EntryPath,
                        DcName,
                        ServerName,
                        ShareName,
                        &RootList);

        } RpcExcept(1) {

            dwErr = RpcExceptionCode();

        } RpcEndExcept;

        DfspFreeBinding( netdfs_bhandle );

    }

#if DBG
    if (DfsDebug) {
        if (dwErr == ERROR_SUCCESS && RootList != NULL) {
            ULONG n;

            DbgPrint("cEntries=%d\n", RootList->cEntries);
            for (n = 0; n < RootList->cEntries; n++)
                DbgPrint("[%d]%ws\n", n, RootList->Entry[n].ServerShare);
        }
    }
#endif

    if (dwErr == ERROR_SUCCESS && RootList != NULL) {

        ULONG n;

        for (n = 0; n < RootList->cEntries; n++) {

            DfspNotifyFtRoot(
                RootList->Entry[n].ServerShare,
                DcName);

        }

        NetApiBufferFree(RootList);

    }

#if DBG
    if (DfsDebug)
        DbgPrint("DfspRemove2 returning %d\n", dwErr);
#endif

    return dwErr;

}


//+----------------------------------------------------------------------------
//
//  Function:   NetDfsRemoveFtRoot
//
//  Synopsis:   Deletes an FtDfs root, or unjoins a Server from an FtDfs as a root.
//
//  Arguments:  [ServerName] -- Name of server to unjoin from FtDfs.
//              [RootShare] -- Name of share hosting the storage.
//              [FtDfsName] -- Name of FtDfs to remove server from.
//              [Flags] -- Flags to operation
//
//  Returns:    [NERR_Success] -- Successfully completed operation.
//
//              [ERROR_INVALID_PARAMETER] -- ServerName and/or FtDfsName is incorrect.
//
//              [ERROR_INVALID_NAME] -- Unable to locate server or domain.
//
//              [ERROR_DCNotFound] -- Unable to locate DC for ServerName
//
//              [ERROR_NOT_ENOUGH_MEMORY] -- Out of memory condition.
//
//              [NERR_DfsNoSuchVolume] -- FtDfsName does not correspond to
//                      a valid FtDfs.
//
//              [NERR_DfsNotALeafVolume] -- Unable to delete the volume
//                      because it is not a leaf volume.
//
//              [NERR_DfsInternalCorruption] -- Corruption of Dfs data
//                      encountered at the server.
//
//-----------------------------------------------------------------------------

NET_API_STATUS
NetDfsRemoveFtRoot(
    IN LPWSTR ServerName,
    IN LPWSTR RootShare,
    IN LPWSTR FtDfsName,
    IN DWORD  Flags)
{
    NET_API_STATUS dwErr;
    LPWSTR DcName = NULL;
    BOOLEAN IsRoot = FALSE;
    ULONG Timeout = 0;
    ULONG i;
    ULONG NameCount;
    PDSROLE_PRIMARY_DOMAIN_INFO_BASIC pPrimaryDomainInfo = NULL;
    PDOMAIN_CONTROLLER_INFO pDomainControllerInfo = NULL;
    PDFSM_ROOT_LIST RootList = NULL;

#if DBG
    if (DfsDebug)
        DbgPrint("NetDfsRemoveFtRoot(%ws,%ws,%ws,%d)\n",
            ServerName,
            RootShare,
            FtDfsName,
            Flags);
#endif

    //
    // Validate the string arguments so RPC won't complain...
    //

    if (!IS_VALID_STRING(ServerName) ||
        !IS_VALID_STRING(RootShare) ||
        !IS_VALID_STRING(FtDfsName)) {
        return( ERROR_INVALID_PARAMETER );
    }

    //
    // we first allow the server to do all the work, so pass in null
    // as dc name and root list. If that fails with error_invalid_param
    // we know we are dealing with a NT5 server, so go into compat mode.
    //
    ENTER_NETDFS_API
    dwErr = DfspBindToServer( ServerName, &netdfs_bhandle );
    if (dwErr == NERR_Success) {

        RpcTryExcept {

            dwErr = NetrDfsRemoveFtRoot(
                        ServerName,
                        L"",
                        RootShare,
                        FtDfsName,
                        Flags,
                        &RootList );

#if DBG
            if (DfsDebug)
                DbgPrint("NetrDfsAddFtRoot returned %d\n", dwErr);
#endif

        } RpcExcept(1) {

            dwErr = RpcExceptionCode();

        } RpcEndExcept;

        DfspFreeBinding( netdfs_bhandle );
    }
    LEAVE_NETDFS_API

    if (dwErr != ERROR_INVALID_PARAMETER)
    {
        goto Cleanup;
    }
    //
    // Contact the server and ask for the DC to work with
    //
#if 0
    dwErr = NetDfsGetDcAddress(
                ServerName,
                &DcName,
                &IsRoot,
                &Timeout);

    if (dwErr != ERROR_SUCCESS) {
        return dwErr;
    }

    if (IsRoot == FALSE) {
        dwErr = ERROR_SERVICE_DOES_NOT_EXIST;
        goto Cleanup;
    }
#endif
    //
    // Now ask it for its dns and domain names
    //

    dwErr = DsRoleGetPrimaryDomainInformation(
                ServerName,
                DsRolePrimaryDomainInfoBasic,
                (PBYTE *)&pPrimaryDomainInfo);

    if (dwErr != ERROR_SUCCESS) {
#if DBG
        if (DfsDebug)
            DbgPrint("DsRoleGetPrimaryDomainInformation returned %d\n", dwErr);
#endif
        goto Cleanup;
    }

    if (pPrimaryDomainInfo->DomainNameDns == NULL) {
#if DBG
        if (DfsDebug)
            DbgPrint("DsRoleGetPrimaryDomainInformation returned NULL domain name\n");
#endif
        dwErr = ERROR_CANT_ACCESS_DOMAIN_INFO;
        goto Cleanup;
    }

    //
    // Get the PDC in that domain
    //

    dwErr = DsGetDcName(
                NULL,
                pPrimaryDomainInfo->DomainNameDns,
                NULL,
                NULL,
                DS_PDC_REQUIRED | DS_FORCE_REDISCOVERY,
                &pDomainControllerInfo);

   
    if (dwErr != ERROR_SUCCESS) {
#if DBG
        if (DfsDebug)
            DbgPrint(" DsGetDcName(%ws) returned %d\n", pPrimaryDomainInfo->DomainNameDns, dwErr);
#endif
        goto Cleanup;
    }

    ENTER_NETDFS_API

    //
    // Tell the server to unjoin and update the Ds object
    //

    dwErr = DfspTearDownFtDfs(
                ServerName,
                &pDomainControllerInfo->DomainControllerName[2],
                RootShare,
                FtDfsName,
                Flags);

    if (dwErr != ERROR_SUCCESS) {
#if DBG
        if (DfsDebug)
            DbgPrint(" DfspTearDownFtDfs returned %d\n", dwErr);
#endif
        LEAVE_NETDFS_API
        goto Cleanup;
    }

    //
    // Tell the local MUP to crack ftdfs names using the selected DC
    //

    DfspSetDomainToDc(
        pPrimaryDomainInfo->DomainNameDns,
        &pDomainControllerInfo->DomainControllerName[2]);

    if (pPrimaryDomainInfo->DomainNameFlat != NULL) {
        PWCHAR wCp = &pDomainControllerInfo->DomainControllerName[2];

        for (; *wCp != L'\0' && *wCp != L'.'; wCp++)
            /* NOTHING */;
        *wCp =  (*wCp == L'.') ? L'\0' : *wCp;
        DfspSetDomainToDc(
            pPrimaryDomainInfo->DomainNameFlat,
            &pDomainControllerInfo->DomainControllerName[2]);
    }

    LEAVE_NETDFS_API

Cleanup:

    if (pDomainControllerInfo != NULL)
        NetApiBufferFree(pDomainControllerInfo);

    if (DcName != NULL)
        NetApiBufferFree(DcName);

#if DBG
    if (DfsDebug)
        DbgPrint("NetDfsRemoveFtRoot returning %d\n", dwErr);
#endif

    return( dwErr );

}

//+----------------------------------------------------------------------------
//
//  Function:   NetDfsRemoveFtRootForced
//
//  Synopsis:   Deletes an FtDfs root, or unjoins a Server from an FtDfs as a root.
//              Does not contact the root/server to do so - it simply updates the DS.
//
//  Arguments:  [DomainName] -- Name of domain the server is in.
//              [ServerName] -- Name of server to unjoin from FtDfs.
//              [RootShare] -- Name of share hosting the storage.
//              [FtDfsName] -- Name of FtDfs to remove server from.
//              [Flags] -- Flags to operation
//
//  Returns:    [NERR_Success] -- Successfully completed operation.
//
//              [ERROR_INVALID_PARAMETER] -- ServerName and/or FtDfsName is incorrect.
//
//              [ERROR_INVALID_NAME] -- Unable to locate server or domain.
//
//              [ERROR_DCNotFound] -- Unable to locate DC for ServerName
//
//              [ERROR_NOT_ENOUGH_MEMORY] -- Out of memory condition.
//
//              [NERR_DfsNoSuchVolume] -- FtDfsName does not correspond to
//                      a valid FtDfs.
//
//              [NERR_DfsNotALeafVolume] -- Unable to delete the volume
//                      because it is not a leaf volume.
//
//              [NERR_DfsInternalCorruption] -- Corruption of Dfs data
//                      encountered at the server.
//
//-----------------------------------------------------------------------------

NET_API_STATUS
NetDfsRemoveFtRootForced(
    IN LPWSTR DomainName,
    IN LPWSTR ServerName,
    IN LPWSTR RootShare,
    IN LPWSTR FtDfsName,
    IN DWORD  Flags)
{
    NET_API_STATUS dwErr;
    LPWSTR DcName = NULL;
    BOOLEAN IsRoot = FALSE;
    ULONG Timeout = 0;
    ULONG i;
    ULONG NameCount;
    PDSROLE_PRIMARY_DOMAIN_INFO_BASIC pPrimaryDomainInfo = NULL;
    PDOMAIN_CONTROLLER_INFO pDomainControllerInfo = NULL;

#if DBG
    if (DfsDebug)
        DbgPrint("NetDfsRemoveFtrootForced(%ws,%ws,%ws,%ws,%d)\n",
                    DomainName,
                    ServerName,
                    RootShare,
                    FtDfsName,
                    Flags);
#endif

    //
    // Validate the string arguments so RPC won't complain...
    //

    if (!IS_VALID_STRING(DomainName) ||
        !IS_VALID_STRING(ServerName) ||
        !IS_VALID_STRING(RootShare) ||
        !IS_VALID_STRING(FtDfsName)) {
        return( ERROR_INVALID_PARAMETER );
    }

    //
    // Get the PDC in the domain
    //

    dwErr = DsGetDcName(
                NULL,
                DomainName,
                NULL,
                NULL,
                DS_PDC_REQUIRED | DS_FORCE_REDISCOVERY,
                &pDomainControllerInfo);

   
    if (dwErr != ERROR_SUCCESS) {
#if DBG
        if (DfsDebug)
            DbgPrint(" DsGetDcName(%ws) returned %d\n", DomainName, dwErr);
#endif
        goto Cleanup;
    }

    //
    // Get the Dns name of the domain the DC is in
    //
    dwErr = DsRoleGetPrimaryDomainInformation(
                &pDomainControllerInfo->DomainControllerName[2],
                DsRolePrimaryDomainInfoBasic,
                (PBYTE *)&pPrimaryDomainInfo);

    if (dwErr != ERROR_SUCCESS) {
#if DBG
        if (DfsDebug)
            DbgPrint(" DsRoleGetPrimaryDomainInformation(%ws) returned %d\n",
                        &pDomainControllerInfo->DomainControllerName[2],
                        dwErr);
#endif
        goto Cleanup;
    }

    if (pPrimaryDomainInfo->DomainNameDns == NULL) {
#if DBG
        if (DfsDebug)
            DbgPrint(" DomainNameDns is NULL\n");
#endif
        dwErr = ERROR_CANT_ACCESS_DOMAIN_INFO;
        goto Cleanup;
    }

    ENTER_NETDFS_API

    //
    // Tell the DC to remove the server from the DS objects
    //

    dwErr = DfspTearDownFtDfs(
                ServerName,
                &pDomainControllerInfo->DomainControllerName[2],
                RootShare,
                FtDfsName,
                Flags | DFS_FORCE_REMOVE);

    if (dwErr != ERROR_SUCCESS) {
#if DBG
        if (DfsDebug)
            DbgPrint(" DfspTearDownFtDfs returned %d\n", dwErr);
#endif
        LEAVE_NETDFS_API
        goto Cleanup;
    }

    //
    // Tell the local MUP to crack ftdfs names using the selected DC
    //

    DfspSetDomainToDc(
        pPrimaryDomainInfo->DomainNameDns,
        &pDomainControllerInfo->DomainControllerName[2]);

    if (pPrimaryDomainInfo->DomainNameFlat != NULL) {
        PWCHAR wCp = &pDomainControllerInfo->DomainControllerName[2];

        for (; *wCp != L'\0' && *wCp != L'.'; wCp++)
            /* NOTHING */;
        *wCp =  (*wCp == L'.') ? L'\0' : *wCp;
        DfspSetDomainToDc(
            pPrimaryDomainInfo->DomainNameFlat,
            &pDomainControllerInfo->DomainControllerName[2]);
    }

    LEAVE_NETDFS_API

Cleanup:

    if (pDomainControllerInfo != NULL)
        NetApiBufferFree(pDomainControllerInfo);

    if (pPrimaryDomainInfo != NULL)
        DsRoleFreeMemory(pPrimaryDomainInfo);

    if (DcName != NULL)
        NetApiBufferFree(DcName);

#if DBG
    if (DfsDebug)
        DbgPrint("NetDfsRemoveFtRootForced returning %d\n", dwErr);
#endif

    return( dwErr );

}

//+----------------------------------------------------------------------------
//
//  Function:   NetDfsRemoveStdRoot
//
//  Synopsis:   Deletes a Dfs root.
//
//  Arguments:  [ServerName] -- Name of server to unjoin from Dfs.
//              [RootShare] -- Name of share hosting the storage.
//              [Flags] -- Flags to operation
//
//  Returns:    [NERR_Success] -- Successfully completed operation.
//
//              [ERROR_INVALID_PARAMETER] -- ServerName and/or RootShare is incorrect.
//
//              [ERROR_INVALID_NAME] -- Unable to locate server or domain.
//
//              [ERROR_NOT_ENOUGH_MEMORY] -- Out of memory condition.
//
//              [NERR_DfsNotALeafVolume] -- Unable to delete the volume
//                      because it is not a leaf volume.
//
//              [NERR_DfsInternalCorruption] -- Corruption of Dfs data
//                      encountered at the server.
//
//-----------------------------------------------------------------------------

NET_API_STATUS
NetDfsRemoveStdRoot(
    IN LPWSTR ServerName,
    IN LPWSTR RootShare,
    IN DWORD  Flags)
{
    NET_API_STATUS dwErr;

#if DBG
    if (DfsDebug)
        DbgPrint("NetDfsRemoveStdRoot(%ws,%ws,%d)\n",
                ServerName,
                RootShare,
                Flags);
#endif

    //
    // Validate the string arguments so RPC won't complain...
    //

    if (!IS_VALID_STRING(ServerName) ||
            !IS_VALID_STRING(RootShare)) {
        return( ERROR_INVALID_PARAMETER );
    }

    ENTER_NETDFS_API

    dwErr = DfspBindToServer(ServerName, &netdfs_bhandle);

    if (dwErr == NERR_Success) {

        RpcTryExcept {

            dwErr = NetrDfsRemoveStdRoot(
                        ServerName,
                        RootShare,
                        Flags);

        } RpcExcept(1) {

            dwErr = RpcExceptionCode();

        } RpcEndExcept;

        DfspFreeBinding( netdfs_bhandle );

    }

    LEAVE_NETDFS_API

#if DBG
    if (DfsDebug)
        DbgPrint("NetDfsRemoveStdRoot returning %d\n", dwErr);
#endif

    return( dwErr );

}


//+----------------------------------------------------------------------------
//
//  Function:   NetDfsSetInfo
//
//  Synopsis:   Sets the comment or state of a Dfs volume or Replica.
//
//  Arguments:  [DfsEntryPath] -- Path to the volume. Implicityly indicates
//                      which server or domain to connect to.
//              [ServerName] -- Optional. If specified, only the state of
//                      the server supporting this volume is modified.
//              [ShareName] -- Optional. If specified, only the state of
//                      this share on the specified server is modified.
//              [Level] -- Must be 100 or 101
//              [Buffer] -- Pointer to DFS_INFO_100 or DFS_INFO_101
//
//  Returns:    [NERR_Success] -- If successfully set info.
//
//              [ERROR_INVALID_LEVEL] -- Level is not 100 or 101, 102
//
//              [ERROR_INVALID_PARAMETER] -- Either DfsEntryPath is NULL,
//                      or ShareName is specified but ServerName is not, or
//                      Buffer is NULL.
//
//              [ERROR_INVALID_NAME] -- Unable to locate server or domain.
//
//              [ERROR_DCNotFound] -- Unable to locate DC for domain.
//
//              [ERROR_NOT_ENOUGH_MEMORY] -- Out of memory condition.
//
//              [NERR_DfsNoSuchVolume] -- No volume matches DfsEntryPath.
//
//              [NERR_DfsNoSuchShare] -- The indicated ServerName/ShareName do
//                      not support this Dfs volume.
//
//              [NERR_DfsInternalCorruption] -- Corruption of Dfs data
//                      encountered at the server.
//
//-----------------------------------------------------------------------------

NET_API_STATUS NET_API_FUNCTION
NetDfsSetInfo(
    IN  LPWSTR  DfsEntryPath,
    IN  LPWSTR  ServerName OPTIONAL,
    IN  LPWSTR  ShareName OPTIONAL,
    IN  DWORD   Level,
    IN  LPBYTE  Buffer)
{
    NET_API_STATUS dwErr;
    LPWSTR pwszDfsName = NULL;
    DWORD cwDfsEntryPath;
    DFS_INFO_STRUCT DfsInfo;


#if DBG
    if (DfsDebug)
        DbgPrint("NetDfsSetInfo(%ws,%ws,%ws,%d)\n",
                DfsEntryPath,
                ServerName,
                ShareName,
                Level);
#endif

    if (!IS_VALID_STRING(DfsEntryPath)) {
        return( ERROR_INVALID_PARAMETER );
    }

    //
    // Some elementary parameter checking to make sure we can proceed
    // reasonably...
    //

    if (!(Level >= 100 && Level <= 102)) {
        return( ERROR_INVALID_LEVEL );
    }

    cwDfsEntryPath = wcslen(DfsEntryPath);

    if (!IS_UNC_PATH(DfsEntryPath, cwDfsEntryPath) &&
            !IS_VALID_PREFIX(DfsEntryPath, cwDfsEntryPath) &&
                !IS_VALID_DFS_PATH(DfsEntryPath, cwDfsEntryPath)) {
        return( ERROR_INVALID_PARAMETER );
    }

    if (!IS_VALID_STRING(ServerName) && IS_VALID_STRING(ShareName)) {
        return( ERROR_INVALID_PARAMETER );
    }

    dwErr = DfspGetMachineNameFromEntryPath(
                DfsEntryPath,
                cwDfsEntryPath,
                &pwszDfsName);

    ENTER_NETDFS_API

    if (dwErr == NERR_Success) {

        //
        // By now, we should have a valid pwszDfsName. Lets try to bind to it,
        // and call the server.
        //

        dwErr = DfspBindRpc( pwszDfsName, &netdfs_bhandle );

        if (dwErr == NERR_Success) {

            RpcTryExcept {

                DfsInfo.DfsInfo100 = (LPDFS_INFO_100) Buffer;

                dwErr = NetrDfsSetInfo(
                            DfsEntryPath,
                            ServerName,
                            ShareName,
                            Level,
                            &DfsInfo);

           } RpcExcept( 1 ) {

               dwErr = RpcExceptionCode();

           } RpcEndExcept;

           DfspFreeBinding( netdfs_bhandle );

        }

    }

    LEAVE_NETDFS_API

    //
    // If we failed with ERROR_NOT_SUPPORTED, this is an NT5+ server,
    // so we use the NetrDfsSetInfo2() call instead.
    //

    if (dwErr == ERROR_NOT_SUPPORTED) {

        dwErr = NetpDfsSetInfo2(
                        pwszDfsName,
                        DfsEntryPath,
                        ServerName,
                        ShareName,
                        Level,
                        &DfsInfo);
                    
    }

    if (pwszDfsName != NULL)
        free(pwszDfsName);

#if DBG
    if (DfsDebug)
        DbgPrint("NetDfsSetInfo returning %d\n", dwErr);
#endif

    return( dwErr );

}

DWORD
NetpDfsSetInfo2(
    LPWSTR RootName,
    LPWSTR DfsEntryPath,
    LPWSTR ServerName,
    LPWSTR ShareName,
    DWORD Level,
    LPDFS_INFO_STRUCT pDfsInfo)
{
    NET_API_STATUS dwErr;
    ULONG i;
    ULONG NameCount;
    PDSROLE_PRIMARY_DOMAIN_INFO_BASIC pPrimaryDomainInfo = NULL;
    PDOMAIN_CONTROLLER_INFO pDomainControllerInfo = NULL;

#if DBG
    if (DfsDebug)
        DbgPrint("NetpDfsSetInfo2(%ws,%ws,%ws,%ws,%d)\n",
                 RootName,
                 DfsEntryPath,
                 ServerName,
                 ShareName,
                 Level);
#endif

    //
    // Contact the server and ask for its domain name
    //

    dwErr = DsRoleGetPrimaryDomainInformation(
                RootName,
                DsRolePrimaryDomainInfoBasic,
                (PBYTE *)&pPrimaryDomainInfo);

    if (dwErr != ERROR_SUCCESS) {
#if DBG
        if (DfsDebug)
            DbgPrint("DsRoleGetPrimaryDomainInformation returned %d\n", dwErr);
#endif
        goto Cleanup;
    }

    if (pPrimaryDomainInfo->DomainNameDns == NULL) {
#if DBG
        if (DfsDebug)
            DbgPrint(" DomainNameDns is NULL\n", NULL);
#endif
        dwErr = ERROR_CANT_ACCESS_DOMAIN_INFO;
        goto Cleanup;
    }

    //
    // Get the PDC in that domain
    //

    dwErr = DsGetDcName(
                NULL,
                pPrimaryDomainInfo->DomainNameDns,
                NULL,
                NULL,
                DS_PDC_REQUIRED | DS_FORCE_REDISCOVERY,
                &pDomainControllerInfo);

   
    if (dwErr != ERROR_SUCCESS) {
#if DBG
        if (DfsDebug)
            DbgPrint(" NetpDfsSetInfo2:DsGetDcName(%ws) returned %d\n",
                        pPrimaryDomainInfo->DomainNameDns,
                        dwErr);
#endif
        goto Cleanup;
    }

    ENTER_NETDFS_API

    //
    // Call the server
    //

    dwErr = DfspSetInfo2(
                RootName,
                DfsEntryPath,
                &pDomainControllerInfo->DomainControllerName[2],
                ServerName,
                ShareName,
                Level,
                pDfsInfo);

    LEAVE_NETDFS_API

Cleanup:

    if (pPrimaryDomainInfo != NULL)
        DsRoleFreeMemory(pPrimaryDomainInfo);

    if (pDomainControllerInfo != NULL)
        NetApiBufferFree(pDomainControllerInfo);

#if DBG
    if (DfsDebug)
        DbgPrint("NetpDfsSetInfo2 returning %d\n", dwErr);
#endif

    return( dwErr );

}

DWORD
DfspSetInfo2(
    LPWSTR RootName,
    LPWSTR EntryPath,
    LPWSTR DcName,
    LPWSTR ServerName,
    LPWSTR ShareName,
    DWORD  Level,
    LPDFS_INFO_STRUCT pDfsInfo)
{
    DWORD dwErr;
    PDFSM_ROOT_LIST RootList = NULL;

#if DBG
    if (DfsDebug)
        DbgPrint("DfspSetInfo2(%ws,%ws,%ws,%ws,%ws,%d)\n",
            RootName,
            EntryPath,
            DcName,
            ServerName,
            ShareName,
            Level);
#endif

    dwErr = DfspBindRpc( RootName, &netdfs_bhandle );

    if (dwErr == NERR_Success) {

        RpcTryExcept {

            dwErr = NetrDfsSetInfo2(
                        EntryPath,
                        DcName,
                        ServerName,
                        ShareName,
                        Level,
                        pDfsInfo,
                        &RootList);

        } RpcExcept(1) {

            dwErr = RpcExceptionCode();

        } RpcEndExcept;

        DfspFreeBinding( netdfs_bhandle );

    }

#if DBG
    if (DfsDebug) {
        if (dwErr == ERROR_SUCCESS && RootList != NULL) {
            ULONG n;

            DbgPrint("cEntries=%d\n", RootList->cEntries);
            for (n = 0; n < RootList->cEntries; n++)
                DbgPrint("[%d]%ws\n", n, RootList->Entry[n].ServerShare);
        }
    }
#endif

    if (dwErr == ERROR_SUCCESS && RootList != NULL) {

        ULONG n;

        for (n = 0; n < RootList->cEntries; n++) {

            DfspNotifyFtRoot(
                RootList->Entry[n].ServerShare,
                DcName);

        }

        NetApiBufferFree(RootList);

    }
#if DBG
    if (DfsDebug)
        DbgPrint("DfspSetInfo2 returning %d\n", dwErr);
#endif

    return dwErr;

}


//+----------------------------------------------------------------------------
//
//  Function:   NetDfsGetInfo
//
//  Synopsis:   Retrieves information about a particular Dfs volume.
//
//  Arguments:  [DfsEntryPath] -- Path to the volume. Implicitly indicates
//                      which server or domain to connect to.
//              [ServerName] -- Optional. If specified, indicates the
//                      server supporting DfsEntryPath.
//              [ShareName] -- Optional. If specified, indicates the share
//                      on ServerName for which info is desired.
//              [Level] -- Indicates the level of info required.
//              [Buffer] -- On successful return, will contain the buffer
//                      containing the required Info. This buffer should be
//                      freed using NetApiBufferFree.
//
//  Returns:    [NERR_Success] -- Info successfully returned.
//
//              [ERROR_INVALID_LEVEL] -- Level is not 1,2,3 or 100
//
//              [ERROR_INVALID_PARAMETER] -- Either DfsEntryPath is NULL,
//                      or ShareName is specified but ServerName is NULL.
//
//              [ERROR_INVALID_NAME] -- Unable to locate server or domain.
//
//              [ERROR_DCNotFound] -- Unable to locate DC for domain.
//
//              [ERROR_NOT_ENOUGH_MEMORY] -- Out of memory condition.
//
//              [NERR_DfsNoSuchVolume] -- No volume matches DfsEntryPath.
//
//              [NERR_DfsInternalCorruption] -- Corruption of Dfs data
//                      encountered at the server.
//
//-----------------------------------------------------------------------------

NET_API_STATUS NET_API_FUNCTION
NetDfsGetInfo(
    IN  LPWSTR  DfsEntryPath,
    IN  LPWSTR  ServerName OPTIONAL,
    IN  LPWSTR  ShareName OPTIONAL,
    IN  DWORD   Level,
    OUT LPBYTE* Buffer)
{
    NET_API_STATUS dwErr;
    LPWSTR pwszDfsName;
    DWORD cwDfsEntryPath;
    DFS_INFO_STRUCT DfsInfo;

#if DBG
    if (DfsDebug)
        DbgPrint("NetDfsGetInfo(%ws,%ws,%ws,%d)\n",
            DfsEntryPath,
            ServerName,
            ShareName,
            Level);
#endif

    if (!IS_VALID_STRING(DfsEntryPath)) {
        return( ERROR_INVALID_PARAMETER );
    }

    //
    // Some elementary parameter checking to make sure we can proceed
    // reasonably...
    //

    if (!(Level >= 1 && Level <= 4) && Level != 100) {
        return( ERROR_INVALID_LEVEL );
    }

    cwDfsEntryPath = wcslen(DfsEntryPath);

    if (!IS_UNC_PATH(DfsEntryPath, cwDfsEntryPath) &&
            !IS_VALID_PREFIX(DfsEntryPath, cwDfsEntryPath) &&
                !IS_VALID_DFS_PATH(DfsEntryPath, cwDfsEntryPath)) {
        return( ERROR_INVALID_PARAMETER );
    }

    if (!IS_VALID_STRING(ServerName) && IS_VALID_STRING(ShareName)) {
        return( ERROR_INVALID_PARAMETER );
    }

    dwErr = DfspGetMachineNameFromEntryPath(
                DfsEntryPath,
                cwDfsEntryPath,
                &pwszDfsName);

    ENTER_NETDFS_API

    if (dwErr == NERR_Success) {

        //
        // By now, we should have a valid pwszDfsName. Lets try to bind to it,
        // and call the server.
        //

        dwErr = DfspBindRpc( pwszDfsName, &netdfs_bhandle );

        if (dwErr == NERR_Success) {

            RpcTryExcept {

                DfsInfo.DfsInfo1 = NULL;

                dwErr = NetrDfsGetInfo(
                            DfsEntryPath,
                            ServerName,
                            ShareName,
                            Level,
                            &DfsInfo);

                if (dwErr == NERR_Success) {

                    *Buffer = (LPBYTE) DfsInfo.DfsInfo1;

                }

           } RpcExcept( 1 ) {

               dwErr = RpcExceptionCode();

           } RpcEndExcept;

           DfspFreeBinding( netdfs_bhandle );

        }

        free( pwszDfsName );

    }

    LEAVE_NETDFS_API

#if DBG
    if (DfsDebug)
        DbgPrint("NetDfsGetInfo returning %d\n", dwErr);
#endif

    return( dwErr );

}


//+----------------------------------------------------------------------------
//
//  Function:   NetDfsGetClientInfo
//
//  Synopsis:   Retrieves information about a particular Dfs volume, from the
//              local PKT.
//
//  Arguments:  [DfsEntryPath] -- Path to the volume.
//              [ServerName] -- Optional. If specified, indicates the
//                      server supporting DfsEntryPath.
//              [ShareName] -- Optional. If specified, indicates the share
//                      on ServerName for which info is desired.
//              [Level] -- Indicates the level of info required.
//              [Buffer] -- On successful return, will contain the buffer
//                      containing the required Info. This buffer should be
//                      freed using NetApiBufferFree.
//
//  Returns:    [NERR_Success] -- Info successfully returned.
//
//              [ERROR_INVALID_LEVEL] -- Level is not 1,2,3 or 4.
//
//              [ERROR_INVALID_PARAMETER] -- Either DfsEntryPath is NULL,
//                      or ShareName is specified but ServerName is NULL.
//
//              [ERROR_NOT_ENOUGH_MEMORY] -- Out of memory condition.
//
//              [NERR_DfsNoSuchVolume] -- No volume matches DfsEntryPath.
//
//              [NERR_DfsInternalError] -- Too many fsctrl attempts
//
//-----------------------------------------------------------------------------

NET_API_STATUS NET_API_FUNCTION
NetDfsGetClientInfo(
    IN  LPWSTR  DfsEntryPath,
    IN  LPWSTR  ServerName OPTIONAL,
    IN  LPWSTR  ShareName OPTIONAL,
    IN  DWORD   Level,
    OUT LPBYTE*  Buffer)
{
    NET_API_STATUS dwErr;
    NTSTATUS NtStatus;
    LPWSTR pwszDfsName;
    DWORD cwDfsEntryPath;
    PDFS_GET_PKT_ENTRY_STATE_ARG OutBuffer;
    HANDLE DriverHandle = NULL;
    IO_STATUS_BLOCK IoStatusBlock;
    OBJECT_ATTRIBUTES objectAttributes;
    UNICODE_STRING DfsDriverName;
    ULONG cbOutBuffer;
    ULONG cbInBuffer;
    PCHAR InBuffer;
    ULONG cRetries;

#if DBG
    if (DfsDebug)
        DbgPrint("NetDfsGetClientInfo(%ws,%ws,%ws,%d)\n",
                DfsEntryPath,
                ServerName,
                ShareName,
                Level);
#endif

    if (!IS_VALID_STRING(DfsEntryPath)) {
        return( ERROR_INVALID_PARAMETER );
    }

    //
    // Some elementary parameter checking to make sure we can proceed
    // reasonably...
    //

    if (!(Level >= 1 && Level <= 4)) {
        return( ERROR_INVALID_LEVEL );
    }

    cwDfsEntryPath = wcslen(DfsEntryPath);

    if (!IS_UNC_PATH(DfsEntryPath, cwDfsEntryPath) &&
            !IS_VALID_PREFIX(DfsEntryPath, cwDfsEntryPath) &&
                !IS_VALID_DFS_PATH(DfsEntryPath, cwDfsEntryPath)) {
        return( ERROR_INVALID_PARAMETER );
    }

    if (!IS_VALID_STRING(ServerName) && IS_VALID_STRING(ShareName)) {
        return( ERROR_INVALID_PARAMETER );
    }

    //
    // Calculate the size of the marshall buffer

    cbOutBuffer = sizeof(DFS_GET_PKT_ENTRY_STATE_ARG) +
                    wcslen(DfsEntryPath) * sizeof(WCHAR);

    if (ServerName) {

        cbOutBuffer += wcslen(ServerName) * sizeof(WCHAR);

    }

    if (ShareName) {

        cbOutBuffer += wcslen(ShareName) * sizeof(WCHAR);

    }


    OutBuffer = malloc(cbOutBuffer);

    if (OutBuffer == NULL) {

        return (ERROR_NOT_ENOUGH_MEMORY);

    }

    ZeroMemory(OutBuffer, cbOutBuffer);

    //
    // marshall the args
    //

    OutBuffer->DfsEntryPathLen = wcslen(DfsEntryPath) * sizeof(WCHAR);
    wcscpy(OutBuffer->Buffer, DfsEntryPath);

    if (ServerName) {

        OutBuffer->ServerNameLen = wcslen(ServerName) * sizeof(WCHAR);
        wcscat(OutBuffer->Buffer, ServerName);

    }

    if (ShareName) {

        OutBuffer->ShareNameLen = wcslen(ShareName) * sizeof(WCHAR);
        wcscat(OutBuffer->Buffer, ShareName);

    }

    //
    // Construct name for opening driver
    //

    RtlInitUnicodeString(&DfsDriverName, DFS_DRIVER_NAME);

    InitializeObjectAttributes(
        &objectAttributes,
        &DfsDriverName,
        OBJ_CASE_INSENSITIVE,
        NULL,
        NULL
    );

    //
    // Open the driver
    //
    NtStatus = NtCreateFile(
                    &DriverHandle,
                    SYNCHRONIZE,
                    &objectAttributes,
                    &IoStatusBlock,
                    NULL,
                    FILE_ATTRIBUTE_NORMAL,
                    FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
                    FILE_OPEN_IF,
                    FILE_CREATE_TREE_CONNECTION | FILE_SYNCHRONOUS_IO_NONALERT,
                    NULL,
                    0
                );

    if (NT_SUCCESS(NtStatus)) {

        //
        // Now fsctl the request down
        //
        OutBuffer->Level = Level;
        cbInBuffer = 0x400;
        NtStatus = STATUS_BUFFER_OVERFLOW;

        for (cRetries = 0;
                NtStatus == STATUS_BUFFER_OVERFLOW && cRetries < 4;
                    cRetries++) {

            dwErr = NetApiBufferAllocate(cbInBuffer, &InBuffer);

            if (dwErr != ERROR_SUCCESS) {

                free(OutBuffer);

                NtClose(DriverHandle);

                return(ERROR_NOT_ENOUGH_MEMORY);

            }

            NtStatus = NtFsControlFile(
                           DriverHandle,
                           NULL,       // Event,
                           NULL,       // ApcRoutine,
                           NULL,       // ApcContext,
                           &IoStatusBlock,
                           FSCTL_DFS_GET_PKT_ENTRY_STATE,
                           OutBuffer,
                           cbOutBuffer,
                           InBuffer,
                           cbInBuffer
                       );

            if (NtStatus == STATUS_BUFFER_OVERFLOW) {

                cbInBuffer = *((PULONG)InBuffer);

                NetApiBufferFree(InBuffer);

            }

        }

        NtClose(DriverHandle);

        //
        // Too many attempts?
        //
        if (cRetries >= 4) {

            NtStatus = STATUS_INTERNAL_ERROR;

        }

    }

    if (NT_SUCCESS(NtStatus)) {

        PDFS_INFO_3 pDfsInfo3;
        PDFS_INFO_4 pDfsInfo4;
        ULONG j;

        pDfsInfo4 = (PDFS_INFO_4)InBuffer;
        pDfsInfo3 = (PDFS_INFO_3)InBuffer;

        try {

            //
            // EntryPath is common to all DFS_INFO_X's and is in the
            // same location.
            //
            OFFSET_TO_POINTER(pDfsInfo4->EntryPath, InBuffer);

            switch (Level) {

            case 4:
                OFFSET_TO_POINTER(pDfsInfo4->Storage, InBuffer);
                for (j = 0; j < pDfsInfo4->NumberOfStorages; j++) {
                    OFFSET_TO_POINTER(pDfsInfo4->Storage[j].ServerName, InBuffer);
                    OFFSET_TO_POINTER(pDfsInfo4->Storage[j].ShareName, InBuffer);
                }
                break;

            case 3:
                OFFSET_TO_POINTER(pDfsInfo3->Storage, InBuffer);
                for (j = 0; j < pDfsInfo3->NumberOfStorages; j++) {
                    OFFSET_TO_POINTER(pDfsInfo3->Storage[j].ServerName, InBuffer);
                    OFFSET_TO_POINTER(pDfsInfo3->Storage[j].ShareName, InBuffer);
                }

            }

            *Buffer = (PBYTE)InBuffer;
            dwErr = NERR_Success;

        } except (EXCEPTION_EXECUTE_HANDLER) {

            NtStatus = GetExceptionCode();

        }

    }

    switch (NtStatus) {

    case STATUS_SUCCESS:
        dwErr = NERR_Success;
        break;

    case STATUS_OBJECT_NAME_NOT_FOUND:
        dwErr = NERR_DfsNoSuchVolume;
        NetApiBufferFree(InBuffer);
        break;

    case STATUS_INTERNAL_ERROR:
        dwErr = NERR_DfsInternalError;
        NetApiBufferFree(InBuffer);
        break;

    default:
        dwErr = ERROR_INVALID_PARAMETER;
        NetApiBufferFree(InBuffer);
        break;

    }

    free(OutBuffer);

#if DBG
    if (DfsDebug)
        DbgPrint("NetDfsGetClientInfo returning %d\n", dwErr);
#endif

    return( dwErr );
}


//+----------------------------------------------------------------------------
//
//  Function:   NetDfsSetClientInfo
//
//  Synopsis:   Associates information with the local PKT.
//
//
//  Arguments:  [DfsEntryPath] -- Path to the volume.
//              [ServerName] -- Optional. If specified, indicates the
//                      server supporting DfsEntryPath.
//              [ShareName] -- Optional. If specified, indicates the share
//                      on ServerName for which info is desired.
//              [Level] -- Indicates the level of info required.
//              [Buffer] -- Pointer to buffer containing information to set.
//
//  Returns:    [NERR_Success] -- Info successfully returned.
//
//              [ERROR_INVALID_PARAMETER] -- Either DfsEntryPath is NULL,
//                      or ShareName is specified but ServerName is NULL.
//
//              [ERROR_NOT_ENOUGH_MEMORY] -- Out of memory condition.
//
//              [NERR_DfsNoSuchVolume] -- No volume matches DfsEntryPath.
//
//-----------------------------------------------------------------------------

NET_API_STATUS NET_API_FUNCTION
NetDfsSetClientInfo(
    IN  LPWSTR  DfsEntryPath,
    IN  LPWSTR  ServerName OPTIONAL,
    IN  LPWSTR  ShareName OPTIONAL,
    IN  DWORD   Level,
    IN  LPBYTE  Buffer)
{
    NET_API_STATUS dwErr;
    NTSTATUS NtStatus;
    LPWSTR pwszDfsName;
    DWORD cwDfsEntryPath;
    PDFS_SET_PKT_ENTRY_STATE_ARG OutBuffer;
    PDFS_INFO_101 pDfsInfo101;
    PDFS_INFO_102 pDfsInfo102;
    HANDLE DriverHandle = NULL;
    IO_STATUS_BLOCK IoStatusBlock;
    OBJECT_ATTRIBUTES objectAttributes;
    UNICODE_STRING DfsDriverName;
    ULONG cbOutBuffer;

#if DBG
    if (DfsDebug)
        DbgPrint("NetDfsSetClientInfo(%ws,%ws,%ws,%d)\n",
                DfsEntryPath,
                ServerName,
                ShareName,
                Level);
#endif

    if (!IS_VALID_STRING(DfsEntryPath)) {
        return( ERROR_INVALID_PARAMETER );
    }

    //
    // Some elementary parameter checking to make sure we can proceed
    // reasonably...
    //

    if (!(Level >= 101 && Level <= 102)) {
        return( ERROR_INVALID_LEVEL );
    }
    cwDfsEntryPath = wcslen(DfsEntryPath);

    if (!IS_UNC_PATH(DfsEntryPath, cwDfsEntryPath) &&
            !IS_VALID_PREFIX(DfsEntryPath, cwDfsEntryPath) &&
                !IS_VALID_DFS_PATH(DfsEntryPath, cwDfsEntryPath)) {
        return( ERROR_INVALID_PARAMETER );
    }

    if (!IS_VALID_STRING(ServerName) && IS_VALID_STRING(ShareName)) {
        return( ERROR_INVALID_PARAMETER );
    }

    if (Buffer == NULL) {
        return( ERROR_INVALID_PARAMETER );
    }

    //
    // Calculate the size of the marshall buffer
    //
    cbOutBuffer = sizeof(DFS_SET_PKT_ENTRY_STATE_ARG) +
                    wcslen(DfsEntryPath) * sizeof(WCHAR);

    if (ServerName) {

        cbOutBuffer += wcslen(ServerName) * sizeof(WCHAR);

    }

    if (ShareName) {

        cbOutBuffer += wcslen(ShareName) * sizeof(WCHAR);

    }

    OutBuffer = malloc(cbOutBuffer);

    if (OutBuffer == NULL) {

        return (ERROR_NOT_ENOUGH_MEMORY);

    }

    ZeroMemory(OutBuffer, cbOutBuffer);

    //
    // marshall the args
    //
    OutBuffer = (PDFS_SET_PKT_ENTRY_STATE_ARG) OutBuffer;
    OutBuffer->DfsEntryPathLen = wcslen(DfsEntryPath) * sizeof(WCHAR);
    wcscpy(OutBuffer->Buffer, DfsEntryPath);
    OutBuffer->Level = Level;

    if (ServerName) {

        OutBuffer->ServerNameLen = wcslen(ServerName) * sizeof(WCHAR);
        wcscat(OutBuffer->Buffer, ServerName);

    }

    if (ShareName) {

        OutBuffer->ShareNameLen = wcslen(ShareName) * sizeof(WCHAR);
        wcscat(OutBuffer->Buffer, ShareName);

    }

    switch (Level) {

    case 101:
        OutBuffer->State = ((PDFS_INFO_101)Buffer)->State;
        break;
    case 102:
        OutBuffer->Timeout = (DWORD)((PDFS_INFO_102)Buffer)->Timeout;
        break;

    }

    //
    // Communicate with the driver
    //

    RtlInitUnicodeString(&DfsDriverName, DFS_DRIVER_NAME);

    InitializeObjectAttributes(
        &objectAttributes,
        &DfsDriverName,
        OBJ_CASE_INSENSITIVE,
        NULL,
        NULL
    );

    NtStatus = NtCreateFile(
                    &DriverHandle,
                    SYNCHRONIZE | FILE_WRITE_DATA,
                    &objectAttributes,
                    &IoStatusBlock,
                    NULL,
                    FILE_ATTRIBUTE_NORMAL,
                    FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
                    FILE_OPEN_IF,
                    FILE_CREATE_TREE_CONNECTION | FILE_SYNCHRONOUS_IO_NONALERT,
                    NULL,
                    0
                );

    if (NT_SUCCESS(NtStatus)) {

        NtStatus = NtFsControlFile(
                       DriverHandle,
                       NULL,       // Event,
                       NULL,       // ApcRoutine,
                       NULL,       // ApcContext,
                       &IoStatusBlock,
                       FSCTL_DFS_SET_PKT_ENTRY_STATE,
                       OutBuffer,
                       cbOutBuffer,
                       NULL,
                       0
                   );

        NtClose(DriverHandle);

    }

    switch (NtStatus) {

    case STATUS_SUCCESS:
        dwErr = NERR_Success;
        break;
    case STATUS_OBJECT_NAME_NOT_FOUND:
        dwErr = NERR_DfsNoSuchVolume;
        break;
    default:
        dwErr = ERROR_INVALID_PARAMETER;
        break;
    }

    free(OutBuffer);

#if DBG
    if (DfsDebug)
        DbgPrint("NetDfsSetClientInfo returning %d\n", dwErr);
#endif

    return( dwErr );
}


//+----------------------------------------------------------------------------
//
//  Function
//
//  Synopsis:   Enumerates the Dfs volumes.
//
//  Arguments:  [DfsName] -- Name of server or domain whose Dfs is being
//                      enumerated. A leading \\ is optional.
//              [Level] -- Indicates the level of info needed back. Valid
//                      Levels are 1,2, and 3.
//              [PrefMaxLen] -- Preferred maximum length of return buffer.
//              [Buffer] -- On successful return, contains an array of
//                      DFS_INFO_X. This buffer should be freed with a call
//                      to NetApiBufferFree.
//              [EntriesRead] -- On successful return, contains the number
//                      of entries read (and therefore, size of the array in
//                      Buffer).
//              [ResumeHandle] -- Must be 0 on first call. On subsequent calls
//                      the value returned by the immediately preceding call.
//
//  Returns:    [NERR_Success] -- Enum data successfully returned.
//
//              [ERROR_INVALID_LEVEL] -- The Level specified in invalid.
//
//              [ERROR_INVALID_NAME] -- Unable to locate server or domain.
//
//              [ERROR_DCNotFound] -- Unable to locate DC for DfsName.
//
//              [ERROR_NOT_ENOUGH_MEMORY] -- Out of memory condition.
//
//              [ERROR_NO_MORE_ITEMS] -- No more volumes to be enumerated.
//
//              [NERR_DfsInternalCorruption] -- Corruption of Dfs data
//                      encountered at the server.
//
//-----------------------------------------------------------------------------

NET_API_STATUS NET_API_FUNCTION
NetDfsEnum(
    IN      LPWSTR  DfsName,
    IN      DWORD   Level,
    IN      DWORD   PrefMaxLen,
    OUT     LPBYTE* Buffer,
    OUT     LPDWORD EntriesRead,
    IN OUT  LPDWORD ResumeHandle)
{
    NET_API_STATUS dwErr;
    LPWSTR pwszMachineName = NULL;
    LPWSTR pwszDomainName = NULL;
    DFS_INFO_ENUM_STRUCT DfsEnum;
    DFS_INFO_3_CONTAINER DfsInfo3Container;
    PDOMAIN_CONTROLLER_INFO pDomainControllerInfo = NULL;
    PWCHAR DCList;
    DWORD Version;

#if DBG
    if (DfsDebug)
        DbgPrint("NetDfsEnum(%ws, %d)\n", DfsName, Level);
#endif

    if (!IS_VALID_STRING(DfsName)) {
        dwErr = ERROR_INVALID_PARAMETER;
        goto AllDone;
    }

    //
    // Check the Level Parameter first, or RPC won't know how to marshal the
    // arguments.
    //

    if (!(Level >= 1 && Level <= 4) && (Level != 200) && (Level != 300)) {
        dwErr = ERROR_INVALID_LEVEL;
        goto AllDone;
    }
    

    //
    // Handle names with leading '\\'
    //
    while (*DfsName == L'\\') {
        DfsName++;
    }

    DfsInfo3Container.EntriesRead = 0;
    DfsInfo3Container.Buffer = NULL;
    DfsEnum.Level = Level;
    DfsEnum.DfsInfoContainer.DfsInfo3Container = &DfsInfo3Container;

    if (Level == 200) 
    {
        if (wcschr(DfsName, L'\\') == NULL) 
	{

	    //
            // Use the PDC to enum
	    //
            dwErr = DsGetDcName( NULL,
                                 DfsName,
                                 NULL,
                                 NULL,
                                 DS_PDC_REQUIRED | DS_FORCE_REDISCOVERY,
                                 &pDomainControllerInfo);

            ENTER_NETDFS_API

            if (dwErr == NERR_Success)
            {
                dwErr = DfspBindRpc(&pDomainControllerInfo->DomainControllerName[2],
                                    &netdfs_bhandle);
            }

            if (dwErr == NERR_Success)
            {

                RpcTryExcept {
                    dwErr = NetrDfsEnumEx( DfsName,
                                           Level,
                                           PrefMaxLen,
                                           &DfsEnum,
                                           ResumeHandle);
#if DBG
                    if (DfsDebug)
                        DbgPrint("NetrDfsEnumEx returned %d\n", dwErr);
#endif
                    if (dwErr == NERR_Success) {
                        *EntriesRead =DfsInfo3Container.EntriesRead;
                        *Buffer = (LPBYTE) DfsInfo3Container.Buffer;
                    }
                    if (dwErr == ERROR_UNEXP_NET_ERR)
                    {
                        dwErr = ERROR_NO_MORE_ITEMS;
                    }
                } RpcExcept( 1 ) {
                      dwErr = RpcExceptionCode();
                } RpcEndExcept;
                DfspFreeBinding( netdfs_bhandle );
            }
            LEAVE_NETDFS_API
        }
        else
        {
            dwErr = ERROR_INVALID_PARAMETER;
        }
    }
    else
    {
        dwErr = DfspGetMachineNameFromEntryPath(
                   DfsName,
                   wcslen(DfsName),
                   &pwszMachineName );

        ENTER_NETDFS_API

        if (dwErr == NERR_Success) {
            dwErr = DfspBindRpc( pwszMachineName, &netdfs_bhandle );
        }

#if DBG
        if (DfsDebug)
            DbgPrint("DfspBindRpc returned %d\n", dwErr);
#endif

        if (dwErr == NERR_Success) {

            RpcTryExcept {
                Version = NetrDfsManagerGetVersion();
            } RpcExcept( 1 ) {
                Version = 3;
            } RpcEndExcept;

            RpcTryExcept {
#if DBG
                if (DfsDebug)
                    DbgPrint("Calling NetrDfsEnumEx (%d)\n", Level);
#endif

                if (Version >= 4) 
                {
                    dwErr = NetrDfsEnumEx( DfsName,
                                           Level,
                                           PrefMaxLen,
                                           &DfsEnum,
                                           ResumeHandle );
                }
                else
                {
                    dwErr = NetrDfsEnum( Level,
                                         PrefMaxLen,
                                         &DfsEnum,
                                         ResumeHandle );

                }
            }
            RpcExcept( 1 ) {

                dwErr = RpcExceptionCode();
 #if DBG
                if (DfsDebug)
                    DbgPrint("RpcExeptionCode() err %d\n", dwErr);
 #endif

            } RpcEndExcept;

            if (dwErr == NERR_Success) {

                *EntriesRead =DfsInfo3Container.EntriesRead;

                *Buffer = (LPBYTE) DfsInfo3Container.Buffer;

            }

            DfspFreeBinding( netdfs_bhandle );
        } 
        LEAVE_NETDFS_API
    }

AllDone:

    if (pDomainControllerInfo != NULL)
        NetApiBufferFree(pDomainControllerInfo);

    if (pwszMachineName != NULL)
        free(pwszMachineName);

    if (pwszDomainName != NULL)
        free(pwszDomainName);

#if DBG
    if (DfsDebug)
        DbgPrint("NetDfsEnum returning %d\n", dwErr);
#endif

    return( dwErr );

}


//+----------------------------------------------------------------------------
//
//  Function:   NetDfsMove
//
//  Synopsis:   Moves a dfs volume to a new place in the Dfs hierarchy.
//
//  Arguments:  [DfsEntryPath] -- Current path to the volume.
//              [NewDfsEntryPath] -- Desired new path to the volume.
//
//  Returns:    [NERR_Success] -- Info successfully returned.
//
//              [ERROR_INVALID_PARAMETER] -- Either DfsEntryPath or
//                      NewDfsEntryPath are not valid.
//
//              [ERROR_INVALID_NAME] -- Unable to locate server or domain.
//
//              [ERROR_DCNotFound] -- Unable to locate DC for domain.
//
//              [ERROR_NOT_ENOUGH_MEMORY] -- Out of memory condition.
//
//              [NERR_DfsNoSuchVolume] -- No volume matches DfsEntryPath.
//
//              [NERR_DfsInternalCorruption] -- Corruption of Dfs data
//                      encountered at the server.
//
//-----------------------------------------------------------------------------

NET_API_STATUS
NetDfsMove(
    IN LPWSTR DfsEntryPath,
    IN LPWSTR NewDfsEntryPath)
{
    NET_API_STATUS dwErr;
    DWORD cwEntryPath;
    LPWSTR pwszDfsName;

    return ERROR_NOT_SUPPORTED;
}


//+----------------------------------------------------------------------------
//
//  Function:   NetDfsRename
//
//  Synopsis:   Renames a path that is along a Dfs Volume Entry Path
//
//  Arguments:  [Path] -- Current path.
//              [NewPath] -- Desired new path.
//
//  Returns:    [NERR_Success] -- Info successfully returned.
//
//              [ERROR_INVALID_PARAMETER] -- Either DfsEntryPath or
//                      NewDfsEntryPath are not valid.
//
//              [ERROR_INVALID_NAME] -- Unable to locate server or domain.
//
//              [ERROR_DCNotFound] -- Unable to locate DC for domain.
//
//              [ERROR_NOT_ENOUGH_MEMORY] -- Out of memory condition.
//
//              [NERR_DfsNoSuchVolume] -- No volume matches DfsEntryPath.
//
//              [NERR_DfsInternalCorruption] -- Corruption of Dfs data
//                      encountered at the server.
//
//-----------------------------------------------------------------------------

NET_API_STATUS
NetDfsRename(
    IN LPWSTR Path,
    IN LPWSTR NewPath)
{
    NET_API_STATUS dwErr;
    DWORD cwPath;
    LPWSTR pwszDfsName;

    return ERROR_NOT_SUPPORTED;

}


//+----------------------------------------------------------------------------
//
//  Function:   NetDfsManagerGetConfigInfo
//
//  Synopsis:   Given a DfsEntryPath and Guid of a local volume, this api
//              remotes to the root server of the entry path and retrieves
//              the config info from it.
//
//  Arguments:  [wszServer] -- Name of local machine
//              [wszLocalVolumeEntryPath] -- Entry Path of local volume.
//              [guidLocalVolume] -- Guid of local volume.
//              [ppDfsmRelationInfo] -- On successful return, contains pointer
//                      to config info at the root server. Free using
//                      NetApiBufferFree.
//
//  Returns:    [NERR_Success] -- Info returned successfully.
//
//              [ERROR_INVALID_PARAMETER] -- wszLocalVolumeEntryPath is
//                      invalid.
//
//              [ERROR_INVALID_NAME] -- Unable to parse out server/domain name
//                      from wszLocalVolumeEntryPath
//
//              [ERROR_DCNotFound] -- Unable to locate a DC for domain
//
//              [ERROR_NOT_ENOUGH_MEMORY] -- Out of memory condition
//
//              [NERR_DfsNoSuchVolume] -- The root server did not recognize
//                      a volume with this guid/entrypath
//
//              [NERR_DfsNoSuchServer] -- wszServer is not a valid server for
//                      wszLocalVolumeEntryPath
//
//-----------------------------------------------------------------------------

NET_API_STATUS
NetDfsManagerGetConfigInfo(
    LPWSTR wszServer,
    LPWSTR wszLocalVolumeEntryPath,
    GUID guidLocalVolume,
    LPDFSM_RELATION_INFO *ppDfsmRelationInfo)
{
    NET_API_STATUS dwErr;
    LPWSTR pwszDfsName = NULL;
    DWORD cwDfsEntryPath;

#if DBG
    if (DfsDebug)
        DbgPrint("NetDfsManagerGetConfigInfo(%ws,%ws)\n",
            wszServer,
            wszLocalVolumeEntryPath);
#endif

    if (!IS_VALID_STRING(wszServer) ||
            !IS_VALID_STRING(wszLocalVolumeEntryPath)) {
        return( ERROR_INVALID_PARAMETER );
    }

    //
    // Some elementary parameter checking to make sure we can proceed
    // reasonably...
    //

    cwDfsEntryPath = wcslen(wszLocalVolumeEntryPath);

    if (!IS_UNC_PATH(wszLocalVolumeEntryPath, cwDfsEntryPath) &&
            !IS_VALID_PREFIX(wszLocalVolumeEntryPath, cwDfsEntryPath) &&
                !IS_VALID_DFS_PATH(wszLocalVolumeEntryPath, cwDfsEntryPath)) {
        return( ERROR_INVALID_PARAMETER );
    }

    dwErr = DfspGetMachineNameFromEntryPath(
                wszLocalVolumeEntryPath,
                cwDfsEntryPath,
                &pwszDfsName);

    ENTER_NETDFS_API

    if (dwErr == NERR_Success) {

        //
        // By now, we should have a valid pwszDfsName. Lets try to bind to it,
        // and call the server.
        //

        dwErr = DfspBindRpc( pwszDfsName, &netdfs_bhandle );

        if (dwErr == NERR_Success) {

            RpcTryExcept {

                *ppDfsmRelationInfo = NULL;

                dwErr = NetrDfsManagerGetConfigInfo(
                            wszServer,
                            wszLocalVolumeEntryPath,
                            guidLocalVolume,
                            ppDfsmRelationInfo);

           } RpcExcept( 1 ) {

               dwErr = RpcExceptionCode();

           } RpcEndExcept;

           DfspFreeBinding( netdfs_bhandle );

        }

        free( pwszDfsName );

    }

    LEAVE_NETDFS_API

#if DBG
    if (DfsDebug)
        DbgPrint("NetDfsManagerGetConfigInfo returning %d\n", dwErr);
#endif

    return( dwErr );

}

//+----------------------------------------------------------------------------
//
//  Function:   NetDfsManagerInitialize
//
//  Synopsis:   Reinitialize the Dfs Manager on a remote machine
//
//  Arguments:  [ServerName] -- Name of server to remote to
//              [Flags] -- Flags
//
//  Returns:    [NERR_Success] -- Successfully completed operation.
//
//-----------------------------------------------------------------------------

NET_API_STATUS
NetDfsManagerInitialize(
    IN LPWSTR ServerName,
    IN DWORD  Flags)
{
    NET_API_STATUS dwErr;

#if DBG
    if (DfsDebug)
        DbgPrint("NetDfsManagerInitialize(%ws,%d)\n",
                ServerName,
                Flags);
#endif

    //
    // Validate the string argument so RPC won't complain...
    //

    if (!IS_VALID_STRING(ServerName)) {
        return( ERROR_INVALID_PARAMETER );
    }

    ENTER_NETDFS_API

    //
    // We should have a valid ServerName. Lets try to bind to it,
    // and call the server.
    //

    dwErr = DfspBindToServer( ServerName, &netdfs_bhandle );

    if (dwErr == NERR_Success) {

        RpcTryExcept {

            dwErr = NetrDfsManagerInitialize(
                        ServerName,
                        Flags);

        } RpcExcept(1) {

            dwErr = RpcExceptionCode();

        } RpcEndExcept;

        DfspFreeBinding( netdfs_bhandle );

    }

    LEAVE_NETDFS_API

#if DBG
    if (DfsDebug)
        DbgPrint("NetDfsManagerInitialize returning %d\n", dwErr);
#endif

    return( dwErr );

}


//+----------------------------------------------------------------------------
//
//  Function:   NetDfsManagerSendSiteInfo
//
//  Synopsis:   Gets site information from a server
//
//  Returns:    [NERR_Success] -- Successfully completed operation.
//
//-----------------------------------------------------------------------------

NET_API_STATUS
NetDfsManagerSendSiteInfo(
    LPWSTR wszServer,
    LPWSTR wszLocalVolumeEntryPath,
    LPDFS_SITELIST_INFO pSiteInfo)
{
    NET_API_STATUS dwErr;
    LPWSTR pwszDfsName = NULL;
    DWORD cwDfsEntryPath;

#if DBG
    if (DfsDebug)
        DbgPrint("NetDfsManagerSendSiteInfo(%ws,%ws)\n",
            wszServer,
            wszLocalVolumeEntryPath);
#endif

    if (!IS_VALID_STRING(wszServer) ||
            !IS_VALID_STRING(wszLocalVolumeEntryPath)) {
        return( ERROR_INVALID_PARAMETER );
    }

    //
    // Some elementary parameter checking to make sure we can proceed
    // reasonably...
    //

    cwDfsEntryPath = wcslen(wszLocalVolumeEntryPath);

    if (!IS_UNC_PATH(wszLocalVolumeEntryPath, cwDfsEntryPath) &&
            !IS_VALID_PREFIX(wszLocalVolumeEntryPath, cwDfsEntryPath) &&
                !IS_VALID_DFS_PATH(wszLocalVolumeEntryPath, cwDfsEntryPath)) {
        return( ERROR_INVALID_PARAMETER );
    }

    dwErr = DfspGetMachineNameFromEntryPath(
                wszLocalVolumeEntryPath,
                cwDfsEntryPath,
                &pwszDfsName);

    ENTER_NETDFS_API

    if (dwErr == NERR_Success) {

        //
        // By now, we should have a valid pwszDfsName. Lets try to bind to it,
        // and call the server.
        //

        dwErr = DfspBindRpc( pwszDfsName, &netdfs_bhandle );

        if (dwErr == NERR_Success) {

            RpcTryExcept {

                dwErr = NetrDfsManagerSendSiteInfo(
                            wszServer,
                            pSiteInfo);

           } RpcExcept( 1 ) {

               dwErr = RpcExceptionCode();

           } RpcEndExcept;

           DfspFreeBinding( netdfs_bhandle );

        }

        free( pwszDfsName );

    }

    LEAVE_NETDFS_API

#if DBG
    if (DfsDebug)
        DbgPrint("NetDfsManagerSendSiteInfo returning %d\n", dwErr);
#endif

    return( dwErr );

}


//+----------------------------------------------------------------------------
//
//  Function:   DfspGetMachineNameFromEntryPath
//
//  Synopsis:   Given a DfsEntryPath, this routine returns the name of the
//              FtDfs Root.
//
//  Arguments:  [wszEntryPath] -- Pointer to EntryPath to parse.
//
//              [cwEntryPath] -- Length in WCHAR of wszEntryPath.
//
//              [ppwszMachineName] -- Name of a root machine; allocated using malloc;
//                                      caller resposible for freeing it.
//
//  Returns:    [NERR_Success] -- Successfully determinded
//
//              [ERROR_INVALID_NAME] -- Unable to parse wszEntryPath.
//
//              [ERROR_NOT_ENOUGH_MEMORY] -- Unable to allocate memory for
//                      ppwszMachineName.
//
//-----------------------------------------------------------------------------

NET_API_STATUS
DfspGetMachineNameFromEntryPath(
    LPWSTR wszEntryPath,
    DWORD cwEntryPath,
    LPWSTR *ppwszMachineName)
{
    NTSTATUS NtStatus;
    LPWSTR pwszDfsName, pwszFirst, pwszLast;
    LPWSTR pwszMachineName;
    DWORD cwDfsName;
    DWORD cwSlash;
    DWORD dwErr;

#if DBG
    if (DfsDebug)
        DbgPrint("DfspGetMachineNameFromEntryPath(%ws,%d\n", wszEntryPath, cwEntryPath);
#endif

    if (!IS_VALID_STRING(wszEntryPath)) {
        return( ERROR_INVALID_PARAMETER );
    }

    if (IS_UNC_PATH(wszEntryPath, cwEntryPath)) {

        pwszFirst = &wszEntryPath[2];

    } else if (IS_VALID_PREFIX(wszEntryPath, cwEntryPath)) {

        pwszFirst = &wszEntryPath[1];

    } else if (IS_VALID_DFS_PATH(wszEntryPath, cwEntryPath)) {

        pwszFirst = &wszEntryPath[0];

    } else {

        return( ERROR_INVALID_NAME );

    }

    dwErr = DfspGetDfsNameFromEntryPath(
                wszEntryPath,
                cwEntryPath,
                &pwszMachineName);

    if (dwErr != NERR_Success) {

#if DBG
        if (DfsDebug)
            DbgPrint("DfspGetMachineNameFromEntryPath: returning %d\n", dwErr);
#endif
        return( dwErr);

    }

    for (cwDfsName = cwSlash = 0, pwszLast = pwszFirst;
            *pwszLast != UNICODE_NULL;
                pwszLast++, cwDfsName++) {
         if (*pwszLast == L'\\')
            cwSlash++;
         if (cwSlash >= 2)
            break;
    }

    if (cwSlash == 0) {

        *ppwszMachineName = pwszMachineName;
        dwErr = NERR_Success;

        return dwErr;
    }

    cwDfsName += 3;

    pwszDfsName = malloc(cwDfsName * sizeof(WCHAR));

    if (pwszDfsName != NULL) {

        ZeroMemory((PCHAR)pwszDfsName, cwDfsName * sizeof(WCHAR));

        wcscpy(pwszDfsName, L"\\\\");

        CopyMemory(&pwszDfsName[2], pwszFirst, (PCHAR)pwszLast - (PCHAR)pwszFirst);

        NtStatus = DfspIsThisADfsPath(&pwszDfsName[1]);

        if (NT_SUCCESS(NtStatus)) {
            GetFileAttributes(pwszDfsName);
        }

        dwErr = DfspDfsPathToRootMachine(pwszDfsName, ppwszMachineName);

        if (NtStatus != STATUS_SUCCESS || dwErr != NERR_Success) {

            *ppwszMachineName = pwszMachineName;
            dwErr = NERR_Success;

        } else {

            free(pwszMachineName);

        }

        free(pwszDfsName);

    } else {

        free(pwszMachineName);
        dwErr = ERROR_NOT_ENOUGH_MEMORY;

    }

#if DBG
    if (DfsDebug)
        DbgPrint("DfspGetMachineNameFromEntryPath returning %d\n", dwErr);
#endif

    return( dwErr );

}


//+----------------------------------------------------------------------------
//
//  Function:   DfspGetDfsNameFromEntryPath
//
//  Synopsis:   Given a DfsEntryPath, this routine returns the name of the
//              Dfs Root.
//
//  Arguments:  [wszEntryPath] -- Pointer to EntryPath to parse.
//
//              [cwEntryPath] -- Length in WCHAR of wszEntryPath.
//
//              [ppwszDfsName] -- Name of Dfs root is returned here. Memory
//                      is allocated using malloc; caller resposible for
//                      freeing it.
//
//  Returns:    [NERR_Success] -- Successfully parsed out Dfs Root.
//
//              [ERROR_INVALID_NAME] -- Unable to parse wszEntryPath.
//
//              [ERROR_NOT_ENOUGH_MEMORY] -- Unable to allocate memory for
//                      ppwszDfsName.
//
//-----------------------------------------------------------------------------

NET_API_STATUS
DfspGetDfsNameFromEntryPath(
    LPWSTR wszEntryPath,
    DWORD cwEntryPath,
    LPWSTR *ppwszDfsName)
{
    LPWSTR pwszDfsName, pwszFirst, pwszLast;
    DWORD cwDfsName;

#if DBG
    if (DfsDebug)
        DbgPrint("DfspGetDfsNameFromEntryPath(%ws,%d)\n", wszEntryPath, cwEntryPath);
#endif

    if (!IS_VALID_STRING(wszEntryPath)) {
#if DBG
        if (DfsDebug)
            DbgPrint("DfspGetDfsNameFromEntryPath returning ERROR_INVALID_PARAMETER\n");
#endif
        return( ERROR_INVALID_PARAMETER );
    }

    if (IS_UNC_PATH(wszEntryPath, cwEntryPath)) {

        pwszFirst = &wszEntryPath[2];

    } else if (IS_VALID_PREFIX(wszEntryPath, cwEntryPath)) {

        pwszFirst = &wszEntryPath[1];

    } else if (IS_VALID_DFS_PATH(wszEntryPath, cwEntryPath)) {

        pwszFirst = &wszEntryPath[0];

    } else {

#if DBG
        if (DfsDebug)
            DbgPrint("DfspGetDfsNameFromEntryPath returning ERROR_INVALID_NAME\n");
#endif
        return( ERROR_INVALID_NAME );

    }

    for (cwDfsName = 0, pwszLast = pwszFirst;
            *pwszLast != UNICODE_NULL && *pwszLast != L'\\';
                pwszLast++, cwDfsName++) {
         ;
    }

    ++cwDfsName;

    pwszDfsName = malloc( cwDfsName * sizeof(WCHAR) );

    if (pwszDfsName != NULL) {

        pwszDfsName[ cwDfsName - 1 ] = 0;

        for (cwDfsName--; cwDfsName > 0; cwDfsName--) {

            pwszDfsName[ cwDfsName - 1 ] = pwszFirst[ cwDfsName - 1 ];

        }

        *ppwszDfsName = pwszDfsName;

#if DBG
    if (DfsDebug)
        DbgPrint("DfspGetDfsNameFromEntryPath returning %ws\n", pwszDfsName);
#endif

        return( NERR_Success );

    } else {

#if DBG
    if (DfsDebug)
        DbgPrint("DfspGetDfsNameFromEntryPath returning ERROR_NOT_ENOUGH_MEMORY\n");
#endif
        return( ERROR_NOT_ENOUGH_MEMORY );

    }

}


//+----------------------------------------------------------------------------
//
//  Function:   DfspBindRpc
//
//  Synopsis:   Given a server or domain name, this API will bind to the
//              appropriate Dfs Manager service.
//
//  Arguments:  [DfsName] -- Name of domain or server. Leading \\ is optional
//
//              [BindingHandle] -- On successful return, the binding handle
//                      is returned here.
//
//  Returns:    [NERR_Success] -- Binding handle successfull returned.
//
//              [RPC_S_SERVER_NOT_AVAILABLE] -- Unable to bind to NetDfs
//                      interface on the named server or domain.
//
//              [ERROR_INVALID_NAME] -- Unable to parse DfsName as a valid
//                      server or domain name.
//
//              [ERROR_DCNotFound] -- Unable to locate DC for DfsName.
//
//              [ERROR_NOT_ENOUGH_MEMORY] -- Out of memory condition.
//
//-----------------------------------------------------------------------------

NET_API_STATUS
DfspBindRpc(
    IN  LPWSTR DfsName,
    OUT RPC_BINDING_HANDLE *BindingHandle)
{
    LPWSTR wszProtocolSeq = L"ncacn_np";
    LPWSTR wszEndPoint = L"\\pipe\\netdfs";
    LPWSTR pwszRpcBindingString = NULL;
    LPWSTR pwszDCName = NULL;
    NET_API_STATUS dwErr;
    PWCHAR DCList = NULL;
    PWCHAR DCListToFree = NULL;
    BOOLEAN IsDomainName = FALSE;

#if DBG
    if (DfsDebug)
        DbgPrint("DfspBindRpc(%ws)\n", DfsName);
#endif

    //
    // First, see if this is a domain name.
    //

    dwErr = DfspIsThisADomainName( DfsName, &DCListToFree );

    DCList = DCListToFree;

    if (dwErr == ERROR_SUCCESS && DCList != NULL && *DCList != UNICODE_NULL) {

        //
        // It's a domain name. Use the DC list as a list of servers to try to bind to.
        //

        IsDomainName = TRUE;
        pwszDCName = DCList + 1;    // Skip '+' or '-'

        dwErr = ERROR_SUCCESS;

    } else {

        //
        // Lets see if this is a machine-based Dfs
        //

        pwszDCName = DfsName;

        dwErr = ERROR_SUCCESS;

    }

Try_Connect:

    if (dwErr == ERROR_SUCCESS) {

#if DBG
        if (DfsDebug)
            DbgPrint("Calling RpcBindingCompose(%ws)\n", pwszDCName);
#endif

        dwErr = RpcStringBindingCompose(
                    NULL,                            // Object UUID
                    wszProtocolSeq,                  // Protocol Sequence
                    pwszDCName,                      // Network Address
                    wszEndPoint,                     // RPC Endpoint
                    NULL,                            // RPC Options
                    &pwszRpcBindingString);          // Returned binding string

        if (dwErr == RPC_S_OK) {

            dwErr = RpcBindingFromStringBinding(
                        pwszRpcBindingString,
                        BindingHandle);

#if DBG
            if (DfsDebug)
                DbgPrint("RpcBindingFromStringBinding() returned %d\n", dwErr);
#endif

            if (dwErr == RPC_S_OK) {

                dwErr = DfspVerifyBinding();
                if (dwErr != RPC_S_OK)
                {
                    DfspFreeBinding(*BindingHandle);
                }

#if DBG
                if (DfsDebug)
                    DbgPrint("DfspVerifyBinding() returned %d\n", dwErr);
#endif

            } else {

                dwErr = ERROR_INVALID_NAME;

            }
        }

    }

    if (pwszRpcBindingString != NULL) {

        RpcStringFree( &pwszRpcBindingString );

    }

    if (dwErr == RPC_S_OUT_OF_MEMORY) {
        dwErr = ERROR_NOT_ENOUGH_MEMORY;
    }

    //
    // If we couldn't connect and we have a domain name and a list of DC's,
    // try the next DC in the list.
    //

    if (dwErr != NERR_Success && DCList != NULL && IsDomainName == TRUE) {

        DCList += wcslen(DCList) + 1;

        if (*DCList != UNICODE_NULL) {

            pwszDCName = DCList + 1;
            dwErr = ERROR_SUCCESS;

            goto Try_Connect;

        }

    }

    if (DCListToFree != NULL) {

        free(DCListToFree);

    }

    return( dwErr );

}

//+----------------------------------------------------------------------------
//
//  Function:   DfspFreeBinding
//
//  Synopsis:   Frees a binding created by DfspBindRpc
//
//  Arguments:  [BindingHandle] -- The handle to free.
//
//  Returns:    Nothing
//
//-----------------------------------------------------------------------------

VOID
DfspFreeBinding(
    RPC_BINDING_HANDLE BindingHandle)
{
    DWORD dwErr;

    dwErr = RpcBindingFree( &BindingHandle );

}


//+----------------------------------------------------------------------------
//
//  Function:   DfspVerifyBinding
//
//  Synopsis:   Verifies that the binding can be used by doing a
//              NetrDfsManagerGetVersion call on the binding.
//
//  Arguments:  None
//
//  Returns:    [NERR_Success] -- Server connnected to.
//
//              [RPC_S_SERVER_UNAVAILABLE] -- The server is not available.
//
//              Other RPC error from calling the remote server.
//
//-----------------------------------------------------------------------------

NET_API_STATUS
DfspVerifyBinding()
{
    NET_API_STATUS status = NERR_Success;
    DWORD Version;

    RpcTryExcept {

        Version = NetrDfsManagerGetVersion();

    } RpcExcept(1) {

        status = RpcExceptionCode();

    } RpcEndExcept;

    return( status );

}


//+----------------------------------------------------------------------------
//
//  Function:   DfspBindToServer
//
//  Synopsis:   Given a server name, this API will bind to the
//              appropriate Dfs Manager service.
//
//  Arguments:  [DfsName] -- Name of server. Leading \\ is optional
//
//              [BindingHandle] -- On successful return, the binding handle
//                      is returned here.
//
//  Returns:    [NERR_Success] -- Binding handle successfull returned.
//
//              [RPC_S_SERVER_NOT_AVAILABLE] -- Unable to bind to NetDfs
//                      interface on the named server or domain.
//
//              [ERROR_INVALID_NAME] -- Unable to parse DfsName as a valid
//                      server or domain name.
//
//              [ERROR_DCNotFound] -- Unable to locate DC for DfsName.
//
//              [ERROR_NOT_ENOUGH_MEMORY] -- Out of memory condition.
//
//-----------------------------------------------------------------------------

NET_API_STATUS
DfspBindToServer(
    IN  LPWSTR ServerName,
    OUT RPC_BINDING_HANDLE *BindingHandle)
{
    LPWSTR wszProtocolSeq = L"ncacn_np";
    LPWSTR wszEndPoint = L"\\pipe\\netdfs";
    LPWSTR pwszRpcBindingString = NULL;
    NET_API_STATUS dwErr;

    dwErr = RpcStringBindingCompose(
                NULL,                            // Object UUID
                wszProtocolSeq,                  // Protocol Sequence
                ServerName,                      // Network Address
                wszEndPoint,                     // RPC Endpoint
                NULL,                            // RPC Options
                &pwszRpcBindingString);          // Returned binding string

    if (dwErr == RPC_S_OK) {

        dwErr = RpcBindingFromStringBinding(
                    pwszRpcBindingString,
                    BindingHandle);

        if (dwErr == RPC_S_OK) {

            dwErr = DfspVerifyBinding();
            if (dwErr != RPC_S_OK)
            {
                DfspFreeBinding(*BindingHandle);
            }
        } else {

            dwErr = ERROR_INVALID_NAME;

        }
    }

    if (pwszRpcBindingString != NULL) {

        RpcStringFree( &pwszRpcBindingString );

    }

    if (dwErr == RPC_S_OUT_OF_MEMORY) {
        dwErr = ERROR_NOT_ENOUGH_MEMORY;
    }

    return( dwErr );

}

//+----------------------------------------------------------------------------
//
//  Function:   DfspFlushPkt
//
//  Synopsis:   Flushes the local pkt
//
//  Arguments:  DfsEntryPath or NULL
//
//  Returns:    The fsctrl's code
//
//-----------------------------------------------------------------------------

VOID
DfspFlushPkt(
    LPWSTR DfsEntryPath)
{
    NTSTATUS NtStatus;
    HANDLE DriverHandle = NULL;
    IO_STATUS_BLOCK IoStatusBlock;
    OBJECT_ATTRIBUTES objectAttributes;
    UNICODE_STRING DfsDriverName;

    RtlInitUnicodeString(&DfsDriverName, DFS_DRIVER_NAME);

    InitializeObjectAttributes(
        &objectAttributes,
        &DfsDriverName,
        OBJ_CASE_INSENSITIVE,
        NULL,
        NULL
    );

    NtStatus = NtCreateFile(
                    &DriverHandle,
                    SYNCHRONIZE | FILE_WRITE_DATA,
                    &objectAttributes,
                    &IoStatusBlock,
                    NULL,
                    FILE_ATTRIBUTE_NORMAL,
                    FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
                    FILE_OPEN_IF,
                    FILE_CREATE_TREE_CONNECTION | FILE_SYNCHRONOUS_IO_NONALERT,
                    NULL,
                    0);

    if (NT_SUCCESS(NtStatus)) {

        if (DfsEntryPath != NULL) {

            NtStatus = NtFsControlFile(
                           DriverHandle,
                           NULL,       // Event,
                           NULL,       // ApcRoutine,
                           NULL,       // ApcContext,
                           &IoStatusBlock,
                           FSCTL_DFS_PKT_FLUSH_CACHE,
                           DfsEntryPath,
                           wcslen(DfsEntryPath) * sizeof(WCHAR),
                           NULL,
                           0);

        } else {

            NtStatus = NtFsControlFile(
                           DriverHandle,
                           NULL,       // Event,
                           NULL,       // ApcRoutine,
                           NULL,       // ApcContext,
                           &IoStatusBlock,
                           FSCTL_DFS_PKT_FLUSH_CACHE,
                           L"*",
                           sizeof(WCHAR),
                           NULL,
                           0);

        }

        NtClose(DriverHandle);

    }

}

//+----------------------------------------------------------------------------
//
//  Function:   DfspDfsPathToRootMachine
//
//  Synopsis:   Turns a dfs root path into a machine name
//              Ex: \\jharperdomain\FtDfs -> jharperdc1
//                  \\jharpera\d -> jharpera
//
//  Arguments:  pwszDfsName - Dfs root path to get machine for
//              ppwszMachineName - The machine, if one found.  Space is
//                                  malloc'd, caller must free.
//
//  Returns:    [NERR_Success] -- Resolved ok
//
//-----------------------------------------------------------------------------

DWORD
DfspDfsPathToRootMachine(
    LPWSTR pwszDfsName,
    LPWSTR *ppwszMachineName)
{
    NTSTATUS NtStatus;
    HANDLE DriverHandle = NULL;
    IO_STATUS_BLOCK IoStatusBlock;
    OBJECT_ATTRIBUTES objectAttributes;
    UNICODE_STRING DfsDriverName;
    WCHAR ServerName[0x100];
    DWORD dwErr;
    ULONG i;

#if DBG
    if (DfsDebug)
        DbgPrint("DfspDfsPathToRootMachine(%ws)\n", pwszDfsName);
#endif

    for (i = 0; i < sizeof(ServerName) / sizeof(WCHAR); i++)
        ServerName[i] = UNICODE_NULL;

    RtlInitUnicodeString(&DfsDriverName, DFS_DRIVER_NAME);

    InitializeObjectAttributes(
        &objectAttributes,
        &DfsDriverName,
        OBJ_CASE_INSENSITIVE,
        NULL,
        NULL
    );

    NtStatus = NtCreateFile(
                    &DriverHandle,
                    SYNCHRONIZE,
                    &objectAttributes,
                    &IoStatusBlock,
                    NULL,
                    FILE_ATTRIBUTE_NORMAL,
                    FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
                    FILE_OPEN_IF,
                    FILE_CREATE_TREE_CONNECTION | FILE_SYNCHRONOUS_IO_NONALERT,
                    NULL,
                    0
                );

    if (NT_SUCCESS(NtStatus)) {

        NtStatus = NtFsControlFile(
                       DriverHandle,
                       NULL,       // Event,
                       NULL,       // ApcRoutine,
                       NULL,       // ApcContext,
                       &IoStatusBlock,
                       FSCTL_DFS_GET_SERVER_NAME,
                       pwszDfsName,
                       wcslen(pwszDfsName) * sizeof(WCHAR),
                       ServerName,
                       sizeof(ServerName)
                   );

        NtClose(DriverHandle);

    }

    if (NT_SUCCESS(NtStatus)) {

        LPWSTR wcpStart;
        LPWSTR wcpEnd;

        for (wcpStart = ServerName; *wcpStart == L'\\'; wcpStart++)
            ;

        for (wcpEnd = wcpStart; *wcpEnd != L'\\' && *wcpEnd != UNICODE_NULL; wcpEnd++)
            ;

        *wcpEnd = UNICODE_NULL;

        *ppwszMachineName = malloc((wcslen(wcpStart) + 1) * sizeof(WCHAR));

        if (*ppwszMachineName != NULL) {

            wcscpy(*ppwszMachineName, wcpStart);

            dwErr = NERR_Success;

        } else {

            dwErr = ERROR_NOT_ENOUGH_MEMORY;

        }

    } else {

#if DBG
        if (DfsDebug)
            DbgPrint("DfspDfsPathToRootMachine NtStatus=0x%x\n", NtStatus);
#endif

        dwErr = ERROR_INVALID_PARAMETER;

    }

#if DBG
    if (DfsDebug) {
        if (dwErr == NERR_Success)
            DbgPrint("DfspDfsPathToRootMachine returning %ws\n", *ppwszMachineName);
         else
            DbgPrint("DfspDfsPathToRootMachine returning %d\n", dwErr);
    }
#endif

    return dwErr;

}

//+----------------------------------------------------------------------------
//
//  Function:   DfspIsThisADfsPath
//
//  Synopsis:   Checks (via IOCTL to driver) if the path passed in
//              is a Dfs path.
//
//  Arguments:  pwszPathName - Path to check (ex: \ntbuilds\release)
//
//  Returns:    NTSTATUS of the call (STATUS_SUCCESS or error)
//
//-----------------------------------------------------------------------------

NTSTATUS
DfspIsThisADfsPath(
    LPWSTR pwszPathName)
{
    NTSTATUS NtStatus;
    HANDLE DriverHandle = NULL;
    IO_STATUS_BLOCK IoStatusBlock;
    OBJECT_ATTRIBUTES objectAttributes;
    UNICODE_STRING DfsDriverName;
    PDFS_IS_VALID_PREFIX_ARG pPrefixArg = NULL;
    ULONG Size;

#if DBG
    if (DfsDebug)
        DbgPrint("DfspIsThisADfsPath(%ws)\n", pwszPathName);
#endif

    Size = sizeof(DFS_IS_VALID_PREFIX_ARG) +
                (wcslen(pwszPathName) + 1) * sizeof(WCHAR);

    pPrefixArg = (PDFS_IS_VALID_PREFIX_ARG) malloc(Size);

    if (pPrefixArg == NULL) {

        NtStatus = STATUS_INSUFFICIENT_RESOURCES;
        goto exit_with_status;

    }

    pPrefixArg->CSCAgentCreate = FALSE;
    pPrefixArg->RemoteNameLen = wcslen(pwszPathName) * sizeof(WCHAR);
    wcscpy(&pPrefixArg->RemoteName[0], pwszPathName);

    RtlInitUnicodeString(&DfsDriverName, DFS_DRIVER_NAME);

    InitializeObjectAttributes(
        &objectAttributes,
        &DfsDriverName,
        OBJ_CASE_INSENSITIVE,
        NULL,
        NULL
    );

    NtStatus = NtCreateFile(
                    &DriverHandle,
                    SYNCHRONIZE,
                    &objectAttributes,
                    &IoStatusBlock,
                    NULL,
                    FILE_ATTRIBUTE_NORMAL,
                    FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
                    FILE_OPEN_IF,
                    FILE_CREATE_TREE_CONNECTION | FILE_SYNCHRONOUS_IO_NONALERT,
                    NULL,
                    0
                );

    if (NT_SUCCESS(NtStatus)) {

        NtStatus = NtFsControlFile(
                       DriverHandle,
                       NULL,       // Event,
                       NULL,       // ApcRoutine,
                       NULL,       // ApcContext,
                       &IoStatusBlock,
                       FSCTL_DFS_IS_VALID_PREFIX,
                       pPrefixArg,
                       Size,
                       NULL,
                       0
                   );

        NtClose(DriverHandle);

    }

exit_with_status:

    if (pPrefixArg != NULL) {

        free(pPrefixArg);

    }

#if DBG
    if (DfsDebug)
        DbgPrint("DfspIsThisADfsPath returning 0x%x\n", NtStatus);
#endif

    return NtStatus;

}

//+----------------------------------------------------------------------------
//
//  Function:   DfspCreateFtDfs
//
//  Synopsis:   Creates/updates a Ds object representing the FtDfs, then rpc's
//              to the server and has it update the DS object, thus completing
//              the setup.
//
//  Arguments:  wszServerName - Name of server we'll be adding
//              wszDcName - DC to use
//              fIsPdc - TRUE if DC is the PDC
//              wszRootShare - Share to become the root share
//              wszFtDfsName - Name of FtDfs we are creating
//              wszComment -- Comment for the root
//              dwFlags - 0
//
//  Returns:    NTSTATUS of the call (STATUS_SUCCESS or error)
//
//----------------------------------------------