  pbstrPermitSetXML = ((string)(results[2]));
        }

        /// <remarks/>
        public System.IAsyncResult BeginGetPermitsForPUID(int lCustomerPUIDHigh, int lCustomerPUIDLow, string bstrServiceComponentGUID, System.AsyncCallback callback, object asyncState)
        {
            return this.BeginInvoke("GetPermitsForPUID", new object[] {
                    lCustomerPUIDHigh,
                    lCustomerPUIDLow,
                    bstrServiceComponentGUID}, callback, asyncState);
        }

        /// <remarks/>
        public void EndGetPermitsForPUID(System.IAsyncResult asyncResult, out string pbstrErrorXML, out int plPermitCount, out string pbstrPermitSetXML)
        {
            object[] results = this.EndInvoke(asyncResult);
            pbstrErrorXML = ((string)(results[0]));
            plPermitCount = ((int)(results[1]));
            pbstrPermitSetXML = ((string)(results[2]));
        }

        /// <remarks/>
        public void GetPermitsForPUIDAsync(int lCustomerPUIDHigh, int lCustomerPUIDLow, string bstrServiceComponentGUID)
        {
            this.GetPermitsForPUIDAsync(lCustomerPUIDHigh, lCustomerPUIDLow, bstrServiceComponentGUID, null);
        }

        /// <remarks/>
        public void GetPermitsForPUIDAsync(int lCustomerPUIDHigh, int lCustomerPUIDLow, string bstrServiceComponentGUID, object userState)
        {
            if ((this.GetPermitsForPUIDOperationCompleted == null))
            {
                this.GetPermitsForPUIDOperationCompleted = new System.Threading.SendOrPostCallback(this.OnGetPermitsForPUIDOperationCompleted);
            }
            this.InvokeAsync("GetPermitsForPUID", new object[] {
                    lCustomerPUIDHigh,
                    lCustomerPUIDLow,
                    bstrServiceComponentGUID}, this.GetPermitsForPUIDOperationCompleted, userState);
        }

        private void OnGetPermitsForPUIDOperationCompleted(object arg)
        {
            if ((this.GetPermitsForPUIDCompleted != null))
            {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.GetPermitsForPUIDCompleted(this, new GetPermitsForPUIDCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }

        /// <remarks/>
        [System.Web.Services.Protocols.SoapHeaderAttribute("UserContextualInfoSoapHeaderValue")]
        [System.Web.Services.Protocols.SoapHeaderAttribute("OnBehalfOfSoapHeaderValue")]
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.GetPolicy", RequestNamespace = "http://tempuri.org/message/", ResponseNamespace = "http://tempuri.org/message/")]
        public void GetPolicy(string bstrPolicyGUID, int lPolicyVersion, string bstrLocale, out string pbstrPolicyInfoXML, out string pbstrErrorXML)
        {
            object[] results = this.Invoke("GetPolicy", new object[] {
                    bstrPolicyGUID,
                    lPolicyVersion,
                    bstrLocale});
            pbstrPolicyInfoXML = ((string)(results[0]));
            pbstrErrorXML = ((string)(results[1]));
        }

        /// <remarks/>
        public System.IAsyncResult BeginGetPolicy(string bstrPolicyGUID, int lPolicyVersion, string bstrLocale, System.AsyncCallback callback, object asyncState)
        {
            return this.BeginInvoke("GetPolicy", new object[] {
                    bstrPolicyGUID,
                    lPolicyVersion,
                    bstrLocale}, callback, asyncState);
        }

        /// <remarks/>
        public void EndGetPolicy(System.IAsyncResult asyncResult, out string pbstrPolicyInfoXML, out string pbstrErrorXML)
        {
            object[] results = this.EndInvoke(asyncResult);
            pbstrPolicyInfoXML = ((string)(results[0]));
            pbstrErrorXML = ((string)(results[1]));
        }

        /// <remarks/>
        public void GetPolicyAsync(string bstrPolicyGUID, int lPolicyVersion, string bstrLocale)
        {
            this.GetPolicyAsync(bstrPolicyGUID, lPolicyVersion, bstrLocale, null);
        }

        /// <remarks/>
        public void GetPolicyAsync(string bstrPolicyGUID, int lPolicyVersion, string bstrLocale, object userState)
        {
            if ((this.GetPolicyOperationCompleted == null))
            {
                this.GetPolicyOperationCompleted = new System.Threading.SendOrPostCallback(this.OnGetPolicyOperationCompleted);
            }
            this.InvokeAsync("GetPolicy", new object[] {
                    bstrPolicyGUID,
                    lPolicyVersion,
                    bstrLocale}, this.GetPolicyOperationCompleted, userState);
        }

        private void OnGetPolicyOperationCompleted(object arg)
        {
            if ((this.GetPolicyCompleted != null))
            {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.GetPolicyCompleted(this, new GetPolicyCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }

        /// <remarks/>
        [System.Web.Services.Protocols.SoapHeaderAttribute("UserContextualInfoSoapHeaderValue")]
        [System.Web.Services.Protocols.SoapHeaderAttribute("OnBehalfOfSoapHeaderValue")]
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.GetProductClasses", RequestNamespace = "http://tempuri.org/message/", ResponseNamespace = "http://tempuri.org/message/")]
        public void GetProductClasses(out string productClassSetXml)
        {
            object[] results = this.Invoke("GetProductClasses", new object[0]);
            productClassSetXml = ((string)(results[0]));
        }

        /// <remarks/>
        public System.IAsyncResult BeginGetProductClasses(System.AsyncCallback callback, object asyncState)
        {
            return this.BeginInvoke("GetProductClasses", new object[0], callback, asyncState);
        }

        /// <remarks/>
        public void EndGetProductClasses(System.IAsyncResult asyncResult, out string productClassSetXml)
        {
            object[] results = this.EndInvoke(asyncResult);
            productClassSetXml = ((string)(results[0]));
        }

        /// <remarks/>
        public void GetProductClassesAsync()
        {
            this.GetProductClassesAsync(null);
        }

        /// <remarks/>
        public void GetProductClassesAsync(object userState)
        {
            if ((this.GetProductClassesOperationCompleted == null))
            {
                this.GetProductClassesOperationCompleted = new System.Threading.SendOrPostCallback(this.OnGetProductClassesOperationCompleted);
            }
            this.InvokeAsync("GetProductClasses", new object[0], this.GetProductClassesOperationCompleted, userState);
        }

        private void OnGetProductClassesOperationCompleted(object arg)
        {
            if ((this.GetProductClassesCompleted != null))
            {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.GetProductClassesCompleted(this, new GetProductClassesCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }

        /// <remarks/>
        [System.Web.Services.Protocols.SoapHeaderAttribute("UserContextualInfoSoapHeaderValue")]
        [System.Web.Services.Protocols.SoapHeaderAttribute("OnBehalfOfSoapHeaderValue")]
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.GetProvisioningInfo", RequestNamespace = "http://tempuri.org/message/", ResponseNamespace = "http://tempuri.org/message/")]
        public void GetProvisioningInfo(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string ObjectId, string BeginDate, string EndDate, int lTargetUserIdHigh, int lTargetUserIdLow, int nDetailLevel, out string ProvisioningInfoXml)
        {
            object[] results = this.Invoke("GetProvisioningInfo", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    ObjectId,
                    BeginDate,
                    EndDate,
                    lTargetUserIdHigh,
                    lTargetUserIdLow,
                    nDetailLevel});
            ProvisioningInfoXml = ((string)(results[0]));
        }

        /// <remarks/>
        public System.IAsyncResult BeginGetProvisioningInfo(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string ObjectId, string BeginDate, string EndDate, int lTargetUserIdHigh, int lTargetUserIdLow, int nDetailLevel, System.AsyncCallback callback, object asyncState)
        {
            return this.BeginInvoke("GetProvisioningInfo", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    ObjectId,
                    BeginDate,
                    EndDate,
                    lTargetUserIdHigh,
                    lTargetUserIdLow,
                    nDetailLevel}, callback, asyncState);
        }

        /// <remarks/>
        public void EndGetProvisioningInfo(System.IAsyncResult asyncResult, out string ProvisioningInfoXml)
        {
            object[] results = this.EndInvoke(asyncResult);
            ProvisioningInfoXml = ((string)(results[0]));
        }

        /// <remarks/>
        public void GetProvisioningInfoAsync(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string ObjectId, string BeginDate, string EndDate, int lTargetUserIdHigh, int lTargetUserIdLow, int nDetailLevel)
        {
            this.GetProvisioningInfoAsync(lDelegateIdHigh, lDelegateIdLow, lRequesterIdHigh, lRequesterIdLow, ObjectId, BeginDate, EndDate, lTargetUserIdHigh, lTargetUserIdLow, nDetailLevel, null);
        }

        /// <remarks/>
        public void GetProvisioningInfoAsync(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string ObjectId, string BeginDate, string EndDate, int lTargetUserIdHigh, int lTargetUserIdLow, int nDetailLevel, object userState)
        {
            if ((this.GetProvisioningInfoOperationCompleted == null))
            {
                this.GetProvisioningInfoOperationCompleted = new System.Threading.SendOrPostCallback(this.OnGetProvisioningInfoOperationCompleted);
            }
            this.InvokeAsync("GetProvisioningInfo", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    ObjectId,
                    BeginDate,
                    EndDate,
                    lTargetUserIdHigh,
                    lTargetUserIdLow,
                    nDetailLevel}, this.GetProvisioningInfoOperationCompleted, userState);
        }

        private void OnGetProvisioningInfoOperationCompleted(object arg)
        {
            if ((this.GetProvisioningInfoCompleted != null))
            {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.GetProvisioningInfoCompleted(this, new GetProvisioningInfoCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }

        /// <remarks/>
        [System.Web.Services.Protocols.SoapHeaderAttribute("UserContextualInfoSoapHeaderValue")]
        [System.Web.Services.Protocols.SoapHeaderAttribute("OnBehalfOfSoapHeaderValue")]
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.GetReferralData", RequestNamespace = "http://tempuri.org/message/", ResponseNamespace = "http://tempuri.org/message/")]
        public void GetReferralData(int lDelegateIdHigh, int lDelegateIdLow, string bstrSubscriptionId, out string pbstrErrorXML, out int plReferralCount, out string pbstrReferralSetXML)
        {
            object[] results = this.Invoke("GetReferralData", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrSubscriptionId});
            pbstrErrorXML = ((string)(results[0]));
            plReferralCount = ((int)(results[1]));
            pbstrReferralSetXML = ((string)(results[2]));
        }

        /// <remarks/>
        public System.IAsyncResult BeginGetReferralData(int lDelegateIdHigh, int lDelegateIdLow, string bstrSubscriptionId, System.AsyncCallback callback, object asyncState)
        {
            return this.BeginInvoke("GetReferralData", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrSubscriptionId}, callback, asyncState);
        }

        /// <remarks/>
        public void EndGetReferralData(System.IAsyncResult asyncResult, out string pbstrErrorXML, out int plReferralCount, out string pbstrReferralSetXML)
        {
            object[] results = this.EndInvoke(asyncResult);
            pbstrErrorXML = ((string)(results[0]));
            plReferralCount = ((int)(results[1]));
            pbstrReferralSetXML = ((string)(results[2]));
        }

        /// <remarks/>
        public void GetReferralDataAsync(int lDelegateIdHigh, int lDelegateIdLow, string bstrSubscriptionId)
        {
            this.GetReferralDataAsync(lDelegateIdHigh, lDelegateIdLow, bstrSubscriptionId, null);
        }

        /// <remarks/>
        public void GetReferralDataAsync(int lDelegateIdHigh, int lDelegateIdLow, string bstrSubscriptionId, object userState)
        {
            if ((this.GetReferralDataOperationCompleted == null))
            {
                this.GetReferralDataOperationCompleted = new System.Threading.SendOrPostCallback(this.OnGetReferralDataOperationCompleted);
            }
            this.InvokeAsync("GetReferralData", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    bstrSubscriptionId}, this.GetReferralDataOperationCompleted, userState);
        }

        private void OnGetReferralDataOperationCompleted(object arg)
        {
            if ((this.GetReferralDataCompleted != null))
            {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.GetReferralDataCompleted(this, new GetReferralDataCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }

        /// <remarks/>
        [System.Web.Services.Protocols.SoapHeaderAttribute("UserContextualInfoSoapHeaderValue")]
        [System.Web.Services.Protocols.SoapHeaderAttribute("OnBehalfOfSoapHeaderValue")]
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.GetReferralEvents", RequestNamespace = "http://tempuri.org/message/", ResponseNamespace = "http://tempuri.org/message/")]
        public void GetReferralEvents(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string AccountId, string SessionKey, out string ReferralEventsInfoXML)
        {
            object[] results = this.Invoke("GetReferralEvents", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    AccountId,
                    SessionKey});
            ReferralEventsInfoXML = ((string)(results[0]));
        }

        /// <remarks/>
        public System.IAsyncResult BeginGetReferralEvents(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string AccountId, string SessionKey, System.AsyncCallback callback, object asyncState)
        {
            return this.BeginInvoke("GetReferralEvents", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    AccountId,
                    SessionKey}, callback, asyncState);
        }

        /// <remarks/>
        public void EndGetReferralEvents(System.IAsyncResult asyncResult, out string ReferralEventsInfoXML)
        {
            object[] results = this.EndInvoke(asyncResult);
            ReferralEventsInfoXML = ((string)(results[0]));
        }

        /// <remarks/>
        public void GetReferralEventsAsync(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string AccountId, string SessionKey)
        {
            this.GetReferralEventsAsync(lDelegateIdHigh, lDelegateIdLow, lRequesterIdHigh, lRequesterIdLow, AccountId, SessionKey, null);
        }

        /// <remarks/>
        public void GetReferralEventsAsync(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string AccountId, string SessionKey, object userState)
        {
            if ((this.GetReferralEventsOperationCompleted == null))
            {
                this.GetReferralEventsOperationCompleted = new System.Threading.SendOrPostCallback(this.OnGetReferralEventsOperationCompleted);
            }
            this.InvokeAsync("GetReferralEvents", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    AccountId,
                    SessionKey}, this.GetReferralEventsOperationCompleted, userState);
        }

        private void OnGetReferralEventsOperationCompleted(object arg)
        {
            if ((this.GetReferralEventsCompleted != null))
            {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.GetReferralEventsCompleted(this, new GetReferralEventsCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }

        /// <remarks/>
        [System.Web.Services.Protocols.SoapHeaderAttribute("UserContextualInfoSoapHeaderValue")]
        [System.Web.Services.Protocols.SoapHeaderAttribute("OnBehalfOfSoapHeaderValue")]
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.GetResourceBalances", RequestNamespace = "http://tempuri.org/message/", ResponseNamespace = "http://tempuri.org/message/")]
        public void GetResourceBalances(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrObjectId, string bstrResourceGUID, out string pbstrErrorText, out int pcResourceInfoCount, out string pbstrResourceInfoSet)
        {
            object[] results = this.Invoke("GetResourceBalances", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrObjectId,
                    bstrResourceGUID});
            pbstrErrorText = ((string)(results[0]));
            pcResourceInfoCount = ((int)(results[1]));
            pbstrResourceInfoSet = ((string)(results[2]));
        }

        /// <remarks/>
        public System.IAsyncResult BeginGetResourceBalances(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrObjectId, string bstrResourceGUID, System.AsyncCallback callback, object asyncState)
        {
            return this.BeginInvoke("GetResourceBalances", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrObjectId,
                    bstrResourceGUID}, callback, asyncState);
        }

        /// <remarks/>
        public void EndGetResourceBalances(System.IAsyncResult asyncResult, out string pbstrErrorText, out int pcResourceInfoCount, out string pbstrResourceInfoSet)
        {
            object[] results = this.EndInvoke(asyncResult);
            pbstrErrorText = ((string)(results[0]));
            pcResourceInfoCount = ((int)(results[1]));
            pbstrResourceInfoSet = ((string)(results[2]));
        }

        /// <remarks/>
        public void GetResourceBalancesAsync(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrObjectId, string bstrResourceGUID)
        {
            this.GetResourceBalancesAsync(lDelegateIdHigh, lDelegateIdLow, lRequesterIdHigh, lRequesterIdLow, bstrObjectId, bstrResourceGUID, null);
        }

        /// <remarks/>
        public void GetResourceBalancesAsync(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrObjectId, string bstrResourceGUID, object userState)
        {
            if ((this.GetResourceBalancesOperationCompleted == null))
            {
                this.GetResourceBalancesOperationCompleted = new System.Threading.SendOrPostCallback(this.OnGetResourceBalancesOperationCompleted);
            }
            this.InvokeAsync("GetResourceBalances", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrObjectId,
                    bstrResourceGUID}, this.GetResourceBalancesOperationCompleted, userState);
        }

        private void OnGetResourceBalancesOperationCompleted(object arg)
        {
            if ((this.GetResourceBalancesCompleted != null))
            {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.GetResourceBalancesCompleted(this, new GetResourceBalancesCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }

        /// <remarks/>
        [System.Web.Services.Protocols.SoapHeaderAttribute("UserContextualInfoSoapHeaderValue")]
        [System.Web.Services.Protocols.SoapHeaderAttribute("OnBehalfOfSoapHeaderValue")]
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.GetReplacementToken", RequestNamespace = "http://tempuri.org/message/", ResponseNamespace = "http://tempuri.org/message/")]
        public void GetReplacementToken(int delegateIdHigh, int delegateIdLow, int replacementPuidHigh, int replacementPuidLow, int replacementReasonCode, string token, int tokenType, int tokenSignature, string emailAddress, string sessionKey, string trackingGuid, out string replacementPin, out int signature, out string sequenceNumber)
        {
            object[] results = this.Invoke("GetReplacementToken", new object[] {
                    delegateIdHigh,
                    delegateIdLow,
                    replacementPuidHigh,
                    replacementPuidLow,
                    replacementReasonCode,
                    token,
                    tokenType,
                    tokenSignature,
                    emailAddress,
                    sessionKey,
                    trackingGuid});
            replacementPin = ((string)(results[0]));
            signature = ((int)(results[1]));
            sequenceNumber = ((string)(results[2]));
        }

        /// <remarks/>
        public System.IAsyncResult BeginGetReplacementToken(int delegateIdHigh, int delegateIdLow, int replacementPuidHigh, int replacementPuidLow, int replacementReasonCode, string token, int tokenType, int tokenSignature, string emailAddress, string sessionKey, string trackingGuid, System.AsyncCallback callback, object asyncState)
        {
            return this.BeginInvoke("GetReplacementToken", new object[] {
                    delegateIdHigh,
                    delegateIdLow,
                    replacementPuidHigh,
                    replacementPuidLow,
                    replacementReasonCode,
                    token,
                    tokenType,
                    tokenSignature,
                    emailAddress,
                    sessionKey,
                    trackingGuid}, callback, asyncState);
        }

        /// <remarks/>
        public void EndGetReplacementToken(System.IAsyncResult asyncResult, out string replacementPin, out int signature, out string sequenceNumber)
        {
            object[] results = this.EndInvoke(asyncResult);
            replacementPin = ((string)(results[0]));
            signature = ((int)(results[1]));
            sequenceNumber = ((string)(results[2]));
        }

        /// <remarks/>
        public void GetReplacementTokenAsync(int delegateIdHigh, int delegateIdLow, int replacementPuidHigh, int replacementPuidLow, int replacementReasonCode, string token, int tokenType, int tokenSignature, string emailAddress, string sessionKey, string trackingGuid)
        {
            this.GetReplacementTokenAsync(delegateIdHigh, delegateIdLow, replacementPuidHigh, replacementPuidLow, replacementReasonCode, token, tokenType, tokenSignature, emailAddress, sessionKey, trackingGuid, null);
        }

        /// <remarks/>
        public void GetReplacementTokenAsync(int delegateIdHigh, int delegateIdLow, int replacementPuidHigh, int replacementPuidLow, int replacementReasonCode, string token, int tokenType, int tokenSignature, string emailAddress, string sessionKey, string trackingGuid, object userState)
        {
            if ((this.GetReplacementTokenOperationCompleted == null))
            {
                this.GetReplacementTokenOperationCompleted = new System.Threading.SendOrPostCallback(this.OnGetReplacementTokenOperationCompleted);
            }
            this.InvokeAsync("GetReplacementToken", new object[] {
                    delegateIdHigh,
                    delegateIdLow,
                    replacementPuidHigh,
                    replacementPuidLow,
                    replacementReasonCode,
                    token,
                    tokenType,
                    tokenSignature,
                    emailAddress,
                    sessionKey,
                    trackingGuid}, this.GetReplacementTokenOperationCompleted, userState);
        }

        private void OnGetReplacementTokenOperationCompleted(object arg)
        {
            if ((this.GetReplacementTokenCompleted != null))
            {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.GetReplacementTokenCompleted(this, new GetReplacementTokenCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }

        /// <remarks/>
        [System.Web.Services.Protocols.SoapHeaderAttribute("UserContextualInfoSoapHeaderValue")]
        [System.Web.Services.Protocols.SoapHeaderAttribute("OnBehalfOfSoapHeaderValue")]
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.GetReplacementTokenFromPuid", RequestNamespace = "http://tempuri.org/message/", ResponseNamespace = "http://tempuri.org/message/")]
        public void GetReplacementTokenFromPuid(int delegateIdHigh, int delegateIdLow, int searchPuidHigh, int searchPuidLow, out int tokenInfoReturnedCount, out string replacementTokenSetXml)
        {
            object[] results = this.Invoke("GetReplacementTokenFromPuid", new object[] {
                    delegateIdHigh,
                    delegateIdLow,
                    searchPuidHigh,
                    searchPuidLow});
            tokenInfoReturnedCount = ((int)(results[0]));
            replacementTokenSetXml = ((string)(results[1]));
        }

        /// <remarks/>
        public System.IAsyncResult BeginGetReplacementTokenFromPuid(int delegateIdHigh, int delegateIdLow, int searchPuidHigh, int searchPuidLow, System.AsyncCallback callback, object asyncState)
        {
            return this.BeginInvoke("GetReplacementTokenFromPuid", new object[] {
                    delegateIdHigh,
                    delegateIdLow,
                    searchPuidHigh,
                    searchPuidLow}, callback, asyncState);
        }

        /// <remarks/>
        public void EndGetReplacementTokenFromPuid(System.IAsyncResult asyncResult, out int tokenInfoReturnedCount, out string replacementTokenSetXml)
        {
            object[] results = this.EndInvoke(asyncResult);
            tokenInfoReturnedCount = ((int)(results[0]));
            replacementTokenSetXml = ((string)(results[1]));
        }

        /// <remarks/>
        public void GetReplacementTokenFromPuidAsync(int delegateIdHigh, int delegateIdLow, int searchPuidHigh, int searchPuidLow)
        {
            this.GetReplacementTokenFromPuidAsync(delegateIdHigh, delegateIdLow, searchPuidHigh, searchPuidLow, null);
        }

        /// <remarks/>
        public void GetReplacementTokenFromPuidAsync(int delegateIdHigh, int delegateIdLow, int searchPuidHigh, int searchPuidLow, object userState)
        {
            if ((this.GetReplacementTokenFromPuidOperationCompleted == null))
            {
                this.GetReplacementTokenFromPuidOperationCompleted = new System.Threading.SendOrPostCallback(this.OnGetReplacementTokenFromPuidOperationCompleted);
            }
            this.InvokeAsync("GetReplacementTokenFromPuid", new object[] {
                    delegateIdHigh,
                    delegateIdLow,
                    searchPuidHigh,
                    searchPuidLow}, this.GetReplacementTokenFromPuidOperationCompleted, userState);
        }

        private void OnGetReplacementTokenFromPuidOperationCompleted(object arg)
        {
            if ((this.GetReplacementTokenFromPuidCompleted != null))
            {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.GetReplacementTokenFromPuidCompleted(this, new GetReplacementTokenFromPuidCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }

        /// <remarks/>
        [System.Web.Services.Protocols.SoapHeaderAttribute("UserContextualInfoSoapHeaderValue")]
        [System.Web.Services.Protocols.SoapHeaderAttribute("OnBehalfOfSoapHeaderValue")]
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.GetResourcePrices", RequestNamespace = "http://tempuri.org/message/", ResponseNamespace = "http://tempuri.org/message/")]
        public void GetResourcePrices(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrSubscriptionId, string bstrOfferingGUID, out string pbstrErrorXML, out int plCount, out string pbstrResourcePriceSetXML)
        {
            object[] results = this.Invoke("GetResourcePrices", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrSubscriptionId,
                    bstrOfferingGUID});
            pbstrErrorXML = ((string)(results[0]));
            plCount = ((int)(results[1]));
            pbstrResourcePriceSetXML = ((string)(results[2]));
        }

        /// <remarks/>
        public System.IAsyncResult BeginGetResourcePrices(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrSubscriptionId, string bstrOfferingGUID, System.AsyncCallback callback, object asyncState)
        {
            return this.BeginInvoke("GetResourcePrices", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrSubscriptionId,
                    bstrOfferingGUID}, callback, asyncState);
        }

        /// <remarks/>
        public void EndGetResourcePrices(System.IAsyncResult asyncResult, out string pbstrErrorXML, out int plCount, out string pbstrResourcePriceSetXML)
        {
            object[] results = this.EndInvoke(asyncResult);
            pbstrErrorXML = ((string)(results[0]));
            plCount = ((int)(results[1]));
            pbstrResourcePriceSetXML = ((string)(results[2]));
        }

        /// <remarks/>
        public void GetResourcePricesAsync(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrSubscriptionId, string bstrOfferingGUID)
        {
            this.GetResourcePricesAsync(lDelegateIdHigh, lDelegateIdLow, lRequesterIdHigh, lRequesterIdLow, bstrSubscriptionId, bstrOfferingGUID, null);
        }

        /// <remarks/>
        public void GetResourcePricesAsync(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrSubscriptionId, string bstrOfferingGUID, object userState)
        {
            if ((this.GetResourcePricesOperationCompleted == null))
            {
                this.GetResourcePricesOperationCompleted = new System.Threading.SendOrPostCallback(this.OnGetResourcePricesOperationCompleted);
            }
            this.InvokeAsync("GetResourcePrices", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrSubscriptionId,
                    bstrOfferingGUID}, this.GetResourcePricesOperationCompleted, userState);
        }

        private void OnGetResourcePricesOperationCompleted(object arg)
        {
            if ((this.GetResourcePricesCompleted != null))
            {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.GetResourcePricesCompleted(this, new GetResourcePricesCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }

        /// <remarks/>
        [System.Web.Services.Protocols.SoapHeaderAttribute("UserContextualInfoSoapHeaderValue")]
        [System.Web.Services.Protocols.SoapHeaderAttribute("OnBehalfOfSoapHeaderValue")]
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.GetStatement", RequestNamespace = "http://tempuri.org/message/", ResponseNamespace = "http://tempuri.org/message/")]
        public void GetStatement(int delegateIdHigh, int delegateIdLow, int requesterIdHigh, int requesterIdLow, string objectId, uint beginBillingPeriodId, uint endBillingPeriodId, byte returnStatementSet, bool returnNotificationSet, out string errorXml, out string accountStatementInfoSetXml, out string userNotificationSetXml)
        {
            object[] results = this.Invoke("GetStatement", new object[] {
                    delegateIdHigh,
                    delegateIdLow,
                    requesterIdHigh,
                    requesterIdLow,
                    objectId,
                    beginBillingPeriodId,
                    endBillingPeriodId,
                    returnStatementSet,
                    returnNotificationSet});
            errorXml = ((string)(results[0]));
            accountStatementInfoSetXml = ((string)(results[1]));
            userNotificationSetXml = ((string)(results[2]));
        }

        /// <remarks/>
        public System.IAsyncResult BeginGetStatement(int delegateIdHigh, int delegateIdLow, int requesterIdHigh, int requesterIdLow, string objectId, uint beginBillingPeriodId, uint endBillingPeriodId, byte returnStatementSet, bool returnNotificationSet, System.AsyncCallback callback, object asyncState)
        {
            return this.BeginInvoke("GetStatement", new object[] {
                    delegateIdHigh,
                    delegateIdLow,
                    requesterIdHigh,
                    requesterIdLow,
                    objectId,
                    beginBillingPeriodId,
                    endBillingPeriodId,
                    returnStatementSet,
                    returnNotificationSet}, callback, asyncState);
        }

        /// <remarks/>
        public void EndGetStatement(System.IAsyncResult asyncResult, out string errorXml, out string accountStatementInfoSetXml, out string userNotificationSetXml)
        {
            object[] results = this.EndInvoke(asyncResult);
            errorXml = ((string)(results[0]));
            accountStatementInfoSetXml = ((string)(results[1]));
            userNotificationSetXml = ((string)(results[2]));
        }

        /// <remarks/>
        public void GetStatementAsync(int delegateIdHigh, int delegateIdLow, int requesterIdHigh, int requesterIdLow, string objectId, uint beginBillingPeriodId, uint endBillingPeriodId, byte returnStatementSet, bool returnNotificationSet)
        {
            this.GetStatementAsync(delegateIdHigh, delegateIdLow, requesterIdHigh, requesterIdLow, objectId, beginBillingPeriodId, endBillingPeriodId, returnStatementSet, returnNotificationSet, null);
        }

        /// <remarks/>
        public void GetStatementAsync(int delegateIdHigh, int delegateIdLow, int requesterIdHigh, int requesterIdLow, string objectId, uint beginBillingPeriodId, uint endBillingPeriodId, byte returnStatementSet, bool returnNotificationSet, object userState)
        {

            if ((this.GetStatementOperationCompleted == null))
            {
                this.GetStatementOperationCompleted = new System.Threading.SendOrPostCallback(this.OnGetStatementOperationCompleted);
            }
            this.InvokeAsync("GetStatement", new object[] {
                    delegateIdHigh,
                    delegateIdLow,
                    requesterIdHigh,
                    requesterIdLow,
                    objectId,
                    beginBillingPeriodId,
                    endBillingPeriodId,
                    returnStatementSet,
                    returnNotificationSet}, this.GetStatementOperationCompleted, userState);
        }

        private void OnGetStatementOperationCompleted(object arg)
        {
            if ((this.GetStatementCompleted != null))
            {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.GetStatementCompleted(this, new GetStatementCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }

        /// <remarks/>
        [System.Web.Services.Protocols.SoapHeaderAttribute("UserContextualInfoSoapHeaderValue")]
        [System.Web.Services.Protocols.SoapHeaderAttribute("OnBehalfOfSoapHeaderValue")]
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.GetStatementEx", RequestNamespace = "http://tempuri.org/message/", ResponseNamespace = "http://tempuri.org/message/")]
        public void GetStatementEx(int delegateIdHigh, int delegateIdLow, int requesterIdHigh, int requesterIdLow, string objectId, uint beginBillingPeriodId, uint endBillingPeriodId, byte returnStatementSet, bool returnNotificationSet, string orderId, out string errorXml, out string accountStatementInfoSetXml, out string userNotificationSetXml)
        {
            object[] results = this.Invoke("GetStatementEx", new object[] {
                    delegateIdHigh,
                    delegateIdLow,
                    requesterIdHigh,
                    requesterIdLow,
                    objectId,
                    beginBillingPeriodId,
                    endBillingPeriodId,
                    returnStatementSet,
                    returnNotificationSet,
                    orderId});
            errorXml = ((string)(results[0]));
            accountStatementInfoSetXml = ((string)(results[1]));
            userNotificationSetXml = ((string)(results[2]));
        }

        /// <remarks/>
        public System.IAsyncResult BeginGetStatementEx(int delegateIdHigh, int delegateIdLow, int requesterIdHigh, int requesterIdLow, string objectId, uint beginBillingPeriodId, uint endBillingPeriodId, byte returnStatementSet, bool returnNotificationSet, string orderId, System.AsyncCallback callback, object asyncState)
        {
            return this.BeginInvoke("GetStatementEx", new object[] {
                    delegateIdHigh,
                    delegateIdLow,
                    requesterIdHigh,
                    requesterIdLow,
                    objectId,
                    beginBillingPeriodId,
                    endBillingPeriodId,
                    returnStatementSet,
                    returnNotificationSet,
                    orderId}, callback, asyncState);
        }

        /// <remarks/>
        public void EndGetStatementEx(System.IAsyncResult asyncResult, out string errorXml, out string accountStatementInfoSetXml, out string userNotificationSetXml)
        {
            object[] results = this.EndInvoke(asyncResult);
            errorXml = ((string)(results[0]));
            accountStatementInfoSetXml = ((string)(results[1]));
            userNotificationSetXml = ((string)(results[2]));
        }

        /// <remarks/>
        public void GetStatementExAsync(int delegateIdHigh, int delegateIdLow, int requesterIdHigh, int requesterIdLow, string objectId, uint beginBillingPeriodId, uint endBillingPeriodId, byte returnStatementSet, bool returnNotificationSet, string orderId)
        {

            this.GetStatementExAsync(delegateIdHigh, delegateIdLow, requesterIdHigh, requesterIdLow, objectId, beginBillingPeriodId, endBillingPeriodId, returnStatementSet, returnNotificationSet, orderId, null);
        }

        /// <remarks/>
        public void GetStatementExAsync(int delegateIdHigh, int delegateIdLow, int requesterIdHigh, int requesterIdLow, string objectId, uint beginBillingPeriodId, uint endBillingPeriodId, byte returnStatementSet, bool returnNotificationSet, string orderId, object userState)
        {
            if ((this.GetStatementExOperationCompleted == null))
            {
                this.GetStatementExOperationCompleted = new System.Threading.SendOrPostCallback(this.OnGetStatementExOperationCompleted);
            }
            this.InvokeAsync("GetStatementEx", new object[] {
                    delegateIdHigh,
                    delegateIdLow,
                    requesterIdHigh,
                    requesterIdLow,
                    objectId,
                    beginBillingPeriodId,
                    endBillingPeriodId,
                    returnStatementSet,
                    returnNotificationSet,
                    orderId}, this.GetStatementExOperationCompleted, userState);
        }

        private void OnGetStatementExOperationCompleted(object arg)
        {
            if ((this.GetStatementExCompleted != null))
            {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.GetStatementExCompleted(this, new GetStatementExCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }

        /// <remarks/>
        [System.Web.Services.Protocols.SoapHeaderAttribute("UserContextualInfoSoapHeaderValue")]
        [System.Web.Services.Protocols.SoapHeaderAttribute("OnBehalfOfSoapHeaderValue")]
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.GetSubscriptionHistory", RequestNamespace = "http://tempuri.org/message/", ResponseNamespace = "http://tempuri.org/message/")]
        public void GetSubscriptionHistory(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrSubscriptionId, out string pbstrErrorXML, out int plHistoryEventCount, out string pbstrSubscriptionHistoryEventSetXML)
        {
            object[] results = this.Invoke("GetSubscriptionHistory", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrSubscriptionId});
            pbstrErrorXML = ((string)(results[0]));
            plHistoryEventCount = ((int)(results[1]));
            pbstrSubscriptionHistoryEventSetXML = ((string)(results[2]));
        }

        /// <remarks/>
        public System.IAsyncResult BeginGetSubscriptionHistory(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrSubscriptionId, System.AsyncCallback callback, object asyncState)
        {
            return this.BeginInvoke("GetSubscriptionHistory", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrSubscriptionId}, callback, asyncState);
        }

        /// <remarks/>
        public void EndGetSubscriptionHistory(System.IAsyncResult asyncResult, out string pbstrErrorXML, out int plHistoryEventCount, out string pbstrSubscriptionHistoryEventSetXML)
        {
            object[] results = this.EndInvoke(asyncResult);
            pbstrErrorXML = ((string)(results[0]));
            plHistoryEventCount = ((int)(results[1]));
            pbstrSubscriptionHistoryEventSetXML = ((string)(results[2]));
        }

        /// <remarks/>
        public void GetSubscriptionHistoryAsync(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrSubscriptionId)
        {
            this.GetSubscriptionHistoryAsync(lDelegateIdHigh, lDelegateIdLow, lRequesterIdHigh, lRequesterIdLow, bstrSubscriptionId, null);
        }

        /// <remarks/>
        public void GetSubscriptionHistoryAsync(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrSubscriptionId, object userState)
        {
            if ((this.GetSubscriptionHistoryOperationCompleted == null))
            {
                this.GetSubscriptionHistoryOperationCompleted = new System.Threading.SendOrPostCallback(this.OnGetSubscriptionHistoryOperationCompleted);
            }
            this.InvokeAsync("GetSubscriptionHistory", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrSubscriptionId}, this.GetSubscriptionHistoryOperationCompleted, userState);
        }

        private void OnGetSubscriptionHistoryOperationCompleted(object arg)
        {
            if ((this.GetSubscriptionHistoryCompleted != null))
            {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.GetSubscriptionHistoryCompleted(this, new GetSubscriptionHistoryCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }

        /// <remarks/>
        [System.Web.Services.Protocols.SoapHeaderAttribute("UserContextualInfoSoapHeaderValue")]
        [System.Web.Services.Protocols.SoapHeaderAttribute("OnBehalfOfSoapHeaderValue")]
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.GetServiceComponents", RequestNamespace = "http://tempuri.org/message/", ResponseNamespace = "http://tempuri.org/message/")]
        public void GetServiceComponents(string bstrOfferingGUID, out string pbstrErrorText, out int plServiceComponentCount, out string pbstrServiceComponentSetXML)
        {
            object[] results = this.Invoke("GetServiceComponents", new object[] {
                    bstrOfferingGUID});
            pbstrErrorText = ((string)(results[0]));
            plServiceComponentCount = ((int)(results[1]));
            pbstrServiceComponentSetXML = ((string)(results[2]));
        }

        /// <remarks/>
        public System.IAsyncResult BeginGetServiceComponents(string bstrOfferingGUID, System.AsyncCallback callback, object asyncState)
        {
            return this.BeginInvoke("GetServiceComponents", new object[] {
                    bstrOfferingGUID}, callback, asyncState);
        }

        /// <remarks/>
        public void EndGetServiceComponents(System.IAsyncResult asyncResult, out string pbstrErrorText, out int plServiceComponentCount, out string pbstrServiceComponentSetXML)
        {
            object[] results = this.EndInvoke(asyncResult);
            pbstrErrorText = ((string)(results[0]));
            plServiceComponentCount = ((int)(results[1]));
            pbstrServiceComponentSetXML = ((string)(results[2]));
        }

        /// <remarks/>
        public void GetServiceComponentsAsync(string bstrOfferingGUID)
        {
            this.GetServiceComponentsAsync(bstrOfferingGUID, null);
        }

        /// <remarks/>
        public void GetServiceComponentsAsync(string bstrOfferingGUID, object userState)
        {
            if ((this.GetServiceComponentsOperationCompleted == null))
            {
                this.GetServiceComponentsOperationCompleted = new System.Threading.SendOrPostCallback(this.OnGetServiceComponentsOperationCompleted);
            }
            this.InvokeAsync("GetServiceComponents", new object[] {
                    bstrOfferingGUID}, this.GetServiceComponentsOperationCompleted, userState);
        }

        private void OnGetServiceComponentsOperationCompleted(object arg)
        {
            if ((this.GetServiceComponentsCompleted != null))
            {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.GetServiceComponentsCompleted(this, new GetServiceComponentsCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }

        /// <remarks/>
        [System.Web.Services.Protocols.SoapHeaderAttribute("UserContextualInfoSoapHeaderValue")]
        [System.Web.Services.Protocols.SoapHeaderAttribute("OnBehalfOfSoapHeaderValue")]
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.GetSubscriptions", RequestNamespace = "http://tempuri.org/message/", ResponseNamespace = "http://tempuri.org/message/")]
        public void GetSubscriptions(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrObjectId, out string pbstrErrorXML, out int plSubscriptionInfoCount, out string pbstrSubscriptionInfoSetXML)
        {
            object[] results = this.Invoke("GetSubscriptions", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrObjectId});
            pbstrErrorXML = ((string)(results[0]));
            plSubscriptionInfoCount = ((int)(results[1]));
            pbstrSubscriptionInfoSetXML = ((string)(results[2]));
        }

        /// <remarks/>
        public System.IAsyncResult BeginGetSubscriptions(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrObjectId, System.AsyncCallback callback, object asyncState)
        {
            return this.BeginInvoke("GetSubscriptions", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrObjectId}, callback, asyncState);
        }

        /// <remarks/>
        public void EndGetSubscriptions(System.IAsyncResult asyncResult, out string pbstrErrorXML, out int plSubscriptionInfoCount, out string pbstrSubscriptionInfoSetXML)
        {
            object[] results = this.EndInvoke(asyncResult);
            pbstrErrorXML = ((string)(results[0]));
            plSubscriptionInfoCount = ((int)(results[1]));
            pbstrSubscriptionInfoSetXML = ((string)(results[2]));
        }

        /// <remarks/>
        public void GetSubscriptionsAsync(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrObjectId)
        {
            this.GetSubscriptionsAsync(lDelegateIdHigh, lDelegateIdLow, lRequesterIdHigh, lRequesterIdLow, bstrObjectId, null);
        }

        /// <remarks/>
        public void GetSubscriptionsAsync(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrObjectId, object userState)
        {
            if ((this.GetSubscriptionsOperationCompleted == null))
            {
                this.GetSubscriptionsOperationCompleted = new System.Threading.SendOrPostCallback(this.OnGetSubscriptionsOperationCompleted);
            }
            this.InvokeAsync("GetSubscriptions", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrObjectId}, this.GetSubscriptionsOperationCompleted, userState);
        }

        private void OnGetSubscriptionsOperationCompleted(object arg)
        {
            if ((this.GetSubscriptionsCompleted != null))
            {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.GetSubscriptionsCompleted(this, new GetSubscriptionsCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }

        /// <remarks/>
        [System.Web.Services.Protocols.SoapHeaderAttribute("UserContextualInfoSoapHeaderValue")]
        [System.Web.Services.Protocols.SoapHeaderAttribute("OnBehalfOfSoapHeaderValue")]
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.GetSubscriptionStatus", RequestNamespace = "http://tempuri.org/message/", ResponseNamespace = "http://tempuri.org/message/")]
        public void GetSubscriptionStatus(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrSubscriptionId, out string pbstrErrorXML, out string pbstrSubscriptionStatusInfoXML)
        {
            object[] results = this.Invoke("GetSubscriptionStatus", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrSubscriptionId});
            pbstrErrorXML = ((string)(results[0]));
            pbstrSubscriptionStatusInfoXML = ((string)(results[1]));
        }

        /// <remarks/>
        public System.IAsyncResult BeginGetSubscriptionStatus(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrSubscriptionId, System.AsyncCallback callback, object asyncState)
        {
            return this.BeginInvoke("GetSubscriptionStatus", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrSubscriptionId}, callback, asyncState);
        }

        /// <remarks/>
        public void EndGetSubscriptionStatus(System.IAsyncResult asyncResult, out string pbstrErrorXML, out string pbstrSubscriptionStatusInfoXML)
        {
            object[] results = this.EndInvoke(asyncResult);
            pbstrErrorXML = ((string)(results[0]));
            pbstrSubscriptionStatusInfoXML = ((string)(results[1]));
        }

        /// <remarks/>
        public void GetSubscriptionStatusAsync(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrSubscriptionId)
        {
            this.GetSubscriptionStatusAsync(lDelegateIdHigh, lDelegateIdLow, lRequesterIdHigh, lRequesterIdLow, bstrSubscriptionId, null);
        }

        /// <remarks/>
        public void GetSubscriptionStatusAsync(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrSubscriptionId, object userState)
        {
            if ((this.GetSubscriptionStatusOperationCompleted == null))
            {
                this.GetSubscriptionStatusOperationCompleted = new System.Threading.SendOrPostCallback(this.OnGetSubscriptionStatusOperationCompleted);
            }
            this.InvokeAsync("GetSubscriptionStatus", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    bstrSubscriptionId}, this.GetSubscriptionStatusOperationCompleted, userState);
        }

        private void OnGetSubscriptionStatusOperationCompleted(object arg)
        {
            if ((this.GetSubscriptionStatusCompleted != null))
            {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.GetSubscriptionStatusCompleted(this, new GetSubscriptionStatusCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }

        /// <remarks/>
        [System.Web.Services.Protocols.SoapHeaderAttribute("UserContextualInfoSoapHeaderValue")]
        [System.Web.Services.Protocols.SoapHeaderAttribute("OnBehalfOfSoapHeaderValue")]
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.GetTokenClassRestrictionInfoForPUID", RequestNamespace = "http://tempuri.org/message/", ResponseNamespace = "http://tempuri.org/message/")]
        public void GetTokenClassRestrictionInfoForPUID(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string tokenClassRestrictionInfoFilterXML, out string tokenClassRestrictionInfoSetXML)
        {
            object[] results = this.Invoke("GetTokenClassRestrictionInfoForPUID", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    tokenClassRestrictionInfoFilterXML});
            tokenClassRestrictionInfoSetXML = ((string)(results[0]));
        }

        /// <remarks/>
        public System.IAsyncResult BeginGetTokenClassRestrictionInfoForPUID(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string tokenClassRestrictionInfoFilterXML, System.AsyncCallback callback, object asyncState)
        {
            return this.BeginInvoke("GetTokenClassRestrictionInfoForPUID", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    tokenClassRestrictionInfoFilterXML}, callback, asyncState);
        }

        /// <remarks/>
        public void EndGetTokenClassRestrictionInfoForPUID(System.IAsyncResult asyncResult, out string tokenClassRestrictionInfoSetXML)
        {
            object[] results = this.EndInvoke(asyncResult);
            tokenClassRestrictionInfoSetXML = ((string)(results[0]));
        }

        /// <remarks/>
        public void GetTokenClassRestrictionInfoForPUIDAsync(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string tokenClassRestrictionInfoFilterXML)
        {
            this.GetTokenClassRestrictionInfoForPUIDAsync(lDelegateIdHigh, lDelegateIdLow, lRequesterIdHigh, lRequesterIdLow, tokenClassRestrictionInfoFilterXML, null);
        }

        /// <remarks/>
        public void GetTokenClassRestrictionInfoForPUIDAsync(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string tokenClassRestrictionInfoFilterXML, object userState)
        {
            if ((this.GetTokenClassRestrictionInfoForPUIDOperationCompleted == null))
            {
                this.GetTokenClassRestrictionInfoForPUIDOperationCompleted = new System.Threading.SendOrPostCallback(this.OnGetTokenClassRestrictionInfoForPUIDOperationCompleted);
            }
            this.InvokeAsync("GetTokenClassRestrictionInfoForPUID", new object[] {
                    lDelegateIdHigh,
                    lDelegateIdLow,
                    lRequesterIdHigh,
                    lRequesterIdLow,
                    tokenClassRestrictionInfoFilterXML}, this.GetTokenClassRestrictionInfoForPUIDOperationCompleted, userState);
        }

        private void OnGetTokenClassRestrictionInfoForPUIDOperationCompleted(object arg)
        {
            if ((this.GetTokenClassRestrictionInfoForPUIDCompleted != null))
            {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.GetTokenClassRestrictionInfoForPUIDCompleted(this, new GetTokenClassRestrictionInfoForPUIDCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }

        /// <remarks/>
        [System.Web.Services.Protocols.SoapHeaderAttribute("UserContextualInfoSoapHeaderValue")]
        [System.Web.Services.Protocols.SoapHeaderAttribute("OnBehalfOfSoapHeaderValue")]
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.GetTokenClasses", RequestNamespace = "http://tempuri.org/message/", ResponseNamespace = "http://tempuri.org/message/")]
        public void GetTokenClasses(string bstrProductClassGuidFilter, int lReturnCountMax, out int plAdditionalTokenClassCount, out int plTokenClassReturnedCount, out string pbstrTokenClassSetXML)
        {
            object[] results = this.Invoke("GetTokenClasses", new object[] {
                    bstrProductClassGuidFilter,
                    lReturnCountMax});
            plAdditionalTokenClassCount = ((int)(results[0]));
            plTokenClassReturnedCount = ((int)(results[1]));
            pbstrTokenClassSetXML = ((string)(results[2]));
        }

        /// <remarks/>
        public System.IAsyncResult BeginGetTokenClasses(string bstrProductClassGuidFilter, int lReturnCountMax, System.AsyncCallback callback, object asyncState)
        {
            return this.BeginInvoke("GetTokenClasses", new object[] {
                    bstrProductClassGuidFilter,
                    lReturnCountMax}, callback, asyncState);
        }

        /// <remarks/>
        public void EndGetTokenClasses(System.IAsyncResult asyncResult, out int plAdditionalTokenClassCount, out int plTokenClassReturnedCount, out string pbstrTokenClassSetXML)
        {
            object[] results = this.EndInvoke(asyncResult);
            plAdditionalTokenClassCount = ((int)(results[0]));
            plTokenClassReturnedCount = ((int)(results[1]));
            pbstrTokenClassSetXML = ((string)(results[2]));
        }

        /// <remarks/>
        public void GetTokenClassesAsync(string bstrProductClassGuidFilter, int lReturnCountMax)
        {
            this.GetTokenClassesAsync(bstrProductClassGuidFilter, lReturnCountMax, null);
        }

        /// <remarks/>
        public void GetTokenClassesAsync(string bstrProductClassGuidFilter, int lReturnCountMax, object userState)
        {
            if ((this.GetTokenClassesOperationCompleted == null))
            {
                this.GetTokenClassesOperationCompleted = new System.Threading.SendOrPostCallback(this.OnGetTokenClassesOperationCompleted);
            }
            this.InvokeAsync("GetTokenClasses", new object[] {
                    bstrProductClassGuidFilter,
                    lReturnCountMax}, this.GetTokenClassesOperationCompleted, userState);
        }

        private void OnGetTokenClassesOperationCompleted(object arg)
        {
            if ((this.GetTokenClassesCompleted != null))
            {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.GetTokenClassesCompleted(this, new GetTokenClassesCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }

        /// <remarks/>
        public new void CancelAsync(object userState)
        {
            base.CancelAsync(userState);
        }
    }

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.SoapTypeAttribute(Namespace = "http://tempuri.org/")]
    public partial class UserContextualInfoSoapHeader : SoapHeader
    {

        private string iPAddressField;

        private string deviceTypeField;

        private string deviceIdField;

        private string acceptLanguageField;

        private string acceptCharsetField;

        private string requestHeaderDateField;

        private string userAgentField;

        private string xForwardedForField;

        /// <remarks/>
        public string IPAddress
        {
            get
            {
                return this.iPAddressField;
            }
            set
            {
                this.iPAddressField = value;
            }
        }

        /// <remarks/>
        public string DeviceType
        {
            get
            {
                return this.deviceTypeField;
            }
            set
            {
                this.deviceTypeField = value;
            }
        }

        /// <remarks/>
        public string DeviceId
        {
            get
            {
                return this.deviceIdField;
            }
            set
            {
                this.deviceIdField = value;
            }
        }

        /// <remarks/>
        public string AcceptLanguage
        {
            get
            {
                return this.acceptLanguageField;
            }
            set
            {
                this.acceptLanguageField = value;
            }
        }

        /// <remarks/>
        public string AcceptCharset
        {
            get
            {
                return this.acceptCharsetField;
            }
            set
            {
                this.acceptCharsetField = value;
            }
        }

        /// <remarks/>
        public string RequestHeaderDate
        {
            get
            {
                return this.requestHeaderDateField;
            }
            set
            {
                this.requestHeaderDateField = value;
            }
        }

        /// <remarks/>
        public string UserAgent
        {
            get
            {
                return this.userAgentField;
            }
            set
            {
                this.userAgentField = value;
            }
        }

        /// <remarks/>
        public string XForwardedFor
        {
            get
            {
                return this.xForwardedForField;
            }
            set
            {
                this.xForwardedForField = value;
            }
        }
    }

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.SoapTypeAttribute(Namespace = "http://tempuri.org/")]
    public partial class BdkSoapHeader : SoapHeader
    {

        private int partitionIdField;

        /// <remarks/>
        public int PartitionId
        {
            get
            {
                return this.partitionIdField;
            }
            set
            {
                this.partitionIdField = value;
            }
        }
    }

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.SoapTypeAttribute(Namespace = "http://tempuri.org/")]
    public partial class OnBehalfOfSoapHeader : SoapHeader
    {

        private string partnerNameField;

        /// <remarks/>
        public string PartnerName
        {
            get
            {
                return this.partnerNameField;
            }
            set
            {
                this.partnerNameField = value;
            }
        }
    }

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void GetTokenInfoCompletedEventHandler(object sender, GetTokenInfoCompletedEventArgs e);

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class GetTokenInfoCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs
    {

        private object[] results;

        internal GetTokenInfoCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) :
            base(exception, cancelled, userState)
        {
            this.results = results;
        }

        /// <remarks/>
        public string pbstrErrorXML
        {
            get
            {
                this.RaiseExceptionIfNecessary();
                return ((string)(this.results[0]));
            }
        }

        /// <remarks/>
        public string pbstrTokenOrderXML
        {
            get
            {
                this.RaiseExceptionIfNecessary();
                return ((string)(this.results[1]));
            }
        }
    }

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void GetTokenInfoExCompletedEventHandler(object sender, GetTokenInfoExCompletedEventArgs e);

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class GetTokenInfoExCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs
    {

        private object[] results;

        internal GetTokenInfoExCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) :
            base(exception, cancelled, userState)
        {
            this.results = results;
        }

        /// <remarks/>
        public string pbstrErrorXML
        {
            get
            {
                this.RaiseExceptionIfNecessary();
                return ((string)(this.results[0]));
            }
        }

        /// <remarks/>
        public string pbstrTokenOrderXML
        {
            get
            {
                this.RaiseExceptionIfNecessary();
                return ((string)(this.results[1]));
            }
        }
    }

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void GetTransactionsCompletedEventHandler(object sender, GetTransactionsCompletedEventArgs e);

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class GetTransactionsCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs
    {

        private object[] results;

        internal GetTransactionsCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) :
            base(exception, cancelled, userState)
        {
            this.results = results;
        }

        /// <remarks/>
        public string transactionSetXml
        {
            get
            {
                this.RaiseExceptionIfNecessary();
                return ((string)(this.results[0]));
            }
        }
    }

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void GetUnconditionalReplacementTokenCompletedEventHandler(object sender, GetUnconditionalReplacementTokenCompletedEventArgs e);

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class GetUnconditionalReplacementTokenCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs
    {

        private object[] results;

        internal GetUnconditionalReplacementTokenCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) :
            base(exception, cancelled, userState)
        {
            this.results = results;
        }

        /// <remarks/>
        public string replacementPin
        {
            get
            {
                this.RaiseExceptionIfNecessary();
                return ((string)(this.results[0]));
            }
        }

        /// <remarks/>
        public int signature
        {
            get
            {
                this.RaiseExceptionIfNecessary();
                return ((int)(this.results[1]));
            }
        }

        /// <remarks/>
        public string sequenceNumber
        {
            get
            {
                this.RaiseExceptionIfNecessary();
                return ((string)(this.results[2]));
            }
        }
    }

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void GetUserProfileCompletedEventHandler(object sender, GetUserProfileCompletedEventArgs e);

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class GetUserProfileCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs
    {

        private object[] results;

        internal GetUserProfileCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) :
            base(exception, cancelled, userState)
        {
            this.results = results;
        }

        /// <remarks/>
        public string userProfileXml
        {
            get
            {
                this.RaiseExceptionIfNecessary();
                return ((string)(this.results[0]));
            }
        }
    }

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void ImportSettledBillingItemCompletedEventHandler(object sender, ImportSettledBillingItemCompletedEventArgs e);

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class ImportSettledBillingItemCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs
    {

        private object[] results;

        internal ImportSettledBillingItemCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) :
            base(exception, cancelled, userState)
        {
            this.results = results;
        }

        /// <remarks/>
        public string pbstrResultXML
        {
            get
            {
                this.RaiseExceptionIfNecessary();
                return ((string)(this.results[0]));
            }
        }

        /// <remarks/>
        public string pbstrNewLineItemsXML
        {
            get
            {
                this.RaiseExceptionIfNecessary();
                return ((string)(this.results[1]));
            }
        }
    }

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void IssueTokenTrustedCompletedEventHandler(object sender, System.ComponentModel.AsyncCompletedEventArgs e);

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void IsPaymentInstrumentBannedCompletedEventHandler(object sender, IsPaymentInstrumentBannedCompletedEventArgs e);

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class IsPaymentInstrumentBannedCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs
    {

        private object[] results;

        internal IsPaymentInstrumentBannedCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) :
            base(exception, cancelled, userState)
        {
            this.results = results;
        }

        /// <remarks/>
        public string pbstrErrorXML
        {
            get
            {
                this.RaiseExceptionIfNecessary();
                return ((string)(this.results[0]));
            }
        }

        /// <remarks/>
        public int plIsBanned
        {
            get
            {
                this.RaiseExceptionIfNecessary();
                return ((int)(this.results[1]));
            }
        }
    }

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void LoadTokenInstanceCompletedEventHandler(object sender, LoadTokenInstanceCompletedEventArgs e);

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class LoadTokenInstanceCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs
    {

        private object[] results;

        internal LoadTokenInstanceCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) :
            base(exception, cancelled, userState)
        {
            this.results = results;
        }

        /// <remarks/>
        public string responseXML
        {
            get
            {
                this.RaiseExceptionIfNecessary();
                return ((string)(this.results[0]));
            }
        }
    }

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void MarkTokenDistributionStatusCompletedEventHandler(object sender, System.ComponentModel.AsyncCompletedEventArgs e);

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void MapAddressCompletedEventHandler(object sender, MapAddressCompletedEventArgs e);

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class MapAddressCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs
    {

        private object[] results;

        internal MapAddressCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) :
            base(exception, cancelled, userState)
        {
            this.results = results;
        }

        /// <remarks/>
        public string MapAddressInfoSet
        {
            get
            {
                this.RaiseExceptionIfNecessary();
                return ((string)(this.results[0]));
            }
        }
    }

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void MatchPaymentInstrumentInfoCompletedEventHandler(object sender, MatchPaymentInstrumentInfoCompletedEventArgs e);

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class MatchPaymentInstrumentInfoCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs
    {

        private object[] results;

        internal MatchPaymentInstrumentInfoCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) :
            base(exception, cancelled, userState)
        {
            this.results = results;
        }

        /// <remarks/>
        public string pbstrErrorXML
        {
            get
            {
                this.RaiseExceptionIfNecessary();
                return ((string)(this.results[0]));
            }
        }

        /// <remarks/>
        public int plAdminPUIDHigh
        {
            get
            {
                this.RaiseExceptionIfNecessary();
                return ((int)(this.results[1]));
            }
        }

        /// <remarks/>
        public int plAdminPUIDLow
        {
            get
            {
                this.RaiseExceptionIfNecessary();
                return ((int)(this.results[2]));
            }
        }
    }

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void MigrateOfferCompletedEventHandler(object sender, MigrateOfferCompletedEventArgs e);

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class MigrateOfferCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs
    {

        private object[] results;

        internal MigrateOfferCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) :
            base(exception, cancelled, userState)
        {
            this.results = results;
        }

        /// <remarks/>
        public int plAddedServiceInstanceSetCount
        {
            get
            {
                this.RaiseExceptionIfNecessary();
                return ((int)(this.results[0]));
            }
        }

        /// <remarks/>
        public string pbstrAddedServiceInstanceSet
        {
            get
            {
                this.RaiseExceptionIfNecessary();
                return ((string)(this.results[1]));
            }
        }

        /// <remarks/>
        public int plRemovedServiceInstanceSetCount
        {
            get
            {
                this.RaiseExceptionIfNecessary();
                return ((int)(this.results[2]));
            }
        }

        /// <remarks/>
        public string pbstrRemoveServiceInstanceSet
        {
            get
            {
                this.RaiseExceptionIfNecessary();
                return ((string)(this.results[3]));
            }
        }
    }

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void OffsetLineItemCompletedEventHandler(object sender, OffsetLineItemCompletedEventArgs e);

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class OffsetLineItemCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs
    {

        private object[] results;

        internal OffsetLineItemCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) :
            base(exception, cancelled, userState)
        {
            this.results = results;
        }

        /// <remarks/>
        public string pbstrError
        {
            get
            {
                this.RaiseExceptionIfNecessary();
                return ((string)(this.results[0]));
            }
        }
    }

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void OffsetLineItem2CompletedEventHandler(object sender, OffsetLineItem2CompletedEventArgs e);

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class OffsetLineItem2CompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs
    {

        private object[] results;

        internal OffsetLineItem2CompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) :
            base(exception, cancelled, userState)
        {
            this.results = results;
        }

        /// <remarks/>
        public string pbstrError
        {
            get
            {
                this.RaiseExceptionIfNecessary();
                return ((string)(this.results[0]));
            }
        }

        /// <remarks/>
        public string pbstrNewLineItemXML
        {
            get
            {
                this.RaiseExceptionIfNecessary();
                return ((string)(this.results[1]));
            }
        }
    }

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void OffsetOrderCompletedEventHandler(object sender, OffsetOrderCompletedEventArgs e);

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class OffsetOrderCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs
    {

        private object[] results;

        internal OffsetOrderCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) :
            base(exception, cancelled, userState)
        {
            this.results = results;
        }

        /// <remarks/>
        public string orderReceiptXml
        {
            get
            {
                this.RaiseExceptionIfNecessary();
                return ((string)(this.results[0]));
            }
        }
    }

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void OffsetSingleUsageEventCompletedEventHandler(object sender, OffsetSingleUsageEventCompletedEventArgs e);

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class OffsetSingleUsageEventCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs
    {

        private object[] results;

        internal OffsetSingleUsageEventCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) :
            base(exception, cancelled, userState)
        {
            this.results = results;
        }

        /// <remarks/>
        public string newLineItemXML
        {
            get
            {
                this.RaiseExceptionIfNecessary();
                return ((string)(this.results[0]));
            }
        }
    }

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void OrderCDforAccountCompletedEventHandler(object sender, OrderCDforAccountCompletedEventArgs e);

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class OrderCDforAccountCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs
    {

        private object[] results;

        internal OrderCDforAccountCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) :
            base(exception, cancelled, userState)
        {
            this.results = results;
        }

        /// <remarks/>
        public long orderId
        {
            get
            {
                this.RaiseExceptionIfNecessary();
                return ((long)(this.results[0]));
            }
        }
    }

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void OrderCDforAnonymousCompletedEventHandler(object sender, OrderCDforAnonymousCompletedEventArgs e);

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class OrderCDforAnonymousCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs
    {

        private object[] results;

        internal OrderCDforAnonymousCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) :
            base(exception, cancelled, userState)
        {
            this.results = results;
        }

        /// <remarks/>
        public long orderId
        {
            get
            {
                this.RaiseExceptionIfNecessary();
                return ((long)(this.results[0]));
            }
        }
    }

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void PayUserCompletedEventHandler(object sender, PayUserCompletedEventArgs e);

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class PayUserCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs
    {

        private object[] results;

        internal PayUserCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) :
            base(exception, cancelled, userState)
        {
            this.results = results;
        }

        /// <remarks/>
        public string payUserResultXml
        {
            get
            {
                this.RaiseExceptionIfNecessary();
                return ((string)(this.results[0]));
            }
        }
    }

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void ProcessChargebackCompletedEventHandler(object sender, ProcessChargebackCompletedEventArgs e);

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class ProcessChargebackCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs
    {

        private object[] results;

        internal ProcessChargebackCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) :
            base(exception, cancelled, userState)
        {
            this.results = results;
        }

        /// <remarks/>
        public string chargebackResponseInfoXml
        {
            get
            {
                this.RaiseExceptionIfNecessary();
                return ((string)(this.results[0]));
            }
        }
    }

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void ProvisionServicesCompletedEventHandler(object sender, ProvisionServicesCompletedEventArgs e);

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class ProvisionServicesCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs
    {

        private object[] results;

        internal ProvisionServicesCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) :
            base(exception, cancelled, userState)
        {
            this.results = results;
        }

        /// <remarks/>
        public string pbstrErrorXML
        {
            get
            {
                this.RaiseExceptionIfNecessary();
                return ((string)(this.results[0]));
            }
        }
    }

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void PurchaseItemCompletedEventHandler(object sender, PurchaseItemCompletedEventArgs e);

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class PurchaseItemCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs
    {

        private object[] results;

        internal PurchaseItemCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) :
            base(exception, cancelled, userState)
        {
            this.results = results;
        }

        /// <remarks/>
        public string receiptXml
        {
            get
            {
                this.RaiseExceptionIfNecessary();
                return ((string)(this.results[0]));
            }
        }
    }

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void PurchaseItemExCompletedEventHandler(object sender, PurchaseItemExCompletedEventArgs e);

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class PurchaseItemExCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs
    {

        private object[] results;

        internal PurchaseItemExCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) :
            base(exception, cancelled, userState)
        {
            this.results = results;
        }

        /// <remarks/>
        public string receiptXml
        {
            get
            {
                this.RaiseExceptionIfNecessary();
                return ((string)(this.results[0]));
            }
        }
    }

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void PurchaseOfferingCompletedEventHandler(object sender, PurchaseOfferingCompletedEventArgs e);

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class PurchaseOfferingCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs
    {

        private object[] results;

        internal PurchaseOfferingCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) :
            base(exception, cancelled, userState)
        {
            this.results = results;
        }

        /// <remarks/>
        public string pbstrErrorXML
        {
            get
            {
                this.RaiseExceptionIfNecessary();
                return ((string)(this.results[0]));
            }
        }

        /// <remarks/>
        public string pbstrSubscriptionId
        {
            get
            {
                this.RaiseExceptionIfNecessary();
                return ((string)(this.results[1]));
            }
        }

        /// <remarks/>
        public string pbstrAmountChargedXML
        {
            get
            {
                this.RaiseExceptionIfNecessary();
                return ((string)(this.results[2]));
            }
        }

        /// <remarks/>
        public int plAddedServiceInstanceCount
        {
            get
            {
                this.RaiseExceptionIfNecessary();
                return ((int)(this.results[3]));
            }
        }

        /// <remarks/>
        public string pbstrAddedServiceInstanceSetXML
        {
            get
            {
                this.RaiseExceptionIfNecessary();
                return ((string)(this.results[4]));
            }
        }
    }

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void PurchaseOfferingExCompletedEventHandler(object sender, PurchaseOfferingExCompletedEventArgs e);

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class PurchaseOfferingExCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs
    {

        private object[] results;

        internal PurchaseOfferingExCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) :
            base(exception, cancelled, userState)
        {
            this.results = results;
        }

        /// <remarks/>
        public string pbstrErrorXML
        {
            get
            {
                this.RaiseExceptionIfNecessary();
                return ((string)(this.results[0]));
            }
        }

        /// <remarks/>
        public string pbstrSubscriptionId
        {
            get
            {
                this.RaiseExceptionIfNecessary();
                return ((string)(this.results[1]));
            }
        }

        /// <remarks/>
        public string pbstrAmountChargedXML
        {
            get
            {
                this.RaiseExceptionIfNecessary();
                return ((string)(this.results[2]));
            }
        }

        /// <remarks/>
        public int plAddedServiceInstanceCount
        {
            get
            {
                this.RaiseExceptionIfNecessary();
                return ((int)(this.results[3]));
            }
        }

        /// <remarks/>
        public string pbstrAddedServiceInstanceSetXML
        {
            get
            {
                this.RaiseExceptionIfNecessary();
                return ((string)(this.results[4]));
            }
        }
    }

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void PurchaseOfferingEx2CompletedEventHandler(object sender, PurchaseOfferingEx2CompletedEventArgs e);

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class PurchaseOfferingEx2CompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs
    {

        private object[] results;

        internal PurchaseOfferingEx2CompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) :
            base(exception, cancelled, userState)
        {
            this.results = results;
        }

        /// <remarks/>
        public string pbstrErrorXML
        {
            get
            {
                this.RaiseExceptionIfNecessary();
                return ((string)(this.results[0]));
            }
        }

        /// <remarks/>
        public string pbstrSubscriptionId
        {
            get
            {
                this.RaiseExceptionIfNecessary();
                return ((string)(this.results[1]));
            }
        }

        /// <remarks/>
        public string pbstrAmountChargedXML
        {
            get
            {
                this.RaiseExceptionIfNecessary();
                return ((string)(this.results[2]));
            }
        }

        /// <remarks/>
        public int plAddedServiceInstanceCount
        {
            get
            {
                this.RaiseExceptionIfNecessary();
                return ((int)(this.results[3]));
            }
        }

        /// <remarks/>
        public string pbstrAddedServiceInstanceSetXML
        {
            get
            {
                this.RaiseExceptionIfNecessary();
                return ((string)(this.results[4]));
            }
        }

        /// <remarks/>
        public string pbstrRedirectOutputInfoXML
        {
            get
            {
                this.RaiseExceptionIfNecessary();
                return ((string)(this.results[5]));
            }
        }
    }

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void PurchaseOfferingEx3CompletedEventHandler(object sender, PurchaseOfferingEx3CompletedEventArgs e);

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class PurchaseOfferingEx3CompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs
    {

        private object[] results;

        internal PurchaseOfferingEx3CompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) :
            base(exception, cancelled, userState)
        {
            this.results = results;
        }

        /// <remarks/>
        public string pbstrErrorXML
        {
            get
            {
                this.RaiseExceptionIfNecessary();
                return ((string)(this.results[0]));
            }
        }

        /// <remarks/>
        public string pbstrSubscriptionId
        {
            get
            {
                this.RaiseExceptionIfNecessary();
                return ((string)(this.results[1]));
            }
        }

        /// <remarks/>
        public string pbstrAmountChargedXML
        {
            get
            {
                this.RaiseExceptionIfNecessary();
                return ((string)(this.results[2]));
            }
        }

        /// <remarks/>
        public int plAddedServiceInstanceCount
        {
            get
            {
                this.RaiseExceptionIfNecessary();
                return ((int)(this.results[3]));
            }
        }

        /// <remarks/>
        public string pbstrAddedServiceInstanceSetXML
        {
            get
            {
                this.RaiseExceptionIfNecessary();
                return ((string)(this.results[4]));
            }
        }

        /// <remarks/>
        public string pbstrRedirectOutputInfoXML
        {
            get
            {
                this.RaiseExceptionIfNecessary();
                return ((string)(this.results[5]));
            }
        }
    }

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void ReconcileTokenTrustedCompletedEventHandler(object sender, ReconcileTokenTrustedCompletedEventArgs e);

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class ReconcileTokenTrustedCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs
    {

        private object[] results;

        internal ReconcileTokenTrustedCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) :
            base(exception, cancelled, userState)
        {
            this.results = results;
        }

        /// <remarks/>
        public int reconStatus
        {
            get
            {
                this.RaiseExceptionIfNecessary();
                return ((int)(this.results[0]));
            }
        }
    }

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void RefundTaxForAccountCompletedEventHandler(object sender, RefundTaxForAccountCompletedEventArgs e);

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class RefundTaxForAccountCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs
    {

        private object[] results;

        internal RefundTaxForAccountCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) :
            base(exception, cancelled, userState)
        {
            this.results = results;
        }

        /// <remarks/>
        public string pbstrNewLineItemSetXML
        {
            get
            {
                this.RaiseExceptionIfNecessary();
                return ((string)(this.results[0]));
            }
        }
    }

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void RegisterPaymentInstrumentCompletedEventHandler(object sender, RegisterPaymentInstrumentCompletedEventArgs e);

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class RegisterPaymentInstrumentCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs
    {

        private object[] results;

        internal RegisterPaymentInstrumentCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) :
            base(exception, cancelled, userState)
        {
            this.results = results;
        }

        /// <remarks/>
        public string paymentInstrumentId
        {
            get
            {
                this.RaiseExceptionIfNecessary();
                return ((string)(this.results[0]));
            }
        }

        /// <remarks/>
        public string requiredPaperWorkUrl
        {
            get
            {
                this.RaiseExceptionIfNecessary();
                return ((string)(this.results[1]));
            }
        }

        /// <remarks/>
        public string paymentInstrumentsResultsXml
        {
            get
            {
                this.RaiseExceptionIfNecessary();
                return ((string)(this.results[2]));
            }
        }
    }

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void ReinstateSubscriptionCompletedEventHandler(object sender, ReinstateSubscriptionCompletedEventArgs e);

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class ReinstateSubscriptionCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs
    {

        private object[] results;

        internal ReinstateSubscriptionCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) :
            base(exception, cancelled, userState)
        {
            this.results = results;
        }

        /// <remarks/>
        public string pbstrErrorXML
        {
            get
            {
                this.RaiseExceptionIfNecessary();
                return ((string)(this.results[0]));
            }
        }

        /// <remarks/>
        public string pbstrAmountChargedXML
        {
            get
            {
                this.RaiseExceptionIfNecessary();
                return ((string)(this.results[1]));
            }
        }

        /// <remarks/>
        public string pbstrSubscriptionStatusInfoXML
        {
            get
            {
                this.RaiseExceptionIfNecessary();
                return ((string)(this.results[2]));
            }
        }
    }

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void RemoveBillingReferenceCompletedEventHandler(object sender, System.ComponentModel.AsyncCompletedEventArgs e);

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void RemovePaymentInstrumentCompletedEventHandler(object sender, RemovePaymentInstrumentCompletedEventArgs e);

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class RemovePaymentInstrumentCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs
    {

        private object[] results;

        internal RemovePaymentInstrumentCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) :
            base(exception, cancelled, userState)
        {
            this.results = results;
        }

        /// <remarks/>
        public string pbstrErrorXML
        {
            get
            {
                this.RaiseExceptionIfNecessary();
                return ((string)(this.results[0]));
            }
        }
    }

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void RemovePMNBasedServicesCompletedEventHandler(object sender, System.ComponentModel.AsyncCompletedEventArgs e);

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void RemoveRoleAssignmentCompletedEventHandler(object sender, RemoveRoleAssignmentCompletedEventArgs e);

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class RemoveRoleAssignmentCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs
    {

        private object[] results;

        internal RemoveRoleAssignmentCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) :
            base(exception, cancelled, userState)
        {
            this.results = results;
        }

        /// <remarks/>
        public string pbstrErrorXML
        {
            get
            {
                this.RaiseExceptionIfNecessary();
                return ((string)(this.results[0]));
            }
        }
    }

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void RemoveViolationCompletedEventHandler(object sender, RemoveViolationCompletedEventArgs e);

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class RemoveViolationCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs
    {

        private object[] results;

        internal RemoveViolationCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) :
            base(exception, cancelled, userState)
        {
            this.results = results;
        }

        /// <remarks/>
        public string pbstrErrorXML
        {
            get
            {
                this.RaiseExceptionIfNecessary();
                return ((string)(this.results[0]));
            }
        }

        /// <remarks/>
        public string pbstrStatusInfoXML
        {
            get
            {
                this.RaiseExceptionIfNecessary();
                return ((string)(this.results[1]));
            }
        }

        /// <remarks/>
        public string pbstrAmountChargedXML
        {
            get
            {
                this.RaiseExceptionIfNecessary();
                return ((string)(this.results[2]));
            }
        }
    }

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void ReportSingleUsageEventCompletedEventHandler(object sender, ReportSingleUsageEventCompletedEventArgs e);

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class ReportSingleUsageEventCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs
    {

        private object[] results;

        internal ReportSingleUsageEventCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) :
            base(exception, cancelled, userState)
        {
            this.results = results;
        }

        /// <remarks/>
        public string lineItemId
        {
            get
            {
                this.RaiseExceptionIfNecessary();
                return ((string)(this.results[0]));
            }
        }

        /// <remarks/>
        public string usageInfoXml
        {
            get
            {
                this.RaiseExceptionIfNecessary();
                return ((string)(this.results[1]));
            }
        }

        /// <remarks/>
        public string amountChargedXml
        {
            get
            {
                this.RaiseExceptionIfNecessary();
                return ((string)(this.results[2]));
            }
        }
    }

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void ReportTransactionEventCompletedEventHandler(object sender, System.ComponentModel.AsyncCompletedEventArgs e);

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void ReportUsageEventCompletedEventHandler(object sender, ReportUsageEventCompletedEventArgs e);

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class ReportUsageEventCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs
    {

        private object[] results;

        internal ReportUsageEventCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) :
            base(exception, cancelled, userState)
        {
            this.results = results;
        }

        /// <remarks/>
        public string pbstrErrorXML
        {
            get
            {
                this.RaiseExceptionIfNecessary();
                return ((string)(this.results[0]));
            }
        }
    }

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void ReschedulePaymentCompletedEventHandler(object sender, ReschedulePaymentCompletedEventArgs e);

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class ReschedulePaymentCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs
    {

        private object[] results;

        internal ReschedulePaymentCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) :
            base(exception, cancelled, userState)
        {
            this.results = results;
        }

        /// <remarks/>
        public string pbstrErrorXML
        {
            get
            {
                this.RaiseExceptionIfNecessary();
                return ((string)(this.results[0]));
            }
        }

        /// <remarks/>
        public string pbstrAmountChargedSetXML
        {
            get
            {
                this.RaiseExceptionIfNecessary();
                return ((string)(this.results[1]));
            }
        }
    }

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void SearchAccountsCompletedEventHandler(object sender, SearchAccountsCompletedEventArgs e);

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class SearchAccountsCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs
    {

        private object[] results;

        internal SearchAccountsCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) :
            base(exception, cancelled, userState)
        {
            this.results = results;
        }

        /// <remarks/>
        public string pbstrErrorXML
        {
            get
            {
                this.RaiseExceptionIfNecessary();
                return ((string)(this.results[0]));
            }
        }

        /// <remarks/>
        public int pfMoreRows
        {
            get
            {
                this.RaiseExceptionIfNecessary();
                return ((int)(this.results[1]));
            }
        }

        /// <remarks/>
        public int plAccountInfoCount
        {
            get
            {
                this.RaiseExceptionIfNecessary();
                return ((int)(this.results[2]));
            }
        }

        /// <remarks/>
        public string pbstrAccountInfoSetXML
        {
            get
            {
                this.RaiseExceptionIfNecessary();
                return ((string)(this.results[3]));
            }
        }
    }

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void SearchAccountsExCompletedEventHandler(object sender, SearchAccountsExCompletedEventArgs e);

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class SearchAccountsExCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs
    {

        private object[] results;

        internal SearchAccountsExCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) :
            base(exception, cancelled, userState)
        {
            this.results = results;
        }

        /// <remarks/>
        public string bookmarkNew
        {
            get
            {
                this.RaiseExceptionIfNecessary();
                return ((string)(this.results[0]));
            }
        }

        /// <remarks/>
        public int returnedAccountCount
        {
            get
            {
                this.RaiseExceptionIfNecessary();
                return ((int)(this.results[1]));
            }
        }

        /// <remarks/>
        public string accountInfoSetXml
        {
            get
            {
                this.RaiseExceptionIfNecessary();
                return ((string)(this.results[2]));
            }
        }
    }

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void SearchBillingInfoCompletedEventHandler(object sender, SearchBillingInfoCompletedEventArgs e);

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class SearchBillingInfoCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs
    {

        private object[] results;

        internal SearchBillingInfoCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) :
            base(exception, cancelled, userState)
        {
            this.results = results;
        }

        /// <remarks/>
        public string billingInfoSetXML
        {
            get
            {
                this.RaiseExceptionIfNecessary();
                return ((string)(this.results[0]));
            }
        }
    }

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void SendHCICompletedEventHandler(object sender, System.ComponentModel.AsyncCompletedEventArgs e);

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void SendValidationTokenInfoCompletedEventHandler(object sender, System.ComponentModel.AsyncCompletedEventArgs e);

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void SetBillingReferenceCompletedEventHandler(object sender, SetBillingReferenceCompletedEventArgs e);

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class SetBillingReferenceCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs
    {

        private object[] results;

        internal SetBillingReferenceCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) :
            base(exception, cancelled, userState)
        {
            this.results = results;
        }

        /// <remarks/>
        public string billingReferenceId
        {
            get
            {
                this.RaiseExceptionIfNecessary();
                return ((string)(this.results[0]));
            }
        }
    }

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void SetPartnerConfigurationCompletedEventHandler(object sender, SetPartnerConfigurationCompletedEventArgs e);

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class SetPartnerConfigurationCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs
    {

        private object[] results;

        internal SetPartnerConfigurationCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) :
            base(exception, cancelled, userState)
        {
            this.results = results;
        }

        /// <remarks/>
        public string responseXML
        {
            get
            {
                this.RaiseExceptionIfNecessary();
                return ((string)(this.results[0]));
            }
        }
    }

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void SettleBalanceCompletedEventHandler(object sender, SettleBalanceCompletedEventArgs e);

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class SettleBalanceCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs
    {

        private object[] results;

        internal SettleBalanceCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) :
            base(exception, cancelled, userState)
        {
            this.results = results;
        }

        /// <remarks/>
        public string pbstrErrorXML
        {
            get
            {
                this.RaiseExceptionIfNecessary();
                return ((string)(this.results[0]));
            }
        }

        /// <remarks/>
        public string pbstrAmountChargedXML
        {
            get
            {
                this.RaiseExceptionIfNecessary();
                return ((string)(this.results[1]));
            }
        }
    }

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void SettleOrderCompletedEventHandler(object sender, SettleOrderCompletedEventArgs e);

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class SettleOrderCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs
    {

        private object[] results;

        internal SettleOrderCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) :
            base(exception, cancelled, userState)
        {
            this.results = results;
        }

        /// <remarks/>
        public string orderReceiptXml
        {
            get
            {
                this.RaiseExceptionIfNecessary();
                return ((string)(this.results[0]));
            }
        }
    }

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void SignAgreementCompletedEventHandler(object sender, SignAgreementCompletedEventArgs e);

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class SignAgreementCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs
    {

        private object[] results;

        internal SignAgreementCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) :
            base(exception, cancelled, userState)
        {
            this.results = results;
        }

        /// <remarks/>
        public string pbstrErrorXML
        {
            get
            {
                this.RaiseExceptionIfNecessary();
                return ((string)(this.results[0]));
            }
        }
    }

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void StopPaymentsCompletedEventHandler(object sender, StopPaymentsCompletedEventArgs e);

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class StopPaymentsCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs
    {

        private object[] results;

        internal StopPaymentsCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) :
            base(exception, cancelled, userState)
        {
            this.results = results;
        }

        /// <remarks/>
        public string pbstrErrorXML
        {
            get
            {
                this.RaiseExceptionIfNecessary();
                return ((string)(this.results[0]));
            }
        }
    }

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void SubmitOrderCompletedEventHandler(object sender, SubmitOrderCompletedEventArgs e);

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class SubmitOrderCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs
    {

        private object[] results;

        internal SubmitOrderCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) :
            base(exception, cancelled, userState)
        {
            this.results = results;
        }

        /// <remarks/>
        public string orderReceiptXml
        {
            get
            {
                this.RaiseExceptionIfNecessary();
                return ((string)(this.results[0]));
            }
        }
    }

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void SwitchPaymentInstrumentsCompletedEventHandler(object sender, SwitchPaymentInstrumentsCompletedEventArgs e);

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class SwitchPaymentInstrumentsCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs
    {

        private object[] results;

        internal SwitchPaymentInstrumentsCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) :
            base(exception, cancelled, userState)
        {
            this.results = results;
        }

        /// <remarks/>
        public string pbstrErrorXML
        {
            get
            {
                this.RaiseExceptionIfNecessary();
                return ((string)(this.results[0]));
            }
        }

        /// <remarks/>
        public string pbstrAmountChargedXML
        {
            get
            {
                this.RaiseExceptionIfNecessary();
                return ((string)(this.results[1]));
            }
        }
    }

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void SyncUPSCacheForPUIDCompletedEventHandler(object sender, SyncUPSCacheForPUIDCompletedEventArgs e);

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class SyncUPSCacheForPUIDCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs
    {

        private object[] results;

        internal SyncUPSCacheForPUIDCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) :
            base(exception, cancelled, userState)
        {
            this.results = results;
        }

        /// <remarks/>
        public string pbstrErrorXML
        {
            get
            {
                this.RaiseExceptionIfNecessary();
                return ((string)(this.results[0]));
            }
        }
    }

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void TestConnectionCompletedEventHandler(object sender, TestConnectionCompletedEventArgs e);

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class TestConnectionCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs
    {

        private object[] results;

        internal TestConnectionCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) :
            base(exception, cancelled, userState)
        {
            this.results = results;
        }

        /// <remarks/>
        public string pbstrOutputString
        {
            get
            {
                this.RaiseExceptionIfNecessary();
                return ((string)(this.results[0]));
            }
        }
    }

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void TokenRedemptionCompletedEventHandler(object sender, TokenRedemptionCompletedEventArgs e);

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class TokenRedemptionCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs
    {

        private object[] results;

        internal TokenRedemptionCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) :
            base(exception, cancelled, userState)
        {
            this.results = results;
        }

        /// <remarks/>
        public string responseXML
        {
            get
            {
                this.RaiseExceptionIfNecessary();
                return ((string)(this.results[0]));
            }
        }
    }

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void TransferBalanceCompletedEventHandler(object sender, TransferBalanceCompletedEventArgs e);

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class TransferBalanceCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs
    {

        private object[] results;

        internal TransferBalanceCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) :
            base(exception, cancelled, userState)
        {
            this.results = results;
        }

        /// <remarks/>
        public string pbstrErrorXML
        {
            get
            {
                this.RaiseExceptionIfNecessary();
                return ((string)(this.results[0]));
            }
        }

        /// <remarks/>
        public string pbstrAmountChargedXML
        {
            get
            {
                this.RaiseExceptionIfNecessary();
                return ((string)(this.results[1]));
            }
        }
    }

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void UnbanPaymentInstrumentCompletedEventHandler(object sender, UnbanPaymentInstrumentCompletedEventArgs e);

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class UnbanPaymentInstrumentCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs
    {

        private object[] results;

        internal UnbanPaymentInstrumentCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) :
            base(exception, cancelled, userState)
        {
            this.results = results;
        }

        /// <remarks/>
        public string pbstrErrorXML
        {
            get
            {
                this.RaiseExceptionIfNecessary();
                return ((string)(this.results[0]));
            }
        }
    }

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void UnbanUserCompletedEventHandler(object sender, UnbanUserCompletedEventArgs e);

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class UnbanUserCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs
    {

        private object[] results;

        internal UnbanUserCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) :
            base(exception, cancelled, userState)
        {
            this.results = results;
        }

        /// <remarks/>
        public string pbstrErrorXML
        {
            get
            {
                this.RaiseExceptionIfNecessary();
                return ((string)(this.results[0]));
            }
        }
    }

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void UnIssueTokenTrustedCompletedEventHandler(object sender, System.ComponentModel.AsyncCompletedEventArgs e);

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void UpdateAccountInfoCompletedEventHandler(object sender, UpdateAccountInfoCompletedEventArgs e);

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class UpdateAccountInfoCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs
    {

        private object[] results;

        internal UpdateAccountInfoCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) :
            base(exception, cancelled, userState)
        {
            this.results = results;
        }

        /// <remarks/>
        public string pbstrErrorXML
        {
            get
            {
                this.RaiseExceptionIfNecessary();
                return ((string)(this.results[0]));
            }
        }

        /// <remarks/>
        public string pbstrRequiredPaperWorkURL
        {
            get
            {
                this.RaiseExceptionIfNecessary();
                return ((string)(this.results[1]));
            }
        }
    }

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void UpdatePaymentInstrumentInfoCompletedEventHandler(object sender, UpdatePaymentInstrumentInfoCompletedEventArgs e);

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class UpdatePaymentInstrumentInfoCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs
    {

        private object[] results;

        internal UpdatePaymentInstrumentInfoCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) :
            base(exception, cancelled, userState)
        {
            this.results = results;
        }

        /// <remarks/>
        public string pbstrErrorXML
        {
            get
            {
                this.RaiseExceptionIfNecessary();
                return ((string)(this.results[0]));
            }
        }
    }

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void UpdateSubscriptionInfoCompletedEventHandler(object sender, UpdateSubscriptionInfoCompletedEventArgs e);

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class UpdateSubscriptionInfoCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs
    {

        private object[] results;

        internal UpdateSubscriptionInfoCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) :
            base(exception, cancelled, userState)
        {
            this.results = results;
        }

        /// <remarks/>
        public string pbstrErrorXML
        {
            get
            {
                this.RaiseExceptionIfNecessary();
                return ((string)(this.results[0]));
            }
        }
    }

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void ValidateProvisioningDataCompletedEventHandler(object sender, ValidateProvisioningDataCompletedEventArgs e);

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class ValidateProvisioningDataCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs
    {

        private object[] results;

        internal ValidateProvisioningDataCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) :
            base(exception, cancelled, userState)
        {
            this.results = results;
        }

        /// <remarks/>
        public string pbstrErrorXML
        {
            get
            {
                this.RaiseExceptionIfNecessary();
                return ((string)(this.results[0]));
            }
        }

        /// <remarks/>
        public string pbstrResponseXML
        {
            get
            {
                this.RaiseExceptionIfNecessary();
                return ((string)(this.results[1]));
            }
        }
    }

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void ValidateTokenCompletedEventHandler(object sender, System.ComponentModel.AsyncCompletedEventArgs e);

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void ActivateTokenCompletedEventHandler(object sender, System.ComponentModel.AsyncCompletedEventArgs e);

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void ActivateTokenExCompletedEventHandler(object sender, System.ComponentModel.AsyncCompletedEventArgs e);

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void AddCommentCompletedEventHandler(object sender, AddCommentCompletedEventArgs e);

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class AddCommentCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs
    {

        private object[] results;

        internal AddCommentCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) :
            base(exception, cancelled, userState)
        {
            this.results = results;
        }

        /// <remarks/>
        public string pbstrErrorXML
        {
            get
            {
                this.RaiseExceptionIfNecessary();
                return ((string)(this.results[0]));
            }
        }
    }

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void AddPaymentInstrumentCompletedEventHandler(object sender, AddPaymentInstrumentCompletedEventArgs e);

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class AddPaymentInstrumentCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs
    {

        private object[] results;

        internal AddPaymentInstrumentCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) :
            base(exception, cancelled, userState)
        {
            this.results = results;
        }

        /// <remarks/>
        public string pbstrErrorXML
        {
            get
            {
                this.RaiseExceptionIfNecessary();
                return ((string)(this.results[0]));
            }
        }

        /// <remarks/>
        public string pbstrPaymentInstrumentId
        {
            get
            {
                this.RaiseExceptionIfNecessary();
                return ((string)(this.results[1]));
            }
        }

        /// <remarks/>
        public string pbstrRequiredPaperWorkURL
        {
            get
            {
                this.RaiseExceptionIfNecessary();
                return ((string)(this.results[2]));
            }
        }
    }

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void AddRoleAssignmentCompletedEventHandler(object sender, AddRoleAssignmentCompletedEventArgs e);

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class AddRoleAssignmentCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs
    {

        private object[] results;

        internal AddRoleAssignmentCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) :
            base(exception, cancelled, userState)
        {
            this.results = results;
        }

        /// <remarks/>
        public string pbstrErrorXML
        {
            get
            {
                this.RaiseExceptionIfNecessary();
                return ((string)(this.results[0]));
            }
        }
    }

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void AddViolationCompletedEventHandler(object sender, AddViolationCompletedEventArgs e);

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class AddViolationCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs
    {

        private object[] results;

        internal AddViolationCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) :
            base(exception, cancelled, userState)
        {
            this.results = results;
        }

        /// <remarks/>
        public string pbstrErrorXML
        {
            get
            {
                this.RaiseExceptionIfNecessary();
                return ((string)(this.results[0]));
            }
        }

        /// <remarks/>
        public string pbstrStatusInfoXML
        {
            get
            {
                this.RaiseExceptionIfNecessary();
                return ((string)(this.results[1]));
            }
        }

        /// <remarks/>
        public string pbstrAmountChargedXML
        {
            get
            {
                this.RaiseExceptionIfNecessary();
                return ((string)(this.results[2]));
            }
        }
    }

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void AdjustGotoBAMDateCompletedEventHandler(object sender, AdjustGotoBAMDateCompletedEventArgs e);

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class AdjustGotoBAMDateCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs
    {

        private object[] results;

        internal AdjustGotoBAMDateCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) :
            base(exception, cancelled, userState)
        {
            this.results = results;
        }

        /// <remarks/>
        public string pbstrErrorXML
        {
            get
            {
                this.RaiseExceptionIfNecessary();
                return ((string)(this.results[0]));
            }
        }
    }

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void AdjustResourceBalanceCompletedEventHandler(object sender, AdjustResourceBalanceCompletedEventArgs e);

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class AdjustResourceBalanceCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs
    {

        private object[] results;

        internal AdjustResourceBalanceCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) :
            base(exception, cancelled, userState)
        {
            this.results = results;
        }

        /// <remarks/>
        public string pbstrError
        {
            get
            {
                this.RaiseExceptionIfNecessary();
                return ((string)(this.results[0]));
            }
        }
    }

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void AdjustSubscriptionCompletedEventHandler(object sender, AdjustSubscriptionCompletedEventArgs e);

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class AdjustSubscriptionCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs
    {

        private object[] results;

        internal AdjustSubscriptionCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) :
            base(exception, cancelled, userState)
        {
            this.results = results;
        }

        /// <remarks/>
        public string pbstrErrorXML
        {
            get
            {
                this.RaiseExceptionIfNecessary();
                return ((string)(this.results[0]));
            }
        }
    }

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void BanPaymentInstrumentCompletedEventHandler(object sender, BanPaymentInstrumentCompletedEventArgs e);

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class BanPaymentInstrumentCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs
    {

        private object[] results;

        internal BanPaymentInstrumentCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) :
            base(exception, cancelled, userState)
        {
            this.results = results;
        }

        /// <remarks/>
        public string pbstrErrorXML
        {
            get
            {
                this.RaiseExceptionIfNecessary();
                return ((string)(this.results[0]));
            }
        }
    }

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void BanUserCompletedEventHandler(object sender, BanUserCompletedEventArgs e);

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class BanUserCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs
    {

        private object[] results;

        internal BanUserCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) :
            base(exception, cancelled, userState)
        {
            this.results = results;
        }

        /// <remarks/>
        public string pbstrErrorXML
        {
            get
            {
                this.RaiseExceptionIfNecessary();
                return ((string)(this.results[0]));
            }
        }
    }

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void BlacklistTokenCompletedEventHandler(object sender, BlacklistTokenCompletedEventArgs e);

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class BlacklistTokenCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs
    {

        private object[] results;

        internal BlacklistTokenCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) :
            base(exception, cancelled, userState)
        {
            this.results = results;
        }

        /// <remarks/>
        public string pbstrErrorXML
        {
            get
            {
                this.RaiseExceptionIfNecessary();
                return ((string)(this.results[0]));
            }
        }

        /// <remarks/>
        public string pbstrBlacklistActionSetXML
        {
            get
            {
                this.RaiseExceptionIfNecessary();
                return ((string)(this.results[1]));
            }
        }

        /// <remarks/>
        public int plBlacklistActionSetCount
        {
            get
            {
                this.RaiseExceptionIfNecessary();
                return ((int)(this.results[2]));
            }
        }
    }

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void CalculateTaxCompletedEventHandler(object sender, CalculateTaxCompletedEventArgs e);

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class CalculateTaxCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs
    {

        private object[] results;

        internal CalculateTaxCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) :
            base(exception, cancelled, userState)
        {
            this.results = results;
        }

        /// <remarks/>
        public string returnOrderDetailXml
        {
            get
            {
                this.RaiseExceptionIfNecessary();
                return ((string)(this.results[0]));
            }
        }
    }

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void CancelConversionCompletedEventHandler(object sender, CancelConversionCompletedEventArgs e);

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class CancelConversionCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs
    {

        private object[] results;

        internal CancelConversionCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) :
            base(exception, cancelled, userState)
        {
            this.results = results;
        }

        /// <remarks/>
        public string pbstrErrorXML
        {
            get
            {
                this.RaiseExceptionIfNecessary();
                return ((string)(this.results[0]));
            }
        }

        /// <remarks/>
        public int plAddedServiceInstanceSetCount
        {
            get
            {
                this.RaiseExceptionIfNecessary();
                return ((int)(this.results[1]));
            }
        }

        /// <remarks/>
        public string pbstrAddedServiceInstanceSet
        {
            get
            {
                this.RaiseExceptionIfNecessary();
                return ((string)(this.results[2]));
            }
        }

        /// <remarks/>
        public int plRemovedServiceInstanceSetCount
        {
            get
            {
                this.RaiseExceptionIfNecessary();
                return ((int)(this.results[3]));
            }
        }

        /// <remarks/>
        public string pbstrRemoveServiceInstanceSet
        {
            get
            {
                this.RaiseExceptionIfNecessary();
                return ((string)(this.results[4]));
            }
        }
    }

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void CancelPaymentCompletedEventHandler(object sender, System.ComponentModel.AsyncCompletedEventArgs e);

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void CancelRenewalCompletedEventHandler(object sender, System.ComponentModel.AsyncCompletedEventArgs e);

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void CancelSubscriptionCompletedEventHandler(object sender, CancelSubscriptionCompletedEventArgs e);

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class CancelSubscriptionCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs
    {

        private object[] results;

        internal CancelSubscriptionCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) :
            base(exception, cancelled, userState)
        {
            this.results = results;
        }

        /// <remarks/>
        public string pbstrErrorXML
        {
            get
            {
                this.RaiseExceptionIfNecessary();
                return ((string)(this.results[0]));
            }
        }

        /// <remarks/>
        public string pbstrAmountChargedXML
        {
            get
            {
                this.RaiseExceptionIfNecessary();
                return ((string)(this.results[1]));
            }
        }

        /// <remarks/>
        public string pbstrSubscriptionStatusInfoXML
        {
            get
            {
                this.RaiseExceptionIfNecessary();
                return ((string)(this.results[2]));
            }
        }

        /// <remarks/>
        public int plRemovedServiceInstanceCount
        {
            get
            {
                this.RaiseExceptionIfNecessary();
                return ((int)(this.results[3]));
            }
        }

        /// <remarks/>
        public string pbstrRemovedServiceInstanceSetXML
        {
            get
            {
                this.RaiseExceptionIfNecessary();
                return ((string)(this.results[4]));
            }
        }
    }

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void CancelSubscriptionExCompletedEventHandler(object sender, CancelSubscriptionExCompletedEventArgs e);

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class CancelSubscriptionExCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs
    {

        private object[] results;

        internal CancelSubscriptionExCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) :
            base(exception, cancelled, userState)
        {
            this.results = results;
        }

        /// <remarks/>
        public string amountChargedXML
        {
            get
            {
                this.RaiseExceptionIfNecessary();
                return ((string)(this.results[0]));
            }
        }

        /// <remarks/>
        public string subscriptionStatusInfoXML
        {
            get
            {
                this.RaiseExceptionIfNecessary();
                return ((string)(this.results[1]));
            }
        }

        /// <remarks/>
        public int removedServiceInstanceCount
        {
            get
            {
                this.RaiseExceptionIfNecessary();
                return ((int)(this.results[2]));
            }
        }

        /// <remarks/>
        public string removedServiceInstanceSetXML
        {
            get
            {
                this.RaiseExceptionIfNecessary();
                return ((string)(this.results[3]));
            }
        }
    }

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void CancelTransactionCompletedEventHandler(object sender, System.ComponentModel.AsyncCompletedEventArgs e);

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void ChargePaymentInstrumentCompletedEventHandler(object sender, ChargePaymentInstrumentCompletedEventArgs e);

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class ChargePaymentInstrumentCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs
    {

        private object[] results;

        internal ChargePaymentInstrumentCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) :
            base(exception, cancelled, userState)
        {
            this.results = results;
        }

        /// <remarks/>
        public string paymentInstrumentResultsXml
        {
            get
            {
                this.RaiseExceptionIfNecessary();
                return ((string)(this.results[0]));
            }
        }
    }

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void CheckCDAvailabilityCompletedEventHandler(object sender, CheckCDAvailabilityCompletedEventArgs e);

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class CheckCDAvailabilityCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs
    {

        private object[] results;

        internal CheckCDAvailabilityCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) :
            base(exception, cancelled, userState)
        {
            this.results = results;
        }

        /// <remarks/>
        public string partnerName
        {
            get
            {
                this.RaiseExceptionIfNecessary();
                return ((string)(this.results[0]));
            }
        }
    }

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void CheckProvisioningStatusCompletedEventHandler(object sender, CheckProvisioningStatusCompletedEventArgs e);

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class CheckProvisioningStatusCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs
    {

        private object[] results;

        internal CheckProvisioningStatusCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) :
            base(exception, cancelled, userState)
        {
            this.results = results;
        }

        /// <remarks/>
        public string pbstrErrorXML
        {
            get
            {
                this.RaiseExceptionIfNecessary();
                return ((string)(this.results[0]));
            }
        }

        /// <remarks/>
        public string pbstrResponseXML
        {
            get
            {
                this.RaiseExceptionIfNecessary();
                return ((string)(this.results[1]));
            }
        }
    }

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void CloseAccountCompletedEventHandler(object sender, CloseAccountCompletedEventArgs e);

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class CloseAccountCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs
    {

        private object[] results;

        internal CloseAccountCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) :
            base(exception, cancelled, userState)
        {
            this.results = results;
        }

        /// <remarks/>
        public string pbstrErrorXML
        {
            get
            {
                this.RaiseExceptionIfNecessary();
                return ((string)(this.results[0]));
            }
        }
    }

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void CloseBalanceCompletedEventHandler(object sender, CloseBalanceCompletedEventArgs e);

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class CloseBalanceCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs
    {

        private object[] results;

        internal CloseBalanceCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) :
            base(exception, cancelled, userState)
        {
            this.results = results;
        }

        /// <remarks/>
        public string pbstrErrorXML
        {
            get
            {
                this.RaiseExceptionIfNecessary();
                return ((string)(this.results[0]));
            }
        }

        /// <remarks/>
        public string pbstrAmountChargedXML
        {
            get
            {
                this.RaiseExceptionIfNecessary();
                return ((string)(this.results[1]));
            }
        }
    }

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void CompleteConversionCompletedEventHandler(object sender, CompleteConversionCompletedEventArgs e);

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class CompleteConversionCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs
    {

        private object[] results;

        internal CompleteConversionCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) :
            base(exception, cancelled, userState)
        {
            this.results = results;
        }

        /// <remarks/>
        public string pbstrErrorXML
        {
            get
            {
                this.RaiseExceptionIfNecessary();
                return ((string)(this.results[0]));
            }
        }

        /// <remarks/>
        public string pbstrAmountChargedXML
        {
            get
            {
                this.RaiseExceptionIfNecessary();
                return ((string)(this.results[1]));
            }
        }

        /// <remarks/>
        public int plAddedServiceInstanceSetCount
        {
            get
            {
                this.RaiseExceptionIfNecessary();
                return ((int)(this.results[2]));
            }
        }

        /// <remarks/>
        public string pbstrAddedServiceInstanceSet
        {
            get
            {
                this.RaiseExceptionIfNecessary();
                return ((string)(this.results[3]));
            }
        }

        /// <remarks/>
        public int plRemovedServiceInstanceSetCount
        {
            get
            {
                this.RaiseExceptionIfNecessary();
                return ((int)(this.results[4]));
            }
        }

        /// <remarks/>
        public string pbstrRemoveServiceInstanceSet
        {
            get
            {
                this.RaiseExceptionIfNecessary();
                return ((string)(this.results[5]));
            }
        }
    }

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void ConsumeTokenCompletedEventHandler(object sender, ConsumeTokenCompletedEventArgs e);

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class ConsumeTokenCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs
    {

        private object[] results;

        internal ConsumeTokenCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) :
            base(exception, cancelled, userState)
        {
            this.results = results;
        }

        /// <remarks/>
        public string consumedTokenDetailsXML
        {
            get
            {
                this.RaiseExceptionIfNecessary();
                return ((string)(this.results[0]));
            }
        }
    }

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void ConvertSubscriptionCompletedEventHandler(object sender, ConvertSubscriptionCompletedEventArgs e);

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class ConvertSubscriptionCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs
    {

        private object[] results;

        internal ConvertSubscriptionCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) :
            base(exception, cancelled, userState)
        {
            this.results = results;
        }

        /// <remarks/>
        public string pbstrErrorXML
        {
            get
            {
                this.RaiseExceptionIfNecessary();
                return ((string)(this.results[0]));
            }
        }

        /// <remarks/>
        public string pbstrAmountChargedXML
        {
            get
            {
                this.RaiseExceptionIfNecessary();
                return ((string)(this.results[1]));
            }
        }

        /// <remarks/>
        public int plAddedServiceInstanceSetCount
        {
            get
            {
                this.RaiseExceptionIfNecessary();
                return ((int)(this.results[2]));
            }
        }

        /// <remarks/>
        public string pbstrAddedServiceInstanceSet
        {
            get
            {
                this.RaiseExceptionIfNecessary();
                return ((string)(this.results[3]));
            }
        }

        /// <remarks/>
        public int plRemovedServiceInstanceSetCount
        {
            get
            {
                this.RaiseExceptionIfNecessary();
                return ((int)(this.results[4]));
            }
        }

        /// <remarks/>
        public string pbstrRemoveServiceInstanceSet
        {
            get
            {
                this.RaiseExceptionIfNecessary();
                return ((string)(this.results[5]));
            }
        }
    }

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void ConvertSubscriptionExCompletedEventHandler(object sender, ConvertSubscriptionExCompletedEventArgs e);

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class ConvertSubscriptionExCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs
    {

        private object[] results;

        internal ConvertSubscriptionExCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) :
            base(exception, cancelled, userState)
        {
            this.results = results;
        }

        /// <remarks/>
        public string pbstrErrorXML
        {
            get
            {
                this.RaiseExceptionIfNecessary();
                return ((string)(this.results[0]));
            }
        }

        /// <remarks/>
        public string pbstrAmountChargedXML
        {
            get
            {
                this.RaiseExceptionIfNecessary();
                return ((string)(this.results[1]));
            }
        }

        /// <remarks/>
        public int plAddedServiceInstanceSetCount
        {
            get
            {
                this.RaiseExceptionIfNecessary();
                return ((int)(this.results[2]));
            }
        }

        /// <remarks/>
        public string pbstrAddedServiceInstanceSet
        {
            get
            {
                this.RaiseExceptionIfNecessary();
                return ((string)(this.results[3]));
            }
        }

        /// <remarks/>
        public int plRemovedServiceInstanceSetCount
        {
            get
            {
                this.RaiseExceptionIfNecessary();
                return ((int)(this.results[4]));
            }
        }

        /// <remarks/>
        public string pbstrRemoveServiceInstanceSet
        {
            get
            {
                this.RaiseExceptionIfNecessary();
                return ((string)(this.results[5]));
            }
        }
    }

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void ConvertSubscriptionEx2CompletedEventHandler(object sender, ConvertSubscriptionEx2CompletedEventArgs e);

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class ConvertSubscriptionEx2CompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs
    {

        private object[] results;

        internal ConvertSubscriptionEx2CompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) :
            base(exception, cancelled, userState)
        {
            this.results = results;
        }

        /// <remarks/>
        public string pbstrErrorXML
        {
            get
            {
                this.RaiseExceptionIfNecessary();
                return ((string)(this.results[0]));
            }
        }

        /// <remarks/>
        public string pbstrAmountChargedXML
        {
            get
            {
                this.RaiseExceptionIfNecessary();
                return ((string)(this.results[1]));
            }
        }

        /// <remarks/>
        public int plAddedServiceInstanceSetCount
        {
            get
            {
                this.RaiseExceptionIfNecessary();
                return ((int)(this.results[2]));
            }
        }

        /// <remarks/>
        public string pbstrAddedServiceInstanceSet
        {
            get
            {
                this.RaiseExceptionIfNecessary();
                return ((string)(this.results[3]));
            }
        }

        /// <remarks/>
        public int plRemovedServiceInstanceSetCount
        {
            get
            {
                this.RaiseExceptionIfNecessary();
                return ((int)(this.results[4]));
            }
        }

        /// <remarks/>
        public string pbstrRemoveServiceInstanceSet
        {
            get
            {
                this.RaiseExceptionIfNecessary();
                return ((string)(this.results[5]));
            }
        }

        /// <remarks/>
        public string pbstrRedirectOutputInfoXML
        {
            get
            {
                this.RaiseExceptionIfNecessary();
                return ((string)(this.results[6]));
            }
        }
    }

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void ConvertSubscriptionEx3CompletedEventHandler(object sender, ConvertSubscriptionEx3CompletedEventArgs e);

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class ConvertSubscriptionEx3CompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs
    {

        private object[] results;

        internal ConvertSubscriptionEx3CompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) :
            base(exception, cancelled, userState)
        {
            this.results = results;
        }

        /// <remarks/>
        public string pbstrErrorXML
        {
            get
            {
                this.RaiseExceptionIfNecessary();
                return ((string)(this.results[0]));
            }
        }

        /// <remarks/>
        public string pbstrAmountChargedXML
        {
            get
            {
                this.RaiseExceptionIfNecessary();
                return ((string)(this.results[1]));
            }
        }

        /// <remarks/>
        public int plAddedServiceInstanceSetCount
        {
            get
            {
                this.RaiseExceptionIfNecessary();
                return ((int)(this.results[2]));
            }
        }

        /// <remarks/>
        public string pbstrAddedServiceInstanceSet
        {
            get
            {
                this.RaiseExceptionIfNecessary();
                return ((string)(this.results[3]));
            }
        }

        /// <remarks/>
        public int plRemovedServiceInstanceSetCount
        {
            get
            {
                this.RaiseExceptionIfNecessary();
                return ((int)(this.results[4]));
            }
        }

        /// <remarks/>
        public string pbstrRemoveServiceInstanceSet
        {
            get
            {
                this.RaiseExceptionIfNecessary();
                return ((string)(this.results[5]));
            }
        }

        /// <remarks/>
        public string pbstrRedirectOutputInfoXML
        {
            get
            {
                this.RaiseExceptionIfNecessary();
                return ((string)(this.results[6]));
            }
        }
    }

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void CreateAccountCompletedEventHandler(object sender, CreateAccountCompletedEventArgs e);

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class CreateAccountCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs
    {

        private object[] results;

        internal CreateAccountCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) :
            base(exception, cancelled, userState)
        {
            this.results = results;
        }

        /// <remarks/>
        public string pbstrErrorXML
        {
            get
            {
                this.RaiseExceptionIfNecessary();
                return ((string)(this.results[0]));
            }
        }

        /// <remarks/>
        public string pbstrAccountId
        {
            get
            {
                this.RaiseExceptionIfNecessary();
                return ((string)(this.results[1]));
            }
        }

        /// <remarks/>
        public string pbstrPaymentInstrumentId
        {
            get
            {
                this.RaiseExceptionIfNecessary();
                return ((string)(this.results[2]));
            }
        }

        /// <remarks/>
        public string pbstrDate
        {
            get
            {
                this.RaiseExceptionIfNecessary();
                return ((string)(this.results[3]));
            }
        }

        /// <remarks/>
        public string bstrRequiredPaperWorkURL
        {
            get
            {
                this.RaiseExceptionIfNecessary();
                return ((string)(this.results[4]));
            }
        }
    }

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void CreditPaymentInstrumentCompletedEventHandler(object sender, CreditPaymentInstrumentCompletedEventArgs e);

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class CreditPaymentInstrumentCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs
    {

        private object[] results;

        internal CreditPaymentInstrumentCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) :
            base(exception, cancelled, userState)
        {
            this.results = results;
        }

        /// <remarks/>
        public string pbstrError
        {
            get
            {
                this.RaiseExceptionIfNecessary();
                return ((string)(this.results[0]));
            }
        }
    }

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void CreditPaymentInstrumentExCompletedEventHandler(object sender, CreditPaymentInstrumentExCompletedEventArgs e);

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class CreditPaymentInstrumentExCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs
    {

        private object[] results;

        internal CreditPaymentInstrumentExCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) :
            base(exception, cancelled, userState)
        {
            this.results = results;
        }

        /// <remarks/>
        public string pbstrError
        {
            get
            {
                this.RaiseExceptionIfNecessary();
                return ((string)(this.results[0]));
            }
        }
    }

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void SetUserProfileCompletedEventHandler(object sender, System.ComponentModel.AsyncCompletedEventArgs e);

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void DeactivateTokenCompletedEventHandler(object sender, System.ComponentModel.AsyncCompletedEventArgs e);

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void DeactivateTokenExCompletedEventHandler(object sender, System.ComponentModel.AsyncCompletedEventArgs e);

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void DeliverTokenCompletedEventHandler(object sender, DeliverTokenCompletedEventArgs e);

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class DeliverTokenCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs
    {

        private object[] results;

        internal DeliverTokenCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) :
            base(exception, cancelled, userState)
        {
            this.results = results;
        }

        /// <remarks/>
        public string pbstrErrorXML
        {
            get
            {
                this.RaiseExceptionIfNecessary();
                return ((string)(this.results[0]));
            }
        }

        /// <remarks/>
        public string pbstrEncryptedTokenSetXML
        {
            get
            {
                this.RaiseExceptionIfNecessary();
                return ((string)(this.results[1]));
            }
        }
    }

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void DeprovisionServicesCompletedEventHandler(object sender, DeprovisionServicesCompletedEventArgs e);

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class DeprovisionServicesCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs
    {

        private object[] results;

        internal DeprovisionServicesCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) :
            base(exception, cancelled, userState)
        {
            this.results = results;
        }

        /// <remarks/>
        public string pbstrErrorXML
        {
            get
            {
                this.RaiseExceptionIfNecessary();
                return ((string)(this.results[0]));
            }
        }
    }

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void ExtendSubscriptionCompletedEventHandler(object sender, ExtendSubscriptionCompletedEventArgs e);

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class ExtendSubscriptionCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs
    {

        private object[] results;

        internal ExtendSubscriptionCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) :
            base(exception, cancelled, userState)
        {
            this.results = results;
        }

        /// <remarks/>
        public string pbstrErrorXML
        {
            get
            {
                this.RaiseExceptionIfNecessary();
                return ((string)(this.results[0]));
            }
        }

        /// <remarks/>
        public string pbstrNewExpirationDate
        {
            get
            {
                this.RaiseExceptionIfNecessary();
                return ((string)(this.results[1]));
            }
        }
    }

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void FixExistingAddressCompletedEventHandler(object sender, FixExistingAddressCompletedEventArgs e);

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class FixExistingAddressCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs
    {

        private object[] results;

        internal FixExistingAddressCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) :
            base(exception, cancelled, userState)
        {
            this.results = results;
        }

        /// <remarks/>
        public bool result
        {
            get
            {
                this.RaiseExceptionIfNecessary();
                return ((bool)(this.results[0]));
            }
        }

        /// <remarks/>
        public double confidenceScore
        {
            get
            {
                this.RaiseExceptionIfNecessary();
                return ((double)(this.results[1]));
            }
        }

        /// <remarks/>
        public int tryNumber
        {
            get
            {
                this.RaiseExceptionIfNecessary();
                return ((int)(this.results[2]));
            }
        }
    }

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void GetAccountIdFromAdminPUIDCompletedEventHandler(object sender, GetAccountIdFromAdminPUIDCompletedEventArgs e);

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class GetAccountIdFromAdminPUIDCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs
    {

        private object[] results;

        internal GetAccountIdFromAdminPUIDCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) :
            base(exception, cancelled, userState)
        {
            this.results = results;
        }

        /// <remarks/>
        public string pbstrErrorXML
        {
            get
            {
                this.RaiseExceptionIfNecessary();
                return ((string)(this.results[0]));
            }
        }

        /// <remarks/>
        public int pfMoreRows
        {
            get
            {
                this.RaiseExceptionIfNecessary();
                return ((int)(this.results[1]));
            }
        }

        /// <remarks/>
        public int plAccountInfoCount
        {
            get
            {
                this.RaiseExceptionIfNecessary();
                return ((int)(this.results[2]));
            }
        }

        /// <remarks/>
        public string pbstrAccountInfoSetXML
        {
            get
            {
                this.RaiseExceptionIfNecessary();
                return ((string)(this.results[3]));
            }
        }
    }

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void GetAccountIdFromPaymentInstrumentInfoCompletedEventHandler(object sender, GetAccountIdFromPaymentInstrumentInfoCompletedEventArgs e);

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class GetAccountIdFromPaymentInstrumentInfoCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs
    {

        private object[] results;

        internal GetAccountIdFromPaymentInstrumentInfoCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) :
            base(exception, cancelled, userState)
        {
            this.results = results;
        }

        /// <remarks/>
        public string pbstrErrorXML
        {
            get
            {
                this.RaiseExceptionIfNecessary();
                return ((string)(this.results[0]));
            }
        }

        /// <remarks/>
        public int pfMoreRows
        {
            get
            {
                this.RaiseExceptionIfNecessary();
                return ((int)(this.results[1]));
            }
        }

        /// <remarks/>
        public int plAccountInfoCount
        {
            get
            {
                this.RaiseExceptionIfNecessary();
                return ((int)(this.results[2]));
            }
        }

        /// <remarks/>
        public string pbstrAccountInfoSetXML
        {
            get
            {
                this.RaiseExceptionIfNecessary();
                return ((string)(this.results[3]));
            }
        }
    }

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void GetAccountIdFromPuidCompletedEventHandler(object sender, GetAccountIdFromPuidCompletedEventArgs e);

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class GetAccountIdFromPuidCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs
    {

        private object[] results;

        internal GetAccountIdFromPuidCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) :
            base(exception, cancelled, userState)
        {
            this.results = results;
        }

        /// <remarks/>
        public string errorXml
        {
            get
            {
                this.RaiseExceptionIfNecessary();
                return ((string)(this.results[0]));
            }
        }

        /// <remarks/>
        public int moreRows
        {
            get
            {
                this.RaiseExceptionIfNecessary();
                return ((int)(this.results[1]));
            }
        }

        /// <remarks/>
        public int accountInfoCount
        {
            get
            {
                this.RaiseExceptionIfNecessary();
                return ((int)(this.results[2]));
            }
        }

        /// <remarks/>
        public string accountInfoSetXml
        {
            get
            {
                this.RaiseExceptionIfNecessary();
                return ((string)(this.results[3]));
            }
        }
    }

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void GetAccountIdFromTokenCompletedEventHandler(object sender, GetAccountIdFromTokenCompletedEventArgs e);

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class GetAccountIdFromTokenCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs
    {

        private object[] results;

        internal GetAccountIdFromTokenCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) :
            base(exception, cancelled, userState)
        {
            this.results = results;
        }

        /// <remarks/>
        public string pbstrErrorXML
        {
            get
            {
                this.RaiseExceptionIfNecessary();
                return ((string)(this.results[0]));
            }
        }

        /// <remarks/>
        public int plAccountInfoCount
        {
            get
            {
                this.RaiseExceptionIfNecessary();
                return ((int)(this.results[1]));
            }
        }

        /// <remarks/>
        public string pbstrAccountInfoSetXML
        {
            get
            {
                this.RaiseExceptionIfNecessary();
                return ((string)(this.results[2]));
            }
        }
    }

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void GetAccountIdFromTokenIdCompletedEventHandler(object sender, GetAccountIdFromTokenIdCompletedEventArgs e);

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class GetAccountIdFromTokenIdCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs
    {

        private object[] results;

        internal GetAccountIdFromTokenIdCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) :
            base(exception, cancelled, userState)
        {
            this.results = results;
        }

        /// <remarks/>
        public string pbstrErrorXML
        {
            get
            {
                this.RaiseExceptionIfNecessary();
                return ((string)(this.results[0]));
            }
        }

        /// <remarks/>
        public int plAccountInfoCount
        {
            get
            {
                this.RaiseExceptionIfNecessary();
                return ((int)(this.results[1]));
            }
        }

        /// <remarks/>
        public string pbstrAccountInfoSetXML
        {
            get
            {
                this.RaiseExceptionIfNecessary();
                return ((string)(this.results[2]));
            }
        }
    }

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void GetAccountInfoCompletedEventHandler(object sender, GetAccountInfoCompletedEventArgs e);

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class GetAccountInfoCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs
    {

        private object[] results;

        internal GetAccountInfoCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) :
            base(exception, cancelled, userState)
        {
            this.results = results;
        }

        /// <remarks/>
        public string pbstrErrorXML
        {
            get
            {
                this.RaiseExceptionIfNecessary();
                return ((string)(this.results[0]));
            }
        }

        /// <remarks/>
        public string pbstrAccountInfoXML
        {
            get
            {
                this.RaiseExceptionIfNecessary();
                return ((string)(this.results[1]));
            }
        }
    }

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void GetAccountStatusCompletedEventHandler(object sender, GetAccountStatusCompletedEventArgs e);

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class GetAccountStatusCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs
    {

        private object[] results;

        internal GetAccountStatusCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) :
            base(exception, cancelled, userState)
        {
            this.results = results;
        }

        /// <remarks/>
        public string pbstrErrorXML
        {
            get
            {
                this.RaiseExceptionIfNecessary();
                return ((string)(this.results[0]));
            }
        }

        /// <remarks/>
        public string pbstrAccountStatusInfoXML
        {
            get
            {
                this.RaiseExceptionIfNecessary();
                return ((string)(this.results[1]));
            }
        }
    }

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void GetAdjustmentsCompletedEventHandler(object sender, GetAdjustmentsCompletedEventArgs e);

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class GetAdjustmentsCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs
    {

        private object[] results;

        internal GetAdjustmentsCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) :
            base(exception, cancelled, userState)
        {
            this.results = results;
        }

        /// <remarks/>
        public string pbstrErrorXML
        {
            get
            {
                this.RaiseExceptionIfNecessary();
                return ((string)(this.results[0]));
            }
        }

        /// <remarks/>
        public int pcAppliedAdjustmentCount
        {
            get
            {
                this.RaiseExceptionIfNecessary();
                return ((int)(this.results[1]));
            }
        }

        /// <remarks/>
        public string pbstrAppliedAdjustmentSetXML
        {
            get
            {
                this.RaiseExceptionIfNecessary();
                return ((string)(this.results[2]));
            }
        }

        /// <remarks/>
        public int pcAvailableAdjustmentCount
        {
            get
            {
                this.RaiseExceptionIfNecessary();
                return ((int)(this.results[3]));
            }
        }

        /// <remarks/>
        public string pbstrAvailableAdjustmentSetXML
        {
            get
            {
                this.RaiseExceptionIfNecessary();
                return ((string)(this.results[4]));
            }
        }
    }

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void GetBaseOfferingsCompletedEventHandler(object sender, GetBaseOfferingsCompletedEventArgs e);

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class GetBaseOfferingsCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs
    {

        private object[] results;

        internal GetBaseOfferingsCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) :
            base(exception, cancelled, userState)
        {
            this.results = results;
        }

        /// <remarks/>
        public string pbstrErrorText
        {
            get
            {
                this.RaiseExceptionIfNecessary();
                return ((string)(this.results[0]));
            }
        }

        /// <remarks/>
        public int plOfferingInfoCount
        {
            get
            {
                this.RaiseExceptionIfNecessary();
                return ((int)(this.results[1]));
            }
        }

        /// <remarks/>
        public string pbstrOfferingInfoSetXML
        {
            get
            {
                this.RaiseExceptionIfNecessary();
                return ((string)(this.results[2]));
            }
        }
    }

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void GetBaseOfferingsExCompletedEventHandler(object sender, GetBaseOfferingsExCompletedEventArgs e);

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class GetBaseOfferingsExCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs
    {

        private object[] results;

        internal GetBaseOfferingsExCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) :
            base(exception, cancelled, userState)
        {
            this.results = results;
        }

        /// <remarks/>
        public string pbstrErrorText
        {
            get
            {
                this.RaiseExceptionIfNecessary();
                return ((string)(this.results[0]));
            }
        }

        /// <remarks/>
        public int plOfferingInfoCount
        {
            get
            {
                this.RaiseExceptionIfNecessary();
                return ((int)(this.results[1]));
            }
        }

        /// <remarks/>
        public string pbstrOfferingInfoSetXML
        {
            get
            {
                this.RaiseExceptionIfNecessary();
                return ((string)(this.results[2]));
            }
        }
    }

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void GetBillingPeriodsCompletedEventHandler(object sender, GetBillingPeriodsCompletedEventArgs e);

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class GetBillingPeriodsCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs
    {

        private object[] results;

        internal GetBillingPeriodsCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) :
            base(exception, cancelled, userState)
        {
            this.results = results;
        }

        /// <remarks/>
        public string pbstrErrorXML
        {
            get
            {
                this.RaiseExceptionIfNecessary();
                return ((string)(this.results[0]));
            }
        }

        /// <remarks/>
        public int plBillingPeriodCount
        {
            get
            {
                this.RaiseExceptionIfNecessary();
                return ((int)(this.results[1]));
            }
        }

        /// <remarks/>
        public string pbstrBillingPeriodSetXML
        {
            get
            {
                this.RaiseExceptionIfNecessary();
                return ((string)(this.results[2]));
            }
        }
    }

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void GetBillingReferenceCompletedEventHandler(object sender, GetBillingReferenceCompletedEventArgs e);

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class GetBillingReferenceCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs
    {

        private object[] results;

        internal GetBillingReferenceCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) :
            base(exception, cancelled, userState)
        {
            this.results = results;
        }

        /// <remarks/>
        public string billingReferenceInfoSetXml
        {
            get
            {
                this.RaiseExceptionIfNecessary();
                return ((string)(this.results[0]));
            }
        }
    }

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void GetCommentsCompletedEventHandler(object sender, GetCommentsCompletedEventArgs e);

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class GetCommentsCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs
    {

        private object[] results;

        internal GetCommentsCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) :
            base(exception, cancelled, userState)
        {
            this.results = results;
        }

        /// <remarks/>
        public string pbstrErrorXML
        {
            get
            {
                this.RaiseExceptionIfNecessary();
                return ((string)(this.results[0]));
            }
        }

        /// <remarks/>
        public int plCommentInfoSetCount
        {
            get
            {
                this.RaiseExceptionIfNecessary();
                return ((int)(this.results[1]));
            }
        }

        /// <remarks/>
        public string pbstrCommentInfoSetXML
        {
            get
            {
                this.RaiseExceptionIfNecessary();
                return ((string)(this.results[2]));
            }
        }
    }

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void GetEligibleOfferingsCompletedEventHandler(object sender, GetEligibleOfferingsCompletedEventArgs e);

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class GetEligibleOfferingsCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs
    {

        private object[] results;

        internal GetEligibleOfferingsCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) :
            base(exception, cancelled, userState)
        {
            this.results = results;
        }

        /// <remarks/>
        public string pbstrErrorText
        {
            get
            {
                this.RaiseExceptionIfNecessary();
                return ((string)(this.results[0]));
            }
        }

        /// <remarks/>
        public int plOfferingInfoCount
        {
            get
            {
                this.RaiseExceptionIfNecessary();
                return ((int)(this.results[1]));
            }
        }

        /// <remarks/>
        public string pbstrOfferingInfoSetXML
        {
            get
            {
                this.RaiseExceptionIfNecessary();
                return ((string)(this.results[2]));
            }
        }
    }

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void GetEligibleOfferingsExCompletedEventHandler(object sender, GetEligibleOfferingsExCompletedEventArgs e);

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class GetEligibleOfferingsExCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs
    {

        private object[] results;

        internal GetEligibleOfferingsExCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) :
            base(exception, cancelled, userState)
        {
            this.results = results;
        }

        /// <remarks/>
        public string pbstrErrorText
        {
            get
            {
                this.RaiseExceptionIfNecessary();
                return ((string)(this.results[0]));
            }
        }

        /// <remarks/>
        public int plOfferingInfoCount
        {
            get
            {
                this.RaiseExceptionIfNecessary();
                return ((int)(this.results[1]));
            }
        }

        /// <remarks/>
        public string pbstrOfferingInfoSetXML
        {
            get
            {
                this.RaiseExceptionIfNecessary();
                return ((string)(this.results[2]));
            }
        }
    }

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void GetEligibleSwitchPITypesCompletedEventHandler(object sender, GetEligibleSwitchPITypesCompletedEventArgs e);

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class GetEligibleSwitchPITypesCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs
    {

        private object[] results;

        internal GetEligibleSwitchPITypesCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) :
            base(exception, cancelled, userState)
        {
            this.results = results;
        }

        /// <remarks/>
        public string pbstrErrorXML
        {
            get
            {
                this.RaiseExceptionIfNecessary();
                return ((string)(this.results[0]));
            }
        }

        /// <remarks/>
        public int plPITypeCount
        {
            get
            {
                this.RaiseExceptionIfNecessary();
                return ((int)(this.results[1]));
            }
        }

        /// <remarks/>
        public string pbstrPITypeSetXML
        {
            get
            {
                this.RaiseExceptionIfNecessary();
                return ((string)(this.results[2]));
            }
        }
    }

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void GetExistingAccountsByCriteriaCompletedEventHandler(object sender, GetExistingAccountsByCriteriaCompletedEventArgs e);

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class GetExistingAccountsByCriteriaCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs
    {

        private object[] results;

        internal GetExistingAccountsByCriteriaCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) :
            base(exception, cancelled, userState)
        {
            this.results = results;
        }

        /// <remarks/>
        public string pbstrErrorXML
        {
            get
            {
                this.RaiseExceptionIfNecessary();
                return ((string)(this.results[0]));
            }
        }

        /// <remarks/>
        public int plAccountDetailCount
        {
            get
            {
                this.RaiseExceptionIfNecessary();
                return ((int)(this.results[1]));
            }
        }

        /// <remarks/>
        public string pbstrAccountDetailSetXML
        {
            get
            {
                this.RaiseExceptionIfNecessary();
                return ((string)(this.results[2]));
            }
        }
    }

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void GetKeyCompletedEventHandler(object sender, GetKeyCompletedEventArgs e);

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class GetKeyCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs
    {

        private object[] results;

        internal GetKeyCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) :
            base(exception, cancelled, userState)
        {
            this.results = results;
        }

        /// <remarks/>
        public string pbstrErrorXML
        {
            get
            {
                this.RaiseExceptionIfNecessary();
                return ((string)(this.results[0]));
            }
        }

        /// <remarks/>
        public string pbstrKeyXml
        {
            get
            {
                this.RaiseExceptionIfNecessary();
                return ((string)(this.results[1]));
            }
        }
    }

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void GetLineItemHistoryCompletedEventHandler(object sender, GetLineItemHistoryCompletedEventArgs e);

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class GetLineItemHistoryCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs
    {

        private object[] results;

        internal GetLineItemHistoryCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) :
            base(exception, cancelled, userState)
        {
            this.results = results;
        }

        /// <remarks/>
        public string errorXml
        {
            get
            {
                this.RaiseExceptionIfNecessary();
                return ((string)(this.results[0]));
            }
        }

        /// <remarks/>
        public string lineItemHistorySetXml
        {
            get
            {
                this.RaiseExceptionIfNecessary();
                return ((string)(this.results[1]));
            }
        }

        /// <remarks/>
        public string mcv
        {
            get
            {
                this.RaiseExceptionIfNecessary();
                return ((string)(this.results[2]));
            }
        }
    }

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void GetPartnerConfigurationCompletedEventHandler(object sender, GetPartnerConfigurationCompletedEventArgs e);

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class GetPartnerConfigurationCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs
    {

        private object[] results;

        internal GetPartnerConfigurationCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) :
            base(exception, cancelled, userState)
        {
            this.results = results;
        }

        /// <remarks/>
        public string responseXML
        {
            get
            {
                this.RaiseExceptionIfNecessary();
                return ((string)(this.results[0]));
            }
        }
    }

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void GetPaymentInstrumentsCompletedEventHandler(object sender, GetPaymentInstrumentsCompletedEventArgs e);

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class GetPaymentInstrumentsCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs
    {

        private object[] results;

        internal GetPaymentInstrumentsCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) :
            base(exception, cancelled, userState)
        {
            this.results = results;
        }

        /// <remarks/>
        public string pbstrErrorXML
        {
            get
            {
                this.RaiseExceptionIfNecessary();
                return ((string)(this.results[0]));
            }
        }

        /// <remarks/>
        public int plPaymentInstrumentInfoCount
        {
            get
            {
                this.RaiseExceptionIfNecessary();
                return ((int)(this.results[1]));
            }
        }

        /// <remarks/>
        public string pbstrPaymentInstrumentInfoSetXML
        {
            get
            {
                this.RaiseExceptionIfNecessary();
                return ((string)(this.results[2]));
            }
        }
    }

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void GetPaymentInstrumentsExCompletedEventHandler(object sender, GetPaymentInstrumentsExCompletedEventArgs e);

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class GetPaymentInstrumentsExCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs
    {

        private object[] results;

        internal GetPaymentInstrumentsExCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) :
            base(exception, cancelled, userState)
        {
            this.results = results;
        }

        /// <remarks/>
        public string pbstrErrorXML
        {
            get
            {
                this.RaiseExceptionIfNecessary();
                return ((string)(this.results[0]));
            }
        }

        /// <remarks/>
        public int plPaymentInstrumentInfoCount
        {
            get
            {
                this.RaiseExceptionIfNecessary();
                return ((int)(this.results[1]));
            }
        }

        /// <remarks/>
        public string pbstrPaymentInstrumentInfoSetXML
        {
            get
            {
                this.RaiseExceptionIfNecessary();
                return ((string)(this.results[2]));
            }
        }
    }

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void GetPaymentMethodTypePropertiesCompletedEventHandler(object sender, GetPaymentMethodTypePropertiesCompletedEventArgs e);

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class GetPaymentMethodTypePropertiesCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs
    {

        private object[] results;

        internal GetPaymentMethodTypePropertiesCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) :
            base(exception, cancelled, userState)
        {
            this.results = results;
        }

        /// <remarks/>
        public string paymentTypeInfoSetXml
        {
            get
            {
                this.RaiseExceptionIfNecessary();
                return ((string)(this.results[0]));
            }
        }
    }

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void GetPermitHistoryForObjectIdCompletedEventHandler(object sender, GetPermitHistoryForObjectIdCompletedEventArgs e);

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class GetPermitHistoryForObjectIdCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs
    {

        private object[] results;

        internal GetPermitHistoryForObjectIdCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) :
            base(exception, cancelled, userState)
        {
            this.results = results;
        }

        /// <remarks/>
        public string errorXml
        {
            get
            {
                this.RaiseExceptionIfNecessary();
                return ((string)(this.results[0]));
            }
        }

        /// <remarks/>
        public int permitCount
        {
            get
            {
                this.RaiseExceptionIfNecessary();
                return ((int)(this.results[1]));
            }
        }

        /// <remarks/>
        public string permitSetXML
        {
            get
            {
                this.RaiseExceptionIfNecessary();
                return ((string)(this.results[2]));
            }
        }
    }

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void GetPermitsForObjectIdCompletedEventHandler(object sender, GetPermitsForObjectIdCompletedEventArgs e);

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class GetPermitsForObjectIdCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs
    {

        private object[] results;

        internal GetPermitsForObjectIdCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) :
            base(exception, cancelled, userState)
        {
            this.results = results;
        }

        /// <remarks/>
        public string pbstrErrorXML
        {
            get
            {
                this.RaiseExceptionIfNecessary();
                return ((string)(this.results[0]));
            }
        }

        /// <remarks/>
        public int plPermitCount
        {
            get
            {
                this.RaiseExceptionIfNecessary();
                return ((int)(this.results[1]));
            }
        }

        /// <remarks/>
        public string pbstrPermitSetXML
        {
            get
            {
                this.RaiseExceptionIfNecessary();
                return ((string)(this.results[2]));
            }
        }
    }

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void GetPermitsForPUIDCompletedEventHandler(object sender, GetPermitsForPUIDCompletedEventArgs e);

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class GetPermitsForPUIDCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs
    {

        private object[] results;

        internal GetPermitsForPUIDCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) :
            base(exception, cancelled, userState)
        {
            this.results = results;
        }

        /// <remarks/>
        public string pbstrErrorXML
        {
            get
            {
                this.RaiseExceptionIfNecessary();
                return ((string)(this.results[0]));
            }
        }

        /// <remarks/>
        public int plPermitCount
        {
            get
            {
                this.RaiseExceptionIfNecessary();
                return ((int)(this.results[1]));
            }
        }

        /// <remarks/>
        public string pbstrPermitSetXML
        {
            get
            {
                this.RaiseExceptionIfNecessary();
                return ((string)(this.results[2]));
            }
        }
    }

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void GetPolicyCompletedEventHandler(object sender, GetPolicyCompletedEventArgs e);

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class GetPolicyCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs
    {

        private object[] results;

        internal GetPolicyCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) :
            base(exception, cancelled, userState)
        {
            this.results = results;
        }

        /// <remarks/>
        public string pbstrPolicyInfoXML
        {
            get
            {
                this.RaiseExceptionIfNecessary();
                return ((string)(this.results[0]));
            }
        }

        /// <remarks/>
        public string pbstrErrorXML
        {
            get
            {
                this.RaiseExceptionIfNecessary();
                return ((string)(this.results[1]));
            }
        }
    }

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void GetProductClassesCompletedEventHandler(object sender, GetProductClassesCompletedEventArgs e);

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class GetProductClassesCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs
    {

        private object[] results;

        internal GetProductClassesCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) :
            base(exception, cancelled, userState)
        {
            this.results = results;
        }

        /// <remarks/>
        public string productClassSetXml
        {
            get
            {
                this.RaiseExceptionIfNecessary();
                return ((string)(this.results[0]));
            }
        }
    }

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void GetProvisioningInfoCompletedEventHandler(object sender, GetProvisioningInfoCompletedEventArgs e);

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class GetProvisioningInfoCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs
    {

        private object[] results;

        internal GetProvisioningInfoCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) :
            base(exception, cancelled, userState)
        {
            this.results = results;
        }

        /// <remarks/>
        public string ProvisioningInfoXml
        {
            get
            {
                this.RaiseExceptionIfNecessary();
                return ((string)(this.results[0]));
            }
        }
    }

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void GetReferralDataCompletedEventHandler(object sender, GetReferralDataCompletedEventArgs e);

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class GetReferralDataCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs
    {

        private object[] results;

        internal GetReferralDataCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) :
            base(exception, cancelled, userState)
        {
            this.results = results;
        }

        /// <remarks/>
        public string pbstrErrorXML
        {
            get
            {
                this.RaiseExceptionIfNecessary();
                return ((string)(this.results[0]));
            }
        }

        /// <remarks/>
        public int plReferralCount
        {
            get
            {
                this.RaiseExceptionIfNecessary();
                return ((int)(this.results[1]));
            }
        }

        /// <remarks/>
        public string pbstrReferralSetXML
        {
            get
            {
                this.RaiseExceptionIfNecessary();
                return ((string)(this.results[2]));
            }
        }
    }

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void GetReferralEventsCompletedEventHandler(object sender, GetReferralEventsCompletedEventArgs e);

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class GetReferralEventsCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs
    {

        private object[] results;

        internal GetReferralEventsCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) :
            base(exception, cancelled, userState)
        {
            this.results = results;
        }

        /// <remarks/>
        public string ReferralEventsInfoXML
        {
            get
            {
                this.RaiseExceptionIfNecessary();
                return ((string)(this.results[0]));
            }
        }
    }

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void GetResourceBalancesCompletedEventHandler(object sender, GetResourceBalancesCompletedEventArgs e);

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class GetResourceBalancesCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs
    {

        private object[] results;

        internal GetResourceBalancesCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) :
            base(exception, cancelled, userState)
        {
            this.results = results;
        }

        /// <remarks/>
        public string pbstrErrorText
        {
            get
            {
                this.RaiseExceptionIfNecessary();
                return ((string)(this.results[0]));
            }
        }

        /// <remarks/>
        public int pcResourceInfoCount
        {
            get
            {
                this.RaiseExceptionIfNecessary();
                return ((int)(this.results[1]));
            }
        }

        /// <remarks/>
        public string pbstrResourceInfoSet
        {
            get
            {
                this.RaiseExceptionIfNecessary();
                return ((string)(this.results[2]));
            }
        }
    }

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void GetReplacementTokenCompletedEventHandler(object sender, GetReplacementTokenCompletedEventArgs e);

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class GetReplacementTokenCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs
    {

        private object[] results;

        internal GetReplacementTokenCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) :
            base(exception, cancelled, userState)
        {
            this.results = results;
        }

        /// <remarks/>
        public string replacementPin
        {
            get
            {
                this.RaiseExceptionIfNecessary();
                return ((string)(this.results[0]));
            }
        }

        /// <remarks/>
        public int signature
        {
            get
            {
                this.RaiseExceptionIfNecessary();
                return ((int)(this.results[1]));
            }
        }

        /// <remarks/>
        public string sequenceNumber
        {
            get
            {
                this.RaiseExceptionIfNecessary();
                return ((string)(this.results[2]));
            }
        }
    }

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void GetReplacementTokenFromPuidCompletedEventHandler(object sender, GetReplacementTokenFromPuidCompletedEventArgs e);

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class GetReplacementTokenFromPuidCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs
    {

        private object[] results;

        internal GetReplacementTokenFromPuidCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) :
            base(exception, cancelled, userState)
        {
            this.results = results;
        }

        /// <remarks/>
        public int tokenInfoReturnedCount
        {
            get
            {
                this.RaiseExceptionIfNecessary();
                return ((int)(this.results[0]));
            }
        }

        /// <remarks/>
        public string replacementTokenSetXml
        {
            get
            {
                this.RaiseExceptionIfNecessary();
                return ((string)(this.results[1]));
            }
        }
    }

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void GetResourcePricesCompletedEventHandler(object sender, GetResourcePricesCompletedEventArgs e);

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class GetResourcePricesCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs
    {

        private object[] results;

        internal GetResourcePricesCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) :
            base(exception, cancelled, userState)
        {
            this.results = results;
        }

        /// <remarks/>
        public string pbstrErrorXML
        {
            get
            {
                this.RaiseExceptionIfNecessary();
                return ((string)(this.results[0]));
            }
        }

        /// <remarks/>
        public int plCount
        {
            get
            {
                this.RaiseExceptionIfNecessary();
                return ((int)(this.results[1]));
            }
        }

        /// <remarks/>
        public string pbstrResourcePriceSetXML
        {
            get
            {
                this.RaiseExceptionIfNecessary();
                return ((string)(this.results[2]));
            }
        }
    }

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void GetStatementCompletedEventHandler(object sender, GetStatementCompletedEventArgs e);

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class GetStatementCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs
    {

        private object[] results;

        internal GetStatementCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) :
            base(exception, cancelled, userState)
        {
            this.results = results;
        }

        /// <remarks/>
        public string errorXml
        {
            get
            {
                this.RaiseExceptionIfNecessary();
                return ((string)(this.results[0]));
            }
        }

        /// <remarks/>
        public string accountStatementInfoSetXml
        {
            get
            {
                this.RaiseExceptionIfNecessary();
                return ((string)(this.results[1]));
            }
        }

        /// <remarks/>
        public string userNotificationSetXml
        {
            get
            {
                this.RaiseExceptionIfNecessary();
                return ((string)(this.results[2]));
            }
        }
    }

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void GetStatementExCompletedEventHandler(object sender, GetStatementExCompletedEventArgs e);

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class GetStatementExCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs
    {

        private object[] results;

        internal GetStatementExCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) :
            base(exception, cancelled, userState)
        {
            this.results = results;
        }

        /// <remarks/>
        public string errorXml
        {
            get
            {
                this.RaiseExceptionIfNecessary();
                return ((string)(this.results[0]));
            }
        }

        /// <remarks/>
        public string accountStatementInfoSetXml
        {
            get
            {
                this.RaiseExceptionIfNecessary();
                return ((string)(this.results[1]));
            }
        }

        /// <remarks/>
        public string userNotificationSetXml
        {
            get
            {
                this.RaiseExceptionIfNecessary();
                return ((string)(this.results[2]));
            }
        }
    }

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void GetSubscriptionHistoryCompletedEventHandler(object sender, GetSubscriptionHistoryCompletedEventArgs e);

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class GetSubscriptionHistoryCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs
    {

        private object[] results;

        internal GetSubscriptionHistoryCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) :
            base(exception, cancelled, userState)
        {
            this.results = results;
        }

        /// <remarks/>
        public string pbstrErrorXML
        {
            get
            {
                this.RaiseExceptionIfNecessary();
                return ((string)(this.results[0]));
            }
        }

        /// <remarks/>
        public int plHistoryEventCount
        {
            get
            {
                this.RaiseExceptionIfNecessary();
                return ((int)(this.results[1]));
            }
        }

        /// <remarks/>
        public string pbstrSubscriptionHistoryEventSetXML
        {
            get
            {
                this.RaiseExceptionIfNecessary();
                return ((string)(this.results[2]));
            }
        }
    }

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void GetServiceComponentsCompletedEventHandler(object sender, GetServiceComponentsCompletedEventArgs e);

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class GetServiceComponentsCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs
    {

        private object[] results;

        internal GetServiceComponentsCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) :
            base(exception, cancelled, userState)
        {
            this.results = results;
        }

        /// <remarks/>
        public string pbstrErrorText
        {
            get
            {
                this.RaiseExceptionIfNecessary();
                return ((string)(this.results[0]));
            }
        }

        /// <remarks/>
        public int plServiceComponentCount
        {
            get
            {
                this.RaiseExceptionIfNecessary();
                return ((int)(this.results[1]));
            }
        }

        /// <remarks/>
        public string pbstrServiceComponentSetXML
        {
            get
            {
                this.RaiseExceptionIfNecessary();
                return ((string)(this.results[2]));
            }
        }
    }

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void GetSubscriptionsCompletedEventHandler(object sender, GetSubscriptionsCompletedEventArgs e);

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class GetSubscriptionsCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs
    {

        private object[] results;

        internal GetSubscriptionsCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) :
            base(exception, cancelled, userState)
        {
            this.results = results;
        }

        /// <remarks/>
        public string pbstrErrorXML
        {
            get
            {
                this.RaiseExceptionIfNecessary();
                return ((string)(this.results[0]));
            }
        }

        /// <remarks/>
        public int plSubscriptionInfoCount
        {
            get
            {
                this.RaiseExceptionIfNecessary();
                return ((int)(this.results[1]));
            }
        }

        /// <remarks/>
        public string pbstrSubscriptionInfoSetXML
        {
            get
            {
                this.RaiseExceptionIfNecessary();
                return ((string)(this.results[2]));
            }
        }
    }

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void GetSubscriptionStatusCompletedEventHandler(object sender, GetSubscriptionStatusCompletedEventArgs e);

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class GetSubscriptionStatusCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs
    {

        private object[] results;

        internal GetSubscriptionStatusCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) :
            base(exception, cancelled, userState)
        {
            this.results = results;
        }

        /// <remarks/>
        public string pbstrErrorXML
        {
            get
            {
                this.RaiseExceptionIfNecessary();
                return ((string)(this.results[0]));
            }
        }

        /// <remarks/>
        public string pbstrSubscriptionStatusInfoXML
        {
            get
            {
                this.RaiseExceptionIfNecessary();
                return ((string)(this.results[1]));
            }
        }
    }

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void GetTokenClassRestrictionInfoForPUIDCompletedEventHandler(object sender, GetTokenClassRestrictionInfoForPUIDCompletedEventArgs e);

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class GetTokenClassRestrictionInfoForPUIDCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs
    {

        private object[] results;

        internal GetTokenClassRestrictionInfoForPUIDCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) :
            base(exception, cancelled, userState)
        {
            this.results = results;
        }

        /// <remarks/>
        public string tokenClassRestrictionInfoSetXML
        {
            get
            {
                this.RaiseExceptionIfNecessary();
                return ((string)(this.results[0]));
            }
        }
    }

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void GetTokenClassesCompletedEventHandler(object sender, GetTokenClassesCompletedEventArgs e);

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class GetTokenClassesCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs
    {

        private object[] results;

        internal GetTokenClassesCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) :
            base(exception, cancelled, userState)
        {
            this.results = results;
        }

        /// <remarks/>
        public int plAdditionalTokenClassCount
        {
            get
            {
                this.RaiseExceptionIfNecessary();
                return ((int)(this.results[0]));
            }
        }

        /// <remarks/>
        public int plTokenClassReturnedCount
        {
            get
            {
                this.RaiseExceptionIfNecessary();
                return ((int)(this.results[1]));
            }
        }

        /// <remarks/>
        public string pbstrTokenClassSetXML
        {
            get
            {
                this.RaiseExceptionIfNecessary();
                return ((string)(this.results[2]));
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\marketplace\billing\PassportUtil.cs ===
using System;
using System.Text;
using System.Collections;
using System.Text.RegularExpressions;
using System.Security.Cryptography;
using System.IO;

using xonline.common.billing;
using xonline.common.config;
using xonline.common.mgmt;
using xonline.common.protocol;
using xonline.common.service;
using xonline.common.sql.webstore;
using xonline.common.user;
using xonline.common.utilities;

namespace xonline.common.billing
{
    /// <summary>
    /// This class is intended to be used only by clients who have no direct access to passport.
    /// </summary>
    public static class PassportUtil
    {
        public static byte[] GetEncryptedPassword(string oldPassword, string newPassword, string secretAnswer, XePassportGetEncryptedProxyParametersResponse encryptedProxyParams)
        {
            byte[] binOldPassword = Encoding.ASCII.GetBytes(oldPassword);
            byte[] binPassword = Encoding.ASCII.GetBytes(newPassword);
            byte[] binSecretAnswer = Encoding.Unicode.GetBytes(secretAnswer);
            byte[] credentials;

            using (BinaryWriter bw = new BinaryWriter(new MemoryStream(200)))
            {
                bw.Write((byte)1); // Version of the encryption scheme
                bw.Write((byte)1); // Version of the format of the plaintext string
                bw.Write((byte)binPassword.Length); // Size of password in bytes
                bw.Write(binPassword); // Password in ascii
                bw.Write((byte)binSecretAnswer.Length); // Size of secret-answer in bytes
                if (0 < binSecretAnswer.Length) bw.Write(binSecretAnswer); // secret-answer in unicode
                bw.Write((byte)binOldPassword.Length); // Size of old-password.
                if (0 < binOldPassword.Length) bw.Write(binOldPassword); // old-password in ascii

                credentials = ((MemoryStream)bw.BaseStream).ToArray();
            }

            // Encrypt
            return PassportUtil.EncryptWithPassportPublicKey(credentials, encryptedProxyParams);
        }

        public static byte[] EncryptWithPassportPublicKey(byte[] data, XePassportGetEncryptedProxyParametersResponse encryptedProxyParams)
        {
            byte[] modulus = encryptedProxyParams.publicKeyModulus;
            uint pubexp = encryptedProxyParams.publicKeyPublicExponent;

            // Managed RSA provider expects key data in big endian order
            byte[] rmodulus = PassportUtil.DuplicateAndReverse(modulus);
            byte[] rpubexp = new byte[] {
                (byte) ((pubexp & 0xFF000000)>>24),
                (byte) ((pubexp & 0xFF0000)>>16),
                (byte) ((pubexp & 0xFF00)>>8),
                (byte) (pubexp & 0xFF)
            };

            // Load up key
            using (RSACryptoServiceProvider rsa = new RSACryptoServiceProvider())
            {
                RSAParameters keyInfo = new RSAParameters();
                keyInfo.Modulus = rmodulus;
                keyInfo.Exponent = rpubexp;
                rsa.ImportParameters(keyInfo);

                // Calculate the max size of message bytes that can be encrypted
                // in one block of cipher text and the number of blocks necessary
                // to encrypt the whole thing
                int msgblocksize = modulus.Length - 2 - 2 * 20;
                int blockcount = (data.Length / msgblocksize) + ((data.Length % msgblocksize) != 0 ? 1 : 0);

                // Encrypt
                using (MemoryStream ciphertext = new MemoryStream(blockcount * modulus.Length))
                {
                    byte[] msgblock = new byte[msgblocksize];
                    int dataleft = data.Length;
                    for (int i = 0; i < blockcount; i++)
                    {
                        int size = Math.Min(dataleft, msgblocksize);
                        if (size != msgblock.Length)
                            msgblock = new byte[size];

                        Buffer.BlockCopy(data, i * msgblocksize, msgblock, 0, size);
                        byte[] cipherblock = rsa.Encrypt(msgblock, true);
                        Array.Reverse(cipherblock);
                        ciphertext.Write(cipherblock, 0, cipherblock.Length);
                        dataleft -= size;
                    }

                    return ciphertext.ToArray();
                }
            }
        }

        // Copy buffer and reverse it at the same time
        private static byte[] DuplicateAndReverse(byte[] bin)
        {
            byte[] rdup = new byte[bin.Length];

            int rduplength = rdup.Length;
            for (int i = 0; i < bin.Length; i++)
            {
                rdup[rduplength - i - 1] = bin[i];
            }

            return rdup;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\marketplace\billing\passport.cs ===
using System;
using System.Collections;
using System.Collections.Generic;
using System.Globalization;
using System.IO;
using System.Linq;
using System.Net;
using System.Runtime.InteropServices;
using System.Security.Cryptography;
using System.Security.Cryptography.X509Certificates;
using System.Threading;
using System.Text;
using System.Web.Services.Protocols;
using System.Xml;

using xonline.common.config;
using xonline.common.mgmt;
using xonline.common.service;
using xonline.common.billing.passport;
using xonline.common.utilities;
using xonline.common.utilities2;
using xonline.common.protocol;

[assembly: XomAreaDefinition(XomAreaName.passportLog)]

namespace xonline.common.billing
{
    public class PassportClientException : XRLException
    {
        public PassportClientException(
                HResult     hr,
                HResult     internalHr,
                XEvent.Id   eventid,
                string      message,
                Exception   e
                )
        : base(hr, eventid, message + String.Format("\nhr = {0}\nInternal hr = {1}", hr, internalHr), e)
        {
            _internalHr = internalHr;
        }

        public HResult InternalHResult
        {
            get { return _internalHr; }
        }

        protected HResult _internalHr;

    }

    public enum WLIDStatus
    {
        Valid,
        Invalid,
        Unknown
    };

    public class PassportMemberNameCredentials
    {
        public readonly string PassportMemberName;
        public readonly Puid PassportPuid;
        public readonly bool IsActive;

        public PassportMemberNameCredentials(XmlNode node)
        {
            bool pmnFound = false, ppFound = false, iaFound = false;

            for (XmlNode propertyNode = node.FirstChild; propertyNode != null; propertyNode = propertyNode.NextSibling)
            {
                if (propertyNode.Name != "p:property")
                    throw new XRLExceptionWithoutEvent( HResult.XONLINE_E_PASSPORT_ERROR,
                                                        "Expected to find node 'p:property' but instead found {0}",
                                                        propertyNode.Name);

                XmlAttribute nameAttribute = (XmlAttribute)propertyNode.Attributes.GetNamedItem("name");

                if (nameAttribute == null)
                    throw new XRLExceptionWithoutEvent( HResult.XONLINE_E_PASSPORT_ERROR,
                                                        "The property node didn't have an attribute called 'name' as expected.");

                string nodeText = propertyNode.InnerText;
                nodeText = nodeText.Replace("\n", "");
                nodeText = nodeText.Replace("\r", "");
                nodeText = nodeText.Trim();

                switch (nameAttribute.Value)
                {
                    case "Name":
                        {
                            if (pmnFound)
                                throw new XRLExceptionWithoutEvent( HResult.XONLINE_E_PASSPORT_ERROR,
                                                                    "Already found one propery for 'Name' ({0}) and just found a second one ({1}).",
                                                                    PassportMemberName,
                                                                    nodeText);
                            pmnFound = true;

                            PassportMemberName = nodeText;
                        }
                        break;

                    case "NETID":
                        {
                            if (ppFound)
                                throw new XRLExceptionWithoutEvent( HResult.XONLINE_E_PASSPORT_ERROR,
                                                                    "Already found one property for 'NETID' ({0}) and just found a second one ({1}).",
                                                                    PassportPuid,
                                                                    nodeText);
                            ppFound = true;

                            PassportPuid = Puid.Parse(nodeText);
                        }
                        break;

                    case "Active":
                        {
                            if (iaFound)
                                throw new XRLExceptionWithoutEvent( HResult.XONLINE_E_PASSPORT_ERROR,
                                                                    "Already found one property for 'Active' ({0}) and just found a second one ({1}).",
                                                                    IsActive,
                                                                    nodeText);
                            iaFound = true;

                            IsActive = Convert.ToBoolean(nodeText);
                        }
                        break;

                    default: throw new XRLExceptionWithoutEvent(HResult.XONLINE_E_PASSPORT_ERROR,
                                                                "Found unexpected property: {0}.",
                                                                nameAttribute.Value);
                }
            }

            if (!pmnFound)
                throw new XRLExceptionWithoutEvent( HResult.XONLINE_E_PASSPORT_ERROR,
                                                    "No property for Name was returned.");

            if (!ppFound)
                throw new XRLExceptionWithoutEvent(HResult.XONLINE_E_PASSPORT_ERROR,
                                                    "No property for NETID was returned.");

            if (!iaFound)
                throw new XRLExceptionWithoutEvent(HResult.XONLINE_E_PASSPORT_ERROR,
                                                    "No property for Active was returned.");
        }
    }

    // Here is what every passport client should be able to do
    public abstract class PassportClientBase
    {
        protected PassportClientBase() { }

        public abstract UInt32 PublicKeyPublicExponent
        {
            get;
        }

        public abstract byte[] PublicKeyModulus
        {
            get;
        }

        public abstract byte[] PublicKeyDigest
        {
            get;
        }

        public abstract string LoginTokenRequest
        {
            get;
        }

        public abstract string GetLoginTokenRequest(
            int serviceId
            );

        public abstract ProofStatus AddProof(
            UInt64 puid, // Chose not to use the Puid class, as I need more control over the serialization
            string proofType,
            string proofData
            );

        public abstract void CreatePassport(
            string passportMemberName,
            byte[] encPassword,
            string alternateEmail,
            string countryCode,
            DateTime birthdate,
            out UInt64 puid
            );

        public abstract void CreatePassport(
            string passportMemberName,
            string secretQuestion,
            byte[] encPassword,
            ProofData extraProof,
            string countryCode,
            DateTime birthdate,
            out UInt64 puid);

        public abstract void ChangePassword(
            UInt64 puid,
            string passportMemberName,
            byte[] encPassword
            );

        public abstract ProofStatus[] GetProofsState(
            UInt64 puid  // Chose not to use the Puid class, as I need more control over the serialization
            );

        public abstract void Login(
            string pname,
            byte[] encSesKey,
            byte[] encPassw,
            byte[] encReq,
            out UInt64 puid
            );

        public abstract void Login(
            string pname,
            int serviceId,
            byte[] encSesKey,
            byte[] encPassw,
            byte[] encReq,
            out UInt64 puid
            );

        public abstract void Login(
            string pname,
            int serviceId,
            byte[] encSesKey,
            byte[] encPassw,
            byte[] encReq,
            out UInt64 puid,
            out byte[] nonce,
            out byte[] cipherValue
            );

        public abstract string[] GetSecretQuestionList(
            string locale
            );

        public abstract WLIDStatus ValidateWLID(
            ulong passportPuid
            );

        internal abstract string GetPassportMemberName(
            ulong puid
            );

        internal abstract string GetPassportMemberNameAndCID(
            ulong puid,
            out string cid
            );

        public abstract void GetProfile(
            ulong puid,
            string attributes,
            out string profileXml
           );

        public abstract void UpdateProfile(
            string profileXml
            );

        public abstract List<PassportMemberNameCredentials> EnumCredentialsByName(
            string passportMemberName
            );

        public abstract UInt64 GetPassportPuid(
            string passportMemberName
            );

        public abstract byte[] GenerateEncryptedCredentials(
            string oldPassword,
            string newPassword,
            string secretAnswer
        );

        public abstract void DeleteCredential(
            Puid puid
        );

        public abstract void ForceCredentialRename(
            Puid puid
        );

        public abstract void SetNoAgeOut(
            ulong  puid,
            bool   value
        );

        public abstract bool GetNoAgeOut(
            ulong puid
        );

        public class ProofStatus
        {
            public bool isConfirmed;
            public string proofType;
            public string proofData;
        }
    }

    // Manages the global instance of PassportClient. Most applications should
    // not instantiate PassportClient directly and instead use the
    // PassportClientGlobal's Global accessor. It will take care of the (lazily)
    // initialialization of the passport client object and of the manual and
    // automatic reloads.
    public class PassportClientGlobal
    {
        static PassportClientGlobal()
        {
            // configure xmgmt command handler
            XomControl.ControlRequestEvent += new XomControl.ControlRequestEventHandler(OnControlRequest);
        }

        // Get the global instance of the PassportClient
        public static PassportClientBase Global
        {
            get
            {
                Thread.MemoryBarrier();
                if(_passport == null)
                {
                    Init();
                }

                string alternateUrl = GetSessionAlternateUrl();
                if(alternateUrl == null)
                {
                    return _passport;
                }
                else
                {
                    // A different Url was specified for this session
                    return GetAlternateHandler(alternateUrl);
                }
            }
        }

        // Reset the session alternate Url. Default Url will be used instead
        public static void ResetSessionAlternateUrl()
        {
            InitAlternateHandler();
            Thread.SetData(_tlsSessionAlternateUrl, null);
        }

        // Set the session alternate Url.
        public static void SetSessionAlternateUrl(string url)
        {
            InitAlternateHandler();
            Thread.SetData(_tlsSessionAlternateUrl, url);
        }

        // Get the session alternate Url
        public static string GetSessionAlternateUrl()
        {
            InitAlternateHandler();
            object url = Thread.GetData(_tlsSessionAlternateUrl);
            return (string) url;
        }

        // Reset the session alternate Url. Default Url will be used instead
        public static void ResetSessionAlternateCredentialServiceUrl()
        {
            InitAlternateHandler();
            Thread.SetData(_tlsSessionAlternateCredentialServiceApiUrl, null);
        }

        // Set the session alternate Url.
        public static void SetSessionAlternateCredentialServiceUrl(string url)
        {
            InitAlternateHandler();
            Thread.SetData(_tlsSessionAlternateCredentialServiceApiUrl, url);
        }

        // Get the session alternate Url
        public static string GetSessionAlternateCredentialServiceUrl()
        {
            InitAlternateHandler();
            object url = Thread.GetData(_tlsSessionAlternateCredentialServiceApiUrl);
            return (string) url;
        }

        // Reset the session alternate Url. Default Url will be used instead
        public static void ResetSessionAlternateProfileServiceUrl()
        {
            InitAlternateHandler();
            Thread.SetData(_tlsSessionAlternateProfileServiceApiUrl, null);
        }

        // Set the session alternate Url.
        public static void SetSessionAlternateProfileServiceUrl(string url)
        {
            InitAlternateHandler();
            Thread.SetData(_tlsSessionAlternateProfileServiceApiUrl, url);
        }

        // Get the session alternate Url
        public static string GetSessionAlternateProfileServiceUrl()
        {
            InitAlternateHandler();
            object url = Thread.GetData(_tlsSessionAlternateProfileServiceApiUrl);
            return (string) url;
        }

        // Reset the session alternate Url. Default Url will be used instead
        public static void ResetSessionAlternateEncryptedProxiedAuthUrl()
        {
            InitAlternateHandler();
            Thread.SetData(_tlsSessionAlternateEncryptedProxiedAuthUrl, null);
        }

        // Set the session alternate Url.
        public static void SetSessionAlternateEncryptedProxiedAuthUrl(string url)
        {
            InitAlternateHandler();
            Thread.SetData(_tlsSessionAlternateEncryptedProxiedAuthUrl, url);
        }

        // Get the session alternate Url
        public static string GetSessionAlternateEncryptedProxiedAuthUrl()
        {
            InitAlternateHandler();
            object url = Thread.GetData(_tlsSessionAlternateEncryptedProxiedAuthUrl);
            return (string) url;
        }

        // First time init
        private static void Init()
        {
            // All threads should be trying to init at the same time. Let's make
            // sure just one handles the initialization while the other threads
            // wait
            if(_passport == null)
            {
                lock(_lockObject)
                {
                    if(_passport == null)
                    {
                        if(Config.GetBoolSetting(Setting.passport_fakeService))
                        {
                            _passport = new FakePassportClient();
                        }
                        else
                        {
                            PassportClient pc = new PassportClient();
                            pc.Init();
                            _passport = pc;
                        }
                    }
                }
            }
        }

        // Xmgmt interface
        private static void OnControlRequest(object sender, ControlRequestEventArgs args)
        {
            switch(args.Command.ToLower())
            {
            case "help":
                XomControlConnection.SendMessage(
                        "Passport help\r\n" +
                        "  PassportReload -- reload Passport partner XML and reinitialize\r\n" +
                        "  GetMemberName  -- return the member name associated with a given Passport puid\r\n" +
                        "  GetPuid        -- return the Passport puid associated with a given member name\r\n\r\n",
                        args.RequestId);
                args.Handled = true;
                break;

            case "passportreload":
                Reload();
                XomControlConnection.SendMessage(
                        "Partner xml reloaded\r\n\r\n",
                        args.RequestId);
                args.Handled = true;
                break;

            case "getpuid":
                if ( args.CommandArgs.Length == 0 )
                {
                    XomControlConnection.SendMessage( "Usage: GetPuid <puid>\r\n\r\n", args.RequestId );
                }
                else
                {
                    PassportClientBase pp = PassportClientGlobal.Global;

                    for (int i=0; i < args.CommandArgs.Length; i++)
                    {
                        string memberName = args.CommandArgs[i];

                        ulong puid = pp.GetPassportPuid(memberName);

                        if ( puid == 0 )
                        {
                            XomControlConnection.SendMessage( "membername: " + memberName + " not recognized by Passport.\r\n\r\n", args.RequestId );
                        }
                        else
                        {
                            XomControlConnection.SendMessage( "membername: " + memberName + " = 0x" + puid.ToString("x") + "\r\n\r\n", args.RequestId );
                        }
                    }
                }
                args.Handled = true;
                break;

            case "getmembername":
                if ( args.CommandArgs.Length == 0 )
                {
                    XomControlConnection.SendMessage( "Usage: GetMemberName <member-name>\r\n\r\n", args.RequestId );
                }
                else
                {
                    for (int i=0; i < args.CommandArgs.Length; i++)
                    {
                        string puidText = args.CommandArgs[i];

                        ulong puid = 0;

                        try
                        {
                            puid = SafeConvert.ToUInt64(puidText);
                        }
                        catch (Exception)
                        {
                            XomControlConnection.SendMessage( "puid: '" + puidText + "' not valid decimal or hexadecimal value.", args.RequestId );
                        }

                        if ( puid != 0 )
                        {
                            try
                            {
                                string memberName = PassportHelper.GetPassportMemberName(puid);
                                XomControlConnection.SendMessage( "puid: 0x" + puid.ToString("x") + " = " + memberName + "\r\n\r\n", args.RequestId );
                            }
                            catch (Exception e)
                            {
                                if ( e is ExceptionWithHResult )
                                {
                                    if ( ((ExceptionWithHResult)e).HResult == HResult.XONLINE_E_PASSPORT_INVALID_ID )
                                    {
                                        XomControlConnection.SendMessage( "puid: 0x" + puid.ToString("x") + " not recognized by Passport.", args.RequestId );
                                    }
                                    else
                                    {
                                        throw;
                                    }
                                }
                                else
                                {
                                    throw;
                                }
                            }
                        }
                        else
                        {
                            XomControlConnection.SendMessage( "unable to parse puid: " + puidText + "\r\n\r\n", args.RequestId );
                        }
                    }
                }
                args.Handled = true;
                break;
            }
        }

        // Initialize a new instance of the passport client with fresh
        // configuration
        public static void Reload()
        {
            // Reload should be called from a single thread. So it's OK to
            // initialize a new instance before blocking to replace the global
            // instance

            PassportClient pc = new PassportClient();
            pc.Init();

            lock(_lockObject)
            {
                _passport = pc;
            }

            lock(_alternateHandlers)
            {
                _alternateHandlers.Clear();
            }
        }

        // Lazily initializes alternate url support. It basically allocates the
        // TLS slot for the alternate url string and instantiates the hashtable
        // to store the handlers.
        private static void InitAlternateHandler()
        {
            if ( _tlsSessionAlternateUrl == null )
            {
                lock(_lockObject)
                {
                    _tlsSessionAlternateUrl = Thread.AllocateDataSlot();

                    _tlsSessionAlternateCredentialServiceApiUrl = Thread.AllocateDataSlot();

                    _tlsSessionAlternateProfileServiceApiUrl = Thread.AllocateDataSlot();

                    _tlsSessionAlternateEncryptedProxiedAuthUrl = Thread.AllocateDataSlot();

                    _alternateHandlers      = new Hashtable();
                }
            }
        }

        // Get alternate handler
        private static PassportClientBase GetAlternateHandler(string url)
        {
            InitAlternateHandler();

            url = url.ToLower();

            // Maybe we already created a handler for this url, let's try
            // that first
            lock(_alternateHandlers)
            {
                PassportClientBase passport = (PassportClientBase) _alternateHandlers[url];

                if(passport != null)
                {
                    return passport;
                }
            }

            // Nope. Let's create a new one
            PassportClient pc = new PassportClient();
            pc.Init(url);

            lock(_alternateHandlers)
            {
                _alternateHandlers[url] = (PassportClientBase) pc;
            }

            return (PassportClientBase) pc;
        }

        private volatile static PassportClientBase    _passport = null;
        private volatile static LocalDataStoreSlot _tlsSessionAlternateUrl = null;
        private volatile static Hashtable          _alternateHandlers = null;

        // synchronization object for lock() calls
        private volatile static object             _lockObject = new object();

        // session-alternate URL for CredentialServiceApi calls
        private volatile static LocalDataStoreSlot _tlsSessionAlternateCredentialServiceApiUrl = null;

        // session-alternate URL for ProfileServiceApi calls
        private volatile static LocalDataStoreSlot _tlsSessionAlternateProfileServiceApiUrl = null;

        // session-alternate URL for EncryptedProxiedAuth calls
        private volatile static LocalDataStoreSlot _tlsSessionAlternateEncryptedProxiedAuthUrl = null;
    }

    // Standard Passport client implementation
    // Most applications won't need to instantiate PassportClient directly.
    // Instead, use PassportClientGlobal
    public class PassportClient : PassportClientBase
    {
        // **** PassportClientBase start ****

        public override UInt32 PublicKeyPublicExponent
        {
            get { return _pubexp; }
        }

        public override byte[] PublicKeyModulus
        {
            get { return _modulus; }
        }

        public override byte[] PublicKeyDigest
        {
            get { return _shaPubKey; }
        }

        public override string LoginTokenRequest
        {
            get { return _loginTokenRequests[XOn.XONLINE_PASSPORT_LOGIN_XBOXLIVE_SERVICE_ID]; }
        }

        public override string GetLoginTokenRequest(int serviceId)
        {
            if ( serviceId < XOn.XONLINE_PASSPORT_LOGIN_SERVICE_ID_MIN
                || serviceId > XOn.XONLINE_PASSPORT_LOGIN_SERVICE_ID_MAX)
            {
                return _loginTokenRequests[XOn.XONLINE_PASSPORT_LOGIN_XBOXLIVE_SERVICE_ID];
            }

            return _loginTokenRequests[serviceId];
        }


        public override ProofStatus AddProof(
            UInt64 puid, // Chose not to use the Puid class, as I need more control over the serialization
            string proofType,
            string proofData
            )
        {
            string apiName = "AddProof";

            HResult hr;
            HResult soaphr;

            string proofParamData = String.Empty;
            tagPASSID passportId = new tagPASSID();

            FastFailTracker tracker = null;

            APIResultEnum apiResult = APIResultEnum.Failed;
            XomRequestTimeElapsed timeElapsed = new XomRequestTimeElapsed();

            string[] inParams = null;
            string[] outParams = null;
            string xmlReply = String.Empty;
            string ppErrorDetails = String.Empty;

            Puid puidTyped = puid;

            try
            {
                try
                {
                    Xom.Trace(XomAreaName.passportTrace, LogLevel.L_LOW, "PassportClient.AddProof: for member puid {0} starting ", puidTyped);
                    // FastFail check
                    tracker = GetFastFailTracker(apiName, PassportCredentials);

                    // Format parameter information
                    passportId.pit = PASSIDTYPE.PASSID_PUID;

                    // Not using Puid class because the string version should not contain 0x prefix in calls to Passport
                    passportId.bstrID = puid.ToString("X16");

                    proofParamData = string.Format(
                        CultureInfo.InvariantCulture,
                        _proofDataTemplate,
                        proofType,
                        proofData);

                    CredentialServiceAPISoapServerSoap pp = GetCredentialServiceAPISoapServer("default");

                    using (HistogramPerfCounterManager.GetHistogramManager("Passport", apiName))
                    {
                        Xom.Trace(XomAreaName.passportTrace, LogLevel.L_NORMAL, "PassportClient.AddProof: calling credential service");
                        xmlReply = pp.AddProof(passportId, proofParamData);
                        Xom.Trace(XomAreaName.passportTrace, LogLevel.L_NORMAL, "PassportClient.AddProof: returned from credential service");
                    }

                    tracker.IndicateSuccess();
                }
                catch (SoapException se)
                {
                    Xom.Trace(XomAreaName.passportTrace, LogLevel.L_ERROR, "PassportClient.AddProof: received SoapException:\r\n" + se.ToString());

                    if (se.Detail != null)
                    {
                        ppErrorDetails = se.Detail.InnerXml;
                    }

                    GetHrFromSoapError(ppErrorDetails, out soaphr, out hr);

                    throw new PassportClientException(
                        hr, soaphr, XEvent.Id.PASSPORT_CHANGE_PASSWORD_ERROR, String.Format(
                        "{0}: error adding proof for puid {1}, member {2}\nMessage: {3}\nXml: {4}",
                        apiName, puidTyped, se.Message, ppErrorDetails), se
                    );
                }
                catch (WebException we)
                {
                    Xom.Trace(XomAreaName.passportTrace, LogLevel.L_ERROR, "PassportClient.ChangePassword: received WebException");

                    if (FastFailHelper.ConsiderWebExceptionAsTimeout(we))
                    {
                        apiResult = APIResultEnum.Timeout;
                        tracker.IndicateTimeout();
                    }

                    throw new XRLException(
                        apiResult == APIResultEnum.Timeout ? HResult.XONLINE_E_PASSPORT_TIMEOUT : HResult.XONLINE_E_PASSPORT_ERROR,
                        XEvent.Id.PASSPORT_CHANGE_PASSWORD_ERROR, we, "{0}: error adding proof for puid {1}", apiName, puidTyped
                    );
                }
                finally
                {
                    // Liberal reporting policy here, success or timeout
                    if (null != tracker)
                    {
                        // Only first feature indication will be acknowledged, this might be ignored
                        tracker.IndicateSuccess();
                    }
                }

                ProofStatus reply;

                try
                {
                    var xml = new XmlDocument();
                    xml.LoadXml(xmlReply);

                    var node = xml.DocumentElement;

                    reply = new ProofStatus
                    {
                        isConfirmed = node.SelectSingleNode("Property[@name='State']").InnerText.Contains("CP"),
                        proofType = node.Attributes["type"].Value,
                        proofData = node.SelectSingleNode("Property[@name='ID']").InnerText
                    };
                }
                catch (Exception e)
                {
                    throw new XRLException(
                        HResult.XONLINE_E_PASSPORT_INVALID_RESPONSE,
                        XEvent.Id.PASSPORT_INVALID_RESPONSE,
                        e,
                        "PassportClient.GetProofState: failed to parse XML response from WLID GetUserProofState.\r\nResponse XML:\r\n{0}",
                        xmlReply
                        );
                }

                Xom.Trace(XomAreaName.passportTrace, LogLevel.L_LOW, "PassportClient.AddProof: completed");

                apiResult = APIResultEnum.Success;

                return reply;
            }
            catch (Exception e)
            {
                if (string.IsNullOrEmpty(ppErrorDetails))
                {
                    ppErrorDetails = e.Message;
                }

                throw;
            }
            finally
            {
                inParams = new string[] {
                    puidTyped.ToString(),
                    proofParamData,
                };

                LogApiCall(apiName, apiResult, timeElapsed.MillisecondsElapsed, inParams, outParams, xmlReply, ppErrorDetails);
            }
        }

        // Create a passport account using the encrypted proxy interface.
        public override void CreatePassport(
            string passportMemberName,
            byte[] encPassword,
            string alternateEmail,
            string countryCode,
            DateTime birthdate,
            out UInt64 puid
            )
        {
            string SLT;
            CreatePassport(
                passportMemberName,
                null,
                encPassword,
                null,
                alternateEmail,
                ByteArrayToString(_ski),
                countryCode,
                birthdate,
                out puid,
                out SLT
                );
        }

        public override void CreatePassport(
            string passportMemberName,
            string secretQuestion,
            byte[] encPassword,
            ProofData extraProof,
            string countryCode,
            DateTime birthdate,
            out UInt64 puid
            )
        {
            string SLT;
            CreatePassport(
                passportMemberName,
                secretQuestion,
                encPassword,
                extraProof,
                null,
                ByteArrayToString(_ski),
                countryCode,
                birthdate,
                out puid,
                out SLT
                );
        }

        public void CreatePassport(
            string passportMemberName,
            string secretQuestion,
            byte[] encPassword,
            ProofData extraProof,
            string alternateEmail,
            string strSKI,
            string countryCode,
            DateTime birthdate,
            out UInt64 puid,
            out string SLT
            )
        {
            int localeId = 0; 

            ArrayList regionCultures = Culture.GetRegionCultures(CountryDictionary.CountryId(countryCode));
            
            // Use the culture id only if there's one culture for the specified country
            if (regionCultures != null && regionCultures.Count == 1)
            {
                try
                {
                    int cultureId = ((CultureData)regionCultures[0]).CultureID;
                    localeId = Locale.GetValidLCID(cultureId);

                }
                catch (Exception)
                {
                    // Do nothing, just default localeId to 0 if it fails
                }
            }

            CreatePassport(
                passportMemberName,
                secretQuestion,
                encPassword,
                alternateEmail,
                extraProof,
                strSKI,
                countryCode,
                localeId,
                birthdate,
                out puid,
                out SLT
                );
        }
        

        public const string PassportCreation    = "PassportCreation";
        public const string PassportCredentials = "PassportCredentials";
        public const string PassportLogin       = "PassportLogin";
        public const string PassportUps         = "PassportUps";

        void CreatePassport(
            string passportMemberName,
            string secretQuestion,
            byte[] encPassword,
            string alternateEmail,
            ProofData extraProof,
            string strSKI,
            string countryCode,
            int localeId,
            DateTime birthdate,
            out UInt64 puid,
            out string SLT
            )
        {
            string apiName = "CreatePassport";

            string errorBlob        = null;
            string[] results        = null;
            string signInName       = null;
            HResult ihr             = UInt32.MaxValue;
            HResult hr              = UInt32.MaxValue;
            XmlDocument xml         = null;
            XmlNode node            = null;
            FastFailTracker tracker = null;

            APIResultEnum apiResult = APIResultEnum.Failed;
            XomRequestTimeElapsed timeElapsed = new XomRequestTimeElapsed();

            string[] inParams;
            string[] outParams = null;
            string xmlReply = "";
            string ppErrorDetails = "";

            try
            {

                try
                {
                    // FastFail check
                    Xom.Trace(XomAreaName.passportTrace, LogLevel.L_LOW, "PassportClientGlobal.CreatePassport: for member name " + passportMemberName + " starting");
                    tracker = GetFastFailTracker(apiName, PassportCreation);

                    // Format proof data
                    // Add extra proof if it exists
                    string otherProof = String.Empty;
                    if (extraProof != null)
                    {
                        otherProof = String.Format(
                            _proofDataTemplate,
                            extraProof.proofType.ToString(),
                            extraProof.proofData);
                    }

                    // Add alt email proof if it exists.
                    string altProof = String.Empty;
                    if (!String.IsNullOrEmpty(alternateEmail))
                    {
                        altProof = String.Format(
                            _proofDataTemplate,
                            "Email",
                            alternateEmail);
                    }

                    // Construct complete proof data
                    string proofData = String.Format(
                        "<p:proof>{0}{1}</p:proof> \n",
                        otherProof,
                        altProof);

                    // Format user data
                    string userData;

                    if ( string.IsNullOrEmpty(countryCode) || birthdate <= DateTime.FromFileTimeUtc(0) )
                    {
                        userData = string.Format(
                            _userDataTemplate,
                            passportMemberName,
                            secretQuestion,
                            strSKI,
                            Convert.ToBase64String(encPassword));
                    }
                    else if ( string.IsNullOrEmpty(secretQuestion) )
                    {
                        if  ( string.IsNullOrEmpty(alternateEmail) )
                        {
                            userData = string.Format(
                                _userDataCreatePassportManagedDomainTemplate,
                                passportMemberName,
                                strSKI,
                                Convert.ToBase64String(encPassword),
                                countryCode,
                                birthdate.ToString("d:M:yyyy"),
                                localeId == 0 ? String.Empty : localeId.ToString(),
                                proofData);
                        }
                        else
                        {
                            userData = string.Format(
                                _userDataCreatePassportManagedDomainTemplate2,
                                passportMemberName,
                                strSKI,
                                Convert.ToBase64String(encPassword),
                                countryCode,
                                birthdate.ToString("d:M:yyyy"),
                                localeId == 0 ? String.Empty : localeId.ToString(),
                                proofData);
                        }
                    }
                    else
                    {
                        userData = string.Format(
                            _userDataCreatePassportTemplate,
                            passportMemberName,
                            secretQuestion,
                            strSKI,
                            Convert.ToBase64String(encPassword),
                            countryCode,
                            birthdate.ToString("d:M:yyyy"),
                            localeId == 0 ? String.Empty : localeId.ToString(),
                            proofData);
                    }

                    Xom.Trace(XomAreaName.passportTrace, LogLevel.L_LOW, "PassportClientGlobal.CreatePassport: " + PrettyPrintXml(userData));

                    ProfileServiceAPISoapServerSoap pp = GetProfileServiceAPISoapServer(passportMemberName);

                    // Call passport
                    using (HistogramPerfCounterManager.GetHistogramManager("Passport", apiName))
                    {
                        Xom.Trace(XomAreaName.passportTrace, LogLevel.L_LOW, "PassportClientGlobal.CreatePassport: calling profile service");
                        results = pp.CreatePassports(new string[] { userData }, eTRANSACTION.TX_ROLLBACK_ALL, out errorBlob);
                        Xom.Trace(XomAreaName.passportTrace, LogLevel.L_LOW, "PassportClientGlobal.CreatePassport: returned from profile service");
                    }

                    tracker.IndicateSuccess();

                    apiResult = APIResultEnum.Success;
                }

                catch (SoapException se)
                {
                    Xom.Trace(XomAreaName.passportTrace, LogLevel.L_ERROR, "PassportClientGlobal.CreatePassport: received SoapException");

                    if ( se.Detail != null )
                    {
                        ppErrorDetails = se.Detail.InnerXml;
                    }

                    GetHrFromSoapError(ppErrorDetails, out ihr, out hr);

                    throw new PassportClientException(
                        hr, ihr, XEvent.Id.PASSPORT_CREATE_ERROR, string.Format(
                        "{0}: error creating passport for member {1}\nSecretQuestion: {2}\nMessage: {3}\nXml: {4}",
                        apiName, passportMemberName, secretQuestion, se.Message, ppErrorDetails), se
                    );
                }

                catch (WebException we)
                {
                    Xom.Trace(XomAreaName.passportTrace, LogLevel.L_ERROR, "PassportClientGlobal.CreatePassport: received WebException");

                    if ( FastFailHelper.ConsiderWebExceptionAsTimeout(we) )
                    {
                        tracker.IndicateTimeout();
                        apiResult = APIResultEnum.Timeout;
                    }

                    throw new XRLException(
                        apiResult == APIResultEnum.Timeout ? HResult.XONLINE_E_PASSPORT_TIMEOUT : HResult.XONLINE_E_PASSPORT_ERROR,
                        XEvent.Id.PASSPORT_CREATE_ERROR, we, "{0}: error creating passport for member {1}", apiName, passportMemberName
                    );
                }

                finally
                {
                    // Liberal reporting policy here, success or timeout
                    if (null != tracker)
                    {
                        // Only first feature indication will be acknowledged, this might be ignored
                        tracker.IndicateSuccess();
                    }
                }

                // Process error
                if ( !string.IsNullOrEmpty(errorBlob) )
                {
                    ppErrorDetails = errorBlob;

                    puid = 0;

                    Xom.Trace(XomAreaName.passportTrace, LogLevel.L_HIGH, "PassportClient.CreatePassport: error XML reply:\r\n" + PrettyPrintXml(errorBlob));

                    // Request failed. Handle errors
                    xml = new XmlDocument();
                    xml.LoadXml(errorBlob);

                    if ((node = xml.SelectSingleNode("MultipleErrors/Error/HR")) == null)
                    {
                        Xom.Trace(XomAreaName.passportTrace, LogLevel.L_ERROR, "PassportClient.CreatePassport: error processing response");

                        throw new XRLException(
                            HResult.XONLINE_E_PASSPORT_INVALID_RESPONSE,
                            XEvent.Id.PASSPORT_INVALID_RESPONSE,
                            "Missing element MultipleErrors/Error/HR"
                        );
                    }

                    ihr = HResult.Parse(node.InnerText);
                    hr  = TranslatePassportHrToLiveHr(ihr);

                    throw new PassportClientException(hr, ihr, XEvent.Id.PASSPORT_CREATE_ERROR, String.Format(
                        "{0}: error creating passport for member {1}\nSecretQuestion: {2}\nErrorBlob: {3}",
                        apiName, passportMemberName, secretQuestion, ppErrorDetails), null
                    );
                }

                // Process results
                if (results.Length != 1)
                {
                    throw new XRLException(
                        HResult.XONLINE_E_PASSPORT_INVALID_RESPONSE,
                        XEvent.Id.PASSPORT_INVALID_RESPONSE,
                        "Unexpected numer of results, {0}", results.Length
                    );
                }

                // save this to be logged
                xmlReply = results[0];

                Xom.Trace(XomAreaName.passportTrace, LogLevel.L_LOW, "PassportClient.CreatePassport: XML reply:\r\n" + PrettyPrintXml(results[0]));

                xml = new XmlDocument();
                xml.LoadXml(results[0]);

                // Extract PUID
                if ((node = xml.SelectSingleNode("Account/bstrID/PID/PUID")) == null)
                {
                    Xom.Trace(XomAreaName.passportTrace, LogLevel.L_ERROR, "PassportClient.CreatePassport: error processing response");

                    throw new XRLException(
                        HResult.XONLINE_E_PASSPORT_INVALID_RESPONSE,
                        XEvent.Id.PASSPORT_INVALID_RESPONSE,
                        "Missing element Account/bstrID/PID/PUID"
                    );
                }

                puid = Convert.ToUInt64(node.InnerText, 16);

                // Extract sign-in-name
                if ((node = xml.SelectSingleNode("Account/bstrID/PID/SIGNINNAME")) == null)
                {
                    Xom.Trace(XomAreaName.passportTrace, LogLevel.L_ERROR, "PassportClient.CreatePassport: error processing response");

                    throw new XRLException(
                        HResult.XONLINE_E_PASSPORT_INVALID_RESPONSE,
                        XEvent.Id.PASSPORT_INVALID_RESPONSE,
                        "Missing element Account/bstrID/PID/SIGNINNAME"
                    );
                }

                signInName = node.InnerText;

                // Verify name matches the one in the request
                if (String.Compare(signInName, passportMemberName, true) != 0)
                {
                    Xom.Trace(XomAreaName.passportTrace, LogLevel.L_ERROR, "PassportClient.CreatePassport: error processing response");

                    throw new XRLException(
                        HResult.XONLINE_E_PASSPORT_INVALID_RESPONSE,
                        XEvent.Id.PASSPORT_INVALID_RESPONSE,
                        "Returned member name does not match name in request"
                    );
                }

                if ((node = xml.SelectSingleNode("Account/SLT")) != null)
                {
                    SLT = node.InnerText;
                }
                else
                {
                    SLT = null; // this is an error condition but doesn't affect console clients
                }

                // the call succeeded so set the output parameters
                outParams = new string[] {
                    puid.ToString("X016"),
                    SLT ?? ""
                };

                Xom.Trace(XomAreaName.passportTrace, LogLevel.L_LOW, "PassportClient.CreatePassport: completed");
                return;
            }
            catch (Exception e)
            {
                if ( string.IsNullOrEmpty(ppErrorDetails) )
                {
                    ppErrorDetails = e.Message;
                }

                throw;
            }
            finally
            {
                inParams = new string[] {
                    passportMemberName,
                    secretQuestion,
                    encPassword == null ? "" : ByteConvert.ToString(encPassword),
                    strSKI,
                    countryCode,
                    birthdate.ToString("d:M:yyyy")
                };

                LogApiCall(apiName, apiResult, timeElapsed.MillisecondsElapsed, inParams, outParams, xmlReply, ppErrorDetails);
            }
        }

        // Change a passport account's password, secret question and secret
        // answer using passport's encrypted proxy interface
        public override void ChangePassword(
            UInt64 puid,
            string passportMemberName,
            byte[] encPassword
            )
        {
            string apiName = "ChangePassword";

            HResult hr;
            HResult ihr;

            string userData = "";

            FastFailTracker tracker = null;

            APIResultEnum apiResult = APIResultEnum.Failed;
            XomRequestTimeElapsed timeElapsed = new XomRequestTimeElapsed();

            string[] inParams;
            string[] outParams = null;
            string xmlReply = "";
            string ppErrorDetails = "";

            try
            {
                try
                {
                    Xom.Trace(XomAreaName.passportTrace, LogLevel.L_LOW, "PassportClient.ChangePassword: for member name " + passportMemberName + " starting");
                    // FastFail check
                    tracker = GetFastFailTracker(apiName, PassportCredentials);

                    // Format user data
                    userData = string.Format(
                        _userDataWithNetIdTemplate,
                        puid.ToString("X16"),
                        ByteArrayToString(_ski),
                        Convert.ToBase64String(encPassword));

                    CredentialServiceAPISoapServerSoap pp = GetCredentialServiceAPISoapServer(passportMemberName);

                    using (HistogramPerfCounterManager.GetHistogramManager("Passport", apiName))
                    {
                        Xom.Trace(XomAreaName.passportTrace, LogLevel.L_NORMAL, "PassportClient.ChangePassword: calling credential service");
                        pp.UpdateCredential(userData);
                        Xom.Trace(XomAreaName.passportTrace, LogLevel.L_NORMAL, "PassportClient.ChangePassword: returned from credential service");
                    }

                    tracker.IndicateSuccess();
                }
                catch(SoapException se)
                {
                    Xom.Trace(XomAreaName.passportTrace, LogLevel.L_ERROR, "PassportClient.ChangePassword: received SoapException:\r\n" + se.ToString());

                    if ( se.Detail != null )
                    {
                        ppErrorDetails = se.Detail.InnerXml;
                    }

                    GetHrFromSoapError(ppErrorDetails, out ihr, out hr);

                    throw new PassportClientException(
                        hr, ihr, XEvent.Id.PASSPORT_CHANGE_PASSWORD_ERROR, String.Format(
                        "{0}: error changing password for puid 0x{1}, member {2}\nMessage: {3}\nXml: {4}",
                        apiName, puid.ToString("X016"), passportMemberName, se.Message, ppErrorDetails), se
                    );
                }
                catch (WebException we)
                {
                    Xom.Trace(XomAreaName.passportTrace, LogLevel.L_ERROR, "PassportClient.ChangePassword: received WebException");

                    if ( FastFailHelper.ConsiderWebExceptionAsTimeout(we) )
                    {
                        apiResult = APIResultEnum.Timeout;
                        tracker.IndicateTimeout();
                    }

                    throw new XRLException(
                        apiResult == APIResultEnum.Timeout ? HResult.XONLINE_E_PASSPORT_TIMEOUT : HResult.XONLINE_E_PASSPORT_ERROR,
                        XEvent.Id.PASSPORT_CHANGE_PASSWORD_ERROR, we, "{0}: error changing password for puid 0x{1}, member {2}", apiName, puid.ToString("X016"), passportMemberName
                    );
                }
                finally
                {
                    // Liberal reporting policy here, success or timeout
                    if (null != tracker)
                    {
                        // Only first feature indication will be acknowledged, this might be ignored
                        tracker.IndicateSuccess();
                    }
                }

                Xom.Trace(XomAreaName.passportTrace, LogLevel.L_LOW, "PassportClient.ChangePassword: completed");

                apiResult = APIResultEnum.Success;

                return;
            }
            catch (Exception e)
            {
                if ( string.IsNullOrEmpty(ppErrorDetails) )
                {
                    ppErrorDetails = e.Message;
                }

                throw;
            }
            finally
            {
                inParams = new string[] {
                    puid.ToString("X016"),
                    passportMemberName,
                    encPassword == null ? "" : ByteConvert.ToString(encPassword),
                    userData,
                };

                LogApiCall(apiName, apiResult, timeElapsed.MillisecondsElapsed, inParams, outParams, xmlReply, ppErrorDetails);
            }
        }

        public override ProofStatus[] GetProofsState(
            UInt64 puid  // Chose not to use the Puid class, as I need more control over the serialization
            )
        {
            string apiName = "GetProofState";

            HResult hr;
            HResult ihr;

            tagPASSID passportId = new tagPASSID();

            FastFailTracker tracker = null;

            APIResultEnum apiResult = APIResultEnum.Failed;
            XomRequestTimeElapsed timeElapsed = new XomRequestTimeElapsed();

            string[] inParams;
            string[] outParams = null;
            string xmlReply = "";
            string ppErrorDetails = "";

            Puid puidTyped = puid;

            try
            {
                try
                {
                    Xom.Trace(XomAreaName.passportTrace, LogLevel.L_LOW, "PassportClient.GetProofsState: for puid {0} starting", puidTyped);
                    // FastFail check
                    tracker = GetFastFailTracker(apiName, PassportCredentials);

                    // Format parameter information
                    passportId.pit = PASSIDTYPE.PASSID_PUID;

                    // Not using Puid class because the string version should not contain 0x prefix in calls to Passport
                    passportId.bstrID = puid.ToString("X16");

                    CredentialServiceAPISoapServerSoap pp = GetCredentialServiceAPISoapServer("default");

                    using (HistogramPerfCounterManager.GetHistogramManager("Passport", apiName))
                    {
                        Xom.Trace(XomAreaName.passportTrace, LogLevel.L_NORMAL, "PassportClient.GetProofsState: calling profile service");
                        xmlReply = pp.GetUserProofState(passportId, eProofFilter.eProofFilter_All);
                        Xom.Trace(XomAreaName.passportTrace, LogLevel.L_NORMAL, "PassportClient.GetProofsState: returned from profile service");
                    }

                    tracker.IndicateSuccess();
                }
                catch (SoapException se)
                {
                    Xom.Trace(XomAreaName.passportTrace, LogLevel.L_ERROR, "PassportClient.GetProofsState: received SoapException:\r\n" + se.ToString());

                    if (se.Detail != null)
                    {
                        ppErrorDetails = se.Detail.InnerXml;
                    }

                    GetHrFromSoapError(ppErrorDetails, out ihr, out hr);

                    throw new PassportClientException(
                        hr, ihr, XEvent.Id.PASSPORT_CHANGE_PASSWORD_ERROR, String.Format(
                        "{0}: error getting proof state for puid {1}\nMessage: {3}\nXml: {4}",
                        apiName, puidTyped, se.Message, ppErrorDetails), se
                    );
                }
                catch (WebException we)
                {
                    Xom.Trace(XomAreaName.passportTrace, LogLevel.L_ERROR, "PassportClient.GetProofsState: received WebException");

                    if (FastFailHelper.ConsiderWebExceptionAsTimeout(we))
                    {
                        apiResult = APIResultEnum.Timeout;
                        tracker.IndicateTimeout();
                    }

                    throw new XRLException(
                        apiResult == APIResultEnum.Timeout ? HResult.XONLINE_E_PASSPORT_TIMEOUT : HResult.XONLINE_E_PASSPORT_ERROR,
                        XEvent.Id.PASSPORT_CHANGE_PASSWORD_ERROR, we, "{0}: error getting proof state for puid {1}",
                        apiName,
                        puidTyped
                    );
                }
                finally
                {
                    // Liberal reporting policy here, success or timeout
                    if (null != tracker)
                    {
                        // Only first feature indication will be acknowledged, this might be ignored
                        tracker.IndicateSuccess();
                    }
                }

                XmlDocument xml;
                XmlNodeList proofNodes;

                IEnumerable<ProofStatus> proofStatusNodes = null;
                ProofStatus[] reply = new ProofStatus[0];

                try
                {
                    xml = new XmlDocument();
                    xml.LoadXml(xmlReply);

                    proofNodes = xml.SelectNodes("/Proofs/Proof");
                    if (proofNodes.Count > 0)
                    {
                        proofStatusNodes = from node in proofNodes.OfType<XmlNode>()
                                           let state = node.SelectSingleNode("Property[@name='State']").InnerText
                                           where !state.Contains("LT") // Lost proofs don't count
                                           select new ProofStatus
                                           {
                                               isConfirmed = state.Contains("CP"),
                                               proofType = node.Attributes["type"].Value,
                                               proofData = node.SelectSingleNode("Property[@name='ID']").InnerText
                                           };

                        reply = proofStatusNodes.ToArray();
                    }

                }
                catch (Exception e)
                {
                    throw new XRLException(
                        HResult.XONLINE_E_PASSPORT_INVALID_RESPONSE,
                        XEvent.Id.PASSPORT_INVALID_RESPONSE,
                        e,
                        "PassportClient.GetProofState: failed to parse XML response from WLID GetUserProofState.\r\nResponse XML:\r\n{0}",
                        xmlReply
                        );
                }

                Xom.Trace(XomAreaName.passportTrace, LogLevel.L_LOW, "PassportClient.GetProofsState: completed");

                apiResult = APIResultEnum.Success;

                return reply;
            }
            catch (Exception e)
            {
                if (string.IsNullOrEmpty(ppErrorDetails))
                {
                    ppErrorDetails = e.Message;
                }

                throw;
            }
            finally
            {
                inParams = new string[] {
                    puidTyped.ToString()
                };

                LogApiCall(apiName, apiResult, timeElapsed.MillisecondsElapsed, inParams, outParams, xmlReply, ppErrorDetails);
            }
        }

        public override void Login(
            string pname,
            byte[] encSesKey,
            byte[] encPassw,
            byte[] encReq,
            out UInt64 puid
            )
        {
            Login(pname, XOn.XONLINE_PASSPORT_LOGIN_XBOXLIVE_SERVICE_ID, encSesKey, encPassw, encReq, out puid);
        }


        // Log a passport account in using passport's encrypted
        // proxy interface. For now, most of the response is being thrown away
        // (including tokens and stuff) with the exception of the account's
        // puid which is returned as an output parameter
        public override void Login(
            string pname,
            int serviceId,
            byte[] encSesKey,
            byte[] encPassw,
            byte[] encReq,
            out UInt64 puid
            )
        {
            byte[] nonce = null;
            byte[] cipherValue = null;
            Login(pname, serviceId, encSesKey, encPassw, encReq, out puid, out nonce, out cipherValue);
        }

        // Log a passport account in using passport's encrypted
        // proxy interface. This version, keeps most of the response is
        // including encrypted tokens and stuff along with the account's
        // puid, all of which is returned as output parameters
        public override void Login(
            string pname,
            int serviceId,
            byte[] encSesKey,
            byte[] encPassw,
            byte[] encReq,
            out UInt64 puid,
            out byte[] nonce,
            out byte[] cipherValue
            )
        {
            string apiName = "Login";

            Stream sreq = null;
            Stream srep = null;
            HttpWebResponse httpRep = null;
            string reply;
            XmlDocument xml;
            XmlNode node;
            XmlNamespaceManager nsm;
            HResult ihr;
            HResult hr;
            FastFailTracker tracker = null;

            APIResultEnum apiResult = APIResultEnum.Failed;
            XomRequestTimeElapsed timeElapsed = new XomRequestTimeElapsed();

            string[] inParams;
            string[] outParams = null;
            string xmlReply = "";
            string ppErrorDetails = "";

            // initialize output parameters
            puid = 0;
            nonce = null;
            cipherValue = null;

            try
            {
                try
                {
                    // FastFail check
                    Xom.Trace(XomAreaName.passportTrace, LogLevel.L_LOW, "PassportClient.Login: for member name " + pname + " starting");
                    tracker = GetFastFailTracker(apiName, PassportLogin);

                    // Build request
                    string req = string.Format(
                        _passportLoginReq,
                        ByteArrayToString(_ski),
                        Convert.ToBase64String(encSesKey),
                        pname,
                        Convert.ToBase64String(encPassw),
                        Convert.ToBase64String(encReq));

                    Xom.Trace(XomAreaName.passportTrace, LogLevel.L_LOW, "PassportClient.Login: request " + PrettyPrintXml(req));
                    int timeout = GetPartnerCallTimeoutSeconds * 1000;

                    // see if BehaviorInjection results in either a reply or a new timeout
                    reply = PassportLoginFailure.HandleBehaviorInjection(ref timeout);

                    // if the BehaviorInjection framework handled this request, a non-empty
                    // string will be returned as the reply.
                    if ( string.IsNullOrEmpty(reply) )
                    {
                        // Post
                        string url = GetDomainConfig(pname).encryptedProxiedAuth;

                        string alternateUrl = PassportClientGlobal.GetSessionAlternateEncryptedProxiedAuthUrl();
                        if ( false == string.IsNullOrEmpty(alternateUrl) )
                        {
                            Xom.Trace(XomAreaName.passportTrace, LogLevel.L_HIGH, "PassportClient.Login: using alternateUrl: " + alternateUrl);
                            url = alternateUrl;
                        }

                        HttpWebRequest httpReq = (HttpWebRequest) WebRequest.Create(url);
                        byte[] binReq = Encoding.UTF8.GetBytes(req);
                        httpReq.Proxy = _proxy;
                        httpReq.Method = "POST";
                        httpReq.ContentLength = binReq.Length;
                        httpReq.Timeout = timeout;

                        byte[] binrep;
                        using (HistogramPerfCounterManager.GetHistogramManager("Passport", apiName))
                        {
                            Xom.Trace(XomAreaName.passportTrace, LogLevel.L_NORMAL, "PassportClient.Login: get request stream");
                            sreq = httpReq.GetRequestStream();
                            sreq.Write(binReq, 0, binReq.Length);

                            // Get response
                            Xom.Trace(XomAreaName.passportTrace, LogLevel.L_NORMAL, "PassportClient.Login: sending request");
                            httpRep = (HttpWebResponse)httpReq.GetResponse();
                            srep = httpRep.GetResponseStream();
                            binrep = new byte[httpRep.ContentLength];
                        }

                        int bytesToRead = (int)httpRep.ContentLength;
                        Xom.Trace(XomAreaName.passportTrace, LogLevel.L_NORMAL, "PassportClient.Login: reading response");

                        int offset = 0;
                        while (bytesToRead > 0)
                        {
                            int bytesRead = srep.Read(binrep, offset, bytesToRead);
                            Xom.Trace(XomAreaName.passportTrace, LogLevel.L_LOW, "PassportClient.Login: " + bytesRead.ToString() + " byte(s) read");
                            bytesToRead -= bytesRead;
                            offset += bytesRead;
                        }

                        Xom.Trace(XomAreaName.passportTrace, LogLevel.L_LOW, "PassportClient.Login: " + httpRep.ContentLength + " total bytes read");
                        reply = Encoding.UTF8.GetString(binrep);

                        xmlReply = reply;
                    }

                    tracker.IndicateSuccess();
                }
                catch (WebException we)
                {
                    Xom.Trace(XomAreaName.passportTrace, LogLevel.L_ERROR, "PassportClient.Login: received WebException");

                    if ( FastFailHelper.ConsiderWebExceptionAsTimeout(we) )
                    {
                        tracker.IndicateTimeout();
                        apiResult = APIResultEnum.Timeout;
                    }

                    throw new XRLException(
                        apiResult == APIResultEnum.Timeout ? HResult.XONLINE_E_PASSPORT_TIMEOUT : HResult.XONLINE_E_PASSPORT_ERROR,
                        XEvent.Id.PASSPORT_LOGIN_ERROR, we, "{0}: error during passport login for member {1}", apiName, pname
                    );
                }
                finally
                {
                    // Liberal reporting policy here, success or timeout
                    if (null != tracker)
                    {
                        // Only first feature indication will be acknowledged, this might be ignored
                        tracker.IndicateSuccess();
                    }

                    if (sreq != null)
                    {
                        sreq.Close();
                    }

                    if (srep != null)
                    {
                        srep.Close();
                    }

                    if (httpRep != null)
                    {
                        httpRep.Close();
                    }
                }

                xmlReply = reply;

                Xom.Trace(XomAreaName.passportTrace, LogLevel.L_LOW, "PassportClient.Login: XML reply:\r\n" + PrettyPrintXml(reply));

                // Process response
                try
                {
                    xml = new XmlDocument();
                    xml.LoadXml(reply);

                    nsm = new XmlNamespaceManager(xml.NameTable);
                    nsm.AddNamespace("ps", "http://schemas.microsoft.com/Passport/SoapServices/EncProxyV1");
                    nsm.AddNamespace("psf", "http://schemas.microsoft.com/Passport/SoapServices/SOAPFault");
                    nsm.AddNamespace("se", "http://schemas.xmlsoap.org/soap/envelope/");
                    nsm.AddNamespace("wsse", "http://schemas.xmlsoap.org/ws/2003/06/secext");
                    nsm.AddNamespace("wssc", "http://schemas.xmlsoap.org/ws/2004/04/sc");
                    nsm.AddNamespace("ed", "http://www.w3.org/2001/04/xmlenc#");
                }
                catch (Exception e)
                {
                    throw new XRLException(
                        HResult.XONLINE_E_PASSPORT_INVALID_RESPONSE,
                        XEvent.Id.PASSPORT_INVALID_RESPONSE,
                        "PassportClient.Login: failed to parse XML response from WLID EncryptedProxiedAuth.\r\nResponse XML:\r\n" + reply,
                        e);
                }

                // There are 2 response types. Try the mainline response first.
                node = null;
                if ((node = xml.SelectSingleNode("/se:Envelope/se:Header/psf:pp/ps:TokenResponse[@id='"+_siteAddresses[serviceId]+"']/psf:reqstatus", nsm)) != null)
                {
                    ihr = HResult.Parse(node.InnerText);

                    if((node = xml.SelectSingleNode("/se:Envelope/se:Header/psf:pp/ps:TokenResponse[@id='"+_siteAddresses[serviceId]+"']/psf:reqdetail", nsm)) != null)
                    {
                        ppErrorDetails = node.InnerText;
                    }
                }
                else if ((node = xml.SelectSingleNode("/se:Envelope/se:Fault/faultcode", nsm)) != null)
                {
                    // Try to parse it as a soap request level error
                    ihr = HResult.Parse(node.InnerText);

                    if (ihr == 0)
                    {
                        Xom.Trace(XomAreaName.passportTrace, LogLevel.L_ERROR, "PassportClient.Login: error processing response");

                        throw new XRLException(
                            HResult.XONLINE_E_PASSPORT_INVALID_RESPONSE,
                            XEvent.Id.PASSPORT_INVALID_RESPONSE,
                            "Element /se:Envelope/se:Fault/faultcode cannot be zero"
                        );
                    }

                    if ((node = xml.SelectSingleNode("/se:Envelope/se:Fault/faultstring", nsm)) != null)
                    {
                        ppErrorDetails = node.InnerText;
                    }
                }
                else
                {
                    Xom.Trace(XomAreaName.passportTrace, LogLevel.L_ERROR, "PassportClient.Login: error processing response");

                    throw new XRLException(
                        HResult.XONLINE_E_PASSPORT_INVALID_RESPONSE,
                        XEvent.Id.PASSPORT_INVALID_RESPONSE,
                        "Unrecognized format, {0}", reply
                    );
                }

                if (ihr != HResult.S_OK)
                {
                    hr = TranslatePassportHrToLiveHr(ihr);
                    Xom.Trace(XomAreaName.passportTrace, LogLevel.L_ERROR, "PassportClient.Login: login failed, hr = " + hr);

                    throw new PassportClientException(
                        hr, ihr, XEvent.Id.PASSPORT_LOGIN_ERROR, String.Format(
                        "{0}: error logging in member {0}\nReply:{1}", apiName, pname, reply), null
                    );
                }

                if ((node = xml.SelectSingleNode("/se:Envelope/se:Header/ps:PUID", nsm)) == null)
                {
                    Xom.Trace(XomAreaName.passportTrace, LogLevel.L_ERROR, "PassportClient.Login: error processing response");

                    throw new XRLException(
                        HResult.XONLINE_E_PASSPORT_INVALID_RESPONSE,
                        XEvent.Id.PASSPORT_INVALID_RESPONSE,
                        "Missing element /se:Envelope/se:Header/ps:PUID"
                    );
                }

                puid = Convert.ToUInt64(node.InnerText, 16);

                if ((node = xml.SelectSingleNode("/se:Envelope/se:Header/wsse:Security/wssc:DerivedKeyToken[@Id='EncKey']/wssc:Nonce", nsm)) != null)
                {
                    string sNonce = node.InnerText;
                    nonce = Convert.FromBase64CharArray(sNonce.ToCharArray(), 0, sNonce.Length);
                }
                else
                {
                    Xom.Trace(XomAreaName.passportTrace, LogLevel.L_ERROR, "PassportClient.Login: error processing response");

                    throw new XRLException(
                        HResult.XONLINE_E_PASSPORT_INVALID_RESPONSE,
                        XEvent.Id.PASSPORT_INVALID_RESPONSE,
                        "Missing element /se:Envelope/se:Header/wsse:Security/wssc:DerivedKeyToken[@Id='EncKey']/wssc:Nonce"
                    );
                }

                if ((node = xml.SelectSingleNode("/se:Envelope/se:Body/ed:EncryptedData[@Id='RSTR']/ed:CipherData/ed:CipherValue", nsm)) != null)
                {
                    string sCipherValue = node.InnerText;
                    cipherValue = Convert.FromBase64CharArray(sCipherValue.ToCharArray(), 0, sCipherValue.Length);
                }
                else
                {
                    Xom.Trace(XomAreaName.passportTrace, LogLevel.L_ERROR, "PassportClient.Login: error processing response");

                    throw new XRLException(
                        HResult.XONLINE_E_PASSPORT_INVALID_RESPONSE,
                        XEvent.Id.PASSPORT_INVALID_RESPONSE,
                        "Missing element /se:Envelope/se:Body/ed:EncryptedData[@Id='RSTR']/ed:CipherData/ed:CipherValue"
                    );
                }

                apiResult = APIResultEnum.Success;

                Xom.Trace(XomAreaName.passportTrace, LogLevel.L_LOW, "PassportClient.Login: completed");
                return;
            }
            catch (Exception e)
            {
                if ( string.IsNullOrEmpty(ppErrorDetails) )
                {
                    ppErrorDetails = e.Message;
                }

                throw;
            }
            finally
            {
                inParams = new string[] {
                    pname,
                    serviceId.ToString(),
                    ByteConvert.ToString(encSesKey),
                    ByteConvert.ToString(encPassw),
                    ByteConvert.ToString(encReq),
                };

                outParams = new string[] {
                    puid.ToString("X016"),
                    nonce == null ? "" : ByteConvert.ToString(nonce),
                    cipherValue == null ? "" : ByteConvert.ToString(cipherValue),
                };

                LogApiCall(apiName, apiResult, timeElapsed.MillisecondsElapsed, inParams, outParams, xmlReply, ppErrorDetails);
            }
        }

        public override string[] GetSecretQuestionList(string locale)
        {
            return (string[]) _secretQuestions[locale.ToLower()];
        }

        // Figure out if a Passport Puid is valid
        public override WLIDStatus ValidateWLID(ulong passportPuid)
        {
            // When we want to force a user through the invalid owner flow, such as when the previous owner
            // explicitly removed a dependent using RemoveDependent, we set the OwnerPassportPuid to a well-known
            // invalid value. In this case, skip the call to passport.
            if (passportPuid == XOn.XONLINE_PASSPORT_INVALID_ID)
            {
                return WLIDStatus.Invalid;
            }

            try
            {
                string userName = PassportHelper.GetPassportMemberName(passportPuid);
            }
            catch (Exception e)
            {
                if ( (e is ExceptionWithHResult)
                && (((ExceptionWithHResult)e).HResult == HResult.XONLINE_E_PASSPORT_INVALID_ID))
                //if ( ((ExceptionWithHResult)e).HResult == HResult.XONLINE_E_PASSPORT_INVALID_ID )
                {
                    return WLIDStatus.Invalid;
                }
                else
                {
                    return WLIDStatus.Unknown;
                }
            }

            return WLIDStatus.Valid;
        }

        internal override string GetPassportMemberName(ulong puid)
        {
            string apiName = "GetPassportMemberName";

            FastFailTracker tracker = null;

            string response;
            XmlDocument xml;
            XmlNode node;
            string pmn = "";

            APIResultEnum apiResult = APIResultEnum.Failed;
            XomRequestTimeElapsed timeElapsed = new XomRequestTimeElapsed();

            string[] inParams;
            string[] outParams = null;
            string xmlReply = "";
            string ppErrorDetails = "";

            try
            {
                try
                {
                    // FastFail check
                    Xom.Trace(XomAreaName.passportTrace, LogLevel.L_LOW, "PassportClient.GetPassportMemberName: for puid 0x" + puid.ToString("X016") + " started");
                    tracker = GetFastFailTracker(apiName, PassportCredentials);

                    CredentialServiceAPISoapServerSoap pp = GetCredentialServiceAPISoapServer("default");

                    using (HistogramPerfCounterManager.GetHistogramManager("Passport", apiName))
                    {
                        Xom.Trace(XomAreaName.passportTrace, LogLevel.L_NORMAL, "PassportClient.GetPassportMemberName: calling credential server");
                        response = pp.GetSigninNamesForNetIDs(puid.ToString("X016"));
                        Xom.Trace(XomAreaName.passportTrace, LogLevel.L_NORMAL, "PassportClient.GetPassportMemberName: returned from credential server");
                    }

                }
                catch (SoapException se)
                {
                    if ( se.Detail != null )
                    {
                        ppErrorDetails = se.Detail.InnerXml;
                    }

                    HResult ihr, hr;
                    GetHrFromSoapError(ppErrorDetails, out ihr, out hr);

                    throw new PassportClientException(
                        hr, ihr, XEvent.Id.PASSPORT_GET_MEMBER_NAME_ERROR, String.Format(
                        "{0}: error getting member name for puid 0x{1}, {2}",
                        apiName, puid.ToString("X016"), ppErrorDetails), se
                    );
                }
                catch (WebException we)
                {
                    Xom.Trace(XomAreaName.passportTrace, LogLevel.L_ERROR, "PassportClient.GetPassportMemberName: received WebException");

                    if ( FastFailHelper.ConsiderWebExceptionAsTimeout(we) )
                    {
                        tracker.IndicateTimeout();
                        apiResult = APIResultEnum.Timeout;
                    }

                    throw new XRLException(
                        apiResult == APIResultEnum.Timeout ? HResult.XONLINE_E_PASSPORT_TIMEOUT : HResult.XONLINE_E_PASSPORT_ERROR,
                        XEvent.Id.PASSPORT_GET_MEMBER_NAME_ERROR, we, "{0}: error getting member name for puid 0x{1}", apiName, puid.ToString("X016")
                    );
                }
                finally
                {
                    // Liberal reporting policy here, success or timeout
                    if (null != tracker)
                    {
                        // Only first feature indication will be acknowledged, this might be ignored
                        tracker.IndicateSuccess();
                    }
                }

                // Process xml response
                try
                {
                    xmlReply = response;

                    Xom.Trace(XomAreaName.passportTrace, LogLevel.L_LOW, "PassportClient.GetPassportMemberName: XML reply:\r\n" + PrettyPrintXml(response) );

                    xml = new XmlDocument();
                    xml.LoadXml(response);

                    // Find the nodes with the puids
                    node = xml.SelectSingleNode("NETID2Name/SigninName");

                    if (node == null)
                    {
                        throw new XRLExceptionWithoutEvent(
                            HResult.XONLINE_E_PASSPORT_INVALID_ID,
                            string.Format("Invalid passport id, 0x{0}", puid.ToString("X016"))
                        );
                    }

                    pmn = node.InnerText;

                    // Remove trailing spaces, LFs and CRs
                    pmn = pmn.Replace("\n", "");
                    pmn = pmn.Replace("\r", "");
                    pmn = pmn.Trim();

                    Xom.Trace(XomAreaName.passportTrace, LogLevel.L_LOW, string.Format("PassportClient.GetPassportMemberName: found PMN: {0} for puid: 0x{1}", pmn, puid.ToString("X016")));

                    apiResult = APIResultEnum.Success;

                    return pmn;
                }

                catch (Exception e)
                {
                    Xom.Trace(XomAreaName.passportTrace, LogLevel.L_ERROR, "PassportClient.GetPassportMemberName: error processing response");

                    // ExceptionWithHResults are all formatted and ready to go
                    // we only act  on  unexpected  runtime  exceptions
                    if ( e is ExceptionWithHResult )
                    {
                        throw;
                    }

                    throw new Exception(string.Format(
                        "pp.GetSigninNamesForNetIDs failed: {0}\n"+
                        "puid=0x{1}\n"+
                        "response:\n{2}",
                        e.Message,
                        puid.ToString("X016"),
                        response),
                        e);
                }
            }
            catch (Exception e)
            {
                if ( string.IsNullOrEmpty(ppErrorDetails) )
                {
                    ppErrorDetails = e.Message;
                }

                throw;
            }
            finally
            {
                inParams = new string[] {  puid.ToString("X016") };

                outParams = new string[] { pmn };

                LogApiCall(apiName, apiResult, timeElapsed.MillisecondsElapsed, inParams, outParams, xmlReply, ppErrorDetails);
            }
        }

        internal override string GetPassportMemberNameAndCID(ulong puid, out string cid)
        {
            string apiName = "GetPassportMemberNameAndCID";

            string response;
            XmlDocument xml;
            XmlNode nameNode;
            string pmn = "";
            FastFailTracker tracker = null;

            APIResultEnum apiResult = APIResultEnum.Failed;
            XomRequestTimeElapsed timeElapsed = new XomRequestTimeElapsed();

            string[] inParams;
            string[] outParams = null;
            string xmlReply = "";
            string ppErrorDetails = "";

            // initialize output param
            cid = "";

            try
            {
                try
                {
                    Xom.Trace(XomAreaName.passportTrace, LogLevel.L_LOW, "PassportClient.GetPassportMemberNameAndCID: for puid " + puid.ToString("X016") + " starting");
                    // FastFail check
                    tracker = GetFastFailTracker(apiName, PassportCredentials);

                    CredentialServiceAPISoapServerSoap pp = GetCredentialServiceAPISoapServer("default");

                    using (HistogramPerfCounterManager.GetHistogramManager("Passport", apiName))
                    {
                        Xom.Trace(XomAreaName.passportTrace, LogLevel.L_NORMAL, "PassportClient.GetPassportMemberNameAndCID: calling credential server");
                        response = pp.GetSigninNamesAndCIDsForNetIDs(puid.ToString("X016"));
                        Xom.Trace(XomAreaName.passportTrace, LogLevel.L_NORMAL, "PassportClient.GetPassportMemberNameAndCID: returned from credential server");
                    }

                }
                catch (SoapException se)
                {
                    Xom.Trace(XomAreaName.passportTrace, LogLevel.L_ERROR, "PassportClient.GetPassportMemberNameAndCID: received SoapException");

                    if ( se.Detail != null )
                    {
                        ppErrorDetails = se.Detail.InnerXml;
                    }

                    HResult ihr, hr;
                    GetHrFromSoapError(ppErrorDetails, out ihr, out hr);

                    throw new PassportClientException(
                        hr, ihr, XEvent.Id.PASSPORT_GET_MEMBER_NAME_AND_CID_ERROR, String.Format(
                        "{0}: error getting member name and cid for puid 0x{1}\nErrorDetails: {2}",
                        apiName, puid.ToString("X016"), ppErrorDetails), se
                    );
                }
                catch (WebException we)
                {
                    Xom.Trace(XomAreaName.passportTrace, LogLevel.L_ERROR, "PassportClient.GetPassportMemberNameAndCID: received WebException");

                    if ( FastFailHelper.ConsiderWebExceptionAsTimeout(we) )
                    {
                        tracker.IndicateTimeout();
                        apiResult = APIResultEnum.Timeout;
                    }

                    throw new XRLException(
                        apiResult == APIResultEnum.Timeout ? HResult.XONLINE_E_PASSPORT_TIMEOUT : HResult.XONLINE_E_PASSPORT_ERROR,
                        XEvent.Id.PASSPORT_GET_MEMBER_NAME_AND_CID_ERROR, we, "{0}: error getting member name and cid for puid 0x{1}", apiName, puid.ToString("X016")
                    );
                }
                finally
                {
                    // Liberal reporting policy here, success or timeout
                    if (null != tracker)
                    {
                        // Only first feature indication will be acknowledged, this might be ignored
                        tracker.IndicateSuccess();
                    }
                }

                // Process xml response
                try
                {
                    xmlReply = response;

                    Xom.Trace(XomAreaName.passportTrace, LogLevel.L_LOW, "PassportClient.GetPassportMemberNameAndCID: XML reply:\r\n" + PrettyPrintXml(response));

                    xml = new XmlDocument();
                    xml.LoadXml(response);

                    // Find the nodes with the puids
                    nameNode = xml.SelectSingleNode("NETID2Name/SigninName");
                    XmlAttribute userCid = nameNode == null ? null : (XmlAttribute) nameNode.Attributes.GetNamedItem("CID");

                    if ((nameNode == null) || (userCid == null))
                    {
                        throw new XRLExceptionWithoutEvent(
                            HResult.XONLINE_E_PASSPORT_INVALID_ID,
                            string.Format("Invalid passport id, 0x{0}", puid.ToString("X016"))
                        );
                    }

                    pmn = nameNode.InnerText;
                    cid = userCid.InnerText;

                    // Remove trailing spaces, LFs and CRs
                    pmn = pmn.Replace("\n", "");
                    pmn = pmn.Replace("\r", "");
                    pmn = pmn.Trim();

                    cid = cid.Replace("\n", "");
                    cid = cid.Replace("\r", "");
                    cid = cid.Trim();

                    // Can split the string into pmn and cid in XePassportGetMemberName
                    Xom.Trace(XomAreaName.passportTrace, LogLevel.L_LOW, string.Format("PassportClient.GetPassportMemberNameAndCID: found PMN: {0} and CID: {1} for puid: 0x{2}", pmn, cid, puid.ToString("x")));

                    apiResult = APIResultEnum.Success;

                    return pmn;
                }

                catch (Exception e)
                {

                    // ExceptionWithHResults are all formatted and ready to go
                    // we only act  on  unexpected  runtime  exceptions
                    if ( e is ExceptionWithHResult )
                    {
                        throw;
                    }

                    Xom.Trace(XomAreaName.passportTrace, LogLevel.L_ERROR, "PassportClient.GetPassportMemberNameAndCID: error processing response");

                    throw new Exception(string.Format(
                        "pp.GetSigninNamesAndCIDsForNetIDs failed: {0}\n" +
                        "puid=0x{1}\n"+
                        "response:\n{2}",
                        e.Message,
                        puid.ToString("X016"),
                        response),
                        e);
                }
            }
            catch (Exception e)
            {
                if ( string.IsNullOrEmpty(ppErrorDetails) )
                {
                    ppErrorDetails = e.Message;
                }

                throw;
            }
            finally
            {
                inParams = new string[] {  puid.ToString("X016") };

                outParams = new string[] { pmn, cid };

                LogApiCall(apiName, apiResult, timeElapsed.MillisecondsElapsed, inParams, outParams, xmlReply, ppErrorDetails);
            }
        }

        public override List<PassportMemberNameCredentials> EnumCredentialsByName(string passportMemberName)
        {
            string apiName = "EnumCredentialsByName";
            const string ENUM_CREDENTIALS_ATTRIBUTES = "Name,NETID,Active";

            FastFailTracker tracker = null;

            string response;
            XmlDocument xml;
            XmlNamespaceManager nsm;
            XmlNode node;
            List<PassportMemberNameCredentials> creds = new List<PassportMemberNameCredentials>();

            APIResultEnum apiResult = APIResultEnum.Failed;
            XomRequestTimeElapsed timeElapsed = new XomRequestTimeElapsed();

            string[] inParams;
            string[] outParams = null;
            string xmlReply = "";
            string ppErrorDetails = "";

            try
            {
                try
                {
                    // FastFail check
                    Xom.Trace(XomAreaName.passportTrace, LogLevel.L_LOW, "PassportClient.EnumCredentialsByName: for member name {0} started", passportMemberName);
                    tracker = GetFastFailTracker(apiName, PassportCredentials);

                    CredentialServiceAPISoapServerSoap pp = GetCredentialServiceAPISoapServer("default");

                    using (HistogramPerfCounterManager.GetHistogramManager("Passport", apiName))
                    {
                        Xom.Trace(XomAreaName.passportTrace, LogLevel.L_NORMAL, "PassportClient.EnumCredentialsByName: calling credential server");
                        response = pp.EnumCredentialsByName(passportMemberName, ENUM_CREDENTIALS_ATTRIBUTES);
                        Xom.Trace(XomAreaName.passportTrace, LogLevel.L_NORMAL, "PassportClient.EnumCredentialsByName: returned from credential server");
                    }
                }
                catch (SoapException se)
                {
                    if (se.Detail != null)
                    {
                        ppErrorDetails = se.Detail.InnerXml;
                    }

                    HResult ihr, hr;
                    GetHrFromSoapError(ppErrorDetails, out ihr, out hr);

                    if (hr == HResult.XONLINE_E_PASSPORT_NO_DATA)
                    {
                        Xom.Trace(XomAreaName.passportTrace, LogLevel.L_NORMAL, "PassportClient.EnumCredentialsByName: invalid passport member name: {0}", passportMemberName);
                        apiResult = APIResultEnum.Success;
                        return creds;
                    }
                    else
                    {
                        throw new PassportClientException(
                            hr, ihr, XEvent.Id.PASSPORT_ENUM_CREDENTIALS_BY_NAME_ERROR, String.Format(
                            "{0}: error getting credentials for member name {1}, {2}",
                            apiName, passportMemberName, ppErrorDetails), se
                        );
                    }
                }
                catch (WebException we)
                {
                    Xom.Trace(XomAreaName.passportTrace, LogLevel.L_ERROR, "PassportClient.EnumCredentialsByName: received WebException");

                    if (FastFailHelper.ConsiderWebExceptionAsTimeout(we))
                    {
                        tracker.IndicateTimeout();
                        apiResult = APIResultEnum.Timeout;
                    }

                    throw new XRLException(
                        apiResult == APIResultEnum.Timeout ? HResult.XONLINE_E_PASSPORT_TIMEOUT : HResult.XONLINE_E_PASSPORT_ERROR,
                        XEvent.Id.PASSPORT_ENUM_CREDENTIALS_BY_NAME_ERROR, we, "{0}: error getting credentials for member name {1}", apiName, passportMemberName
                    );
                }
                finally
                {
                    // Liberal reporting policy here, success or timeout
                    if (null != tracker)
                    {
                        // Only first feature indication will be acknowledged, this might be ignored
                        tracker.IndicateSuccess();
                    }
                }

                // Process xml response
                try
                {
                    xmlReply = response;

                    Xom.Trace(XomAreaName.passportTrace, LogLevel.L_LOW, "PassportClient.EnumCredentialsByName: XML reply:\r\n{0}", PrettyPrintXml(response));

                    xml = new XmlDocument();
                    xml.LoadXml(response);
                    nsm = new XmlNamespaceManager(xml.NameTable);
                    nsm.AddNamespace("p", "http://schemas.microsoft.com/Passport/User");

                    // loop through each credential we find
                    for (node = xml.SelectSingleNode("p:userData/p:credential", nsm); node != null; node = node.NextSibling)
                    {
                        try { creds.Add(new PassportMemberNameCredentials(node)); }
                        catch (Exception e)
                        {
                            throw new XRLException(
                                HResult.XONLINE_E_PASSPORT_INVALID_RESPONSE,
                                XEvent.Id.PASSPORT_INVALID_RESPONSE,
                                e,
                                "Error reading in xml ({0}) xml:\r\n{1}",
                                e.Message,
                                xmlReply
                            );
                        }
                    }

                    if (creds.Count == 0)
                    {
                        Xom.Trace(XomAreaName.passportTrace, LogLevel.L_NORMAL, "PassportClient.EnumCredentialsByName: invalid passport member name: {0}", passportMemberName);
                    }

                    Xom.Trace(XomAreaName.passportTrace, LogLevel.L_LOW, "PassportClient.EnumCredentialsByName: found creds: [{0}] for Passport Member Name: {1}", creds.ToString(), passportMemberName);
                    
                    apiResult = APIResultEnum.Success;

                    return creds;
                }

                catch (Exception e)
                {
                    Xom.Trace(XomAreaName.passportTrace, LogLevel.L_ERROR, "PassportClient.EnumCredentialsByName: error processing response");

                    // ExceptionWithHResults are all formatted and ready to go
                    // we only act  on  unexpected  runtime  exceptions
                    if (e is ExceptionWithHResult)
                    {
                        throw;
                    }

                    throw new XRLException(
                        HResult.XONLINE_E_PASSPORT_INVALID_RESPONSE,
                        XEvent.Id.PASSPORT_INVALID_RESPONSE,
                        e,
                        "pp.EnumCredentialsByName failed: {0}\npassport member name={1}\nresponse:\n{2}",
                        e.Message,
                        passportMemberName,
                        response
                    );
                }
            }
            catch (Exception e)
            {
                if (string.IsNullOrEmpty(ppErrorDetails))
                {
                    ppErrorDetails = e.Message;
                }

                throw;
            }
            finally
            {
                inParams = new string[] { passportMemberName };

                outParams = new string[] { creds.ToString() };

                LogApiCall(apiName, apiResult, timeElapsed.MillisecondsElapsed, inParams, outParams, xmlReply, ppErrorDetails);
            }
        }



        // Get the profile of a user. The attributes string contains a comma-
        // separated list of attributes using the following format: namespace.name
        // For example: "xbox.email,xbox.dayphone". There can be no white-spaces
        // before, after or between each attribute otherwise UPS will puke.
        // The output is a UpsProfile object which should contain all the
        // attributes requested.
        public override void GetProfile(
            ulong puid,
            string attributes,
            out string profileXml
           )
        {
            string apiName = "GetProfile";

            string[] results = null;
            
            string[] inParams = null;
            string[] outParams = null;
            string xmlReply = "";
            string ppErrorDetails = "";

            string puidString = puid.ToString("X016");

            FastFailTracker tracker = null;

            APIResultEnum apiResult = APIResultEnum.Failed;
            XomRequestTimeElapsed timeElapsed = new XomRequestTimeElapsed();

            profileXml = "";

            try
            {
                try
                {
                    // FastFail check
                    Xom.Trace(XomAreaName.passportTrace, LogLevel.L_LOW, "PassportClient.GetProfile: for puid {0} started", puidString);
                    tracker = GetFastFailTracker(apiName, PassportCredentials);

                    ProfileServiceAPISoapServerSoap pp = GetProfileServiceAPISoapServer("default");

                    Xom.Trace(XomAreaName.passportTrace, LogLevel.L_NORMAL, "PassportClient.GetProfile: calling Profile server");
                        
                    using (HistogramPerfCounterManager.GetHistogramManager("Passport", apiName))
                    {
                        results = pp.GetProfileByAttributes(
                            new string[] { puidString },
                            attributes,
                            0,
                            out ppErrorDetails);
                    }

                    if (string.IsNullOrEmpty(ppErrorDetails))
                    {
                        profileXml = results[0];
                    }
                    else
                    {
                        apiResult = APIResultEnum.Success;

                        throw new XRLException(
                            HResult.XONLINE_E_PASSPORT_ERROR, XEvent.Id.PASSPORT_GET_PROFILE_ERROR,
                            "{0}: error getting profile for puid {1}", ppErrorDetails, puidString);
                    }

                    Xom.Trace(XomAreaName.passportTrace, LogLevel.L_NORMAL, "PassportClient.GetProfile: returned from Profile server");
                }
                catch (SoapException se)
                {
                    if (se.Detail != null)
                    {
                        ppErrorDetails = se.Detail.InnerXml;
                    }

                    HResult ihr, hr;
                    GetHrFromSoapError(ppErrorDetails, out ihr, out hr);

                    if (hr == HResult.XONLINE_E_PASSPORT_NO_DATA)
                    {
                        Xom.Trace(XomAreaName.passportTrace, LogLevel.L_NORMAL, "PassportClient.GetProfile: invalid passport puid: {0}", puidString);
                        apiResult = APIResultEnum.Success;
                    }
                    else
                    {
                        throw new PassportClientException(
                            hr, ihr, XEvent.Id.PASSPORT_GET_PROFILE_ERROR, String.Format(
                            "{0}: error getting profile for puid {1}, {2}",
                            apiName, puidString, ppErrorDetails), se
                        );
                    }
                }
                catch (WebException we)
                {
                    Xom.Trace(XomAreaName.passportTrace, LogLevel.L_ERROR, "PassportClient.GetProfile: received WebException");

                    if (FastFailHelper.ConsiderWebExceptionAsTimeout(we))
                    {
                        tracker.IndicateTimeout();
                        apiResult = APIResultEnum.Timeout;
                    }

                    throw new XRLException(
                        apiResult == APIResultEnum.Timeout ? HResult.XONLINE_E_PASSPORT_TIMEOUT : HResult.XONLINE_E_PASSPORT_ERROR,
                        XEvent.Id.PASSPORT_GET_PROFILE_ERROR, we, "{0}: error getting profile for puid {1}", apiName, puidString);                   

                }
                finally
                {
                    // Liberal reporting policy here, success or timeout
                    if (null != tracker)
                    {
                        // Only first feature indication will be acknowledged, this might be ignored
                        tracker.IndicateSuccess();
                    }
                }
               
            }
            catch (Exception e)
            {
                if (string.IsNullOrEmpty(ppErrorDetails))
                {
                    ppErrorDetails = e.Message;
                }

                throw;
            }
            finally
            {
                inParams = new string[] { puidString, attributes };

                outParams = new string[] { profileXml };

                if (results != null)
                {
                    xmlReply = results.ToString();
                }

                LogApiCall(apiName, apiResult, timeElapsed.MillisecondsElapsed, inParams, outParams, xmlReply, ppErrorDetails);
            }

           
        }



        public override UInt64 GetPassportPuid(string passportMemberName)
        {
            string apiName = "GetPassportPuid";

            FastFailTracker tracker = null;

            string response;
            XmlDocument xml;
            XmlNode node;
            XmlAttribute attribute;

            APIResultEnum apiResult = APIResultEnum.Failed;
            XomRequestTimeElapsed timeElapsed = new XomRequestTimeElapsed();

            string[] inParams;
            string[] outParams = null;
            string xmlReply = "";
            string ppErrorDetails = "";

            UInt64 passportPuid = 0;

            try
            {
                try
                {
                    Xom.Trace(XomAreaName.passportTrace, LogLevel.L_LOW, "PassportClient.GetPassportPuid: for member name " + passportMemberName + " starting");
                    // FastFail check
                    tracker = GetFastFailTracker(apiName, PassportCredentials);

                    CredentialServiceAPISoapServerSoap pp = GetCredentialServiceAPISoapServer("default");

                    using (HistogramPerfCounterManager.GetHistogramManager("Passport", apiName))
                    {
                        Xom.Trace(XomAreaName.passportTrace, LogLevel.L_NORMAL, "PassportClient.GetPassportPuid: calling credential server ");
                        response = pp.GetNetIDsForSigninNames(passportMemberName);
                        Xom.Trace(XomAreaName.passportTrace, LogLevel.L_NORMAL, "PassportClient.GetPassportPuid: returned from credential server ");
                    }

                }
                catch (SoapException se)
                {
                    Xom.Trace(XomAreaName.passportTrace, LogLevel.L_ERROR, "PassportClient.GetPassportPuid: received SoapException");

                    if ( se.Detail != null )
                    {
                        ppErrorDetails = se.Detail.InnerXml;
                    }

                    HResult ihr, hr;
                    GetHrFromSoapError(ppErrorDetails, out ihr, out hr);

                    throw new PassportClientException(
                        hr, ihr, XEvent.Id.PASSPORT_GET_PUID_ERROR, String.Format(
                        "{0}: error getting puid for member name {1}\nErrorDetails: {2}",
                        apiName, passportMemberName, ppErrorDetails), se
                    );
                }
                catch (WebException we)
                {
                    Xom.Trace(XomAreaName.passportTrace, LogLevel.L_ERROR, "PassportClient.GetPassportPuid: received WebException");

                    if ( FastFailHelper.ConsiderWebExceptionAsTimeout(we) )
                    {
                        tracker.IndicateTimeout();
                        apiResult = APIResultEnum.Timeout;
                    }

                    throw new XRLException(
                        apiResult == APIResultEnum.Timeout ? HResult.XONLINE_E_PASSPORT_TIMEOUT : HResult.XONLINE_E_PASSPORT_ERROR,
                        XEvent.Id.PASSPORT_GET_PUID_ERROR, we, "{0}: error getting puid for member name {1}", apiName, passportMemberName
                    );
                }
                finally
                {
                    // Liberal reporting policy here, success or timeout
                    if (null != tracker)
                    {
                        // Only first feature indication will be acknowledged, this might be ignored
                        tracker.IndicateSuccess();
                    }
                }

                // Process xml response
                try
                {
                    xmlReply = response;

                    Xom.Trace(XomAreaName.passportTrace, LogLevel.L_LOW, "PassportClient.GetPassportPuid: XML reply:\r\n" + PrettyPrintXml(response) );

                    xml = new XmlDocument();
                    xml.LoadXml(response);

                    // Find the nodes with the puids
                    node = xml.SelectSingleNode("Name2NETID/SigninName");

                    if (node == null)
                    {
                        Xom.Trace(XomAreaName.passportTrace, LogLevel.L_LOW, "PassportClient.GetPassportPuid: completed");

                        apiResult = APIResultEnum.Success;

                        return passportPuid;
                    }

                    attribute = (XmlAttribute)node.Attributes.GetNamedItem("NetID");

                    // attribute now contains the Hex Passport-Puid
                    Xom.Trace(XomAreaName.passportTrace, LogLevel.L_LOW, "PassportClient.GetPassportPuid: found NetID value: " + attribute);

                    passportPuid = UInt64.Parse(attribute.Value, NumberStyles.HexNumber);

                    apiResult = APIResultEnum.Success;

                    return passportPuid;
                }
                catch(Exception e)
                {
                    Xom.Trace(XomAreaName.passportTrace, LogLevel.L_ERROR, "PassportClient.GetPassportPuid: error processing response");

                    throw new Exception(string.Format(
                        "pp.GetNetIDsForSigninNames failed: {0}\n"+
                        "passportMemberName={1}\n"+
                        "response:\n{2}",
                        e.Message,
                        passportMemberName,
                        response),
                        e);
                }
            }
            catch (Exception e)
            {
                if ( string.IsNullOrEmpty(ppErrorDetails) )
                {
                    ppErrorDetails = e.Message;
                }

                throw;
            }
            finally
            {
                inParams = new string[] {  passportMemberName };

                outParams = new string[] { passportPuid.ToString("X016") };

                LogApiCall(apiName, apiResult, timeElapsed.MillisecondsElapsed, inParams, outParams, xmlReply, ppErrorDetails);
            }
        }

        public override void DeleteCredential(Puid puid)
        {
            string apiName = "DeleteCredential";

            FastFailTracker tracker = null;

            APIResultEnum apiResult = APIResultEnum.Failed;
            XomRequestTimeElapsed timeElapsed = new XomRequestTimeElapsed();

            string[] inParams;
            string[] outParams = null;
            string xmlReply = "";
            string ppErrorDetails = "";

            try
            {
                try
                {
                    Xom.Trace(XomAreaName.passportTrace, LogLevel.L_LOW, "PassportClient.DeleteCredential: for puid " + puid + " starting");
                    // FastFail check
                    tracker = GetFastFailTracker(apiName, PassportCredentials);

                    // Format user data
                    tagPASSID tagPassId = new tagPASSID();
                    tagPassId.pit = PASSIDTYPE.PASSID_PUID;
                    tagPassId.bstrID = ((ulong)puid).ToString("X016");

                    // Prepare request
                    CredentialServiceAPISoapServerSoap pp = GetCredentialServiceAPISoapServer("default");

                    using (HistogramPerfCounterManager.GetHistogramManager("Passport", apiName))
                    {
                        Xom.Trace(XomAreaName.passportTrace, LogLevel.L_NORMAL, "PassportClient.DeleteCredential: calling credential server");
                        pp.DeleteCredential(tagPassId);
                        Xom.Trace(XomAreaName.passportTrace, LogLevel.L_NORMAL, "PassportClient.DeleteCredential: returned from credential server");
                    }

                    tracker.IndicateSuccess();
                }
                catch (SoapException se)
                {
                    Xom.Trace(XomAreaName.passportTrace, LogLevel.L_ERROR, "PassportClient.DeleteCredential: received SoapException");

                    if (se.Detail != null)
                    {
                        ppErrorDetails = se.Detail.InnerXml;
                    }

                    HResult ihr, hr;
                    GetHrFromSoapError(ppErrorDetails, out ihr, out hr);

                    throw new PassportClientException(
                        hr, ihr, XEvent.Id.PASSPORT_DELETE_CREDENTIAL_ERROR, String.Format(
                        "{0}: error deleting credentials for puid {1}\nMessage: {2}\nErrorDetails: {3}",
                        apiName, puid, se.Message, ppErrorDetails), se
                    );
                }
                catch (WebException we)
                {
                    Xom.Trace(XomAreaName.passportTrace, LogLevel.L_ERROR, "PassportClient.DeleteCredential: received WebException");

                    if (FastFailHelper.ConsiderWebExceptionAsTimeout(we))
                    {
                        apiResult = APIResultEnum.Timeout;
                        tracker.IndicateTimeout();
                    }

                    throw new XRLException(
                        apiResult == APIResultEnum.Timeout ? HResult.XONLINE_E_PASSPORT_TIMEOUT : HResult.XONLINE_E_PASSPORT_ERROR,
                        XEvent.Id.PASSPORT_DELETE_CREDENTIAL_ERROR, we, "{0}: error deleting credentials for puid {1}", apiName, puid
                    );
                }
                finally
                {
                    // Liberal reporting policy here, success or timeout
                    if (null != tracker)
                    {
                        // Only first feature indication will be acknowledged, this might be ignored
                        tracker.IndicateSuccess();
                    }
                }

                Xom.Trace(XomAreaName.passportTrace, LogLevel.L_LOW, "PassportClient.DeleteCredential: completed");

                apiResult = APIResultEnum.Success;

                return;
            }
            catch (Exception e)
            {
                if (string.IsNullOrEmpty(ppErrorDetails))
                {
                    ppErrorDetails = e.Message;
                }

                throw;
            }
            finally
            {
                inParams = new string[] { puid.ToString() };

                LogApiCall(apiName, apiResult, timeElapsed.MillisecondsElapsed, inParams, outParams, xmlReply, ppErrorDetails);
            }
        }

        public override void ForceCredentialRename(Puid puid)
        {
            string apiName = "ForceCredentialRename";

            FastFailTracker tracker = null;

            APIResultEnum apiResult = APIResultEnum.Failed;
            XomRequestTimeElapsed timeElapsed = new XomRequestTimeElapsed();

            string[] inParams;
            string[] outParams = null;
            string xmlReply = "";
            string ppErrorDetails = "";

            try
            {
                try
                {
                    Xom.Trace(XomAreaName.passportTrace, LogLevel.L_LOW, "PassportClient.ForceCredentialRename: for puid {0} starting", puid);
                    // FastFail check
                    tracker = GetFastFailTracker(apiName, PassportCredentials);

                    // Format user data
                    tagPASSID tagPassId = new tagPASSID();
                    tagPassId.pit = PASSIDTYPE.PASSID_PUID;
                    tagPassId.bstrID = ((ulong)puid).ToString("X016");

                    // Prepare request
                    CredentialServiceAPISoapServerSoap pp = GetCredentialServiceAPISoapServer("default");

                    using (HistogramPerfCounterManager.GetHistogramManager("Passport", apiName))
                    {
                        Xom.Trace(XomAreaName.passportTrace, LogLevel.L_NORMAL, "PassportClient.ForceCredentialRename: calling credential server");
                        pp.ForceCredentialRename(tagPassId);
                        Xom.Trace(XomAreaName.passportTrace, LogLevel.L_NORMAL, "PassportClient.ForceCredentialRename: returned from credential server");
                    }

                    tracker.IndicateSuccess();
                }
                catch (SoapException se)
                {
                    Xom.Trace(XomAreaName.passportTrace, LogLevel.L_ERROR, "PassportClient.ForceCredentialRename: received SoapException");

                    if (se.Detail != null)
                    {
                        ppErrorDetails = se.Detail.InnerXml;
                    }

                    HResult ihr, hr;
                    GetHrFromSoapError(ppErrorDetails, out ihr, out hr);

                    throw new PassportClientException(
                        hr, ihr, XEvent.Id.PASSPORT_FORCE_CREDENTIAL_RENAME_ERROR, String.Format(
                        "{0}: error deleting credentials for puid {1}\nMessage: {2}\nErrorDetails: {3}",
                        apiName, puid, se.Message, ppErrorDetails), se
                    );
                }
                catch (WebException we)
                {
                    Xom.Trace(XomAreaName.passportTrace, LogLevel.L_ERROR, "PassportClient.ForceCredentialRename: received WebException");

                    if (FastFailHelper.ConsiderWebExceptionAsTimeout(we))
                    {
                        apiResult = APIResultEnum.Timeout;
                        tracker.IndicateTimeout();
                    }

                    throw new XRLException(
                        apiResult == APIResultEnum.Timeout ? HResult.XONLINE_E_PASSPORT_TIMEOUT : HResult.XONLINE_E_PASSPORT_ERROR,
                        XEvent.Id.PASSPORT_FORCE_CREDENTIAL_RENAME_ERROR, we, "{0}: error deleting credentials for puid {1}", apiName, puid
                    );
                }
                finally
                {
                    // Liberal reporting policy here, success or timeout
                    if (null != tracker)
                    {
                        // Only first feature indication will be acknowledged, this might be ignored
                        tracker.IndicateSuccess();
                    }
                }

                Xom.Trace(XomAreaName.passportTrace, LogLevel.L_LOW, "PassportClient.ForceCredentialRename: completed");

                apiResult = APIResultEnum.Success;

                return;
            }
            catch (Exception e)
            {
                if (string.IsNullOrEmpty(ppErrorDetails))
                {
                    ppErrorDetails = e.Message;
                }

                throw;
            }
            finally
            {
                inParams = new string[] { puid.ToString() };

                LogApiCall(apiName, apiResult, timeElapsed.MillisecondsElapsed, inParams, outParams, xmlReply, ppErrorDetails);
            }
        }

        // update the single non-encrypted property for the specified user

        public override void SetNoAgeOut(ulong puid, bool value)
        {
            string apiName = "SetNoAgeOut";

            FastFailTracker tracker = null;

            APIResultEnum apiResult = APIResultEnum.Failed;
            XomRequestTimeElapsed timeElapsed = new XomRequestTimeElapsed();

            string[] inParams;
            string[] outParams = null;
            string xmlReply = "";
            string ppErrorDetails = "";

            try
            {
                try
                {
                    Xom.Trace(XomAreaName.passportTrace, LogLevel.L_LOW, "PassportClient.SetNoAgeOut: for puid " + puid.ToString("X016") + " starting");
                    // FastFail check
                    tracker = GetFastFailTracker(apiName, PassportCredentials);

                    // Format user data
                    string userData = string.Format(
                                                    _userDataSingleNonEncryptedProperty,
                                                    puid.ToString("X016"), "NoAgeOut", value ? "True" : "False"
                                                    );

                    // Prepare request
                    CredentialServiceAPISoapServerSoap pp = GetCredentialServiceAPISoapServer("default");

                    using (HistogramPerfCounterManager.GetHistogramManager("Passport", apiName))
                    {
                        Xom.Trace(XomAreaName.passportTrace, LogLevel.L_NORMAL, "PassportClient.SetNoAgeOut: calling credential server");
                        pp.UpdateCredential(userData);
                        Xom.Trace(XomAreaName.passportTrace, LogLevel.L_NORMAL, "PassportClient.SetNoAgeOut: returned from credential server");
                    }

                    tracker.IndicateSuccess();
                }
                catch (SoapException se)
                {
                    Xom.Trace(XomAreaName.passportTrace, LogLevel.L_ERROR, "PassportClient.SetNoAgeOut: received SoapException");

                    if ( se.Detail != null )
                    {
                        ppErrorDetails = se.Detail.InnerXml;
                    }

                    HResult ihr, hr;
                    GetHrFromSoapError(ppErrorDetails, out ihr, out hr);

                    throw new PassportClientException(
                        hr, ihr, XEvent.Id.PASSPORT_SET_NO_AGE_OUT_ERROR, String.Format(
                        "{0}: error setting no age out for puid 0x{1}\nMessage: {2}\nErrorDetails: {3}",
                        apiName, puid.ToString("X016"), se.Message, ppErrorDetails), se
                    );
                }
                catch (WebException we)
                {
                    Xom.Trace(XomAreaName.passportTrace, LogLevel.L_ERROR, "PassportClient.SetNoAgeOut: received WebException");

                    if (FastFailHelper.ConsiderWebExceptionAsTimeout(we))
                    {
                        apiResult = APIResultEnum.Timeout;
                        tracker.IndicateTimeout();
                    }

                    throw new XRLException(
                        apiResult == APIResultEnum.Timeout ? HResult.XONLINE_E_PASSPORT_TIMEOUT : HResult.XONLINE_E_PASSPORT_ERROR,
                        XEvent.Id.PASSPORT_SET_NO_AGE_OUT_ERROR, we, "{0}: error setting no age out for puid 0x{1}", apiName, puid.ToString("X016")
                    );
                }
                finally
                {
                    // Liberal reporting policy here, success or timeout
                    if (null != tracker)
                    {
                        // Only first feature indication will be acknowledged, this might be ignored
                        tracker.IndicateSuccess();
                    }
                }

                Xom.Trace(XomAreaName.passportTrace, LogLevel.L_LOW, "PassportClient.SetNoAgeOut: completed");

                apiResult = APIResultEnum.Success;

                return;
            }
            catch (Exception e)
            {
                if ( string.IsNullOrEmpty(ppErrorDetails) )
                {
                    ppErrorDetails = e.Message;
                }

                throw;
            }
            finally
            {
                inParams = new string[] {  puid.ToString("X016") };

                LogApiCall(apiName, apiResult, timeElapsed.MillisecondsElapsed, inParams, outParams, xmlReply, ppErrorDetails);
            }
        }


        public override bool GetNoAgeOut(ulong puid)
        {
            string apiName = "GetNoAgeOut";
            FastFailTracker tracker = null;
            string userData = string.Empty;

            HResult hr;
            HResult ihr;

            APIResultEnum apiResult = APIResultEnum.Failed;
            XomRequestTimeElapsed timeElapsed = new XomRequestTimeElapsed();

            string[] inParams;
            string[] outParams = null;
            string xmlReply = "";
            string ppErrorDetails = "";
            bool isNoAgeOutSet = false;

            try
            {
                try
                {
                    // FastFail check
                    tracker = GetFastFailTracker(apiName, PassportCredentials);

                    // Prepare request
                    CredentialServiceAPISoapServerSoap pp = GetCredentialServiceAPISoapServer("default");

                    tagPASSID tagPassId = new tagPASSID();
                    tagPassId.pit = PASSIDTYPE.PASSID_PUID;
                    tagPassId.bstrID = puid.ToString("X016");

                    using (HistogramPerfCounterManager.GetHistogramManager("Passport", apiName))
                    {
                        userData = pp.GetCredentialInfo(tagPassId, "NoAgeOut");
                    }

                    tracker.IndicateSuccess();
                }

                catch (SoapException se)
                {
                    if ( se.Detail != null )
                    {
                        ppErrorDetails = se.Detail.InnerXml;
                    }

                    GetHrFromSoapError(ppErrorDetails, out ihr, out hr);

                    throw new PassportClientException(
                        hr, ihr, XEvent.Id.PASSPORT_GET_NO_AGE_OUT_ERROR, String.Format(
                        "{0}: error getting no age out for puid 0x{1}\nMessage: {2}\nErrorDetails: {3}",
                        apiName, puid.ToString("X016"), se.Message, ppErrorDetails), se
                    );
                }

                catch (WebException we)
                {
                    if (FastFailHelper.ConsiderWebExceptionAsTimeout(we))
                    {
                        apiResult = APIResultEnum.Timeout;
                        tracker.IndicateTimeout();
                    }

                    throw new XRLException(
                        apiResult == APIResultEnum.Timeout ? HResult.XONLINE_E_PASSPORT_TIMEOUT : HResult.XONLINE_E_PASSPORT_ERROR,
                        XEvent.Id.PASSPORT_GET_NO_AGE_OUT_ERROR, we, "{0}: error getting no age out for puid 0x{1}", apiName, puid.ToString("X016")
                    );
                }

                finally
                {
                    // Liberal reporting policy here, success or timeout
                    if (null != tracker)
                    {
                        // Only first feature indication will be acknowledged, this might be ignored
                        tracker.IndicateSuccess();
                    }
                }

                // Process xml response
                xmlReply = userData;

                Xom.Trace(XomAreaName.passportTrace, LogLevel.L_LOW, "PassportClient.GetNoAgeOut: XML reply:\r\n" + PrettyPrintXml(userData));

                XmlDocument document = new XmlDocument();
                document.LoadXml(userData);

                XmlNamespaceManager namespaceManager = new XmlNamespaceManager(document.NameTable);
                namespaceManager.AddNamespace("p", "http://schemas.microsoft.com/Passport/User");

                // Find the nodes with the puids
                XmlNode node = document.SelectSingleNode(
                    "/p:userData/p:credential/p:property[@name='NoAgeout']", namespaceManager
                );

                if (node != null)
                {
                    apiResult = APIResultEnum.Success;

                    if (string.Compare(node.InnerText.Trim(), "True", true) == 0)
                    {
                        isNoAgeOutSet = true;
                        return true;
                    }
                    else if (string.Compare(node.InnerText.Trim(), "False", true) == 0)
                    {
                        isNoAgeOutSet = false;
                        return false;
                    }
                }

                throw new XRLException(
                    HResult.XONLINE_E_PASSPORT_INVALID_RESPONSE,
                    XEvent.Id.PASSPORT_INVALID_RESPONSE,
                    "Missing element /p:userData/p:credential/p:property[@name='NoAgeOut']\r\n" + userData
                );
            }
            catch (Exception e)
            {
                if ( string.IsNullOrEmpty(ppErrorDetails) )
                {
                    ppErrorDetails = e.Message;
                }

                throw;
            }
            finally
            {
                inParams = new string[] {  puid.ToString("X016") };

                outParams = new string[] { isNoAgeOutSet.ToString() };

                LogApiCall(apiName, apiResult, timeElapsed.MillisecondsElapsed, inParams, outParams, xmlReply, ppErrorDetails);
            }
        }


        public override void UpdateProfile(string profileXml)
        {
            try
            {
                InternalUpdateProfile(profileXml);
            }
            catch(PassportClientException e)
            {
                if(e.InternalHResult == 0x8004812f) // Profile doesn't exist
                {
                    InternalCreateProfile(profileXml);
                }
                else
                {
                    throw;
                }
            }
        }

        protected void InternalCreateProfile(string profileXml)
        {
            string apiName = "InternalCreateProfile";
            string ppErrorDetails = string.Empty;

            Xom.Trace(XomAreaName.passportTrace, LogLevel.L_LOW, "PassportClient.InternalCreateProfile: starting");
            ProfileServiceAPISoapServerSoap pp = GetProfileServiceAPISoapServer("default");

            FastFailTracker tracker = null;

            try
            {
                // FastFail check
                tracker = GetFastFailTracker(apiName, PassportUps);
                
                using (HistogramPerfCounterManager.GetHistogramManager("Passport", apiName))
                {
                    Xom.Trace(XomAreaName.passportTrace, LogLevel.L_NORMAL, "PassportClient.InternalCreateProfile: calling profile service");
                    pp.CreateProfile(new string[] { profileXml });
                    Xom.Trace(XomAreaName.passportTrace, LogLevel.L_NORMAL, "PassportClient.InternalCreateProfile: returned from service");
                }

            }
            catch (SoapException se)
            {
                Xom.Trace(XomAreaName.passportTrace, LogLevel.L_ERROR, "PassportClient.InternalCreateProfile: received soap exception");

                if (se.Detail != null)
                {
                    ppErrorDetails = se.Detail.InnerXml;
                }

                HResult ihr, hr;
                GetHrFromSoapError(ppErrorDetails, out ihr, out hr);

                throw new PassportClientException(
                    hr, ihr, XEvent.Id.PASSPORT_CREATE_PROFILE_ERROR, String.Format(
                    "{0}: error creating profile\nProfile: {1}\nMessage: {2}\nXml: {3}",
                    apiName, profileXml, se.Message, ppErrorDetails), se
                );
            }

            catch (WebException we)
            {
                Xom.Trace(XomAreaName.passportTrace, LogLevel.L_ERROR, "PassportClient.InternalCreateProfile: received WebException");
                APIResultEnum apiResult = APIResultEnum.Success;

                if ( FastFailHelper.ConsiderWebExceptionAsTimeout(we) )
                {
                    tracker.IndicateTimeout();
                    apiResult = APIResultEnum.Timeout;
                }

                throw new XRLException(
                    apiResult == APIResultEnum.Timeout ? HResult.XONLINE_E_PASSPORT_TIMEOUT : HResult.XONLINE_E_PASSPORT_ERROR,
                    XEvent.Id.PASSPORT_CREATE_PROFILE_ERROR, we, "{0}: error creating profile", apiName
                );
            }

            finally
            {
                // Liberal reporting policy here, success or timeout
                if (null != tracker) {
                    // Only first feature indication will be acknowledged, this might be ignored
                    tracker.IndicateSuccess();
                }
            }

            Xom.Trace(XomAreaName.passportTrace, LogLevel.L_LOW, "PassportClient.InternalCreateProfile: completed");
        }

        protected void InternalUpdateProfile(string profileXml)
        {
            string apiName = "InternalUpdateProfile";
            string ppErrorDetails = string.Empty;

            Xom.Trace(XomAreaName.passportTrace, LogLevel.L_LOW, "PassportClient.InternalUpdateProfile: starting");
            ProfileServiceAPISoapServerSoap pp = GetProfileServiceAPISoapServer("default");

            FastFailTracker tracker = null;

            try
            {
                // FastFail check
                tracker = GetFastFailTracker(apiName, PassportUps);

                Xom.Trace(XomAreaName.passportTrace, LogLevel.L_NORMAL, "PassportClient.InternalUpdateProfile: calling profile service");
                pp.UpdateProfile(new string[] {profileXml});
                Xom.Trace(XomAreaName.passportTrace, LogLevel.L_NORMAL, "PassportClient.InternalUpdateProfile: returned from profile service");
            }

            catch (SoapException se)
            {
                Xom.Trace(XomAreaName.passportTrace, LogLevel.L_ERROR, "PassportClient.InternalUpdateProfile: received SoapException");

                if (se.Detail != null)
                {
                    ppErrorDetails = se.Detail.InnerXml;
                }

                HResult ihr, hr;
                GetHrFromSoapError(ppErrorDetails, out ihr, out hr);

                throw new PassportClientException(
                    hr, ihr, XEvent.Id.PASSPORT_UPDATE_PROFILE_ERROR, String.Format(
                    "{0}: error updating profile.\nProfile: {1}\nMessage: {2}\nErrorDetails: {3}",
                    apiName, profileXml, se.Message, ppErrorDetails), se
                );
            }

            catch (WebException we)
            {
                Xom.Trace(XomAreaName.passportTrace, LogLevel.L_ERROR, "PassportClient.InternalUpdateProfile: received WebException");
                APIResultEnum apiResult = APIResultEnum.Success;

                if ( FastFailHelper.ConsiderWebExceptionAsTimeout(we) )
                {
                    tracker.IndicateTimeout();
                    apiResult = APIResultEnum.Timeout;
                }

                throw new XRLException(
                    apiResult == APIResultEnum.Timeout ? HResult.XONLINE_E_PASSPORT_TIMEOUT : HResult.XONLINE_E_PASSPORT_ERROR,
                    XEvent.Id.PASSPORT_UPDATE_PROFILE_ERROR, we, "{0}: error updating profile", apiName
                );
            }

            finally
            {
                // Liberal reporting policy here, success or timeout
                if (null != tracker) {
                    // Only first feature indication will be acknowledged, this might be ignored
                    tracker.IndicateSuccess();
                }
            }

            Xom.Trace(XomAreaName.passportTrace, LogLevel.L_LOW, "PassportClient.InternalUpdateProfile: completed");
        }



        // Initialize with settings from the global config
        public void Init()
        {
            Init(null);
        }

        // Initialize with settings from the global config
        public void Init(string alternateUrl)
        {
            // Retrieve settings
            string   partnerUrl     = Config.GetSetting(Setting.passport_partnerUrl);
            string   siteId         = Config.GetSetting(Setting.passport_siteId);
            string   siteAddress    = Config.GetSetting(Setting.passport_siteAddress);
            string   siteAddressMsn = Config.GetSetting(Setting.passport_siteAddressMsn);
            string   clientCertName = Config.GetSetting(Setting.passport_clientCertName);
            string   publicKeyCert  = Config.GetSetting(Setting.passport_publicKeyCert);
            string   sitePolicy     = Config.GetSetting(Setting.passport_sitePolicy);
            string   sitePolicyMsn  = Config.GetSetting(Setting.passport_sitePolicyMsn);
            string[] arrSqXml       = Config.GetMultiSetting(MultiSetting.passport_secretQuestionsXml);
            string   proxy          = Config.GetSetting(Setting.billing_proxy);

            if(alternateUrl != null)
                partnerUrl = alternateUrl;

            string msg = string.Format(
                "Passport interface initializing with the following settings:\n"+
                "passport_partnerXrl         = {0}\n"+
                "passport_siteId             = {1}\n"+
                "passport_siteAddress        = {2}\n"+
                "passport_siteAddressMsn     = {3}\n"+
                "passport_clientCertName     = {4}\n"+
                "passport_publicKeyCert      = {5}\n"+
                "passport_sitePolicy         = {6}\n"+
                "passport_sitePolicyMsn      = {7}\n"+
                "passport_secretQuestionsXml = (blob-count = {8})\n"+
                "billing_proxy               = {9}\n",
                partnerUrl,
                siteId,
                siteAddress,
                siteAddressMsn,
                clientCertName,
                publicKeyCert,
                sitePolicy,
                sitePolicyMsn,
                arrSqXml.Length.ToString(),
                proxy);

          Xom.NtEvent(XEvent.Id.COMMON_INFO_2, msg);

            SetWebProxy(proxy);

            // Load partner.xml
            string partnerXml = RetrievePartnerXmlFromPassport(partnerUrl, _proxy);
            LoadPartnerXml(partnerXml);

            // Init
            ManualInit(siteId,
                       siteAddress,
                       siteAddressMsn,
                       clientCertName,
                       Encoding.ASCII.GetBytes(publicKeyCert),
                       sitePolicy,
                       sitePolicyMsn,
                       arrSqXml);

            InitializeFastFail();

            // Grab any setting changes we're interested in.
            Config.SettingChange += new SettingChangeEventHandler(OnSettingsChanged);
        }

        public void OnSettingsChanged(object sender, SettingChangeEventArgs eventArgs)
        {
            switch (eventArgs.Setting)
            {
                case Setting.passport_publicKeyCert:
                    string publicKeyCert = eventArgs.ValueNew;
                    LoadPublicKeyFromCertificate(Encoding.ASCII.GetBytes(publicKeyCert), this);
                    Xom.Log(XomAreaName.passportLog,
                            "PassportClient.OnSettingsChanged: new value for Setting.passport_publicKeyCert: {0}",
                            publicKeyCert);
                    break;
            }
        }

        private void InitializeFastFail() {
            FastFailResourceConfig defaultConfig;

            defaultConfig = FastFailBillingDefaults.GetConfiguration();

            FastFailBillingDefaults.InitializeFastFailResource(defaultConfig, PassportCreation);
            FastFailBillingDefaults.InitializeFastFailResource(defaultConfig, PassportCredentials);
            FastFailBillingDefaults.InitializeFastFailResource(defaultConfig, PassportLogin);
            FastFailBillingDefaults.InitializeFastFailResource(defaultConfig, PassportUps);
        }


        // Manual initialize (you provide initialization parameters)
        public void ManualInit(
            string siteId,
            string siteAddress,
            string siteAddressMsn,
            string clientCertSubject,
            byte[] passportPublicKeyCert,
            string sitePolicy,
            string sitePolicyMsn,
            string[] arrSqXml
        )
        {
            _siteId = siteId;
            _siteAddresses = new string[XOn.XONLINE_PASSPORT_LOGIN_SERVICE_ID_MAX + 1];

            _loginTokenRequests = new string[XOn.XONLINE_PASSPORT_LOGIN_SERVICE_ID_MAX + 1];

            for(int i = XOn.XONLINE_PASSPORT_LOGIN_SERVICE_ID_MIN;
                i <= XOn.XONLINE_PASSPORT_LOGIN_SERVICE_ID_MAX;
                i++)
            {
                switch(i)
                {
                case XOn.XONLINE_PASSPORT_LOGIN_LEGACY_SERVICE_ID:
                    _siteAddresses[i] = siteAddress;
                    _loginTokenRequests[i] = string.Format(_loginTokenRequestTemplate, siteAddress, sitePolicy);
                    break;
                case XOn.XONLINE_PASSPORT_LOGIN_XBOXLIVE_SERVICE_ID:
                    _siteAddresses[i] = siteAddress;
                    _loginTokenRequests[i] = string.Format(_loginTokenRequestTemplate, siteAddress, sitePolicy);
                    break;
                case XOn.XONLINE_PASSPORT_LOGIN_MESSENGER_SERVICE_ID:
                    _siteAddresses[i] = siteAddressMsn;
                    _loginTokenRequests[i] = string.Format(_loginTokenRequestTemplate, siteAddressMsn, sitePolicyMsn);
                    break;
                }
            }

            LoadPassportClientCertificate(clientCertSubject);
            LoadPublicKeyFromCertificate(passportPublicKeyCert, this);
            LoadSecretQuestions(arrSqXml);
            Xom.Trace(XomAreaName.passportTrace, LogLevel.L_LOW, "PassportClientGlobal.ManualInit: completed successfully.");
        }

        public void TestGenerateEncryptedLoginParts(
            string passw,
            out byte[] encSesKey,
            out byte[] encPassw,
            out byte[] encReq
            )
        {
            TestGenerateEncryptedLoginParts(
                passw,
                XOn.XONLINE_PASSPORT_LOGIN_LEGACY_SERVICE_ID,
                out encSesKey,
                out encPassw,
                out encReq);
        }

        public byte[] TestGenerateEncryptedLoginParts(
            string passw,
            int serviceId,
            out byte[] encSesKey,
            out byte[] encPassw,
            out byte[] encReq
            )
        {
            SHA1Managed shafn = new SHA1Managed();

            // Generate a random session key
            RandomNumberGenerator rand = RandomNumberGenerator.Create();
            byte[] sessionKey = new byte[24];
            rand.GetBytes(sessionKey);

            // Use Iv = 0
            byte[] iv = new byte[8];

            // Encript session key using passport public key
            encSesKey = EncryptWithPassportPublicKey(sessionKey);

            // Format timestamp
            DateTime now = DateTime.UtcNow;
            byte[] timestamp = Encoding.UTF8.GetBytes(now.ToString("yyyy-MM-ddTHH:mm:ssZ"));

            // Calculate password message using the following scheme:
            // shaPassw = SHA1_hash(Password + timestamp + SHA1_hash(PP public key))
            // PasswordCiphervalue= Base64(Encrypt-SessionKey_S(shaPassw+timestamp))
            BinaryWriter bw = new BinaryWriter(new MemoryStream(256));
            bw.Write(Encoding.UTF8.GetBytes(passw));
            bw.Write(timestamp);
            bw.Write(_shaPubKey);
            byte[] passwblob = ((MemoryStream)bw.BaseStream).ToArray();
            byte[] shaPassw = shafn.ComputeHash(passwblob);

            using (bw = new BinaryWriter(new MemoryStream(256)))
            {
                bw.Write(shaPassw);
                bw.Write(timestamp);
                byte[] shaTsBlob = ((MemoryStream)bw.BaseStream).ToArray();

                byte[] encShaTsBlob = EncryptWith3Des(sessionKey, iv, shaTsBlob);
                encPassw = encShaTsBlob;
            }

            // Request
            encReq = EncryptWith3Des(sessionKey, iv, Encoding.UTF8.GetBytes(_loginTokenRequests[serviceId]));
            return sessionKey;
        }

        public override byte[] GenerateEncryptedCredentials(
            string oldPassword,
            string newPassword,
            string secretAnswer
        ) {
            byte[] binOldPassword = Encoding.ASCII.GetBytes(oldPassword);
            byte[] binPassword = Encoding.ASCII.GetBytes(newPassword);
            byte[] binSecretAnswer = Encoding.Unicode.GetBytes(secretAnswer);
            byte[] credentials;

            using (BinaryWriter bw = new BinaryWriter(new MemoryStream(200)))
            {
                bw.Write((byte) 1); // Version of the encryption scheme
                bw.Write((byte) 1); // Version of the format of the plaintext string
                bw.Write((byte) binPassword.Length); // Size of password in bytes
                bw.Write(binPassword); // Password in ascii
                bw.Write((byte) binSecretAnswer.Length); // Size of secret-answer in bytes
                if (0 < binSecretAnswer.Length) bw.Write(binSecretAnswer); // secret-answer in unicode
                bw.Write((byte) binOldPassword.Length); // Size of old-password.
                if (0 < binOldPassword.Length) bw.Write(binOldPassword); // old-password in ascii

                credentials = ((MemoryStream) bw.BaseStream).ToArray();
            }

            // Encrypt
            return EncryptWithPassportPublicKey(credentials);
        }

        public void TestGenerateEncryptedCredentials(
            string oldPassword,
            string newPassword,
            string secretAnswer,
            out byte[] encryptedCredentials
        )
        {
            encryptedCredentials = GenerateEncryptedCredentials(oldPassword, newPassword, secretAnswer);
        }

        protected CredentialServiceAPISoapServerSoap GetCredentialServiceAPISoapServer(string pmn)
        {
            Xom.Trace(XomAreaName.passportTrace, LogLevel.L_LOW, "PassportClient.GetCredentialServiceSoapServer: starting");

            // Format header
            string ppSoapHeader25 = string.Format(
                _ppSoapHeader25Template,
                _siteId );

            string url = GetDomainConfig(pmn).serviceAPICredentialServerPK;

            string alternateUrl = PassportClientGlobal.GetSessionAlternateCredentialServiceUrl();
            if ( false == string.IsNullOrEmpty(alternateUrl) )
            {
                Xom.Trace(XomAreaName.passportTrace, LogLevel.L_HIGH, "GetCredentialServiceSoapServer: using alternateUrl: " + alternateUrl);
                url = alternateUrl;
            }

            CredentialServiceAPISoapServerSoap pp = new CredentialServiceAPISoapServerSoap();
            // Set the URL based on the passport member name's domain
            pp.Url = url;
            pp.Proxy = _proxy;
            pp.ClientCertificates.Add(_clientCert);
            pp.WSSecurityHeader = new tagWSSECURITYHEADER();
            pp.WSSecurityHeader.version   = EnumSHVersion.eshHeader25;
            pp.WSSecurityHeader.sitetoken = _siteId;
            pp.WSSecurityHeader.ppSoapHeader25 = ppSoapHeader25;
            pp.Timeout = GetPartnerCallTimeoutSeconds * 1000;

            Xom.Trace(XomAreaName.passportTrace, LogLevel.L_LOW, "PassportClient.GetCredentialServiceSoapServer: completed");
            return pp;
        }

        protected ProfileServiceAPISoapServerSoap GetProfileServiceAPISoapServer(string pmn)
        {
            Xom.Trace(XomAreaName.passportTrace, LogLevel.L_LOW, "PassportClient.GetProfileServiceAPISoapServer: starting");

            string ppSoapHeader25 = string.Format(
                _ppSoapHeader25Template,
                _siteId );

            string url = GetDomainConfig(pmn).serviceAPIProfileServerPK;

            string alternateUrl = PassportClientGlobal.GetSessionAlternateProfileServiceUrl();
            if ( false == string.IsNullOrEmpty(alternateUrl) )
            {
                Xom.Trace(XomAreaName.passportTrace, LogLevel.L_HIGH, "GetProfileServiceSoapServer: using alternateUrl: " + alternateUrl);
                url = alternateUrl;
            }

            ProfileServiceAPISoapServerSoap pp = new ProfileServiceAPISoapServerSoap();
            pp.Url = url;
            pp.Proxy = _proxy;
            pp.ClientCertificates.Add(_clientCert);
            pp.WSSecurityHeader = new tagWSSECURITYHEADER1();
            pp.WSSecurityHeader.version   = EnumSHVersion1.eshHeader25;
            pp.WSSecurityHeader.sitetoken = _siteId;
            pp.WSSecurityHeader.ppSoapHeader25 = ppSoapHeader25;
            pp.Timeout = GetPartnerCallTimeoutSeconds * 1000;

            Xom.Trace(XomAreaName.passportTrace, LogLevel.L_LOW, "PassportClient.GetProfileServiceAPISoapServer: completed");
            return pp;
        }

        protected FastFailTracker GetFastFailTracker(string apiName, string resourceName) {
            try { return new FastFailTracker(resourceName); }
            catch (FastFailException inner) {
                Xom.Trace(XomAreaName.passportTrace, LogLevel.L_ERROR, "PassportClient.GetFastFailTracker: " + apiName + " call blocked due to fast fail");

                throw new XRLExceptionWithoutEvent(
                    HResult.XONLINE_E_RESOURCE_UNAVAILABLE,
                    inner,
                    "{0}: call blocked due to fail-fasting of passport server", apiName
                );
            }
        }

        protected void GetHrFromSoapError(string errorXml, out HResult internalHr, out HResult liveHr )
        {
            string invalidFields = null;
            XmlDocument xml = new XmlDocument();
            XmlNode node = null;
            xml.LoadXml(errorXml);
            XmlNamespaceManager nsm = new XmlNamespaceManager(xml.NameTable);
            nsm.AddNamespace("psf", "http://schemas.microsoft.com/Passport/SoapServices/SOAPFault");

            internalHr = 0;
            liveHr     = 0;

            if((node = xml.SelectSingleNode("/psf:error/psf:value", nsm)) != null)
            {
                internalHr = HResult.Parse(node.InnerText);

                //
                // Before returning the hr, check if it's not the generic
                // passport soap error which would indicate that there is a
                // internal error hr in the same blob that is more specific
                //

                if(internalHr == 0x80048102)
                {
                    // Error is in an internal error node
                    if((node = xml.SelectSingleNode("/psf:error/psf:internalerror/psf:code", nsm)) != null)
                    {
                        internalHr = HResult.Parse(node.InnerText);
                    }
                }
                else if (internalHr == 0x80048112)
                {
                    // Multiple errors. We care about the first one.
                    if((node = xml.SelectSingleNode("/psf:error/psf:description/psf:detail/MultipleErrors/Error", nsm)) != null)
                    {
                        internalHr = HResult.Parse(node.SelectSingleNode("HR", nsm).InnerText);

                        if((node = node.SelectSingleNode("InvalidFields", nsm)) != null)
                        {
                            invalidFields = node.InnerText;
                        }
                    }
                }
            }
            else
            {
                throw new XRLException(
                    HResult.XONLINE_E_PASSPORT_INVALID_RESPONSE,
                    XEvent.Id.PASSPORT_INVALID_RESPONSE,
                    "Missing element /psf:error/psf:value, " + errorXml
                );
            }

            // derive liveHr from internalHr
            if(internalHr == 0x80044513)
            {
                // special case. if error = invalid postal-code, return a
                // specific hr
                if(invalidFields != null
                   && invalidFields.ToLower().IndexOf("addresses_cs.home.postalcode") != -1)
                {
                    liveHr = HResult.XONLINE_E_PASSPORT_INVALID_POSTAL_CODE;
                }
            }

            if(liveHr == 0)
            {
                liveHr = TranslatePassportHrToLiveHr(internalHr);
            }
        }

        protected HResult TranslatePassportHrToLiveHr(HResult passportHr)
        {
            switch(passportHr)
            {
            //case 0x8004816f: // Password Missing
            //case 0x8004110a: // The email is blank.
            //case 0x8004114f: // The password entered matches one of the accounts with the same member name.
            //case 0x8004111c: // No secret question was entered or found.
            //case 0x8004450f: // The cred field provided was not valid on the operation being performed.
            //case 0x8004118d: // The required field is blank.
            //case 0x80041113: // The year of birth is missing.
            //case 0x80041163: // The field contains invalid characters.
            //case 0x800481a3: // The transaction type is invalid and/or is not supported.
            //case 0x8004812b: // Credential xml contains no credentials
            //case 0x80044064: // Invalid data, the xml input does not conform with the XML standards
            //case 0x80070057: // The parameter is incorrect.
            //case 0x8004400e: // The credential field does not contain any data.
            //case 0x80045024: // The specified user is not authorized to perform the requested operation.
            //case 0x80045074: // The delegated passport id is invalid or does not match the identity for the current request
            //case 0x80045075: // The authorization token does not contain delegate information
            //case 0x80041802: // Failed to decrypt data. Check error code for reason.
            //case 0x8004819f: // The type attribute of the X509SKI node in the XML had an unrecognized value.
            //case 0x8004438a: // The input xml is missing a required node
            //case 0x8004816b: // Credential Name Missing
            //case 0x800481a0: // The XML version specified in the decrypted data is not supported, or it did not match the Version node in the XML.
            //case 0x800481a1: // The data version specified in the decrypted data is not supported.
            //case 0x800481a2: // The encrypted credentials could not be parsed.  There is some kind of inconsistency between the byte count and the number of bytes a field actually uses up, or the decrypted data is incomplete.
            case 0x80041010: // The credential is locked out.
                return HResult.XONLINE_E_PASSPORT_LOCKED_OUT;
            case 0x80041011: // The credential is locked out.
                return HResult.XONLINE_E_PASSPORT_LOCKED_OUT;
            case 0x80041012: // Wrong password and/or membername dose not exist.
                return HResult.XONLINE_E_PASSPORT_WRONG_NAME_OR_PASSWORD;
            case 0x8004103a: // The PP Kids account does not have consent
                return HResult.XONLINE_E_PASSPORT_KIDS_ACCOUNT_NO_CONSENT;
            case 0x8004104C: // The credential is in a forced renamed state
                return HResult.XONLINE_E_PASSPORT_FORCE_RENAME;
            case 0x80041082: // The password for the account has expired.
                return HResult.XONLINE_E_PASSPORT_PASSWORD_EXPIRED;
            case 0x80041083: // The secret question and answer has to be changed.
                return HResult.XONLINE_E_PASSPORT_FORCE_CHANGE_SQ_SA;
            case 0x8004180b: // The key being sent to passport is invalid (wrong version, expired)
                return HResult.XONLINE_E_PASSPORT_ASM_KEY_NOT_FOUND;
            case 0x80041101: // The signin name is too short.
                return HResult.XONLINE_E_MEMBER_NAME_TOO_SHORT;
            case 0x80041103: // The signin name is incomplete or has invalid characters.
                return HResult.XONLINE_E_MEMBER_NAME_INVALID;
            case 0x80041104: // The password is blank.
                return HResult.XONLINE_E_PASSWORD_BLANK;
            case 0x80041105: // The password is too short.
                return HResult.XONLINE_E_PASSWORD_TOO_SHORT;
            case 0x80041106: // The password is too long.
                return HResult.XONLINE_E_PASSWORD_TOO_LONG;
            case 0x80041107: // The password contains the member name.
                return HResult.XONLINE_E_PASSWORD_CONTAINS_MEMBER_NAME;
            case 0x80041108: // The password contains invalid characters.
                return HResult.XONLINE_E_PASSWORD_CONTAINS_INVALID_CHARACTERS;
            case 0x8004110d: // The email address is incomplete. This is usually due to missing '@' or '.'.
                return HResult.XONLINE_E_MEMBER_NAME_INVALID;
            case 0x80041120: // The answer to the secret question is too short.
                return HResult.XONLINE_E_SA_TOO_SHORT;
            case 0x80041122: // The secret question is too short.
                return HResult.XONLINE_E_PASSPORT_SQ_TOO_SHORT;
            case 0x80041123: // The secret question is too short.
                return HResult.XONLINE_E_PASSPORT_SQ_TOO_LONG;
            case 0x8004116a: // The answer for the secret question contains the member name.
                return HResult.XONLINE_E_SA_CONTAINS_MEMBER_NAME;
            case 0x80041132: // The non EASI member exists.
                return HResult.XONLINE_E_PASSPORT_NAME_ALREADY_TAKEN;
            case 0x80041133: // this seems to be "name already taken"
                return HResult.XONLINE_E_PASSPORT_NAME_ALREADY_TAKEN;
            case 0x80041153: // The email name starts and ends with '.'.
                return HResult.XONLINE_E_MEMBER_NAME_INVALID;
            case 0x80041154: // The email name starts after a '.'.
                return HResult.XONLINE_E_MEMBER_NAME_INVALID;
            case 0x80041155: // The domain has invalid characters.
                return HResult.XONLINE_E_MEMBER_NAME_INVALID;
            case 0x80041156: // The email name has invalid characters.
                return HResult.XONLINE_E_MEMBER_NAME_INVALID;
            case 0x80041158: // The domain portion begins with a dot.
                return HResult.XONLINE_E_MEMBER_NAME_INVALID;
            case 0x80041165: // The secret question contains the answer.
                return HResult.XONLINE_E_SQ_CONTAINS_SA;
            case 0x80041166: // The password is contained in the answer for the secret question.
                return HResult.XONLINE_E_SA_CONTAINS_PASSWORD;
            case 0x80041167: // The password is contained in the secret question.
                return HResult.XONLINE_E_SQ_CONTAINS_PASSWORD;
            case 0x8004117d: // The answer to the secret question contains that question.
                return HResult.XONLINE_E_SA_CONTAINS_SQ;
            case 0x8004117e: // The password validation code detected the answer to the secret question in the password.
                return HResult.XONLINE_E_PASSWORD_CONTAINS_SA;
            case 0x80041084: // The password has to be changed.
                return HResult.XONLINE_E_PASSPORT_FORCE_CHANGE_PASSWORD;
            case 0x8004341c: // The answer for the secret question contains the password.
                return HResult.XONLINE_E_SA_CONTAINS_PASSWORD;
            case 0x8004341d: // The answer for the secret question contained in the password.
                return HResult.XONLINE_E_PASSWORD_CONTAINS_SA;
            case 0x8004341e: // The secret question contains the password.
                return HResult.XONLINE_E_SQ_CONTAINS_PASSWORD;
            case 0x80045024: // Action not authorized. Unfortunatelly this is the error we get when an user tries to create a passport in a reserved domain (e.g. "hotmail.com") therefore we're translating it appropriatelly.
                return HResult.XONLINE_E_PASSPORT_INVALID_DOMAIN;
            case 0x80047856: // The account is blocked pending email address validation.
                return HResult.XONLINE_E_PASSPORT_REQUIRE_EMAIL_VALIDATION;
            case 0x80048104: // the data does not exist in database
                return HResult.XONLINE_E_PASSPORT_NO_DATA;
            case 0x80048105: // caller is not authorized
                return HResult.XONLINE_E_PASSPORT_SITE_NOT_AUTHORIZED;
            //case 0x8004810A: // Invalid NetID
            //case 0x80048173: // Secret anwser missing
            default:
                return HResult.XONLINE_E_PASSPORT_ERROR;
            }
        }

        protected void LoadPassportClientCertificate(string certSubject)
        {
            _clientCert = CertUtil.GetLocalMachineCertificate(certSubject);
        }

        protected string RetrievePartnerXmlFromPassport(string url, WebProxy proxy)
        {
            string partnerXml;
            Stream srep = null;
            HttpWebResponse httpRep = null;

            try
            {
                // Post
                HttpWebRequest httpReq = (HttpWebRequest) WebRequest.Create(url);
                httpReq.Proxy = proxy;
                httpReq.Method = "GET";
                httpReq.Timeout = GetPartnerCallTimeoutSeconds * 1000;

                // Get response
                httpRep = (HttpWebResponse) httpReq.GetResponse();
                srep = httpRep.GetResponseStream();
                byte[] binrep = (new BinaryReader(srep)).ReadBytes((int)httpRep.ContentLength);
                partnerXml = Encoding.UTF8.GetString(binrep);
            }
            finally
            {
                if(srep != null)
                    srep.Close();

                if(httpRep != null)
                    httpRep.Close();
            }

            return partnerXml;
        }

        protected void LoadPartnerXml(string partnerXml)
        {
            Hashtable newConfig = new Hashtable();
            string domainElementString = "/Partner/PassportNetwork/Domain";

            XmlDocument xml = new XmlDocument();
            xml.LoadXml(partnerXml);
            XmlNodeList domains = xml.SelectNodes(domainElementString);
            XmlNode urlNode;

            if (domains == null || domains.Count == 0)
            {
                throw new XRLException(
                    HResult.XONLINE_E_PASSPORT_INVALID_RESPONSE,
                    XEvent.Id.PASSPORT_INVALID_RESPONSE,
                    "Missing element {0}", domainElementString
                );
            }

            foreach(XmlNode domainNode in domains)
            {
                DomainConfig domainConfig = new DomainConfig();
                domainConfig.domainSuffix = domainNode.Attributes["DomainSuffix"].InnerText.ToLower();

                if((urlNode = domainNode.SelectSingleNode("EncryptedProxiedAuth")) == null)
                {
                    throw new XRLException(
                        HResult.XONLINE_E_PASSPORT_INVALID_RESPONSE,
                        XEvent.Id.PASSPORT_INVALID_RESPONSE,
                        "Missing element {0}/EncryptedProxiedAuth for domain {1}", domainElementString, domainConfig.domainSuffix
                    );
                }

                domainConfig.encryptedProxiedAuth = urlNode.InnerText;

                if((urlNode = domainNode.SelectSingleNode("ServiceAPIProfileServerPK")) == null)
                {
                    throw new XRLException(
                        HResult.XONLINE_E_PASSPORT_INVALID_RESPONSE,
                        XEvent.Id.PASSPORT_INVALID_RESPONSE,
                        "Missing element {0}/ServiceAPIProfileServerPK for domain {1}", domainElementString, domainConfig.domainSuffix
                    );
                }

                domainConfig.serviceAPIProfileServerPK = urlNode.InnerText;

                if((urlNode = domainNode.SelectSingleNode("ServiceAPICredentialServerPK")) == null)
                {
                    throw new XRLException(
                        HResult.XONLINE_E_PASSPORT_INVALID_RESPONSE,
                        XEvent.Id.PASSPORT_INVALID_RESPONSE,
                        "Missing element {0}/ServiceAPICredentialServerPK for domain {1}", domainElementString, domainConfig.domainSuffix
                    );
                }

                domainConfig.serviceAPICredentialServerPK = urlNode.InnerText;

                newConfig[domainConfig.domainSuffix] = domainConfig;
            }

            if (newConfig["default"] == null)
            {
                throw new XRLException(
                    HResult.XONLINE_E_PASSPORT_INVALID_RESPONSE,
                    XEvent.Id.PASSPORT_INVALID_RESPONSE,
                    "There is no 'default' domain"
                );
            }

            lock(this)
            {
                _domainConfig = newConfig;
            }
        }

        protected void LoadSecretQuestions(string[] arrSqXml)
        {
            Hashtable secretQuestions;
            XmlNodeList questionNodes;
            XmlNodeList localeNodes;
            XmlDocument xml;
            string question;
            ArrayList questionList;
            int questionIndex = 0;
            string secretQuestionsXml = string.Empty;
            string locale;

            //
            // Build hashtable with the questions. The key of the table is the
            // locale in lowercase. The value is an ArrayList with the
            // questions for that country/language.
            //

            secretQuestions = new Hashtable(30);

            for(int i=0; i < arrSqXml.Length; i++)
            {
                try
                {
                    // Parse Xml blob
                    secretQuestionsXml = arrSqXml[i];

                    xml = new XmlDocument();
                    xml.LoadXml(secretQuestionsXml);

                    localeNodes = xml.SelectNodes("/PassportSecretQuestions/Locale");

                    foreach(XmlNode localeNode in localeNodes)
                    {
                        locale = localeNode.Attributes["name"].InnerText.ToLower();
                        locale = locale.Replace("_", "-");

                        questionNodes = localeNode.SelectNodes("Question");

                        foreach(XmlNode questionNode in questionNodes)
                        {
                            question = questionNode.InnerText;

                            // Remove trailing spaces, LFs and CRs
                            question = question.Replace("\n", "");
                            question = question.Replace("\r", "");
                            question = question.Trim();

                            if (question.Length < XOn.XONLINE_PASSPORT_SECRET_QUESTION_MIN_LEN)
                            {
                                throw new XRLExceptionWithoutEvent(
                                    HResult.XONLINE_E_PASSPORT_SQ_TOO_SHORT,
                                    "Secret question must be at least {0} characters long\r\n, {1}",
                                    XOn.XONLINE_PASSPORT_SECRET_QUESTION_MIN_LEN, question
                                );
                            }

                            if (question.Length > XOn.XONLINE_PASSPORT_SECRET_QUESTION_MAX_LEN)
                            {
                                throw new XRLExceptionWithoutEvent(
                                    HResult.XONLINE_E_PASSPORT_SQ_TOO_LONG,
                                    "Secret question must be at most {0} characters long\r\n, {1}",
                                    XOn.XONLINE_PASSPORT_SECRET_QUESTION_MAX_LEN, question
                                );
                            }

                            // Retrieve the ArrayList with the questions for
                            // the locale so we can add one more question
                            questionList = (ArrayList) secretQuestions[locale];

                            if (questionList == null)
                            {
                                // This is the first question for the country/language pair.
                                // Create a new, empty array list and add it to the hash
                                // table
                                questionList = new ArrayList();
                                secretQuestions.Add(locale, questionList);
                            }

                            // Add question to question list
                            questionList.Add(question);

                            if (questionList.Count > XOn.XONLINE_PASSPORT_SECRET_QUESTION_MAX_COUNT)
                            {
                                throw new XRLExceptionWithoutEvent(
                                    HResult.XONLINE_E_PASSPORT_TOO_MANY_SECRET_QUESTIONS,
                                    "Too many secret questions, {0}", questionList.Count
                                );
                            }

                            questionIndex++;
                        }
                    }
                }

                catch(Exception e)
                {
                    // ExceptionWithHResults are all formatted and ready to go
                    // we only act  on  unexpected  runtime  exceptions
                    if ( e is ExceptionWithHResult )
                    {
                        throw;
                    }

                    throw new ExceptionWithEventId(XEvent.Id.COMMON_CONFIG_53, string.Format(
                        "An error occurred while parsing the Passport Secret "+
                        "Questions xml blob from the setting passport_SecretQuestionsXml. "+
                        "The index of the multisetting is {0}. "+
                        "The index of the message that was being processed is {1}. "+
                        "Xml: {2}",
                        i, questionIndex, secretQuestionsXml), e);
                }
            }

            // Convert arraylists to arrays
            _secretQuestions = new Hashtable(secretQuestions.Count);
            foreach(DictionaryEntry keyvalue in secretQuestions)
            {
                _secretQuestions[keyvalue.Key] =
                    ((ArrayList)keyvalue.Value).ToArray(typeof(string));
            }
        }

        public DomainConfig GetDomainConfig(string domainName)
        {
            domainName = domainName.Trim().ToLower();

            // if domain-name is in the form dude@domain.com, remove the dude@
            // and leave the 'domain.com'
            int atCharNdx = domainName.IndexOf('@');
            if(atCharNdx != -1)
                domainName = domainName.Substring(atCharNdx+1);

            DomainConfig domainConfig = (DomainConfig)_domainConfig[domainName];

            if(domainConfig == null)
                domainConfig = (DomainConfig)_domainConfig["default"];

            return domainConfig;
        }

        public static void LoadPublicKeyFromCertificate(byte[] rawcert, PassportClient pp)
        {
            byte[] bincert = null;
            byte[] encpubkey;
            byte[] cspImport;
            UInt32 cbCspImport;
            IntPtr certCtx = IntPtr.Zero;
            UInt32 cbData = 0;
            X509Certificate cert;
            byte[] shaPubKey = null;
            byte[] ski = null;

            // Maybe cert was encoded in base 64. Try to decode it first
            if(!DecodeBase64Cert(rawcert, out bincert))
            {
                // Failed to decode. Let's assume that rawcert is binary
                bincert = rawcert;
            }

            cert      = new X509Certificate(bincert);
            shaPubKey = new SHA1Managed().ComputeHash(cert.GetPublicKey());

            // Prepare to decode public key. Find out the size of the buffer
            encpubkey   = cert.GetPublicKey();
            cbCspImport = 0;
            if(WinApiCryptDecodeObject(X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
                RSA_CSP_PUBLICKEYBLOB, encpubkey, (UInt32) encpubkey.Length,
                0, null, ref cbCspImport) == 0)
            {
                throw new Exception(string.Format(
                    "WinApiCryptDecodeObject failed. Error = {0}",
                    Marshal.GetLastWin32Error()));
            }

            // Decode public key.
            cspImport = new byte[cbCspImport];
            if(WinApiCryptDecodeObject(X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
                RSA_CSP_PUBLICKEYBLOB, encpubkey, (UInt32) encpubkey.Length,
                0, cspImport, ref cbCspImport) == 0)
            {
                throw new Exception(string.Format(
                    "WinApiCryptDecodeObject failed. Error = {0}",
                    Marshal.GetLastWin32Error()));
            }

            ImportFromKeyBlob(cspImport, pp);

            // X509Certificate class doesn't expose the SKI. We'll have to go
            // through extra work for that
            try
            {
                // Open certificate
                certCtx = WinApiCertCreateCertificateContext(CRYPT_ASN_ENCODING,
                    bincert, (UInt32) bincert.Length);

                if(certCtx == IntPtr.Zero)
                {
                    throw new Exception(
                        "WinApiCertCreateCertificateContext failed, error = " +
                        Marshal.GetLastWin32Error().ToString());
                }

                // Get subject key identifier
                if(WinApiCertGetCertificateContextProperty(certCtx,
                    CERT_KEY_IDENTIFIER_PROP_ID, null, ref cbData) == 0)
                {
                    throw new Exception(
                        "WinApiCertGetCertificateContextProperty failed, error = " +
                        Marshal.GetLastWin32Error().ToString());
                }

                ski = new byte[cbData];
                if(WinApiCertGetCertificateContextProperty(certCtx,
                    CERT_KEY_IDENTIFIER_PROP_ID, ski, ref cbData) == 0)
                {
                    throw new Exception(
                        "WinApiCertGetCertificateContextProperty failed, error = " +
                        Marshal.GetLastWin32Error().ToString());
                }

                if (pp != null)
                {
                    pp._shaPubKey = shaPubKey;
                    pp._ski = ski;
                }
            }
            finally
            {
                if(certCtx != IntPtr.Zero)
                    WinApiCertFreeCertificateContext(certCtx);
                certCtx = IntPtr.Zero;
            }
        }

        protected static void ImportFromKeyBlob(byte[] cspImport, PassportClient pp)
        {
            UInt32 alg;
            UInt32 bitlen;
            UInt32 pubexp = 0;
            byte[] modulus = null;

            // Extract the modulus and the public exponent
            using (BinaryReader br = new BinaryReader(new MemoryStream(cspImport)))
            {
                if( br.ReadByte() != PUBLICKEYBLOB || br.ReadByte() != CUR_BLOB_VERSION)
                {
                    throw new Exception("Failed to parse public-key-blob. Invalid header.");
                }

                br.ReadUInt16(); // Reserved

                alg = br.ReadUInt32();
                if (alg != CALG_RSA_SIGN && alg != CALG_RSA_KEYX)
                {
                    throw new Exception("Failed to parse public-key-blob. Invalid algorithm.");
                }

                if (br.ReadUInt32() != 0x31415352)
                {
                    throw new Exception("Failed to parse public-key-blob. Key is not public key.");
                }

                bitlen = br.ReadUInt32();
                if (bitlen == 0 || bitlen > 2048)
                {
                    throw new Exception("Failed to parse public-key-blob. Invalid key lenght.");
                }

                // And finally:
                pubexp  = br.ReadUInt32();
                modulus = br.ReadBytes(Convert.ToInt32(bitlen) / 8);

                if (pp != null)
                {
                    pp._pubexp = pubexp;
                    pp._modulus = modulus;
                }
            }
        }

        static public string ByteArrayToString(byte[] bin)
        {
            StringBuilder str = new StringBuilder(bin.Length * 2 + 1);
            for(int i=0; i < bin.Length; i++)
            {
                str.Append(bin[i].ToString("x2"));
            }

            return str.ToString();
        }

        static protected byte[] EncryptWith3Des(byte[] key, byte[] iv, byte[] data)
        {
            TripleDESCryptoServiceProvider tdes = new TripleDESCryptoServiceProvider();
            MemoryStream ms = new MemoryStream(1024);
            CryptoStream cs = new CryptoStream(ms, tdes.CreateEncryptor(key, iv), CryptoStreamMode.Write);
            cs.Write(data, 0, data.Length);
            cs.Close();
            return ms.ToArray();
        }

        protected byte[] EncryptWithPassportPublicKey(byte[] data)
        {
            // Managed RSA provider expects key data in big endian order
            byte[] rmodulus = DuplicateAndReverse(_modulus);
            byte[] rpubexp  = new byte[] {
                (byte) ((_pubexp & 0xFF000000)>>24),
                (byte) ((_pubexp & 0xFF0000)>>16),
                (byte) ((_pubexp & 0xFF00)>>8),
                (byte) (_pubexp & 0xFF)
            };

            // Load up key
            using (RSACryptoServiceProvider rsa = new RSACryptoServiceProvider())
            {
                RSAParameters keyInfo = new RSAParameters();
                keyInfo.Modulus  = rmodulus;
                keyInfo.Exponent = rpubexp;
                rsa.ImportParameters(keyInfo);

                // Calculate the max size of message bytes that can be encrypted
                // in one block of cipher text and the number of blocks necessary
                // to encrypt the whole thing
                int msgblocksize  = _modulus.Length - 2 - 2 * 20;
                int blockcount    = (data.Length / msgblocksize) + ((data.Length % msgblocksize) != 0 ? 1 : 0);

                // Encrypt
                using (MemoryStream ciphertext = new MemoryStream(blockcount * _modulus.Length))
                {
                    byte[] msgblock = new byte[msgblocksize];
                    int dataleft = data.Length;
                    for(int i=0; i < blockcount; i++)
                    {
                        int size = Math.Min(dataleft, msgblocksize);
                        if(size != msgblock.Length)
                            msgblock = new byte[size];

                        Buffer.BlockCopy(data, i * msgblocksize, msgblock, 0, size);
                        byte[] cipherblock = rsa.Encrypt(msgblock, true);
                        Array.Reverse(cipherblock);
                        ciphertext.Write(cipherblock, 0, cipherblock.Length);
                        dataleft -= size;
                    }

                    return ciphertext.ToArray();
                }
            }
        }

        // Copy buffer and reverse it at the same time
        protected byte[] DuplicateAndReverse(byte[] bin)
        {
            byte[] rdup = new byte[bin.Length];

            int rduplength = rdup.Length;
            for(int i=0; i < bin.Length; i++)
            {
                rdup[rduplength - i - 1] = bin[i];
            }

            return rdup;
        }

        // Decode certificate encoded with base64
        protected static bool DecodeBase64Cert(byte[] base64cert, out byte[] bincert)
        {
            const string begincert   = "-----BEGIN CERTIFICATE-----";
            const string endcert     = "-----END CERTIFICATE-----";
            string strCert = Encoding.ASCII.GetString(base64cert);
            bincert = null;

            // Find Header
            int iPosBeginCert = strCert.IndexOf(begincert);
            if(iPosBeginCert == -1)
                return false;
            iPosBeginCert += begincert.Length;

            // Find footer
            int iPosEndCert = strCert.IndexOf(endcert, iPosBeginCert);
            if(iPosEndCert == -1)
                return false;

            int iSize = iPosEndCert - iPosBeginCert;
            if(iSize <= 0)
                return false;

            // Convert
            try
            {
                bincert = Convert.FromBase64CharArray(strCert.ToCharArray(), iPosBeginCert, iSize);
            }
            catch(FormatException)
            {
                return false;
            }

            return true;
        }

        protected enum APIResultEnum
        {
            Success,
            FailFast,
            Failed,
            Timeout
        }

        protected static void LogApiCall(string apiName, APIResultEnum result, long millisecondsElapsed, string [] inParams, string [] outParams, string xmlReply, string ppErrorDetails)
        {
            string resultString;
            switch (result)
            {
                case APIResultEnum.Success:
                    resultString = "Success";
                    break;

                case APIResultEnum.FailFast:
                    resultString = "FailFast";
                    break;

                case APIResultEnum.Failed:
                    resultString = "Failed";
                    break;

                case APIResultEnum.Timeout:
                    resultString = "Timeout";
                    break;

                default:
                    resultString = "Unknown";
                    break;
            }

            string outParamsString;
            if (result == APIResultEnum.Success)
            {
                if (outParams == null)
                    outParamsString = "";
                else
                    outParamsString = string.Join("|", outParams);
            }
            else
            {
                outParamsString = "Failed";
            }

            string logText = string.Join("|", new string []
            {
                apiName,
                resultString,
                millisecondsElapsed.ToString(),
                string.Join("|", inParams),
                outParamsString,
                xmlReply,
                ppErrorDetails ?? ""
            });

            Xom.Log(XomAreaName.passportLog, logText);
        }

        protected static string PrettyPrintXml(string xmlText)
        {
            try
            {
                return XmlUtil.PrettyPrint(xmlText);
            }
            catch (XmlException)
            {
                // in case of invalid XML returned by Passport... this almost never happens
                return xmlText;
            }
        }

        [DllImport("crypt32.dll",  EntryPoint="CryptDecodeObject",
            ExactSpelling=true, SetLastError=true,
            CallingConvention=CallingConvention.StdCall)]
        protected static extern int WinApiCryptDecodeObject(
            UInt32 dwCertEncodingType,
            UInt32 structType,
            byte[] pbEncoded,
            UInt32 cbEncoded,
            UInt32 dwFlags,
            byte[] pvStructInfo,
            ref UInt32 pcbStructInfo);

        [DllImport("crypt32.dll", EntryPoint="CertCreateCertificateContext",
            SetLastError=true, ExactSpelling=true,
            CallingConvention=CallingConvention.StdCall)]
        protected static extern IntPtr WinApiCertCreateCertificateContext(
            UInt32 dwCertEncodingType,
            byte[] pbCertEncoded,
            UInt32 cbCertEncoded);

        [DllImport("crypt32.dll", EntryPoint="CertGetCertificateContextProperty",
            SetLastError=true, ExactSpelling=true,
            CallingConvention=CallingConvention.StdCall)]
        protected static extern UInt32 WinApiCertGetCertificateContextProperty(
            IntPtr pCertContext,
            UInt32 dwPropId,
            byte[] pvData,
            ref UInt32 pcbData);

        [DllImport("crypt32.dll", EntryPoint="CertFreeCertificateContext",
            SetLastError=true, ExactSpelling=true,
            CallingConvention=CallingConvention.StdCall)]
        protected static extern UInt32 WinApiCertFreeCertificateContext(
            IntPtr pCertContext);

        [DllImport("crypt32.dll", EntryPoint="CertOpenStore",
            SetLastError=true, ExactSpelling=true, CharSet=CharSet.Unicode,
            CallingConvention=CallingConvention.StdCall)]
        protected static extern IntPtr WinApiCertOpenStore(
            UInt32 storeProvider,
            UInt32 dwMsgAndCertEncodingType,
            IntPtr hCryptProv,
            UInt32 dwFlags,
            string pvPara);

        [DllImport("crypt32.dll", EntryPoint="CertFindCertificateInStore",
            SetLastError=true, ExactSpelling=true, CharSet=CharSet.Unicode,
            CallingConvention=CallingConvention.StdCall)]
        protected static extern IntPtr WinApiCertFindCertificateInStore(
          IntPtr hCertStore,
          UInt32 dwCertEncodingType,
          UInt32 dwFindFlags,
          UInt32 dwFindType,
          string pvFindPara,
          IntPtr pPrevCertContext);

        [DllImport("crypt32.dll", EntryPoint="CertCloseStore",
            SetLastError=true, ExactSpelling=true,
            CallingConvention=CallingConvention.StdCall)]
        protected static extern UInt32 WinApiCertCloseStore(
            IntPtr hCertStore,
            UInt32 dwFlags);

        protected const UInt32 CRYPT_ASN_ENCODING       = 0x00000001;
        protected const UInt32 CERT_KEY_IDENTIFIER_PROP_ID = 20;
        protected const UInt32 RSA_CSP_PUBLICKEYBLOB    = 19;
        protected const UInt32 X509_ASN_ENCODING        = 0x00000001;
        protected const UInt32 PKCS_7_ASN_ENCODING      = 0x00010000;
        protected const byte   PUBLICKEYBLOB            = 0x6;
        protected const byte   CUR_BLOB_VERSION         = 2;
        protected const UInt32 ALG_CLASS_SIGNATURE      = (1 << 13);
        protected const UInt32 ALG_CLASS_KEY_EXCHANGE   = (5 << 13);
        protected const UInt32 ALG_TYPE_RSA             = (2 << 9);
        protected const UInt32 ALG_SID_RSA_ANY          = 0;
        protected const UInt32 CALG_RSA_SIGN            = (ALG_CLASS_SIGNATURE | ALG_TYPE_RSA | ALG_SID_RSA_ANY);
        protected const UInt32 CALG_RSA_KEYX            = (ALG_CLASS_KEY_EXCHANGE|ALG_TYPE_RSA|ALG_SID_RSA_ANY);
        protected const UInt32 CERT_STORE_PROV_SYSTEM_W = 10;
        protected const Int32  CERT_SYSTEM_STORE_LOCATION_SHIFT =16;
        protected const UInt32 CERT_SYSTEM_STORE_CURRENT_USER_ID = 1;
        protected const UInt32 CERT_SYSTEM_STORE_LOCAL_MACHINE_ID = 2;
        protected const UInt32 CERT_SYSTEM_STORE_LOCAL_MACHINE = (CERT_SYSTEM_STORE_LOCAL_MACHINE_ID << CERT_SYSTEM_STORE_LOCATION_SHIFT);
        protected const UInt32 CERT_SYSTEM_STORE_CURRENT_USER = (CERT_SYSTEM_STORE_CURRENT_USER_ID << CERT_SYSTEM_STORE_LOCATION_SHIFT);
        protected const UInt32 CERT_COMPARE_NAME_STR_W  = 8;
        protected const Int32  CERT_COMPARE_SHIFT       = 16;
        protected const UInt32 CERT_INFO_SUBJECT_FLAG   = 7;
        protected const UInt32 CERT_FIND_SUBJECT_STR_W  = (CERT_COMPARE_NAME_STR_W << CERT_COMPARE_SHIFT | CERT_INFO_SUBJECT_FLAG);
        protected const UInt32 CERT_CLOSE_STORE_FORCE_FLAG = 0x00000001;
        protected const UInt32 CERT_CLOSE_STORE_CHECK_FLAG = 0x00000002;
        protected const UInt32 CERT_STORE_READONLY_FLAG = 0x00008000;

        protected const string _passportLoginReq =
            "<?xml version=\"1.0\" encoding=\"utf-8\"?>"+
            "<S:Envelope xmlns:S=\"http://schemas.xmlsoap.org/soap/envelope/\" xmlns:wsse=\"http://schemas.xmlsoap.org/ws/2003/06/secext\" xmlns:ds=\"http://www.w3.org/2000/09/xmldsig#\" xmlns:wssc=\"http://schemas.xmlsoap.org/ws/2004/04/sc\" xmlns:ps=\"http://schemas.microsoft.com/Passport/SoapServices/EncProxyV1\">"+
            "  <S:Header>"+
            "    <wsse:Security>"+
            "      <EncryptedKey xmlns=\"http://www.w3.org/2001/04/xmlenc#\" Id=\"SessionKey\" Type=\"http://www.w3.org/2001/04/xmlenc#Element\">"+
            "        <EncryptionMethod Algorithm=\"http://www.w3.org/2001/04/xmlenc#rsa-oaep-mgf1p\" />"+
            "        <ds:KeyInfo>"+
            "          <ds:KeyName>Microsoft Passport SAPI</ds:KeyName>"+
            "          <ds:X509SKI type=\"hexBinary\">{0}</ds:X509SKI>"+
            "        </ds:KeyInfo>"+
            "        <CipherData>"+
            "          <CipherValue>{1}</CipherValue>"+
            "        </CipherData>"+
            "        <ReferenceList>"+
            "          <DataReference URI=\"#pw\" />"+
            "          <DataReference URI=\"#rst\" />"+
            "        </ReferenceList>"+
            "      </EncryptedKey>"+
            "      <wsse:UsernameToken Id=\"user\">"+
            "        <wsse:Username>{2}</wsse:Username>"+
            "        <wsse:Password>"+
            "          <EncryptedData xmlns=\"http://www.w3.org/2001/04/xmlenc#\" Type=\"http://www.w3.org/2001/04/xmlenc#Content\" Id=\"pw\">"+
            "            <EncryptionMethod Algorithm=\"http://www.w3.org/2001/04/xmlenc#tripledes-cbc\" />"+
            "            <CipherData>"+
            "              <CipherValue>{3}</CipherValue>"+
            "            </CipherData>"+
            "          </EncryptedData>"+
            "        </wsse:Password>"+
            "      </wsse:UsernameToken>"+
            "    </wsse:Security>"+
            "  </S:Header>"+
            "  <S:Body>"+
            "    <ps:RequestMultipleSecurityTokens>"+
            "      <EncryptedData xmlns=\"http://www.w3.org/2001/04/xmlenc#\" Type=\"http://www.w3.org/2001/04/xmlenc#Element\" Id=\"rst\">"+
            "        <EncryptionMethod Algorithm=\"http://www.w3.org/2001/04/xmlenc#tripledes-cbc\" />"+
            "        <CipherData>"+
            "          <CipherValue>{4}</CipherValue>"+
            "        </CipherData>"+
            "      </EncryptedData>"+
            "    </ps:RequestMultipleSecurityTokens>"+
            "  </S:Body>"+
            "</S:Envelope>";

        protected string _loginTokenRequestTemplate =
            "<ps:EncryptedRequest"+
            "    xmlns:ps='http://schemas.microsoft.com/Passport/SoapServices/EncProxyV1'"+
            "    xmlns:wst='http://schemas.xmlsoap.org/ws/2004/04/trust'"+
            "    xmlns:wsp='http://schemas.xmlsoap.org/ws/2002/12/policy'"+
            "    xmlns:wsa='http://schemas.xmlsoap.org/ws/2004/03/addressing'"+
            "    xmlns:wsse='http://schemas.xmlsoap.org/ws/2003/06/secext'>"+
            "    <wst:RequestSecurityToken>"+
            "        <wst:RequestType>"+
            "            http://schemas.xmlsoap.org/ws/2004/04/security/trust/Issue"+
            "        </wst:RequestType>"+
            "        <wsp:AppliesTo>"+
            "            <wsa:EndpointReference>"+
            "                <wsa:Address>{0}</wsa:Address>"+
            "            </wsa:EndpointReference>"+
            "        </wsp:AppliesTo>"+
            "        <wsse:PolicyReference URI='{1}'/>"+
            "    </wst:RequestSecurityToken>"+
            "</ps:EncryptedRequest>";

        protected static string _ppSoapHeader25Template =
                " <s:ppSoapHeader xmlns:s=\"http://schemas.microsoft.com/Passport/SoapServices/SoapHeader\" version=\"1.0\"> \n"+
                "   <s:lcid>1033</s:lcid> \n"+
                "   <s:authorizationLicence> \n"+
                "   </s:authorizationLicence> \n"+
                "   <s:auditInfo></s:auditInfo> \n"+
                "   <s:sitetoken> \n"+
                "     <t:siteheader xmlns:t=\"http://schemas.microsoft.com/Passport/SiteToken\" id=\"{0}\"/> \n"+
                "   </s:sitetoken> \n"+
                " </s:ppSoapHeader> \n";

        protected static string _userDataTemplate =
                "<p:userData xmlns:p=\"http://schemas.microsoft.com/Passport/User\"> \n"+
                "    <p:credential type=\"Web\"> \n"+
                "        <p:property name=\"Name\">{0}</p:property> \n"+
                "        <p:property name=\"SecretQuestion\">{1}</p:property> \n"+
                "        <p:property name=\"FCPTemporaryPassword\">FALSE</p:property> \n"+
                "        <p:EncryptedProperties> \n"+
                "            <p:x509SKI type=\"hexBinary\">{2}</p:x509SKI> \n"+
                "            <p:CipherValue>{3}</p:CipherValue> \n"+
                "            <p:Version>1</p:Version> \n"+
                "        </p:EncryptedProperties> \n"+
                "    </p:credential> \n"+
                "    <p:profile> \n"+
                "        <p:propertyCollection name=\"Authorization_CS\"> \n"+
                "            <p:property name=\"WinLiveTOUVersion\">-1</p:property> \n"+
                "        </p:propertyCollection> \n"+
                "    </p:profile> \n"+
                "    <p:creationdirectives> \n" +
                "        <p:property name=\"NeedsSLT\">true</p:property> \n" +
                "    </p:creationdirectives> \n" +
                "</p:userData> \n";

        protected static string _userDataCreatePassportTemplate =
                "<p:userData xmlns:p=\"http://schemas.microsoft.com/Passport/User\"> \n"+
                "    <p:credential type=\"Web\"> \n"+
                "        <p:property name=\"Name\">{0}</p:property> \n"+
                "        <p:property name=\"SecretQuestion\">{1}</p:property> \n"+
                "        <p:property name=\"FCPTemporaryPassword\">FALSE</p:property> \n"+
                "        <p:EncryptedProperties> \n" +
                "            <p:x509SKI type=\"hexBinary\">{2}</p:x509SKI> \n"+
                "            <p:CipherValue>{3}</p:CipherValue> \n"+
                "            <p:Version>1</p:Version> \n"+
                "        </p:EncryptedProperties> \n"+
                "    </p:credential> \n"+
                "    <p:profile> \n"+
                "        <p:propertyCollection name=\"Addresses_CS\"> \n"+
                "            <p:property name=\"Home.Country\">{4}</p:property> \n"+
                "        </p:propertyCollection> \n"+
                "        <p:propertyCollection name=\"Authorization_CS\"> \n"+
                "            <p:property name=\"WinLiveTOUVersion\">-1</p:property> \n"+
                "        </p:propertyCollection> \n"+
                "        <p:propertyCollection name=\"Personal_CS\"> \n"+
                "            <p:property name=\"Birthdate\">{5}</p:property> \n"+
                "            <p:property name=\"LangPreference\">{6}</p:property> \n"+
                "        </p:propertyCollection> \n"+
                "    </p:profile> \n"+
                "    <p:creationdirectives> \n" +
                "        <p:property name=\"NeedsSLT\">true</p:property> \n" +
                "    </p:creationdirectives> \n" +
                "{7}" +
                "</p:userData> \n";

        protected static string _userDataCreatePassportManagedDomainTemplate =
                "<p:userData xmlns:p=\"http://schemas.microsoft.com/Passport/User\"> \n"+
                "    <p:credential type=\"Web\"> \n"+
                "        <p:property name=\"Name\">{0}</p:property> \n"+
                "        <p:property name=\"FCPTemporaryPassword\">FALSE</p:property> \n"+
                "        <p:EncryptedProperties> \n" +
                "            <p:x509SKI type=\"hexBinary\">{1}</p:x509SKI> \n"+
                "            <p:CipherValue>{2}</p:CipherValue> \n"+
                "            <p:Version>1</p:Version> \n"+
                "        </p:EncryptedProperties> \n"+
                "    </p:credential> \n"+
                "    <p:profile> \n"+
                "        <p:propertyCollection name=\"Addresses_CS\"> \n"+
                "            <p:property name=\"Home.Country\">{3}</p:property> \n"+
                "        </p:propertyCollection> \n"+
                "        <p:propertyCollection name=\"Authorization_CS\"> \n"+
                "            <p:property name=\"WinLiveTOUVersion\">-1</p:property> \n"+
                "        </p:propertyCollection> \n"+
                "        <p:propertyCollection name=\"Personal_CS\"> \n"+
                "            <p:property name=\"Birthdate\">{4}</p:property> \n"+
                "            <p:property name=\"LangPreference\">{5}</p:property> \n"+
                "        </p:propertyCollection> \n"+
                "    </p:profile> \n"+
                "    <p:creationdirectives> \n" +
                "        <p:property name=\"NeedsSLT\">true</p:property> \n" +
                "    </p:creationdirectives> \n" +
                "{6}" +
                "</p:userData> \n";

        protected static string _userDataCreatePassportManagedDomainTemplate2 =
                "<p:userData xmlns:p=\"http://schemas.microsoft.com/Passport/User\"> \n"+
                "    <p:credential type=\"Web\"> \n"+
                "        <p:property name=\"Name\">{0}</p:property> \n"+
                "        <p:property name=\"FCPTemporaryPassword\">FALSE</p:property> \n"+
                "        <p:EncryptedProperties> \n" +
                "            <p:x509SKI type=\"hexBinary\">{1}</p:x509SKI> \n"+
                "            <p:CipherValue>{2}</p:CipherValue> \n"+
                "            <p:Version>1</p:Version> \n"+
                "        </p:EncryptedProperties> \n"+
                "    </p:credential> \n"+
                "    <p:profile> \n"+
                "        <p:propertyCollection name=\"Addresses_CS\"> \n"+
                "            <p:property name=\"Home.Country\">{3}</p:property> \n"+
                "        </p:propertyCollection> \n"+
                "        <p:propertyCollection name=\"Authorization_CS\"> \n"+
                "            <p:property name=\"WinLiveTOUVersion\">-1</p:property> \n"+
                "        </p:propertyCollection> \n"+
                "        <p:propertyCollection name=\"Personal_CS\"> \n"+
                "            <p:property name=\"Birthdate\">{4}</p:property> \n"+
                "            <p:property name=\"LangPreference\">{5}</p:property> \n"+
                "        </p:propertyCollection> \n"+
                "    </p:profile> \n"+
                "    <p:creationdirectives> \n" +
                "        <p:property name=\"NeedsSLT\">true</p:property> \n" +
                "    </p:creationdirectives> \n" +
                "{6}" +
                "</p:userData> \n";

        protected static string _userDataWithNetIdTemplate =
                "<p:userData xmlns:p=\"http://schemas.microsoft.com/Passport/User\"> \n"+
                "    <p:credential type=\"Web\"> \n"+
                "        <p:property name=\"NetID\">{0}</p:property> \n"+
                "        <p:EncryptedProperties> \n"+
                "            <p:x509SKI type=\"hexBinary\">{1}</p:x509SKI> \n"+
                "            <p:CipherValue>{2}</p:CipherValue> \n"+
                "            <p:Version>1</p:Version> \n"+
                "        </p:EncryptedProperties> \n"+
                "    </p:credential> \n"+
                "</p:userData> \n";

        protected static string _userDataSingleNonEncryptedProperty =
                "<p:userData xmlns:p=\"http://schemas.microsoft.com/Passport/User\"> \n" +
                "    <p:credential type=\"Web\"> \n" +
                "        <p:property name=\"NetID\">{0}</p:property> \n" +
                "        <p:property name=\"{1}\">{2}</p:property> \n" +
                "    </p:credential> \n" +
                "</p:userData> \n";

        protected static string _proofDataTemplate =
                "<Proof type=\"{0}\">" +
                "<Property name=\"ID\">{1}</Property>" +
                "</Proof>";

        protected static string _oneTimeTokenTemplate =
                "<OneTimeToken xmlns=\"http://schemas.microsoft.com/Passport/User\">" +
                    "<Purpose>eProofPurpose_ResetPassword</Purpose>" +
                    "<Template>MobileResetPasswordCode75</Template>" +
                    "<Channel>{0}</Channel>" +
                    "<Destination>{1}</Destination>" +
                    "<Market>{2}</Market>" +
                "</OneTimeToken>";

        public class DomainConfig
        {
            public string domainSuffix;
            public string encryptedProxiedAuth;
            public string serviceAPIProfileServerPK;
            public string serviceAPICredentialServerPK;
        }

        protected class SecretQuestionKey
        {
            public ushort countryId;
            public ushort languageId;

            public override int GetHashCode()
            {
                return (((int)countryId) << 16) | languageId;
            }

            public override bool Equals(object o)
            {
                SecretQuestionKey otherKey = (SecretQuestionKey) o;

                return (this.countryId == otherKey.countryId) &&
                       (this.languageId == otherKey.languageId);
            }
        }

        public static int GetPartnerCallTimeoutSeconds
        {
            get
            {
                return Config.GetIntSetting(Setting.passport_partnerCallTimeoutSeconds);
            }
        }

        protected void SetWebProxy(string proxyUrl)
        {
            if ( string.IsNullOrEmpty(proxyUrl) )
            {
                _proxy = new WebProxy();
            }
            else
            {
                _proxy = new WebProxy(proxyUrl, true);
            }
        }

        protected byte[] _shaPubKey = null;
        protected UInt32 _pubexp    = 0;            // Passport public key's public exponent
        protected byte[] _modulus   = null;         // Passport public key's modulus
        protected byte[] _ski       = null;
        protected X509Certificate _clientCert = null;
        protected string _siteId    = null;
        protected string[] _siteAddresses = null;
        protected Hashtable _domainConfig = null;
        protected string[] _loginTokenRequests = null;
        protected Hashtable _secretQuestions = null;
        protected WebProxy _proxy = null;
    }

    // FakePassportClient
    // Simple fake. Just enought to unblock us while passport is down
    public class FakePassportClient : PassportClientBase
    {
        private Dictionary<ulong, bool> _noAgeOut = new Dictionary<ulong, bool>();

        public override UInt32 PublicKeyPublicExponent
        {
            get
            {
                return 3;
            }
        }

        public override byte[] PublicKeyModulus
        {
            get
            {
                return new byte[] {
                    0x39,0x3C,0xFD,0x6A,0xE4,0x76,0x73,0x96,
                    0xB5,0x96,0x2B,0xC3,0xE6,0x2D,0xAD,0x58,
                    0xC8,0xE2,0x7E,0x83,0x49,0xDC,0x05,0x97,
                    0x2A,0x2D,0x91,0xD2,0x0D,0xD7,0x45,0xCC,
                    0x19,0xA4,0xC3,0x5C,0x4E,0xEE,0x6C,0xDD,
                    0x4C,0xE9,0xF6,0x0A,0xA4,0xE0,0xC8,0xA7,
                    0x60,0x71,0x0D,0xBB,0x1D,0xA7,0xBC,0xCE,
                    0x5B,0x77,0x96,0xA5,0x26,0x96,0xA5,0x5E,
                    0x66,0xDE,0xEF,0x93,0x1F,0x3C,0x12,0x1F,
                    0x93,0xCB,0xB3,0xBD,0x6C,0x38,0x6C,0xF0,
                    0x84,0xE9,0x90,0xFB,0x78,0x76,0xAB,0xAC,
                    0xA2,0x37,0xCE,0x10,0x8B,0x7A,0x50,0x16,
                    0x86,0xAA,0x31,0xDE,0x06,0x22,0xA6,0x21,
                    0x77,0x3E,0x1C,0x50,0x56,0x54,0x45,0xD0,
                    0x51,0x45,0xD8,0x7B,0xC8,0xA7,0xDF,0xF1,
                    0xF9,0x8F,0x39,0x9D,0x8A,0x32,0x00,0xCA };
            }
        }

        public override byte[] PublicKeyDigest
        {
            get
            {
                return new byte[] {
                    0x00,0x01,0x02,0x03,0x04,0x05,0x06,0x07,
                    0x08,0x09,0x0a,0x0b,0x0c,0x0d,0x0e,0x0f,
                    0x10,0x11,0x12,0x13};
            }
        }

        public override string LoginTokenRequest
        {
            get
            {
                return "Login-token-Request";
            }
        }

        public override string GetLoginTokenRequest(int serviceId)
        {
            return LoginTokenRequest;
        }

        public override ProofStatus AddProof(
            ulong puid,
            string proofType,
            string proofData)
        {
            return new ProofStatus { isConfirmed = false, proofData = proofData, proofType = proofType };
        }

        public override void CreatePassport(
            string passportMemberName,
            string secretQuestion,
            byte[] encPassword,
            ProofData extraProof,
            string countryCode,
            DateTime birthdate,
            out UInt64 puid)
        {
            string SLT;
            CreatePassport(
                passportMemberName,
                secretQuestion,
                encPassword,
                extraProof,
                string.Empty, // alternateEmail
                null, // strSKI
                countryCode,
                birthdate,
                out puid,
                out SLT
                );
        }

        public override void CreatePassport(
            string passportMemberName,
            byte[] encPassword,
            string alternateEmail,
            string countryCode,
            DateTime birthdate,
            out UInt64 puid
            )
        {
            string SLT;
            CreatePassport(
                passportMemberName,
                null,
                encPassword,
                null,
                alternateEmail,
                null, // strSKI
                countryCode,
                birthdate,
                out puid,
                out SLT
                );
        }

        void CreatePassport(
            string passportMemberName,
            string secretQuestion,
            byte[] encPassword,
            ProofData extraProof,
            string alternateEmail,
            string strSKI,
            string countryCode,
            DateTime birthdate,
            out UInt64 puid,
            out string SLT
            )
        {
            RandomNumberGenerator rand = RandomNumberGenerator.Create();
            byte[] binpuid = new byte[8];
            rand.GetBytes(binpuid);
            puid = BitConverter.ToUInt64(binpuid, 0);
            SLT = "didyousayslt?";
        }

        public override void ChangePassword(UInt64 puid, string passportMemberName, byte[] encPassword)
        {
        }

        public override ProofStatus[] GetProofsState(ulong puid)
        {
            return new ProofStatus[0];
        }

        public override void Login(string pname, byte[] encSesKey, byte[] encPassw, byte[] encReq, out UInt64 puid)
        {
            Login(pname, XOn.XONLINE_PASSPORT_LOGIN_LEGACY_SERVICE_ID, encSesKey, encPassw, encReq, out puid);
        }

        public override void Login(string pname, int serviceId, byte[] encSesKey, byte[] encPassw, byte[] encReq, out UInt64 puid)
        {
            byte[] nonce = null;
            byte[] cipherValue = null;
            Login(pname, serviceId, encSesKey, encPassw, encReq, out puid, out nonce, out cipherValue);
        }

        public override void Login(string pname, int serviceId, byte[] encSesKey, byte[] encPassw, byte[] encReq, out UInt64 puid, out byte[] nonce, out byte[] cipherValue)
        {
            string strpuid = pname.Split(new char[] {'@'})[0];
            puid = Convert.ToUInt64(strpuid, 16);
            nonce = new byte[XOn.XONLINE_PASSPORT_LOGIN_NONCE_MAX_LEN];
            cipherValue = new byte[XOn.XONLINE_PASSPORT_LOGIN_CIPHER_VALUE_MAX_LEN];
            nonce[0] = nonce[XOn.XONLINE_PASSPORT_LOGIN_NONCE_MAX_LEN - 1] = 0xf;
            cipherValue[0] = cipherValue[XOn.XONLINE_PASSPORT_LOGIN_CIPHER_VALUE_MAX_LEN - 1] = 0xf;
        }

        public override string[] GetSecretQuestionList(string locale)
        {
            return new string[] {
                "Where do we come from?",
                "Where are we going?",
                "What's the meaning of life?",
                "Do you like pudding?"
            };
        }

        public override WLIDStatus ValidateWLID(ulong passportPuid)
        {
            // When we want to force a user through the invalid owner flow, such as when the previous owner
            // explicitly removed a dependent using RemoveDependent, we set the OwnerPassportPuid to a well-known
            // invalid value. In this case, force the result to Invalid.
            if (passportPuid == XOn.XONLINE_PASSPORT_INVALID_ID)
            {
                return WLIDStatus.Invalid;
            }

            return WLIDStatus.Valid;
        }

        internal override string GetPassportMemberName(ulong puid)
        {
            return string.Format("{0}@xboxtest.com", puid.ToString("X016"));
        }

        internal override string GetPassportMemberNameAndCID(ulong puid, out string cid)
        {
            cid = "DEADBEEF1337CAFE";
            // !!! NEED TO FIX !!!
            return string.Format("{0}@xboxtest.com", puid.ToString("X016"));
        }

        public override List<PassportMemberNameCredentials> EnumCredentialsByName(string passportMemberName)
        {
            return new List<PassportMemberNameCredentials>();
        }

        public override UInt64 GetPassportPuid(string passportMemberName)
        {
            return 0x0;
        }

        public override void GetProfile(ulong puid, string attributes, out string profileXml)
        {
            // !!! NEED TO FIX !!!
            profileXml = "CHANGEME";
        }

        public override void UpdateProfile(string profileXml)
        {
        }

        public override void DeleteCredential(Puid puid)
        {
        }

        public override void ForceCredentialRename(Puid puid)
        {
        }

        public override void SetNoAgeOut(ulong puid, bool value)
        {
            if (_noAgeOut.ContainsKey(puid)) _noAgeOut.Remove(puid);
            _noAgeOut.Add(puid, value);
        }

        public override bool GetNoAgeOut(ulong puid)
        {
            bool value;

            if (_noAgeOut.TryGetValue(puid, out value)) return value;
            return false;
        }

        public override byte[] GenerateEncryptedCredentials(
            string oldPassword,
            string newPassword,
            string secretAnswer
        ) {
            byte[] binOldPassword = Encoding.ASCII.GetBytes(oldPassword);
            byte[] binPassword = Encoding.ASCII.GetBytes(newPassword);
            byte[] binSecretAnswer = Encoding.Unicode.GetBytes(secretAnswer);
            byte[] credentials;

            using (BinaryWriter bw = new BinaryWriter(new MemoryStream(200)))
            {
                bw.Write((byte) 1); // Version of the encryption scheme
                bw.Write((byte) 1); // Version of the format of the plaintext string
                bw.Write((byte) binPassword.Length); // Size of password in bytes
                bw.Write(binPassword); // Password in ascii
                bw.Write((byte) binSecretAnswer.Length); // Size of secret-answer in bytes
                bw.Write(binSecretAnswer); // secret-answer in unicode
                bw.Write((byte) binOldPassword.Length); // Size of old-password.
                bw.Write(binOldPassword); // old-password in ascii

                credentials = ((MemoryStream) bw.BaseStream).ToArray();
            }

            return EncryptWithPassportPublicKey(credentials);
        }

        public void TestGenerateEncryptedCredentials(
            string oldPassword,
            string newPassword,
            string secretAnswer,
            out byte[] encryptedCredentials
        )
        {
            encryptedCredentials = GenerateEncryptedCredentials(oldPassword, newPassword, secretAnswer);
        }

        static protected byte[] EncryptWith3Des(byte[] key, byte[] iv, byte[] data)
        {
            TripleDESCryptoServiceProvider tdes = new TripleDESCryptoServiceProvider();
            MemoryStream ms = new MemoryStream(1024);
            CryptoStream cs = new CryptoStream(ms, tdes.CreateEncryptor(key, iv), CryptoStreamMode.Write);
            cs.Write(data, 0, data.Length);
            cs.Close();
            return ms.ToArray();
        }

        protected byte[] EncryptWithPassportPublicKey(byte[] data)
        {
            // Managed RSA provider expects key data in big endian order
            byte[] rmodulus = DuplicateAndReverse(PublicKeyModulus);
            byte[] rpubexp  = new byte[] {
                (byte) ((PublicKeyPublicExponent & 0xFF000000)>>24),
                (byte) ((PublicKeyPublicExponent & 0xFF0000)>>16),
                (byte) ((PublicKeyPublicExponent & 0xFF00)>>8),
                (byte) (PublicKeyPublicExponent & 0xFF)
            };

            // Load up key
            using (RSACryptoServiceProvider rsa = new RSACryptoServiceProvider())
            {
                RSAParameters keyInfo = new RSAParameters();
                keyInfo.Modulus  = rmodulus;
                keyInfo.Exponent = rpubexp;
                rsa.ImportParameters(keyInfo);

                // Calculate the max size of message bytes that can be encrypted
                // in one block of cipher text and the number of blocks necessary
                // to encrypt the whole thing
                int msgblocksize  = PublicKeyModulus.Length - 2 - 2 * 20;
                int blockcount    = (data.Length / msgblocksize) + ((data.Length % msgblocksize) != 0 ? 1 : 0);

                // Encrypt
                using (MemoryStream ciphertext = new MemoryStream(blockcount * PublicKeyModulus.Length))
                {
                    byte[] msgblock = new byte[msgblocksize];
                    int dataleft = data.Length;
                    for(int i=0; i < blockcount; i++)
                    {
                        int size = Math.Min(dataleft, msgblocksize);
                        if(size != msgblock.Length)
                            msgblock = new byte[size];

                        Buffer.BlockCopy(data, i * msgblocksize, msgblock, 0, size);
                        byte[] cipherblock = rsa.Encrypt(msgblock, true);
                        Array.Reverse(cipherblock);
                        ciphertext.Write(cipherblock, 0, cipherblock.Length);
                        dataleft -= size;
                    }

                    return ciphertext.ToArray();
                }
            }
        }

        // Copy buffer and reverse it at the same time
        protected byte[] DuplicateAndReverse(byte[] bin)
        {
            byte[] rdup = new byte[bin.Length];

            int rduplength = rdup.Length;
            for(int i=0; i < bin.Length; i++)
            {
                rdup[rduplength - i - 1] = bin[i];
            }

            return rdup;
        }
    }


    // Utility class to read and write to the Passport profile xml blob
    public class PassportProfile
    {
        public PassportProfile(string profileXml)
        {
            Init(profileXml);
        }

        public PassportProfile(ulong puid)
        {
            Init(puid);
        }

        public string Xml
        {
            get { return _xml.OuterXml; }
        }

        protected void Init(string profileXml)
        {
            // Load xml document
            _xml = new XmlDocument();
            _xml.LoadXml(profileXml);

            // Load namespaces
            _nsm = new XmlNamespaceManager(_xml.NameTable);
            _nsm.AddNamespace("p", _passportUserNs);

            // Get the userData element node
            _userDataNode = _xml.SelectSingleNode("/p:userData", _nsm);
            if (_userDataNode == null)
                throw new Exception("Cannot find 'userData' element in profile xml");
        }

        protected void Init(ulong puid)
        {
            _xml = new XmlDocument();
            _nsm = new XmlNamespaceManager(_xml.NameTable);
            _nsm.AddNamespace("p", _passportUserNs);

            // Create an empty profile xml
            _userDataNode = _xml.CreateElement("p:userData", _passportUserNs);
            _xml.AppendChild(_userDataNode);
            XmlNode dataOwnerNode = _xml.CreateElement("p:dataOwner", _passportUserNs);
            dataOwnerNode.InnerText = puid.ToString("X016");
            _userDataNode.AppendChild(dataOwnerNode);
        }

        public ulong GetPassportPuid()
        {
            XmlNode node;

            if ((node = _xml.SelectSingleNode("/p:userData/p:dataOwner", _nsm)) == null)
                throw new Exception("Cannot find passport-puid in profile xml");

            return Convert.ToUInt64(node.InnerText, 16);
        }

        private static string lowerCase = "abcdefghijklmnopqrstuvwxyz";
        private static string upperCase = "ABCDEFGHIJKLMNOPQRSTUVWXYZ";

        protected XmlNode GetAttributeNode(string namespc, string attributeName)
        {
            XmlNode node;

            namespc = namespc.ToUpper();
            attributeName = attributeName.ToUpper();

            string translateString = "[translate(@name, '{0}', '{1}') = '{2}']";

            string translatedNameSpc = string.Format(translateString, lowerCase, upperCase, namespc);

            string translatedAttribute = string.Format(translateString,lowerCase, upperCase, attributeName);

            string xpathString = string.Format("/p:userData/p:propertyCollection{0}/p:property{1}",
                translatedNameSpc, translatedAttribute);

            node = _xml.SelectSingleNode(xpathString, _nsm);

            if (node == null)
                throw new Exception(string.Format("Cannot find attribute {0}.{1} in profile xml:\n", namespc, attributeName));

            return node;
        }

        public bool GetAttributeString(
            string namespc,
            string attributeName,
            out string value
        )
        {
            XmlNode node = GetAttributeNode(namespc, attributeName);

            string attributeType = node.Attributes["datatype"].Value.ToLower();

            if (attributeType == "nil")
            {
                value = string.Empty;
                return false;
            }
            else if (attributeType == "string" || attributeType == "bstr")
            {
                value = node.InnerText;
                return true;
            }
            else
            {
                throw new Exception(string.Format("Attribute {0}.{1} is not string. Profile xml:", namespc, attributeName));
            }
        }

        public bool GetAttributeInt(
            string namespc,
            string attributeName,
            out int value
        )
        {
            XmlNode node = GetAttributeNode(namespc, attributeName);

            string attributeType = node.Attributes["datatype"].Value.ToLower();

            if (attributeType == "nil")
            {
                value = 0;
                return false;
            }
            else if (attributeType == "i4")
            {
                value = Convert.ToInt32(node.InnerText);
                return true;
            }
            else
            {
                throw new Exception(string.Format("Attribute {0}.{1} is not valid Int. Profile xml:", namespc, attributeName));
            }
        }

        protected void AppendAttribute(string namespc, string attributeName, string datatype, string value)
        {
            XmlNode attributeNode;
            XmlNode namespcNode;
            XmlAttribute attribute;

            namespc = namespc.ToUpper();
            attributeName = attributeName.ToUpper();
            datatype = datatype.ToLower();

            namespcNode = _xml.SelectSingleNode(
                string.Format("/p:userData/p:propertyCollection[@name=\"{0}\"]", namespc), _nsm);

            if (namespcNode == null)
            {
                namespcNode = _xml.CreateElement("p:propertyCollection", _passportUserNs);
                attribute = _xml.CreateAttribute("name");
                attribute.Value = namespc;
                namespcNode.Attributes.Append(attribute);
                _userDataNode.AppendChild(namespcNode);
            }

            attributeNode = namespcNode.SelectSingleNode(
                string.Format("p:property[@name=\"{0}\"]", attributeName), _nsm);

            if (attributeNode == null)
            {
                attributeNode = _xml.CreateElement("p:property", _passportUserNs);
                namespcNode.AppendChild(attributeNode);
            }

            attribute = _xml.CreateAttribute("name");
            attribute.Value = attributeName;
            attributeNode.Attributes.Append(attribute);

            attribute = _xml.CreateAttribute("datatype");
            attribute.Value = datatype;
            attributeNode.Attributes.Append(attribute);

            attributeNode.InnerText = value;
        }

        public void AppendAttributeString(string namespc, string attributeName, string value)
        {
            if (value == null)
                AppendAttribute(namespc, attributeName, "nil", string.Empty);
            else
                AppendAttribute(namespc, attributeName, "string", value);
        }

        protected static string _passportUserNs = "http://schemas.microsoft.com/Passport/User";
        protected XmlDocument _xml;
        protected XmlNamespaceManager _nsm;
        protected XmlNode _userDataNode;
    }


}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\marketplace\billing\PassportHelper.cs ===
using System;
using System.Collections;
using System.Text.RegularExpressions;

using xonline.common.billing;
using xonline.common.config;
using xonline.common.mgmt;
using xonline.common.protocol;
using xonline.common.service;
using xonline.common.sql.webstore;
using xonline.common.user;
using xonline.common.utilities;

namespace xonline.common.billing
{
    public static class PassportHelper
    {
        public static bool IsUserError(HResult hResult)
        {
            switch (hResult) {
                case HResult.XONLINE_E_PASSPORT_TIMEOUT                   : return false;
                case HResult.XONLINE_E_PASSPORT_INVALID_RESPONSE          : return false;
                case HResult.XONLINE_E_PASSPORT_SITE_NOT_AUTHORIZED       : return false;
                case HResult.XONLINE_E_PASSPORT_TOO_MANY_SECRET_QUESTIONS : return false;
                case HResult.XONLINE_E_PASSPORT_NO_SECRET_QUESTIONS       : return false;
                case HResult.XONLINE_E_PASSPORT_ERROR                     : return false;

            }

            // if it's any other passport error it is a user error
            // other errors are runtime errors - not  user  errors

            return (hResult & 0xFFFFFF00) == HResult.XONLINE_E_PASSPORT_ERROR;
        }

        public static string GetPassportMemberName(ulong puid)
        {
            string response;
            PassportClientBase pp = PassportClientGlobal.Global;

            try
            {
                response = pp.GetPassportMemberName(puid);
            }
            catch (Exception e)
            {
                if (e is ExceptionWithHResult
                    && ((ExceptionWithHResult)e).HResult == HResult.XONLINE_E_PASSPORT_INVALID_ID)
                {
                    try
                    {
                        InvalidatePassportInUODB(puid);
                    }
                    catch (Exception ex)
                    {
                        Xom.Trace(
                            "passportTrace", LogLevel.L_HIGH, "PassportHelper.GetPassportMemberName: InvalidatePassportInUODB failed for passport puid " + puid + " with exception: " + ex
                        );
                    }
                }

                throw e;
            }

            return response;
        }

        public static string GetPassportMemberNameAndCID(ulong puid, out string cid)
        {
            string response;
            PassportClientBase pp = PassportClientGlobal.Global;

            try
            {
                response = pp.GetPassportMemberNameAndCID(puid, out cid);
            }
            catch (Exception e)
            {
                if (e is ExceptionWithHResult
                    && ((ExceptionWithHResult)e).HResult == HResult.XONLINE_E_PASSPORT_INVALID_ID)
                {
                    try
                    {
                        InvalidatePassportInUODB(puid);
                    }
                    catch (Exception ex)
                    {
                        Xom.Trace(
                            "passportTrace", LogLevel.L_HIGH, "PassportHelper.GetPassportMemberNameAndCID: InvalidatePassportInUODB failed for passport puid " + puid + " with exception: " + ex
                        );
                    }
                }

                throw e;
            }

            return response;
        }

        public static PassportProfile getPassportProfile(ulong puid)
        {
            // Return all attributes for the profile
            return getPassportProfile(puid, "*");

        }


        public static PassportProfile getPassportProfile(ulong puid, string attributes)
        {

            PassportClientBase pp = PassportClientGlobal.Global;

            string profileXml;

            pp.GetProfile(puid, attributes, out profileXml);

            return new PassportProfile(profileXml);

        }

        public static PassportProfileData PassportGetUserData(byte[] sessionToken)
        {
            ulong puid = PassportSessionToken.GetPuid(sessionToken);
            return PassportGetUserData(puid);
        }

        public static PassportProfileData PassportGetUserData(ulong puid)
        {
            
            PassportProfile profile = getPassportProfile(puid);

            int geoid;
            GeoId.RegionInfo regionInfo = null;


            PassportProfileData response = new PassportProfileData();

         
            // Personal information
            GetAttributeString(profile, "Personal2_CS", "name.first", out response.firstName);
            GetAttributeString(profile, "Personal2_CS", "name.last", out response.lastName);

            // Birthdate
            string birthDateString;
            if (GetAttributeString(profile, "Personal_CS", "birthdate", out birthDateString))
            {
                ParseBirthdate(birthDateString, out response.birthdate);
            }
            else
            {
                response.birthdate = _nulldate;
            }

            // Address
            response.addressInfo = new PassportProfileAddressInfoData();
            GetAttributeString(profile, "Addresses_CS", "home.street1", out response.addressInfo.street1);
            GetAttributeString(profile, "Addresses_CS", "home.street2", out response.addressInfo.street2);
            GetAttributeString(profile, "Addresses_CS", "home.city", out response.addressInfo.city);

            response.addressInfo.district = "";

            // Get geo-id. We'll use it to get the country and the state
            if(GetAttributeInt(profile, "Addresses_CS", "home.region", out geoid))
            {
                regionInfo = GeoId.GetRegionInfo((uint)geoid);
            }
                
            response.addressInfo.state = regionInfo != null ? regionInfo._region : string.Empty;

            GetAttributeString(profile, "Addresses_CS", "home.postalcode", out response.addressInfo.postalCode);
                       
            if (regionInfo != null)
            {
                response.countryId = regionInfo._countryId;
            }
            else
            {
                string countryCode;
                if(GetAttributeString(profile, "Addresses_CS", "home.country", out countryCode))
                {
                    response.countryId = CountryDictionary.CountryId(countryCode.ToUpper());
                }
            }

            // Phone number - no longer populated since Passport  unlike UPS does not return this 
            response.phoneInfo = new PassportProfilePhoneInfoData();
            response.phoneInfo.phonePrefix = string.Empty;
            response.phoneInfo.phoneNumber = string.Empty;
            response.phoneInfo.phoneExtension = string.Empty;

            //Email - no longer populated since Passport  unlike UPS does not return this 
            response.email = string.Empty;

            return response;
        }

        //These are the more forgiving versions of the same methods in PassportPRofile that dont throw an exception if it cannot find an attribute
        private static bool GetAttributeString( PassportProfile profile, string namespc, string attributeName, out string value)   
        {
            try
            {
                bool nodePresent = profile.GetAttributeString(namespc, attributeName, out value);
                return nodePresent;
            }
            catch (Exception ex)
            {
                //Node is not present
                Xom.Trace(
                           "passportTrace", LogLevel.L_HIGH, "PassportHelper.GetAttributeString: Attribute not found " + attributeName + " with exception: " + ex
                       );
                value = null;
                return false;
            }
            
        }

        //These are the more forgiving versions of the same methods in PassportPRofile that dont throw an exception if it cannot find an attribute
        private static bool GetAttributeInt( PassportProfile profile,   string namespc, string attributeName, out int value)   
        {
            try
            {
                bool nodePresent = profile.GetAttributeInt(namespc, attributeName, out value);
                return nodePresent;
            }
            catch (Exception ex)
            {
                //Node is not present
                Xom.Trace(
                         "passportTrace", LogLevel.L_HIGH, "PassportHelper.GetAttributeInt: Attribute not found " + attributeName + " with exception: " + ex
                     );
                value = 0;
                return false;
            }
            
        }


        private static bool ParseBirthdate(
          string birthdateStr,
          out DateTime birthdate
        )
        {
            birthdate = _nulldate;

            Match match = _dateRegex.Match(birthdateStr);
            if (match.Success)
            {
                try
                {
                    birthdate = new DateTime(
                        Convert.ToInt32(match.Groups["year"].Value),
                        Convert.ToInt32(match.Groups["month"].Value),
                        Convert.ToInt32(match.Groups["day"].Value));
                }
                catch (ArgumentOutOfRangeException)
                {
                    return false;
                }
                catch (ArgumentException)
                {
                    return false;
                }

                return true;
            }
            else
            {
                return false;
            }
        }
        
        private static bool ParsePhoneNumber(
            string phoneNumber,
            out string prefix,
            out string number,
            out string extension
        )
        {
            Match match = _phoneNumberRegEx.Match(phoneNumber);

            if (match.Success)
            {
                prefix = match.Groups["prefix"].Value;
                number = match.Groups["number"].Value;
                extension = string.Empty;
                return true;
            }
            else
            {
                prefix = string.Empty;
                number = string.Empty;
                extension = string.Empty;
                return false;
            }
        }

        private static Regex _phoneNumberRegEx = new Regex(
         @"^\s*" +                      // Trailing spaces
         @"\((?<prefix> \d{1,12} )\)" + // Prefix
         @"\s*" +                       // More spaces
         @"(?<number> \d+ -? \d+)" +       // Number
         @"\s*$",                      // Trailing spaces
         RegexOptions.Compiled | RegexOptions.IgnorePatternWhitespace
        );

        private static Regex _dateRegex = new Regex(
          @"^\s*" +               // Trailing spaces
          @"(?<day>\d{1,2})" +    // Day
          @"(?<sep> [-/:])" +     // Separator (either -, / or :)
          @"(?<month>\d{1,2})" +  // Month
          @"\k<sep>" +            // Separator (matching the first one)
          @"(?<year> \d{4})" +    // Year
          @"\s*$        ",       // More trailing spaces
          RegexOptions.Compiled | RegexOptions.IgnorePatternWhitespace);

        private static DateTime _nulldate = new DateTime(1601, 1, 1);

        private static void InvalidatePassportInUODB(ulong passportPuid)
        {
            // find the user
            ulong xuid = 0;
            using (WSClient ws = new WSClient(ConfigUtil.UodbWebstoreApp, CmdType.WRITETHENREAD_COMMANDTYPE))
            {
                ws.SetHashVal(passportPuid);
                ws.StoredProc = "dbo.p_xuacs_get_user_by_passport";
                ws.AddParameter(ParamType.RETVAL, "@RETVAL", 0);
                ws.AddParameter(ParamType.INPUT, "@bi_user_passport_puid", passportPuid);
                ws.AddParameter(ParamType.OUTPUT, "@bi_user_puid", xuid);
                ws.ExecuteNonQuery();

                if (HResult.Succeeded((uint)ws.GetIntParameter("@RETVAL")))
                {
                    xuid = (ulong)ws.GetLongParameter("@bi_user_puid");
                }
            }

            // if we found him, invalidate him
            if (xuid != 0)
            {
                User u = new User();

                u.Load(xuid);

                // Make sure the target user is a parent
                if (!u.IsJuvenileAccount && XeSubscriptionUtil.GetUserGoldLimit(xuid) > 0)
                {
                    // First we have to find out if he has a family membership and remove them 
                    FamilyMember[] members;
                    User Child = new User();
                    u.GetFamilyMembers(out members);

                    foreach (FamilyMember member in members)
                    {
                        if ((member.userFlags & FamilyDefs.FAMILY_SUBSCRIPTION_GOLD) == FamilyDefs.FAMILY_SUBSCRIPTION_GOLD)
                        {
                            Child.Load(member.userPuid);
                            Child.RemoveFromFamilyGoldSeat(xuid, xonline.core.history.HistoryReason.OwnerPassportInvalid);
                            Child.Save();
                        }
                    }
                }

                using (WSClient ws = new WSClient(ConfigUtil.UodbWebstoreApp, CmdType.WRITETHENREAD_COMMANDTYPE))
                {
                    ws.SetHashVal(xuid);
                    ws.StoredProc = "dbo.p_passport_invalidate_user_passport_puid";
                    ws.AddParameter(ParamType.INPUT, "@bi_user_puid", xuid);
                    ws.ExecuteNonQuery();
                }

                Xom.Trace(
                    "passportTrace", LogLevel.L_LOW, "PassportHelper.InvalidatePassportInUODB: set ti_invalid_user_passport for user puid: " + xuid + ", passport puid: " + passportPuid
                );
            }
            // otherwise, assume it's a parent account. notify the next of kin.
            else
            {
                // No need to worry about family membership here
                // WLID only parents can't have family memberships
                ulong rowsAffected = 0;
                using (WSClient ws = new WSClient(ConfigUtil.UodbWebstoreApp, CmdType.WRITEONLY_COMMANDTYPE))
                {
                    ws.StoredProc = "dbo.p_passport_invalidate_owner_passport_puid";
                    ws.AddParameter("@bi_owner_passport_puid", passportPuid);

                    for (int partition = 0; partition < ws.PhysicalPartitions; partition++)
                    {
                        ws.PhysicalPartition = partition;

                        rowsAffected += (ulong)ws.ExecuteNonQuery();
                    }
                }

                if (rowsAffected == 0)
                {
                    Xom.Trace(
                        "passportTrace", LogLevel.L_HIGH, "PassportHelper.InvalidatePassportInUODB: passport puid: " + passportPuid + " has no entries in t_users as either bi_user_passport_puid or bi_owner_passport_puid!"
                    );
                }
                else
                {
                    Xom.Trace(
                        "passportTrace", LogLevel.L_LOW, "PassportHelper.InvalidatePassportInUODB: set ti_invalid_owner_passport for this many users: " + rowsAffected + ". passport puid: " + passportPuid
                    );
                }
            }
        }
    }


    public class PassportProfileData
    {

        public string firstName;

        public string lastName;

        public DateTime birthdate;

        public PassportProfileAddressInfoData addressInfo;

        public PassportProfilePhoneInfoData phoneInfo;

        public byte countryId;

        public string email;

    }


    public class PassportProfileAddressInfoData 
    {

        public string street1 = "";

        public string street2 = "";

        public string city = "";

        public string district = "";

        public string state = "";

        public string postalCode = "";
    }

    public class PassportProfilePhoneInfoData 
    {
        public string phonePrefix = "";

        public string phoneNumber = "";

        public string phoneExtension = "";
    }



}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\marketplace\billing\PassportSessionToken.cs ===
//
// BillingConfig.cs
//
// Copyright (c) Microsoft Corporation. All Rights Reserved.
//
//

using System;
using System.IO;
using xonline.common.service;

namespace xonline.common.billing
{
    public class PassportSessionToken
    {
        static public byte[] Generate(UInt64 puid)
        {
            return Generate(SGInfo.Current, puid);
        }

        static public byte[] Generate(SGInfo sgInfo, UInt64 puid)
        {
            // Generate signed puid using the following format:
            // puid       (8 bytes)
            // signature  (20 bytes)

            byte[] signature;
            MemoryStream ms = new MemoryStream(XOn.XONLINE_PASSPORT_SESSION_TOKEN_LEN);

            using (BinaryWriter bw = new BinaryWriter(ms))
            {
                bw.Write(puid);

                if(AuthToggle.On)
                {
                    signature = sgInfo.SignWithKey(ms.GetBuffer(), 0, (int)ms.Length);
                }
                else
                {
                    signature = new byte[20];
                }

                if(signature.Length != 20)
                {
                    throw new Exception(string.Format("Unexpected: invalid signature size:{0}", signature.Length.ToString()));
                }
                bw.Write(signature);
            }

            return ms.ToArray();
        }

        static public void Verify(byte[] signedPuid, out UInt64 puid)
        {
            byte[] signature;
            byte[] signature2;

            if (AuthToggle.On)
            {
                signature = SGInfo.Current.SignWithKey(signedPuid, 0, 8);
            }
            else
            {
                signature = new byte[20];
            }

            MemoryStream ms = new MemoryStream(signedPuid);

            using (BinaryReader br = new BinaryReader(ms))
            {
                puid = br.ReadUInt64();
                signature2 = br.ReadBytes(20);

                for (int i=0; i < signature.Length; i++)
                {
                    if (signature[i] != signature2[i])
                    {
                        throw new ExceptionWithEventId(XEvent.Id.COMMON_HACK_3, "Signature of signed puid is invalid. Puid = 0x"+puid.ToString("x"));
                    }
                }
            }
        }

        static public ulong GetPuid(byte[] sessionToken)
        {
            MemoryStream ms = new MemoryStream(sessionToken);

            using (BinaryReader br = new BinaryReader(ms))
            {
                ulong puid = br.ReadUInt64();
                return puid;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\marketplace\billing\PayPalPayinInfo.cs ===
using System.Xml;
using System.IO;

using xonline.common.mgmt;
using xonline.common.protocol;

namespace xonline.common.billing
{
    public class PayPalPayinInfo
    {
        public BillingAgreementDetails BillingAgreementDetails = new BillingAgreementDetails();

        public void FromXml(string xml, string rootNodeName)
        {
            XmlTextReader xmlReader = new XmlTextReader(new StringReader(xml));
            FromXml(xmlReader, rootNodeName);
            xmlReader.Close();
        }

        public void FromXml(XmlTextReader xmlReader, string rootNodeName)
        {
            xmlReader.MoveToContent();
            while (!xmlReader.EOF)
            {
                if (xmlReader.NodeType == XmlNodeType.EndElement &&
                    xmlReader.Name == rootNodeName)
                {
                    xmlReader.Skip();
                    break;
                }

                if (xmlReader.NodeType != XmlNodeType.Element)
                {
                    xmlReader.Skip();
                    continue;
                }

                switch (xmlReader.Name)
                {
                    case "BillingAgreementDetails":
                        BillingAgreementDetails bad = new BillingAgreementDetails();
                        bad.FromXml(xmlReader, "BillingAgreementDetails");
                        this.BillingAgreementDetails = bad;
                        break;

                    default:
                        if (xmlReader.Name == rootNodeName)
                        {
                            // advance to the first inner element
                            xmlReader.ReadStartElement();
                            break;
                        }

                        Xom.Trace(XomAreaName.spstrace, LogLevel.L_NORMAL, "PayPalPayinInfo: Unrecognized Xml element: " + xmlReader.Name );
                        xmlReader.Skip();
                        break;
                }
            }
        }


        // since we only receive PayPalPayinInfo from SCS and never send it,
        // there should not be a need to serialize this
#if false
        public string ToXml(string rootNodeName)
        {
            StringBuilder xmlBldr = new StringBuilder();
            ToXml(xmlBldr, rootNodeName);
            return xmlBldr.ToString();
        }

        public void ToXml(StringBuilder xmlBldr, string rootNodeName)
        {


            Debug.Assert(xmlBldr != null, "Invalid Argument");

            xmlBldr.Append("<" + (rootNodeName == null ? "WholesaleInfo" : rootNodeName) + " xmlns=\"urn:schemas-microsoft-com:billing-data\">");

            xmlBldr.Append("<AccountHolderName>");
            xmlBldr.Append(XmlCleanser.Cleanup(AccountHolderName));
            xmlBldr.Append("</AccountHolderName>");

            xmlBldr.Append("<ExternalPartnerId>");
            xmlBldr.Append(XmlCleanser.Cleanup(ExternalReferenceId));
            xmlBldr.Append("</ExternalPartnerId>");

            xmlBldr.Append("<WholesalePartner>");
            xmlBldr.Append(XmlCleanser.Cleanup(WholesalePartner));
            xmlBldr.Append("</WholesalePartner>");

            if (! string.IsNullOrEmpty(EncryptedPassword))
            {
                WholesaleData wholesaleData = new WholesaleData();
                wholesaleData.EncryptedPassword = EncryptedPassword;
                wholesaleData.ToXml(xmlBldr, "WholesaleData");
            }

            xmlBldr.Append("</WholesaleInfo>");
        }
#endif

        // Returns a new instance of DirectDebitInfoData populated with data
        // from the current DirectDebitInfo instance.
        public PayPalPayinInfoData ToWireData()
        {
            PayPalPayinInfoData paypalPayinInfoData = new PayPalPayinInfoData();

            /* stuff happens here */

            return paypalPayinInfoData;
        }

        // since we only receive PayPalPayinInfo from SCS and never send it,
        // there should not be a need to serialize this
#if false
        // Populates PayPalPayinInfo property data with data from the given
        // DirectDebitInfoData instance.
        public void FromWireData(PayPalPayinInfoData paypalPayinInfoData)
        {
            /* stuff happens here */
        }

        // validates required fieds have been set before generating xml.
        // (should this be debug only?)
        public void ValidateFields(bool isUpdate)
        {
            /* if anything is missing... */
            //  throw new Exception("Missing PayPalPayinInfo.missingStuff");
        }
#endif

        public override string ToString()
        {
            string a;

            a = "BillingAgreementDetails: "     + BillingAgreementDetails.ToString() +
                "\n";

            return a;
        }
    }

    public class BillingAgreementDetails
    {
        public string PayerEmail;
        public string BillingAgreementId;
        public string FirstName;
        public string LastName;
        public string MiddleName;
        public string PayerBusiness;
        public string PayerCountry;
        public string BillingAgreementDescription;

        public void FromXml(string xml, string rootNodeName)
        {
            XmlTextReader xmlReader = new XmlTextReader(new StringReader(xml));
            FromXml(xmlReader, rootNodeName);
            xmlReader.Close();
        }

        public void FromXml(XmlTextReader xmlReader, string rootNodeName)
        {
            xmlReader.MoveToContent();
            while (!xmlReader.EOF)
            {
                if (xmlReader.NodeType == XmlNodeType.EndElement &&
                    xmlReader.Name == rootNodeName)
                {
                    xmlReader.Skip();
                    break;
                }

                if (xmlReader.NodeType != XmlNodeType.Element)
                {
                    xmlReader.Skip();
                    continue;
                }

                switch (xmlReader.Name)
                {
                    case "PayerEmail":
                        PayerEmail = xmlReader.ReadElementString();
                        break;

                    case "BillingAgreementId":
                        BillingAgreementId = xmlReader.ReadElementString();
                        break;

                    case "FirstName":
                        FirstName = xmlReader.ReadElementString();
                        break;

                    case "LastName":
                        LastName = xmlReader.ReadElementString();
                        break;

                    case "MiddleName":
                        MiddleName = xmlReader.ReadElementString();
                        break;

                    case "PayerBusiness":
                        PayerBusiness = xmlReader.ReadElementString();
                        break;

                    case "PayerCountry":
                        PayerCountry = xmlReader.ReadElementString();
                        break;

                    case "BillingAgreementDescription":
                        BillingAgreementDescription = xmlReader.ReadElementString();
                        break;

                    default:
                        if (xmlReader.Name == rootNodeName)
                        {
                            // advance to the first inner element
                            xmlReader.ReadStartElement();
                            break;
                        }

                        Xom.Trace(XomAreaName.spstrace, LogLevel.L_NORMAL, "BillingAgreementDetails: Unrecognized Xml element: " + xmlReader.Name);
                        xmlReader.Skip();
                        break;
                }
            }
        }

        // because we only receive this data from SCS, there should be no need to serialize it
#if false
        public string ToXml(string rootNodeName)
        {
            StringBuilder xmlBldr = new StringBuilder();
            ToXml(xmlBldr, rootNodeName);
            return xmlBldr.ToString();
        }

        public void ToXml(StringBuilder xmlBldr, string rootNodeName)
        {
            Debug.Assert(xmlBldr != null, "Invalid Argument");

            xmlBldr.Append("<" + (rootNodeName == null ? "BillingAgreementDetails" : rootNodeName) + " xmlns=\"urn:schemas-microsoft-com:billing-data\">");

            xmlBldr.Append("<>");
            xmlBldr.Append(XmlCleanser.Cleanup(EncryptedPassword));
            xmlBldr.Append("</EncryptedPassword>");

            xmlBldr.Append("</WholesaleData>");
        }

        // validates required fieds have been set before generating xml.
        // (should this be debug only?)
        public void ValidateFields(bool isUpdate)
        {
            if (string.IsNullOrEmpty(EncryptedPassword)) throw new Exception("Missing WholesaleInfo.EncryptedPassword");
        }
#endif

        public override string ToString()
        {
            string a;

            a = "PayerEmail: "                      + PayerEmail +
                "\nBillingAgreementId: "            + BillingAgreementId +
                "\nFirstName: "                     + FirstName +
                "\nLastName: "                      + LastName +
                "\nMiddleName: "                    + MiddleName +
                "\nPayerBusiness: "                 + PayerBusiness +
                "\nPayerCountry: "                  + PayerCountry +
                "\nBillingAgreementDescription: "   + BillingAgreementDescription +
                "\n";

            return a;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\marketplace\billing\PaymentInfo.cs ===
using System;
using System.Diagnostics;
using System.Collections;
using System.Xml;
using System.Text;
using System.IO;

using xonline.common.mgmt;
using xonline.common.protocol;
using xonline.common.service;

namespace xonline.common.billing
{
    public enum PaymentInstrumentTypeEnum
    {
        None            = 0,
        CreditCard      = 1,
        DirectDebit     = 2,
        Wholesale       = 3,
        PayPalPayin     = 4,
    }

    public enum PaymentInstrumentStatusEnum
    {
        Pending         = 0,
        Good            = 1,
        Declined        = 2,
        Disabled        = 3,
        Removed         = 4,
    }

public class PaymentInfo
{
    public PaymentInfo()
    {
        PaymentInstrumentType = PaymentInstrumentTypeEnum.CreditCard;
        CardType = CardTypeEnum.Visa;
    }

    private static string[] PaymentInstrumentTypes = new string[] {
        "NONE",
        "CREDITCARD",
        "DIRECTDEBIT",
        "WHOLESALE",
        "PAYPALPAYIN",
    };

    private static string[] PaymentInstrumentStatuses = new string[] {
        "PENDING",
        "GOOD",
        "DECLINED",
        "DISABLED",
        "REMOVED",
    };

    public string   Id;

    public PaymentInstrumentTypeEnum PaymentInstrumentType;
    public PaymentInstrumentStatusEnum Status;
    public string FriendlyName;

    public string AccountHolderName
    {
        get
        {
            switch (PaymentInstrumentType) {
                case PaymentInstrumentTypeEnum.CreditCard :
                    return CreditCard.AccountHolderName;
                case PaymentInstrumentTypeEnum.Wholesale :
                    return Wholesale.AccountHolderName;
            }

            throw new Exception(
                "AccountHolderName not accessible for payment instrument type: " + PaymentInstrumentType
            );
        }

        set
        {
            switch (PaymentInstrumentType)
            {
                case PaymentInstrumentTypeEnum.CreditCard:
                    CreditCard.AccountHolderName = value; return;
                case PaymentInstrumentTypeEnum.Wholesale:
                    Wholesale.AccountHolderName = value; return;
            }

            throw new Exception(
                "AccountHolderName not accessible for payment instrument type: " + PaymentInstrumentType
            );
        }
    }

    public string AccountNumber
    {
        get
        {
            if ( PaymentInstrumentType == PaymentInstrumentTypeEnum.CreditCard )
            {
                return CreditCard.AccountNumber;
            }
            else if ( PaymentInstrumentType == PaymentInstrumentTypeEnum.DirectDebit )
            {
                return DirectDebit.AccountNumber;
            }
            else
            {
                throw new Exception("AccountNumber not accessible for payment instrument type: " + PaymentInstrumentType);
            }
        }
        set
        {
            if ( PaymentInstrumentType == PaymentInstrumentTypeEnum.CreditCard )
            {
                CreditCard.AccountNumber = value;
            }
            else if ( PaymentInstrumentType == PaymentInstrumentTypeEnum.DirectDebit )
            {
                DirectDebit.AccountNumber = value;
            }
            else
            {
                throw new Exception("AccountNumber not accessible for payment instrument type: " + PaymentInstrumentType);
            }
        }
    }

    public string AccountNumberLastFour
    {
        get
        {
            if ( PaymentInstrumentType == PaymentInstrumentTypeEnum.CreditCard )
            {
                return CreditCard.AccountNumberLastFour;
            }
            else if ( PaymentInstrumentType == PaymentInstrumentTypeEnum.DirectDebit )
            {
                return DirectDebit.AccountNumberLastFour;
            }
            else
            {
                return null;
            }
        }
        set
        {
            if ( PaymentInstrumentType == PaymentInstrumentTypeEnum.CreditCard )
            {
                CreditCard.AccountNumberLastFour = value;
            }
            else if ( PaymentInstrumentType == PaymentInstrumentTypeEnum.DirectDebit )
            {
                DirectDebit.AccountNumberLastFour = value;
            }
            else
            {
                throw new Exception("AccountNumberLastFour not accessible for payment instrument type: " + PaymentInstrumentType);
            }
        }
    }

    // CreditCardInfo properties
    public DateTime ExpirationDate
    {
        get
        {
            if ( PaymentInstrumentType == PaymentInstrumentTypeEnum.CreditCard )
            {
                return CreditCard.ExpirationDate;
            }

            throw new Exception("ExpirationDate not accessible for payment instrument type: " + PaymentInstrumentType);
        }
        set
        {
            if ( PaymentInstrumentType == PaymentInstrumentTypeEnum.CreditCard )
            {
                CreditCard.ExpirationDate = value;
            }
            else
            {
                throw new Exception("ExpirationDate not accessible for payment instrument type: " + PaymentInstrumentType);
            }
        }
    }

    public CardTypeEnum CardType
    {
        get
        {
            if ( PaymentInstrumentType == PaymentInstrumentTypeEnum.CreditCard )
            {
                return CreditCard.CardType;
            }

            throw new Exception("CardType not accessible for payment instrument type: " + PaymentInstrumentType);
        }
        set
        {
            if ( PaymentInstrumentType == PaymentInstrumentTypeEnum.CreditCard )
            {
                CreditCard.CardType = value;
            }
            else
            {
                throw new Exception("CardType not accessible for payment instrument type: " + PaymentInstrumentType);
            }
        }
    }

    public CreditCardInfo CreditCard = new CreditCardInfo();
    public DirectDebitInfo DirectDebit = new DirectDebitInfo();
    public WholesaleInfo Wholesale = new WholesaleInfo();
    public PayPalPayinInfo PayPalPayin = new PayPalPayinInfo();

    public Address  BillingAddress = new Address();
    public Phone    BillingPhone = new Phone();

    public void EncryptAccountNumber()
    {
        if ( PaymentInstrumentType == PaymentInstrumentTypeEnum.CreditCard )
        {
            CreditCard.EncryptAccountNumber();
        }
        else if ( PaymentInstrumentType == PaymentInstrumentTypeEnum.DirectDebit )
        {
            DirectDebit.EncryptAccountNumber();
        }
    }

    public void FromXml(string xml, string rootNodeName)
    {
        XmlTextReader xmlReader = new XmlTextReader(new StringReader(xml));
        FromXml(xmlReader, rootNodeName);
        xmlReader.Close();
    }

    public void FromXml(XmlTextReader xmlReader, string rootNodeName)
    {
        Stack docFormat = new Stack();

        xmlReader.MoveToContent();
        while (!xmlReader.EOF)
        {
            if (xmlReader.NodeType == XmlNodeType.EndElement &&
                (xmlReader.Name == rootNodeName))
            {
                xmlReader.Skip();
                break;              // we're done with this section
            }

            switch (xmlReader.Name)
            {
            case "PaymentInstrumentType":
                PaymentInstrumentType = (PaymentInstrumentTypeEnum)Array.IndexOf(PaymentInstrumentTypes, xmlReader.ReadElementString());
                break;

            case "PaymentInstrumentId":
                Id = xmlReader.ReadElementString();
                break;

            case "FriendlyName":
                FriendlyName = xmlReader.ReadElementString();
                break;

            case "Phone":
                // read in the phone data here.
                BillingPhone = new Phone();
                BillingPhone.FromXml(xmlReader, "Phone");
                break;

            case "AddressInfo":
                // read in address info here.
                BillingAddress = new Address();
                BillingAddress.FromXml(xmlReader, "AddressInfo");
                break;

            case "CreditCardInfo":
                // read in credit card info here
                CreditCard = new CreditCardInfo();
                CreditCard.FromXml(xmlReader, "CreditCardInfo");
                break;

            case "DirectDebitInfo":
                // read in direct debit info here
                DirectDebit = new DirectDebitInfo();
                DirectDebit.FromXml(xmlReader, "DirectDebitInfo");
                break;

            case "WholesaleInfo":
                // read in wholesale info here
                Wholesale = new WholesaleInfo();
                Wholesale.FromXml(xmlReader, "WholesaleInfo");
                break;

            case "PayPalPayinInfo":
                // read in PayPalPayin info here
                PayPalPayin = new PayPalPayinInfo();
                PayPalPayin.FromXml(xmlReader, "PayPalPayinInfo");
                break;

            case "PaymentInstrumentInfo":
                if (xmlReader.NodeType == XmlNodeType.EndElement)
                {
                    xmlReader.Skip();
                }
                else
                {
                    xmlReader.ReadStartElement();
                }
                break;

            case "PaymentInstrumentStatus":
                Status = (PaymentInstrumentStatusEnum)Array.IndexOf(PaymentInstrumentStatuses, xmlReader.ReadElementString());
                break;

            default:

                if (xmlReader.Name == rootNodeName)
                {
                    // advance to the first inner element
                    xmlReader.ReadStartElement();
                    break;
                }

                Xom.Trace(XomAreaName.spstrace, LogLevel.L_NORMAL, "PaymentInfo: Unrecognized Xml element: " + xmlReader.Name );
                xmlReader.Skip();
                break;
            }
        }
    }

    public string ToXml(string rootNodeName)
    {
        StringBuilder xmlBldr = new StringBuilder();
        ToXml(xmlBldr, rootNodeName);
        return xmlBldr.ToString();
    }


    public void ToXml(StringBuilder xmlBldr, string rootNodeName)
    {
        Debug.Assert(xmlBldr != null, "Invalid Argument");

        Xom.Trace(XomAreaName.spstrace, LogLevel.L_NORMAL, "Beginning to serialize PayInfo object..." );
        if ( PaymentInstrumentType != PaymentInstrumentTypeEnum.None )
        {
            xmlBldr.Append("<" + (rootNodeName == null ? "PaymentInstrumentInfo" : rootNodeName) + " xmlns=\"urn:schemas-microsoft-com:billing-data\">");

            xmlBldr.Append("<PaymentInstrumentType>");
            xmlBldr.Append(XmlCleanser.Cleanup(PaymentInstrumentTypes[(int)PaymentInstrumentType]));
            xmlBldr.Append("</PaymentInstrumentType>");

            xmlBldr.Append("<FriendlyName>");
            xmlBldr.Append(XmlCleanser.Cleanup(FriendlyName));
            xmlBldr.Append("</FriendlyName>");

            switch (PaymentInstrumentType) {
                case PaymentInstrumentTypeEnum.CreditCard :
                    CreditCard.ToXml(xmlBldr, "CreditCardInfo");
                    break;
                case PaymentInstrumentTypeEnum.DirectDebit :
                    DirectDebit.ToXml(xmlBldr, "DirectDebitInfo");
                    break;
                case PaymentInstrumentTypeEnum.Wholesale :
                    Wholesale.ToXml(xmlBldr, "WholesaleInfo");
                    break;
            }

            // Phone element
            if ( BillingPhone != null && BillingPhone.PhoneNumber != null && BillingPhone.PhoneNumber != string.Empty )
            {
                BillingPhone.ToXml(xmlBldr, "Phone");
            }

            // AddressInfo element
            BillingAddress.ToXml(xmlBldr, "AddressInfo");

            xmlBldr.Append("</" + (rootNodeName == null ? "PaymentInstrumentInfo" : rootNodeName) + ">");
        }

        Xom.Trace(XomAreaName.spstrace, LogLevel.L_NORMAL, "...done serializing. Result: " + xmlBldr.ToString() );
    }


    // Returns a new instance of PaymentInstrumentInfoEx populated with data
    // from the current PaymentInfo instance.
    public PaymentInstrumentInfoEx ToWireData()
    {
        PaymentInstrumentInfoEx paymentInfo = new PaymentInstrumentInfoEx();

        paymentInfo.paymentInstrumentId = Id;
        paymentInfo.paymentInstrumentType = (byte) PaymentInstrumentType;

        paymentInfo.addressInfo = BillingAddress.ToWireData();
        paymentInfo.phoneInfo = BillingPhone.ToWireData();
        paymentInfo.creditCardInfo = CreditCard.ToWireData();

        paymentInfo.directDebitInfo = DirectDebit.ToWireData();
        paymentInfo.wholesaleInfo = Wholesale.ToWireData();
        paymentInfo.paypalPayinInfo = PayPalPayin.ToWireData();

        return paymentInfo;
    }

    // validates required fieds have been set before generating xml.
    // (should this be debug only?)
    public void ValidateFields(bool isUpdate)
    {
        if ( PaymentInstrumentType == PaymentInstrumentTypeEnum.None )
        {
            return;
        }

        if (FriendlyName == null)       throw new XRLExceptionWithoutEvent(HResult.XONLINE_E_BILLING_FRIENDLY_NAME_NOT_FOUND_ERROR, "Missing PaymentInfo.FriendlyName");

        switch (PaymentInstrumentType) {
            case PaymentInstrumentTypeEnum.CreditCard :
                CreditCard.ValidateFields(isUpdate);
                break;
            case PaymentInstrumentTypeEnum.DirectDebit :
                DirectDebit.ValidateFields(isUpdate);
                break;
            case PaymentInstrumentTypeEnum.Wholesale:
                Wholesale.ValidateFields(isUpdate);
                break;
        }

        if (BillingAddress == null)     throw new XRLExceptionWithoutEvent(HResult.XONLINE_E_BILLING_ADDRESS_NOT_FOUND_ERROR, "Missing PaymentInfo.BillingAddress");
        if (BillingPhone == null)       throw new XRLExceptionWithoutEvent(HResult.XONLINE_E_BILLING_PHONE_NUMBER_NOT_FOUND_ERROR, "Missing PaymentInfo.BillingPhone");

        /*
        if (isUpdate)
            if (Id == 0)     throw new Exception("Missing PaymentInfo.Id");
        }
        */
    }


    //
    //  Converts a full card number into a billing PIN.
    //
    public static byte[] GetLastFourDigits(string cardNumber)
    {
        byte[] pin      = new byte[XOn.ACCOUNT_PIN_LENGTH];

        if(cardNumber.Length < XOn.ACCOUNT_PIN_LENGTH)
        {
            throw new Exception( "GetLastFourDigits: Card number too short!  Must be long enough for "
                + XOn.ACCOUNT_PIN_LENGTH + "-digit PIN!");
        }

        for(int i = 0; i < XOn.ACCOUNT_PIN_LENGTH; i++)
        {
            pin[i] = Convert.ToByte(cardNumber.Substring(cardNumber.Length - XOn.ACCOUNT_PIN_LENGTH + i, 1));
        }

        return pin;
    }

    public void UpdateInBilling(ulong passportId)
    {
        if ( PaymentInstrumentType == PaymentInstrumentTypeEnum.None )
        {
            Xom.Trace(XomAreaName.spstrace, LogLevel.L_ERROR, "PaymentInfo.UpdateInBilling: unexpectedly called for payment instrument type: None");
            return;
        }

        if ( BillingConfig.ConnectToBilling == false )
        {
            Xom.Trace(XomAreaName.spstrace, LogLevel.L_NORMAL, "PaymentInfo.UpdateInBilling: ConnectToBilling is false, no update performed.");
            return;
        }

        BillingProvider bp = new BillingProvider();

        uint puidHigh;
        uint puidLow;
        Int64Convert.ToUintPair((long)passportId, out puidHigh, out puidLow);

        string errorXml;

        bp.UpdatePaymentInstrumentInfo(0, 0, (int) puidHigh, (int) puidLow, this.Id, this.ToXml("PaymentInstrumentInfo"), out errorXml);

        Xom.Trace(XomAreaName.spstrace, LogLevel.L_NORMAL, "Updated existing payment instrument '" + this.Id + "' for user 0x" + passportId.ToString("X") + "." );

        //
        // In addition to calling UpdatePaymentInstrumentInfo, we
        // also call SettleBalance.  The reason we do this is because
        // if the user is in a suspended state due to an expired
        // credit card, calling UpdatePII will not change their account
        // from suspended to enabled.  Because of this, we call
        // SettleBalance which will correct the state of their account
        // (assuming the last authorization on the old PI isn't still
        // being processed by Citi).
        //
        Guid sbGuid = Guid.NewGuid();
        string amountChargedXml;

        bp.SettleBalance(0, 0, sbGuid.ToString(), this.Id, out errorXml, out amountChargedXml);

        Xom.Trace(XomAreaName.spstrace, LogLevel.L_NORMAL, "Called SettleBalance for user 0x" + passportId.ToString("x") + " (payment instrument '" + this.Id + "', amountChargedXml: " + amountChargedXml + ")" );
    }

    public void AddToBillingAccount(ulong passportId, string accountId)
    {
        if ( PaymentInstrumentType == PaymentInstrumentTypeEnum.None )
        {
            Xom.Trace(XomAreaName.spstrace, LogLevel.L_ERROR, "PaymentInfo.AddToBillingAccount: unexpectedly called for payment instrument type: None");
            return;
        }

        uint puidHigh = 0;
        uint puidLow = 0;
        string guid = Guid.NewGuid().ToString();
        string errorXml = null;
        string paperworkUrl = null;
        string paymentInstrumentId = null;

        Int64Convert.ToUintPair((long)passportId, out puidHigh, out puidLow);

        Xom.Trace(XomAreaName.spstrace, LogLevel.L_LOW, "PaymentInfo.AddToBillingAccount: adding new payment instrument for user " + passportId + ", accountId: " + accountId);

        BillingProvider bp = new BillingProvider();

        EncryptAccountNumber();

        bp.AddPaymentInstrument(
            0x1,
            0x1,
            (int)puidHigh,
            (int)puidLow,
            guid,
            accountId,
            this.ToXml("PaymentInstrumentInfo"),
            out errorXml,
            out paymentInstrumentId,
            out paperworkUrl );

        Id = paymentInstrumentId;

        Xom.Trace(XomAreaName.spstrace, LogLevel.L_NORMAL, "PaymentInfo.AddToBillingAccount: added new payment instrument: " + paymentInstrumentId + " for user: 0x" + passportId.ToString("x") + ", accountId: " + accountId );
    }

    public static void RemoveFromBillingAccount(ulong passportId, string paymentInstrumentId)
    {
        uint puidHigh = 0;
        uint puidLow = 0;
        string errorXml = null;

        Int64Convert.ToUintPair((long)passportId, out puidHigh, out puidLow);

        Xom.Trace(XomAreaName.spstrace, LogLevel.L_LOW, "PaymentInfo.RemoveFromBillingAccount: adding new payment instrument for user " + passportId);

        BillingProvider bp = new BillingProvider();

        bp.RemovePaymentInstrument(
            0x1,
            0x1,
            (int)puidHigh,
            (int)puidLow,
            paymentInstrumentId,
            out errorXml );
    }
}

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\marketplace\billing\Price.cs ===
//
// Offering.cs
//
// Copyright (c) Microsoft Corporation. All Rights Reserved.
//
// SPS 2.5 Wrapper Class
// Xbox Online Service
//
// Author: Ben Zotto (benzotto)
//

using System;
using System.Globalization;
using System.Xml;
using System.IO;

using xonline.common.offer;
using xonline.common.utilities;


namespace xonline.common.billing
{
    public class Price
    {
        public int     grossWhole;
        public int     grossDecimal;
        public int     netWhole;
        public int     netDecimal;
        public char[]  currencyCode;
        public string  cultureCode;

        public Price()
        {}

        public static string XeFormatPrice(uint paymentType, int wholePrice, int fractionalPrice, int LCID)
        {
            double priceValue = (double)(wholePrice) + ((double)(fractionalPrice) / 100);

            return Price.XeFormatPrice(paymentType, priceValue, LCID);
        }

        public static string XeFormatPrice(uint paymentType, double priceValue, int LCID)
        {
            string formattedPrice = "";

            // if the lcid is fake, we need to fix it
            LCID = Locale.GetValidLCID(LCID);

            CultureInfo ci = new CultureInfo(LCID);
            NumberFormatInfo nfi = ci.NumberFormat;

            // based on payment type, determine the if we need to do special cases
            switch ((PaymentTypeEnum)paymentType)
            {
                case PaymentTypeEnum.CreditCard:
                    switch (LCID)
                    {
                        case 1033: // US
                            nfi.CurrencySymbol = "\u0024";
                            break;

                        case 2057: // UK
                            nfi.CurrencySymbol = "\u00A3";
                            break;

                        case 1041: // Japan
                            nfi.CurrencySymbol = "\u00A5";
                            break;

                        case 1042: // S. Korea
                            nfi.CurrencySymbol = "\u20A9";
                            break;

                        case 1081: // Hindi India mapped to en-IN
                            nfi.CurrencySymbol = "Rs.";
                            break;
                    }
                    formattedPrice = priceValue.ToString("c", nfi);
                    break;

                case PaymentTypeEnum.Points:

                    // points do not have fractions
                    nfi.NumberDecimalDigits = 0;
                    nfi.CurrencyDecimalDigits = 0;
                    nfi.CurrencySymbol = "\u00A4";
                    nfi.CurrencyPositivePattern = 1;
                    nfi.CurrencyNegativePattern = 5;
                    formattedPrice = Convert.ToInt32(priceValue).ToString("c", nfi);
                    break;

                case PaymentTypeEnum.Token:
                default:
                    formattedPrice = "";
                    return formattedPrice;
            }

            return formattedPrice;
        }

        public void ParseFromXml(string xml)
        {
            XmlTextReader xmlReader = new XmlTextReader(new StringReader(xml));
            string   fullPrice;
            string[] splitPrice;

            xmlReader.ReadStartElement("AmountCharged");

            // Gross (tax-inclusive)
            xmlReader.ReadStartElement("Gross");
            fullPrice = xmlReader.ReadString();
            splitPrice = fullPrice.Split(new Char[] {'.'}, 2);
            grossWhole = Convert.ToInt32(splitPrice[0]);
            if(splitPrice.Length < 2) { grossDecimal = 0; }
            else { grossDecimal = Convert.ToInt32(splitPrice[1]); }
            xmlReader.ReadEndElement();

            // Net (exclusive of tax)
            xmlReader.ReadStartElement("Charge");
            fullPrice = xmlReader.ReadString();
            splitPrice = fullPrice.Split(new Char[] {'.'}, 2);
            netWhole = Convert.ToInt32(splitPrice[0]);
            if(splitPrice.Length < 2) { netDecimal = 0; }
            else { netDecimal = Convert.ToInt32(splitPrice[1]); }
            xmlReader.ReadEndElement();

            // seek for locale code
            while( xmlReader.Name != "Locale" ) { xmlReader.Read(); }
            cultureCode = xmlReader.ReadString();
            xmlReader.ReadEndElement();

            // Currency
            xmlReader.ReadStartElement("Currency");
            currencyCode = xmlReader.ReadString().ToCharArray(0, 3);
            xmlReader.ReadEndElement();
            xmlReader.Close();

            // Do a bit of sanity checking on the stuff we got
            if( grossDecimal > 99 || netDecimal > 99 )
            {
                throw new Exception( "Bad decimal values from SPS: Check the parsing of amountCharged" );
            }
        }
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\marketplace\billing\PaymentInstrumentInfoSet.cs ===
using System;
using System.Collections;
using System.IO;
using System.Text;
using System.Xml;
using System.Diagnostics;
using xonline.common.service;
using xonline.common.mgmt;

namespace xonline.common.billing
{

    /// <summary>
    /// The PaymentInstrumentInfoSet class represents a set of payment
    /// instruments in SCS and mirrors the PaymentInstrumentInfoSet XML schema.
    /// </summary>

public class PaymentInstrumentInfoSet
{
    private PaymentInstrumentTypeEnum[] _paymentInstrumentTypes = null;
    private ArrayList paymentInstrumentInfoList = null;

    // by default we only return credit cards and direct debit payment instruments
    public PaymentInstrumentInfoSet() :
        this(PaymentInstrumentTypeEnum.CreditCard, PaymentInstrumentTypeEnum.DirectDebit)
    {
    }

    private PaymentInstrumentInfoSet(params PaymentInstrumentTypeEnum[] paymentInstrumentTypes)
    {
        this._paymentInstrumentTypes = paymentInstrumentTypes;
    }

    public ArrayList PaymentInstrumentInfoList
    {
        get { return paymentInstrumentInfoList; }
    }

    // validates required fieds have been set before generating xml.
    // (should this be debug only?)
    public void ValidateFields(bool isUpdate)
    {
    }


    public void FromXml(string xml, string rootNodeName, bool validOnly)
    {
        XmlTextReader xmlReader = new XmlTextReader(new StringReader(xml));
        FromXml(xmlReader, rootNodeName, validOnly);
        xmlReader.Close();
    }

    public void FromXml(XmlTextReader xmlReader, string rootNodeName, bool validOnly)
    {
        paymentInstrumentInfoList = new ArrayList();

        xmlReader.MoveToContent();
        while (!xmlReader.EOF)
        {
            if (xmlReader.NodeType == XmlNodeType.EndElement &&
                xmlReader.Name == rootNodeName)
            {
                xmlReader.Skip();
                break;
            }

            switch (xmlReader.Name)
            {
            case "PaymentInstrumentInfo":
                PaymentInfo paymentInfo = new PaymentInfo();
                paymentInfo.FromXml(xmlReader, "PaymentInstrumentInfo");

                // Ignore payment instrument types we don't support such as
                // WHOLESALE.  Users who have existing billing accounts tied
                // to their Passports may have payment instrument types that
                // we don't support in Xbox Live.

                foreach (PaymentInstrumentTypeEnum paymentInstrumentType in _paymentInstrumentTypes)
                {
                    if (paymentInfo.PaymentInstrumentType == paymentInstrumentType)
                    {
                        if ( paymentInfo.Status == PaymentInstrumentStatusEnum.Good || !validOnly )
                        {
                            paymentInstrumentInfoList.Add(paymentInfo);
                            break;
                        }
                    }
                }

                break;

            default:
                if (xmlReader.Name == rootNodeName)
                {
                    // advance to the first inner element
                    xmlReader.ReadStartElement();
                    break;
                }

                Xom.Trace(XomAreaName.spstrace, LogLevel.L_HIGH, "PaymentInstrumentInfoSet: Unrecognized Xml element: " + xmlReader.Name );
                xmlReader.Skip();
                break;
            }
        }
    }

    public string ToXml()
    {
        StringBuilder xmlBldr = new StringBuilder(1536);
        ToXml(xmlBldr);
        Xom.Trace(XomAreaName.spstrace, LogLevel.L_INFO, "PaymentInstrumentInfoSet.ToXml() - xmlBldr size = " + xmlBldr.Length );
        Xom.Trace(XomAreaName.spstrace, LogLevel.L_INFO, xmlBldr.ToString() );
        return xmlBldr.ToString();
    }

    public void ToXml(StringBuilder xmlBldr)
    {


        Debug.Assert(xmlBldr != null, "Invalid Argument");

        xmlBldr.Append("<PaymentInstrumentInfoSet xmlns=\"urn:schemas-microsoft-com:billing-data\"><CustomerType>");
        foreach (Object o in paymentInstrumentInfoList)
        {
            PaymentInfo paymentInfo = (PaymentInfo) o;
            paymentInfo.ToXml(xmlBldr, "PaymentInstrumentInfo");
        }
        xmlBldr.Append("</PaymentInstrumentInfoSet>");
    }

    /// <summary>
    /// Used to dump the basic information on a payment instrument set. For debugging purposes only.
    /// (remove from retail build?)
    /// </summary>
    /// <returns></returns>
    public override string ToString()
    {
        return "PaymentInstrumentInfoSet: " + (paymentInstrumentInfoList == null ? 0 : paymentInstrumentInfoList.Count) + " payment instruments.";
    }

    // Instantiate a new PaymentInstrumentInfoSet list from the payment
    // instruments associated with an SCS account id.
    public static PaymentInstrumentInfoSet GetPaymentInstruments(ulong puid, string accountId, bool validOnly) {
        return GetPaymentInstruments(puid, accountId, validOnly, false, null);
    }

    public static PaymentInstrumentInfoSet GetPaymentInstruments(ulong puid, string accountId, bool validOnly, params PaymentInstrumentTypeEnum[] paymentInstrumentTypes)
    {
        return GetPaymentInstruments(puid, accountId, validOnly, false, paymentInstrumentTypes);
    }
    
    public static PaymentInstrumentInfoSet GetPaymentInstruments(ulong puid, string accountId, bool validOnly, bool returnRemoved) {
        return GetPaymentInstruments(puid, accountId, validOnly, returnRemoved, null);
    }

    public static PaymentInstrumentInfoSet GetPaymentInstruments(ulong puid, string accountId, bool validOnly, bool returnRemoved, params PaymentInstrumentTypeEnum[] paymentInstrumentTypes)
    {
        uint puidHigh = 0;
        uint puidLow = 0;
        string paymentInstrumentXml;
        int paymentInstrumentCount;
        string errorXml;

        Int64Convert.ToUintPair((long)puid, out puidHigh, out puidLow);

        BillingProvider bp = new BillingProvider();

        bp.GetPaymentInstrumentsEx(
            0x1, 0x1, // delegate puid
            (int)puidHigh, (int)puidLow, // requester puid
            accountId,
            returnRemoved,
            out errorXml,
            out paymentInstrumentCount,
            out paymentInstrumentXml);

        PaymentInstrumentInfoSet payInfoSet = paymentInstrumentTypes == null ?
            new PaymentInstrumentInfoSet(): new PaymentInstrumentInfoSet(paymentInstrumentTypes);

        payInfoSet.FromXml(paymentInstrumentXml, "PaymentInstrumentInfoSet", validOnly);

        Debug.Assert(payInfoSet.PaymentInstrumentInfoList.Count == paymentInstrumentCount );

        return payInfoSet;
    }

    public static PaymentInstrumentInfoSet GetPaymentInstruments(ulong puid, string accountId)
    {
        // by default, only return valid payment instruments (i.e. status of good)
        return GetPaymentInstruments(puid, accountId, true);
    }
}

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\marketplace\billing\RegionalRating.cs ===
using System;
using System.Collections;

using xonline.common.config;
using xonline.common.sql.webstore;

using Microsoft.Webstore.WstClient;

namespace xonline.common.billing
{
    public class RegionalRatings
    {
        private static Hashtable m_ratings;
        public static Hashtable Ratings
        {
            get
            {
                if (m_ratings == null)
                    LoadRatings();

                return m_ratings;
            }
        }

        private static Hashtable m_ratingSystems;
        public static Hashtable RatingSystems
        {
            get
            {
                if (m_ratingSystems == null)
                    LoadRatings();

                return m_ratingSystems;
            }
        }

        private static Hashtable m_regionRatingSystems;
        public static Hashtable RegionRatingSystems
        {
            get
            {
                if (m_regionRatingSystems == null)
                    LoadRegionRatingSystems();

                return m_regionRatingSystems;
            }
        }

        public RegionalRatings()
        {
            m_ratings = null;
            m_ratingSystems = null;
        }

        public static bool VerifyRating(ushort rating)
        {
            return Ratings.ContainsKey(rating);
        }

        public static string RatingToString(ushort rating)
        {
            object o = Ratings[rating];

            if (o == null)
                throw new Exception("invalid rating: " + rating);

            return (string) o;
        }

        public static byte GetRegionRatingSystem(byte countryID)
        {
            return (byte) m_regionRatingSystems[countryID];
        }

        public static byte GetRatingSystem(ushort rating)
        {
            return (byte) (rating >> 8);
        }

        public static byte GetRating(ushort rating)
        {
            return (byte) (rating & 0xFF);
        }

        public static ushort ConstructRating(byte ratingSystem, byte rating)
        {
            return (ushort) ((ratingSystem << 8) | rating);
        }

        protected static void LoadRatings()
        {
            using (WSClient ws = new WSClient(ConfigUtil.UodbWebstoreApp, CmdType.READORWRITE_COMMANDTYPE))
            {
                // Data is partitioned by user puid
                ws.PartitionType   = WstPartitionType.Logical;
                ws.Partition       = WstCommand.AnyPartition;

                ws.StoredProc = "dbo.p_xbos_load_ratings";

                WstDataReader r = ws.Execute();

                Hashtable ratings = new Hashtable();
                Hashtable ratingSystems = new Hashtable();

                while (r.Read())
                {
                    ushort ratingSystem = (ushort) r.GetInt32(0);
                    ushort ratingID = (ushort) r.GetInt32(1);
                    ushort ratingRank = (ushort)r.GetInt32(2);
                    string ratingName = r.GetString(3);

                    object o = ratingSystems[ratingSystem];
                    if (o == null)
                    {
                        ArrayList ratingSystemRatings = new ArrayList(5);
                        ratingSystemRatings.Add(ratingRank);
                        ratingSystems[ratingSystem] = ratingSystemRatings;
                    }
                    else
                    {
                        ArrayList ratingSystemRatings = (ArrayList) o;
                        ratingSystemRatings.Add(ratingRank);
                    }

                    ushort rating = ConstructRating((byte) ratingSystem, (byte) ratingRank);
                    ratings.Add(rating, ratingName);
                }

                m_ratings = ratings;
                m_ratingSystems = ratingSystems;
            }
        }

        protected static void LoadRegionRatingSystems()
        {
            using (WSClient ws = new WSClient(ConfigUtil.UodbWebstoreApp, CmdType.READORWRITE_COMMANDTYPE))
            {
                // Data is partitioned by user puid
                ws.PartitionType   = WstPartitionType.Logical;
                ws.Partition       = WstCommand.AnyPartition;

                ws.StoredProc = "dbo.p_xbos_load_region_rating_systems";

                WstDataReader r = ws.Execute();

                Hashtable regionRatingSystems = new Hashtable();

                while (r.Read())
                {
                    byte countryID = r.GetByte(0);
                    ushort ratingSystem = (ushort) r.GetInt32(1);

                    regionRatingSystems.Add(countryID, ratingSystem);
                }

                m_regionRatingSystems = regionRatingSystems;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\marketplace\billing\RenewalUtil.cs ===
using System;
using System.Diagnostics;

using xonline.common.audit;
using xonline.common.config;
using xonline.common.offer;
using xonline.common.service;
using xonline.common.sql.webstore;
using xonline.common.mgmt;
using xonline.common.user;
using xonline.common.protocol;
using System.Transactions;
using xonline.core.history;


namespace xonline.common.billing
{
    public class RenewalUtil
    {
        //
        // Will call MoveSubscription if necessary.  Return values:
        //
        // S_OK:    No action necessary.
        // S_FALSE: Subscription move accomplished
        // (other): Error.
        //

        public static uint MoveSubscriptionIfRequired(ulong userId, SubscriptionInfo subscriptionInfo, string instanceId, ref ulong baseOfferId)
        {
            bool authoritative = false;
            HResult hr = 0;

            //
            // Lazy verification: has this subscription changed offers since we last checked?
            // If so, we need to update the database appropriately.
            //
            ulong authoritativeBaseOfferId = Offer.OfferIdFromBillingOfferId(subscriptionInfo.OfferingGUID,
                                                                             baseOfferId,
                                                                             out authoritative);

            //
            // if we don't have 100% confidence in the answer,
            // don't do any lazy updating but instead plow ahead.
            //
            if (authoritative == true && authoritativeBaseOfferId != 0)
            {
                if (authoritativeBaseOfferId != baseOfferId)
                {
                    //
                    // Update is required.
                    //

                    DateTime activationDate = subscriptionInfo.ActivationDate;

                    // In test environments, the clock on the billing server
                    // is often advanced to test offer renewal scenarios.  So
                    // for test environments (and test environments only),
                    // if the activation date for the current subscription is
                    // in the future, reset it to the current time.
                    if (Config.IsTestEnvironment() && activationDate > DateTime.UtcNow)
                    {
                        activationDate = DateTime.UtcNow;
                    }

                    hr = MoveSubscription(userId, baseOfferId, instanceId, authoritativeBaseOfferId, instanceId, activationDate);
                    if (HResult.Failed(hr))
                    {
                        Xom.NtEvent(XEvent.Id.COMMON_COMM_5, "Subscription move in UODB failed "
                            + "with hr = " + hr + ". \nUser = " + (Puid)userId
                            + "\nBase offer: " + (OfferId)baseOfferId + "\nSIID: " + instanceId
                        );

                    }
                    else
                    {
                        baseOfferId = authoritativeBaseOfferId;
                        hr = HResult.S_FALSE;
                    }
                }

            }

            return hr;
        }

        public static uint MoveSubscriptionWithFamilyCheck
            (
              Puid userId
            , ulong baseOfferId
            , string instanceId
            , ulong newOfferId
            , string newInstanceId
            , Guid? catalogOfferId
            , Guid? catalogOfferInstanceId
            , DateTime moveDate
            , Offer scsOffer
            )
        {
            User user = new User();
            user.Load(userId);

            HResult hr = HResult.S_OK;

            //check to make sure user is familygold,offer is a base offer and offer provided family gold
            //if yes then we want to apply changes to family as well.
            if (
               user.Tier == (int)TierEnum.FamilyGold
               && scsOffer.IsBaseOffer
               && scsOffer.TierProvided == (int)TierEnum.FamilyGold
            )
            {
                hr= MoveFamilySubscription
                                (
                                      userId
                                    , baseOfferId
                                    , instanceId
                                    , newOfferId
                                    , newInstanceId
                                    , catalogOfferId
                                    , catalogOfferInstanceId
                                    , moveDate
                                    ,scsOffer.TierProvided
                                );

            }
            else
            {
                hr = MoveSubscription
                                (
                                      userId
                                    , baseOfferId
                                    , instanceId
                                    , newOfferId
                                    , newInstanceId
                                    , catalogOfferId
                                    , catalogOfferInstanceId
                                    , moveDate
                                );
            }

            return hr;
        }
        //-----------------------------------------------------
        // Move Subscription
        //
        //  This does a bit of a wacky operation on the t_subscriptions table:
        //
        //      1. Add new row which is basically a copy of the old row, except
        //          with the start date set to the moveData datetime, and the new
        //          offer ID in offer field.
        //      2. Update the old subscription:
        //          - remove the service instance ID.
        //          - set the end date to the moveDate
        //          - set the subscription status to = 10 ("moved")
        //          - clear the transaction flags
        //
        public static uint MoveSubscription
            (
              ulong userId
            , ulong baseOfferId
            , string instanceId
            , ulong newOfferId
            , string newInstanceId
            , Guid? catalogOfferId
            , Guid? catalogOfferInstanceId
            , DateTime moveDate
            )
        {
            Debug.Assert(instanceId != null);
            Debug.Assert(newInstanceId != null);

            WSClient ws = null;
            HResult hr = 0;

            try
            {
                ws = new WSClient(ConfigUtil.UodbWebstoreApp, CmdType.WRITEONLY_COMMANDTYPE);
                ws.SetHashVal((long)userId);
                ws.StoredProc = "dbo.p_xbos_move_subscription";

                // intput and output params
                ws.AddParameter(ParamType.RETVAL, "@RETVAL", 0);
                ws.AddParameter(ParamType.INPUT, "@bi_user_puid", userId);
                ws.AddParameter(ParamType.INPUT, "@bi_old_offer_id", baseOfferId);
                ws.AddParameter(ParamType.INPUT, "@vc_old_instance_id", instanceId, instanceId.Length);
                ws.AddParameter(ParamType.INPUT, "@bi_new_offer_id", newOfferId);
                ws.AddParameter(ParamType.INPUT, "@vc_new_instance_id", newInstanceId, newInstanceId.Length);
                ws.AddParameter(ParamType.INPUT, "@dt_movedate", moveDate);


                if (catalogOfferId.HasValue)
                {
                    ws.AddParameter(ParamType.INPUT, "@uid_catalogoffer_id", catalogOfferId.Value);
                }
                if (catalogOfferInstanceId.HasValue)
                {
                    ws.AddParameter(ParamType.INPUT, "@uid_catalog_offerinstance_id", catalogOfferInstanceId.Value);
                }


                // call the procedure
                ws.ExecuteNonQuery();
                AuditStream.Write(userId, AuditSubsystem.XBOS, ws, string.Empty);

                hr = (uint)ws.GetIntParameter("@RETVAL");
            }
            finally
            {
                if (ws != null)
                {
                    ws.Close();
                    ws = null;
                }
            }

            return hr;
        }

        public static uint MoveSubscription
        (
              ulong userId
            , ulong baseOfferId
            , string instanceId
            , ulong newOfferId
            , string newInstanceId
            , DateTime moveDate
         )
        {
            Guid? catalogOfferId = null;

            Guid? catalogOfferInstanceId = null;

            return MoveSubscription
                (
                  userId
                , baseOfferId
                , instanceId
                , newOfferId
                , newInstanceId
                , catalogOfferId
                , catalogOfferInstanceId
                , moveDate
                );

        }

        public static uint MoveSubscription
            (
              ulong userId
            , Guid catalogOfferId
            , Guid catalogOfferInstanceId
            , string instanceId
            , Guid newCatalogOfferId
            , Guid newCatalogOfferInstanceId
            , string newInstanceId
            , ulong uodbOfferId
            , DateTime moveDate
            , bool isTierChange 
            )
        {
            Debug.Assert(instanceId != null);
            Debug.Assert(newInstanceId != null);

            HResult hr = 0;

            using (WSClient ws = new WSClient(ConfigUtil.UodbWebstoreApp, CmdType.WRITEONLY_COMMANDTYPE))
            {
                ws.SetHashVal((long)userId);
                ws.StoredProc = "dbo.p_xbos_move_subscription_v2";

                // intput and output params
                ws.AddParameter(ParamType.RETVAL, "@RETVAL", 0);
                ws.AddParameter(ParamType.INPUT, "@bi_user_puid", userId);
                ws.AddParameter(ParamType.INPUT, "@uid_old_offer_id", catalogOfferId);
                ws.AddParameter(ParamType.INPUT, "@uid_old_offer_instance_id", catalogOfferInstanceId);
                ws.AddParameter(ParamType.INPUT, "@vc_old_instance_id", instanceId, instanceId.Length);
                ws.AddParameter(ParamType.INPUT, "@uid_new_offer_id", newCatalogOfferId);
                ws.AddParameter(ParamType.INPUT, "@uid_new_offer_instance_id", newCatalogOfferInstanceId);
                ws.AddParameter(ParamType.INPUT, "@vc_new_instance_id", newInstanceId, newInstanceId.Length);
                ws.AddParameter(ParamType.INPUT, "@bi_offer_id", uodbOfferId);
                ws.AddParameter(ParamType.INPUT, "@dt_movedate", moveDate);

                //if the tier is changing the user gets a new serviceInstanceId 
                if (isTierChange)
                {
                    ws.AddParameter(ParamType.INPUT, "@ti_is_tier_change", 1);
                }
                // call the procedure
                ws.ExecuteNonQuery();
                AuditStream.Write(userId, AuditSubsystem.XBOS, ws, string.Empty);

                hr = (uint)ws.GetIntParameter("@RETVAL");
            }
            return hr;
        }

        public static uint MoveDependentSubscription
           (
             ulong userId
           , Guid catalogOfferId
           , Guid catalogOfferInstanceId
           , string instanceId
           , Guid newCatalogOfferId
           , Guid newCatalogOfferInstanceId
           , string newInstanceId
           , ulong uodbOfferId
           , int newTransactionFlags
           , int newSubscriptionStatus
           , ulong ownerPuid
           , DateTime moveDate
           )
        {

            HResult hr = 0;

            using (WSClient ws = new WSClient(ConfigUtil.UodbWebstoreApp, CmdType.WRITEONLY_COMMANDTYPE))
            {
                ws.SetHashVal((long)userId);
                ws.StoredProc = "dbo.p_xbos_move_dependent_subscription";

                // intput and output params
                ws.AddParameter(ParamType.RETVAL, "@RETVAL", 0);
                ws.AddParameter(ParamType.INPUT, "@bi_user_puid", userId);
                ws.AddParameter(ParamType.INPUT, "@uid_old_offer_id", catalogOfferId);
                ws.AddParameter(ParamType.INPUT, "@uid_old_offer_instance_id", catalogOfferInstanceId);
                ws.AddParameter(ParamType.INPUT, "@vc_old_instance_id", instanceId, instanceId.Length);
                ws.AddParameter(ParamType.INPUT, "@uid_new_offer_id", newCatalogOfferId);
                ws.AddParameter(ParamType.INPUT, "@uid_new_offer_instance_id", newCatalogOfferInstanceId);
                ws.AddParameter(ParamType.INPUT, "@vc_new_instance_id", newInstanceId, newInstanceId.Length);
                ws.AddParameter(ParamType.INPUT, "@bi_offer_id", uodbOfferId);
                ws.AddParameter(ParamType.INPUT, "@dt_movedate", moveDate);
                ws.AddParameter(ParamType.INPUT, "@i_transaction_flags", newTransactionFlags);
                ws.AddParameter(ParamType.INPUT, "@i_subscription_status", newSubscriptionStatus);
                ws.AddParameter(ParamType.INPUT, "@bi_subscription_owner_puid", ownerPuid);

                // call the procedure
                ws.ExecuteNonQuery();
                AuditStream.Write(userId, AuditSubsystem.XBOS, ws, string.Empty);

                hr = (uint)ws.GetIntParameter("@RETVAL");
            }
            return hr;
        }

        /// <summary>
        /// Moves the subscriptions of the dependent members of a family subscription
        /// </summary>
        /// <param name="primaryUserId">Puid of the primary</param>
        /// <param name="baseOfferId">Old base OfferId of the primary</param>
        /// <param name="instanceId">Old Instance Id of the priamry</param>
        /// <param name="newOfferId">New offer which Primary is moving to</param>
        /// <param name="newInstanceId">New InstanceId which Primary is moving</param>
        /// <param name="catalogOfferId">Catatalog OfferId corresponding to the family</param>
        /// <param name="catalogOfferInstanceId">Catalog OfferInstanceId corresponding to the family</param>
        /// <param name="moveDate">Date of the move</param>
        /// <param name="tierProvided">tier provided by the SCS offer/New offer</param>
        /// <returns></returns>
        public static uint MoveFamilySubscription
           (
             Puid primaryUserId
           , Puid baseOfferId
           , string instanceId
           , Puid newOfferId
           , string newInstanceId
           , Guid? catalogOfferId
           , Guid? catalogOfferInstanceId
           , DateTime moveDate
           , uint tierProvided
           )
        {

            HResult hresult = HResult.S_OK;

            User primaryUser = new User();
            primaryUser.Load(primaryUserId);

            //Get the family members
            FamilyMember[] familyMembers = null;
            primaryUser.GetFamilyMembers(out familyMembers);

            using (TransactionScope tx = new TransactionScope())
            {
                //Go through every family member and move their subscriptions
                //If there is a non success return then return the first occurence of the error code for the caller to take action.
                    foreach (FamilyMember familyMember in familyMembers)
                    {
                        if (
                            (familyMember.userFlags & FamilyDefs.FAMILY_OWNER) == FamilyDefs.FAMILY_OWNER
                        ||  (
                                  (familyMember.userFlags & FamilyDefs.FAMILY_SUBSCRIPTION_GOLD) == FamilyDefs.FAMILY_SUBSCRIPTION_GOLD
                                && tierProvided==(uint)TierEnum.FamilyGold
                            )
                          )
                        {
                            hresult = MoveSubscription
                                 (
                                    familyMember.userPuid
                                   , baseOfferId
                                   , instanceId
                                   , newOfferId
                                   , newInstanceId
                                   , catalogOfferId
                                   , catalogOfferInstanceId
                                   , moveDate
                                 );

                            //If failed then return the Hresult and back out of transaction
                            if (HResult.Failed(hresult))
                            {
                                Xom.NtEvent(XEvent.Id.ACCOUNT_MOVE_SUBSCRIPTION_ERROR, "Error moving subscription for family member {0}", familyMember.userPuid);
                                return hresult;
                            }

                        }
                        // if primary is moving to a base subscription but to a gold offer then we want to make sure we downgrade the dependent.
                        else if(
                                 (familyMember.userFlags & FamilyDefs.FAMILY_SUBSCRIPTION_GOLD) == FamilyDefs.FAMILY_SUBSCRIPTION_GOLD
                                 && tierProvided!=(uint)TierEnum.FamilyGold
                               )
                            { 
                                User dependentUser=new User();
                                dependentUser.Load(familyMember.userPuid);

                                //this method throws an exception so not considering return here
                                XeSubscriptionUtil.CancelAndDowngradeDependent
                                    (
                                         dependentUser
                                        , instanceId
                                        , true
                                        , HistoryReason.ExpireFamilyGold
                                    );
                            }

                        }
                     tx.Complete();
                    }
          
            return hresult;
          }


        /// <summary>
        /// Updates the subscription history table with details of current offer
        /// If user is family user then dependents are also updated
        /// </summary>
        public static uint SetCurrentSubscriptionHistoryOfferWithFamilyCheck(ulong userId, ulong offerId, Guid? catalogOfferId, Guid? catalogOfferInstanceId,Offer scsOffer)
        {
            User user = new User();
            user.Load(userId);

            //check to make sure user is familygold,offer is a base offer and offer provided family gold
            //if yes then we want to apply changes to family as well.
            if (
                user.Tier == (int)TierEnum.FamilyGold
                && scsOffer.IsBaseOffer
                && scsOffer.TierProvided == (int)TierEnum.FamilyGold
            )
            {
                return SetCurrentFamilySubscriptionHistory
                (
                  userId
                , offerId
                , catalogOfferId
                , catalogOfferInstanceId
                );
            }
            else
            {
                return SetCurrentSubscriptionHistoryOffer
                    (
                      userId
                    , offerId
                    , catalogOfferId
                    , catalogOfferInstanceId
                    );
            }
        }

        public static uint  SetCurrentFamilySubscriptionHistory(ulong userId, ulong offerId, Guid? catalogOfferId, Guid? catalogOfferInstanceId)
        {
            HResult hresult = HResult.S_OK;

            User primaryUser = new User();
            primaryUser.Load(userId);

            //Get the family members
            FamilyMember[] familyMembers = null;
            primaryUser.GetFamilyMembers(out familyMembers);

            using (TransactionScope tx = new TransactionScope())
            {
                //Go through every family member and set their current subscription history
                //If there is a non success return then return the first occurence of the error code for the caller to take action.
                foreach (FamilyMember item in familyMembers)
                {
                    if
                        (
                            (item.userFlags & FamilyDefs.FAMILY_OWNER) == FamilyDefs.FAMILY_OWNER
                        ||  (item.userFlags & FamilyDefs.FAMILY_SUBSCRIPTION_GOLD ) == FamilyDefs.FAMILY_SUBSCRIPTION_GOLD

                        )
                    {
                        hresult = SetCurrentSubscriptionHistoryOffer
                                   (
                                     item.userPuid
                                   , offerId
                                   , catalogOfferId
                                   , catalogOfferInstanceId
                                   );
                    }
                    //If failed then return the Hresult and back out of transaction
                    if (HResult.Failed(hresult))
                    {
                         return hresult;
                    }
                }
                tx.Complete();
            }

            return hresult;
            
        }

        public static uint SetCurrentSubscriptionHistoryOffer(ulong userId, ulong offerId)
        {
            Guid? catalogOfferId = null;

            Guid? catalogOfferInstanceId = null;

            return SetCurrentSubscriptionHistoryOffer
                (
                  userId
                , offerId
                , catalogOfferId
                , catalogOfferInstanceId
                );
        }

        //-----------------------------------------------------
        // SetCurrentSubscriptionHistoryOffer
        //
        //  This will insert a new row into t_subscription_history with the new offerId
        //  unless there is a current (ends in the future, must be enabled) row with that
        //  offerId already.
        //
        //  Furthermore, if there is a current row with a different offerId, it will be
        //  ended so that this new row will be the only current row.
        //
        public static uint SetCurrentSubscriptionHistoryOffer(ulong userId, ulong offerId, Guid? catalogOfferId, Guid? catalogOfferInstanceId)
        {
            WSClient ws = null;
            HResult hr = 0;

            if (userId != 0 && offerId != 0)
            {
                try
                {
                    ws = new WSClient(ConfigUtil.UodbWebstoreApp, CmdType.WRITEONLY_COMMANDTYPE);
                    ws.SetHashVal((long)userId);
                    ws.StoredProc = "dbo.p_xbos_move_subscription_history";

                    // intput and output params
                    ws.AddParameter(ParamType.RETVAL, "@RETVAL", 0);
                    ws.AddParameter(ParamType.INPUT, "@bi_user_puid", userId);
                    ws.AddParameter(ParamType.INPUT, "@bi_new_offer_id", offerId);
                    ws.AddParameter(ParamType.INPUT, "@si_hash_bucket", ws.Partition);

                    if (catalogOfferId.HasValue)
                    {
                        ws.AddParameter(ParamType.INPUT, "@uid_catalogoffer_id", catalogOfferId.Value);
                    }
                    if (catalogOfferInstanceId.HasValue)
                    {
                        ws.AddParameter(ParamType.INPUT, "@uid_catalog_offerinstance_id", catalogOfferInstanceId.Value);
                    }

                    // call the procedure
                    ws.ExecuteNonQuery();
                    AuditStream.Write(userId, AuditSubsystem.XBOS, ws, string.Empty);

                    hr = (uint)ws.GetIntParameter("@RETVAL");
                }
                finally
                {
                    if (ws != null)
                    {
                        ws.Close();
                        ws = null;
                    }
                }
            }

            return hr;
        }

        /// <summary>
        /// This method calls p_xbos_move_subscription_history_v2 which takes catalog guids and liveOfferId
        /// Difference with  SetCurrentSubscriptionHistoryOffer is that , v2 sproc uses the catalog guids
        /// to update the liveOfferId 
        /// </summary>
        public static uint SetCurrentSubscriptionHistoryOfferV2(ulong userId, Guid catalogOfferId, Guid catalogOfferInstanceId, ulong liveOfferId)
        {
            HResult hr = 0;

            if (userId != 0 && catalogOfferInstanceId != Guid.Empty)
            {
                using (WSClient ws = new WSClient(ConfigUtil.UodbWebstoreApp, CmdType.WRITEONLY_COMMANDTYPE))
                {
                    ws.SetHashVal((long)userId);
                    ws.StoredProc = "dbo.p_xbos_move_subscription_history_v2";

                    // intput and output params
                    ws.AddParameter(ParamType.RETVAL, "@RETVAL", 0);
                    ws.AddParameter(ParamType.INPUT, "@bi_user_puid", userId);
                    ws.AddParameter(ParamType.INPUT, "@uid_new_offer_id", catalogOfferId);
                    ws.AddParameter(ParamType.INPUT, "@uid_new_offer_instance_id", catalogOfferInstanceId);
                    ws.AddParameter(ParamType.INPUT, "@bi_offer_id", liveOfferId);
                    ws.AddParameter(ParamType.INPUT, "@si_hash_bucket", ws.Partition);


                    // call the procedure
                    ws.ExecuteNonQuery();
                    AuditStream.Write(userId, AuditSubsystem.XBOS, ws, string.Empty);

                    hr = (uint)ws.GetIntParameter("@RETVAL");
                }
            }
            return hr;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\marketplace\billing\Phone.cs ===
using System;
using System.Diagnostics;
using System.Xml;
using System.Text;
using System.IO;

using xonline.common.mgmt;
using xonline.common.protocol;
using xonline.common.service;

namespace xonline.common.billing
{
    public enum PhoneTypesEnum
    {
        Primary = 0,
        Work,
        Home,
        Mobile,
        Fax
    }

    public class Phone
    {
        private static string[] PhoneTypes = new string[] {  "PRIMARY",
                                                             "WORK",
                                                             "HOME",
                                                             "MOBILE",
                                                             "FAX" };

        // The following fields must be filled in to Create an account.
        public string   AreaCode;
        public string   PhoneNumber;
        public string   PhoneExtension;
        public string   CountryCode;
        public PhoneTypesEnum PhoneType;

        public Phone()
        {
            PhoneType = PhoneTypesEnum.Primary;
            CountryCode = "US";                          // defaults to USA
        }


        public void FromXml(string xml, string rootNodeName)
        {
            XmlTextReader xmlReader = new XmlTextReader(new StringReader(xml));
            FromXml(xmlReader, rootNodeName);
            xmlReader.Close();
        }

        public void FromXml(XmlTextReader xmlReader, string rootNodeName)
        {
            xmlReader.MoveToContent();
            while (!xmlReader.EOF)
            {
                if (xmlReader.NodeType == XmlNodeType.EndElement &&
                    xmlReader.Name == rootNodeName)
                {
                    xmlReader.Skip();
                    break;
                }

                if (xmlReader.NodeType != XmlNodeType.Element)
                {
                    xmlReader.Skip();
                    continue;
                }

                switch (xmlReader.Name)
                {
                    case "PhonePrefix":
                        AreaCode = xmlReader.ReadElementString();
                        break;

                    case "PhoneNumber":
                        PhoneNumber = xmlReader.ReadElementString();
                        break;

                    case "PhoneExtension":
                        PhoneExtension = xmlReader.ReadElementString();
                        break;

                    case "CountryCode":
                        CountryCode = xmlReader.ReadElementString();
                        break;

                    case "PhoneType":
                        PhoneType = (PhoneTypesEnum)Array.IndexOf(PhoneTypes, xmlReader.ReadElementString());
                        if( PhoneType < 0 ) PhoneType = PhoneTypesEnum.Primary;
                        break;

                    default:
                        if (xmlReader.Name == rootNodeName)
                        {
                            // advance to the first inner element
                            xmlReader.ReadStartElement();
                            break;
                        }

                        Xom.Trace(XomAreaName.spstrace, LogLevel.L_NORMAL, "Phone: Unrecognized Xml element: " + xmlReader.Name );
                        xmlReader.Skip();
                        break;
                }
            }
        }


        public string ToXml(string rootNodeName)
        {
            StringBuilder xmlBldr = new StringBuilder();
            ToXml(xmlBldr, rootNodeName);
            return xmlBldr.ToString();
        }

        public void ToXml(StringBuilder xmlBldr, string rootNodeName)
        {
            Debug.Assert(xmlBldr != null, "Invalid Argument");

            xmlBldr.Append("<" + (rootNodeName == null ? "Phone" : rootNodeName) + ">");
            xmlBldr.Append("<PhoneType>");
            xmlBldr.Append(PhoneTypes[(int)PhoneType]);
            xmlBldr.Append("</PhoneType>");

            if ( AreaCode != null )
            {
                xmlBldr.Append("<PhonePrefix>");
                xmlBldr.Append(XmlCleanser.Cleanup(AreaCode));
                xmlBldr.Append("</PhonePrefix>");
            }

            if ( PhoneNumber != null )
            {
                xmlBldr.Append("<PhoneNumber>");
                xmlBldr.Append(XmlCleanser.Cleanup(PhoneNumber));
                xmlBldr.Append("</PhoneNumber>");
            }

            if ( PhoneExtension != null )
            {
                xmlBldr.Append("<PhoneExtension>");
                xmlBldr.Append(XmlCleanser.Cleanup(PhoneExtension));
                xmlBldr.Append("</PhoneExtension>");
            }

            xmlBldr.Append("<CountryCode>");
            xmlBldr.Append(XmlCleanser.Cleanup(CountryCode));
            xmlBldr.Append("</CountryCode>");
            xmlBldr.Append("</" + (rootNodeName == null ? "Phone" : rootNodeName) + ">");
        }

        // Returns a new instance of PhoneInfoData populated with data from
        // the current phone instance.
        public PhoneInfoData ToWireData()
        {
            PhoneInfoData phoneInfo = new PhoneInfoData();

            phoneInfo.phonePrefix = AreaCode;
            phoneInfo.phoneNumber = PhoneNumber;
            phoneInfo.phoneExtension = PhoneExtension;

            return phoneInfo;
        }

        // Populates Phone property data with data from the given PhoneInfoData
        // instance.
        public void FromWireData(PhoneInfoData phoneInfo)
        {
            AreaCode = phoneInfo.phonePrefix;
            PhoneNumber = phoneInfo.phoneNumber;
            PhoneExtension = phoneInfo.phoneExtension;
        }

        // validates required fieds have been set before generating xml.
        // (should this be debug only?)
        public void ValidateFields(bool isUpdate)
        {
            // phone info is now optional but if it is supplied, both area
            // code (aka prefix) and phone number must be supplied.
            if ( AreaCode != "" || PhoneNumber != "" )
            {
                if (AreaCode == "")     throw new XRLExceptionWithoutEvent(HResult.XONLINE_E_BILLING_AREA_CODE_NOT_FOUND_ERROR, "Missing Phone.AreaCode");
                if (PhoneNumber == "")  throw new XRLExceptionWithoutEvent(HResult.XONLINE_E_BILLING_PHONE_NUMBER_NOT_FOUND_ERROR, "Missing Phone.PhoneNumber");
            }
            if (CountryCode == null)    throw new XRLExceptionWithoutEvent(HResult.XONLINE_E_BILLING_COUNTRY_ID_NOT_FOUND, "Missing Phone.CountryCode");

            /*
            if (isUpdate)
            {
                if (Id == 0)   throw new Exception("Missing Phone.Id");
            }
            */

        }

        public override string ToString()
        {
            string a;

            a = "AreaCode: " + AreaCode +
                "\nPhoneNumber: " + PhoneNumber +
                "\nPhoneExtension: " + PhoneExtension +
                "\nCountryCode: " + CountryCode +
                "\nPhoneType: " + PhoneTypes[(int)PhoneType];

            return a;
        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\marketplace\billing\PurchaseItem.cs ===
using System;
using System.Collections.Generic;
using System.IO;
using System.Xml;
using System.Xml.Serialization;

using xonline.common.config;
using xonline.common.mgmt;
using xonline.common.offer;
using xonline.common.service;
using xonline.common.sql.webstore;
using xonline.common.user;

using Microsoft.Webstore.WstClient;

namespace xonline.common.billing
{
    // the following struct-like classes are used only
    // for passing data around between functions

    public class SCSItemDetails
    {
        public int CampaignID;
        public uint OfferType;
        public string BillingOfferID;
    }

    public class SCSRetryablePurchase
    {
        public ulong    OfferID;
        public ulong    UserPuid;
        public ulong    UserPassportPuid;
        public string   AccountID;
        public ulong    MachinePuid;
        public int      CountryID;
        public int      TierRequired;
        public string   PaymentInstrumentID;
        public string   EncryptedPassword;
        public string   Token;
        public byte[]   TokenHash;
        public Guid     TransactionGuid;
        public string   AlternateUrl;
        public uint     OfferType;
        public Guid     OfferInstanceId;
        public string   BillingOfferId;
        public string   IpAddress;
        public string   DeviceId;
    }

    public class XmlTextWriterMinimalist : System.Xml.XmlTextWriter
    {
        public XmlTextWriterMinimalist(System.IO.TextWriter w) : base(w)
        {
        }

        public override void WriteStartDocument()
        {
            // suppress writing "<?xml version="1.0"?>"
        }

        public override void WriteWhitespace(string ws)
        {
            // suppress whitespace in xml
        }
    }

    public class SCSPurchaseItem
    {
        BillingProvider m_billingProvider;

        public SCSPurchaseItem()
        {
            m_billingProvider = new BillingProvider();
        }

        public SCSPurchaseItem(BillingProvider billingProvider)
        {
            m_billingProvider = billingProvider;
        }

        public static string ConvertObjectToXml(Object serializableObject)
        {
            XmlSerializer serializer = new XmlSerializer(serializableObject.GetType());
            StringWriter stringWriter = new StringWriter();
            XmlTextWriterMinimalist xmlWriter = new XmlTextWriterMinimalist(stringWriter);
            string xml = null;
            try
            {
                serializer.Serialize(xmlWriter, serializableObject);
                xml = stringWriter.ToString();
            }
            finally
            {
                xmlWriter.Close();
                stringWriter.Close();
            }
            return xml;
        }


        public void TryPurchase(Guid trackingGuid, ulong userPuid, ulong machinePuid, ulong userPassportPuid,
            string accountID, ulong offerID, string paymentInstrumentID, string token, string encryptedPassword, int countryID, int tierRequired, string billingOfferId)
        {
            TryPurchase(trackingGuid, userPuid, machinePuid, userPassportPuid, accountID, offerID, paymentInstrumentID,
                token, encryptedPassword, countryID, tierRequired, false, null, billingOfferId);
        }

        public void TryPurchase(Guid trackingGuid, ulong userPuid, ulong machinePuid, ulong userPassportPuid,
            string accountID, ulong offerID, string paymentInstrumentID, string token, string encryptedPassword, int countryID, int tierRequired,
            bool retryingPurchase, byte[] tokenHash, string billingOfferId)
        {
            PaymentTypeEnum paymentType;

            if ((paymentInstrumentID != null) && (token == null) && (encryptedPassword == null))
                paymentType = PaymentTypeEnum.CreditCard;
            else if ((paymentInstrumentID != null) && (token == null) && (encryptedPassword != null))
                paymentType = PaymentTypeEnum.Wholesale;
            else if ((paymentInstrumentID == null) && (token != null) && (encryptedPassword == null))
                paymentType = PaymentTypeEnum.Token;
            else
            {
                throw new XRLException(HResult.E_INVALIDARG, XEvent.Id.COMMON_BILLING_CODE_203,
                    "SCSPurchaseItem: invalid combination of paymentInstrumentID, token and encryptedPassword"
                );
            }
            //check for offerPurchaseInfos and retrieve the billingOfferId. Older clients will have offerPurchaseInfos null.
            //This check ensures that older and the newer clients can work side by side 
            if (string.IsNullOrEmpty(billingOfferId))
            {
                SCSItemDetails details = GetSCSOfferItemDetails(offerID, countryID, paymentType, tierRequired);
                billingOfferId = details.BillingOfferID;
            }

            uint userPassportPuidHigh = 0;
            uint userPassportPuidLow = 0;
            Int64Convert.ToUintPair((long) userPassportPuid, out userPassportPuidHigh, out userPassportPuidLow);

            Item item = new Item();
            item.InternalId = billingOfferId;
            item.ExternalId = DMPClient.GenerateExternalID(offerID, countryID, tierRequired, 0);

            ItemSet itemSet = new ItemSet();
            itemSet.Item = new Item[1];
            itemSet.Item[0] = item;
            string itemSetXml = ConvertObjectToXml(itemSet);

            PaymentMethod paymentMethod = new PaymentMethod();
            paymentMethod.AccountId = accountID;

            if (paymentType == PaymentTypeEnum.Token)
            {
                paymentMethod.TokenId = token;
            }
            else if (paymentType != PaymentTypeEnum.Wholesale)
            {
                paymentMethod.PaymentInstrumentId = paymentInstrumentID;
            }
            else
            {
                paymentMethod.PaymentInstrumentId = paymentInstrumentID;
                paymentMethod.EncryptedPassword = encryptedPassword;
            }

            string paymentMethodXml = ConvertObjectToXml(paymentMethod);

            TransactionContext transactionContext = new TransactionContext();
            transactionContext.ExternalReferenceId = trackingGuid.ToString();
            transactionContext.PostingDate = DateTime.UtcNow.ToString("s");
            transactionContext.CampaignId = -1;
            transactionContext.ClientAddress = machinePuid.ToString("x");
            string transactionContextXml = ConvertObjectToXml(transactionContext);

            // The exception handling for initial purchase calls differs
            // significantly from the exception handling for retries so
            // they are handled in separate methods
            if ( retryingPurchase )
            {
                RetryPurchaseItem(userPuid, userPassportPuidHigh, userPassportPuidLow, trackingGuid, itemSetXml, paymentMethodXml, transactionContextXml, tokenHash);
            }
            else
            {
                InitialPurchaseItem(userPuid, userPassportPuidHigh, userPassportPuidLow, trackingGuid, itemSetXml, paymentMethodXml, transactionContextXml);
            }
        }

        protected void InitialPurchaseItem(ulong userPuid, uint puidHigh, uint puidLow, Guid trackingGuid, string itemSetXml, string paymentMethodXml, string transactionContextXml)
        {
            try
            {
                string receiptXml = "";

                m_billingProvider.PurchaseItem(
                    0,
                    0,
                    (int)puidHigh,
                    (int)puidLow,
                    trackingGuid.ToString(),
                    itemSetXml,
                    paymentMethodXml,
                    transactionContextXml,
                    out receiptXml);

                RecordPurchaseItemSuccess(userPuid, trackingGuid, receiptXml);
            }

            catch (Exception e)
            {
                if (FastFailHelper.ConsiderExceptionAsTimeout(e))
                {
                    //
                    // If we receive a timeout, it's likely that the credit card was
                    // charged, token consumed, etc. so we can't simply fail.
                    //
                    // Instead, assume success, swallow the error and retry the call
                    // again later.
                    //

                    Xom.NtEvent(XEvent.Id.QUEUE_FAILURE_AUTO_FIX, e,
                        "SCS::PurchaseItem timed-out.. the queue will retry the call again later"
                    );
                }
                else
                {
                    HResult hr = HResult.E_FAIL;

                    hr = BillingProviderException.ToHResult(e, hr);

                    int status = (int)DMPClient.DMPTransactionStatus.Failed;

                    RecordPurchaseItemResult(userPuid, trackingGuid, status,
                        "", (uint)hr, "Exception", e.Message, DateTime.UtcNow);

                    throw;
                }
            }

        }

        protected void RetryPurchaseItem(ulong userPuid, uint puidHigh, uint puidLow, Guid trackingGuid, string itemSetXml, string paymentMethodXml, string transactionContextXml, byte[] tokenHash)
        {
            try
            {
                string receiptXml = "";

                m_billingProvider.PurchaseItem(
                    0,
                    0,
                    (int) puidHigh,
                    (int) puidLow,
                    trackingGuid.ToString(),
                    itemSetXml,
                    paymentMethodXml,
                    transactionContextXml,
                    out receiptXml);

                RecordPurchaseItemSuccess(userPuid, trackingGuid, receiptXml);
            }
            catch (Exception e)
            {
                HResult hr = HResult.E_FAIL;

                hr = BillingProviderException.ToHResult(e, hr);

                string errorCode = e.GetType().Name;

                bool isRetryableError = true;

                //
                // If the exception is an exception from SCS and it is not flagged
                // as Retryable, move the transaction into the RetryFailed state.
                //
                // Otherwise, leave the transaction in the Pending state so it will
                // be reattempted again.
                //
                if ( e is BillingProviderException )
                {
                    isRetryableError = ((BillingProviderException)e).IsRetryable;
                }

                int status = isRetryableError ? (int) DMPClient.DMPTransactionStatus.Pending :
                    (int) DMPClient.DMPTransactionStatus.RetryFailed;

                // if the error SCS returned is non-retryable and a token was used, the
                // token needs to be unconsumed
                if ( isRetryableError == false && tokenHash != null )
                {
                    Xom.Trace(XomAreaName.spstrace, LogLevel.L_HIGH, string.Format("RetryPurchaseItem: retry of SCS.PurchaseItem encountered non-retryable error: 0x{0} from SCS - marking token unconsumed for user: 0x{1}", hr.ToString(), userPuid.ToString("x")));

                    // If an error is encountered unconsuming the token, log an event
                    // but rethrow the original exception and leave the item in the Pending
                    // state so it will be retried.
                    try
                    {
                        VoucherUtil.UnregisterVoucherUse(tokenHash, userPuid);
                    }
                    catch (Exception ee)
                    {
                        Xom.NtEvent(XEvent.Id.SCS_QUEUE_FAILED_TO_UNCONSUME_TOKEN, ee,
                            "RetryPurchaseItem: failed to unconsume token for user: 0x{0}, encountered exception:\r\n{1}", (Puid) userPuid
                        );

                        throw e;
                    }
                }

                RecordPurchaseItemResult(userPuid, trackingGuid, status,
                                         "", (uint) hr, errorCode, e.Message, DateTime.UtcNow);

                throw;
            }
        }

        public Guid Purchase(ulong userPuid, ulong machinePuid, ulong userPassportPuid, string accountID,
            ulong offerID, string paymentInstrumentID, string token, byte[] tokenHash, string encryptedPassword, int countryID, int tierRequired, List<OfferInfo> offerInfos)
        {
            DateTime postingDate = DateTime.UtcNow;
            Guid trackingGuid = Guid.NewGuid();

            string alternateUrl = BillingProvider.GetSessionAlternateUrl();

            // encrypt the token prior to recording it in the database
            if (!string.IsNullOrEmpty(token))
            {
                BillingProvider bdk = new BillingProvider();
                token = bdk.EncryptNumber(token);
            }

            RecordPurchaseItemIntent(userPuid, machinePuid, offerID, paymentInstrumentID, token, tokenHash, encryptedPassword, trackingGuid,
                postingDate, alternateUrl, offerInfos);

            //Offerinfos are passed by newer client, we pass the billingOfferId only if the OfferInfo is present
            TryPurchase(trackingGuid, userPuid, machinePuid, userPassportPuid, accountID, offerID, paymentInstrumentID,
                token, encryptedPassword, countryID, tierRequired, (offerInfos!=null&&offerInfos.Count>0)?offerInfos[0].billingOfferId:null);

            return trackingGuid;
        }

        protected static void RecordPurchaseItemSuccess(ulong userPuid, Guid trackingGuid, string receiptXml)
        {
            try
            {
                XmlSerializer s = new XmlSerializer(typeof(Receipt));
                XmlReader r = new XmlTextReader(new StringReader(receiptXml));
                Receipt receipt = (Receipt) s.Deserialize(r);

                RecordPurchaseItemResult(userPuid, trackingGuid, (int) DMPClient.DMPTransactionStatus.Success,
                    receipt.ItemReceiptSet[0].ItemInstanceId, HResult.S_OK, "", "", DateTime.UtcNow);
            }
            catch (Exception e)
            {
                // if this fails, do nothing--the worker threads will try to purchaseitem again later,
                // and will update the result at that time

                Xom.NtEvent(XEvent.Id.QUEUE_FAILURE_AUTO_FIX, e,
                    "Recording SCS::PurchaseItem result failed.. queue will retry SCS::PurchaseItem later."
                );
            }
        }

        protected static SCSItemDetails GetSCSOfferItemDetails(ulong offerID, int countryID, PaymentTypeEnum paymentType,
            int tierRequired)
        {
            using(WSClient ws = new WSClient(ConfigUtil.UodbWebstoreApp, CmdType.WRITETHENREAD_COMMANDTYPE))
            {
                ws.PartitionType   = WstPartitionType.Logical;
                ws.Partition       = WstCommand.AnyPartition;

                ws.StoredProc = "dbo.p_xbos_get_offer_scs_item_details";

                ws.AddParameter(ParamType.RETVAL, "@RETVAL", 0);
                ws.AddParameter("@bi_offer_id", offerID);
                ws.AddParameter("@i_country_id", countryID);
                ws.AddParameter("@i_payment_type_id", (int) paymentType);
                ws.AddParameter("@i_tier_required", tierRequired);

                using (WstDataReader r = ws.Execute())
                {
                    SCSItemDetails details = new SCSItemDetails();

                    if (r.Read())
                    {
                        details.CampaignID = r.GetInt32(0);
                        details.OfferType = (uint) r.GetInt32(1);
                        details.BillingOfferID = r.GetString(2);
                    }

                    r.Close();

                    HResult hr = (uint)ws.GetIntParameter("@RETVAL");
                    if (HResult.Failed(hr))
                    {
                        string msg = ws.GetCallSignature() + " failed with hr = " + hr;

                        Xom.Trace(XomAreaName.spstrace, LogLevel.L_ERROR, msg);

                        throw new XRLException(hr, XEvent.Id.COMMON_BILLING_CODE_204, msg);
                    }

                    return details;
                }
            }
        }

        public static SCSRetryablePurchase GetPurchaseForRetry(int partition, uint expiredSeconds,
            uint considerFailedSeconds, out bool keepGoing)
        {
            keepGoing = false;

            using(WSClient ws = new WSClient(ConfigUtil.GetUserCommerceWebstoreApp(), CmdType.WRITETHENREAD_COMMANDTYPE))
            {
                ws.StoredProc = "dbo.p_xbos_get_scs_purchaseitem_for_retry_v2";
                ws.PhysicalPartition = partition;

                ws.AddParameter(ParamType.RETVAL, "@hr", 0);
                ws.AddParameter("@i_expired_seconds", expiredSeconds);
                ws.AddParameter("@i_consider_failed_seconds", considerFailedSeconds);

                using (WstDataReader r = ws.Execute())
                {
                    SCSRetryablePurchase retryablePurchase = null;

                    if (r.Read())
                    {
                        retryablePurchase = new SCSRetryablePurchase();

                        int columnNumber = 0;
                        retryablePurchase.OfferID = (ulong) r.GetInt64(columnNumber++);
                        retryablePurchase.UserPuid = (ulong) r.GetInt64(columnNumber++);
                        retryablePurchase.MachinePuid = (ulong) r.GetInt64(columnNumber++);
                        retryablePurchase.PaymentInstrumentID = r.GetString(columnNumber++);
                        if (retryablePurchase.PaymentInstrumentID == string.Empty)
                            retryablePurchase.PaymentInstrumentID = null;
                        retryablePurchase.Token = r.GetString(columnNumber++);
                        if (retryablePurchase.Token == string.Empty)
                            retryablePurchase.Token = null;
                        retryablePurchase.TransactionGuid = r.GetGuid(columnNumber++);
                        retryablePurchase.AlternateUrl = r.GetString(columnNumber++);
                        if (retryablePurchase.AlternateUrl == string.Empty)
                            retryablePurchase.AlternateUrl = null;
                        retryablePurchase.EncryptedPassword = r.GetString(columnNumber++);
                        if (retryablePurchase.EncryptedPassword == string.Empty)
                            retryablePurchase.EncryptedPassword = null;
                       

                        // TokenHash will either be NULL or a 20 byte array
                        if (!r.IsDBNull(columnNumber))
                        {
                            long numBytes = r.GetBytes(columnNumber, 0, null, 0, 0);
                            byte[] hashBytes = new byte[numBytes];
                            r.GetBytes(columnNumber, 0, hashBytes, 0, hashBytes.Length);

                            retryablePurchase.TokenHash = hashBytes;

                            columnNumber++;
                        }
                        else
                        {
                            columnNumber++;
                        }

                        // load user info from UODB to fill in details not found in UserCommerceDb
                        User u = new User();
                        u.Load(retryablePurchase.UserPuid);

                        retryablePurchase.UserPassportPuid = u.PassportPuid;
                        retryablePurchase.AccountID = u.AccountId;
                        retryablePurchase.CountryID = u.CountryId;
                        retryablePurchase.TierRequired = u.Tier;

                        if (!r.IsDBNull(columnNumber))
                        {
                            retryablePurchase.OfferInstanceId = r.GetGuid(columnNumber);
                            columnNumber++;
                        }
                        else
                        {
                            columnNumber++;
                        }
                        if (!r.IsDBNull(columnNumber))
                        {
                            retryablePurchase.BillingOfferId = r.GetGuid(columnNumber).ToString();
                            columnNumber++;
                        }
                        else
                        {
                            retryablePurchase.BillingOfferId = null;
                            columnNumber++;
                        }

                        //IP Address
                        retryablePurchase.IpAddress = r.GetString(columnNumber++);
                        //Device Id
                        retryablePurchase.DeviceId = r.GetString(columnNumber++);
                    }
                    r.Close();

                    HResult hr = (uint)ws.GetIntParameter("@hr");
                    if (HResult.Failed(hr))
                    {
                        string msg = ws.GetCallSignature() + " failed with hr = " + hr;

                        Xom.Trace(XomAreaName.dmptrace, LogLevel.L_ERROR, msg);

                        throw new XRLException(hr, XEvent.Id.COMMON_BILLING_CODE_205, msg);
                    }

                    if (hr == HResult.XONLINE_S_DMP_RETRY_INTERVAL_EXCEEDED)
                    {
                        keepGoing = true;
                    }

                    return retryablePurchase;


                }
            }
        }

        public static int GetRetryablePurchaseCount(int partition, uint expiredSeconds)
        {
            using (WSClient ws = new WSClient(ConfigUtil.GetUserCommerceWebstoreApp(), CmdType.WRITETHENREAD_COMMANDTYPE))
            {
                ws.StoredProc = "dbo.p_xbos_get_scs_purchaseitem_retry_count";
                ws.PhysicalPartition = partition;

                ws.AddParameter(ParamType.RETVAL, "@hr", 0);
                ws.AddParameter("@i_expired_seconds", expiredSeconds);

                using (WstDataReader r = ws.Execute())
                {
                    int count = 0;

                    if (r.Read())
                    {
                        count = r.GetInt32(0);
                    }

                    r.Close();

                    HResult hr = (uint)ws.GetIntParameter("@hr");
                    if (HResult.Failed(hr))
                    {
                        string msg = ws.GetCallSignature() + " failed with hr = " + hr;

                        Xom.Trace(XomAreaName.spstrace, LogLevel.L_ERROR, msg);

                        throw new XRLException(hr, XEvent.Id.COMMON_BILLING_CODE_206, msg);
                    }

                    return count;
                }
            }
        }

        protected static void RecordPurchaseItemIntent(ulong userPuid, ulong machinePuid, ulong offerID,
            string paymentInstrumentID, string token, byte[] tokenHash, string encryptedPassword, Guid trackingGuid, DateTime postingDate, string alternateUrl, List<OfferInfo> offerInfos)
        {
            using (WSClient ws = new WSClient(ConfigUtil.GetUserCommerceWebstoreApp(), CmdType.WRITEONLY_COMMANDTYPE))
            {
                // Data is partitioned by user puid
                ws.PartitionType = WstPartitionType.Logical;
                ws.SetHashVal(userPuid);

                ws.StoredProc = "dbo.p_scs_record_purchaseitem_intent";

                ws.AddParameter(ParamType.RETVAL, "@hr", 0);
                ws.AddParameter("@bi_user_puid", userPuid);
                ws.AddParameter("@bi_machine_puid", machinePuid);
                ws.AddParameter("@bi_offer_id", offerID);
                ws.AddParameter("@vc_billing_payment_id", paymentInstrumentID != null ? paymentInstrumentID : string.Empty);
                ws.AddParameter("@vc_billing_token", token != null ? token : string.Empty);
                ws.AddParameter("@vc_encrypted_password", encryptedPassword != null ? encryptedPassword : string.Empty);
                ws.AddParameter("@uid_tracking_guid", trackingGuid.ToString());
                ws.AddParameter("@dt_posting_date", postingDate);
                ws.AddParameter("@vc_alternate_url", alternateUrl != null ? alternateUrl : string.Empty);
                ws.AddParameter("@si_hash_bucket", ws.Partition);

                //Add offerInstanceId,billingOfferId only if it is passed in . Older clients would always pass offerInfos as null.
                //Newer client would pass offerInfos from catalog.
                if (offerInfos != null && offerInfos.Count>0)
                {
                    ws.AddParameter("@uid_offer_instance_id", offerInfos[0].offerInstanceId);
                    ws.AddParameter("@vc_billing_offer_id", offerInfos[0].billingOfferId);
                }

                if ( tokenHash != null )
                {
                    ws.AddParameter("@bin_token_hash", tokenHash);
                }

                if (SGInfo.Current != null)
                {
                    ws.AddParameter("@vc_ip_address",SGInfo.Current.ClientIP.ToString());
                    ws.AddParameter("@vc_device_id", SGInfo.Current.MachineId.ToString("x"));

                }
                ws.ExecuteNonQuery();

                HResult hr = (uint)ws.GetIntParameter("@hr");
                if (HResult.Failed(hr))
                {
                    string msg = ws.GetCallSignature() + " failed with hr = " + hr;

                    Xom.Trace(XomAreaName.spstrace, LogLevel.L_ERROR, msg);

                    throw new XRLException(hr, XEvent.Id.COMMON_BILLING_CODE_207, msg);
                }
            }
        }

        protected static void RecordPurchaseItemResult(ulong userPuid, Guid trackingGuid, int statusID, string itemInstanceID,
            HResult hresult, string errorCode, string errorXML, DateTime confirmationDate)
        {
            using(WSClient ws = new WSClient(ConfigUtil.GetUserCommerceWebstoreApp(), CmdType.WRITEONLY_COMMANDTYPE))
            {
                // Data is partitioned by user puid
                ws.PartitionType = WstPartitionType.Logical;
                ws.SetHashVal(userPuid);

                ws.StoredProc = "dbo.p_scs_record_purchaseitem_result";

                ws.AddParameter(ParamType.RETVAL, "@hr", 0);
                ws.AddParameter("@uid_tracking_guid", trackingGuid.ToString());
                ws.AddParameter("@i_status_id", statusID);
                ws.AddParameter("@vc_item_instance_id", itemInstanceID);
                ws.AddParameter("@i_hresult", hresult);
                ws.AddParameter("@vc_error_code", errorCode);
                ws.AddParameter("@vc_error_xml", errorXML);
                ws.AddParameter("@dt_transaction_end", confirmationDate);

                ws.ExecuteNonQuery();

                HResult hr = (uint)ws.GetIntParameter("@hr");
                if (HResult.Failed(hr))
                {
                    string msg = ws.GetCallSignature() + " failed with hr = " + hr;

                    Xom.Trace(XomAreaName.spstrace, LogLevel.L_ERROR, msg);

                    throw new XRLException(hr, XEvent.Id.COMMON_BILLING_CODE_208, msg);
                }
            }
        }

        public static bool UserHasAnyPendingPointsPurchases(ulong userPuid)
        {
            using (WSClient ws = new WSClient(ConfigUtil.GetUserCommerceWebstoreApp(), CmdType.WRITEONLY_COMMANDTYPE))
            {
                // Data is partitioned by user puid
                ws.PartitionType = WstPartitionType.Logical;
                ws.SetHashVal(userPuid);

                ws.StoredProc = "dbo.p_scs_user_has_pending_points_purchases";

                ws.AddParameter(ParamType.RETVAL, "@hr", 0);
                ws.AddParameter("@bi_user_puid", userPuid);

                ws.ExecuteNonQuery();

                return (ws.GetIntParameter("@hr") == 1);
            }
        }

        [System.Xml.Serialization.XmlTypeAttribute(Namespace="urn:schemas-microsoft-com:billing-data")]
        [System.Xml.Serialization.XmlRootAttribute(Namespace="urn:schemas-microsoft-com:billing-data", IsNullable=false)]
        public class ItemSet {


            [System.Xml.Serialization.XmlElementAttribute("Item")]
            public Item[] Item;
        }


        [System.Xml.Serialization.XmlTypeAttribute(Namespace="urn:schemas-microsoft-com:billing-data")]
        [System.Xml.Serialization.XmlRootAttribute(Namespace="urn:schemas-microsoft-com:billing-data", IsNullable=false)]
        public class Item {


            public string InternalId;


            public string ExternalId;
        }

        [System.Xml.Serialization.XmlTypeAttribute(Namespace = "urn:schemas-microsoft-com:billing-data")]
        [System.Xml.Serialization.XmlRootAttribute(Namespace = "urn:schemas-microsoft-com:billing-data", IsNullable = false)]
        public class CreditCardData {
        }

        [System.Xml.Serialization.XmlTypeAttribute(Namespace = "urn:schemas-microsoft-com:billing-data")]
        [System.Xml.Serialization.XmlRootAttribute(Namespace = "urn:schemas-microsoft-com:billing-data", IsNullable = false)]
        public class WholesaleData {
            public string EncryptedPassword;
        }

        [System.Xml.Serialization.XmlTypeAttribute(Namespace = "urn:schemas-microsoft-com:billing-data")]
        [System.Xml.Serialization.XmlRootAttribute(Namespace = "urn:schemas-microsoft-com:billing-data", IsNullable = false)]
        public class PaymentInstrumentData {

            public CreditCardData CreditCardData;
            public WholesaleData  WholesaleData;

            [XmlIgnore]
            public string EncryptedPassword
            {
                get
                {
                    if (WholesaleData == null) return null;
                    return WholesaleData.EncryptedPassword;
                }

                set
                {
                    if (WholesaleData == null) WholesaleData = new WholesaleData();
                    WholesaleData.EncryptedPassword = value;
                }
            }
        }

        [System.Xml.Serialization.XmlTypeAttribute(Namespace="urn:schemas-microsoft-com:billing-data")]
        [System.Xml.Serialization.XmlRootAttribute(Namespace="urn:schemas-microsoft-com:billing-data", IsNullable=false)]
        public class PaymentMethod {


            public string AccountId;


            public string PaymentInstrumentId;


            public string TokenId;

            public PaymentInstrumentData PaymentInstrumentData;

            [XmlIgnore]
            public string EncryptedPassword {
                get {
                    if (PaymentInstrumentData == null) return null;
                    return PaymentInstrumentData.EncryptedPassword;
                }

                set {
                    if (PaymentInstrumentData == null) PaymentInstrumentData = new PaymentInstrumentData();
                    PaymentInstrumentData.EncryptedPassword = value;
                }
            }
        }

        [System.Xml.Serialization.XmlTypeAttribute(Namespace="urn:schemas-microsoft-com:billing-data")]
        [System.Xml.Serialization.XmlRootAttribute(Namespace="urn:schemas-microsoft-com:billing-data", IsNullable=false)]
        public class TransactionContext {


            public string ExternalReferenceId;


            public string PostingDate;


            public int CampaignId;


            public string ClientAddress;


            public ReferralInfo ReferralInfo;
        }


        [System.Xml.Serialization.XmlTypeAttribute(Namespace="urn:schemas-microsoft-com:billing-data")]
        [System.Xml.Serialization.XmlRootAttribute(Namespace="urn:schemas-microsoft-com:billing-data", IsNullable=false)]
        public class ReferralInfo {


            [System.Xml.Serialization.XmlArrayItemAttribute("ReferralCode", IsNullable=false)]
            public string[] ReferralCodeSet;


            public string ReferralReferenceId;
        }


        [System.Xml.Serialization.XmlTypeAttribute(Namespace="urn:schemas-microsoft-com:billing-data")]
        [System.Xml.Serialization.XmlRootAttribute(Namespace="urn:schemas-microsoft-com:billing-data", IsNullable=false)]
        public class ReferralCodeSet {


            [System.Xml.Serialization.XmlElementAttribute("ReferralCode")]
            public string[] ReferralCode;
        }

        [System.Xml.Serialization.XmlTypeAttribute(Namespace="urn:schemas-microsoft-com:billing-data")]
        [System.Xml.Serialization.XmlRootAttribute(Namespace="urn:schemas-microsoft-com:billing-data", IsNullable=false)]
        public class Receipt {


            [System.Xml.Serialization.XmlArrayItemAttribute(IsNullable=false)]
            public ItemReceipt[] ItemReceiptSet;


            public RedirectOutputInfo RedirectOutputInfo;
        }


        [System.Xml.Serialization.XmlTypeAttribute(Namespace="urn:schemas-microsoft-com:billing-data")]
        [System.Xml.Serialization.XmlRootAttribute(Namespace="urn:schemas-microsoft-com:billing-data", IsNullable=false)]
        public class ItemReceipt {


            public AmountCharged AmountCharged;


            public string ItemInstanceId;
        }


        [System.Xml.Serialization.XmlTypeAttribute(Namespace="urn:schemas-microsoft-com:billing-data")]
        [System.Xml.Serialization.XmlRootAttribute(Namespace="urn:schemas-microsoft-com:billing-data", IsNullable=false)]
        public class RedirectOutputInfo {


            public string RedirectURL;


            public string ConfirmationNumber;


            public string EncryptedInfo;


            public string ContextInfo;
        }

        [System.Xml.Serialization.XmlTypeAttribute(Namespace="urn:schemas-microsoft-com:billing-data")]
        [System.Xml.Serialization.XmlRootAttribute(Namespace="urn:schemas-microsoft-com:billing-data", IsNullable=false)]
        public class AmountCharged {


            public System.Decimal Gross;


            public System.Decimal Charge;


            public string Locale;


            public string Currency;


            [System.Xml.Serialization.XmlArrayItemAttribute("Tax", IsNullable=false)]
            public taxSet25TypeTax[] TaxSet;


            public chargeStatusType ChargeStatus;
        }

        [System.Xml.Serialization.XmlTypeAttribute(Namespace="urn:schemas-microsoft-com:billing-data")]
        public enum chargeStatusType {


            SUCCESS,


            FAIL,


            PENDING,


            COMPUTE,
        }

        [System.Xml.Serialization.XmlTypeAttribute(Namespace="urn:schemas-microsoft-com:billing-data")]
        public class taxSet25TypeTax {


            public taxType TaxType;


            public System.Decimal TaxAmount;


            public string Rate;


            public Exempt Exempt;
        }


        [System.Xml.Serialization.XmlTypeAttribute(Namespace="urn:schemas-microsoft-com:billing-data")]
        public enum taxType {


            CITY,


            CITY2,


            COUNTRY,


            COUNTY,


            COUNTY2,


            DISTRICT,


            GST,


            PST,


            STATE,


            STATE2,


            TERRITORY,


            VAT,
        }


        [System.Xml.Serialization.XmlTypeAttribute(Namespace="urn:schemas-microsoft-com:billing-data")]
        [System.Xml.Serialization.XmlRootAttribute(Namespace="urn:schemas-microsoft-com:billing-data", IsNullable=false)]
        public enum Exempt {


            TRUE,


            FALSE
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\marketplace\billing\PermitSet.cs ===
//
// Copyright (c) Microsoft Corporation. All Rights Reserved.
//
//
using System.Collections;
using System.Collections.Generic;
using System.IO;
using System.Xml;

using xonline.common.mgmt;
using xonline.common.service;

namespace xonline.common.billing
{
    public class PermitSet
    {
        public List<Permit> PermitList = new List<Permit>();

        public void FromXml(string xml, string rootNodeName)
        {
            XmlTextReader xmlReader = new XmlTextReader(new StringReader(xml));
            FromXml(xmlReader, rootNodeName);
            xmlReader.Close();
        }

        public void FromXml(XmlTextReader xmlReader, string rootNodeName)
        {
            Stack docFormat = new Stack();

            xmlReader.MoveToContent();
            while (!xmlReader.EOF)
            {
                if (xmlReader.NodeType == XmlNodeType.EndElement &&
                    (xmlReader.Name == rootNodeName))
                {
                    xmlReader.Skip();
                    break;              // we're done with this section
                }

                switch (xmlReader.Name)
                {
                case "Permit":
                    Permit permit = new Permit();
                    permit.FromXml(xmlReader, "Permit");
                    PermitList.Add(permit);
                    break;

                default:
                    if (xmlReader.Name == rootNodeName)
                    {
                        // advance to the first inner element
                        xmlReader.ReadStartElement();
                        break;
                    }

                    Xom.Trace(XomAreaName.spstrace, LogLevel.L_WARNING, "Account: Unrecgonized Xml element: " + xmlReader.Name );
                    xmlReader.Skip();
                    break;
                }
            }
        }
    }

    public class RoleAssignment
    {
        public string Role;
        public int PUIDHigh;
        public int PUIDLow;
        public string PMN;
        public string BillableAcctId;
        public string SubscriptionRefId;
        public string ServiceRefId;
        
        public ulong Puid
        {
            get
            {
                ulong puid = (ulong) Int64Convert.FromIntPair(PUIDHigh, PUIDLow);
                return puid;
            }
        }
        
        public void FromXml(string xml, string rootNodeName)
        {
            XmlTextReader xmlReader = new XmlTextReader(new StringReader(xml));
            FromXml(xmlReader, rootNodeName);
            xmlReader.Close();
        }

        public void FromXml(XmlTextReader xmlReader, string rootNodeName)
        {
            Stack docFormat = new Stack();

            xmlReader.MoveToContent();
            while (!xmlReader.EOF)
            {
                if (xmlReader.NodeType == XmlNodeType.EndElement &&
                    (xmlReader.Name == rootNodeName))
                {
                    xmlReader.Skip();
                    break;              // we're done with this section
                }

                switch (xmlReader.Name)
                {
                case "Role":
                    Role = xmlReader.ReadElementString();
                    break;

                case "PUIDHigh":
                    PUIDHigh = XmlSafeConvert.ToInt32(xmlReader.ReadElementString());
                    break;

                case "PUIDLow":
                    PUIDLow = XmlSafeConvert.ToInt32(xmlReader.ReadElementString());
                    break;

                case "PMN":
                    PMN = xmlReader.ReadElementString();
                    break;

                case "RightSet":
                    xmlReader.Skip();
                    break;

                case "BillableAcctId":
                    BillableAcctId = xmlReader.ReadElementString();
                    break;

                case "SubscriptionRefId":
                    SubscriptionRefId = xmlReader.ReadElementString();
                    break;

                case "ServiceRefId":
                    ServiceRefId = xmlReader.ReadElementString();
                    break;

                default:

                    if (xmlReader.Name == rootNodeName)
                    {
                        // advance to the first inner element
                        xmlReader.ReadStartElement();
                        break;
                    }

                    if(xmlReader.NodeType == XmlNodeType.Element)
                    {
                        docFormat.Push(xmlReader.Name);
                        xmlReader.ReadStartElement();
                    }
                    else // EndElement
                    {
                        if( docFormat.Count == 0 || ((string)docFormat.Peek() != xmlReader.Name))
                        {
                            Xom.Trace(XomAreaName.spstrace, LogLevel.L_NORMAL, "Unrecognized Xml element: " + xmlReader.Name );
                            xmlReader.Skip();
                        }
                        else
                        {
                            xmlReader.ReadEndElement();
                            docFormat.Pop();
                        }
                    }

                    break;
                }
            }
        }
    }

    public class Permit
    {
        public string PermitCreationTime;
        public string ObjectType;
        public RoleAssignment RoleAssignment;

        public void FromXml(string xml, string rootNodeName)
        {
            XmlTextReader xmlReader = new XmlTextReader(new StringReader(xml));
            FromXml(xmlReader, rootNodeName);
            xmlReader.Close();
        }

        public void FromXml(XmlTextReader xmlReader, string rootNodeName)
        {
            Stack docFormat = new Stack();

            xmlReader.MoveToContent();
            while (!xmlReader.EOF)
            {
                if (xmlReader.NodeType == XmlNodeType.EndElement &&
                    (xmlReader.Name == rootNodeName))
                {
                    xmlReader.Skip();
                    break;              // we're done with this section
                }

                switch (xmlReader.Name)
                {
                case "PermitCreationTime":
                    PermitCreationTime = xmlReader.ReadElementString();
                    break;

                case "ObjectType":
                    ObjectType = xmlReader.ReadElementString();
                    break;

                case "RoleAssignment":
                    RoleAssignment = new RoleAssignment();
                    RoleAssignment.FromXml(xmlReader, "RoleAssignment");
                    break;

                case "Account":
                    xmlReader.Skip();
                    break;

                case "Subscription":
                    xmlReader.Skip();
                    break;

                case "ServiceInstance":
                    xmlReader.Skip();
                    break;

                default:

                    if (xmlReader.Name == rootNodeName)
                    {
                        // advance to the first inner element
                        xmlReader.ReadStartElement();
                        break;
                    }

                    if(xmlReader.NodeType == XmlNodeType.Element)
                    {
                        docFormat.Push(xmlReader.Name);
                        xmlReader.ReadStartElement();
                    }
                    else // EndElement
                    {
                        if( docFormat.Count == 0 || ((string)docFormat.Peek() != xmlReader.Name))
                        {
                            Xom.Trace(XomAreaName.spstrace, LogLevel.L_NORMAL, "Unrecognized Xml element: " + xmlReader.Name );
                            xmlReader.Skip();
                        }
                        else
                        {
                            xmlReader.ReadEndElement();
                            docFormat.Pop();
                        }
                    }

                    break;
                }
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\marketplace\billing\Subscription.cs ===
//
// Subscription.cs
//
// Copyright (c) Microsoft Corporation. All Rights Reserved.
//
// SCS 2.5
// Xbox Live Service
//
// Author: Ben Zotto (benzotto) - 4/15/03 (created)
//

using System;

using xonline.common.service;
using xonline.common.mgmt;

namespace xonline.common.billing
{

    public class Subscription
    {

        public const byte NO_RENEWAL      = 0;
        public const byte VOUCHER_RENEWAL = 1;
        public const byte NORMAL_RENEWAL  = 2;

        // legal values for ConvertSubscription's ConvertMode parameter
        public const int MODE_CONVERT     = 0;
        public const int MODE_RENEW       = 1;

        // subscription status values
        // SCG defines PENDING, ENABLED, SUSPENDED, EXPIRED, CANCELED
        // We use EXPIRED_NO_VIOLATIONS to indicate EXPIRED but without
        // any violations on the account.  The dash already assumes that
        // EXPIRED subscriptions have violations present.
        public const int PENDING                    = 0;
        public const int ENABLED                    = 1;
        public const int SUSPENDED                  = 2;
        public const int EXPIRED                    = 3;
        public const int CANCELED                   = 4;
        public const int EXPIRED_NO_VIOLATIONS      = 128;

        public static int GetSubscriptionStatusId(string subscriptionStatus)
        {
            switch (subscriptionStatus.ToUpper())
            {
            case "PENDING":
                return PENDING;
            case "ENABLED":
                return ENABLED;
            case "SUSPENDED":
                return SUSPENDED;
            case "EXPIRED":
                return EXPIRED;
            case "CANCELED":
                return CANCELED;
            default:
                Xom.NtEvent(XEvent.Id.COMMON_CONFIG_63, "Subscription.GetSubscriptionStatusId: encountered unknown subscription status value: '" + subscriptionStatus + "' -- returning ENABLED instead.");
                return ENABLED;
            }
        }

        public static string GetSubscriptionStatusFromId(int subscriptionStatusId)
        {
            switch (subscriptionStatusId)
            {
            case PENDING:
                return "PENDING";
            case ENABLED:
                return "ENABLED";
            case SUSPENDED:
                return "SUSPENDED";
            case EXPIRED:
                return "EXPIRED";
            case CANCELED:
                return "CANCELED";
            default:
                throw new ArgumentException("subscriptionStatusId", "Subscription.GetSubscriptionStatusFromId: encountered unknown subscription status id value: " + subscriptionStatusId);
            }
        }

        //
        // wrapper method to retrieve subscription info given a subscription ID or service instance ID
        //
        // This method currently does NOT support retrieval of multiple SubscriptionInfos.
        //

        public static SubscriptionInfo GetSubscriptionInfo(ulong billingPuid, string objectId)
        {
            int high, low;
            string errorXML, subInfoXML;
            int subInfoCount;

            SubscriptionInfo si;
            BillingProvider bdk = new BillingProvider();

            Int64Convert.ToIntPair((long)billingPuid, out high, out low);

            Xom.Trace(XomAreaName.spstrace, LogLevel.L_LOW, "SubscriptionInfo.GetSubscriptionInfo: puid: 0x" + billingPuid.ToString("x") + ", objectId: " + objectId );

            bdk.GetSubscriptions(0, 0, high, low, objectId, out errorXML, out subInfoCount, out subInfoXML);

            if(subInfoCount != 1)
            {
                throw new Exception("Subscription.GetSubscriptionInfo only expects one subscription!  Code will need to be added to support multiples.");
            }

            si = new SubscriptionInfo();

            si.FromXml(subInfoXML, "SubscriptionInfoSet");

            Xom.Trace(XomAreaName.spstrace, LogLevel.L_LOW, "SubscriptionInfo.GetSubscriptionInfo: " + si.ToString() );

            return si;

        }


        //
        // wrapper method to retrieve subscription info given a puid and objectid
        //
        // This method retrieves all SubscriptionInfos for that object (i.e. passing
        // in an accountId will return all subscriptions for that account)
        //

        public static SubscriptionInfoCollection GetSubscriptionInfoSet(ulong billingPuid, string objectId)
        {
            int high, low;
            string errorXML, subInfoXML;
            int subInfoCount;

            SubscriptionInfoCollection siSet = null;
            BillingProvider bdk = new BillingProvider();

            Int64Convert.ToIntPair((long)billingPuid, out high, out low);

            Xom.Trace(XomAreaName.spstrace, LogLevel.L_LOW, "SubscriptionInfo.GetSubscriptionInfoSet: puid: 0x" + billingPuid.ToString("x") + ", objectId: " + objectId);

            bdk.GetSubscriptions(0, 0, high, low, objectId, out errorXML, out subInfoCount, out subInfoXML);

            siSet = new SubscriptionInfoCollection();

            siSet.FromXml(subInfoXML, "SubscriptionInfoSet");

            Xom.Trace(XomAreaName.spstrace, LogLevel.L_LOW, "SubscriptionInfo.GetSubscriptionInfoSet: " + siSet.ToString());

            return siSet;
        }

        //
        // wrapper method to retrieve subscription info given a puid and objectid
        //
        // This method returns the raw SubscriptionInfoSet XML returned by
        // the SCS GetSubscriptions API.  During migration of Xbox1 accounts
        // to Xenon, we record this for financial reporting reasons.
        //

        public static string GetSubscriptionInfoSetXml(ulong billingPuid, string objectId)
        {
            int high, low;
            int subscriptionInfoCount;
            string subscriptionInfoXml;
            string errorXml;

            BillingProvider bdk = new BillingProvider();

            Int64Convert.ToIntPair((long)billingPuid, out high, out low);

            Xom.Trace(XomAreaName.spstrace, LogLevel.L_LOW, "SubscriptionInfo.GetSubscriptionInfoSet: puid: 0x" + billingPuid.ToString("x") + ", objectId: " + objectId);

            bdk.GetSubscriptions(0, 0, high, low, objectId, out errorXml, out subscriptionInfoCount, out subscriptionInfoXml);

            return subscriptionInfoXml;
        }

        public static void RenewSubscriptionEx(ulong billingPuid,
                                               string subscriptionFriendlyName,
                                               string subscriptionId,
                                               string destinationOffer,
                                               string trackingGUID,
                                               int conversionMode,
                                               string paymentInstrumentId,
                                               string tokenId
                                               )
        {
            int high, low;
            string errorXML;
            int countInstancesAdded, countInstancesRemoved;
            string instancesAdded, instancesRemoved, amountCharged;

            BillingProvider bdk = new BillingProvider();

            Int64Convert.ToIntPair((long)billingPuid, out high, out low);

            bdk.ConvertSubscriptionEx(
                0,
                0,
                high,
                low,
                trackingGUID,               // string bstrTrackingGUID
                false,                      // bool fComputeOnly
                conversionMode,             // int lConvertMode
                0,                          // int lOverrideFlags
                subscriptionFriendlyName,   // string bstrSubscriptionName
                subscriptionId,             // string bstrSubscriptionId
                destinationOffer,           // string bstrOfferingGUID
                0,                          // int lOverrideAmount
                String.Empty,               // string bstrSubscriptionEndDate
                String.Empty,               // string bstrReferralSetXML
                conversionMode == MODE_RENEW ? "" : paymentInstrumentId,        // string bstrPaymentInstrumentId
                tokenId,                    // string bstrTokenID
                string.Empty,               // string bstrPolicyGUID
                0,                          // int lPolicyVersion
                string.Empty,               // bstrSignatureDateTime
                out errorXML,
                out amountCharged,
                out countInstancesAdded,
                out instancesAdded,
                out countInstancesRemoved,
                out instancesRemoved
                );


            if (countInstancesAdded != 0 || countInstancesRemoved != 0)
            {
                throw new ExceptionWithEventId(XEvent.Id.MC_SPS_OFFER_MISCONFIGURATION_1,
                          "Subscription.RenewSubscription expects no added or removed service instances!!. "
                        + "Got " + countInstancesAdded + " instances added and " + countInstancesRemoved + " when "
                        + "renewing subscription ID " + subscriptionId + " to offer ID " + destinationOffer + ". "
                        + "(Owner 0x" + billingPuid.ToString("x"));
            }

        }

        //
        // wrapper around SCS's ConvertSubscription API to do renewals.
        //

        public static void RenewSubscription(ulong billingPuid,
                                               string subscriptionFriendlyName,
                                               string subscriptionId,
                                               string destinationOffer,
                                               string trackingGUID,
                                               int conversionMode
                                               )
        {
            int high, low;
            string errorXML;
            int countInstancesAdded, countInstancesRemoved;
            string instancesAdded, instancesRemoved, amountCharged;

            BillingProvider bdk = new BillingProvider();

            Int64Convert.ToIntPair((long)billingPuid, out high, out low);


            bdk.ConvertSubscription(0, 0, high, low,
                trackingGUID,
                false,             // computeOnly
                conversionMode,    // conversion mode (1 == "renew")
                0,                 // override flags
                subscriptionFriendlyName,      // friendly name
                subscriptionId,
                destinationOffer,
                0,
                String.Empty,
                String.Empty,
                out errorXML,
                out amountCharged,
                out countInstancesAdded,
                out instancesAdded,
                out countInstancesRemoved,
                out instancesRemoved
                );

            if (countInstancesAdded != 0 || countInstancesRemoved != 0)
            {
                throw new ExceptionWithEventId(XEvent.Id.COMMON_CONFIG_65,
                          "Subscription.RenewSubscription expects no added or removed service instances!!. "
                        + "Got " + countInstancesAdded + " instances added and " + countInstancesRemoved + " when "
                        + "renewing subscription ID " + subscriptionId + " to offer ID " + destinationOffer + ". "
                        + "(Owner 0x" + billingPuid.ToString("x"));
            }
        }

        //
        // wrapper around SCS's UpdateSubscriptionInfo API
        //
        public static void UpdatePaymentInstrumentInfo(
            ulong billingPuid,
            string subscriptionFriendlyName,
            string shippingAddressId,
            string trackingGuid,
            string subscriptionId,
            string oldPaymentInstrumentId,
            string newPaymentInstrumentId
            )
        {
            int high, low;
            string subscriptionInfoXml;
            string referralSetXml;
            string errorXml;
            string amountChargedXml;

            BillingProvider bdk = new BillingProvider();

            Int64Convert.ToIntPair((long)billingPuid, out high, out low);


            subscriptionInfoXml =
                "<SubscriptionInfo xmlns=\"urn:schemas-microsoft-com:billing-data\">" +
                "<FriendlyName>" + subscriptionFriendlyName + "</FriendlyName>" +
                "<ShippingAddressId>" + shippingAddressId + "</ShippingAddressId>" +
                "<PaymentInstrumentId>" + (newPaymentInstrumentId == null ? "" : newPaymentInstrumentId) + "</PaymentInstrumentId>" +
                "<SubscriptionCoBrand>MSFT</SubscriptionCoBrand>" +
                "</SubscriptionInfo>";

            referralSetXml = "";

            string tbGuid = Guid.NewGuid().ToString();

            // If there was no original payment instrument or if the new
            // payment instrument is the same as the old one (this would
            // happen when updating a credit card's expiration date), we
            // call SettleBalance instead of TransferBalance.
            if ( oldPaymentInstrumentId != null &&
                 oldPaymentInstrumentId != string.Empty &&
                 oldPaymentInstrumentId != newPaymentInstrumentId )
            {
                bdk.TransferBalance(
                    0, 0,
                    tbGuid,
                    oldPaymentInstrumentId,
                    newPaymentInstrumentId,
                    out errorXml,
                    out amountChargedXml);
            }
            else
            {
                bdk.SettleBalance(
                    0, 0,
                    tbGuid,
                    newPaymentInstrumentId,
                    out errorXml,
                    out amountChargedXml);
            }

            bdk.UpdateSubscriptionInfo(
                0, 0,
                high, low,
                trackingGuid,
                subscriptionId,
                subscriptionInfoXml,
                referralSetXml,
                out errorXml
                );
        }

        //
        // wrapper around SCS's ReinstateSubscription API
        //
        public static void ReinstateSubscription(
            ulong billingPuid,
            string subscriptionId
            )
        {
            int high, low;
            string commentXml;
            string subscriptionInfoXml;
            string amtChargedXml;
            string errorXml;

            BillingProvider bdk = new BillingProvider();

            Int64Convert.ToIntPair((long)billingPuid, out high, out low);


            commentXml =
                    "<CommentInfo xmlns=\"urn:schemas-microsoft-com:billing-data\">" +
                        "<CommentCode>0</CommentCode>" +
                        "<CommentText>Xbox Live calling ReinstateSubscription due to subscription being EXPIRED with violations.</CommentText>" +
                    "</CommentInfo>";

            Xom.Trace(XomAreaName.spstrace, LogLevel.L_NORMAL, "ReinstateSubscription: reinstating subscription '" + subscriptionId + " for user 0x" + billingPuid.ToString("x") + "." );

            bdk.ReinstateSubscription(
                0, 0,
                high, low,
                subscriptionId,
                0,
                commentXml,
                out errorXml,
                out amtChargedXml,
                out subscriptionInfoXml
                );

            Xom.Trace(XomAreaName.spstrace, LogLevel.L_NORMAL, "ReinstateSubscription: reinstated subscription '" + subscriptionId + " for user 0x" + billingPuid.ToString("x") + ": amtChargedXml='" + amtChargedXml + "', subscriptionInfoXml='" + subscriptionInfoXml + "'." );
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\marketplace\billing\ScsBehaviorInjection.cs ===
//
// ScsBehaviorInjection.cs
//
// Copyright (c) Microsoft Corporation. All Rights Reserved.
//

using System;
using System.Collections.Specialized;
using System.Net;
using System.Reflection;
using System.Web.Services.Protocols;

using xonline.common.service;

namespace xonline.common.billing
{
    public sealed class ScsFailure : BehaviorInjection
    {
        static ScsFailure()
        {
        }

        public delegate void PostCallDelegate();

        public static void Init()
        {
            // remove the dummy handler (if present)
            RequestHeaderBehaviorInjectionMgr.RemoveBehaviorInjectionFactory("ScsFailure");

            // add the real handler
            RequestHeaderBehaviorInjectionMgr.AddBehaviorInjectionFactory("ScsFailure", ScsFailure.Create, RequestHeaderBehaviorInjectionMgr.BehaviorInjectionFactoryFlags.None);
        }

        private ScsFailure(string injectionName, string specificParams, string genericParams)
            : base(injectionName, specificParams, genericParams)
        {
            NameValueCollection parameters = ParameterParsingUtil.ParseAsNameValuePairs(specificParams);

            string api = parameters["api"];

            if ( string.IsNullOrEmpty(api) )
            {
                throw new Exception(String.Format("ScsFailure must have an API name associated with it but none was found in '{0}'.", specificParams));
            }

            _api = api;

            string error = parameters["error"];
            string timeout = parameters["timeout"];

            if ( string.IsNullOrEmpty(error) && string.IsNullOrEmpty(timeout) )
            {
                throw new Exception(String.Format("ScsFailure must have at least one of 'error' and 'timeout' but neither was found in '{0}'.", specificParams));
            }

            if ( !string.IsNullOrEmpty(error) )
            {
                _error = error;
                _message = parameters["message"];
            }
            else
            {
                if ( !string.IsNullOrEmpty(timeout) )
                {
                    _timeoutMillis = Int32.Parse(timeout);
                }
                else
                {
                    _timeoutMillis = 1;
                }
            }

        }

        public static PostCallDelegate HandleBehaviorInjection(string api, ref int timeout)
        {
            PostCallDelegate d;
            ScsFailure scsFailure;

            if (RequestHeaderBehaviorInjectionMgr.TryGetBehaviorInjection("ScsFailure", out scsFailure))
            {
                d = scsFailure.PerformFailureAction(api, ref timeout);

            }
            else
            {
                d = delegate() { /* do nothing */ };
            }

            return d;
        }

        public static ScsFailure Create(BehaviorRequest behaviorRequest)
        {
            return new ScsFailure(behaviorRequest.Name, behaviorRequest.SpecificParams, behaviorRequest.GenericParams);
        }

        public PostCallDelegate PerformFailureAction(string api, ref int timeout)
        {
            PostCallDelegate noop = delegate() { };

            if ( api.Equals(_api, StringComparison.InvariantCultureIgnoreCase) )
            {
                if ( _timeoutMillis.HasValue )
                {
                    timeout = _timeoutMillis.Value;

                    // For timeouts, it is possible that the SCS API call can
                    // succeed even with a timeout of 1 ms specified.
                    //
                    // This is presumably because the web service call completes
                    // before the internal timer has a chance to fire.
                    //
                    // This delegate will be called immediately after the SCS call
                    // completes and will force an artifical timeout exception.
                    //
                    return delegate()
                    {
                        throw new WebException(string.Format("Artificial timeout for {0} introduced by BehaviorInjection. Call to SCS.{0} was successfully made", _api), WebExceptionStatus.Timeout);
                    };
                }
                else
                {
                    string scsMessage = null;
                    uint bdkHr = 0;
                    if ( _error.StartsWith("BDK_E_") )
                    {
                        Type bdkErrType = typeof(xonline.common.billing.BdkError);
                        FieldInfo f = bdkErrType.GetField(_error.Trim());
                        if ( f == null )
                        {
                        }
                        else
                        {
                            bdkHr = (uint) f.GetValue(null);
                        }
                    }
                    else
                    {
                        bdkHr = Convert.ToUInt32(_error);
                    }

                    BdkErrorDetail errDetail = BdkError.GetErrorDetail(bdkHr);
                    if ( errDetail != null )
                    {
                        string disclaimer = "This error was artificially injected due to an HTTP header in the incoming request and was not generated by SCS.";

                        scsMessage = string.Format("<ErrorPackage><ErrorHResult>0x{0}</ErrorHResult><ErrorMessage>{1}</ErrorMessage><Retryable>{2}</Retryable><InjectedErrorDisclaimer>{3}</InjectedErrorDisclaimer>",
                            bdkHr.ToString("X"),
                            (errDetail.Message == null ? "" : errDetail.Message),
                            (errDetail.Retryable ? "true" : "false"),
                            disclaimer);

                        throw new SoapException(scsMessage, SoapException.ClientFaultCode);
                    }
                }
            }

            return noop;
        }

        string _api = string.Empty;
        string _error = string.Empty;
        string _message = string.Empty;
        int?   _timeoutMillis;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\marketplace\billing\ScsQueue.cs ===
using System;
using System.Threading;
using System.Security.Principal;
using Microsoft.Webstore.WstClient;

using xonline.common.audit;
using xonline.common.config;
using xonline.common.service;
using xonline.common.mgmt;

namespace xonline.common.billing
{
    public class ScsQueue
    {
        private static Timer m_timer = null;
        private static bool m_isStopped = false;

        static ScsQueue()
        {
            XomControl.ControlRequestEvent += new XomControl.ControlRequestEventHandler(ScsQueue.OnControlRequest);
        }

        public static uint PurchaseItemTransactionExpiredSeconds
        {
            get
            {
                return Config.GetUIntSetting(Setting.scs_purchaseItemTransactionExpiredSeconds);
            }
        }

        public static uint PurchaseItemTransactionConsiderFailedSeconds
        {
            get
            {
                return Config.GetUIntSetting(Setting.scs_purchaseItemTransactionConsiderFailedSeconds);
            }
        }

        public static uint PumpIntervalSeconds
        {
            get
            {
                return Config.GetUIntSetting(Setting.scs_queuePumpIntervalSeconds);
            }
        }

        public static bool PumpPurchaseItemQueue
        {
            get
            {
                return Config.GetBoolSetting(Setting.scs_pumpPurchaseItemQueue);
            }
        }

        public static int UserCommerceDbPartitionCount
        {
            get
            {
                using(WstConnection c = new WstConnection(ConfigUtil.GetUserCommerceWebstoreApp()))
                {
                    c.Open();

                    return c.SqlPartitions.Count;
                }
            }
        }

        public static void StartPump()
        {
            if ( BillingConfig.ConnectToBilling )
            {
                WindowsIdentity id = WindowsIdentity.GetCurrent();
                ThreadPool.QueueUserWorkItem(new WaitCallback(PumpFunc), id);
            }
        }

        public static void StopPump()
        {
            m_isStopped = true;

            if (m_timer != null)
            {
                m_timer.Dispose();
                m_timer = null;
            }
        }

        private static void ResetPumpTimer(WindowsIdentity id)
        {
            try
            {
                if (m_isStopped)
                    return;

                uint timerIntervalMillseconds = PumpIntervalSeconds * 1000;

                if (m_timer == null)
                    m_timer = new Timer(new TimerCallback(PumpFunc), id, timerIntervalMillseconds, Timeout.Infinite);
                else
                    m_timer.Change(timerIntervalMillseconds, Timeout.Infinite);
            }
            catch (Exception e)
            {
                Xom.NtEvent(XEvent.Id.COMMON_CONFIG_57, e, 
                    "Failed to reset the scs queue timer.  SCS queues will not be processed."
                );
            }
        }

        private static void ResetQueueThreadSessionState()
        {
            // use longer SCS timeout values because these calls are server <-> server
            BdkWrapper.SetSessionClientType(SessionClientType.LiveService);

            // Reset any session alternate URL
            BdkWrapper.ResetSessionAlternateUrl();

            // Reset the SCS session client info (client IP address, etc.)
            BdkWrapper.ResetSessionClientInfo();

            // In order to allow the existing AlternateUrl columns in the queue
            // tables to be overloaded to support behavior injections, resetting
            // the current thread's AlternateUrl must also clear any pending
            // BehaviorInjection headers as well
            RequestHeaderBehaviorInjectionMgr.ClearBehaviorInjections();
        }

        public static void PumpFunc(object o)
        {
            WindowsIdentity identity = (WindowsIdentity) o;
            WindowsImpersonationContext impContext = null;

            // If this extra catch looks odd to you, then maybe you haven't read http://msdn.microsoft.com/en-us/ms182322.aspx.
            // Mind you, there's a comment at the bottom that indicates you don't need to do this anymore, but I trust our
            // current version of FxCop more than I trust some comment on MSDN.
            try
            {
                try
                {
                    if (identity.IsSystem == false)
                    {
                        // impersonate the thread that started this
                        impContext = identity.Impersonate();
                    }

                    UpdatePendingPurchaseItemsTotal();

                    if (PumpPurchaseItemQueue)
                    {
                        XomRequestTimeElapsed timeElapsed = new XomRequestTimeElapsed();

                        ScsQueueCounters.Counters.PurchaseItemPumpRunsTotal.Increment();

                        RetryPurchaseItemsLoop();

                        ScsQueueCounters.Counters.PurchaseItemPumpRunTime.IncrementBy(timeElapsed.TimeElapsed);
                        ScsQueueCounters.Counters.PurchaseItemPumpRunTimeBase.Increment();
                    }
                }
                finally
                {
                    try
                    {
                        if (impContext != null)
                            impContext.Undo();
                    }
                    catch (Exception e)
                    {
                        Xom.NtEvent(XEvent.Id.COMMON_CONFIG_59, e, "Failure undoing impersonation in the SCS queue pump.");
                    }
                }
            }
            catch (Exception e)
            {
                Xom.NtEvent(XEvent.Id.COMMON_CONFIG_58, e, "Failure in the SCS queue pump.");
            }

            ResetPumpTimer(identity);
        }

        public static void UpdatePendingPurchaseItemsTotal()
        {
            int partitions = UserCommerceDbPartitionCount;

            int totalRetryablePurchases = 0;
            for (int partition = 0; partition < partitions; partition++)
            {
                try
                {
                    totalRetryablePurchases += SCSPurchaseItem.GetRetryablePurchaseCount(partition,
                        PurchaseItemTransactionExpiredSeconds);
                }
                catch (Exception e)
                {
                    Xom.NtEvent(XEvent.Id.COMMON_CONFIG_60, e, "ScsQueue unable to read count of retryable PurchaseItem transactions.");
                    // this isn't fatal, our count will just be wrong
                }
            }

            if (totalRetryablePurchases > 0)
            {
                string szTrace = string.Format("ScsPurchaseItemQueue: {0} retryable purchases found",
                    totalRetryablePurchases);
                Xom.Trace(XomAreaName.spsqueuetrace, LogLevel.L_NORMAL, szTrace);
            }

            ScsQueueCounters.Counters.PurchaseItemPendingTotal.RawValue = totalRetryablePurchases;
        }

        public static void RetryPurchaseItemsLoop()
        {
            BillingProvider bp = new BillingProvider();

            int partitions = UserCommerceDbPartitionCount;

            for (int partition = 0; partition < partitions; partition++)
            {
                while (true)
                {
                    SCSRetryablePurchase retryablePurchase;
                    bool keepGoing = false;

                    try
                    {
                        retryablePurchase = SCSPurchaseItem.GetPurchaseForRetry(partition,
                            PurchaseItemTransactionExpiredSeconds, PurchaseItemTransactionConsiderFailedSeconds,
                            out keepGoing);
                    }
                    catch (Exception e)
                    {
                        Xom.NtEvent(XEvent.Id.COMMON_CONFIG_61, e, 
                            "ScsQueue: SCSPurchaseItem.GetPurchaseForRetry failed on partition {0}, moving on to the next partition...", partition
                        );

                        // this isn't fatal, move on to the next partition
                        break;
                    }

                    if (keepGoing == true)
                    {
                        Xom.Trace(XomAreaName.spsqueuetrace, LogLevel.L_NORMAL,
                            "ScsPurchaseItemQueue: Giving up on transaction and moving it to the failure state");

                        continue;
                    }

                    if (retryablePurchase == null)
                        break;

                    //Set the session client Info
                    BillingProvider.SetSessionClientInfo(retryablePurchase.IpAddress, retryablePurchase.DeviceId, string.Empty);

                    // reset thread-local alternate URL, behavior injection, etc.
                    ResetQueueThreadSessionState();

                    // if an alternate URL is present in the queue, use it
                    if ( !string.IsNullOrEmpty(retryablePurchase.AlternateUrl) )
                    {
                        BdkWrapper.SetSessionAlternateUrl(retryablePurchase.AlternateUrl);
                    }



                    ScsQueueCounters.Counters.PurchaseItemAttemptsPerSecond.Increment();
                    ScsQueueCounters.Counters.PurchaseItemAttemptsTotal.Increment();

                    // most auditing happens through a front door,  not a
                    // worker thread.  prime this thread with  user  puid

                    AuditStream.WriteOptional(
                        retryablePurchase.UserPuid, AuditSubsystem.XBOS, "ScsPurchaseItemQueue", string.Empty
                    );

                    try
                    {
                        string szTrace = string.Format("ScsPurchaseItemQueue: Retrying SCS.PurchaseItem for GUID '{0}'",
                            retryablePurchase.TransactionGuid.ToString());
                        Xom.Trace(XomAreaName.spsqueuetrace, LogLevel.L_NORMAL, szTrace);

                        SCSPurchaseItem purchaseItem = new SCSPurchaseItem();

                        purchaseItem.TryPurchase(
                            retryablePurchase.TransactionGuid,
                            retryablePurchase.UserPuid,
                            retryablePurchase.MachinePuid,
                            retryablePurchase.UserPassportPuid,
                            retryablePurchase.AccountID,
                            retryablePurchase.OfferID,
                            retryablePurchase.PaymentInstrumentID,
                            retryablePurchase.Token,
                            retryablePurchase.EncryptedPassword,
                            retryablePurchase.CountryID,
                            retryablePurchase.TierRequired,
                            true, // retryingPurchase
                            retryablePurchase.TokenHash,
                            retryablePurchase.BillingOfferId
                        );

                        ScsQueueCounters.Counters.PurchaseItemPendingTotal.Decrement();
                    }
                    catch (Exception e)
                    {
                        Xom.NtEvent(XEvent.Id.COMMON_CONFIG_62, e,
                            "ScsQueue: SCSPurchaseItem.TryPurchase failed on transactionGuid '{0}', moving on to the next transaction...",
                            retryablePurchase.TransactionGuid
                        );

                        // this isn't fatal, move on to the next reward
                    }
                    finally
                    {
                        // and then flush any work audited on this thread
                        AuditStream.Cleanup(/* flush = */ true);
                    }
                }
            }
        }

        public static void OnControlRequest(object sender, ControlRequestEventArgs args)
        {
            string cmd = args.Command.ToLower();
            switch (args.Command)
            {
            case "help":
                XomControlConnection.SendMessage(
                    "ScsQueue help:\r\n" +
                    "ScsDequeue -- Force the ScsQueue to start processing queued items\n\r\n\r",
                    args.RequestId);
                args.Handled = true;
                break;

            case "scsdq":
            case "scsdequeue":
                ScsQueue.PumpFunc(WindowsIdentity.GetCurrent());
                args.Handled = true;
                break;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\marketplace\billing\SubscriptionInfo.cs ===
//
// SubscriptionInfo.cs
//
// Copyright (c) Microsoft Corporation. All Rights Reserved.
//
// SPS 2.5 Object Model
// Xbox Online Service
//
// Author: Ben Zotto (benzotto) - 4/15/03 (created)
//
using System;
using System.Collections;
using System.Xml;
using System.Text;
using System.IO;

using xonline.common.service;
using xonline.common.mgmt;


namespace xonline.common.billing
{

public class SubscriptionInfo
{
    public SubscriptionInfo()
    {
        doneOneInstance = false;        //check for multiple instances in reading XML.
    }

    private string   subscriptionId;
    private int      anniversaryDate;
    private string   offeringGUID;
    private string   subscriptionDescription;
    private string   subscriptionPriceDescription;
    private string   internalSubscriptionDescription;
    private string   friendlyName;
    private string   shippingAddressId;
    private string   subscriptionStatus;
    private int      subscriptionStatusNumeric;
    private DateTime purchaseDate;
    private DateTime activationDate;
    private DateTime endDate;
    private bool     delayedCancel;
    private int      renewalGracePeriod;
    private string   renewOfferingId;
    private string   paymentInstrumentId;
    private bool     hasViolations;

    private ServiceInstance subServiceInstance;

    private bool    doneOneInstance;

    public void FromXml(string xml, string rootNodeName)
    {
        XmlReaderSettings settings = new XmlReaderSettings()
        {
            IgnoreWhitespace = true,
        };

        XmlReader xmlReader = XmlReader.Create(new StringReader(xml), settings);
        FromXml(xmlReader, rootNodeName);
        xmlReader.Close();
    }

    public void FromXml(XmlTextReader xmlReader, string rootNodeName)
    {
        FromXml((XmlReader)xmlReader, rootNodeName);
    }

    public void FromXml(XmlReader xmlReader, string rootNodeName)
    {
        Stack docFormat = new Stack();

        xmlReader.MoveToContent();
        while (!xmlReader.EOF)
        {
            if (xmlReader.NodeType == XmlNodeType.EndElement &&
                (xmlReader.Name == rootNodeName))
            {
                xmlReader.Skip();
                break;              // we're done with this section
            }

            Xom.Trace(XomAreaName.spstrace, LogLevel.L_LOW, "SubscriptionInfo: XmlReader - NodeType:{0}, Name:{1}",
                xmlReader.NodeType, xmlReader.Name);

            switch (xmlReader.Name)
            {

            case "SubscriptionInfo":
                xmlReader.Read();
                if(doneOneInstance == true && xmlReader.NodeType != XmlNodeType.EndElement)
                {
                    //
                    // this shouldn't happen.
                    //
                    Xom.Trace(XomAreaName.spstrace, LogLevel.L_WARNING, "Seeing another sub after sub "
                        + subscriptionId + "!  Ignoring." );
                    return;
                }
                else
                {
                    doneOneInstance = true;
                }
                break;

            case "SubscriptionId":
                subscriptionId = xmlReader.ReadElementString().Trim();
                break;

            case "AnniversaryDate":
                anniversaryDate = XmlSafeConvert.ToInt32(xmlReader.ReadElementString());
                break;

            case "OfferingGUID":
                offeringGUID = xmlReader.ReadElementString().Trim();
                break;

            case "SubscriptionDescription":
                subscriptionDescription = xmlReader.ReadElementString().Trim();
                break;

            case "SubscriptionPriceDescription":
                SubscriptionPriceDescription = xmlReader.ReadElementString().Trim();
                break;

            case "InternalSubscriptionDescription":
                internalSubscriptionDescription = xmlReader.ReadElementString().Trim();
                break;

            case "FriendlyName":
                friendlyName = xmlReader.ReadElementString().Trim();
                break;

            case "ShippingAddressId":
                shippingAddressId = xmlReader.ReadElementString().Trim();
                break;

            case "SubscriptionStatus":
                subscriptionStatus = xmlReader.ReadElementString().Trim();

                switch(subscriptionStatus)
                {
                case "PENDING":
                    subscriptionStatusNumeric = Subscription.PENDING;
                    break;
                case "ENABLED":
                    subscriptionStatusNumeric = Subscription.ENABLED;
                    break;
                case "SUSPENDED":
                    subscriptionStatusNumeric = Subscription.SUSPENDED;
                    break;
                case "EXPIRED":
                    subscriptionStatusNumeric = Subscription.EXPIRED;
                    break;
                case "CANCELED":
                    subscriptionStatusNumeric = Subscription.CANCELED;
                    break;
                default:
                    subscriptionStatusNumeric = -1;
                    break;
                }

                break;

            case "ViolationId":
                // ignore the violation id itself
                xmlReader.ReadElementString();

                hasViolations = true;
                break;

            case "PurchaseDate":
                purchaseDate = Convert.ToDateTime(xmlReader.ReadElementString());
                break;

            case "ActivationDate":
                activationDate = Convert.ToDateTime(xmlReader.ReadElementString());
                break;

            case "EndDate":
                endDate = Convert.ToDateTime(xmlReader.ReadElementString());
                break;

            case "DelayedCancel":
                delayedCancel = Convert.ToBoolean(xmlReader.ReadElementString().Trim());
                break;

            case "RenewalGracePeriod":
                renewalGracePeriod = XmlSafeConvert.ToInt32(xmlReader.ReadElementString());
                break;

            case "RenewOfferingId":
                renewOfferingId = xmlReader.ReadElementString().Trim();
                break;

            case "PaymentInstrumentId":
                paymentInstrumentId = xmlReader.ReadElementString().Trim();
                break;

            case "PaymentInstrumentSet":
                // ignore this and any PaymentInstrumentId elements within it
                xmlReader.Skip();
                break;

            case "ServiceInstanceSet":
                subServiceInstance = new ServiceInstance();
                subServiceInstance.FromXml(xmlReader, "ServiceInstanceSet");
                break;

            case "HasTermCommit":
            case "TermCommitStartDate":
            case "TermCommitPriceDescription":
            case "TermCommitCyclesRemaining":
            case "SubscriptionCoBrand":

                //
                // ignored
                //

                xmlReader.ReadElementString();

                break;

            default:

                if (xmlReader.Name == rootNodeName)
                {
                    // advance to the first inner element
                    xmlReader.ReadStartElement();
                    break;
                }

                if(xmlReader.NodeType == XmlNodeType.Element)
                {
                    docFormat.Push(xmlReader.Name);
                    xmlReader.ReadStartElement();
                }
                else // EndElement
                {
                    if( docFormat.Count == 0 || ((string)docFormat.Peek() != xmlReader.Name))
                    {
                        Xom.Trace(XomAreaName.spstrace, LogLevel.L_NORMAL, "Unrecognized Xml element: " + xmlReader.Name );
                        xmlReader.Skip();
                    }
                    else
                    {
                        xmlReader.ReadEndElement();
                        docFormat.Pop();
                    }
                }

                break;
            }
        }

        // if the state of the subscription is EXPIRED and there are
        // no violations present, return an Xbox specific status to indicate
        // this to the dash.  This allows the dash to present proper UI to
        // the user for dealing with EXPIRED both with and without violations.
        if ( !hasViolations && subscriptionStatusNumeric == Subscription.EXPIRED )
        {
            subscriptionStatusNumeric = Subscription.EXPIRED_NO_VIOLATIONS;
        }

        Xom.Trace(XomAreaName.spstrace, LogLevel.L_LOW, "SubscriptionInfo.FromXml: subscriptionStatusNumeric: " + subscriptionStatusNumeric );
    }

    public override string ToString()
    {
        StringBuilder sb = new StringBuilder();

        sb.Append("subscriptionId: " + subscriptionId + "\n");
        sb.Append("anniversaryDate: " + anniversaryDate + "\n");
        sb.Append("offeringGUID: " + offeringGUID + "\n");
        sb.Append("subscriptionDescription: " + subscriptionDescription + "\n");
        sb.Append("subscriptionPriceDescription: " + subscriptionPriceDescription + "\n");
        sb.Append("internalSubscriptionDescription: " + internalSubscriptionDescription + "\n");
        sb.Append("friendlyName: " + friendlyName + "\n");
        sb.Append("shippingAddressId: " + shippingAddressId + "\n");
        sb.Append("subscriptionStatus: " + subscriptionStatus + " (" + subscriptionStatusNumeric + ")\n");
        sb.Append("hasViolations: " + hasViolations + "\n");
        sb.Append("purchaseDate: " + purchaseDate + "\n");
        sb.Append("activationDate: " + activationDate + "\n");
        sb.Append("endDate: " + endDate + "\n");
        sb.Append("renewalGracePeriod: " + renewalGracePeriod + "\n");
        sb.Append("renewOfferingId: " + renewOfferingId + "\n");
        sb.Append("paymentInstrumentId: " + paymentInstrumentId + "\n");
        sb.Append("service instance: " + ((subServiceInstance != null) ? subServiceInstance.ServiceInstanceId : "(none)") + "\n");

        return sb.ToString();
    }

    //
    // Public accessors
    //

    public string SubscriptionId
    {
        get { return subscriptionId; }
        set { subscriptionId = value; }
    }
    public int AnniversaryDate
    {
        get { return anniversaryDate; }
        set { anniversaryDate = value; }
    }
    public string OfferingGUID
    {
        get { return offeringGUID; }
        set { offeringGUID = value; }
    }
    public string SubscriptionDescription
    {
        get { return subscriptionDescription; }
        set { subscriptionDescription = value; }
    }
    public string SubscriptionPriceDescription
    {
        get { return subscriptionPriceDescription; }
        set { subscriptionPriceDescription = value; }
    }
    public string InternalSubscriptionDescription
    {
        get { return internalSubscriptionDescription; }
        set { internalSubscriptionDescription = value; }
    }
    public int SubscriptionStatusNumeric
    {
        get { return subscriptionStatusNumeric; }
        set { subscriptionStatusNumeric = value; }
    }
    public string SubscriptionStatus
    {
        get { return subscriptionStatus; }
        set { subscriptionStatus = value; }
    }
    public string FriendlyName
    {
        get { return friendlyName; }
        set { friendlyName = value; }
    }
    public string ShippingAddressId
    {
        get { return shippingAddressId; }
        set { shippingAddressId = value; }
    }
    public DateTime PurchaseDate
    {
        get { return purchaseDate; }
        set { purchaseDate = value; }
    }
    public DateTime ActivationDate
    {
        get { return activationDate; }
        set { activationDate = value; }
    }
    public DateTime EndDate
    {
        get { return endDate; }
        set { endDate = value; }
    }
    public int RenewalGracePeriod
    {
        get { return renewalGracePeriod; }
        set { renewalGracePeriod = value; }
    }
    public string RenewOfferingId
    {
        get { return renewOfferingId; }
        set { renewOfferingId = value; }
    }
    public string PaymentInstrumentId
    {
        get { return paymentInstrumentId; }
        set { paymentInstrumentId = value; }
    }
    public ServiceInstance Instance
    {
        get { return subServiceInstance; }
        set { subServiceInstance = value; }
    }
    public bool HasViolations
    {
        get { return hasViolations; }
        set { hasViolations = value; }
    }
    public bool IsExpired
    {
        get
        {
            return (subscriptionStatusNumeric == Subscription.EXPIRED) || (subscriptionStatusNumeric == Subscription.EXPIRED_NO_VIOLATIONS);
        }
    }
    public bool DelayedCancel
    {
        get { return delayedCancel; }
    }
}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\marketplace\billing\ServiceInstance.cs ===
// 
// ServiceInstance.cs
//
// Copyright (c) Microsoft Corporation. All Rights Reserved.
//
// SPS 2.5 Object Model
// Xbox Online Service
// 
// Author: Ben Zotto (benzotto)
//
using System;
using System.Collections;
using System.Xml;
using System.Text;
using System.IO;
using System.Diagnostics;
using xonline.common.service;
using xonline.common.mgmt;


namespace xonline.common.billing 
{

public enum InstanceStatusEnum
{
    Pending             = 0,
    Enabled             = 1,
    Suspended           = 2,
    Expired             = 3,
    Canceled            = 4    
}


public class ServiceInstance
{
    private static string[] InstanceStatusTypes = new string[] {  "PENDING",                                                            
                                                          "ENABLED",
                                                          "SUSPENDED",
                                                          "EXPIRED",
                                                          "CANCELED"};    

    public ServiceInstance()
    {
        doneOneInstance = false;        //check for multiple instances in reading XML.
    }

    public bool     MigrationStatus;
    public string   InstanceFriendlyName;
    public int      PuidHigh;
    public int      PuidLow;
    public string   PMN;
    public string   Role;
    public string   ServiceInstanceId;
    public InstanceStatusEnum ServiceInstanceStatus;
    public string   BaseServiceInstanceId;
    public string   ServiceComponentId;
    public string   ServiceComponentName;
    public string   Details;
    public string   ProvisioningStatus;
    public string   ProvisioningErrorCode;

    private bool    doneOneInstance;


    public void FromXml(string xml, string rootNodeName)
    {
        XmlReaderSettings settings = new XmlReaderSettings()
        {
            IgnoreWhitespace = true,
        };

        XmlReader xmlReader = XmlReader.Create(new StringReader(xml), settings);
        FromXml(xmlReader, rootNodeName);
        xmlReader.Close();
    }

    public void FromXml(XmlTextReader xmlReader, string rootNodeName)
    {
        FromXml((XmlReader)xmlReader, rootNodeName);
    }

    public void FromXml(XmlReader xmlReader, string rootNodeName)
    {
        Stack docFormat = new Stack();

        xmlReader.MoveToContent(); 
        while (!xmlReader.EOF)   
        {
            if (xmlReader.NodeType == XmlNodeType.EndElement &&
                (xmlReader.Name == rootNodeName))
            {
                xmlReader.Skip();
                break;              // we're done with this section
            }

            switch (xmlReader.Name)
            {

            case "ServiceInstance":
                xmlReader.Read();
                if(doneOneInstance == true && xmlReader.NodeType != XmlNodeType.EndElement) 
                {
                    //
                    // this shouldn't happen.
                    //
                    Xom.Trace(XomAreaName.spstrace, LogLevel.L_WARNING, "Seeing another service instance after component " 
                        + ServiceComponentId + "!  Ignoring." );
                    return;
                } 
                else
                {                            
                    doneOneInstance = true;
                }
                break;

            case "MigrationStatus":
                MigrationStatus = (XmlSafeConvert.ToInt32(xmlReader.ReadElementString()) == 1) ? true : false;
                break;

            case "PUIDHigh":
                PuidHigh = XmlSafeConvert.ToInt32(xmlReader.ReadElementString());
                break;

            case "PUIDLow":
                PuidLow = XmlSafeConvert.ToInt32(xmlReader.ReadElementString());
                break;

            case "PMN":
                PMN = xmlReader.ReadElementString();
                break;
                    
            case "Role":
                Role = xmlReader.ReadElementString();
                break;

            case "ServiceInstanceId":
                ServiceInstanceId = xmlReader.ReadElementString();
                break;

            case "ServiceInstanceFriendlyName":
                InstanceFriendlyName = xmlReader.ReadElementString();
                break;

            case "ServiceInstanceStatus":
                ServiceInstanceStatus = (InstanceStatusEnum)Array.IndexOf(InstanceStatusTypes, xmlReader.ReadElementString());                        
                if( ServiceInstanceStatus < 0 ) 
                {   
                    Xom.Trace(XomAreaName.spstrace, LogLevel.L_WARNING, "Bad service instance status, using Pending" );
                    ServiceInstanceStatus = InstanceStatusEnum.Pending;                
                }
                break;

            case "BaseServiceInstanceId":
                BaseServiceInstanceId = xmlReader.ReadElementString();
                break;             

            case "ServiceComponentId":
                ServiceComponentId = xmlReader.ReadElementString();
                break;

            case "ServiceComponentName":
                ServiceComponentName = xmlReader.ReadElementString();
                break;

            case "Details":
                Details = xmlReader.ReadElementString();
                break;

            case "ProvisioningStatus":
                ProvisioningStatus = xmlReader.ReadElementString();
                break;

            case "ProvisioningErrorCode":
                ProvisioningErrorCode = xmlReader.ReadElementString();
                break;

            default:
                
                if (xmlReader.Name == rootNodeName)
                {                                   
                    // advance to the first inner element
                    xmlReader.ReadStartElement();
                    break;
                }

                if(xmlReader.NodeType == XmlNodeType.Element) 
                {
                    docFormat.Push(xmlReader.Name);
                    xmlReader.ReadStartElement();
                } 
                else // EndElement
                {                  
                    if( docFormat.Count == 0 || ((string)docFormat.Peek() != xmlReader.Name)) 
                    {
                        Xom.Trace(XomAreaName.spstrace, LogLevel.L_NORMAL, "Unrecognized Xml element: " + xmlReader.Name );
                        xmlReader.Skip();
                    } 
                    else
                    {
                        xmlReader.ReadEndElement();
                        docFormat.Pop();
                    }
                }

                break;
            }
        }
    }

    public string ToXml(string rootNodeName)
    {
        StringBuilder xmlBldr = new StringBuilder();
        ToXml(xmlBldr, rootNodeName);
        return xmlBldr.ToString();
    }


    public void ToXml(StringBuilder xmlBldr, string rootNodeName)
    {
        Debug.Assert(xmlBldr != null, "Invalid Argument");

        xmlBldr.Append("<" + (rootNodeName == null ? "ServiceInstanceSet" : rootNodeName) + " xmlns=\"urn:schemas-microsoft-com:billing-data\">");
        if( MigrationStatus != false ) 
        {
            xmlBldr.Append("<MigrationStatus>1</MigrationStatus>");
        }
        xmlBldr.Append("<ServiceInstance>");    // only describe one service instance

        xmlBldr.Append("<Role>");
        xmlBldr.Append(Role);
        xmlBldr.Append("</Role><PUIDHigh>");
        xmlBldr.Append(PuidHigh);
        xmlBldr.Append("</PUIDHigh><PUIDLow>");
        xmlBldr.Append(PuidLow);
        xmlBldr.Append("</PUIDLow><PMN>");
        xmlBldr.Append(PMN);
        xmlBldr.Append("</PMN><ServiceComponentId>");
        xmlBldr.Append(ServiceComponentId);
        xmlBldr.Append("</ServiceComponentId>");
        if(ServiceComponentName != null) 
        {    
            xmlBldr.Append("<ServiceComponentName>");
            xmlBldr.Append(ServiceComponentName);
            xmlBldr.Append("</ServiceComponentName>");
        }        
        xmlBldr.Append("<ServiceInstanceId>");
        xmlBldr.Append(ServiceInstanceId);
        xmlBldr.Append("</ServiceInstanceId><ServiceInstanceFriendlyName>");
        xmlBldr.Append(InstanceFriendlyName);
        xmlBldr.Append("</ServiceInstanceFriendlyName>");
      
        // don't write this
        /*
        xmlBldr.Append("<ServiceInstanceStatus>");
        xmlBldr.Append(InstanceStatusTypes[(int)ServiceInstanceStatus]);
        xmlBldr.Append("</ServiceInstanceStatus>");
        */
      
        if(BaseServiceInstanceId != null) 
        {
            xmlBldr.Append("<BaseServiceInstanceId>");
            xmlBldr.Append(BaseServiceInstanceId);
            xmlBldr.Append("</BaseServiceInstanceId>");
        } 
        else 
        {
            xmlBldr.Append("<BaseServiceInstanceId/>");
        }

        if(Details != null) 
        {
            xmlBldr.Append("<Details>");
            xmlBldr.Append(Details);
            xmlBldr.Append("</Details>");
        } 
        else 
        {
            xmlBldr.Append("<Details/>");
        }

        if(ProvisioningStatus != null) 
        {
            xmlBldr.Append("<ProvisioningStatus>");
            xmlBldr.Append(ProvisioningStatus);
            xmlBldr.Append("</ProvisioningStatus>");
        }
        if(ProvisioningErrorCode != null)
        {
            xmlBldr.Append("<ProvisioningErrorCode>" + ProvisioningErrorCode + "</ProvisioningErrorCode>");
        }

        xmlBldr.Append("</ServiceInstance>");
        xmlBldr.Append("</" + (rootNodeName == null ? "ServiceInstanceSet" : rootNodeName) + ">");
    }
   
    
    // validates required fieds have been set before generating xml.
    // (should this be debug only?)
    public void ValidateFields()
    {
        if (PuidHigh == 0)          throw new Exception("Missing ServiceInstance.PuidHigh");
        
        // @@slamb: it's quite possible this will be 0 and be valid..
        //if (PuidLow == 0)           throw new Exception("Missing ServiceInstance.PuidLow");
        if (PMN == null)            throw new Exception("Missing ServiceInstance.PMN");
        if (Role == null)           throw new Exception("Missing ServiceInstance.Role");
        if ((int)ServiceInstanceStatus < 0 || (int)ServiceInstanceStatus > 5) 
            throw new Exception("Bad Service Instance Status (ServiceInstance.ServiceInstanceStatus)");

        if (ServiceInstanceId == null)              throw new Exception("Missing ServiceInstance.ServiceInstanceId");
        if (InstanceFriendlyName == null)           throw new Exception("Missing ServiceInstance.ServiceInstanceFriendlyName");
        if (ServiceComponentId == null)             throw new Exception("Missing ServiceInstance.ServiceComponentId");        
    }


    
}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\marketplace\billing\SetNoAgeOut.cs ===
// SetNoAgeOutQueue.cs
// Copyright (c) Microsoft Corporation.  All Rights Reserved.

using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Net;
using System.Security.Principal;
using System.Text;
using System.Threading;

using Microsoft.Webstore.WstClient;

using xonline.common.config;
using xonline.common.service;
using xonline.common.sql.webstore;
using xonline.common.mgmt;

namespace xonline.common.billing
{
    public enum SetNoAgeOutQueueStatus : short
    {
        Failed        = -1,
        Pending       =  0,
        InProgress    =  1,
        Completed     =  2,
    }

    public enum SetNoAgeOutQueueStep : short
    {
        Start         =  0,
        Finish        =  1
    }

    public class SetNoAgeOutUtil {

        public static void SetNoAgeOut(
            ulong  userPuid,
            ulong  passportPuid
        ) {

            // see if there is an existing item we can run,
            // if so we will try to restart it down  below.

            SetNoAgeOutItem item = SetNoAgeOutItem.Load(userPuid, passportPuid, true);

            // if there is not an item we can run, check if
            // there is an item that has already  been  run

            if (item == null)
            {
                item = SetNoAgeOutItem.Load(userPuid, passportPuid, false);

                if (item != null)
                {
                    // completed is just fine.  just return
                    if (item.QueueStatus == (short) SetNoAgeOutQueueStatus.Completed) return;
                    throw new Exception("Error setting no age out");
                }

                string alternatePassportUrl = PassportClientGlobal.GetSessionAlternateUrl() ?? string.Empty;
                item = SetNoAgeOutQueue.Add(userPuid, passportPuid, alternatePassportUrl);
            }

            SetNoAgeOutQueue.SetNoAgeOut(item);
        }
    }


    public class SetNoAgeOutItem
    {
        public static SetNoAgeOutItem Load(ulong userPuid, ulong passportPuid, bool markInProgress)
        {
            HResult hr;
            SetNoAgeOutItem item = null;

            using (WSClient ws = new WSClient(ConfigUtil.UodbWebstoreApp, CmdType.WRITETHENREAD_COMMANDTYPE))
            {
                ws.SetHashVal(userPuid);
                ws.StoredProc = "dbo.p_set_no_age_out_dequeue";

                ws.AddParameter(ParamType.RETVAL, "@hr", 0);
                ws.AddParameter(ParamType.INPUT, "@bi_user_puid", userPuid);
                ws.AddParameter(ParamType.INPUT, "@bi_passport_puid", passportPuid);
                ws.AddParameter(ParamType.INPUT, "@ti_mark_in_progress", (markInProgress ? 1 : 0));

                using (WstDataReader rdr = ws.Execute())
                {
                    if (rdr.Read())
                    {
                        item = new SetNoAgeOutItem();

                        item.UserPuid             = userPuid;
                        item.PassportPuid         = passportPuid;
                        item.AlternatePassportUrl = WSClient.GetString(rdr,   "vc_alternate_passport_url");
                        item.QueueStatus          = WSClient.GetInt16(rdr,    "si_queue_status");
                        item.QueueStep            = WSClient.GetInt16(rdr,    "si_queue_step");
                        item.XonlineHr            = WSClient.GetUInt32(rdr,   "i_xonline_hr");
                        item.Initiated            = WSClient.GetDateTime(rdr, "dt_initiated");
                        item.RetryCount           = WSClient.GetInt32(rdr,    "i_retry_count");
                        item.LastRetry            = WSClient.GetDateTime(rdr, "dt_last_retry");
                    }
                }

                hr = (uint) ws.GetIntParameter("@hr");
                if (HResult.Failed(hr)) return null;
            }

            return item;
        }

        public ulong                UserPuid;
        public ulong                PassportPuid;
        public string               AlternatePassportUrl;

        public short                QueueStep;
        public HResult              XonlineHr;
        public DateTime             Initiated;
        public int                  RetryCount;
        public DateTime             LastRetry;
        public short                QueueStatus;


        public HResult Save()
        {
            using (WSClient ws = new WSClient(ConfigUtil.UodbWebstoreApp, CmdType.WRITEONLY_COMMANDTYPE))
            {
                ws.SetHashVal(UserPuid);
                ws.StoredProc = "dbo.p_set_no_age_out_update";
                ws.AddParameter(ParamType.RETVAL, "@hr", 0);

                // these are the key values for finding the item
                ws.AddParameter(ParamType.INPUT, "@bi_user_puid",     UserPuid);
                ws.AddParameter(ParamType.INPUT, "@bi_passport_puid", PassportPuid);

                // these are the values that change after each step
                ws.AddParameter(ParamType.INPUT, "@si_queue_status",  QueueStatus);
                ws.AddParameter(ParamType.INPUT, "@si_queue_step",    QueueStep);
                ws.AddParameter(ParamType.INPUT, "@i_xonline_hr",     XonlineHr);

                ws.ExecuteNonQuery();
                return (uint) ws.GetIntParameter("@hr");
            }
        }
    }

    public class SetNoAgeOutQueue
    {
        static SetNoAgeOutQueue()
        {
            XomControl.ControlRequestEvent += new XomControl.ControlRequestEventHandler(SetNoAgeOutQueue.OnControlRequest);
        }

        public static void Init()
        {
            Xom.Trace(XomAreaName.xuacs, LogLevel.L_LOW, "SetNoAgeOutQueue.Init: initializing.");
            if (Config.GetBoolSetting(Setting.xuacs_setNoAgeOutQueueStart)) Start();
            Xom.Trace(XomAreaName.xuacs, LogLevel.L_NORMAL, "SetNoAgeOutQueue.Init(): initialized.");
        }

        public static SetNoAgeOutItem Add(
            ulong  userPuid,
            ulong  passportPuid,
            string alternatePassportUrl
        )
        {
            HResult hr;

            using (WSClient ws = new WSClient(ConfigUtil.UodbWebstoreApp, CmdType.WRITEONLY_COMMANDTYPE))
            {
                ws.SetHashVal(userPuid);
                ws.StoredProc = "dbo.p_set_no_age_out_enqueue";

                ws.AddParameter(ParamType.RETVAL, "@hr", 0);
                ws.AddParameter("@bi_user_puid", userPuid);
                ws.AddParameter("@bi_passport_puid", passportPuid);
                ws.AddParameter("@vc_alternate_passport_url", alternatePassportUrl);

                ws.ExecuteNonQuery();
                hr = (uint) ws.GetIntParameter("@hr");
                ws.Close();

                if (HResult.Succeeded(hr))
                {
                    SetNoAgeOutItem item = SetNoAgeOutItem.Load(userPuid, passportPuid, false);
                    Debug.Assert(item.QueueStatus == (int) SetNoAgeOutQueueStatus.InProgress);
                    return item;
                }
            }

            throw new XRLException(
                hr, XEvent.Id.BILLING_ACCOUNTS_SET_NO_AGE_OUT_QUEUE_ERROR,
                "Error queuing work to set no age out"
            );
        }


        public static HResult SetNoAgeOut(SetNoAgeOutItem item)
        {
            HResult hr = HResult.XONLINE_E_ACCOUNTS_SET_NO_AGE_OUT_QUEUED;
            Debug.Assert(item.QueueStatus == (int) SetNoAgeOutQueueStatus.InProgress);

            // TODO - alternatePassportUrl
            if (! string.IsNullOrEmpty(item.AlternatePassportUrl))
            {
                Xom.Trace(XomAreaName.xuacs, LogLevel.L_NORMAL, "SetNoAgeOut: using alternate passport url: " + item.AlternatePassportUrl);
                PassportClientGlobal.SetSessionAlternateUrl(item.AlternatePassportUrl);
            }

            try
            {
                // reset XonlineHr
                item.XonlineHr = HResult.S_OK;

                // begin processing the queue item
                if (item.QueueStep == (int) SetNoAgeOutQueueStep.Start)
                {
                    try
                    {
                        Xom.Trace(XomAreaName.xuacs, LogLevel.L_LOW, string.Format("SetNoAgeOut: Start for userPuid {0}, passportPuiud {1}", item.UserPuid.ToString("x"), item.PassportPuid.ToString("x")));

                        PassportClientBase passportClient = PassportClientGlobal.Global;
                        passportClient.SetNoAgeOut(item.PassportPuid, true);

                        item.QueueStatus = (int) SetNoAgeOutQueueStatus.Completed;
                        item.QueueStep = (int) SetNoAgeOutQueueStep.Finish;
                        item.Save();
                    }
                    catch (Exception e)
                    {
                        Xom.Trace(XomAreaName.xuacs, LogLevel.L_ERROR, "SetNoAgeOut: caught exception performing UpdateUser step: user: 0x" + item.UserPuid.ToString("x") + ", Exception:\r\n" + e);
                        hr = HandleException(item, e);
                        return hr;
                    }
                }
            }

            finally
            {
                if (! string.IsNullOrEmpty(item.AlternatePassportUrl))
                {
                    PassportClientGlobal.ResetSessionAlternateUrl();
                }
            }

            // everything finished fine
            hr = HResult.S_OK;
            Xom.Trace(XomAreaName.xuacs, LogLevel.L_NORMAL, "SetNoAgeOut: completed successfully for user: 0x" + item.UserPuid.ToString("x"));

            return hr;
        }


        public static HResult HandleException(SetNoAgeOutItem item, Exception e)
        {
            // in nearly all cases, SET_NO_AGE_OUT_QUEUED will be returned
            HResult hr = HResult.XONLINE_E_ACCOUNTS_SET_NO_AGE_OUT_QUEUED;

            try
            {
                item.QueueStatus = (int) SetNoAgeOutQueueStatus.Pending;
                item.XonlineHr = BillingProviderException.ToHResult(e, HResult.XONLINE_E_ACCOUNTS_SET_NO_AGE_OUT_ERROR);

                // we don't have a concept of retryable for passport
                // so just go until we reach  our  own  retry  limit

                if (e is System.ServiceProcess.TimeoutException || (e is WebException && FastFailHelper.ConsiderWebExceptionAsTimeout((WebException)e)))
                {
                    item.XonlineHr = HResult.XONLINE_E_PASSPORT_TIMEOUT;
                }

                // a pending status means we will attempt to  retry.
                // stop that if we have exceeded  the  retry  limit

                if (item.QueueStatus == (int) SetNoAgeOutQueueStatus.Pending)
                {
                    if (item.RetryCount >= Config.GetIntSetting(Setting.xuacs_setNoAgeOutQueueRetryLimit))
                    {
                        item.QueueStatus = (int) SetNoAgeOutQueueStatus.Failed;
                        hr = item.XonlineHr;
                        Xom.Trace(XomAreaName.xuacs, LogLevel.L_HIGH, "SetNoAgeOutQueue.HandleException: retry limit exceeded");
                    }
                }

                item.Save();
            }
            catch (Exception ee)
            {
                Xom.Trace(XomAreaName.xuacs, LogLevel.L_ERROR, "SetNoAgeOutQueue.HandleException: caught exception trying to update UODB!  Check UODB!\r\nException: " + ee.ToString());
                throw;
            }

            return hr;
        }

        public static void Start()
        {
            WindowsIdentity id = WindowsIdentity.GetCurrent();
            ThreadPool.QueueUserWorkItem(new WaitCallback(Run), id);
        }

        public static void Stop()
        {
            _isStopped = true;

            if (_timer != null)
            {
                _timer.Dispose();
                _timer = null;
            }
        }


        public static void Run(object o)
        {
            WindowsIdentity id = (WindowsIdentity)o;
            WindowsImpersonationContext impctx = null;
            XomRequestTimeElapsed timeElapsed = new XomRequestTimeElapsed();
            XomRequestTimeElapsed createTimeElapsed;

            SetNoAgeOutQueueCounters.Current.RunsTotal.Increment();
            Xom.Trace(XomAreaName.xuacs, LogLevel.L_LOW, "SetNoAgeOutQueue.Run() starting");

            try
            {
                if (id.IsSystem == false)
                {
                    // impersonate the thread that started this
                    impctx = id.Impersonate();
                }

                // get the list of queued items
                SetNoAgeItemHeader[] itemHeaders = SetNoAgeOutQueue.GetPending();
                SetNoAgeOutQueueCounters.Current.PendingTotal.RawValue = itemHeaders.Length;

                for (int i = 0; i < itemHeaders.Length; i++)
                {
                    if (_isStopped == true)
                    {
                        Xom.Trace(XomAreaName.xuacs, LogLevel.L_LOW, "SetNoAgeOutQueue.Run() stopping");
                        return;
                    }

                    ulong userPuid = itemHeaders[i].UserPuid;
                    ulong passportPuid = itemHeaders[i].PassportPuid;

                    SetNoAgeOutItem item = SetNoAgeOutItem.Load(userPuid, passportPuid, true);

                    if (item == null)
                    {
                        SetNoAgeOutQueueCounters.Current.PendingTotal.Decrement();
                        continue;
                    }

                    createTimeElapsed = new XomRequestTimeElapsed();

                    try
                    {
                        SetNoAgeOutQueueCounters.Current.ProcessedTotal.Increment();
                        SetNoAgeOut(item);
                        SetNoAgeOutQueueCounters.Current.PendingTotal.Decrement();
                    }
                    catch (Exception)
                    {
                    }
                }
            }

            catch (Exception e)
            {
                Xom.NtEvent(XEvent.Id.BILLING_ACCOUNTS_SET_NO_AGE_OUT_DEQUEUE_ERROR, e, "SetNoAgeOutQueue.Run() queue processing failure.");
            }

            try
            {
                if (impctx != null)
                {
                    impctx.Undo();
                }

            }
            catch (Exception e)
            {
                Xom.NtEvent(XEvent.Id.BILLING_ACCOUNTS_SET_NO_AGE_OUT_IMPERSONATION_ERROR, e, "SetNoAgeOutQueue.Run() failure undoing impersonation.");
            }

            ResetTimer(id);
            Xom.Trace(XomAreaName.xuacs, LogLevel.L_LOW, "SetNoAgeOutQueue.Run() stopping");
        }

        internal class SetNoAgeItemHeader
        {
            private ulong _userPuid;
            private ulong _passportPuid;

            internal SetNoAgeItemHeader(ulong userPuid, ulong passportPuid)
            {
                _userPuid = userPuid;
                _passportPuid = passportPuid;
            }

            internal ulong UserPuid
            {
                get { return _userPuid; }
            }

            internal ulong PassportPuid
            {
                get { return _passportPuid; }
            }
        }

        internal static SetNoAgeItemHeader[] GetPending()
        {
            List<SetNoAgeItemHeader> itemHeaders = new List<SetNoAgeItemHeader>();

            using (WstConnection c = new WstConnection(ConfigUtil.UodbWebstoreApp))
            {
                c.Open();

                for (int i=0; i < c.SqlPartitions.Count; i++)
                {
                    try
                    {
                        using (WSClient ws = new WSClient(ConfigUtil.UodbWebstoreApp, CmdType.WRITETHENREAD_COMMANDTYPE))
                        {
                            ws.StoredProc = "dbo.p_set_no_age_out_get_pending";
                            ws.PhysicalPartition = i;

                            using (WstDataReader reader= ws.Execute())
                            {
                                int puidOrdinal = reader.GetOrdinal("bi_user_puid");
                                int passportPuidOrdinal = reader.GetOrdinal("bi_passport_puid");

                                while (reader.Read())
                                {
                                    itemHeaders.Add(new SetNoAgeItemHeader(
                                        (ulong) reader.GetInt64(puidOrdinal), (ulong) reader.GetInt64(passportPuidOrdinal)
                                    ));
                                }

                                Xom.Trace(XomAreaName.xuacs, LogLevel.L_NORMAL, "SetNoAgeOutQueue.GetPending() found " + itemHeaders.Count + " items");
                            }
                        }
                    }

                    // capture list of all failed partitions. But we only
                    // record one exception, the last one that we saw

                    catch (Exception e)
                    {
                        Xom.NtEvent(XEvent.Id.BILLING_ACCOUNTS_SET_NO_AGE_OUT_QUEUE_ERROR, e,
                            "SetNoAgeOutQueue.GetPending() : Error accessing partition {0}", i
                        );
                    }
                }
            }

            // Now we have the queue from all partitions, sort the whole list
            // by number of retries (least to most) and then by date (oldest
            // to newest).

            return itemHeaders.ToArray();
        }


        private static void ResetTimer(WindowsIdentity id)
        {
            try
            {
                if (_isStopped)
                {
                    return;
                }

                int intervalMilliseconds = Config.GetIntSetting(Setting. xuacs_setNoAgeOutQueueIntervalSeconds) * 1000;

                if (_timer == null)
                {
                    _timer = new Timer(new TimerCallback(Run), id, intervalMilliseconds, Timeout.Infinite);
                }
                else
                {
                    _timer.Change(intervalMilliseconds, Timeout.Infinite);
                }
            }
            catch (Exception e)
            {
               Xom.NtEvent(XEvent.Id.BILLING_ACCOUNTS_SET_NO_AGE_OUT_TIMER_ERROR, e, "SetNoAgeOutQueue.ResetTimer() failed to reset timer.");
            }
        }

        public static void OnControlRequest(object sender, ControlRequestEventArgs args)
        {
            string cmd = args.Command.ToLower();

            switch (cmd)
            {
                case "help":
                    XomControlConnection.SendMessage(
                        "SetNoAgeOutQueue help:\r\n" +
                        "  noageout start -- force no age out queue to start processing\r\n" + 
                        "  noageout stop  -- force no age out queue to stop processing\r\n",
                        args.RequestId);

                    args.Handled = true;
                    break;

                case "noageout":
                    if (args.CommandArgs.Length != 1)
                        XomControlConnection.SendMessage("Expected one parameter", args.RequestId);
                    else if (string.Compare(args.CommandArgs[0], "start", true) == 0)
                        SetNoAgeOutQueue.Start();
                    else if (string.Compare(args.CommandArgs[0], "stop", true) == 0)
                        SetNoAgeOutQueue.Stop();
                    else {
                        XomControlConnection.SendMessage("Invalid command '" + args.CommandArgs[1] + "'", args.RequestId);
                    }

                    args.Handled = true;
                    break;
            }
        }

        private static Timer _timer = null;
        private static bool _isStopped = false;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\marketplace\billing\SubscriptionInfoCollection.cs ===
using System.Collections;
using System.IO;
using System.Xml;

using xonline.common.mgmt;

namespace xonline.common.billing
{

    /// <summary>
    /// The SubscriptionInfoCollection class represents a set of subscriptions
    /// in SCS and mirrors the SubscriptionInfoSet XML schema.
    /// </summary>

public class SubscriptionInfoCollection
{
    // internal SCS instance
    private BillingProvider _bdk;


    public SubscriptionInfoCollection()
    {
    }

    public ArrayList SubscriptionInfoList = null;

    // validates required fieds have been set before generating xml.
    // (should this be debug only?)
    public void ValidateFields(bool isUpdate)
    {
    }


    public void FromXml(string xml, string rootNodeName)
    {
        XmlReaderSettings settings = new XmlReaderSettings()
        {
            IgnoreWhitespace = true,
        };

        XmlReader xmlReader = XmlReader.Create(new StringReader(xml), settings);
        FromXml(xmlReader, rootNodeName);
        xmlReader.Close();
    }

    public void FromXml(XmlTextReader xmlReader, string rootNodeName)
    {
        FromXml((XmlReader)xmlReader, rootNodeName);
    }

    public void FromXml(XmlReader xmlReader, string rootNodeName)
    {
        SubscriptionInfoList = new ArrayList();

        xmlReader.MoveToContent();
        while (!xmlReader.EOF)
        {
            if (xmlReader.NodeType == XmlNodeType.EndElement &&
                xmlReader.Name == rootNodeName)
            {
                xmlReader.Skip();
                break;
            }

            Xom.Trace(XomAreaName.spstrace, LogLevel.L_LOW, "SubscriptionInfoCollection: XmlReader - NodeType:{0}, Name:{1}",
                xmlReader.NodeType, xmlReader.Name);

            switch (xmlReader.Name)
            {
            case "SubscriptionInfo":
                SubscriptionInfo subInfo = new SubscriptionInfo();
                subInfo.FromXml(xmlReader, "SubscriptionInfo");
                SubscriptionInfoList.Add(subInfo);
                break;

            default:
                if (xmlReader.Name == rootNodeName)
                {
                    // advance to the first inner element
                    xmlReader.ReadStartElement();
                    break;
                }

                Xom.Trace(XomAreaName.spstrace, LogLevel.L_HIGH, "SubscriptionInfoCollection: Unrecognized Xml element: " + xmlReader.Name );
                xmlReader.Skip();
                break;
            }
        }
    }

    private BillingProvider BillingProvider
    {
        get {
            if (_bdk == null) _bdk = new BillingProvider();
            return _bdk;
        }

        set { _bdk = value; }
    }

    /// <summary>
    /// Used to dump the basic information on a subscription set. For debugging purposes only.
    /// (remove from retail build?)
    /// </summary>
    /// <returns></returns>
    public override string ToString()
    {
        return "SubscriptionInfoCollection: " + (SubscriptionInfoList == null ? 0 : SubscriptionInfoList.Count) + " subscriptions.";
    }

}

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\marketplace\billing\ppsa.cs ===
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:2.0.50727.4961
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

// 
// This source code was auto-generated by wsdl, Version=2.0.50727.42.
// 
namespace xonline.common.billing.passport
{
    using System.Xml.Serialization;
    using System.Web.Services;
    using System.ComponentModel;
    using System.Web.Services.Protocols;
    using System;
    using System.Diagnostics;


    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Web.Services.WebServiceBindingAttribute(Name = "CredentialServiceAPISoapServerSoap", Namespace = "http://schemas.microsoft.com/Passport/SoapServices/CredentialServiceAPI/V1")]
    [System.Xml.Serialization.XmlIncludeAttribute(typeof(string[]))]
    public partial class CredentialServiceAPISoapServerSoap : System.Web.Services.Protocols.SoapHttpClientProtocol
    {

        public PPSoapHeader_wrapper PPSoapHeader;

        public tagWSSECURITYHEADER WSSecurityHeader;

        /// <remarks/>
        public CredentialServiceAPISoapServerSoap()
        {
            this.Url = "https://ppsacredential.service.passport.net/PPSACredential.srf";
        }

        /// <remarks/>
        [System.Web.Services.Protocols.SoapHeaderAttribute("WSSecurityHeader")]
        [System.Web.Services.Protocols.SoapHeaderAttribute("PPSoapHeader")]
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("#GetPassportID", RequestNamespace = "http://schemas.microsoft.com/Passport/SoapServices/CredentialServiceAPI/V1", ResponseNamespace = "http://schemas.microsoft.com/Passport/SoapServices/CredentialServiceAPI/V1", Use = System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle = System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        [return: System.Xml.Serialization.XmlElementAttribute("pPassIDOut")]
        public tagPASSID GetPassportID(tagPASSID PassIDIn)
        {
            object[] results = this.Invoke("GetPassportID", new object[] {
                        PassIDIn});
            return ((tagPASSID)(results[0]));
        }

        /// <remarks/>
        public System.IAsyncResult BeginGetPassportID(tagPASSID PassIDIn, System.AsyncCallback callback, object asyncState)
        {
            return this.BeginInvoke("GetPassportID", new object[] {
                        PassIDIn}, callback, asyncState);
        }

        /// <remarks/>
        public tagPASSID EndGetPassportID(System.IAsyncResult asyncResult)
        {
            object[] results = this.EndInvoke(asyncResult);
            return ((tagPASSID)(results[0]));
        }

        /// <remarks/>
        [System.Web.Services.Protocols.SoapHeaderAttribute("WSSecurityHeader")]
        [System.Web.Services.Protocols.SoapHeaderAttribute("PPSoapHeader")]
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("#GetCredentialInfo", RequestNamespace = "http://schemas.microsoft.com/Passport/SoapServices/CredentialServiceAPI/V1", ResponseNamespace = "http://schemas.microsoft.com/Passport/SoapServices/CredentialServiceAPI/V1", Use = System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle = System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        [return: System.Xml.Serialization.XmlElementAttribute("pbstrcredXML")]
        public string GetCredentialInfo(tagPASSID PassIDIn, string bstrAttribList)
        {
            object[] results = this.Invoke("GetCredentialInfo", new object[] {
                        PassIDIn,
                        bstrAttribList});
            return ((string)(results[0]));
        }

        /// <remarks/>
        public System.IAsyncResult BeginGetCredentialInfo(tagPASSID PassIDIn, string bstrAttribList, System.AsyncCallback callback, object asyncState)
        {
            return this.BeginInvoke("GetCredentialInfo", new object[] {
                        PassIDIn,
                        bstrAttribList}, callback, asyncState);
        }

        /// <remarks/>
        public string EndGetCredentialInfo(System.IAsyncResult asyncResult)
        {
            object[] results = this.EndInvoke(asyncResult);
            return ((string)(results[0]));
        }

        /// <remarks/>
        [System.Web.Services.Protocols.SoapHeaderAttribute("WSSecurityHeader")]
        [System.Web.Services.Protocols.SoapHeaderAttribute("PPSoapHeader")]
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("#AddCredential", RequestNamespace = "http://schemas.microsoft.com/Passport/SoapServices/CredentialServiceAPI/V1", ResponseNamespace = "http://schemas.microsoft.com/Passport/SoapServices/CredentialServiceAPI/V1", Use = System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle = System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public void AddCredential(string bstrNamespace, string bstrCredXML, ref string pbstrNetID)
        {
            object[] results = this.Invoke("AddCredential", new object[] {
                        bstrNamespace,
                        bstrCredXML,
                        pbstrNetID});
            pbstrNetID = ((string)(results[0]));
        }

        /// <remarks/>
        public System.IAsyncResult BeginAddCredential(string bstrNamespace, string bstrCredXML, string pbstrNetID, System.AsyncCallback callback, object asyncState)
        {
            return this.BeginInvoke("AddCredential", new object[] {
                        bstrNamespace,
                        bstrCredXML,
                        pbstrNetID}, callback, asyncState);
        }

        /// <remarks/>
        public void EndAddCredential(System.IAsyncResult asyncResult, out string pbstrNetID)
        {
            object[] results = this.EndInvoke(asyncResult);
            pbstrNetID = ((string)(results[0]));
        }

        /// <remarks/>
        [System.Web.Services.Protocols.SoapHeaderAttribute("WSSecurityHeader")]
        [System.Web.Services.Protocols.SoapHeaderAttribute("PPSoapHeader")]
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("#UpdateCredential", RequestNamespace = "http://schemas.microsoft.com/Passport/SoapServices/CredentialServiceAPI/V1", ResponseNamespace = "http://schemas.microsoft.com/Passport/SoapServices/CredentialServiceAPI/V1", Use = System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle = System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public void UpdateCredential(string bstrCredXML)
        {
            this.Invoke("UpdateCredential", new object[] {
                        bstrCredXML});
        }

        /// <remarks/>
        public System.IAsyncResult BeginUpdateCredential(string bstrCredXML, System.AsyncCallback callback, object asyncState)
        {
            return this.BeginInvoke("UpdateCredential", new object[] {
                        bstrCredXML}, callback, asyncState);
        }

        /// <remarks/>
        public void EndUpdateCredential(System.IAsyncResult asyncResult)
        {
            this.EndInvoke(asyncResult);
        }

        /// <remarks/>
        [System.Web.Services.Protocols.SoapHeaderAttribute("WSSecurityHeader")]
        [System.Web.Services.Protocols.SoapHeaderAttribute("PPSoapHeader")]
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("#DeleteCredential", RequestNamespace = "http://schemas.microsoft.com/Passport/SoapServices/CredentialServiceAPI/V1", ResponseNamespace = "http://schemas.microsoft.com/Passport/SoapServices/CredentialServiceAPI/V1", Use = System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle = System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public void DeleteCredential(tagPASSID PassID)
        {
            this.Invoke("DeleteCredential", new object[] {
                        PassID});
        }

        /// <remarks/>
        public System.IAsyncResult BeginDeleteCredential(tagPASSID PassID, System.AsyncCallback callback, object asyncState)
        {
            return this.BeginInvoke("DeleteCredential", new object[] {
                        PassID}, callback, asyncState);
        }

        /// <remarks/>
        public void EndDeleteCredential(System.IAsyncResult asyncResult)
        {
            this.EndInvoke(asyncResult);
        }

        /// <remarks/>
        [System.Web.Services.Protocols.SoapHeaderAttribute("WSSecurityHeader")]
        [System.Web.Services.Protocols.SoapHeaderAttribute("PPSoapHeader")]
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("#RenameCredential", RequestNamespace = "http://schemas.microsoft.com/Passport/SoapServices/CredentialServiceAPI/V1", ResponseNamespace = "http://schemas.microsoft.com/Passport/SoapServices/CredentialServiceAPI/V1", Use = System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle = System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public void RenameCredential(tagPASSID PassIDIn, string bstrnewCredName)
        {
            this.Invoke("RenameCredential", new object[] {
                        PassIDIn,
                        bstrnewCredName});
        }

        /// <remarks/>
        public System.IAsyncResult BeginRenameCredential(tagPASSID PassIDIn, string bstrnewCredName, System.AsyncCallback callback, object asyncState)
        {
            return this.BeginInvoke("RenameCredential", new object[] {
                        PassIDIn,
                        bstrnewCredName}, callback, asyncState);
        }

        /// <remarks/>
        public void EndRenameCredential(System.IAsyncResult asyncResult)
        {
            this.EndInvoke(asyncResult);
        }

        /// <remarks/>
        [System.Web.Services.Protocols.SoapHeaderAttribute("WSSecurityHeader")]
        [System.Web.Services.Protocols.SoapHeaderAttribute("PPSoapHeader")]
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("#UnblockCredential", RequestNamespace = "http://schemas.microsoft.com/Passport/SoapServices/CredentialServiceAPI/V1", ResponseNamespace = "http://schemas.microsoft.com/Passport/SoapServices/CredentialServiceAPI/V1", Use = System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle = System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public void UnblockCredential(tagPASSID PassID)
        {
            this.Invoke("UnblockCredential", new object[] {
                        PassID});
        }

        /// <remarks/>
        public System.IAsyncResult BeginUnblockCredential(tagPASSID PassID, System.AsyncCallback callback, object asyncState)
        {
            return this.BeginInvoke("UnblockCredential", new object[] {
                        PassID}, callback, asyncState);
        }

        /// <remarks/>
        public void EndUnblockCredential(System.IAsyncResult asyncResult)
        {
            this.EndInvoke(asyncResult);
        }

        /// <remarks/>
        [System.Web.Services.Protocols.SoapHeaderAttribute("WSSecurityHeader")]
        [System.Web.Services.Protocols.SoapHeaderAttribute("PPSoapHeader")]
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("#BlockCredential", RequestNamespace = "http://schemas.microsoft.com/Passport/SoapServices/CredentialServiceAPI/V1", ResponseNamespace = "http://schemas.microsoft.com/Passport/SoapServices/CredentialServiceAPI/V1", Use = System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle = System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public void BlockCredential(tagPASSID PassID)
        {
            this.Invoke("BlockCredential", new object[] {
                        PassID});
        }

        /// <remarks/>
        public System.IAsyncResult BeginBlockCredential(tagPASSID PassID, System.AsyncCallback callback, object asyncState)
        {
            return this.BeginInvoke("BlockCredential", new object[] {
                        PassID}, callback, asyncState);
        }

        /// <remarks/>
        public void EndBlockCredential(System.IAsyncResult asyncResult)
        {
            this.EndInvoke(asyncResult);
        }

        /// <remarks/>
        [System.Web.Services.Protocols.SoapHeaderAttribute("WSSecurityHeader")]
        [System.Web.Services.Protocols.SoapHeaderAttribute("PPSoapHeader")]
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("#EnumCredentialsByName", RequestNamespace = "http://schemas.microsoft.com/Passport/SoapServices/CredentialServiceAPI/V1", ResponseNamespace = "http://schemas.microsoft.com/Passport/SoapServices/CredentialServiceAPI/V1", Use = System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle = System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        [return: System.Xml.Serialization.XmlElementAttribute("pbstrCredXML")]
        public string EnumCredentialsByName(string bstrCredName, string bstrAttribList)
        {
            object[] results = this.Invoke("EnumCredentialsByName", new object[] {
                        bstrCredName,
                        bstrAttribList});
            return ((string)(results[0]));
        }

        /// <remarks/>
        public System.IAsyncResult BeginEnumCredentialsByName(string bstrCredName, string bstrAttribList, System.AsyncCallback callback, object asyncState)
        {
            return this.BeginInvoke("EnumCredentialsByName", new object[] {
                        bstrCredName,
                        bstrAttribList}, callback, asyncState);
        }

        /// <remarks/>
        public string EndEnumCredentialsByName(System.IAsyncResult asyncResult)
        {
            object[] results = this.EndInvoke(asyncResult);
            return ((string)(results[0]));
        }

        /// <remarks/>
        [System.Web.Services.Protocols.SoapHeaderAttribute("WSSecurityHeader")]
        [System.Web.Services.Protocols.SoapHeaderAttribute("PPSoapHeader")]
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("#EnumCredentialsByNetID", RequestNamespace = "http://schemas.microsoft.com/Passport/SoapServices/CredentialServiceAPI/V1", ResponseNamespace = "http://schemas.microsoft.com/Passport/SoapServices/CredentialServiceAPI/V1", Use = System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle = System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        [return: System.Xml.Serialization.XmlElementAttribute("pbstrCredentialXML")]
        public string EnumCredentialsByNetID(string bstrNetID, string bstrAttribList)
        {
            object[] results = this.Invoke("EnumCredentialsByNetID", new object[] {
                        bstrNetID,
                        bstrAttribList});
            return ((string)(results[0]));
        }

        /// <remarks/>
        public System.IAsyncResult BeginEnumCredentialsByNetID(string bstrNetID, string bstrAttribList, System.AsyncCallback callback, object asyncState)
        {
            return this.BeginInvoke("EnumCredentialsByNetID", new object[] {
                        bstrNetID,
                        bstrAttribList}, callback, asyncState);
        }

        /// <remarks/>
        public string EndEnumCredentialsByNetID(System.IAsyncResult asyncResult)
        {
            object[] results = this.EndInvoke(asyncResult);
            return ((string)(results[0]));
        }

        /// <remarks/>
        [System.Web.Services.Protocols.SoapHeaderAttribute("WSSecurityHeader")]
        [System.Web.Services.Protocols.SoapHeaderAttribute("PPSoapHeader")]
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("#EnumCredentialsByNamespace", RequestNamespace = "http://schemas.microsoft.com/Passport/SoapServices/CredentialServiceAPI/V1", ResponseNamespace = "http://schemas.microsoft.com/Passport/SoapServices/CredentialServiceAPI/V1", Use = System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle = System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        [return: System.Xml.Serialization.XmlElementAttribute("pbstrCredListXML")]
        public string EnumCredentialsByNamespace(string bstrNamespace, string bstrStartingCredName, int NumCredsToReturn)
        {
            object[] results = this.Invoke("EnumCredentialsByNamespace", new object[] {
                        bstrNamespace,
                        bstrStartingCredName,
                        NumCredsToReturn});
            return ((string)(results[0]));
        }

        /// <remarks/>
        public System.IAsyncResult BeginEnumCredentialsByNamespace(string bstrNamespace, string bstrStartingCredName, int NumCredsToReturn, System.AsyncCallback callback, object asyncState)
        {
            return this.BeginInvoke("EnumCredentialsByNamespace", new object[] {
                        bstrNamespace,
                        bstrStartingCredName,
                        NumCredsToReturn}, callback, asyncState);
        }

        /// <remarks/>
        public string EndEnumCredentialsByNamespace(System.IAsyncResult asyncResult)
        {
            object[] results = this.EndInvoke(asyncResult);
            return ((string)(results[0]));
        }

        /// <remarks/>
        [System.Web.Services.Protocols.SoapHeaderAttribute("WSSecurityHeader")]
        [System.Web.Services.Protocols.SoapHeaderAttribute("PPSoapHeader")]
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("#GetCertificateAssociations", RequestNamespace = "http://schemas.microsoft.com/Passport/SoapServices/CredentialServiceAPI/V1", ResponseNamespace = "http://schemas.microsoft.com/Passport/SoapServices/CredentialServiceAPI/V1", Use = System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle = System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        [return: System.Xml.Serialization.XmlElementAttribute("pbstrCertXML")]
        public string GetCertificateAssociations(string bstrNetID, string bstrSigninName)
        {
            object[] results = this.Invoke("GetCertificateAssociations", new object[] {
                        bstrNetID,
                        bstrSigninName});
            return ((string)(results[0]));
        }

        /// <remarks/>
        public System.IAsyncResult BeginGetCertificateAssociations(string bstrNetID, string bstrSigninName, System.AsyncCallback callback, object asyncState)
        {
            return this.BeginInvoke("GetCertificateAssociations", new object[] {
                        bstrNetID,
                        bstrSigninName}, callback, asyncState);
        }

        /// <remarks/>
        public string EndGetCertificateAssociations(System.IAsyncResult asyncResult)
        {
            object[] results = this.EndInvoke(asyncResult);
            return ((string)(results[0]));
        }

        /// <remarks/>
        [System.Web.Services.Protocols.SoapHeaderAttribute("WSSecurityHeader")]
        [System.Web.Services.Protocols.SoapHeaderAttribute("PPSoapHeader")]
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("#DeleteCertificateAssociation", RequestNamespace = "http://schemas.microsoft.com/Passport/SoapServices/CredentialServiceAPI/V1", ResponseNamespace = "http://schemas.microsoft.com/Passport/SoapServices/CredentialServiceAPI/V1", Use = System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle = System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public void DeleteCertificateAssociation(string bstrNetID, string bstrSigninName, string bstrIssuer, string bstrSerialNumber, short sPurpose)
        {
            this.Invoke("DeleteCertificateAssociation", new object[] {
                        bstrNetID,
                        bstrSigninName,
                        bstrIssuer,
                        bstrSerialNumber,
                        sPurpose});
        }

        /// <remarks/>
        public System.IAsyncResult BeginDeleteCertificateAssociation(string bstrNetID, string bstrSigninName, string bstrIssuer, string bstrSerialNumber, short sPurpose, System.AsyncCallback callback, object asyncState)
        {
            return this.BeginInvoke("DeleteCertificateAssociation", new object[] {
                        bstrNetID,
                        bstrSigninName,
                        bstrIssuer,
                        bstrSerialNumber,
                        sPurpose}, callback, asyncState);
        }

        /// <remarks/>
        public void EndDeleteCertificateAssociation(System.IAsyncResult asyncResult)
        {
            this.EndInvoke(asyncResult);
        }

        /// <remarks/>
        [System.Web.Services.Protocols.SoapHeaderAttribute("WSSecurityHeader")]
        [System.Web.Services.Protocols.SoapHeaderAttribute("PPSoapHeader")]
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("#DeleteAllCertificateAssociations", RequestNamespace = "http://schemas.microsoft.com/Passport/SoapServices/CredentialServiceAPI/V1", ResponseNamespace = "http://schemas.microsoft.com/Passport/SoapServices/CredentialServiceAPI/V1", Use = System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle = System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public void DeleteAllCertificateAssociations(string bstrNetID, string bstrSigninName)
        {
            this.Invoke("DeleteAllCertificateAssociations", new object[] {
                        bstrNetID,
                        bstrSigninName});
        }

        /// <remarks/>
        public System.IAsyncResult BeginDeleteAllCertificateAssociations(string bstrNetID, string bstrSigninName, System.AsyncCallback callback, object asyncState)
        {
            return this.BeginInvoke("DeleteAllCertificateAssociations", new object[] {
                        bstrNetID,
                        bstrSigninName}, callback, asyncState);
        }

        /// <remarks/>
        public void EndDeleteAllCertificateAssociations(System.IAsyncResult asyncResult)
        {
            this.EndInvoke(asyncResult);
        }

        /// <remarks/>
        [System.Web.Services.Protocols.SoapHeaderAttribute("WSSecurityHeader")]
        [System.Web.Services.Protocols.SoapHeaderAttribute("PPSoapHeader")]
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("#GetSigninNamesForNetIDs", RequestNamespace = "http://schemas.microsoft.com/Passport/SoapServices/CredentialServiceAPI/V1", ResponseNamespace = "http://schemas.microsoft.com/Passport/SoapServices/CredentialServiceAPI/V1", Use = System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle = System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        [return: System.Xml.Serialization.XmlElementAttribute("pbstrCredXML")]
        public string GetSigninNamesForNetIDs(string bstrNetIDs)
        {
            object[] results = this.Invoke("GetSigninNamesForNetIDs", new object[] {
                        bstrNetIDs});
            return ((string)(results[0]));
        }

        /// <remarks/>
        public System.IAsyncResult BeginGetSigninNamesForNetIDs(string bstrNetIDs, System.AsyncCallback callback, object asyncState)
        {
            return this.BeginInvoke("GetSigninNamesForNetIDs", new object[] {
                        bstrNetIDs}, callback, asyncState);
        }

        /// <remarks/>
        public string EndGetSigninNamesForNetIDs(System.IAsyncResult asyncResult)
        {
            object[] results = this.EndInvoke(asyncResult);
            return ((string)(results[0]));
        }

        /// <remarks/>
        [System.Web.Services.Protocols.SoapHeaderAttribute("WSSecurityHeader")]
        [System.Web.Services.Protocols.SoapHeaderAttribute("PPSoapHeader")]
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("#ForceCredentialRename", RequestNamespace = "http://schemas.microsoft.com/Passport/SoapServices/CredentialServiceAPI/V1", ResponseNamespace = "http://schemas.microsoft.com/Passport/SoapServices/CredentialServiceAPI/V1", Use = System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle = System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public void ForceCredentialRename(tagPASSID PassID)
        {
            this.Invoke("ForceCredentialRename", new object[] {
                        PassID});
        }

        /// <remarks/>
        public System.IAsyncResult BeginForceCredentialRename(tagPASSID PassID, System.AsyncCallback callback, object asyncState)
        {
            return this.BeginInvoke("ForceCredentialRename", new object[] {
                        PassID}, callback, asyncState);
        }

        /// <remarks/>
        public void EndForceCredentialRename(System.IAsyncResult asyncResult)
        {
            this.EndInvoke(asyncResult);
        }

        /// <remarks/>
        [System.Web.Services.Protocols.SoapHeaderAttribute("WSSecurityHeader")]
        [System.Web.Services.Protocols.SoapHeaderAttribute("PPSoapHeader")]
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("#GetNetIDsForSigninNames", RequestNamespace = "http://schemas.microsoft.com/Passport/SoapServices/CredentialServiceAPI/V1", ResponseNamespace = "http://schemas.microsoft.com/Passport/SoapServices/CredentialServiceAPI/V1", Use = System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle = System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        [return: System.Xml.Serialization.XmlElementAttribute("pbstrCredXML")]
        public string GetNetIDsForSigninNames(string bstrSigninNames)
        {
            object[] results = this.Invoke("GetNetIDsForSigninNames", new object[] {
                        bstrSigninNames});
            return ((string)(results[0]));
        }

        /// <remarks/>
        public System.IAsyncResult BeginGetNetIDsForSigninNames(string bstrSigninNames, System.AsyncCallback callback, object asyncState)
        {
            return this.BeginInvoke("GetNetIDsForSigninNames", new object[] {
                        bstrSigninNames}, callback, asyncState);
        }

        /// <remarks/>
        public string EndGetNetIDsForSigninNames(System.IAsyncResult asyncResult)
        {
            object[] results = this.EndInvoke(asyncResult);
            return ((string)(results[0]));
        }

        /// <remarks/>
        [System.Web.Services.Protocols.SoapHeaderAttribute("WSSecurityHeader")]
        [System.Web.Services.Protocols.SoapHeaderAttribute("PPSoapHeader")]
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("#QueryCredentialChanges", RequestNamespace = "http://schemas.microsoft.com/Passport/SoapServices/CredentialServiceAPI/V1", ResponseNamespace = "http://schemas.microsoft.com/Passport/SoapServices/CredentialServiceAPI/V1", Use = System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle = System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        [return: System.Xml.Serialization.XmlElementAttribute("ChangesXml")]
        public string QueryCredentialChanges(string OptionsXml)
        {
            object[] results = this.Invoke("QueryCredentialChanges", new object[] {
                        OptionsXml});
            return ((string)(results[0]));
        }

        /// <remarks/>
        public System.IAsyncResult BeginQueryCredentialChanges(string OptionsXml, System.AsyncCallback callback, object asyncState)
        {
            return this.BeginInvoke("QueryCredentialChanges", new object[] {
                        OptionsXml}, callback, asyncState);
        }

        /// <remarks/>
        public string EndQueryCredentialChanges(System.IAsyncResult asyncResult)
        {
            object[] results = this.EndInvoke(asyncResult);
            return ((string)(results[0]));
        }

        /// <remarks/>
        [System.Web.Services.Protocols.SoapHeaderAttribute("WSSecurityHeader")]
        [System.Web.Services.Protocols.SoapHeaderAttribute("PPSoapHeader")]
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("#QueryCredentialHistory", RequestNamespace = "http://schemas.microsoft.com/Passport/SoapServices/CredentialServiceAPI/V1", ResponseNamespace = "http://schemas.microsoft.com/Passport/SoapServices/CredentialServiceAPI/V1", Use = System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle = System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        [return: System.Xml.Serialization.XmlElementAttribute("ChangeHistory")]
        public string QueryCredentialHistory(string StartAfterDateTime, string EndAtDateTime, string CredType, string ChangeType, string OptionalDomainAuthority, int NumRecordsMax, string StartAfterChangeID)
        {
            object[] results = this.Invoke("QueryCredentialHistory", new object[] {
                        StartAfterDateTime,
                        EndAtDateTime,
                        CredType,
                        ChangeType,
                        OptionalDomainAuthority,
                        NumRecordsMax,
                        StartAfterChangeID});
            return ((string)(results[0]));
        }

        /// <remarks/>
        public System.IAsyncResult BeginQueryCredentialHistory(string StartAfterDateTime, string EndAtDateTime, string CredType, string ChangeType, string OptionalDomainAuthority, int NumRecordsMax, string StartAfterChangeID, System.AsyncCallback callback, object asyncState)
        {
            return this.BeginInvoke("QueryCredentialHistory", new object[] {
                        StartAfterDateTime,
                        EndAtDateTime,
                        CredType,
                        ChangeType,
                        OptionalDomainAuthority,
                        NumRecordsMax,
                        StartAfterChangeID}, callback, asyncState);
        }

        /// <remarks/>
        public string EndQueryCredentialHistory(System.IAsyncResult asyncResult)
        {
            object[] results = this.EndInvoke(asyncResult);
            return ((string)(results[0]));
        }

        /// <remarks/>
        [System.Web.Services.Protocols.SoapHeaderAttribute("WSSecurityHeader")]
        [System.Web.Services.Protocols.SoapHeaderAttribute("PPSoapHeader")]
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("#QueryCredentialHistoryByNetID", RequestNamespace = "http://schemas.microsoft.com/Passport/SoapServices/CredentialServiceAPI/V1", ResponseNamespace = "http://schemas.microsoft.com/Passport/SoapServices/CredentialServiceAPI/V1", Use = System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle = System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        [return: System.Xml.Serialization.XmlElementAttribute("ChangeHistory")]
        public string QueryCredentialHistoryByNetID(string StartAfterDateTime, string EndAtDateTime, string NetID, string CredType, string ChangeType, int NumRecordsMax, string StartAfterChangeID)
        {
            object[] results = this.Invoke("QueryCredentialHistoryByNetID", new object[] {
                        StartAfterDateTime,
                        EndAtDateTime,
                        NetID,
                        CredType,
                        ChangeType,
                        NumRecordsMax,
                        StartAfterChangeID});
            return ((string)(results[0]));
        }

        /// <remarks/>
        public System.IAsyncResult BeginQueryCredentialHistoryByNetID(string StartAfterDateTime, string EndAtDateTime, string NetID, string CredType, string ChangeType, int NumRecordsMax, string StartAfterChangeID, System.AsyncCallback callback, object asyncState)
        {
            return this.BeginInvoke("QueryCredentialHistoryByNetID", new object[] {
                        StartAfterDateTime,
                        EndAtDateTime,
                        NetID,
                        CredType,
                        ChangeType,
                        NumRecordsMax,
                        StartAfterChangeID}, callback, asyncState);
        }

        /// <remarks/>
        public string EndQueryCredentialHistoryByNetID(System.IAsyncResult asyncResult)
        {
            object[] results = this.EndInvoke(asyncResult);
            return ((string)(results[0]));
        }

        /// <remarks/>
        [System.Web.Services.Protocols.SoapHeaderAttribute("WSSecurityHeader")]
        [System.Web.Services.Protocols.SoapHeaderAttribute("PPSoapHeader")]
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("#QueryNetIDHistoryBySigninName", RequestNamespace = "http://schemas.microsoft.com/Passport/SoapServices/CredentialServiceAPI/V1", ResponseNamespace = "http://schemas.microsoft.com/Passport/SoapServices/CredentialServiceAPI/V1", Use = System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle = System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        [return: System.Xml.Serialization.XmlElementAttribute("NetIDHistory")]
        public string QueryNetIDHistoryBySigninName(string StartAfterDateTime, string EndAtDateTime, string SigninName, int NumRecordsMax)
        {
            object[] results = this.Invoke("QueryNetIDHistoryBySigninName", new object[] {
                        StartAfterDateTime,
                        EndAtDateTime,
                        SigninName,
                        NumRecordsMax});
            return ((string)(results[0]));
        }

        /// <remarks/>
        public System.IAsyncResult BeginQueryNetIDHistoryBySigninName(string StartAfterDateTime, string EndAtDateTime, string SigninName, int NumRecordsMax, System.AsyncCallback callback, object asyncState)
        {
            return this.BeginInvoke("QueryNetIDHistoryBySigninName", new object[] {
                        StartAfterDateTime,
                        EndAtDateTime,
                        SigninName,
                        NumRecordsMax}, callback, asyncState);
        }

        /// <remarks/>
        public string EndQueryNetIDHistoryBySigninName(System.IAsyncResult asyncResult)
        {
            object[] results = this.EndInvoke(asyncResult);
            return ((string)(results[0]));
        }

        /// <remarks/>
        [System.Web.Services.Protocols.SoapHeaderAttribute("WSSecurityHeader")]
        [System.Web.Services.Protocols.SoapHeaderAttribute("PPSoapHeader")]
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("#SuggestAlternateMemberNames", RequestNamespace = "http://schemas.microsoft.com/Passport/SoapServices/CredentialServiceAPI/V1", ResponseNamespace = "http://schemas.microsoft.com/Passport/SoapServices/CredentialServiceAPI/V1", Use = System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle = System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        [return: System.Xml.Serialization.XmlElementAttribute("Names")]
        public string SuggestAlternateMemberNames(string Namespace, string FirstName, string LastName, string RequestedName)
        {
            object[] results = this.Invoke("SuggestAlternateMemberNames", new object[] {
                        Namespace,
                        FirstName,
                        LastName,
                        RequestedName});
            return ((string)(results[0]));
        }

        /// <remarks/>
        public System.IAsyncResult BeginSuggestAlternateMemberNames(string Namespace, string FirstName, string LastName, string RequestedName, System.AsyncCallback callback, object asyncState)
        {
            return this.BeginInvoke("SuggestAlternateMemberNames", new object[] {
                        Namespace,
                        FirstName,
                        LastName,
                        RequestedName}, callback, asyncState);
        }

        /// <remarks/>
        public string EndSuggestAlternateMemberNames(System.IAsyncResult asyncResult)
        {
            object[] results = this.EndInvoke(asyncResult);
            return ((string)(results[0]));
        }

        /// <remarks/>
        [System.Web.Services.Protocols.SoapHeaderAttribute("WSSecurityHeader")]
        [System.Web.Services.Protocols.SoapHeaderAttribute("PPSoapHeader")]
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("#GetSigninNamesAndCIDsForNetIDs", RequestNamespace = "http://schemas.microsoft.com/Passport/SoapServices/CredentialServiceAPI/V1", ResponseNamespace = "http://schemas.microsoft.com/Passport/SoapServices/CredentialServiceAPI/V1", Use = System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle = System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        [return: System.Xml.Serialization.XmlElementAttribute("pbstrCredXML")]
        public string GetSigninNamesAndCIDsForNetIDs(string bstrNetIDs)
        {
            object[] results = this.Invoke("GetSigninNamesAndCIDsForNetIDs", new object[] {
                        bstrNetIDs});
            return ((string)(results[0]));
        }

        /// <remarks/>
        public System.IAsyncResult BeginGetSigninNamesAndCIDsForNetIDs(string bstrNetIDs, System.AsyncCallback callback, object asyncState)
        {
            return this.BeginInvoke("GetSigninNamesAndCIDsForNetIDs", new object[] {
                        bstrNetIDs}, callback, asyncState);
        }

        /// <remarks/>
        public string EndGetSigninNamesAndCIDsForNetIDs(System.IAsyncResult asyncResult)
        {
            object[] results = this.EndInvoke(asyncResult);
            return ((string)(results[0]));
        }

        /// <remarks/>
        [System.Web.Services.Protocols.SoapHeaderAttribute("WSSecurityHeader")]
        [System.Web.Services.Protocols.SoapHeaderAttribute("PPSoapHeader")]
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("#GetNetIDsAndCIDsForSigninNames", RequestNamespace = "http://schemas.microsoft.com/Passport/SoapServices/CredentialServiceAPI/V1", ResponseNamespace = "http://schemas.microsoft.com/Passport/SoapServices/CredentialServiceAPI/V1", Use = System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle = System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        [return: System.Xml.Serialization.XmlElementAttribute("pbstrCredXML")]
        public string GetNetIDsAndCIDsForSigninNames(string bstrSigninNames)
        {
            object[] results = this.Invoke("GetNetIDsAndCIDsForSigninNames", new object[] {
                        bstrSigninNames});
            return ((string)(results[0]));
        }

        /// <remarks/>
        public System.IAsyncResult BeginGetNetIDsAndCIDsForSigninNames(string bstrSigninNames, System.AsyncCallback callback, object asyncState)
        {
            return this.BeginInvoke("GetNetIDsAndCIDsForSigninNames", new object[] {
                        bstrSigninNames}, callback, asyncState);
        }

        /// <remarks/>
        public string EndGetNetIDsAndCIDsForSigninNames(System.IAsyncResult asyncResult)
        {
            object[] results = this.EndInvoke(asyncResult);
            return ((string)(results[0]));
        }

        /// <remarks/>
        [System.Web.Services.Protocols.SoapHeaderAttribute("WSSecurityHeader")]
        [System.Web.Services.Protocols.SoapHeaderAttribute("PPSoapHeader")]
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("#CheckAvailableSigninNames", RequestNamespace = "http://schemas.microsoft.com/Passport/SoapServices/CredentialServiceAPI/V1", ResponseNamespace = "http://schemas.microsoft.com/Passport/SoapServices/CredentialServiceAPI/V1", Use = System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle = System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        [return: System.Xml.Serialization.XmlElementAttribute("pbstrCredXML")]
        public string CheckAvailableSigninNames(string bstrSigninNames)
        {
            object[] results = this.Invoke("CheckAvailableSigninNames", new object[] {
                        bstrSigninNames});
            return ((string)(results[0]));
        }

        /// <remarks/>
        public System.IAsyncResult BeginCheckAvailableSigninNames(string bstrSigninNames, System.AsyncCallback callback, object asyncState)
        {
            return this.BeginInvoke("CheckAvailableSigninNames", new object[] {
                        bstrSigninNames}, callback, asyncState);
        }

        /// <remarks/>
        public string EndCheckAvailableSigninNames(System.IAsyncResult asyncResult)
        {
            object[] results = this.EndInvoke(asyncResult);
            return ((string)(results[0]));
        }

        /// <remarks/>
        [System.Web.Services.Protocols.SoapHeaderAttribute("WSSecurityHeader")]
        [System.Web.Services.Protocols.SoapHeaderAttribute("PPSoapHeader")]
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("#CheckRenameRules", RequestNamespace = "http://schemas.microsoft.com/Passport/SoapServices/CredentialServiceAPI/V1", ResponseNamespace = "http://schemas.microsoft.com/Passport/SoapServices/CredentialServiceAPI/V1", Use = System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle = System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        [return: System.Xml.Serialization.XmlElementAttribute("pbstrAvailableAttributes")]
        public string CheckRenameRules(tagPASSID PassIDIn)
        {
            object[] results = this.Invoke("CheckRenameRules", new object[] {
                        PassIDIn});
            return ((string)(results[0]));
        }

        /// <remarks/>
        public System.IAsyncResult BeginCheckRenameRules(tagPASSID PassIDIn, System.AsyncCallback callback, object asyncState)
        {
            return this.BeginInvoke("CheckRenameRules", new object[] {
                        PassIDIn}, callback, asyncState);
        }

        /// <remarks/>
        public string EndCheckRenameRules(System.IAsyncResult asyncResult)
        {
            object[] results = this.EndInvoke(asyncResult);
            return ((string)(results[0]));
        }

        /// <remarks/>
        [System.Web.Services.Protocols.SoapHeaderAttribute("WSSecurityHeader")]
        [System.Web.Services.Protocols.SoapHeaderAttribute("PPSoapHeader")]
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("#RenameCredentialEx", RequestNamespace = "http://schemas.microsoft.com/Passport/SoapServices/CredentialServiceAPI/V1", ResponseNamespace = "http://schemas.microsoft.com/Passport/SoapServices/CredentialServiceAPI/V1", Use = System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle = System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public void RenameCredentialEx(tagPASSID PassIDIn, string bstrNewSigninName, string bstrOptionalParams)
        {
            this.Invoke("RenameCredentialEx", new object[] {
                        PassIDIn,
                        bstrNewSigninName,
                        bstrOptionalParams});
        }

        /// <remarks/>
        public System.IAsyncResult BeginRenameCredentialEx(tagPASSID PassIDIn, string bstrNewSigninName, string bstrOptionalParams, System.AsyncCallback callback, object asyncState)
        {
            return this.BeginInvoke("RenameCredentialEx", new object[] {
                        PassIDIn,
                        bstrNewSigninName,
                        bstrOptionalParams}, callback, asyncState);
        }

        /// <remarks/>
        public void EndRenameCredentialEx(System.IAsyncResult asyncResult)
        {
            this.EndInvoke(asyncResult);
        }

        /// <remarks/>
        [System.Web.Services.Protocols.SoapHeaderAttribute("WSSecurityHeader")]
        [System.Web.Services.Protocols.SoapHeaderAttribute("PPSoapHeader")]
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("#ReserveName", RequestNamespace = "http://schemas.microsoft.com/Passport/SoapServices/CredentialServiceAPI/V1", ResponseNamespace = "http://schemas.microsoft.com/Passport/SoapServices/CredentialServiceAPI/V1", Use = System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle = System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public void ReserveName(tagPASSID PassIDIn, string bstrNewSigninName)
        {
            this.Invoke("ReserveName", new object[] {
                        PassIDIn,
                        bstrNewSigninName});
        }

        /// <remarks/>
        public System.IAsyncResult BeginReserveName(tagPASSID PassIDIn, string bstrNewSigninName, System.AsyncCallback callback, object asyncState)
        {
            return this.BeginInvoke("ReserveName", new object[] {
                        PassIDIn,
                        bstrNewSigninName}, callback, asyncState);
        }

        /// <remarks/>
        public void EndReserveName(System.IAsyncResult asyncResult)
        {
            this.EndInvoke(asyncResult);
        }

        /// <remarks/>
        [System.Web.Services.Protocols.SoapHeaderAttribute("WSSecurityHeader")]
        [System.Web.Services.Protocols.SoapHeaderAttribute("PPSoapHeader")]
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("#AddLinkAccounts", RequestNamespace = "http://schemas.microsoft.com/Passport/SoapServices/CredentialServiceAPI/V1", ResponseNamespace = "http://schemas.microsoft.com/Passport/SoapServices/CredentialServiceAPI/V1", Use = System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle = System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public void AddLinkAccounts(string bstrLinkProofData, ref string pbstrLinkID)
        {
            object[] results = this.Invoke("AddLinkAccounts", new object[] {
                        bstrLinkProofData,
                        pbstrLinkID});
            pbstrLinkID = ((string)(results[0]));
        }

        /// <remarks/>
        public System.IAsyncResult BeginAddLinkAccounts(string bstrLinkProofData, string pbstrLinkID, System.AsyncCallback callback, object asyncState)
        {
            return this.BeginInvoke("AddLinkAccounts", new object[] {
                        bstrLinkProofData,
                        pbstrLinkID}, callback, asyncState);
        }

        /// <remarks/>
        public void EndAddLinkAccounts(System.IAsyncResult asyncResult, out string pbstrLinkID)
        {
            object[] results = this.EndInvoke(asyncResult);
            pbstrLinkID = ((string)(results[0]));
        }

        /// <remarks/>
        [System.Web.Services.Protocols.SoapHeaderAttribute("WSSecurityHeader")]
        [System.Web.Services.Protocols.SoapHeaderAttribute("PPSoapHeader")]
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("#DeLinkAccounts", RequestNamespace = "http://schemas.microsoft.com/Passport/SoapServices/CredentialServiceAPI/V1", ResponseNamespace = "http://schemas.microsoft.com/Passport/SoapServices/CredentialServiceAPI/V1", Use = System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle = System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public void DeLinkAccounts(string bstrSigninNames, string SLT)
        {
            this.Invoke("DeLinkAccounts", new object[] {
                        bstrSigninNames,
                        SLT});
        }

        /// <remarks/>
        public System.IAsyncResult BeginDeLinkAccounts(string bstrSigninNames, string SLT, System.AsyncCallback callback, object asyncState)
        {
            return this.BeginInvoke("DeLinkAccounts", new object[] {
                        bstrSigninNames,
                        SLT}, callback, asyncState);
        }

        /// <remarks/>
        public void EndDeLinkAccounts(System.IAsyncResult asyncResult)
        {
            this.EndInvoke(asyncResult);
        }

        /// <remarks/>
        [System.Web.Services.Protocols.SoapHeaderAttribute("WSSecurityHeader")]
        [System.Web.Services.Protocols.SoapHeaderAttribute("PPSoapHeader")]
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("#GetLinkAccountMembers", RequestNamespace = "http://schemas.microsoft.com/Passport/SoapServices/CredentialServiceAPI/V1", ResponseNamespace = "http://schemas.microsoft.com/Passport/SoapServices/CredentialServiceAPI/V1", Use = System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle = System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        [return: System.Xml.Serialization.XmlElementAttribute("pbstrLinkCredXML")]
        public string GetLinkAccountMembers(string bstrLinkID)
        {
            object[] results = this.Invoke("GetLinkAccountMembers", new object[] {
                        bstrLinkID});
            return ((string)(results[0]));
        }

        /// <remarks/>
        public System.IAsyncResult BeginGetLinkAccountMembers(string bstrLinkID, System.AsyncCallback callback, object asyncState)
        {
            return this.BeginInvoke("GetLinkAccountMembers", new object[] {
                        bstrLinkID}, callback, asyncState);
        }

        /// <remarks/>
        public string EndGetLinkAccountMembers(System.IAsyncResult asyncResult)
        {
            object[] results = this.EndInvoke(asyncResult);
            return ((string)(results[0]));
        }

        /// <remarks/>
        [System.Web.Services.Protocols.SoapHeaderAttribute("WSSecurityHeader")]
        [System.Web.Services.Protocols.SoapHeaderAttribute("PPSoapHeader")]
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("#AssociateCertificate", RequestNamespace = "http://schemas.microsoft.com/Passport/SoapServices/CredentialServiceAPI/V1", ResponseNamespace = "http://schemas.microsoft.com/Passport/SoapServices/CredentialServiceAPI/V1", Use = System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle = System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public void AssociateCertificate(string bstrCertType, string bstrNetID, string bstrCertificateToken)
        {
            this.Invoke("AssociateCertificate", new object[] {
                        bstrCertType,
                        bstrNetID,
                        bstrCertificateToken});
        }

        /// <remarks/>
        public System.IAsyncResult BeginAssociateCertificate(string bstrCertType, string bstrNetID, string bstrCertificateToken, System.AsyncCallback callback, object asyncState)
        {
            return this.BeginInvoke("AssociateCertificate", new object[] {
                        bstrCertType,
                        bstrNetID,
                        bstrCertificateToken}, callback, asyncState);
        }

        /// <remarks/>
        public void EndAssociateCertificate(System.IAsyncResult asyncResult)
        {
            this.EndInvoke(asyncResult);
        }

        /// <remarks/>
        [System.Web.Services.Protocols.SoapHeaderAttribute("WSSecurityHeader")]
        [System.Web.Services.Protocols.SoapHeaderAttribute("PPSoapHeader")]
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("#DisassociateCertificate", RequestNamespace = "http://schemas.microsoft.com/Passport/SoapServices/CredentialServiceAPI/V1", ResponseNamespace = "http://schemas.microsoft.com/Passport/SoapServices/CredentialServiceAPI/V1", Use = System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle = System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public void DisassociateCertificate(string bstrCertType, string bstrNetID, string bstrCertificateList)
        {
            this.Invoke("DisassociateCertificate", new object[] {
                        bstrCertType,
                        bstrNetID,
                        bstrCertificateList});
        }

        /// <remarks/>
        public System.IAsyncResult BeginDisassociateCertificate(string bstrCertType, string bstrNetID, string bstrCertificateList, System.AsyncCallback callback, object asyncState)
        {
            return this.BeginInvoke("DisassociateCertificate", new object[] {
                        bstrCertType,
                        bstrNetID,
                        bstrCertificateList}, callback, asyncState);
        }

        /// <remarks/>
        public void EndDisassociateCertificate(System.IAsyncResult asyncResult)
        {
            this.EndInvoke(asyncResult);
        }

        /// <remarks/>
        [System.Web.Services.Protocols.SoapHeaderAttribute("WSSecurityHeader")]
        [System.Web.Services.Protocols.SoapHeaderAttribute("PPSoapHeader")]
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("#DeleteCredentialEx", RequestNamespace = "http://schemas.microsoft.com/Passport/SoapServices/CredentialServiceAPI/V1", ResponseNamespace = "http://schemas.microsoft.com/Passport/SoapServices/CredentialServiceAPI/V1", Use = System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle = System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public void DeleteCredentialEx(tagPASSID PassIDIn, string bstrOptionalParams)
        {
            this.Invoke("DeleteCredentialEx", new object[] {
                        PassIDIn,
                        bstrOptionalParams});
        }

        /// <remarks/>
        public System.IAsyncResult BeginDeleteCredentialEx(tagPASSID PassIDIn, string bstrOptionalParams, System.AsyncCallback callback, object asyncState)
        {
            return this.BeginInvoke("DeleteCredentialEx", new object[] {
                        PassIDIn,
                        bstrOptionalParams}, callback, asyncState);
        }

        /// <remarks/>
        public void EndDeleteCredentialEx(System.IAsyncResult asyncResult)
        {
            this.EndInvoke(asyncResult);
        }

        /// <remarks/>
        [System.Web.Services.Protocols.SoapHeaderAttribute("WSSecurityHeader")]
        [System.Web.Services.Protocols.SoapHeaderAttribute("PPSoapHeader")]
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("#CreateAlias", RequestNamespace = "http://schemas.microsoft.com/Passport/SoapServices/CredentialServiceAPI/V1", ResponseNamespace = "http://schemas.microsoft.com/Passport/SoapServices/CredentialServiceAPI/V1", Use = System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle = System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        [return: System.Xml.Serialization.XmlElementAttribute("pbstrAUID")]
        public string CreateAlias(tagPASSID PassIDIn, string bstrAliasXML, bool fSuggestName, out string pbstrSuggestedNames)
        {
            object[] results = this.Invoke("CreateAlias", new object[] {
                        PassIDIn,
                        bstrAliasXML,
                        fSuggestName});
            pbstrSuggestedNames = ((string)(results[1]));
            return ((string)(results[0]));
        }

        /// <remarks/>
        public System.IAsyncResult BeginCreateAlias(tagPASSID PassIDIn, string bstrAliasXML, bool fSuggestName, System.AsyncCallback callback, object asyncState)
        {
            return this.BeginInvoke("CreateAlias", new object[] {
                        PassIDIn,
                        bstrAliasXML,
                        fSuggestName}, callback, asyncState);
        }

        /// <remarks/>
        public string EndCreateAlias(System.IAsyncResult asyncResult, out string pbstrSuggestedNames)
        {
            object[] results = this.EndInvoke(asyncResult);
            pbstrSuggestedNames = ((string)(results[1]));
            return ((string)(results[0]));
        }

        /// <remarks/>
        [System.Web.Services.Protocols.SoapHeaderAttribute("WSSecurityHeader")]
        [System.Web.Services.Protocols.SoapHeaderAttribute("PPSoapHeader")]
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("#UpdateAlias", RequestNamespace = "http://schemas.microsoft.com/Passport/SoapServices/CredentialServiceAPI/V1", ResponseNamespace = "http://schemas.microsoft.com/Passport/SoapServices/CredentialServiceAPI/V1", Use = System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle = System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public void UpdateAlias(tagPASSID PassIDIn, string bstrAliasXML)
        {
            this.Invoke("UpdateAlias", new object[] {
                        PassIDIn,
                        bstrAliasXML});
        }

        /// <remarks/>
        public System.IAsyncResult BeginUpdateAlias(tagPASSID PassIDIn, string bstrAliasXML, System.AsyncCallback callback, object asyncState)
        {
            return this.BeginInvoke("UpdateAlias", new object[] {
                        PassIDIn,
                        bstrAliasXML}, callback, asyncState);
        }

        /// <remarks/>
        public void EndUpdateAlias(System.IAsyncResult asyncResult)
        {
            this.EndInvoke(asyncResult);
        }

        /// <remarks/>
        [System.Web.Services.Protocols.SoapHeaderAttribute("WSSecurityHeader")]
        [System.Web.Services.Protocols.SoapHeaderAttribute("PPSoapHeader")]
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("#DeleteAlias", RequestNamespace = "http://schemas.microsoft.com/Passport/SoapServices/CredentialServiceAPI/V1", ResponseNamespace = "http://schemas.microsoft.com/Passport/SoapServices/CredentialServiceAPI/V1", Use = System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle = System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public void DeleteAlias(tagPASSID PassIDIn, string bstrAliasXML)
        {
            this.Invoke("DeleteAlias", new object[] {
                        PassIDIn,
                        bstrAliasXML});
        }

        /// <remarks/>
        public System.IAsyncResult BeginDeleteAlias(tagPASSID PassIDIn, string bstrAliasXML, System.AsyncCallback callback, object asyncState)
        {
            return this.BeginInvoke("DeleteAlias", new object[] {
                        PassIDIn,
                        bstrAliasXML}, callback, asyncState);
        }

        /// <remarks/>
        public void EndDeleteAlias(System.IAsyncResult asyncResult)
        {
            this.EndInvoke(asyncResult);
        }

        /// <remarks/>
        [System.Web.Services.Protocols.SoapHeaderAttribute("WSSecurityHeader")]
        [System.Web.Services.Protocols.SoapHeaderAttribute("PPSoapHeader")]
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("#RenameAlias", RequestNamespace = "http://schemas.microsoft.com/Passport/SoapServices/CredentialServiceAPI/V1", ResponseNamespace = "http://schemas.microsoft.com/Passport/SoapServices/CredentialServiceAPI/V1", Use = System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle = System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        [return: System.Xml.Serialization.XmlElementAttribute("pbstrAliasXML")]
        public string RenameAlias(tagPASSID PassIDIn, string bstrOldName, string bstrNewName)
        {
            object[] results = this.Invoke("RenameAlias", new object[] {
                        PassIDIn,
                        bstrOldName,
                        bstrNewName});
            return ((string)(results[0]));
        }

        /// <remarks/>
        public System.IAsyncResult BeginRenameAlias(tagPASSID PassIDIn, string bstrOldName, string bstrNewName, System.AsyncCallback callback, object asyncState)
        {
            return this.BeginInvoke("RenameAlias", new object[] {
                        PassIDIn,
                        bstrOldName,
                        bstrNewName}, callback, asyncState);
        }

        /// <remarks/>
        public string EndRenameAlias(System.IAsyncResult asyncResult)
        {
            object[] results = this.EndInvoke(asyncResult);
            return ((string)(results[0]));
        }

        /// <remarks/>
        [System.Web.Services.Protocols.SoapHeaderAttribute("WSSecurityHeader")]
        [System.Web.Services.Protocols.SoapHeaderAttribute("PPSoapHeader")]
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("#GetAliasesForAccount", RequestNamespace = "http://schemas.microsoft.com/Passport/SoapServices/CredentialServiceAPI/V1", ResponseNamespace = "http://schemas.microsoft.com/Passport/SoapServices/CredentialServiceAPI/V1", Use = System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle = System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        [return: System.Xml.Serialization.XmlElementAttribute("pbstrAliasXML")]
        public string GetAliasesForAccount(tagPASSID PassIDIn, string bstrOptionalParams)
        {
            object[] results = this.Invoke("GetAliasesForAccount", new object[] {
                        PassIDIn,
                        bstrOptionalParams});
            return ((string)(results[0]));
        }

        /// <remarks/>
        public System.IAsyncResult BeginGetAliasesForAccount(tagPASSID PassIDIn, string bstrOptionalParams, System.AsyncCallback callback, object asyncState)
        {
            return this.BeginInvoke("GetAliasesForAccount", new object[] {
                        PassIDIn,
                        bstrOptionalParams}, callback, asyncState);
        }

        /// <remarks/>
        public string EndGetAliasesForAccount(System.IAsyncResult asyncResult)
        {
            object[] results = this.EndInvoke(asyncResult);
            return ((string)(results[0]));
        }

        /// <remarks/>
        [System.Web.Services.Protocols.SoapHeaderAttribute("WSSecurityHeader")]
        [System.Web.Services.Protocols.SoapHeaderAttribute("PPSoapHeader")]
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("#GetAccountForAlias", RequestNamespace = "http://schemas.microsoft.com/Passport/SoapServices/CredentialServiceAPI/V1", ResponseNamespace = "http://schemas.microsoft.com/Passport/SoapServices/CredentialServiceAPI/V1", Use = System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle = System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        [return: System.Xml.Serialization.XmlElementAttribute("pbstrAliasXML")]
        public string GetAccountForAlias(tagPASSID AliasIDIn, string bstrOptionalParams)
        {
            object[] results = this.Invoke("GetAccountForAlias", new object[] {
                        AliasIDIn,
                        bstrOptionalParams});
            return ((string)(results[0]));
        }

        /// <remarks/>
        public System.IAsyncResult BeginGetAccountForAlias(tagPASSID AliasIDIn, string bstrOptionalParams, System.AsyncCallback callback, object asyncState)
        {
            return this.BeginInvoke("GetAccountForAlias", new object[] {
                        AliasIDIn,
                        bstrOptionalParams}, callback, asyncState);
        }

        /// <remarks/>
        public string EndGetAccountForAlias(System.IAsyncResult asyncResult)
        {
            object[] results = this.EndInvoke(asyncResult);
            return ((string)(results[0]));
        }

        /// <remarks/>
        [System.Web.Services.Protocols.SoapHeaderAttribute("WSSecurityHeader")]
        [System.Web.Services.Protocols.SoapHeaderAttribute("PPSoapHeader")]
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("#AddToReputationScore", RequestNamespace = "http://schemas.microsoft.com/Passport/SoapServices/CredentialServiceAPI/V1", ResponseNamespace = "http://schemas.microsoft.com/Passport/SoapServices/CredentialServiceAPI/V1", Use = System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle = System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        [return: System.Xml.Serialization.XmlElementAttribute("pbstrDataFeedXML")]
        public string AddToReputationScore(string bstrDataFeedXML)
        {
            object[] results = this.Invoke("AddToReputationScore", new object[] {
                        bstrDataFeedXML});
            return ((string)(results[0]));
        }

        /// <remarks/>
        public System.IAsyncResult BeginAddToReputationScore(string bstrDataFeedXML, System.AsyncCallback callback, object asyncState)
        {
            return this.BeginInvoke("AddToReputationScore", new object[] {
                        bstrDataFeedXML}, callback, asyncState);
        }

        /// <remarks/>
        public string EndAddToReputationScore(System.IAsyncResult asyncResult)
        {
            object[] results = this.EndInvoke(asyncResult);
            return ((string)(results[0]));
        }

        /// <remarks/>
        [System.Web.Services.Protocols.SoapHeaderAttribute("WSSecurityHeader")]
        [System.Web.Services.Protocols.SoapHeaderAttribute("PPSoapHeader")]
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("#OverrideReputationScore", RequestNamespace = "http://schemas.microsoft.com/Passport/SoapServices/CredentialServiceAPI/V1", ResponseNamespace = "http://schemas.microsoft.com/Passport/SoapServices/CredentialServiceAPI/V1", Use = System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle = System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        [return: System.Xml.Serialization.XmlElementAttribute("pbstrDataFeedXML")]
        public string OverrideReputationScore(string bstrDataFeedXML)
        {
            object[] results = this.Invoke("OverrideReputationScore", new object[] {
                        bstrDataFeedXML});
            return ((string)(results[0]));
        }

        /// <remarks/>
        public System.IAsyncResult BeginOverrideReputationScore(string bstrDataFeedXML, System.AsyncCallback callback, object asyncState)
        {
            return this.BeginInvoke("OverrideReputationScore", new object[] {
                        bstrDataFeedXML}, callback, asyncState);
        }

        /// <remarks/>
        public string EndOverrideReputationScore(System.IAsyncResult asyncResult)
        {
            object[] results = this.EndInvoke(asyncResult);
            return ((string)(results[0]));
        }

        /// <remarks/>
        [System.Web.Services.Protocols.SoapHeaderAttribute("WSSecurityHeader")]
        [System.Web.Services.Protocols.SoapHeaderAttribute("PPSoapHeader")]
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("#GetReputationScoreDetails", RequestNamespace = "http://schemas.microsoft.com/Passport/SoapServices/CredentialServiceAPI/V1", ResponseNamespace = "http://schemas.microsoft.com/Passport/SoapServices/CredentialServiceAPI/V1", Use = System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle = System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        [return: System.Xml.Serialization.XmlElementAttribute("pbstrReputationScoreXML")]
        public string GetReputationScoreDetails(tagPASSID PassIDIn, string bstrOptionalParams)
        {
            object[] results = this.Invoke("GetReputationScoreDetails", new object[] {
                        PassIDIn,
                        bstrOptionalParams});
            return ((string)(results[0]));
        }

        /// <remarks/>
        public System.IAsyncResult BeginGetReputationScoreDetails(tagPASSID PassIDIn, string bstrOptionalParams, System.AsyncCallback callback, object asyncState)
        {
            return this.BeginInvoke("GetReputationScoreDetails", new object[] {
                        PassIDIn,
                        bstrOptionalParams}, callback, asyncState);
        }

        /// <remarks/>
        public string EndGetReputationScoreDetails(System.IAsyncResult asyncResult)
        {
            object[] results = this.EndInvoke(asyncResult);
            return ((string)(results[0]));
        }

        /// <remarks/>
        [System.Web.Services.Protocols.SoapHeaderAttribute("WSSecurityHeader")]
        [System.Web.Services.Protocols.SoapHeaderAttribute("PPSoapHeader")]
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("#EnumerateDevice", RequestNamespace = "http://schemas.microsoft.com/Passport/SoapServices/CredentialServiceAPI/V1", ResponseNamespace = "http://schemas.microsoft.com/Passport/SoapServices/CredentialServiceAPI/V1", Use = System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle = System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        [return: System.Xml.Serialization.XmlElementAttribute("pbstrDeviceIdsXML")]
        public string EnumerateDevice(tagPASSID idUserPUID)
        {
            object[] results = this.Invoke("EnumerateDevice", new object[] {
                        idUserPUID});
            return ((string)(results[0]));
        }

        /// <remarks/>
        public System.IAsyncResult BeginEnumerateDevice(tagPASSID idUserPUID, System.AsyncCallback callback, object asyncState)
        {
            return this.BeginInvoke("EnumerateDevice", new object[] {
                        idUserPUID}, callback, asyncState);
        }

        /// <remarks/>
        public string EndEnumerateDevice(System.IAsyncResult asyncResult)
        {
            object[] results = this.EndInvoke(asyncResult);
            return ((string)(results[0]));
        }

        /// <remarks/>
        [System.Web.Services.Protocols.SoapHeaderAttribute("WSSecurityHeader")]
        [System.Web.Services.Protocols.SoapHeaderAttribute("PPSoapHeader")]
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("#EnumerateAssociationsForDevice", RequestNamespace = "http://schemas.microsoft.com/Passport/SoapServices/CredentialServiceAPI/V1", ResponseNamespace = "http://schemas.microsoft.com/Passport/SoapServices/CredentialServiceAPI/V1", Use = System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle = System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        [return: System.Xml.Serialization.XmlElementAttribute("pbstrUserIdsXML")]
        public string EnumerateAssociationsForDevice(tagPASSID idDevicePUID, string bstrAssociationsTypes)
        {
            object[] results = this.Invoke("EnumerateAssociationsForDevice", new object[] {
                        idDevicePUID,
                        bstrAssociationsTypes});
            return ((string)(results[0]));
        }

        /// <remarks/>
        public System.IAsyncResult BeginEnumerateAssociationsForDevice(tagPASSID idDevicePUID, string bstrAssociationsTypes, System.AsyncCallback callback, object asyncState)
        {
            return this.BeginInvoke("EnumerateAssociationsForDevice", new object[] {
                        idDevicePUID,
                        bstrAssociationsTypes}, callback, asyncState);
        }

        /// <remarks/>
        public string EndEnumerateAssociationsForDevice(System.IAsyncResult asyncResult)
        {
            object[] results = this.EndInvoke(asyncResult);
            return ((string)(results[0]));
        }

        /// <remarks/>
        [System.Web.Services.Protocols.SoapHeaderAttribute("WSSecurityHeader")]
        [System.Web.Services.Protocols.SoapHeaderAttribute("PPSoapHeader")]
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("#AssociateDevice", RequestNamespace = "http://schemas.microsoft.com/Passport/SoapServices/CredentialServiceAPI/V1", ResponseNamespace = "http://schemas.microsoft.com/Passport/SoapServices/CredentialServiceAPI/V1", Use = System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle = System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public void AssociateDevice(string bstrAssociationInfoXml)
        {
            this.Invoke("AssociateDevice", new object[] {
                        bstrAssociationInfoXml});
        }

        /// <remarks/>
        public System.IAsyncResult BeginAssociateDevice(string bstrAssociationInfoXml, System.AsyncCallback callback, object asyncState)
        {
            return this.BeginInvoke("AssociateDevice", new object[] {
                        bstrAssociationInfoXml}, callback, asyncState);
        }

        /// <remarks/>
        public void EndAssociateDevice(System.IAsyncResult asyncResult)
        {
            this.EndInvoke(asyncResult);
        }

        /// <remarks/>
        [System.Web.Services.Protocols.SoapHeaderAttribute("WSSecurityHeader")]
        [System.Web.Services.Protocols.SoapHeaderAttribute("PPSoapHeader")]
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("#DisassociateDevice", RequestNamespace = "http://schemas.microsoft.com/Passport/SoapServices/CredentialServiceAPI/V1", ResponseNamespace = "http://schemas.microsoft.com/Passport/SoapServices/CredentialServiceAPI/V1", Use = System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle = System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public void DisassociateDevice(tagPASSID idUserPUID, tagPASSID idDIDPUID, string bstrAssociationInfoXml)
        {
            this.Invoke("DisassociateDevice", new object[] {
                        idUserPUID,
                        idDIDPUID,
                        bstrAssociationInfoXml});
        }

        /// <remarks/>
        public System.IAsyncResult BeginDisassociateDevice(tagPASSID idUserPUID, tagPASSID idDIDPUID, string bstrAssociationInfoXml, System.AsyncCallback callback, object asyncState)
        {
            return this.BeginInvoke("DisassociateDevice", new object[] {
                        idUserPUID,
                        idDIDPUID,
                        bstrAssociationInfoXml}, callback, asyncState);
        }

        /// <remarks/>
        public void EndDisassociateDevice(System.IAsyncResult asyncResult)
        {
            this.EndInvoke(asyncResult);
        }

        /// <remarks/>
        [System.Web.Services.Protocols.SoapHeaderAttribute("WSSecurityHeader")]
        [System.Web.Services.Protocols.SoapHeaderAttribute("PPSoapHeader")]
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("#UpdateDeviceProperties", RequestNamespace = "http://schemas.microsoft.com/Passport/SoapServices/CredentialServiceAPI/V1", ResponseNamespace = "http://schemas.microsoft.com/Passport/SoapServices/CredentialServiceAPI/V1", Use = System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle = System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public void UpdateDeviceProperties(tagPASSID idDIDPUID, string bstrDeviceProperties)
        {
            this.Invoke("UpdateDeviceProperties", new object[] {
                        idDIDPUID,
                        bstrDeviceProperties});
        }

        /// <remarks/>
        public System.IAsyncResult BeginUpdateDeviceProperties(tagPASSID idDIDPUID, string bstrDeviceProperties, System.AsyncCallback callback, object asyncState)
        {
            return this.BeginInvoke("UpdateDeviceProperties", new object[] {
                        idDIDPUID,
                        bstrDeviceProperties}, callback, asyncState);
        }

        /// <remarks/>
        public void EndUpdateDeviceProperties(System.IAsyncResult asyncResult)
        {
            this.EndInvoke(asyncResult);
        }

        /// <remarks/>
        [System.Web.Services.Protocols.SoapHeaderAttribute("WSSecurityHeader")]
        [System.Web.Services.Protocols.SoapHeaderAttribute("PPSoapHeader")]
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("#QueryDeviceProperties", RequestNamespace = "http://schemas.microsoft.com/Passport/SoapServices/CredentialServiceAPI/V1", ResponseNamespace = "http://schemas.microsoft.com/Passport/SoapServices/CredentialServiceAPI/V1", Use = System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle = System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        [return: System.Xml.Serialization.XmlElementAttribute("pbstrDeviceIdPropertiesXML")]
        public string QueryDeviceProperties(tagPASSID idDIDPUID, string bstrPropertyFilter)
        {
            object[] results = this.Invoke("QueryDeviceProperties", new object[] {
                        idDIDPUID,
                        bstrPropertyFilter});
            return ((string)(results[0]));
        }

        /// <remarks/>
        public System.IAsyncResult BeginQueryDeviceProperties(tagPASSID idDIDPUID, string bstrPropertyFilter, System.AsyncCallback callback, object asyncState)
        {
            return this.BeginInvoke("QueryDeviceProperties", new object[] {
                        idDIDPUID,
                        bstrPropertyFilter}, callback, asyncState);
        }

        /// <remarks/>
        public string EndQueryDeviceProperties(System.IAsyncResult asyncResult)
        {
            object[] results = this.EndInvoke(asyncResult);
            return ((string)(results[0]));
        }

        /// <remarks/>
        [System.Web.Services.Protocols.SoapHeaderAttribute("WSSecurityHeader")]
        [System.Web.Services.Protocols.SoapHeaderAttribute("PPSoapHeader")]
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("#ConvertCredential", RequestNamespace = "http://schemas.microsoft.com/Passport/SoapServices/CredentialServiceAPI/V1", ResponseNamespace = "http://schemas.microsoft.com/Passport/SoapServices/CredentialServiceAPI/V1", Use = System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle = System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public void ConvertCredential(tagPASSID PassIDIn, string bstrNewCredXML)
        {
            this.Invoke("ConvertCredential", new object[] {
                        PassIDIn,
                        bstrNewCredXML});
        }

        /// <remarks/>
        public System.IAsyncResult BeginConvertCredential(tagPASSID PassIDIn, string bstrNewCredXML, System.AsyncCallback callback, object asyncState)
        {
            return this.BeginInvoke("ConvertCredential", new object[] {
                        PassIDIn,
                        bstrNewCredXML}, callback, asyncState);
        }

        /// <remarks/>
        public void EndConvertCredential(System.IAsyncResult asyncResult)
        {
            this.EndInvoke(asyncResult);
        }

        /// <remarks/>
        [System.Web.Services.Protocols.SoapHeaderAttribute("WSSecurityHeader")]
        [System.Web.Services.Protocols.SoapHeaderAttribute("PPSoapHeader")]
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("#QueryNotifications", RequestNamespace = "http://schemas.microsoft.com/Passport/SoapServices/CredentialServiceAPI/V1", ResponseNamespace = "http://schemas.microsoft.com/Passport/SoapServices/CredentialServiceAPI/V1", Use = System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle = System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        [return: System.Xml.Serialization.XmlElementAttribute("bstrNotificationsXML")]
        public string QueryNotifications(tagPASSID PassIDIn, string bstrQueryNotificationsXML)
        {
            object[] results = this.Invoke("QueryNotifications", new object[] {
                        PassIDIn,
                        bstrQueryNotificationsXML});
            return ((string)(results[0]));
        }

        /// <remarks/>
        public System.IAsyncResult BeginQueryNotifications(tagPASSID PassIDIn, string bstrQueryNotificationsXML, System.AsyncCallback callback, object asyncState)
        {
            return this.BeginInvoke("QueryNotifications", new object[] {
                        PassIDIn,
                        bstrQueryNotificationsXML}, callback, asyncState);
        }

        /// <remarks/>
        public string EndQueryNotifications(System.IAsyncResult asyncResult)
        {
            object[] results = this.EndInvoke(asyncResult);
            return ((string)(results[0]));
        }

        /// <remarks/>
        [System.Web.Services.Protocols.SoapHeaderAttribute("WSSecurityHeader")]
        [System.Web.Services.Protocols.SoapHeaderAttribute("PPSoapHeader")]
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("#ConsumeNotifications", RequestNamespace = "http://schemas.microsoft.com/Passport/SoapServices/CredentialServiceAPI/V1", ResponseNamespace = "http://schemas.microsoft.com/Passport/SoapServices/CredentialServiceAPI/V1", Use = System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle = System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public void ConsumeNotifications(tagPASSID PassIDIn, string bstrConsumeNotificationsXML)
        {
            this.Invoke("ConsumeNotifications", new object[] {
                        PassIDIn,
                        bstrConsumeNotificationsXML});
        }

        /// <remarks/>
        public System.IAsyncResult BeginConsumeNotifications(tagPASSID PassIDIn, string bstrConsumeNotificationsXML, System.AsyncCallback callback, object asyncState)
        {
            return this.BeginInvoke("ConsumeNotifications", new object[] {
                        PassIDIn,
                        bstrConsumeNotificationsXML}, callback, asyncState);
        }

        /// <remarks/>
        public void EndConsumeNotifications(System.IAsyncResult asyncResult)
        {
            this.EndInvoke(asyncResult);
        }

        /// <remarks/>
        [System.Web.Services.Protocols.SoapHeaderAttribute("WSSecurityHeader")]
        [System.Web.Services.Protocols.SoapHeaderAttribute("PPSoapHeader")]
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("#AddProof", RequestNamespace = "http://schemas.microsoft.com/Passport/SoapServices/CredentialServiceAPI/V1", ResponseNamespace = "http://schemas.microsoft.com/Passport/SoapServices/CredentialServiceAPI/V1", Use = System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle = System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        [return: System.Xml.Serialization.XmlElementAttribute("pbstrAddedProof")]
        public string AddProof(tagPASSID idUserPUID, string bstrProofData)
        {
            object[] results = this.Invoke("AddProof", new object[] {
                        idUserPUID,
                        bstrProofData});
            return ((string)(results[0]));
        }

        /// <remarks/>
        public System.IAsyncResult BeginAddProof(tagPASSID idUserPUID, string bstrProofData, System.AsyncCallback callback, object asyncState)
        {
            return this.BeginInvoke("AddProof", new object[] {
                        idUserPUID,
                        bstrProofData}, callback, asyncState);
        }

        /// <remarks/>
        public string EndAddProof(System.IAsyncResult asyncResult)
        {
            object[] results = this.EndInvoke(asyncResult);
            return ((string)(results[0]));
        }

        /// <remarks/>
        [System.Web.Services.Protocols.SoapHeaderAttribute("WSSecurityHeader")]
        [System.Web.Services.Protocols.SoapHeaderAttribute("PPSoapHeader")]
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("#ConfirmProof", RequestNamespace = "http://schemas.microsoft.com/Passport/SoapServices/CredentialServiceAPI/V1", ResponseNamespace = "http://schemas.microsoft.com/Passport/SoapServices/CredentialServiceAPI/V1", Use = System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle = System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public void ConfirmProof(tagPASSID idUserPUID, string bstrProofData)
        {
            this.Invoke("ConfirmProof", new object[] {
                        idUserPUID,
                        bstrProofData});
        }

        /// <remarks/>
        public System.IAsyncResult BeginConfirmProof(tagPASSID idUserPUID, string bstrProofData, System.AsyncCallback callback, object asyncState)
        {
            return this.BeginInvoke("ConfirmProof", new object[] {
                        idUserPUID,
                        bstrProofData}, callback, asyncState);
        }

        /// <remarks/>
        public void EndConfirmProof(System.IAsyncResult asyncResult)
        {
            this.EndInvoke(asyncResult);
        }

        /// <remarks/>
        [System.Web.Services.Protocols.SoapHeaderAttribute("WSSecurityHeader")]
        [System.Web.Services.Protocols.SoapHeaderAttribute("PPSoapHeader")]
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("#DeleteProof", RequestNamespace = "http://schemas.microsoft.com/Passport/SoapServices/CredentialServiceAPI/V1", ResponseNamespace = "http://schemas.microsoft.com/Passport/SoapServices/CredentialServiceAPI/V1", Use = System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle = System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public void DeleteProof(tagPASSID idUserPUID, string bstrProofData)
        {
            this.Invoke("DeleteProof", new object[] {
                        idUserPUID,
                        bstrProofData});
        }

        /// <remarks/>
        public System.IAsyncResult BeginDeleteProof(tagPASSID idUserPUID, string bstrProofData, System.AsyncCallback callback, object asyncState)
        {
            return this.BeginInvoke("DeleteProof", new object[] {
                        idUserPUID,
                        bstrProofData}, callback, asyncState);
        }

        /// <remarks/>
        public void EndDeleteProof(System.IAsyncResult asyncResult)
        {
            this.EndInvoke(asyncResult);
        }

        /// <remarks/>
        [System.Web.Services.Protocols.SoapHeaderAttribute("WSSecurityHeader")]
        [System.Web.Services.Protocols.SoapHeaderAttribute("PPSoapHeader")]
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("#LostProofs", RequestNamespace = "http://schemas.microsoft.com/Passport/SoapServices/CredentialServiceAPI/V1", ResponseNamespace = "http://schemas.microsoft.com/Passport/SoapServices/CredentialServiceAPI/V1", Use = System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle = System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public void LostProofs(tagPASSID idUserPUID)
        {
            this.Invoke("LostProofs", new object[] {
                        idUserPUID});
        }

        /// <remarks/>
        public System.IAsyncResult BeginLostProofs(tagPASSID idUserPUID, System.AsyncCallback callback, object asyncState)
        {
            return this.BeginInvoke("LostProofs", new object[] {
                        idUserPUID}, callback, asyncState);
        }

        /// <remarks/>
        public void EndLostProofs(System.IAsyncResult asyncResult)
        {
            this.EndInvoke(asyncResult);
        }

        /// <remarks/>
        [System.Web.Services.Protocols.SoapHeaderAttribute("WSSecurityHeader")]
        [System.Web.Services.Protocols.SoapHeaderAttribute("PPSoapHeader")]
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("#GetUserProofState", RequestNamespace = "http://schemas.microsoft.com/Passport/SoapServices/CredentialServiceAPI/V1", ResponseNamespace = "http://schemas.microsoft.com/Passport/SoapServices/CredentialServiceAPI/V1", Use = System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle = System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        [return: System.Xml.Serialization.XmlElementAttribute("pbstrProofs")]
        public string GetUserProofState(tagPASSID idUserPUID, eProofFilter epfFilter)
        {
            object[] results = this.Invoke("GetUserProofState", new object[] {
                        idUserPUID,
                        epfFilter});
            return ((string)(results[0]));
        }

        /// <remarks/>
        public System.IAsyncResult BeginGetUserProofState(tagPASSID idUserPUID, eProofFilter epfFilter, System.AsyncCallback callback, object asyncState)
        {
            return this.BeginInvoke("GetUserProofState", new object[] {
                        idUserPUID,
                        epfFilter}, callback, asyncState);
        }

        /// <remarks/>
        public string EndGetUserProofState(System.IAsyncResult asyncResult)
        {
            object[] results = this.EndInvoke(asyncResult);
            return ((string)(results[0]));
        }

        /// <remarks/>
        [System.Web.Services.Protocols.SoapHeaderAttribute("WSSecurityHeader")]
        [System.Web.Services.Protocols.SoapHeaderAttribute("PPSoapHeader")]
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("#SetAccountProtection", RequestNamespace = "http://schemas.microsoft.com/Passport/SoapServices/CredentialServiceAPI/V1", ResponseNamespace = "http://schemas.microsoft.com/Passport/SoapServices/CredentialServiceAPI/V1", Use = System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle = System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public void SetAccountProtection(tagPASSID idUserPUID, string bstrState)
        {
            this.Invoke("SetAccountProtection", new object[] {
                        idUserPUID,
                        bstrState});
        }

        /// <remarks/>
        public System.IAsyncResult BeginSetAccountProtection(tagPASSID idUserPUID, string bstrState, System.AsyncCallback callback, object asyncState)
        {
            return this.BeginInvoke("SetAccountProtection", new object[] {
                        idUserPUID,
                        bstrState}, callback, asyncState);
        }

        /// <remarks/>
        public void EndSetAccountProtection(System.IAsyncResult asyncResult)
        {
            this.EndInvoke(asyncResult);
        }

        /// <remarks/>
        [System.Web.Services.Protocols.SoapHeaderAttribute("WSSecurityHeader")]
        [System.Web.Services.Protocols.SoapHeaderAttribute("PPSoapHeader")]
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("#GetAccountProtection", RequestNamespace = "http://schemas.microsoft.com/Passport/SoapServices/CredentialServiceAPI/V1", ResponseNamespace = "http://schemas.microsoft.com/Passport/SoapServices/CredentialServiceAPI/V1", Use = System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle = System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        [return: System.Xml.Serialization.XmlElementAttribute("pbstrState")]
        public string GetAccountProtection(tagPASSID idUserPUID)
        {
            object[] results = this.Invoke("GetAccountProtection", new object[] {
                        idUserPUID});
            return ((string)(results[0]));
        }

        /// <remarks/>
        public System.IAsyncResult BeginGetAccountProtection(tagPASSID idUserPUID, System.AsyncCallback callback, object asyncState)
        {
            return this.BeginInvoke("GetAccountProtection", new object[] {
                        idUserPUID}, callback, asyncState);
        }

        /// <remarks/>
        public string EndGetAccountProtection(System.IAsyncResult asyncResult)
        {
            object[] results = this.EndInvoke(asyncResult);
            return ((string)(results[0]));
        }

        /// <remarks/>
        [System.Web.Services.Protocols.SoapHeaderAttribute("WSSecurityHeader")]
        [System.Web.Services.Protocols.SoapHeaderAttribute("PPSoapHeader")]
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("#SetUserPolicy", RequestNamespace = "http://schemas.microsoft.com/Passport/SoapServices/CredentialServiceAPI/V1", ResponseNamespace = "http://schemas.microsoft.com/Passport/SoapServices/CredentialServiceAPI/V1", Use = System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle = System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public void SetUserPolicy(tagPASSID idUserPUID, string bstrPolicy)
        {
            this.Invoke("SetUserPolicy", new object[] {
                        idUserPUID,
                        bstrPolicy});
        }

        /// <remarks/>
        public System.IAsyncResult BeginSetUserPolicy(tagPASSID idUserPUID, string bstrPolicy, System.AsyncCallback callback, object asyncState)
        {
            return this.BeginInvoke("SetUserPolicy", new object[] {
                        idUserPUID,
                        bstrPolicy}, callback, asyncState);
        }

        /// <remarks/>
        public void EndSetUserPolicy(System.IAsyncResult asyncResult)
        {
            this.EndInvoke(asyncResult);
        }

        /// <remarks/>
        [System.Web.Services.Protocols.SoapHeaderAttribute("WSSecurityHeader")]
        [System.Web.Services.Protocols.SoapHeaderAttribute("PPSoapHeader")]
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("#GetUserPolicy", RequestNamespace = "http://schemas.microsoft.com/Passport/SoapServices/CredentialServiceAPI/V1", ResponseNamespace = "http://schemas.microsoft.com/Passport/SoapServices/CredentialServiceAPI/V1", Use = System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle = System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        [return: System.Xml.Serialization.XmlElementAttribute("pbstrPolicy")]
        public string GetUserPolicy(tagPASSID idUserPUID, string bstrPolicyFilter)
        {
            object[] results = this.Invoke("GetUserPolicy", new object[] {
                        idUserPUID,
                        bstrPolicyFilter});
            return ((string)(results[0]));
        }

        /// <remarks/>
        public System.IAsyncResult BeginGetUserPolicy(tagPASSID idUserPUID, string bstrPolicyFilter, System.AsyncCallback callback, object asyncState)
        {
            return this.BeginInvoke("GetUserPolicy", new object[] {
                        idUserPUID,
                        bstrPolicyFilter}, callback, asyncState);
        }

        /// <remarks/>
        public string EndGetUserPolicy(System.IAsyncResult asyncResult)
        {
            object[] results = this.EndInvoke(asyncResult);
            return ((string)(results[0]));
        }

        /// <remarks/>
        [System.Web.Services.Protocols.SoapHeaderAttribute("WSSecurityHeader")]
        [System.Web.Services.Protocols.SoapHeaderAttribute("PPSoapHeader")]
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("#UpdateChannelState", RequestNamespace = "http://schemas.microsoft.com/Passport/SoapServices/CredentialServiceAPI/V1", ResponseNamespace = "http://schemas.microsoft.com/Passport/SoapServices/CredentialServiceAPI/V1", Use = System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle = System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public void UpdateChannelState(string bstrChannelStateXML)
        {
            this.Invoke("UpdateChannelState", new object[] {
                        bstrChannelStateXML});
        }

        /// <remarks/>
        public System.IAsyncResult BeginUpdateChannelState(string bstrChannelStateXML, System.AsyncCallback callback, object asyncState)
        {
            return this.BeginInvoke("UpdateChannelState", new object[] {
                        bstrChannelStateXML}, callback, asyncState);
        }

        /// <remarks/>
        public void EndUpdateChannelState(System.IAsyncResult asyncResult)
        {
            this.EndInvoke(asyncResult);
        }

        /// <remarks/>
        [System.Web.Services.Protocols.SoapHeaderAttribute("WSSecurityHeader")]
        [System.Web.Services.Protocols.SoapHeaderAttribute("PPSoapHeader")]
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("#AddFamiliarLocation", RequestNamespace = "http://schemas.microsoft.com/Passport/SoapServices/CredentialServiceAPI/V1", ResponseNamespace = "http://schemas.microsoft.com/Passport/SoapServices/CredentialServiceAPI/V1", Use = System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle = System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public void AddFamiliarLocation(tagPASSID idUserPUID, string IP, string Options)
        {
            this.Invoke("AddFamiliarLocation", new object[] {
                        idUserPUID,
                        IP,
                        Options});
        }

        /// <remarks/>
        public System.IAsyncResult BeginAddFamiliarLocation(tagPASSID idUserPUID, string IP, string Options, System.AsyncCallback callback, object asyncState)
        {
            return this.BeginInvoke("AddFamiliarLocation", new object[] {
                        idUserPUID,
                        IP,
                        Options}, callback, asyncState);
        }

        /// <remarks/>
        public void EndAddFamiliarLocation(System.IAsyncResult asyncResult)
        {
            this.EndInvoke(asyncResult);
        }

        /// <remarks/>
        [System.Web.Services.Protocols.SoapHeaderAttribute("WSSecurityHeader")]
        [System.Web.Services.Protocols.SoapHeaderAttribute("PPSoapHeader")]
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("#GetSLT", RequestNamespace = "http://schemas.microsoft.com/Passport/SoapServices/CredentialServiceAPI/V1", ResponseNamespace = "http://schemas.microsoft.com/Passport/SoapServices/CredentialServiceAPI/V1", Use = System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle = System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        [return: System.Xml.Serialization.XmlElementAttribute("SLT")]
        public string GetSLT(tagPASSID PassIDIn, int LoginSeconds)
        {
            object[] results = this.Invoke("GetSLT", new object[] {
                        PassIDIn,
                        LoginSeconds});
            return ((string)(results[0]));
        }

        /// <remarks/>
        public System.IAsyncResult BeginGetSLT(tagPASSID PassIDIn, int LoginSeconds, System.AsyncCallback callback, object asyncState)
        {
            return this.BeginInvoke("GetSLT", new object[] {
                        PassIDIn,
                        LoginSeconds}, callback, asyncState);
        }

        /// <remarks/>
        public string EndGetSLT(System.IAsyncResult asyncResult)
        {
            object[] results = this.EndInvoke(asyncResult);
            return ((string)(results[0]));
        }
    }

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Web.Services.WebServiceBindingAttribute(Name = "ProfileServiceAPISoapServerSoap", Namespace = "http://schemas.microsoft.com/Passport/SoapServices/ProfileServiceAPI/V1")]
    [System.Xml.Serialization.XmlIncludeAttribute(typeof(string[]))]
    public partial class ProfileServiceAPISoapServerSoap : System.Web.Services.Protocols.SoapHttpClientProtocol
    {

        public PPSoapHeader_wrapper1 PPSoapHeader;

        public tagWSSECURITYHEADER1 WSSecurityHeader;

        /// <remarks/>
        public ProfileServiceAPISoapServerSoap()
        {
            this.Url = "https://ppsaprofile.service.passport.net/PPSAProfile.srf";
        }

        /// <remarks/>
        [System.Web.Services.Protocols.SoapHeaderAttribute("PPSoapHeader")]
        [System.Web.Services.Protocols.SoapHeaderAttribute("WSSecurityHeader")]
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("#CreateProfile", RequestNamespace = "http://schemas.microsoft.com/Passport/SoapServices/ProfileServiceAPI/V1", ResponseNamespace = "http://schemas.microsoft.com/Passport/SoapServices/ProfileServiceAPI/V1", Use = System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle = System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public void CreateProfile([System.Xml.Serialization.XmlArrayAttribute(IsNullable = true)] [System.Xml.Serialization.XmlArrayItemAttribute(IsNullable = false)] string[] bstrProfileXMLArray)
        {
            this.Invoke("CreateProfile", new object[] {
                        bstrProfileXMLArray});
        }

        /// <remarks/>
        public System.IAsyncResult BeginCreateProfile(string[] bstrProfileXMLArray, System.AsyncCallback callback, object asyncState)
        {
            return this.BeginInvoke("CreateProfile", new object[] {
                        bstrProfileXMLArray}, callback, asyncState);
        }

        /// <remarks/>
        public void EndCreateProfile(System.IAsyncResult asyncResult)
        {
            this.EndInvoke(asyncResult);
        }

        /// <remarks/>
        [System.Web.Services.Protocols.SoapHeaderAttribute("PPSoapHeader")]
        [System.Web.Services.Protocols.SoapHeaderAttribute("WSSecurityHeader")]
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("#CreatePassports", RequestNamespace = "http://schemas.microsoft.com/Passport/SoapServices/ProfileServiceAPI/V1", ResponseNamespace = "http://schemas.microsoft.com/Passport/SoapServices/ProfileServiceAPI/V1", Use = System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle = System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        [return: System.Xml.Serialization.XmlArrayAttribute("ppbstrCreatedAccountsArray", IsNullable = true)]
        [return: System.Xml.Serialization.XmlArrayItemAttribute(IsNullable = false)]
        public string[] CreatePassports([System.Xml.Serialization.XmlArrayAttribute(IsNullable = true)] [System.Xml.Serialization.XmlArrayItemAttribute(IsNullable = false)] string[] pbstrAccountXMLArray, eTRANSACTION etFlags, out string pbstrErrorBlob)
        {
            object[] results = this.Invoke("CreatePassports", new object[] {
                        pbstrAccountXMLArray,
                        etFlags});
            pbstrErrorBlob = ((string)(results[1]));
            return ((string[])(results[0]));
        }

        /// <remarks/>
        public System.IAsyncResult BeginCreatePassports(string[] pbstrAccountXMLArray, eTRANSACTION etFlags, System.AsyncCallback callback, object asyncState)
        {
            return this.BeginInvoke("CreatePassports", new object[] {
                        pbstrAccountXMLArray,
                        etFlags}, callback, asyncState);
        }

        /// <remarks/>
        public string[] EndCreatePassports(System.IAsyncResult asyncResult, out string pbstrErrorBlob)
        {
            object[] results = this.EndInvoke(asyncResult);
            pbstrErrorBlob = ((string)(results[1]));
            return ((string[])(results[0]));
        }

        /// <remarks/>
        [System.Web.Services.Protocols.SoapHeaderAttribute("PPSoapHeader")]
        [System.Web.Services.Protocols.SoapHeaderAttribute("WSSecurityHeader")]
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("#UpdatePassports", RequestNamespace = "http://schemas.microsoft.com/Passport/SoapServices/ProfileServiceAPI/V1", ResponseNamespace = "http://schemas.microsoft.com/Passport/SoapServices/ProfileServiceAPI/V1", Use = System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle = System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        [return: System.Xml.Serialization.XmlArrayAttribute("ppbstrUpdatedAccountsArray", IsNullable = true)]
        [return: System.Xml.Serialization.XmlArrayItemAttribute(IsNullable = false)]
        public string[] UpdatePassports([System.Xml.Serialization.XmlArrayAttribute(IsNullable = true)] [System.Xml.Serialization.XmlArrayItemAttribute(IsNullable = false)] string[] pbstrNetIDArray, [System.Xml.Serialization.XmlArrayAttribute(IsNullable = true)] [System.Xml.Serialization.XmlArrayItemAttribute(IsNullable = false)] string[] pbstrAccountXMLArray, [System.Xml.Serialization.XmlArrayAttribute(IsNullable = true)] [System.Xml.Serialization.XmlArrayItemAttribute(IsNullable = false)] string[] pbstrAdditionalXML, string bstrOptions, out string pbstrErrorBlob)
        {
            object[] results = this.Invoke("UpdatePassports", new object[] {
                        pbstrNetIDArray,
                        pbstrAccountXMLArray,
                        pbstrAdditionalXML,
                        bstrOptions});
            pbstrErrorBlob = ((string)(results[1]));
            return ((string[])(results[0]));
        }

        /// <remarks/>
        public System.IAsyncResult BeginUpdatePassports(string[] pbstrNetIDArray, string[] pbstrAccountXMLArray, string[] pbstrAdditionalXML, string bstrOptions, System.AsyncCallback callback, object asyncState)
        {
            return this.BeginInvoke("UpdatePassports", new object[] {
                        pbstrNetIDArray,
                        pbstrAccountXMLArray,
                        pbstrAdditionalXML,
                        bstrOptions}, callback, asyncState);
        }

        /// <remarks/>
        public string[] EndUpdatePassports(System.IAsyncResult asyncResult, out string pbstrErrorBlob)
        {
            object[] results = this.EndInvoke(asyncResult);
            pbstrErrorBlob = ((string)(results[1]));
            return ((string[])(results[0]));
        }

        /// <remarks/>
        [System.Web.Services.Protocols.SoapHeaderAttribute("PPSoapHeader")]
        [System.Web.Services.Protocols.SoapHeaderAttribute("WSSecurityHeader")]
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("#GetProfileByAttributes", RequestNamespace = "http://schemas.microsoft.com/Passport/SoapServices/ProfileServiceAPI/V1", ResponseNamespace = "http://schemas.microsoft.com/Passport/SoapServices/ProfileServiceAPI/V1", Use = System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle = System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        [return: System.Xml.Serialization.XmlArrayAttribute("ppbstrProfileXMLArray", IsNullable = true)]
        [return: System.Xml.Serialization.XmlArrayItemAttribute(IsNullable = false)]
        public string[] GetProfileByAttributes([System.Xml.Serialization.XmlArrayAttribute(IsNullable = true)] [System.Xml.Serialization.XmlArrayItemAttribute(IsNullable = false)] string[] pbstrNetIDArray, string bstrAttribList, uint ulFlags, out string pbstrErrorBlob)
        {
            object[] results = this.Invoke("GetProfileByAttributes", new object[] {
                        pbstrNetIDArray,
                        bstrAttribList,
                        ulFlags});
            pbstrErrorBlob = ((string)(results[1]));
            return ((string[])(results[0]));
        }

        /// <remarks/>
        public System.IAsyncResult BeginGetProfileByAttributes(string[] pbstrNetIDArray, string bstrAttribList, uint ulFlags, System.AsyncCallback callback, object asyncState)
        {
            return this.BeginInvoke("GetProfileByAttributes", new object[] {
                        pbstrNetIDArray,
                        bstrAttribList,
                        ulFlags}, callback, asyncState);
        }

        /// <remarks/>
        public string[] EndGetProfileByAttributes(System.IAsyncResult asyncResult, out string pbstrErrorBlob)
        {
            object[] results = this.EndInvoke(asyncResult);
            pbstrErrorBlob = ((string)(results[1]));
            return ((string[])(results[0]));
        }

        /// <remarks/>
        [System.Web.Services.Protocols.SoapHeaderAttribute("PPSoapHeader")]
        [System.Web.Services.Protocols.SoapHeaderAttribute("WSSecurityHeader")]
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("#GetProfileByXPath", RequestNamespace = "http://schemas.microsoft.com/Passport/SoapServices/ProfileServiceAPI/V1", ResponseNamespace = "http://schemas.microsoft.com/Passport/SoapServices/ProfileServiceAPI/V1", Use = System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle = System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        [return: System.Xml.Serialization.XmlArrayAttribute("ppbstrProfileXMLArray", IsNullable = true)]
        [return: System.Xml.Serialization.XmlArrayItemAttribute(IsNullable = false)]
        public string[] GetProfileByXPath([System.Xml.Serialization.XmlArrayAttribute(IsNullable = true)] [System.Xml.Serialization.XmlArrayItemAttribute(IsNullable = false)] string[] pbstrNetIDArray, [System.Xml.Serialization.XmlArrayAttribute(IsNullable = true)] [System.Xml.Serialization.XmlArrayItemAttribute(IsNullable = false)] string[] pbstrXPathArray, out string pbstrErrorBlob)
        {
            object[] results = this.Invoke("GetProfileByXPath", new object[] {
                        pbstrNetIDArray,
                        pbstrXPathArray});
            pbstrErrorBlob = ((string)(results[1]));
            return ((string[])(results[0]));
        }

        /// <remarks/>
        public System.IAsyncResult BeginGetProfileByXPath(string[] pbstrNetIDArray, string[] pbstrXPathArray, System.AsyncCallback callback, object asyncState)
        {
            return this.BeginInvoke("GetProfileByXPath", new object[] {
                        pbstrNetIDArray,
                        pbstrXPathArray}, callback, asyncState);
        }

        /// <remarks/>
        public string[] EndGetProfileByXPath(System.IAsyncResult asyncResult, out string pbstrErrorBlob)
        {
            object[] results = this.EndInvoke(asyncResult);
            pbstrErrorBlob = ((string)(results[1]));
            return ((string[])(results[0]));
        }

        /// <remarks/>
        [System.Web.Services.Protocols.SoapHeaderAttribute("PPSoapHeader")]
        [System.Web.Services.Protocols.SoapHeaderAttribute("WSSecurityHeader")]
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("#UpdateProfile", RequestNamespace = "http://schemas.microsoft.com/Passport/SoapServices/ProfileServiceAPI/V1", ResponseNamespace = "http://schemas.microsoft.com/Passport/SoapServices/ProfileServiceAPI/V1", Use = System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle = System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public void UpdateProfile([System.Xml.Serialization.XmlArrayAttribute(IsNullable = true)] [System.Xml.Serialization.XmlArrayItemAttribute(IsNullable = false)] string[] pbstrProfileXMLArray)
        {
            this.Invoke("UpdateProfile", new object[] {
                        pbstrProfileXMLArray});
        }

        /// <remarks/>
        public System.IAsyncResult BeginUpdateProfile(string[] pbstrProfileXMLArray, System.AsyncCallback callback, object asyncState)
        {
            return this.BeginInvoke("UpdateProfile", new object[] {
                        pbstrProfileXMLArray}, callback, asyncState);
        }

        /// <remarks/>
        public void EndUpdateProfile(System.IAsyncResult asyncResult)
        {
            this.EndInvoke(asyncResult);
        }

        /// <remarks/>
        [System.Web.Services.Protocols.SoapHeaderAttribute("PPSoapHeader")]
        [System.Web.Services.Protocols.SoapHeaderAttribute("WSSecurityHeader")]
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("#UpdateProfileEx", RequestNamespace = "http://schemas.microsoft.com/Passport/SoapServices/ProfileServiceAPI/V1", ResponseNamespace = "http://schemas.microsoft.com/Passport/SoapServices/ProfileServiceAPI/V1", Use = System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle = System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public void UpdateProfileEx([System.Xml.Serialization.XmlArrayAttribute(IsNullable = true)] [System.Xml.Serialization.XmlArrayItemAttribute(IsNullable = false)] string[] pbstrNetIDArray, string bstrProfileXML)
        {
            this.Invoke("UpdateProfileEx", new object[] {
                        pbstrNetIDArray,
                        bstrProfileXML});
        }

        /// <remarks/>
        public System.IAsyncResult BeginUpdateProfileEx(string[] pbstrNetIDArray, string bstrProfileXML, System.AsyncCallback callback, object asyncState)
        {
            return this.BeginInvoke("UpdateProfileEx", new object[] {
                        pbstrNetIDArray,
                        bstrProfileXML}, callback, asyncState);
        }

        /// <remarks/>
        public void EndUpdateProfileEx(System.IAsyncResult asyncResult)
        {
            this.EndInvoke(asyncResult);
        }

        /// <remarks/>
        [System.Web.Services.Protocols.SoapHeaderAttribute("PPSoapHeader")]
        [System.Web.Services.Protocols.SoapHeaderAttribute("WSSecurityHeader")]
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("#DeleteProfileW", RequestNamespace = "http://schemas.microsoft.com/Passport/SoapServices/ProfileServiceAPI/V1", ResponseNamespace = "http://schemas.microsoft.com/Passport/SoapServices/ProfileServiceAPI/V1", Use = System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle = System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public void DeleteProfileW([System.Xml.Serialization.XmlArrayAttribute(IsNullable = true)] [System.Xml.Serialization.XmlArrayItemAttribute(IsNullable = false)] string[] ppbstrNetIDArray, string bstrPropertyCollectionList)
        {
            this.Invoke("DeleteProfileW", new object[] {
                        ppbstrNetIDArray,
                        bstrPropertyCollectionList});
        }

        /// <remarks/>
        public System.IAsyncResult BeginDeleteProfileW(string[] ppbstrNetIDArray, string bstrPropertyCollectionList, System.AsyncCallback callback, object asyncState)
        {
            return this.BeginInvoke("DeleteProfileW", new object[] {
                        ppbstrNetIDArray,
                        bstrPropertyCollectionList}, callback, asyncState);
        }

        /// <remarks/>
        public void EndDeleteProfileW(System.IAsyncResult asyncResult)
        {
            this.EndInvoke(asyncResult);
        }

        /// <remarks/>
        [System.Web.Services.Protocols.SoapHeaderAttribute("PPSoapHeader")]
        [System.Web.Services.Protocols.SoapHeaderAttribute("WSSecurityHeader")]
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("#DeletePassports", RequestNamespace = "http://schemas.microsoft.com/Passport/SoapServices/ProfileServiceAPI/V1", ResponseNamespace = "http://schemas.microsoft.com/Passport/SoapServices/ProfileServiceAPI/V1", Use = System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle = System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public void DeletePassports([System.Xml.Serialization.XmlArrayAttribute(IsNullable = true)] [System.Xml.Serialization.XmlArrayItemAttribute(IsNullable = false)] string[] pbstrNetIDArray)
        {
            this.Invoke("DeletePassports", new object[] {
                        pbstrNetIDArray});
        }

        /// <remarks/>
        public System.IAsyncResult BeginDeletePassports(string[] pbstrNetIDArray, System.AsyncCallback callback, object asyncState)
        {
            return this.BeginInvoke("DeletePassports", new object[] {
                        pbstrNetIDArray}, callback, asyncState);
        }

        /// <remarks/>
        public void EndDeletePassports(System.IAsyncResult asyncResult)
        {
            this.EndInvoke(asyncResult);
        }

        /// <remarks/>
        [System.Web.Services.Protocols.SoapHeaderAttribute("PPSoapHeader")]
        [System.Web.Services.Protocols.SoapHeaderAttribute("WSSecurityHeader")]
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("#GetIdentityInfo", RequestNamespace = "http://schemas.microsoft.com/Passport/SoapServices/ProfileServiceAPI/V1", ResponseNamespace = "http://schemas.microsoft.com/Passport/SoapServices/ProfileServiceAPI/V1", Use = System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle = System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        [return: System.Xml.Serialization.XmlElementAttribute("pbstrXML")]
        public string GetIdentityInfo(tagPASSID1 PassIDIn, string bstrCredAttribList, string bstrProfileAttribList, string bstrOptionalParams)
        {
            object[] results = this.Invoke("GetIdentityInfo", new object[] {
                        PassIDIn,
                        bstrCredAttribList,
                        bstrProfileAttribList,
                        bstrOptionalParams});
            return ((string)(results[0]));
        }

        /// <remarks/>
        public System.IAsyncResult BeginGetIdentityInfo(tagPASSID1 PassIDIn, string bstrCredAttribList, string bstrProfileAttribList, string bstrOptionalParams, System.AsyncCallback callback, object asyncState)
        {
            return this.BeginInvoke("GetIdentityInfo", new object[] {
                        PassIDIn,
                        bstrCredAttribList,
                        bstrProfileAttribList,
                        bstrOptionalParams}, callback, asyncState);
        }

        /// <remarks/>
        public string EndGetIdentityInfo(System.IAsyncResult asyncResult)
        {
            object[] results = this.EndInvoke(asyncResult);
            return ((string)(results[0]));
        }

        /// <remarks/>
        [System.Web.Services.Protocols.SoapHeaderAttribute("PPSoapHeader")]
        [System.Web.Services.Protocols.SoapHeaderAttribute("WSSecurityHeader")]
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("#UpdateUserAppConsent", RequestNamespace = "http://schemas.microsoft.com/Passport/SoapServices/ProfileServiceAPI/V1", ResponseNamespace = "http://schemas.microsoft.com/Passport/SoapServices/ProfileServiceAPI/V1", Use = System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle = System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        [return: System.Xml.Serialization.XmlElementAttribute("pbstrResultXML")]
        public string UpdateUserAppConsent(tagPASSID1 passID, string bstrAppPermissionXML)
        {
            object[] results = this.Invoke("UpdateUserAppConsent", new object[] {
                        passID,
                        bstrAppPermissionXML});
            return ((string)(results[0]));
        }

        /// <remarks/>
        public System.IAsyncResult BeginUpdateUserAppConsent(tagPASSID1 passID, string bstrAppPermissionXML, System.AsyncCallback callback, object asyncState)
        {
            return this.BeginInvoke("UpdateUserAppConsent", new object[] {
                        passID,
                        bstrAppPermissionXML}, callback, asyncState);
        }

        /// <remarks/>
        public string EndUpdateUserAppConsent(System.IAsyncResult asyncResult)
        {
            object[] results = this.EndInvoke(asyncResult);
            return ((string)(results[0]));
        }

        /// <remarks/>
        [System.Web.Services.Protocols.SoapHeaderAttribute("PPSoapHeader")]
        [System.Web.Services.Protocols.SoapHeaderAttribute("WSSecurityHeader")]
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("#EnumerateAppPermissions", RequestNamespace = "http://schemas.microsoft.com/Passport/SoapServices/ProfileServiceAPI/V1", ResponseNamespace = "http://schemas.microsoft.com/Passport/SoapServices/ProfileServiceAPI/V1", Use = System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle = System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        [return: System.Xml.Serialization.XmlElementAttribute("pbstrAppPermissionXML")]
        public string EnumerateAppPermissions(tagPASSID1 passID, string bstrFilterXML)
        {
            object[] results = this.Invoke("EnumerateAppPermissions", new object[] {
                        passID,
                        bstrFilterXML});
            return ((string)(results[0]));
        }

        /// <remarks/>
        public System.IAsyncResult BeginEnumerateAppPermissions(tagPASSID1 passID, string bstrFilterXML, System.AsyncCallback callback, object asyncState)
        {
            return this.BeginInvoke("EnumerateAppPermissions", new object[] {
                        passID,
                        bstrFilterXML}, callback, asyncState);
        }

        /// <remarks/>
        public string EndEnumerateAppPermissions(System.IAsyncResult asyncResult)
        {
            object[] results = this.EndInvoke(asyncResult);
            return ((string)(results[0]));
        }

        /// <remarks/>
        [System.Web.Services.Protocols.SoapHeaderAttribute("PPSoapHeader")]
        [System.Web.Services.Protocols.SoapHeaderAttribute("WSSecurityHeader")]
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("#GetDelegationToken", RequestNamespace = "http://schemas.microsoft.com/Passport/SoapServices/ProfileServiceAPI/V1", ResponseNamespace = "http://schemas.microsoft.com/Passport/SoapServices/ProfileServiceAPI/V1", Use = System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle = System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        [return: System.Xml.Serialization.XmlElementAttribute("pbstrAppPermissionXML")]
        public string GetDelegationToken(tagPASSID1 passID, string bstrFilterXML)
        {
            object[] results = this.Invoke("GetDelegationToken", new object[] {
                        passID,
                        bstrFilterXML});
            return ((string)(results[0]));
        }

        /// <remarks/>
        public System.IAsyncResult BeginGetDelegationToken(tagPASSID1 passID, string bstrFilterXML, System.AsyncCallback callback, object asyncState)
        {
            return this.BeginInvoke("GetDelegationToken", new object[] {
                        passID,
                        bstrFilterXML}, callback, asyncState);
        }

        /// <remarks/>
        public string EndGetDelegationToken(System.IAsyncResult asyncResult)
        {
            object[] results = this.EndInvoke(asyncResult);
            return ((string)(results[0]));
        }

        /// <remarks/>
        [System.Web.Services.Protocols.SoapHeaderAttribute("PPSoapHeader")]
        [System.Web.Services.Protocols.SoapHeaderAttribute("WSSecurityHeader")]
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("#ReservePassports", RequestNamespace = "http://schemas.microsoft.com/Passport/SoapServices/ProfileServiceAPI/V1", ResponseNamespace = "http://schemas.microsoft.com/Passport/SoapServices/ProfileServiceAPI/V1", Use = System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle = System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        [return: System.Xml.Serialization.XmlArrayAttribute("ppbstrReservedAccountsArray", IsNullable = true)]
        [return: System.Xml.Serialization.XmlArrayItemAttribute(IsNullable = false)]
        public string[] ReservePassports([System.Xml.Serialization.XmlArrayAttribute(IsNullable = true)] [System.Xml.Serialization.XmlArrayItemAttribute(IsNullable = false)] string[] pbstrAccountXMLArray, eTRANSACTION etFlags, out string pbstrErrorBlob)
        {
            object[] results = this.Invoke("ReservePassports", new object[] {
                        pbstrAccountXMLArray,
                        etFlags});
            pbstrErrorBlob = ((string)(results[1]));
            return ((string[])(results[0]));
        }

        /// <remarks/>
        public System.IAsyncResult BeginReservePassports(string[] pbstrAccountXMLArray, eTRANSACTION etFlags, System.AsyncCallback callback, object asyncState)
        {
            return this.BeginInvoke("ReservePassports", new object[] {
                        pbstrAccountXMLArray,
                        etFlags}, callback, asyncState);
        }

        /// <remarks/>
        public string[] EndReservePassports(System.IAsyncResult asyncResult, out string pbstrErrorBlob)
        {
            object[] results = this.EndInvoke(asyncResult);
            pbstrErrorBlob = ((string)(results[1]));
            return ((string[])(results[0]));
        }

        /// <remarks/>
        [System.Web.Services.Protocols.SoapHeaderAttribute("PPSoapHeader")]
        [System.Web.Services.Protocols.SoapHeaderAttribute("WSSecurityHeader")]
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("#GenerateOneTimeToken", RequestNamespace = "http://schemas.microsoft.com/Passport/SoapServices/ProfileServiceAPI/V1", ResponseNamespace = "http://schemas.microsoft.com/Passport/SoapServices/ProfileServiceAPI/V1", Use = System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle = System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        [return: System.Xml.Serialization.XmlElementAttribute("bstrOneTimeToken")]
        public string GenerateOneTimeToken(tagPASSID1 PassID, string bstrGenerateOneTimeTokenXML)
        {
            object[] results = this.Invoke("GenerateOneTimeToken", new object[] {
                        PassID,
                        bstrGenerateOneTimeTokenXML});
            return ((string)(results[0]));
        }

        /// <remarks/>
        public System.IAsyncResult BeginGenerateOneTimeToken(tagPASSID1 PassID, string bstrGenerateOneTimeTokenXML, System.AsyncCallback callback, object asyncState)
        {
            return this.BeginInvoke("GenerateOneTimeToken", new object[] {
                        PassID,
                        bstrGenerateOneTimeTokenXML}, callback, asyncState);
        }

        /// <remarks/>
        public string EndGenerateOneTimeToken(System.IAsyncResult asyncResult)
        {
            object[] results = this.EndInvoke(asyncResult);
            return ((string)(results[0]));
        }

        /// <remarks/>
        [System.Web.Services.Protocols.SoapHeaderAttribute("PPSoapHeader")]
        [System.Web.Services.Protocols.SoapHeaderAttribute("WSSecurityHeader")]
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("#SendOneTimeToken", RequestNamespace = "http://schemas.microsoft.com/Passport/SoapServices/ProfileServiceAPI/V1", ResponseNamespace = "http://schemas.microsoft.com/Passport/SoapServices/ProfileServiceAPI/V1", Use = System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle = System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        [return: System.Xml.Serialization.XmlElementAttribute("bstrSendOneTimeTokenResultXML")]
        public string SendOneTimeToken(tagPASSID1 PassID, string bstrSendOneTimeTokenXML)
        {
            object[] results = this.Invoke("SendOneTimeToken", new object[] {
                        PassID,
                        bstrSendOneTimeTokenXML});
            return ((string)(results[0]));
        }

        /// <remarks/>
        public System.IAsyncResult BeginSendOneTimeToken(tagPASSID1 PassID, string bstrSendOneTimeTokenXML, System.AsyncCallback callback, object asyncState)
        {
            return this.BeginInvoke("SendOneTimeToken", new object[] {
                        PassID,
                        bstrSendOneTimeTokenXML}, callback, asyncState);
        }

        /// <remarks/>
        public string EndSendOneTimeToken(System.IAsyncResult asyncResult)
        {
            object[] results = this.EndInvoke(asyncResult);
            return ((string)(results[0]));
        }

        /// <remarks/>
        [System.Web.Services.Protocols.SoapHeaderAttribute("PPSoapHeader")]
        [System.Web.Services.Protocols.SoapHeaderAttribute("WSSecurityHeader")]
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("#ConsumeOneTimeToken", RequestNamespace = "http://schemas.microsoft.com/Passport/SoapServices/ProfileServiceAPI/V1", ResponseNamespace = "http://schemas.microsoft.com/Passport/SoapServices/ProfileServiceAPI/V1", Use = System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle = System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public void ConsumeOneTimeToken(tagPASSID1 PassID, string bstrOneTimeToken, string bstrConsumeOneTimeTokenXML)
        {
            this.Invoke("ConsumeOneTimeToken", new object[] {
                        PassID,
                        bstrOneTimeToken,
                        bstrConsumeOneTimeTokenXML});
        }

        /// <remarks/>
        public System.IAsyncResult BeginConsumeOneTimeToken(tagPASSID1 PassID, string bstrOneTimeToken, string bstrConsumeOneTimeTokenXML, System.AsyncCallback callback, object asyncState)
        {
            return this.BeginInvoke("ConsumeOneTimeToken", new object[] {
                        PassID,
                        bstrOneTimeToken,
                        bstrConsumeOneTimeTokenXML}, callback, asyncState);
        }

        /// <remarks/>
        public void EndConsumeOneTimeToken(System.IAsyncResult asyncResult)
        {
            this.EndInvoke(asyncResult);
        }

        /// <remarks/>
        [System.Web.Services.Protocols.SoapHeaderAttribute("PPSoapHeader")]
        [System.Web.Services.Protocols.SoapHeaderAttribute("WSSecurityHeader")]
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("#BatchSendOneTimeToken", RequestNamespace = "http://schemas.microsoft.com/Passport/SoapServices/ProfileServiceAPI/V1", ResponseNamespace = "http://schemas.microsoft.com/Passport/SoapServices/ProfileServiceAPI/V1", Use = System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle = System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        [return: System.Xml.Serialization.XmlElementAttribute("bstrSendBatchOneTimeTokenResultXML")]
        public string BatchSendOneTimeToken(tagPASSID1 PassID, string bstrSendBatchOneTimeTokenXML)
        {
            object[] results = this.Invoke("BatchSendOneTimeToken", new object[] {
                        PassID,
                        bstrSendBatchOneTimeTokenXML});
            return ((string)(results[0]));
        }

        /// <remarks/>
        public System.IAsyncResult BeginBatchSendOneTimeToken(tagPASSID1 PassID, string bstrSendBatchOneTimeTokenXML, System.AsyncCallback callback, object asyncState)
        {
            return this.BeginInvoke("BatchSendOneTimeToken", new object[] {
                        PassID,
                        bstrSendBatchOneTimeTokenXML}, callback, asyncState);
        }

        /// <remarks/>
        public string EndBatchSendOneTimeToken(System.IAsyncResult asyncResult)
        {
            object[] results = this.EndInvoke(asyncResult);
            return ((string)(results[0]));
        }

        /// <remarks/>
        [System.Web.Services.Protocols.SoapHeaderAttribute("PPSoapHeader")]
        [System.Web.Services.Protocols.SoapHeaderAttribute("WSSecurityHeader")]
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("#SetPreferredDogfoodState", RequestNamespace = "http://schemas.microsoft.com/Passport/SoapServices/ProfileServiceAPI/V1", ResponseNamespace = "http://schemas.microsoft.com/Passport/SoapServices/ProfileServiceAPI/V1", Use = System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle = System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public void SetPreferredDogfoodState(string bstrNetID, string fOptInForDogfood)
        {
            this.Invoke("SetPreferredDogfoodState", new object[] {
                        bstrNetID,
                        fOptInForDogfood});
        }

        /// <remarks/>
        public System.IAsyncResult BeginSetPreferredDogfoodState(string bstrNetID, string fOptInForDogfood, System.AsyncCallback callback, object asyncState)
        {
            return this.BeginInvoke("SetPreferredDogfoodState", new object[] {
                        bstrNetID,
                        fOptInForDogfood}, callback, asyncState);
        }

        /// <remarks/>
        public void EndSetPreferredDogfoodState(System.IAsyncResult asyncResult)
        {
            this.EndInvoke(asyncResult);
        }
    }

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Web.Services.WebServiceBindingAttribute(Name = "AuthorizationServerSoap", Namespace = "http://schemas.microsoft.com/Passport/SoapServices/AuthorizationServer/V1")]
    [System.Xml.Serialization.XmlIncludeAttribute(typeof(string[]))]
    public partial class AuthorizationServerSoap : System.Web.Services.Protocols.SoapHttpClientProtocol
    {

        public PPSoapHeader_wrapper2 PPSoapHeader;

        public tagWSSECURITYHEADER2 WSSecurityHeader;

        /// <remarks/>
        public AuthorizationServerSoap()
        {
            this.Url = "https://authorization.service.passport.net:443/pp1100/AuthorizationServerWSDL.srf" +
                "?Handler=AuthorizationServer";
        }

        /// <remarks/>
        [System.Web.Services.Protocols.SoapHeaderAttribute("PPSoapHeader")]
        [System.Web.Services.Protocols.SoapHeaderAttribute("WSSecurityHeader")]
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("#GenerateAuthZToken", RequestNamespace = "http://schemas.microsoft.com/Passport/SoapServices/AuthorizationServer/V1", ResponseNamespace = "http://schemas.microsoft.com/Passport/SoapServices/AuthorizationServer/V1", Use = System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle = System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        [return: System.Xml.Serialization.XmlElementAttribute("AuthzToken")]
        public string GenerateAuthZToken(string SourceScope, [System.Xml.Serialization.XmlArrayAttribute(IsNullable = true)] [System.Xml.Serialization.XmlArrayItemAttribute(IsNullable = false)] string[] ResourceArray, uint ulFlags)
        {
            object[] results = this.Invoke("GenerateAuthZToken", new object[] {
                        SourceScope,
                        ResourceArray,
                        ulFlags});
            return ((string)(results[0]));
        }

        /// <remarks/>
        public System.IAsyncResult BeginGenerateAuthZToken(string SourceScope, string[] ResourceArray, uint ulFlags, System.AsyncCallback callback, object asyncState)
        {
            return this.BeginInvoke("GenerateAuthZToken", new object[] {
                        SourceScope,
                        ResourceArray,
                        ulFlags}, callback, asyncState);
        }

        /// <remarks/>
        public string EndGenerateAuthZToken(System.IAsyncResult asyncResult)
        {
            object[] results = this.EndInvoke(asyncResult);
            return ((string)(results[0]));
        }

        /// <remarks/>
        [System.Web.Services.Protocols.SoapHeaderAttribute("PPSoapHeader")]
        [System.Web.Services.Protocols.SoapHeaderAttribute("WSSecurityHeader")]
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("#GenerateAuthZTokenForBinding", RequestNamespace = "http://schemas.microsoft.com/Passport/SoapServices/AuthorizationServer/V1", ResponseNamespace = "http://schemas.microsoft.com/Passport/SoapServices/AuthorizationServer/V1", Use = System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle = System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        [return: System.Xml.Serialization.XmlElementAttribute("AuthzToken")]
        public string GenerateAuthZTokenForBinding(string SourceScope, string TargetBindingScope, string TargetScopeType, uint ulFlags)
        {
            object[] results = this.Invoke("GenerateAuthZTokenForBinding", new object[] {
                        SourceScope,
                        TargetBindingScope,
                        TargetScopeType,
                        ulFlags});
            return ((string)(results[0]));
        }

        /// <remarks/>
        public System.IAsyncResult BeginGenerateAuthZTokenForBinding(string SourceScope, string TargetBindingScope, string TargetScopeType, uint ulFlags, System.AsyncCallback callback, object asyncState)
        {
            return this.BeginInvoke("GenerateAuthZTokenForBinding", new object[] {
                        SourceScope,
                        TargetBindingScope,
                        TargetScopeType,
                        ulFlags}, callback, asyncState);
        }

        /// <remarks/>
        public string EndGenerateAuthZTokenForBinding(System.IAsyncResult asyncResult)
        {
            object[] results = this.EndInvoke(asyncResult);
            return ((string)(results[0]));
        }

        /// <remarks/>
        [System.Web.Services.Protocols.SoapHeaderAttribute("PPSoapHeader")]
        [System.Web.Services.Protocols.SoapHeaderAttribute("WSSecurityHeader")]
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("#GenerateAuthZTokenFromProof", RequestNamespace = "http://schemas.microsoft.com/Passport/SoapServices/AuthorizationServer/V1", ResponseNamespace = "http://schemas.microsoft.com/Passport/SoapServices/AuthorizationServer/V1", Use = System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle = System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        [return: System.Xml.Serialization.XmlElementAttribute("AuthZToken")]
        public string GenerateAuthZTokenFromProof(eProofPurpose ProofPurpose, string ProofXML, out string NetID)
        {
            object[] results = this.Invoke("GenerateAuthZTokenFromProof", new object[] {
                        ProofPurpose,
                        ProofXML});
            NetID = ((string)(results[1]));
            return ((string)(results[0]));
        }

        /// <remarks/>
        public System.IAsyncResult BeginGenerateAuthZTokenFromProof(eProofPurpose ProofPurpose, string ProofXML, System.AsyncCallback callback, object asyncState)
        {
            return this.BeginInvoke("GenerateAuthZTokenFromProof", new object[] {
                        ProofPurpose,
                        ProofXML}, callback, asyncState);
        }

        /// <remarks/>
        public string EndGenerateAuthZTokenFromProof(System.IAsyncResult asyncResult, out string NetID)
        {
            object[] results = this.EndInvoke(asyncResult);
            NetID = ((string)(results[1]));
            return ((string)(results[0]));
        }

        /// <remarks/>
        [System.Web.Services.Protocols.SoapHeaderAttribute("PPSoapHeader")]
        [System.Web.Services.Protocols.SoapHeaderAttribute("WSSecurityHeader")]
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("#EvaluateAuthZToken", RequestNamespace = "http://schemas.microsoft.com/Passport/SoapServices/AuthorizationServer/V1", ResponseNamespace = "http://schemas.microsoft.com/Passport/SoapServices/AuthorizationServer/V1", Use = System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle = System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        [return: System.Xml.Serialization.XmlArrayAttribute("ClaimsGrantedArray", IsNullable = true)]
        [return: System.Xml.Serialization.XmlArrayItemAttribute(IsNullable = false)]
        public string[] EvaluateAuthZToken(string AuthzToken, string ResourceScope, [System.Xml.Serialization.XmlArrayAttribute(IsNullable = true)] [System.Xml.Serialization.XmlArrayItemAttribute(IsNullable = false)] string[] ClaimsArray, uint ulFlags)
        {
            object[] results = this.Invoke("EvaluateAuthZToken", new object[] {
                        AuthzToken,
                        ResourceScope,
                        ClaimsArray,
                        ulFlags});
            return ((string[])(results[0]));
        }

        /// <remarks/>
        public System.IAsyncResult BeginEvaluateAuthZToken(string AuthzToken, string ResourceScope, string[] ClaimsArray, uint ulFlags, System.AsyncCallback callback, object asyncState)
        {
            return this.BeginInvoke("EvaluateAuthZToken", new object[] {
                        AuthzToken,
                        ResourceScope,
                        ClaimsArray,
                        ulFlags}, callback, asyncState);
        }

        /// <remarks/>
        public string[] EndEvaluateAuthZToken(System.IAsyncResult asyncResult)
        {
            object[] results = this.EndInvoke(asyncResult);
            return ((string[])(results[0]));
        }

        /// <remarks/>
        [System.Web.Services.Protocols.SoapHeaderAttribute("PPSoapHeader")]
        [System.Web.Services.Protocols.SoapHeaderAttribute("WSSecurityHeader")]
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("#EvaluateAuthZTokenForXML", RequestNamespace = "http://schemas.microsoft.com/Passport/SoapServices/AuthorizationServer/V1", ResponseNamespace = "http://schemas.microsoft.com/Passport/SoapServices/AuthorizationServer/V1", Use = System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle = System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        [return: System.Xml.Serialization.XmlElementAttribute("ClaimEvaluationXML")]
        public string EvaluateAuthZTokenForXML(string AuthzToken, string ClaimBindingsXML, uint ulFlags)
        {
            object[] results = this.Invoke("EvaluateAuthZTokenForXML", new object[] {
                        AuthzToken,
                        ClaimBindingsXML,
                        ulFlags});
            return ((string)(results[0]));
        }

        /// <remarks/>
        public System.IAsyncResult BeginEvaluateAuthZTokenForXML(string AuthzToken, string ClaimBindingsXML, uint ulFlags, System.AsyncCallback callback, object asyncState)
        {
            return this.BeginInvoke("EvaluateAuthZTokenForXML", new object[] {
                        AuthzToken,
                        ClaimBindingsXML,
                        ulFlags}, callback, asyncState);
        }

        /// <remarks/>
        public string EndEvaluateAuthZTokenForXML(System.IAsyncResult asyncResult)
        {
            object[] results = this.EndInvoke(asyncResult);
            return ((string)(results[0]));
        }

        /// <remarks/>
        [System.Web.Services.Protocols.SoapHeaderAttribute("PPSoapHeader")]
        [System.Web.Services.Protocols.SoapHeaderAttribute("WSSecurityHeader")]
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("#GetProofsForPurpose", RequestNamespace = "http://schemas.microsoft.com/Passport/SoapServices/AuthorizationServer/V1", ResponseNamespace = "http://schemas.microsoft.com/Passport/SoapServices/AuthorizationServer/V1", Use = System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle = System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        [return: System.Xml.Serialization.XmlElementAttribute("pbstrProofs")]
        public string GetProofsForPurpose(eProofPurpose eppPurpose, tagPASSID2 PassID)
        {
            object[] results = this.Invoke("GetProofsForPurpose", new object[] {
                        eppPurpose,
                        PassID});
            return ((string)(results[0]));
        }

        /// <remarks/>
        public System.IAsyncResult BeginGetProofsForPurpose(eProofPurpose eppPurpose, tagPASSID2 PassID, System.AsyncCallback callback, object asyncState)
        {
            return this.BeginInvoke("GetProofsForPurpose", new object[] {
                        eppPurpose,
                        PassID}, callback, asyncState);
        }

        /// <remarks/>
        public string EndGetProofsForPurpose(System.IAsyncResult asyncResult)
        {
            object[] results = this.EndInvoke(asyncResult);
            return ((string)(results[0]));
        }

        /// <remarks/>
        [System.Web.Services.Protocols.SoapHeaderAttribute("PPSoapHeader")]
        [System.Web.Services.Protocols.SoapHeaderAttribute("WSSecurityHeader")]
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("#GenerateAuthZTokenFromProofEx", RequestNamespace = "http://schemas.microsoft.com/Passport/SoapServices/AuthorizationServer/V1", ResponseNamespace = "http://schemas.microsoft.com/Passport/SoapServices/AuthorizationServer/V1", Use = System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle = System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        [return: System.Xml.Serialization.XmlElementAttribute("AuthZToken")]
        public string GenerateAuthZTokenFromProofEx(eProofPurpose ProofPurpose, string ProofXML, out string NetID, out string ProofInfo)
        {
            object[] results = this.Invoke("GenerateAuthZTokenFromProofEx", new object[] {
                        ProofPurpose,
                        ProofXML});
            NetID = ((string)(results[1]));
            ProofInfo = ((string)(results[2]));
            return ((string)(results[0]));
        }

        /// <remarks/>
        public System.IAsyncResult BeginGenerateAuthZTokenFromProofEx(eProofPurpose ProofPurpose, string ProofXML, System.AsyncCallback callback, object asyncState)
        {
            return this.BeginInvoke("GenerateAuthZTokenFromProofEx", new object[] {
                        ProofPurpose,
                        ProofXML}, callback, asyncState);
        }

        /// <remarks/>
        public string EndGenerateAuthZTokenFromProofEx(System.IAsyncResult asyncResult, out string NetID, out string ProofInfo)
        {
            object[] results = this.EndInvoke(asyncResult);
            NetID = ((string)(results[1]));
            ProofInfo = ((string)(results[2]));
            return ((string)(results[0]));
        }
    }

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(TypeName = "PPSoapHeader_wrapper", Namespace = "http://schemas.microsoft.com/Passport/SoapServices/ProfileServiceAPI/V1")]
    [System.Xml.Serialization.XmlRootAttribute("PPSoapHeader", Namespace = "http://schemas.microsoft.com/Passport/SoapServices/ProfileServiceAPI/V1", IsNullable = false)]
    public partial class PPSoapHeader_wrapper1 : System.Web.Services.Protocols.SoapHeader
    {

        /// <remarks/>
        [System.Xml.Serialization.XmlTextAttribute()]
        public string[] Text;
    }

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(TypeName = "PPSoapHeader_wrapper", Namespace = "http://schemas.microsoft.com/Passport/SoapServices/AuthorizationServer/V1")]
    [System.Xml.Serialization.XmlRootAttribute("PPSoapHeader", Namespace = "http://schemas.microsoft.com/Passport/SoapServices/AuthorizationServer/V1", IsNullable = false)]
    public partial class PPSoapHeader_wrapper2 : System.Web.Services.Protocols.SoapHeader
    {

        /// <remarks/>
        [System.Xml.Serialization.XmlTextAttribute()]
        public string[] Text;
    }

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace = "http://schemas.microsoft.com/Passport/SoapServices/CredentialServiceAPI/V1")]
    [System.Xml.Serialization.XmlRootAttribute("WSSecurityHeader", Namespace = "http://schemas.microsoft.com/Passport/SoapServices/CredentialServiceAPI/V1", IsNullable = false)]
    public partial class tagWSSECURITYHEADER : System.Web.Services.Protocols.SoapHeader
    {

        /// <remarks/>
        public EnumSHVersion version;

        /// <remarks/>
        public string wssecurity;

        /// <remarks/>
        public string authorization;

        /// <remarks/>
        public string sitetoken;

        /// <remarks/>
        public string ppSoapHeader25;

        /// <remarks/>
        public string auditInfo;

        /// <remarks/>
        public string @delegate;

        /// <remarks/>
        public string originator;

        /// <remarks/>
        public string clientip;
    }

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace = "http://schemas.microsoft.com/Passport/SoapServices/CredentialServiceAPI/V1")]
    public enum EnumSHVersion
    {

        /// <remarks/>
        eshHeader30,

        /// <remarks/>
        eshHeader25,

        /// <remarks/>
        eshNone,
    }

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(TypeName = "tagPASSID", Namespace = "http://schemas.microsoft.com/Passport/SoapServices/AuthorizationServer/V1")]
    public partial class tagPASSID2
    {

        /// <remarks/>
        public PASSIDTYPE2 pit;

        /// <remarks/>
        public string bstrID;
    }

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Xml.Serialization.XmlTypeAttribute(TypeName = "PASSIDTYPE", Namespace = "http://schemas.microsoft.com/Passport/SoapServices/AuthorizationServer/V1")]
    public enum PASSIDTYPE2
    {

        /// <remarks/>
        PASSID_AUID,

        /// <remarks/>
        PASSID_ALIASNAME,

        /// <remarks/>
        PASSID_PUID_SIGNINNAME,

        /// <remarks/>
        PASSID_ROLEID,

        /// <remarks/>
        PASSID_PPSACREDENTIALID,

        /// <remarks/>
        PASSID_NULL,

        /// <remarks/>
        PASSID_PUID,

        /// <remarks/>
        PASSID_SIGNINNAME,
    }

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(TypeName = "tagPASSID", Namespace = "http://schemas.microsoft.com/Passport/SoapServices/ProfileServiceAPI/V1")]
    public partial class tagPASSID1
    {

        /// <remarks/>
        public PASSIDTYPE1 pit;

        /// <remarks/>
        public string bstrID;
    }

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Xml.Serialization.XmlTypeAttribute(TypeName = "PASSIDTYPE", Namespace = "http://schemas.microsoft.com/Passport/SoapServices/ProfileServiceAPI/V1")]
    public enum PASSIDTYPE1
    {

        /// <remarks/>
        PASSID_AUID,

        /// <remarks/>
        PASSID_ALIASNAME,

        /// <remarks/>
        PASSID_PUID_SIGNINNAME,

        /// <remarks/>
        PASSID_ROLEID,

        /// <remarks/>
        PASSID_PPSACREDENTIALID,

        /// <remarks/>
        PASSID_NULL,

        /// <remarks/>
        PASSID_PUID,

        /// <remarks/>
        PASSID_SIGNINNAME,
    }

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace = "http://schemas.microsoft.com/Passport/SoapServices/CredentialServiceAPI/V1")]
    public partial class tagPASSID
    {

        /// <remarks/>
        public PASSIDTYPE pit;

        /// <remarks/>
        public string bstrID;
    }

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace = "http://schemas.microsoft.com/Passport/SoapServices/CredentialServiceAPI/V1")]
    public enum PASSIDTYPE
    {

        /// <remarks/>
        PASSID_AUID,

        /// <remarks/>
        PASSID_ALIASNAME,

        /// <remarks/>
        PASSID_PUID_SIGNINNAME,

        /// <remarks/>
        PASSID_ROLEID,

        /// <remarks/>
        PASSID_PPSACREDENTIALID,

        /// <remarks/>
        PASSID_NULL,

        /// <remarks/>
        PASSID_PUID,

        /// <remarks/>
        PASSID_SIGNINNAME,
    }

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(TypeName = "tagWSSECURITYHEADER", Namespace = "http://schemas.microsoft.com/Passport/SoapServices/AuthorizationServer/V1")]
    [System.Xml.Serialization.XmlRootAttribute("WSSecurityHeader", Namespace = "http://schemas.microsoft.com/Passport/SoapServices/AuthorizationServer/V1", IsNullable = false)]
    public partial class tagWSSECURITYHEADER2 : System.Web.Services.Protocols.SoapHeader
    {

        /// <remarks/>
        public EnumSHVersion2 version;

        /// <remarks/>
        public string wssecurity;

        /// <remarks/>
        public string authorization;

        /// <remarks/>
        public string sitetoken;

        /// <remarks/>
        public string ppSoapHeader25;

        /// <remarks/>
        public string auditInfo;

        /// <remarks/>
        public string @delegate;

        /// <remarks/>
        public string originator;

        /// <remarks/>
        public string clientip;
    }

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Xml.Serialization.XmlTypeAttribute(TypeName = "EnumSHVersion", Namespace = "http://schemas.microsoft.com/Passport/SoapServices/AuthorizationServer/V1")]
    public enum EnumSHVersion2
    {

        /// <remarks/>
        eshHeader30,

        /// <remarks/>
        eshHeader25,

        /// <remarks/>
        eshNone,
    }

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(TypeName = "tagWSSECURITYHEADER", Namespace = "http://schemas.microsoft.com/Passport/SoapServices/ProfileServiceAPI/V1")]
    [System.Xml.Serialization.XmlRootAttribute("WSSecurityHeader", Namespace = "http://schemas.microsoft.com/Passport/SoapServices/ProfileServiceAPI/V1", IsNullable = false)]
    public partial class tagWSSECURITYHEADER1 : System.Web.Services.Protocols.SoapHeader
    {

        /// <remarks/>
        public EnumSHVersion1 version;

        /// <remarks/>
        public string wssecurity;

        /// <remarks/>
        public string authorization;

        /// <remarks/>
        public string sitetoken;

        /// <remarks/>
        public string ppSoapHeader25;

        /// <remarks/>
        public string auditInfo;

        /// <remarks/>
        public string @delegate;

        /// <remarks/>
        public string originator;

        /// <remarks/>
        public string clientip;
    }

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Xml.Serialization.XmlTypeAttribute(TypeName = "EnumSHVersion", Namespace = "http://schemas.microsoft.com/Passport/SoapServices/ProfileServiceAPI/V1")]
    public enum EnumSHVersion1
    {

        /// <remarks/>
        eshHeader30,

        /// <remarks/>
        eshHeader25,

        /// <remarks/>
        eshNone,
    }

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace = "http://schemas.microsoft.com/Passport/SoapServices/CredentialServiceAPI/V1")]
    [System.Xml.Serialization.XmlRootAttribute("PPSoapHeader", Namespace = "http://schemas.microsoft.com/Passport/SoapServices/CredentialServiceAPI/V1", IsNullable = false)]
    public partial class PPSoapHeader_wrapper : System.Web.Services.Protocols.SoapHeader
    {

        /// <remarks/>
        [System.Xml.Serialization.XmlTextAttribute()]
        public string[] Text;
    }

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace = "http://schemas.microsoft.com/Passport/SoapServices/CredentialServiceAPI/V1")]
    public enum eProofFilter
    {

        /// <remarks/>
        eProofFilter_Max,

        /// <remarks/>
        eProofFilter_NeedConfirm,

        /// <remarks/>
        eProofFilter_All,

        /// <remarks/>
        eProofFilter_Invalid,
    }

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace = "http://schemas.microsoft.com/Passport/SoapServices/ProfileServiceAPI/V1")]
    public enum eTRANSACTION
    {

        /// <remarks/>
        TX_MAX,

        /// <remarks/>
        TX_ROLLBACK_NONE,

        /// <remarks/>
        TX_ROLLBACK_ACCOUNT,

        /// <remarks/>
        TX_ROLLBACK_ALL,
    }

    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace = "http://schemas.microsoft.com/Passport/SoapServices/AuthorizationServer/V1")]
    public enum eProofPurpose
    {

        /// <remarks/>
        eProofPurpose_UnfamiliarLocationEasy,

        /// <remarks/>
        eProofPurpose_UnfamiliarLocationHard,

        /// <remarks/>
        eProofPurpose_OneTimePassword,

        /// <remarks/>
        eProofPurpose_FedRenameCredential,

        /// <remarks/>
        eProofPurpose_ConvertCredential,

        /// <remarks/>
        eProofPurpose_CompromiseRecovery,

        /// <remarks/>
        eProofPurpose_ChangePassword,

        /// <remarks/>
        eProofPurpose_ResetPassword,

        /// <remarks/>
        eProofPurpose_RecoverLostProofs,

        /// <remarks/>
        eProofPurpose_ManageProofs,

        /// <remarks/>
        eProofPurpose_StrongProofForCredMgt,

        /// <remarks/>
        eProofPurpose_ManageAlias,

        /// <remarks/>
        eProofPurpose_ManageMobile,

        /// <remarks/>
        eProofPurpose_ManageAltEmail,

        /// <remarks/>
        eProofPurpose_ManageDeviceStrongCred,

        /// <remarks/>
        eProofPurpose_CancelAlias,

        /// <remarks/>
        eProofPurpose_ConfirmAlias,

        /// <remarks/>
        eProofPurpose_ChangeCertificate,

        /// <remarks/>
        eProofPurpose_NewLinkCredProf,

        /// <remarks/>
        eProofPurpose_LinkedInt,

        /// <remarks/>
        eProofPurpose_CombinedInt,

        /// <remarks/>
        eProofPurpose_IntReadCredProf,

        /// <remarks/>
        eProofPurpose_CancelAccount,

        /// <remarks/>
        eProofPurpose_ConfirmAccount,

        /// <remarks/>
        eProofPurpose_ParentDeleteKid,

        /// <remarks/>
        eProofPurpose_ParentManageKid,

        /// <remarks/>
        eProofPurpose_CloseAccount,

        /// <remarks/>
        eProofPurpose_RenameCred,

        /// <remarks/>
        eProofPurpose_CancelEmail,

        /// <remarks/>
        eProofPurpose_ChangeSQSA,

        /// <remarks/>
        eProofPurpose_ChangePwd,

        /// <remarks/>
        eProofPurpose_ResetPwd,

        /// <remarks/>
        eProofPurpose_Invalid,
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\marketplace\billing\UserAccountAuthorizeProtocol.cs ===
using System.Xml;
using System.Xml.Serialization;

namespace xonline.common.billing
{
    public class ErrorInfo
    {
        public uint HResult;
        public string Message;

        public bool TagChangeRequired;
        public bool AcceptedTermsOfService;
        public bool AccountSuspended;

        [XmlIgnore]
        public bool SubscriptionLapsed;
        public bool BillingUnavailable;
    }

    public class UserAccountAuthorizeProtocol
    {
        [XmlRootAttribute( ElementName = "UserAccount_AuthorizeGetInfo" )]
        public class UserAccountAuthorizeInfo
        {
            public ErrorInfo ErrorInfo;

            public UserAccountAuthorizeAccountInfo AccountInfo;
        }

        public class UserAccountAuthorizeAccountInfo
        {
            public ulong XboxPuid;
            public ulong LivePuid;
            public string Tag;
            public string CountryCode;
            public bool ParentallyControlled;

            [XmlArrayItem( ElementName = "Privilege", Type = typeof( byte ) )]
            [XmlArray]
            public byte[] Privileges;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\marketplace\billing\SubscriptionUtil.cs ===
using System;
using System.Collections;
using System.Diagnostics;

using xonline.common.config;
using xonline.common.family;
using xonline.common.mgmt;
using xonline.common.musicnet;
using xonline.common.offer;
using xonline.common.protocol;
using xonline.common.service;
using xonline.common.sql.webstore;
using xonline.common.user;

using Microsoft.Webstore.WstClient;
using System.Transactions;
using xonline.core.history;


namespace xonline.common.billing
{
    public class UserSubscriptionInfo
    {
        public ulong LegacyOfferId
        {
            get;
            set;
        }
        public int Instances
        {
            get;
            set;
        }
        public string SvcInstanceId
        {
            get;
            set;
        }
        public int SubscriptionStatusId
        {
            get;
            set;
        }
        public int TransactionFlags
        {
            get;
            set;
        }
        public Guid CatalogOfferId
        {
            get;
            set;
        }
        public Guid CatalogOfferInstanceId
        {
            get;
            set;
        }
        public int TierId
        {
            get;
            set;
        }
    }

    public class XeSubscriptionUtil
    {
      
        public enum TransactionFlagsEnum : uint
        {
            ProvisionInProgress = 0x0001,
            CancelInProgress    = 0x0002,
            PurchaseInProgress  = 0x0004,
        };
        public enum SubscriptionStatus : int
        {
            Pending = 0,
            Enabled = 1,
            Suspended = 2,
            Expired = 3,
            Canceled = 4,
            Renewed = 10
        }
        private XeSubscriptionUtil()
        {
        }

        public static BasicSubscriptionInfo ReadBasicSubscriptionInfo(WstDataReader r)
        {
            BasicSubscriptionInfo info = new BasicSubscriptionInfo();

            info.offerID = (ulong) r.GetInt64(0);
            info.offerName = r.GetString(1);
            info.offerNameLength = (ushort) info.offerName.Length;
            info.sellText = r.GetString(2);
            info.sellTextLength = info.sellText.Length;
            info.titleName = r.GetString(3);
            if ( string.IsNullOrEmpty(info.titleName) )
            {
                info.titleName = null;
                info.titleNameLength = 0;
            }
            else
            {
                info.titleNameLength = (ushort) info.titleName.Length;
            }
            info.offerType = (uint) r.GetInt32(4);
            info.titleID = (uint) r.GetInt32(5);
            info.tierProvided = (byte) r.GetInt32(6);
            info.tierRequired = (byte) r.GetInt32(7);
            info.gameRating = (ushort) r.GetInt32(8);
            info.titleCategory = (uint) r.GetInt32(9);

            ushort globalDetails = (ushort) r.GetInt16(10);
            info.duration = Details.DetailsFlagsDuration(globalDetails);
            info.frequency = Details.DetailsFlagsFrequency(globalDetails);

            info.relationType = (byte) r.GetInt32(11);
            info.convertMode = (byte) r.GetInt32(12);
            info.userIsSubscribed = ((uint) r.GetInt32(13)) == 1;
            info.instanceID = r.GetString(14);
            if ( string.IsNullOrEmpty(info.instanceID) )
            {
                info.instanceID = null;
                info.instanceIDLength = 0;
            }
            else
            {
                info.instanceIDLength = (ushort) info.instanceID.Length;
            }

            info.relatedOfferID = (ulong) r.GetInt64(15);
            info.subscriptionStatusID = r.GetInt32(16);

            return info;
        }

        public static SubscriptionDetailsResponse GetDetails(SubscriptionDetailsRequest request)
        {
            int cultureID = Culture.GetCultureFromLanguageCountry(request.languageID, request.countryID);

            ulong offerID = request.offerID;

            //
            // XeSubscriptionUtil.GetDetails will only be called by Xenon
            // consoles.  If a details request is made for an Xbox1 offer,
            // it must be because an Xbox1 token (aka voucher) was entered.
            //
            // In that case, fetch details of the equivalent Xenon offer as
            // the details stored procedure would fail if called with an
            // Xbox1 offer (it assumes all offers will have a console type
            // of Xenon).
            //
            Offer subOffer = Offer.CreateInstance(offerID);
            if ( subOffer.IsXbox1Offer )
            {
                offerID = subOffer.EquivalentXenonOfferId;

                Xom.Trace(XomAreaName.contentutiltrace, LogLevel.L_NORMAL, "XeSubscriptionUtil.GetDetails: offer 0x" + request.offerID.ToString("X") + " is an Xbox1 offer.  Using equivalent Xenon offer id 0x" + offerID.ToString("X") + " instead." );
            }

            using(WSClient ws = new WSClient(ConfigUtil.UodbWebstoreApp, CmdType.WRITETHENREAD_COMMANDTYPE))
            {
                // Data is partitioned by user puid
                ws.PartitionType   = WstPartitionType.Logical;
                ws.SetHashVal(request.userPuid);

                ws.StoredProc = "dbo.p_xbos_subscription_details";

                ws.AddParameter(ParamType.RETVAL, "@RETVAL", 0);
                ws.AddParameter("@bi_user_puid", request.userPuid);
                ws.AddParameter("@i_country_id", request.countryID);
                ws.AddParameter("@i_culture_id", cultureID);
                ws.AddParameter("@bi_offer_id", offerID);
                ws.AddParameter("@i_payment_type_id", request.paymentType);
                ws.AddParameter("@i_tier_required", request.tierRequired);
                ws.AddParameter("@i_rating_system_id", (int) request.ratingSystem);

                using (WstDataReader r = ws.Execute())
                {
                    SubscriptionDetailsResponse results = new SubscriptionDetailsResponse();

                    if (r.Read())
                    {
                        BasicSubscriptionInfo info = ReadBasicSubscriptionInfo(r);
                        results.basicInfo = info;

                        ArrayList prices = new ArrayList();

                        r.NextResult();
                        while (r.Read())
                        {
                            OfferPrice price = XeContentUtil.ReadOfferPrice(r, cultureID);

                            prices.Add(price);
                        }

                        info.pricesLength = (byte) prices.Count;
                        info.prices = new OfferPrice [info.pricesLength];
                        prices.CopyTo(info.prices);
                    }

                    r.Close();

                    HResult hr = (uint) ws.GetIntParameter("@RETVAL");
                    if (HResult.Failed(hr))
                    {
                        string msg = ws.GetCallSignature() + " failed with hr = " + hr.ToString();

                        Xom.Trace(XomAreaName.contentutiltrace, LogLevel.L_ERROR, msg);

                        throw new XRLException(hr, XEvent.Id.COMMON_BILLING_CODE_209, msg);
                    }

                    //
                    // We can only return associated trial offers in the response if
                    // the console making the request hasn't reached the trial offer
                    // limit yet.
                    //
                    EnforceTrialLimit(request.machinePuid, new BasicSubscriptionInfo[]{results.basicInfo});

                    return results;
                }
            }
        }

        // EnforceTrialLimit
        // This will make sure that we do not return a associated trial offer
        // if the console making the request has already reached the trials
        // per console limit.
        protected static void EnforceTrialLimit(ulong machineId, BasicSubscriptionInfo[] infos)
        {
            int iCount = -1;
            int iLimit = Config.GetIntSetting(Setting.billing_maxTrialCount);

            for(int i=0; i < infos.Length; i++)
            {
                if(infos[i].relatedOfferID != 0)
                {
                    if(iCount == -1)
                    {
                        // This is a trip to UODB. Let's do it only if we
                        // really need too, and only once.

                        iCount = Machine.GetTrialCount(machineId);
                    }

                    if(iCount >= iLimit)
                    {
                        infos[i].relatedOfferID = 0;
                    }
                }
            }
        }

        /// <summary>
        /// Returns true if machine already has reached  trial limit
        /// </summary>
        public static bool IsEligibleForTrial(ulong machineId)
        {

            int iCount = -1;
            int iLimit = Config.GetIntSetting(Setting.billing_maxTrialCount);


            iCount = Machine.GetTrialCount(machineId);
            return (iCount >= iLimit) ? false : true;
              
        }
        public static SubscriptionEnumerateResponse EnumerateFromUODB(SubscriptionEnumerateRequest request)
        {
            int cultureID = Culture.GetCultureFromLanguageCountry(request.languageID, request.countryID);

            using(WSClient ws = new WSClient(ConfigUtil.UodbWebstoreApp, CmdType.WRITETHENREAD_COMMANDTYPE))
            {
                // Data is partitioned by user puid
                ws.PartitionType   = WstPartitionType.Logical;
                ws.SetHashVal(request.userPuid);

                ws.StoredProc = "dbo.p_xbos_subscription_enumerate";

                ws.AddParameter(ParamType.RETVAL, "@RETVAL", 0);
                ws.AddParameter("@bi_user_puid", request.userPuid);
                ws.AddParameter("@i_tier_required", request.userTier);
                ws.AddParameter("@i_country_id", request.countryID);
                ws.AddParameter("@i_culture_id", cultureID);
                ws.AddParameter("@i_starting_index", request.startingIndex);
                ws.AddParameter("@i_max_results", request.maxResults);

                int ratingSystemId = RegionalRatings.GetRatingSystem(request.gameRating);
                ws.AddParameter("@i_rating_system_id", ratingSystemId);

                int ratingRank = RegionalRatings.GetRating(request.gameRating);
                ws.AddParameter("@i_rating_rank", ratingRank);

                ws.AddParameter("@i_offer_type_id", request.offerType);
                ws.AddParameter("@i_payment_type_id", request.paymentType);

                ws.AddParameter("@i_title_id", request.titleID);
                ws.AddParameter("@i_title_bit_filter", request.titleCategories);

                ws.AddParameter("@i_query_for_new", request.queryForNew ? 1 : 0);
                ws.AddParameter("@i_query_for_renewals", request.queryForRenewals ? 1 : 0);
                ws.AddParameter("@i_query_for_current", request.queryForCurrent ? 1 : 0);
                ws.AddParameter("@i_query_for_expired", request.queryForExpired ? 1 : 0);
                ws.AddParameter("@i_query_for_suspended", request.queryForSuspended ? 1 : 0);

                bool partnernet = string.Compare(Config.Environment, "partnernet", true) == 0;
                ws.AddParameter("@i_partner_net", (partnernet ? 1 : 0));

                using (WstDataReader r = ws.Execute())
                {
                    SubscriptionEnumerateResponse results = new SubscriptionEnumerateResponse();

                    if (r.Read())
                    {
                        results.offersReturned = (ushort) r.GetInt32(0);

                        results.infos = new BasicSubscriptionInfo[results.offersReturned];

                        r.NextResult();
                        for (int i = 0; i < results.offersReturned; i++)
                        {
                            if (r.Read())
                            {
                                BasicSubscriptionInfo info = ReadBasicSubscriptionInfo(r);

                                info.pricesLength = (byte) r.GetInt32(16);
                                info.prices = new OfferPrice[info.pricesLength];

                                results.infos[i] = info;
                            }
                        }

                        r.NextResult();
                        for (int i = 0; i < results.offersReturned; i++)
                        {
                            BasicSubscriptionInfo info = results.infos[i];
                            if (info != null)
                            {
                                for (int p = 0; p < info.pricesLength; p++)
                                {
                                    if (r.Read())
                                    {
                                        ulong offerID = (ulong) r.GetInt64(4);
                                        Debug.Assert(offerID == info.offerID);

                                        OfferPrice price = XeContentUtil.ReadOfferPrice(r, cultureID);

                                        info.prices[p] = price;
                                    }
                                }
                            }
                        }

                        r.NextResult();
                        if (r.Read())
                        {
                            results.offersTotal = r.GetInt32(0);
                        }
                    }

                    r.Close();

                    HResult hr = (uint) ws.GetIntParameter("@RETVAL");
                    if (HResult.Failed(hr))
                    {
                        string msg = ws.GetCallSignature() + " failed with hr = " + hr.ToString();

                        Xom.Trace(XomAreaName.contentutiltrace, LogLevel.L_ERROR, msg);

                        throw new XRLException(hr, XEvent.Id.COMMON_BILLING_CODE_210, msg);
                    }

                    return results;
                }
            }
        }

        public static SubscriptionEnumerateResponse Enumerate(SubscriptionEnumerateRequest request)
        {
            SubscriptionInfoCollection siSet = null;
            //
            // Reconcile any subscriptions that no longer match up to what is returned from SCS
            // but only when we are looking at our current subs, or looking at renewal options
            //
            if (request.queryForRenewals || request.queryForCurrent || request.queryForSuspended)
            {
                siSet = ReconcileSubscriptions(request.userPuid);
            }

            //
            // Now return the desired subscriptions
            //
            SubscriptionEnumerateResponse response = EnumerateFromUODB(request);


            // For any subscription that exists in SCS (i.e. non-empty instance id),
            // find it in the reconciliation set and set the UserHasCancelled flag if
            // necessary.
            if ( siSet != null && response != null && response.infos != null )
            {
                foreach ( BasicSubscriptionInfo bsi in response.infos )
                {
                    if ( string.IsNullOrEmpty(bsi.instanceID) == false )
                    {
                        for (int i=0; i < siSet.SubscriptionInfoList.Count; i++)
                        {
                            SubscriptionInfo si = (SubscriptionInfo) siSet.SubscriptionInfoList[i];

                            if ( si.Instance != null && bsi.instanceID.Equals(si.Instance.ServiceInstanceId, StringComparison.InvariantCultureIgnoreCase) )
                            {
                                Xom.Trace(XomAreaName.contentutiltrace, LogLevel.L_LOW, string.Format("XeSubscriptionUtil.Enumerate: setting UserHasCancelled response flag to: {1} for subscription: {0}", bsi.instanceID, si.DelayedCancel) );

                                bsi.userHasCancelled = si.DelayedCancel;
                            }
                        }
                    }
                }
            }

            //
            // We can only return associated trial offers in the response if
            // the console making the request hasn't reached the trial offer
            // limit yet.
            //
            EnforceTrialLimit(request.machinePuid, response.infos);

            return response;
        }

        public static SubscriptionInfoCollection ReconcileSubscriptions(ulong userPuid)
        {
            // by default, attempt to provision a non-provisioned base subscription
            return ReconcileSubscriptions(userPuid, true);
        }

        public static SubscriptionInfoCollection ReconcileSubscriptions(ulong userPuid, bool fixProvisioningStatus)
        {
            HResult hr = HResult.S_OK;
            SubscriptionInfoCollection siSet = null;

            //
            // Load user so we can get their accountId
            //
            User u = new User();
            u.Load(userPuid);

            //
            // Only need to Reconcile if we have SCS subscriptions
            //
            if (BillingProvider.IsDummyId(u.AccountId))
            {
                Xom.Trace(XomAreaName.contentutiltrace, LogLevel.L_LOW, "ReconcileSubscriptions: user 0x" + u.Puid.ToString("X") + " is queued.  No reconciliation will be performed.");
                return siSet;
            }

            if (BillingConfig.ConnectToBilling == false)
            {
                hr = HResult.XONLINE_E_BILLING_NOT_CONNECTED;

                throw new XRLException(
                    hr,
                    XEvent.Id.COMMON_CONFIG_66,
                    "Couldn't load information for user puid 0x" + userPuid.ToString("x") +
                    " because ConnectToBilling=false!");
            }

            siSet = Subscription.GetSubscriptionInfoSet(u.BillingPuid, u.AccountId);

#if DEBUG
            // to assist with debugging, dump the state of all the returned SCS subscriptions
            for (int i = 0; i < siSet.SubscriptionInfoList.Count; i++)
            {
                SubscriptionInfo subInfo = (SubscriptionInfo) siSet.SubscriptionInfoList[i];

                if ( subInfo.Instance == null || subInfo.Instance.ServiceInstanceId == null )
                {
                    continue;
                }

                Xom.Trace(XomAreaName.contentutiltrace, LogLevel.L_HIGH, "ReconcileSubscriptions: user: 0x" + userPuid.ToString("X") + ", instanceId: " + subInfo.Instance.ServiceInstanceId + ", status: " + subInfo.SubscriptionStatus);
            }
#endif

            for (int i = 0; i < siSet.SubscriptionInfoList.Count; i++)
            {
                SubscriptionInfo subInfo = (SubscriptionInfo) siSet.SubscriptionInfoList[i];

                // Skip any subscriptions without service instances.  Xbox1 premium content purchases
                // may not have an instance.  Also, the user may have other non-Xbox subscrpitions on
                // their account as well.
                if ( subInfo.Instance == null || string.IsNullOrEmpty(subInfo.Instance.ServiceInstanceId) )
                {
                    Xom.Trace(XomAreaName.contentutiltrace, LogLevel.L_NORMAL, "ReconcileSubscriptions: user 0x" + userPuid.ToString("X") + ": subscription (id: " + subInfo.SubscriptionId + ", offer id: " + subInfo.OfferingGUID + ") has no service instance -- skipping...");
                    continue;
                }

                // See if the subscription is for an Xbox Live subscription
                Offer o = null;
                try
                {
                    bool authoritative = false;
                    o = Offer.CreateInstanceFromBillingOfferId(subInfo.OfferingGUID, 0, out authoritative);

                    Xom.Trace(XomAreaName.contentutiltrace, LogLevel.L_NORMAL, "ReconcileSubscriptions: user 0x" + userPuid.ToString("X") + ": subscription (id: " + subInfo.SubscriptionId + ", instance: " + subInfo.Instance.ServiceInstanceId + ", offer id: " + subInfo.OfferingGUID + ", subStatus: " + subInfo.SubscriptionStatus + ") has corresponding Xbox Live offer id: 0x" + o.OfferId.ToString("X") + " -- will attempt to reconcile...");
                }
                catch (Exception e)
                {
                    string msg = null;
                    if ( e is ExceptionWithHResult && ((ExceptionWithHResult)e).HResult == HResult.XONLINE_E_OFFERING_INVALID_OFFER_ID )
                    {
                        msg = "ReconcileSubscriptions: user 0x" + userPuid.ToString("X") + ": subscription (id: " + subInfo.SubscriptionId + ", offer id: " + subInfo.OfferingGUID + ") has no corresponding Xbox Live offer id -- skipping...";
                        Xom.Trace(XomAreaName.contentutiltrace, LogLevel.L_NORMAL, msg);
                    }
                    else
                    {
                        msg = "ReconcileSubscriptions: user " + (Puid) userPuid + ": subscription (id: " + subInfo.SubscriptionId + ", offer id: " + subInfo.OfferingGUID + ") attempt to load offer resulted in an exception";
                        Xom.Trace(XomAreaName.contentutiltrace, LogLevel.L_HIGH, msg + "\r\nException: " + e);
                        Xom.NtEvent(XEvent.Id.COMMON_CODE_13, e, msg);
                    }

                    continue;
                }

                DateTime activationDate = subInfo.ActivationDate;

                // 39824: In test environments, the clock on the billing server
                // is often advanced to test offer renewal scenarios.  So
                // for test environments (and test environments only),
                // if the activation date for the current subscription is
                // in the future, reset it to the current time.
                if ( Config.IsTestEnvironment() && activationDate > DateTime.UtcNow )
                {
                    activationDate = DateTime.UtcNow;
                }

                // Reconcile any inconsistencies between UODB and SCS with
                // respect to the service instance id and the subscription
                // status id.
                ReconcileSubscriptionInstanceAndStatus(userPuid, subInfo, o);

                // If the subscription is enabled but was not provisioned,
                // provision it now.
                if ( fixProvisioningStatus && Subscription.GetSubscriptionStatusId(subInfo.SubscriptionStatus) == Subscription.ENABLED && subInfo.Instance.ProvisioningStatus == "NOT PROVISIONED" )
                {
                    Xom.Trace(XomAreaName.contentutiltrace, LogLevel.L_NORMAL, "ReconcileSubscriptions: calling ReprovisionSubscription for user 0x" + u.Puid.ToString("X") + " and service instance id " + subInfo.Instance.ServiceInstanceId);

                    ReprovisionSubscription(u, subInfo);
                }
            }

            // reload the user object to pick up changes to instance, tier, etc.
            u = new User();
            u.Load(userPuid);

            // Due to a bug, juvenile users who migrated from Xbox1 to Xbox360
            // didn't have their subscriptions in UODB updated with the new
            // service component and a side-effect of that is that the
            // ProvisionServices callback from SCS never succeeded and so the
            // provisioning status is not correct.  Attempt to correct any
            // mismatches now.
            ReconcileBaseServiceInstance(u, siSet, fixProvisioningStatus);

            // reload the user object to pick up changes to instance, tier, etc.
            u = new User();
            u.Load(userPuid);

            // Due to a combination of several client and server bugs,
            // the user's silver downgrade flag or billing account status
            // may be out of sync.  Attempt to correct any mismatches now.
            ReconcileUserBillingAccountStatus(u);

            return siSet;
        }

        public  static bool HandleFamilyUsersInReconcile
            (
             User user
            ,out string instanceId
            ,out int subscriptionStatusId
            ,out Puid subscriptionOwnerPuid
            ,out ulong legacyOfferId
            )
        {
            instanceId=string.Empty;

            subscriptionStatusId=0;

            subscriptionOwnerPuid=0;

            Guid catalogOfferId=Guid.Empty;

            Guid catalogOfferInstanceId=Guid.Empty;

            int tierProvided=-1;

            legacyOfferId = 0;

            bool handled = false;

            Puid userOwnerPuid = user.GetOwnerPuid();

            User.XeGetBaseSubscription(
                                         user.Puid
                                        ,out instanceId
                                        ,out subscriptionStatusId
                                        ,out catalogOfferId
                                        ,out catalogOfferInstanceId
                                        ,out tierProvided
                                        ,out subscriptionOwnerPuid
                                        ,out legacyOfferId
                                       );

            if (
                //User is a dependent and is a family user but the ownerPuid in t_users to different from that in t_subscriptions
                //In this case we want to make sure that we change dependent's subscription state to cancelled and downgrade to silver so that he/she can be readded
                //to the family
                (
                        userOwnerPuid != subscriptionOwnerPuid
                        && subscriptionOwnerPuid != 0
                        && subscriptionStatusId == (int)SubscriptionStatus.Enabled
                        && user.IsFamilySecondary
                    )
                //User is a primary but has a wrong subscription ownerPuid and has that subscription active then we need to make sure that
                //the subscription status is cancelled and the user is marked for downgrade
                //this should ideally never happen
                ||
                    (
                        userOwnerPuid == user.Puid
                        && subscriptionOwnerPuid != 0
                        && subscriptionStatusId == (int)SubscriptionStatus.Enabled
                        && !user.IsFamilySecondary
                    )

                )
            {
                CancelAndDowngradeDependent
                (
                   user
                 , instanceId
                 , true
                 , HistoryReason.ExpireFamilyGold
                );

                handled = true;
            }
            //Irrespective of whether a user is primary/secondary, if the user has a ownerPuid for the base subscription but the status is not enabled /suspended
            //then mark the user for downgrade since this user should have been downgraded
            else if (subscriptionOwnerPuid != 0 && (subscriptionStatusId != (int)SubscriptionStatus.Enabled && subscriptionStatusId != (int)SubscriptionStatus.Suspended))
            {
                //Downgrade them only if they haven't been downgraded already
                if (!user.IsDowngraded)
                {
                    CancelAndDowngradeDependent
                       (
                          user
                        , instanceId
                        , false
                        , HistoryReason.ExpireFamilyGold
                       );
                }

                //Mark the user handled so we don't call CTP whether we downgraded them or not.
                handled = true;
            }
            //This case will happen if a dependent is removed from family and is attempted to be added again after cool down period without troubleshooting.
            //In this case we want to make sure that we dont call CTP.
            else if
                (
                       subscriptionOwnerPuid == 0
                    && subscriptionStatusId == (int)SubscriptionStatus.Canceled
                    && user.IsFamilySecondary
                    && user.IsDowngraded
                    && user.BillingAccountStatus== HResult.XONLINE_E_LOGON_USER_ACCOUNT_REQUIRES_MANAGEMENT
                )
            {
                handled = true;
            }

            // Check for inconsistency between subscription and flag in t_family_membership that indicates whether the
            // user occupies a gold seat. The user's current subscription is the authoritative source of info.
            if (!handled && user.IsParentallyControlled && user.Tier != (int)TierEnum.FamilyGold)
            {
                // The user doesn't have a family gold membership. Make sure t_family_membership doesn't
                // have the FAMILY_SUBSCRIPTION_GOLD flag set.
                FamilyMember[] familyMembers;
                user.GetFamilyMembers(out familyMembers);

                FamilyMember self = Array.Find(familyMembers, fm => fm.userPuid == user.Puid);
                if (self != null &&
                    (self.userFlags & FamilyDefs.FAMILY_SUBSCRIPTION_GOLD) == FamilyDefs.FAMILY_SUBSCRIPTION_GOLD)
                {
                    User.UpdateFamilyMemberGoldSeat(user.OwnerPassportPuid, user.Puid, false, HistoryReason.ExpireFamilyGold);
                }
            }
        
            //if we handled any of these cases then return true so that reconciliation code can skip the reconciliation process     
            return handled;                
        }

        public  static void CancelAndDowngradeDependent(User dependentUser, string instanceId, bool isCancel, HistoryReason reason)
        {
            //Call change dependent subscription status to cancelled and set the owner puid to null
            using (TransactionScope tx = new TransactionScope())
            {
                if (isCancel)
                {
                    ChangeDependentSubscriptionState(dependentUser.Puid, instanceId, (uint)SubscriptionStatus.Canceled, 0xFFFFFFFF, 0x0, null);
                }

                dependentUser.UpdateFamilyMemberGoldSeat(false, reason);

                dependentUser.BillingAccountStatus = HResult.XONLINE_E_LOGON_USER_ACCOUNT_REQUIRES_MANAGEMENT;

                //Downgrade the dependent to silver
                dependentUser.IsDowngraded = true;

                dependentUser.Save();

                tx.Complete();
            }
        }

        /// <summary>
        /// Saves the user
        /// 1)If the user is a family user then the change to downgraded flag and billing account status is replicated to dependent user as well in transactional manner.
        /// 2)If the user is not a family user then we just save the user , no transaction needed
        /// </summary>
        private static void SaveUserWithFamilyCheck(User user)
        {
            if (user.Tier == (int)TierEnum.FamilyGold)
            {
                //Get the family members and save the primary's account state and downgrade state.
                FamilyMember[] familyMembers = null;
                user.GetFamilyMembers(out familyMembers);

                using (TransactionScope tx = new TransactionScope())
                {
                    foreach (FamilyMember item in familyMembers)
                    {
                           if(
                               (item.userFlags & FamilyDefs.FAMILY_OWNER) == FamilyDefs.FAMILY_OWNER
                            || (item.userFlags & FamilyDefs.FAMILY_SUBSCRIPTION_GOLD) == FamilyDefs.FAMILY_SUBSCRIPTION_GOLD
                             )
                            {
                                User familyUser = new User();

                                familyUser.Load(item.userPuid);

                                familyUser.IsDowngraded = user.IsDowngraded;

                                familyUser.BillingAccountStatus = user.BillingAccountStatus;

                                familyUser.Save();
                            }
                    }

                    tx.Complete();
                }
            }
            else
            {
                user.Save();
            }
        }
        
        internal static void ReconcileSubscriptionInstanceAndStatus(ulong userPuid, SubscriptionInfo subInfo, Offer o)
        {
            Debug.Assert( subInfo.Instance != null );
            Debug.Assert( string.IsNullOrEmpty(subInfo.Instance.ServiceInstanceId) == false );

            if ( subInfo.Instance == null || string.IsNullOrEmpty(subInfo.Instance.ServiceInstanceId) )
            {
                throw new ArgumentException("subInfo.Instance.ServiceInstanceId must not be empty");
            }

            User user=new User();
            user.Load(userPuid);

            string instanceId = subInfo.Instance.ServiceInstanceId;

            Xom.Trace(XomAreaName.contentutiltrace, LogLevel.L_NORMAL, "ReconcileSubscriptionInstanceAndStatus: called for user 0x" + userPuid.ToString("X") + ", offerId: 0x" + o.OfferId.ToString("X") + ", instanceId: '" + instanceId + ", status: " + subInfo.SubscriptionStatus);

            DateTime activationDate = subInfo.ActivationDate;

            // 39824: In test environments, the clock on the billing server
            // is often advanced to test offer renewal scenarios.  So
            // for test environments (and test environments only),
            // if the activation date for the current subscription is
            // in the future, reset it to the current time.
            if ( Config.IsTestEnvironment() && activationDate > DateTime.UtcNow )
            {
                activationDate = DateTime.UtcNow;
            }

            ulong uodbOfferId;
            int uodbSubStatusId;
            string uodbInstanceId = instanceId;

            // attempt to locate the subscription in UODB by the service instance id
            User.GetSubscription(userPuid, instanceId, out uodbOfferId, out uodbSubStatusId);

            int scsSubStatusId = Subscription.GetSubscriptionStatusId(subInfo.SubscriptionStatus);

            //
            // If the offer id returned is 0, it means there's no current subscription in UODB
            // matching that instance.  It could be that a subscription was canceled and a new
            // instance was purchased, which would cause the row with the old instance to be
            // cleared and set to a status of 10.
            //
            // It could also mean that the PurchaseOfferingEx call timed out and the
            // subscription was saved with a dummy instance id.  In that case, the instance
            // needs to be corrected.
            //
            // If there is no match in UODB, make no attempt to correct anything.
            //
            if ( uodbOfferId == 0 )
            {
                // If the subscription is ENABLED in SCS, the instance mismatch could be the
                // result of a timeout.
                if ( scsSubStatusId == Subscription.ENABLED )
                {
                    User.GetSubscriptionFromServiceComponentId(userPuid, o.ServiceComponentId, out uodbInstanceId, out uodbOfferId, out uodbSubStatusId);

                }

                if ( uodbOfferId == 0 )
                {
                    Xom.Trace(XomAreaName.contentutiltrace, LogLevel.L_LOW, "ReconcileSubscriptionInstanceAndStatus: user: 0x" + userPuid.ToString("X") + ", instanceId: " + instanceId + ", status: " + subInfo.SubscriptionStatus + ": no UODB subscription found.  Skipping..." );

                    return;
                }
            }

            // fix up the instance id or offer id if it changed
            if ( uodbInstanceId != instanceId || uodbOfferId != o.OfferId )
            {
                Xom.Trace(XomAreaName.contentutiltrace, LogLevel.L_HIGH, "ReconcileSubscriptionInstanceAndStatus: user 0x" + userPuid.ToString("X") + ": subscription with instance id '" + instanceId + "' has an offer id that matches 0x" + o.OfferId.ToString("X")  + " in SCS and an offer id of 0x" + uodbOfferId.ToString("X") + " in UODB.  Updating UODB to match SCS...");

                BillingOfferInfo billingOfferInfo = null;
                
                Guid? catalogOfferId = null;
                
                Guid? catalogOfferInstanceId = null;
                
                try
                {
                    if (Config.GetBoolSetting(Setting.billing_useCatalogSubscriptionOffers))
                    {
                        billingOfferInfo = BillingOfferInfo.GetInstance(new Guid(subInfo.OfferingGUID));

                        catalogOfferId = billingOfferInfo.OfferId;
                        
                        catalogOfferInstanceId = billingOfferInfo.OfferInstanceId;
                    }

                    RenewalUtil.MoveSubscriptionWithFamilyCheck(userPuid, uodbOfferId, uodbInstanceId, o.OfferId, instanceId, catalogOfferId, catalogOfferInstanceId, activationDate,o);

                    // If this is an ENABLED subscription, do the same for the history table (though it may not be necessary)
                    if (scsSubStatusId == Subscription.ENABLED)
                    {
                        RenewalUtil.SetCurrentSubscriptionHistoryOfferWithFamilyCheck(userPuid, o.OfferId, catalogOfferId, catalogOfferInstanceId,o);
                    }
                }
                catch (Exception e)
                {
                    string msg = "ReconcileSubscriptionInstanceAndStatus: user: 0x" + userPuid.ToString("X") + ", instanceId: " + instanceId + ", status: " + subInfo.SubscriptionStatus + ": failed to update UODB!";
                    Xom.Trace(XomAreaName.contentutiltrace, LogLevel.L_ERROR, msg + "\r\nException: " + e);
                    Xom.NtEvent( XEvent.Id.COMMON_BILLING_MOVE_SUBSCRIPTION_FAILED, e, msg);
                }
            }

            // If there is a mismatch in subscription status ids between SCS
            // and UODB, update UODB to match what's in SCS.
            if ( uodbSubStatusId != scsSubStatusId )
            {
                Xom.Trace(XomAreaName.contentutiltrace, LogLevel.L_HIGH, "ReconcileSubscriptionInstanceAndStatus: user 0x" + userPuid.ToString("X") + ": subscription with instance id '" + instanceId + "' has a subscription status of " + scsSubStatusId + " (" + subInfo.SubscriptionStatus + ") in SCS and a subscription status of " + uodbSubStatusId + " in UODB.  Updating UODB to match SCS...");

                // clear both the in-progress and provision flags
                uint bitMask = ~( (uint)TransactionFlagsEnum.PurchaseInProgress | (uint)TransactionFlagsEnum.ProvisionInProgress );

                try
                {
                    // change the subscription status and the transaction flags
                    ChangeSubscriptionStateWithFamilyCheck(userPuid, string.Empty, subInfo.Instance.ServiceInstanceId, (uint)scsSubStatusId, bitMask, 0,o);
                }
                catch (Exception e)
                {
                    string msg = "ReconcileSubscriptionInstanceAndStatus: user: 0x" + userPuid.ToString("X") + ", instanceId: " + instanceId + ", status: " + subInfo.SubscriptionStatus + ": failed to update UODB!";
                    Xom.Trace(XomAreaName.contentutiltrace, LogLevel.L_ERROR, msg + "\r\nException: " + e);
                    Xom.NtEvent( XEvent.Id.COMMON_BILLING_CHANGE_SUBSCRIPTION_STATE_FAILED, e, msg);
                }
            }

            // If the subscription is for a MusicNet offer, call AddSubscriptionOffer if it's
            // enabled and CancelSubscriptionOffer if it's not enabled.
            if ( o.IsMusicNetSubscription && o.MusicNetSku != string.Empty )
            {
                if ( scsSubStatusId == Subscription.ENABLED )
                {
                    Guid trackingGuid = Guid.NewGuid();
                    try
                    {
                        Xom.Trace(XomAreaName.contentutiltrace, LogLevel.L_LOW, "ReconcileSubscriptions: calling MusicnetClient.AddSubscriptionOffer for user: 0x" + userPuid.ToString("X") + ", MusicNet SKU: " + o.MusicNetSku + " (offerId: 0x" + o.OfferId.ToString("X")  + ", status: " + subInfo.SubscriptionStatus + ")" );
                        if ( o.IsTrial )
                        {
                            MusicnetClient.AddTrialSubscriptionOffer(userPuid, o.MusicNetSku, trackingGuid);
                        }
                        else
                        {
                            MusicnetClient.AddSubscriptionOffer(userPuid, o.MusicNetSku, trackingGuid);
                        }
                    }
                    catch (Exception e)
                    {
                        string msg = "ReconcileSubscriptions: user: " + (Puid) userPuid + ", offerId: " + (OfferId) o.OfferId + ", MusicNet SKU: " + o.MusicNetSku + ": MusicnetClient.AddsubscriptionOffer failed.";
                        Xom.Trace(XomAreaName.contentutiltrace, LogLevel.L_HIGH, msg + "\r\nException: " + e);
                        Xom.NtEvent( XEvent.Id.COMMON_CODE_14, e, msg);
                    }
                }
                else if ( scsSubStatusId == Subscription.SUSPENDED || scsSubStatusId == Subscription.EXPIRED || scsSubStatusId == Subscription.CANCELED )
                {
                    try
                    {
                        Xom.Trace(XomAreaName.contentutiltrace, LogLevel.L_LOW, "ReconcileSubscriptions: calling MusicnetClient.CancelSubscriptionOffer for user: 0x" + userPuid.ToString("X") + ", MusicNet SKU: " + o.MusicNetSku + " (offerId: 0x" + o.OfferId.ToString("X") + ", status: " + subInfo.SubscriptionStatus + ")" );
                        MusicnetClient.CancelSubscriptionOffer(userPuid, true);
                    }
                    catch (Exception e)
                    {
                        string msg = "ReconcileSubscriptions: user: " + (Puid) userPuid + ", offerId: " + (OfferId) o.OfferId + ", MusicNet SKU: " + o.MusicNetSku + ": MusicnetClient.CancelSubscriptionOffer: failed with exception";
                        Xom.Trace(XomAreaName.contentutiltrace, LogLevel.L_HIGH, msg + "\r\nException: " + e);
                        Xom.NtEvent( XEvent.Id.COMMON_CODE_14, e, msg);
                    }
                }
            }
        }

        
        internal static void ReconcileBaseServiceInstance(User u, SubscriptionInfoCollection siSet, bool fixProvisioningStatus)
        {
            ulong baseOfferId = 0;
            string baseInstanceId = "";
            int subscriptionStatusId = 0;
            u.XeGetBaseSubscription(out baseInstanceId, out baseOfferId, out subscriptionStatusId);
            
            Xom.Trace(XomAreaName.contentutiltrace, LogLevel.L_NORMAL, "ReconcileBaseServiceInstance: in UODB, user 0x" + u.Puid.ToString("X") + " has base offer id 0x" + baseOfferId.ToString("X") + " and service instance id '" + baseInstanceId + "' with a subscription status of " + subscriptionStatusId);

            int scsEnabledBaseSubscriptions = 0;
            string scsBaseInstanceId = string.Empty;
            ulong scsBaseXboxOfferId = 0;
            string billingOfferId = string.Empty;
            uint tierProvided=0;
            Offer scsOffer=null;

            for (int i = 0; i < siSet.SubscriptionInfoList.Count; i++)
            {
                SubscriptionInfo subInfo = (SubscriptionInfo) siSet.SubscriptionInfoList[i];

                if ( string.IsNullOrEmpty(subInfo.Instance.ServiceInstanceId) )
                {
                    Xom.Trace(XomAreaName.contentutiltrace, LogLevel.L_NORMAL, "ReconcileBaseServiceInstance: user: 0x" + u.Puid.ToString("X") + ": subscription has no instance.  Skipping...");
                    continue;
                }

                //We will attempt reconciling both suspended/enabled subscriptions
                if (!subInfo.SubscriptionStatus.Equals("ENABLED", StringComparison.InvariantCultureIgnoreCase) && !subInfo.SubscriptionStatus.Equals("SUSPENDED", StringComparison.InvariantCultureIgnoreCase))
                {
                    Xom.Trace(XomAreaName.contentutiltrace, LogLevel.L_NORMAL, "ReconcileBaseServiceInstance: user: 0x" + u.Puid.ToString("X") + ": subscription: '" + subInfo.Instance.ServiceInstanceId + "' has status of: " + subInfo.SubscriptionStatus + ".  Skipping....");
                    continue;
                }

                // See if the subscription is for an Xbox Live subscription
                try
                {
                    bool authoritative = false;
                    scsOffer = Offer.CreateInstanceFromBillingOfferId(subInfo.OfferingGUID, 0, out authoritative);
                    if (scsOffer.IsBaseOffer)
                    {
                        Xom.Trace(XomAreaName.contentutiltrace, LogLevel.L_NORMAL, "ReconcileBaseServiceInstance: user 0x" + u.Puid.ToString("X") + ": base subscription (id: " + subInfo.SubscriptionId + ", offer id: " + subInfo.OfferingGUID + ") has corresponding Xbox Live offer id: 0x" + scsOffer.OfferId.ToString("X") + " -- will attempt to reconcile...");
                        scsEnabledBaseSubscriptions++;
                        scsBaseInstanceId = subInfo.Instance.ServiceInstanceId;
                        scsBaseXboxOfferId = scsOffer.OfferId;
                        billingOfferId = subInfo.OfferingGUID;
                        tierProvided = scsOffer.TierProvided;
                    }
                    else
                    {
                        Xom.Trace(XomAreaName.contentutiltrace, LogLevel.L_LOW, "ReconcileBaseServiceInstance: user 0x" + u.Puid.ToString("X") + ": skipping non-base subscription (id: " + subInfo.SubscriptionId + ", offer id: " + subInfo.OfferingGUID + ") has corresponding Xbox Live offer id: 0x" + scsOffer.OfferId.ToString("X") + "...");
                    }
                }
                catch (Exception e)
                {
                    string msg = null;
                    if ( e is ExceptionWithHResult && ((ExceptionWithHResult)e).HResult == HResult.XONLINE_E_OFFERING_INVALID_OFFER_ID )
                    {
                        msg = "ReconcileBaseServiceInstance: user " + (Puid) u.Puid + ": subscription (id: " + subInfo.SubscriptionId + ", offer id: " + subInfo.OfferingGUID + ") has no corresponding Xbox Live offer id -- skipping...";
                        Xom.Trace(XomAreaName.contentutiltrace, LogLevel.L_NORMAL, msg);
                    }
                    else
                    {
                        msg = "ReconcileBaseServiceInstance: user " + (Puid) u.Puid + ": subscription (id: " + subInfo.SubscriptionId + ", offer id: " + subInfo.OfferingGUID + ") attempt to load offer resulted in exception";
                        Xom.Trace(XomAreaName.contentutiltrace, LogLevel.L_HIGH, msg + "\r\nException: " + e);
                        Xom.NtEvent( XEvent.Id.COMMON_CODE_15, e, msg );
                    }
                }
            }


            // If there is exactly one enabled Xbox Live base subscription
            // and it has a different instance id than the one in UODB,
            // the reconcile it now.
            if ( scsEnabledBaseSubscriptions == 1 && baseInstanceId != scsBaseInstanceId )
            {
                Xom.Trace(XomAreaName.contentutiltrace, LogLevel.L_LOW, "ReconcileBaseServiceInstance: moving user 0x" + u.Puid.ToString("X") + " from base offer 0x" + baseOfferId.ToString("X") + ", service instance id '" + baseInstanceId + "' to offer 0x" + scsBaseXboxOfferId.ToString("X") + ", service instance id " + scsBaseInstanceId);

                //Respect the npdb switch and start commiting the catalog Guids only if this is turned on.
                BillingOfferInfo billingOfferInfo = null;
                
                Guid? catalogOfferId = null;

                Guid? catalogOfferInstanceId = null;

                if (Config.GetBoolSetting(Setting.billing_useCatalogSubscriptionOffers))
                {
                    billingOfferInfo = BillingOfferInfo.GetInstance(new Guid(billingOfferId));

                    catalogOfferId = billingOfferInfo.OfferId;

                    catalogOfferInstanceId = billingOfferInfo.OfferInstanceId;

                }
                HResult hr = RenewalUtil.MoveSubscriptionWithFamilyCheck
                         (
                           u.Puid,
                           baseOfferId,
                           baseInstanceId,
                           scsBaseXboxOfferId,
                           scsBaseInstanceId,
                           catalogOfferId,
                           catalogOfferInstanceId,
                           DateTime.UtcNow,
                           scsOffer  
                         );

                if ( HResult.Failed(hr) )
                {
                    string msg = "ReconcileBaseServiceInstance: RenewalUtil.MoveSubscription failed with hr = " + hr.ToString();
                    Xom.Trace(XomAreaName.contentutiltrace, LogLevel.L_ERROR, msg);
                    throw new XRLException(hr, XEvent.Id.COMMON_BILLING_CODE_211, msg);
                }
            }

            // One of several bugs could have caused the subscription to not
            // be provisioned.  If we find the current subscription isn't
            // provisioned, go ahead and correct it now.
            if ( fixProvisioningStatus && scsEnabledBaseSubscriptions == 1 && !string.IsNullOrEmpty(scsBaseInstanceId) )
            {
                SubscriptionInfo baseSubInfo = null;
                for (int i = 0; i < siSet.SubscriptionInfoList.Count; i++)
                {
                    SubscriptionInfo subInfo = (SubscriptionInfo) siSet.SubscriptionInfoList[i];
                    if ( subInfo.Instance != null && subInfo.Instance.ServiceInstanceId == scsBaseInstanceId )
                    {
                        baseSubInfo = subInfo;
                        break;
                    }
                }

                Xom.Trace(XomAreaName.contentutiltrace, LogLevel.L_NORMAL, "ReconcileBaseServiceInstance: user 0x" + u.Puid.ToString("X") + " has service instance id '" + scsBaseInstanceId + "' with a provisioning status of: " + baseSubInfo.Instance.ProvisioningStatus);

                //Only provision if the subscription is enabled
                if (baseSubInfo.Instance.ProvisioningStatus == "NOT PROVISIONED" && baseSubInfo.SubscriptionStatus.Equals("ENABLED",StringComparison.InvariantCultureIgnoreCase))
                {
                    Xom.Trace(XomAreaName.contentutiltrace, LogLevel.L_NORMAL, "ReconcileBaseServiceInstance: calling ReprovisionSubscription for user 0x" + u.Puid.ToString("X") + " and service instance id " + baseSubInfo.Instance.ServiceInstanceId);

                    ReprovisionSubscription(u, baseSubInfo);
                }
            }
        }
        public static void ReconcileUserBillingAccountStatusFromCatalog(Puid userPuid)
        {
            bool saveUser = false;

            int tier;

            User user = new User();

            user.Load(userPuid);

            try
            {

                Guid baseCatalogOfferId = Guid.Empty;

                Guid baseCatalogOfferInstanceId = Guid.Empty;

                string baseInstanceId = string.Empty;

                int subscriptionStatusId = 0;

                User.XeGetBaseSubscription(user.Puid, out baseInstanceId, out subscriptionStatusId, out baseCatalogOfferId, out baseCatalogOfferInstanceId,out tier);

                if (string.IsNullOrEmpty(baseInstanceId))
                {
                    // If the user has a valid silver subscription but has a
                    // billing account status is flagged for maintenance, go
                    // ahead and clear it now.
                    if (user.IsXenonAccount && tier == (int)TierEnum.Silver && HResult.Failed(user.BillingAccountStatus) && subscriptionStatusId == Subscription.ENABLED)
                    {
                        Xom.Trace(XomAreaName.contentutiltrace, LogLevel.L_HIGH, "ReconcileUserBillingAccountStatus: user 0x" + user.Puid.ToString("X") + " has a valid silver subscription but is flagged with a BillingAccountStatus value of 0x" + user.BillingAccountStatus.ToString("X") + ".  Resetting to 0 now.");
                        user.BillingAccountStatus = 0;
                        saveUser = true;
                    }

                    // If the user has a base subscription to something other
                    // than the silver offer and has a valid billing account
                    // status but doesn't have an enabled subscription in UODB,
                    // flag the account as requiring management.
                    if (tier != (int)TierEnum.Silver && HResult.Succeeded(user.BillingAccountStatus) && subscriptionStatusId != Subscription.ENABLED)
                    {
                        Xom.Trace(XomAreaName.contentutiltrace, LogLevel.L_HIGH, "ReconcileUserBillingAccountStatus: user 0x" + user.Puid.ToString("X") + " has a non-enabled non-silver subscription but is flagged with a BillingAccountStatus value of 0.  Resetting to 0x80151200 now.");
                        user.BillingAccountStatus = HResult.XONLINE_E_LOGON_USER_ACCOUNT_REQUIRES_MANAGEMENT;
                        saveUser = true;
                    }
                }
                else
                {
                    SubscriptionInfo baseSubInfo = Subscription.GetSubscriptionInfo(user.BillingPuid, baseInstanceId);

                    if (!baseSubInfo.SubscriptionStatus.Equals("ENABLED", StringComparison.InvariantCultureIgnoreCase) && subscriptionStatusId != Subscription.ENABLED)
                    {
                        // If the user's base subscription is not enabled, they need to
                        // be flagged with a billing account status of
                        // XONLINE_E_LOGON_USER_ACCOUNT_REQUIRES_MANAGEMENT.
                        user.BillingAccountStatus = HResult.XONLINE_E_LOGON_USER_ACCOUNT_REQUIRES_MANAGEMENT;

                        // If this is a base subscription and the user is a Xenon user,
                        // flag the user as being downgraded to silver unless the subscription
                        // is SUSPENDED or EXPIRED with violations.
                        if (user.IsXenonAccount)
                        {
                            user.IsDowngraded = baseSubInfo.SubscriptionStatus.Equals("CANCELED", StringComparison.InvariantCultureIgnoreCase) || (baseSubInfo.HasViolations == false);
                        }
                        else
                        {
                            user.IsDowngraded = false;
                        }

                        saveUser = true;
                    }
                    else
                    {
                        // The user has a valid base subscription so ensure that
                        // billing account status and downgraded are both cleared.
                        user.BillingAccountStatus = 0;
                        user.IsDowngraded = false;
                        saveUser = true;
                    }
                }

            }
            finally
            {
                if (saveUser)
                {
                    Xom.Trace(XomAreaName.contentutiltrace, LogLevel.L_HIGH, string.Format("ReconcileUserBillingAccountStatus: user 0x{0}: changing BillingAccountStatus to 0x{1} and IsDowngraded to {2}.", user.Puid.ToString("x"), user.BillingAccountStatus.ToString("x"), user.IsDowngraded.ToString()));

                    user.Save();
                }
            }


        }

        public static void ReconcileUserBillingAccountStatus(User u)
        {
            const ulong silverOfferId = 0xfffe07d180000011;
            bool saveUser = false;

            try
            {

                ulong baseOfferId = 0;
                string baseInstanceId = "";
                int subscriptionStatusId = 0;
                Puid subscriptionOwnerPuid=0;
                ulong billingPuid = u.BillingPuid;
                Puid userOwnerPuid = u.GetOwnerPuid();

                //We want to make sure that we handle all the family scenarios before we call CTP.
                //This is not strictly a reconciliation logic but is logic to correct any users in bad state.
                bool familyUserhandled = HandleFamilyUsersInReconcile(u, out baseInstanceId, out subscriptionStatusId, out subscriptionOwnerPuid,out baseOfferId);

                //If the reconcile call was for a family dependent user/primary with a wrong family record and we handled the scenarios then return now and dont call CTP
                if (familyUserhandled)
                {
                    return;
                }

                //if user is a dependent and has the right ownerPuid and also has an active base subscription then we need to call CTP with parent's billing Puid
                if 
                    (
                        u.IsFamilySecondary
                     && userOwnerPuid == subscriptionOwnerPuid 
                     && subscriptionStatusId==(int)SubscriptionStatus.Enabled )
                {
                    User parentUser = new User();
                    parentUser.Load(userOwnerPuid);

                    billingPuid = parentUser.BillingPuid;

                }
                // If the base offer id comes back as 0, the stored procedure was
                // most likely executed against the read partition before the
                // subscription purchase was replicated.  Bail out now rather than
                // disable the user's account for no good reason.
                if ( baseInstanceId == null && baseOfferId == 0 )
                {
                    Xom.Trace(XomAreaName.contentutiltrace, LogLevel.L_HIGH, "ReconcileUserBillingAccountStatus: user 0x" + u.Puid.ToString("X") + " has base offer id of 0.  This is indicative of a UODB issue.  No attempt to reconcile billing account status will be made.");
                    return;
                }

                Xom.Trace(XomAreaName.contentutiltrace, LogLevel.L_NORMAL, "ReconcileUserBillingAccountStatus: in UODB, user 0x" + u.Puid.ToString("X") + " has base offer id 0x" + baseOfferId.ToString("X") + " and service instance id '" + baseInstanceId + "' with a subscription status of " + subscriptionStatusId);

                if ( string.IsNullOrEmpty(baseInstanceId) )
                {
                    Debug.Assert( baseOfferId == silverOfferId );
                    Debug.Assert( u.IsXenonAccount );
                    Debug.Assert( u.Tier == (int) TierEnum.Silver );

                    // If the user has a valid silver subscription but has a
                    // billing account status is flagged for maintenance, go
                    // ahead and clear it now.
                    if ( u.IsXenonAccount && baseOfferId == silverOfferId && HResult.Failed(u.BillingAccountStatus) && subscriptionStatusId == Subscription.ENABLED )
                    {
                        Xom.Trace(XomAreaName.contentutiltrace, LogLevel.L_HIGH, "ReconcileUserBillingAccountStatus: user 0x" + u.Puid.ToString("X") + " has a valid silver subscription but is flagged with a BillingAccountStatus value of 0x" + u.BillingAccountStatus.ToString("X") + ".  Resetting to 0 now.");
                        u.BillingAccountStatus = 0;
                        saveUser = true;
                    }

                    // If the user has a base subscription to something other
                    // than the silver offer and has a valid billing account
                    // flag the account as requiring management.
                    //if user got a gold/family subscription because of a time out(and we succeeded at CTP then ReconcileBaseServiceInstanceandstatus should have updated the serviceInstanceId
                    //if we are at this stage and we still have base Instance empty , then we can be certain that this user has no purchase record in CTP and hence must be downgraded so that he can go back to silve
                    if (baseOfferId != silverOfferId && HResult.Succeeded(u.BillingAccountStatus))
                    {
                        Xom.Trace(XomAreaName.contentutiltrace, LogLevel.L_HIGH, "ReconcileUserBillingAccountStatus: user 0x" + u.Puid.ToString("X") + " has a non-enabled non-silver subscription but is flagged with a BillingAccountStatus value of 0.  Resetting to 0x80151200 now.");
                        u.BillingAccountStatus = HResult.XONLINE_E_LOGON_USER_ACCOUNT_REQUIRES_MANAGEMENT;
                        u.IsDowngraded = true;
                        saveUser = true;
                    }
                }
                else
                {
                    SubscriptionInfo baseSubInfo = Subscription.GetSubscriptionInfo(billingPuid, baseInstanceId);

                    if ( !baseSubInfo.SubscriptionStatus.Equals("ENABLED", StringComparison.InvariantCultureIgnoreCase) && subscriptionStatusId != Subscription.ENABLED )
                    {
                        // If the user's base subscription is not enabled, they need to
                        // be flagged with a billing account status of
                        // XONLINE_E_LOGON_USER_ACCOUNT_REQUIRES_MANAGEMENT.
                        u.BillingAccountStatus = HResult.XONLINE_E_LOGON_USER_ACCOUNT_REQUIRES_MANAGEMENT;

                        // If this is a base subscription and the user is a Xenon user,
                        // flag the user as being downgraded to silver unless the subscription
                        // is SUSPENDED or EXPIRED with violations.
                        if ( u.IsXenonAccount )
                        {
                            u.IsDowngraded = baseSubInfo.SubscriptionStatus.Equals("CANCELED", StringComparison.InvariantCultureIgnoreCase) || (baseSubInfo.HasViolations == false);
                        }
                        else
                        {
                            u.IsDowngraded = false;
                        }

                        saveUser = true;
                    }
                    else
                    {
                        // The user has a valid base subscription so ensure that
                        // billing account status and downgraded are both cleared.
                        u.BillingAccountStatus = 0;
                        u.IsDowngraded = false;
                        saveUser = true;
                    }
                }
            }
            finally
            {
                if ( saveUser )
                {
                    Xom.Trace(XomAreaName.contentutiltrace, LogLevel.L_HIGH, string.Format("ReconcileUserBillingAccountStatus: user 0x{0}: changing BillingAccountStatus to 0x{1} and IsDowngraded to {2}.", u.Puid.ToString("x"), u.BillingAccountStatus.ToString("x"), u.IsDowngraded.ToString()));

                    SaveUserWithFamilyCheck(u);
                }
            }
        }

        public static void DeprovisionSubscription(User u, SubscriptionInfo subInfo, ulong userPuid, string details)
        {
            uint userPuidHigh;
            uint userPuidLow;
            Int64Convert.ToUintPair((long)userPuid, out userPuidHigh, out userPuidLow);

            uint billingPuidHigh;
            uint billingPuidLow;
            Int64Convert.ToUintPair((long)u.BillingPuid, out billingPuidHigh, out billingPuidLow);

            string pmn = u.BillingPMN;

            Xom.Trace(XomAreaName.contentutiltrace, LogLevel.L_LOW, "DeprovisionSubscription: deprovisioning user 0x" + userPuid.ToString("X") + " for service instance id " + subInfo.Instance.ServiceInstanceId + ", service component id " + subInfo.Instance.ServiceComponentId );

            ServiceInstance serviceInstanceSet = new ServiceInstance();
            serviceInstanceSet.FromXml(subInfo.Instance.ToXml("ServiceInstanceSet"), "ServiceInstanceSet");

            serviceInstanceSet.PuidHigh = (int) userPuidHigh;
            serviceInstanceSet.PuidLow = (int) userPuidLow;
            serviceInstanceSet.PMN = pmn;
            serviceInstanceSet.Role = "User";
            if ( !string.IsNullOrEmpty(details) )
            {
                serviceInstanceSet.Details = details;
            }
            serviceInstanceSet.ServiceInstanceStatus = InstanceStatusEnum.Enabled;
            serviceInstanceSet.InstanceFriendlyName = pmn;

            BillingProvider bp = new BillingProvider();

            string errorXml;

            bp.DeprovisionServices(
                0, 0,
                (int) billingPuidHigh,
                (int) billingPuidLow,
                serviceInstanceSet.ToXml("ServiceInstanceSet"),
                out errorXml);
        }

        public static void ReprovisionSubscription(User u, SubscriptionInfo subInfo)
        {
            uint userPuidHigh;
            uint userPuidLow;
            Int64Convert.ToUintPair((long)u.Puid, out userPuidHigh, out userPuidLow);

            uint billingPuidHigh;
            uint billingPuidLow;
            Int64Convert.ToUintPair((long)u.BillingPuid, out billingPuidHigh, out billingPuidLow);

            string pmn = u.BillingPMN;

            Xom.Trace(XomAreaName.contentutiltrace, LogLevel.L_LOW, "ReprovisionSubscription: provisioning user 0x" + u.Puid.ToString("X") + " for service instance id " + subInfo.Instance.ServiceInstanceId + ", service component id " + subInfo.Instance.ServiceComponentId );

            ServiceInstance serviceInstanceSet = new ServiceInstance();
            serviceInstanceSet.FromXml(subInfo.Instance.ToXml("ServiceInstanceSet"), "ServiceInstanceSet");

            serviceInstanceSet.PuidHigh = (int) userPuidHigh;
            serviceInstanceSet.PuidLow = (int) userPuidLow;
            serviceInstanceSet.PMN = pmn;
            serviceInstanceSet.Role = "User";
            serviceInstanceSet.Details = "&lt;AlreadyProvisioned&gt;1&lt;/AlreadyProvisioned&gt;";
            serviceInstanceSet.ServiceInstanceStatus = InstanceStatusEnum.Enabled;
            serviceInstanceSet.InstanceFriendlyName = pmn;

            BillingProvider bp = new BillingProvider();

            string errorXml;

            bp.ProvisionServices(
                0, 0,
                (int) billingPuidHigh,
                (int) billingPuidLow,
                serviceInstanceSet.ToXml("ServiceInstanceSet"),
                out errorXml);
        }

        public static XeGetUserSubscriptionDetailsResponse GetUserSubscriptionDetails(XeGetUserSubscriptionDetailsRequest request)
        {
            XeGetUserSubscriptionDetailsResponse response = new XeGetUserSubscriptionDetailsResponse();

            HResult hr = HResult.S_OK;

            User u = null;

            string instanceId = request.instanceId;

            int paymentTypeMask = (int)( PaymentTypeEnum.CreditCard | PaymentTypeEnum.Token | PaymentTypeEnum.Wholesale);

            u = new User();
            u.Load(request.userPuid);

            int cultureID = Culture.GetCultureFromLanguageCountry((ushort)u.LanguageId, u.CountryId);

            //
            // If necessary, grab the instanceId from uodb
            //
            if ( string.IsNullOrEmpty(instanceId) )
            {
                hr = User.GetSubscriptionFromOffer(request.userPuid, request.offerId, out instanceId);
                if (HResult.Failed(hr))
                {
                    string msg = "User.GetSubscriptionFromOffer: user: 0x" + request.userPuid.ToString("x") + ", offerId: 0x" + request.offerId.ToString("x") + " failed with hr = " + hr;
                    throw new XRLException(hr, XEvent.Id.COMMON_BILLING_CODE_212, msg);
                }
            }

            //
            // Grab pertinent offer details
            //
            SubscriptionDetailsRequest reqSubscription = new SubscriptionDetailsRequest();

            Offer currentOffer = Offer.CreateInstance(request.offerId);

            UserSubscriptionDetailsData currentOfferDetails = new UserSubscriptionDetailsData();
            UserSubscriptionDetailsData renewalOfferDetails = new UserSubscriptionDetailsData();

            // subscription prices won't vary by tier
            currentOfferDetails.wholePart = (uint)currentOffer.WholePriceNoTier(u.CountryId, paymentTypeMask);
            currentOfferDetails.fractionalPart = (byte) currentOffer.FractionalPriceNoTier(u.CountryId, paymentTypeMask);
            currentOfferDetails.offeringDetails = Details.BuildDetailsFlagsNoTier(currentOffer, u.CountryId, paymentTypeMask);
            Details.FormatCurrencyData(u.CountryId, (uint)u.LanguageId, out currentOfferDetails.currencyFormat, out currentOfferDetails.isoCode);
            currentOfferDetails.formattedPrice = Details.BuildFormattedPrice(u.CountryId, (uint) u.LanguageId, currentOfferDetails.wholePart, currentOfferDetails.fractionalPart);

            response.currentOfferDetails = currentOfferDetails;

            response.paymentInstrument = new PaymentInstrumentInfoEx();

            response.paymentInstrument.paymentInstrumentId = string.Empty;
            response.paymentInstrument.paymentInstrumentType = (byte)PaymentInstrumentTypeEnum.None;
            response.paymentInstrument.addressInfo = new AddressInfoData();
            response.paymentInstrument.phoneInfo = new PhoneInfoData();
            response.paymentInstrument.creditCardInfo = new CreditCardInfoData();
            response.paymentInstrument.directDebitInfo = new DirectDebitInfoData();
            response.paymentInstrument.wholesaleInfo = new WholesaleInfoData();
            response.paymentInstrument.paypalPayinInfo = new PayPalPayinInfoData();

            if (!BillingProvider.IsDummyId(u.AccountId))
            {
                if (BillingConfig.ConnectToBilling == false)
                {
                    hr = HResult.XONLINE_E_BILLING_NOT_CONNECTED;

                    throw new XRLException(
                        hr,
                        XEvent.Id.COMMON_CONFIG_67,
                        "Couldn't load information for user puid 0x" + request.userPuid.ToString("x") + " because ConnectToBilling=false!");
                }

                //
                // Grab pertinent information from the billing system
                //
                if ( !string.IsNullOrEmpty(instanceId) )
                {
                    // If the subscription has a dummy instance, it usually means
                    // the call to PurchaseOfferingEx timed out.  Perform a
                    // reconciliation and only fail with an error if the id is still
                    // a dummy instance.
                    if ( BillingProvider.IsDummyId(instanceId) )
                    {
                        Xom.Trace(XomAreaName.contentutiltrace, LogLevel.L_LOW, "GetUserSubscriptionDetails: user: 0x" + request.userPuid.ToString("x") + ": dummy instance id: " + instanceId + " -- attempting to reconcile." );

                        ReconcileSubscriptions(request.userPuid);

                        // reread the instance id from UODB in hopes that the
                        // ReconcileSubscriptions corrected it
                        User.GetSubscriptionFromOffer(request.userPuid, request.offerId, out instanceId);

                        // if it is still not a valid instance, fail now
                        if ( string.IsNullOrEmpty(instanceId) || BillingProvider.IsDummyId(instanceId) )
                        {
                            throw new XRLException( HResult.XONLINE_E_ACCOUNTS_TRY_AGAIN_LATER, XEvent.Id.COMMON_BILLING_CODE_0, "GetUserSubscriptionDetails: user: 0x" + request.userPuid.ToString("x") + " has a dummy instance id: " + instanceId );
                        }
                        else
                        {
                            Xom.Trace(XomAreaName.contentutiltrace, LogLevel.L_HIGH, "GetUserSubscriptionDetails: calling ReconcileSubscriptions fixed instance id: " + instanceId );
                        }

                    }

                    Debug.Assert( !string.IsNullOrEmpty(instanceId) );
                    Debug.Assert( !BillingProvider.IsDummyId(instanceId) );

                    SubscriptionInfo subInfo = Subscription.GetSubscriptionInfo(u.BillingPuid, instanceId);

                    response.subscriptionId = subInfo.SubscriptionId;
                    response.description = subInfo.SubscriptionDescription;
                    if ( response.description.Length > XeGetUserSubscriptionDetailsResponse.maxDescriptionLength )
                    {
                        response.description = response.description.Substring(0, XeGetUserSubscriptionDetailsResponse.maxDescriptionLength);
                    }

                    response.currentOfferStatus = (byte) subInfo.SubscriptionStatusNumeric;
                    response.delayedCancel = subInfo.DelayedCancel;

                    response.friendlyName = subInfo.FriendlyName;
                    if ( response.friendlyName.Length > XeGetUserSubscriptionDetailsResponse.maxFriendlyNameLength )
                    {
                        response.friendlyName = response.friendlyName.Substring(0, XeGetUserSubscriptionDetailsResponse.maxFriendlyNameLength);
                    }
                    response.anniversaryDate = (byte) subInfo.AnniversaryDate;
                    response.purchaseDate = subInfo.PurchaseDate;
                    response.activationDate = subInfo.ActivationDate;
                    response.endDate = subInfo.EndDate;
                    response.hasViolations = (byte)(subInfo.HasViolations ? 1 : 0);

                    response.renewalGracePeriod = (uint) subInfo.RenewalGracePeriod;

                    // If there's a renewal offer present, get details for it
                    // as well
                    if ( !string.IsNullOrEmpty(subInfo.RenewOfferingId) )
                    {
                        bool authoritative = false;

                        ulong renewalXoid = Offer.OfferIdFromBillingOfferId(subInfo.RenewOfferingId, request.offerId, out authoritative);

                        Offer renewalOffer = Offer.CreateInstance(renewalXoid);

                        response.renewalOfferId = renewalXoid;

                        renewalOfferDetails.wholePart = (uint)renewalOffer.WholePriceNoTier(u.CountryId, paymentTypeMask);
                        renewalOfferDetails.fractionalPart = (byte) renewalOffer.FractionalPriceNoTier(u.CountryId, paymentTypeMask);
                        renewalOfferDetails.offeringDetails = Details.BuildDetailsFlagsNoTier(renewalOffer, u.CountryId, paymentTypeMask);
                        Details.FormatCurrencyData(u.CountryId, (uint)u.LanguageId, out renewalOfferDetails.currencyFormat, out renewalOfferDetails.isoCode);
                        renewalOfferDetails.formattedPrice = Details.BuildFormattedPrice(u.CountryId, (uint) u.LanguageId, renewalOfferDetails.wholePart, renewalOfferDetails.fractionalPart);
                    }

                    //
                    // Grab pertinent information from the payment information
                    //
                    Account acct = new Account();
                    if ( !string.IsNullOrEmpty(subInfo.PaymentInstrumentId) )
                    {
                        acct.GetPayInfo(u.BillingPuid, subInfo.PaymentInstrumentId);
                        response.paymentInstrument = acct.PayInfo.ToWireData();
                    }
                    else
                    {
                        PaymentInstrumentInfoEx pi = new PaymentInstrumentInfoEx();
                        pi.paymentInstrumentType = (byte)PaymentInstrumentTypeEnum.None;
                        pi.addressInfo = new AddressInfoData();
                        pi.phoneInfo = new PhoneInfoData();
                        pi.creditCardInfo = new CreditCardInfoData();
                        pi.directDebitInfo = new DirectDebitInfoData();
                        pi.wholesaleInfo = new WholesaleInfoData();
                        pi.paypalPayinInfo = new PayPalPayinInfoData();

                        response.paymentInstrument = pi;
                    }
                }
            }

            response.renewalOfferDetails = renewalOfferDetails;

            return response;
        }
        /// <summary>
        /// Changes the state of subscription with  a check for Family
        /// If primary has family members then the change also applies to all the gold dependents
        /// </summary>
        public static void ChangeSubscriptionStateWithFamilyCheck(ulong userPuid, string serviceComponentId, string instanceId, uint newSubscriptionStatus, uint bitMask, uint bitFlags,Offer scsOffer)
        { 
            User user = new User();
            user.Load(userPuid);

            HResult hr = HResult.S_OK;

            //check to make sure user is familygold,offer is a base offer and offer provided family gold
            //if yes then we want to apply changes to family as well.
            if (
                   user.Tier == (int)TierEnum.FamilyGold
                && scsOffer.IsBaseOffer
                && scsOffer.TierProvided == (int)TierEnum.FamilyGold
                )
            {
                ChangeFamilySubscriptionState
                    (
                          userPuid
                        , serviceComponentId
                        , instanceId
                        , newSubscriptionStatus
                        , bitMask
                        , bitFlags
                    );
            }
            else
            {
                ChangeSubscriptionState
                    (
                          userPuid
                        , serviceComponentId
                        , instanceId
                        , newSubscriptionStatus
                        , bitMask
                        , bitFlags
                    );
            }
        }

       
        /// <summary>
        /// Change the subscription state 
        /// </summary>
        public static void ChangeFamilySubscriptionState(ulong userPuid, string serviceComponentId, string instanceId, uint newSubscriptionStatus, uint bitMask, uint bitFlags)
        { 
            HResult hresult = HResult.S_OK;

            User user = new User();
            user.Load(userPuid);

            //Get the family members
            FamilyMember[] familyMembers = null;
            user.GetFamilyMembers(out familyMembers);

            using (TransactionScope tx = new TransactionScope())
            {
                //change the state of the dependent only if the scs offer is a family gold offer
                foreach (FamilyMember item in familyMembers)
                {
                    if
                       (
                           (item.userFlags & FamilyDefs.FAMILY_OWNER) == FamilyDefs.FAMILY_OWNER
                       ||  (item.userFlags & FamilyDefs.FAMILY_SUBSCRIPTION_GOLD) == FamilyDefs.FAMILY_SUBSCRIPTION_GOLD
                       )
                    {
                        ChangeSubscriptionState
                            (
                                  item.userPuid
                                , serviceComponentId
                                , instanceId
                                , newSubscriptionStatus
                                , bitMask
                                , bitFlags
                            );
                    }
                }
                tx.Complete();
            }
        }
        public static void ChangeSubscriptionState(ulong userPuid, string serviceComponentId, string instanceId, uint newSubscriptionStatus, uint bitMask, uint bitFlags)
        {
            using (WSClient ws = new WSClient(ConfigUtil.UodbWebstoreApp, CmdType.WRITEONLY_COMMANDTYPE))
            {
                ws.SetHashVal(userPuid);
                ws.StoredProc = "dbo.p_xcbk_change_state";

                Xom.Trace(XomAreaName.contentutiltrace, LogLevel.L_LOW, "ChangeSubscriptionState: calling p_xcbk_change_state for user: 0x" + userPuid.ToString("X") + ", instanceId: " + instanceId + ", newSubscriptionStatus: " + newSubscriptionStatus.ToString() + ", bitMask: 0x" + bitMask.ToString("X") + ", bitFlags: 0x" + bitFlags.ToString("X"));

                // intput and output params
                ws.AddParameter(ParamType.RETVAL, "@RETVAL", 0);
                ws.AddParameter(ParamType.INPUT, "@userpuid", userPuid);
                ws.AddParameter(ParamType.INPUT, "@componentid", serviceComponentId, 36);
                ws.AddParameter(ParamType.INPUT, "@instanceid", instanceId, 16);
                ws.AddParameter(ParamType.INPUT, "@newstate", newSubscriptionStatus);
                ws.AddParameter(ParamType.INPUT, "@bitmask", bitMask);
                ws.AddParameter(ParamType.INPUT, "@bitflags", bitFlags);

                // call the procedure
                ws.ExecuteNonQuery();

                HResult hr = (uint)ws.GetIntParameter("@RETVAL");

                if (HResult.Failed(hr))
                {
                    throw new XRLException(hr, XEvent.Id.COMMON_BILLING_CODE_213, "ChangeSubscriptionState: p_xcbk_change_state failed (hr = " + hr + ") for user: 0x" + userPuid.ToString("X") + ", instanceId: " + instanceId + ", newSubscriptionStatus: " + newSubscriptionStatus.ToString() + ", bitMask: 0x" + bitMask.ToString("X") + ", bitFlags: 0x" + bitFlags.ToString("X"));
                }
            }
        }

        /// <summary>
        /// Change the billing account state of the user.
        /// </summary>
         public static void ChangeBillingAccountState(ulong userPuid, int newSubscriptionStatus)
        {
            using (WSClient ws = new WSClient(ConfigUtil.UodbWebstoreApp, CmdType.WRITEONLY_COMMANDTYPE))
            {
                ws.SetHashVal(userPuid);
                ws.StoredProc = "dbo.p_xcbk_change_billing_account_state";

                Xom.Trace(XomAreaName.ctpTransactionServiceTrace, LogLevel.L_LOW, "ChangeSubscriptionState: calling p_xcbk_change_billing_account_state for user: 0x" + userPuid.ToString("X") + ", newSubscriptionStatus: " + newSubscriptionStatus.ToString());

                // intput and output params
                ws.AddParameter(ParamType.RETVAL, "@RETVAL", 0);
                ws.AddParameter(ParamType.INPUT, "@userpuid", userPuid);
                ws.AddParameter(ParamType.INPUT, "@newstate", newSubscriptionStatus);

                // call the procedure
                ws.ExecuteNonQuery();

                HResult hr = (uint)ws.GetIntParameter("@RETVAL");

                if (HResult.Failed(hr))
                {
                    throw new XRLException(hr, XEvent.Id.COMMON_BILLING_CODE_CHANGE_BILLING_STATE, "ChangeSubscriptionState: p_xcbk_change_billing_account_state failed (hr = " + hr + ") for user: 0x" + userPuid.ToString("X") +", newSubscriptionStatus: " + newSubscriptionStatus.ToString());
                }
            }
        }

        /// <summary>
        /// Change the subscription state of the user 
        /// </summary>
        public static void ChangeSubscriptionState(ulong userPuid, string instanceId, int newSubscriptionStatus, uint bitMask, uint bitFlags)
        {
            using (WSClient ws = new WSClient(ConfigUtil.UodbWebstoreApp, CmdType.WRITEONLY_COMMANDTYPE))
            {
                ws.SetHashVal(userPuid);
                ws.StoredProc = "dbo.p_xcbk_change_state_v2";

                Xom.Trace(XomAreaName.ctpTransactionServiceTrace, LogLevel.L_LOW, "ChangeSubscriptionState: calling p_xcbk_change_state_v2 for user: 0x" + userPuid.ToString("X") + ", instanceId: " + instanceId + ", newSubscriptionStatus: " + newSubscriptionStatus.ToString() + ", bitMask: 0x" + bitMask.ToString("X") + ", bitFlags: 0x" + bitFlags.ToString("X"));

                // intput and output params
                ws.AddParameter(ParamType.RETVAL, "@RETVAL", 0);
                ws.AddParameter(ParamType.INPUT, "@userpuid", userPuid);
                ws.AddParameter(ParamType.INPUT, "@instanceid", instanceId, 16);
                ws.AddParameter(ParamType.INPUT, "@newstate", newSubscriptionStatus);
                ws.AddParameter(ParamType.INPUT, "@bitmask", bitMask);
                ws.AddParameter(ParamType.INPUT, "@bitflags", bitFlags);

                // call the procedure
                ws.ExecuteNonQuery();

                HResult hr = (uint)ws.GetIntParameter("@RETVAL");

                if (HResult.Failed(hr))
                {
                    throw new XRLException(hr, XEvent.Id.COMMON_BILLING_CODE_CHANGE_STATE, "ChangeSubscriptionState: p_xcbk_change_state_v2 failed (hr = " + hr + ") for user: 0x" + userPuid.ToString("X") + ", instanceId: " + instanceId + ", newSubscriptionStatus: " + newSubscriptionStatus.ToString() + ", bitMask: 0x" + bitMask.ToString("X") + ", bitFlags: 0x" + bitFlags.ToString("X"));
                }
            }
        }


        public static void ChangeDependentSubscriptionState(ulong userPuid, string instanceId, uint newSubscriptionStatus, uint bitMask, uint bitFlags, ulong? ownerPuid)
        {
            using (WSClient ws = new WSClient(ConfigUtil.UodbWebstoreApp, CmdType.WRITEONLY_COMMANDTYPE))
            {
                ws.SetHashVal(userPuid);
                ws.StoredProc = "dbo.p_xcbk_change_dependent_state";

                Xom.Trace(
                    XomAreaName.ctpTransactionServiceTrace
                    , LogLevel.L_LOW
                    , "ChangeSubscriptionState: calling p_xcbk_change_state for user: {0} + , instanceId: {1} , newSubscriptionStatus: {2} + , bitMask: 0x{3} + ,bitFlags: 0x{4}"
                    , userPuid
                    , instanceId
                    , newSubscriptionStatus.ToString()
                    , bitMask.ToString("X")
                    , bitFlags.ToString("X")
                    );

                // intput and output params
                ws.AddParameter(ParamType.RETVAL, "@RETVAL", 0);
                ws.AddParameter(ParamType.INPUT, "@userpuid", userPuid);

                ws.AddParameter(ParamType.INPUT, "@instanceid", instanceId, 16);
                ws.AddParameter(ParamType.INPUT, "@newstate", newSubscriptionStatus);
                ws.AddParameter(ParamType.INPUT, "@bitmask", bitMask);
                ws.AddParameter(ParamType.INPUT, "@bitflags", bitFlags);

                if (ownerPuid.HasValue)
                {
                    ws.AddParameter(ParamType.INPUT, "@ownerPuid", ownerPuid.Value);
                }
                // call the procedure
                ws.ExecuteNonQuery();

                HResult hr = (uint)ws.GetIntParameter("@RETVAL");

                if (HResult.Failed(hr))
                {
                    throw new XRLException(hr, XEvent.Id.COMMON_BILLING_CODE_213, "ChangeSubscriptionState: p_xcbk_change_dependent_state failed (hr = " + hr + ") for user: 0x" + userPuid.ToString("X") + ", instanceId: " + instanceId + ", newSubscriptionStatus: " + newSubscriptionStatus.ToString() + ", bitMask: 0x" + bitMask.ToString("X") + ", bitFlags: 0x" + bitFlags.ToString("X") + ", ownerPuid: " + (ownerPuid.HasValue ? ownerPuid.Value.ToString("X") : string.Empty));
                }
            }
        }

        public static void FlagSubscriptionAsPendingMove(ulong userId, ulong offerId, string instanceId)
        {
            // This set will flag the subscription as 0x8, pending move, preserving all other flags.
            uint bitMask = 0xFFFFFFFF;
            uint bitFlags = 0x8;

            using (WSClient ws = new WSClient(ConfigUtil.UodbWebstoreApp, CmdType.WRITEONLY_COMMANDTYPE))
            {
                ws.SetHashVal(userId);
                ws.StoredProc = "dbo.p_xcbk_change_state";

                Xom.Trace(XomAreaName.contentutiltrace, LogLevel.L_LOW, "calling p_xcbk_change_state for " + userId
                          + "'s svc instance " + instanceId + " to Pending Move" );

                // intput and output params
                ws.AddParameter(ParamType.RETVAL, "@RETVAL", 0);
                ws.AddParameter(ParamType.INPUT, "@userpuid", userId);
                ws.AddParameter(ParamType.INPUT, "@componentid", String.Empty, 36);     // no service component ID
                ws.AddParameter(ParamType.INPUT, "@instanceid", instanceId, 16);
                ws.AddParameter(ParamType.INPUT, "@newstate", -1);                      // -1 == don't change subscription status
                ws.AddParameter(ParamType.INPUT, "@bitmask", bitMask);
                ws.AddParameter(ParamType.INPUT, "@bitflags", bitFlags);

                // call the procedure
                ws.ExecuteNonQuery();

                HResult hr = (uint)ws.GetIntParameter("@RETVAL");

                if (HResult.Failed(hr))
                {
                    throw new Exception("Failed flagging as Pending Move on user " + userId + " offerId " + offerId
                                        + " instanceId " + instanceId + " (hr = " + hr + ")");
                }
            }
        }

        public static void ClearSubscriptionNotifications(ulong userPuid, uint titleId, string instanceId)
        {
            using (WSClient ws = new WSClient(ConfigUtil.UodbWebstoreApp, CmdType.WRITEONLY_COMMANDTYPE))
            {
                ws.SetHashVal(userPuid);
                ws.StoredProc = "dbo.p_xuacs_user_subscription_notifications_disable";

                Xom.Trace(XomAreaName.contentutiltrace, LogLevel.L_LOW, string.Format("ClearSubscriptionNotification: calling p_xuacs_user_subscription_notifications_disable for user: 0x{0}, titleId: 0x{1}, instanceId: {2}", userPuid.ToString("x"), titleId.ToString("x"), instanceId));

                // intput and output params
                ws.AddParameter(ParamType.RETVAL, "@hr", 0);
                ws.AddParameter(ParamType.INPUT, "@bi_user_puid", userPuid);
                ws.AddParameter(ParamType.INPUT, "@i_title_id", titleId);
                ws.AddParameter(ParamType.INPUT, "@vc_instance_id", instanceId, 16);

                // call the procedure
                ws.ExecuteNonQuery();

                HResult hr = (uint)ws.GetIntParameter("@hr");

                if (HResult.Failed(hr))
                {
                    throw new Exception(string.Format("Failed (hr={0}) disabling notifications for user: 0x{1}, titleId: 0x{2}, instanceId: {3}", hr, userPuid, titleId, instanceId));
                }
            }
        }

        public static void RollbackCancel(ulong userPuid, string instanceId)
        {
            RollbackCancel(userPuid, 0, instanceId);
        }
        
        public static void RollbackCancel(ulong userPuid, ulong offerId, string instanceId)
        {
            HResult hr;
            using (WSClient ws = new WSClient(ConfigUtil.UodbWebstoreApp, CmdType.WRITEONLY_COMMANDTYPE))
            {
                ws.ClearParameters();
                ws.SetHashVal(userPuid);
                ws.StoredProc = "dbo.p_xbos_rollback_cancel";


                // intput and output params
                ws.AddParameter(ParamType.RETVAL, "@RETVAL", 0);
                ws.AddParameter(ParamType.INPUT, "@userpuid", userPuid);
                ws.AddParameter(ParamType.INPUT, "@instanceid", instanceId, 16);

                // call the procedure
                ws.ExecuteNonQuery();

                // the SP should return zero on OK, nonzero on failure
                hr = (uint)ws.GetIntParameter("@RETVAL");
            }

            if ( hr != HResult.S_OK )
            {
                throw new XRLException(
                    hr, XEvent.Id.COMMON_BILLING_CODE_214,         // pass through the hresult from the SP
                    "XeSubscriptionUtil.RollbackCancel failure: " + hr + " for user 0x" + userPuid.ToString("x")
                    + ", offer 0x" + offerId.ToString("x")
                    + ", instance id " + instanceId
                );
            }
        }

        public static void ChangeSubscriptionPaymentInstrument(
            User             u,
            SubscriptionInfo subscriptionInfo,
            string           paymentInstrumentId
        ) {

            Subscription.UpdatePaymentInstrumentInfo(
                u.BillingPuid,
                subscriptionInfo.FriendlyName,
                subscriptionInfo.ShippingAddressId,
                Guid.NewGuid().ToString(),
                subscriptionInfo.SubscriptionId,
                subscriptionInfo.PaymentInstrumentId,
                paymentInstrumentId
            );

            // If the user's subscription status is EXPIRED with violations
            // then ReinstateSubscription should be called after the
            // payment instrument has changed so that the outstanding
            // balance can be charged to the new payment instrument.
            //
            // Update: even if the user's subscription has no
            // violations, ReinstateSubscription will be called so
            // that it will be re-provisioned by SCS and reenabled in
            // UODB.

            if (subscriptionInfo.IsExpired /* && subInfo.HasViolations */ )
            {
                Subscription.ReinstateSubscription(u.BillingPuid, subscriptionInfo.SubscriptionId);
            }
        }


        public static ulong[] GetActiveFromUODB(ulong userPuid)
        {
            HResult hr;
            var activeOfferIds = new System.Collections.Generic.List<ulong>();

            using (WSClient ws = new WSClient(ConfigUtil.UodbWebstoreApp, CmdType.WRITETHENREAD_COMMANDTYPE))
            {
                ws.PartitionType = WstPartitionType.Logical;
                ws.SetHashVal(userPuid);
                ws.StoredProc = "dbo.p_xbos_subscription_get_active";

                ws.AddParameter(ParamType.RETVAL, "@RETVAL", 0);
                ws.AddParameter(ParamType.INPUT, "@bi_user_puid", userPuid);

                try
                {
                    //read through all of the OfferId's returned from the UODB Subscription table
                    using (WstDataReader reader = ws.Execute())
                    {
                        //Add all the results to our list - we'll get an array of total results right before we return
                        while (reader.Read())
                        {
                            activeOfferIds.Add((ulong)reader.GetInt64(reader.GetOrdinal("bi_offer_id")));
                        }

                        // the SP should return zero on OK, nonzero on failure
                        hr = (uint)ws.GetIntParameter("@RETVAL");

                        if (hr != HResult.S_OK)
                        {
                            throw new XRLExceptionWithoutEvent(hr, // pass through the hresult from the SP
                                String.Format("Received an error HResult of {0} retrieving the active subscriptions from UODB for userPuid {1} from the dbo.p_xbos_subscription_get_active", hr, userPuid));
                        }

                    }

                }
                catch (Exception ex)
                {
                    //rethrow the exception if it's already an XRL type of exception
                    if (ex is XRLException || ex is XRLExceptionWithoutEvent)
                        throw;

                    //We've received an error from looking up the subscription information in UPDB,
                    // so add context to the error while rethrowing
                    throw new XRLException(HResult.E_UNEXPECTED, XEvent.Id.UODB_ACCESS_ERROR,
                        String.Format("Encountered an unexpected error retrieving the active subscriptions for userPuid {0} from UODB. Please see the inner exception for more information.", userPuid), ex);
                }

            }

            return activeOfferIds.ToArray();
        }
        /// <summary>
        /// Adds dependent to family subscription
        /// </summary>
        public static void AddDependentToSubscription(Puid ownerPuid, User dependentUser)
        {

            UserSubscriptionInfo primaryFamilySubscriptionInfo = GetFamilySubscriptionInfo(ownerPuid);

            string dependentInstanceId = string.Empty;

            int dependentSubscriptionStatusId = 0;

            Guid dependentCatalogOfferId = Guid.Empty;

            Guid dependentCatalogOfferInstanceId = Guid.Empty;

            int dependentTier = 0;

            Puid dependentPuid = dependentUser.Puid;

            //Get dependent's base subscription details
            User.XeGetBaseSubscription(dependentPuid, out dependentInstanceId, out dependentSubscriptionStatusId, out dependentCatalogOfferId, out dependentCatalogOfferInstanceId, out dependentTier);

            if (dependentCatalogOfferInstanceId == Guid.Empty)
            {
                throw new XRLExceptionWithoutEvent
                  (
                     HResult.XONLINE_E_ACCOUNTS_INVALID_DEPENDENT_BASE
                   , string.Format("Dependent user {0} for primary {1} does not have a base subscription",dependentPuid,ownerPuid)
                   , false);
            }

            if (dependentTier != (uint)TierEnum.Silver && dependentTier != (uint)TierEnum.Gold)
            {
                throw new XRLExceptionWithoutEvent
                 (
                   HResult.XONLINE_E_ACCOUNTS_INVALID_DEPENDENT_TIER
                  , string.Format("Tier of the dependent {0} is not silver/gold.Dependent cannot be added to family subscription", dependentPuid)
                  , false);
            }

            //do actual merge
            //do actual merge.No point making this part of transaction as this is a call to CTP
            MergeSubscriptionUtils.MergeSubscription(ownerPuid, dependentPuid);

            using (TransactionScope tx = new TransactionScope(TransactionScopeOption.RequiresNew))
            {
                
                //Move the dependent's base subscription
                RenewalUtil.MoveDependentSubscription
                    (
                            dependentPuid

                          , dependentCatalogOfferId

                          , dependentCatalogOfferInstanceId

                          , dependentInstanceId

                          , primaryFamilySubscriptionInfo.CatalogOfferId

                          , primaryFamilySubscriptionInfo.CatalogOfferInstanceId

                          , primaryFamilySubscriptionInfo.SvcInstanceId

                          , primaryFamilySubscriptionInfo.LegacyOfferId

                          , primaryFamilySubscriptionInfo.TransactionFlags

                          , primaryFamilySubscriptionInfo.SubscriptionStatusId

                          , ownerPuid

                          , DateTime.UtcNow
                    );

                //set the current subscription history
                RenewalUtil.SetCurrentSubscriptionHistoryOfferV2
                    (
                        dependentPuid

                      , primaryFamilySubscriptionInfo.CatalogOfferId

                      , primaryFamilySubscriptionInfo.CatalogOfferInstanceId

                      , primaryFamilySubscriptionInfo.LegacyOfferId
                   );

                //update the seathcount
                User.UpdateFamilyMemberGoldSeat
                    (
                           dependentUser.OwnerPassportPuid
                         , dependentUser.Puid
                         , true
                         , HistoryReason.AssignFamilyGold
                     );

                tx.Complete();
            }

        }


        /// <summary>
        /// Adds dependent to family subscription
        /// </summary>
        public static void RemoveDependentFromSubscription(Puid ownerPuid, User dependentuser,HistoryReason reason)
        {
            //Get owner's subscription family subscription info
            UserSubscriptionInfo dependentFamilySubscriptionInfo = null;
            //supress this transaction since this is a read operation to catalog.
            using (TransactionScope txnScope = new TransactionScope(TransactionScopeOption.Suppress))
            {
                dependentFamilySubscriptionInfo = GetFamilySubscriptionInfo(dependentuser.Puid);
                
                txnScope.Complete();
            }

            CancelAndDowngradeDependent(dependentuser, dependentFamilySubscriptionInfo.SvcInstanceId, true, reason);

        }

        /// <summary>
        /// Gets the gold limit for the user
        /// </summary>
        public static uint GetUserGoldLimit(Puid userPuid)
        {
            User u = new User();
            u.Load(userPuid);

            if (u.PassportPuid != u.OwnerPassportPuid)
            {
                // Dependents, even if they're assigned to a gold seat in a
                // family subscription, have no gold seats of their own to assign.
                return 0;
            }
            else
            {
                //Get owner's subscription family subscription info
                UserSubscriptionInfo primaryFamilySubscriptionInfo = User.GetBaseSubscriptionInfo(userPuid);

                //if nothing is returned then the user does not have any family subscription associated
                if (primaryFamilySubscriptionInfo == null)
                {
                    return 0;
                }
                else if (primaryFamilySubscriptionInfo.TierId != (int)TierEnum.FamilyGold)
                {
                    return 0;
                }
                else
                {
                    return (uint)Config.GetIntSetting(Setting.billing_familyGoldLimit);
                }
            }
        }


        /// <summary>
        /// Returns the family subscription associated with the Puid
        /// </summary>
        /// <returns>UserSubscriptionInfo</returns>
        private static UserSubscriptionInfo GetFamilySubscriptionInfo(Puid userPuid)
        {
            UserSubscriptionInfo primaryFamilySubscriptionInfo= User.GetBaseSubscriptionInfo(userPuid);

            if (primaryFamilySubscriptionInfo == null)
            {
                throw new XRLExceptionWithoutEvent
                    (
                      HResult.XONLINE_E_ACCOUNTS_INVALID_FAMILY_SUBSCRIPTION
                     , "No family subscription found for user {0}.This might be an issue with Offer configuration/Purchase of subscription"
                     , false
                     , userPuid);
            }
            if (primaryFamilySubscriptionInfo.TierId != (int)TierEnum.FamilyGold)
            { 
                throw new XRLExceptionWithoutEvent
                    (
                       HResult.XONLINE_E_ACCOUNTS_INVALID_FAMILY_SUBSCRIPTION
                     , "Subscription owned by user {0} is not a family subscription"
                     , false
                     , userPuid);
            }
            if (
                   primaryFamilySubscriptionInfo.SubscriptionStatusId == (int)XeSubscriptionUtil.SubscriptionStatus.Canceled
                || primaryFamilySubscriptionInfo.SubscriptionStatusId == (int)XeSubscriptionUtil.SubscriptionStatus.Suspended
                || primaryFamilySubscriptionInfo.SubscriptionStatusId == (int)XeSubscriptionUtil.SubscriptionStatus.Expired
               )
            {
                throw new XRLExceptionWithoutEvent
                   (
                     HResult.XONLINE_E_ACCOUNTS_INVALID_FAMILY_SUBSCRIPTION
                    , string.Format("Family subscription owned by the Primary user is cancelled/expired/suspended. The statusId is {0}", primaryFamilySubscriptionInfo.SubscriptionStatusId.ToString())
                    , false);
            }

            return primaryFamilySubscriptionInfo;

        }
        
        internal static void GetCatalogOfferForNewUser(
            ulong offerId, byte countryId, uint paymentType,
            out Guid? catalogOfferId, out Guid? catalogOfferInstanceId
        )
        {
            catalogOfferId = null;
            catalogOfferInstanceId = null;

            if (Config.GetBoolSetting(Setting.billing_useCatalogSubscriptionOffers))
            {
                CatalogUtil.OfferIdToOfferInstanceId(
                    offerId, (int) TierEnum.Silver, countryId, paymentType,
                    out catalogOfferId, out catalogOfferInstanceId
                );
            }
        }

        internal static HResult CreateSubscriptionForNewUser(
           ulong  userId,
           ulong  offerId,
           string serviceInstanceId,
           Guid?  catalogOfferId,
           Guid?  catalogOfferInstanceId
        )
        {
            Debug.Assert(serviceInstanceId != null);

            using (WSClient ws = new WSClient(ConfigUtil.UodbWebstoreApp, CmdType.WRITEONLY_COMMANDTYPE))
            {
                ws.SetHashVal((long) userId);
                ws.StoredProc = "dbo.p_xbos_create_subscription_for_new_user";

                // intput and output params
                ws.AddParameter(ParamType.RETVAL, "@RETVAL", 0);
                ws.AddParameter(ParamType.INPUT, "@bi_user_puid", userId);
                ws.AddParameter(ParamType.INPUT, "@bi_offer_id", offerId);
                ws.AddParameter(ParamType.INPUT, "@vc_service_instance_id", serviceInstanceId, serviceInstanceId.Length);
                ws.AddParameter(ParamType.INPUT, "@si_hash_bucket", ws.Partition);


                if (catalogOfferId.HasValue) {
                    ws.AddParameter(ParamType.INPUT, "@uid_catalogOfferId", catalogOfferId.Value);
                }

                if (catalogOfferInstanceId.HasValue) {
                    ws.AddParameter(ParamType.INPUT, "@uid_catalogOfferInstanceId ", catalogOfferInstanceId.Value);
                }

                // call the procedure
                ws.ExecuteNonQuery();
                return (uint) ws.GetIntParameter("@RETVAL");
            }
        }

        /// <summary>
        /// utility method to get the months from datediff
        /// </summary>
        /// <param name="start"></param>
        /// <param name="end"></param>
        /// <returns></returns>
        public static int GetMonthsFromDateDiff(DateTime start, DateTime end)
        {
            int months = Math.Abs(12 * (end.Year - start.Year) + end.Month - start.Month);
            //take days into account and give time benefit to user.
            if (end.Day > start.Day)
            {
                months++;
            }
            return months;
        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\marketplace\billing\Transaction.cs ===
/*
 * Transaction.cs
 *
 * Copyright (c) Microsoft Corporation. All Rights Reserved.
 *
 * Object around a "transaction" entry in the UODB.
 *
 */

using System;

using xonline.common.config;
using xonline.common.service;
using xonline.common.sql.webstore;
using xonline.common.mgmt;


namespace xonline.common.billing
{

    public class Transaction
    {

        private const int   TRANSACTION_NEW_ACCOUNT     = 0;
        private const int   TRANSACTION_PURCHASE        = 1;
        private const int   TRANSACTION_CANCEL          = 2;
        private const int   TRANSACTION_RENEWAL         = 3;


        public static void RecordNewAccount(ulong passportId, string subscriptionId, string accountId, ulong machineId)
        {
            try
            {
                Write(passportId, TRANSACTION_NEW_ACCOUNT, subscriptionId, machineId, accountId);
            }
            catch(Exception e)
            {
                Xom.NtEvent(XEvent.Id.MC_CANNOT_RECORD_TRANSACTION, e, "Couldn't log an ACCOUNT CREATION to the UODB:" 
                    + "\n\nTRANSACTION DATA:\nUser: " + passportId + "\nSubscriptionId: " + subscriptionId + "\nAccountID: "
                    + accountId + "\nMachine: " + machineId
                );
            }
        }


        public static void RecordPurchase(ulong passportId, string subscriptionId, ulong machineId)
        {
            try
            {
                Write(passportId, TRANSACTION_PURCHASE, subscriptionId, machineId, "");
            }
            catch(Exception e)
            {
                Xom.NtEvent(XEvent.Id.MC_CANNOT_RECORD_TRANSACTION_1, e,
                   "Couldn't log a PURCHASE to the UODB:" 
                    + "\n\nTRANSACTION DATA:\nUser: " + passportId + "\nSubscriptionId: " + subscriptionId
                    + "\nMachine: " + machineId
               );
            }
        }


        public static void RecordCancel(ulong passportId, string subscriptionId, ulong machineId)
        {
            try
            {
                // record machine ID only if available, otherwise 0.
                //
                Write(passportId, TRANSACTION_CANCEL, subscriptionId, machineId, "");
            }
            catch(Exception e)
            {
              Xom.NtEvent(XEvent.Id.MC_CANNOT_RECORD_TRANSACTION_2, e, "Couldn't log a CANCEL to the UODB:"
                    + "\n\nTRANSACTION DATA:\nUser: " + passportId + "\nSubscriptionId: " + subscriptionId
                    + "\nMachine: " + machineId);
            }
        }

        public static void RecordRenewal(ulong passportId, string subscriptionId, ulong machineId)
        {
            try
            {
                Write(passportId, TRANSACTION_RENEWAL, subscriptionId, machineId, "");
            }
            catch(Exception e)
            {
              Xom.NtEvent(XEvent.Id.MC_CANNOT_RECORD_TRANSACTION_3, e, "Couldn't log a RENEWAL to the UODB:"
                    + "\n\nTRANSACTION DATA:\nUser: " + passportId + "\nSubscriptionId: " + subscriptionId
                    + "\nMachine: " + machineId);
            }
        }


        private static void Write(ulong passportId, int type, string subscriptionId, ulong machineId, string accountId)
        {
            HResult hr;
            using (WSClient ws = new WSClient(ConfigUtil.UodbWebstoreApp, CmdType.WRITEONLY_COMMANDTYPE))
            {
                ws.StoredProc = "dbo.p_xbos_log_transaction";
                ws.SetHashVal((long)passportId);

                ws.AddParameter(ParamType.RETVAL, "@RETVAL", 0);
                ws.AddParameter(ParamType.INPUT,  "@ownerpuid", passportId);
                ws.AddParameter(ParamType.INPUT,  "@type", type);
                ws.AddParameter(ParamType.INPUT,  "@subscriptionid", subscriptionId, 16);
                ws.AddParameter(ParamType.INPUT,  "@accountid", accountId, 16);
                ws.AddParameter(ParamType.INPUT,  "@machineid", machineId);
                ws.AddParameter(ParamType.INPUT,  "@hashbucket", ws.Partition);

                ws.ExecuteNonQuery();

                hr = (uint)ws.GetIntParameter("@RETVAL");
                if (HResult.Failed(hr))
                {
                    throw new Exception("Error committing Transaction type " + type + " to UODB transactions table! (hr = " + hr + ")\n"
                        + "Onwer: " + passportId + "\nSubscription ID: " + subscriptionId);
                }
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\marketplace\billing\TitleActivation.cs ===
//
// GetTitleActivationList
//
// This file contains classes to retrieve and sign the list of activated titles
// for one or more users.
//
// This is essentially a list of title ids with a signature block.
//
// The signature field is the RSA (PKCS1-V1.5) signature of the entire reply
// packet minus the signature field itself, obviously.
//

using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Globalization;
using System.IO;
using System.Security.Cryptography;

using xonline.common.config;
using xonline.common.mgmt;
using xonline.common.protocol;
using xonline.common.service;
using xonline.common.sql.webstore;
using xonline.common.utilities2;
using xonline.common.xcrypto;

using Microsoft.Webstore.WstClient;

namespace xonline.common.billing
{
    // This is the format of the 'license' in the reply; this is what gets signed. All
    // integer fields are big-endian.
    public class TitleActivationUtil
    {
        private static volatile TitleActivationUtil _global = null;
        public static TitleActivationUtil Global
        {
            get
            {
                if(_global == null)
                {
                    lock(typeof(TitleActivationUtil))
                    {
                        if(_global == null)
                        {
                            _global = new TitleActivationUtil();
                        }
                    }
                }

                return _global;
            }
        }

        // Don't iterate over this array directly, make a local copy before iterating, or
        // else you may blow up, as it can be swapped out from under you.
        private volatile Dictionary<UInt32, bool> _TestTitleIds;

        // -------------------------------------------------------------------------
        // Constructor - builds list of test titles and registers for changes
        // -------------------------------------------------------------------------
        private TitleActivationUtil()
        {
            _TestTitleIds = ParseTestTitleIds(Config.GetMultiSetting(MultiSetting.xbos_titleActivation_testTitles));

            Config.MultiSettingChange += new MultiSettingChangeEventHandler(MultiSettingsChanged);
        }

        // -------------------------------------------------------------------------
        // MultiSettingsChanged - handles change notifications from Config. We need to
        // build our new list of titles.
        // -------------------------------------------------------------------------
        public void MultiSettingsChanged(object sender, MultiSettingChangeEventArgs eventArgs)
        {
            switch(eventArgs.MultiSetting)
            {
            case MultiSetting.xbos_titleActivation_testTitles:
                // Swap out real quick like
                _TestTitleIds = ParseTestTitleIds(eventArgs.ValueNew);
                break;
            }
        }

        // -------------------------------------------------------------------------
        // Convert an array of string[] title ids to dictionary. Ignore and log an event
        // about any malformed ones.
        // -------------------------------------------------------------------------
        private Dictionary<UInt32, bool> ParseTestTitleIds(string[] testTitles)
        {
            Dictionary<UInt32, bool> titleDict = new Dictionary<UInt32, bool>();
            UInt32 titleId;

            foreach (string titleString in testTitles)
            {
                string titleStringToParse;
                if (titleString.StartsWith("0x"))
                    titleStringToParse = titleString.Substring(2);
                else
                    titleStringToParse = titleString;

                if (!UInt32.TryParse(titleStringToParse, NumberStyles.HexNumber, null, out titleId))
                {
                    string msg = String.Format(
                        "Warning: The multisetting xbos_titleActivation_testTitles value {0} " +
                        "cannot be converted to a UInt32. It should be in the format 0xnnnnnnnn.",
                        titleString);

                    Xom.NtEvent(XEvent.Id.COMMON_BILLING_TITLEID_FORMAT, msg);
                    continue;
                }

                if (Config.EnvironmentType == "production")
                {
                    string msg = String.Format(
                        "Warning: GetUserTitleActivationList is activating titleId " +
                        "{0} via multisetting {1}. This should be carefully " +
                        "controlled in a production environment.",
                        (TitleId) titleId, MultiSetting.xbos_titleActivation_testTitles);

                    Xom.NtEvent(XEvent.Id.COMMON_BILLING_TEST_SETTING_WARNING, msg);
                }

                titleDict[titleId] = true;
            }

            return titleDict;
        }



        // -------------------------------------------------------------------------
        // GetTitleActivationList - This will process the Refresh-License request and
        // serves as the main entry point.
        // -------------------------------------------------------------------------
        public GetTitleActivationListResponse GetTitleActivationList(
            GetTitleActivationListRequest request
            )
        {
            GetTitleActivationListResponse response = new GetTitleActivationListResponse();

            // Retrieve list of activated titles from the database
            response.titles = GetTitleActivationList(
                request.userIds,
                request.machineId,
                request.requestedTitleId);

            // Prepare the response
            response.nonce = request.nonce;
            response.machineId = request.machineId;
            response.userIds = request.userIds;

            // Nothing activated?
            if (response.titles == null || response.titles.Length == 0)
            {
                if (request.requestedTitleId != 0)
                {
                    // If user requested a single title but no one was authorized for it, then
                    // we want to return it but set license bits to 0.
                    response.titlesLength = 1;
                    response.titles = new TitleLicenseInfo[1];
                    response.titles[0] = new TitleLicenseInfo();
                    response.titles[0].titleId = request.requestedTitleId;
                    response.titles[0].licenseFlags = 0;
                }
                else
                {
                    // User wanted list of all titles, but none were activated. So return
                    // nothing.
                    response.titlesLength = 0;
                }
            }
            else
            {
                response.titlesLength = (UInt32)response.titles.Length;
            }

            // Sign the response
            SignResponse(response, request.signatureFormat);

            return response;
        }

        // -------------------------------------------------------------------------
        // SignResponse - will sign the response, treating the fields as either
        // little-endian or big-endian.
        //
        // signatureFormat = 0: little-endian
        // signatureFormat = 1: big-endian
        // -------------------------------------------------------------------------
        protected void SignResponse(GetTitleActivationListResponse response, uint signatureFormat)
        {
            Debug.Assert(response != null);
            Debug.Assert(response.userIds != null && response.userIds.Length == 4);

            if (GetTitleActivationListRequest.SIGNATUREFORMAT_BIG_ENDIAN != signatureFormat &&
                GetTitleActivationListRequest.SIGNATUREFORMAT_LITTLE_ENDIAN != signatureFormat)
            {
                throw new ArgumentOutOfRangeException("signatureFormat has invalid value " +
                                                      signatureFormat.ToString());
            }

            // I wish we could be more efficient here. Perhaps we should look at trading
            // protocol definition simplicity for speed. Or not.

            // Serialize the body
            MemoryStream ms = new MemoryStream((int)response.GetBodySize());
            using (BinaryWriter bw = new BinaryWriter(ms))
            {

                if (GetTitleActivationListRequest.SIGNATUREFORMAT_BIG_ENDIAN == signatureFormat)
                {
                    // Do big endian
                    bw.Write(ByteOrder.Revert(response.machineId));
                    bw.Write(ByteOrder.Revert(response.userIds[0]));
                    bw.Write(ByteOrder.Revert(response.userIds[1]));
                    bw.Write(ByteOrder.Revert(response.userIds[2]));
                    bw.Write(ByteOrder.Revert(response.userIds[3]));
                    bw.Write(ByteOrder.Revert(response.nonce));
                    bw.Write(ByteOrder.Revert(response.titlesLength));
                    for (int i = 0; i < response.titlesLength; i++)
                    {
                        Debug.Assert(response.titles != null && i < response.titles.Length);
                        bw.Write(ByteOrder.Revert(response.titles[i].titleId));
                        bw.Write(ByteOrder.Revert(response.titles[i].licenseFlags));
                    }
                }
                else if (GetTitleActivationListRequest.SIGNATUREFORMAT_LITTLE_ENDIAN == signatureFormat)
                {
                    // Fall back to little endian for all other cases
                    bw.Write(response.machineId);
                    bw.Write(response.userIds[0]);
                    bw.Write(response.userIds[1]);
                    bw.Write(response.userIds[2]);
                    bw.Write(response.userIds[3]);
                    bw.Write(response.nonce);
                    bw.Write(response.titlesLength);
                    for (int i = 0; i < response.titlesLength; i++)
                    {
                        Debug.Assert(response.titles != null && i < response.titles.Length);
                        bw.Write(response.titles[i].titleId);
                        bw.Write(response.titles[i].licenseFlags);
                    }
                }

                // Sign it
                byte[] body = ms.ToArray();
                byte[] hash = (new SHA1Managed()).ComputeHash(body);

                UInt32 sigLen = 0;
                response.signature = new byte[XOn.TITLE_ACTIVATION_LIST_SIGNATURE_SIZE];
                CryptoKeyProxy.Sign(CONTAINER_CLASS,
                                    hash,
                                    response.signature,
                                    out sigLen);
            }
        }


        // -------------------------------------------------------------------------
        // GetTitleActivationList
        // Given an array of user-ids, this will return an array of activated titles
        // unioned for all users. We are also including the machine-id, though currently
        // it is not implemented or supported. We are also including the current title-id,
        // which we will guarantee to be in the returned list.
        //
        // null may be returned when no titles are activated, or activation is disabled
        // globally. A zero-length array may also be returned.
        // -------------------------------------------------------------------------
        protected TitleLicenseInfo[] GetTitleActivationList(
            UInt64[] userIds,
            UInt64 machineId,
            UInt32 titleId
        )
        {
            if (userIds == null)
                return null;

            // If title activation is globally turned off, return a dummy entry.
            if (Config.GetBoolSetting(Setting.xbos_titleActivation_disableAllTitles))
            {
                return null;
            }

            List<TitleLicenseInfo> tempTitles;

            SortedDictionary<UInt32, TitleLicenseInfo> allTitles;
            allTitles = new SortedDictionary<UInt32, TitleLicenseInfo>();

            // @@@ get machine list? same stored proc?

            for (int i = 0; i < userIds.Length; i++)
            {
                if (userIds[i] == 0)
                    continue;

                // @@@ check if user is also a guest in the authdata?

                // Get titles for this user for testing
                tempTitles = GetUserTitleActivationListFromTestSetting(
                    userIds[i],
                    titleId,
                    TitleLicenseInfo.LicenseFlags_GrantedUser1 << i);

                if (tempTitles == null || tempTitles.Count == 0)
                {
                    // Get titles for this user from the database
                    tempTitles = GetUserTitleActivationListFromDatabase(
                        userIds[i],
                        titleId,
                        TitleLicenseInfo.LicenseFlags_GrantedUser1 << i);
                }
                else
                {
                    // We're using the override setting here. For testing only, we're
                    // going to say user #4 (index 3) never gets the title activated. But
                    // only for the override setting case.
                    if (i == 3)
                    {
                        tempTitles = null;
                    }
                }

                // merge with allTitles
                MergeTitleActivationLists(tempTitles, allTitles);
            }

            // Build array out of this

            TitleLicenseInfo[] titles = new TitleLicenseInfo[allTitles.Count];
            int idx = 0;
            foreach (KeyValuePair<UInt32, TitleLicenseInfo> kvp in allTitles)
            {
                titles[idx] = kvp.Value;
                idx++;
            }
            return titles;
        }

        // -------------------------------------------------------------------------
        // GetUserTitleActivationListFromDatabase - gets a list of activated titles from
        // the db. If titleId is 0, result will be a list of activated titles. If titleId
        // is not 0, result will be a single entry for that titleId if activated, or else
        // a blank list if not activated.
        //
        // null is never returned.
        // -------------------------------------------------------------------------
        protected List<TitleLicenseInfo> GetUserTitleActivationListFromDatabase(
            UInt64 userId,
            UInt32 titleId,
            UInt32 licenseFlags
        )
        {
            using(WSClient ws = new WSClient(ConfigUtil.UodbWebstoreApp, CmdType.WRITETHENREAD_COMMANDTYPE))
            {
                ws.PartitionType = WstPartitionType.Logical;
                ws.SetHashVal(userId);

                ws.StoredProc = "dbo.p_xbos_get_title_activation_list";
                ws.AddParameter(ParamType.RETVAL, "@RETVAL", 0);
                ws.AddParameter("@bi_user_id",  userId);
                ws.AddParameter("@i_title_id", titleId);

                List<TitleLicenseInfo> titleList;
                titleList = new List<TitleLicenseInfo>();

                using (WstDataReader r = ws.Execute())
                {
                    while(r.Read())
                    {
                        TitleLicenseInfo title;
                        title = new TitleLicenseInfo();
                        title.titleId = (UInt32)r.GetInt32(0);
                        title.licenseFlags = licenseFlags;

                        // @@@ any extra flags to add or check?

                        titleList.Add(title);
                    }
                }

                HResult hr = (uint) ws.GetIntParameter("@RETVAL");

                if (HResult.Failed(hr))
                {
                    string msg = String.Format(
                        "{0} failed with hr = {1}", ws.GetCallSignature(),
                        hr.ToString());

                    throw new XRLException(hr, XEvent.Id.COMMON_BILLING_CODE_224, msg);
                }

                return titleList;
            }
        }

        // -------------------------------------------------------------------------
        // GetUserTitleActivationListFromTestSetting - gets a list (or single result) of
        // activated titles from the test-only setting xbos_titleActivation_testTitles.
        //
        // null is never returned.
        // -------------------------------------------------------------------------
        protected List<TitleLicenseInfo> GetUserTitleActivationListFromTestSetting(
            UInt64 userId,
            UInt32 titleId,
            UInt32 licenseFlags
        )
        {
            List<TitleLicenseInfo> titleList = new List<TitleLicenseInfo>();

            if (titleId == 0)
            {
                // We don't support lists from the setting
                return titleList;
            }

            if (_TestTitleIds.ContainsKey(titleId))
            {
                TitleLicenseInfo title = new TitleLicenseInfo();
                title.titleId = titleId;
                title.licenseFlags = licenseFlags;

                // @@@ any extra flags to add or check?

                titleList.Add(title);
            }

            return titleList;
        }


        protected void MergeTitleActivationLists(
            List<TitleLicenseInfo> listTitles,
            SortedDictionary<UInt32, TitleLicenseInfo> allTitles)
        {
            if (listTitles == null || allTitles == null)
                return;

            // Go through list to add. If it exists in the dictionary, just update the
            // license bits.  Otherwise add it.
            foreach (TitleLicenseInfo tli in listTitles)
            {
                if (allTitles.ContainsKey(tli.titleId))
                {
                    allTitles[tli.titleId].licenseFlags |= tli.licenseFlags;
                }
                else
                {
                    allTitles[tli.titleId] = tli;
                }
            }
        }

        private const EContainerClasses CONTAINER_CLASS = EContainerClasses.Drm;

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\marketplace\billing\upsutil.cs ===
using System;
using System.Collections;
using System.Text.RegularExpressions;

using xonline.common.config;
using xonline.common.mgmt;
using xonline.common.protocol;
using xonline.common.service;
using xonline.common.utilities;

namespace xonline.common.billing
{
    // The name is misleading. This contains the implementation to most Ups
    // related SPIs.
    public class UpsUtil
    {
        public static PassportGetUserDataResponse XePassportGetUserData(PassportGetUserDataRequest request)
        {
            ulong puid = PassportSessionToken.GetPuid(request.sessionToken);
            return XePassportGetUserData(puid);
        }

        public static PassportGetUserDataResponse XePassportGetUserData(ulong puid)
        {
            IUpsClient ups = UpsClientGlobal.Global;
            UpsProfile profile;
            string profileXml;
            int geoid;
            GeoId.RegionInfo regionInfo;

            string attributes = String.Join(",", new string[] {
                "Personal2_CS.Name_First",
                "Personal2_CS.Name_Last",
                "Personal_CS.Birthdate",
                "Addresses_CS.Home_Street1",
                "Addresses_CS.Home_Street2",
                "Addresses_CS.Home_City",
                "Addresses_CS.Home_Country",
                "Addresses_CS.Home_Region",
                "Addresses_CS.Home_PostalCode",
                "xbox.dayphone",
                "xbox.email",
                "xbox.gamertag"
            });

            ups.GetProfile(puid, attributes, out profileXml);
            profile = new UpsProfile(profileXml);

            PassportGetUserDataResponse response = new PassportGetUserDataResponse();

            // Get geo-id. We'll use it to get the country and the state
            profile.GetAttributeInt("Addresses_CS", "Home_Region", out geoid);
            regionInfo = GeoId.GetRegionInfo((uint)geoid);

            // Personal information
            profile.GetAttributeString("Personal2_CS", "Name_First",   out response.firstName);
            profile.GetAttributeString("Personal2_CS", "Name_Last",    out response.lastName);

            // Birthdate
            string birthDateString;
            if(profile.GetAttributeString("Personal_CS", "Birthdate", out birthDateString))
            {
                ParseBirthdate(birthDateString, out response.birthdate);
            }
            else
            {
                response.birthdate = _nulldate;
            }

            // Address
            response.addressInfo = new AddressInfoData();
            profile.GetAttributeString("Addresses_CS", "Home_Street1", out response.addressInfo.street1);
            profile.GetAttributeString("Addresses_CS", "Home_Street2", out response.addressInfo.street2);
            profile.GetAttributeString("Addresses_CS", "Home_City", out response.addressInfo.city);

            response.addressInfo.district = "";

            response.addressInfo.state = regionInfo != null ? regionInfo._region : string.Empty;

            profile.GetAttributeString("Addresses_CS", "Home_PostalCode", out response.addressInfo.postalCode);

            // Phone number
            response.phoneInfo = new PhoneInfoData();
            string phoneNumberString;
            if(profile.GetAttributeString("xbox", "dayphone", out phoneNumberString))
            {
                ParsePhoneNumber(
                    phoneNumberString,
                    out response.phoneInfo.phonePrefix,
                    out response.phoneInfo.phoneNumber,
                    out response.phoneInfo.phoneExtension);
            }
            else
            {
                response.phoneInfo.phonePrefix    = string.Empty;
                response.phoneInfo.phoneNumber    = string.Empty;
                response.phoneInfo.phoneExtension = string.Empty;
            }

            if ( regionInfo != null )
            {
                response.countryId = regionInfo._countryId;
            }
            else
            {
                string countryCode;
                profile.GetAttributeString("Addresses_CS", "Home_Country", out countryCode);
                response.countryId = CountryDictionary.CountryId(countryCode.ToUpper());
            }

            profile.GetAttributeString("xbox", "email", out response.email);

            return response;
        }

        public static void UpdateGamertag(ulong puid, string gamertag)
        {
            UpsProfile profile = new UpsProfile(puid);
            profile.AppendAttributeString("xbox", "gamertag", gamertag);

            string pprof = null;
            string uprof = null;
            profile.GetPassportAndUpsProfiles(out uprof, out pprof);

            if (uprof != null)
            {
                Xom.Trace(XomAreaName.passportTrace, LogLevel.L_LOW, "UpsUtil.UpdateGamertag: updating UPS profile for puid: 0x" + puid.ToString("x") + ": gamertag: '" + gamertag + "'");

                IUpsClient ups = UpsClientGlobal.Global;

                ups.UpdateProfile(uprof);
            }

            if (pprof != null)
            {
                Xom.Trace(XomAreaName.passportTrace, LogLevel.L_LOW, "UpsUtil.UpdateGamertag: updating Passport profile for puid: 0x" + puid.ToString("x") + ": gamertag: '" + gamertag + "'");

                PassportClientBase pc = PassportClientGlobal.Global;
                pc.UpdateProfile(pprof);
            }
        }

        public static void UpdateDateOfBirth(Puid puid, DateTime birthdate)
        {
            string birthdateString = BuildBirthdateString(birthdate);

            UpsProfile profile = new UpsProfile(puid);
            profile.AppendAttributeString("Personal_CS", "Birthdate", birthdateString);

            string pprof = null;
            string uprof = null;
            profile.GetPassportAndUpsProfiles(out uprof, out pprof);

            if (uprof != null)
            {
                Xom.Trace(XomAreaName.passportTrace, LogLevel.L_LOW, "UpsUtil.UpdateDateOfBirth: updating UPS profile for puid: " + puid + ": date of birth: '" + birthdateString + "'");
                IUpsClient ups = UpsClientGlobal.Global;
                ups.UpdateProfile(uprof);
            }

            if (pprof != null)
            {
                Xom.Trace(XomAreaName.passportTrace, LogLevel.L_LOW, "UpsUtil.UpdateDateOfBirth: updating Passport profile for puid: " + puid + ": date of birth: '" + birthdateString + "'");
                PassportClientBase pc = PassportClientGlobal.Global;
                pc.UpdateProfile(pprof);
            }
        }

        public static void UpdateAddress(Puid puid, int cultureId, string street1, string street2, string city, string state, string postalCode, string country)
        {
            UpsProfile profile = new UpsProfile(puid);
            profile.AppendAttributeString("Addresses_CS", "Home_Country", country);
            if ( !string.IsNullOrEmpty(street1) ) profile.AppendAttributeString("Addresses_CS", "Home_Street1", street1);
            if ( !string.IsNullOrEmpty(street2) ) profile.AppendAttributeString("Addresses_CS", "Home_Street2", street2);
            if ( !string.IsNullOrEmpty(city) ) profile.AppendAttributeString("Addresses_CS", "Home_City", city);
            if ( !string.IsNullOrEmpty(state) ) profile.AppendAttributeString("Addresses_CS", "Home_Region", state);
            if ( !string.IsNullOrEmpty(postalCode) ) profile.AppendAttributeString("Addresses_CS", "Home_PostalCode", postalCode);

            string pprof = null;
            string uprof = null;
            profile.GetPassportAndUpsProfiles(out uprof, out pprof);

            if (uprof != null)
            {
                Xom.Trace(XomAreaName.passportTrace, LogLevel.L_LOW, "UpsUtil.UpdateAddress: updating UPS profile for puid: 0x{0}, country: {1}", puid.ToString(), country);

                IUpsClient ups = UpsClientGlobal.Global;

                ups.UpdateProfile(uprof);
            }

            if (pprof != null)
            {
                Xom.Trace(XomAreaName.passportTrace, LogLevel.L_LOW, "UpsUtil.UpdateAddress: updating UPS profile for puid: 0x{0}, country: {1}", puid.ToString(), country);

                // find the valid LCID for this pseudo LCID
                int lcid = Locale.GetValidLCID(cultureId);

                PassportClientBase pc = PassportClientGlobal.Global;

                pc.UpdateProfile(pprof);
            }
        }

        public static DateTime GetBirthdate(ulong puid)
        {
            DateTime birthdate = DateTime.MinValue;
            IUpsClient ups = UpsClientGlobal.Global;

            string attributes = String.Join(",", new string[] {
                "Personal_CS.Birthdate",
                "Addresses_CS.Home_Region"
            });

            string profileXml;
            ups.GetProfile(puid, attributes, out profileXml);

            UpsProfile profile = new UpsProfile(profileXml);

            // Birthdate
            string birthDateString;
            if (profile.GetAttributeString("Personal_CS", "Birthdate", out birthDateString))
            {
                UpsUtil.ParseBirthdate(birthDateString, out birthdate);
            }

            return birthdate;
        }


        protected static Regex _phoneNumberRegEx = new Regex(
            @"^\s*"+                      // Trailing spaces
            @"\((?<prefix> \d{1,12} )\)"+ // Prefix
            @"\s*"+                       // More spaces
            @"(?<number> \d+ -? \d+)"+       // Number
            @"\s*$",                      // Trailing spaces
            RegexOptions.Compiled | RegexOptions.IgnorePatternWhitespace
        );

        public static bool ParsePhoneNumber(
            string phoneNumber,
            out string prefix,
            out string number,
            out string extension
        )
        {
            Match match = _phoneNumberRegEx.Match(phoneNumber);

            if(match.Success)
            {
                prefix    = match.Groups["prefix"].Value;
                number    = match.Groups["number"].Value;
                extension = string.Empty;
                return true;
            }
            else
            {
                prefix    = string.Empty;
                number    = string.Empty;
                extension = string.Empty;
                return false;
            }
        }

        protected static Regex _dateRegex = new Regex(
            @"^\s*"+               // Trailing spaces
            @"(?<day>\d{1,2})"+    // Day
            @"(?<sep> [-/:])"+     // Separator (either -, / or :)
            @"(?<month>\d{1,2})"+  // Month
            @"\k<sep>"+            // Separator (matching the first one)
            @"(?<year> \d{4})"+    // Year
            @"\s*$        ",       // More trailing spaces
            RegexOptions.Compiled | RegexOptions.IgnorePatternWhitespace);

        protected static DateTime _nulldate = new DateTime(1601, 1, 1);

        public static bool ParseBirthdate(
            string birthdateStr,
            out DateTime birthdate
        )
        {
            birthdate = _nulldate;

            Match match = _dateRegex.Match(birthdateStr);
            if(match.Success)
            {
                try
                {
                    birthdate = new DateTime(
                        Convert.ToInt32(match.Groups["year"].Value),
                        Convert.ToInt32(match.Groups["month"].Value),
                        Convert.ToInt32(match.Groups["day"].Value));
                }
                catch(ArgumentOutOfRangeException)
                {
                    return false;
                }
                catch(ArgumentException)
                {
                    return false;
                }

                return true;
            }
            else
            {
                return false;
            }
        }

        public static string BuildBirthdateString(DateTime birthdate)
        {
            return birthdate.ToString("d:M:yyyy");
        }
    }

    // GeoId
    // Maps GeoIds to region information
    public class GeoId
    {
        public class RegionInfo
        {
            public byte     _countryId;
            public string   _region;
        }

        public static RegionInfo GetRegionInfo(uint geoid)
        {
            Init();
            return (RegionInfo)_regions[geoid];
        }

        protected static void Init()
        {
            if(_regions == null)
            {
                lock(typeof(GeoId))
                {
                    _regions = LoadRegions();
                }
            }
        }

        protected static Hashtable LoadRegions()
        {
            string[] regionSettings = Config.GetMultiSetting(MultiSetting.billing_geoid_region);
            Hashtable regions = new Hashtable(regionSettings.Length);

            for(int i=0; i < regionSettings.Length; i++)
            {
                string regionSetting = regionSettings[i];

                // parse region setting. It uses the following format:
                // geo-id;country-id;region-name

                string[] fields = regionSetting.Split(';');

                try
                {
                    if(fields.Length < 3)
                        throw new Exception("Invalid number of fields");

                    uint geoid = Convert.ToUInt32(fields[0]);
                    RegionInfo regionInfo = new RegionInfo();

                    regionInfo._countryId = Convert.ToByte(fields[1]);
                    regionInfo._region    = fields[2];

                    regions.Add(geoid, regionInfo);
                }
                catch(Exception e)
                {
                    throw new ExceptionWithEventId(
                        XEvent.Id.COMMON_CONFIG_68, string.Format(
                            "Failed to load billing_geoid_region multisettings. Stopped on entry "+
                            "# {0}. Inner exception contains the reason.", i.ToString()), e);
                }
            }

            return regions;
        }

        static protected Hashtable _regions;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\marketplace\billing\ups.cs ===
using System;
using System.Net;
using System.Security.Cryptography.X509Certificates;
using System.Threading;
using System.Web.Services.Protocols;
using System.Xml;

using xonline.common.billing.ups;
using xonline.common.config;
using xonline.common.mgmt;
using xonline.common.service;
using xonline.common.utilities2;

namespace xonline.common.billing
{
    // Here is what every UPS client should be able to do
    public interface IUpsClient
    {
        void GetProfile(
            ulong puid,
            string attributes,
            out string profileXml);

        void UpdateProfile(
            string profileXml);
    }

    // Manages the global instance of UpsClient. Most applications should
    // not instantiate UpsClient directly and instead use the UpsClientGlobal's
    // Global accessor. It will take care of the (lazily) intialialization of
    // the Ups client object and of manual and automatic reloads.
    public class UpsClientGlobal
    {
        // Get the global instance of the PassportClient
        public static IUpsClient Global
        {
            get
            {
                if(_ups == null)
                {
                    Init();
                }
                return _ups;
            }
        }

        // First time init
        private static void Init()
        {
            // All threads should be trying to init at the same time. Let's make
            // sure just one handles the initialization while the other threads
            // wait
            lock(_lockObject)
            {
                if(_ups == null)
                {
                    UpsClient ups = new UpsClient();
                    ups.Init();
                    _ups = ups;
                }
            }
        }

        // Initialize a new instance of the ups client with fresh
        // configuration
        public static void Reload()
        {
            // Reload should be called from a single thread. So it's OK to
            // initialize a new instance before blocking to replace the global
            // instance

            UpsClient ups = new UpsClient();
            ups.Init();

            lock(_lockObject)
            {
                _ups = ups;
            }
        }

        // Reset the session alternate Url. Default Url will be used instead
        public static void ResetSessionAlternateUrl()
        {
            InitAlternateHandler();
            Thread.SetData(_tlsSessionAlternateUrl, null);
        }

        // Set the session alternate Url.
        public static void SetSessionAlternateUrl(string url)
        {
            InitAlternateHandler();
            Thread.SetData(_tlsSessionAlternateUrl, url);
        }

        // Get the session alternate Url
        public static string GetSessionAlternateUrl()
        {
            InitAlternateHandler();
            object url = Thread.GetData(_tlsSessionAlternateUrl);
            return (string) url;
        }

        // Lazily initializes alternate url support. It basically allocates the
        // TLS slot for the alternate url string and instantiates the hashtable
        // to store the handlers.
        private static void InitAlternateHandler()
        {
            if (_tlsSessionAlternateUrl == null)
            {
                lock(_lockObject)
                {
                    _tlsSessionAlternateUrl = Thread.AllocateDataSlot();
                }
            }
        }

        private volatile static LocalDataStoreSlot _tlsSessionAlternateUrl = null;

        private static volatile object _lockObject = new object();

        private static volatile IUpsClient _ups;
    }

    // Standard Ups client implementation
    // Most applications won't need to instantiate UpsClient directly.
    // Instead, use UpsClientGlobal
    public class UpsClient : IUpsClient
    {
        static UpsClient()
        {
            XomControl.ControlRequestEvent += new XomControl.ControlRequestEventHandler(OnControlRequest);

        }

        // ***** IUpsClient *****

        // Get the profile of a user. The attributes string contains a comma-
        // separated list of attributes using the following format: namespace.name
        // For example: "xbox.email,xbox.dayphone". There can be no white-spaces
        // before, after or between each attribute otherwise UPS will puke.
        // The output is a UpsProfile object which should contain all the
        // attributes requested.
        public void GetProfile(
            ulong puid,
            string attributes,
            out string profileXml
        )
        {
            string apiName = "GetProfile";

            string error;
            string[] results;

            UpsWebService ups = GetUpsWebService();

            try
            {
                CheckForFastFail(apiName);

                int timeout = Config.GetIntSetting(Setting.ups_getProfileTimeoutSeconds) * 1000;

                UpsFailure.HandleBehaviorInjection(apiName, ref timeout);

                ups.Timeout = timeout;

                results = ups.GetProfileByAttributes(
                    new string[] { puid.ToString("X016") },
                    attributes,
                    0,
                    out error);
            }
            catch (SoapException e)
            {
                string innerXml = (e == null || e.Detail == null || string.IsNullOrEmpty(e.Detail.InnerXml)) ? "" : e.Detail.InnerXml;

                string errMsg = string.Format("ups.GetProfileByAttributes failed. e.Detail.InnerXml:\r\n{0}\r\n\r\n", innerXml);

                throw new XRLException(
                    HResult.XONLINE_E_UPS_GET_PROFILE_ERROR, XEvent.Id.COMMON_UPS_GET_PROFILE_ERROR,
                    errMsg, e
                );
            }
            catch (WebException we)
            {
                HResult hr = HResult.XONLINE_E_UPS_ERROR;

                if (FastFailHelper.ConsiderWebExceptionAsTimeout(we))
                {
                    HandleTimeout(apiName, we.ToString());
                    hr = HResult.XONLINE_E_UPS_TIMEOUT_ERROR;
                }

                throw new XRLException(
                    hr, XEvent.Id.COMMON_UPS_ERROR, "Error connecting to UPS", we
                );
            }
            finally
            {
                HandleSuccess(apiName); // ok to call after HandleFailure
            }

            profileXml = results[0];

            Xom.Trace(XomAreaName.passportTrace, LogLevel.L_LOW, "UpsClient.GetProfile: puid: 0x" + puid.ToString("x") + ": profileXml:\r\n" + XmlUtil.PrettyPrint(profileXml));
        }

        // Update the profile of an user
        // It takes an UpsProfile object. Use the constructor that takes a puid
        // and then use the AppendAttribute* methods to add attributes to it.
        public void UpdateProfile(string profileXml)
        {
            Xom.Trace(XomAreaName.passportTrace, LogLevel.L_LOW, "UpsClient.UpdateProfile: profileXml:\r\n" + profileXml);

            string apiName = "UpdateProfile";
            UpsWebService ups = GetUpsWebService();

            try
            {
                CheckForFastFail(apiName);

                int timeout = Config.GetIntSetting(Setting.ups_updateProfileTimeoutSeconds) * 1000;

                UpsFailure.HandleBehaviorInjection(apiName, ref timeout);

                ups.Timeout = timeout;

                ups.UpdateProfile(new string[] { profileXml });
            }
            catch (SoapException e)
            {
                string innerXml = (e == null || e.Detail == null || string.IsNullOrEmpty(e.Detail.InnerXml)) ? "" : e.Detail.InnerXml;

                string errMsg = string.Format("ups.UpdateProfile failed. e.Detail.InnerXml:\r\n{0}\r\n\r\n", innerXml);

                throw new XRLException(
                    HResult.XONLINE_E_UPS_UPDATE_PROFILE_ERROR, XEvent.Id.COMMON_UPS_UPDATE_PROFILE_ERROR,
                    errMsg, e
                );
            }
            catch (WebException we)
            {
                HResult hr = HResult.XONLINE_E_UPS_ERROR;

                if (FastFailHelper.ConsiderWebExceptionAsTimeout(we))
                {
                    HandleTimeout(apiName, we.ToString());
                    hr = HResult.XONLINE_E_UPS_TIMEOUT_ERROR;
                }

                throw new XRLException(
                    hr, XEvent.Id.COMMON_UPS_UPDATE_PROFILE_ERROR, "Error connecting to UPS", we
                );
            }
            finally
            {
                HandleSuccess(apiName); // ok to call after HandleFailure
            }
        }

        public void Init()
        {
            string certName;
            string proxy;

            _partnerId = Config.GetSetting(Setting.ups_partnerId);
            _url       = Config.GetSetting(Setting.ups_url);
            certName   = Config.GetSetting(Setting.ups_clientCertName);
            proxy      = Config.GetSetting(Setting.billing_proxy);

            string msg = string.Format(
                "Ups interface initializing with the following settings:\n"+
                "ups_partnerId      = {0}\n"+
                "ups_url            = {1}\n"+
                "ups_clientCertName = {2}\n"+
                "billing_proxy      = {3}\n",
                _partnerId,
                _url,
                certName,
                proxy);

          Xom.NtEvent(XEvent.Id.COMMON_INFO_3, msg);

            _cert  = CertUtil.GetLocalMachineCertificate(certName);

            if ( string.IsNullOrEmpty(proxy) )
            {
                _proxy = new WebProxy();
            }
            else
            {
                _proxy = new WebProxy(proxy, true);
            }

            // Initialize the FastFail helper
            _fastFailHelper = new FastFailHelper(
                Setting.ups_blacklistTimeoutThresholdCount,
                Setting.ups_blacklistTimeoutTimespanSeconds,
                Setting.ups_blacklistBlockIntervalSeconds,
                XEvent.Id.FAIL_FAST_ENTER,
                XEvent.Id.FAIL_FAST_EXIT
            );  // TODO: should be unique
        }

        public string PartnerId
        {
            get { return _partnerId; }
        }

        public string Url
        {
            get { return _url; }
        }

        public X509Certificate ClientCert
        {
            get { return _cert; }
        }

        public WebProxy Proxy
        {
            get { return _proxy; }
        }

        protected UpsWebService GetUpsWebService()
        {
            UpsWebService ups = new UpsWebService();
            ups.WSSECURITYHEADERValue = new WSSecurityHeader();
            ups.WSSECURITYHEADERValue.version = EnumSHVersion.eshHeader30;
            ups.WSSECURITYHEADERValue.wssecurity = null;
            ups.WSSECURITYHEADERValue.authorization = null;
            ups.WSSECURITYHEADERValue.sitetoken = string.Format(
                "<u:UPS-siteToken xmlns:u=\"http://schemas.microsoft.com/UPS/SiteToken\">\n"+
                "  <u:siteID>{0}</u:siteID>\n"+
                "</u:UPS-siteToken>\n", _partnerId);
            ups.WSSECURITYHEADERValue.ppSoapHeader25 = null;
            ups.Url = _url;

            string alternateUrl = UpsClientGlobal.GetSessionAlternateUrl();
            if ( false == string.IsNullOrEmpty(alternateUrl) )
            {
                Xom.Trace(XomAreaName.passportTrace, LogLevel.L_HIGH, "GetUpsWebService: using alternateUrl: " + alternateUrl);
                ups.Url = alternateUrl;
            }

            ups.ClientCertificates.Add(_cert);
            ups.Proxy = _proxy;

            return ups;
        }

        protected void CheckForFastFail(string apiName)
        {
            if (_fastFailHelper.InFastFailState(apiName))
            {
                throw new XRLExceptionWithoutEvent(
                    HResult.XONLINE_E_RESOURCE_UNAVAILABLE,
                    "{0}: call blocked due to fail-fasting of passport server", apiName
                );
            }
        }

        private void HandleTimeout(string apiName, string errorMessage)
        {
            _fastFailHelper.ReportFailure(apiName, errorMessage);
        }

        private void HandleSuccess(string apiName)
        {
            _fastFailHelper.ReportSuccess(apiName);
        }

        // Xmgmt interface
        private static void OnControlRequest(object sender, ControlRequestEventArgs args)
        {
            switch(args.Command.ToLower())
            {
            case "help":
                XomControlConnection.SendMessage(
                        "UPS help\r\n" +
                        "  UpsGetProfile  -- retrieve UPS profile attributes for the given membername or puid\r\n\r\n",
                        args.RequestId);
                args.Handled = true;
                break;

            case "upsgetprofile":
                if ( args.CommandArgs.Length == 0 )
                {
                    XomControlConnection.SendMessage( "Usage: UpsGetProfile <membername|puid>\r\n\r\n", args.RequestId );
                }
                else
                {
                    ulong puid = 0;

                    try
                    {
                        string userText = args.CommandArgs[0];
                        if ( userText.IndexOf("@") == -1 )
                        {
                            puid = SafeConvert.ToUInt64(userText);
                        }

                        if ( puid == 0 )
                        {
                            PassportClientBase pp = PassportClientGlobal.Global;
                            puid = pp.GetPassportPuid(userText);
                        }

                        if ( puid == 0 )
                        {
                            XomControlConnection.SendMessage( "Usage: UpsGetProfile: " + userText + " is not a valid membername or puid!", args.RequestId );
                            break;
                        }
                        else
                        {
                            string attributes = String.Join(",", new string[] {
                                "Personal_CS.Birthdate",
                                "Addresses_CS.Home_Region",
                                "xbox.gamertag"
                            });

                            IUpsClient iUps = UpsClientGlobal.Global;

                            string profileXml;
                            iUps.GetProfile(puid, attributes, out profileXml);

                            UpsProfile profile = new UpsProfile(profileXml);

                            string birthdateText;
                            if ( !profile.GetAttributeString("Personal_CS", "Birthdate", out birthdateText) )
                            {
                                birthdateText = "<not found>";
                            }
                            else
                            {
                                DateTime birthdate;
                                UpsUtil.ParseBirthdate(birthdateText, out birthdate);
                                birthdateText = birthdate.ToString("d");
                            }

                            string gamertag;
                            if ( !profile.GetAttributeString("xbox", "gamertag", out gamertag) )
                            {
                                gamertag = "<not found>";
                            }

                            string countryText;
                            if ( !profile.GetAttributeString("Addresses_CS", "Home_Region", out countryText) )
                            {
                                countryText = "<not found>";
                            }

                            XomControlConnection.SendMessage( "UpsProfile for user: 0x" + puid.ToString("x") + "\r\n", args.RequestId );
                            XomControlConnection.SendMessage( "    Country: " + countryText + "\r\n", args.RequestId );
                            XomControlConnection.SendMessage( "   Gamertag: " + gamertag + "\r\n", args.RequestId );
                            XomControlConnection.SendMessage( "  Birthdate: " + birthdateText + "\r\n", args.RequestId );
                            XomControlConnection.SendMessage( "\r\n", args.RequestId );

                        }
                    }
                    catch (Exception e)
                    {
                        XomControlConnection.SendMessage( "UpsGetProfile: caught exception: " + e.ToString(), args.RequestId );
                        XomControlConnection.SendMessage( "\r\n\r\n", args.RequestId );
                    }
                }
                args.Handled = true;
                break;
            }
        }

        protected FastFailHelper _fastFailHelper = null;

        protected string _partnerId = null;
        protected string _url = null;
        protected X509Certificate _cert = null;
        protected WebProxy _proxy = null;
    }

    // Utility class to read and write to the Ups profile xml blob
    public class UpsProfile
    {
        public UpsProfile(string profileXml)
        {
            Init(profileXml);
        }

        public UpsProfile(ulong puid)
        {
            Init(puid);
        }

        public string Xml
        {
            get { return _xml.OuterXml; }
        }

        protected void Init(string profileXml)
        {
            // Load xml document
            _xml = new XmlDocument();
            _xml.LoadXml(profileXml);

            // Load namespaces
            _nsm = new XmlNamespaceManager(_xml.NameTable);
            _nsm.AddNamespace("p", _passportUserNs);

            // Get the userData element node
            _userDataNode = _xml.SelectSingleNode("/p:userData", _nsm);
            if(_userDataNode == null)
                throw new Exception("Cannot find 'userData' element in profile xml");
        }

        protected void Init(ulong puid)
        {
            _xml = new XmlDocument();
            _nsm = new XmlNamespaceManager(_xml.NameTable);
            _nsm.AddNamespace("p", _passportUserNs);

            // Create an empty profile xml
            _userDataNode = _xml.CreateElement("p:userData", _passportUserNs);
            _xml.AppendChild(_userDataNode);
            XmlNode dataOwnerNode = _xml.CreateElement("p:dataOwner", _passportUserNs);
            dataOwnerNode.InnerText = puid.ToString("X016");
            _userDataNode.AppendChild(dataOwnerNode);
        }

        public ulong GetPassportPuid()
        {
            XmlNode node;

            if((node = _xml.SelectSingleNode("/p:userData/p:dataOwner", _nsm)) == null)
                throw new Exception("Cannot find passport-puid in profile xml");

            return Convert.ToUInt64(node.InnerText, 16);
        }

        protected XmlNode GetAttributeNode(string namespc, string attributeName)
        {
            XmlNode node;

            namespc       = namespc.ToUpper();
            attributeName = attributeName.ToUpper();

            node = _xml.SelectSingleNode(
                string.Format("/p:userData/p:propertyCollection[@name=\"{0}\"]/p:property[@name=\"{1}\"]",
                namespc, attributeName), _nsm);

            if(node == null)
                throw new Exception(string.Format("Cannot find attribute {0}.{1} in profile xml:\n", namespc, attributeName));

            return node;
        }

        public bool GetAttributeString(
            string namespc,
            string attributeName,
            out string value
        )
        {
            XmlNode node = GetAttributeNode(namespc, attributeName);

            string attributeType = node.Attributes["datatype"].Value.ToLower();

            if(attributeType == "nil")
            {
                value  = string.Empty;
                return false;
            }
            else if(attributeType == "string" || attributeType == "bstr")
            {
                value = node.InnerText;
                return true;
            }
            else
            {
                throw new Exception(string.Format("Attribute {0}.{1} is not string. Profile xml:", namespc, attributeName));
            }
        }

        public bool GetAttributeInt(
            string namespc,
            string attributeName,
            out int value
        )
        {
            XmlNode node = GetAttributeNode(namespc, attributeName);

            string attributeType = node.Attributes["datatype"].Value.ToLower();

            if(attributeType == "nil")
            {
                value  = 0;
                return false;
            }
            else if(attributeType == "i4")
            {
                value = Convert.ToInt32(node.InnerText);
                return true;
            }
            else
            {
                throw new Exception(string.Format("Attribute {0}.{1} is not valid Int. Profile xml:", namespc, attributeName));
            }
        }

        protected void AppendAttribute(string namespc, string attributeName, string datatype, string value)
        {
            XmlNode attributeNode;
            XmlNode namespcNode;
            XmlAttribute attribute;

            namespc       = namespc.ToUpper();
            attributeName = attributeName.ToUpper();
            datatype      = datatype.ToLower();

            namespcNode = _xml.SelectSingleNode(
                string.Format("/p:userData/p:propertyCollection[@name=\"{0}\"]", namespc), _nsm);

            if(namespcNode == null)
            {
                namespcNode = _xml.CreateElement("p:propertyCollection", _passportUserNs);
                attribute = _xml.CreateAttribute("name");
                attribute.Value = namespc;
                namespcNode.Attributes.Append(attribute);
                _userDataNode.AppendChild(namespcNode);
            }

            attributeNode = namespcNode.SelectSingleNode(
                string.Format("p:property[@name=\"{0}\"]", attributeName), _nsm);

            if(attributeNode == null)
            {
                attributeNode = _xml.CreateElement("p:property", _passportUserNs);
                namespcNode.AppendChild(attributeNode);
            }

            attribute = _xml.CreateAttribute("name");
            attribute.Value = attributeName;
            attributeNode.Attributes.Append(attribute);

            attribute = _xml.CreateAttribute("datatype");
            attribute.Value = datatype;
            attributeNode.Attributes.Append(attribute);

            attributeNode.InnerText = value;
        }

        public void AppendAttributeString(string namespc, string attributeName, string value)
        {
            if(value == null)
                AppendAttribute(namespc, attributeName, "nil", string.Empty);
            else
                AppendAttribute(namespc, attributeName, "string", value);
        }

        // GetPassportAndUpsProfiles
        // Updating a user's profile in UPS might require a trip to passport
        // and one to UPS. You knew that, right? This method will generate the
        // XML profiles for each trip.
        // Either one (or both) of the returned XML profiles might be null which
        // means that there's nothing to be updated there.
        public void GetPassportAndUpsProfiles(out string upsProfile, out string passportProfile)
        {
            // Updating stuff in UPS is a mess. The core namespace can only be
            // updated via passport while the xbox namespace can only be updated
            // through UPS. Let's build a separate profile object for each trip.

            UInt64     puid      = GetPassportPuid();
            UpsProfile pprof     = new UpsProfile(puid);
            UpsProfile uprof     = new UpsProfile(puid);
            bool       fhasU     = false;
            bool       fhasP     = false;

            XmlNodeList nspaces = _xml.SelectNodes("/p:userData/p:propertyCollection", _nsm);

            // Enumerate namespaces
            foreach(XmlNode nspace in nspaces)
            {
                string nsname       = nspace.Attributes["name"].Value;
                XmlNodeList attribs = nspace.SelectNodes("p:property", _nsm);
                bool fuseP          = false;

                // Core namespaces go to passport, xbox namespace goes to UPS.
                // We don't support anything else.
                switch(nsname.ToUpper())
                {
                case "PERSONAL_CS":
                case "PERSONAL2_CS":
                case "ADDRESSES_CS":
                    fuseP=true;
                    fhasP=true;
                    break;

                case "XBOX":
                    fuseP=false;
                    fhasU=true;
                    break;

                default:
                    throw new Exception("Invalid namespace: "+nsname);
                }

                foreach(XmlNode attrib in attribs)
                {
                    string aname  = attrib.Attributes["name"].Value;
                    string atype  = attrib.Attributes["datatype"].Value;
                    string avalue = attrib.InnerText;

                    if(atype == null)
                    {
                        atype  = "string";
                    }

                    // Add the attribute to the corresponding profile object.
                    if(fuseP)
                    {
                        // One more thing. In the request to passport, we gotta
                        // replace all the underscores with dots.
                        aname = aname.Replace('_', '.');
                        pprof.AppendAttribute(nsname, aname, atype, avalue);
                    }
                    else
                    {
                        uprof.AppendAttribute(nsname, aname, atype, avalue);
                    }
                }
            }

            upsProfile      = fhasU ? uprof.Xml : null;
            passportProfile = fhasP ? pprof.Xml : null;
        }

        protected static string _passportUserNs = "http://schemas.microsoft.com/Passport/User";
        protected XmlDocument _xml;
        protected XmlNamespaceManager _nsm;
        protected XmlNode _userDataNode;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\marketplace\billing\VoucherUtil.cs ===
using System;
using System.Security.Cryptography;
using System.Text;
using System.Text.RegularExpressions;

using xonline.common.audit;
using xonline.common.config;
using xonline.common.mgmt;
using xonline.common.service;
using xonline.common.sql.webstore;

using Microsoft.Webstore.WstClient;

namespace xonline.common.billing
{

    public enum VoucherStatusEnum
    {
        Active = 0,
        Disabled = 1
    }

    public enum BillingTokenStatusEnum
    {
        Invalid = -1,
        Available = 0,
        Pending = 1,
        Activated = 2,
        Consumed = 3,
    }

    public class VoucherUtil
    {
        // this is the hashed value of "1111111111111111111111111"
        //
        static byte[] _fakeHash = new byte[] { 0x46, 0x0D, 0x1A, 0xBD, 0x93, 0x38, 0x33, 0xBA, 0xD5, 0x4F, 0x47, 0xBC, 0x83, 0xB0, 0x42, 0x26, 0xE9, 0xC9, 0x62, 0x23 };

        private static string token5x5Regex =
            "([a-zA-Z0-9]{5}-[a-zA-Z0-9]{5}-[a-zA-Z0-9]{5}-[a-zA-Z0-9]{5}-[a-zA-Z0-9]{5}|[a-zA-Z0-9]{25})";

        public static string CanonicalizeToken(string token)
        {
            if (!Regex.IsMatch(token, token5x5Regex))
            {
                throw new XRLExceptionWithoutEvent(HResult.XONLINE_E_ACCOUNTS_INVALID_VOUCHER, "VoucherUtil.CanonicalizeToken: token is not a valid 5x5 code");
            }

            // convert to upper case
            token = token.ToUpper();

            // insert dashes (if necessary)
            if (token[5] != '-')
            {
                // insert dashes (thank you windows.net)
                token = token.Insert(20, "-");
                token = token.Insert(15, "-");
                token = token.Insert(10, "-");
                token = token.Insert(5, "-");
            }

            return token;
        }

        public static byte[] GetSha256TokenHash(string token)
        {
            if ( token == null )
            {
                throw new ArgumentException("token");
            }

            using (SHA256CryptoServiceProvider sha256 = new SHA256CryptoServiceProvider())
            {
                UnicodeEncoding enc = new UnicodeEncoding();

                byte[] keyBytes = enc.GetBytes(CanonicalizeToken(token) + "\0");

                byte[] sha256Hash = sha256.ComputeHash(keyBytes);

                // _fakeHash contains the SHA1 hash of the "11111-11111-11111-11111-11111" token
                if (sha256Hash.Length > _fakeHash.Length)
                {
                    byte[] truncatedHash = new byte[_fakeHash.Length];

                    Array.Copy(sha256Hash, truncatedHash, _fakeHash.Length);

                    return truncatedHash;
                }
                else
                {
                    return sha256Hash;
                }
            }
        }

        public static byte[] GetSha1TokenHash(string token)
        {
            if (token == null)
            {
                // no voucher specified, fake it
                return _fakeHash;
            }

            using (SHA1CryptoServiceProvider sha1 = new SHA1CryptoServiceProvider())
            {
                UnicodeEncoding enc = new UnicodeEncoding();

                byte[] keyBytes = enc.GetBytes(CanonicalizeToken(token) + "\0");

                return sha1.ComputeHash(keyBytes);
            }
        }

        public static bool IsLiveGeneratedToken(string token)
        {
            string canonicalizedToken = CanonicalizeToken(token);
            // All live generated token will ends with "Z".
            return (canonicalizedToken.EndsWith("Z", StringComparison.InvariantCultureIgnoreCase));
        }

        public static byte[] GetVoucherHash(string voucherCode)
        {
            if (IsLiveGeneratedToken(voucherCode))
            {
                return GetSha256TokenHash(voucherCode);
            }
            else
            {
                return GetSha1TokenHash(voucherCode);
            }
        }

        public static void GetTokenHash(string token, out byte[] tokenHash, out bool isLiveGenerated)
        {
            if ( IsLiveGeneratedToken(token) )
            {
                isLiveGenerated = true;
                tokenHash = GetSha256TokenHash(token);
            }
            else
            {
                isLiveGenerated = false;
                tokenHash = GetSha1TokenHash(token);
            }
        }

        public static HResult ValidateVoucher(byte[] voucherHash, byte countryId, out ulong offerId, out string billingOfferId)
        {
            bool isScsToken;
            return ValidateVoucher(voucherHash, countryId, out offerId, out billingOfferId, out isScsToken);
        }

        public static HResult ValidateVoucher(byte[] voucherHash, byte countryId, out ulong offerId, out string billingOfferId, out bool isScsToken)
        {
            HResult hr;
            int offerTypeId;
            byte voucherInScs = 0;
            string offerXml = string.Empty;
            int usedVoucherCount = -1;

            hr = 0;
            offerId = 0;
            offerTypeId = 0;
            billingOfferId = "";
            isScsToken = false;

            if (Config.GetBoolSetting(Setting.billing_allowFakeActivationCode) == false && IsFakeVoucher(voucherHash))
            {
                // don't 't allow fake vouchers!
                return HResult.XONLINE_E_ACCOUNTS_INVALID_VOUCHER;
            }

            //Get the voucher xml from tokendb
            hr=GetVoucherXmlByHash(voucherHash, out offerXml, out usedVoucherCount);
            if (HResult.Succeeded(hr))
            {
                //Validate the vouchers in UODB
                hr = ValidateOffer(offerXml, usedVoucherCount, voucherHash, countryId, out offerId, out offerTypeId, out billingOfferId, out voucherInScs, out isScsToken);
            }

            return hr;
        }

        public static HResult XeValidateToken(byte[] voucherHash, byte countryId, out ulong offerId, out int offerTypeId, out string billingOfferId)
        {
            HResult hr;
            byte voucherInSCG;
            string offerXml = string.Empty;
            int usedVoucherCount = -1;
            bool isScsToken = false;

            hr = 0;
            offerId = 0;
            offerTypeId = 0;
            voucherInSCG = 0;
            billingOfferId = "";

            if (Config.GetBoolSetting(Setting.billing_allowFakeActivationCode) == false && IsFakeVoucher(voucherHash))
            {
                // don't 't allow fake vouchers!
                return HResult.XONLINE_E_ACCOUNTS_INVALID_VOUCHER;
            }

            //Get the voucher xml from tokendb
            hr=GetVoucherXmlByHash(voucherHash, out offerXml, out usedVoucherCount);
            if (HResult.Succeeded(hr))
            {
                //Validate the vouchers in UODB
                hr = ValidateOffer(offerXml, usedVoucherCount, voucherHash, countryId, out offerId, out offerTypeId, out billingOfferId, out voucherInSCG, out isScsToken);
            }
            return hr;
        }

        private static HResult ValidateOffer(string offerXml, int usedVoucherCount, byte[] voucherHash, byte countryId, out ulong offerId, out int offerTypeId, out string billingOfferId, out byte voucherInSCG,out bool isScsToken)
        {
            HResult hr;
            hr = 0;
            offerId = 0;
            offerTypeId = 0;
            voucherInSCG = 0;
            isScsToken = false;
            billingOfferId = "";

            using (WSClient ws = new WSClient(ConfigUtil.UodbWebstoreApp, CmdType.WRITETHENREAD_COMMANDTYPE))
            {
                ws.StoredProc = "dbo.p_verify_valid_offer";
                ws.Partition = WstCommand.AnyPartition;
                ws.AddParameter(ParamType.RETVAL, "@RETVAL", hr);
                ws.AddParameter("@ti_country_id", countryId);
                ws.AddParameter("@offerid", offerXml == null?string.Empty:offerXml);
                ws.AddParameter("@used_voucher", usedVoucherCount);
                ws.AddParameter(ParamType.OUTPUT, "@bi_offer_id", offerId);
                ws.AddParameter(ParamType.OUTPUT, "@i_offer_type_id", offerTypeId);
                ws.AddParameter(ParamType.OUTPUT, "@f_in_scg", voucherInSCG);
                ws.AddParameter(ParamType.OUTPUT, "@vc_billing_offer_id", billingOfferId, 36);
                ws.ExecuteNonQuery();

                hr = (uint)ws.GetIntParameter("@RETVAL");
                if (HResult.Succeeded(hr))
                {
                    offerId = (ulong)ws.GetLongParameter("@bi_offer_id");
                    offerTypeId = ws.GetIntParameter("@i_offer_type_id");
                    voucherInSCG = (byte)ws.GetByteParameter("@f_in_scg");
                    isScsToken = (voucherInSCG != 0);
                    billingOfferId = ws.GetStringParameter("@vc_billing_offer_id");
                }
            }
            return hr;
        }
        private static HResult GetVoucherXmlByHash(byte[] voucherHash, out string offerXml, out int usedVoucherCount)
        {
            offerXml = string.Empty;
            usedVoucherCount = 0;
            HResult hr;
            hr = 0;
            using (WSClient ws = new WSClient(ConfigUtil.TokendbWebstoreApp, CmdType.WRITETHENREAD_COMMANDTYPE))
            {
                ws.StoredProc = "dbo.p_xuacs_get_voucher_byhash";
                ws.SetHashVal(BitConverter.ToInt64(voucherHash, 0));
                ws.AddParameter(ParamType.RETVAL, "@RETVAL", hr);
                ws.AddParameter("@bin_voucher_hash", voucherHash);
                ws.AddParameter(ParamType.OUTPUT, "@offerxml", offerXml,-1);
                ws.AddParameter(ParamType.OUTPUT, "@used_voucher_count", usedVoucherCount);
                ws.ExecuteNonQuery();
                //get the outout parameters
                offerXml = ws.GetStringParameter("@offerxml");
                usedVoucherCount = ws.GetIntParameter("@used_voucher_count");
                hr = (uint)ws.GetIntParameter("@RETVAL");
            }
            return hr;
        }

        public static HResult ValidateEmsToken(byte[] tokenHash, out string offerId, out int mediaTypeId, out bool isScsToken)
        {
            string pkpn = null;
            return ValidateEmsToken(tokenHash, out offerId, out mediaTypeId, out isScsToken, out pkpn);
        }

        public static HResult ValidateEmsToken(byte[] tokenHash, out string offerId, out int mediaTypeId, out bool isScsToken, out string pkpn)
        {
            offerId = null;
            mediaTypeId = 0;
            isScsToken = false;
            pkpn = null;

            // Looking for the token in xbox live tables first, then the RMS table.
            HResult hr = ValidateEmsTokenFromXboxLive(tokenHash, out offerId, out mediaTypeId, out isScsToken, out pkpn);
            if (hr == HResult.XONLINE_E_ACCOUNTS_INVALID_VOUCHER)
            {
                hr = ValidateEmsTokenFromRsm(tokenHash, out offerId, out mediaTypeId, out isScsToken);
            }
            return hr;
        }

        // This function looks for the token in t_tokens_v2 table, which holds Xbox Live generated token
        private static HResult ValidateEmsTokenFromXboxLive(byte[] tokenHash, out string offerId, out int mediaTypeId, out bool isScsToken, out string pkpn)
        {
            HResult hr = HResult.E_FAIL;
            offerId = null;
            mediaTypeId = 0;
            pkpn = null;
            isScsToken = false;
            bool isRevenueBearing = false;
            bool isRoyaltyBearing = false;
            using (WSClient ws = new WSClient(ConfigUtil.TokendbWebstoreApp, CmdType.WRITETHENREAD_COMMANDTYPE))
            {
                ws.StoredProc = "dbo.p_validate_token";
                ws.SetHashVal(BitConverter.ToInt64(tokenHash, 0));

                ws.AddParameter(ParamType.RETVAL, "@hr", hr);
                ws.AddParameter("@bin_token_hash", tokenHash);

                using (WstDataReader r = ws.Execute())
                {
                    if ( r.Read() )
                    {
                        offerId = r.GetGuid(0).ToString();
                        mediaTypeId = r.GetInt32(1);
                        pkpn = r.GetString(2);
                        isScsToken = (r.GetByte(3) != 0);
                        isRevenueBearing = (r.GetByte(4) != 0);
                        isRoyaltyBearing = (r.GetByte(5) != 0);
                    }
                }

                // in addition to POSA tokens, LIVE-generated tokens should also be treated as tokens
                // within CTP if they are revenue- or royalty-bearing
                isScsToken = isScsToken || isRevenueBearing || isRoyaltyBearing;

                hr = (uint)ws.GetIntParameter("@hr");
            }

            return hr;
        }

        // This function looks for the token in t_tokens table, which holds RSM generated token
        private static HResult ValidateEmsTokenFromRsm(byte[] tokenHash, out string offerId, out int mediaTypeId, out bool isScsToken)
        {
            HResult hr = HResult.E_FAIL;

            offerId = null;
            mediaTypeId = 0;
            isScsToken = false;

            byte tokenInScs = 0;

            using (WSClient ws = new WSClient(ConfigUtil.TokendbWebstoreApp, CmdType.WRITETHENREAD_COMMANDTYPE))
            {
                ws.StoredProc = "dbo.p_xuacs_validate_token";
                ws.SetHashVal(BitConverter.ToInt64(tokenHash, 0));

                ws.AddParameter(ParamType.RETVAL, "@hr", hr);
                ws.AddParameter("@bin_token_hash", tokenHash);
                ws.AddParameter(ParamType.OUTPUT, "@vc_offer_id", offerId, 36);
                ws.AddParameter(ParamType.OUTPUT, "@i_media_type_id", mediaTypeId);
                ws.AddParameter(ParamType.OUTPUT, "@f_in_scg", tokenInScs);

                ws.ExecuteNonQuery();

                hr = (uint)ws.GetIntParameter("@hr");
                if (HResult.Succeeded(hr))
                {
                    offerId = ws.GetStringParameter("@vc_offer_id");
                    mediaTypeId = ws.GetIntParameter("@i_media_type_id");
                    tokenInScs = ws.GetByteParameter("@f_in_scg");
                    isScsToken = tokenInScs != 0;
                }
            }

            return hr;
        }

        public static HResult AddXboxLiveToken(byte[] tokenHash, int useCount, int status, Guid tokenCategoryId, Guid jobId, int sequenceNumber)
        {
            HResult hr = HResult.E_FAIL;
            using (WSClient ws = new WSClient(ConfigUtil.TokendbWebstoreApp, CmdType.WRITEONLY_COMMANDTYPE))
            {
                ws.ClearParameters();
                ws.StoredProc = "dbo.p_add_token";
                ws.SetHashVal(BitConverter.ToInt64(tokenHash, 0));
                ws.AddParameter(ParamType.RETVAL, "@RETVAL", hr);
                ws.AddParameter("@bin_token_hash", tokenHash);
                ws.AddParameter("@i_use_count", useCount);
                ws.AddParameter("@i_token_status_id", status);
                ws.AddParameter("@f_console_version", 2);
                ws.AddParameter("@si_hash_bucket", ws.Partition);
                ws.AddParameter("@uid_token_category_id", tokenCategoryId);
                ws.AddParameter("@uid_job_id", jobId);
                ws.AddParameter("@i_sequence_number", sequenceNumber);
                ws.ExecuteNonQuery();
                hr = (uint)ws.GetIntParameter("@RETVAL");
            }
            return hr;
        }

        public static uint RegisterVoucherUse(byte[] voucherHash, ulong userPuid)
        {
            WSClient ws = null;

            if (IsFakeVoucher(voucherHash) == true)
            {
                if (Config.GetBoolSetting(Setting.billing_allowFakeActivationCode) == true)
                {
                    // no need to register fake vouchers
                    return 0x0;
                }

                // don't 't allow fake vouchers!
                return HResult.XONLINE_E_ACCOUNTS_INVALID_VOUCHER;
            }

            try
            {
                ws = new WSClient(ConfigUtil.TokendbWebstoreApp, CmdType.WRITEONLY_COMMANDTYPE);
                ws.StoredProc = "dbo.p_xuacs_use_voucher";
                ws.SetHashVal(BitConverter.ToInt64(voucherHash, 0));

                ws.AddParameter(ParamType.RETVAL, "@RETVAL", (uint)0);
                ws.AddParameter("@bin_voucher_hash", voucherHash);
                ws.AddParameter("@bi_user_puid", userPuid);
                ws.AddParameter("@si_hash_bucket", ws.Partition);

                ws.ExecuteNonQuery();

                return (uint)ws.GetIntParameter("@RETVAL");
            }
            finally
            {
                if (ws != null)
                {
                    ws.Close();
                    ws = null;
                }
            }
        }

        public static uint UnregisterVoucherUse(byte[] voucherHash, ulong userPuid)
        {
            using (WSClient ws = new WSClient(ConfigUtil.TokendbWebstoreApp, CmdType.WRITEONLY_COMMANDTYPE))
            {
                ws.StoredProc = "dbo.p_xuacs_unuse_voucher";
                ws.SetHashVal(BitConverter.ToInt64(voucherHash, 0));

                ws.AddParameter(ParamType.RETVAL, "@hr", (uint)0);
                ws.AddParameter("@bin_voucher_hash", voucherHash);
                ws.AddParameter("@bi_user_puid", userPuid);

                ws.ExecuteNonQuery();

                return (uint)ws.GetIntParameter("@hr");
            }
        }

        public static uint RegisterEmsTokenUse(byte[] tokenHash, ulong userPuid)
        {
            using (WSClient ws = new WSClient(ConfigUtil.TokendbWebstoreApp, CmdType.WRITEONLY_COMMANDTYPE))
            {
                return RegisterEmsTokenUse(ws, tokenHash, userPuid);
            }
        }

        public static uint RegisterEmsTokenUse(WSClient ws, byte[] tokenHash, ulong userPuid)
        {
            ws.StoredProc = "dbo.p_xuacs_use_token";
            ws.SetHashVal(BitConverter.ToInt64(tokenHash, 0));

            ws.AddParameter(ParamType.RETVAL, "@hr", (uint)0);
            ws.AddParameter("@bin_token_hash", tokenHash);
            ws.AddParameter("@bi_user_puid", userPuid);
            ws.AddParameter("@si_hash_bucket", ws.Partition);

            ws.ExecuteNonQuery();

            return (uint)ws.GetIntParameter("@hr");
        }

        public static bool IsFakeVoucher(byte[] voucherHash)
        {
            if (voucherHash.Length != _fakeHash.Length)
            {
                return false;
            }

            for (int i = 0; i < voucherHash.Length; i++)
            {
                if (voucherHash[i] != _fakeHash[i])
                    return false;
            }

            return true;
        }

        public static void GetUnactivatedBillingToken(ulong offerId, out string billingToken, out string tokenSequenceNumber)
        {
            billingToken = string.Empty;
            tokenSequenceNumber = string.Empty;

            using (WSClient ws = new WSClient(ConfigUtil.TokendbWebstoreApp, CmdType.WRITEONLY_COMMANDTYPE))
            {
                // Data is partitioned by user puid
                ws.PartitionType = WstPartitionType.Logical;
                ws.SetHashVal(offerId);

                ws.StoredProc = "dbo.p_xuacs_get_unactivated_billing_token";

                ws.AddParameter(ParamType.RETVAL, "@hr", 0);
                ws.AddParameter("@bi_offer_id", offerId);
                ws.AddParameter(ParamType.OUTPUT, "@vc_billing_token", string.Empty, 29);
                ws.AddParameter(ParamType.OUTPUT, "@vc_sequence_number", string.Empty, 15);

                ws.ExecuteNonQuery();

                HResult hr = (uint)ws.GetIntParameter("@hr");
                if (HResult.Failed(hr))
                {
                    string msg = ws.GetCallSignature() + " failed with hr = " + hr;
                    throw new XRLException(hr, XEvent.Id.COMMON_BILLING_CODE_215, msg);
                }

                billingToken = ws.GetStringParameter("@vc_billing_token");
                tokenSequenceNumber = ws.GetStringParameter("@vc_sequence_number");
            }
        }

        public static void ActivateBillingToken(string tokenSequenceNumber)
        {
            BillingProvider bp = new BillingProvider();

            if (BillingConfig.ConnectToBilling == false)
            {
                return;
            }

            try
            {
                DateTime now = DateTime.UtcNow;

                string trackingGuid = Guid.NewGuid().ToString().ToUpper();
                string externalReferenceId = string.Empty;

                string timestamp = now.ToString("yyyy-MM-dd") + "T" + now.ToString("HH:mm:ss");

                bp.ActivateToken(
                    0x1,
                    0x1,
                    trackingGuid,
                    tokenSequenceNumber,
                    0,                      // tokenType is token sequence number
                    externalReferenceId,    // external reference id
                    timestamp,
                    0                       // ActivateToken called synchronously
                    );
            }
            catch (BillingProviderException bpe)
            {
                if (BdkError.BdkToXonlineHr(bpe) != HResult.XONLINE_E_BILLING_ALREADY_ACTIVATED)
                {
                    throw bpe;
                }
                else
                {
                    Xom.Trace(XomAreaName.spstrace, LogLevel.L_HIGH, "ActivateBillingToken: token " + tokenSequenceNumber + " is already activated -- ignoring ActivateToken exception.  This should only happen in test environments.");
                }
            }
        }

        public static int GetUnactivatedBillingTokenStatus(ulong offerId, string billingToken)
        {
            int tokenStatusId = -1;

            using (WSClient ws = new WSClient(ConfigUtil.TokendbWebstoreApp, CmdType.WRITETHENREAD_COMMANDTYPE))
            {
                // Data is partitioned by user puid
                ws.PartitionType = WstPartitionType.Logical;
                ws.SetHashVal(offerId);

                ws.StoredProc = "dbo.p_xuacs_get_unactivated_billing_token_status";

                ws.AddParameter(ParamType.RETVAL, "@hr", 0);
                ws.AddParameter("@vc_billing_token", billingToken);
                ws.AddParameter(ParamType.OUTPUT, "@i_token_status_id", 0);
                ws.ExecuteNonQuery();

                HResult hr = (uint)ws.GetIntParameter("@hr");
                if (HResult.Failed(hr))
                {
                    string msg = ws.GetCallSignature() + " failed with hr = " + hr;
                    throw new XRLException(hr, XEvent.Id.COMMON_BILLING_CODE_216, msg);
                }

                tokenStatusId = ws.GetIntParameter("@i_token_status_id");

                return tokenStatusId;
            }
        }

        public static void SetUnactivatedBillingTokenStatus(ulong offerId, string billingToken, int tokenStatusId)
        {
            SetUnactivatedBillingTokenStatus(offerId, billingToken, tokenStatusId, 0);
        }

        public static void SetUnactivatedBillingTokenStatus(ulong offerId, string billingToken, int tokenStatusId, ulong userPuid)
        {
            using (WSClient ws = new WSClient(ConfigUtil.TokendbWebstoreApp, CmdType.WRITEONLY_COMMANDTYPE))
            {
                // Data is partitioned by user puid
                ws.PartitionType = WstPartitionType.Logical;
                ws.SetHashVal(offerId);

                ws.StoredProc = "dbo.p_xuacs_set_unactivated_billing_token_status";

                ws.AddParameter(ParamType.RETVAL, "@hr", 0);
                ws.AddParameter("@vc_billing_token", billingToken);
                ws.AddParameter("@i_token_status_id", tokenStatusId);
                ws.AddParameter("@bi_user_puid", userPuid);
                ws.ExecuteNonQuery();

                HResult hr = (uint)ws.GetIntParameter("@hr");
                if (HResult.Failed(hr))
                {
                    string msg = ws.GetCallSignature() + " failed with hr = " + hr;
                    throw new XRLException(hr, XEvent.Id.COMMON_BILLING_CODE_217, msg);
                }
            }
        }

        public static void VerifyOfferExistence(ulong offerId)
        {
            using (WSClient ws = new WSClient(ConfigUtil.UodbWebstoreApp, CmdType.READONLY_COMMANDTYPE))
            {
                // Data is partitioned by offer id
                ws.Partition = WstCommand.AnyPartition;
                ws.StoredProc = "dbo.p_verify_offer_exists";
                ws.AddParameter(ParamType.RETVAL, "@hr", 0);
                ws.AddParameter("@bi_offer_id", offerId);
                HResult hr = (uint)ws.GetIntParameter("@hr");
                if (HResult.Failed(hr))
                {
                    string msg = ws.GetCallSignature() + " failed with hr = " + hr;
                    throw new XRLException(hr, XEvent.Id.COMMON_BILLING_CODE_218, msg);
                }
            }
        }
        public static void AddUnactivatedBillingToken(ulong offerId, string billingToken, string sequenceNumber)
        {
            //Verify and raise an error if Offer does not exist
            VerifyOfferExistence(offerId);
            //Add unactivated voucher only if the offer verification passes.
            using (WSClient ws = new WSClient(ConfigUtil.TokendbWebstoreApp, CmdType.WRITEONLY_COMMANDTYPE))
            {
                // Data is partitioned by offer id
                ws.PartitionType = WstPartitionType.Logical;
                ws.SetHashVal(offerId);

                ws.StoredProc = "dbo.p_svc_add_unactivated_token";
                ws.AddParameter(ParamType.RETVAL, "@hr", 0);
                ws.AddParameter("@bi_offer_id", offerId);
                ws.AddParameter("@vc_billing_token", billingToken);
                ws.AddParameter("@vc_sequence_number", sequenceNumber);
                ws.AddParameter("@si_hash_bucket", ws.Partition);
                ws.ExecuteNonQuery();
            }

        }
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\marketplace\billing\UserAccountSoapWithAAInfo.cs ===
// -------------------------------------------------------------------------------
// class UserAccountWithAAInfo
//
// The wsdl generated class UserAccount (UserAccountSoap.cs) can't be used as is
// because it is hard-coded to a specific machine.
// This class provides an implementation that derives from UserAccount but uses 
// configuration information to send the request to the real Xuacs server plus
// adds needed headers to the request. 
// (Atleast the headers needed by GetUserAuthorization, the only method this is
// currently being used for).
// -------------------------------------------------------------------------------

using System;
using System.Net;
using System.Web;

using xonline.common.service;
using xonline.common.config;

namespace xonline.server.billing.useraccount.soap 
{
    public class UserAccountWithAAInfo : UserAccount
    {
        private string _authZHeader;
        private string _clientType; // "winmo" for XPLT_MOBILE or "xna" for XPLT_WEB_GAMES among others
        private string _urlPrefix;

        public UserAccountWithAAInfo( string clientType )
        {
            IVirtualInterfaceInfo viInfo = Config.GetVirtualInterface(VirtualInterface.xuacs_int, Config.SiteId);
            _urlPrefix = viInfo.Protocol + "://" + viInfo.IPAddressString + ":" + viInfo.Port;

            _authZHeader = HttpContextAdapter.Current.Request.Headers[XHttpHdr.AUTHZ];
            _clientType = clientType;

            Uri uri = new Uri(this.Url);
            this.Url = _urlPrefix + uri.LocalPath;
        }
        
        protected override WebRequest GetWebRequest(Uri uri)
        {
            WebRequest request = base.GetWebRequest(uri);
            request.Headers[XHttpHdr.AUTHZ] = _authZHeader;
            request.Headers["X-ClientType"] = _clientType;  

            return request;
        }
    } 
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\marketplace\billing\XMLCleanser.cs ===
/*
 * XmlCleanser.cs
 *
 * Copyright (c) Microsoft Corporation.  All Rights Reserved.
 *
 * Author: Ben Zotto (benzotto)
 *
 */
 
 
using System;
// using System.Text;
// using System.IO;
// using System.Xml;
 
 namespace xonline.common.billing
 {
 
    internal class XmlCleanser
    {
        public static string Cleanup(string s)
        {
            if(s == null)
            {
                return null;
            }
                               
                       
            // first replace all single quotes with backticks
            //
            s = s.Replace('\'', '`');
            
            // replace all other bad chars with space
            s = s.Replace('<', ' ');
            s = s.Replace('>', ' ');
            s = s.Replace('&', ' ');
            s = s.Replace(';', ' ');
            s = s.Replace('%', ' ');
                                    
            
            return s;
        }
                 
    }
        
 }
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\marketplace\billing\upsint.cs ===
﻿//------------------------------------------------------------------------------
// <autogenerated>
//     This code was generated by a tool.
//     Runtime Version: 1.1.4322.2032
//
//     Changes to this file may cause incorrect behavior and will be lost if 
//     the code is regenerated.
// </autogenerated>
//------------------------------------------------------------------------------

// 
// This source code was auto-generated by wsdl, Version=1.1.4322.2032.
// 
using System.Diagnostics;
using System.Xml.Serialization;
using System;
using System.Web.Services.Protocols;
using System.ComponentModel;
using System.Web.Services;

namespace xonline.common.billing.ups
{


/// <remarks/>
[System.Diagnostics.DebuggerStepThroughAttribute()]
[System.ComponentModel.DesignerCategoryAttribute("code")]
[System.Web.Services.WebServiceBindingAttribute(Name="UpsWebServiceSoap", Namespace="urn:UpsWebService")]
public class UpsWebService : System.Web.Services.Protocols.SoapHttpClientProtocol {
    
    public WSSecurityHeader WSSECURITYHEADERValue;
    
    /// <remarks/>
    public UpsWebService() {
        this.Url = "http://profileservice.msn-int.com:80/UpsWebSvc/UpsWebSvc.dll?Handler=Default";
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapHeaderAttribute("WSSECURITYHEADERValue")]
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("#GetProfileByAttributes", RequestNamespace="urn:UpsWebService", ResponseNamespace="urn:UpsWebService")]
    [return: System.Xml.Serialization.SoapElementAttribute("ppbstrProfileXMLArray")]
    public string[] GetProfileByAttributes(string[] pbstrNetIDArray, string bstrAttribList, System.UInt32 ulFlags, out string pbstrErrorBlob) {
        object[] results = this.Invoke("GetProfileByAttributes", new object[] {
                    pbstrNetIDArray,
                    bstrAttribList,
                    ulFlags});
        pbstrErrorBlob = ((string)(results[1]));
        return ((string[])(results[0]));
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginGetProfileByAttributes(string[] pbstrNetIDArray, string bstrAttribList, System.UInt32 ulFlags, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("GetProfileByAttributes", new object[] {
                    pbstrNetIDArray,
                    bstrAttribList,
                    ulFlags}, callback, asyncState);
    }
    
    /// <remarks/>
    public string[] EndGetProfileByAttributes(System.IAsyncResult asyncResult, out string pbstrErrorBlob) {
        object[] results = this.EndInvoke(asyncResult);
        pbstrErrorBlob = ((string)(results[1]));
        return ((string[])(results[0]));
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapHeaderAttribute("WSSECURITYHEADERValue")]
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("#UpdateProfile", RequestNamespace="urn:UpsWebService", ResponseNamespace="urn:UpsWebService")]
    public void UpdateProfile(string[] pbstrProfileXMLArray) {
        this.Invoke("UpdateProfile", new object[] {
                    pbstrProfileXMLArray});
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginUpdateProfile(string[] pbstrProfileXMLArray, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("UpdateProfile", new object[] {
                    pbstrProfileXMLArray}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndUpdateProfile(System.IAsyncResult asyncResult) {
        this.EndInvoke(asyncResult);
    }
    
    /// <remarks/>
    [System.Web.Services.Protocols.SoapHeaderAttribute("WSSECURITYHEADERValue")]
    [System.Web.Services.Protocols.SoapRpcMethodAttribute("#DeleteProfile", RequestNamespace="urn:UpsWebService", ResponseNamespace="urn:UpsWebService")]
    public void DeleteProfile(string[] pbstrNetIDArray, string bstrPropertyCollectionList) {
        this.Invoke("DeleteProfile", new object[] {
                    pbstrNetIDArray,
                    bstrPropertyCollectionList});
    }
    
    /// <remarks/>
    public System.IAsyncResult BeginDeleteProfile(string[] pbstrNetIDArray, string bstrPropertyCollectionList, System.AsyncCallback callback, object asyncState) {
        return this.BeginInvoke("DeleteProfile", new object[] {
                    pbstrNetIDArray,
                    bstrPropertyCollectionList}, callback, asyncState);
    }
    
    /// <remarks/>
    public void EndDeleteProfile(System.IAsyncResult asyncResult) {
        this.EndInvoke(asyncResult);
    }
}

/// <remarks/>
[System.Xml.Serialization.SoapTypeAttribute("WSSecurityHeader", "urn:UpsWebService")]
public class WSSecurityHeader : SoapHeader {
    
    /// <remarks/>
    public EnumSHVersion version;
    
    /// <remarks/>
    public string wssecurity;
    
    /// <remarks/>
    public string authorization;
    
    /// <remarks/>
    public string sitetoken;
    
    /// <remarks/>
    public string ppSoapHeader25;
}

/// <remarks/>
[System.Xml.Serialization.SoapTypeAttribute("EnumSHVersion", "urn:UpsWebService")]
public enum EnumSHVersion {
    
    /// <remarks/>
    eshHeader30,
    
    /// <remarks/>
    eshHeader25,
    
    /// <remarks/>
    eshNone,
}

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\marketplace\billing\WholesaleInfo.cs ===
using System;
using System.Diagnostics;
using System.Xml;
using System.Text;
using System.IO;

using xonline.common.mgmt;
using xonline.common.protocol;
using xonline.common.service;

namespace xonline.common.billing
{
    public class WholesaleInfo
    {
        // The following fields must be filled in to Create an account.
        public string   AccountHolderName;
        public string   ExternalReferenceId;
        public string   WholesalePartner;
        public string   EncryptedPassword;

        public void FromXml(string xml, string rootNodeName)
        {
            XmlTextReader xmlReader = new XmlTextReader(new StringReader(xml));
            FromXml(xmlReader, rootNodeName);
            xmlReader.Close();
        }

        public void FromXml(XmlTextReader xmlReader, string rootNodeName)
        {
            xmlReader.MoveToContent();
            while (!xmlReader.EOF)
            {
                if (xmlReader.NodeType == XmlNodeType.EndElement &&
                    xmlReader.Name == rootNodeName)
                {
                    xmlReader.Skip();
                    break;
                }

                if (xmlReader.NodeType != XmlNodeType.Element)
                {
                    xmlReader.Skip();
                    continue;
                }

                switch (xmlReader.Name)
                {
                    case "AccountHolderName":
                        AccountHolderName = xmlReader.ReadElementString();
                        break;

                    case "ExternalPartnerId":
                        ExternalReferenceId = xmlReader.ReadElementString();
                        break;

                    case "WholesalePartner":
                        WholesalePartner = xmlReader.ReadElementString();
                        break;

                    case "WholesaleData":
                        WholesaleData wholesaleData = new WholesaleData();
                        wholesaleData.FromXml(xmlReader, "WholesaleData");
                        EncryptedPassword = wholesaleData.EncryptedPassword;
                        break;

                    default:
                        if (xmlReader.Name == rootNodeName)
                        {
                            // advance to the first inner element
                            xmlReader.ReadStartElement();
                            break;
                        }

                        Xom.Trace(XomAreaName.spstrace, LogLevel.L_NORMAL, "WholesaleInfo: Unrecognized Xml element: " + xmlReader.Name );
                        xmlReader.Skip();
                        break;
                }
            }
        }


        public string ToXml(string rootNodeName)
        {
            StringBuilder xmlBldr = new StringBuilder();
            ToXml(xmlBldr, rootNodeName);
            return xmlBldr.ToString();
        }

        public void ToXml(StringBuilder xmlBldr, string rootNodeName)
        {
            Debug.Assert(xmlBldr != null, "Invalid Argument");

            xmlBldr.Append("<" + (rootNodeName == null ? "WholesaleInfo" : rootNodeName) + " xmlns=\"urn:schemas-microsoft-com:billing-data\">");

            xmlBldr.Append("<AccountHolderName>");
            xmlBldr.Append(XmlCleanser.Cleanup(AccountHolderName));
            xmlBldr.Append("</AccountHolderName>");

            xmlBldr.Append("<ExternalPartnerId>");
            xmlBldr.Append(XmlCleanser.Cleanup(ExternalReferenceId));
            xmlBldr.Append("</ExternalPartnerId>");

            xmlBldr.Append("<WholesalePartner>");
            xmlBldr.Append(XmlCleanser.Cleanup(WholesalePartner));
            xmlBldr.Append("</WholesalePartner>");

            if (! string.IsNullOrEmpty(EncryptedPassword))
            {
                WholesaleData wholesaleData = new WholesaleData();
                wholesaleData.EncryptedPassword = EncryptedPassword;
                wholesaleData.ToXml(xmlBldr, "WholesaleData");
            }

            xmlBldr.Append("</WholesaleInfo>");
        }


        // Returns a new instance of DirectDebitInfoData populated with data
        // from the current DirectDebitInfo instance.
        public WholesaleInfoData ToWireData()
        {
            WholesaleInfoData wholesaleInfoData = new WholesaleInfoData();
             
            wholesaleInfoData.accountHolderName   = AccountHolderName;
            wholesaleInfoData.externalReferenceId = ExternalReferenceId;
            wholesaleInfoData.wholesalePartner    = WholesalePartner;
            wholesaleInfoData.encryptedPassword   = EncryptedPassword;

            return wholesaleInfoData;
        }

        // Populates DirectDebit property data with data from the given
        // DirectDebitInfoData instance.
        public void FromWireData(WholesaleInfoData wholesaleInfoData)
        {
            AccountHolderName   = wholesaleInfoData.accountHolderName;
            ExternalReferenceId = wholesaleInfoData.externalReferenceId;
            WholesalePartner    = wholesaleInfoData.wholesalePartner;
            EncryptedPassword   = wholesaleInfoData.encryptedPassword;
        }

        // validates required fieds have been set before generating xml.
        // (should this be debug only?)
        public void ValidateFields(bool isUpdate)
        {
            if (string.IsNullOrEmpty(AccountHolderName))    throw new XRLExceptionWithoutEvent(HResult.XONLINE_E_BILLING_ACCOUNT_HOLDER_NAME_NOT_FOUND_ERROR, "Missing WholesaleInfo.AccountHolderName");
            if (string.IsNullOrEmpty(ExternalReferenceId))  throw new XRLExceptionWithoutEvent(HResult.XONLINE_E_BILLING_EXTERNAL_REFERENCE_ID_NOT_FOUND, "Missing WholesaleInfo.ExternalReferenceId");
            if (string.IsNullOrEmpty(WholesalePartner))     throw new XRLExceptionWithoutEvent(HResult.XONLINE_E_BILLING_WHOLESALE_PARTNER_NOT_FOUND, "Missing WholesaleInfo.WholesalePartner");
            if (EncryptedPassword == null)                  throw new XRLExceptionWithoutEvent(HResult.XONLINE_E_BILLING_ENCRYPTED_PASSWORD_NOT_FOUND, "Missing WholesaleInfo.EncryptedPassword");
        }

        public override string ToString()
        {
            string a;

            a = "AccountHolderName: "     + AccountHolderName +
                "\nExternalReferenceId: " + ExternalReferenceId +
                "\nWholesalePartner: "    + WholesalePartner +
                "\nEncryptedPassword: "   + EncryptedPassword;

            return a;
        }
    }

    public class WholesaleData
	{
        public string EncryptedPassword;

        public void FromXml(string xml, string rootNodeName)
        {
            XmlTextReader xmlReader = new XmlTextReader(new StringReader(xml));
            FromXml(xmlReader, rootNodeName);
            xmlReader.Close();
        }

        public void FromXml(XmlTextReader xmlReader, string rootNodeName)
        {
            xmlReader.MoveToContent();
            while (!xmlReader.EOF)
            {
                if (xmlReader.NodeType == XmlNodeType.EndElement &&
                    xmlReader.Name == rootNodeName)
                {
                    xmlReader.Skip();
                    break;
                }

                if (xmlReader.NodeType != XmlNodeType.Element)
                {
                    xmlReader.Skip();
                    continue;
                }

                switch (xmlReader.Name)
                {
                    case "EncryptedPassword":
                        EncryptedPassword = xmlReader.ReadElementString();
                        break;

                    default:
                        if (xmlReader.Name == rootNodeName)
                        {
                            // advance to the first inner element
                            xmlReader.ReadStartElement();
                            break;
                        }

                        Xom.Trace(XomAreaName.spstrace, LogLevel.L_NORMAL, "WholesaleData: Unrecognized Xml element: " + xmlReader.Name);
                        xmlReader.Skip();
                        break;
                }
            }
        }

        public string ToXml(string rootNodeName)
        {
            StringBuilder xmlBldr = new StringBuilder();
            ToXml(xmlBldr, rootNodeName);
            return xmlBldr.ToString();
        }

        public void ToXml(StringBuilder xmlBldr, string rootNodeName)
        {
            Debug.Assert(xmlBldr != null, "Invalid Argument");

            xmlBldr.Append("<" + (rootNodeName == null ? "WholesaleData" : rootNodeName) + " xmlns=\"urn:schemas-microsoft-com:billing-data\">");

            xmlBldr.Append("<EncryptedPassword>");
            xmlBldr.Append(XmlCleanser.Cleanup(EncryptedPassword));
            xmlBldr.Append("</EncryptedPassword>");

            xmlBldr.Append("</WholesaleData>");
        }

        // validates required fieds have been set before generating xml.
        // (should this be debug only?)
        public void ValidateFields(bool isUpdate)
        {
            if (string.IsNullOrEmpty(EncryptedPassword)) throw new Exception("Missing WholesaleInfo.EncryptedPassword");
        }

        public override string ToString()
        {
            string a;

            a = "EncryptedPassword: " + EncryptedPassword;

            return a;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\marketplace\billing\CTP\CTPBehaviourInjection.cs ===
using System;
using System.Collections.Specialized;
using System.Net;
using System.Reflection;
using System.Web.Services.Protocols;

using xonline.common.service;

namespace xonline.common.billing
{
    public sealed class CTPTransactionFailure : BehaviorInjection
    {

        public static void Init()
        {
            // remove the dummy handler (if present)
            RequestHeaderBehaviorInjectionMgr.RemoveBehaviorInjectionFactory("ctptransactionfailure");
            // add the real handler
            RequestHeaderBehaviorInjectionMgr.AddBehaviorInjectionFactory("ctptransactionfailure", CTPTransactionFailure.Create, RequestHeaderBehaviorInjectionMgr.BehaviorInjectionFactoryFlags.None);
        }

        private CTPTransactionFailure(string injectionName, string specificParams, string genericParams)
            : base(injectionName, specificParams, genericParams)
        {
            NameValueCollection parameters = ParameterParsingUtil.ParseAsNameValuePairs(specificParams);

            string api = parameters["api"];

            if (string.IsNullOrEmpty(api))
            {
                throw new Exception(String.Format("ctpFailure must have an API name associated with it but none was found in '{0}'.", specificParams));
            }

            _api = api;

            _error = parameters["error"];
            string timeout = parameters["timeout"];

            bool _retryableNotnull = false;

            if (bool.TryParse(parameters["retryable"], out _retryableNotnull))
            {
                _retryable = _retryableNotnull;
            }
            else
            {
                _retryable = null;
            }

            if (string.IsNullOrEmpty(_error) && string.IsNullOrEmpty(timeout))
            {
                throw new Exception(String.Format("ctpFailure must have at least one of 'error' and 'timeout' but neither was found in '{0}'.", specificParams));
            }

            if (!string.IsNullOrEmpty(timeout))
            {
                _timeoutMillis = Int32.Parse(timeout);
            }
        }

        public static void HandleBehaviorInjection(string api, ref int timeout)
        {
            CTPTransactionFailure ctpFailure;
            if (RequestHeaderBehaviorInjectionMgr.TryGetBehaviorInjection("ctptransactionfailure", out ctpFailure))
            {
                ctpFailure.PerformFailureAction(api, ref timeout);
            }
        }

        public static CTPTransactionFailure Create(BehaviorRequest behaviorRequest)
        {
            return new CTPTransactionFailure(behaviorRequest.Name, behaviorRequest.SpecificParams, behaviorRequest.GenericParams);
        }

        public void PerformFailureAction(string api, ref int timeout)
        {
            if (api.Equals(_api, StringComparison.InvariantCultureIgnoreCase))
            {
                if (_timeoutMillis.HasValue)
                {
                    timeout = _timeoutMillis.Value;
                }
                else
                {
                    string ctpMessage = null;
                    int ctpErrorCode = 0;
                    if (_error.StartsWith("BDK_E_") || _error.StartsWith("TRANSACTION_E_") || _error.StartsWith("BILLING_E_"))
                    {
                        System.Type ctpErrType = typeof(CTPError);
                        FieldInfo fieldInfo = ctpErrType.GetField(_error.Trim());
                        if (fieldInfo == null)
                        {
                            ctpErrorCode = -1;
                        }
                        else
                        {
                            ctpErrorCode = (int)fieldInfo.GetValue(null);
                        }
                    }

                    CTPErrorDetail errorDetail = CTPError.GetErrorDetail(ctpErrorCode);

                    if (errorDetail != null)
                    {
                        string disclaimer = "This error was artificially injected due to an HTTP header in the incoming request and was not generated by CTP.";

                        ctpMessage = string.Format("<ErrorPackage><ErrorHResult>{0}</ErrorHResult><ErrorMessage>{1}</ErrorMessage><Retryable>{2}</Retryable><InjectedErrorDisclaimer>{3}</InjectedErrorDisclaimer>",
                            ctpErrorCode.ToString(),
                            (errorDetail.Message == null ? "" : errorDetail.Message),
                            (_retryable.HasValue ? _retryable.Value : errorDetail.Retryable),
                            disclaimer);

                        throw new CTPTransactionServiceException(null, ctpMessage, (_retryable.HasValue ? _retryable.Value : errorDetail.Retryable), errorDetail.CTPErrorCode);
                    }
                }
            }
        }

        string _api;
        int? _timeoutMillis;
        string _error;
        bool? _retryable;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\marketplace\billing\UserAccountSoap.cs ===
﻿//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:2.0.50727.4961
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

// 
// This source code was auto-generated by wsdl, Version=2.0.50727.42.
// 
namespace xonline.server.billing.useraccount.soap {
    using System.Xml.Serialization;
    using System.Web.Services;
    using System.ComponentModel;
    using System.Web.Services.Protocols;
    using System;
    using System.Diagnostics;
    
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Web.Services.WebServiceBindingAttribute(Name="UserAccountSoap", Namespace="urn:schemas-xbox-com:user-account-data")]
    [System.Xml.Serialization.XmlIncludeAttribute(typeof(WireData))]
    public partial class UserAccount : System.Web.Services.Protocols.SoapHttpClientProtocol {
        
        private System.Threading.SendOrPostCallback AcceptTermsOfServiceOperationCompleted;
        
        private System.Threading.SendOrPostCallback AddCreditCardOperationCompleted;
        
        private System.Threading.SendOrPostCallback GetPointsBalanceOperationCompleted;
        
        private System.Threading.SendOrPostCallback SignInOperationCompleted;
        
        private System.Threading.SendOrPostCallback ConsoleApplicationsGetByMachinePuidOperationCompleted;
        
        private System.Threading.SendOrPostCallback CreateMobileAccountOperationCompleted;
        
        private System.Threading.SendOrPostCallback EnumFamilyMembersOperationCompleted;
        
        private System.Threading.SendOrPostCallback GenerateGamertagOperationCompleted;
        
        private System.Threading.SendOrPostCallback GetPaymentInstrumentsOperationCompleted;
        
        private System.Threading.SendOrPostCallback GetSupportedCountriesOperationCompleted;
        
        private System.Threading.SendOrPostCallback GetUserAuthorizationOperationCompleted;
        
        private System.Threading.SendOrPostCallback GamertagHistoryGetOperationCompleted;
        
        private System.Threading.SendOrPostCallback UserHistoryGetOperationCompleted;
        
        private System.Threading.SendOrPostCallback MachineHistoryGetOperationCompleted;
        
        private System.Threading.SendOrPostCallback FamilyHistoryGetOperationCompleted;
        
        private System.Threading.SendOrPostCallback SetFreeGamertagEligibleOperationCompleted;
        
        private System.Threading.SendOrPostCallback SetFamilyGoldSeatExemptionOperationCompleted;
        
        private System.Threading.SendOrPostCallback TestConnectionOperationCompleted;
        
        private System.Threading.SendOrPostCallback UserAccountAuthorizeOperationCompleted;
        
        /// <remarks/>
        public UserAccount() {
            this.Url = "http://10.10.1.60/xuacs/useraccount.asmx";
        }
        
        /// <remarks/>
        public event AcceptTermsOfServiceCompletedEventHandler AcceptTermsOfServiceCompleted;
        
        /// <remarks/>
        public event AddCreditCardCompletedEventHandler AddCreditCardCompleted;
        
        /// <remarks/>
        public event GetPointsBalanceCompletedEventHandler GetPointsBalanceCompleted;
        
        /// <remarks/>
        public event SignInCompletedEventHandler SignInCompleted;
        
        /// <remarks/>
        public event ConsoleApplicationsGetByMachinePuidCompletedEventHandler ConsoleApplicationsGetByMachinePuidCompleted;
        
        /// <remarks/>
        public event CreateMobileAccountCompletedEventHandler CreateMobileAccountCompleted;
        
        /// <remarks/>
        public event EnumFamilyMembersCompletedEventHandler EnumFamilyMembersCompleted;
        
        /// <remarks/>
        public event GenerateGamertagCompletedEventHandler GenerateGamertagCompleted;
        
        /// <remarks/>
        public event GetPaymentInstrumentsCompletedEventHandler GetPaymentInstrumentsCompleted;
        
        /// <remarks/>
        public event GetSupportedCountriesCompletedEventHandler GetSupportedCountriesCompleted;
        
        /// <remarks/>
        public event GetUserAuthorizationCompletedEventHandler GetUserAuthorizationCompleted;
        
        /// <remarks/>
        public event GamertagHistoryGetCompletedEventHandler GamertagHistoryGetCompleted;
        
        /// <remarks/>
        public event UserHistoryGetCompletedEventHandler UserHistoryGetCompleted;
        
        /// <remarks/>
        public event MachineHistoryGetCompletedEventHandler MachineHistoryGetCompleted;
        
        /// <remarks/>
        public event FamilyHistoryGetCompletedEventHandler FamilyHistoryGetCompleted;
        
        /// <remarks/>
        public event SetFreeGamertagEligibleCompletedEventHandler SetFreeGamertagEligibleCompleted;
        
        /// <remarks/>
        public event SetFamilyGoldSeatExemptionCompletedEventHandler SetFamilyGoldSeatExemptionCompleted;
        
        /// <remarks/>
        public event TestConnectionCompletedEventHandler TestConnectionCompleted;
        
        /// <remarks/>
        public event UserAccountAuthorizeCompletedEventHandler UserAccountAuthorizeCompleted;
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("urn:schemas-xbox-com:user-account-data/AcceptTermsOfService", RequestNamespace="urn:schemas-xbox-com:user-account-data", ResponseNamespace="urn:schemas-xbox-com:user-account-data", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public void AcceptTermsOfService(ulong userPuid, [System.Xml.Serialization.XmlElementAttribute(DataType="base64Binary")] byte[] signedOwnerPassportPuid, ServiceTypeEnum serviceType) {
            this.Invoke("AcceptTermsOfService", new object[] {
                        userPuid,
                        signedOwnerPassportPuid,
                        serviceType});
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginAcceptTermsOfService(ulong userPuid, byte[] signedOwnerPassportPuid, ServiceTypeEnum serviceType, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("AcceptTermsOfService", new object[] {
                        userPuid,
                        signedOwnerPassportPuid,
                        serviceType}, callback, asyncState);
        }
        
        /// <remarks/>
        public void EndAcceptTermsOfService(System.IAsyncResult asyncResult) {
            this.EndInvoke(asyncResult);
        }
        
        /// <remarks/>
        public void AcceptTermsOfServiceAsync(ulong userPuid, byte[] signedOwnerPassportPuid, ServiceTypeEnum serviceType) {
            this.AcceptTermsOfServiceAsync(userPuid, signedOwnerPassportPuid, serviceType, null);
        }
        
        /// <remarks/>
        public void AcceptTermsOfServiceAsync(ulong userPuid, byte[] signedOwnerPassportPuid, ServiceTypeEnum serviceType, object userState) {
            if ((this.AcceptTermsOfServiceOperationCompleted == null)) {
                this.AcceptTermsOfServiceOperationCompleted = new System.Threading.SendOrPostCallback(this.OnAcceptTermsOfServiceOperationCompleted);
            }
            this.InvokeAsync("AcceptTermsOfService", new object[] {
                        userPuid,
                        signedOwnerPassportPuid,
                        serviceType}, this.AcceptTermsOfServiceOperationCompleted, userState);
        }
        
        private void OnAcceptTermsOfServiceOperationCompleted(object arg) {
            if ((this.AcceptTermsOfServiceCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.AcceptTermsOfServiceCompleted(this, new System.ComponentModel.AsyncCompletedEventArgs(invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("urn:schemas-xbox-com:user-account-data/AddCreditCard", RequestNamespace="urn:schemas-xbox-com:user-account-data", ResponseNamespace="urn:schemas-xbox-com:user-account-data", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public AddCreditCardResults AddCreditCard(
                    ulong userPuid, 
                    ulong machinePuid, 
                    string addressStreet1, 
                    string addressStreet2, 
                    string addressCity, 
                    string addressDistrict, 
                    string addressState, 
                    string addressPostalCode, 
                    string phonePrefix, 
                    string phoneNumber, 
                    string phoneExtension, 
                    byte cardType, 
                    string accountHolderName, 
                    string accountNumber, 
                    string cardVerificationNumber, 
                    string expirationDate) {
            object[] results = this.Invoke("AddCreditCard", new object[] {
                        userPuid,
                        machinePuid,
                        addressStreet1,
                        addressStreet2,
                        addressCity,
                        addressDistrict,
                        addressState,
                        addressPostalCode,
                        phonePrefix,
                        phoneNumber,
                        phoneExtension,
                        cardType,
                        accountHolderName,
                        accountNumber,
                        cardVerificationNumber,
                        expirationDate});
            return ((AddCreditCardResults)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginAddCreditCard(
                    ulong userPuid, 
                    ulong machinePuid, 
                    string addressStreet1, 
                    string addressStreet2, 
                    string addressCity, 
                    string addressDistrict, 
                    string addressState, 
                    string addressPostalCode, 
                    string phonePrefix, 
                    string phoneNumber, 
                    string phoneExtension, 
                    byte cardType, 
                    string accountHolderName, 
                    string accountNumber, 
                    string cardVerificationNumber, 
                    string expirationDate, 
                    System.AsyncCallback callback, 
                    object asyncState) {
            return this.BeginInvoke("AddCreditCard", new object[] {
                        userPuid,
                        machinePuid,
                        addressStreet1,
                        addressStreet2,
                        addressCity,
                        addressDistrict,
                        addressState,
                        addressPostalCode,
                        phonePrefix,
                        phoneNumber,
                        phoneExtension,
                        cardType,
                        accountHolderName,
                        accountNumber,
                        cardVerificationNumber,
                        expirationDate}, callback, asyncState);
        }
        
        /// <remarks/>
        public AddCreditCardResults EndAddCreditCard(System.IAsyncResult asyncResult) {
            object[] results = this.EndInvoke(asyncResult);
            return ((AddCreditCardResults)(results[0]));
        }
        
        /// <remarks/>
        public void AddCreditCardAsync(
                    ulong userPuid, 
                    ulong machinePuid, 
                    string addressStreet1, 
                    string addressStreet2, 
                    string addressCity, 
                    string addressDistrict, 
                    string addressState, 
                    string addressPostalCode, 
                    string phonePrefix, 
                    string phoneNumber, 
                    string phoneExtension, 
                    byte cardType, 
                    string accountHolderName, 
                    string accountNumber, 
                    string cardVerificationNumber, 
                    string expirationDate) {
            this.AddCreditCardAsync(userPuid, machinePuid, addressStreet1, addressStreet2, addressCity, addressDistrict, addressState, addressPostalCode, phonePrefix, phoneNumber, phoneExtension, cardType, accountHolderName, accountNumber, cardVerificationNumber, expirationDate, null);
        }
        
        /// <remarks/>
        public void AddCreditCardAsync(
                    ulong userPuid, 
                    ulong machinePuid, 
                    string addressStreet1, 
                    string addressStreet2, 
                    string addressCity, 
                    string addressDistrict, 
                    string addressState, 
                    string addressPostalCode, 
                    string phonePrefix, 
                    string phoneNumber, 
                    string phoneExtension, 
                    byte cardType, 
                    string accountHolderName, 
                    string accountNumber, 
                    string cardVerificationNumber, 
                    string expirationDate, 
                    object userState) {
            if ((this.AddCreditCardOperationCompleted == null)) {
                this.AddCreditCardOperationCompleted = new System.Threading.SendOrPostCallback(this.OnAddCreditCardOperationCompleted);
            }
            this.InvokeAsync("AddCreditCard", new object[] {
                        userPuid,
                        machinePuid,
                        addressStreet1,
                        addressStreet2,
                        addressCity,
                        addressDistrict,
                        addressState,
                        addressPostalCode,
                        phonePrefix,
                        phoneNumber,
                        phoneExtension,
                        cardType,
                        accountHolderName,
                        accountNumber,
                        cardVerificationNumber,
                        expirationDate}, this.AddCreditCardOperationCompleted, userState);
        }
        
        private void OnAddCreditCardOperationCompleted(object arg) {
            if ((this.AddCreditCardCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.AddCreditCardCompleted(this, new AddCreditCardCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("urn:schemas-xbox-com:user-account-data/GetPointsBalance", RequestNamespace="urn:schemas-xbox-com:user-account-data", ResponseNamespace="urn:schemas-xbox-com:user-account-data", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public GetPointsBalanceResults GetPointsBalance(ulong userPuid) {
            object[] results = this.Invoke("GetPointsBalance", new object[] {
                        userPuid});
            return ((GetPointsBalanceResults)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginGetPointsBalance(ulong userPuid, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("GetPointsBalance", new object[] {
                        userPuid}, callback, asyncState);
        }
        
        /// <remarks/>
        public GetPointsBalanceResults EndGetPointsBalance(System.IAsyncResult asyncResult) {
            object[] results = this.EndInvoke(asyncResult);
            return ((GetPointsBalanceResults)(results[0]));
        }
        
        /// <remarks/>
        public void GetPointsBalanceAsync(ulong userPuid) {
            this.GetPointsBalanceAsync(userPuid, null);
        }
        
        /// <remarks/>
        public void GetPointsBalanceAsync(ulong userPuid, object userState) {
            if ((this.GetPointsBalanceOperationCompleted == null)) {
                this.GetPointsBalanceOperationCompleted = new System.Threading.SendOrPostCallback(this.OnGetPointsBalanceOperationCompleted);
            }
            this.InvokeAsync("GetPointsBalance", new object[] {
                        userPuid}, this.GetPointsBalanceOperationCompleted, userState);
        }
        
        private void OnGetPointsBalanceOperationCompleted(object arg) {
            if ((this.GetPointsBalanceCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.GetPointsBalanceCompleted(this, new GetPointsBalanceCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("urn:schemas-xbox-com:user-account-data/SignIn", RequestNamespace="urn:schemas-xbox-com:user-account-data", ResponseNamespace="urn:schemas-xbox-com:user-account-data", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public SignInResults SignIn() {
            object[] results = this.Invoke("SignIn", new object[0]);
            return ((SignInResults)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginSignIn(System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("SignIn", new object[0], callback, asyncState);
        }
        
        /// <remarks/>
        public SignInResults EndSignIn(System.IAsyncResult asyncResult) {
            object[] results = this.EndInvoke(asyncResult);
            return ((SignInResults)(results[0]));
        }
        
        /// <remarks/>
        public void SignInAsync() {
            this.SignInAsync(null);
        }
        
        /// <remarks/>
        public void SignInAsync(object userState) {
            if ((this.SignInOperationCompleted == null)) {
                this.SignInOperationCompleted = new System.Threading.SendOrPostCallback(this.OnSignInOperationCompleted);
            }
            this.InvokeAsync("SignIn", new object[0], this.SignInOperationCompleted, userState);
        }
        
        private void OnSignInOperationCompleted(object arg) {
            if ((this.SignInCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.SignInCompleted(this, new SignInCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("urn:schemas-xbox-com:user-account-data/ConsoleApplicationsGetByMachinePuid", RequestNamespace="urn:schemas-xbox-com:user-account-data", ResponseNamespace="urn:schemas-xbox-com:user-account-data", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public ConsoleApplications ConsoleApplicationsGetByMachinePuid(ulong machinePuid) {
            object[] results = this.Invoke("ConsoleApplicationsGetByMachinePuid", new object[] {
                        machinePuid});
            return ((ConsoleApplications)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginConsoleApplicationsGetByMachinePuid(ulong machinePuid, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("ConsoleApplicationsGetByMachinePuid", new object[] {
                        machinePuid}, callback, asyncState);
        }
        
        /// <remarks/>
        public ConsoleApplications EndConsoleApplicationsGetByMachinePuid(System.IAsyncResult asyncResult) {
            object[] results = this.EndInvoke(asyncResult);
            return ((ConsoleApplications)(results[0]));
        }
        
        /// <remarks/>
        public void ConsoleApplicationsGetByMachinePuidAsync(ulong machinePuid) {
            this.ConsoleApplicationsGetByMachinePuidAsync(machinePuid, null);
        }
        
        /// <remarks/>
        public void ConsoleApplicationsGetByMachinePuidAsync(ulong machinePuid, object userState) {
            if ((this.ConsoleApplicationsGetByMachinePuidOperationCompleted == null)) {
                this.ConsoleApplicationsGetByMachinePuidOperationCompleted = new System.Threading.SendOrPostCallback(this.OnConsoleApplicationsGetByMachinePuidOperationCompleted);
            }
            this.InvokeAsync("ConsoleApplicationsGetByMachinePuid", new object[] {
                        machinePuid}, this.ConsoleApplicationsGetByMachinePuidOperationCompleted, userState);
        }
        
        private void OnConsoleApplicationsGetByMachinePuidOperationCompleted(object arg) {
            if ((this.ConsoleApplicationsGetByMachinePuidCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.ConsoleApplicationsGetByMachinePuidCompleted(this, new ConsoleApplicationsGetByMachinePuidCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("urn:schemas-xbox-com:user-account-data/CreateMobileAccount", RequestNamespace="urn:schemas-xbox-com:user-account-data", ResponseNamespace="urn:schemas-xbox-com:user-account-data", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public void CreateMobileAccount(ulong userPuid, [System.Xml.Serialization.XmlElementAttribute(DataType="base64Binary")] byte[] reserved, ulong machinePuid, string gamertag, byte countryId, ushort languageId, System.DateTime birthDate) {
            this.Invoke("CreateMobileAccount", new object[] {
                        userPuid,
                        reserved,
                        machinePuid,
                        gamertag,
                        countryId,
                        languageId,
                        birthDate});
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginCreateMobileAccount(ulong userPuid, byte[] reserved, ulong machinePuid, string gamertag, byte countryId, ushort languageId, System.DateTime birthDate, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("CreateMobileAccount", new object[] {
                        userPuid,
                        reserved,
                        machinePuid,
                        gamertag,
                        countryId,
                        languageId,
                        birthDate}, callback, asyncState);
        }
        
        /// <remarks/>
        public void EndCreateMobileAccount(System.IAsyncResult asyncResult) {
            this.EndInvoke(asyncResult);
        }
        
        /// <remarks/>
        public void CreateMobileAccountAsync(ulong userPuid, byte[] reserved, ulong machinePuid, string gamertag, byte countryId, ushort languageId, System.DateTime birthDate) {
            this.CreateMobileAccountAsync(userPuid, reserved, machinePuid, gamertag, countryId, languageId, birthDate, null);
        }
        
        /// <remarks/>
        public void CreateMobileAccountAsync(ulong userPuid, byte[] reserved, ulong machinePuid, string gamertag, byte countryId, ushort languageId, System.DateTime birthDate, object userState) {
            if ((this.CreateMobileAccountOperationCompleted == null)) {
                this.CreateMobileAccountOperationCompleted = new System.Threading.SendOrPostCallback(this.OnCreateMobileAccountOperationCompleted);
            }
            this.InvokeAsync("CreateMobileAccount", new object[] {
                        userPuid,
                        reserved,
                        machinePuid,
                        gamertag,
                        countryId,
                        languageId,
                        birthDate}, this.CreateMobileAccountOperationCompleted, userState);
        }
        
        private void OnCreateMobileAccountOperationCompleted(object arg) {
            if ((this.CreateMobileAccountCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.CreateMobileAccountCompleted(this, new System.ComponentModel.AsyncCompletedEventArgs(invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("urn:schemas-xbox-com:user-account-data/EnumFamilyMembers", RequestNamespace="urn:schemas-xbox-com:user-account-data", ResponseNamespace="urn:schemas-xbox-com:user-account-data", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        [return: System.Xml.Serialization.XmlArrayAttribute("familyMembers")]
        public FamilyMember[] EnumFamilyMembers(ulong userPuid) {
            object[] results = this.Invoke("EnumFamilyMembers", new object[] {
                        userPuid});
            return ((FamilyMember[])(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginEnumFamilyMembers(ulong userPuid, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("EnumFamilyMembers", new object[] {
                        userPuid}, callback, asyncState);
        }
        
        /// <remarks/>
        public FamilyMember[] EndEnumFamilyMembers(System.IAsyncResult asyncResult) {
            object[] results = this.EndInvoke(asyncResult);
            return ((FamilyMember[])(results[0]));
        }
        
        /// <remarks/>
        public void EnumFamilyMembersAsync(ulong userPuid) {
            this.EnumFamilyMembersAsync(userPuid, null);
        }
        
        /// <remarks/>
        public void EnumFamilyMembersAsync(ulong userPuid, object userState) {
            if ((this.EnumFamilyMembersOperationCompleted == null)) {
                this.EnumFamilyMembersOperationCompleted = new System.Threading.SendOrPostCallback(this.OnEnumFamilyMembersOperationCompleted);
            }
            this.InvokeAsync("EnumFamilyMembers", new object[] {
                        userPuid}, this.EnumFamilyMembersOperationCompleted, userState);
        }
        
        private void OnEnumFamilyMembersOperationCompleted(object arg) {
            if ((this.EnumFamilyMembersCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.EnumFamilyMembersCompleted(this, new EnumFamilyMembersCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("urn:schemas-xbox-com:user-account-data/GenerateGamertag", RequestNamespace="urn:schemas-xbox-com:user-account-data", ResponseNamespace="urn:schemas-xbox-com:user-account-data", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public string GenerateGamertag(string seed, ulong machinePuid, GamertagSuggestionType gamertagSuggestionType) {
            object[] results = this.Invoke("GenerateGamertag", new object[] {
                        seed,
                        machinePuid,
                        gamertagSuggestionType});
            return ((string)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginGenerateGamertag(string seed, ulong machinePuid, GamertagSuggestionType gamertagSuggestionType, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("GenerateGamertag", new object[] {
                        seed,
                        machinePuid,
                        gamertagSuggestionType}, callback, asyncState);
        }
        
        /// <remarks/>
        public string EndGenerateGamertag(System.IAsyncResult asyncResult) {
            object[] results = this.EndInvoke(asyncResult);
            return ((string)(results[0]));
        }
        
        /// <remarks/>
        public void GenerateGamertagAsync(string seed, ulong machinePuid, GamertagSuggestionType gamertagSuggestionType) {
            this.GenerateGamertagAsync(seed, machinePuid, gamertagSuggestionType, null);
        }
        
        /// <remarks/>
        public void GenerateGamertagAsync(string seed, ulong machinePuid, GamertagSuggestionType gamertagSuggestionType, object userState) {
            if ((this.GenerateGamertagOperationCompleted == null)) {
                this.GenerateGamertagOperationCompleted = new System.Threading.SendOrPostCallback(this.OnGenerateGamertagOperationCompleted);
            }
            this.InvokeAsync("GenerateGamertag", new object[] {
                        seed,
                        machinePuid,
                        gamertagSuggestionType}, this.GenerateGamertagOperationCompleted, userState);
        }
        
        private void OnGenerateGamertagOperationCompleted(object arg) {
            if ((this.GenerateGamertagCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.GenerateGamertagCompleted(this, new GenerateGamertagCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("urn:schemas-xbox-com:user-account-data/GetPaymentInstruments", RequestNamespace="urn:schemas-xbox-com:user-account-data", ResponseNamespace="urn:schemas-xbox-com:user-account-data", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public GetPaymentInstrumentResults GetPaymentInstruments(ulong userPuid, ulong machinePuid) {
            object[] results = this.Invoke("GetPaymentInstruments", new object[] {
                        userPuid,
                        machinePuid});
            return ((GetPaymentInstrumentResults)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginGetPaymentInstruments(ulong userPuid, ulong machinePuid, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("GetPaymentInstruments", new object[] {
                        userPuid,
                        machinePuid}, callback, asyncState);
        }
        
        /// <remarks/>
        public GetPaymentInstrumentResults EndGetPaymentInstruments(System.IAsyncResult asyncResult) {
            object[] results = this.EndInvoke(asyncResult);
            return ((GetPaymentInstrumentResults)(results[0]));
        }
        
        /// <remarks/>
        public void GetPaymentInstrumentsAsync(ulong userPuid, ulong machinePuid) {
            this.GetPaymentInstrumentsAsync(userPuid, machinePuid, null);
        }
        
        /// <remarks/>
        public void GetPaymentInstrumentsAsync(ulong userPuid, ulong machinePuid, object userState) {
            if ((this.GetPaymentInstrumentsOperationCompleted == null)) {
                this.GetPaymentInstrumentsOperationCompleted = new System.Threading.SendOrPostCallback(this.OnGetPaymentInstrumentsOperationCompleted);
            }
            this.InvokeAsync("GetPaymentInstruments", new object[] {
                        userPuid,
                        machinePuid}, this.GetPaymentInstrumentsOperationCompleted, userState);
        }
        
        private void OnGetPaymentInstrumentsOperationCompleted(object arg) {
            if ((this.GetPaymentInstrumentsCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.GetPaymentInstrumentsCompleted(this, new GetPaymentInstrumentsCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("urn:schemas-xbox-com:user-account-data/GetSupportedCountries", RequestNamespace="urn:schemas-xbox-com:user-account-data", ResponseNamespace="urn:schemas-xbox-com:user-account-data", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public CountryInfo[] GetSupportedCountries(byte serviceType, byte platformType) {
            object[] results = this.Invoke("GetSupportedCountries", new object[] {
                        serviceType,
                        platformType});
            return ((CountryInfo[])(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginGetSupportedCountries(byte serviceType, byte platformType, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("GetSupportedCountries", new object[] {
                        serviceType,
                        platformType}, callback, asyncState);
        }
        
        /// <remarks/>
        public CountryInfo[] EndGetSupportedCountries(System.IAsyncResult asyncResult) {
            object[] results = this.EndInvoke(asyncResult);
            return ((CountryInfo[])(results[0]));
        }
        
        /// <remarks/>
        public void GetSupportedCountriesAsync(byte serviceType, byte platformType) {
            this.GetSupportedCountriesAsync(serviceType, platformType, null);
        }
        
        /// <remarks/>
        public void GetSupportedCountriesAsync(byte serviceType, byte platformType, object userState) {
            if ((this.GetSupportedCountriesOperationCompleted == null)) {
                this.GetSupportedCountriesOperationCompleted = new System.Threading.SendOrPostCallback(this.OnGetSupportedCountriesOperationCompleted);
            }
            this.InvokeAsync("GetSupportedCountries", new object[] {
                        serviceType,
                        platformType}, this.GetSupportedCountriesOperationCompleted, userState);
        }
        
        private void OnGetSupportedCountriesOperationCompleted(object arg) {
            if ((this.GetSupportedCountriesCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.GetSupportedCountriesCompleted(this, new GetSupportedCountriesCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("urn:schemas-xbox-com:user-account-data/GetUserAuthorization", RequestNamespace="urn:schemas-xbox-com:user-account-data", ResponseNamespace="urn:schemas-xbox-com:user-account-data", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        [return: System.Xml.Serialization.XmlElementAttribute("GetUserAuthorizationInfo", IsNullable=true)]
        public GetUserAuthorizationInfo GetUserAuthorization(int serviceType, uint titleId) {
            object[] results = this.Invoke("GetUserAuthorization", new object[] {
                        serviceType,
                        titleId});
            return ((GetUserAuthorizationInfo)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginGetUserAuthorization(int serviceType, uint titleId, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("GetUserAuthorization", new object[] {
                        serviceType,
                        titleId}, callback, asyncState);
        }
        
        /// <remarks/>
        public GetUserAuthorizationInfo EndGetUserAuthorization(System.IAsyncResult asyncResult) {
            object[] results = this.EndInvoke(asyncResult);
            return ((GetUserAuthorizationInfo)(results[0]));
        }
        
        /// <remarks/>
        public void GetUserAuthorizationAsync(int serviceType, uint titleId) {
            this.GetUserAuthorizationAsync(serviceType, titleId, null);
        }
        
        /// <remarks/>
        public void GetUserAuthorizationAsync(int serviceType, uint titleId, object userState) {
            if ((this.GetUserAuthorizationOperationCompleted == null)) {
                this.GetUserAuthorizationOperationCompleted = new System.Threading.SendOrPostCallback(this.OnGetUserAuthorizationOperationCompleted);
            }
            this.InvokeAsync("GetUserAuthorization", new object[] {
                        serviceType,
                        titleId}, this.GetUserAuthorizationOperationCompleted, userState);
        }
        
        private void OnGetUserAuthorizationOperationCompleted(object arg) {
            if ((this.GetUserAuthorizationCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.GetUserAuthorizationCompleted(this, new GetUserAuthorizationCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("urn:schemas-xbox-com:user-account-data/GamertagHistoryGet", RequestNamespace="urn:schemas-xbox-com:user-account-data", ResponseNamespace="urn:schemas-xbox-com:user-account-data", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public UserHistoryDetail[] GamertagHistoryGet(string gamertag, [System.Xml.Serialization.XmlElementAttribute(IsNullable=true)] System.Nullable<System.DateTime> since) {
            object[] results = this.Invoke("GamertagHistoryGet", new object[] {
                        gamertag,
                        since});
            return ((UserHistoryDetail[])(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginGamertagHistoryGet(string gamertag, System.Nullable<System.DateTime> since, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("GamertagHistoryGet", new object[] {
                        gamertag,
                        since}, callback, asyncState);
        }
        
        /// <remarks/>
        public UserHistoryDetail[] EndGamertagHistoryGet(System.IAsyncResult asyncResult) {
            object[] results = this.EndInvoke(asyncResult);
            return ((UserHistoryDetail[])(results[0]));
        }
        
        /// <remarks/>
        public void GamertagHistoryGetAsync(string gamertag, System.Nullable<System.DateTime> since) {
            this.GamertagHistoryGetAsync(gamertag, since, null);
        }
        
        /// <remarks/>
        public void GamertagHistoryGetAsync(string gamertag, System.Nullable<System.DateTime> since, object userState) {
            if ((this.GamertagHistoryGetOperationCompleted == null)) {
                this.GamertagHistoryGetOperationCompleted = new System.Threading.SendOrPostCallback(this.OnGamertagHistoryGetOperationCompleted);
            }
            this.InvokeAsync("GamertagHistoryGet", new object[] {
                        gamertag,
                        since}, this.GamertagHistoryGetOperationCompleted, userState);
        }
        
        private void OnGamertagHistoryGetOperationCompleted(object arg) {
            if ((this.GamertagHistoryGetCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.GamertagHistoryGetCompleted(this, new GamertagHistoryGetCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("urn:schemas-xbox-com:user-account-data/UserHistoryGet", RequestNamespace="urn:schemas-xbox-com:user-account-data", ResponseNamespace="urn:schemas-xbox-com:user-account-data", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public UserHistory UserHistoryGet(ulong userPuid, [System.Xml.Serialization.XmlElementAttribute(IsNullable=true)] System.Nullable<System.DateTime> since) {
            object[] results = this.Invoke("UserHistoryGet", new object[] {
                        userPuid,
                        since});
            return ((UserHistory)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginUserHistoryGet(ulong userPuid, System.Nullable<System.DateTime> since, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("UserHistoryGet", new object[] {
                        userPuid,
                        since}, callback, asyncState);
        }
        
        /// <remarks/>
        public UserHistory EndUserHistoryGet(System.IAsyncResult asyncResult) {
            object[] results = this.EndInvoke(asyncResult);
            return ((UserHistory)(results[0]));
        }
        
        /// <remarks/>
        public void UserHistoryGetAsync(ulong userPuid, System.Nullable<System.DateTime> since) {
            this.UserHistoryGetAsync(userPuid, since, null);
        }
        
        /// <remarks/>
        public void UserHistoryGetAsync(ulong userPuid, System.Nullable<System.DateTime> since, object userState) {
            if ((this.UserHistoryGetOperationCompleted == null)) {
                this.UserHistoryGetOperationCompleted = new System.Threading.SendOrPostCallback(this.OnUserHistoryGetOperationCompleted);
            }
            this.InvokeAsync("UserHistoryGet", new object[] {
                        userPuid,
                        since}, this.UserHistoryGetOperationCompleted, userState);
        }
        
        private void OnUserHistoryGetOperationCompleted(object arg) {
            if ((this.UserHistoryGetCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.UserHistoryGetCompleted(this, new UserHistoryGetCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("urn:schemas-xbox-com:user-account-data/MachineHistoryGet", RequestNamespace="urn:schemas-xbox-com:user-account-data", ResponseNamespace="urn:schemas-xbox-com:user-account-data", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public MachineHistory MachineHistoryGet(ulong machinePuid, [System.Xml.Serialization.XmlElementAttribute(IsNullable=true)] System.Nullable<System.DateTime> since) {
            object[] results = this.Invoke("MachineHistoryGet", new object[] {
                        machinePuid,
                        since});
            return ((MachineHistory)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginMachineHistoryGet(ulong machinePuid, System.Nullable<System.DateTime> since, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("MachineHistoryGet", new object[] {
                        machinePuid,
                        since}, callback, asyncState);
        }
        
        /// <remarks/>
        public MachineHistory EndMachineHistoryGet(System.IAsyncResult asyncResult) {
            object[] results = this.EndInvoke(asyncResult);
            return ((MachineHistory)(results[0]));
        }
        
        /// <remarks/>
        public void MachineHistoryGetAsync(ulong machinePuid, System.Nullable<System.DateTime> since) {
            this.MachineHistoryGetAsync(machinePuid, since, null);
        }
        
        /// <remarks/>
        public void MachineHistoryGetAsync(ulong machinePuid, System.Nullable<System.DateTime> since, object userState) {
            if ((this.MachineHistoryGetOperationCompleted == null)) {
                this.MachineHistoryGetOperationCompleted = new System.Threading.SendOrPostCallback(this.OnMachineHistoryGetOperationCompleted);
            }
            this.InvokeAsync("MachineHistoryGet", new object[] {
                        machinePuid,
                        since}, this.MachineHistoryGetOperationCompleted, userState);
        }
        
        private void OnMachineHistoryGetOperationCompleted(object arg) {
            if ((this.MachineHistoryGetCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.MachineHistoryGetCompleted(this, new MachineHistoryGetCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("urn:schemas-xbox-com:user-account-data/FamilyHistoryGet", RequestNamespace="urn:schemas-xbox-com:user-account-data", ResponseNamespace="urn:schemas-xbox-com:user-account-data", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public FamilyHistoryDetail[] FamilyHistoryGet(ulong ownerPassportPuid, [System.Xml.Serialization.XmlElementAttribute(IsNullable=true)] System.Nullable<System.DateTime> since) {
            object[] results = this.Invoke("FamilyHistoryGet", new object[] {
                        ownerPassportPuid,
                        since});
            return ((FamilyHistoryDetail[])(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginFamilyHistoryGet(ulong ownerPassportPuid, System.Nullable<System.DateTime> since, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("FamilyHistoryGet", new object[] {
                        ownerPassportPuid,
                        since}, callback, asyncState);
        }
        
        /// <remarks/>
        public FamilyHistoryDetail[] EndFamilyHistoryGet(System.IAsyncResult asyncResult) {
            object[] results = this.EndInvoke(asyncResult);
            return ((FamilyHistoryDetail[])(results[0]));
        }
        
        /// <remarks/>
        public void FamilyHistoryGetAsync(ulong ownerPassportPuid, System.Nullable<System.DateTime> since) {
            this.FamilyHistoryGetAsync(ownerPassportPuid, since, null);
        }
        
        /// <remarks/>
        public void FamilyHistoryGetAsync(ulong ownerPassportPuid, System.Nullable<System.DateTime> since, object userState) {
            if ((this.FamilyHistoryGetOperationCompleted == null)) {
                this.FamilyHistoryGetOperationCompleted = new System.Threading.SendOrPostCallback(this.OnFamilyHistoryGetOperationCompleted);
            }
            this.InvokeAsync("FamilyHistoryGet", new object[] {
                        ownerPassportPuid,
                        since}, this.FamilyHistoryGetOperationCompleted, userState);
        }
        
        private void OnFamilyHistoryGetOperationCompleted(object arg) {
            if ((this.FamilyHistoryGetCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.FamilyHistoryGetCompleted(this, new FamilyHistoryGetCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("urn:schemas-xbox-com:user-account-data/SetFreeGamertagEligible", RequestNamespace="urn:schemas-xbox-com:user-account-data", ResponseNamespace="urn:schemas-xbox-com:user-account-data", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public void SetFreeGamertagEligible(ulong userPuid, bool isEligible) {
            this.Invoke("SetFreeGamertagEligible", new object[] {
                        userPuid,
                        isEligible});
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginSetFreeGamertagEligible(ulong userPuid, bool isEligible, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("SetFreeGamertagEligible", new object[] {
                        userPuid,
                        isEligible}, callback, asyncState);
        }
        
        /// <remarks/>
        public void EndSetFreeGamertagEligible(System.IAsyncResult asyncResult) {
            this.EndInvoke(asyncResult);
        }
        
        /// <remarks/>
        public void SetFreeGamertagEligibleAsync(ulong userPuid, bool isEligible) {
            this.SetFreeGamertagEligibleAsync(userPuid, isEligible, null);
        }
        
        /// <remarks/>
        public void SetFreeGamertagEligibleAsync(ulong userPuid, bool isEligible, object userState) {
            if ((this.SetFreeGamertagEligibleOperationCompleted == null)) {
                this.SetFreeGamertagEligibleOperationCompleted = new System.Threading.SendOrPostCallback(this.OnSetFreeGamertagEligibleOperationCompleted);
            }
            this.InvokeAsync("SetFreeGamertagEligible", new object[] {
                        userPuid,
                        isEligible}, this.SetFreeGamertagEligibleOperationCompleted, userState);
        }
        
        private void OnSetFreeGamertagEligibleOperationCompleted(object arg) {
            if ((this.SetFreeGamertagEligibleCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.SetFreeGamertagEligibleCompleted(this, new System.ComponentModel.AsyncCompletedEventArgs(invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("urn:schemas-xbox-com:user-account-data/SetFamilyGoldSeatExemption", RequestNamespace="urn:schemas-xbox-com:user-account-data", ResponseNamespace="urn:schemas-xbox-com:user-account-data", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public void SetFamilyGoldSeatExemption(ulong ownerPassportPuid, ulong dependentPuid) {
            this.Invoke("SetFamilyGoldSeatExemption", new object[] {
                        ownerPassportPuid,
                        dependentPuid});
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginSetFamilyGoldSeatExemption(ulong ownerPassportPuid, ulong dependentPuid, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("SetFamilyGoldSeatExemption", new object[] {
                        ownerPassportPuid,
                        dependentPuid}, callback, asyncState);
        }
        
        /// <remarks/>
        public void EndSetFamilyGoldSeatExemption(System.IAsyncResult asyncResult) {
            this.EndInvoke(asyncResult);
        }
        
        /// <remarks/>
        public void SetFamilyGoldSeatExemptionAsync(ulong ownerPassportPuid, ulong dependentPuid) {
            this.SetFamilyGoldSeatExemptionAsync(ownerPassportPuid, dependentPuid, null);
        }
        
        /// <remarks/>
        public void SetFamilyGoldSeatExemptionAsync(ulong ownerPassportPuid, ulong dependentPuid, object userState) {
            if ((this.SetFamilyGoldSeatExemptionOperationCompleted == null)) {
                this.SetFamilyGoldSeatExemptionOperationCompleted = new System.Threading.SendOrPostCallback(this.OnSetFamilyGoldSeatExemptionOperationCompleted);
            }
            this.InvokeAsync("SetFamilyGoldSeatExemption", new object[] {
                        ownerPassportPuid,
                        dependentPuid}, this.SetFamilyGoldSeatExemptionOperationCompleted, userState);
        }
        
        private void OnSetFamilyGoldSeatExemptionOperationCompleted(object arg) {
            if ((this.SetFamilyGoldSeatExemptionCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.SetFamilyGoldSeatExemptionCompleted(this, new System.ComponentModel.AsyncCompletedEventArgs(invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("urn:schemas-xbox-com:user-account-data/TestConnection", RequestNamespace="urn:schemas-xbox-com:user-account-data", ResponseNamespace="urn:schemas-xbox-com:user-account-data", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        public string TestConnection(string inputMessage) {
            object[] results = this.Invoke("TestConnection", new object[] {
                        inputMessage});
            return ((string)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginTestConnection(string inputMessage, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("TestConnection", new object[] {
                        inputMessage}, callback, asyncState);
        }
        
        /// <remarks/>
        public string EndTestConnection(System.IAsyncResult asyncResult) {
            object[] results = this.EndInvoke(asyncResult);
            return ((string)(results[0]));
        }
        
        /// <remarks/>
        public void TestConnectionAsync(string inputMessage) {
            this.TestConnectionAsync(inputMessage, null);
        }
        
        /// <remarks/>
        public void TestConnectionAsync(string inputMessage, object userState) {
            if ((this.TestConnectionOperationCompleted == null)) {
                this.TestConnectionOperationCompleted = new System.Threading.SendOrPostCallback(this.OnTestConnectionOperationCompleted);
            }
            this.InvokeAsync("TestConnection", new object[] {
                        inputMessage}, this.TestConnectionOperationCompleted, userState);
        }
        
        private void OnTestConnectionOperationCompleted(object arg) {
            if ((this.TestConnectionCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.TestConnectionCompleted(this, new TestConnectionCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("urn:schemas-xbox-com:user-account-data/UserAccountAuthorize", RequestNamespace="urn:schemas-xbox-com:user-account-data", ResponseNamespace="urn:schemas-xbox-com:user-account-data", Use=System.Web.Services.Description.SoapBindingUse.Literal, ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped)]
        [return: System.Xml.Serialization.XmlElementAttribute("UserAccount_AuthorizeGetInfo", IsNullable=true)]
        public UserAccountAuthorizeInfo UserAccountAuthorize(int serviceType, uint titleId) {
            object[] results = this.Invoke("UserAccountAuthorize", new object[] {
                        serviceType,
                        titleId});
            return ((UserAccountAuthorizeInfo)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginUserAccountAuthorize(int serviceType, uint titleId, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("UserAccountAuthorize", new object[] {
                        serviceType,
                        titleId}, callback, asyncState);
        }
        
        /// <remarks/>
        public UserAccountAuthorizeInfo EndUserAccountAuthorize(System.IAsyncResult asyncResult) {
            object[] results = this.EndInvoke(asyncResult);
            return ((UserAccountAuthorizeInfo)(results[0]));
        }
        
        /// <remarks/>
        public void UserAccountAuthorizeAsync(int serviceType, uint titleId) {
            this.UserAccountAuthorizeAsync(serviceType, titleId, null);
        }
        
        /// <remarks/>
        public void UserAccountAuthorizeAsync(int serviceType, uint titleId, object userState) {
            if ((this.UserAccountAuthorizeOperationCompleted == null)) {
                this.UserAccountAuthorizeOperationCompleted = new System.Threading.SendOrPostCallback(this.OnUserAccountAuthorizeOperationCompleted);
            }
            this.InvokeAsync("UserAccountAuthorize", new object[] {
                        serviceType,
                        titleId}, this.UserAccountAuthorizeOperationCompleted, userState);
        }
        
        private void OnUserAccountAuthorizeOperationCompleted(object arg) {
            if ((this.UserAccountAuthorizeCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.UserAccountAuthorizeCompleted(this, new UserAccountAuthorizeCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks/>
        public new void CancelAsync(object userState) {
            base.CancelAsync(userState);
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="urn:schemas-xbox-com:user-account-data")]
    public enum ServiceTypeEnum {
        
        /// <remarks/>
        Unknown,
        
        /// <remarks/>
        XboxLive,
        
        /// <remarks/>
        Zune,
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="urn:schemas-xbox-com:user-account-data")]
    public partial class AddCreditCardResults {
        
        private string paymentInstrumentIdField;
        
        /// <remarks/>
        public string PaymentInstrumentId {
            get {
                return this.paymentInstrumentIdField;
            }
            set {
                this.paymentInstrumentIdField = value;
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="urn:schemas-xbox-com:user-account-data")]
    public partial class UserAccountAuthorizeAccountInfo {
        
        private ulong xboxPuidField;
        
        private ulong livePuidField;
        
        private string tagField;
        
        private string countryCodeField;
        
        private string postalCodeField;
        
        private bool parentallyControlledField;
        
        private byte[] privilegesField;
        
        /// <remarks/>
        public ulong XboxPuid {
            get {
                return this.xboxPuidField;
            }
            set {
                this.xboxPuidField = value;
            }
        }
        
        /// <remarks/>
        public ulong LivePuid {
            get {
                return this.livePuidField;
            }
            set {
                this.livePuidField = value;
            }
        }
        
        /// <remarks/>
        public string Tag {
            get {
                return this.tagField;
            }
            set {
                this.tagField = value;
            }
        }
        
        /// <remarks/>
        public string CountryCode {
            get {
                return this.countryCodeField;
            }
            set {
                this.countryCodeField = value;
            }
        }
        
        /// <remarks/>
        public string PostalCode {
            get {
                return this.postalCodeField;
            }
            set {
                this.postalCodeField = value;
            }
        }
        
        /// <remarks/>
        public bool ParentallyControlled {
            get {
                return this.parentallyControlledField;
            }
            set {
                this.parentallyControlledField = value;
            }
        }
        
        /// <remarks/>
        [System.Xml.Serialization.XmlArrayAttribute()]
        [System.Xml.Serialization.XmlArrayItemAttribute("Privilege", IsNullable=false)]
        public byte[] Privileges {
            get {
                return this.privilegesField;
            }
            set {
                this.privilegesField = value;
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="urn:schemas-xbox-com:user-account-data")]
    public partial class UserAccountAuthorizeInfo {
        
        private ErrorInfo errorInfoField;
        
        private UserAccountAuthorizeAccountInfo accountInfoField;
        
        /// <remarks/>
        public ErrorInfo ErrorInfo {
            get {
                return this.errorInfoField;
            }
            set {
                this.errorInfoField = value;
            }
        }
        
        /// <remarks/>
        public UserAccountAuthorizeAccountInfo AccountInfo {
            get {
                return this.accountInfoField;
            }
            set {
                this.accountInfoField = value;
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="urn:schemas-xbox-com:user-account-data")]
    public partial class ErrorInfo {
        
        private uint hResultField;
        
        private string messageField;
        
        private bool tagChangeRequiredField;
        
        private bool acceptedTermsOfServiceField;
        
        private bool accountSuspendedField;
        
        private bool billingUnavailableField;
        
        /// <remarks/>
        public uint HResult {
            get {
                return this.hResultField;
            }
            set {
                this.hResultField = value;
            }
        }
        
        /// <remarks/>
        public string Message {
            get {
                return this.messageField;
            }
            set {
                this.messageField = value;
            }
        }
        
        /// <remarks/>
        public bool TagChangeRequired {
            get {
                return this.tagChangeRequiredField;
            }
            set {
                this.tagChangeRequiredField = value;
            }
        }
        
        /// <remarks/>
        public bool AcceptedTermsOfService {
            get {
                return this.acceptedTermsOfServiceField;
            }
            set {
                this.acceptedTermsOfServiceField = value;
            }
        }
        
        /// <remarks/>
        public bool AccountSuspended {
            get {
                return this.accountSuspendedField;
            }
            set {
                this.accountSuspendedField = value;
            }
        }
        
        /// <remarks/>
        public bool BillingUnavailable {
            get {
                return this.billingUnavailableField;
            }
            set {
                this.billingUnavailableField = value;
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="urn:schemas-xbox-com:user-account-data")]
    public partial class FamilyHistoryDetail {
        
        private ulong ownerPassportPuidField;
        
        private ulong dependentPuidField;
        
        private System.Nullable<ulong> machinePuidField;
        
        private string ipAddressField;
        
        private System.DateTime timestampField;
        
        private uint hrField;
        
        private string reasonField;
        
        /// <remarks/>
        public ulong OwnerPassportPuid {
            get {
                return this.ownerPassportPuidField;
            }
            set {
                this.ownerPassportPuidField = value;
            }
        }
        
        /// <remarks/>
        public ulong DependentPuid {
            get {
                return this.dependentPuidField;
            }
            set {
                this.dependentPuidField = value;
            }
        }
        
        /// <remarks/>
        [System.Xml.Serialization.XmlElementAttribute(IsNullable=true)]
        public System.Nullable<ulong> MachinePuid {
            get {
                return this.machinePuidField;
            }
            set {
                this.machinePuidField = value;
            }
        }
        
        /// <remarks/>
        public string IpAddress {
            get {
                return this.ipAddressField;
            }
            set {
                this.ipAddressField = value;
            }
        }
        
        /// <remarks/>
        public System.DateTime Timestamp {
            get {
                return this.timestampField;
            }
            set {
                this.timestampField = value;
            }
        }
        
        /// <remarks/>
        public uint Hr {
            get {
                return this.hrField;
            }
            set {
                this.hrField = value;
            }
        }
        
        /// <remarks/>
        public string Reason {
            get {
                return this.reasonField;
            }
            set {
                this.reasonField = value;
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="urn:schemas-xbox-com:user-account-data")]
    public partial class MachineHistory {
        
        private ulong machinePuidField;
        
        private UserHistoryDetail[] userHistoryDetailsField;
        
        private MachineHistoryDetail[] machineHistoryDetailsField;
        
        /// <remarks/>
        public ulong MachinePuid {
            get {
                return this.machinePuidField;
            }
            set {
                this.machinePuidField = value;
            }
        }
        
        /// <remarks/>
        public UserHistoryDetail[] UserHistoryDetails {
            get {
                return this.userHistoryDetailsField;
            }
            set {
                this.userHistoryDetailsField = value;
            }
        }
        
        /// <remarks/>
        public MachineHistoryDetail[] MachineHistoryDetails {
            get {
                return this.machineHistoryDetailsField;
            }
            set {
                this.machineHistoryDetailsField = value;
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="urn:schemas-xbox-com:user-account-data")]
    public partial class UserHistoryDetail {
        
        private System.DateTime timestampField;
        
        private System.Nullable<ulong> userPuidField;
        
        private System.Nullable<ulong> machinePuidField;
        
        private string ipAddressField;
        
        private string reasonField;
        
        private string detailField;
        
        /// <remarks/>
        public System.DateTime Timestamp {
            get {
                return this.timestampField;
            }
            set {
                this.timestampField = value;
            }
        }
        
        /// <remarks/>
        [System.Xml.Serialization.XmlElementAttribute(IsNullable=true)]
        public System.Nullable<ulong> UserPuid {
            get {
                return this.userPuidField;
            }
            set {
                this.userPuidField = value;
            }
        }
        
        /// <remarks/>
        [System.Xml.Serialization.XmlElementAttribute(IsNullable=true)]
        public System.Nullable<ulong> MachinePuid {
            get {
                return this.machinePuidField;
            }
            set {
                this.machinePuidField = value;
            }
        }
        
        /// <remarks/>
        public string IpAddress {
            get {
                return this.ipAddressField;
            }
            set {
                this.ipAddressField = value;
            }
        }
        
        /// <remarks/>
        public string Reason {
            get {
                return this.reasonField;
            }
            set {
                this.reasonField = value;
            }
        }
        
        /// <remarks/>
        public string Detail {
            get {
                return this.detailField;
            }
            set {
                this.detailField = value;
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="urn:schemas-xbox-com:user-account-data")]
    public partial class MachineHistoryDetail {
        
        private ulong userPuidField;
        
        private ulong machinePuidField;
        
        private System.DateTime firstSeenField;
        
        private System.DateTime lastSeenField;
        
        private int daysSeenField;
        
        private string ipAddressField;
        
        /// <remarks/>
        public ulong UserPuid {
            get {
                return this.userPuidField;
            }
            set {
                this.userPuidField = value;
            }
        }
        
        /// <remarks/>
        public ulong MachinePuid {
            get {
                return this.machinePuidField;
            }
            set {
                this.machinePuidField = value;
            }
        }
        
        /// <remarks/>
        public System.DateTime FirstSeen {
            get {
                return this.firstSeenField;
            }
            set {
                this.firstSeenField = value;
            }
        }
        
        /// <remarks/>
        public System.DateTime LastSeen {
            get {
                return this.lastSeenField;
            }
            set {
                this.lastSeenField = value;
            }
        }
        
        /// <remarks/>
        public int DaysSeen {
            get {
                return this.daysSeenField;
            }
            set {
                this.daysSeenField = value;
            }
        }
        
        /// <remarks/>
        public string IpAddress {
            get {
                return this.ipAddressField;
            }
            set {
                this.ipAddressField = value;
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="urn:schemas-xbox-com:user-account-data")]
    public partial class UserHistory {
        
        private ulong userPuidField;
        
        private UserHistoryDetail[] userHistoryDetailsField;
        
        private MachineHistoryDetail[] machineHistoryDetailsField;
        
        /// <remarks/>
        public ulong UserPuid {
            get {
                return this.userPuidField;
            }
            set {
                this.userPuidField = value;
            }
        }
        
        /// <remarks/>
        public UserHistoryDetail[] UserHistoryDetails {
            get {
                return this.userHistoryDetailsField;
            }
            set {
                this.userHistoryDetailsField = value;
            }
        }
        
        /// <remarks/>
        public MachineHistoryDetail[] MachineHistoryDetails {
            get {
                return this.machineHistoryDetailsField;
            }
            set {
                this.machineHistoryDetailsField = value;
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="urn:schemas-xbox-com:user-account-data")]
    public partial class SessionInfo {
        
        private string musicNetAuthTokenField;
        
        private string geoCountryCodeField;
        
        /// <remarks/>
        public string MusicNetAuthToken {
            get {
                return this.musicNetAuthTokenField;
            }
            set {
                this.musicNetAuthTokenField = value;
            }
        }
        
        /// <remarks/>
        public string GeoCountryCode {
            get {
                return this.geoCountryCodeField;
            }
            set {
                this.geoCountryCodeField = value;
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="urn:schemas-xbox-com:user-account-data")]
    public partial class SubscriptionInfo {
        
        private ulong offerIdField;
        
        private string billingInstanceIdField;
        
        private string statusField;
        
        private bool hasBillingViolationField;
        
        private bool hasPendingCancelField;
        
        private bool hasLapsedField;
        
        private System.DateTime startDateField;
        
        private System.DateTime endDateField;
        
        private string renewalOfferIdField;
        
        /// <remarks/>
        public ulong OfferId {
            get {
                return this.offerIdField;
            }
            set {
                this.offerIdField = value;
            }
        }
        
        /// <remarks/>
        public string BillingInstanceId {
            get {
                return this.billingInstanceIdField;
            }
            set {
                this.billingInstanceIdField = value;
            }
        }
        
        /// <remarks/>
        public string Status {
            get {
                return this.statusField;
            }
            set {
                this.statusField = value;
            }
        }
        
        /// <remarks/>
        public bool HasBillingViolation {
            get {
                return this.hasBillingViolationField;
            }
            set {
                this.hasBillingViolationField = value;
            }
        }
        
        /// <remarks/>
        public bool HasPendingCancel {
            get {
                return this.hasPendingCancelField;
            }
            set {
                this.hasPendingCancelField = value;
            }
        }
        
        /// <remarks/>
        public bool HasLapsed {
            get {
                return this.hasLapsedField;
            }
            set {
                this.hasLapsedField = value;
            }
        }
        
        /// <remarks/>
        public System.DateTime StartDate {
            get {
                return this.startDateField;
            }
            set {
                this.startDateField = value;
            }
        }
        
        /// <remarks/>
        public System.DateTime EndDate {
            get {
                return this.endDateField;
            }
            set {
                this.endDateField = value;
            }
        }
        
        /// <remarks/>
        public string RenewalOfferId {
            get {
                return this.renewalOfferIdField;
            }
            set {
                this.renewalOfferIdField = value;
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="urn:schemas-xbox-com:user-account-data")]
    public partial class AccountInfo {
        
        private ulong xboxPuidField;
        
        private ulong livePuidField;
        
        private string tagField;
        
        private string countryCodeField;
        
        private string postalCodeField;
        
        private bool parentallyControlledField;
        
        private byte[] privilegesField;
        
        private uint[] servicesField;
        
        private uint pointsBalanceField;
        
        private bool isLightweightField;
        
        private uint cultureIdField;
        
        private uint parentalControlGroupIdField;
        
        /// <remarks/>
        public ulong XboxPuid {
            get {
                return this.xboxPuidField;
            }
            set {
                this.xboxPuidField = value;
            }
        }
        
        /// <remarks/>
        public ulong LivePuid {
            get {
                return this.livePuidField;
            }
            set {
                this.livePuidField = value;
            }
        }
        
        /// <remarks/>
        public string Tag {
            get {
                return this.tagField;
            }
            set {
                this.tagField = value;
            }
        }
        
        /// <remarks/>
        public string CountryCode {
            get {
                return this.countryCodeField;
            }
            set {
                this.countryCodeField = value;
            }
        }
        
        /// <remarks/>
        public string PostalCode {
            get {
                return this.postalCodeField;
            }
            set {
                this.postalCodeField = value;
            }
        }
        
        /// <remarks/>
        public bool ParentallyControlled {
            get {
                return this.parentallyControlledField;
            }
            set {
                this.parentallyControlledField = value;
            }
        }
        
        /// <remarks/>
        [System.Xml.Serialization.XmlArrayAttribute()]
        [System.Xml.Serialization.XmlArrayItemAttribute("Privilege", IsNullable=false)]
        public byte[] Privileges {
            get {
                return this.privilegesField;
            }
            set {
                this.privilegesField = value;
            }
        }
        
        /// <remarks/>
        [System.Xml.Serialization.XmlArrayItemAttribute("Service", IsNullable=false)]
        public uint[] Services {
            get {
                return this.servicesField;
            }
            set {
                this.servicesField = value;
            }
        }
        
        /// <remarks/>
        public uint PointsBalance {
            get {
                return this.pointsBalanceField;
            }
            set {
                this.pointsBalanceField = value;
            }
        }
        
        /// <remarks/>
        public bool IsLightweight {
            get {
                return this.isLightweightField;
            }
            set {
                this.isLightweightField = value;
            }
        }
        
        /// <remarks/>
        public uint CultureId {
            get {
                return this.cultureIdField;
            }
            set {
                this.cultureIdField = value;
            }
        }
        
        /// <remarks/>
        public uint ParentalControlGroupId {
            get {
                return this.parentalControlGroupIdField;
            }
            set {
                this.parentalControlGroupIdField = value;
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="urn:schemas-xbox-com:user-account-data")]
    public partial class GetUserAuthorizationInfo {
        
        private ErrorInfo errorInfoField;
        
        private AccountInfo accountInfoField;
        
        private SubscriptionInfo[] subscriptionInfoField;
        
        private SessionInfo sessionInfoField;
        
        /// <remarks/>
        public ErrorInfo ErrorInfo {
            get {
                return this.errorInfoField;
            }
            set {
                this.errorInfoField = value;
            }
        }
        
        /// <remarks/>
        public AccountInfo AccountInfo {
            get {
                return this.accountInfoField;
            }
            set {
                this.accountInfoField = value;
            }
        }
        
        /// <remarks/>
        [System.Xml.Serialization.XmlArrayItemAttribute("Subscription")]
        public SubscriptionInfo[] SubscriptionInfo {
            get {
                return this.subscriptionInfoField;
            }
            set {
                this.subscriptionInfoField = value;
            }
        }
        
        /// <remarks/>
        public SessionInfo SessionInfo {
            get {
                return this.sessionInfoField;
            }
            set {
                this.sessionInfoField = value;
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="urn:schemas-xbox-com:user-account-data")]
    public partial class CountryInfo {
        
        private byte countryIdField;
        
        private string countryCodeField;
        
        private byte userField;
        
        private byte billingField;
        
        private bool allowDirectDebitField;
        
        private bool allowPayPalField;
        
        private bool requireCCAgeVerificationField;
        
        /// <remarks/>
        public byte CountryId {
            get {
                return this.countryIdField;
            }
            set {
                this.countryIdField = value;
            }
        }
        
        /// <remarks/>
        public string CountryCode {
            get {
                return this.countryCodeField;
            }
            set {
                this.countryCodeField = value;
            }
        }
        
        /// <remarks/>
        public byte User {
            get {
                return this.userField;
            }
            set {
                this.userField = value;
            }
        }
        
        /// <remarks/>
        public byte Billing {
            get {
                return this.billingField;
            }
            set {
                this.billingField = value;
            }
        }
        
        /// <remarks/>
        public bool AllowDirectDebit {
            get {
                return this.allowDirectDebitField;
            }
            set {
                this.allowDirectDebitField = value;
            }
        }
        
        /// <remarks/>
        public bool AllowPayPal {
            get {
                return this.allowPayPalField;
            }
            set {
                this.allowPayPalField = value;
            }
        }
        
        /// <remarks/>
        public bool RequireCCAgeVerification {
            get {
                return this.requireCCAgeVerificationField;
            }
            set {
                this.requireCCAgeVerificationField = value;
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="urn:schemas-xbox-com:user-account-data")]
    public partial class BillingAgreementDetails {
        
        private string payerEmailField;
        
        private string billingAgreementIdField;
        
        private string firstNameField;
        
        private string lastNameField;
        
        private string middleNameField;
        
        private string payerBusinessField;
        
        private string payerCountryField;
        
        private string billingAgreementDescriptionField;
        
        /// <remarks/>
        public string PayerEmail {
            get {
                return this.payerEmailField;
            }
            set {
                this.payerEmailField = value;
            }
        }
        
        /// <remarks/>
        public string BillingAgreementId {
            get {
                return this.billingAgreementIdField;
            }
            set {
                this.billingAgreementIdField = value;
            }
        }
        
        /// <remarks/>
        public string FirstName {
            get {
                return this.firstNameField;
            }
            set {
                this.firstNameField = value;
            }
        }
        
        /// <remarks/>
        public string LastName {
            get {
                return this.lastNameField;
            }
            set {
                this.lastNameField = value;
            }
        }
        
        /// <remarks/>
        public string MiddleName {
            get {
                return this.middleNameField;
            }
            set {
                this.middleNameField = value;
            }
        }
        
        /// <remarks/>
        public string PayerBusiness {
            get {
                return this.payerBusinessField;
            }
            set {
                this.payerBusinessField = value;
            }
        }
        
        /// <remarks/>
        public string PayerCountry {
            get {
                return this.payerCountryField;
            }
            set {
                this.payerCountryField = value;
            }
        }
        
        /// <remarks/>
        public string BillingAgreementDescription {
            get {
                return this.billingAgreementDescriptionField;
            }
            set {
                this.billingAgreementDescriptionField = value;
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="urn:schemas-xbox-com:user-account-data")]
    public partial class PayPalPayinInfo {
        
        private BillingAgreementDetails billingAgreementDetailsField;
        
        /// <remarks/>
        public BillingAgreementDetails BillingAgreementDetails {
            get {
                return this.billingAgreementDetailsField;
            }
            set {
                this.billingAgreementDetailsField = value;
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="urn:schemas-xbox-com:user-account-data")]
    public partial class WholesaleInfo {
        
        private string accountHolderNameField;
        
        private string externalReferenceIdField;
        
        private string wholesalePartnerField;
        
        private string encryptedPasswordField;
        
        /// <remarks/>
        public string AccountHolderName {
            get {
                return this.accountHolderNameField;
            }
            set {
                this.accountHolderNameField = value;
            }
        }
        
        /// <remarks/>
        public string ExternalReferenceId {
            get {
                return this.externalReferenceIdField;
            }
            set {
                this.externalReferenceIdField = value;
            }
        }
        
        /// <remarks/>
        public string WholesalePartner {
            get {
                return this.wholesalePartnerField;
            }
            set {
                this.wholesalePartnerField = value;
            }
        }
        
        /// <remarks/>
        public string EncryptedPassword {
            get {
                return this.encryptedPasswordField;
            }
            set {
                this.encryptedPasswordField = value;
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="urn:schemas-xbox-com:user-account-data")]
    public partial class DirectDebitInfo {
        
        private string accountHolderNameField;
        
        private string accountNumberField;
        
        private string bankCodeField;
        
        private string branchCodeField;
        
        private string checkDigitsField;
        
        /// <remarks/>
        public string AccountHolderName {
            get {
                return this.accountHolderNameField;
            }
            set {
                this.accountHolderNameField = value;
            }
        }
        
        /// <remarks/>
        public string AccountNumber {
            get {
                return this.accountNumberField;
            }
            set {
                this.accountNumberField = value;
            }
        }
        
        /// <remarks/>
        public string BankCode {
            get {
                return this.bankCodeField;
            }
            set {
                this.bankCodeField = value;
            }
        }
        
        /// <remarks/>
        public string BranchCode {
            get {
                return this.branchCodeField;
            }
            set {
                this.branchCodeField = value;
            }
        }
        
        /// <remarks/>
        public string CheckDigits {
            get {
                return this.checkDigitsField;
            }
            set {
                this.checkDigitsField = value;
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="urn:schemas-xbox-com:user-account-data")]
    public partial class CreditCardInfo {
        
        private byte cardTypeField;
        
        private string accountHolderNameField;
        
        private string accountNumberField;
        
        private string ccvNumberField;
        
        private System.DateTime expirationDateField;
        
        /// <remarks/>
        public byte CardType {
            get {
                return this.cardTypeField;
            }
            set {
                this.cardTypeField = value;
            }
        }
        
        /// <remarks/>
        public string AccountHolderName {
            get {
                return this.accountHolderNameField;
            }
            set {
                this.accountHolderNameField = value;
            }
        }
        
        /// <remarks/>
        public string AccountNumber {
            get {
                return this.accountNumberField;
            }
            set {
                this.accountNumberField = value;
            }
        }
        
        /// <remarks/>
        public string CcvNumber {
            get {
                return this.ccvNumberField;
            }
            set {
                this.ccvNumberField = value;
            }
        }
        
        /// <remarks/>
        public System.DateTime ExpirationDate {
            get {
                return this.expirationDateField;
            }
            set {
                this.expirationDateField = value;
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="urn:schemas-xbox-com:user-account-data")]
    public partial class PhoneInfo {
        
        private string phonePrefixField;
        
        private string phoneNumberField;
        
        private string phoneExtensionField;
        
        /// <remarks/>
        public string PhonePrefix {
            get {
                return this.phonePrefixField;
            }
            set {
                this.phonePrefixField = value;
            }
        }
        
        /// <remarks/>
        public string PhoneNumber {
            get {
                return this.phoneNumberField;
            }
            set {
                this.phoneNumberField = value;
            }
        }
        
        /// <remarks/>
        public string PhoneExtension {
            get {
                return this.phoneExtensionField;
            }
            set {
                this.phoneExtensionField = value;
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="urn:schemas-xbox-com:user-account-data")]
    public partial class AddressInfo {
        
        private string street1Field;
        
        private string street2Field;
        
        private string cityField;
        
        private string districtField;
        
        private string stateField;
        
        private string postalCodeField;
        
        /// <remarks/>
        public string Street1 {
            get {
                return this.street1Field;
            }
            set {
                this.street1Field = value;
            }
        }
        
        /// <remarks/>
        public string Street2 {
            get {
                return this.street2Field;
            }
            set {
                this.street2Field = value;
            }
        }
        
        /// <remarks/>
        public string City {
            get {
                return this.cityField;
            }
            set {
                this.cityField = value;
            }
        }
        
        /// <remarks/>
        public string District {
            get {
                return this.districtField;
            }
            set {
                this.districtField = value;
            }
        }
        
        /// <remarks/>
        public string State {
            get {
                return this.stateField;
            }
            set {
                this.stateField = value;
            }
        }
        
        /// <remarks/>
        public string PostalCode {
            get {
                return this.postalCodeField;
            }
            set {
                this.postalCodeField = value;
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="urn:schemas-xbox-com:user-account-data")]
    public partial class PaymentInstrumentInfo {
        
        private string paymentInstrumentIdField;
        
        private byte paymentInstrumentTypeField;
        
        private AddressInfo addressInfoField;
        
        private PhoneInfo phoneInfoField;
        
        private CreditCardInfo creditCardInfoField;
        
        private DirectDebitInfo directDebitInfoField;
        
        private WholesaleInfo wholesaleInfoField;
        
        private PayPalPayinInfo payPalPayinInfoField;
        
        /// <remarks/>
        public string PaymentInstrumentId {
            get {
                return this.paymentInstrumentIdField;
            }
            set {
                this.paymentInstrumentIdField = value;
            }
        }
        
        /// <remarks/>
        public byte PaymentInstrumentType {
            get {
                return this.paymentInstrumentTypeField;
            }
            set {
                this.paymentInstrumentTypeField = value;
            }
        }
        
        /// <remarks/>
        public AddressInfo AddressInfo {
            get {
                return this.addressInfoField;
            }
            set {
                this.addressInfoField = value;
            }
        }
        
        /// <remarks/>
        public PhoneInfo PhoneInfo {
            get {
                return this.phoneInfoField;
            }
            set {
                this.phoneInfoField = value;
            }
        }
        
        /// <remarks/>
        public CreditCardInfo CreditCardInfo {
            get {
                return this.creditCardInfoField;
            }
            set {
                this.creditCardInfoField = value;
            }
        }
        
        /// <remarks/>
        public DirectDebitInfo DirectDebitInfo {
            get {
                return this.directDebitInfoField;
            }
            set {
                this.directDebitInfoField = value;
            }
        }
        
        /// <remarks/>
        public WholesaleInfo WholesaleInfo {
            get {
                return this.wholesaleInfoField;
            }
            set {
                this.wholesaleInfoField = value;
            }
        }
        
        /// <remarks/>
        public PayPalPayinInfo PayPalPayinInfo {
            get {
                return this.payPalPayinInfoField;
            }
            set {
                this.payPalPayinInfoField = value;
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="urn:schemas-xbox-com:user-account-data")]
    public partial class GetPaymentInstrumentResults {
        
        private PaymentInstrumentInfo[] paymentInstrumentInfosField;
        
        /// <remarks/>
        public PaymentInstrumentInfo[] PaymentInstrumentInfos {
            get {
                return this.paymentInstrumentInfosField;
            }
            set {
                this.paymentInstrumentInfosField = value;
            }
        }
    }
    
    /// <remarks/>
    [System.Xml.Serialization.XmlIncludeAttribute(typeof(FamilyMember))]
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="urn:schemas-xbox-com:user-account-data")]
    public partial class WireData {
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="urn:schemas-xbox-com:user-account-data")]
    public partial class FamilyMember : WireData {
        
        private ulong userPuidField;
        
        private ushort userFlagsField;
        
        private string gamertagField;
        
        /// <remarks/>
        public ulong userPuid {
            get {
                return this.userPuidField;
            }
            set {
                this.userPuidField = value;
            }
        }
        
        /// <remarks/>
        public ushort userFlags {
            get {
                return this.userFlagsField;
            }
            set {
                this.userFlagsField = value;
            }
        }
        
        /// <remarks/>
        public string gamertag {
            get {
                return this.gamertagField;
            }
            set {
                this.gamertagField = value;
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="urn:schemas-xbox-com:user-account-data")]
    public partial class ConsoleApplicationDetail {
        
        private string fileNameField;
        
        private string friendlyNameField;
        
        private string appVersionField;
        
        private bool onlineField;
        
        /// <remarks/>
        public string FileName {
            get {
                return this.fileNameField;
            }
            set {
                this.fileNameField = value;
            }
        }
        
        /// <remarks/>
        public string FriendlyName {
            get {
                return this.friendlyNameField;
            }
            set {
                this.friendlyNameField = value;
            }
        }
        
        /// <remarks/>
        public string AppVersion {
            get {
                return this.appVersionField;
            }
            set {
                this.appVersionField = value;
            }
        }
        
        /// <remarks/>
        public bool Online {
            get {
                return this.onlineField;
            }
            set {
                this.onlineField = value;
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="urn:schemas-xbox-com:user-account-data")]
    public partial class ConsoleApplicationGroup {
        
        private string nameField;
        
        private string systemOnlineManifestRevisionField;
        
        private string systemManifestRevisionField;
        
        private int flashVersionField;
        
        private System.Guid groupIdField;
        
        private ConsoleApplicationDetail[] applicationsField;
        
        /// <remarks/>
        public string Name {
            get {
                return this.nameField;
            }
            set {
                this.nameField = value;
            }
        }
        
        /// <remarks/>
        public string SystemOnlineManifestRevision {
            get {
                return this.systemOnlineManifestRevisionField;
            }
            set {
                this.systemOnlineManifestRevisionField = value;
            }
        }
        
        /// <remarks/>
        public string SystemManifestRevision {
            get {
                return this.systemManifestRevisionField;
            }
            set {
                this.systemManifestRevisionField = value;
            }
        }
        
        /// <remarks/>
        public int FlashVersion {
            get {
                return this.flashVersionField;
            }
            set {
                this.flashVersionField = value;
            }
        }
        
        /// <remarks/>
        public System.Guid GroupId {
            get {
                return this.groupIdField;
            }
            set {
                this.groupIdField = value;
            }
        }
        
        /// <remarks/>
        public ConsoleApplicationDetail[] Applications {
            get {
                return this.applicationsField;
            }
            set {
                this.applicationsField = value;
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="urn:schemas-xbox-com:user-account-data")]
    public partial class ConsoleApplications {
        
        private string consoleIdField;
        
        private ConsoleApplicationGroup[] applicationGroupsField;
        
        /// <remarks/>
        public string ConsoleId {
            get {
                return this.consoleIdField;
            }
            set {
                this.consoleIdField = value;
            }
        }
        
        /// <remarks/>
        public ConsoleApplicationGroup[] ApplicationGroups {
            get {
                return this.applicationGroupsField;
            }
            set {
                this.applicationGroupsField = value;
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="urn:schemas-xbox-com:user-account-data")]
    public partial class SessionDetails {
        
        private byte[] sessionKeyField;
        
        private string musicNetAuthTokenField;
        
        private string geoCountryCodeField;
        
        /// <remarks/>
        [System.Xml.Serialization.XmlElementAttribute(DataType="base64Binary")]
        public byte[] SessionKey {
            get {
                return this.sessionKeyField;
            }
            set {
                this.sessionKeyField = value;
            }
        }
        
        /// <remarks/>
        public string MusicNetAuthToken {
            get {
                return this.musicNetAuthTokenField;
            }
            set {
                this.musicNetAuthTokenField = value;
            }
        }
        
        /// <remarks/>
        public string GeoCountryCode {
            get {
                return this.geoCountryCodeField;
            }
            set {
                this.geoCountryCodeField = value;
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="urn:schemas-xbox-com:user-account-data")]
    public partial class SubscriptionDetails {
        
        private ulong xboxOfferIdField;
        
        private string billingInstanceIdField;
        
        private string statusField;
        
        private bool hasBillingViolationField;
        
        private bool hasPendingCancelField;
        
        private string musicNetSkuField;
        
        private System.DateTime startDateField;
        
        private System.DateTime endDateField;
        
        private string renewalXboxOfferIdField;
        
        /// <remarks/>
        public ulong XboxOfferId {
            get {
                return this.xboxOfferIdField;
            }
            set {
                this.xboxOfferIdField = value;
            }
        }
        
        /// <remarks/>
        public string BillingInstanceId {
            get {
                return this.billingInstanceIdField;
            }
            set {
                this.billingInstanceIdField = value;
            }
        }
        
        /// <remarks/>
        public string Status {
            get {
                return this.statusField;
            }
            set {
                this.statusField = value;
            }
        }
        
        /// <remarks/>
        public bool HasBillingViolation {
            get {
                return this.hasBillingViolationField;
            }
            set {
                this.hasBillingViolationField = value;
            }
        }
        
        /// <remarks/>
        public bool HasPendingCancel {
            get {
                return this.hasPendingCancelField;
            }
            set {
                this.hasPendingCancelField = value;
            }
        }
        
        /// <remarks/>
        public string MusicNetSku {
            get {
                return this.musicNetSkuField;
            }
            set {
                this.musicNetSkuField = value;
            }
        }
        
        /// <remarks/>
        public System.DateTime StartDate {
            get {
                return this.startDateField;
            }
            set {
                this.startDateField = value;
            }
        }
        
        /// <remarks/>
        public System.DateTime EndDate {
            get {
                return this.endDateField;
            }
            set {
                this.endDateField = value;
            }
        }
        
        /// <remarks/>
        public string RenewalXboxOfferId {
            get {
                return this.renewalXboxOfferIdField;
            }
            set {
                this.renewalXboxOfferIdField = value;
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="urn:schemas-xbox-com:user-account-data")]
    public partial class AccountDetails {
        
        private ulong xboxPuidField;
        
        private ulong livePuidField;
        
        private string tagField;
        
        private string postalCodeField;
        
        private string countryCodeField;
        
        private bool parentallyControlledField;
        
        private byte[] privilegesField;
        
        private uint pointsBalanceField;
        
        private bool isLightweightField;
        
        /// <remarks/>
        public ulong XboxPuid {
            get {
                return this.xboxPuidField;
            }
            set {
                this.xboxPuidField = value;
            }
        }
        
        /// <remarks/>
        public ulong LivePuid {
            get {
                return this.livePuidField;
            }
            set {
                this.livePuidField = value;
            }
        }
        
        /// <remarks/>
        public string Tag {
            get {
                return this.tagField;
            }
            set {
                this.tagField = value;
            }
        }
        
        /// <remarks/>
        public string PostalCode {
            get {
                return this.postalCodeField;
            }
            set {
                this.postalCodeField = value;
            }
        }
        
        /// <remarks/>
        public string CountryCode {
            get {
                return this.countryCodeField;
            }
            set {
                this.countryCodeField = value;
            }
        }
        
        /// <remarks/>
        public bool ParentallyControlled {
            get {
                return this.parentallyControlledField;
            }
            set {
                this.parentallyControlledField = value;
            }
        }
        
        /// <remarks/>
        [System.Xml.Serialization.XmlElementAttribute(DataType="base64Binary")]
        public byte[] Privileges {
            get {
                return this.privilegesField;
            }
            set {
                this.privilegesField = value;
            }
        }
        
        /// <remarks/>
        public uint PointsBalance {
            get {
                return this.pointsBalanceField;
            }
            set {
                this.pointsBalanceField = value;
            }
        }
        
        /// <remarks/>
        public bool IsLightweight {
            get {
                return this.isLightweightField;
            }
            set {
                this.isLightweightField = value;
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="urn:schemas-xbox-com:user-account-data")]
    public partial class ErrorDetails {
        
        private uint hResultField;
        
        private string messageField;
        
        private bool tagChangeRequiredField;
        
        private bool acceptedTermsOfServiceField;
        
        private bool accountSuspendedField;
        
        private bool subscriptionLapsedField;
        
        private bool billingUnavailableField;
        
        /// <remarks/>
        public uint HResult {
            get {
                return this.hResultField;
            }
            set {
                this.hResultField = value;
            }
        }
        
        /// <remarks/>
        public string Message {
            get {
                return this.messageField;
            }
            set {
                this.messageField = value;
            }
        }
        
        /// <remarks/>
        public bool TagChangeRequired {
            get {
                return this.tagChangeRequiredField;
            }
            set {
                this.tagChangeRequiredField = value;
            }
        }
        
        /// <remarks/>
        public bool AcceptedTermsOfService {
            get {
                return this.acceptedTermsOfServiceField;
            }
            set {
                this.acceptedTermsOfServiceField = value;
            }
        }
        
        /// <remarks/>
        public bool AccountSuspended {
            get {
                return this.accountSuspendedField;
            }
            set {
                this.accountSuspendedField = value;
            }
        }
        
        /// <remarks/>
        public bool SubscriptionLapsed {
            get {
                return this.subscriptionLapsedField;
            }
            set {
                this.subscriptionLapsedField = value;
            }
        }
        
        /// <remarks/>
        public bool BillingUnavailable {
            get {
                return this.billingUnavailableField;
            }
            set {
                this.billingUnavailableField = value;
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="urn:schemas-xbox-com:user-account-data")]
    public partial class SignInResults {
        
        private ErrorDetails errorInfoField;
        
        private AccountDetails accountInfoField;
        
        private SubscriptionDetails subscriptionInfoField;
        
        private SessionDetails sessionInfoField;
        
        /// <remarks/>
        public ErrorDetails ErrorInfo {
            get {
                return this.errorInfoField;
            }
            set {
                this.errorInfoField = value;
            }
        }
        
        /// <remarks/>
        public AccountDetails AccountInfo {
            get {
                return this.accountInfoField;
            }
            set {
                this.accountInfoField = value;
            }
        }
        
        /// <remarks/>
        public SubscriptionDetails SubscriptionInfo {
            get {
                return this.subscriptionInfoField;
            }
            set {
                this.subscriptionInfoField = value;
            }
        }
        
        /// <remarks/>
        public SessionDetails SessionInfo {
            get {
                return this.sessionInfoField;
            }
            set {
                this.sessionInfoField = value;
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="urn:schemas-xbox-com:user-account-data")]
    public partial class GetPointsBalanceResults {
        
        private int pointsBalanceField;
        
        private bool aboveLowBalanceField;
        
        private byte dmpAccountStatusField;
        
        /// <remarks/>
        public int PointsBalance {
            get {
                return this.pointsBalanceField;
            }
            set {
                this.pointsBalanceField = value;
            }
        }
        
        /// <remarks/>
        public bool AboveLowBalance {
            get {
                return this.aboveLowBalanceField;
            }
            set {
                this.aboveLowBalanceField = value;
            }
        }
        
        /// <remarks/>
        public byte DmpAccountStatus {
            get {
                return this.dmpAccountStatusField;
            }
            set {
                this.dmpAccountStatusField = value;
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.SerializableAttribute()]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="urn:schemas-xbox-com:user-account-data")]
    public enum GamertagSuggestionType {
        
        /// <remarks/>
        NounAdjectiveSuggestion,
        
        /// <remarks/>
        SeedSuggestion,
        
        /// <remarks/>
        UniqueNounAdjectiveSuggestion,
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void AcceptTermsOfServiceCompletedEventHandler(object sender, System.ComponentModel.AsyncCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void AddCreditCardCompletedEventHandler(object sender, AddCreditCardCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class AddCreditCardCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal AddCreditCardCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public AddCreditCardResults Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((AddCreditCardResults)(this.results[0]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void GetPointsBalanceCompletedEventHandler(object sender, GetPointsBalanceCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class GetPointsBalanceCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal GetPointsBalanceCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public GetPointsBalanceResults Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((GetPointsBalanceResults)(this.results[0]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void SignInCompletedEventHandler(object sender, SignInCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class SignInCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal SignInCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public SignInResults Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((SignInResults)(this.results[0]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void ConsoleApplicationsGetByMachinePuidCompletedEventHandler(object sender, ConsoleApplicationsGetByMachinePuidCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class ConsoleApplicationsGetByMachinePuidCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal ConsoleApplicationsGetByMachinePuidCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public ConsoleApplications Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((ConsoleApplications)(this.results[0]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void CreateMobileAccountCompletedEventHandler(object sender, System.ComponentModel.AsyncCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void EnumFamilyMembersCompletedEventHandler(object sender, EnumFamilyMembersCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class EnumFamilyMembersCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal EnumFamilyMembersCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public FamilyMember[] Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((FamilyMember[])(this.results[0]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void GenerateGamertagCompletedEventHandler(object sender, GenerateGamertagCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class GenerateGamertagCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal GenerateGamertagCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public string Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((string)(this.results[0]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void GetPaymentInstrumentsCompletedEventHandler(object sender, GetPaymentInstrumentsCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class GetPaymentInstrumentsCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal GetPaymentInstrumentsCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public GetPaymentInstrumentResults Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((GetPaymentInstrumentResults)(this.results[0]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void GetSupportedCountriesCompletedEventHandler(object sender, GetSupportedCountriesCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class GetSupportedCountriesCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal GetSupportedCountriesCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public CountryInfo[] Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((CountryInfo[])(this.results[0]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void GetUserAuthorizationCompletedEventHandler(object sender, GetUserAuthorizationCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class GetUserAuthorizationCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal GetUserAuthorizationCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public GetUserAuthorizationInfo Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((GetUserAuthorizationInfo)(this.results[0]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void GamertagHistoryGetCompletedEventHandler(object sender, GamertagHistoryGetCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class GamertagHistoryGetCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal GamertagHistoryGetCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public UserHistoryDetail[] Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((UserHistoryDetail[])(this.results[0]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void UserHistoryGetCompletedEventHandler(object sender, UserHistoryGetCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class UserHistoryGetCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal UserHistoryGetCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public UserHistory Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((UserHistory)(this.results[0]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void MachineHistoryGetCompletedEventHandler(object sender, MachineHistoryGetCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class MachineHistoryGetCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal MachineHistoryGetCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public MachineHistory Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((MachineHistory)(this.results[0]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void FamilyHistoryGetCompletedEventHandler(object sender, FamilyHistoryGetCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class FamilyHistoryGetCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal FamilyHistoryGetCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public FamilyHistoryDetail[] Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((FamilyHistoryDetail[])(this.results[0]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void SetFreeGamertagEligibleCompletedEventHandler(object sender, System.ComponentModel.AsyncCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void SetFamilyGoldSeatExemptionCompletedEventHandler(object sender, System.ComponentModel.AsyncCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void TestConnectionCompletedEventHandler(object sender, TestConnectionCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class TestConnectionCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal TestConnectionCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public string Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((string)(this.results[0]));
            }
        }
    }
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    public delegate void UserAccountAuthorizeCompletedEventHandler(object sender, UserAccountAuthorizeCompletedEventArgs e);
    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("wsdl", "2.0.50727.42")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class UserAccountAuthorizeCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal UserAccountAuthorizeCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        /// <remarks/>
        public UserAccountAuthorizeInfo Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((UserAccountAuthorizeInfo)(this.results[0]));
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\marketplace\billing\obj\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=x86_common_billing_none_12.4.56.0_none_f95282595a85b1ed
ASSEMBLY_IDENTITY_XP_KEY_FORM=x86_common_billing_no-public-key_12.4.56.0_x-ww_bbca565d
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=common_billing
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=x86
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=x86_common_billing_no-public-key_12.4.56.0_x-ww_bbca565d
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=x86_common_billing_no-public-key_12.4.56.0_x-ww_bbca565d.manifest
XP_MANIFEST_PATH=manifests\x86_common_billing_no-public-key_12.4.56.0_x-ww_bbca565d.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=x86_common_billing_no-public-key_12.4.56.0_x-ww_bbca565d.cat
XP_CATALOG_PATH=manifests\x86_common_billing_no-public-key_12.4.56.0_x-ww_bbca565d.cat
XP_PAYLOAD_PATH=x86_common_billing_no-public-key_12.4.56.0_x-ww_bbca565d
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=common_billing,processorArchitecture=x86,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\marketplace\billing\objd\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=x86_common_billing_none_12.4.56.0_none_f95282595a85b1ed
ASSEMBLY_IDENTITY_XP_KEY_FORM=x86_common_billing_no-public-key_12.4.56.0_x-ww_bbca565d
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=common_billing
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=x86
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=x86_common_billing_no-public-key_12.4.56.0_x-ww_bbca565d
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=x86_common_billing_no-public-key_12.4.56.0_x-ww_bbca565d.manifest
XP_MANIFEST_PATH=manifests\x86_common_billing_no-public-key_12.4.56.0_x-ww_bbca565d.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=x86_common_billing_no-public-key_12.4.56.0_x-ww_bbca565d.cat
XP_CATALOG_PATH=manifests\x86_common_billing_no-public-key_12.4.56.0_x-ww_bbca565d.cat
XP_PAYLOAD_PATH=x86_common_billing_no-public-key_12.4.56.0_x-ww_bbca565d
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=common_billing,processorArchitecture=x86,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\marketplace\billing\CTP\CTPTransactionServiceException.cs ===
﻿using xonline.common.service;
using CTPTransactionService;
using System;

namespace xonline.common.billing
{
    public class CTPTransactionServiceException : Exception, ExceptionWithHResult, IRetryableException
    {
        protected string _Message;
        protected bool _isRetryable;
        protected HResult _XonlineHResult;
        protected HResult _ctpHResult;
        protected int _ctpErrorCode;

        internal CTPTransactionServiceException(Exception e, string message, bool isRetryable, int ctpErrorCode)
            : base("", e)
        {
            _Message = message;

            _isRetryable = isRetryable;

            _ctpErrorCode = ctpErrorCode;

            _XonlineHResult = CTPError.CTPErrorToXonlineHr(ctpErrorCode);
        }

        public int CTPErrorCode
        {
            get { return _ctpErrorCode; }
        }

        public override string Message
        {
            get { return _Message; }
        }

        public new HResult HResult
        {
            get { return _XonlineHResult; }
            set { _XonlineHResult = value; }
        }

        public HResult XonlineHResult
        {
            get { return HResult; }
            set { HResult = value; }
        }

        public HResult CTPHResult
        {
            get { return _ctpHResult; }
        }

        public bool IsRetryable
        {
            get { return _isRetryable; }
        }

        public string Api
        {
            get { return CTPTransactionServiceWrapper.GetSessionCtpApi(); }
        }

        public static HResult ToHResult(Exception e, HResult hr)
        {
            if (e is ExceptionWithHResult)
            {
                hr = ((ExceptionWithHResult)e).HResult;
            }

            return hr;
        }
        /// <summary>
        /// Gets the CTPTransactionServiceException from CTPResponse .
        /// </summary>
        /// <param name="e"></param>
        /// <returns></returns>
        public static CTPTransactionServiceException FromCTPResponse(AbstractResponse output)
        {
            CTPError ctpError = null;
            if (output.Error == null)
            {
                return null;
            }

            ctpError = new CTPError(output.Error.ErrorCode);

            if (ctpError.IsNonUserError)
            {
                return new NonUserCTPTransactionServiceException(
                    null,
                    string.Format("Billing Error. Error text is: {0}", ctpError.Message),
                    output.Error.Retryable
                    , ctpError.CtpErrorCode
                   );
            }
            else
            {
                return new UserCTPTransactionServiceException(
                    null,
                    string.Format("Billing Error. Error text is: {0}", ctpError.Message),
                    output.Error.Retryable
                    , ctpError.CtpErrorCode
                   );
            }
        }

    }
    public class NonUserCTPTransactionServiceException : CTPTransactionServiceException, ExceptionWithEvent
    {
        protected XEvent.Id _EventId;

        public NonUserCTPTransactionServiceException(Exception e, string message, bool isRetryable, int ctpErrorCode)
            : base(e, message, isRetryable, ctpErrorCode)
        {
            _EventId = XEvent.Id.CTP_NON_USER_EXCEPTION;
            _XonlineHResult = CTPError.CTPErrorToXonlineHr(ctpErrorCode);
        }
        public NonUserCTPTransactionServiceException(Exception e, XEvent.Id eventId, string message, bool isRetryable, int ctpErrorCode)
            : base(e, message, isRetryable, ctpErrorCode)
        {
            _EventId = eventId;
            _XonlineHResult = CTPError.CTPErrorToXonlineHr(ctpErrorCode);
        }
        public NonUserCTPTransactionServiceException(Exception e, XEvent.Id eventId, string message, bool isRetryable)
            : base(e, message, isRetryable, 0)
        {
            _EventId = eventId;
        }
        public NonUserCTPTransactionServiceException(Exception e, string message, bool isRetryable)
            : base(e, message, isRetryable, 0)
        {
            _EventId = XEvent.Id.CTP_NON_USER_EXCEPTION;
        }

        public XEvent.Id EventId
        {
            get { return _EventId; }
            set { _EventId = value; }
        }
    }

    public class UserCTPTransactionServiceException : CTPTransactionServiceException, ExceptionWithoutEvent
    {
        public UserCTPTransactionServiceException(Exception e,  string message, bool isRetryable, int ctpErrorCode)
            : base(e, message, isRetryable, ctpErrorCode)
        {
        }
        public UserCTPTransactionServiceException(Exception e,  string message, bool isRetryable)
            : base(e, message, isRetryable, 0)
        {
        }
        public UserCTPTransactionServiceException(Exception e, string message, bool isRetryable,HResult xonlineHresult)
            : base(e, message, isRetryable, 0)
        {
            this.XonlineHResult = xonlineHresult;
        }
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\marketplace\billing\CTP\CTPTransactionServiceWrapper.cs ===
﻿using System;
using System.Collections;
using System.Collections.Generic;
using System.Net;
using System.Xml;

using xonline.common.audit;
using xonline.common.config;
using xonline.common.mgmt;
using xonline.common.service;
using xonline.common.utilities2;
using CTPTransactionService;
using xonline.common.billing;
using System.ServiceModel;
using System.Text;
using System.Security.Cryptography.X509Certificates;
using System.IO;
using System.Runtime.Serialization;
using System.Xml.Serialization;
using System.Text.RegularExpressions;
using System.Collections.Specialized;

[assembly: XomAreaDefinition(XomAreaName.ctpTransactionServiceLog)]
[assembly: XomAreaDefinition(XomAreaName.ctpTransactionServiceTrace)]

//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//

namespace xonline.common.billing
{
    /// <summary>
    /// CTP Service wrapper
    /// </summary>
    public class CTPTransactionServiceWrapper : TransactionServiceClient
    {

        /* ************************************************************** */
        /* **********                PUBLIC PROPERTIES                          *********** */
        /* ************************************************************** */

        /// <summary>
        /// Gets the Purchase time out from npdb
        /// </summary>
        public static int CTPPurchaseTransactionServiceTimeOut
        {
            get
            {
                return Config.GetIntSetting(Setting.billing_ctpPurchaseTransactionServiceTimeoutSeconds);
            }
        }
        /// <summary>
        /// Gets the joinsubscription time out from npdb
        /// </summary>
        public static int CTPJoinSubscriptionTimeOut
        {
            get
            {
                return Config.GetIntSetting(Setting.billing_ctpJoinSubscriptionTimeoutSeconds);
            }
        }
        /// <summary>
        /// Gets the service url for CTP Transaction service from npdb
        /// </summary>
        public static string CTPPurchaseTransactionServiceUrl
        {
            get
            {
                return Config.GetSetting(Setting.billing_ctpPurchaseTransactionServiceUrl);
            }
        }
        /// <summary>
        /// Gets the service url for CTP Transaction service from npdb
        /// </summary>
        public static bool CTPOverrideUrl
        {
            get
            {
                return Config.GetBoolSetting(Setting.billing_ctpAllowUrlOverride);
            }
        }
        /// <summary>
        /// Gets the service url for CTP Transaction service from npdb
        /// </summary>
        public static bool CTPConnecttoBilling
        {
            get
            {
                return Config.GetBoolSetting(Setting.billing_ctpconnectbilling);
            }
        }

        public const string FastFailCTP = "CTPPurchase";

        private static Regex _urlRegex = new Regex(
          @"^(https?://)([0-9a-z].*)",
          RegexOptions.Compiled | RegexOptions.IgnorePatternWhitespace | RegexOptions.IgnoreCase
      );

        private const string behaviorInjectionKey = "BEHAVIOR_INJECTIONS";

        protected static FastFailTracker GetFastFailTracker(string api)
        {
            APIResultEnum result = APIResultEnum.Success;

            return GetFastFailTracker(api, ref result);
        }

        protected static FastFailTracker GetFastFailTracker(string api, ref APIResultEnum result)
        {

            if (string.IsNullOrEmpty(api))
                throw new ArgumentException("api");

            try
            {
                FastFailTracker tracker;

                tracker = new FastFailTracker(FastFailCTP);

                Xom.Trace(XomAreaName.ctpTransactionServiceTrace, LogLevel.L_LOW, "GetFastFailTracker: api: " + api + " is not blocked.");

                return tracker;
            }
            catch (FastFailException inner)
            {
                string msg = "GetFastFailTracker: api:" + api + " is blocked due to fast-fail CTP Purchase apis.";
                Xom.Trace(XomAreaName.ctpTransactionServiceTrace, LogLevel.L_HIGH, msg);

                CTPTransactionCounters.Current(null).BlockedCallsPerSecond.Increment();
                CTPTransactionCounters.Current(null).BlockedCallsTotal.Increment();

                CTPTransactionCounters.Current(api).BlockedCallsPerSecond.Increment();
                CTPTransactionCounters.Current(api).BlockedCallsTotal.Increment();

                throw new XRLExceptionWithoutEvent(
                    HResult.XONLINE_E_RESOURCE_UNAVAILABLE,
                    inner,
                    "CTP." + api + " call blocked due to previous timeout!");
            }
        }


        private static bool _initialized = false;

        private static bool _eventHandlersInitalized = false;

        private static object syncObject = new object();

        public static void Init()
        {
            //if setting to use wrapper is turned off then return
            if (!Config.GetBoolSetting(Setting.billing_initializeCTPWrapper))
            {
                return;
            }
            if (_initialized == false)
            {
                lock (syncObject)
                {
                    if (_initialized == false)
                    {

                        FastFailResourceConfig defaultConfig;

                        //ctp purchase has a different call pattern with success weighing more than failure and hence we set the throttling to .3 from npdb
                        defaultConfig = FastFailBillingDefaults.GetConfiguration(Convert.ToSingle(Config.GetSetting(Setting.CTPPurchase_fastFailThrottling)));

                        FastFailBillingDefaults.InitializeFastFailResource(defaultConfig, FastFailCTP);

                        if (CTPTransactionServiceWrapper.CTPConnecttoBilling == true)
                        {
                            Xom.Trace(XomAreaName.ctpTransactionServiceTrace, LogLevel.L_NORMAL, "CTPTransactionServiceWrapper.Init: loading DMP certificate...");
                            GetClientCertificate();
                        }
                        else
                        {
                            Xom.Trace(XomAreaName.ctpTransactionServiceTrace, LogLevel.L_NORMAL, "CTPTransactionServiceWrapper.Init: skipping loading DMP certificate...");
                        }
                    }

                    // _eventHandlersInitalized should only ever be assigned during Init
                    if (_eventHandlersInitalized == false)
                    {
                        XomControl.ControlRequestEvent += new XomControl.ControlRequestEventHandler(CTPTransactionServiceWrapper.OnControlRequest);

                        _eventHandlersInitalized = true;
                    }

                    _initialized = true;
                }
            }
        }

        /// <summary>
        /// On control Request for XOM
        /// </summary>
        /// <param name="sender"></param>
        /// <param name="args"></param>
        internal static void OnControlRequest(object sender, ControlRequestEventArgs args)
        {
            try
            {
                switch (args.Command)
                {
                    case "help":
                        XomControlConnection.SendMessage("CTPTransaction help:\r\n  TestConnection\r\n\r\n", args.RequestId);
                        args.Handled = true;
                        break;

                    case "testconnection":
                        // make sure billing is enabled before doing anything
                        if (false == CTPTransactionServiceWrapper.CTPConnecttoBilling)
                        {
                            XomControlConnection.SendMessage("CTPTransactionServiceWrapper -- unable to test billing connection because billing_ctpconnectbilling is disabled.\r\n\r\n", args.RequestId);
                            args.Handled = true;
                            return;
                        }

                        // Use longer ctp timeout values because these calls are
                        // initiated from the server rather than an Xbox client.
                        CTPTransactionServiceWrapper.SetSessionClientType(SessionClientType.LiveService);

                        XomControlConnection.SendMessage(ProcessTestConnectionRequest(args), args.RequestId);
                        args.Handled = true;
                        break;

                }
            }
            catch (Exception e)
            {
                XomControlConnection.SendMessage("Error: " + e.ToString() + "\r\n\r\n", args.RequestId);
            }
        }

        /// <summary>
        /// Processes the test connection Request
        /// </summary>
        /// <param name="args"></param>
        /// <returns></returns>
        internal static string ProcessTestConnectionRequest(ControlRequestEventArgs args)
        {
            StringBuilder strB = new StringBuilder();

            CTPTransactionServiceWrapper ctpWrapper;

            try
            {
                strB.Append("Creating CTPTransactionServiceWrapper object...");

                ctpWrapper = new CTPTransactionServiceWrapper();

                strB.Append("success!\r\n\r\n");
            }
            catch (Exception eInitialize)
            {
                strB.Append("failure!!!\r\n " + eInitialize.ToString());
                goto Cleanup;
            }

            try
            {

                strB.Append("Running testconnection against\r\n    " + CTPTransactionServiceWrapper.CTPPurchaseTransactionServiceUrl + "\r\n...");

                string returnString = ctpWrapper.TestConnection("Testing 1, 2, 3..!\r\n");

                strB.Append("success!\r\n" + returnString + "");
            }
            catch (Exception eTest)
            {
                strB.Append("failure: " + eTest.ToString());
            }

        Cleanup:
            strB.Append("\r\n\r\n");
            return strB.ToString();
        }

        private void OverrideSecurityMode()
        {
            if (this.Endpoint.Binding is BasicHttpBinding)
            {
                if (this.Endpoint.Address.Uri.Scheme.Equals("http", StringComparison.InvariantCultureIgnoreCase))
                {
                    ((BasicHttpBinding)this.Endpoint.Binding).Security.Mode = BasicHttpSecurityMode.None;
                }
            }
        }

        private void OverrideUrl()
        {
            if (CTPTransactionServiceWrapper.CTPOverrideUrl)
            {
                string alternateUrl = GetSessionAlternateUrl();
                if (string.IsNullOrEmpty(alternateUrl) == false)
                {
                    this.Endpoint.Address = new EndpointAddress(alternateUrl);

                    //Over ride the security mode to use no security mode
                    OverrideSecurityMode();
                }
            }
        }

        /// <summary>
        /// Default constructor
        /// Instantiates proxy and sets the End point address from npdb
        /// </summary>
        public CTPTransactionServiceWrapper()
            : base()
        {

            string billingProxy = string.Empty;

            this.Endpoint.Address = new EndpointAddress(CTPPurchaseTransactionServiceUrl);


            //Set the send timeout - note that this also sets the InnerChannel.OperationTimeout to the same 
            // value, though we change the OperationTimeout below for timeout injection testing
            this.Endpoint.Binding.SendTimeout = TimeSpan.FromSeconds(CTPPurchaseTransactionServiceTimeOut);

            //Add the client cert
            this.ClientCredentials.ClientCertificate.Certificate = _clientCert;

            //do not use the default web proxy use the billing proxy
            billingProxy = Config.GetSetting(Setting.billing_proxy);

            if (billingProxy != string.Empty)
            {
                if (this.Endpoint.Binding is BasicHttpBinding)
                {
                    ((BasicHttpBinding)this.Endpoint.Binding).UseDefaultWebProxy = false;

                    //set the web proxy to be the billing proxy
                    ((BasicHttpBinding)this.Endpoint.Binding).ProxyAddress = new Uri(Config.GetSetting(Setting.billing_proxy));

                    ((BasicHttpBinding)this.Endpoint.Binding).BypassProxyOnLocal = true;

                }
            }

            // Override URL if that's what we're supposed to do
            OverrideUrl();
        }

        private static X509Certificate2 _clientCert;

        /// <summary>
        /// Adds the DMP client certificate
        /// </summary>
        private static void GetClientCertificate()
        {
            string clientCertSubject = Config.GetSetting(Setting.dmp_clientCertSubject);
            Xom.Trace(XomAreaName.ctpTransactionServiceTrace, LogLevel.L_NORMAL, "GetClientCertificate: authenticating with certificate for: " + clientCertSubject);

            if (_clientCert == null)
            {
                _clientCert = new X509Certificate2(CertUtil.GetLocalMachineCertificate(clientCertSubject));
            }
        }

        #region Session variables
        [ThreadStaticAttribute]
        private static string _tlsSessionCTPApi = null;

        [ThreadStaticAttribute]
        private static string _tlsSessionAlternateUrl = null;

        // Get the session alternate Url
        public static string GetSessionAlternateUrl()
        {
            return _tlsSessionAlternateUrl;
        }


        // Reset the session alternate Url. Default Url will be used instead
        public static void ResetSessionAlternateUrl()
        {
            _tlsSessionAlternateUrl = null;

        }

        // Set the session alternate Url.
        public static void SetSessionAlternateUrl(string url)
        {
            // if the url doesn't look like a url, treat it as BehaviorInjection headers
            if (_urlRegex.IsMatch(url))
            {
                Xom.Trace(XomAreaName.spstrace, LogLevel.L_HIGH,"CTPTransactionWrapper.SetSessionAlternateUrl: using AlternateUrl: {0}...",url);

                _tlsSessionAlternateUrl = url;
            }
            else if (url.StartsWith(behaviorInjectionKey + ":",StringComparison.InvariantCultureIgnoreCase))
            {
                // header value itself follows "BEHAVIOR_INJECTIONS:" key
                string biHeader = url.Substring(behaviorInjectionKey.Length + 1);

                Xom.Trace(XomAreaName.spstrace, LogLevel.L_HIGH, "CTPTransactionWrapper.SetSessionAlternateUrl: adding BehaviorInjection headers: {0}...", biHeader);

                // construct a NameValueCollection and add it as the BehaviorInjections
                NameValueCollection nvc = new NameValueCollection();
                nvc.Add(behaviorInjectionKey, biHeader);
                RequestHeaderBehaviorInjectionMgr.AddBehaviorInjections(nvc);
            }
        }
        /// <summary>
        /// Resets the thread local storage
        /// </summary>
        public static void ResetSessionCtpApi()
        {
            _tlsSessionCTPApi = null;
        }

        /// <summary>
        /// sets the thread local storage
        /// </summary>
        /// <param name="api"></param>
        public static void SetSessionCtpApi(string api)
        {
            _tlsSessionCTPApi = api;
        }
        /// <summary>
        /// Gets the thread local storage
        /// </summary>
        /// <returns></returns>
        public static string GetSessionCtpApi()
        {
            return _tlsSessionCTPApi;
        }

        #endregion

        [ThreadStaticAttribute]
        private static int _tlsSessionClientType = 0;

        public static void ResetSessionClientType()
        {
            _tlsSessionClientType = 0;

            // make sure SessionClientInfo is also cleared
            ResetSessionClientInfo();
        }

        public static void SetSessionClientType(int clientType)
        {
            _tlsSessionClientType = clientType;
        }

        public static void SetSessionClientType(SessionClientType clientType)
        {
            SetSessionClientType((int)clientType);
        }

        public static void SetSessionClientType(SGInfo sg)
        {
            if (sg != null)
            {
                if (sg._IsXbox360() || sg._IsPc())
                {
                    SetSessionClientType((int)SessionClientType.XenonConsole);
                }
                else if (sg._IsInternal())
                {
                    SetSessionClientType((int)SessionClientType.LiveService);
                }
                else
                {
                    SetSessionClientType((int)SessionClientType.Xbox1Console);
                }
            }
            else
            {
                SetSessionClientType((int)SessionClientType.Xbox1Console);
            }

            // make sure SessionClientInfo is also populated
            SetSessionClientInfo(sg);
        }

        // In order to support passing IP address, device id, etc. to CTP,
        // this TLS can be used to track what is present in either SGInfo
        // or AAInfo
        [ThreadStaticAttribute]
        private static SessionClientInfo _tlsSessionClientInfo;

        public static void ResetSessionClientInfo()
        {
            _tlsSessionClientInfo = null;
        }

        public static void SetSessionClientInfo(SessionClientInfo clientInfo)
        {
            _tlsSessionClientInfo = clientInfo;
        }

        public static void SetSessionClientInfo(SGInfo sg)
        {
            if (sg != null)
            {
                string ipAddress = string.Empty;
                string deviceId = string.Empty;
                string deviceType = string.Empty;

                ipAddress = sg.ClientIP.ToString();
                deviceId = sg.MachineId.ToString("x");

                if (sg._IsXbox360())
                    deviceType = "Xbox 360";
                else if (sg._IsXbox())
                    deviceType = "Xbox";
                else if (sg._IsPc())
                    deviceType = "Panorama";
                else if (sg._IsInternal())
                {
                    deviceType = "Service";
                    deviceId = null;
                }
                else
                    deviceType = "Unknown";

                SetSessionClientInfo(ipAddress, deviceId, deviceType);
            }
        }

        public static void SetSessionClientInfo(string ipAddress, string deviceId, string deviceType)
        {
            SessionClientInfo clientInfo = new SessionClientInfo();
            clientInfo.ipAddress = ipAddress;
            clientInfo.deviceId = deviceId;
            clientInfo.deviceType = deviceType;
            _tlsSessionClientInfo = clientInfo;
        }

        public static void SetSessionClientInfo(AAInfo aaInfo)
        {
            if (aaInfo != null)
            {
                SessionClientInfo clientInfo = new SessionClientInfo();

                clientInfo.ipAddress = aaInfo.IpAddressInternet;
                clientInfo.deviceType = "IDCRL client";
                clientInfo.deviceId = aaInfo.PassportPuid.ToString("x");

                _tlsSessionClientInfo = clientInfo;
            }
        }

        public static SessionClientInfo GetSessionClientInfo()
        {
            return _tlsSessionClientInfo;
        }

        public static int GetSessionClientType()
        {
            return _tlsSessionClientType;
        }

        [ThreadStaticAttribute]
        private static string _fraudSessionId = String.Empty;

        public static void ResetFraudSessionId()
        {
            _fraudSessionId = String.Empty;
        }

        public static void SetFraudSessionId(string fraudSessionId)
        {
            _fraudSessionId = fraudSessionId;
        }

        public static string GetFraudSessionId()
        {
            return _fraudSessionId;
        }


        public static void ResetSessionState()
        {
            ResetSessionAlternateUrl();

            ResetSessionCtpApi();

            ResetSessionClientType();

            ResetFraudSessionId();
        }

        # region APIResult enums
        /// <summary>
        /// Api result enumration.Primarily for fast fail
        /// </summary>
        protected enum APIResultEnum
        {
            Success,
            FailFast,
            Failed,
            Timeout
        }
        #endregion

        # region Perfcounters and Timeout methods

        /// <summary>
        /// Increments the apispecific timeout counters
        /// </summary>
        /// <param name="apiName"></param>
        private void HandleTimeout(string apiName)
        {
            CTPTransactionCounters.Current(null).TimeoutsPerSecond.Increment();
            CTPTransactionCounters.Current(null).TimeoutsTotal.Increment();

            CTPTransactionCounters.Current(apiName).TimeoutsPerSecond.Increment();
            CTPTransactionCounters.Current(apiName).TimeoutsTotal.Increment();
        }

        /// <summary>
        /// Increments the api specific Calls/second counters
        /// </summary>
        /// <param name="apiName"></param>
        private void HandlePerfCountersBegin(string apiName)
        {
            CTPTransactionCounters.Current(null).CallsPerSecond.Increment();
            CTPTransactionCounters.Current(null).CallsTotal.Increment();

            CTPTransactionCounters.Current(apiName).CallsPerSecond.Increment();
            CTPTransactionCounters.Current(apiName).CallsTotal.Increment();
        }

        /// <summary>
        /// Final counter incrementation after api call suceeds/fails
        /// </summary>
        /// <param name="apiName"></param>
        /// <param name="result"></param>
        /// <param name="timeElapsed"></param>
        private void HandlePerfCountersEnd(string apiName, APIResultEnum result, XomRequestTimeElapsed timeElapsed)
        {
            CTPTransactionCounters.Current(null).CallsTime.IncrementBy(timeElapsed.TimeElapsed);
            CTPTransactionCounters.Current(null).CallsTimeBase.Increment();

            CTPTransactionCounters.Current(apiName).CallsTime.IncrementBy(timeElapsed.TimeElapsed);
            CTPTransactionCounters.Current(apiName).CallsTimeBase.Increment();

            if (result != APIResultEnum.Success && result != APIResultEnum.FailFast)
            {
                CTPTransactionCounters.Current(null).CallsFailedPerSecond.Increment();
                CTPTransactionCounters.Current(null).CallsFailedTotal.Increment();

                CTPTransactionCounters.Current(apiName).CallsFailedPerSecond.Increment();
                CTPTransactionCounters.Current(apiName).CallsFailedTotal.Increment();
            }
        }

        /// <summary>
        /// Log the API call and the result
        /// </summary>
        /// <param name="apiName"></param>
        /// <param name="result"></param>
        /// <param name="millisecondsElapsed"></param>
        /// <param name="inParams"></param>
        /// <param name="outParams"></param>
        /// <param name="ctpErrorDetails"></param>
        private void LogApiCall(string apiName, APIResultEnum result, long millisecondsElapsed, string[] inParams, string[] outParams, string ctpErrorDetails)
        {
            string resultString;
            switch (result)
            {
                case APIResultEnum.Success:
                    resultString = "Success";
                    break;

                case APIResultEnum.FailFast:
                    resultString = "FailFast";
                    break;

                case APIResultEnum.Failed:
                    resultString = "Failed";
                    break;

                case APIResultEnum.Timeout:
                    resultString = "Timeout";
                    break;

                default:
                    resultString = "Unknown";
                    break;
            }
            string szLog = string.Join("|", new string[]
            {
                apiName,
                resultString,
                millisecondsElapsed.ToString(),
                string.Join("|", inParams),
                result == APIResultEnum.Success ? string.Join("|", outParams) : "Failed",
                ctpErrorDetails == null ? "" : ctpErrorDetails
            });

            Xom.Log(XomAreaName.ctpTransactionServiceLog, szLog);
        }

        # endregion

        # region Method call
        /// <summary>
        /// Purchase method which does the following
        /// Set the session API variable
        /// Check for Fast Fail
        /// Begin handling the perf counters. The perf counters used as same as the existing Billing counters.
        /// Set the EndPoint binding close timeout from npdb.
        /// Call the TransactionServiceClient.Purchase
        /// Read Errors if any
        /// Finally block does the following
        ///Log the API call
        ///End the Performance counter handling
        /// </summary>
        /// <param name="purchaseReq"></param>
        /// <returns></returns>
        public new virtual PurchaseOutput Purchase(PurchaseInput purchaseReq)
        {

            string apiName = "Purchase";

            string auditMessage = string.Empty;

            APIResultEnum result = APIResultEnum.Failed;

            XomRequestTimeElapsed timeElapsed = new XomRequestTimeElapsed();

            string errorMessage = null;

            PurchaseOutput purchaseResp = null;

            FastFailTracker ffTracker = null;

            List<AuditParam> auditParams = new List<AuditParam>();

            string inputRequest = string.Empty;

            string outputResponse = string.Empty;

            CTPTransactionServiceException error = null;

            try
            {

                SetSessionCtpApi(apiName);

                ffTracker = GetFastFailTracker(apiName);

                HandlePerfCountersBegin(apiName);

                //Set the Fraud detection context
                purchaseReq.PurchaseContext.FraudDetectionContext = CTPTransactionServiceWrapper.GetFraudDetectionContext();

                inputRequest = GetDataContractXml<PurchaseInput>(purchaseReq);

                //add to the audit stream
                auditParams.Add(new AuditXmlParam("PurchaseInput", inputRequest));

                //Dont do any behaviour injection for compute only calls
                if (!purchaseReq.PurchaseContext.ComputeOnly)
                {

                    int timeoutMillis = CTPPurchaseTransactionServiceTimeOut * 1000;

                    //Handle the behaviour injection
                    CTPTransactionFailure.HandleBehaviorInjection(apiName, ref timeoutMillis);

                    //Reset the operation timeout using the injected value (if one was present)
                    this.InnerChannel.OperationTimeout = TimeSpan.FromMilliseconds(timeoutMillis);
                }

                //Call Billing partners
                using (HistogramPerfCounterManager.GetHistogramManager("CtpTransaction", apiName))
                {

                    purchaseResp = base.Purchase(purchaseReq);

                }

                error = CTPTransactionServiceException.FromCTPResponse(purchaseResp);

                outputResponse = GetDataContractXml<PurchaseOutput>(purchaseResp);

                if (error != null)
                {
                    auditMessage = "failure";

                    errorMessage = error.Message;

                    throw error;
                }

                result = APIResultEnum.Success;

                ffTracker.IndicateSuccess();

                auditMessage = "success";

                return purchaseResp;
            }
            catch (CommunicationException exception)
            {
                throw new NonUserCTPTransactionServiceException(exception,
                     XEvent.Id.CTP_TRANSACTIONSERVICE_COMMUNICATION_ERROR,
                     "Error communicating with CTP Servers",
                     true
                     , 0
                     );
            }
            catch (Exception ex)
            {
                if (FastFailHelper.ConsiderExceptionAsTimeout(ex))
                {
                    result = APIResultEnum.Timeout;

                    ffTracker.IndicateTimeout();

                    HandleTimeout(apiName);

                    throw new XRLException( HResult.XONLINE_E_BILLING_CTP_COMMUNICATION_ERROR, 
                                            XEvent.Id.CTP_TRANSACTIONSERVICE_COMMUNICATION_ERROR,
                                            "WebException communicating with CTP Servers", 
                                            ex);
                }
                else if (ex is CTPTransactionServiceException || ex is XRLExceptionWithoutEvent || ex is XRLException)
                {
                    throw;
                }
                else
                {
                    throw new NonUserCTPTransactionServiceException(ex,
                     XEvent.Id.CTP_NON_USER_EXCEPTION,
                     "Unknown error communicating with CTP Servers",
                     true
                     , 0
                     );
                }

            }
            finally
            {
                HandlePerfCountersEnd(apiName, result, timeElapsed);

                LogApiCall(apiName, result, timeElapsed.MillisecondsElapsed, new string[] { inputRequest }, new string[] { outputResponse }, (error == null) ? string.Empty : error.Message);

                if (auditParams.Count > 0)
                {
                    AuditStream.Write(0, AuditSubsystem.CTP, apiName, auditMessage, auditParams);
                    AuditStream.Flush();
                }
                if (ffTracker != null)
                {
                    ffTracker.IndicateSuccess();

                    ffTracker = null;
                }
            }
        }

        public new virtual JoinSubscriptionOutput JoinSubscription(JoinSubscriptionInput joinSubscriptionRequest)
        {

            string apiName = "JoinSubscription";

            string auditMessage = string.Empty;

            APIResultEnum result = APIResultEnum.Failed;

            XomRequestTimeElapsed timeElapsed = new XomRequestTimeElapsed();

            string errorMessage = null;

            JoinSubscriptionOutput joinSubscriptionResponse = null;

            FastFailTracker ffTracker = null;

            List<AuditParam> auditParams = new List<AuditParam>();

            string inputRequest = string.Empty;

            string outputResponse = string.Empty;

            CTPTransactionServiceException error = null;

            try
            {

                SetSessionCtpApi(apiName);

                ffTracker = GetFastFailTracker(apiName);

                HandlePerfCountersBegin(apiName);

                //Set the Fraud detection context
                joinSubscriptionRequest.JoinSubsContext.FraudDetectionContext = CTPTransactionServiceWrapper.GetFraudDetectionContext();

                inputRequest = GetDataContractXml<JoinSubscriptionInput>(joinSubscriptionRequest);

                //add to the audit stream
                auditParams.Add(new AuditXmlParam("JoinSubscriptionRequest", inputRequest));


                int timeoutMillis = CTPJoinSubscriptionTimeOut * 1000;

                //Handle the behaviour injection
                CTPTransactionFailure.HandleBehaviorInjection(apiName, ref timeoutMillis);

                //Reset the send timeout using the injected value (if one was present)
                this.Endpoint.Binding.SendTimeout = TimeSpan.FromMilliseconds(timeoutMillis);

                //Call Billing partners
                using (HistogramPerfCounterManager.GetHistogramManager("CtpTransaction", apiName))
                {

                    joinSubscriptionResponse = base.JoinSubscription(joinSubscriptionRequest);
                
                }

                error = CTPTransactionServiceException.FromCTPResponse(joinSubscriptionResponse);

                outputResponse = GetDataContractXml<JoinSubscriptionOutput>(joinSubscriptionResponse);

                if (error != null)
                {
                    auditMessage = "failure";

                    errorMessage = error.Message;

                    throw error;
                }

                result = APIResultEnum.Success;

                ffTracker.IndicateSuccess();

                auditMessage = "success";

                return joinSubscriptionResponse;
            }
            catch (CommunicationException exception)
            {
                throw new NonUserCTPTransactionServiceException(exception,
                     XEvent.Id.CTP_TRANSACTIONSERVICE_COMMUNICATION_ERROR,
                     "Error communicating with CTP Servers",
                     true
                     , 0
                     );
            }
            catch (Exception ex)
            {
                if (FastFailHelper.ConsiderExceptionAsTimeout(ex))
                {
                    result = APIResultEnum.Timeout;

                    ffTracker.IndicateTimeout();

                    HandleTimeout(apiName);

                    throw new NonUserCTPTransactionServiceException(ex,
                     XEvent.Id.CTP_TRANSACTIONSERVICE_COMMUNICATION_ERROR,
                     "WebException communicating with CTP Servers",
                     true
                     , 0
                     );
                }
                else if (ex is CTPTransactionServiceException)
                {
                    throw;
                }
                else
                {
                    throw new NonUserCTPTransactionServiceException(ex,
                     XEvent.Id.CTP_NON_USER_EXCEPTION,
                     "Unknown error communicating with CTP Servers",
                     true
                     , 0
                     );
                }

            }
            finally
            {
                HandlePerfCountersEnd(apiName, result, timeElapsed);

                LogApiCall(apiName, result, timeElapsed.MillisecondsElapsed, new string[] { inputRequest }, new string[] { outputResponse }, (error == null) ? string.Empty : error.Message);

                if (auditParams.Count > 0)
                {
                    AuditStream.Write(0, AuditSubsystem.CTP, apiName, auditMessage, auditParams);
                    AuditStream.Flush();
                }
                if (ffTracker != null)
                {
                    ffTracker.IndicateSuccess();

                    ffTracker = null;
                }
            }
        }

        public new virtual MigrateAccountOutput MigrateAccount(MigrateAccountInput migrateAccountRequest)
        {
            string apiName = "MigrateAccount";

            string auditMessage = string.Empty;

            APIResultEnum result = APIResultEnum.Failed;

            XomRequestTimeElapsed timeElapsed = new XomRequestTimeElapsed();

            string errorMessage = null;

            MigrateAccountOutput migrateAccountResponse = null;

            FastFailTracker ffTracker = null;

            List<AuditParam> auditParams = new List<AuditParam>();

            string inputRequest = string.Empty;

            string outputResponse = string.Empty;

            CTPTransactionServiceException error = null;

            try
            {

                SetSessionCtpApi(apiName);

                ffTracker = GetFastFailTracker(apiName);

                HandlePerfCountersBegin(apiName);

                //Set the Fraud detection context
                migrateAccountRequest.MigrateAccountContext.FraudDetectionContext = CTPTransactionServiceWrapper.GetFraudDetectionContext();

                inputRequest = GetDataContractXml<MigrateAccountInput>(migrateAccountRequest);

                //add to the audit stream
                auditParams.Add(new AuditXmlParam("MigrateAccountRequest", inputRequest));

                //Dont do any behaviour injection for compute only calls
                if (!migrateAccountRequest.MigrateAccountContext.ComputeOnly)
                {

                    int timeoutMillis = Config.GetIntSetting(Setting.billing_ctpMigrateAccountTimeoutSeconds) * 1000;

                    //Handle the behaviour injection
                    CTPTransactionFailure.HandleBehaviorInjection(apiName, ref timeoutMillis);

                    //Reset the operation timeout using the injected value (if one was present)
                    this.InnerChannel.OperationTimeout = TimeSpan.FromMilliseconds(timeoutMillis);
                }

                // call billing partner
                using (HistogramPerfCounterManager.GetHistogramManager("CtpTransaction", apiName))
                {
                 
                    migrateAccountResponse = base.MigrateAccount(migrateAccountRequest);
                
                }

                error = CTPTransactionServiceException.FromCTPResponse(migrateAccountResponse);

                outputResponse = GetDataContractXml<MigrateAccountOutput>(migrateAccountResponse);

                if (error != null)
                {
                    auditMessage = "failure";

                    errorMessage = error.Message;

                    throw error;
                }

                result = APIResultEnum.Success;

                ffTracker.IndicateSuccess();

                auditMessage = "success";

                return migrateAccountResponse;
            }
            catch (CommunicationException exception)
            {
                throw new NonUserCTPTransactionServiceException(exception,
                     XEvent.Id.CTP_TRANSACTIONSERVICE_COMMUNICATION_ERROR,
                     "Error communicating with CTP Servers",
                     true
                     , 0
                     );
            }
            catch (Exception ex)
            {
                if (FastFailHelper.ConsiderExceptionAsTimeout(ex))
                {
                    result = APIResultEnum.Timeout;

                    ffTracker.IndicateTimeout();

                    HandleTimeout(apiName);

                    throw new NonUserCTPTransactionServiceException(ex,
                     XEvent.Id.CTP_TRANSACTIONSERVICE_COMMUNICATION_ERROR,
                     "WebException communicating with CTP Servers",
                     true
                     , 0
                     );
                }
                else if (ex is CTPTransactionServiceException)
                {
                    throw;
                }
                else
                {
                    throw new NonUserCTPTransactionServiceException(ex,
                     XEvent.Id.CTP_NON_USER_EXCEPTION,
                     "Unknown error communicating with CTP Servers",
                     true
                     , 0
                     );
                }

            }
            finally
            {
                HandlePerfCountersEnd(apiName, result, timeElapsed);

                LogApiCall(apiName, result, timeElapsed.MillisecondsElapsed, new string[] { inputRequest }, new string[] { outputResponse }, (error == null) ? string.Empty : error.Message);

                if (auditParams.Count > 0)
                {
                    AuditStream.Write(0, AuditSubsystem.CTP, apiName, auditMessage, auditParams);
                    AuditStream.Flush();
                }
                if (ffTracker != null)
                {
                    ffTracker.IndicateSuccess();

                    ffTracker = null;
                }
            }
        }

        public new virtual string TestConnection(string inputString)
        {
            return base.TestConnection(inputString);
        }

        # endregion

        /// <summary>
        /// Retrieves the DataContractXml for PurchaseInput
        /// </summary>
        /// <param name="purchaseReq"></param>
        /// <returns></returns>
        public static string GetDataContractXml<T>(T datacontractObject)
        {
            MemoryStream memoryStream = new MemoryStream();

            DataContractSerializer dcSerializer = new DataContractSerializer(typeof(T));

            XmlWriterSettings xmlWriterSettings = new XmlWriterSettings();

            xmlWriterSettings.Encoding = new UTF8Encoding(false);

            xmlWriterSettings.ConformanceLevel = ConformanceLevel.Document;

            xmlWriterSettings.Indent = true;

            string serializedString = string.Empty;

            using (XmlWriter xWriter = XmlWriter.Create(memoryStream, xmlWriterSettings))
            {

                dcSerializer.WriteObject(xWriter, datacontractObject);
                xWriter.Flush();


                memoryStream.Position = 0;

                XmlDocument xDoc = new XmlDocument();
                xDoc.Load(memoryStream);

                serializedString = xDoc.OuterXml;
            }

            return serializedString;
        }

        public static T GetDataContractObject<T>(string xml)
        {

            DataContractSerializer dcSerializer = new DataContractSerializer(typeof(T));

            T retObject = default(T); ;

            using (XmlTextReader reader = new XmlTextReader(new StringReader(xml)))
            {

                retObject = (T)dcSerializer.ReadObject(reader, true);
            }

            return retObject;

        }

        public static string ConvertObjectToXml<T>(T serializableObject)
        {
            XmlSerializer serializer = new XmlSerializer(typeof(T));

            StringWriter stringWriter = new StringWriter();

            XmlTextWriterMinimalist xmlWriter = new XmlTextWriterMinimalist(stringWriter);

            string xml = null;
            try
            {
                serializer.Serialize(xmlWriter, serializableObject);

                xml = stringWriter.ToString();
            }
            finally
            {
                xmlWriter.Close();

                stringWriter.Close();
            }

            return xml;
        }

        public static T GetObjectFromXml<T>(string xml)
        {
            T item = default(T);

            XmlSerializer serializer = new XmlSerializer(typeof(T));

            StringReader stream = new StringReader(xml);

            XmlTextReader reader = new XmlTextReader(stream);

            item = (T)serializer.Deserialize(reader);

            return item;
        }

        public static Property[] GetFraudDetectionContext()
        {
            SessionClientInfo clientInfo = GetSessionClientInfo();

            if (clientInfo == null)
            {
                return null;
            }

            int propertyCount = 7;

            //Only add a property for the FraudSessionId if the caller has provided a value via SetFraudSessionId
            if (!String.IsNullOrEmpty(_fraudSessionId))
            {
                propertyCount++;
            }

            Property[] fraudDetectionContext = new Property[propertyCount];

            fraudDetectionContext[0] = new Property();
            fraudDetectionContext[0].Name = "IPAddress";
            fraudDetectionContext[0].Value = clientInfo.ipAddress == null ? string.Empty : clientInfo.ipAddress;
            fraudDetectionContext[0].Namespace = "XboxLive-IPAddress";

            fraudDetectionContext[1] = new Property();
            fraudDetectionContext[1].Name = "DeviceType";
            fraudDetectionContext[1].Value = clientInfo.deviceType == null ? string.Empty : clientInfo.deviceType;
            fraudDetectionContext[1].Namespace = "XboxLive-DeviceType";

            fraudDetectionContext[2] = new Property();
            fraudDetectionContext[2].Name = "DeviceId";
            fraudDetectionContext[2].Value = clientInfo.deviceId == null ? string.Empty : clientInfo.deviceId;
            fraudDetectionContext[2].Namespace = "XboxLive-DeviceId";

            fraudDetectionContext[3] = new Property();
            fraudDetectionContext[3].Name = "AcceptLanguage";
            fraudDetectionContext[3].Value = clientInfo.acceptLanguage == null ? string.Empty : clientInfo.acceptLanguage;
            fraudDetectionContext[3].Namespace = "XboxLive-AcceptLanguage";

            fraudDetectionContext[4] = new Property();
            fraudDetectionContext[4].Name = "AcceptCharset";
            fraudDetectionContext[4].Value = clientInfo.acceptCharset == null ? string.Empty : clientInfo.acceptCharset;
            fraudDetectionContext[4].Namespace = "XboxLive-AcceptCharset";

            fraudDetectionContext[5] = new Property();
            fraudDetectionContext[5].Name = "UserAgent";
            fraudDetectionContext[5].Value = clientInfo.userAgent == null ? string.Empty : clientInfo.userAgent;
            fraudDetectionContext[5].Namespace = "XboxLive-UserAgent";

            fraudDetectionContext[6] = new Property();
            fraudDetectionContext[6].Name = "XForwardedFor";
            fraudDetectionContext[6].Value = clientInfo.xForwardedFor == null ? string.Empty : clientInfo.xForwardedFor;
            fraudDetectionContext[6].Namespace = "XboxLive-XForwardedFor";

            if (!String.IsNullOrEmpty(_fraudSessionId))
            {
                fraudDetectionContext[7] = new Property();
                fraudDetectionContext[7].Name = XHttpHdr.THMSESSIONID;
                fraudDetectionContext[7].Value = _fraudSessionId;
                fraudDetectionContext[7].Namespace = String.Empty;
            }

            return fraudDetectionContext;
        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\marketplace\billing\CTP\CTPTransactionService.cs ===
﻿//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:2.0.50727.4927
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

namespace CTPTransactionService
{
    using System.Runtime.Serialization;
    
    
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.Runtime.Serialization", "3.0.0.0")]
    [System.Runtime.Serialization.DataContractAttribute(Name="AbstractRequest", Namespace="urn:schemas.microsoft.com/CommercePlatform/Services/TransactionService/2010/01")]
    [System.Runtime.Serialization.KnownTypeAttribute(typeof(CTPTransactionService.PayoutInput))]
    [System.Runtime.Serialization.KnownTypeAttribute(typeof(CTPTransactionService.JoinSubscriptionInput))]
    [System.Runtime.Serialization.KnownTypeAttribute(typeof(CTPTransactionService.MigrateAccountInput))]
    [System.Runtime.Serialization.KnownTypeAttribute(typeof(CTPTransactionService.GetPayoutOrderStatusInput))]
    [System.Runtime.Serialization.KnownTypeAttribute(typeof(CTPTransactionService.GetPayoutOrderEventUpdateInput))]
    [System.Runtime.Serialization.KnownTypeAttribute(typeof(CTPTransactionService.RegisterUserInput))]
    [System.Runtime.Serialization.KnownTypeAttribute(typeof(CTPTransactionService.PurchaseInput))]
    public partial class AbstractRequest : object, System.Runtime.Serialization.IExtensibleDataObject
    {
        
        private System.Runtime.Serialization.ExtensionDataObject extensionDataField;
        
        public System.Runtime.Serialization.ExtensionDataObject ExtensionData
        {
            get
            {
                return this.extensionDataField;
            }
            set
            {
                this.extensionDataField = value;
            }
        }
    }
    
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.Runtime.Serialization", "3.0.0.0")]
    [System.Runtime.Serialization.DataContractAttribute(Name="PayoutInput", Namespace="urn:schemas.microsoft.com/CommercePlatform/Services/TransactionService/2010/01")]
    public partial class PayoutInput : CTPTransactionService.AbstractRequest
    {
        
        private CTPTransactionService.APIContext APIContextField;
        
        private CTPTransactionService.BillingInfo BillingInfoField;
        
        private CTPTransactionService.CallerInfo CallerInfoField;
        
        private CTPTransactionService.PartnerApprovalInfo PartnerApprovalInfoField;
        
        private CTPTransactionService.PayoutContext PayoutContextField;
        
        private CTPTransactionService.PayoutOrderInput PayoutOrderInputField;
        
        private CTPTransactionService.Partner PayoutPartnerField;
        
        private CTPTransactionService.TaxProfileInfo TaxProfileInfoField;
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public CTPTransactionService.APIContext APIContext
        {
            get
            {
                return this.APIContextField;
            }
            set
            {
                this.APIContextField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public CTPTransactionService.BillingInfo BillingInfo
        {
            get
            {
                return this.BillingInfoField;
            }
            set
            {
                this.BillingInfoField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public CTPTransactionService.CallerInfo CallerInfo
        {
            get
            {
                return this.CallerInfoField;
            }
            set
            {
                this.CallerInfoField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public CTPTransactionService.PartnerApprovalInfo PartnerApprovalInfo
        {
            get
            {
                return this.PartnerApprovalInfoField;
            }
            set
            {
                this.PartnerApprovalInfoField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public CTPTransactionService.PayoutContext PayoutContext
        {
            get
            {
                return this.PayoutContextField;
            }
            set
            {
                this.PayoutContextField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public CTPTransactionService.PayoutOrderInput PayoutOrderInput
        {
            get
            {
                return this.PayoutOrderInputField;
            }
            set
            {
                this.PayoutOrderInputField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public CTPTransactionService.Partner PayoutPartner
        {
            get
            {
                return this.PayoutPartnerField;
            }
            set
            {
                this.PayoutPartnerField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public CTPTransactionService.TaxProfileInfo TaxProfileInfo
        {
            get
            {
                return this.TaxProfileInfoField;
            }
            set
            {
                this.TaxProfileInfoField = value;
            }
        }
    }
    
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.Runtime.Serialization", "3.0.0.0")]
    [System.Runtime.Serialization.DataContractAttribute(Name="JoinSubscriptionInput", Namespace="urn:schemas.microsoft.com/CommercePlatform/Services/TransactionService/2010/01")]
    public partial class JoinSubscriptionInput : CTPTransactionService.AbstractRequest
    {
        
        private CTPTransactionService.APIContext APIContextField;
        
        private CTPTransactionService.CallerInfo CallerInfoField;
        
        private CTPTransactionService.JoinSubsContext JoinSubsContextField;
        
        private CTPTransactionService.JoinSubscriptionInfoInput JoinSubscriptionInfoInputField;
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public CTPTransactionService.APIContext APIContext
        {
            get
            {
                return this.APIContextField;
            }
            set
            {
                this.APIContextField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public CTPTransactionService.CallerInfo CallerInfo
        {
            get
            {
                return this.CallerInfoField;
            }
            set
            {
                this.CallerInfoField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public CTPTransactionService.JoinSubsContext JoinSubsContext
        {
            get
            {
                return this.JoinSubsContextField;
            }
            set
            {
                this.JoinSubsContextField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public CTPTransactionService.JoinSubscriptionInfoInput JoinSubscriptionInfoInput
        {
            get
            {
                return this.JoinSubscriptionInfoInputField;
            }
            set
            {
                this.JoinSubscriptionInfoInputField = value;
            }
        }
    }
    
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.Runtime.Serialization", "3.0.0.0")]
    [System.Runtime.Serialization.DataContractAttribute(Name="MigrateAccountInput", Namespace="urn:schemas.microsoft.com/CommercePlatform/Services/TransactionService/2010/01")]
    public partial class MigrateAccountInput : CTPTransactionService.AbstractRequest
    {
        
        private CTPTransactionService.APIContext APIContextField;
        
        private CTPTransactionService.CallerInfo CallerInfoField;
        
        private CTPTransactionService.MigrateAccountContext MigrateAccountContextField;
        
        private CTPTransactionService.MigrateAccountInfoInput MigrateAccountInfoInputField;
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public CTPTransactionService.APIContext APIContext
        {
            get
            {
                return this.APIContextField;
            }
            set
            {
                this.APIContextField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public CTPTransactionService.CallerInfo CallerInfo
        {
            get
            {
                return this.CallerInfoField;
            }
            set
            {
                this.CallerInfoField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public CTPTransactionService.MigrateAccountContext MigrateAccountContext
        {
            get
            {
                return this.MigrateAccountContextField;
            }
            set
            {
                this.MigrateAccountContextField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public CTPTransactionService.MigrateAccountInfoInput MigrateAccountInfoInput
        {
            get
            {
                return this.MigrateAccountInfoInputField;
            }
            set
            {
                this.MigrateAccountInfoInputField = value;
            }
        }
    }
    
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.Runtime.Serialization", "3.0.0.0")]
    [System.Runtime.Serialization.DataContractAttribute(Name="GetPayoutOrderStatusInput", Namespace="urn:schemas.microsoft.com/CommercePlatform/Services/TransactionService/2010/01")]
    public partial class GetPayoutOrderStatusInput : CTPTransactionService.AbstractRequest
    {
        
        private CTPTransactionService.CallerInfo CallerInfoField;
        
        private CTPTransactionService.PayoutFilter FilterField;
        
        private int NumRecordsRequestedField;
        
        private string StartHandlerField;
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public CTPTransactionService.CallerInfo CallerInfo
        {
            get
            {
                return this.CallerInfoField;
            }
            set
            {
                this.CallerInfoField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public CTPTransactionService.PayoutFilter Filter
        {
            get
            {
                return this.FilterField;
            }
            set
            {
                this.FilterField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public int NumRecordsRequested
        {
            get
            {
                return this.NumRecordsRequestedField;
            }
            set
            {
                this.NumRecordsRequestedField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public string StartHandler
        {
            get
            {
                return this.StartHandlerField;
            }
            set
            {
                this.StartHandlerField = value;
            }
        }
    }
    
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.Runtime.Serialization", "3.0.0.0")]
    [System.Runtime.Serialization.DataContractAttribute(Name="GetPayoutOrderEventUpdateInput", Namespace="urn:schemas.microsoft.com/CommercePlatform/Services/TransactionService/2010/01")]
    public partial class GetPayoutOrderEventUpdateInput : CTPTransactionService.AbstractRequest
    {
        
        private CTPTransactionService.PayoutFilter FilterField;
        
        private int NumRecordsRequestedField;
        
        private CTPTransactionService.Partner PayoutPartnerField;
        
        private string StartHandlerField;
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public CTPTransactionService.PayoutFilter Filter
        {
            get
            {
                return this.FilterField;
            }
            set
            {
                this.FilterField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public int NumRecordsRequested
        {
            get
            {
                return this.NumRecordsRequestedField;
            }
            set
            {
                this.NumRecordsRequestedField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public CTPTransactionService.Partner PayoutPartner
        {
            get
            {
                return this.PayoutPartnerField;
            }
            set
            {
                this.PayoutPartnerField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public string StartHandler
        {
            get
            {
                return this.StartHandlerField;
            }
            set
            {
                this.StartHandlerField = value;
            }
        }
    }
    
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.Runtime.Serialization", "3.0.0.0")]
    [System.Runtime.Serialization.DataContractAttribute(Name="RegisterUserInput", Namespace="urn:schemas.microsoft.com/CommercePlatform/Services/TransactionService/2010/01")]
    public partial class RegisterUserInput : CTPTransactionService.AbstractRequest
    {
        
        private CTPTransactionService.APIContext APIContextField;
        
        private CTPTransactionService.CallerInfo CallerInfoField;
        
        private CTPTransactionService.Property[] PropertyBagField;
        
        private CTPTransactionService.RegisterUserInfoInput RegisterUserInfoInputField;
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public CTPTransactionService.APIContext APIContext
        {
            get
            {
                return this.APIContextField;
            }
            set
            {
                this.APIContextField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public CTPTransactionService.CallerInfo CallerInfo
        {
            get
            {
                return this.CallerInfoField;
            }
            set
            {
                this.CallerInfoField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public CTPTransactionService.Property[] PropertyBag
        {
            get
            {
                return this.PropertyBagField;
            }
            set
            {
                this.PropertyBagField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public CTPTransactionService.RegisterUserInfoInput RegisterUserInfoInput
        {
            get
            {
                return this.RegisterUserInfoInputField;
            }
            set
            {
                this.RegisterUserInfoInputField = value;
            }
        }
    }
    
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.Runtime.Serialization", "3.0.0.0")]
    [System.Runtime.Serialization.DataContractAttribute(Name="PurchaseInput", Namespace="urn:schemas.microsoft.com/CommercePlatform/Services/TransactionService/2010/01")]
    public partial class PurchaseInput : CTPTransactionService.AbstractRequest
    {
        
        private CTPTransactionService.APIContext APIContextField;
        
        private CTPTransactionService.BillingInfo BillingInfoField;
        
        private CTPTransactionService.CallerInfo CallerInfoField;
        
        private CTPTransactionService.Marketplace MarketplaceField;
        
        private CTPTransactionService.PurchaseContext PurchaseContextField;
        
        private CTPTransactionService.PurchaseInfoInput PurchaseInfoInputField;
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public CTPTransactionService.APIContext APIContext
        {
            get
            {
                return this.APIContextField;
            }
            set
            {
                this.APIContextField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public CTPTransactionService.BillingInfo BillingInfo
        {
            get
            {
                return this.BillingInfoField;
            }
            set
            {
                this.BillingInfoField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public CTPTransactionService.CallerInfo CallerInfo
        {
            get
            {
                return this.CallerInfoField;
            }
            set
            {
                this.CallerInfoField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public CTPTransactionService.Marketplace Marketplace
        {
            get
            {
                return this.MarketplaceField;
            }
            set
            {
                this.MarketplaceField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public CTPTransactionService.PurchaseContext PurchaseContext
        {
            get
            {
                return this.PurchaseContextField;
            }
            set
            {
                this.PurchaseContextField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public CTPTransactionService.PurchaseInfoInput PurchaseInfoInput
        {
            get
            {
                return this.PurchaseInfoInputField;
            }
            set
            {
                this.PurchaseInfoInputField = value;
            }
        }
    }
    
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.Runtime.Serialization", "3.0.0.0")]
    [System.Runtime.Serialization.DataContractAttribute(Name="APIContext", Namespace="urn:schemas.microsoft.com/CommercePlatform/Services/TransactionService/2010/01")]
    public partial class APIContext : object, System.Runtime.Serialization.IExtensibleDataObject
    {
        
        private System.Runtime.Serialization.ExtensionDataObject extensionDataField;
        
        private CTPTransactionService.Property[] FraudDetectionContextField;
        
        private CTPTransactionService.Property[] PropertyBagField;
        
        private System.Guid TrackingGuidField;
        
        public System.Runtime.Serialization.ExtensionDataObject ExtensionData
        {
            get
            {
                return this.extensionDataField;
            }
            set
            {
                this.extensionDataField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public CTPTransactionService.Property[] FraudDetectionContext
        {
            get
            {
                return this.FraudDetectionContextField;
            }
            set
            {
                this.FraudDetectionContextField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public CTPTransactionService.Property[] PropertyBag
        {
            get
            {
                return this.PropertyBagField;
            }
            set
            {
                this.PropertyBagField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public System.Guid TrackingGuid
        {
            get
            {
                return this.TrackingGuidField;
            }
            set
            {
                this.TrackingGuidField = value;
            }
        }
    }
    
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.Runtime.Serialization", "3.0.0.0")]
    [System.Runtime.Serialization.DataContractAttribute(Name="BillingInfo", Namespace="urn:schemas.microsoft.com/CommercePlatform/Services/TransactionService/2010/01")]
    public partial class BillingInfo : object, System.Runtime.Serialization.IExtensibleDataObject
    {
        
        private System.Runtime.Serialization.ExtensionDataObject extensionDataField;
        
        private CTPTransactionService.BillingMode BillingModeField;
        
        private CTPTransactionService.PaymentMethod[] PaymentMethodField;
        
        private CTPTransactionService.Property[] PropertyBagField;
        
        public System.Runtime.Serialization.ExtensionDataObject ExtensionData
        {
            get
            {
                return this.extensionDataField;
            }
            set
            {
                this.extensionDataField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public CTPTransactionService.BillingMode BillingMode
        {
            get
            {
                return this.BillingModeField;
            }
            set
            {
                this.BillingModeField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public CTPTransactionService.PaymentMethod[] PaymentMethod
        {
            get
            {
                return this.PaymentMethodField;
            }
            set
            {
                this.PaymentMethodField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public CTPTransactionService.Property[] PropertyBag
        {
            get
            {
                return this.PropertyBagField;
            }
            set
            {
                this.PropertyBagField = value;
            }
        }
    }
    
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.Runtime.Serialization", "3.0.0.0")]
    [System.Runtime.Serialization.DataContractAttribute(Name="CallerInfo", Namespace="urn:schemas.microsoft.com/CommercePlatform/Services/TransactionService/2010/01")]
    public partial class CallerInfo : object, System.Runtime.Serialization.IExtensibleDataObject
    {
        
        private System.Runtime.Serialization.ExtensionDataObject extensionDataField;
        
        private string AccountIdField;
        
        private string AddressIdField;
        
        private CTPTransactionService.Identity DelegatorField;
        
        private CTPTransactionService.Identity RequesterField;
        
        public System.Runtime.Serialization.ExtensionDataObject ExtensionData
        {
            get
            {
                return this.extensionDataField;
            }
            set
            {
                this.extensionDataField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public string AccountId
        {
            get
            {
                return this.AccountIdField;
            }
            set
            {
                this.AccountIdField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public string AddressId
        {
            get
            {
                return this.AddressIdField;
            }
            set
            {
                this.AddressIdField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public CTPTransactionService.Identity Delegator
        {
            get
            {
                return this.DelegatorField;
            }
            set
            {
                this.DelegatorField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public CTPTransactionService.Identity Requester
        {
            get
            {
                return this.RequesterField;
            }
            set
            {
                this.RequesterField = value;
            }
        }
    }
    
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.Runtime.Serialization", "3.0.0.0")]
    [System.Runtime.Serialization.DataContractAttribute(Name="Marketplace", Namespace="urn:schemas.microsoft.com/CommercePlatform/Services/TransactionService/2010/01")]
    public partial class Marketplace : object, System.Runtime.Serialization.IExtensibleDataObject
    {
        
        private System.Runtime.Serialization.ExtensionDataObject extensionDataField;
        
        private System.Guid MarkerplaceGuidField;
        
        private string MarketplaceNameField;
        
        private CTPTransactionService.Property[] PropertyBagField;
        
        public System.Runtime.Serialization.ExtensionDataObject ExtensionData
        {
            get
            {
                return this.extensionDataField;
            }
            set
            {
                this.extensionDataField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public System.Guid MarkerplaceGuid
        {
            get
            {
                return this.MarkerplaceGuidField;
            }
            set
            {
                this.MarkerplaceGuidField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public string MarketplaceName
        {
            get
            {
                return this.MarketplaceNameField;
            }
            set
            {
                this.MarketplaceNameField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public CTPTransactionService.Property[] PropertyBag
        {
            get
            {
                return this.PropertyBagField;
            }
            set
            {
                this.PropertyBagField = value;
            }
        }
    }
    
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.Runtime.Serialization", "3.0.0.0")]
    [System.Runtime.Serialization.DataContractAttribute(Name="PurchaseContext", Namespace="urn:schemas.microsoft.com/CommercePlatform/Services/TransactionService/2010/01")]
    public partial class PurchaseContext : object, System.Runtime.Serialization.IExtensibleDataObject
    {
        
        private System.Runtime.Serialization.ExtensionDataObject extensionDataField;
        
        private bool ComputeOnlyField;
        
        private CTPTransactionService.Property[] FraudDetectionContextField;
        
        private CTPTransactionService.Policy PolicyField;
        
        private CTPTransactionService.Property[] PropertyBagField;
        
        private System.DateTime TimeStampField;
        
        public System.Runtime.Serialization.ExtensionDataObject ExtensionData
        {
            get
            {
                return this.extensionDataField;
            }
            set
            {
                this.extensionDataField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public bool ComputeOnly
        {
            get
            {
                return this.ComputeOnlyField;
            }
            set
            {
                this.ComputeOnlyField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public CTPTransactionService.Property[] FraudDetectionContext
        {
            get
            {
                return this.FraudDetectionContextField;
            }
            set
            {
                this.FraudDetectionContextField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public CTPTransactionService.Policy Policy
        {
            get
            {
                return this.PolicyField;
            }
            set
            {
                this.PolicyField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public CTPTransactionService.Property[] PropertyBag
        {
            get
            {
                return this.PropertyBagField;
            }
            set
            {
                this.PropertyBagField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public System.DateTime TimeStamp
        {
            get
            {
                return this.TimeStampField;
            }
            set
            {
                this.TimeStampField = value;
            }
        }
    }
    
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.Runtime.Serialization", "3.0.0.0")]
    [System.Runtime.Serialization.DataContractAttribute(Name="PurchaseInfoInput", Namespace="urn:schemas.microsoft.com/CommercePlatform/Services/TransactionService/2010/01")]
    public partial class PurchaseInfoInput : object, System.Runtime.Serialization.IExtensibleDataObject
    {
        
        private System.Runtime.Serialization.ExtensionDataObject extensionDataField;
        
        private System.Nullable<int> CampaignIdField;
        
        private string ClientAddressField;
        
        private string DescriptionField;
        
        private string ExternalPurchaseIdField;
        
        private CTPTransactionService.Property[] PropertyBagField;
        
        private CTPTransactionService.PurchaseBundleInput[] PurchaseBundleInputSetField;
        
        private CTPTransactionService.SalesModelType SalesModelField;
        
        private string TitleField;
        
        public System.Runtime.Serialization.ExtensionDataObject ExtensionData
        {
            get
            {
                return this.extensionDataField;
            }
            set
            {
                this.extensionDataField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public System.Nullable<int> CampaignId
        {
            get
            {
                return this.CampaignIdField;
            }
            set
            {
                this.CampaignIdField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public string ClientAddress
        {
            get
            {
                return this.ClientAddressField;
            }
            set
            {
                this.ClientAddressField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public string Description
        {
            get
            {
                return this.DescriptionField;
            }
            set
            {
                this.DescriptionField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public string ExternalPurchaseId
        {
            get
            {
                return this.ExternalPurchaseIdField;
            }
            set
            {
                this.ExternalPurchaseIdField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public CTPTransactionService.Property[] PropertyBag
        {
            get
            {
                return this.PropertyBagField;
            }
            set
            {
                this.PropertyBagField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public CTPTransactionService.PurchaseBundleInput[] PurchaseBundleInputSet
        {
            get
            {
                return this.PurchaseBundleInputSetField;
            }
            set
            {
                this.PurchaseBundleInputSetField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public CTPTransactionService.SalesModelType SalesModel
        {
            get
            {
                return this.SalesModelField;
            }
            set
            {
                this.SalesModelField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public string Title
        {
            get
            {
                return this.TitleField;
            }
            set
            {
                this.TitleField = value;
            }
        }
    }
    
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.Runtime.Serialization", "3.0.0.0")]
    [System.Runtime.Serialization.DataContractAttribute(Name="PartnerApprovalInfo", Namespace="urn:schemas.microsoft.com/CommercePlatform/Services/TransactionService/2010/01")]
    public partial class PartnerApprovalInfo : object, System.Runtime.Serialization.IExtensibleDataObject
    {
        
        private System.Runtime.Serialization.ExtensionDataObject extensionDataField;
        
        private CTPTransactionService.ApproveDecision ApproveDecisionField;
        
        private string ApproveIdField;
        
        private string ApproverField;
        
        private CTPTransactionService.Property[] PropertyBagField;
        
        public System.Runtime.Serialization.ExtensionDataObject ExtensionData
        {
            get
            {
                return this.extensionDataField;
            }
            set
            {
                this.extensionDataField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public CTPTransactionService.ApproveDecision ApproveDecision
        {
            get
            {
                return this.ApproveDecisionField;
            }
            set
            {
                this.ApproveDecisionField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public string ApproveId
        {
            get
            {
                return this.ApproveIdField;
            }
            set
            {
                this.ApproveIdField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public string Approver
        {
            get
            {
                return this.ApproverField;
            }
            set
            {
                this.ApproverField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public CTPTransactionService.Property[] PropertyBag
        {
            get
            {
                return this.PropertyBagField;
            }
            set
            {
                this.PropertyBagField = value;
            }
        }
    }
    
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.Runtime.Serialization", "3.0.0.0")]
    [System.Runtime.Serialization.DataContractAttribute(Name="PayoutContext", Namespace="urn:schemas.microsoft.com/CommercePlatform/Services/TransactionService/2010/01")]
    public partial class PayoutContext : object, System.Runtime.Serialization.IExtensibleDataObject
    {
        
        private System.Runtime.Serialization.ExtensionDataObject extensionDataField;
        
        private bool ComputeOnlyField;
        
        private CTPTransactionService.Property[] FraudDetectionContextField;
        
        private CTPTransactionService.Property[] PropertyBagField;
        
        private System.DateTime TimeStampField;
        
        public System.Runtime.Serialization.ExtensionDataObject ExtensionData
        {
            get
            {
                return this.extensionDataField;
            }
            set
            {
                this.extensionDataField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public bool ComputeOnly
        {
            get
            {
                return this.ComputeOnlyField;
            }
            set
            {
                this.ComputeOnlyField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public CTPTransactionService.Property[] FraudDetectionContext
        {
            get
            {
                return this.FraudDetectionContextField;
            }
            set
            {
                this.FraudDetectionContextField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public CTPTransactionService.Property[] PropertyBag
        {
            get
            {
                return this.PropertyBagField;
            }
            set
            {
                this.PropertyBagField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public System.DateTime TimeStamp
        {
            get
            {
                return this.TimeStampField;
            }
            set
            {
                this.TimeStampField = value;
            }
        }
    }
    
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.Runtime.Serialization", "3.0.0.0")]
    [System.Runtime.Serialization.DataContractAttribute(Name="PayoutOrderInput", Namespace="urn:schemas.microsoft.com/CommercePlatform/Services/TransactionService/2010/01")]
    public partial class PayoutOrderInput : object, System.Runtime.Serialization.IExtensibleDataObject
    {
        
        private System.Runtime.Serialization.ExtensionDataObject extensionDataField;
        
        private string DescriptionField;
        
        private string ExternalPayoutIdField;
        
        private System.Nullable<System.DateTime> ForeignExchangeRateDateField;
        
        private CTPTransactionService.PayoutLineEntryInput[] PayoutLineEntryInputSetField;
        
        private CTPTransactionService.Property[] PropertyBagField;
        
        private string SourceCurrencyField;
        
        private string TargetCurrencyField;
        
        public System.Runtime.Serialization.ExtensionDataObject ExtensionData
        {
            get
            {
                return this.extensionDataField;
            }
            set
            {
                this.extensionDataField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public string Description
        {
            get
            {
                return this.DescriptionField;
            }
            set
            {
                this.DescriptionField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public string ExternalPayoutId
        {
            get
            {
                return this.ExternalPayoutIdField;
            }
            set
            {
                this.ExternalPayoutIdField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public System.Nullable<System.DateTime> ForeignExchangeRateDate
        {
            get
            {
                return this.ForeignExchangeRateDateField;
            }
            set
            {
                this.ForeignExchangeRateDateField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public CTPTransactionService.PayoutLineEntryInput[] PayoutLineEntryInputSet
        {
            get
            {
                return this.PayoutLineEntryInputSetField;
            }
            set
            {
                this.PayoutLineEntryInputSetField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public CTPTransactionService.Property[] PropertyBag
        {
            get
            {
                return this.PropertyBagField;
            }
            set
            {
                this.PropertyBagField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public string SourceCurrency
        {
            get
            {
                return this.SourceCurrencyField;
            }
            set
            {
                this.SourceCurrencyField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public string TargetCurrency
        {
            get
            {
                return this.TargetCurrencyField;
            }
            set
            {
                this.TargetCurrencyField = value;
            }
        }
    }
    
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.Runtime.Serialization", "3.0.0.0")]
    [System.Runtime.Serialization.DataContractAttribute(Name="Partner", Namespace="urn:schemas.microsoft.com/CommercePlatform/Services/TransactionService/2010/01")]
    public partial class Partner : object, System.Runtime.Serialization.IExtensibleDataObject
    {
        
        private System.Runtime.Serialization.ExtensionDataObject extensionDataField;
        
        private System.Guid PartnerGuidField;
        
        private CTPTransactionService.Property[] PropertyBagField;
        
        public System.Runtime.Serialization.ExtensionDataObject ExtensionData
        {
            get
            {
                return this.extensionDataField;
            }
            set
            {
                this.extensionDataField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public System.Guid PartnerGuid
        {
            get
            {
                return this.PartnerGuidField;
            }
            set
            {
                this.PartnerGuidField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public CTPTransactionService.Property[] PropertyBag
        {
            get
            {
                return this.PropertyBagField;
            }
            set
            {
                this.PropertyBagField = value;
            }
        }
    }
    
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.Runtime.Serialization", "3.0.0.0")]
    [System.Runtime.Serialization.DataContractAttribute(Name="TaxProfileInfo", Namespace="urn:schemas.microsoft.com/CommercePlatform/Services/TransactionService/2010/01")]
    public partial class TaxProfileInfo : object, System.Runtime.Serialization.IExtensibleDataObject
    {
        
        private System.Runtime.Serialization.ExtensionDataObject extensionDataField;
        
        private CTPTransactionService.Owner OwnerField;
        
        private string TaxProfileIdField;
        
        private CTPTransactionService.TaxProfileIdType TaxProfileIdTypeField;
        
        public System.Runtime.Serialization.ExtensionDataObject ExtensionData
        {
            get
            {
                return this.extensionDataField;
            }
            set
            {
                this.extensionDataField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public CTPTransactionService.Owner Owner
        {
            get
            {
                return this.OwnerField;
            }
            set
            {
                this.OwnerField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public string TaxProfileId
        {
            get
            {
                return this.TaxProfileIdField;
            }
            set
            {
                this.TaxProfileIdField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public CTPTransactionService.TaxProfileIdType TaxProfileIdType
        {
            get
            {
                return this.TaxProfileIdTypeField;
            }
            set
            {
                this.TaxProfileIdTypeField = value;
            }
        }
    }
    
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.Runtime.Serialization", "3.0.0.0")]
    [System.Runtime.Serialization.DataContractAttribute(Name="Property", Namespace="urn:schemas.microsoft.com/CommercePlatform/Services/TransactionService/2010/01")]
    public partial class Property : object, System.Runtime.Serialization.IExtensibleDataObject
    {
        
        private System.Runtime.Serialization.ExtensionDataObject extensionDataField;
        
        private string NameField;
        
        private string NamespaceField;
        
        private string ValueField;
        
        public System.Runtime.Serialization.ExtensionDataObject ExtensionData
        {
            get
            {
                return this.extensionDataField;
            }
            set
            {
                this.extensionDataField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public string Name
        {
            get
            {
                return this.NameField;
            }
            set
            {
                this.NameField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public string Namespace
        {
            get
            {
                return this.NamespaceField;
            }
            set
            {
                this.NamespaceField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public string Value
        {
            get
            {
                return this.ValueField;
            }
            set
            {
                this.ValueField = value;
            }
        }
    }
    
    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.Runtime.Serialization", "3.0.0.0")]
    [System.Runtime.Serialization.DataContractAttribute(Name="BillingMode", Namespace="urn:schemas.microsoft.com/CommercePlatform/Services/TransactionService/2010/01")]
    public enum BillingMode : int
    {
        
        [System.Runtime.Serialization.EnumMemberAttribute()]
        ImmediateSettle = 0,
        
        [System.Runtime.Serialization.EnumMemberAttribute()]
        ScheduledSettle = 1,
        
        [System.Runtime.Serialization.EnumMemberAttribute()]
        ThresholdBilling = 2,
        
        [System.Runtime.Serialization.EnumMemberAttribute()]
        None = 99,
    }
    
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.Runtime.Serialization", "3.0.0.0")]
    [System.Runtime.Serialization.DataContractAttribute(Name="PaymentMethod", Namespace="urn:schemas.microsoft.com/CommercePlatform/Services/TransactionService/2010/01")]
    [System.Runtime.Serialization.KnownTypeAttribute(typeof(CTPTransactionService.TokenPaymentMethod))]
    [System.Runtime.Serialization.KnownTypeAttribute(typeof(CTPTransactionService.DummyPaymentMethod))]
    [System.Runtime.Serialization.KnownTypeAttribute(typeof(CTPTransactionService.RegisteredPaymentMethod))]
    [System.Runtime.Serialization.KnownTypeAttribute(typeof(CTPTransactionService.PointPaymentMethod))]
    public partial class PaymentMethod : object, System.Runtime.Serialization.IExtensibleDataObject
    {
        
        private System.Runtime.Serialization.ExtensionDataObject extensionDataField;
        
        public System.Runtime.Serialization.ExtensionDataObject ExtensionData
        {
            get
            {
                return this.extensionDataField;
            }
            set
            {
                this.extensionDataField = value;
            }
        }
    }
    
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.Runtime.Serialization", "3.0.0.0")]
    [System.Runtime.Serialization.DataContractAttribute(Name="TokenPaymentMethod", Namespace="urn:schemas.microsoft.com/CommercePlatform/Services/TransactionService/2010/01")]
    public partial class TokenPaymentMethod : CTPTransactionService.PaymentMethod
    {
        
        private string PKPNField;
        
        private CTPTransactionService.TokenHashAlgorithms TokenHashAlgorithmField;
        
        private string TokenInstanceIdField;
        
        private CTPTransactionService.TokenInstanceType TokenInstanceTypeField;
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public string PKPN
        {
            get
            {
                return this.PKPNField;
            }
            set
            {
                this.PKPNField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public CTPTransactionService.TokenHashAlgorithms TokenHashAlgorithm
        {
            get
            {
                return this.TokenHashAlgorithmField;
            }
            set
            {
                this.TokenHashAlgorithmField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public string TokenInstanceId
        {
            get
            {
                return this.TokenInstanceIdField;
            }
            set
            {
                this.TokenInstanceIdField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public CTPTransactionService.TokenInstanceType TokenInstanceType
        {
            get
            {
                return this.TokenInstanceTypeField;
            }
            set
            {
                this.TokenInstanceTypeField = value;
            }
        }
    }
    
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.Runtime.Serialization", "3.0.0.0")]
    [System.Runtime.Serialization.DataContractAttribute(Name="DummyPaymentMethod", Namespace="urn:schemas.microsoft.com/CommercePlatform/Services/TransactionService/2010/01")]
    public partial class DummyPaymentMethod : CTPTransactionService.PaymentMethod
    {
    }
    
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.Runtime.Serialization", "3.0.0.0")]
    [System.Runtime.Serialization.DataContractAttribute(Name="RegisteredPaymentMethod", Namespace="urn:schemas.microsoft.com/CommercePlatform/Services/TransactionService/2010/01")]
    public partial class RegisteredPaymentMethod : CTPTransactionService.PaymentMethod
    {
        
        private string PaymentMethodIDField;
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public string PaymentMethodID
        {
            get
            {
                return this.PaymentMethodIDField;
            }
            set
            {
                this.PaymentMethodIDField = value;
            }
        }
    }
    
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.Runtime.Serialization", "3.0.0.0")]
    [System.Runtime.Serialization.DataContractAttribute(Name="PointPaymentMethod", Namespace="urn:schemas.microsoft.com/CommercePlatform/Services/TransactionService/2010/01")]
    public partial class PointPaymentMethod : CTPTransactionService.PaymentMethod
    {
    }
    
    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.Runtime.Serialization", "3.0.0.0")]
    [System.Runtime.Serialization.DataContractAttribute(Name="TokenHashAlgorithms", Namespace="urn:schemas.microsoft.com/CommercePlatform/Services/TransactionService/2010/01")]
    public enum TokenHashAlgorithms : int
    {
        
        [System.Runtime.Serialization.EnumMemberAttribute()]
        UNKNOWN = 0,
        
        [System.Runtime.Serialization.EnumMemberAttribute()]
        SHA1 = 1,
        
        [System.Runtime.Serialization.EnumMemberAttribute()]
        SHA256 = 2,
    }
    
    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.Runtime.Serialization", "3.0.0.0")]
    [System.Runtime.Serialization.DataContractAttribute(Name="TokenInstanceType", Namespace="urn:schemas.microsoft.com/CommercePlatform/Services/TransactionService/2010/01")]
    public enum TokenInstanceType : int
    {
        
        [System.Runtime.Serialization.EnumMemberAttribute()]
        RSMToken = 0,
        
        [System.Runtime.Serialization.EnumMemberAttribute()]
        PartnerToken = 1,
    }
    
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.Runtime.Serialization", "3.0.0.0")]
    [System.Runtime.Serialization.DataContractAttribute(Name="Identity", Namespace="urn:schemas.microsoft.com/CommercePlatform/Services/TransactionService/2010/01")]
    public partial class Identity : object, System.Runtime.Serialization.IExtensibleDataObject
    {
        
        private System.Runtime.Serialization.ExtensionDataObject extensionDataField;
        
        private CTPTransactionService.Property[] IdentityPropertyField;
        
        private string IdentityTypeField;
        
        private string IdentityValueField;
        
        public System.Runtime.Serialization.ExtensionDataObject ExtensionData
        {
            get
            {
                return this.extensionDataField;
            }
            set
            {
                this.extensionDataField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public CTPTransactionService.Property[] IdentityProperty
        {
            get
            {
                return this.IdentityPropertyField;
            }
            set
            {
                this.IdentityPropertyField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public string IdentityType
        {
            get
            {
                return this.IdentityTypeField;
            }
            set
            {
                this.IdentityTypeField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public string IdentityValue
        {
            get
            {
                return this.IdentityValueField;
            }
            set
            {
                this.IdentityValueField = value;
            }
        }
    }
    
    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.Runtime.Serialization", "3.0.0.0")]
    [System.Runtime.Serialization.DataContractAttribute(Name="ApproveDecision", Namespace="urn:schemas.microsoft.com/CommercePlatform/Services/TransactionService/2010/01")]
    public enum ApproveDecision : int
    {
        
        [System.Runtime.Serialization.EnumMemberAttribute()]
        Disapprove = 0,
        
        [System.Runtime.Serialization.EnumMemberAttribute()]
        Approve = 1,
    }
    
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.Runtime.Serialization", "3.0.0.0")]
    [System.Runtime.Serialization.DataContractAttribute(Name="PayoutLineEntryInput", Namespace="urn:schemas.microsoft.com/CommercePlatform/Services/TransactionService/2010/01")]
    public partial class PayoutLineEntryInput : object, System.Runtime.Serialization.IExtensibleDataObject
    {
        
        private System.Runtime.Serialization.ExtensionDataObject extensionDataField;
        
        private string CategoryField;
        
        private string DescriptionField;
        
        private string ExternalItemIdField;
        
        private CTPTransactionService.FinancialReportType FinancialReportingTypeField;
        
        private string IncomeCodeField;
        
        private string NameField;
        
        private string SourceOfIncomeField;
        
        private System.Nullable<decimal> SourceTotalAmountField;
        
        private System.Nullable<decimal> TargetTotalAmountField;
        
        public System.Runtime.Serialization.ExtensionDataObject ExtensionData
        {
            get
            {
                return this.extensionDataField;
            }
            set
            {
                this.extensionDataField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public string Category
        {
            get
            {
                return this.CategoryField;
            }
            set
            {
                this.CategoryField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public string Description
        {
            get
            {
                return this.DescriptionField;
            }
            set
            {
                this.DescriptionField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public string ExternalItemId
        {
            get
            {
                return this.ExternalItemIdField;
            }
            set
            {
                this.ExternalItemIdField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public CTPTransactionService.FinancialReportType FinancialReportingType
        {
            get
            {
                return this.FinancialReportingTypeField;
            }
            set
            {
                this.FinancialReportingTypeField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public string IncomeCode
        {
            get
            {
                return this.IncomeCodeField;
            }
            set
            {
                this.IncomeCodeField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public string Name
        {
            get
            {
                return this.NameField;
            }
            set
            {
                this.NameField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public string SourceOfIncome
        {
            get
            {
                return this.SourceOfIncomeField;
            }
            set
            {
                this.SourceOfIncomeField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public System.Nullable<decimal> SourceTotalAmount
        {
            get
            {
                return this.SourceTotalAmountField;
            }
            set
            {
                this.SourceTotalAmountField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public System.Nullable<decimal> TargetTotalAmount
        {
            get
            {
                return this.TargetTotalAmountField;
            }
            set
            {
                this.TargetTotalAmountField = value;
            }
        }
    }
    
    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.Runtime.Serialization", "3.0.0.0")]
    [System.Runtime.Serialization.DataContractAttribute(Name="FinancialReportType", Namespace="http://schemas.datacontract.org/2004/07/Microsoft.Transaction.Interfaces")]
    public enum FinancialReportType : byte
    {
        
        [System.Runtime.Serialization.EnumMemberAttribute()]
        None = 0,
        
        [System.Runtime.Serialization.EnumMemberAttribute()]
        RevShare = 1,
        
        [System.Runtime.Serialization.EnumMemberAttribute()]
        Expense = 2,
    }
    
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.Runtime.Serialization", "3.0.0.0")]
    [System.Runtime.Serialization.DataContractAttribute(Name="Owner", Namespace="urn:schemas.microsoft.com/CommercePlatform/Services/TransactionService/2010/01")]
    public partial class Owner : object, System.Runtime.Serialization.IExtensibleDataObject
    {
        
        private System.Runtime.Serialization.ExtensionDataObject extensionDataField;
        
        private string OwnerIdField;
        
        private CTPTransactionService.OwnerType OwnerTypeField;
        
        public System.Runtime.Serialization.ExtensionDataObject ExtensionData
        {
            get
            {
                return this.extensionDataField;
            }
            set
            {
                this.extensionDataField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public string OwnerId
        {
            get
            {
                return this.OwnerIdField;
            }
            set
            {
                this.OwnerIdField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public CTPTransactionService.OwnerType OwnerType
        {
            get
            {
                return this.OwnerTypeField;
            }
            set
            {
                this.OwnerTypeField = value;
            }
        }
    }
    
    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.Runtime.Serialization", "3.0.0.0")]
    [System.Runtime.Serialization.DataContractAttribute(Name="TaxProfileIdType", Namespace="urn:schemas.microsoft.com/CommercePlatform/Services/TransactionService/2010/01")]
    public enum TaxProfileIdType : int
    {
        
        [System.Runtime.Serialization.EnumMemberAttribute()]
        PrimaryId = 0,
        
        [System.Runtime.Serialization.EnumMemberAttribute()]
        TaxReferenceId = 1,
        
        [System.Runtime.Serialization.EnumMemberAttribute()]
        PartnerReferenceId = 2,
    }
    
    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.Runtime.Serialization", "3.0.0.0")]
    [System.Runtime.Serialization.DataContractAttribute(Name="OwnerType", Namespace="urn:schemas.microsoft.com/CommercePlatform/Services/TransactionService/2010/01")]
    public enum OwnerType : int
    {
        
        [System.Runtime.Serialization.EnumMemberAttribute()]
        PUID = 0,
        
        [System.Runtime.Serialization.EnumMemberAttribute()]
        CTPAccount = 1,
        
        [System.Runtime.Serialization.EnumMemberAttribute()]
        AdCenterCustomerID = 2,
    }
    
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.Runtime.Serialization", "3.0.0.0")]
    [System.Runtime.Serialization.DataContractAttribute(Name="JoinSubsContext", Namespace="urn:schemas.microsoft.com/CommercePlatform/Services/TransactionService/2010/01")]
    public partial class JoinSubsContext : object, System.Runtime.Serialization.IExtensibleDataObject
    {
        
        private System.Runtime.Serialization.ExtensionDataObject extensionDataField;
        
        private bool ComputeOnlyField;
        
        private CTPTransactionService.Property[] FraudDetectionContextField;
        
        private CTPTransactionService.Property[] PropertyBagField;
        
        private System.DateTime TimeStampField;
        
        public System.Runtime.Serialization.ExtensionDataObject ExtensionData
        {
            get
            {
                return this.extensionDataField;
            }
            set
            {
                this.extensionDataField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public bool ComputeOnly
        {
            get
            {
                return this.ComputeOnlyField;
            }
            set
            {
                this.ComputeOnlyField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public CTPTransactionService.Property[] FraudDetectionContext
        {
            get
            {
                return this.FraudDetectionContextField;
            }
            set
            {
                this.FraudDetectionContextField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public CTPTransactionService.Property[] PropertyBag
        {
            get
            {
                return this.PropertyBagField;
            }
            set
            {
                this.PropertyBagField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public System.DateTime TimeStamp
        {
            get
            {
                return this.TimeStampField;
            }
            set
            {
                this.TimeStampField = value;
            }
        }
    }
    
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.Runtime.Serialization", "3.0.0.0")]
    [System.Runtime.Serialization.DataContractAttribute(Name="JoinSubscriptionInfoInput", Namespace="urn:schemas.microsoft.com/CommercePlatform/Services/TransactionService/2010/01")]
    public partial class JoinSubscriptionInfoInput : object, System.Runtime.Serialization.IExtensibleDataObject
    {
        
        private System.Runtime.Serialization.ExtensionDataObject extensionDataField;
        
        private string DestinationSubscriptionIdField;
        
        private string SourceSubscriptionIdField;
        
        private CTPTransactionService.SubsTimeExtensionInfo SubsTimeExtensionInfoField;
        
        public System.Runtime.Serialization.ExtensionDataObject ExtensionData
        {
            get
            {
                return this.extensionDataField;
            }
            set
            {
                this.extensionDataField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public string DestinationSubscriptionId
        {
            get
            {
                return this.DestinationSubscriptionIdField;
            }
            set
            {
                this.DestinationSubscriptionIdField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public string SourceSubscriptionId
        {
            get
            {
                return this.SourceSubscriptionIdField;
            }
            set
            {
                this.SourceSubscriptionIdField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public CTPTransactionService.SubsTimeExtensionInfo SubsTimeExtensionInfo
        {
            get
            {
                return this.SubsTimeExtensionInfoField;
            }
            set
            {
                this.SubsTimeExtensionInfoField = value;
            }
        }
    }
    
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.Runtime.Serialization", "3.0.0.0")]
    [System.Runtime.Serialization.DataContractAttribute(Name="SubsTimeExtensionInfo", Namespace="urn:schemas.microsoft.com/CommercePlatform/Services/TransactionService/2010/01")]
    public partial class SubsTimeExtensionInfo : object, System.Runtime.Serialization.IExtensibleDataObject
    {
        
        private System.Runtime.Serialization.ExtensionDataObject extensionDataField;
        
        private System.Nullable<CTPTransactionService.ExtendReasonCode> ExtendReasonCodeField;
        
        private int ExtendedLengthField;
        
        private CTPTransactionService.TimeExtensionUnit ExtendedUnitField;
        
        private CTPTransactionService.Property[] PropertyBagField;
        
        public System.Runtime.Serialization.ExtensionDataObject ExtensionData
        {
            get
            {
                return this.extensionDataField;
            }
            set
            {
                this.extensionDataField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public System.Nullable<CTPTransactionService.ExtendReasonCode> ExtendReasonCode
        {
            get
            {
                return this.ExtendReasonCodeField;
            }
            set
            {
                this.ExtendReasonCodeField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public int ExtendedLength
        {
            get
            {
                return this.ExtendedLengthField;
            }
            set
            {
                this.ExtendedLengthField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public CTPTransactionService.TimeExtensionUnit ExtendedUnit
        {
            get
            {
                return this.ExtendedUnitField;
            }
            set
            {
                this.ExtendedUnitField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public CTPTransactionService.Property[] PropertyBag
        {
            get
            {
                return this.PropertyBagField;
            }
            set
            {
                this.PropertyBagField = value;
            }
        }
    }
    
    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.Runtime.Serialization", "3.0.0.0")]
    [System.Runtime.Serialization.DataContractAttribute(Name="ExtendReasonCode", Namespace="http://schemas.datacontract.org/2004/07/Microsoft.Transaction.Interfaces")]
    public enum ExtendReasonCode : int
    {
        
        [System.Runtime.Serialization.EnumMemberAttribute()]
        NormalExtend = 10,
        
        [System.Runtime.Serialization.EnumMemberAttribute()]
        FlexibleExtend = 11,
    }
    
    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.Runtime.Serialization", "3.0.0.0")]
    [System.Runtime.Serialization.DataContractAttribute(Name="TimeExtensionUnit", Namespace="urn:schemas.microsoft.com/CommercePlatform/Services/TransactionService/2010/01")]
    public enum TimeExtensionUnit : int
    {
        
        [System.Runtime.Serialization.EnumMemberAttribute()]
        Day = 0,
        
        [System.Runtime.Serialization.EnumMemberAttribute()]
        Month = 1,
        
        [System.Runtime.Serialization.EnumMemberAttribute()]
        Year = 2,
    }
    
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.Runtime.Serialization", "3.0.0.0")]
    [System.Runtime.Serialization.DataContractAttribute(Name="MigrateAccountContext", Namespace="urn:schemas.microsoft.com/CommercePlatform/Services/TransactionService/2010/01")]
    public partial class MigrateAccountContext : object, System.Runtime.Serialization.IExtensibleDataObject
    {
        
        private System.Runtime.Serialization.ExtensionDataObject extensionDataField;
        
        private bool ComputeOnlyField;
        
        private CTPTransactionService.Property[] FraudDetectionContextField;
        
        private CTPTransactionService.Policy PolicyField;
        
        private CTPTransactionService.Property[] PropertyBagField;
        
        private System.DateTime TimeStampField;
        
        public System.Runtime.Serialization.ExtensionDataObject ExtensionData
        {
            get
            {
                return this.extensionDataField;
            }
            set
            {
                this.extensionDataField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public bool ComputeOnly
        {
            get
            {
                return this.ComputeOnlyField;
            }
            set
            {
                this.ComputeOnlyField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public CTPTransactionService.Property[] FraudDetectionContext
        {
            get
            {
                return this.FraudDetectionContextField;
            }
            set
            {
                this.FraudDetectionContextField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public CTPTransactionService.Policy Policy
        {
            get
            {
                return this.PolicyField;
            }
            set
            {
                this.PolicyField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public CTPTransactionService.Property[] PropertyBag
        {
            get
            {
                return this.PropertyBagField;
            }
            set
            {
                this.PropertyBagField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public System.DateTime TimeStamp
        {
            get
            {
                return this.TimeStampField;
            }
            set
            {
                this.TimeStampField = value;
            }
        }
    }
    
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.Runtime.Serialization", "3.0.0.0")]
    [System.Runtime.Serialization.DataContractAttribute(Name="MigrateAccountInfoInput", Namespace="urn:schemas.microsoft.com/CommercePlatform/Services/TransactionService/2010/01")]
    public partial class MigrateAccountInfoInput : object, System.Runtime.Serialization.IExtensibleDataObject
    {
        
        private System.Runtime.Serialization.ExtensionDataObject extensionDataField;
        
        private string DestinationAccountIdField;
        
        private CTPTransactionService.MigrateSubscriptionInfoInput[] MigrateSubscriptionInfoInputsField;
        
        private string SourceAccountIdField;
        
        public System.Runtime.Serialization.ExtensionDataObject ExtensionData
        {
            get
            {
                return this.extensionDataField;
            }
            set
            {
                this.extensionDataField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public string DestinationAccountId
        {
            get
            {
                return this.DestinationAccountIdField;
            }
            set
            {
                this.DestinationAccountIdField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public CTPTransactionService.MigrateSubscriptionInfoInput[] MigrateSubscriptionInfoInputs
        {
            get
            {
                return this.MigrateSubscriptionInfoInputsField;
            }
            set
            {
                this.MigrateSubscriptionInfoInputsField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public string SourceAccountId
        {
            get
            {
                return this.SourceAccountIdField;
            }
            set
            {
                this.SourceAccountIdField = value;
            }
        }
    }
    
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.Runtime.Serialization", "3.0.0.0")]
    [System.Runtime.Serialization.DataContractAttribute(Name="Policy", Namespace="urn:schemas.microsoft.com/CommercePlatform/Services/TransactionService/2010/01")]
    public partial class Policy : object, System.Runtime.Serialization.IExtensibleDataObject
    {
        
        private System.Runtime.Serialization.ExtensionDataObject extensionDataField;
        
        private System.Guid PolicyGUIDField;
        
        private int PolicyVersionField;
        
        private System.DateTime SignatureDateTimeField;
        
        public System.Runtime.Serialization.ExtensionDataObject ExtensionData
        {
            get
            {
                return this.extensionDataField;
            }
            set
            {
                this.extensionDataField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public System.Guid PolicyGUID
        {
            get
            {
                return this.PolicyGUIDField;
            }
            set
            {
                this.PolicyGUIDField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public int PolicyVersion
        {
            get
            {
                return this.PolicyVersionField;
            }
            set
            {
                this.PolicyVersionField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public System.DateTime SignatureDateTime
        {
            get
            {
                return this.SignatureDateTimeField;
            }
            set
            {
                this.SignatureDateTimeField = value;
            }
        }
    }
    
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.Runtime.Serialization", "3.0.0.0")]
    [System.Runtime.Serialization.DataContractAttribute(Name="MigrateSubscriptionInfoInput", Namespace="urn:schemas.microsoft.com/CommercePlatform/Services/TransactionService/2010/01")]
    public partial class MigrateSubscriptionInfoInput : object, System.Runtime.Serialization.IExtensibleDataObject
    {
        
        private System.Runtime.Serialization.ExtensionDataObject extensionDataField;
        
        private CTPTransactionService.PurchaseNewSubscriptionProductItemInput DestinationSubscriptionInfoField;
        
        private bool ProvisionServiceField;
        
        private string SourceSubscriptionIdField;
        
        public System.Runtime.Serialization.ExtensionDataObject ExtensionData
        {
            get
            {
                return this.extensionDataField;
            }
            set
            {
                this.extensionDataField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public CTPTransactionService.PurchaseNewSubscriptionProductItemInput DestinationSubscriptionInfo
        {
            get
            {
                return this.DestinationSubscriptionInfoField;
            }
            set
            {
                this.DestinationSubscriptionInfoField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public bool ProvisionService
        {
            get
            {
                return this.ProvisionServiceField;
            }
            set
            {
                this.ProvisionServiceField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public string SourceSubscriptionId
        {
            get
            {
                return this.SourceSubscriptionIdField;
            }
            set
            {
                this.SourceSubscriptionIdField = value;
            }
        }
    }
    
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.Runtime.Serialization", "3.0.0.0")]
    [System.Runtime.Serialization.DataContractAttribute(Name="PurchaseNewSubscriptionProductItemInput", Namespace="urn:schemas.microsoft.com/CommercePlatform/Services/TransactionService/2010/01")]
    public partial class PurchaseNewSubscriptionProductItemInput : CTPTransactionService.PurchaseProductItemInput
    {
        
        private string ProductItemCatalogIdField;
        
        private CTPTransactionService.RatingEvent[] RatingEventsField;
        
        private CTPTransactionService.ReferralInfo[] ReferralInfoSetField;
        
        private string SubscriptionFriendlyNameField;
        
        private string SupportDescriptionField;
        
        private string SupportTitleField;
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public string ProductItemCatalogId
        {
            get
            {
                return this.ProductItemCatalogIdField;
            }
            set
            {
                this.ProductItemCatalogIdField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public CTPTransactionService.RatingEvent[] RatingEvents
        {
            get
            {
                return this.RatingEventsField;
            }
            set
            {
                this.RatingEventsField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public CTPTransactionService.ReferralInfo[] ReferralInfoSet
        {
            get
            {
                return this.ReferralInfoSetField;
            }
            set
            {
                this.ReferralInfoSetField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public string SubscriptionFriendlyName
        {
            get
            {
                return this.SubscriptionFriendlyNameField;
            }
            set
            {
                this.SubscriptionFriendlyNameField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public string SupportDescription
        {
            get
            {
                return this.SupportDescriptionField;
            }
            set
            {
                this.SupportDescriptionField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public string SupportTitle
        {
            get
            {
                return this.SupportTitleField;
            }
            set
            {
                this.SupportTitleField = value;
            }
        }
    }
    
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.Runtime.Serialization", "3.0.0.0")]
    [System.Runtime.Serialization.DataContractAttribute(Name="PurchaseProductItemInput", Namespace="urn:schemas.microsoft.com/CommercePlatform/Services/TransactionService/2010/01")]
    [System.Runtime.Serialization.KnownTypeAttribute(typeof(CTPTransactionService.PurchasePointsProductItemInput))]
    [System.Runtime.Serialization.KnownTypeAttribute(typeof(CTPTransactionService.PurchaseContentProductItemInput))]
    [System.Runtime.Serialization.KnownTypeAttribute(typeof(CTPTransactionService.PurchaseStoredValueProductItemInput))]
    [System.Runtime.Serialization.KnownTypeAttribute(typeof(CTPTransactionService.PurchaseConvertSubscriptionProductItemInput))]
    [System.Runtime.Serialization.KnownTypeAttribute(typeof(CTPTransactionService.PurchaseNewSubscriptionProductItemInput))]
    public partial class PurchaseProductItemInput : object, System.Runtime.Serialization.IExtensibleDataObject
    {
        
        private System.Runtime.Serialization.ExtensionDataObject extensionDataField;
        
        private string DescriptionField;
        
        private string ExternalProductItemIdField;
        
        private string ProductTypeField;
        
        private CTPTransactionService.Property[] PropertyBagField;
        
        private CTPTransactionService.RevenueInfo RevenueInfoField;
        
        private string TitleField;
        
        public System.Runtime.Serialization.ExtensionDataObject ExtensionData
        {
            get
            {
                return this.extensionDataField;
            }
            set
            {
                this.extensionDataField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public string Description
        {
            get
            {
                return this.DescriptionField;
            }
            set
            {
                this.DescriptionField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public string ExternalProductItemId
        {
            get
            {
                return this.ExternalProductItemIdField;
            }
            set
            {
                this.ExternalProductItemIdField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public string ProductType
        {
            get
            {
                return this.ProductTypeField;
            }
            set
            {
                this.ProductTypeField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public CTPTransactionService.Property[] PropertyBag
        {
            get
            {
                return this.PropertyBagField;
            }
            set
            {
                this.PropertyBagField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public CTPTransactionService.RevenueInfo RevenueInfo
        {
            get
            {
                return this.RevenueInfoField;
            }
            set
            {
                this.RevenueInfoField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public string Title
        {
            get
            {
                return this.TitleField;
            }
            set
            {
                this.TitleField = value;
            }
        }
    }
    
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.Runtime.Serialization", "3.0.0.0")]
    [System.Runtime.Serialization.DataContractAttribute(Name="RevenueInfo", Namespace="urn:schemas.microsoft.com/CommercePlatform/Services/TransactionService/2010/01")]
    public partial class RevenueInfo : object, System.Runtime.Serialization.IExtensibleDataObject
    {
        
        private System.Runtime.Serialization.ExtensionDataObject extensionDataField;
        
        private CTPTransactionService.FinancialReportingProperty[] FinancialReportingPropertyBagField;
        
        private decimal RevenueAllocationAmountField;
        
        private decimal RevenueAllocationPercentageField;
        
        private CTPTransactionService.RevenueAllocationPriceType RevenueAllocationPriceTypeField;
        
        private string RevenueSKUField;
        
        public System.Runtime.Serialization.ExtensionDataObject ExtensionData
        {
            get
            {
                return this.extensionDataField;
            }
            set
            {
                this.extensionDataField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public CTPTransactionService.FinancialReportingProperty[] FinancialReportingPropertyBag
        {
            get
            {
                return this.FinancialReportingPropertyBagField;
            }
            set
            {
                this.FinancialReportingPropertyBagField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public decimal RevenueAllocationAmount
        {
            get
            {
                return this.RevenueAllocationAmountField;
            }
            set
            {
                this.RevenueAllocationAmountField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public decimal RevenueAllocationPercentage
        {
            get
            {
                return this.RevenueAllocationPercentageField;
            }
            set
            {
                this.RevenueAllocationPercentageField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public CTPTransactionService.RevenueAllocationPriceType RevenueAllocationPriceType
        {
            get
            {
                return this.RevenueAllocationPriceTypeField;
            }
            set
            {
                this.RevenueAllocationPriceTypeField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public string RevenueSKU
        {
            get
            {
                return this.RevenueSKUField;
            }
            set
            {
                this.RevenueSKUField = value;
            }
        }
    }
    
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.Runtime.Serialization", "3.0.0.0")]
    [System.Runtime.Serialization.DataContractAttribute(Name="PurchasePointsProductItemInput", Namespace="urn:schemas.microsoft.com/CommercePlatform/Services/TransactionService/2010/01")]
    public partial class PurchasePointsProductItemInput : CTPTransactionService.PurchaseProductItemInput
    {
        
        private string ItemCategoryField;
        
        private string ProductItemCatalogIdField;
        
        private CTPTransactionService.ReferralInfo[] ReferralInfoSetField;
        
        private string SupportDescriptionField;
        
        private string SupportTitleField;
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public string ItemCategory
        {
            get
            {
                return this.ItemCategoryField;
            }
            set
            {
                this.ItemCategoryField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public string ProductItemCatalogId
        {
            get
            {
                return this.ProductItemCatalogIdField;
            }
            set
            {
                this.ProductItemCatalogIdField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public CTPTransactionService.ReferralInfo[] ReferralInfoSet
        {
            get
            {
                return this.ReferralInfoSetField;
            }
            set
            {
                this.ReferralInfoSetField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public string SupportDescription
        {
            get
            {
                return this.SupportDescriptionField;
            }
            set
            {
                this.SupportDescriptionField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public string SupportTitle
        {
            get
            {
                return this.SupportTitleField;
            }
            set
            {
                this.SupportTitleField = value;
            }
        }
    }
    
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.Runtime.Serialization", "3.0.0.0")]
    [System.Runtime.Serialization.DataContractAttribute(Name="PurchaseContentProductItemInput", Namespace="urn:schemas.microsoft.com/CommercePlatform/Services/TransactionService/2010/01")]
    public partial class PurchaseContentProductItemInput : CTPTransactionService.PurchaseProductItemInput
    {
        
        private string ExternalProductItemCatalogIdField;
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public string ExternalProductItemCatalogId
        {
            get
            {
                return this.ExternalProductItemCatalogIdField;
            }
            set
            {
                this.ExternalProductItemCatalogIdField = value;
            }
        }
    }
    
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.Runtime.Serialization", "3.0.0.0")]
    [System.Runtime.Serialization.DataContractAttribute(Name="PurchaseStoredValueProductItemInput", Namespace="urn:schemas.microsoft.com/CommercePlatform/Services/TransactionService/2010/01")]
    public partial class PurchaseStoredValueProductItemInput : CTPTransactionService.PurchaseProductItemInput
    {
        
        private System.Nullable<decimal> AmountField;
        
        private string ExternalProductItemCatalogIdField;
        
        private string FundTypeField;
        
        private CTPTransactionService.RatingEvent[] RatingEventsField;
        
        private CTPTransactionService.ReferralInfo[] ReferralInfoSetField;
        
        private string StoredValuePaymentInstrumentIdField;
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public System.Nullable<decimal> Amount
        {
            get
            {
                return this.AmountField;
            }
            set
            {
                this.AmountField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public string ExternalProductItemCatalogId
        {
            get
            {
                return this.ExternalProductItemCatalogIdField;
            }
            set
            {
                this.ExternalProductItemCatalogIdField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public string FundType
        {
            get
            {
                return this.FundTypeField;
            }
            set
            {
                this.FundTypeField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public CTPTransactionService.RatingEvent[] RatingEvents
        {
            get
            {
                return this.RatingEventsField;
            }
            set
            {
                this.RatingEventsField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public CTPTransactionService.ReferralInfo[] ReferralInfoSet
        {
            get
            {
                return this.ReferralInfoSetField;
            }
            set
            {
                this.ReferralInfoSetField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public string StoredValuePaymentInstrumentId
        {
            get
            {
                return this.StoredValuePaymentInstrumentIdField;
            }
            set
            {
                this.StoredValuePaymentInstrumentIdField = value;
            }
        }
    }
    
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.Runtime.Serialization", "3.0.0.0")]
    [System.Runtime.Serialization.DataContractAttribute(Name="PurchaseConvertSubscriptionProductItemInput", Namespace="urn:schemas.microsoft.com/CommercePlatform/Services/TransactionService/2010/01")]
    public partial class PurchaseConvertSubscriptionProductItemInput : CTPTransactionService.PurchaseProductItemInput
    {
        
        private string ConvertFromSubscriptionIDField;
        
        private CTPTransactionService.ConvertMode ConvertModeField;
        
        private CTPTransactionService.CreditMode CreditModeField;
        
        private string ProductItemCatalogIdField;
        
        private CTPTransactionService.RatingEvent[] RatingEventsField;
        
        private CTPTransactionService.ReferralInfo[] ReferralInfoSetField;
        
        private System.Nullable<int> RoundBoundaryField;
        
        private CTPTransactionService.SubsTimeExtensionInfo SubsTimeExtensionInfoField;
        
        private string SubscriptionFriendlyNameField;
        
        private string SupportDescriptionField;
        
        private string SupportTitleField;
        
        private System.Nullable<decimal> TimeConversionRatioField;
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public string ConvertFromSubscriptionID
        {
            get
            {
                return this.ConvertFromSubscriptionIDField;
            }
            set
            {
                this.ConvertFromSubscriptionIDField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public CTPTransactionService.ConvertMode ConvertMode
        {
            get
            {
                return this.ConvertModeField;
            }
            set
            {
                this.ConvertModeField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public CTPTransactionService.CreditMode CreditMode
        {
            get
            {
                return this.CreditModeField;
            }
            set
            {
                this.CreditModeField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public string ProductItemCatalogId
        {
            get
            {
                return this.ProductItemCatalogIdField;
            }
            set
            {
                this.ProductItemCatalogIdField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public CTPTransactionService.RatingEvent[] RatingEvents
        {
            get
            {
                return this.RatingEventsField;
            }
            set
            {
                this.RatingEventsField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public CTPTransactionService.ReferralInfo[] ReferralInfoSet
        {
            get
            {
                return this.ReferralInfoSetField;
            }
            set
            {
                this.ReferralInfoSetField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public System.Nullable<int> RoundBoundary
        {
            get
            {
                return this.RoundBoundaryField;
            }
            set
            {
                this.RoundBoundaryField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public CTPTransactionService.SubsTimeExtensionInfo SubsTimeExtensionInfo
        {
            get
            {
                return this.SubsTimeExtensionInfoField;
            }
            set
            {
                this.SubsTimeExtensionInfoField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public string SubscriptionFriendlyName
        {
            get
            {
                return this.SubscriptionFriendlyNameField;
            }
            set
            {
                this.SubscriptionFriendlyNameField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public string SupportDescription
        {
            get
            {
                return this.SupportDescriptionField;
            }
            set
            {
                this.SupportDescriptionField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public string SupportTitle
        {
            get
            {
                return this.SupportTitleField;
            }
            set
            {
                this.SupportTitleField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public System.Nullable<decimal> TimeConversionRatio
        {
            get
            {
                return this.TimeConversionRatioField;
            }
            set
            {
                this.TimeConversionRatioField = value;
            }
        }
    }
    
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.Runtime.Serialization", "3.0.0.0")]
    [System.Runtime.Serialization.DataContractAttribute(Name="RatingEvent", Namespace="urn:schemas.microsoft.com/CommercePlatform/Services/TransactionService/2010/01")]
    public partial class RatingEvent : object, System.Runtime.Serialization.IExtensibleDataObject
    {
        
        private System.Runtime.Serialization.ExtensionDataObject extensionDataField;
        
        private CTPTransactionService.RatingRule[] RuleInfoField;
        
        private CTPTransactionService.RatingEventType TypeField;
        
        public System.Runtime.Serialization.ExtensionDataObject ExtensionData
        {
            get
            {
                return this.extensionDataField;
            }
            set
            {
                this.extensionDataField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public CTPTransactionService.RatingRule[] RuleInfo
        {
            get
            {
                return this.RuleInfoField;
            }
            set
            {
                this.RuleInfoField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public CTPTransactionService.RatingEventType Type
        {
            get
            {
                return this.TypeField;
            }
            set
            {
                this.TypeField = value;
            }
        }
    }
    
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.Runtime.Serialization", "3.0.0.0")]
    [System.Runtime.Serialization.DataContractAttribute(Name="ReferralInfo", Namespace="urn:schemas.microsoft.com/CommercePlatform/Services/TransactionService/2010/01")]
    public partial class ReferralInfo : object, System.Runtime.Serialization.IExtensibleDataObject
    {
        
        private System.Runtime.Serialization.ExtensionDataObject extensionDataField;
        
        private System.DateTime CreatedDateTimeField;
        
        private string DataField;
        
        private System.Guid PartnerIdField;
        
        private string PartnerNameField;
        
        private string TypeField;
        
        public System.Runtime.Serialization.ExtensionDataObject ExtensionData
        {
            get
            {
                return this.extensionDataField;
            }
            set
            {
                this.extensionDataField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public System.DateTime CreatedDateTime
        {
            get
            {
                return this.CreatedDateTimeField;
            }
            set
            {
                this.CreatedDateTimeField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public string Data
        {
            get
            {
                return this.DataField;
            }
            set
            {
                this.DataField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public System.Guid PartnerId
        {
            get
            {
                return this.PartnerIdField;
            }
            set
            {
                this.PartnerIdField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public string PartnerName
        {
            get
            {
                return this.PartnerNameField;
            }
            set
            {
                this.PartnerNameField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public string Type
        {
            get
            {
                return this.TypeField;
            }
            set
            {
                this.TypeField = value;
            }
        }
    }
    
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.Runtime.Serialization", "3.0.0.0")]
    [System.Runtime.Serialization.DataContractAttribute(Name="FinancialReportingProperty", Namespace="urn:schemas.microsoft.com/CommercePlatform/Services/TransactionService/2010/01")]
    public partial class FinancialReportingProperty : object, System.Runtime.Serialization.IExtensibleDataObject
    {
        
        private System.Runtime.Serialization.ExtensionDataObject extensionDataField;
        
        private decimal AmountField;
        
        private CTPTransactionService.SkuCategoryName NameField;
        
        private string NamespaceField;
        
        private string SkuField;
        
        public System.Runtime.Serialization.ExtensionDataObject ExtensionData
        {
            get
            {
                return this.extensionDataField;
            }
            set
            {
                this.extensionDataField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public decimal Amount
        {
            get
            {
                return this.AmountField;
            }
            set
            {
                this.AmountField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public CTPTransactionService.SkuCategoryName Name
        {
            get
            {
                return this.NameField;
            }
            set
            {
                this.NameField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public string Namespace
        {
            get
            {
                return this.NamespaceField;
            }
            set
            {
                this.NamespaceField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public string Sku
        {
            get
            {
                return this.SkuField;
            }
            set
            {
                this.SkuField = value;
            }
        }
    }
    
    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.Runtime.Serialization", "3.0.0.0")]
    [System.Runtime.Serialization.DataContractAttribute(Name="RevenueAllocationPriceType", Namespace="urn:schemas.microsoft.com/CommercePlatform/Services/TransactionService/2010/01")]
    public enum RevenueAllocationPriceType : int
    {
        
        [System.Runtime.Serialization.EnumMemberAttribute()]
        Percentage = 0,
        
        [System.Runtime.Serialization.EnumMemberAttribute()]
        Amount = 1,
    }
    
    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.Runtime.Serialization", "3.0.0.0")]
    [System.Runtime.Serialization.DataContractAttribute(Name="SkuCategoryName", Namespace="urn:schemas.microsoft.com/CommercePlatform/Services/TransactionService/2010/01")]
    public enum SkuCategoryName : int
    {
        
        [System.Runtime.Serialization.EnumMemberAttribute()]
        Revenue = 1,
        
        [System.Runtime.Serialization.EnumMemberAttribute()]
        Liability = 2,
    }
    
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.Runtime.Serialization", "3.0.0.0")]
    [System.Runtime.Serialization.DataContractAttribute(Name="RatingRule", Namespace="urn:schemas.microsoft.com/CommercePlatform/Services/TransactionService/2010/01")]
    public partial class RatingRule : object, System.Runtime.Serialization.IExtensibleDataObject
    {
        
        private System.Runtime.Serialization.ExtensionDataObject extensionDataField;
        
        private decimal AmountField;
        
        private int CycleEndField;
        
        private int CycleStartField;
        
        private int CycleUnitField;
        
        private System.Guid GuidReferenceField;
        
        private CTPTransactionService.RatingRuleType TypeField;
        
        public System.Runtime.Serialization.ExtensionDataObject ExtensionData
        {
            get
            {
                return this.extensionDataField;
            }
            set
            {
                this.extensionDataField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public decimal Amount
        {
            get
            {
                return this.AmountField;
            }
            set
            {
                this.AmountField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public int CycleEnd
        {
            get
            {
                return this.CycleEndField;
            }
            set
            {
                this.CycleEndField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public int CycleStart
        {
            get
            {
                return this.CycleStartField;
            }
            set
            {
                this.CycleStartField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public int CycleUnit
        {
            get
            {
                return this.CycleUnitField;
            }
            set
            {
                this.CycleUnitField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public System.Guid GuidReference
        {
            get
            {
                return this.GuidReferenceField;
            }
            set
            {
                this.GuidReferenceField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public CTPTransactionService.RatingRuleType Type
        {
            get
            {
                return this.TypeField;
            }
            set
            {
                this.TypeField = value;
            }
        }
    }
    
    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.Runtime.Serialization", "3.0.0.0")]
    [System.Runtime.Serialization.DataContractAttribute(Name="RatingEventType", Namespace="urn:schemas.microsoft.com/CommercePlatform/Services/TransactionService/2010/01")]
    public enum RatingEventType : int
    {
        
        [System.Runtime.Serialization.EnumMemberAttribute()]
        ConvertFrom = 0,
        
        [System.Runtime.Serialization.EnumMemberAttribute()]
        CancelSubscription = 1,
    }
    
    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.Runtime.Serialization", "3.0.0.0")]
    [System.Runtime.Serialization.DataContractAttribute(Name="RatingRuleType", Namespace="urn:schemas.microsoft.com/CommercePlatform/Services/TransactionService/2010/01")]
    public enum RatingRuleType : int
    {
        
        [System.Runtime.Serialization.EnumMemberAttribute()]
        Charge = 0,
        
        [System.Runtime.Serialization.EnumMemberAttribute()]
        Proration = 1,
    }
    
    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.Runtime.Serialization", "3.0.0.0")]
    [System.Runtime.Serialization.DataContractAttribute(Name="ConvertMode", Namespace="urn:schemas.microsoft.com/CommercePlatform/Services/TransactionService/2010/01")]
    public enum ConvertMode : int
    {
        
        [System.Runtime.Serialization.EnumMemberAttribute()]
        Convert = 0,
        
        [System.Runtime.Serialization.EnumMemberAttribute()]
        Renew = 1,
    }
    
    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.Runtime.Serialization", "3.0.0.0")]
    [System.Runtime.Serialization.DataContractAttribute(Name="CreditMode", Namespace="urn:schemas.microsoft.com/CommercePlatform/Services/TransactionService/2010/01")]
    public enum CreditMode : int
    {
        
        [System.Runtime.Serialization.EnumMemberAttribute()]
        CreditByRefund = 0,
        
        [System.Runtime.Serialization.EnumMemberAttribute()]
        CreditByTimeExtension = 1,
    }
    
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.Runtime.Serialization", "3.0.0.0")]
    [System.Runtime.Serialization.DataContractAttribute(Name="PayoutFilter", Namespace="urn:schemas.microsoft.com/CommercePlatform/Services/TransactionService/2010/01")]
    public partial class PayoutFilter : object, System.Runtime.Serialization.IExtensibleDataObject
    {
        
        private System.Runtime.Serialization.ExtensionDataObject extensionDataField;
        
        private string MerchantReferenceField;
        
        private CTPTransactionService.DateRange OrderCreateDateRangeField;
        
        private CTPTransactionService.DateRange OrderEventDateRangeField;
        
        private string[] OrderEventTypeSetField;
        
        private string PayoutOrderIDField;
        
        private CTPTransactionService.Property[] PropertyBagField;
        
        public System.Runtime.Serialization.ExtensionDataObject ExtensionData
        {
            get
            {
                return this.extensionDataField;
            }
            set
            {
                this.extensionDataField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public string MerchantReference
        {
            get
            {
                return this.MerchantReferenceField;
            }
            set
            {
                this.MerchantReferenceField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public CTPTransactionService.DateRange OrderCreateDateRange
        {
            get
            {
                return this.OrderCreateDateRangeField;
            }
            set
            {
                this.OrderCreateDateRangeField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public CTPTransactionService.DateRange OrderEventDateRange
        {
            get
            {
                return this.OrderEventDateRangeField;
            }
            set
            {
                this.OrderEventDateRangeField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public string[] OrderEventTypeSet
        {
            get
            {
                return this.OrderEventTypeSetField;
            }
            set
            {
                this.OrderEventTypeSetField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public string PayoutOrderID
        {
            get
            {
                return this.PayoutOrderIDField;
            }
            set
            {
                this.PayoutOrderIDField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public CTPTransactionService.Property[] PropertyBag
        {
            get
            {
                return this.PropertyBagField;
            }
            set
            {
                this.PropertyBagField = value;
            }
        }
    }
    
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.Runtime.Serialization", "3.0.0.0")]
    [System.Runtime.Serialization.DataContractAttribute(Name="DateRange", Namespace="urn:schemas.microsoft.com/CommercePlatform/Services/TransactionService/2010/01")]
    public partial class DateRange : object, System.Runtime.Serialization.IExtensibleDataObject
    {
        
        private System.Runtime.Serialization.ExtensionDataObject extensionDataField;
        
        private System.Nullable<System.DateTime> EndDateField;
        
        private System.Nullable<System.DateTime> StartDateField;
        
        public System.Runtime.Serialization.ExtensionDataObject ExtensionData
        {
            get
            {
                return this.extensionDataField;
            }
            set
            {
                this.extensionDataField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public System.Nullable<System.DateTime> EndDate
        {
            get
            {
                return this.EndDateField;
            }
            set
            {
                this.EndDateField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public System.Nullable<System.DateTime> StartDate
        {
            get
            {
                return this.StartDateField;
            }
            set
            {
                this.StartDateField = value;
            }
        }
    }
    
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.Runtime.Serialization", "3.0.0.0")]
    [System.Runtime.Serialization.DataContractAttribute(Name="RegisterUserInfoInput", Namespace="urn:schemas.microsoft.com/CommercePlatform/Services/TransactionService/2010/01")]
    public partial class RegisterUserInfoInput : object, System.Runtime.Serialization.IExtensibleDataObject
    {
        
        private System.Runtime.Serialization.ExtensionDataObject extensionDataField;
        
        private string CountryCodeField;
        
        private string CurrencyField;
        
        private string FriendlyNameField;
        
        private string OwnerIdField;
        
        private string OwnerTypeField;
        
        private string TargetField;
        
        public System.Runtime.Serialization.ExtensionDataObject ExtensionData
        {
            get
            {
                return this.extensionDataField;
            }
            set
            {
                this.extensionDataField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public string CountryCode
        {
            get
            {
                return this.CountryCodeField;
            }
            set
            {
                this.CountryCodeField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public string Currency
        {
            get
            {
                return this.CurrencyField;
            }
            set
            {
                this.CurrencyField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public string FriendlyName
        {
            get
            {
                return this.FriendlyNameField;
            }
            set
            {
                this.FriendlyNameField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public string OwnerId
        {
            get
            {
                return this.OwnerIdField;
            }
            set
            {
                this.OwnerIdField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public string OwnerType
        {
            get
            {
                return this.OwnerTypeField;
            }
            set
            {
                this.OwnerTypeField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public string Target
        {
            get
            {
                return this.TargetField;
            }
            set
            {
                this.TargetField = value;
            }
        }
    }
    
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.Runtime.Serialization", "3.0.0.0")]
    [System.Runtime.Serialization.DataContractAttribute(Name="PurchaseBundleInput", Namespace="urn:schemas.microsoft.com/CommercePlatform/Services/TransactionService/2010/01")]
    public partial class PurchaseBundleInput : object, System.Runtime.Serialization.IExtensibleDataObject
    {
        
        private System.Runtime.Serialization.ExtensionDataObject extensionDataField;
        
        private System.Nullable<decimal> AmountField;
        
        private string CurrencyField;
        
        private string DescriptionField;
        
        private CTPTransactionService.DiscountInfo[] DiscountInfoSetField;
        
        private string ExternalBundleCatalogIdField;
        
        private string ExternalBundleIdField;
        
        private System.Nullable<bool> IsTaxExemptionAllowedField;
        
        private System.Nullable<bool> IsTaxIncludedField;
        
        private CTPTransactionService.Property[] PropertyBagField;
        
        private CTPTransactionService.PurchaseProductItemInput[] PurchaseProductItemInputSetField;
        
        private string TitleField;
        
        public System.Runtime.Serialization.ExtensionDataObject ExtensionData
        {
            get
            {
                return this.extensionDataField;
            }
            set
            {
                this.extensionDataField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public System.Nullable<decimal> Amount
        {
            get
            {
                return this.AmountField;
            }
            set
            {
                this.AmountField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public string Currency
        {
            get
            {
                return this.CurrencyField;
            }
            set
            {
                this.CurrencyField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public string Description
        {
            get
            {
                return this.DescriptionField;
            }
            set
            {
                this.DescriptionField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public CTPTransactionService.DiscountInfo[] DiscountInfoSet
        {
            get
            {
                return this.DiscountInfoSetField;
            }
            set
            {
                this.DiscountInfoSetField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public string ExternalBundleCatalogId
        {
            get
            {
                return this.ExternalBundleCatalogIdField;
            }
            set
            {
                this.ExternalBundleCatalogIdField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public string ExternalBundleId
        {
            get
            {
                return this.ExternalBundleIdField;
            }
            set
            {
                this.ExternalBundleIdField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public System.Nullable<bool> IsTaxExemptionAllowed
        {
            get
            {
                return this.IsTaxExemptionAllowedField;
            }
            set
            {
                this.IsTaxExemptionAllowedField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public System.Nullable<bool> IsTaxIncluded
        {
            get
            {
                return this.IsTaxIncludedField;
            }
            set
            {
                this.IsTaxIncludedField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public CTPTransactionService.Property[] PropertyBag
        {
            get
            {
                return this.PropertyBagField;
            }
            set
            {
                this.PropertyBagField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public CTPTransactionService.PurchaseProductItemInput[] PurchaseProductItemInputSet
        {
            get
            {
                return this.PurchaseProductItemInputSetField;
            }
            set
            {
                this.PurchaseProductItemInputSetField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public string Title
        {
            get
            {
                return this.TitleField;
            }
            set
            {
                this.TitleField = value;
            }
        }
    }
    
    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.Runtime.Serialization", "3.0.0.0")]
    [System.Runtime.Serialization.DataContractAttribute(Name="SalesModelType", Namespace="urn:schemas.microsoft.com/CommercePlatform/Services/TransactionService/2010/01")]
    public enum SalesModelType : int
    {
        
        [System.Runtime.Serialization.EnumMemberAttribute()]
        Reseller = 0,
        
        [System.Runtime.Serialization.EnumMemberAttribute()]
        Agent = 1,
    }
    
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.Runtime.Serialization", "3.0.0.0")]
    [System.Runtime.Serialization.DataContractAttribute(Name="DiscountInfo", Namespace="urn:schemas.microsoft.com/CommercePlatform/Services/TransactionService/2010/01")]
    public partial class DiscountInfo : object, System.Runtime.Serialization.IExtensibleDataObject
    {
        
        private System.Runtime.Serialization.ExtensionDataObject extensionDataField;
        
        private string DiscountDescriptionField;
        
        public System.Runtime.Serialization.ExtensionDataObject ExtensionData
        {
            get
            {
                return this.extensionDataField;
            }
            set
            {
                this.extensionDataField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public string DiscountDescription
        {
            get
            {
                return this.DiscountDescriptionField;
            }
            set
            {
                this.DiscountDescriptionField = value;
            }
        }
    }
    
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.Runtime.Serialization", "3.0.0.0")]
    [System.Runtime.Serialization.DataContractAttribute(Name="AbstractResponse", Namespace="urn:schemas.microsoft.com/CommercePlatform/Services/TransactionService/2010/01")]
    [System.Runtime.Serialization.KnownTypeAttribute(typeof(CTPTransactionService.PayoutOutput))]
    [System.Runtime.Serialization.KnownTypeAttribute(typeof(CTPTransactionService.JoinSubscriptionOutput))]
    [System.Runtime.Serialization.KnownTypeAttribute(typeof(CTPTransactionService.MigrateAccountOutput))]
    [System.Runtime.Serialization.KnownTypeAttribute(typeof(CTPTransactionService.GetPayoutOrderStatusOutput))]
    [System.Runtime.Serialization.KnownTypeAttribute(typeof(CTPTransactionService.GetPayoutOrderEventUpdateOutput))]
    [System.Runtime.Serialization.KnownTypeAttribute(typeof(CTPTransactionService.RegisterUserOutput))]
    [System.Runtime.Serialization.KnownTypeAttribute(typeof(CTPTransactionService.PurchaseOutput))]
    public partial class AbstractResponse : object, System.Runtime.Serialization.IExtensibleDataObject
    {
        
        private System.Runtime.Serialization.ExtensionDataObject extensionDataField;
        
        private CTPTransactionService.AckCodeType AckField;
        
        private CTPTransactionService.ErrorType ErrorField;
        
        private bool IsSameTrackingGuidRetryField;
        
        private System.Guid ResponseGuidField;
        
        public System.Runtime.Serialization.ExtensionDataObject ExtensionData
        {
            get
            {
                return this.extensionDataField;
            }
            set
            {
                this.extensionDataField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public CTPTransactionService.AckCodeType Ack
        {
            get
            {
                return this.AckField;
            }
            set
            {
                this.AckField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public CTPTransactionService.ErrorType Error
        {
            get
            {
                return this.ErrorField;
            }
            set
            {
                this.ErrorField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public bool IsSameTrackingGuidRetry
        {
            get
            {
                return this.IsSameTrackingGuidRetryField;
            }
            set
            {
                this.IsSameTrackingGuidRetryField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public System.Guid ResponseGuid
        {
            get
            {
                return this.ResponseGuidField;
            }
            set
            {
                this.ResponseGuidField = value;
            }
        }
    }
    
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.Runtime.Serialization", "3.0.0.0")]
    [System.Runtime.Serialization.DataContractAttribute(Name="ErrorType", Namespace="urn:schemas.microsoft.com/CommercePlatform/Services/TransactionService/2010/01")]
    public partial class ErrorType : object, System.Runtime.Serialization.IExtensibleDataObject
    {
        
        private System.Runtime.Serialization.ExtensionDataObject extensionDataField;
        
        private int ErrorCodeField;
        
        private string ErrorDescriptionField;
        
        private string ErrorLongMessageField;
        
        private string ErrorShortMessageField;
        
        private bool RetryableField;
        
        public System.Runtime.Serialization.ExtensionDataObject ExtensionData
        {
            get
            {
                return this.extensionDataField;
            }
            set
            {
                this.extensionDataField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public int ErrorCode
        {
            get
            {
                return this.ErrorCodeField;
            }
            set
            {
                this.ErrorCodeField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public string ErrorDescription
        {
            get
            {
                return this.ErrorDescriptionField;
            }
            set
            {
                this.ErrorDescriptionField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public string ErrorLongMessage
        {
            get
            {
                return this.ErrorLongMessageField;
            }
            set
            {
                this.ErrorLongMessageField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public string ErrorShortMessage
        {
            get
            {
                return this.ErrorShortMessageField;
            }
            set
            {
                this.ErrorShortMessageField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public bool Retryable
        {
            get
            {
                return this.RetryableField;
            }
            set
            {
                this.RetryableField = value;
            }
        }
    }
    
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.Runtime.Serialization", "3.0.0.0")]
    [System.Runtime.Serialization.DataContractAttribute(Name="PayoutOutput", Namespace="urn:schemas.microsoft.com/CommercePlatform/Services/TransactionService/2010/01")]
    public partial class PayoutOutput : CTPTransactionService.AbstractResponse
    {
        
        private CTPTransactionService.PayoutOrderOutput PayoutOrderOutputField;
        
        private CTPTransactionService.Property[] PropertyBagField;
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public CTPTransactionService.PayoutOrderOutput PayoutOrderOutput
        {
            get
            {
                return this.PayoutOrderOutputField;
            }
            set
            {
                this.PayoutOrderOutputField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public CTPTransactionService.Property[] PropertyBag
        {
            get
            {
                return this.PropertyBagField;
            }
            set
            {
                this.PropertyBagField = value;
            }
        }
    }
    
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.Runtime.Serialization", "3.0.0.0")]
    [System.Runtime.Serialization.DataContractAttribute(Name="JoinSubscriptionOutput", Namespace="urn:schemas.microsoft.com/CommercePlatform/Services/TransactionService/2010/01")]
    public partial class JoinSubscriptionOutput : CTPTransactionService.AbstractResponse
    {
        
        private CTPTransactionService.JoinSubscriptionInfoOutput JoinSubscriptionInfoOutputField;
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public CTPTransactionService.JoinSubscriptionInfoOutput JoinSubscriptionInfoOutput
        {
            get
            {
                return this.JoinSubscriptionInfoOutputField;
            }
            set
            {
                this.JoinSubscriptionInfoOutputField = value;
            }
        }
    }
    
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.Runtime.Serialization", "3.0.0.0")]
    [System.Runtime.Serialization.DataContractAttribute(Name="MigrateAccountOutput", Namespace="urn:schemas.microsoft.com/CommercePlatform/Services/TransactionService/2010/01")]
    public partial class MigrateAccountOutput : CTPTransactionService.AbstractResponse
    {
        
        private CTPTransactionService.MigrateAccountInfoOutput MigrateAccountInfoOutputField;
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public CTPTransactionService.MigrateAccountInfoOutput MigrateAccountInfoOutput
        {
            get
            {
                return this.MigrateAccountInfoOutputField;
            }
            set
            {
                this.MigrateAccountInfoOutputField = value;
            }
        }
    }
    
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.Runtime.Serialization", "3.0.0.0")]
    [System.Runtime.Serialization.DataContractAttribute(Name="GetPayoutOrderStatusOutput", Namespace="urn:schemas.microsoft.com/CommercePlatform/Services/TransactionService/2010/01")]
    public partial class GetPayoutOrderStatusOutput : CTPTransactionService.AbstractResponse
    {
        
        private string NextHandlerField;
        
        private CTPTransactionService.PayoutOrderOutput[] PayoutOrderOutputSetField;
        
        private CTPTransactionService.Property PropertyBagField;
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public string NextHandler
        {
            get
            {
                return this.NextHandlerField;
            }
            set
            {
                this.NextHandlerField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public CTPTransactionService.PayoutOrderOutput[] PayoutOrderOutputSet
        {
            get
            {
                return this.PayoutOrderOutputSetField;
            }
            set
            {
                this.PayoutOrderOutputSetField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public CTPTransactionService.Property PropertyBag
        {
            get
            {
                return this.PropertyBagField;
            }
            set
            {
                this.PropertyBagField = value;
            }
        }
    }
    
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.Runtime.Serialization", "3.0.0.0")]
    [System.Runtime.Serialization.DataContractAttribute(Name="GetPayoutOrderEventUpdateOutput", Namespace="urn:schemas.microsoft.com/CommercePlatform/Services/TransactionService/2010/01")]
    public partial class GetPayoutOrderEventUpdateOutput : CTPTransactionService.AbstractResponse
    {
        
        private string NextHandlerField;
        
        private CTPTransactionService.PayoutOrderEventOutput[] PayoutOrderEventOutputSetField;
        
        private CTPTransactionService.Property PropertyBagField;
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public string NextHandler
        {
            get
            {
                return this.NextHandlerField;
            }
            set
            {
                this.NextHandlerField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public CTPTransactionService.PayoutOrderEventOutput[] PayoutOrderEventOutputSet
        {
            get
            {
                return this.PayoutOrderEventOutputSetField;
            }
            set
            {
                this.PayoutOrderEventOutputSetField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public CTPTransactionService.Property PropertyBag
        {
            get
            {
                return this.PropertyBagField;
            }
            set
            {
                this.PropertyBagField = value;
            }
        }
    }
    
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.Runtime.Serialization", "3.0.0.0")]
    [System.Runtime.Serialization.DataContractAttribute(Name="RegisterUserOutput", Namespace="urn:schemas.microsoft.com/CommercePlatform/Services/TransactionService/2010/01")]
    public partial class RegisterUserOutput : CTPTransactionService.AbstractResponse
    {
        
        private CTPTransactionService.RegisterUserInfoOutput RegisterUserInfoOutputField;
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public CTPTransactionService.RegisterUserInfoOutput RegisterUserInfoOutput
        {
            get
            {
                return this.RegisterUserInfoOutputField;
            }
            set
            {
                this.RegisterUserInfoOutputField = value;
            }
        }
    }
    
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.Runtime.Serialization", "3.0.0.0")]
    [System.Runtime.Serialization.DataContractAttribute(Name="PurchaseOutput", Namespace="urn:schemas.microsoft.com/CommercePlatform/Services/TransactionService/2010/01")]
    public partial class PurchaseOutput : CTPTransactionService.AbstractResponse
    {
        
        private CTPTransactionService.Property[] PropertyBagField;
        
        private CTPTransactionService.PurchaseInfoOutput PurchaseInfoOutputField;
        
        private decimal TotalPriceWithoutTaxField;
        
        private decimal TotalTaxField;
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public CTPTransactionService.Property[] PropertyBag
        {
            get
            {
                return this.PropertyBagField;
            }
            set
            {
                this.PropertyBagField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public CTPTransactionService.PurchaseInfoOutput PurchaseInfoOutput
        {
            get
            {
                return this.PurchaseInfoOutputField;
            }
            set
            {
                this.PurchaseInfoOutputField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public decimal TotalPriceWithoutTax
        {
            get
            {
                return this.TotalPriceWithoutTaxField;
            }
            set
            {
                this.TotalPriceWithoutTaxField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public decimal TotalTax
        {
            get
            {
                return this.TotalTaxField;
            }
            set
            {
                this.TotalTaxField = value;
            }
        }
    }
    
    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.Runtime.Serialization", "3.0.0.0")]
    [System.Runtime.Serialization.DataContractAttribute(Name="AckCodeType", Namespace="urn:schemas.microsoft.com/CommercePlatform/Services/TransactionService/2010/01")]
    public enum AckCodeType : int
    {
        
        [System.Runtime.Serialization.EnumMemberAttribute()]
        Success = 0,
        
        [System.Runtime.Serialization.EnumMemberAttribute()]
        RetryableFailure = 1,
        
        [System.Runtime.Serialization.EnumMemberAttribute()]
        NonRetryableFailure = 2,
        
        [System.Runtime.Serialization.EnumMemberAttribute()]
        InternalError = 3,
    }
    
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.Runtime.Serialization", "3.0.0.0")]
    [System.Runtime.Serialization.DataContractAttribute(Name="PurchaseInfoOutput", Namespace="urn:schemas.microsoft.com/CommercePlatform/Services/TransactionService/2010/01")]
    public partial class PurchaseInfoOutput : object, System.Runtime.Serialization.IExtensibleDataObject
    {
        
        private System.Runtime.Serialization.ExtensionDataObject extensionDataField;
        
        private string ExternalPurchaseIdField;
        
        private System.Nullable<int> NewPointsBalanceField;
        
        private CTPTransactionService.OrderOutput[] OrderSetField;
        
        private CTPTransactionService.Property[] PropertyBagField;
        
        private CTPTransactionService.PurchaseBundleOutput[] PurchaseBundleOutputSetField;
        
        private string PurchaseIdField;
        
        private CTPTransactionService.PurchaseStatus StateField;
        
        public System.Runtime.Serialization.ExtensionDataObject ExtensionData
        {
            get
            {
                return this.extensionDataField;
            }
            set
            {
                this.extensionDataField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public string ExternalPurchaseId
        {
            get
            {
                return this.ExternalPurchaseIdField;
            }
            set
            {
                this.ExternalPurchaseIdField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public System.Nullable<int> NewPointsBalance
        {
            get
            {
                return this.NewPointsBalanceField;
            }
            set
            {
                this.NewPointsBalanceField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public CTPTransactionService.OrderOutput[] OrderSet
        {
            get
            {
                return this.OrderSetField;
            }
            set
            {
                this.OrderSetField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public CTPTransactionService.Property[] PropertyBag
        {
            get
            {
                return this.PropertyBagField;
            }
            set
            {
                this.PropertyBagField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public CTPTransactionService.PurchaseBundleOutput[] PurchaseBundleOutputSet
        {
            get
            {
                return this.PurchaseBundleOutputSetField;
            }
            set
            {
                this.PurchaseBundleOutputSetField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public string PurchaseId
        {
            get
            {
                return this.PurchaseIdField;
            }
            set
            {
                this.PurchaseIdField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public CTPTransactionService.PurchaseStatus State
        {
            get
            {
                return this.StateField;
            }
            set
            {
                this.StateField = value;
            }
        }
    }
    
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.Runtime.Serialization", "3.0.0.0")]
    [System.Runtime.Serialization.DataContractAttribute(Name="PayoutOrderOutput", Namespace="urn:schemas.microsoft.com/CommercePlatform/Services/TransactionService/2010/01")]
    public partial class PayoutOrderOutput : object, System.Runtime.Serialization.IExtensibleDataObject
    {
        
        private System.Runtime.Serialization.ExtensionDataObject extensionDataField;
        
        private System.Nullable<System.DateTime> DueDateField;
        
        private string ExternalPayoutIdField;
        
        private CTPTransactionService.PaymentMethod PaymentMethodField;
        
        private CTPTransactionService.PayoutLineEntryOutput[] PayoutLineEntryOutputSetField;
        
        private CTPTransactionService.PayoutOrderEventOutput[] PayoutOrderEventOutputSetField;
        
        private string PayoutOrderIdField;
        
        private CTPTransactionService.Partner PayoutPartnerField;
        
        private string PayoutTaxProfileIdField;
        
        private CTPTransactionService.Property[] PropertyBagField;
        
        private string TargetCurrencyField;
        
        public System.Runtime.Serialization.ExtensionDataObject ExtensionData
        {
            get
            {
                return this.extensionDataField;
            }
            set
            {
                this.extensionDataField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public System.Nullable<System.DateTime> DueDate
        {
            get
            {
                return this.DueDateField;
            }
            set
            {
                this.DueDateField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public string ExternalPayoutId
        {
            get
            {
                return this.ExternalPayoutIdField;
            }
            set
            {
                this.ExternalPayoutIdField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public CTPTransactionService.PaymentMethod PaymentMethod
        {
            get
            {
                return this.PaymentMethodField;
            }
            set
            {
                this.PaymentMethodField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public CTPTransactionService.PayoutLineEntryOutput[] PayoutLineEntryOutputSet
        {
            get
            {
                return this.PayoutLineEntryOutputSetField;
            }
            set
            {
                this.PayoutLineEntryOutputSetField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public CTPTransactionService.PayoutOrderEventOutput[] PayoutOrderEventOutputSet
        {
            get
            {
                return this.PayoutOrderEventOutputSetField;
            }
            set
            {
                this.PayoutOrderEventOutputSetField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public string PayoutOrderId
        {
            get
            {
                return this.PayoutOrderIdField;
            }
            set
            {
                this.PayoutOrderIdField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public CTPTransactionService.Partner PayoutPartner
        {
            get
            {
                return this.PayoutPartnerField;
            }
            set
            {
                this.PayoutPartnerField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public string PayoutTaxProfileId
        {
            get
            {
                return this.PayoutTaxProfileIdField;
            }
            set
            {
                this.PayoutTaxProfileIdField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public CTPTransactionService.Property[] PropertyBag
        {
            get
            {
                return this.PropertyBagField;
            }
            set
            {
                this.PropertyBagField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public string TargetCurrency
        {
            get
            {
                return this.TargetCurrencyField;
            }
            set
            {
                this.TargetCurrencyField = value;
            }
        }
    }
    
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.Runtime.Serialization", "3.0.0.0")]
    [System.Runtime.Serialization.DataContractAttribute(Name="PayoutLineEntryOutput", Namespace="urn:schemas.microsoft.com/CommercePlatform/Services/TransactionService/2010/01")]
    public partial class PayoutLineEntryOutput : object, System.Runtime.Serialization.IExtensibleDataObject
    {
        
        private System.Runtime.Serialization.ExtensionDataObject extensionDataField;
        
        private string ExternalItemIdField;
        
        private CTPTransactionService.FinancialReportType FinancialReportingTypeField;
        
        private CTPTransactionService.ForeignExchange ForeignExchangeField;
        
        private CTPTransactionService.PayoutTaxEntry[] PayoutTaxEntriesField;
        
        private string SourceCurrencyField;
        
        private System.Nullable<decimal> SourceTotalAmountField;
        
        private string TargetCurrencyField;
        
        private decimal TargetNetAmountField;
        
        private decimal TargetTotalAmountField;
        
        private CTPTransactionService.WHTStateType WHTStateField;
        
        public System.Runtime.Serialization.ExtensionDataObject ExtensionData
        {
            get
            {
                return this.extensionDataField;
            }
            set
            {
                this.extensionDataField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public string ExternalItemId
        {
            get
            {
                return this.ExternalItemIdField;
            }
            set
            {
                this.ExternalItemIdField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public CTPTransactionService.FinancialReportType FinancialReportingType
        {
            get
            {
                return this.FinancialReportingTypeField;
            }
            set
            {
                this.FinancialReportingTypeField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public CTPTransactionService.ForeignExchange ForeignExchange
        {
            get
            {
                return this.ForeignExchangeField;
            }
            set
            {
                this.ForeignExchangeField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public CTPTransactionService.PayoutTaxEntry[] PayoutTaxEntries
        {
            get
            {
                return this.PayoutTaxEntriesField;
            }
            set
            {
                this.PayoutTaxEntriesField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public string SourceCurrency
        {
            get
            {
                return this.SourceCurrencyField;
            }
            set
            {
                this.SourceCurrencyField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public System.Nullable<decimal> SourceTotalAmount
        {
            get
            {
                return this.SourceTotalAmountField;
            }
            set
            {
                this.SourceTotalAmountField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public string TargetCurrency
        {
            get
            {
                return this.TargetCurrencyField;
            }
            set
            {
                this.TargetCurrencyField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public decimal TargetNetAmount
        {
            get
            {
                return this.TargetNetAmountField;
            }
            set
            {
                this.TargetNetAmountField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public decimal TargetTotalAmount
        {
            get
            {
                return this.TargetTotalAmountField;
            }
            set
            {
                this.TargetTotalAmountField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public CTPTransactionService.WHTStateType WHTState
        {
            get
            {
                return this.WHTStateField;
            }
            set
            {
                this.WHTStateField = value;
            }
        }
    }
    
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.Runtime.Serialization", "3.0.0.0")]
    [System.Runtime.Serialization.DataContractAttribute(Name="PayoutOrderEventOutput", Namespace="urn:schemas.microsoft.com/CommercePlatform/Services/TransactionService/2010/01")]
    public partial class PayoutOrderEventOutput : object, System.Runtime.Serialization.IExtensibleDataObject
    {
        
        private System.Runtime.Serialization.ExtensionDataObject extensionDataField;
        
        private System.Nullable<System.DateTime> DueDateField;
        
        private System.DateTime EventDateField;
        
        private string ExternalPayoutIdField;
        
        private string PaymentEventTypeField;
        
        private string PaymentResponseCodeField;
        
        private CTPTransactionService.PayoutLineEntryOutput[] PayoutLineEntryOutputSetField;
        
        private string PayoutOrderEventTypeField;
        
        private string PayoutOrderIdField;
        
        private CTPTransactionService.Property[] PropertyBagField;
        
        public System.Runtime.Serialization.ExtensionDataObject ExtensionData
        {
            get
            {
                return this.extensionDataField;
            }
            set
            {
                this.extensionDataField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public System.Nullable<System.DateTime> DueDate
        {
            get
            {
                return this.DueDateField;
            }
            set
            {
                this.DueDateField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public System.DateTime EventDate
        {
            get
            {
                return this.EventDateField;
            }
            set
            {
                this.EventDateField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public string ExternalPayoutId
        {
            get
            {
                return this.ExternalPayoutIdField;
            }
            set
            {
                this.ExternalPayoutIdField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public string PaymentEventType
        {
            get
            {
                return this.PaymentEventTypeField;
            }
            set
            {
                this.PaymentEventTypeField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public string PaymentResponseCode
        {
            get
            {
                return this.PaymentResponseCodeField;
            }
            set
            {
                this.PaymentResponseCodeField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public CTPTransactionService.PayoutLineEntryOutput[] PayoutLineEntryOutputSet
        {
            get
            {
                return this.PayoutLineEntryOutputSetField;
            }
            set
            {
                this.PayoutLineEntryOutputSetField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public string PayoutOrderEventType
        {
            get
            {
                return this.PayoutOrderEventTypeField;
            }
            set
            {
                this.PayoutOrderEventTypeField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public string PayoutOrderId
        {
            get
            {
                return this.PayoutOrderIdField;
            }
            set
            {
                this.PayoutOrderIdField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public CTPTransactionService.Property[] PropertyBag
        {
            get
            {
                return this.PropertyBagField;
            }
            set
            {
                this.PropertyBagField = value;
            }
        }
    }
    
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.Runtime.Serialization", "3.0.0.0")]
    [System.Runtime.Serialization.DataContractAttribute(Name="ForeignExchange", Namespace="urn:schemas.microsoft.com/CommercePlatform/Services/TransactionService/2010/01")]
    public partial class ForeignExchange : object, System.Runtime.Serialization.IExtensibleDataObject
    {
        
        private System.Runtime.Serialization.ExtensionDataObject extensionDataField;
        
        private System.Nullable<decimal> RateField;
        
        private string SourceCurrencyField;
        
        private string TargetCurrencyField;
        
        private CTPTransactionService.ExchangeRateType TypeField;
        
        public System.Runtime.Serialization.ExtensionDataObject ExtensionData
        {
            get
            {
                return this.extensionDataField;
            }
            set
            {
                this.extensionDataField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public System.Nullable<decimal> Rate
        {
            get
            {
                return this.RateField;
            }
            set
            {
                this.RateField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public string SourceCurrency
        {
            get
            {
                return this.SourceCurrencyField;
            }
            set
            {
                this.SourceCurrencyField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public string TargetCurrency
        {
            get
            {
                return this.TargetCurrencyField;
            }
            set
            {
                this.TargetCurrencyField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public CTPTransactionService.ExchangeRateType Type
        {
            get
            {
                return this.TypeField;
            }
            set
            {
                this.TypeField = value;
            }
        }
    }
    
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.Runtime.Serialization", "3.0.0.0")]
    [System.Runtime.Serialization.DataContractAttribute(Name="PayoutTaxEntry", Namespace="urn:schemas.microsoft.com/CommercePlatform/Services/TransactionService/2010/01")]
    public partial class PayoutTaxEntry : CTPTransactionService.TaxEntry
    {
    }
    
    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.Runtime.Serialization", "3.0.0.0")]
    [System.Runtime.Serialization.DataContractAttribute(Name="WHTStateType", Namespace="urn:schemas.microsoft.com/CommercePlatform/Services/TransactionService/2010/01")]
    public enum WHTStateType : int
    {
        
        [System.Runtime.Serialization.EnumMemberAttribute()]
        Applied = 0,
        
        [System.Runtime.Serialization.EnumMemberAttribute()]
        NotApplicable = 1,
        
        [System.Runtime.Serialization.EnumMemberAttribute()]
        PendingCalculation = 2,
    }
    
    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.Runtime.Serialization", "3.0.0.0")]
    [System.Runtime.Serialization.DataContractAttribute(Name="ExchangeRateType", Namespace="http://schemas.datacontract.org/2004/07/Microsoft.Transaction.Interfaces")]
    public enum ExchangeRateType : int
    {
        
        [System.Runtime.Serialization.EnumMemberAttribute()]
        None = 0,
        
        [System.Runtime.Serialization.EnumMemberAttribute()]
        MonthlyReuters = 1,
    }
    
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.Runtime.Serialization", "3.0.0.0")]
    [System.Runtime.Serialization.DataContractAttribute(Name="TaxEntry", Namespace="urn:schemas.microsoft.com/CommercePlatform/Services/TransactionService/2010/01")]
    [System.Runtime.Serialization.KnownTypeAttribute(typeof(CTPTransactionService.PayoutTaxEntry))]
    public partial class TaxEntry : object, System.Runtime.Serialization.IExtensibleDataObject
    {
        
        private System.Runtime.Serialization.ExtensionDataObject extensionDataField;
        
        private decimal AmountField;
        
        private string CurrencyField;
        
        private string JurisdictionField;
        
        private decimal RateField;
        
        private string SourceOfIncomeField;
        
        public System.Runtime.Serialization.ExtensionDataObject ExtensionData
        {
            get
            {
                return this.extensionDataField;
            }
            set
            {
                this.extensionDataField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public decimal Amount
        {
            get
            {
                return this.AmountField;
            }
            set
            {
                this.AmountField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public string Currency
        {
            get
            {
                return this.CurrencyField;
            }
            set
            {
                this.CurrencyField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public string Jurisdiction
        {
            get
            {
                return this.JurisdictionField;
            }
            set
            {
                this.JurisdictionField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public decimal Rate
        {
            get
            {
                return this.RateField;
            }
            set
            {
                this.RateField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public string SourceOfIncome
        {
            get
            {
                return this.SourceOfIncomeField;
            }
            set
            {
                this.SourceOfIncomeField = value;
            }
        }
    }
    
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.Runtime.Serialization", "3.0.0.0")]
    [System.Runtime.Serialization.DataContractAttribute(Name="JoinSubscriptionInfoOutput", Namespace="urn:schemas.microsoft.com/CommercePlatform/Services/TransactionService/2010/01")]
    public partial class JoinSubscriptionInfoOutput : object, System.Runtime.Serialization.IExtensibleDataObject
    {
        
        private System.Runtime.Serialization.ExtensionDataObject extensionDataField;
        
        private CTPTransactionService.RatingEvent[] DestSubsRatingRuleSetField;
        
        private System.DateTime DestSubscriptionNextCycleChargeDateField;
        
        private CTPTransactionService.SubscriptionStatusInfo DestinationSubscriptionStatusField;
        
        private string ExternalJoinSubsIdField;
        
        private int SourceSubsRemainingDaysPrejoinField;
        
        private CTPTransactionService.ServiceInstance[] SourceSubsRemovedServiceInstanceSetField;
        
        private CTPTransactionService.SubscriptionStatusInfo SourceSubscriptionStatusField;
        
        private CTPTransactionService.JoinSubsStatus StateField;
        
        public System.Runtime.Serialization.ExtensionDataObject ExtensionData
        {
            get
            {
                return this.extensionDataField;
            }
            set
            {
                this.extensionDataField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public CTPTransactionService.RatingEvent[] DestSubsRatingRuleSet
        {
            get
            {
                return this.DestSubsRatingRuleSetField;
            }
            set
            {
                this.DestSubsRatingRuleSetField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public System.DateTime DestSubscriptionNextCycleChargeDate
        {
            get
            {
                return this.DestSubscriptionNextCycleChargeDateField;
            }
            set
            {
                this.DestSubscriptionNextCycleChargeDateField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public CTPTransactionService.SubscriptionStatusInfo DestinationSubscriptionStatus
        {
            get
            {
                return this.DestinationSubscriptionStatusField;
            }
            set
            {
                this.DestinationSubscriptionStatusField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public string ExternalJoinSubsId
        {
            get
            {
                return this.ExternalJoinSubsIdField;
            }
            set
            {
                this.ExternalJoinSubsIdField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public int SourceSubsRemainingDaysPrejoin
        {
            get
            {
                return this.SourceSubsRemainingDaysPrejoinField;
            }
            set
            {
                this.SourceSubsRemainingDaysPrejoinField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public CTPTransactionService.ServiceInstance[] SourceSubsRemovedServiceInstanceSet
        {
            get
            {
                return this.SourceSubsRemovedServiceInstanceSetField;
            }
            set
            {
                this.SourceSubsRemovedServiceInstanceSetField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public CTPTransactionService.SubscriptionStatusInfo SourceSubscriptionStatus
        {
            get
            {
                return this.SourceSubscriptionStatusField;
            }
            set
            {
                this.SourceSubscriptionStatusField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public CTPTransactionService.JoinSubsStatus State
        {
            get
            {
                return this.StateField;
            }
            set
            {
                this.StateField = value;
            }
        }
    }
    
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.Runtime.Serialization", "3.0.0.0")]
    [System.Runtime.Serialization.DataContractAttribute(Name="SubscriptionStatusInfo", Namespace="urn:schemas.microsoft.com/CommercePlatform/Services/TransactionService/2010/01")]
    public partial class SubscriptionStatusInfo : object, System.Runtime.Serialization.IExtensibleDataObject
    {
        
        private System.Runtime.Serialization.ExtensionDataObject extensionDataField;
        
        private System.DateTime NewEndDateField;
        
        private string SubscriptionIdField;
        
        private CTPTransactionService.SubscriptionStatus SubscriptionStatusField;
        
        private CTPTransactionService.ViolationId[] ViolationSetField;
        
        public System.Runtime.Serialization.ExtensionDataObject ExtensionData
        {
            get
            {
                return this.extensionDataField;
            }
            set
            {
                this.extensionDataField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public System.DateTime NewEndDate
        {
            get
            {
                return this.NewEndDateField;
            }
            set
            {
                this.NewEndDateField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public string SubscriptionId
        {
            get
            {
                return this.SubscriptionIdField;
            }
            set
            {
                this.SubscriptionIdField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public CTPTransactionService.SubscriptionStatus SubscriptionStatus
        {
            get
            {
                return this.SubscriptionStatusField;
            }
            set
            {
                this.SubscriptionStatusField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public CTPTransactionService.ViolationId[] ViolationSet
        {
            get
            {
                return this.ViolationSetField;
            }
            set
            {
                this.ViolationSetField = value;
            }
        }
    }
    
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.Runtime.Serialization", "3.0.0.0")]
    [System.Runtime.Serialization.DataContractAttribute(Name="ServiceInstance", Namespace="urn:schemas.microsoft.com/CommercePlatform/Services/TransactionService/2010/01")]
    public partial class ServiceInstance : object, System.Runtime.Serialization.IExtensibleDataObject
    {
        
        private System.Runtime.Serialization.ExtensionDataObject extensionDataField;
        
        private string ServiceComponentIdField;
        
        private string ServiceInstanceIdField;
        
        public System.Runtime.Serialization.ExtensionDataObject ExtensionData
        {
            get
            {
                return this.extensionDataField;
            }
            set
            {
                this.extensionDataField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public string ServiceComponentId
        {
            get
            {
                return this.ServiceComponentIdField;
            }
            set
            {
                this.ServiceComponentIdField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public string ServiceInstanceId
        {
            get
            {
                return this.ServiceInstanceIdField;
            }
            set
            {
                this.ServiceInstanceIdField = value;
            }
        }
    }
    
    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.Runtime.Serialization", "3.0.0.0")]
    [System.Runtime.Serialization.DataContractAttribute(Name="JoinSubsStatus", Namespace="urn:schemas.microsoft.com/CommercePlatform/Services/TransactionService/2010/01")]
    public enum JoinSubsStatus : int
    {
        
        [System.Runtime.Serialization.EnumMemberAttribute()]
        None = 0,
        
        [System.Runtime.Serialization.EnumMemberAttribute()]
        InProgress = 1,
        
        [System.Runtime.Serialization.EnumMemberAttribute()]
        Complete = 2,
        
        [System.Runtime.Serialization.EnumMemberAttribute()]
        Abandon = 3,
        
        [System.Runtime.Serialization.EnumMemberAttribute()]
        Aborted = 4,
    }
    
    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.Runtime.Serialization", "3.0.0.0")]
    [System.Runtime.Serialization.DataContractAttribute(Name="SubscriptionStatus", Namespace="urn:schemas.microsoft.com/CommercePlatform/Services/TransactionService/2010/01")]
    public enum SubscriptionStatus : int
    {
        
        [System.Runtime.Serialization.EnumMemberAttribute()]
        INVALID = 0,
        
        [System.Runtime.Serialization.EnumMemberAttribute()]
        PENDING = 1,
        
        [System.Runtime.Serialization.EnumMemberAttribute()]
        ENABLED = 2,
        
        [System.Runtime.Serialization.EnumMemberAttribute()]
        SUSPENDED = 3,
        
        [System.Runtime.Serialization.EnumMemberAttribute()]
        CANCELED = 4,
        
        [System.Runtime.Serialization.EnumMemberAttribute()]
        EXPIRED = 5,
        
        [System.Runtime.Serialization.EnumMemberAttribute()]
        ABANDONED = 6,
        
        [System.Runtime.Serialization.EnumMemberAttribute()]
        PENDINGCOMMITCREATESUBS = 7,
        
        [System.Runtime.Serialization.EnumMemberAttribute()]
        PENDINGCOMMITCONVERTSUBS = 8,
    }
    
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.Runtime.Serialization", "3.0.0.0")]
    [System.Runtime.Serialization.DataContractAttribute(Name="ViolationId", Namespace="urn:schemas.microsoft.com/CommercePlatform/Services/TransactionService/2010/01")]
    public partial class ViolationId : object, System.Runtime.Serialization.IExtensibleDataObject
    {
        
        private System.Runtime.Serialization.ExtensionDataObject extensionDataField;
        
        private int IdField;
        
        public System.Runtime.Serialization.ExtensionDataObject ExtensionData
        {
            get
            {
                return this.extensionDataField;
            }
            set
            {
                this.extensionDataField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public int Id
        {
            get
            {
                return this.IdField;
            }
            set
            {
                this.IdField = value;
            }
        }
    }
    
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.Runtime.Serialization", "3.0.0.0")]
    [System.Runtime.Serialization.DataContractAttribute(Name="MigrateAccountInfoOutput", Namespace="urn:schemas.microsoft.com/CommercePlatform/Services/TransactionService/2010/01")]
    public partial class MigrateAccountInfoOutput : object, System.Runtime.Serialization.IExtensibleDataObject
    {
        
        private System.Runtime.Serialization.ExtensionDataObject extensionDataField;
        
        private CTPTransactionService.MigrateAccountStatus MigrateAccountStatusField;
        
        private CTPTransactionService.MigrateSubscriptionInfoOutput[] MigrateSubscriptionInfoOutputsField;
        
        public System.Runtime.Serialization.ExtensionDataObject ExtensionData
        {
            get
            {
                return this.extensionDataField;
            }
            set
            {
                this.extensionDataField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public CTPTransactionService.MigrateAccountStatus MigrateAccountStatus
        {
            get
            {
                return this.MigrateAccountStatusField;
            }
            set
            {
                this.MigrateAccountStatusField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public CTPTransactionService.MigrateSubscriptionInfoOutput[] MigrateSubscriptionInfoOutputs
        {
            get
            {
                return this.MigrateSubscriptionInfoOutputsField;
            }
            set
            {
                this.MigrateSubscriptionInfoOutputsField = value;
            }
        }
    }
    
    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.Runtime.Serialization", "3.0.0.0")]
    [System.Runtime.Serialization.DataContractAttribute(Name="MigrateAccountStatus", Namespace="urn:schemas.microsoft.com/CommercePlatform/Services/TransactionService/2010/01")]
    public enum MigrateAccountStatus : int
    {
        
        [System.Runtime.Serialization.EnumMemberAttribute()]
        None = 0,
        
        [System.Runtime.Serialization.EnumMemberAttribute()]
        InProgress = 1,
        
        [System.Runtime.Serialization.EnumMemberAttribute()]
        Complete = 2,
        
        [System.Runtime.Serialization.EnumMemberAttribute()]
        Abandon = 3,
        
        [System.Runtime.Serialization.EnumMemberAttribute()]
        Aborted = 4,
    }
    
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.Runtime.Serialization", "3.0.0.0")]
    [System.Runtime.Serialization.DataContractAttribute(Name="MigrateSubscriptionInfoOutput", Namespace="urn:schemas.microsoft.com/CommercePlatform/Services/TransactionService/2010/01")]
    public partial class MigrateSubscriptionInfoOutput : object, System.Runtime.Serialization.IExtensibleDataObject
    {
        
        private System.Runtime.Serialization.ExtensionDataObject extensionDataField;
        
        private CTPTransactionService.ServiceInstance[] DestinationSubsAddedServiceInstanceSetField;
        
        private CTPTransactionService.SubscriptionStatusInfo DestinationSubscriptionStatusField;
        
        private CTPTransactionService.ProvisionServiceResult ProvisionServiceResultField;
        
        private CTPTransactionService.ServiceInstance[] SourceSubsRemovedServiceInstanceSetField;
        
        private CTPTransactionService.SubscriptionStatusInfo SourceSubscriptionStatusField;
        
        public System.Runtime.Serialization.ExtensionDataObject ExtensionData
        {
            get
            {
                return this.extensionDataField;
            }
            set
            {
                this.extensionDataField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public CTPTransactionService.ServiceInstance[] DestinationSubsAddedServiceInstanceSet
        {
            get
            {
                return this.DestinationSubsAddedServiceInstanceSetField;
            }
            set
            {
                this.DestinationSubsAddedServiceInstanceSetField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public CTPTransactionService.SubscriptionStatusInfo DestinationSubscriptionStatus
        {
            get
            {
                return this.DestinationSubscriptionStatusField;
            }
            set
            {
                this.DestinationSubscriptionStatusField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public CTPTransactionService.ProvisionServiceResult ProvisionServiceResult
        {
            get
            {
                return this.ProvisionServiceResultField;
            }
            set
            {
                this.ProvisionServiceResultField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public CTPTransactionService.ServiceInstance[] SourceSubsRemovedServiceInstanceSet
        {
            get
            {
                return this.SourceSubsRemovedServiceInstanceSetField;
            }
            set
            {
                this.SourceSubsRemovedServiceInstanceSetField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public CTPTransactionService.SubscriptionStatusInfo SourceSubscriptionStatus
        {
            get
            {
                return this.SourceSubscriptionStatusField;
            }
            set
            {
                this.SourceSubscriptionStatusField = value;
            }
        }
    }
    
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.Runtime.Serialization", "3.0.0.0")]
    [System.Runtime.Serialization.DataContractAttribute(Name="ProvisionServiceResult", Namespace="urn:schemas.microsoft.com/CommercePlatform/Services/TransactionService/2010/01")]
    public partial class ProvisionServiceResult : object, System.Runtime.Serialization.IExtensibleDataObject
    {
        
        private System.Runtime.Serialization.ExtensionDataObject extensionDataField;
        
        private string ErrorMessageField;
        
        private bool ServiceProvisionedField;
        
        public System.Runtime.Serialization.ExtensionDataObject ExtensionData
        {
            get
            {
                return this.extensionDataField;
            }
            set
            {
                this.extensionDataField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public string ErrorMessage
        {
            get
            {
                return this.ErrorMessageField;
            }
            set
            {
                this.ErrorMessageField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public bool ServiceProvisioned
        {
            get
            {
                return this.ServiceProvisionedField;
            }
            set
            {
                this.ServiceProvisionedField = value;
            }
        }
    }
    
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.Runtime.Serialization", "3.0.0.0")]
    [System.Runtime.Serialization.DataContractAttribute(Name="RegisterUserInfoOutput", Namespace="urn:schemas.microsoft.com/CommercePlatform/Services/TransactionService/2010/01")]
    public partial class RegisterUserInfoOutput : object, System.Runtime.Serialization.IExtensibleDataObject
    {
        
        private System.Runtime.Serialization.ExtensionDataObject extensionDataField;
        
        private string PaymentInstrumentIdField;
        
        private CTPTransactionService.Property[] PropertyBagField;
        
        private CTPTransactionService.RegisterUserStatus StateField;
        
        private CTPTransactionService.StoredValueAccountInfo StoredValueAccountInfoField;
        
        public System.Runtime.Serialization.ExtensionDataObject ExtensionData
        {
            get
            {
                return this.extensionDataField;
            }
            set
            {
                this.extensionDataField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public string PaymentInstrumentId
        {
            get
            {
                return this.PaymentInstrumentIdField;
            }
            set
            {
                this.PaymentInstrumentIdField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public CTPTransactionService.Property[] PropertyBag
        {
            get
            {
                return this.PropertyBagField;
            }
            set
            {
                this.PropertyBagField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public CTPTransactionService.RegisterUserStatus State
        {
            get
            {
                return this.StateField;
            }
            set
            {
                this.StateField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public CTPTransactionService.StoredValueAccountInfo StoredValueAccountInfo
        {
            get
            {
                return this.StoredValueAccountInfoField;
            }
            set
            {
                this.StoredValueAccountInfoField = value;
            }
        }
    }
    
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.Runtime.Serialization", "3.0.0.0")]
    [System.Runtime.Serialization.DataContractAttribute(Name="StoredValueAccountInfo", Namespace="urn:schemas.microsoft.com/CommercePlatform/Services/TransactionService/2010/01")]
    public partial class StoredValueAccountInfo : object, System.Runtime.Serialization.IExtensibleDataObject
    {
        
        private System.Runtime.Serialization.ExtensionDataObject extensionDataField;
        
        private CTPTransactionService.StoredValueAccount StoredValueAccountField;
        
        private CTPTransactionService.StoredValueBalance[] StoredValueAccountBalanceSetField;
        
        public System.Runtime.Serialization.ExtensionDataObject ExtensionData
        {
            get
            {
                return this.extensionDataField;
            }
            set
            {
                this.extensionDataField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public CTPTransactionService.StoredValueAccount StoredValueAccount
        {
            get
            {
                return this.StoredValueAccountField;
            }
            set
            {
                this.StoredValueAccountField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public CTPTransactionService.StoredValueBalance[] StoredValueAccountBalanceSet
        {
            get
            {
                return this.StoredValueAccountBalanceSetField;
            }
            set
            {
                this.StoredValueAccountBalanceSetField = value;
            }
        }
    }
    
    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.Runtime.Serialization", "3.0.0.0")]
    [System.Runtime.Serialization.DataContractAttribute(Name="RegisterUserStatus", Namespace="urn:schemas.microsoft.com/CommercePlatform/Services/TransactionService/2010/01")]
    public enum RegisterUserStatus : int
    {
        
        [System.Runtime.Serialization.EnumMemberAttribute()]
        None = 0,
        
        [System.Runtime.Serialization.EnumMemberAttribute()]
        InProgress = 1,
        
        [System.Runtime.Serialization.EnumMemberAttribute()]
        Complete = 2,
        
        [System.Runtime.Serialization.EnumMemberAttribute()]
        Abandon = 3,
        
        [System.Runtime.Serialization.EnumMemberAttribute()]
        Aborted = 4,
    }
    
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.Runtime.Serialization", "3.0.0.0")]
    [System.Runtime.Serialization.DataContractAttribute(Name="StoredValueAccount", Namespace="urn:schemas.microsoft.com/CommercePlatform/Services/TransactionService/2010/01")]
    public partial class StoredValueAccount : object, System.Runtime.Serialization.IExtensibleDataObject
    {
        
        private System.Runtime.Serialization.ExtensionDataObject extensionDataField;
        
        private short AnniversaryField;
        
        private string CountryCodeField;
        
        private string CurrencyCodeField;
        
        private CTPTransactionService.Property[] PropertyBagField;
        
        private string StoredValueAccountIdField;
        
        private short StoredValueAccountStatusCodeField;
        
        private string StoredValueAccountStatusValueField;
        
        private CTPTransactionService.User StoredValueOwnerField;
        
        public System.Runtime.Serialization.ExtensionDataObject ExtensionData
        {
            get
            {
                return this.extensionDataField;
            }
            set
            {
                this.extensionDataField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public short Anniversary
        {
            get
            {
                return this.AnniversaryField;
            }
            set
            {
                this.AnniversaryField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public string CountryCode
        {
            get
            {
                return this.CountryCodeField;
            }
            set
            {
                this.CountryCodeField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public string CurrencyCode
        {
            get
            {
                return this.CurrencyCodeField;
            }
            set
            {
                this.CurrencyCodeField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public CTPTransactionService.Property[] PropertyBag
        {
            get
            {
                return this.PropertyBagField;
            }
            set
            {
                this.PropertyBagField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public string StoredValueAccountId
        {
            get
            {
                return this.StoredValueAccountIdField;
            }
            set
            {
                this.StoredValueAccountIdField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public short StoredValueAccountStatusCode
        {
            get
            {
                return this.StoredValueAccountStatusCodeField;
            }
            set
            {
                this.StoredValueAccountStatusCodeField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public string StoredValueAccountStatusValue
        {
            get
            {
                return this.StoredValueAccountStatusValueField;
            }
            set
            {
                this.StoredValueAccountStatusValueField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public CTPTransactionService.User StoredValueOwner
        {
            get
            {
                return this.StoredValueOwnerField;
            }
            set
            {
                this.StoredValueOwnerField = value;
            }
        }
    }
    
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.Runtime.Serialization", "3.0.0.0")]
    [System.Runtime.Serialization.DataContractAttribute(Name="StoredValueBalance", Namespace="urn:schemas.microsoft.com/CommercePlatform/Services/TransactionService/2010/01")]
    public partial class StoredValueBalance : object, System.Runtime.Serialization.IExtensibleDataObject
    {
        
        private System.Runtime.Serialization.ExtensionDataObject extensionDataField;
        
        private decimal AmountField;
        
        private string CurrencyCodeField;
        
        private CTPTransactionService.Property[] PropertyBagField;
        
        private string StoredValueAccountIdField;
        
        private short StoredValueBalanceStatusCodeField;
        
        private string StoredValueBalanceStatusValueField;
        
        public System.Runtime.Serialization.ExtensionDataObject ExtensionData
        {
            get
            {
                return this.extensionDataField;
            }
            set
            {
                this.extensionDataField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public decimal Amount
        {
            get
            {
                return this.AmountField;
            }
            set
            {
                this.AmountField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public string CurrencyCode
        {
            get
            {
                return this.CurrencyCodeField;
            }
            set
            {
                this.CurrencyCodeField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public CTPTransactionService.Property[] PropertyBag
        {
            get
            {
                return this.PropertyBagField;
            }
            set
            {
                this.PropertyBagField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public string StoredValueAccountId
        {
            get
            {
                return this.StoredValueAccountIdField;
            }
            set
            {
                this.StoredValueAccountIdField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public short StoredValueBalanceStatusCode
        {
            get
            {
                return this.StoredValueBalanceStatusCodeField;
            }
            set
            {
                this.StoredValueBalanceStatusCodeField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public string StoredValueBalanceStatusValue
        {
            get
            {
                return this.StoredValueBalanceStatusValueField;
            }
            set
            {
                this.StoredValueBalanceStatusValueField = value;
            }
        }
    }
    
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.Runtime.Serialization", "3.0.0.0")]
    [System.Runtime.Serialization.DataContractAttribute(Name="User", Namespace="urn:schemas.microsoft.com/CommercePlatform/Services/TransactionService/2010/01")]
    public partial class User : object, System.Runtime.Serialization.IExtensibleDataObject
    {
        
        private System.Runtime.Serialization.ExtensionDataObject extensionDataField;
        
        private string UserIdField;
        
        private string UserTypeField;
        
        public System.Runtime.Serialization.ExtensionDataObject ExtensionData
        {
            get
            {
                return this.extensionDataField;
            }
            set
            {
                this.extensionDataField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public string UserId
        {
            get
            {
                return this.UserIdField;
            }
            set
            {
                this.UserIdField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public string UserType
        {
            get
            {
                return this.UserTypeField;
            }
            set
            {
                this.UserTypeField = value;
            }
        }
    }
    
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.Runtime.Serialization", "3.0.0.0")]
    [System.Runtime.Serialization.DataContractAttribute(Name="OrderOutput", Namespace="urn:schemas.microsoft.com/CommercePlatform/Services/TransactionService/2010/01")]
    public partial class OrderOutput : object, System.Runtime.Serialization.IExtensibleDataObject
    {
        
        private System.Runtime.Serialization.ExtensionDataObject extensionDataField;
        
        private CTPTransactionService.BillingMode BillingModeField;
        
        private string CurrencyField;
        
        private System.DateTime EstimatedChargeTimeField;
        
        private CTPTransactionService.ItemEntryOutput[] ItemEntriesField;
        
        private long OrderIdField;
        
        public System.Runtime.Serialization.ExtensionDataObject ExtensionData
        {
            get
            {
                return this.extensionDataField;
            }
            set
            {
                this.extensionDataField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public CTPTransactionService.BillingMode BillingMode
        {
            get
            {
                return this.BillingModeField;
            }
            set
            {
                this.BillingModeField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public string Currency
        {
            get
            {
                return this.CurrencyField;
            }
            set
            {
                this.CurrencyField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public System.DateTime EstimatedChargeTime
        {
            get
            {
                return this.EstimatedChargeTimeField;
            }
            set
            {
                this.EstimatedChargeTimeField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public CTPTransactionService.ItemEntryOutput[] ItemEntries
        {
            get
            {
                return this.ItemEntriesField;
            }
            set
            {
                this.ItemEntriesField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public long OrderId
        {
            get
            {
                return this.OrderIdField;
            }
            set
            {
                this.OrderIdField = value;
            }
        }
    }
    
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.Runtime.Serialization", "3.0.0.0")]
    [System.Runtime.Serialization.DataContractAttribute(Name="PurchaseBundleOutput", Namespace="urn:schemas.microsoft.com/CommercePlatform/Services/TransactionService/2010/01")]
    public partial class PurchaseBundleOutput : object, System.Runtime.Serialization.IExtensibleDataObject
    {
        
        private System.Runtime.Serialization.ExtensionDataObject extensionDataField;
        
        private System.Nullable<decimal> AmountField;
        
        private string BundleIdField;
        
        private string CurrencyField;
        
        private string DescriptionField;
        
        private string ExternalBundleCatalogIdField;
        
        private string ExternalBundleIdField;
        
        private System.Nullable<bool> IsTaxExemptionAppliedField;
        
        private System.Nullable<bool> IsTaxIncludedField;
        
        private CTPTransactionService.Property[] PropertyBagField;
        
        private CTPTransactionService.PurchaseProductItemOutput[] PurchaseProductItemOutputSetField;
        
        private CTPTransactionService.TaxEntry[] TaxEntriesField;
        
        private string TitleField;
        
        private decimal TotalTaxAmountField;
        
        private decimal TotalTaxRateField;
        
        public System.Runtime.Serialization.ExtensionDataObject ExtensionData
        {
            get
            {
                return this.extensionDataField;
            }
            set
            {
                this.extensionDataField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public System.Nullable<decimal> Amount
        {
            get
            {
                return this.AmountField;
            }
            set
            {
                this.AmountField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public string BundleId
        {
            get
            {
                return this.BundleIdField;
            }
            set
            {
                this.BundleIdField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public string Currency
        {
            get
            {
                return this.CurrencyField;
            }
            set
            {
                this.CurrencyField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public string Description
        {
            get
            {
                return this.DescriptionField;
            }
            set
            {
                this.DescriptionField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public string ExternalBundleCatalogId
        {
            get
            {
                return this.ExternalBundleCatalogIdField;
            }
            set
            {
                this.ExternalBundleCatalogIdField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public string ExternalBundleId
        {
            get
            {
                return this.ExternalBundleIdField;
            }
            set
            {
                this.ExternalBundleIdField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public System.Nullable<bool> IsTaxExemptionApplied
        {
            get
            {
                return this.IsTaxExemptionAppliedField;
            }
            set
            {
                this.IsTaxExemptionAppliedField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public System.Nullable<bool> IsTaxIncluded
        {
            get
            {
                return this.IsTaxIncludedField;
            }
            set
            {
                this.IsTaxIncludedField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public CTPTransactionService.Property[] PropertyBag
        {
            get
            {
                return this.PropertyBagField;
            }
            set
            {
                this.PropertyBagField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public CTPTransactionService.PurchaseProductItemOutput[] PurchaseProductItemOutputSet
        {
            get
            {
                return this.PurchaseProductItemOutputSetField;
            }
            set
            {
                this.PurchaseProductItemOutputSetField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public CTPTransactionService.TaxEntry[] TaxEntries
        {
            get
            {
                return this.TaxEntriesField;
            }
            set
            {
                this.TaxEntriesField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public string Title
        {
            get
            {
                return this.TitleField;
            }
            set
            {
                this.TitleField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public decimal TotalTaxAmount
        {
            get
            {
                return this.TotalTaxAmountField;
            }
            set
            {
                this.TotalTaxAmountField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public decimal TotalTaxRate
        {
            get
            {
                return this.TotalTaxRateField;
            }
            set
            {
                this.TotalTaxRateField = value;
            }
        }
    }
    
    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.Runtime.Serialization", "3.0.0.0")]
    [System.Runtime.Serialization.DataContractAttribute(Name="PurchaseStatus", Namespace="urn:schemas.microsoft.com/CommercePlatform/Services/TransactionService/2010/01")]
    public enum PurchaseStatus : int
    {
        
        [System.Runtime.Serialization.EnumMemberAttribute()]
        None = 0,
        
        [System.Runtime.Serialization.EnumMemberAttribute()]
        InProgress = 1,
        
        [System.Runtime.Serialization.EnumMemberAttribute()]
        Complete = 2,
        
        [System.Runtime.Serialization.EnumMemberAttribute()]
        Abandon = 3,
        
        [System.Runtime.Serialization.EnumMemberAttribute()]
        Aborted = 4,
    }
    
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.Runtime.Serialization", "3.0.0.0")]
    [System.Runtime.Serialization.DataContractAttribute(Name="ItemEntryOutput", Namespace="urn:schemas.microsoft.com/CommercePlatform/Services/TransactionService/2010/01")]
    public partial class ItemEntryOutput : object, System.Runtime.Serialization.IExtensibleDataObject
    {
        
        private System.Runtime.Serialization.ExtensionDataObject extensionDataField;
        
        private long BundleIdField;
        
        private System.Nullable<bool> IsTaxExemptionAppliedField;
        
        private System.Nullable<bool> IsTaxIncludedField;
        
        private string ItemDescriptionField;
        
        private string ItemNameField;
        
        private string ItemTypeField;
        
        private long ProductItemIdField;
        
        private long PurchaseIdField;
        
        private System.Nullable<int> QuantityField;
        
        private string RevenueSKUField;
        
        private string TaxCodeField;
        
        private CTPTransactionService.TaxEntry[] TaxEntriesField;
        
        private System.Nullable<decimal> UnitAmountField;
        
        public System.Runtime.Serialization.ExtensionDataObject ExtensionData
        {
            get
            {
                return this.extensionDataField;
            }
            set
            {
                this.extensionDataField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public long BundleId
        {
            get
            {
                return this.BundleIdField;
            }
            set
            {
                this.BundleIdField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public System.Nullable<bool> IsTaxExemptionApplied
        {
            get
            {
                return this.IsTaxExemptionAppliedField;
            }
            set
            {
                this.IsTaxExemptionAppliedField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public System.Nullable<bool> IsTaxIncluded
        {
            get
            {
                return this.IsTaxIncludedField;
            }
            set
            {
                this.IsTaxIncludedField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public string ItemDescription
        {
            get
            {
                return this.ItemDescriptionField;
            }
            set
            {
                this.ItemDescriptionField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public string ItemName
        {
            get
            {
                return this.ItemNameField;
            }
            set
            {
                this.ItemNameField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public string ItemType
        {
            get
            {
                return this.ItemTypeField;
            }
            set
            {
                this.ItemTypeField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public long ProductItemId
        {
            get
            {
                return this.ProductItemIdField;
            }
            set
            {
                this.ProductItemIdField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public long PurchaseId
        {
            get
            {
                return this.PurchaseIdField;
            }
            set
            {
                this.PurchaseIdField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public System.Nullable<int> Quantity
        {
            get
            {
                return this.QuantityField;
            }
            set
            {
                this.QuantityField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public string RevenueSKU
        {
            get
            {
                return this.RevenueSKUField;
            }
            set
            {
                this.RevenueSKUField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public string TaxCode
        {
            get
            {
                return this.TaxCodeField;
            }
            set
            {
                this.TaxCodeField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public CTPTransactionService.TaxEntry[] TaxEntries
        {
            get
            {
                return this.TaxEntriesField;
            }
            set
            {
                this.TaxEntriesField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public System.Nullable<decimal> UnitAmount
        {
            get
            {
                return this.UnitAmountField;
            }
            set
            {
                this.UnitAmountField = value;
            }
        }
    }
    
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.Runtime.Serialization", "3.0.0.0")]
    [System.Runtime.Serialization.DataContractAttribute(Name="PurchaseProductItemOutput", Namespace="urn:schemas.microsoft.com/CommercePlatform/Services/TransactionService/2010/01")]
    [System.Runtime.Serialization.KnownTypeAttribute(typeof(CTPTransactionService.PurchasePointsProductItemOutput))]
    [System.Runtime.Serialization.KnownTypeAttribute(typeof(CTPTransactionService.PurchaseContentProductItemOutput))]
    [System.Runtime.Serialization.KnownTypeAttribute(typeof(CTPTransactionService.PurchaseStoredValueProductItemOutput))]
    [System.Runtime.Serialization.KnownTypeAttribute(typeof(CTPTransactionService.PurchaseNewSubscriptionProductItemOutput))]
    [System.Runtime.Serialization.KnownTypeAttribute(typeof(CTPTransactionService.PurchaseConvertSubscriptionProductItemOutput))]
    public partial class PurchaseProductItemOutput : object, System.Runtime.Serialization.IExtensibleDataObject
    {
        
        private System.Runtime.Serialization.ExtensionDataObject extensionDataField;
        
        private string ExternalProductItemIdField;
        
        private string ProductItemIdField;
        
        public System.Runtime.Serialization.ExtensionDataObject ExtensionData
        {
            get
            {
                return this.extensionDataField;
            }
            set
            {
                this.extensionDataField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public string ExternalProductItemId
        {
            get
            {
                return this.ExternalProductItemIdField;
            }
            set
            {
                this.ExternalProductItemIdField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public string ProductItemId
        {
            get
            {
                return this.ProductItemIdField;
            }
            set
            {
                this.ProductItemIdField = value;
            }
        }
    }
    
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.Runtime.Serialization", "3.0.0.0")]
    [System.Runtime.Serialization.DataContractAttribute(Name="PurchasePointsProductItemOutput", Namespace="urn:schemas.microsoft.com/CommercePlatform/Services/TransactionService/2010/01")]
    public partial class PurchasePointsProductItemOutput : CTPTransactionService.PurchaseProductItemOutput
    {
        
        private string PointsPurchaseInstanceIdField;
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public string PointsPurchaseInstanceId
        {
            get
            {
                return this.PointsPurchaseInstanceIdField;
            }
            set
            {
                this.PointsPurchaseInstanceIdField = value;
            }
        }
    }
    
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.Runtime.Serialization", "3.0.0.0")]
    [System.Runtime.Serialization.DataContractAttribute(Name="PurchaseContentProductItemOutput", Namespace="urn:schemas.microsoft.com/CommercePlatform/Services/TransactionService/2010/01")]
    public partial class PurchaseContentProductItemOutput : CTPTransactionService.PurchaseProductItemOutput
    {
    }
    
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.Runtime.Serialization", "3.0.0.0")]
    [System.Runtime.Serialization.DataContractAttribute(Name="PurchaseStoredValueProductItemOutput", Namespace="urn:schemas.microsoft.com/CommercePlatform/Services/TransactionService/2010/01")]
    public partial class PurchaseStoredValueProductItemOutput : CTPTransactionService.PurchaseProductItemOutput
    {
        
        private CTPTransactionService.StoredValueBalance StoredValueBalanceField;
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public CTPTransactionService.StoredValueBalance StoredValueBalance
        {
            get
            {
                return this.StoredValueBalanceField;
            }
            set
            {
                this.StoredValueBalanceField = value;
            }
        }
    }
    
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.Runtime.Serialization", "3.0.0.0")]
    [System.Runtime.Serialization.DataContractAttribute(Name="PurchaseNewSubscriptionProductItemOutput", Namespace="urn:schemas.microsoft.com/CommercePlatform/Services/TransactionService/2010/01")]
    public partial class PurchaseNewSubscriptionProductItemOutput : CTPTransactionService.PurchaseProductItemOutput
    {
        
        private CTPTransactionService.ServiceInstance[] AddedServiceInstanceSetField;
        
        private CTPTransactionService.RatingEvent[] RatingEventsField;
        
        private System.DateTime SubscriptionEndDateField;
        
        private System.Nullable<System.DateTime> SubscriptionFirstCycleChargeDateField;
        
        private string SubscriptionIdField;
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public CTPTransactionService.ServiceInstance[] AddedServiceInstanceSet
        {
            get
            {
                return this.AddedServiceInstanceSetField;
            }
            set
            {
                this.AddedServiceInstanceSetField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public CTPTransactionService.RatingEvent[] RatingEvents
        {
            get
            {
                return this.RatingEventsField;
            }
            set
            {
                this.RatingEventsField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public System.DateTime SubscriptionEndDate
        {
            get
            {
                return this.SubscriptionEndDateField;
            }
            set
            {
                this.SubscriptionEndDateField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public System.Nullable<System.DateTime> SubscriptionFirstCycleChargeDate
        {
            get
            {
                return this.SubscriptionFirstCycleChargeDateField;
            }
            set
            {
                this.SubscriptionFirstCycleChargeDateField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public string SubscriptionId
        {
            get
            {
                return this.SubscriptionIdField;
            }
            set
            {
                this.SubscriptionIdField = value;
            }
        }
    }
    
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.Runtime.Serialization", "3.0.0.0")]
    [System.Runtime.Serialization.DataContractAttribute(Name="PurchaseConvertSubscriptionProductItemOutput", Namespace="urn:schemas.microsoft.com/CommercePlatform/Services/TransactionService/2010/01")]
    public partial class PurchaseConvertSubscriptionProductItemOutput : CTPTransactionService.PurchaseProductItemOutput
    {
        
        private CTPTransactionService.ServiceInstance[] AddedServiceInstanceSetField;
        
        private int MonthExtendedField;
        
        private System.Nullable<decimal> PotentialRefundAmountField;
        
        private CTPTransactionService.RatingEvent[] RatingEventsField;
        
        private int RemainingDaysinOldSubsField;
        
        private CTPTransactionService.ServiceInstance[] RemovedServiceInstanceSetField;
        
        private System.Nullable<int> RoundBoundaryField;
        
        private CTPTransactionService.SubsTimeExtensionInfo SubsTimeExtensionInfoField;
        
        private System.DateTime SubscriptionEndDateField;
        
        private System.Nullable<System.DateTime> SubscriptionFirstCycleChargeDateField;
        
        private string SubscriptionIdField;
        
        private System.Nullable<decimal> TimeConversionRatioField;
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public CTPTransactionService.ServiceInstance[] AddedServiceInstanceSet
        {
            get
            {
                return this.AddedServiceInstanceSetField;
            }
            set
            {
                this.AddedServiceInstanceSetField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public int MonthExtended
        {
            get
            {
                return this.MonthExtendedField;
            }
            set
            {
                this.MonthExtendedField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public System.Nullable<decimal> PotentialRefundAmount
        {
            get
            {
                return this.PotentialRefundAmountField;
            }
            set
            {
                this.PotentialRefundAmountField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public CTPTransactionService.RatingEvent[] RatingEvents
        {
            get
            {
                return this.RatingEventsField;
            }
            set
            {
                this.RatingEventsField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public int RemainingDaysinOldSubs
        {
            get
            {
                return this.RemainingDaysinOldSubsField;
            }
            set
            {
                this.RemainingDaysinOldSubsField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public CTPTransactionService.ServiceInstance[] RemovedServiceInstanceSet
        {
            get
            {
                return this.RemovedServiceInstanceSetField;
            }
            set
            {
                this.RemovedServiceInstanceSetField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public System.Nullable<int> RoundBoundary
        {
            get
            {
                return this.RoundBoundaryField;
            }
            set
            {
                this.RoundBoundaryField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public CTPTransactionService.SubsTimeExtensionInfo SubsTimeExtensionInfo
        {
            get
            {
                return this.SubsTimeExtensionInfoField;
            }
            set
            {
                this.SubsTimeExtensionInfoField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public System.DateTime SubscriptionEndDate
        {
            get
            {
                return this.SubscriptionEndDateField;
            }
            set
            {
                this.SubscriptionEndDateField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public System.Nullable<System.DateTime> SubscriptionFirstCycleChargeDate
        {
            get
            {
                return this.SubscriptionFirstCycleChargeDateField;
            }
            set
            {
                this.SubscriptionFirstCycleChargeDateField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public string SubscriptionId
        {
            get
            {
                return this.SubscriptionIdField;
            }
            set
            {
                this.SubscriptionIdField = value;
            }
        }
        
        [System.Runtime.Serialization.DataMemberAttribute()]
        public System.Nullable<decimal> TimeConversionRatio
        {
            get
            {
                return this.TimeConversionRatioField;
            }
            set
            {
                this.TimeConversionRatioField = value;
            }
        }
    }
    
    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.ServiceModel", "3.0.0.0")]
    [System.ServiceModel.ServiceContractAttribute(Namespace="urn:schemas.microsoft.com/CommercePlatform/Services/TransactionService/2010/01", ConfigurationName="CTPTransactionService.TransactionService")]
    public interface TransactionService
    {
        
        [System.ServiceModel.OperationContractAttribute(Action="urn:schemas.microsoft.com/CommercePlatform/Services/TransactionService/2010/01/Te" +
            "stConnection", ReplyAction="urn:schemas.microsoft.com/CommercePlatform/Services/TransactionService/2010/01/Tr" +
            "ansactionService/TestConnectionResponse")]
        string TestConnection(string inputString);
        
        [System.ServiceModel.OperationContractAttribute(Action="urn:schemas.microsoft.com/CommercePlatform/Services/TransactionService/2010/01/Pu" +
            "rchase", ReplyAction="urn:schemas.microsoft.com/CommercePlatform/Services/TransactionService/2010/01/Tr" +
            "ansactionService/PurchaseResponse")]
        CTPTransactionService.PurchaseOutput Purchase(CTPTransactionService.PurchaseInput purchaseInput);
        
        [System.ServiceModel.OperationContractAttribute(Action="urn:schemas.microsoft.com/CommercePlatform/Services/TransactionService/2010/01/Pa" +
            "yout", ReplyAction="urn:schemas.microsoft.com/CommercePlatform/Services/TransactionService/2010/01/Tr" +
            "ansactionService/PayoutResponse")]
        CTPTransactionService.PayoutOutput Payout(CTPTransactionService.PayoutInput PayoutInput);
        
        [System.ServiceModel.OperationContractAttribute(Action="urn:schemas.microsoft.com/CommercePlatform/Services/TransactionService/2010/01/Jo" +
            "inSubscription", ReplyAction="urn:schemas.microsoft.com/CommercePlatform/Services/TransactionService/2010/01/Tr" +
            "ansactionService/JoinSubscriptionResponse")]
        CTPTransactionService.JoinSubscriptionOutput JoinSubscription(CTPTransactionService.JoinSubscriptionInput joinSubscriptionInput);
        
        [System.ServiceModel.OperationContractAttribute(Action="urn:schemas.microsoft.com/CommercePlatform/Services/TransactionService/2010/01/Mi" +
            "grateAccount", ReplyAction="urn:schemas.microsoft.com/CommercePlatform/Services/TransactionService/2010/01/Tr" +
            "ansactionService/MigrateAccountResponse")]
        CTPTransactionService.MigrateAccountOutput MigrateAccount(CTPTransactionService.MigrateAccountInput migrateAccountInput);
        
        [System.ServiceModel.OperationContractAttribute(Action="urn:schemas.microsoft.com/CommercePlatform/Services/TransactionService/2010/01/Ge" +
            "tPayoutOrderStatus", ReplyAction="urn:schemas.microsoft.com/CommercePlatform/Services/TransactionService/2010/01/Tr" +
            "ansactionService/GetPayoutOrderStatusResponse")]
        CTPTransactionService.GetPayoutOrderStatusOutput GetPayoutOrderStatus(CTPTransactionService.GetPayoutOrderStatusInput GetPayoutOrderStatusInput);
        
        [System.ServiceModel.OperationContractAttribute(Action="urn:schemas.microsoft.com/CommercePlatform/Services/TransactionService/2010/01/Ge" +
            "tPayoutOrderEventUpdate", ReplyAction="urn:schemas.microsoft.com/CommercePlatform/Services/TransactionService/2010/01/Tr" +
            "ansactionService/GetPayoutOrderEventUpdateResponse")]
        CTPTransactionService.GetPayoutOrderEventUpdateOutput GetPayoutOrderEventUpdate(CTPTransactionService.GetPayoutOrderEventUpdateInput GetPayoutOrderEventUpdateInput);
        
        [System.ServiceModel.OperationContractAttribute(Action="urn:schemas.microsoft.com/CommercePlatform/Services/TransactionService/2010/01/Re" +
            "gisterUser", ReplyAction="urn:schemas.microsoft.com/CommercePlatform/Services/TransactionService/2010/01/Tr" +
            "ansactionService/RegisterUserResponse")]
        CTPTransactionService.RegisterUserOutput RegisterUser(CTPTransactionService.RegisterUserInput registerUserInput);
    }
    
    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.ServiceModel", "3.0.0.0")]
    public interface TransactionServiceChannel : CTPTransactionService.TransactionService, System.ServiceModel.IClientChannel
    {
    }
    
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.ServiceModel", "3.0.0.0")]
    public partial class TransactionServiceClient : System.ServiceModel.ClientBase<CTPTransactionService.TransactionService>, CTPTransactionService.TransactionService
    {
        
        public TransactionServiceClient()
        {
        }
        
        public TransactionServiceClient(string endpointConfigurationName) : 
                base(endpointConfigurationName)
        {
        }
        
        public TransactionServiceClient(string endpointConfigurationName, string remoteAddress) : 
                base(endpointConfigurationName, remoteAddress)
        {
        }
        
        public TransactionServiceClient(string endpointConfigurationName, System.ServiceModel.EndpointAddress remoteAddress) : 
                base(endpointConfigurationName, remoteAddress)
        {
        }
        
        public TransactionServiceClient(System.ServiceModel.Channels.Binding binding, System.ServiceModel.EndpointAddress remoteAddress) : 
                base(binding, remoteAddress)
        {
        }
        
        public string TestConnection(string inputString)
        {
            return base.Channel.TestConnection(inputString);
        }
        
        public CTPTransactionService.PurchaseOutput Purchase(CTPTransactionService.PurchaseInput purchaseInput)
        {
            return base.Channel.Purchase(purchaseInput);
        }
        
        public CTPTransactionService.PayoutOutput Payout(CTPTransactionService.PayoutInput PayoutInput)
        {
            return base.Channel.Payout(PayoutInput);
        }
        
        public CTPTransactionService.JoinSubscriptionOutput JoinSubscription(CTPTransactionService.JoinSubscriptionInput joinSubscriptionInput)
        {
            return base.Channel.JoinSubscription(joinSubscriptionInput);
        }
        
        public CTPTransactionService.MigrateAccountOutput MigrateAccount(CTPTransactionService.MigrateAccountInput migrateAccountInput)
        {
            return base.Channel.MigrateAccount(migrateAccountInput);
        }
        
        public CTPTransactionService.GetPayoutOrderStatusOutput GetPayoutOrderStatus(CTPTransactionService.GetPayoutOrderStatusInput GetPayoutOrderStatusInput)
        {
            return base.Channel.GetPayoutOrderStatus(GetPayoutOrderStatusInput);
        }
        
        public CTPTransactionService.GetPayoutOrderEventUpdateOutput GetPayoutOrderEventUpdate(CTPTransactionService.GetPayoutOrderEventUpdateInput GetPayoutOrderEventUpdateInput)
        {
            return base.Channel.GetPayoutOrderEventUpdate(GetPayoutOrderEventUpdateInput);
        }
        
        public CTPTransactionService.RegisterUserOutput RegisterUser(CTPTransactionService.RegisterUserInput registerUserInput)
        {
            return base.Channel.RegisterUser(registerUserInput);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\marketplace\catalog\CatalogDatabase.cs ===
﻿using System;
using System.Text;
using xonline.common.config;
using xonline.common.service;

namespace xonline.common.marketplace.catalog
{
    public class CatalogDatabase
    {
        // By default the connection string will be empty and be populated when first requested
        private static StringBuilder rawCatalogDBConnectionString;
        
        /// <summary>
        /// Get/Set the db connection string for the Raw catalog.
        /// </summary>
        public static String RawCatalogDBConnectionString
        {
            get
            {
                if (rawCatalogDBConnectionString == null)
                {
                    try
                    {
                        rawCatalogDBConnectionString = new StringBuilder();
                        rawCatalogDBConnectionString.Append("metadata=res://*/RawCatalogDB.csdl|res://*/RawCatalogDB.ssdl|res://*/RawCatalogDB.msl;");
                        rawCatalogDBConnectionString.Append("provider=System.Data.SqlClient;provider connection string=\"MultipleActiveResultSets=true;");
                        rawCatalogDBConnectionString.Append(Config.GetSingleInterface(Interface.ContentIngestionCatalogDB).SqlConnectionString);
                        rawCatalogDBConnectionString.Append("\"");
                    }
                    catch (Exception ex)
                    {
                        throw new ExceptionWithEventId(XEvent.Id.CONTENTINGESTION_ERROR_INTERFACE, string.Format("Error occured querying the contentIngestion Interface.Actual exception string is {0}", ex.ToString()));
                    }
                }//end if
                return rawCatalogDBConnectionString.ToString();
            }//end get
        }//end String RawCatalogDBConnectionString

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\marketplace\billing\CTP\CTPTransactionServiceError.cs ===
//
// BdkError.cs
//
// Copyright (c) Microsoft Corporation. All Rights Reserved.
//

using System;
using System.Collections.Generic;
using System.Net;

using xonline.common.mgmt;
using xonline.common.service;
using XHResult = xonline.common.service.HResult;

namespace xonline.common.billing
{


    public class CTPError
    {

        private static List<uint> nonUserErrors = null;


        public static HResult CTPErrorToXonlineHr(int errorCode)
        {
            CTPError ctpError = new CTPError(errorCode);
            return ctpError.XonlineHResult;

        }

        private static void InitNonUserErrorList()
        {
            //TODO generate this list from NPDB
            nonUserErrors = new List<uint>();
            nonUserErrors.Add(HResult.XONLINE_E_BILLING_CTP_INVALID_PAYMENT);
            nonUserErrors.Add(HResult.XONLINE_E_BILLING_CTP_INVALID_MODE);
            nonUserErrors.Add(HResult.XONLINE_E_BILLING_CTP_RATING_RULES_ERROR);
            nonUserErrors.Add(HResult.XONLINE_E_BILLING_CTP_COMMUNICATION_ERROR);
            nonUserErrors.Add(HResult.XONLINE_E_BILLING_CTP_INVALIDRESPONSE);
            nonUserErrors.Add(HResult.XONLINE_E_BILLING_CTP_INVALID_TRANSACTIONSTATUS);
            nonUserErrors.Add(HResult.XONLINE_E_BILLING_CTP_INVALID_ITEM);
            nonUserErrors.Add(HResult.XONLINE_E_BILLING_CTP_INVALID_CALLINGPARTNER);
            nonUserErrors.Add(HResult.XONLINE_E_BILLING_CTP_INVALID_PAYMENTPROVIDER);
            nonUserErrors.Add(HResult.XONLINE_E_BILLING_INVALID_ARG);

        }

        private HResult xonlineHr;

        private int ctpErrorCode;

        private string message = string.Empty;

        private bool retryable = false;

        public bool IsNonUserError
        {
            get { return nonUserErrors.Contains(this.XonlineHResult); }
        }


        public int CtpErrorCode
        {
            get { return ctpErrorCode; }
        }
        public HResult XonlineHResult
        {
            get { return xonlineHr; }
        }
        public string Message
        {
            get { return message; }
        }
        public bool Retryable
        {
            get { return retryable; }
        }
        public static CTPErrorDetail GetErrorDetail(int CTPErrorCode)
        {
            try
            {
                return _errorDetails[CTPErrorCode];
            }
            catch (KeyNotFoundException)
            {
                return null;
            }
        }
        public CTPError(int CTPErrorCode)
        {
            HResult hr;
            string err = string.Empty;

            CTPErrorDetail ctpError = GetErrorDetail(CTPErrorCode);
            if (ctpError == null)
            {
                hr = XHResult.XONLINE_E_BILLING_UNKNOWN_ERROR;
                err = string.Format("Unrecognized CTP errorCode = ({0}), translating to hr = {1}", CTPErrorCode, hr);
            }
            else
            {
                hr = ctpError.XonHResult;
                err = ctpError.Message;
            }

            // assign the member variables
            this.ctpErrorCode = CTPErrorCode;
            this.xonlineHr = hr;
            this.message = err;
        }


        public const int BDK_E_BAN_NULL_INPUT_PARAMETER = 30100;
        public const int BDK_E_ALREADY_BANNED = 30105;
        public const int BDK_E_NOT_BANNED = 30110;
        public const int BDK_E_BANNEDPERSON = 30140;
        public const int BDK_E_COUNTRY_CURRENCY_PI_MISMATCH = 30145;
        public const int BDK_E_INVALID_PAYMENT_INSTRUMENT_TYPE = 30152;
        public const int BDK_E_INVALID_CREDIT_CARD_TYPE = 30155;
        public const int BDK_E_DECRYPTION_FAILURE = 30160;
        public const int BDK_E_BANNED_PAYMENT_INSTRUMENT = 30150;
        public const int BDK_E_INVALID_DD_ACCOUNT = 30180;
        public const int BDK_E_DD_CONCATENATED_STRING_LENGTH_EXCEEDS_24 = 30185;
        public const int BDK_E_INVALID_CREDIT_CARD_NUMBER = 30000;
        public const int BDK_E_CREDIT_CARD_EXPIRED = 30001;
        public const int BDK_E_AVS_FAILED = 30220;
        public const int BDK_E_NO_AVS_RESULT = 30221;
        public const int BDK_E_AUTHORIZATION_FAILED = 30225;
        public const int BDK_E_PAYMENT_PROVIDER_CONNECTION_FAILED = 30235;
        public const int BDK_E_DD_INVALID_COUNTRY = 30255;
        public const int BDK_E_DD_INVALID_ACCOUNT_FORMAT = 30260;
        public const int BDK_E_DD_INVALID_BANKCODE_FORMAT = 30265;
        public const int BDK_E_DD_INVALID_BRANCHCODE_FORMAT = 30270;
        public const int BDK_E_DD_INVALID_CHECKDIGIT_FORMAT = 30275;
        public const int BDK_E_DD_ACCOUNT_MISSING = 30280;
        public const int BDK_E_DD_BANKCODE_MISSING = 30285;
        public const int BDK_E_DD_BRANCHCODE_MISSING = 30290;
        public const int BDK_E_DD_CHECKDIGIT_MISSING = 30295;
        public const int BDK_E_DD_ERROR_IN_FIELDS = 30300;
        public const int BDK_E_DD_INVALID_ACCOUNT_VALUE = 30305;
        public const int BDK_E_DD_INVALID_BANKCODE_VALUE = 30310;
        public const int BDK_E_DD_INVALID_BRANCHCODE_VALUE = 30315;
        public const int BDK_E_DD_INVALID_CHECKDIGIT_VALUE = 30320;
        public const int BDK_E_DD_INVALID_ACCOUNT_HOLDER_NAME = 30330;
        public const int BDK_E_DD_UNKNOWN_PROVIDER_FAILURE = 30495;
        public const int BDK_E_PAYMENT_PROVIDER_CONNECTION_TIMEOUT = 30335;
        public const int BDK_E_TRANSACTION_DECLINED_BY_PAYMENT_PROVIDER = 30336;
        public const int BDK_E_INVALID_INITIATE_TRANSACTION_RESULT = 30337;
        public const int BDK_E_INVALID_WHOLESALE_PARTNER = 30340;
        public const int BDK_E_PI_NOT_SUPPORTED = 30355;
        public const int BDK_E_UPS_NOT_UPDATED = 30365;
        public const int BDK_E_DD_UNSUPPORTED = 30370;
        public const int BDK_E_DD_MPF_NON_XML_RESPONSE = 30375;
        public const int BDK_E_DD_MPF_INCORRECT_XML_FORMAT = 30380;
        public const int BDK_E_DD_GC_NON_XML_RESPONSE = 30385;
        public const int BDK_E_DD_GC_INCORRECT_XML_FORMAT = 30390;
        public const int BDK_E_DD_GC_RETURNED_NOK_RESULT = 30395;
        public const int BDK_E_DD_GC_CHECK_INCOMPLETE = 30400;
        public const int BDK_E_DD_OPENING_GC_XML_CHECKSPERFORMED = 30405;
        public const int BDK_E_DD_GC_XML_INVALID_CHECK_RESULT = 30410;
        public const int BDK_E_DD_GC_INVALID_RFBANKCODE = 30415;
        public const int BDK_E_INVALID_PAYMENT_INSTRUMENT_DETAILS = 30425;
        public const int BDK_E_INVALID_BAN_REASON_CODE = 30430;
        public const int BDK_E_INVALID_CVM_CODE = 30435;
        public const int BDK_E_UNEXPECTED_CVM_RESPONSE_CODE = 30440;
        public const int BDK_E_CVM_FAILED = 30445;
        public const int BDK_E_IMMEDIATE_SETTLEMENT_FAILURE = 30446;
        public const int BDK_E_FREQUENCY_CHECK_FAILED = 30450;
        public const int BDK_E_DD_INVALID_MERCHANT_INDEX = 30455;
        public const int BDK_E_DD_DUPLICATE_MRN = 30460;
        public const int BDK_E_DD_UNKNOWN_VALIDATION_FAILURE = 30465;
        public const int BDK_ERROR_DD_BANK_ACCOUNT_TYPE_MUST_BE_NULL = 30470;
        public const int BDK_ERROR_DD_BANK_ACCOUNT_TYPE_MAY_NOT_BE_NULL = 30475;
        public const int BDK_E_DD_RISK_DECLINE = 30485;
        public const int BDK_E_UNABLE_TO_VALIDATE_TAX_ID = 30500;
        public const int BDK_E_TAX_ID_UPDATE_ATTEMPTS_EXCEEDED = 30505;
        public const int BDK_E_EXTERNAL_VENDOR_ERROR = 30510;
        public const int BDK_E_ALREADY_IN_SPECIFIED_STATE = 40001;
        public const int BDK_E_MISSING_SEARCH_CRITERIA = 40004;
        public const int BDK_E_REQUIRED_FIELD_MISSING = 40005;
        public const int BDK_E_ACTIVE_SUBSCRIPTIONS = 40006;
        public const int BDK_E_UNEXPECTED_FIELD = 40007;
        public const int BDK_E_INVALID_ACCOUNT_SOUCE = 40013;
        public const int BDK_E_INVALID_CREATION_DATE = 40014;
        public const int BDK_E_EXCEEDING_TAX_EXEMPT_LIMITS = 40021;
        public const int BDK_E_GENERATE_NEXT_ID = 40025;
        public const int BDK_E_INVALID_STATE_FOR_COUNTRY = 40031;
        public const int BDK_E_ADDRESS_COUNTRY_ACCOUNT_MISMATCH = 40033;
        public const int BDK_E_OFFERING_COUNTRY_ACCOUNT_MISMATCH = 40034;
        public const int BDK_E_INVALID_BILLABLE_ACCOUNT_ID = 40130;
        public const int BDK_E_INVALID_BILLABLE_ACCOUNT_STATUS_ID = 40135;
        public const int BDK_E_INVALID_PHONE_TYPE = 40150;
        public const int BDK_E_INVALID_OFFERING_ID = 40165;
        public const int BDK_E_INVALID_PURCHASE_INPUT_DATA = 40166;
        public const int BDK_E_PUID_MISSING_ATTRIBUTE = 40167;
        public const int BDK_E_INVALID_COUNTRY_CODE = 40170;
        public const int BDK_E_INVALID_ADDRESS_ID = 40175;
        public const int BDK_E_INVALID_PAYMENT_METHOD_ID = 40185;
        public const int BDK_E_PI_EXECEED_MAX_OWNER_SHIP = 40195;
        public const int BDK_E_SUBSCRIPTION_ALREADY_CANCELED = 40200;
        public const int BDK_E_DELAYED_EXPIRE_ALREADY_PENDING = 40202;
        public const int BDK_E_DELAYED_EXPIRE_NOT_PENDING = 40203;
        public const int BDK_E_DELAYED_EXPIRE_NOT_SUPPORTED = 40204;
        public const int BDK_E_INVALID_CANCEL_DATE = 40201;
        public const int BDK_E_INVALID_SUBSCRIPTION_ID = 40205;
        public const int BDK_E_INVALID_PERIOD_TO_PROCESS = 40235;
        public const int BDK_E_INVALID_SUBSCRIPTION_STATUS = 40250;
        public const int BDK_E_NON_ACTIVE_ACCOUNT = 40340;
        public const int BDK_E_VATID_DOESNOTHAVEEXPDATE = 40341;
        public const int BDK_E_TAXID_EXPDATE = 40342;
        public const int BDK_E_INVALID_TAX_EXEMPT_TYPE = 40343;
        public const int BDK_E_INVALID_TAX_EXEMPT_BILLABLE_ACCOUNT_ID = 40344;
        public const int BDK_E_NO_ACTIVE_SUBSCRIPTION = 40345;
        public const int BDK_E_INVALID_SERVICE_INSTANCE = 40350;
        public const int BDK_E_ADD_USER_TO_SERVICE_INSTANCE = 40355;
        public const int BDK_E_INVALID_BILLABLEACCTSTATUS = 40360;
        public const int BDK_E_SERVICE_INSTANCES_NONE = 40380;
        public const int BDK_E_ACCOUNT_CLOSED = 40401;
        public const int BDK_E_BILLINGPERIOD_PAST = 40406;
        public const int BDK_E_INVALID_ADJUSTMENTGUID = 40407;
        public const int BDK_E_INVALID_ADJUSMENT_FOR_PERIOD = 40408;
        public const int BDK_E_ADJUSTMENT_TOOBIG = 40409;
        public const int BDK_E_ADJUSTMENT_TOOSMALL = 40411;
        public const int BDK_E_INVALID_LOCALE = 40421;
        public const int BDK_E_INVALID_CUSTOMER_TYPE = 40422;
        public const int BDK_E_INVALID_CURRENCY = 40423;
        public const int BDK_E_DATE_EXPIRED = 40424;
        public const int BDK_E_GUID_EXISTS = 40425;
        public const int BDK_E_INVALID_VIOLATION_ID = 40428;
        public const int BDK_E_MISSING_VIOLATION_ID = 40429;
        public const int BDK_E_NEEDTODEPROVISION = 40431;
        public const int BDK_E_PARTIALCONV_INITIATED = 40432;
        public const int BDK_E_CANNOT_UPDATE_CURRENCY = 40433;
        public const int BDK_E_PARTIALCONV_EXPECTED = 40434;
        public const int BDK_E_INVALID_CATEGORY_NAME = 40435;
        public const int BDK_E_OFFERING_NOT_PURCHASEABLE = 40437;
        public const int BDK_E_OFFERING_ACCOUNT_CURRENCY_MISMATCH = 40438;
        public const int BDK_E_OFFERING_PAYMENT_INSTRUMENT_MISMATCH = 40439;
        public const int BDK_E_INVALID_DATE = 40440;
        public const int BDK_E_CANNOT_EXCEED_MAX_OWNERSHIP = 40441;
        public const int BDK_E_INVALID_RESOURCE_ID = 40450;
        public const int BDK_E_UNIT_OF_MEASURE_MISMATCH = 40451;
        public const int BDK_E_EVT_DATE_BEFORE_PURCHASE_DATE = 40452;
        public const int BDK_E_INVALID_OFFERING_FOR_LOCALE = 40453;
        public const int BDK_E_NOT_A_BASE_OFFERING = 40454;
        public const int BDK_E_FUTURE_OFFERING_PAYMENT_INSTRUMENT_MISMATCH = 40456;
        public const int BDK_E_INVALID_OFFERING_FOR_COUNTRY = 40457;
        public const int BDK_E_MEG_CONFLICT = 40458;
        public const int BDK_E_INVALID_ACCOUNT_STATUS = 40470;
        public const int BDK_E_ACTIVE_SUBSCRIPTIONS_EXIST = 40475;
        public const int BDK_E_EXISTING_BILLING_ACTIVITY = 40476;
        public const int BDK_E_INVALID_SUBSCRIPTION_STATUS_FOR_OPERATION = 40480;
        public const int BDK_E_PRIMARY_PHONE_REQUIRED = 40485;
        public const int BDK_E_EMAIL_REQUIRED = 40490;
        public const int BDK_E_ACCOUNT_NOT_CLOSED = 40491;
        public const int BDK_E_INVALID_VIOLATION = 40467;
        public const int BDK_E_SUBSCRIPTION_IS_CANCELLED = 40468;
        public const int BDK_E_NO_VIOLATION = 40469;
        public const int BDK_E_EXISTS_VIOLATION = 40471;
        public const int BDK_E_INVALID_SERVICE_COMPONENT_ID = 40498;
        public const int BDK_E_END_DATE_IN_THE_PAST = 40499;
        public const int BDK_E_END_DATE_BEYOND_MAX = 40500;
        public const int BDK_E_VIOLATION_ALREADY_SET = 40510;
        public const int BDK_E_NO_VIOLATION_SET = 40515;
        public const int BDK_E_INVALID_CONVERSION = 40525;
        public const int BDK_E_SUBS_NOT_INTERMEDIATE = 40526;
        public const int BDK_E_OFFERING_NOT_PUBLISHED = 40530;
        public const int BDK_E_CONVERSION_NEEDTODEPROVISION = 40531;
        public const int BDK_E_INVALID_MANDATE_STATUS = 40535;
        public const int BDK_E_PI_ALREADY_GOOD = 40545;
        public const int BDK_E_PI_ALREADY_DECLINED = 40550;
        public const int BDK_E_PI_IS_DISABLED = 40555;
        public const int BDK_E_INVOICEPI_SAP_NUMBER_REQUIRED = 40560;
        public const int BDK_E_INVALID_INVOICE_INFO_XML = 40561;
        public const int BDK_E_MAX_PI_PER_ACCOUNT_REACHED = 44417;
        public const int BDK_E_PI_ACCOUNT_COUNTRY_MISMATCH = 40567;
        public const int BDK_E_ERROR_OCCURRED_TRY_LATER = 40568;
        public const int BDK_E_ERROR_OCCURRED = 40569;
        public const int BDK_E_INVALID_PAYMENT_INSTRUMENT_STATUS = 40575;
        public const int BDK_E_INVALID_OFFERING_GUID = 40580;
        public const int BDK_E_OFFERING_REQUIRES_PI = 40585;
        public const int BDK_E_DELAYED_PROVISIONING_COMPONENTS_EXIST = 40595;
        public const int BDK_E_INVALID_AMOUNT_FOR_CURRENCY = 40601;
        public const int BDK_E_INVALID_EMAIL_ADDRESS = 40610;
        public const int BDK_E_INVALID_TAX_EXEMPT_STATUS = 40620;
        public const int BDK_E_NO_VALID_TAX_EXEMPTION = 40621;
        public const int BDK_E_INVALID_TAX_EXEMPT_STATUS_CHANGE = 40625;
        public const int BDK_E_INVALID_OLD_PAYMENT_INSTRUMENT_STATUS = 40630;
        public const int BDK_E_INVALID_START_PERIOD = 40644;
        public const int BDK_E_INVALID_END_PERIOD = 40645;
        public const int BDK_E_INVALID_DETAILEDLEVEL = 40646;
        public const int BDK_E_EXCEED_DATERANGE_LIMIT = 40647;
        public const int BDK_E_WRONG_DATERANGE = 40648;
        public const int BDK_E_INVALID_BEGIN_DATE = 40649;
        public const int BDK_E_INVALID_END_DATE = 40651;
        public const int BDK_E_END_DATE_GREATER_THAN_CURRENT_DATE = 40652;
        public const int BDK_E_COMPUTE_ONLY = 40650;
        public const int BDK_E_MISSED_PROCESSING_PERIOD = 40755;
        public const int BDK_E_SUBSCRIPTION_NOT_EXPIRED = 40771;
        public const int BDK_E_TOOLATE_REINSTATE = 40772;
        public const int BDK_E_EXTRA_REFERRAL_DATA = 40775;
        public const int BDK_E_NO_REFERRAL_UPDATES_ALLOWED = 40780;
        public const int BDK_E_FREE_SCHEDULED_RENEWAL_EXISTS = 40781;
        public const int BDK_E_DEAL_HAS_MULTIPLE_DELAYED_COMPONENTS = 40782;
        public const int BDK_E_INVALID_COBRAND = 40790;
        public const int BDK_E_INVALID_OPERATION_FOR_WHOLESALE_SUBSCRIPTION = 40805;
        public const int BDK_E_HCI_NOT_VALID = 40835;
        public const int BDK_E_CANT_STOP_TAIWAN_TAXINV = 40837;
        public const int BDK_E_RESOURCE_BALANCE_CHANGE_ON_NONACTIVE_SUBS = 40885;
        public const int BDK_E_INVALID_TOKEN_TYPE = 40970;
        public const int BDK_E_TOKEN_NOT_VALID_FOR_OFFERING = 41035;
        public const int BDK_E_DEAL_TOKEN_MAPPING_NOT_PRESENT = 41036;
        public const int BDK_E_MAXIMUM_CONSUMPTION_COUNT_PER_USER_REACHED = 40971;
        public const int BDK_E_INSERTING_USER_TOKEN_HASH = 40972;
        public const int BDK_E_TOKEN_AND_PI_BOTH_SPECIFIED = 41070;
        public const int BDK_E_TOKEN_CLASS_INVALID = 41075;
        public const int BDK_E_INPUT_FILTER_XML_MISSING = 41076;
        public const int BDK_E_TOKEN_CLASS_NOT_FOUND = 5035;
        public const int BDK_E_INVALID_INPUT_FILTER_XML = 41077;
        public const int BDK_E_PI_CANNOT_BE_SPECIFIED = 41080;
        public const int BDK_E_SUBSCRIPTION_NOT_PREPAID = 41085;
        public const int BDK_E_TOTAL_EXTENSION_LESS_THAN_ZERO = 41090;
        public const int BDK_E_INVALID_NUMBER_OF_DAYS = 41095;
        public const int BDK_E_INVALID_NUMBER_OF_MONTHS = 41096;
        public const int BDK_E_TOTAL_EXTENSION_GREATER_THAN_MAX = 41100;
        public const int BDK_E_PREPAID_TOKEN_IS_REQUIRED = 41110;
        public const int BDK_E_TERM_COMMIT_EXISTS = 41115;
        public const int BDK_E_TOKEN_NOT_APPLICABLE = 41120;
        public const int BDK_E_TOKEN_RENEWAL_PRESENT = 41125;
        public const int BDK_E_EXCEEDS_MAXIMUM_DURATION = 41210;
        public const int BDK_E_CONVERSION_CREDITS_NOT_ENABLED = 41220;
        public const int BDK_E_INVALID_USERROLE_FOR_ADDPI = 41230;
        public const int BDK_E_NOT_AUTHORIZED_TAX_RULE_CONFIG_GROUP = 41300;
        public const int BDK_E_BLACKLIST_ACTION_NOT_PERFORMED = 41130;
        public const int BDK_E_INVALID_SUBSCRIPTION_ACTION = 41135;
        public const int BDK_E_TOKEN_DISTRIBUTION_CHANNEL_NOT_FOUND = 41145;
        public const int BDK_E_INVALID_LEN_PART_NUMBER = 41150;
        public const int BDK_E_INVALID_LEN_SAP_CUST_NAME = 41155;
        public const int BDK_E_INVALID_LEN_SUPPORT_VENDOR_NAME = 41160;
        public const int BDK_E_INSERING_TOKEN_CLASS_PARTNER = 41165;
        public const int BDK_E_TOKEN_PART_NUMBER_ASSOC_WITH_OTHER_TOKEN_CLASS = 41170;
        public const int BDK_E_TOKEN_ALREADY_DELIVERED = 5261;
        public const int BDK_E_TOKEN_DISTRIBUTION_BATCH_INVALID = 40410;
        public const int BDK_E_TOKEN_DISTRIBUTION_BATCH_INACTIVE = 40415;
        public const int BDK_E_DISTRIBUTION_PROGRAM_INACTIVE = 40426;
        public const int BDK_E_INSERTING_RECONCILE_HISTORY = 5310;
        public const int BDK_E_TOKEN_ALREADY_ISSUED = 5315;
        public const int BDK_E_TOKEN_ALREADY_UNISSUED = 5320;
        public const int BDK_E_TOKEN_ISSUE_UPDATE = 5325;
        public const int BDK_E_INVALID_COMBINATION = 5330;
        public const int BDK_E_INVALID_REPLACEMENT_REASON_CODE = 5335;
        public const int BDK_E_MAX_REPLACEMENT_REACHED = 5340;
        public const int BDK_E_TOKEN_REPLACEMENT_FAILED = 5345;
        public const int BDK_E_TOKEN_DISTRIBUTION_STATUS_UPDATE = 5350;
        public const int BDK_E_SIGNATURE_TOKEN_MISMATCH = 5355;
        public const int BDK_E_INVALID_STATUS_NAME = 5360;
        public const int BDK_E_INVALID_TOKEN_DISTRIBUTION_STATUS = 5365;
        public const int BDK_E_ALREADY_REPLACED_TOKEN = 5370;
        public const int BDK_E_TOKEN_ACTION_ACCESS_DENIED = 5375;
        public const int BDK_E_NOT_EXISTS_PARTNER = 5510;
        public const int BDK_E_DUPLICATED_PKPN_WITH_PCT = 5520;
        public const int BDK_E_NOT_EXISTS_PKPN = 5530;
        public const int BDK_E_RESELLER_TOKEN_BLACKLISTED = 5540;
        public const int BDK_E_RESELLER_TOKEN_CONSUMED = 5550;
        public const int BDK_E_SERVER_INTERNAL_ERROR = 5560;
        public const int BDK_E_DUPLICATED_CHANNELSKU_WITH_PCT = 5570;
        public const int BDK_E_CHANNELSKU_PKPN_PERCENTAGE_CANNOT_UPDATE = 5580;
        public const int BKE_E_CHANNELSKU_PKPN_MAPPING_CANNOT_ADD = 5590;
        public const int BDK_E_INVALID_PKPN_ALLOCATION = 5600;
        public const int BDK_E_EXCEEDS_MAX_TOKEN_INSTANCE = 5650;
        public const int BDK_E_BAD_RETURN_STATEMENT_SET_INDICATOR = 42500;
        public const int BDK_E_BAD_BEGIN_BILLING_PERIOD = 42505;
        public const int BDK_E_INVALID_END_BILLING_PERIOD = 42510;
        public const int BDK_E_BILLING_PERIOD_NEGATIVE = 42515;
        public const int BDK_E_BAD_START_END_BILLING_PERIOD = 42520;
        public const int BDK_E_CURRENT_DATE_LESS_THAN_ACCOUNT_HISTORY_DATE = 42525;
        public const int BDK_E_NO_NON_NULL_PARAMS = 42530;
        public const int BDK_E_INVALID_SUBSCRIPTION_BILLING_PERIOD = 42535;
        public const int BDK_E_BILLING_PERIOD_GREATER_THAN_SUBSCRIPTION_DURATION = 42540;
        public const int BDK_E_MISMATCH_SUB_ID_OFFER_GUID = 42750;
        public const int BDK_E_EVENT_TIMESTAMP_IN_THE_FUTURE = 42765;
        public const int BDK_E_INVALID_POLICY_ID = 40840;
        public const int BDK_E_OFFERING_PI_COUNTRY_MISMATCH = 40841;
        public const int BDK_E_INSERT_AGREEMENT_SIGNATURE = 40845;
        public const int BDK_E_AGREEMENT_ALREADY_SIGNED = 40850;
        public const int BDK_E_LOCALE_NOT_SUPPORTED_FOR_POLICY = 40860;
        public const int BDK_E_POLICY_DEAL_VERSION_MISMATCH = 40862;
        public const int BDK_E_POLICY_DEAL_COUNTRY_MISMATCH = 40865;
        public const int BDK_E_CANNOT_CONVERT_BACK_TO_WHOLESALE = 42705;
        public const int BDK_E_CANNOT_SPECIFY_PI_DURING_RENEW = 42710;
        public const int BDK_E_NO_RENEWAL_FROM_PERPETUAL_OFFERING = 42725;
        public const int BDK_E_INVALID_TECERTIFICATENUMBER = 42730;
        public const int BDK_E_NO_WHOLESALE_TO_WHOLESALE = 42760;
        public const int BDK_E_INVALID_NEW_PAYMENT_INSTRUMENT_STATUS = 42770;
        public const int BDK_E_INVALID_RENEWAL = 42780;
        public const int BDK_E_ERROR_PHONE_STRING_TOOLONG = 42785;
        public const int BDK_E_ERROR_TOKEN_CLASS_ACCESS_DENIED = 42795;
        public const int BDK_E_LAST_ADMIN_ROLE = 50115;
        public const int BDK_E_PUID_USED_AS_BILLABLEACCOUNTADMIN = 50116;
        public const int BDK_E_UPDATING_MEMBERNAME = 50120;
        public const int BDK_E_OBJECT_ROLE_LIMIT_EXCEEDED = 50125;
        public const int BDK_E_ACCOUNT_DELADMIN_ROLE_EXCEEDED = 50126;
        public const int PROVISION_E_MALFORMED_REQUEST = 43901;
        public const int PROVISION_E_WRONG_INPUT_PARAMETERS = 43902;
        public const int PROVISION_E_MPF_CALL_FAILED = 43903;
        public const int PROVISION_E_XML_OPERATION_ERROR = 43904;
        public const int PROVISION_E_MPF_CREATE = 43905;
        public const int PROVISION_E_CREATION = 43906;
        public const int BDK_E_EXCEEDS_MAX_NUMBER_OF_SERVICE_INSTANCE_REQUESTS = 43938;
        public const int BDK_E_DBBADZIP = 43939;
        public const int BDK_E_REQUIRED_FIELD_MISSING_DUE_TO_SUBSCRIPTIONS = 43940;
        public const int BDK_E_ADDITIONAL_ACCOUNT_DATA_REQUIRED = 43941;
        public const int BDK_E_ACCT_ALREADY_REFERRED = 43982;
        public const int BDK_E_REWARD_OFFER_NOT_PURCHASABLE = 43994;
        public const int BDK_E_AGREEMENT_NOT_SIGNED = 44153;
        public const int BDK_E_ITEM_VIOLATION_EXISTS = 44154;
        public const int BDK_E_DYNAMIC_TITLE_AND_CATEGORY_CONFIGURATION = 44155;
        public const int BDK_E_PENDING_TRANSACTION = 44156;
        public const int BDK_E_INCREMENT_TOTAL = 20025;
        public const int BDK_E_RES_NOT_BELONG_TO_OBJECT = 20055;
        public const int BDK_E_DECLINING_BALANCE = 20060;
        public const int BDK_E_DUPLICATE_TRACKING_GUID = 20085;
        public const int BDK_E_INVALID_EXPIRATION_DATE = 20135;
        public const int BDK_E_UNKNOWN_MANDATE_STATUS = 20140;
        public const int BDK_E_INVALID_PAYMENT_METHOD_TYPE = 20146;
        public const int BDK_E_INVALID_CURRENCY2 = 20160;
        public const int BDK_E_INVALID_AMOUNT = 20220;
        public const int BDK_E_INVALID_BILLING_PERIOD = 20290;
        public const int BDK_E_INVALID_ANNIV = 20380;
        public const int BDK_E_INVALID_LINEITEM_ID = 20470;
        public const int BDK_E_INVALID_LINEITEM_STATUS = 20475;
        public const int BDK_E_INVALID_EVENT_TYPE = 20510;
        public const int BDK_E_LINE_ITEM_ID_NOT_OPEN = 20550;
        public const int BDK_E_LINEITEM_ALREADY_OFFSET = 20555;
        public const int BDK_E_LINEITEM_ALREADY_CHARGED_BACK = 20557;
        public const int BDK_E_INVALID_OFFSET_AMOUNT = 20560;
        public const int BDK_E_CANNOT_OFFSET_HARD_SOFT_DECLINED = 20565;
        public const int BDK_E_LINEITEM_ALREADY_CROSS_TRANSFERED = 20567;
        public const int BDK_E_AMOUNT_NOT_COLLECTED_YET = 20570;
        public const int BDK_E_CANNOT_OFFSET_ZERO_AMOUNT = 20575;
        public const int BDK_E_AMOUNT_IN_PROCESS = 20580;
        public const int BDK_E_INVALID_CREDIT_AMOUNT = 20610;
        public const int BDK_E_CREDIT_AMOUNT_OVER_LIMIT = 20611;
        public const int BDK_E_INVALID_AMOUNT_FOR_CURRENCY_2 = 20612;
        public const int BDK_E_DUPLICATE_EVENT_ID = 20625;
        public const int BDK_E_OFFSET_IMM_SETTLE_IN_PROG = 20635;
        public const int BDK_E_SA_IN_STATE_UNOFFSETABLE = 20645;
        public const int BDK_E_SA_IN_STATE_UNESCHEATABLE = 20646;
        public const int BDK_E_OFFSET_AMOUNT_GREATER_THAN_ORIGINAL = 20650;
        public const int BDK_E_RES_BALANCE_CHANGE_ON_NONACTIVE_SUBS = 20655;
        public const int BDK_E_PI_IN_DECLINE = 20680;
        public const int BDK_E_SA_IN_INTERMEDIATE_STATUS = 20945;
        public const int BDK_E_INVALID_SETTLEMENT_AMOUNT_ID = 20950;
        public const int BDK_E_MISMATCH_RATED_USAGE_TOTAL = 20965;
        public const int BDK_E_BAD_RETURN_STATEMENT_SET_INDICATOR2 = 20925;
        public const int BDK_E_ARITHMETIC_OVERFLOW_FOR_ADD_OR_UPDATE_USAGE = 20970;
        public const int BDK_E_REFUND_LINEITEM_NOT_SETTLED = 21015;
        public const int BDK_E_RESOURCE_BALANCE_INACTIVE = 21030;
        public const int BDK_E_INVALID_NUMBER_OF_UNITS = 21045;
        public const int BDK_E_INVALID_USAGE_CATEGORY = 21050;
        public const int BDK_E_INSUFFICIENT_PREPAID_BALANCE = 21055;
        public const int BDK_E_INVALID_FINANCIAL_REASON_CODE = 21090;
        public const int BDK_E_OFFSET_OF_OFFSET_NOT_PERMITTED = 21095;
        public const int BDK_E_DONOTSHOWOFFSET_MISMATCHED_AMOUNT = 21110;
        public const int BDK_E_INVALID_FIN_REASON_CODE_FOR_OFFSET = 21115;
        public const int BDK_E_EVENT_ACTION_NOT_OFFSETTABLE = 21120;
        public const int BDK_E_IMMEDIATE_SETTLE_OF_USAGE_NOT_PERMITTED = 21125;
        public const int BDK_E_RESOURCE_OFFSET_ONLY_ALLOWED_FOR_USAGE = 21130;
        public const int BDK_E_ERROR_PP_INVALID_TAX_REFUND_CODE = 21165;
        public const int BDK_E_DUPLICATE_TRANSACTION_CONFIRMATION_NUMBER = 22010;
        public const int BDK_E_TRANSACTION_NOT_EXIST = 22025;
        public const int BDK_E_INVALID_CUMULATIVE_AMOUNT = 22035;
        public const int BDK_E_TRANSACTION_EVENT_UNKNOWN = 22040;
        public const int BDK_E_TRANSACTION_EVENT_INCONSISTENT = 22045;
        public const int BDK_E_INVALID_SEQUENCE_NUMBER = 22050;
        public const int BDK_E_INVALID_VENDOR_TRANSACTION_ID = 22055;
        public const int BDK_E_INVALID_REJECTION_REASON_CODE = 22060;
        public const int BDK_E_INVALID_TRANSACTION_STATUS = 22105;
        public const int BDK_E_INVALID_CUMULATIVE_TAX_AMOUNT = 22125;
        public const int BDK_E_UNKNOWN_MERCHANT_ID = 22135;
        public const int BDK_E_TRANSACTION_ALREADY_CANCELLED = 22140;
        public const int BDK_E_PMN_INSERT_FAILURE = 25020;
        public const int BDK_E_BADSAMECARDUSEDMULTIPLETIMES = 25040;
        public const int BDK_E_PI_ALREADY_ON_ACCOUNT = 25055;
        public const int BDK_E_PUID_ROLE_LIMIT_EXCEEDED = 25060;
        public const int BDK_E_TOOMANY_FDE_PURCHASES = 25061;
        public const int BDK_E_TAX_ID_ASSOCIATION_LIMIT_EXCEEDED = 25100;
        public const int BDK_E_NOPERMISSION = 10001;
        public const int BDK_E_CANNOT_REMOVE_SELF = 10002;
        public const int BDK_E_BADXML = 10003;
        public const int BDK_E_INVALIDCOMMENTSIZE = 10004;
        public const int BDK_E_BADCANCELMODE = 10005;
        public const int BDK_E_INVALID_BUF_SIZE = 10006;
        public const int BDK_E_INVALID_ROLE = 10007;
        public const int BDK_E_INVALID_PPORT_ID = 10008;
        public const int BDK_E_INVALID_ARG = 10010;
        public const int BDK_E_UNKNOWN_SERVER_FAILURE = 10015;
        public const int BDK_E_INVALID_STATUS_VALUE = 10016;
        public const int BDK_E_INVALID_FILTER = 10017;
        public const int BDK_E_MISSING_CATEGORY = 10018;
        public const int BDK_E_FIELD_TOO_SHORT = 10019;
        public const int BDK_E_FIELD_TOO_LONG = 10020;
        public const int BDK_E_BADZIP = 10021;
        public const int BDK_E_ONLYONENODE = 10022;
        public const int BDK_E_INVALID_FIELD_LENGTH = 10023;
        public const int BDK_E_CSR_AUTHZ_FAILED = 10024;
        public const int BDK_E_NOT_ACCOUNT_ADMIN = 10025;
        public const int BDK_E_DELEGATE_ID_UNSPECIFIED = 10026;
        public const int BDK_E_REQUESTER_ID_UNSPECIFIED = 10027;
        public const int BDK_E_INVALID_FLAG_VALUE = 10028;
        public const int BDK_E_PROVISIONING_INACTIVE_SUBSCRIPTION = 10029;
        public const int BDK_E_INVALID_OBJECT_ID = 10030;
        public const int BDK_E_INVALID_FIRSTNAME_FIELD_LENGTH = 10031;
        public const int BDK_E_INVALID_LASTNAME_FIELD_LENGTH = 10032;
        public const int BDK_E_INVALID_ADDRESS_FIELD_LENGTH = 10033;
        public const int BDK_E_PARTNERNOTINBILLING = 10040;
        public const int BDK_E_RATING_FAILURE = 10045;
        public const int BDK_SVR2_STARTED = 10050;
        public const int BDK_CSR_API_CALL_MADE = 10051;
        public const int BDK_E_CSR_CALL_FROM_NONCSR = 10052;
        public const int BDK_E_TRANS_BALANCE_MISMATCHING_ACCTS = 10060;
        public const int BDK_E_TRANS_BALANCE_TO_PI_INVALID = 10065;
        public const int BDK_E_TRANS_BALANCE_TO_SAME_PI = 10070;
        public const int BDK_E_TRANS_BALANCE_NOT_ALLOW = 10075;
        public const int BDK_E_INTERNAL_ERROR = 10080;
        public const int BDK_E_OUTSTANDING_BALANCE = 10085;
        public const int BDK_E_INVALID_REFERRALDATA_XML = 10090;
        public const int BDK_E_INVALID_GUID = 10095;
        public const int E_UNSUPPORTED_PAYMENT_INSTRUMENT = 10100;
        public const int BDK_E_SUBSCRIPTION_INACTIVE = 10105;
        public const int BDK_E_INVALID_PM_FOR_STOP_PAYMENTS = 10110;
        public const int BDK_E_EXCEEDS_MAX_NUMBER_OF_USAGE_EVENTS = 10115;
        public const int BDK_E_FIELD_NOT_UPDATEABLE = 10120;
        public const int BDK_E_DEFERRED_COMPUTE_ONLY_NOT_SUPPORTED = 10125;
        public const int BDK_E_SETTLE_SHOULD_BE_THE_LAST_EVENT = 10126;
        public const int BDK_E_PAYMENT_METHOD_NO_LONGER_VALID = 10127;
        public const int BDK_E_PROCESS_USAGE_EVENTS = 10128;
        public const int BDK_E_WRONG_OBJECT_ID_TYPE = 10129;
        public const int BDK_E_INVALID_PHONE_VALUE = 10130;
        public const int BDK_E_INVALID_AMOUNT_VALUE = 10135;
        public const int BDK_E_MISMATCH_ACCTID_IN_CLOSEBALANCE = 10131;
        public const int BDK_E_INTERNAL_ADD_COMMENT_FAILED = 10132;
        public const int BDK_E_INVALID_IMMEDIATE_SETTLE_VALUE = 10133;
        public const int BDK_E_NO_RECORDS_FOR_STOP_PAYMENTS = 10140;
        public const int BDK_E_FAILED_SETTLEMENT_AMOUNT_UPDATE = 10150;
        public const int BDK_E_INVALID_TELENUMERIC_STRING = 10160;
        public const int BDK_E_NO_MATCH = 10170;
        public const int BDK_E_MULTIPLE_MATCHES = 10180;
        public const int BDK_E_BAD_PUID = 10190;
        public const int BDK_E_BAD_OBJECT_ID_LENGTH = 10201;
        public const int BDK_E_END_PERIOD_LESS_THAN_START_PERIOD = 10202;
        public const int BDK_E_BAD_BILLING_PERIOD_LENGTH = 10203;
        public const int BDK_E_BAD_RETURN_STATEMENT_SET = 10204;
        public const int BDK_E_INVALID_USAGE_EVENT_DATE = 10207;
        public const int BDK_E_NULL_DEFAULT_BILLING_PERIOD = 10208;
        public const int BDK_E_BAD_START_BILLING_PERIOD = 10209;
        public const int BDK_E_BAD_END_BILLING_PERIOD = 10210;
        public const int BDK_E_NEW_DUE_DATE_IS_PAST = 10215;
        public const int BDK_E_NEW_DUE_DATE_THRESHOLD_PASSED = 10220;
        public const int BDK_E_NO_NEW_DUE_DATE_SPECIFIED = 10225;
        public const int BDK_E_INVALID_TRANSACTION_TYPE = 10230;
        public const int BDK_E_INVALID_REASON_CODE = 10235;
        public const int BDK_E_GROUP_SID_INITIALIZATION_FAILED = 10251;
        public const int BDK_E_INVALID_OPERATION_FOR_WHOLESALE_PI = 10252;
        public const int BDK_E_INVALID_OPERATION_FOR_DIRECT_DEBIT = 10253;
        public const int BDK_E_EXCEEDS_RESOURCE_CREDIT_LIMIT = 10254;
        public const int BDK_E_ADJUST_RESOURCE_BALANCE_FOR_NONACTIVE_SUBS = 10255;
        public const int BDK_E_FAILED_TO_CREATE_MAIL_RECORD = 10256;
        public const int BDK_E_MSNIA_LATE_USAGE = 10257;
        public const int BDK_E_FAILED_TO_WRITE_TO_AUDIT_DB = 10258;
        public const int BDK_E_INVALID_REFERRAL_OFFER = 43980;
        public const int BDK_E_REWARD_REFERRAL_XML_REQUIRED = 10259;
        public const int BDK_E_REFERRER_NOT_IN_SYSTEM = 10260;
        public const int BDK_E_REFERRER_EXCEEDED_MAX_REFERRALS_ON_OFFER = 10261;
        public const int BDK_E_REFERRER_NOT_ACTIVE = 10262;
        public const int BDK_E_CANNOT_REFER_SELF = 10263;
        public const int BDK_E_OFFER_NOT_CONFIGURED_FOR_REFERRAL = 10264;
        public const int BDK_E_INVALID_REWARD_REFFERAL_SCHEMA = 10265;
        public const int BDK_E_REFERRER_NOT_ELIGIBLE_FOR_REWARD_OFFER = 10266;
        public const int BDK_E_SETTLE_BALANCE_INVALID_MANDATE_STATUS = 10267;
        public const int BDK_E_MULTIPLE_USAGE_EVENTS_REPORTED = 10268;
        public const int BDK_E_BELOW_IMMEDIATE_SETTLE_MINIMUM = 10269;
        public const int BDK_E_REPORT_USAGE_WITH_IMMEDIATE_SETTLE = 10270;
        public const int BDK_E_REPORT_USAGE_WITH_PREPAID = 10271;
        public const int BDK_E_NO_USAGE_EVENT_REPORTED = 10272;
        public const int BDK_E_IMMEDIATE_SETTLE_NOT_AVAILABLE_FOR_PAYMENT_INSTRUMENT = 10273;
        public const int BDK_E_RESOURCE_UNIT_OF_MEASURE_DO_NOT_MATCH = 10274;
        public const int BDK_E_INVALID_REDIRECT_INPUTINFO_XML = 10275;
        public const int BDK_E_TRANSACTION_NOT_CANCELLABLE = 10276;
        public const int BDK_E_NO_CDS_FOUND = 10277;
        public const int BDK_E_INVALID_CHARGE_DESCRIPTOR = 10278;
        public const int BDK_E_INVALID_WHOLESALEPI = 10400;
        public const int BDK_E_NOT_BOBOPARTNER = 10401;
        public const int BDK_E_INVALID_BOBOPARTNER = 10402;
        public const int BDK_E_ENTITLEMENT_ENDPOINT_UNAVAILABLE = 10490;
        public const int BDK_E_ENTITLEMENT_VALIDATION_FAILED = 10491;
        public const int BDK_E_INVALID_ENTITLEMENT_ENDPOINT = 10492;
        public const int BDK_E_NOT_AUTHORIZED_TO_ACCESS_OBJECT = 40279;
        public const int BDK_E_UNABLE_TO_CALL_ON_BEHALF_OF = 10280;
        public const int BDK_E_TAXWARE_FAILURE = 60000;
        public const int BDK_E_ADDRESS_VALIDATION_FAILURE = 60001;
        public const int BDK_E_ZIP_INVALID = 60011;
        public const int BDK_E_STATE_INVALID = 60012;
        public const int BDK_E_ZIP_CITY_MISSING = 60013;
        public const int BDK_E_STATE_ZIP_INVALID = 60014;
        public const int BDK_E_STATE_CITY_INVALID = 60015;
        public const int BDK_E_STATE_ZIP_CITY_INVALID = 60016;
        public const int BDK_E_STATE_ZIP_CITY_INVALID2 = 60017;
        public const int BDK_E_STATE_ZIP_CITY_INVALID3 = 60018;
        public const int BDK_E_STATE_ZIP_CITY_INVALID4 = 60019;
        public const int BDK_E_REDIRECTURL_MISSING = 60020;
        public const int BDK_E_INVALID_SOFT_DESCRIPTOR = 60021;
        public const int BDK_E_CANNOT_CREATE_BILLING_AGREEMENT = 60022;
        public const int BDK_E_GET_BADETAIL_FAILED = 60023;
        public const int BDK_E_CANNOT_UPDATE_PAYPALPAYIN_PAYMENT_METHOD_AGAIN = 60024;
        public const int BDK_E_PP_INVALID_FIELD_VALUE = 60026;
        public const int BDK_E_MULTIPLE_COUNTIES_FOUND = 60029;
        public const int BDK_E_ZIP_INVALID_FOR_ENTERED_STATE = 60030;
        public const int BDK_E_STATE_ZIP_COVERS_MULTIPLE_CITIES = 60041;
        public const int BDK_E_MULTIPLE_CITIES_FOUND = 60042;
        public const int BDK_E_BAD_CITYNAME_LENGTH = 60043;
        public const int BDK_E_BAD_COUNTRYCODE_LENGTH = 60044;
        public const int BDK_E_BAD_STATECODE_LENGTH = 60045;
        public const int BDK_E_BAD_ZIPCODE_LENGTH = 60046;
        public const int BDK_E_BAD_PRODUCTCODE_LENGTH = 60047;
        public const int BDK_E_BAD_BUSINESSLOCATIONCODE_LENGTH = 60048;
        public const int BDK_E_BAD_TRANSACTIONDATE_LENGTH = 60049;
        public const int BDK_E_BAD_VATREGISTRATION_LENGTH = 60050;
        public const int BDK_E_BAD_CURRENCYCODE_LENGTH = 60051;
        public const int BDK_E_BAD_WTCODE_LENGTH = 60052;
        public const int BDK_E_INVALID_INPUT_TO_TAXWARE_OR_VERAZIP = 60053;
        public const int BDK_E_INVALID_VATID_FORMAT = 60055;
        public const int BDK_E_INVALID_VATID_INVALID = 60056;
        public const int BDK_E_UNSUPPORTED_CHAR_EXIST = 60060;
        public const int BDK_E_ERROR_COUNTRYCODE_MISMATCH = 60065;
        public const int BDK_E_ERROR_COUNTRYCODE_REQUIRED = 60070;
        public const int BDK_E_INVALID_TOKEN_SPECIFIED = 5005;
        public const int BDK_E_TOKEN_ALREADY_BLACKLISTED = 5010;
        public const int BDK_E_TOKEN_ALREADY_UNBLACKLISTED = 5011;
        public const int BDK_E_TOKEN_BLACKLISTED = 5055;
        public const int BDK_E_TOKEN_RANGE_BLACKLISTED = 5060;
        public const int BDK_E_USAGE_COUNT_FOR_TOKEN_EXCEEDED = 5065;
        public const int BDK_E_TOKEN_EXPIRY_DATE_SET_AS_NULL = 5070;
        public const int BDK_E_FAILED_INSERTING_TOKEN_INS_DEAL_SUBS = 5071;
        public const int BDK_E_ACTIVATE_TOKEN_RANGE_NOT_PRESENT = 5075;
        public const int BDK_E_TOKEN_EXPIRED = 5105;
        public const int BDK_E_TOKEN_NOT_STARTED = 5110;
        public const int BDK_E_TOKEN_RANGE_NOT_ACTIVE = 5115;
        public const int BDK_E_INVALID_BLACKLIST_HISTORY_REASON_CODE = 5150;
        public const int BDK_E_TRACKING_GUID_NODATA = 5210;
        public const int BDK_E_DUPLICATE_TOKEN_TRACKING_GUID = 5215;
        public const int BDK_E_ALREADY_ACTIVATED = 5230;
        public const int BDK_E_INVALID_COMMITTED_STATUS = 5232;
        public const int BDK_E_INVALID_BLACKLIST_HISTORY_DESCRIPTION = 5235;
        public const int BDK_E_BLACKLIST_EFFECTIVE_DATE_LESS_THAN_ORDER_CREATION_DATE = 5240;
        public const int BDK_E_TOKEN_CONSUMED = 5245;
        public const int BDK_E_INVALID_PART_NUMBER_FOR_TOKEN_CLASS = 5250;
        public const int BDK_E_INVALID_EXTERNAL_REFERENCE_ID = 5251;
        public const int BDK_E_TOKEN_ALREADY_DEACTIVATED = 5255;
        public const int BDK_E_REPLACEMENT_TOKEN_PUID_MISMATCH = 5265;
        public const int ERROR_NULL_INPUT_PARAMETER_TOKEN_CLASS_GUID = 5270;
        public const int BDK_E_INVALID_BOOKMARK = 5252;
        public const int BDK_E_INVALID_MAX = 5253;
        public const int BDK_E_INTERNAL_ERROR_TOKEN = 5205;
        public const int BDK_E_UNSUPPORTED_VERSION = 44380;
        public const int BDK_E_INVALID_QUANTITY = 44300;
        public const int BDK_E_INVALID_PRODUCT_TYPE = 44305;
        public const int BDK_E_DUPLICATE_ITEM_EXTERNAL_ID = 44310;
        public const int BDK_E_NO_TAX_RULE_CONFIGURED = 44315;
        public const int BDK_E_TAX_CALCULATION_FAILURE = 44320;
        public const int BDK_E_NO_ASSOCIATED_TAX_INFO = 44350;
        public const int BDK_E_INVALID_TAX_CALCULATION_INFO = 44365;
        public const int BDK_E_NO_TAX_INCLUSIVE_CALCULATION = 44385;
        public const int BDK_E_INVALID_REVENUE_SKU = 42855;
        public const int BDK_E_INVALID_TAX_AMOUNT = 44330;
        public const int BDK_E_INVALID_TAX_RATE = 44335;
        public const int BDK_E_INVALID_BILLING_MODE = 44340;
        public const int BDK_E_INVALID_ITEM_ENTRY_SET = 44375;
        public const int BDK_E_BILLING_FAILURE = 44355;
        public const int BDK_E_BILLING_RETRYABLE_FAILURE = 44360;
        public const int BDK_E_ORIGINAL_ORDER_ID_NOT_SPECIFIED = 44370;
        public const int BDK_E_NO_MATCHING_BILLING_CONFIGURATION = 44345;
        public const int BDK_E_INVALID_BILLING_REFERENCE_ID = 42800;
        public const int BDK_E_BILLING_REFERENCE_ID_ALREADY_REMOVED = 42805;
        public const int BDK_E_PROCESSIMPORT_OFFSET_LINE_MISSING_FIELD = 52500;
        public const int BDK_E_PROCESSIMPORT_OFFSET_LINE_MISSING_MATCH_EVENT = 52550;
        public const int BDK_E_CANCELREFUND_OFFSET_OF_OFFSET = 52600;
        public const int BDK_E_CANCELREFUND_BOTH_LINE_AND_RELATED_LINE = 52650;
        public const int BDK_E_INVALID_SESSION_KEY = 30350;
        public const int BDK_E_NO_PRODUCT_KEY_FOR_OBJECT_ID = 41140;
        public const int BDK_E_PRODUCT_KEY_NOT_AVAILABLE = 5256;
        public const int BDK_E_PIN_OR_SEQ_REQUIRED = 5257;
        public const int BDK_E_INPUT_PARAM_MALFORMED = 5258;
        public const int BDK_E_INVALID_ADJUSTMENT_OFFSET = 52663;
        public const int BDK_E_INVALID_ITEM_INSTANCE_ID = 52700;
        public const int BDK_E_INVALID_REVERSE_REASON = 52701;
        public const int BDK_E_TOO_MANY_ITEMS_IN_PURCHASE = 52704;
        public const int BDK_E_INVALID_OFFERING_TYPE = 52705;
        public const int BDK_E_PRICE_IS_NEGATIVE = 52706;
        public const int BDK_E_DYNAMIC_PRICE_CONFIGURATION = 52707;
        public const int BDK_E_DMP_MAX_BALANCE_EXCEEDED = 52708;
        public const int BDK_E_CURRENCY_MISSING = 52709;
        public const int BDK_E_PENDING_ITEM_PURCHASE = 52710;
        public const int BDK_E_DMP_FLOW_NOT_ENABLED = 52711;
        public const int BDK_E_ITEM_ALREADY_REVERSED = 52712;
        public const int BDK_E_ITEM_NOT_FULFILLED = 52713;
        public const int BDK_E_DMP_UNKNOWN_ERROR = 52714;
        public const int BDK_E_ACTION_NOT_APPLICABLE_FOR_PAYMENT_TYPE = 52716;
        public const int BDK_E_INVALID_CANCEL_TRANSACTION_RESULT = 52717;
        public const int BDK_E_CVM_MISSING = 52718;
        public const int BDK_E_ACCOUNT_CANNOT_PURCHASE_FREE_TRIAL = 52719;
        public const int BDK_E_DONOR_BENEFICIARY_COUNTRY_MISMATCH = 52720;
        public const int BDK_E_DONOR_BENEFICIARY_SAME = 52721;
        public const int BDK_E_RENEWAL_DOES_NOT_EXISTS = 44186;
        public const int BDK_E_TOKEN_SCHEDULED_RENEWAL_EXISTS = 44188;
        public const int BDK_E_NOTIFICATION_QUEUE_EVENT_FAIL_FREQUENTLY = 49000;
        public const int BDK_E_NOTIFICATION_CLIENT_UNKNOWN_ERROR = 49001;
        public const int BDK_E_NOTIFICATION_CLIENT_INIT_FAIL = 49002;
        public const int BDK_E_NOTIFICATION_CLIENT_INVALID_QUEUE_OPTION = 49003;
        public const int BDK_E_NOTIFICATION_CLIENT_TOO_SLOW = 49004;
        public const int BDK_E_NOTIFICATION_QUEUE_EVENT_FAIL_NOT_FREQUENTLY = 49005;
        public const int BDK_E_NOTIFICATION_NO_RELATED_PARTNER_SUBS = 49006;
        public const int BDK_E_INVALID_DISCOUNT = 44205;
        public const int BDK_E_INSERT_DISCOUNT = 44210;
        public const int BDK_E_DISCOUNT_ALREADY_APPLIED = 44215;
        public const int BDK_E_DISCOUNT_REQUIRED_FOR_TOKEN = 44220;
        public const int BDK_E_DISCOUNT_TOKEN = 44225;
        public const int BDK_E_INSERT_DISCOUNT_LOCALIZE = 44230;
        public const int BDK_E_DISCOUNT_USAGE_EXCEEDED = 44235;
        public const int BDK_E_DISCOUNT_TOKEN_CLASS_MISMATCH = 44240;
        public const int BDK_E_INVALID_CUSTOMER_TYPE_FOR_PARTNER = 44312;
        public const int BDK_E_NULL_CATEGORY = 44130;
        public const int BDK_E_NULL_ACCOUNTID = 44131;
        public const int BDK_E_NULL_SUBSCRIPTIONREFID = 44132;
        public const int BDK_E_INVALID_SURVEYRESULTCODE = 44133;
        public const int BDK_E_CD_NOTFOUND = 44134;
        public const int BDK_E_INVALID_ACCOUNTID = 44135;
        public const int BDK_E_INVALID_ANONYMOUS_INFO_XML = 44136;
        public const int BDK_E_UNSUPPORTED_OBJECT_TYPE = 44137;
        public const int BDK_E_INVALID_PHONE_XML = 44138;
        public const int BDK_E_INVALID_REQUESTOR_INFO = 44140;
        public const int BDK_E_PENDING_TRANSACTIONS = 44202;
        public const int BDK_E_LINEITEM_SETTLEMENT_AMOUNT_NOT_MATCH = 21200;
        public const int BDK_E_INVALID_ORIGINAL_CHARGE_DETAILS = 21205;
        public const int BDK_E_PARTIAL_CHAREGBACK = 21208;
        public const int BDK_E_INVALID_LINEITEM_ID_FOR_REVERSAL = 21210;
        public const int BDK_E_INVALID_CHARGEBACK_DATE = 21225;
        public const int BDK_E_INVALID_CHARGEBACK_AMOUNT = 21230;
        public const int BDK_E_ALREADY_OFFSET_TAX = 21233;
        public const int BDK_E_COUNTRY_CODE_MAPPOINT_NOT_ENABLED = 40171;
        public const int BDK_E_NETWORK_ERROR_CONNECTING_TO_MAPPOINT = 52815;
        public const int BDK_E_INTERNAL_ERROR_CONNECTING_TO_MAPPOINT = 52816;
        public const int BDK_E_ZERO_ADDRESSES_BY_MAPPOINT = 52817;
        public const int BDK_E_UNKNOWN_ERROR = 52818;
        public const int BDK_E_UPDATE_ADDRESS_UNKNOWN_ERROR = 44196;
        public const int BDK_E_INVALID_ADDRESSINFOXML = 52820;
        public const int BDK_E_POST_BOX_ERROR_MAPPOINT = 52821;
        public const int BDK_E_MAPPOINT_CONNECTION_MAPPOINT = 52822;
        public const int BDK_E_ERROR_INVALID_CHARGEBACK_INPUT_DETAILS = 55320;
        public const int BDK_E_CHARGEBACK_NOT_FOUND = 55325;
        public const int BDK_E_CHARGEBACK_NOT_MATCH = 55335;
        public const int BDK_E_DOUBLE_CHARGEBACK = 55350;
        public const int BDK_E_INVALID_CHARGEBACK_LINEITEM_ID = 55355;
        public const int BDK_E_INVALID_CHARGEBACK_REVERSAL_ID = 55370;
        public const int BDK_E_INVALID_CHARGEBACK_ID_FOR_REVERSAL_CHARGEBACK_ID = 55375;
        public const int BDK_E_INVALID_LINEITEM_ID_FOR_CHARGEBACK_ID = 55380;
        public const int BDK_E_INVALID_LINEITEM_TYPE = 55385;
        public const int BDK_E_DOUBLE_CHARGEBACK_FOR_REVERSAL = 55400;
        public const int BDK_E_COUNTRY_NOT_SUPPORTED = 44197;
        public const int BDK_E_COUNTRY_MAPPOINT_DISABLED = 44198;
        public const int BDK_E_INVALID_PARAMETER = 44199;
        public const int BDK_E_INVALID_INPUT_RATINGRULE_DATA = 40168;
        public const int BDK_E_INVALID_TIME_CONVERSION_RATIO = 44421;
        public const int BDK_E_INVALID_ROUND_DAY_BOUNDARY = 44422;
        public const int BDK_E_TIME_EXTENSION_NOT_SUPPORTED = 44424;
        public const int BDK_E_INVALID_SUBS_STATUS_FOR_COMMIT_CONVERT = 44425;
        public const int BDK_E_INVALID_SUBS_STATUS_FOR_COMMIT_CREATESUBS = 44426;
        public const int BDK_E_INVALID_TAX_CODE = 44427;
        public const int BDK_E_MULTIPLE_RATING_RULE_FOUND = 44428;
        public const int BDK_E_INVALID_SUBS_STATUS_FOR_ABANDON_CONVERT = 44429;
        public const int BDK_E_INVALID_SUBS_STATUS_FOR_ABANDON_CREATESUBS = 44430;
        public const int BDK_E_INVALID_TAX_INCLUDED = 44440;
        public const int BDK_E_INVALID_DESCRIPTION_PRICEDESC = 44441;
        public const int BDK_E_RENEW_SUBSCRIPTION_NOT_SUPPORTED = 44442;
        public const int BDK_E_INVALID_CHARGEBACK_ID = 10300;
        public const int BDK_E_CHARGEBACK_PROCESSING_FAILURE = 10301;
        public const int BDK_E_INVALID_MERCHANT_REFERENCE = 10302;
        public const int BDK_E_CHARGEBACK_INFO_MISSING = 10303;
        public const int BDK_E_RECORD_CHARGEBACK_FAILED = 10304;
        public const int BDK_E_DOUBLE_CHARGEBACK_REVERSAL = 10305;
        public const int BDK_E_REVERSAL_OF_PROCESSED_CHARGEBACK = 10306;
        public const int BDK_E_MISMATCH_PAYMENT_SUBSCRIPTION = 10307;
        public const int BDK_E_SUBSCRIPTION_ALREADY_CONVERTED_OR_RENEWED = 10308;
        public const int BDK_E_MERCHANT_REFERENCE_NUMBER_MISSING = 10309;
        public const int BDK_E_INVALID_ENCRYPT_ACCOUNT_NUMBER = 10310;
        public const int BDK_E_SUBSCRIPTION_SCHEDULED_RENEWAL = 10311;
        public const int BDK_E_PROFILE_ALREADY_EXISTS = 10312;
        public const int BDK_E_PROFILE_DOES_NOT_EXIST = 10313;
        public const int BDK_E_ACCOUNT_WITHOUT_ADDRESS = 10314;
        public const int BDK_E_NO_PAYOUT_PREFERENCE = 10315;
        public const int BDK_E_CAN_NOT_DELETE_DEFAULT_PAYOUT_PREFERENCE = 10316;
        public const int BDK_E_INVALID_PAYUSERINFOXML = 10317;
        public const int BDK_E_INVALID_USERPROFILEXML = 10318;
        public const int BDK_E_CANNOT_SPECIFY_BILLABLE_ACCOUNT_ID = 10319;
        public const int BDK_E_DESCRIPTION_MAXLENGTH_EXCEEDED = 10320;
        public const int BDK_E_RIME_REJECTED = 10321;
        public const int BDK_E_RIME_INVALID_VALUE = 10322;
        public const int BDK_E_REFERRAL_CODE_NOT_FOUND = 44121;
        public const int BDK_E_BSS_NOT_SUPPORTED_LINE_ITEM_ID = 44400;
        public const int BDK_E_BSS_INTERNAL_SERVER_ERROR = 44401;
        public const int BDK_E_BSS_INVALID_ORDER_STATUS = 44402;
        public const int BDK_E_BSS_PARITAL_CHARGE_BACK = 44403;
        public const int BDK_E_BSS_TIMEOUT_ERROR = 44404;
        public const int ERROR_MISSING_PROV_INFO = 54013;
        public const int BDK_E_INVALID_RESOURCE_TYPE = 44122;
        public const int BDK_E_PAYMENT_PROVIDER_SUBMISSION_FAILED = 20010;
        public const int BDK_E_PAYMENT_PROVIDER_SUBMISSION_DECLINED = 20011;
        public const int BDK_E_ENCRYPTION_FAILURE = 20012;
        public const int BDK_E_DMP_FIRST = 64000;
        public const int BDK_E_DMP_LAST = 64999;
        public const int BDK_E_INVALID_TARGET_USER_INFORMATION = 31000;
        public const int BDK_E_INVALID_DELEGATE_USER_INFORMATION = 31001;
        public const int BDK_E_INVALID_SOURCE_USER_INFORMATION = 31002;
        public const int BDK_E_INVALID_TRANSACTION_INFORMATION = 31003;
        public const int BDK_E_NO_MATCHING_TRANSACTION = 31004;
        public const int BDK_E_NO_MATCHING_PENDINGPAYOUT_TRANSACTION = 31005;
        public const int BDK_E_NO_MATCHING_PENDING_TRANSACTION = 31006;
        public const int BDK_E_ORDER_LAYER_FIRST = 56001;
        public const int BDK_E_ORDER_LAYER_LAST = 57000;
        public const int BDK_E_TRANSACTION_LAYER_FIRST = 57001;
        public const int BDK_E_TRANSACTION_LAYER_LAST = 58000;
        public const int BDK_E_PROVISIONING_MPF_CALL_FAILED = 58005;
        public const int BDK_E_PROVISIONING_INVALID_ADJUSTMENT_OFFSET = 58006;
        public const int BDK_E_PROVISIONING_INVALID_ARG = 58007;
        public const int AU_E_NO_REQUEST_SENT = 58151;
        public const int AU_E_DUPLICATE_RUN = 58152;
        public const int AU_E_BAD_BATCH_FORMAT = 58153;
        public const int AU_E_FAIL_TO_ARCHIVE = 58154;
        public const int AU_E_FAIL_TO_GENERATE_INQUIRY_FILE = 58155;
        public const int AU_E_INQUIRY_GENERATION_TASK_ENDED_UNSUCCESSFULLY = 58051;
        public const int AU_E_RESPONSE_PROCESS_TASK_ENDED_UNSUCCESSFULLY = 58052;
        public const int AU_E_UPDATE_PROCESS_TASK_ENDED_UNSUCCESSFULLY = 58053;
        public const int PP_E_REQUEST_PROCESS_TASK_ENDED_UNSUCCESSFULLY = 58304;
        public const int PP_E_RESPONSE_PROCESS_TASK_ENDED_UNSUCCESSFULLY = 58305;
        public const int SCS_E_CERT_INAVLID = 59000;
        public const int SCS_E_INAVLID_CALLING_PARTNER = 59001;
        public const int BDK_E_RISK_EVALUATION_FAILED = 65001;
        public const int BDK_E_RISK_EVALUATION_EXCEPTION = 65002;
        public const int BDK_E_RISK_EVALUATION_UNDEFINED = 65003;
        public const int BDK_E_RISK_CONFIGURATION_ERROR = 65004;
        public const int BDK_E_RISK_NEXT = 65005;
        public const int BDK_E_RISK_ENGINE_EXCEPTION = 65006;
        public const int BDK_E_RISK_ARGUMENT_VALIDATION_FAILED = 65007;
        public const int BDK_E_DAV_APARTMENT = 65100;
        public const int BDK_E_DAV_INSUFFICIENT = 65101;
        public const int BDK_E_DAV_ID = 65102;
        public const int BDK_E_DAV_MULTIPLE = 65103;
        public const int BDK_E_DAV_POBOX = 65104;
        public const int BDK_E_DAV_ROUTE = 65105;
        public const int BDK_E_DAV_STREET = 65106;
        public const int BDK_E_DAV_POSTAL = 65107;
        public const int BDK_E_DAV_GENERAL = 65108;
        public const int BDK_E_DAV_MISSING_DATA = 65109;
        public const int BDK_E_DAV_INVALID_DATA = 65110;
        public const int BDK_E_DAV_SYSTEM_FAILURE = 65111;
        public const int BDK_E_DAV_TIMEOUT = 65112;
        public const int BDK_E_DAV_DISABLED = 65113;
        public const int BDK_E_DAV_INVALID_CHARSET = 65114;
        public const int BDK_E_RISK_LAST = 65535;
        public const int DMP_E_VALIDATION_ERROR = 64001;
        public const int DMP_E_UNKNOWNSERVER_ERROR = 64002;
        public const int DMP_E_CONFIGURATION_ERROR = 64003;
        public const int DMP_E_SYSTEM_INTERNAL_ERROR = 64004;
        public const int DMP_E_INVALID_TENANT = 64005;
        public const int DMP_E_INVALID_API_SIGNATURE = 64006;
        public const int DMP_E_USER_REGISTERED = 64007;
        public const int DMP_E_REQUEST_CANNOT_BE_COMPLETED = 64008;
        public const int DMP_E_STATUS_UNREGISTERED = 64009;
        public const int DMP_E_INVALID_NEXTHANDLE = 64010;
        public const int DMP_E_INVALID_DATE_RANGE = 64011;
        public const int DMP_E_INSUFFICIENT_BALANCE = 64012;
        public const int DMP_E_DATA_OVERLIMIT_ERROR = 64013;
        public const int DMP_E_ITEM_UNIQUENESS_ERROR = 64014;
        public const int DMP_E_INVALID_ITEM_VALUE = 64015;
        public const int DMP_E_NOT_ALL_ITEMS_ELIGIBLE_FOR_CREDIT = 64016;
        public const int DMP_E_INVALID_CONFIRMATION_ID = 64017;
        public const int DMP_E_INVALID_SKU = 64018;
        public const int DMP_E_INVALID_SKU_TYPE = 64019;
        public const int DMP_E_PROMO_EXPIRED = 64020;
        public const int DMP_E_STATUS_NOT_CHANGED = 64021;
        public const int DMP_E_COUNTRY_NOT_CHANGED = 64022;
        public const int DMP_E_INVALID_TRANSACTION_TYPE = 64023;
        public const int DMP_E_ORIGINAL_TRANSACTION_HAS_CREDIT = 64024;
        public const int DMP_E_MAX_BALANCE_EXCEEDED = 64025;
        public const int DMP_E_MAX_ACQUISITION_EXCEEDED = 64026;
        public const int DMP_E_MAX_CONSUMPTION_EXCEEDED = 64027;
        public const int DMP_E_NO_MORE_PROMO_POINTS = 64028;
        public const int DMP_E_PROMO_POINTS_UNAVAILIABLE = 64029;
        public const int DMP_E_ORIGINAL_TRANSACTION_NOT_FOUND = 64030;
        public const int DMP_E_ORIGINAL_TRANSACTION_HAS_DEBIT = 64031;
        public const int DMP_E_INVALID_TRANSACTION_TO_CREDIT = 64032;
        public const int DMP_E_INVALID_REASON_CODE = 64033;
        public const int DMP_E_PROMOTION_LIMIT_LIFE_MAX = 64034;
        public const int DMP_E_STATUS_CHANGE_NOT_ALLOWED = 64035;
        public const int DMP_E_PROPERTY_VALUE_NOT_CHANGED = 64036;
        public const int DMP_E_NOT_ALL_ITEMS_ELIGIBLE_FOR_OFFSET = 64037;
        public const int DMP_E_MUST_SPECIFY_CONFIRMATION = 64038;
        public const int DMP_E_CONFIRMATION_HAS_TO_BE_NULL = 64039;
        public const int DMP_E_INVALID_EXCHANGE_TYPE = 64040;
        public const int DMP_E_CANNOT_CREDIT_SUBSCRIPTION = 64041;
        public const int DMP_E_EXCHANGE_PRICE_MISMATCH = 64042;
        public const int DMP_E_INVALID_SOURCE_ACCOUNT = 64043;
        public const int DMP_E_INVALID_DESTINATION_ACCOUNT = 64044;
        public const int DMP_E_SOURCE_TRANSFER_PUIDS_SAME = 64045;
        public const int DMP_E_COUNTRY_CODE_MISMATCH = 64046;
        public const int DMP_E_SOURCETRANSFER_INITIATED_WITHIN_NO_TRANSFER_WINDOW = 64047;
        public const int DMP_E_TARGETTRANSFER_INITIATED_WITHIN_NO_TRANSFER_WINDOW = 64048;
        public const int DMP_E_MAX_BALANCE_TRANSFER_PROVISIONAL_EXCEEDED = 64049;
        public const int DMP_E_MAX_BALANCE_TRANSFER_PROMOTIONAL_EXCEEDED = 64050;
        public const int DMP_E_PARTIAL_TRANSFER = 64051;
        public const int DMP_E_SOURCE_ZERO = 64052;
        public const int DMP_E_DESTINATION_ZERO = 64053;
        public const int DMP_E_DELEGATE_NOT_SUPPORTED = 64054;
        public const int DMP_E_INVALID_PMN = 64055;
        public const int DMP_DP_INVALID_DISTRIBUTION_PROGRAM = 64056;
        public const int DMP_DP_INVALID_DISTRIBUTION_PROGRAM_CALLING_PARTNER = 64057;
        public const int DMP_DP_INVALID_DISTRIBUTION_PROGRAM_SELLING_PARTNER = 64058;
        public const int DMP_DP_INVALID_DISTRIBUTION_PROGRAM_SKU = 64059;
        public const int DMP_DP_INVALID_DISTRIBUTION_PROGRAM_USER = 64060;
        public const int DMP_DP_USER_NOT_ENROLLED = 64061;
        public const int DMP_E_USER_DISABLED = 64062;
        public const int DMP_E_MAX_ACQUISITIONPERSPAN_EXCEEDED = 64063;
        public const int TRANSACTION_E_AUTHORIZATION_FAILED = 141078;
        public const int TRANSACTION_E_INVALID_SUBS_RESPONSE = 131074;
        public const int BILLING_E_LINEITEM_ALREADY_REFUND = 75554;
        public const int BILLING_E_INVALID_TRANSACTION_STATUS = 75542;
        public const int BILLING_E_INVALID_CALLING_PARTER = 85555;
        public const int TRANSACTION_E_INVALID_ACCOUNT_STATUS = 141080;
        public const int BILLING_E_INTERNAL_SERVER_ERROR = 85537;
        public const int BILLING_E_PARITAL_CHARGE_BACK = 75549;
        public const int BILLING_E_INVALID_LINE_ITEM_EVENT = 75548;
        public const int TRANSACTION_E_INVALID_TRACKING_GUID = 141076;
        public const int TRANSACTION_E_EXTERNAL_TIMEOUT_ERROR = 141073;
        public const int BILLING_E_INVALID_TRACKING_GUID = 75547;
        public const int BILLING_E_INVALID_PAYMENT_INSTRUMENT_DETAILS = 85554;
        public const int BILLING_E_INVALID_LINE_ITEM = 75551;
        public const int BILLING_E_INVALID_BALANCE_STATUS = 75541;
        public const int BILLING_E_INVALID_PARTNER_PAYMENT_REF = 85551;
        public const int BILLING_E_INVALID_DECLINE_CODE = 85552;
        public const int BILLING_E_LINEITEM_ALREADY_CHARGED_BACK = 75553;
        public const int BILLING_E_INVALID_BALANCE_ID = 85550;
        public const int BILLING_E_INVALID_ORDER_STATUS = 75540;
        public const int BILLING_E_INVALID_OPERATION = 75539;
        public const int TRANSACTION_E_INVALID_ACCOUNT_RESPONSE = 131079;
        public const int TRANSACTION_E_INVALID_OPERATION = 141075;
        public const int TRANSACTION_E_TRANSACTION_RACE_CONDITION = 141081;
        public const int BILLING_E_INVALID_ARGUMENT = 75538;
        public const int TRANSACTION_E_INVALID_PAYMENTMETHOD_RESPONSE = 131078;
        public const int BILLING_E_LINEITEM_ALREADY_CROSS_TRANSFERED = 75555;
        public const int BILLING_E_PAYMENT_PROVIDER_DECLINE = 75550;
        public const int BILLING_E_INVALID_OFFSET_AMOUNT = 75556;
        public const int TRANSACTION_E_INTERNAL_SERVER_ERROR = 131073;
        public const int BILLING_E_INVALID_LINE_ITEM_STATUS = 75552;
        public const int TRANSACTION_E_INVALID_DMP_RESPONSE = 131076;
        public const int BILLING_E_PAYMENT_PROVIDER_RETRYABLE_ERROR = 75546;
        public const int BILLING_E_INVALID_SOFT_DESCRIPTOR = 85556;
        public const int BILLING_E_UNEXPECTED_PAYMENT_EVENT = 85543;
        public const int BILLING_E_UNRECOGNIZED_MRN = 85544;
        public const int TRANSACTION_E_INVALID_PARTNER = 141077;
        public const int BILLING_E_PAYMENT_PROVIDER_ERROR = 85545;
        public const int TRANSACTION_E_INVALID_TAX_RESPONSE = 131077;
        public const int TRANSACTION_E_INVALID_RISK_RESPONSE = 131080;
        public const int TRANSACTION_E_INVALID_ARGUMENT = 141074;
        public const int BILLING_E_INVALID_ORDER_ID = 85553;
        public const int TRANSACTION_E_INVALID_BILLING_RESPONSE = 131075;
        public const int TRANSACTION_E_INVALID_PAYMENT_INSTRUMENT_STATUS = 141079;
        public const int TRANSACTION_E_UNSUPPORTED_DD_OPERATION = 141082;





        private static Dictionary<int, CTPErrorDetail> _errorDetails;



        static CTPError()
        {
            _errorDetails = new Dictionary<int, CTPErrorDetail>();

            InitNonUserErrorList();

            InitializeErrorDetails();
        }
        public static void SetErrorDetail(int ctpErrorCode, string message, bool retryable, HResult xonHr)
        {
            _errorDetails[ctpErrorCode] = new CTPErrorDetail(ctpErrorCode, message, retryable, xonHr);
        }
        public static void InitializeErrorDetails()
        {
            SetErrorDetail(BDK_E_BAN_NULL_INPUT_PARAMETER, "Null input parameter passed to a ban API.", false, 0x80190001);
            SetErrorDetail(BDK_E_ALREADY_BANNED, "Already banned.", false, 0x80190002);
            SetErrorDetail(BDK_E_NOT_BANNED, "Not banned.", false, 0x80190003);
            SetErrorDetail(BDK_E_BANNEDPERSON, "This account is banned.", false, 0x80190004);
            SetErrorDetail(BDK_E_COUNTRY_CURRENCY_PI_MISMATCH, "Country/currency/payment instrument type mismatch.", false, 0x80190005);
            SetErrorDetail(BDK_E_INVALID_PAYMENT_INSTRUMENT_TYPE, "Invalid payment instrument type.", false, 0x80190006);
            SetErrorDetail(BDK_E_INVALID_CREDIT_CARD_TYPE, "Invalid credit card type.", false, 0x80190007);
            SetErrorDetail(BDK_E_DECRYPTION_FAILURE, "Decryption failed. Verify that data is encrypted correctly.", false, 0x80190008);
            SetErrorDetail(BDK_E_BANNED_PAYMENT_INSTRUMENT, "Payment instrument is banned.", false, 0x80190009);
            SetErrorDetail(BDK_E_INVALID_DD_ACCOUNT, "Direct debit account validation failed.", false, 0x80190010);
            SetErrorDetail(BDK_E_DD_CONCATENATED_STRING_LENGTH_EXCEEDS_24, "Concatenated direct debit account number exceeds 24 characters.", false, 0x80190011);
            SetErrorDetail(BDK_E_INVALID_CREDIT_CARD_NUMBER, "Invalid credit card number.", false, 0x80190012);
            SetErrorDetail(BDK_E_CREDIT_CARD_EXPIRED, "Credit card has already expired.", false, 0x80190013);
            SetErrorDetail(BDK_E_AVS_FAILED, "Address verification failed.", false, 0x80190014);
            SetErrorDetail(BDK_E_NO_AVS_RESULT, "Address verification through AVS did not provide a result.", false, 0x80190015);
            SetErrorDetail(BDK_E_AUTHORIZATION_FAILED, "Payment Instrument authorization failed.", false, 0x80190016);
            SetErrorDetail(BDK_E_PAYMENT_PROVIDER_CONNECTION_FAILED, "Unable to connect to payment provider.", false, 0x80190017);
            SetErrorDetail(BDK_E_DD_INVALID_COUNTRY, "Invalid country code.", false, 0x80190018);
            SetErrorDetail(BDK_E_DD_INVALID_ACCOUNT_FORMAT, "Invalid account format.", false, 0x80190019);
            SetErrorDetail(BDK_E_DD_INVALID_BANKCODE_FORMAT, "Invalid bank code format.", false, 0x80190020);
            SetErrorDetail(BDK_E_DD_INVALID_BRANCHCODE_FORMAT, "Invalid branch code format.", false, 0x80190021);
            SetErrorDetail(BDK_E_DD_INVALID_CHECKDIGIT_FORMAT, "Invalid check digit format.", false, 0x80190022);
            SetErrorDetail(BDK_E_DD_ACCOUNT_MISSING, "Account missing.", false, 0x80190023);
            SetErrorDetail(BDK_E_DD_BANKCODE_MISSING, "Bank code missing.", false, 0x80190024);
            SetErrorDetail(BDK_E_DD_BRANCHCODE_MISSING, "Branch code missing.", false, 0x80190025);
            SetErrorDetail(BDK_E_DD_CHECKDIGIT_MISSING, "Check digit missing.", false, 0x80190026);
            SetErrorDetail(BDK_E_DD_ERROR_IN_FIELDS, "Some fields have errors.", false, 0x80190027);
            SetErrorDetail(BDK_E_DD_INVALID_ACCOUNT_VALUE, "Invalid account code.", false, 0x80190028);
            SetErrorDetail(BDK_E_DD_INVALID_BANKCODE_VALUE, "Invalid bank code.", false, 0x80190029);
            SetErrorDetail(BDK_E_DD_INVALID_BRANCHCODE_VALUE, "Invalid branch code.", false, 0x80190030);
            SetErrorDetail(BDK_E_DD_INVALID_CHECKDIGIT_VALUE, "Invalid check digit.", false, 0x80190031);
            SetErrorDetail(BDK_E_DD_INVALID_ACCOUNT_HOLDER_NAME, "Account holder name not specified or it exceeds 35 characters.", false, 0x80190032);
            SetErrorDetail(BDK_E_DD_UNKNOWN_PROVIDER_FAILURE, "Soap call to provider failed.", false, 0x80190033);
            SetErrorDetail(BDK_E_PAYMENT_PROVIDER_CONNECTION_TIMEOUT, "Payment provider connection timed out.", false, 0x80190034);
            SetErrorDetail(BDK_E_TRANSACTION_DECLINED_BY_PAYMENT_PROVIDER, "Transaction declined by payment provider.", false, 0x80190035);
            SetErrorDetail(BDK_E_INVALID_INITIATE_TRANSACTION_RESULT, "Payment provider error.", false, 0x80190036);
            SetErrorDetail(BDK_E_INVALID_WHOLESALE_PARTNER, "The wholesale partner specified is invalid.", false, 0x80190037);
            SetErrorDetail(BDK_E_PI_NOT_SUPPORTED, "PI Not Supported in this version", false, 0x80190038);
            SetErrorDetail(BDK_E_UPS_NOT_UPDATED, "A fatal error occured updating the UPS entries for all PUIDs relating to i_billable_acct_id %1. This account should be investigated and the UPS entries for PUIDs attached to it should be updated manually.", false, 0x80190039);
            SetErrorDetail(BDK_E_DD_UNSUPPORTED, "This branch will not support Direct Debit transactions.", false, 0x80190040);
            SetErrorDetail(BDK_E_DD_MPF_NON_XML_RESPONSE, "Internal error, Return from MPF is not in XML format.", false, 0x80190041);
            SetErrorDetail(BDK_E_DD_MPF_INCORRECT_XML_FORMAT, "Internal error, Return XML from MPF is not in correct format.", false, 0x80190042);
            SetErrorDetail(BDK_E_DD_GC_NON_XML_RESPONSE, "Global Collect error, Return from Global Collect is not in XML format.", false, 0x80190043);
            SetErrorDetail(BDK_E_DD_GC_INCORRECT_XML_FORMAT, "Global Collect error, Return XML from Global Collect is not in correct format.", false, 0x80190044);
            SetErrorDetail(BDK_E_DD_GC_RETURNED_NOK_RESULT, "Global collect failed to process this request, returned NOT OK result.", false, 0x80190045);
            SetErrorDetail(BDK_E_DD_GC_CHECK_INCOMPLETE, "Direct Debit account Check performed by Global Collect is not complete for this account.", false, 0x80190046);
            SetErrorDetail(BDK_E_DD_OPENING_GC_XML_CHECKSPERFORMED, "Global Collect error, Return XML from Global Collect is not in correct format. Error in CHECKSPERFORMED node of the return XML.", false, 0x80190047);
            SetErrorDetail(BDK_E_DD_GC_XML_INVALID_CHECK_RESULT, "Global Collect error, Return XML from Global Collect is not in correct format. Data within CHECKSPERFORMED nodes are invalid.", false, 0x80190048);
            SetErrorDetail(BDK_E_DD_GC_INVALID_RFBANKCODE, "Global collect returned non null Reformatted Bank Code though the input Bank code was blank.", false, 0x80190049);
            SetErrorDetail(BDK_E_INVALID_PAYMENT_INSTRUMENT_DETAILS, "Invalid payment instrument details.", false, 0x80190050);
            SetErrorDetail(BDK_E_INVALID_BAN_REASON_CODE, "Invalid ban reason code.", false, 0x80190051);
            SetErrorDetail(BDK_E_INVALID_CVM_CODE, "Invalid encrypted CVM code.", false, 0x80190052);
            SetErrorDetail(BDK_E_UNEXPECTED_CVM_RESPONSE_CODE, "Unexpected CVM response code.", false, 0x80190053);
            SetErrorDetail(BDK_E_CVM_FAILED, "CVM check failed.", false, 0x80190054);
            SetErrorDetail(BDK_E_IMMEDIATE_SETTLEMENT_FAILURE, "Immediate settlement failed", false, 0x80190055);
            SetErrorDetail(BDK_E_FREQUENCY_CHECK_FAILED, "Frequency check failed.", false, 0x80190056);
            SetErrorDetail(BDK_E_DD_INVALID_MERCHANT_INDEX, "Invalid merchant index.", false, 0x80190057);
            SetErrorDetail(BDK_E_DD_DUPLICATE_MRN, "Duplicate merchant reference.", false, 0x80190058);
            SetErrorDetail(BDK_E_DD_UNKNOWN_VALIDATION_FAILURE, "Account validation failed.", false, 0x80190059);
            SetErrorDetail(BDK_ERROR_DD_BANK_ACCOUNT_TYPE_MUST_BE_NULL, "Bank account type may not be specified for this country.", false, 0x80190060);
            SetErrorDetail(BDK_ERROR_DD_BANK_ACCOUNT_TYPE_MAY_NOT_BE_NULL, "Bank account type is required for this country.", false, 0x80190061);
            SetErrorDetail(BDK_E_DD_RISK_DECLINE, "Risk check failed.", false, 0x80190062);
            SetErrorDetail(BDK_E_UNABLE_TO_VALIDATE_TAX_ID, "Unable to validate the tax ID.", false, 0x80190063);
            SetErrorDetail(BDK_E_TAX_ID_UPDATE_ATTEMPTS_EXCEEDED, "Number of updates allowed in a period has exceeded the maximum limit.", false, 0x80190064);
            SetErrorDetail(BDK_E_EXTERNAL_VENDOR_ERROR, "External vendor error.", false, 0x80190065);
            SetErrorDetail(BDK_E_ALREADY_IN_SPECIFIED_STATE, "Object is already in the specified state.", false, 0x80190066);
            SetErrorDetail(BDK_E_MISSING_SEARCH_CRITERIA, "Required search criteria field missing. Either a phone number or both first name and last name is required.", false, 0x80190067);
            SetErrorDetail(BDK_E_REQUIRED_FIELD_MISSING, "Required field missing.", false, 0x80190068);
            SetErrorDetail(BDK_E_ACTIVE_SUBSCRIPTIONS, "The account has subscriptions.", false, 0x80190069);
            SetErrorDetail(BDK_E_UNEXPECTED_FIELD, "Unexpected field", false, 0x80190070);
            SetErrorDetail(BDK_E_INVALID_ACCOUNT_SOUCE, "Invalid account source.", false, 0x80190071);
            SetErrorDetail(BDK_E_INVALID_CREATION_DATE, "Creation date/time cannot be later than current date/time.", false, 0x80190072);
            SetErrorDetail(BDK_E_EXCEEDING_TAX_EXEMPT_LIMITS, "No more tax exemptions are allowed for this account.", false, 0x80190073);
            SetErrorDetail(BDK_E_GENERATE_NEXT_ID, "Generating next ID.", false, 0x80190074);
            SetErrorDetail(BDK_E_INVALID_STATE_FOR_COUNTRY, "State invalid for the country.", false, 0x80190075);
            SetErrorDetail(BDK_E_ADDRESS_COUNTRY_ACCOUNT_MISMATCH, "Country for address provided does not match existing country for account.", false, 0x80190076);
            SetErrorDetail(BDK_E_OFFERING_COUNTRY_ACCOUNT_MISMATCH, "The offering requested is not available in the country of this account.", false, 0x80190077);
            SetErrorDetail(BDK_E_INVALID_BILLABLE_ACCOUNT_ID, "Invalid account.", false, 0x80190078);
            SetErrorDetail(BDK_E_INVALID_BILLABLE_ACCOUNT_STATUS_ID, "Invalid account status.", false, 0x80190079);
            SetErrorDetail(BDK_E_INVALID_PHONE_TYPE, "Invalid phone type.", false, 0x80190080);
            SetErrorDetail(BDK_E_INVALID_OFFERING_ID, "Invalid offering.", false, 0x80190081);
            SetErrorDetail(BDK_E_INVALID_PURCHASE_INPUT_DATA, "The combination of data passed to PurchaseOffering is invalid for the scenario.", false, 0x80190082);
            SetErrorDetail(BDK_E_PUID_MISSING_ATTRIBUTE, "UPS profile is missing either FirstName, LastName, Country or PMN", false, 0x80190083);
            SetErrorDetail(BDK_E_INVALID_COUNTRY_CODE, "Invalid country code.", false, 0x80190084);
            SetErrorDetail(BDK_E_INVALID_ADDRESS_ID, "Invalid address ID.", false, 0x80190085);
            SetErrorDetail(BDK_E_INVALID_PAYMENT_METHOD_ID, "Invalid payment instrument ID.", false, 0x80190086);
            SetErrorDetail(BDK_E_PI_EXECEED_MAX_OWNER_SHIP, "Cannot exceed max ownership for the payment instrument.", false, 0x80190087);
            SetErrorDetail(BDK_E_SUBSCRIPTION_ALREADY_CANCELED, "Subscription is already cancelled.", false, 0x80190088);
            SetErrorDetail(BDK_E_DELAYED_EXPIRE_ALREADY_PENDING, "A delayed expire request is already pending and should not be requested again.", false, 0x80190089);
            SetErrorDetail(BDK_E_DELAYED_EXPIRE_NOT_PENDING, "A delayed expire is not pending and cannot be undone.", false, 0x80190090);
            SetErrorDetail(BDK_E_DELAYED_EXPIRE_NOT_SUPPORTED, "A delayed expire is not support unless the subscription is active with no term commits.", false, 0x80190091);
            SetErrorDetail(BDK_E_INVALID_CANCEL_DATE, "The value specified for the cancel option/date should be DELAYED_EXPIRE, UNDO_DELAYED_EXPIRE, IMMEDIATE_EXPIRE or IMMEDIATE_CANCEL.", false, 0x80190092);
            SetErrorDetail(BDK_E_INVALID_SUBSCRIPTION_ID, "Invalid subscription ID.", false, 0x80190093);
            SetErrorDetail(BDK_E_INVALID_PERIOD_TO_PROCESS, "Invalid period.", false, 0x80190094);
            SetErrorDetail(BDK_E_INVALID_SUBSCRIPTION_STATUS, "Invalid subscription status or invalid operation for the status.", false, 0x80190095);
            SetErrorDetail(BDK_E_NON_ACTIVE_ACCOUNT, "Account is inactive.", false, 0x80190096);
            SetErrorDetail(BDK_E_VATID_DOESNOTHAVEEXPDATE, "VATIDs do not have an expiration date.", false, 0x80190097);
            SetErrorDetail(BDK_E_TAXID_EXPDATE, "Expiration date was not specified.", false, 0x80190098);
            SetErrorDetail(BDK_E_INVALID_TAX_EXEMPT_TYPE, "Invalid tax exemption type.", false, 0x80190099);
            SetErrorDetail(BDK_E_INVALID_TAX_EXEMPT_BILLABLE_ACCOUNT_ID, "Invalid Tax Exempt Billable Account Id specified.", false, 0x80190100);
            SetErrorDetail(BDK_E_NO_ACTIVE_SUBSCRIPTION, "No active subscription for adding a service instance.", false, 0x80190101);
            SetErrorDetail(BDK_E_INVALID_SERVICE_INSTANCE, "Invalid service instance for adding a new user.", false, 0x80190102);
            SetErrorDetail(BDK_E_ADD_USER_TO_SERVICE_INSTANCE, "Failed to add a new user to a service instance.", false, 0x80190103);
            SetErrorDetail(BDK_E_INVALID_BILLABLEACCTSTATUS, "Status change not allowed.", false, 0x80190104);
            SetErrorDetail(BDK_E_SERVICE_INSTANCES_NONE, "No service instances available for the billable account.", false, 0x80190105);
            SetErrorDetail(BDK_E_ACCOUNT_CLOSED, "Account is already closed.", false, 0x80190106);
            SetErrorDetail(BDK_E_BILLINGPERIOD_PAST, "Period is already past.", false, 0x80190107);
            SetErrorDetail(BDK_E_INVALID_ADJUSTMENTGUID, "Invalid adjustment GUID.", false, 0x80190108);
            SetErrorDetail(BDK_E_INVALID_ADJUSMENT_FOR_PERIOD, "Adjustment not applicable to the specified period.", false, 0x80190109);
            SetErrorDetail(BDK_E_ADJUSTMENT_TOOBIG, "Adjustment amount is too large.", false, 0x80190110);
            SetErrorDetail(BDK_E_ADJUSTMENT_TOOSMALL, "Adjustment amount is too small.", false, 0x80190111);
            SetErrorDetail(BDK_E_INVALID_LOCALE, "Invalid locale.", false, 0x80190112);
            SetErrorDetail(BDK_E_INVALID_CUSTOMER_TYPE, "Invalid customer type.", false, 0x80190113);
            SetErrorDetail(BDK_E_INVALID_CURRENCY, "Invalid currency.", false, 0x80190114);
            SetErrorDetail(BDK_E_DATE_EXPIRED, "Date is already expired.", false, 0x80190115);
            SetErrorDetail(BDK_E_GUID_EXISTS, "GUID already exists.", false, 0x80190116);
            SetErrorDetail(BDK_E_INVALID_VIOLATION_ID, "Invalid violation ID.", false, 0x80190117);
            SetErrorDetail(BDK_E_MISSING_VIOLATION_ID, "Violation ID is required.", false, 0x80190118);
            SetErrorDetail(BDK_E_NEEDTODEPROVISION, "De-provision service instances before proceeding.", false, 0x80190119);
            SetErrorDetail(BDK_E_PARTIALCONV_INITIATED, "Partial conversion is already initiated.", false, 0x80190120);
            SetErrorDetail(BDK_E_CANNOT_UPDATE_CURRENCY, "The currency of the account cannot be updated.", false, 0x80190121);
            SetErrorDetail(BDK_E_PARTIALCONV_EXPECTED, "Subscription is expected to be in the partial state.", false, 0x80190122);
            SetErrorDetail(BDK_E_INVALID_CATEGORY_NAME, "Invalid category. Valid category name has a size limit of 50 characters.", false, 0x80190123);
            SetErrorDetail(BDK_E_OFFERING_NOT_PURCHASEABLE, "Offering cannot be purchased.", false, 0x80190124);
            SetErrorDetail(BDK_E_OFFERING_ACCOUNT_CURRENCY_MISMATCH, "Offering currency does not match account currency.", false, 0x80190125);
            SetErrorDetail(BDK_E_OFFERING_PAYMENT_INSTRUMENT_MISMATCH, "Offering does not support payment instrument type.", false, 0x80190126);
            SetErrorDetail(BDK_E_INVALID_DATE, "Invalid date.", false, 0x80190127);
            SetErrorDetail(BDK_E_CANNOT_EXCEED_MAX_OWNERSHIP, "Cannot exceed max ownership for the offering.", false, 0x80190128);
            SetErrorDetail(BDK_E_INVALID_RESOURCE_ID, "Invalid resource ID.", false, 0x80190129);
            SetErrorDetail(BDK_E_UNIT_OF_MEASURE_MISMATCH, "Unit of measure reported in the usage event does not match the one in SPS.", false, 0x80190130);
            SetErrorDetail(BDK_E_EVT_DATE_BEFORE_PURCHASE_DATE, "Event date is before the subscription purchase date.", false, 0x80190131);
            SetErrorDetail(BDK_E_INVALID_OFFERING_FOR_LOCALE, "Offering invalid for the locale.", false, 0x80190132);
            SetErrorDetail(BDK_E_NOT_A_BASE_OFFERING, "Offering is not a base offering.", false, 0x80190133);
            SetErrorDetail(BDK_E_FUTURE_OFFERING_PAYMENT_INSTRUMENT_MISMATCH, "There is a scheduled renewal or pending conversion to an offer that does not support that payment instrument.", false, 0x80190134);
            SetErrorDetail(BDK_E_INVALID_OFFERING_FOR_COUNTRY, "Offering is invalid for Country.", false, 0x80190135);
            SetErrorDetail(BDK_E_MEG_CONFLICT, "The offering requested conflicts with an existing subscription on this account.", false, 0x80190136);
            SetErrorDetail(BDK_E_INVALID_ACCOUNT_STATUS, "Account state does not allow this operation.", false, 0x80190137);
            SetErrorDetail(BDK_E_ACTIVE_SUBSCRIPTIONS_EXIST, "Payment instrument has active subscriptions.", false, 0x80190138);
            SetErrorDetail(BDK_E_EXISTING_BILLING_ACTIVITY, "The account has billing charges.", false, 0x80190139);
            SetErrorDetail(BDK_E_INVALID_SUBSCRIPTION_STATUS_FOR_OPERATION, "Subscription is in an invalid state for this operation.", false, 0x80190140);
            SetErrorDetail(BDK_E_PRIMARY_PHONE_REQUIRED, "Primary phone required for payment instruments.", false, 0x80190141);
            SetErrorDetail(BDK_E_EMAIL_REQUIRED, "Account requires an e-mail address for this operation.", false, 0x80190142);
            SetErrorDetail(BDK_E_ACCOUNT_NOT_CLOSED, "To perform this operation, the account should be closed.", false, 0x80190143);
            SetErrorDetail(BDK_E_INVALID_VIOLATION, "Invalid violation ID.", false, 0x80190144);
            SetErrorDetail(BDK_E_SUBSCRIPTION_IS_CANCELLED, "Subscription is cancelled and cannot change status.", false, 0x80190145);
            SetErrorDetail(BDK_E_NO_VIOLATION, "Subscription has no violations.", false, 0x80190146);
            SetErrorDetail(BDK_E_EXISTS_VIOLATION, "Subscription has violations.", false, 0x80190147);
            SetErrorDetail(BDK_E_INVALID_SERVICE_COMPONENT_ID, "Invalid Service Component Id was passed.", false, 0x80190148);
            SetErrorDetail(BDK_E_END_DATE_IN_THE_PAST, "End date is already past.", false, 0x80190149);
            SetErrorDetail(BDK_E_END_DATE_BEYOND_MAX, "End date passed in is later than the latest allowable end date for this subscription.", false, 0x80190150);
            SetErrorDetail(BDK_E_VIOLATION_ALREADY_SET, "Violation is already set.", false, 0x80190151);
            SetErrorDetail(BDK_E_NO_VIOLATION_SET, "Violation ID not set.", false, 0x80190152);
            SetErrorDetail(BDK_E_INVALID_CONVERSION, "Either there is no path between the current offering and the target offering or the path does not match the calling mode (Convert or Renew).", false, 0x80190153);
            SetErrorDetail(BDK_E_SUBS_NOT_INTERMEDIATE, "Subscription is not in the partial state.", false, 0x80190154);
            SetErrorDetail(BDK_E_OFFERING_NOT_PUBLISHED, "Offering is not published.", false, 0x80190155);
            SetErrorDetail(BDK_E_CONVERSION_NEEDTODEPROVISION, "Service instances must be de-provisioned to proceed.", false, 0x80190156);
            SetErrorDetail(BDK_E_INVALID_MANDATE_STATUS, "Invalid mandate status.", false, 0x80190157);
            SetErrorDetail(BDK_E_PI_ALREADY_GOOD, "Payment instrument status is already GOOD.", false, 0x80190158);
            SetErrorDetail(BDK_E_PI_ALREADY_DECLINED, "Payment instrument status is already DECLINED.", false, 0x80190159);
            SetErrorDetail(BDK_E_PI_IS_DISABLED, "Payment instrument status is DISABLED and cannot be changed.", false, 0x80190160);
            SetErrorDetail(BDK_E_INVOICEPI_SAP_NUMBER_REQUIRED, "SAP Number is required for Invoice PI.", false, 0x80190161);
            SetErrorDetail(BDK_E_INVALID_INVOICE_INFO_XML, "Invoice XML was invalid.", false, 0x80190162);
            SetErrorDetail(BDK_E_MAX_PI_PER_ACCOUNT_REACHED, "Max Limit for this PI Type within account reached.", false, 0x80190163);
            SetErrorDetail(BDK_E_PI_ACCOUNT_COUNTRY_MISMATCH, "PI country does not match Account country.", false, 0x80190164);
            SetErrorDetail(BDK_E_ERROR_OCCURRED_TRY_LATER, "An error occured. Try again later.", false, 0x80190165);
            SetErrorDetail(BDK_E_ERROR_OCCURRED, "An error occured.", false, 0x80190166);
            SetErrorDetail(BDK_E_INVALID_PAYMENT_INSTRUMENT_STATUS, "Payment instrument exists or the payment instrument status is invalid or does not allow the operation.", false, 0x80190167);
            SetErrorDetail(BDK_E_INVALID_OFFERING_GUID, "Invalid offering GUID.", false, 0x80190168);
            SetErrorDetail(BDK_E_OFFERING_REQUIRES_PI, "Offering requires a payment instrument.", false, 0x80190169);
            SetErrorDetail(BDK_E_DELAYED_PROVISIONING_COMPONENTS_EXIST, "Offering cannot be purchased because it has delayed provisioning components.", false, 0x80190170);
            SetErrorDetail(BDK_E_INVALID_AMOUNT_FOR_CURRENCY, "Invalid currency format.", false, 0x80190171);
            SetErrorDetail(BDK_E_INVALID_EMAIL_ADDRESS, "Invalid e-mail address.", false, 0x80190172);
            SetErrorDetail(BDK_E_INVALID_TAX_EXEMPT_STATUS, "Invalid tax exemption status.", false, 0x80190173);
            SetErrorDetail(BDK_E_NO_VALID_TAX_EXEMPTION, "No valid tax exemption certificates exist for the account.", false, 0x80190174);
            SetErrorDetail(BDK_E_INVALID_TAX_EXEMPT_STATUS_CHANGE, "Invalid tax exemption status change.", false, 0x80190175);
            SetErrorDetail(BDK_E_INVALID_OLD_PAYMENT_INSTRUMENT_STATUS, "The status of the old payment instrument does not allow this operation.", false, 0x80190176);
            SetErrorDetail(BDK_E_INVALID_START_PERIOD, "The specified start period is invalid.", false, 0x80190177);
            SetErrorDetail(BDK_E_INVALID_END_PERIOD, "The specified end period is invalid.", false, 0x80190178);
            SetErrorDetail(BDK_E_INVALID_DETAILEDLEVEL, "The specified Detailed level is invalid.", false, 0x80190179);
            SetErrorDetail(BDK_E_EXCEED_DATERANGE_LIMIT, "Difference between BeginDate and EndDate is more than 6 months", false, 0x80190180);
            SetErrorDetail(BDK_E_WRONG_DATERANGE, "Begin Date can never be greater than EndDate", false, 0x80190181);
            SetErrorDetail(BDK_E_INVALID_BEGIN_DATE, "Begin date is not valid", false, 0x80190182);
            SetErrorDetail(BDK_E_INVALID_END_DATE, "End date is not valid", false, 0x80190183);
            SetErrorDetail(BDK_E_END_DATE_GREATER_THAN_CURRENT_DATE, "End date is greater than the current date", false, 0x80190184);
            SetErrorDetail(BDK_E_COMPUTE_ONLY, "SPS is in compute-only mode.", false, 0x80190185);
            SetErrorDetail(BDK_E_MISSED_PROCESSING_PERIOD, "Detected that month(s) were missed in periodic processing.", false, 0x80190186);
            SetErrorDetail(BDK_E_SUBSCRIPTION_NOT_EXPIRED, "Subscription is not expired.", false, 0x80190187);
            SetErrorDetail(BDK_E_TOOLATE_REINSTATE, "Subscription can no longer be reinstated.", false, 0x80190188);
            SetErrorDetail(BDK_E_EXTRA_REFERRAL_DATA, "Only a single Referral node may be passed in to this API.", false, 0x80190189);
            SetErrorDetail(BDK_E_NO_REFERRAL_UPDATES_ALLOWED, "bstrReferralIDSetXML parameter must be left empty for this API.", false, 0x80190190);
            SetErrorDetail(BDK_E_FREE_SCHEDULED_RENEWAL_EXISTS, "Cannot schedule a new renewal because there exists already a free renewal on the subscription.", false, 0x80190191);
            SetErrorDetail(BDK_E_DEAL_HAS_MULTIPLE_DELAYED_COMPONENTS, "Cannot convert a deal with multiple components with delayed provisioning.", false, 0x80190192);
            SetErrorDetail(BDK_E_INVALID_COBRAND, "The specified cobrand is invalid.", false, 0x80190193);
            SetErrorDetail(BDK_E_INVALID_OPERATION_FOR_WHOLESALE_SUBSCRIPTION, "This operation is not valid for wholesale subscriptions.", false, 0x80190194);
            SetErrorDetail(BDK_E_HCI_NOT_VALID, "HCI not valid for Account Id.", false, 0x80190195);
            SetErrorDetail(BDK_E_CANT_STOP_TAIWAN_TAXINV, "Taiwan users cannot opt out of hard copy tax invoices.", false, 0x80190196);
            SetErrorDetail(BDK_E_RESOURCE_BALANCE_CHANGE_ON_NONACTIVE_SUBS, "Adjusting a resource balance is not allowed for subscriptions that are not active.", false, 0x80190197);
            SetErrorDetail(BDK_E_INVALID_TOKEN_TYPE, "The type of the token specified was invalid.", false, 0x80190198);
            SetErrorDetail(BDK_E_TOKEN_NOT_VALID_FOR_OFFERING, "The token Id specified is not valid for the given offering.", false, 0x80190199);
            SetErrorDetail(BDK_E_DEAL_TOKEN_MAPPING_NOT_PRESENT, "Deal Token mapping currently not present in the system to be marked as invalid.", false, 0x80190200);
            SetErrorDetail(BDK_E_MAXIMUM_CONSUMPTION_COUNT_PER_USER_REACHED, "Maximum consumption count per user reached.", false, 0x80190201);
            SetErrorDetail(BDK_E_INSERTING_USER_TOKEN_HASH, "Error in inserting a new row in table user_token_hash.", false, 0x80190202);
            SetErrorDetail(BDK_E_TOKEN_AND_PI_BOTH_SPECIFIED, "A token Id and a payment instrument Id cannot both be specified.", false, 0x80190203);
            SetErrorDetail(BDK_E_TOKEN_CLASS_INVALID, "The token class is invalid or does not exist.", false, 0x80190204);
            SetErrorDetail(BDK_E_INPUT_FILTER_XML_MISSING, "The Input TokenClass Restriction Info Filter is Missing.", false, 0x80190205);
            SetErrorDetail(BDK_E_TOKEN_CLASS_NOT_FOUND, "Unable to find the token mapping to the specified token class.", false, 0x80190206);
            SetErrorDetail(BDK_E_INVALID_INPUT_FILTER_XML, "Invalid TokenClass Restriction Info Filter.", false, 0x80190207);
            SetErrorDetail(BDK_E_PI_CANNOT_BE_SPECIFIED, "A payment instrument cannot be specified.", false, 0x80190208);
            SetErrorDetail(BDK_E_SUBSCRIPTION_NOT_PREPAID, "The subscription specified is not a PrePaid subscription.", false, 0x80190209);
            SetErrorDetail(BDK_E_TOTAL_EXTENSION_LESS_THAN_ZERO, "The total number of extended days cannot be less than zero.", false, 0x80190210);
            SetErrorDetail(BDK_E_INVALID_NUMBER_OF_DAYS, "The number of days specified is invalid, possibly because the subscription doesn't have that many days remaining.", false, 0x80190211);
            SetErrorDetail(BDK_E_INVALID_NUMBER_OF_MONTHS, "The number of months specified is invalid, possibly because it is negative.", false, 0x80190212);
            SetErrorDetail(BDK_E_TOTAL_EXTENSION_GREATER_THAN_MAX, "The total number of extended days is greater than the maximum allowed for the current subscription.", false, 0x80190213);
            SetErrorDetail(BDK_E_PREPAID_TOKEN_IS_REQUIRED, "The deal specified requires a valid Prepaid Token Id to be specified.", false, 0x80190214);
            SetErrorDetail(BDK_E_TERM_COMMIT_EXISTS, "There are remaining cycles on the current term commit.", false, 0x80190215);
            SetErrorDetail(BDK_E_TOKEN_NOT_APPLICABLE, "The specified token cannot be used for the current operation.", false, 0x80190216);
            SetErrorDetail(BDK_E_TOKEN_RENEWAL_PRESENT, "Renewal cannot be scheduled if there is already a token based renewal present.", false, 0x80190217);
            SetErrorDetail(BDK_E_EXCEEDS_MAXIMUM_DURATION, "Error subscription duration exceeds max duration.", false, 0x80190218);
            SetErrorDetail(BDK_E_CONVERSION_CREDITS_NOT_ENABLED, "Error conversion credits were applied but the offer does not support conversion credits.", false, 0x80190219);
            SetErrorDetail(BDK_E_INVALID_USERROLE_FOR_ADDPI, "Only BillableAccountAdmin can add the PI.", false, 0x80190220);
            SetErrorDetail(BDK_E_NOT_AUTHORIZED_TAX_RULE_CONFIG_GROUP, "Not authorized to use the tax rule configuration group.", false, 0x80190221);
            SetErrorDetail(BDK_E_BLACKLIST_ACTION_NOT_PERFORMED, "BlacklistToken found actions to take, but BSTRSubscriptionAction was set to DONOTHING.", false, 0x80190222);
            SetErrorDetail(BDK_E_INVALID_SUBSCRIPTION_ACTION, "BlacklistToken was called with invalid bstrSubscriptionAction parameter.", false, 0x80190223);
            SetErrorDetail(BDK_E_TOKEN_DISTRIBUTION_CHANNEL_NOT_FOUND, "Invalid distribution channel specified for token class part number.", false, 0x80190224);
            SetErrorDetail(BDK_E_INVALID_LEN_PART_NUMBER, "Invalid length for token class part number.", false, 0x80190225);
            SetErrorDetail(BDK_E_INVALID_LEN_SAP_CUST_NAME, "nvalid length for SAP customer name.", false, 0x80190226);
            SetErrorDetail(BDK_E_INVALID_LEN_SUPPORT_VENDOR_NAME, "Invalid length for Support Vendor name.", false, 0x80190227);
            SetErrorDetail(BDK_E_INSERING_TOKEN_CLASS_PARTNER, "Failed while inserting in partner_token_class table.", false, 0x80190228);
            SetErrorDetail(BDK_E_TOKEN_PART_NUMBER_ASSOC_WITH_OTHER_TOKEN_CLASS, "Token Part Number is currently associated with other token class please remove the association from the other token class and try again.", false, 0x80190229);
            SetErrorDetail(BDK_E_TOKEN_ALREADY_DELIVERED, "A token is being delivered to the same service instance at this moment. Please retry.", false, 0x80190230);
            SetErrorDetail(BDK_E_TOKEN_DISTRIBUTION_BATCH_INVALID, "A Token passed in does not have an associated Distribution batch.", false, 0x80190231);
            SetErrorDetail(BDK_E_TOKEN_DISTRIBUTION_BATCH_INACTIVE, "A Distribution Batch associated with the passed in Token is in inactive state.", false, 0x80190232);
            SetErrorDetail(BDK_E_DISTRIBUTION_PROGRAM_INACTIVE, "A Distribution Program is in inactive state.", false, 0x80190233);
            SetErrorDetail(BDK_E_INSERTING_RECONCILE_HISTORY, "Failed while inserting in reconcile_history table.", false, 0x80190234);
            SetErrorDetail(BDK_E_TOKEN_ALREADY_ISSUED, "Specified Token is already issued.", false, 0x80190235);
            SetErrorDetail(BDK_E_TOKEN_ALREADY_UNISSUED, "Specified Token is already unissued, can not unissue the same token again.", false, 0x80190236);
            SetErrorDetail(BDK_E_TOKEN_ISSUE_UPDATE, "Failed to update the token issue status in token_instance table.", false, 0x80190237);
            SetErrorDetail(BDK_E_INVALID_COMBINATION, "The input parameter combination does not match the system.", false, 0x80190238);
            SetErrorDetail(BDK_E_INVALID_REPLACEMENT_REASON_CODE, "Invalid Replacement Reason code specified.", false, 0x80190239);
            SetErrorDetail(BDK_E_MAX_REPLACEMENT_REACHED, "The request failed because the maximum number of replacements for this sequence number have exceeded the threshold value.", false, 0x80190240);
            SetErrorDetail(BDK_E_TOKEN_REPLACEMENT_FAILED, "Token Replacement failed due to unknown error.", false, 0x80190241);
            SetErrorDetail(BDK_E_TOKEN_DISTRIBUTION_STATUS_UPDATE, "Failed to update Token Distribution status.", false, 0x80190242);
            SetErrorDetail(BDK_E_SIGNATURE_TOKEN_MISMATCH, "Signature does not belong to specified Token.", false, 0x80190243);
            SetErrorDetail(BDK_E_INVALID_STATUS_NAME, "Invalid Token Staus Name specified.", false, 0x80190244);
            SetErrorDetail(BDK_E_INVALID_TOKEN_DISTRIBUTION_STATUS, "Invalid distribution status to issue token.", false, 0x80190245);
            SetErrorDetail(BDK_E_ALREADY_REPLACED_TOKEN, "Specified token is replaced token, can not provide replacement for Replaced Token.", false, 0x80190246);
            SetErrorDetail(BDK_E_TOKEN_ACTION_ACCESS_DENIED, "Invalid Partner specified or the partner does not have permission to take action on specified token.", false, 0x80190247);
            SetErrorDetail(BDK_E_NOT_EXISTS_PARTNER, "Specified partner does not exist.", false, 0x80190248);
            SetErrorDetail(BDK_E_DUPLICATED_PKPN_WITH_PCT, "Specified reseller PKPN is duplicated with the existing PKPN configured by PCT.", false, 0x80190249);
            SetErrorDetail(BDK_E_NOT_EXISTS_PKPN, "Specified reseller token part number does not exist.", false, 0x80190250);
            SetErrorDetail(BDK_E_RESELLER_TOKEN_BLACKLISTED, "Specified reseller token instance has already been blacklisted.", false, 0x80190251);
            SetErrorDetail(BDK_E_RESELLER_TOKEN_CONSUMED, "Specified reseller token instance has already been consumed.", false, 0x80190252);
            SetErrorDetail(BDK_E_SERVER_INTERNAL_ERROR, "Server internal error occurred.", false, 0x80190253);
            SetErrorDetail(BDK_E_DUPLICATED_CHANNELSKU_WITH_PCT, "Specified reseller channel SKU is duplicated with the existing channel SKU configured by PCT.", false, 0x80190254);
            SetErrorDetail(BDK_E_CHANNELSKU_PKPN_PERCENTAGE_CANNOT_UPDATE, "Percentage on ChannelSKU-PKPN mapping cannot be updated.", false, 0x80190255);
            SetErrorDetail(BKE_E_CHANNELSKU_PKPN_MAPPING_CANNOT_ADD, "ChannelSKU-PKPN mappings cannot be added after setup.", false, 0x80190256);
            SetErrorDetail(BDK_E_INVALID_PKPN_ALLOCATION, "Sum of all PKPNs' percentage under one channel sku should be less than or equal 1.", false, 0x80190257);
            SetErrorDetail(BDK_E_EXCEEDS_MAX_TOKEN_INSTANCE, "The input token number in batch exceeds max allowerd number.", false, 0x80190258);
            SetErrorDetail(BDK_E_BAD_RETURN_STATEMENT_SET_INDICATOR, "Value for returnStatementSet parameter must be 0, 1, or 2.", false, 0x80190259);
            SetErrorDetail(BDK_E_BAD_BEGIN_BILLING_PERIOD, "The begin billing period is not valid for this account.", false, 0x80190260);
            SetErrorDetail(BDK_E_INVALID_END_BILLING_PERIOD, "The end billing period is not valid for this account.", false, 0x80190261);
            SetErrorDetail(BDK_E_BILLING_PERIOD_NEGATIVE, "The billing period value cannot be negative.", false, 0x80190262);
            SetErrorDetail(BDK_E_BAD_START_END_BILLING_PERIOD, "The end period must be greater than start period.", false, 0x80190263);
            SetErrorDetail(BDK_E_CURRENT_DATE_LESS_THAN_ACCOUNT_HISTORY_DATE, "The account history date cannot be greater than the current date.", false, 0x80190264);
            SetErrorDetail(BDK_E_NO_NON_NULL_PARAMS, "Cannot pass null for all parameters.", false, 0x80190265);
            SetErrorDetail(BDK_E_INVALID_SUBSCRIPTION_BILLING_PERIOD, "The billing period value must be of the format YYYYMM (Y representing the year and M representing month).", false, 0x80190266);
            SetErrorDetail(BDK_E_BILLING_PERIOD_GREATER_THAN_SUBSCRIPTION_DURATION, "The billing period value cannot be greater than the subscription duration (i.e. past subscription expiration).", false, 0x80190267);
            SetErrorDetail(BDK_E_MISMATCH_SUB_ID_OFFER_GUID, "The offering guid passed in does not match offering guid on subscription.", false, 0x80190268);
            SetErrorDetail(BDK_E_EVENT_TIMESTAMP_IN_THE_FUTURE, "The event time stamp is too far in future.", false, 0x80190269);
            SetErrorDetail(BDK_E_INVALID_POLICY_ID, "The policy GuidID/Version combination supplied does not exist.", false, 0x80190270);
            SetErrorDetail(BDK_E_OFFERING_PI_COUNTRY_MISMATCH, "The offering specified does not support the country of payment instrument being used.", false, 0x80190271);
            SetErrorDetail(BDK_E_INSERT_AGREEMENT_SIGNATURE, "Error inserting into table agreement_signature.", false, 0x80190272);
            SetErrorDetail(BDK_E_AGREEMENT_ALREADY_SIGNED, "Agreement for this subscription has already been signed by this user at a different time.", false, 0x80190273);
            SetErrorDetail(BDK_E_LOCALE_NOT_SUPPORTED_FOR_POLICY, "The specified policy has not been localized in the specified locale.", false, 0x80190274);
            SetErrorDetail(BDK_E_POLICY_DEAL_VERSION_MISMATCH, "The policy specified is valid but the version is incorrect.", false, 0x80190275);
            SetErrorDetail(BDK_E_POLICY_DEAL_COUNTRY_MISMATCH, "The policy specified exists but is not valid on the deal/country combination of the supplied subscription.", false, 0x80190276);
            SetErrorDetail(BDK_E_CANNOT_CONVERT_BACK_TO_WHOLESALE, "The subscription was previously a wholesale subscription which was converted to a direct subscription and is now trying to be converted to wholesale again.  This is not allowed.", false, 0x80190277);
            SetErrorDetail(BDK_E_CANNOT_SPECIFY_PI_DURING_RENEW, "A payment instrument cannot specified when the conversion mode is RENEW.", false, 0x80190278);
            SetErrorDetail(BDK_E_NO_RENEWAL_FROM_PERPETUAL_OFFERING, "Renewing from a perpetual offering is not allowed.", false, 0x80190279);
            SetErrorDetail(BDK_E_INVALID_TECERTIFICATENUMBER, "Tax Exempt Certificate Number is invalid.", false, 0x80190280);
            SetErrorDetail(BDK_E_NO_WHOLESALE_TO_WHOLESALE, "Conversions between wholesale offers are not allowed.", false, 0x80190281);
            SetErrorDetail(BDK_E_INVALID_NEW_PAYMENT_INSTRUMENT_STATUS, "The status of the new payment instrument specified does not allow this operation.", false, 0x80190282);
            SetErrorDetail(BDK_E_INVALID_RENEWAL, "Renewal does not exist.", false, 0x80190283);
            SetErrorDetail(BDK_E_ERROR_PHONE_STRING_TOOLONG, "The length of phone number is greater than expected.", false, 0x80190284);
            SetErrorDetail(BDK_E_ERROR_TOKEN_CLASS_ACCESS_DENIED, "The calling partner does not have access to the token class.", false, 0x80190285);
            SetErrorDetail(BDK_E_LAST_ADMIN_ROLE, "Last administrator role on the account cannot be removed.", false, 0x80190286);
            SetErrorDetail(BDK_E_PUID_USED_AS_BILLABLEACCOUNTADMIN, "The PUID is already being used as BillableAccountAdmin.", false, 0x80190287);
            SetErrorDetail(BDK_E_UPDATING_MEMBERNAME, "Error updating member name.", false, 0x80190288);
            SetErrorDetail(BDK_E_OBJECT_ROLE_LIMIT_EXCEEDED, "Object can have a maximum of 2000 roles.", false, 0x80190289);
            SetErrorDetail(BDK_E_ACCOUNT_DELADMIN_ROLE_EXCEEDED, "The allowable number of the delegate admins for an account has reached its limit.", false, 0x80190290);
            SetErrorDetail(PROVISION_E_MALFORMED_REQUEST, "Provisioning: Provision request malformed.", false, 0x80190291);
            SetErrorDetail(PROVISION_E_WRONG_INPUT_PARAMETERS, "Provisioning: Wrong input parameters.", false, 0x80190292);
            SetErrorDetail(PROVISION_E_MPF_CALL_FAILED, "Provisioning: Microsoft Provisioning Framework call failed. %1", false, 0x80190293);
            SetErrorDetail(PROVISION_E_XML_OPERATION_ERROR, "Provisioning: Error during XML manipulation. %1", false, 0x80190294);
            SetErrorDetail(PROVISION_E_MPF_CREATE, "Provisioning: MPF client instantiation failed. %1", false, 0x80190295);
            SetErrorDetail(PROVISION_E_CREATION, "Provisioning: General error in startup code. %1", false, 0x80190296);
            SetErrorDetail(BDK_E_EXCEEDS_MAX_NUMBER_OF_SERVICE_INSTANCE_REQUESTS, "The number of service instances in the provisioning request exceeds the configured limit.", false, 0x80190297);
            SetErrorDetail(BDK_E_DBBADZIP, "Invalid ZIP code.", false, 0x80190298);
            SetErrorDetail(BDK_E_REQUIRED_FIELD_MISSING_DUE_TO_SUBSCRIPTIONS, "The account has subscription(s) in non-cancelled state that require information that you are attempting to remove.", false, 0x80190299);
            SetErrorDetail(BDK_E_ADDITIONAL_ACCOUNT_DATA_REQUIRED, "The account requires additional attributes before performing the operation.", false, 0x80190300);
            SetErrorDetail(BDK_E_ACCT_ALREADY_REFERRED, "The referrer has already reffered the customer to this offer.", false, 0x80190301);
            SetErrorDetail(BDK_E_REWARD_OFFER_NOT_PURCHASABLE, "There are no reward offers currently available in the system.", false, 0x80190302);
            SetErrorDetail(BDK_E_AGREEMENT_NOT_SIGNED, "Need to sign the agreement before continuing with the call.", false, 0x80190303);
            SetErrorDetail(BDK_E_ITEM_VIOLATION_EXISTS, "The user has a violation on their payment instrument.", false, 0x80190304);
            SetErrorDetail(BDK_E_DYNAMIC_TITLE_AND_CATEGORY_CONFIGURATION, "Title and/or category is not allowed for this offer.", false, 0x80190305);
            SetErrorDetail(BDK_E_PENDING_TRANSACTION, "Account has a pending transaction.", false, 0x80190306);
            SetErrorDetail(BDK_E_INCREMENT_TOTAL, "Cannot update total.", false, 0x80190307);
            SetErrorDetail(BDK_E_RES_NOT_BELONG_TO_OBJECT, "Resource does not belong to this object id.", false, 0x80190308);
            SetErrorDetail(BDK_E_DECLINING_BALANCE, "Payment instrument on the current subscription has a declining balance.", false, 0x80190309);
            SetErrorDetail(BDK_E_DUPLICATE_TRACKING_GUID, "Duplicate tracking GUID.", false, 0x80190310);
            SetErrorDetail(BDK_E_INVALID_EXPIRATION_DATE, "Invalid credit card expiration date.", false, 0x80190311);
            SetErrorDetail(BDK_E_UNKNOWN_MANDATE_STATUS, "Invalid mandate status.", false, 0x80190312);
            SetErrorDetail(BDK_E_INVALID_PAYMENT_METHOD_TYPE, "Payment method of this type can't support the action", false, 0x80190313);
            SetErrorDetail(BDK_E_INVALID_CURRENCY2, "Invalid input currency.", false, 0x80190314);
            SetErrorDetail(BDK_E_INVALID_AMOUNT, "Invalid amount passed in as argument.", false, 0x80190315);
            SetErrorDetail(BDK_E_INVALID_BILLING_PERIOD, "Invalid billing period.", false, 0x80190316);
            SetErrorDetail(BDK_E_INVALID_ANNIV, "Invalid billing anniversary date.", false, 0x80190317);
            SetErrorDetail(BDK_E_INVALID_LINEITEM_ID, "Invalid line item ID.", false, 0x80190318);
            SetErrorDetail(BDK_E_INVALID_LINEITEM_STATUS, "Invalid line item status.", false, 0x80190319);
            SetErrorDetail(BDK_E_INVALID_EVENT_TYPE, "The event type of the line item is invalid for this operation.", false, 0x80190320);
            SetErrorDetail(BDK_E_LINE_ITEM_ID_NOT_OPEN, "Line item ID not associated with an open record.", false, 0x80190321);
            SetErrorDetail(BDK_E_LINEITEM_ALREADY_OFFSET, "Line item has already been offset.", false, 0x80190322);
            SetErrorDetail(BDK_E_LINEITEM_ALREADY_CHARGED_BACK, "Line item has already been Charged back.", false, 0x80190323);
            SetErrorDetail(BDK_E_INVALID_OFFSET_AMOUNT, "Offset amount must be greater than zero but less than or equal to original amount. %1", false, 0x80190324);
            SetErrorDetail(BDK_E_CANNOT_OFFSET_HARD_SOFT_DECLINED, "Cannot offset line item that is soft- or hard-declined.", false, 0x80190325);
            SetErrorDetail(BDK_E_LINEITEM_ALREADY_CROSS_TRANSFERED, "Cannot offset line item which is cross SA and BSS transfered.", false, 0x80190326);
            SetErrorDetail(BDK_E_AMOUNT_NOT_COLLECTED_YET, "Amount has not been collected, so it cannot be offset and immediately settled.", false, 0x80190327);
            SetErrorDetail(BDK_E_CANNOT_OFFSET_ZERO_AMOUNT, "Cannot offset line item amount of zero.", false, 0x80190328);
            SetErrorDetail(BDK_E_AMOUNT_IN_PROCESS, "The operation cannot be completed because an amount involved is in the process of being sent to the bank for collection.", false, 0x80190329);
            SetErrorDetail(BDK_E_INVALID_CREDIT_AMOUNT, "Credit amount should not be zero.", false, 0x80190330);
            SetErrorDetail(BDK_E_CREDIT_AMOUNT_OVER_LIMIT, "Credit amount should not exceed the limit.", false, 0x80190331);
            SetErrorDetail(BDK_E_INVALID_AMOUNT_FOR_CURRENCY_2, "The requested currency(JPY,KRW,TWD etc.) does not support decimals.", false, 0x80190332);
            SetErrorDetail(BDK_E_DUPLICATE_EVENT_ID, "Same event id already been used, please create a new event id and retry.", false, 0x80190333);
            SetErrorDetail(BDK_E_OFFSET_IMM_SETTLE_IN_PROG, "Line items in the immediate_settle_in_progress state cannot be offset.", false, 0x80190334);
            SetErrorDetail(BDK_E_SA_IN_STATE_UNOFFSETABLE, "Line item with this settlement amount status cannot be offset.", false, 0x80190335);
            SetErrorDetail(BDK_E_SA_IN_STATE_UNESCHEATABLE, "this settlement amount status cannot be escheated.", false, 0x80190336);
            SetErrorDetail(BDK_E_OFFSET_AMOUNT_GREATER_THAN_ORIGINAL, "Offset amount should never exceed the original item amount.", false, 0x80190337);
            SetErrorDetail(BDK_E_RES_BALANCE_CHANGE_ON_NONACTIVE_SUBS, "The subscription is not active. The resource usage event is still being reported for the subscription.", false, 0x80190338);
            SetErrorDetail(BDK_E_PI_IN_DECLINE, "the payment instrument already has declines on it", false, 0x80190339);
            SetErrorDetail(BDK_E_SA_IN_INTERMEDIATE_STATUS, "The operation is not allowed when there are Settlement Amounts in intermediate status.", false, 0x80190340);
            SetErrorDetail(BDK_E_INVALID_SETTLEMENT_AMOUNT_ID, "The specified settlement amount id is invalid.", false, 0x80190341);
            SetErrorDetail(BDK_E_MISMATCH_RATED_USAGE_TOTAL, "This thread has an out-dated usage total it is trying to rate and write a billing transaction for threshold billing.", false, 0x80190342);
            SetErrorDetail(BDK_E_BAD_RETURN_STATEMENT_SET_INDICATOR2, "Value for returnStatementSet parameter must be 0, 1, or 2.", false, 0x80190343);
            SetErrorDetail(BDK_E_ARITHMETIC_OVERFLOW_FOR_ADD_OR_UPDATE_USAGE, "%1", false, 0x80190344);
            SetErrorDetail(BDK_E_REFUND_LINEITEM_NOT_SETTLED, "Refund failed - line item was offset but original line item was never settled.", false, 0x80190345);
            SetErrorDetail(BDK_E_RESOURCE_BALANCE_INACTIVE, "Specified resource balance has already been billed.", false, 0x80190346);
            SetErrorDetail(BDK_E_INVALID_NUMBER_OF_UNITS, "The number of units specified is invalid.", false, 0x80190347);
            SetErrorDetail(BDK_E_INVALID_USAGE_CATEGORY, "Usage category does not exist for this resource.", false, 0x80190348);
            SetErrorDetail(BDK_E_INSUFFICIENT_PREPAID_BALANCE, "The prepaid resource balance is not sufficient for this usage event.", false, 0x80190349);
            SetErrorDetail(BDK_E_INVALID_FINANCIAL_REASON_CODE, "Financial reason code does not exist.", false, 0x80190350);
            SetErrorDetail(BDK_E_OFFSET_OF_OFFSET_NOT_PERMITTED, "Offset of offset is not permitted through this API.", false, 0x80190351);
            SetErrorDetail(BDK_E_DONOTSHOWOFFSET_MISMATCHED_AMOUNT, "If offset is not to be shown by getstatement, the offset amount must match the original amount.", false, 0x80190352);
            SetErrorDetail(BDK_E_INVALID_FIN_REASON_CODE_FOR_OFFSET, "Invalid financial reason code passed for the offset usage API.", false, 0x80190353);
            SetErrorDetail(BDK_E_EVENT_ACTION_NOT_OFFSETTABLE, "The line item is associated with a non-offsettable event action.", false, 0x80190354);
            SetErrorDetail(BDK_E_IMMEDIATE_SETTLE_OF_USAGE_NOT_PERMITTED, "Action is not permitted for immediate settle of usage offers.", false, 0x80190355);
            SetErrorDetail(BDK_E_RESOURCE_OFFSET_ONLY_ALLOWED_FOR_USAGE, "Resource offset is only allowed for usage.", false, 0x80190356);
            SetErrorDetail(BDK_E_ERROR_PP_INVALID_TAX_REFUND_CODE, "Invalid Tax Refund Code.", false, 0x80190357);
            SetErrorDetail(BDK_E_DUPLICATE_TRANSACTION_CONFIRMATION_NUMBER, "The transaction confirmation number is already used on the account.", false, 0x80190358);
            SetErrorDetail(BDK_E_TRANSACTION_NOT_EXIST, "The transaction does not exist.", false, 0x80190359);
            SetErrorDetail(BDK_E_INVALID_CUMULATIVE_AMOUNT, "Invalid combination of cumulative authorized amount and cumulative reversed amount.", false, 0x80190360);
            SetErrorDetail(BDK_E_TRANSACTION_EVENT_UNKNOWN, "The transaction event code is unknown.", false, 0x80190361);
            SetErrorDetail(BDK_E_TRANSACTION_EVENT_INCONSISTENT, "The transaction event code is not consistent.", false, 0x80190362);
            SetErrorDetail(BDK_E_INVALID_SEQUENCE_NUMBER, "Invalid sequence number reported in transaction event.", false, 0x80190363);
            SetErrorDetail(BDK_E_INVALID_VENDOR_TRANSACTION_ID, "Invalid vendor internal transaction id.", false, 0x80190364);
            SetErrorDetail(BDK_E_INVALID_REJECTION_REASON_CODE, "Invalid rejection reason code.", false, 0x80190365);
            SetErrorDetail(BDK_E_INVALID_TRANSACTION_STATUS, "Invalid transaction status.", false, 0x80190366);
            SetErrorDetail(BDK_E_INVALID_CUMULATIVE_TAX_AMOUNT, "Invalid combination of cumulative authorized tax amount and cumulative reversed tax amount.", false, 0x80190367);
            SetErrorDetail(BDK_E_UNKNOWN_MERCHANT_ID, "Invalid merchant id.", false, 0x80190368);
            SetErrorDetail(BDK_E_TRANSACTION_ALREADY_CANCELLED, "Transaction has already been cancelled.", false, 0x80190369);
            SetErrorDetail(BDK_E_PMN_INSERT_FAILURE, "Passport member name could not be added.", false, 0x80190370);
            SetErrorDetail(BDK_E_BADSAMECARDUSEDMULTIPLETIMES, "Payment card number has been used multiple times.", false, 0x80190371);
            SetErrorDetail(BDK_E_PI_ALREADY_ON_ACCOUNT, "Payment instrument already assigned to account.", false, 0x80190372);
            SetErrorDetail(BDK_E_PUID_ROLE_LIMIT_EXCEEDED, "Passport ID can have a maximum of 100 roles.", false, 0x80190373);
            SetErrorDetail(BDK_E_TOOMANY_FDE_PURCHASES, "Too many fraud enticing purchases on the payment instrument", false, 0x80190374);
            SetErrorDetail(BDK_E_TAX_ID_ASSOCIATION_LIMIT_EXCEEDED, "Passport PUIDs associated with this tax Id has already reaches the maximum limit.", false, 0x80190375);
            SetErrorDetail(BDK_E_NOPERMISSION, "Access denied.", false, 0x80190376);
            SetErrorDetail(BDK_E_CANNOT_REMOVE_SELF, "Cannot remove self from object.", false, 0x80190377);
            SetErrorDetail(BDK_E_BADXML, "XML is either malformed or incorrect for this API.", false, 0x80190378);
            SetErrorDetail(BDK_E_INVALIDCOMMENTSIZE, "Comment text length must be between 1 and 512 characters.", false, 0x80190379);
            SetErrorDetail(BDK_E_BADCANCELMODE, "Invalid cancellation mode.", false, 0x80190380);
            SetErrorDetail(BDK_E_INVALID_BUF_SIZE, "Input parameter is the wrong size.", false, 0x80190381);
            SetErrorDetail(BDK_E_INVALID_ROLE, "Invalid role.", false, 0x80190382);
            SetErrorDetail(BDK_E_INVALID_PPORT_ID, "Invalid Passport ID.", false, 0x80190383);
            SetErrorDetail(BDK_E_INVALID_ARG, "Invalid argument.", false, 0x80190384);
            SetErrorDetail(BDK_E_UNKNOWN_SERVER_FAILURE, "Unknown server failure. API name: %2, Error code: 0x%3, Error description: %1.", false, 0x80190385);
            SetErrorDetail(BDK_E_INVALID_STATUS_VALUE, "Status must be ENABLED or SUSPENDED.", false, 0x80190386);
            SetErrorDetail(BDK_E_INVALID_FILTER, "Filter must be BASE, UPGRADE, DOWNGRADE, RENEWAL, or empty.", false, 0x80190387);
            SetErrorDetail(BDK_E_MISSING_CATEGORY, "Missing category.", false, 0x80190388);
            SetErrorDetail(BDK_E_FIELD_TOO_SHORT, "Input field is too short.", false, 0x80190389);
            SetErrorDetail(BDK_E_FIELD_TOO_LONG, "Input field is too long.", false, 0x80190390);
            SetErrorDetail(BDK_E_BADZIP, "Invalid ZIP code.", false, 0x80190391);
            SetErrorDetail(BDK_E_ONLYONENODE, "Only one of these nodes should be passed.", false, 0x80190392);
            SetErrorDetail(BDK_E_INVALID_FIELD_LENGTH, "Input field length does not meet requirement.", false, 0x80190393);
            SetErrorDetail(BDK_E_CSR_AUTHZ_FAILED, "Only customer service representatives can invoke this API.", false, 0x80190394);
            SetErrorDetail(BDK_E_NOT_ACCOUNT_ADMIN, "Caller is not an account administrator.", false, 0x80190395);
            SetErrorDetail(BDK_E_DELEGATE_ID_UNSPECIFIED, "Delegate ID entered was invalid or not specified.", false, 0x80190396);
            SetErrorDetail(BDK_E_REQUESTER_ID_UNSPECIFIED, "Requester Passport ID must be specified.", false, 0x80190397);
            SetErrorDetail(BDK_E_INVALID_FLAG_VALUE, "Boolean value must be 0 or 1", false, 0x80190398);
            SetErrorDetail(BDK_E_PROVISIONING_INACTIVE_SUBSCRIPTION, "Subscription service instance is inactive.", false, 0x80190399);
            SetErrorDetail(BDK_E_INVALID_OBJECT_ID, "Invalid object.", false, 0x80190400);
            SetErrorDetail(BDK_E_INVALID_FIRSTNAME_FIELD_LENGTH, "Input field length of first name does not meet requirement.", false, 0x80190401);
            SetErrorDetail(BDK_E_INVALID_LASTNAME_FIELD_LENGTH, "Input field length of last name does not meet requirement.", false, 0x80190402);
            SetErrorDetail(BDK_E_INVALID_ADDRESS_FIELD_LENGTH, "Input field length of address does not meet requirement.", false, 0x80190403);
            SetErrorDetail(BDK_E_PARTNERNOTINBILLING, "Calling partner is not registered in SPS database.", false, 0x80190404);
            SetErrorDetail(BDK_E_RATING_FAILURE, "Rating error has occurred. Check the event log and the tracer.", false, 0x80190405);
            SetErrorDetail(BDK_SVR2_STARTED, "BDKSVR2 started.", false, 0x80190406);
            SetErrorDetail(BDK_CSR_API_CALL_MADE, "CSR call made.", false, 0x80190407);
            SetErrorDetail(BDK_E_CSR_CALL_FROM_NONCSR, "CSR call attempt by non-CSR caller.", false, 0x80190408);
            SetErrorDetail(BDK_E_TRANS_BALANCE_MISMATCHING_ACCTS, "From and to payment instrument are not on the same account in TransferBalance.", false, 0x80190409);
            SetErrorDetail(BDK_E_TRANS_BALANCE_TO_PI_INVALID, "Invalid to payment instrument in TransferBalance.", false, 0x80190410);
            SetErrorDetail(BDK_E_TRANS_BALANCE_TO_SAME_PI, "Cannot transfer to same payment instrument in TransferBalance.", false, 0x80190411);
            SetErrorDetail(BDK_E_TRANS_BALANCE_NOT_ALLOW, "Cannot transfer balances between payment instrument types.", false, 0x80190412);
            SetErrorDetail(BDK_E_INTERNAL_ERROR, "Internal database inconsistencies detected.", false, 0x80190413);
            SetErrorDetail(BDK_E_OUTSTANDING_BALANCE, "Payment instrument has outstanding balance.", false, 0x80190414);
            SetErrorDetail(BDK_E_INVALID_REFERRALDATA_XML, "Invalid  data passed in ReferralData node. Verify that the node exists and that it contains valid XML (1-1024 characters).", false, 0x80190415);
            SetErrorDetail(BDK_E_INVALID_GUID, "Invalid GUID.", false, 0x80190416);
            SetErrorDetail(E_UNSUPPORTED_PAYMENT_INSTRUMENT, "Payment instrument type not supported for SettleBalance.", false, 0x80190417);
            SetErrorDetail(BDK_E_SUBSCRIPTION_INACTIVE, "Subscription is inactive.", false, 0x80190418);
            SetErrorDetail(BDK_E_INVALID_PM_FOR_STOP_PAYMENTS, "Payments can only be stopped for credit card and direct debit transactions.", false, 0x80190419);
            SetErrorDetail(BDK_E_EXCEEDS_MAX_NUMBER_OF_USAGE_EVENTS, "Excessive number of usage events reported in one ReportUsageEvent() call.", false, 0x80190420);
            SetErrorDetail(BDK_E_FIELD_NOT_UPDATEABLE, "Field cannot be updated.", false, 0x80190421);
            SetErrorDetail(BDK_E_DEFERRED_COMPUTE_ONLY_NOT_SUPPORTED, "Calling CancelSubscription with an end date and in compute-only mode is not supported.", false, 0x80190422);
            SetErrorDetail(BDK_E_SETTLE_SHOULD_BE_THE_LAST_EVENT, "The SETTLE event should be the last event in the event list for ImportSettleBillingItems.", false, 0x80190423);
            SetErrorDetail(BDK_E_PAYMENT_METHOD_NO_LONGER_VALID, "Line item payment method is no longer valid.", false, 0x80190424);
            SetErrorDetail(BDK_E_PROCESS_USAGE_EVENTS, "Failed to process all usage events.", false, 0x80190425);
            SetErrorDetail(BDK_E_WRONG_OBJECT_ID_TYPE, "Object ID does not contain account and subscription information.", false, 0x80190426);
            SetErrorDetail(BDK_E_INVALID_PHONE_VALUE, "Field contains invalid characters for a phone number.", false, 0x80190427);
            SetErrorDetail(BDK_E_INVALID_AMOUNT_VALUE, "Invalid amount.", false, 0x80190428);
            SetErrorDetail(BDK_E_MISMATCH_ACCTID_IN_CLOSEBALANCE, "Payment instrument ID and line item ID do not match.", false, 0x80190429);
            SetErrorDetail(BDK_E_INTERNAL_ADD_COMMENT_FAILED, "InternalAddComment failed. Escalate error to SPG development.", false, 0x80190430);
            SetErrorDetail(BDK_E_INVALID_IMMEDIATE_SETTLE_VALUE, "Immediate settle flag value not supported.", false, 0x80190431);
            SetErrorDetail(BDK_E_NO_RECORDS_FOR_STOP_PAYMENTS, "No eligible records were found for this call.", false, 0x80190432);
            SetErrorDetail(BDK_E_FAILED_SETTLEMENT_AMOUNT_UPDATE, "Failed to update the settlement amount table with credit card authorization results. This needs to be escalated to SPG development.", false, 0x80190433);
            SetErrorDetail(BDK_E_INVALID_TELENUMERIC_STRING, "The supplied telenumeric string does not consist of digits exclusively or exceeds the maximum limit.", false, 0x80190434);
            SetErrorDetail(BDK_E_NO_MATCH, "There are no matches for the requested information.", false, 0x80190435);
            SetErrorDetail(BDK_E_MULTIPLE_MATCHES, "There are multiple matches for the requested information.", false, 0x80190436);
            SetErrorDetail(BDK_E_BAD_PUID, "PUID entered was invalid.", false, 0x80190437);
            SetErrorDetail(BDK_E_BAD_OBJECT_ID_LENGTH, "ObjectId length must be 16.", false, 0x80190438);
            SetErrorDetail(BDK_E_END_PERIOD_LESS_THAN_START_PERIOD, "Start period can never be greater than End period.", false, 0x80190439);
            SetErrorDetail(BDK_E_BAD_BILLING_PERIOD_LENGTH, "Billing period length must be 6.", false, 0x80190440);
            SetErrorDetail(BDK_E_BAD_RETURN_STATEMENT_SET, "Value for returnStatementSet parameter for GetStatement API must be 0, 1, or 2 while for GetStatementEx API must be 0, 1, 2, or 3.", false, 0x80190441);
            SetErrorDetail(BDK_E_INVALID_USAGE_EVENT_DATE, "The usage event date specified was invalid.  One possible reason is that it is too far in the future.", false, 0x80190442);
            SetErrorDetail(BDK_E_NULL_DEFAULT_BILLING_PERIOD, "The default billing period returned was null, cannot proceed. This could be due to the current date time being less than the account creation date.", false, 0x80190443);
            SetErrorDetail(BDK_E_BAD_START_BILLING_PERIOD, "The start billing period is less than the currently available billing period.", false, 0x80190444);
            SetErrorDetail(BDK_E_BAD_END_BILLING_PERIOD, "The end billing period is less than the currently available billing period.", false, 0x80190445);
            SetErrorDetail(BDK_E_NEW_DUE_DATE_IS_PAST, "The new due date is in the past", false, 0x80190446);
            SetErrorDetail(BDK_E_NEW_DUE_DATE_THRESHOLD_PASSED, "The new due date is more than MAXIMUM DELAY days in the future than the original due date", false, 0x80190447);
            SetErrorDetail(BDK_E_NO_NEW_DUE_DATE_SPECIFIED, "If the applydeclineEffect is off, we need a new due date specified", false, 0x80190448);
            SetErrorDetail(BDK_E_INVALID_TRANSACTION_TYPE, "Invalid transaction type", false, 0x80190449);
            SetErrorDetail(BDK_E_INVALID_REASON_CODE, "Invalid reason code", false, 0x80190450);
            SetErrorDetail(BDK_E_GROUP_SID_INITIALIZATION_FAILED, "Initialization of group SIDs from AD failed. It may indicate user group configuration is not correct or DNS failure.", false, 0x80190451);
            SetErrorDetail(BDK_E_INVALID_OPERATION_FOR_WHOLESALE_PI, "This operation is not valid for wholesale payment instruments.", false, 0x80190452);
            SetErrorDetail(BDK_E_INVALID_OPERATION_FOR_DIRECT_DEBIT, "This operation is not valid for direct debit payment instrument.", false, 0x80190453);
            SetErrorDetail(BDK_E_EXCEEDS_RESOURCE_CREDIT_LIMIT, "Adjustment amount exceeds the resource credit limit.", false, 0x80190454);
            SetErrorDetail(BDK_E_ADJUST_RESOURCE_BALANCE_FOR_NONACTIVE_SUBS, "Adjusting a resource balance is not allowed for subscriptions that are not active.", false, 0x80190455);
            SetErrorDetail(BDK_E_FAILED_TO_CREATE_MAIL_RECORD, "Failed to create mail record for account: %1.", false, 0x80190456);
            SetErrorDetail(BDK_E_MSNIA_LATE_USAGE, "This MSNIA usage event is for a billing period that is not active, in other words late usage is being reported but not billed.", false, 0x80190457);
            SetErrorDetail(BDK_E_FAILED_TO_WRITE_TO_AUDIT_DB, "Failed to write asynchronous immediate settlement failure into the audit db for account: %1.", false, 0x80190458);
            SetErrorDetail(BDK_E_INVALID_REFERRAL_OFFER, "This offering is not configured as a referral offer.", false, 0x80190459);
            SetErrorDetail(BDK_E_REWARD_REFERRAL_XML_REQUIRED, "Reward referral XML is required as this is a referral based offer.", false, 0x80190460);
            SetErrorDetail(BDK_E_REFERRER_NOT_IN_SYSTEM, "Referral PUID not found.", false, 0x80190461);
            SetErrorDetail(BDK_E_REFERRER_EXCEEDED_MAX_REFERRALS_ON_OFFER, "Referrer has exceeded the max number of referrals configured on the offer.", false, 0x80190462);
            SetErrorDetail(BDK_E_REFERRER_NOT_ACTIVE, "The referrer does not have an Active or Locked account in the system.", false, 0x80190463);
            SetErrorDetail(BDK_E_CANNOT_REFER_SELF, "The referrer cannot refer self for the offer.", false, 0x80190464);
            SetErrorDetail(BDK_E_OFFER_NOT_CONFIGURED_FOR_REFERRAL, "The referral xml has reward referral info but the offer is not configured for reward referrals.", false, 0x80190465);
            SetErrorDetail(BDK_E_INVALID_REWARD_REFFERAL_SCHEMA, "The reward referral schema in the referral xml is invalid.", false, 0x80190466);
            SetErrorDetail(BDK_E_REFERRER_NOT_ELIGIBLE_FOR_REWARD_OFFER, "The referrer does not have any eligible offers configured for the reward.", false, 0x80190467);
            SetErrorDetail(BDK_E_SETTLE_BALANCE_INVALID_MANDATE_STATUS, "Invalid mandate status for SettleBalance.", false, 0x80190468);
            SetErrorDetail(BDK_E_MULTIPLE_USAGE_EVENTS_REPORTED, "More than one usage event reported to ReportSingleUsageEvent API", false, 0x80190469);
            SetErrorDetail(BDK_E_BELOW_IMMEDIATE_SETTLE_MINIMUM, "The reported usage is below the threshold in immediate settle usage.", false, 0x80190470);
            SetErrorDetail(BDK_E_REPORT_USAGE_WITH_IMMEDIATE_SETTLE, "ReportUsage cannot be used for immediate settle of usage deals; use ReportSingleUsage.", false, 0x80190471);
            SetErrorDetail(BDK_E_REPORT_USAGE_WITH_PREPAID, "ReportUsage cannot be used for prepaid resource; use ReportSingleUsage.", false, 0x80190472);
            SetErrorDetail(BDK_E_NO_USAGE_EVENT_REPORTED, "ReportSingleUsage cannot be used with empty event set.", false, 0x80190473);
            SetErrorDetail(BDK_E_IMMEDIATE_SETTLE_NOT_AVAILABLE_FOR_PAYMENT_INSTRUMENT, "The payment instrument type does not support immediate settlements", false, 0x80190474);
            SetErrorDetail(BDK_E_RESOURCE_UNIT_OF_MEASURE_DO_NOT_MATCH, "The reported resource and unit of measure do not match.", false, 0x80190475);
            SetErrorDetail(BDK_E_INVALID_REDIRECT_INPUTINFO_XML, "Invalid  data passed in RedirectInputInfoXML node.", false, 0x80190476);
            SetErrorDetail(BDK_E_TRANSACTION_NOT_CANCELLABLE, "Transaction cannot be cancelled.", false, 0x80190477);
            SetErrorDetail(BDK_E_NO_CDS_FOUND, "No CDs found.", false, 0x80190478);
            SetErrorDetail(BDK_E_INVALID_CHARGE_DESCRIPTOR, "Charge descriptor (e.g. credit card descriptor or support info) has invalid characters or length", false, 0x80190479);
            SetErrorDetail(BDK_E_INVALID_WHOLESALEPI, "This Wholesale payment instrument has no related wholesale partner.", false, 0x80190480);
            SetErrorDetail(BDK_E_NOT_BOBOPARTNER, "This partner is not BOBO wholesale partner.", false, 0x80190481);
            SetErrorDetail(BDK_E_INVALID_BOBOPARTNER, "This BOBO wholesale partner has no entitle endpoint.", false, 0x80190482);
            SetErrorDetail(BDK_E_ENTITLEMENT_ENDPOINT_UNAVAILABLE, "The entitlement endpoint web service could not be reached", false, 0x80190483);
            SetErrorDetail(BDK_E_ENTITLEMENT_VALIDATION_FAILED, "The entitlement endpoint returned a validation failure", false, 0x80190484);
            SetErrorDetail(BDK_E_INVALID_ENTITLEMENT_ENDPOINT, "The entitlement endpoint is invalid", false, 0x80190485);
            SetErrorDetail(BDK_E_NOT_AUTHORIZED_TO_ACCESS_OBJECT, "Calling partner does not have permissions to access the sandboxed object", false, 0x80190486);
            SetErrorDetail(BDK_E_UNABLE_TO_CALL_ON_BEHALF_OF, "Calling partner does not have permissions to call on behalf of this partner", false, 0x80190487);
            SetErrorDetail(BDK_E_TAXWARE_FAILURE, "Taxware error. Check the event log and the tracer.", false, 0x80190488);
            SetErrorDetail(BDK_E_ADDRESS_VALIDATION_FAILURE, "Address validation error. Check the event log and the tracer.", false, 0x80190489);
            SetErrorDetail(BDK_E_ZIP_INVALID, "VERAZIP: Invalid ZIP code.", false, 0x80190490);
            SetErrorDetail(BDK_E_STATE_INVALID, "VERAZIP: Invalid state code.", false, 0x80190491);
            SetErrorDetail(BDK_E_ZIP_CITY_MISSING, "VERAZIP: Missing ZIP code or city name.", false, 0x80190492);
            SetErrorDetail(BDK_E_STATE_ZIP_INVALID, "VERAZIP: Invalid state code/ZIP code combination.", false, 0x80190493);
            SetErrorDetail(BDK_E_STATE_CITY_INVALID, "VERAZIP: Invalid state code/city name combination.", false, 0x80190494);
            SetErrorDetail(BDK_E_STATE_ZIP_CITY_INVALID, "VERAZIP: Invalid state code/ZIP code/city name combinations. Both state code/ZIP code and state code/city name were incorrect.", false, 0x80190495);
            SetErrorDetail(BDK_E_STATE_ZIP_CITY_INVALID2, "VERAZIP: Invalid state code/ZIP code/city name combination.", false, 0x80190496);
            SetErrorDetail(BDK_E_STATE_ZIP_CITY_INVALID3, "VERAZIP: Invalid state code/ZIP code/city name combination.", false, 0x80190497);
            SetErrorDetail(BDK_E_STATE_ZIP_CITY_INVALID4, "VERAZIP: Invalid state code/ZIP code/city name combination. Verify that state code was passed.", false, 0x80190498);
            SetErrorDetail(BDK_E_REDIRECTURL_MISSING, "Missing PayPalPayIn RedirectURL.", false, 0x80190499);
            SetErrorDetail(BDK_E_INVALID_SOFT_DESCRIPTOR, "Invalid soft descriptor.", false, 0x80190500);
            SetErrorDetail(BDK_E_CANNOT_CREATE_BILLING_AGREEMENT, "Failed to create billing agreement.", false, 0x80190501);
            SetErrorDetail(BDK_E_GET_BADETAIL_FAILED, "Failed to get payPal billing agreement details.", false, 0x80190502);
            SetErrorDetail(BDK_E_CANNOT_UPDATE_PAYPALPAYIN_PAYMENT_METHOD_AGAIN, "Cannot update PayPalPayin payment method again.", false, 0x80190503);
            SetErrorDetail(BDK_E_PP_INVALID_FIELD_VALUE, "PayPal-Payin invalid filed value.", false, 0x80190504);
            SetErrorDetail(BDK_E_MULTIPLE_COUNTIES_FOUND, "VERAZIP: Multiple counties exist for state code/ZIP code/city name combination.", false, 0x80190505);
            SetErrorDetail(BDK_E_ZIP_INVALID_FOR_ENTERED_STATE, "VERAZIP: Invalid state code for ZIP code. Changed to correct state code.", false, 0x80190506);
            SetErrorDetail(BDK_E_STATE_ZIP_COVERS_MULTIPLE_CITIES, "VERAZIP: ZIP code has multiple city names.", false, 0x80190507);
            SetErrorDetail(BDK_E_MULTIPLE_CITIES_FOUND, "VERAZIP: City has multiple ZIP codes.", false, 0x80190508);
            SetErrorDetail(BDK_E_BAD_CITYNAME_LENGTH, "Incorrect city name length.", false, 0x80190509);
            SetErrorDetail(BDK_E_BAD_COUNTRYCODE_LENGTH, "Incorrect country code length.", false, 0x80190510);
            SetErrorDetail(BDK_E_BAD_STATECODE_LENGTH, "Incorrect code length for state or province.", false, 0x80190511);
            SetErrorDetail(BDK_E_BAD_ZIPCODE_LENGTH, "Incorrect zip code length.", false, 0x80190512);
            SetErrorDetail(BDK_E_BAD_PRODUCTCODE_LENGTH, "Incorrect product code length.", false, 0x80190513);
            SetErrorDetail(BDK_E_BAD_BUSINESSLOCATIONCODE_LENGTH, "Incorrect business location code length.", false, 0x80190514);
            SetErrorDetail(BDK_E_BAD_TRANSACTIONDATE_LENGTH, "Incorrect transaction date length.", false, 0x80190515);
            SetErrorDetail(BDK_E_BAD_VATREGISTRATION_LENGTH, "Incorrect VAT registration length.", false, 0x80190516);
            SetErrorDetail(BDK_E_BAD_CURRENCYCODE_LENGTH, "Incorrect currency code length.", false, 0x80190517);
            SetErrorDetail(BDK_E_BAD_WTCODE_LENGTH, "Incorrect WorldTax code length.", false, 0x80190518);
            SetErrorDetail(BDK_E_INVALID_INPUT_TO_TAXWARE_OR_VERAZIP, "Invalid input parameter passed to TaxWare or VeraZip.", false, 0x80190519);
            SetErrorDetail(BDK_E_INVALID_VATID_FORMAT, "The Vat ID provided is of invalid format.", false, 0x80190520);
            SetErrorDetail(BDK_E_INVALID_VATID_INVALID, "The Vat ID provided is invalid.", false, 0x80190521);
            SetErrorDetail(BDK_E_UNSUPPORTED_CHAR_EXIST, "Input string contains unsupported characters.", false, 0x80190522);
            SetErrorDetail(BDK_E_ERROR_COUNTRYCODE_MISMATCH, "Country code in Address does not match with the country code in Account Info.", false, 0x80190523);
            SetErrorDetail(BDK_E_ERROR_COUNTRYCODE_REQUIRED, "A Country code is required in Account Info.", false, 0x80190524);
            SetErrorDetail(BDK_E_INVALID_TOKEN_SPECIFIED, "Token passed is Invalid.", false, 0x80190525);
            SetErrorDetail(BDK_E_TOKEN_ALREADY_BLACKLISTED, "The token is already blacklisted.", false, 0x80190526);
            SetErrorDetail(BDK_E_TOKEN_ALREADY_UNBLACKLISTED, "The token is already un-blacklisted.", false, 0x80190527);
            SetErrorDetail(BDK_E_TOKEN_BLACKLISTED, "The specified token has been blacklisted.", false, 0x80190528);
            SetErrorDetail(BDK_E_TOKEN_RANGE_BLACKLISTED, "The specified token belongs to a blacklisted token range.", false, 0x80190529);
            SetErrorDetail(BDK_E_USAGE_COUNT_FOR_TOKEN_EXCEEDED, "The usage for the specified token has been exceeded.", false, 0x80190530);
            SetErrorDetail(BDK_E_TOKEN_EXPIRY_DATE_SET_AS_NULL, "Token Expiry date not set as may be duration based token was not activated correctly.", false, 0x80190531);
            SetErrorDetail(BDK_E_FAILED_INSERTING_TOKEN_INS_DEAL_SUBS, "Failed while consumption to create an entry in token_instance_deal_subscription table.", false, 0x80190532);
            SetErrorDetail(BDK_E_ACTIVATE_TOKEN_RANGE_NOT_PRESENT, "Not found non-active token range to be activated.", false, 0x80190533);
            SetErrorDetail(BDK_E_TOKEN_EXPIRED, "The specified token has expired.", false, 0x80190534);
            SetErrorDetail(BDK_E_TOKEN_NOT_STARTED, "The specified token cannot be used yet.", false, 0x80190535);
            SetErrorDetail(BDK_E_TOKEN_RANGE_NOT_ACTIVE, "The specified token has not been activated yet.", false, 0x80190536);
            SetErrorDetail(BDK_E_INVALID_BLACKLIST_HISTORY_REASON_CODE, "The reason code specified is not valid.", false, 0x80190537);
            SetErrorDetail(BDK_E_TRACKING_GUID_NODATA, "The specified action is in progress.", false, 0x80190538);
            SetErrorDetail(BDK_E_DUPLICATE_TOKEN_TRACKING_GUID, "The specified tracking has already been used", false, 0x80190539);
            SetErrorDetail(BDK_E_ALREADY_ACTIVATED, "The specified token has already been activated", false, 0x80190540);
            SetErrorDetail(BDK_E_INVALID_COMMITTED_STATUS, "Committed status is not valid for this API.", false, 0x80190541);
            SetErrorDetail(BDK_E_INVALID_BLACKLIST_HISTORY_DESCRIPTION, "The description specified is not valid.", false, 0x80190542);
            SetErrorDetail(BDK_E_BLACKLIST_EFFECTIVE_DATE_LESS_THAN_ORDER_CREATION_DATE, "Blacklist Effective date passed was prior to the order creation date.", false, 0x80190543);
            SetErrorDetail(BDK_E_TOKEN_CONSUMED, "The Token has been consumed.", false, 0x80190544);
            SetErrorDetail(BDK_E_INVALID_PART_NUMBER_FOR_TOKEN_CLASS, "Part Number specified for the token import is not a valid part number for the associated token class.", false, 0x80190545);
            SetErrorDetail(BDK_E_INVALID_EXTERNAL_REFERENCE_ID, "External reference id is too long or invalid.", false, 0x80190546);
            SetErrorDetail(BDK_E_TOKEN_ALREADY_DEACTIVATED, "The token is already deactivated.", false, 0x80190547);
            SetErrorDetail(BDK_E_REPLACEMENT_TOKEN_PUID_MISMATCH, "Token Passed in for consumption is a replacement token for which PUID specified at the time of replacement does not match the account admin PUID.", false, 0x80190548);
            SetErrorDetail(ERROR_NULL_INPUT_PARAMETER_TOKEN_CLASS_GUID, "Null parameter was passed for Token Class GUID during token class access verification.", false, 0x80190549);
            SetErrorDetail(BDK_E_INVALID_BOOKMARK, "The argument specified is not a valid bookmark.", false, 0x80190550);
            SetErrorDetail(BDK_E_INVALID_MAX, "The max argument must be between 1 and 50.", false, 0x80190551);
            SetErrorDetail(BDK_E_INTERNAL_ERROR_TOKEN, "Internal inconsistency in Token Database.", false, 0x80190552);
            SetErrorDetail(BDK_E_UNSUPPORTED_VERSION, "The version specified is not supported.", false, 0x80190553);
            SetErrorDetail(BDK_E_INVALID_QUANTITY, "The quantity specified is invalid.", false, 0x80190554);
            SetErrorDetail(BDK_E_INVALID_PRODUCT_TYPE, "Invalid product type", false, 0x80190555);
            SetErrorDetail(BDK_E_DUPLICATE_ITEM_EXTERNAL_ID, "The input item external id is duplicate", false, 0x80190556);
            SetErrorDetail(BDK_E_NO_TAX_RULE_CONFIGURED, "No tax rule was returned for the specified country, product and event date combination", false, 0x80190557);
            SetErrorDetail(BDK_E_TAX_CALCULATION_FAILURE, "Fail to calculate tax", false, 0x80190558);
            SetErrorDetail(BDK_E_NO_ASSOCIATED_TAX_INFO, "No tax info associated with the account", false, 0x80190559);
            SetErrorDetail(BDK_E_INVALID_TAX_CALCULATION_INFO, "Invalid tax calculation info.", false, 0x80190560);
            SetErrorDetail(BDK_E_NO_TAX_INCLUSIVE_CALCULATION, "Tax inclusive calculation cannot be performed for US and CA.", false, 0x80190561);
            SetErrorDetail(BDK_E_INVALID_REVENUE_SKU, "Invalid revenue sku.", false, 0x80190562);
            SetErrorDetail(BDK_E_INVALID_TAX_AMOUNT, "Invalid tax amount.", false, 0x80190563);
            SetErrorDetail(BDK_E_INVALID_TAX_RATE, "Invalid tax rate.", false, 0x80190564);
            SetErrorDetail(BDK_E_INVALID_BILLING_MODE, "Invalid billing mode.", false, 0x80190565);
            SetErrorDetail(BDK_E_INVALID_ITEM_ENTRY_SET, "Invalid item entry set.", false, 0x80190566);
            SetErrorDetail(BDK_E_BILLING_FAILURE, "Failed to execute operation in billing component.", false, 0x80190567);
            SetErrorDetail(BDK_E_BILLING_RETRYABLE_FAILURE, "Failed to execute operation in billing component, please retry.", false, 0x80190568);
            SetErrorDetail(BDK_E_ORIGINAL_ORDER_ID_NOT_SPECIFIED, "The original order is is not specified.", false, 0x80190569);
            SetErrorDetail(BDK_E_NO_MATCHING_BILLING_CONFIGURATION, "No matching billing configuration for the specified partner, country, currency, PI type, billing configuration group combination.", false, 0x80190570);
            SetErrorDetail(BDK_E_INVALID_BILLING_REFERENCE_ID, "Invalid billing reference id.", false, 0x80190571);
            SetErrorDetail(BDK_E_BILLING_REFERENCE_ID_ALREADY_REMOVED, "The billing reference id has already been removed.", false, 0x80190572);
            SetErrorDetail(BDK_E_PROCESSIMPORT_OFFSET_LINE_MISSING_FIELD, "Unable to retrieve event ID and billing impact for event.", false, 0x80190573);
            SetErrorDetail(BDK_E_PROCESSIMPORT_OFFSET_LINE_MISSING_MATCH_EVENT, "Unable to find line item matching event.", false, 0x80190574);
            SetErrorDetail(BDK_E_CANCELREFUND_OFFSET_OF_OFFSET, "Cannot process if there is an offset of an offset.", false, 0x80190575);
            SetErrorDetail(BDK_E_CANCELREFUND_BOTH_LINE_AND_RELATED_LINE, "This can't happen, both line item and related line item in the active list.", false, 0x80190576);
            SetErrorDetail(BDK_E_INVALID_SESSION_KEY, "The session key passed in does not pass validation checks.", false, 0x80190577);
            SetErrorDetail(BDK_E_NO_PRODUCT_KEY_FOR_OBJECT_ID, "This object ID is not entitled to get a deliverable token.", false, 0x80190578);
            SetErrorDetail(BDK_E_PRODUCT_KEY_NOT_AVAILABLE, "The token cannot be issued, either because the database is unavailable or there are no more unused tokens.", false, 0x80190579);
            SetErrorDetail(BDK_E_PIN_OR_SEQ_REQUIRED, "Either PIN or Sequence number is required as input parameter to validate Token.", false, 0x80190580);
            SetErrorDetail(BDK_E_INPUT_PARAM_MALFORMED, "Either Token Class Guid or Signature or Part Number should be specified for validating Token.", false, 0x80190581);
            SetErrorDetail(BDK_E_INVALID_ADJUSTMENT_OFFSET, "The offset must be between -1 and 365 inclusive.", false, 0x80190582);
            SetErrorDetail(BDK_E_INVALID_ITEM_INSTANCE_ID, "Invalid item instance ID.", false, 0x80190583);
            SetErrorDetail(BDK_E_INVALID_REVERSE_REASON, "Invalid reason for reverse operation.", false, 0x80190584);
            SetErrorDetail(BDK_E_TOO_MANY_ITEMS_IN_PURCHASE, "Only 1 item can be purchased at once.", false, 0x80190585);
            SetErrorDetail(BDK_E_INVALID_OFFERING_TYPE, "PurchaseItem accepts only offers that are configured for item, PurchaseSubscription accepts only subscription offers and the account must be specified, or free trial offer and account must not be specified.", false, 0x80190586);
            SetErrorDetail(BDK_E_PRICE_IS_NEGATIVE, "The price specified must be a positive value.", false, 0x80190587);
            SetErrorDetail(BDK_E_DYNAMIC_PRICE_CONFIGURATION, "Cannot pass in a price and/or currency because it is configured on the item.", false, 0x80190588);
            SetErrorDetail(BDK_E_DMP_MAX_BALANCE_EXCEEDED, "The maximum allowable DMP point balance is exceeded.", false, 0x80190589);
            SetErrorDetail(BDK_E_CURRENCY_MISSING, "Calling partner needs to add a currency because it is not pre-configured.", false, 0x80190590);
            SetErrorDetail(BDK_E_PENDING_ITEM_PURCHASE, "The user already has a pending purchase for for this item that must first be cancelled or completed.", false, 0x80190591);
            SetErrorDetail(BDK_E_DMP_FLOW_NOT_ENABLED, "Unable to talk to DMP system.", false, 0x80190592);
            SetErrorDetail(BDK_E_ITEM_ALREADY_REVERSED, "Item has been already reversed.", false, 0x80190593);
            SetErrorDetail(BDK_E_ITEM_NOT_FULFILLED, "Reversing an item that has not been fulfilled.", false, 0x80190594);
            SetErrorDetail(BDK_E_DMP_UNKNOWN_ERROR, "Unknown DMP error has occurred.", false, 0x80190595);
            SetErrorDetail(BDK_E_ACTION_NOT_APPLICABLE_FOR_PAYMENT_TYPE, "Payment method type does not support operation.", false, 0x80190596);
            SetErrorDetail(BDK_E_INVALID_CANCEL_TRANSACTION_RESULT, "Redirect vendor returned an invalid CancelTransaction result.", false, 0x80190597);
            SetErrorDetail(BDK_E_CVM_MISSING, "CVM code Missing", false, 0x80190598);
            SetErrorDetail(BDK_E_ACCOUNT_CANNOT_PURCHASE_FREE_TRIAL, "A fre Trial cannot be purchased using an account. Use only the PUID", false, 0x80190599);
            SetErrorDetail(BDK_E_DONOR_BENEFICIARY_COUNTRY_MISMATCH, "Countries in the billable account (in payment method XML) of the donor and the Points account of the beneficiary mismatch", false, 0x80190600);
            SetErrorDetail(BDK_E_DONOR_BENEFICIARY_SAME, "The donor and the beneficiary are the same.", false, 0x80190601);
            SetErrorDetail(BDK_E_RENEWAL_DOES_NOT_EXISTS, "The renewal does not exists.", false, 0x80190602);
            SetErrorDetail(BDK_E_TOKEN_SCHEDULED_RENEWAL_EXISTS, "The token schedule rennewal exists for this offer.", false, 0x80190603);
            SetErrorDetail(BDK_E_NOTIFICATION_QUEUE_EVENT_FAIL_FREQUENTLY, "The event could not be queued to notification engine frequently.", false, 0x80190604);
            SetErrorDetail(BDK_E_NOTIFICATION_CLIENT_UNKNOWN_ERROR, "Unknown notification client error.", false, 0x80190605);
            SetErrorDetail(BDK_E_NOTIFICATION_CLIENT_INIT_FAIL, "Notification client initialization failure.", false, 0x80190606);
            SetErrorDetail(BDK_E_NOTIFICATION_CLIENT_INVALID_QUEUE_OPTION, "Notification client queue option is not well configured in tower db.", false, 0x80190607);
            SetErrorDetail(BDK_E_NOTIFICATION_CLIENT_TOO_SLOW, "Notification client performs too slow.", false, 0x80190608);
            SetErrorDetail(BDK_E_NOTIFICATION_QUEUE_EVENT_FAIL_NOT_FREQUENTLY, "The event could not be queued to notification engine but not happens frequently.", false, 0x80190609);
            SetErrorDetail(BDK_E_NOTIFICATION_NO_RELATED_PARTNER_SUBS, "The notification is not related to any partner subscriptions.", false, 0x80190610);
            SetErrorDetail(BDK_E_INVALID_DISCOUNT, "Specified Discount is invalid.", false, 0x80190611);
            SetErrorDetail(BDK_E_INSERT_DISCOUNT, "Could not insert into a discount table.", false, 0x80190612);
            SetErrorDetail(BDK_E_DISCOUNT_ALREADY_APPLIED, "Only one discount permitted per subscription.", false, 0x80190613);
            SetErrorDetail(BDK_E_DISCOUNT_REQUIRED_FOR_TOKEN, "Token is a discount coupon yet no discount was passed.", false, 0x80190614);
            SetErrorDetail(BDK_E_DISCOUNT_TOKEN, "Token is a discount coupon and cannot be associated with a deal.", false, 0x80190615);
            SetErrorDetail(BDK_E_INSERT_DISCOUNT_LOCALIZE, "Failed to insert record into discount_localize table.", false, 0x80190616);
            SetErrorDetail(BDK_E_DISCOUNT_USAGE_EXCEEDED, "Per Account Usage limit was exceeded for discount.", false, 0x80190617);
            SetErrorDetail(BDK_E_DISCOUNT_TOKEN_CLASS_MISMATCH, "Token class and discount are not a valid combination.", false, 0x80190618);
            SetErrorDetail(BDK_E_INVALID_CUSTOMER_TYPE_FOR_PARTNER, "Partner does not have access to the specified customer type", false, 0x80190619);
            SetErrorDetail(BDK_E_NULL_CATEGORY, "Category should not be null.", false, 0x80190620);
            SetErrorDetail(BDK_E_NULL_ACCOUNTID, "Account ID cannot be null.", false, 0x80190621);
            SetErrorDetail(BDK_E_NULL_SUBSCRIPTIONREFID, "Subscription Ref ID cannot be null.", false, 0x80190622);
            SetErrorDetail(BDK_E_INVALID_SURVEYRESULTCODE, "Invalid Survey Result Code.", false, 0x80190623);
            SetErrorDetail(BDK_E_CD_NOTFOUND, "CD not found.", false, 0x80190624);
            SetErrorDetail(BDK_E_INVALID_ACCOUNTID, "Invalid Account ID.", false, 0x80190625);
            SetErrorDetail(BDK_E_INVALID_ANONYMOUS_INFO_XML, "Invalid AnonymousInfo Xml.", false, 0x80190626);
            SetErrorDetail(BDK_E_UNSUPPORTED_OBJECT_TYPE, "Unsupported object type.", false, 0x80190627);
            SetErrorDetail(BDK_E_INVALID_PHONE_XML, "Invalid Phone XML.", false, 0x80190628);
            SetErrorDetail(BDK_E_INVALID_REQUESTOR_INFO, "Invalid requestor info. Valid Requestor Info has a size limit of 256 Characters.", false, 0x80190629);
            SetErrorDetail(BDK_E_PENDING_TRANSACTIONS, "There are pending transactions on this deal or subscription.", false, 0x80190630);
            SetErrorDetail(BDK_E_LINEITEM_SETTLEMENT_AMOUNT_NOT_MATCH, "The lineitem id and settlement id do not match", false, 0x80190631);
            SetErrorDetail(BDK_E_INVALID_ORIGINAL_CHARGE_DETAILS, "Invalid original charge details", false, 0x80190632);
            SetErrorDetail(BDK_E_PARTIAL_CHAREGBACK, "Partial Chargeback cannot be Processed", false, 0x80190633);
            SetErrorDetail(BDK_E_INVALID_LINEITEM_ID_FOR_REVERSAL, "Invalid lineitem id for reversal", false, 0x80190634);
            SetErrorDetail(BDK_E_INVALID_CHARGEBACK_DATE, "Invalid chargeback date. Chargeback date must greater or equals to original settlement date", false, 0x80190635);
            SetErrorDetail(BDK_E_INVALID_CHARGEBACK_AMOUNT, "Invalid chargeback amount.", false, 0x80190636);
            SetErrorDetail(BDK_E_ALREADY_OFFSET_TAX, "Tax was already offset for this line item.", false, 0x80190637);
            SetErrorDetail(BDK_E_COUNTRY_CODE_MAPPOINT_NOT_ENABLED, "mappoint is not enabled for the country code.", false, 0x80190638);
            SetErrorDetail(BDK_E_NETWORK_ERROR_CONNECTING_TO_MAPPOINT, "SCS had error connecting to mappoint due to some network problems.", false, 0x80190639);
            SetErrorDetail(BDK_E_INTERNAL_ERROR_CONNECTING_TO_MAPPOINT, "SCS had some internal error connecting that is preventing connection to mappoint.", false, 0x80190640);
            SetErrorDetail(BDK_E_ZERO_ADDRESSES_BY_MAPPOINT, "Mappoint returned 0 addresses.", false, 0x80190641);
            SetErrorDetail(BDK_E_UNKNOWN_ERROR, "UNKNOWN ERROR in MAPPOINT API.", false, 0x80190642);
            SetErrorDetail(BDK_E_UPDATE_ADDRESS_UNKNOWN_ERROR, "UNKNOWN ERROR ENCOUNTERED.", false, 0x80190643);
            SetErrorDetail(BDK_E_INVALID_ADDRESSINFOXML, "Invalid AddressInfo Xml.", false, 0x80190644);
            SetErrorDetail(BDK_E_POST_BOX_ERROR_MAPPOINT, "Mappoint does not support Post Box Addresses currently.", false, 0x80190645);
            SetErrorDetail(BDK_E_MAPPOINT_CONNECTION_MAPPOINT, "The connection to Mappoint has timed out.", false, 0x80190646);
            SetErrorDetail(BDK_E_ERROR_INVALID_CHARGEBACK_INPUT_DETAILS, "Invalid Chargeback details provided as input", false, 0x80190647);
            SetErrorDetail(BDK_E_CHARGEBACK_NOT_FOUND, "Chargeback id not found", false, 0x80190648);
            SetErrorDetail(BDK_E_CHARGEBACK_NOT_MATCH, "Chargeback id did not match", false, 0x80190649);
            SetErrorDetail(BDK_E_DOUBLE_CHARGEBACK, "Double chargeback", false, 0x80190650);
            SetErrorDetail(BDK_E_INVALID_CHARGEBACK_LINEITEM_ID, "Invalid chargebacklineitem id", false, 0x80190651);
            SetErrorDetail(BDK_E_INVALID_CHARGEBACK_REVERSAL_ID, "Invalid reversal chargeback id", false, 0x80190652);
            SetErrorDetail(BDK_E_INVALID_CHARGEBACK_ID_FOR_REVERSAL_CHARGEBACK_ID, "Invalid chargeback for reversal chargeback id", false, 0x80190653);
            SetErrorDetail(BDK_E_INVALID_LINEITEM_ID_FOR_CHARGEBACK_ID, "invalid lineitem id for chargeback id", false, 0x80190654);
            SetErrorDetail(BDK_E_INVALID_LINEITEM_TYPE, "invalid lineitem id", false, 0x80190655);
            SetErrorDetail(BDK_E_DOUBLE_CHARGEBACK_FOR_REVERSAL, "Double chargeback for reversal", false, 0x80190656);
            SetErrorDetail(BDK_E_COUNTRY_NOT_SUPPORTED, "The country of the address is not supported at this time", false, 0x80190657);
            SetErrorDetail(BDK_E_COUNTRY_MAPPOINT_DISABLED, "SCS has temporarily disabled MAPPOINT support for this country", false, 0x80190658);
            SetErrorDetail(BDK_E_INVALID_PARAMETER, "The input parameter is incorrect", false, 0x80190659);
            SetErrorDetail(BDK_E_INVALID_INPUT_RATINGRULE_DATA, "The input ratingrules is invalid.", false, 0x80190660);
            SetErrorDetail(BDK_E_INVALID_TIME_CONVERSION_RATIO, "Invalid time conversion ratio for time extension.", false, 0x80190661);
            SetErrorDetail(BDK_E_INVALID_ROUND_DAY_BOUNDARY, "Invalid round day boundary for time extension.", false, 0x80190662);
            SetErrorDetail(BDK_E_TIME_EXTENSION_NOT_SUPPORTED, "Time extension is not supported for target subscription.", false, 0x80190663);
            SetErrorDetail(BDK_E_INVALID_SUBS_STATUS_FOR_COMMIT_CONVERT, "The subscription status is invalid for committing subscription conversion.", false, 0x80190664);
            SetErrorDetail(BDK_E_INVALID_SUBS_STATUS_FOR_COMMIT_CREATESUBS, "The subscription status is invalid for committing subscription creation.", false, 0x80190665);
            SetErrorDetail(BDK_E_INVALID_TAX_CODE, "Tax code is invalid.", false, 0x80190666);
            SetErrorDetail(BDK_E_MULTIPLE_RATING_RULE_FOUND, "Multiple charge or proration rating rule found.", false, 0x80190667);
            SetErrorDetail(BDK_E_INVALID_SUBS_STATUS_FOR_ABANDON_CONVERT, "The subscription status is invalid for abandoning subscription conversion.", false, 0x80190668);
            SetErrorDetail(BDK_E_INVALID_SUBS_STATUS_FOR_ABANDON_CREATESUBS, "The subscription status is invalid for abandoning subscription creation.", false, 0x80190669);
            SetErrorDetail(BDK_E_INVALID_TAX_INCLUDED, "Tax included info is invalid.", false, 0x80190670);
            SetErrorDetail(BDK_E_INVALID_DESCRIPTION_PRICEDESC, "Invalid description or price description.", false, 0x80190671);
            SetErrorDetail(BDK_E_RENEW_SUBSCRIPTION_NOT_SUPPORTED, "Renew mode of subscription conversion is not supported.", false, 0x80190672);
            SetErrorDetail(BDK_E_INVALID_CHARGEBACK_ID, "Invalid ChargebackID Generation.", false, 0x80190673);
            SetErrorDetail(BDK_E_CHARGEBACK_PROCESSING_FAILURE, "Error when Chargeback Processing Failure.", false, 0x80190674);
            SetErrorDetail(BDK_E_INVALID_MERCHANT_REFERENCE, "Invalid Merchant Reference Number.", false, 0x80190675);
            SetErrorDetail(BDK_E_CHARGEBACK_INFO_MISSING, "Error when any input details missing.", false, 0x80190676);
            SetErrorDetail(BDK_E_RECORD_CHARGEBACK_FAILED, "Error while recording chargeback/reversal in Chargeback History table.", false, 0x80190677);
            SetErrorDetail(BDK_E_DOUBLE_CHARGEBACK_REVERSAL, "Double Chargeback Reversal", false, 0x80190678);
            SetErrorDetail(BDK_E_REVERSAL_OF_PROCESSED_CHARGEBACK, "Chargeback Processing Reversal", false, 0x80190679);
            SetErrorDetail(BDK_E_MISMATCH_PAYMENT_SUBSCRIPTION, "Payment instrument not associated with subscription", false, 0x80190680);
            SetErrorDetail(BDK_E_SUBSCRIPTION_ALREADY_CONVERTED_OR_RENEWED, "Subscription already converted or renewed", false, 0x80190681);
            SetErrorDetail(BDK_E_MERCHANT_REFERENCE_NUMBER_MISSING, "Merchant Reference Number missing", false, 0x80190682);
            SetErrorDetail(BDK_E_INVALID_ENCRYPT_ACCOUNT_NUMBER, "Invalid Encrypt Account number", false, 0x80190683);
            SetErrorDetail(BDK_E_SUBSCRIPTION_SCHEDULED_RENEWAL, "Subscription has been scheduled to renew", false, 0x80190684);
            SetErrorDetail(BDK_E_PROFILE_ALREADY_EXISTS, "Account holder's profile already exists.", false, 0x80190685);
            SetErrorDetail(BDK_E_PROFILE_DOES_NOT_EXIST, "Account holder's profile does not exist.", false, 0x80190686);
            SetErrorDetail(BDK_E_ACCOUNT_WITHOUT_ADDRESS, "Account does not have an address associated with it.", false, 0x80190687);
            SetErrorDetail(BDK_E_NO_PAYOUT_PREFERENCE, "Payout preference (default) is not set.", false, 0x80190688);
            SetErrorDetail(BDK_E_CAN_NOT_DELETE_DEFAULT_PAYOUT_PREFERENCE, "Payout preference (default) can not be deleted.", false, 0x80190689);
            SetErrorDetail(BDK_E_INVALID_PAYUSERINFOXML, "Invalid PayUserInfo XML.", false, 0x80190690);
            SetErrorDetail(BDK_E_INVALID_USERPROFILEXML, "Invalid UserProfile XML.", false, 0x80190691);
            SetErrorDetail(BDK_E_CANNOT_SPECIFY_BILLABLE_ACCOUNT_ID, "Account ID must not be specified.", false, 0x80190692);
            SetErrorDetail(BDK_E_DESCRIPTION_MAXLENGTH_EXCEEDED, "Description length exceeded", false, 0x80190693);
            SetErrorDetail(BDK_E_RIME_REJECTED, "RiME returns Rejected", false, 0x80190694);
            SetErrorDetail(BDK_E_RIME_INVALID_VALUE, "Invalid Values were sent to RiME", false, 0x80190695);
            SetErrorDetail(BDK_E_REFERRAL_CODE_NOT_FOUND, "Referral code not found in SCS database", false, 0x80190696);
            SetErrorDetail(BDK_E_BSS_NOT_SUPPORTED_LINE_ITEM_ID, "Billing subsystem doesn't support line item id for processing chargeback", false, 0x80190697);
            SetErrorDetail(BDK_E_BSS_INTERNAL_SERVER_ERROR, "Billing subsystem encountered internal error.", false, 0x80190698);
            SetErrorDetail(BDK_E_BSS_INVALID_ORDER_STATUS, "Billing subsystem only, the order status is invalid for chargeback.", false, 0x80190699);
            SetErrorDetail(BDK_E_BSS_PARITAL_CHARGE_BACK, "Billing subsystem doesn't support partial chargeback.", false, 0x80190700);
            SetErrorDetail(BDK_E_BSS_TIMEOUT_ERROR, "Timeout when calling billing subsystem.", false, 0x80190701);
            SetErrorDetail(ERROR_MISSING_PROV_INFO, "There is no existing provisioning information to complete this call", false, 0x80190702);
            SetErrorDetail(BDK_E_INVALID_RESOURCE_TYPE, "Invalid Resource Type", false, 0x80190703);
            SetErrorDetail(BDK_E_PAYMENT_PROVIDER_SUBMISSION_FAILED, "fail when submit to payment provider", false, 0x80190704);
            SetErrorDetail(BDK_E_PAYMENT_PROVIDER_SUBMISSION_DECLINED, "declined when submit to payment provider", false, 0x80190705);
            SetErrorDetail(BDK_E_ENCRYPTION_FAILURE, "fail to encrypt file", false, 0x80190706);
            SetErrorDetail(BDK_E_DMP_FIRST, "BDK_E_DMP_FIRST", false, 0x80190707);
            SetErrorDetail(BDK_E_DMP_LAST, "BDK_E_DMP_LAST", false, 0x80190708);
            SetErrorDetail(BDK_E_INVALID_TARGET_USER_INFORMATION, "Invalid target user information specified", false, 0x80190709);
            SetErrorDetail(BDK_E_INVALID_DELEGATE_USER_INFORMATION, "Invalid delegate user information", false, 0x80190710);
            SetErrorDetail(BDK_E_INVALID_SOURCE_USER_INFORMATION, "Invalid source information", false, 0x80190711);
            SetErrorDetail(BDK_E_INVALID_TRANSACTION_INFORMATION, "Invalid transaction Id", false, 0x80190712);
            SetErrorDetail(BDK_E_NO_MATCHING_TRANSACTION, "Transaction information passed in does not match the information stored", false, 0x80190713);
            SetErrorDetail(BDK_E_NO_MATCHING_PENDINGPAYOUT_TRANSACTION, "Unable to find transaction in PENDING_PAYOUT state matching the input parameters", false, 0x80190714);
            SetErrorDetail(BDK_E_NO_MATCHING_PENDING_TRANSACTION, "Unable to find transaction in PENDING state matching the input parameters", false, 0x80190715);
            SetErrorDetail(BDK_E_ORDER_LAYER_FIRST, "BDK_E_ORDER_LAYER_FIRST", false, 0x80190716);
            SetErrorDetail(BDK_E_ORDER_LAYER_LAST, "BDK_E_ORDER_LAYER_LAST", false, 0x80190717);
            SetErrorDetail(BDK_E_TRANSACTION_LAYER_FIRST, "BDK_E_TRANSACTION_LAYER_FIRST", false, 0x80190718);
            SetErrorDetail(BDK_E_TRANSACTION_LAYER_LAST, "BDK_E_TRANSACTION_LAYER_LAST", false, 0x80190719);
            SetErrorDetail(BDK_E_PROVISIONING_MPF_CALL_FAILED, "Provisioning call from MPF to endpoint failed.", false, 0x80190720);
            SetErrorDetail(BDK_E_PROVISIONING_INVALID_ADJUSTMENT_OFFSET, "Invalid adjustment date offset.", false, 0x80190721);
            SetErrorDetail(BDK_E_PROVISIONING_INVALID_ARG, "Invalid arguments.", false, 0x80190722);
            SetErrorDetail(AU_E_NO_REQUEST_SENT, "Response file received but no request file sent for it.", false, 0x80190723);
            SetErrorDetail(AU_E_DUPLICATE_RUN, "CC Account Updater already run for the current day.", false, 0x80190724);
            SetErrorDetail(AU_E_BAD_BATCH_FORMAT, "Batch files are not configured properly: input, output, archive, log data are missing.", false, 0x80190725);
            SetErrorDetail(AU_E_FAIL_TO_ARCHIVE, "Could not archive inquiry / response file.", false, 0x80190726);
            SetErrorDetail(AU_E_FAIL_TO_GENERATE_INQUIRY_FILE, "Cannot generate Inquiry file.", false, 0x80190727);
            SetErrorDetail(AU_E_INQUIRY_GENERATION_TASK_ENDED_UNSUCCESSFULLY, "Task for inquiry file generation ended: error(s) found(s) during process, check log file.", false, 0x80190728);
            SetErrorDetail(AU_E_RESPONSE_PROCESS_TASK_ENDED_UNSUCCESSFULLY, "Task for response file processing ended: error(s) found(s) during process, check log file.", false, 0x80190729);
            SetErrorDetail(AU_E_UPDATE_PROCESS_TASK_ENDED_UNSUCCESSFULLY, "Task for response file processing ended: error(s) found(s) during process, check log file.", false, 0x80190730);
            SetErrorDetail(PP_E_REQUEST_PROCESS_TASK_ENDED_UNSUCCESSFULLY, "Task for request file sending ended: error(s) found(s) during process, check log file.", false, 0x80190731);
            SetErrorDetail(PP_E_RESPONSE_PROCESS_TASK_ENDED_UNSUCCESSFULLY, "Task for response file processing ended: error(s) found(s) during process, check log file.", false, 0x80190732);
            SetErrorDetail(SCS_E_CERT_INAVLID, "SCS_E_CERT_INAVLID", false, 0x80190733);
            SetErrorDetail(SCS_E_INAVLID_CALLING_PARTNER, "SCS_E_INAVLID_CALLING_PARTNER", false, 0x80190734);
            SetErrorDetail(BDK_E_RISK_EVALUATION_FAILED, "BDK_E_RISK_EVALUATION_FAILED", false, 0x80190735);
            SetErrorDetail(BDK_E_RISK_EVALUATION_EXCEPTION, "BDK_E_RISK_EVALUATION_EXCEPTION", false, 0x80190736);
            SetErrorDetail(BDK_E_RISK_EVALUATION_UNDEFINED, "BDK_E_RISK_EVALUATION_UNDEFINED", false, 0x80190737);
            SetErrorDetail(BDK_E_RISK_CONFIGURATION_ERROR, "BDK_E_RISK_CONFIGURATION_ERROR", false, 0x80190738);
            SetErrorDetail(BDK_E_RISK_NEXT, "BDK_E_RISK_NEXT", false, 0x80190739);
            SetErrorDetail(BDK_E_RISK_ENGINE_EXCEPTION, "Risk Engine throw exception", false, 0x80190740);
            SetErrorDetail(BDK_E_RISK_ARGUMENT_VALIDATION_FAILED, "Risk Engine throw exception in argument validation", false, 0x80190741);
            SetErrorDetail(BDK_E_DAV_APARTMENT, "Apartment number missing or not found", false, 0x80190742);
            SetErrorDetail(BDK_E_DAV_INSUFFICIENT, "Insufficient address information", false, 0x80190743);
            SetErrorDetail(BDK_E_DAV_ID, "House number or PO box not found", false, 0x80190744);
            SetErrorDetail(BDK_E_DAV_MULTIPLE, "Multiple address matches found", false, 0x80190745);
            SetErrorDetail(BDK_E_DAV_POBOX, "PO box identifier out of range", false, 0x80190746);
            SetErrorDetail(BDK_E_DAV_ROUTE, "Route service identified out of range", false, 0x80190747);
            SetErrorDetail(BDK_E_DAV_STREET, "Street name not found", false, 0x80190748);
            SetErrorDetail(BDK_E_DAV_POSTAL, "Postal code not found", false, 0x80190749);
            SetErrorDetail(BDK_E_DAV_GENERAL, "Genreal address error", false, 0x80190750);
            SetErrorDetail(BDK_E_DAV_MISSING_DATA, "Missing required address field(s)", false, 0x80190751);
            SetErrorDetail(BDK_E_DAV_INVALID_DATA, "Invalid address field(s)", false, 0x80190752);
            SetErrorDetail(BDK_E_DAV_SYSTEM_FAILURE, "System failure during address check", false, 0x80190753);
            SetErrorDetail(BDK_E_DAV_TIMEOUT, "Timeout during DAV check", false, 0x80190754);
            SetErrorDetail(BDK_E_DAV_DISABLED, "Delivery Address Verification system is not available at this time", false, 0x80190755);
            SetErrorDetail(BDK_E_DAV_INVALID_CHARSET, "The character set used for this transaction is not supported by the address verification service.", false, 0x80190756);
            SetErrorDetail(BDK_E_RISK_LAST, "BDK_E_RISK_LAST", false, 0x80190757);
            SetErrorDetail(DMP_E_VALIDATION_ERROR, "Soap request is invalid, check parameters.", false, 0x80190758);
            SetErrorDetail(DMP_E_UNKNOWNSERVER_ERROR, "Unknown Server Error.", false, 0x80190759);
            SetErrorDetail(DMP_E_CONFIGURATION_ERROR, "Server Configuration Problem.", false, 0x80190760);
            SetErrorDetail(DMP_E_SYSTEM_INTERNAL_ERROR, "A system internal error has occured.", false, 0x80190761);
            SetErrorDetail(DMP_E_INVALID_TENANT, "Invalid tenant ID input.", false, 0x80190762);
            SetErrorDetail(DMP_E_INVALID_API_SIGNATURE, "The tracking guid does not match the api signature.", false, 0x80190763);
            SetErrorDetail(DMP_E_USER_REGISTERED, "User already registered.", false, 0x80190764);
            SetErrorDetail(DMP_E_REQUEST_CANNOT_BE_COMPLETED, "The request cannot be completed due to user state.", false, 0x80190765);
            SetErrorDetail(DMP_E_STATUS_UNREGISTERED, "User is not registered.", false, 0x80190766);
            SetErrorDetail(DMP_E_INVALID_NEXTHANDLE, "The NextHandle parameter is invalid.", false, 0x80190767);
            SetErrorDetail(DMP_E_INVALID_DATE_RANGE, "Date Range is not supported in the system.", false, 0x80190768);
            SetErrorDetail(DMP_E_INSUFFICIENT_BALANCE, "There is not sufficient balance to support this transaction.", false, 0x80190769);
            SetErrorDetail(DMP_E_DATA_OVERLIMIT_ERROR, "The input data length is over system size limit.", false, 0x80190770);
            SetErrorDetail(DMP_E_ITEM_UNIQUENESS_ERROR, "The input item ExternalId is not unique within the items array.", false, 0x80190771);
            SetErrorDetail(DMP_E_INVALID_ITEM_VALUE, "The item string input has invalid values.", false, 0x80190772);
            SetErrorDetail(DMP_E_NOT_ALL_ITEMS_ELIGIBLE_FOR_CREDIT, "Not all items included in this request are eligible for credit, some items are credited already.", false, 0x80190773);
            SetErrorDetail(DMP_E_INVALID_CONFIRMATION_ID, "The confirmation id is invalid.", false, 0x80190774);
            SetErrorDetail(DMP_E_INVALID_SKU, "The SKU code is not supported.", false, 0x80190775);
            SetErrorDetail(DMP_E_INVALID_SKU_TYPE, "The SKU Type is incorrect for the API.", false, 0x80190776);
            SetErrorDetail(DMP_E_PROMO_EXPIRED, "The promotional SKU has expired.", false, 0x80190777);
            SetErrorDetail(DMP_E_STATUS_NOT_CHANGED, "The user status is in requested state already.", false, 0x80190778);
            SetErrorDetail(DMP_E_COUNTRY_NOT_CHANGED, "The user country is in requested state already.", false, 0x80190779);
            SetErrorDetail(DMP_E_INVALID_TRANSACTION_TYPE, "The transaction type passed in is not valid.", false, 0x80190780);
            SetErrorDetail(DMP_E_ORIGINAL_TRANSACTION_HAS_CREDIT, "The original transaction is not eligible for cancellation because it has all or partial credit on it.", false, 0x80190781);
            SetErrorDetail(DMP_E_MAX_BALANCE_EXCEEDED, "The result point balance will exceed the policy max balance.", false, 0x80190782);
            SetErrorDetail(DMP_E_MAX_ACQUISITION_EXCEEDED, "The point amount exceeds the policy max acquisition limit per transaction.", false, 0x80190783);
            SetErrorDetail(DMP_E_MAX_CONSUMPTION_EXCEEDED, "The user consumption per period of time would exceed the policy limit.", false, 0x80190784);
            SetErrorDetail(DMP_E_NO_MORE_PROMO_POINTS, "There are no more points to distribute for this tenant sku combination.", false, 0x80190785);
            SetErrorDetail(DMP_E_PROMO_POINTS_UNAVAILIABLE, "The system is busy, please retry.", false, 0x80190786);
            SetErrorDetail(DMP_E_ORIGINAL_TRANSACTION_NOT_FOUND, "The original record was not found, possibly archived.", false, 0x80190787);
            SetErrorDetail(DMP_E_ORIGINAL_TRANSACTION_HAS_DEBIT, "The original transaction already is already debited.", false, 0x80190788);
            SetErrorDetail(DMP_E_INVALID_TRANSACTION_TO_CREDIT, "The original transaction must be a PurchaseItem transaction type.", false, 0x80190789);
            SetErrorDetail(DMP_E_INVALID_REASON_CODE, "The supplied reason code is invalid.", false, 0x80190790);
            SetErrorDetail(DMP_E_PROMOTION_LIMIT_LIFE_MAX, "The promotional points user obtained would exceed the sku limit.", false, 0x80190791);
            SetErrorDetail(DMP_E_STATUS_CHANGE_NOT_ALLOWED, "The requested state change is not allowed.", false, 0x80190792);
            SetErrorDetail(DMP_E_PROPERTY_VALUE_NOT_CHANGED, "The property value did not change, new values should be supplied.", false, 0x80190793);
            SetErrorDetail(DMP_E_NOT_ALL_ITEMS_ELIGIBLE_FOR_OFFSET, "Not all items eligible for offset.", false, 0x80190794);
            SetErrorDetail(DMP_E_MUST_SPECIFY_CONFIRMATION, "The confirmationId is required.", false, 0x80190795);
            SetErrorDetail(DMP_E_CONFIRMATION_HAS_TO_BE_NULL, "the confirmationId has to be null.", false, 0x80190796);
            SetErrorDetail(DMP_E_INVALID_EXCHANGE_TYPE, "Exchange type is not valid.", false, 0x80190797);
            SetErrorDetail(DMP_E_CANNOT_CREDIT_SUBSCRIPTION, "The original transaction for creditbalance call must not be a subscription.", false, 0x80190798);
            SetErrorDetail(DMP_E_EXCHANGE_PRICE_MISMATCH, "Exchange price supplied does not match system rates.", false, 0x80190799);
            SetErrorDetail(DMP_E_INVALID_SOURCE_ACCOUNT, "Source Account is not in Active State for the Transaction.", false, 0x80190800);
            SetErrorDetail(DMP_E_INVALID_DESTINATION_ACCOUNT, "Destination Account is not in Active State for the Transaction.", false, 0x80190801);
            SetErrorDetail(DMP_E_SOURCE_TRANSFER_PUIDS_SAME, "Source and Transfer Puid's are same.", false, 0x80190802);
            SetErrorDetail(DMP_E_COUNTRY_CODE_MISMATCH, "Source and Destination country code mismatch.", false, 0x80190803);
            SetErrorDetail(DMP_E_SOURCETRANSFER_INITIATED_WITHIN_NO_TRANSFER_WINDOW, "TransferBalance initiated within the no transfer window for the source account.", false, 0x80190804);
            SetErrorDetail(DMP_E_TARGETTRANSFER_INITIATED_WITHIN_NO_TRANSFER_WINDOW, "TransferBalance initiated within the no transfer window for the target account.", false, 0x80190805);
            SetErrorDetail(DMP_E_MAX_BALANCE_TRANSFER_PROVISIONAL_EXCEEDED, "Transferred points balance exceeded the system transferred provisional max balance.", false, 0x80190806);
            SetErrorDetail(DMP_E_MAX_BALANCE_TRANSFER_PROMOTIONAL_EXCEEDED, "Transferred points balance exceeded the system transferred promotional max balance.", false, 0x80190807);
            SetErrorDetail(DMP_E_PARTIAL_TRANSFER, "TransferBalance doesnot support partial transfer,PointsToTransfer should be 0", false, 0x80190808);
            SetErrorDetail(DMP_E_SOURCE_ZERO, "Source Puid cannot be zero for the Transaction.", false, 0x80190809);
            SetErrorDetail(DMP_E_DESTINATION_ZERO, "Destination Puid cannot be zero for the Transaction.", false, 0x80190810);
            SetErrorDetail(DMP_E_DELEGATE_NOT_SUPPORTED, "DelegateUser is not supported in Transfer Balance API", false, 0x80190811);
            SetErrorDetail(DMP_E_INVALID_PMN, "PMN does not exist", false, 0x80190812);
            SetErrorDetail(DMP_DP_INVALID_DISTRIBUTION_PROGRAM, "Invalid points distribution program.", false, 0x80190813);
            SetErrorDetail(DMP_DP_INVALID_DISTRIBUTION_PROGRAM_CALLING_PARTNER, "Invalid points distribution program calling partner.", false, 0x80190814);
            SetErrorDetail(DMP_DP_INVALID_DISTRIBUTION_PROGRAM_SELLING_PARTNER, "Invalid points distribution program selling partner.", false, 0x80190815);
            SetErrorDetail(DMP_DP_INVALID_DISTRIBUTION_PROGRAM_SKU, "Invalid points distribution program SKU.", false, 0x80190816);
            SetErrorDetail(DMP_DP_INVALID_DISTRIBUTION_PROGRAM_USER, "Invalid points distribution program user.", false, 0x80190817);
            SetErrorDetail(DMP_DP_USER_NOT_ENROLLED, "User is not enrolled in the distribution program.", false, 0x80190818);
            SetErrorDetail(DMP_E_USER_DISABLED, "User is disabled.", false, 0x80190819);
            SetErrorDetail(DMP_E_MAX_ACQUISITIONPERSPAN_EXCEEDED, "The point amount acquired per period of time would exceed the policy limit.", false, 0x80190820);
            SetErrorDetail(TRANSACTION_E_AUTHORIZATION_FAILED, "Risk check rejected", false, 0x80190821);
            SetErrorDetail(TRANSACTION_E_INVALID_SUBS_RESPONSE, "Invalid Subscription component response", false, 0x80190822);
            SetErrorDetail(BILLING_E_LINEITEM_ALREADY_REFUND, "The line item has already been refunded.", false, 0x80190823);
            SetErrorDetail(BILLING_E_INVALID_TRANSACTION_STATUS, "The transaction status is in an invalid status for this operation.", false, 0x80190824);
            SetErrorDetail(BILLING_E_INVALID_CALLING_PARTER, "Either the request is not allowed of this partner or the partner information is invalid", false, 0x80190825);
            SetErrorDetail(TRANSACTION_E_INVALID_ACCOUNT_STATUS, "Invalid account status", false, 0x80190826);
            SetErrorDetail(BILLING_E_INTERNAL_SERVER_ERROR, "Server encountered unspecified error.", false, 0x80190827);
            SetErrorDetail(BILLING_E_PARITAL_CHARGE_BACK, "The partial charge back is not supported", false, 0x80190828);
            SetErrorDetail(BILLING_E_INVALID_LINE_ITEM_EVENT, "The passed in line item event id is not consistent with the server side record", false, 0x80190829);
            SetErrorDetail(TRANSACTION_E_INVALID_TRACKING_GUID, "The passed in tracking guid is not consistent with the server side record", false, 0x80190830);
            SetErrorDetail(TRANSACTION_E_EXTERNAL_TIMEOUT_ERROR, "Timeout when calling external component", true, 0x80190831);
            SetErrorDetail(BILLING_E_INVALID_TRACKING_GUID, "The passed in tracking guid is not consistent with the server side record", false, 0x80190832);
            SetErrorDetail(BILLING_E_INVALID_PAYMENT_INSTRUMENT_DETAILS, "The payment method information is invalid or the action is not applicable for this payment method", false, 0x80190833);
            SetErrorDetail(BILLING_E_INVALID_LINE_ITEM, "The passed in line item is not consistent with the server side record", false, 0x80190834);
            SetErrorDetail(BILLING_E_INVALID_BALANCE_STATUS, "The balance status is in an invalid status for this operation.", false, 0x80190835);
            SetErrorDetail(BILLING_E_INVALID_PARTNER_PAYMENT_REF, "The partner payment reference is invalid", false, 0x80190836);
            SetErrorDetail(BILLING_E_INVALID_DECLINE_CODE, "Cannot get decline type for the decline code", false, 0x80190837);
            SetErrorDetail(BILLING_E_LINEITEM_ALREADY_CHARGED_BACK, "The line item has already been charged back.", false, 0x80190838);
            SetErrorDetail(BILLING_E_INVALID_BALANCE_ID, "The passed in balance id is not consistent with the server side record", false, 0x80190839);
            SetErrorDetail(BILLING_E_INVALID_ORDER_STATUS, "The order status is in an invalid status for this operation.", false, 0x80190840);
            SetErrorDetail(BILLING_E_INVALID_OPERATION, "Unsupported server operation.", false, 0x80190841);
            SetErrorDetail(TRANSACTION_E_INVALID_ACCOUNT_RESPONSE, "Invalid Account component response", false, 0x80190842);
            SetErrorDetail(TRANSACTION_E_INVALID_OPERATION, "Unsupported server operation.", false, 0x80190843);
            SetErrorDetail(TRANSACTION_E_TRANSACTION_RACE_CONDITION, "Same trasaction was processed by other thread", false, 0x80190844);
            SetErrorDetail(BILLING_E_INVALID_ARGUMENT, "API request does not pass server side validation.", false, 0x80190845);
            SetErrorDetail(TRANSACTION_E_INVALID_PAYMENTMETHOD_RESPONSE, "Invalid PaymentMethod component response", false, 0x80190846);
            SetErrorDetail(BILLING_E_LINEITEM_ALREADY_CROSS_TRANSFERED, "The line item has already been transfered cross SA and BSS.", false, 0x80190847);
            SetErrorDetail(BILLING_E_PAYMENT_PROVIDER_DECLINE, "The payment provider declined the transaction", false, 0x80190848);
            SetErrorDetail(BILLING_E_INVALID_OFFSET_AMOUNT, "Offset amount must be greater than zero but less than or equal to original amount", false, 0x80190849);
            SetErrorDetail(TRANSACTION_E_INTERNAL_SERVER_ERROR, "Server encountered unspecified error.", true, 0x80190850);
            SetErrorDetail(BILLING_E_INVALID_LINE_ITEM_STATUS, "The line item status is in an invalid status for this operation.", false, 0x80190851);
            SetErrorDetail(TRANSACTION_E_INVALID_DMP_RESPONSE, "Invalid DMP component response", false, 0x80190852);
            SetErrorDetail(BILLING_E_PAYMENT_PROVIDER_RETRYABLE_ERROR, "The payment provider returned a retryable error.", false, 0x80190853);
            SetErrorDetail(BILLING_E_INVALID_SOFT_DESCRIPTOR, "Invalid soft descriptor.", false, 0x80190854);
            SetErrorDetail(BILLING_E_UNEXPECTED_PAYMENT_EVENT, "The payment event type is unexpected in server side.", false, 0x80190855);
            SetErrorDetail(BILLING_E_UNRECOGNIZED_MRN, "The merchant reference number is invalid.", false, 0x80190856);
            SetErrorDetail(TRANSACTION_E_INVALID_PARTNER, "Invalid partner certificate", false, 0x80190857);
            SetErrorDetail(BILLING_E_PAYMENT_PROVIDER_ERROR, "The payment provider returned an error.", false, 0x80190858);
            SetErrorDetail(TRANSACTION_E_INVALID_TAX_RESPONSE, "Invalid Tax component response", false, 0x80190859);
            SetErrorDetail(TRANSACTION_E_INVALID_RISK_RESPONSE, "Invalid risk check response", false, 0x80190860);
            SetErrorDetail(TRANSACTION_E_INVALID_ARGUMENT, "API request does not pass server side validation.", false, 0x80190861);
            SetErrorDetail(BILLING_E_INVALID_ORDER_ID, "The passed in order id is not consistent with the server side record", false, 0x80190862);
            SetErrorDetail(TRANSACTION_E_INVALID_BILLING_RESPONSE, "Invalid Billing component response", false, 0x80190863);
            SetErrorDetail(TRANSACTION_E_INVALID_PAYMENT_INSTRUMENT_STATUS, "Invalid payment instrument status", false, 0x80190864);
            //special treatment for DD error.Cannot change xonline HResults right now since console already makes use of this error code
            SetErrorDetail(TRANSACTION_E_UNSUPPORTED_DD_OPERATION, "Currently DirectDebit Purchase API only supports purchase one and at least one new subscription", false, 0x8015309A);
        }

    }
    public class CTPErrorDetail
    {
        public CTPErrorDetail(int ctpErrorCode, string message, bool retryable, HResult xonHr)
        {
            this.CTPErrorCode = ctpErrorCode;
            this.Message = message;
            this.Retryable = retryable;
            this.XonHResult = xonHr;
        }

        public int CTPErrorCode;
        public string Message;
        public bool Retryable;
        public HResult XonHResult;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\marketplace\catalog\MixOfferManagement.cs ===
﻿using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Linq;
using System.Text;
using xonline.mix.offermanagement.contract;
using xonline.mix.common;
using xonline.common.service;
using System.ServiceModel;


namespace xonline.common.marketplace.catalog
{
    public class MixOfferManagement
    {
        #region GetOffer

        /// <summary>
        /// Return an offer
        /// </summary>
        /// <param name="offerId"></param>
        /// <returns></returns>
        static public OfferV1 GetOffer(Guid offerId)
        {
            OfferV1 mixOffer = new OfferV1();

            RawCatalogDBEntities catalog = null;

            try
            {
                catalog = new RawCatalogDBEntities(CatalogDatabase.RawCatalogDBConnectionString);
            }
            catch (Exception ex)
            {
                throw new XRLException(HResult.XONLINE_E_MIX_CONNECTIONERROR, XEvent.Id.MIX_COMMON_SQL_CONNECTION_ERROR, string.Format("Exception generating entities from SQL {0}", ex.Message),true);
            }


            Offer catOffer = catalog.Offer.Where(o => o.offerId == offerId).FirstOrDefault();

            if (catOffer == null)
            {
                throw new XRLExceptionWithoutEvent(HResult.XONLINE_E_MIX_GETOFFER, ("Offer " + offerId.ToString() + " not found."),false);
            }

            if (!catOffer.MediaReference.IsLoaded)
            {
                catOffer.MediaReference.Load();
            }
            mixOffer.ProductId = catOffer.Media.mediaId;
            mixOffer.OfferId = offerId;
            mixOffer.Name = catOffer.name;

            LoadOfferInstances(catalog, mixOffer);

            LoadStoreIds(catalog, mixOffer);

            return mixOffer;
        }

        /// <summary>
        /// Load the offer instances for an offer
        /// </summary>
        /// <param name="catalog"></param>
        /// <param name="mixOffer"></param>
        static private void LoadOfferInstances(RawCatalogDBEntities catalog, OfferV1 mixOffer)
        {
            List<OfferInstanceV1> mixOfferInstances = new List<OfferInstanceV1>();

            foreach (OfferInstance catOfferInstance in catalog.OfferInstance.Where(oi => oi.Offer.offerId == mixOffer.OfferId))
            {
                OfferInstanceV1 mixOfferInstance = new OfferInstanceV1();

                mixOfferInstance.OfferInstanceId = catOfferInstance.offerInstanceId;
                if (!catOfferInstance.CountryReference.IsLoaded)
                {
                    catOfferInstance.CountryReference.Load();
                }
                mixOfferInstance.CountryCode = catOfferInstance.Country.countryCode;
                mixOfferInstance.PaymentPrice = catOfferInstance.price;
                if (!catOfferInstance.CurrencyReference.IsLoaded)
                {
                    catOfferInstance.CurrencyReference.Load();
                }
                mixOfferInstance.PaymentPriceCurrencyCode = catOfferInstance.Currency.currencyCode;
                if (!catOfferInstance.PaymentTypeReference.IsLoaded)
                {
                    catOfferInstance.PaymentTypeReference.Load();
                }
                mixOfferInstance.PaymentTypeId = catOfferInstance.PaymentType.paymentTypeId;
                mixOfferInstance.StartDate = catOfferInstance.startDateTime;
                mixOfferInstance.EndDate = catOfferInstance.endDateTime;

                LoadPackages(catalog, mixOfferInstance);

                LoadUserTypeIds(catalog, mixOfferInstance);

                if (!catOfferInstance.VisibilityLevelReference.IsLoaded)
                {
                    catOfferInstance.VisibilityLevelReference.Load();
                }
                mixOfferInstance.VisibilityLevelId = catOfferInstance.VisibilityLevel.visibilityLevelId;

                mixOfferInstances.Add(mixOfferInstance);
            }

            mixOffer.Instances = mixOfferInstances.ToArray<OfferInstanceV1>();
        }

        /// <summary>
        /// Load the offer packages for an offer instance
        /// </summary>
        /// <param name="catalog"></param>
        /// <param name="mixOfferInstance"></param>
        static private void LoadPackages(RawCatalogDBEntities catalog, OfferInstanceV1 mixOfferInstance)
        {
            List<OfferPackageV1> mixOfferPackages = new List<OfferPackageV1>();

            var q = (from o in catalog.Offer
                     join oi in catalog.OfferInstance on o.offerId equals oi.Offer.offerId
                     join oimi in catalog.OfferInstanceMediaInstance on oi.offerInstanceId equals oimi.offerInstanceId
                     join gci in catalog.GameContentInstance on oimi.mediaInstanceId equals gci.gameContentInstanceId
                     join oigci in catalog.OfferInstanceGameContentInstance on oimi.mediaInstanceId equals oigci.gameContentInstanceId
                     where mixOfferInstance.OfferInstanceId == oi.offerInstanceId
                     && oi.offerInstanceId == oigci.offerInstanceId
                     select new { gci.gameContentInstanceId, oimi.Provider.providerId, oigci.licenseExtensionBits, oimi.LicenseType.licenseTypeId, oimi.VisibilityStatus.visibilityStatusId }).Distinct();
            foreach (var qElem in q)
            {
                OfferPackageV1 mixOfferPackage = new OfferPackageV1();

                mixOfferPackage.PackageId = qElem.gameContentInstanceId;
                mixOfferPackage.ProviderId = qElem.providerId;
                mixOfferPackage.LicenseExtensionBits = qElem.licenseExtensionBits;
                mixOfferPackage.LicenseTypeId = qElem.licenseTypeId;
                mixOfferPackage.VisibilityStatusId = qElem.visibilityStatusId;

                mixOfferPackages.Add(mixOfferPackage);
            }

            mixOfferInstance.Packages = mixOfferPackages.ToArray<OfferPackageV1>();
        }

        static private void LoadStoreIds(RawCatalogDBEntities catalog, OfferV1 mixOffer)
        {
            IEnumerable<int> catOfferStores = catalog.OfferStore.Where(os => os.offerId == mixOffer.OfferId).Select(os => os.storeId);
            mixOffer.StoreIds = catOfferStores.ToArray<int>();
        }

        static private void LoadUserTypeIds(RawCatalogDBEntities catalog, OfferInstanceV1 mixOfferInstance)
        {
            IEnumerable<int> catUserTypeIds = catalog.OfferInstanceUserType.Where(oiut => oiut.offerInstanceId == mixOfferInstance.OfferInstanceId).Select(oiut => oiut.userTypeId);
            mixOfferInstance.UserTypeIds = catUserTypeIds.ToArray<int>();
        }

        #endregion

        #region ConfigureOffer

        /// <summary>
        /// Add/Update an offer
        /// </summary>
        /// <param name="mixOffer"></param>
        static public void ConfigureOffer(OfferV1 mixOffer)
        {
            RawCatalogDBEntities catalog = null;
            try
            {
                catalog = new RawCatalogDBEntities(CatalogDatabase.RawCatalogDBConnectionString);
            }
            catch (Exception ex)
            {
                throw new XRLException(HResult.XONLINE_E_MIX_CONNECTIONERROR, XEvent.Id.MIX_COMMON_SQL_CONNECTION_ERROR, string.Format("Exception generating entities from SQL {0}", ex.Message),true);
            }

            Offer catOffer = TableOperations.SavePrimitiveOffer(catalog, mixOffer.OfferId, mixOffer.ProductId, mixOffer.Name);

            ConfigureOfferInstances(catalog, catOffer, mixOffer.Instances);

            ConfigureOfferStores(catalog, catOffer, mixOffer.StoreIds);

            // TODO: Handle OptimisticConcurrencyException
            catalog.SaveChanges();
        }

        /// <summary>
        /// Add/Update offer instances
        /// </summary>
        /// <param name="catalog"></param>
        /// <param name="catOffer"></param>
        /// <param name="mixInstances"></param>
        static private void ConfigureOfferInstances(RawCatalogDBEntities catalog, Offer catOffer, OfferInstanceV1[] mixInstances)
        {
            // Add offer instances
            foreach (OfferInstanceV1 mixOfferInstance in mixInstances)
            {
                OfferInstance catOfferInstance = TableOperations.SavePrimitiveOfferInstance(catalog, catOffer, catOffer.offerId,
                    mixOfferInstance.OfferInstanceId, mixOfferInstance.CountryCode, mixOfferInstance.PaymentPrice, 
                    mixOfferInstance.PaymentPriceCurrencyCode, mixOfferInstance.PaymentTypeId, mixOfferInstance.StartDate, 
                    mixOfferInstance.EndDate, mixOfferInstance.VisibilityLevelId);

                // Add new user types
                foreach (int mixUserTypeId in mixOfferInstance.UserTypeIds)
                {
                    TableOperations.SavePrimitiveOfferInstanceUserType(catalog, catOfferInstance, mixUserTypeId);
                }

                // Remove old user types
                TableOperations.DeletePrimitiveOfferInstanceUserTypes(catalog, mixOfferInstance.UserTypeIds.ToArray<int>(), 
                    catOfferInstance.offerInstanceId);

                // NOTE: packageid == mediainstanceid
                foreach (OfferPackageV1 mixOfferPackage in mixOfferInstance.Packages)
                {
                    TableOperations.SavePrimitiveOfferInstanceMediaInstance(catalog, catOfferInstance, mixOfferPackage.PackageId, 
                        mixOfferPackage.LicenseTypeId,
                        mixOfferPackage.ProviderId, mixOfferPackage.VisibilityStatusId);

                    TableOperations.SavePrimitiveOfferInstanceGameContentInstance(catalog, catOfferInstance, 
                        mixOfferPackage.PackageId, mixOfferPackage.LicenseExtensionBits);

                    // TODO: Add OfferInstanceGameContentInstanceAsset
                }
            }
        }

        /// <summary>
        /// Add/Remove offer stores
        /// </summary>
        /// <param name="catalog"></param>
        /// <param name="catOffer"></param>
        /// <param name="mixStoreIds"></param>
        static private void ConfigureOfferStores(RawCatalogDBEntities catalog, Offer catOffer, int[] mixStoreIds)
        {
            // Add new offer stores
            foreach (int mixStoreId in mixStoreIds)
            {
                TableOperations.SavePrimitiveOfferStore(catalog, catOffer, mixStoreId);
            }

            // Remove old offer stores
            TableOperations.DeletePrimitiveOfferStores(catalog, mixStoreIds.ToArray<int>(), catOffer.offerId);
        }

        #endregion
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\marketplace\catalog\MixContentIngestion.cs ===
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using xonline.mix.contentingestion.contract;
using xonline.mix.common;
using xonline.common.service;
using System.ServiceModel;

namespace xonline.common.marketplace.catalog
{
    public class MixContentIngestion
    {
        #region GetProduct

        /// <summary>
        /// Called into from Content Ingestion Mix API
        /// Returns a Data Contract object 
        /// </summary>
        /// <param name="id">Guid</param>
        static public ProductV1 GetProduct(Guid id)
        {

              RawCatalogDBEntities catalog =null;

              try
              {
                  catalog = new RawCatalogDBEntities(CatalogDatabase.RawCatalogDBConnectionString);
              }
              catch (Exception ex)
              {
                  throw new XRLException(HResult.XONLINE_E_MIX_CONNECTIONERROR, XEvent.Id.MIX_COMMON_SQL_CONNECTION_ERROR, string.Format("Exception generating entities from SQL {0}", ex.Message),true);
              }

                //finding the instance of the media
                Media catMedia = catalog.Media.Where(m => m.mediaId == id).FirstOrDefault();
                if (catMedia == null)
                {
                    //media not found
                    throw new XRLExceptionWithoutEvent(HResult.XONLINE_E_MIX_GETPRODUCT, "Product " + id.ToString() + " not found",false);
                }


                if (!catMedia.MediaTypeReference.IsLoaded)
                {
                    catMedia.MediaTypeReference.Load();
                }
                switch (catMedia.MediaType.mediaTypeId)
                {
                    // Game
                    case (int)CatalogConstants.MediaTypeEnum.Game:
                    case (int)CatalogConstants.MediaTypeEnum.GameTrial:
                    case (int)CatalogConstants.MediaTypeEnum.GameDemo:
                    case (int)CatalogConstants.MediaTypeEnum.XboxOriginalGame:
                    case (int)CatalogConstants.MediaTypeEnum.ArcadeGame:
                    case (int)CatalogConstants.MediaTypeEnum.XNACommunityGame:
                    case (int)CatalogConstants.MediaTypeEnum.FullGame:
                    case (int)CatalogConstants.MediaTypeEnum.GamePackagedVideo:
                    case (int)CatalogConstants.MediaTypeEnum.LegacyXbox1Game:
                    case (int)CatalogConstants.MediaTypeEnum.PCGame:
                    case (int)CatalogConstants.MediaTypeEnum.ServerBackedGames:
                        GameV1 mixGame = new GameV1();
                        LoadProductInfo(catalog, mixGame, catMedia);
                        LoadMediaBaseInfo(catalog, mixGame, catMedia);
                        LoadProductBaseInfo(catalog, mixGame, catMedia);
                        LoadProductPackageInfo(catalog, mixGame);
                        return mixGame;

                    //	Game Content
                    case (int)CatalogConstants.MediaTypeEnum.GameContent:
                    case (int)CatalogConstants.MediaTypeEnum.Theme:
                        GameContentV1 mixGameContent = new GameContentV1();
                        LoadProductInfo(catalog, mixGameContent, catMedia);
                        LoadMediaBaseInfo(catalog, mixGameContent, catMedia);
                        LoadProductPackageInfo(catalog, mixGameContent);
                        return mixGameContent;

                    //	Game Consumable
                    case (int)24:
                        GameConsumableV1 mixGameConsumable = new GameConsumableV1();
                        LoadProductInfo(catalog, mixGameConsumable, catMedia);
                        LoadMediaBaseInfo(catalog, mixGameConsumable, catMedia);
                        return mixGameConsumable;
                    //image
                    case (int)CatalogConstants.MediaTypeEnum.Poster:
                    case (int)CatalogConstants.MediaTypeEnum.Image:
                    case (int)CatalogConstants.MediaTypeEnum.BoxArt:
                    case (int)CatalogConstants.MediaTypeEnum.ArtistPicture:
                    case (int)CatalogConstants.MediaTypeEnum.ScreenShot:
                    case (int)CatalogConstants.MediaTypeEnum.AlbumArt:
                    case (int)CatalogConstants.MediaTypeEnum.BackgroundArt:
                    case (int)CatalogConstants.MediaTypeEnum.SlideshowPreviewImage:
                        ImageV1 mixImage = new ImageV1();
                        LoadProductInfo(catalog, mixImage, catMedia);
                        LoadMediaBaseInfo(catalog, mixImage, catMedia);
                        LoadImageInfo(catalog, mixImage);
                        return mixImage;

                    //	Avatar Item               
                    case (int)CatalogConstants.MediaTypeEnum.AvatarItem:
                        AvatarItemV1 mixAvatarItem = new AvatarItemV1();
                        LoadProductInfo(catalog, mixAvatarItem, catMedia);
                        LoadMediaBaseInfo(catalog, mixAvatarItem, catMedia);
                        return mixAvatarItem;
                }//end switch
                throw new XRLExceptionWithoutEvent(HResult.XONLINE_E_MIX_GETPRODUCT, "Product " + id.ToString() + " is not of valid Data Contract type",false);
            }//end GetProduct

        /// <summary>
        /// Sets the ProductItem information from the retrieved RawCatalogDB values
        /// </summary>
        /// <param name="catalog">RawCatalogDBEntities</param>
        /// <param name="mixProduct">ProductItemV1</param>
        /// <param name="catMedia">Media</param>
        static private void LoadProductInfo(RawCatalogDBEntities catalog, ProductV1 mixProduct, Media catMedia)
        {
            mixProduct.ProductId = catMedia.mediaId;
        }//end LoadProductInfo

        /// <summary>
        /// Sets the MediaBase information from the retrieved RawCatalogDB values
        /// </summary>
        /// <param name="catalog">RawCatalogDBEntities</param>
        /// <param name="mixMediaBase">MediaBaseV1</param>
        /// <param name="catMedia">Media</param>
        static private void LoadMediaBaseInfo(RawCatalogDBEntities catalog, MediaBaseV1 mixMediaBase, Media catMedia)
        {
            mixMediaBase.ProductId = catMedia.mediaId;
            mixMediaBase.VisibilityDate = catMedia.visibilityDate;
            if (!catMedia.VisibilityStatusReference.IsLoaded)
                catMedia.VisibilityStatusReference.Load();
            mixMediaBase.VisibilityStatus = catMedia.VisibilityStatus.visibilityStatusId;
        }//end LoadMediaBaseInfo

        /// <summary>
        /// Sets the ProductBase information from the retrieved RawCatalogDB values
        /// </summary>
        /// <param name="catalog">RawCatalogDBEntities</param>
        /// <param name="mixProductBase">ProductBaseV1</param>
        /// <param name="catMedia">Media</param>
        static private void LoadProductBaseInfo(RawCatalogDBEntities catalog, ProductBaseV1 mixProductBase, Media catMedia)
        {
            mixProductBase.ReleaseDate = catMedia.originalReleaseDate;
            mixProductBase.GeoCheckPolicy = true;
            if (catMedia.geoCheckPolicy == 0)
            {
                mixProductBase.GeoCheckPolicy = false;
            }
        }//end LoadProductBaseInfo

        /// <summary>
        /// Loads the product package into Game Contract
        /// </summary>
        /// <param name="catalog"></param>
        /// <param name="game"></param>
        static private void LoadProductPackageInfo(RawCatalogDBEntities catalog, GameV1 game)
        {
            MediaInstance[] mediaInstances = TableOperations.GetPrimitiveMediaInstances(catalog, game.ProductId);

            game.Executables = new GameExecutableV1[mediaInstances.Length];

            for (int i = 0; i < mediaInstances.Length; i++)
            {
                game.Executables[i] = new GameExecutableV1();
                LoadProductPackageInfo(catalog, game.Executables[i], mediaInstances[i].mediaInstanceId);
            }
        }

        /// <summary>
        /// Loads the product package into GameContent
        /// </summary>
        /// <param name="catalog"></param>
        /// <param name="gameContent"></param>
        static private void LoadProductPackageInfo(RawCatalogDBEntities catalog, GameContentV1 gameContent)
        {
            MediaInstance[] mediaInstances = TableOperations.GetPrimitiveMediaInstances(catalog, gameContent.ProductId);

            gameContent.Packages = new GameContentPackageV1[mediaInstances.Length];

            for (int i = 0; i < mediaInstances.Length; i++)
            {
                gameContent.Packages[i] = new GameContentPackageV1();
                LoadProductPackageInfo(catalog, gameContent.Packages[i], mediaInstances[i].mediaInstanceId);
            }
        }

        /// <summary>
        /// Loads the ProductPackageInfo into ProductPackage COntract.Look up happens based on MediaInstanceId
        /// </summary>
        /// <param name="catalog"></param>
        /// <param name="productPackage"></param>
        /// <param name="mediaInstanceId"></param>
        static private void LoadProductPackageInfo(RawCatalogDBEntities catalog, ProductPackageV1 productPackage, Guid mediaInstanceId)
        {

            LoadProductPackageClientTypes(catalog, productPackage, mediaInstanceId);

            GameContentInstance gameContentInstance = TableOperations.GetPrimitiveGameContentInstance(catalog, mediaInstanceId);

            if (gameContentInstance != null)
            {
                if (!gameContentInstance.PackageTypeReference.IsLoaded)
                {
                    gameContentInstance.PackageTypeReference.Load();
                }


                if (!gameContentInstance.GameRegionMaskReference.IsLoaded)
                {
                    gameContentInstance.GameRegionMaskReference.Load();
                }

                productPackage.PackageId = gameContentInstance.gameContentInstanceId;
                productPackage.InstallSize = (ulong)gameContentInstance.installSize;
                productPackage.PackageSize = (ulong)gameContentInstance.packageSize;
                productPackage.PackageType = gameContentInstance.PackageType.packageTypeId;
                productPackage.ContentId = gameContentInstance.liveContentId;
                productPackage.SupportedGameRegionMask = gameContentInstance.GameRegionMask.gameRegionMaskId;

                LoadProductPackageFiles(catalog, productPackage, mediaInstanceId);

                LoadProductPackageEncryptedKey(catalog, productPackage, mediaInstanceId);
            }

        }
        /// <summary>
        /// Loads the ProductPackage Files into ProductPackageContract.
        /// </summary>
        /// <param name="catalog"></param>
        /// <param name="productPackage"></param>
        /// <param name="mediaInstanceId"></param>
        static private void LoadProductPackageFiles(RawCatalogDBEntities catalog, ProductPackageV1 productPackage, Guid mediaInstanceId)
        {
            GameContentInstanceFile[] gameContentInstanceFiles = TableOperations.GetPrimitiveGameContentInstanceFiles(catalog, mediaInstanceId);

            productPackage.Files = new FileV1[gameContentInstanceFiles.Length];

            for (int i = 0; i < gameContentInstanceFiles.Length; i++)
            {
                FileV1 file = new FileV1();
                file.FileUrl = gameContentInstanceFiles[i].fileUrl;
                file.SortOrder = gameContentInstanceFiles[i].sortOrder;
                productPackage.Files[i] = file;
            }

        }

        /// <summary>
        /// Loads the MediaInstance clienttypes into ProductPackage
        /// </summary>
        /// <param name="catalog"></param>
        /// <param name="productPackage"></param>
        /// <param name="mediaInstanceId"></param>
        static private void LoadProductPackageClientTypes(RawCatalogDBEntities catalog, ProductPackageV1 productPackage, Guid mediaInstanceId)
        {
            MediaInstanceClientType[] mediaInstanceClientTypes = TableOperations.GetPrimitiveMediaInstanceClientTypes(catalog, mediaInstanceId);

            productPackage.ClientTypes = new int[mediaInstanceClientTypes.Length];

            for (int i = 0; i < mediaInstanceClientTypes.Length; i++)
            {
                productPackage.ClientTypes[i] = mediaInstanceClientTypes[i].clientTypeId;
            }
        }

        /// <summary>
        /// Loads the Encryption Public and Private Key Info into ProductPackage
        /// </summary>
        /// <param name="catalog"></param>
        /// <param name="productPackage"></param>
        /// <param name="mediaInstanceId"></param>
        static private void LoadProductPackageEncryptedKey(RawCatalogDBEntities catalog, ProductPackageV1 productPackage, Guid mediaInstanceId)
        {
            GameContentInstanceEncryptedKey[] gameContentEncryptedKey = TableOperations.GetPrimitiveGameContentInstanceEncryptedKeys(catalog, mediaInstanceId);

            if (gameContentEncryptedKey.Length > 0)
            {
                EncryptionV1 encryptedKey = new EncryptionV1();
                encryptedKey.PublicKey = gameContentEncryptedKey[0].encryptedPublicKey;
                encryptedKey.SymKey = gameContentEncryptedKey[0].encryptedSymKey;
                productPackage.Encryption = encryptedKey;
            }
        }
        #endregion

        #region ConfigureProduct
        /// <summary>
        /// Called into from Content Ingestion Mix API
        /// Props a Data Contract object 
        /// </summary>
        /// <param name="mixProduct">ProductV1</param>
        static public void ConfigureProduct(ProductV1 mixProduct)
        {
            RawCatalogDBEntities catalog = null;
            try
            {
                catalog = new RawCatalogDBEntities(CatalogDatabase.RawCatalogDBConnectionString);
            }
            catch (Exception ex)
            {
                throw new XRLException(HResult.XONLINE_E_MIX_CONNECTIONERROR,XEvent.Id.MIX_COMMON_SQL_CONNECTION_ERROR, string.Format("Exception generating entities from SQL {0}", ex.Message),true);
            }
           
            Media catMedia = TableOperations.GetPrimitiveMedia(catalog, mixProduct.ProductId);

            if (mixProduct.GetType() == typeof(GameV1))
            {
                GameV1 mixGame = (GameV1)mixProduct;
                SaveProductBaseInfo(catalog, mixGame, catMedia, 1); //mediaTypeId to be updated when Game is implimented
                SaveGame(catalog, mixGame, catMedia);
                SaveProductPackages(catalog, mixGame, catMedia);
                catalog.SaveChanges();
                return;
            }

            if (mixProduct.GetType() == typeof(GameContentV1))
            {
                GameContentV1 mixGameContent = (GameContentV1)mixProduct;
                SaveProductBaseInfo(catalog, mixGameContent, catMedia, 18); //mediaTypeId to be updated when GameContent is implimented
                SaveProductPackages(catalog, mixGameContent, catMedia);
                catalog.SaveChanges();
                return;
            }

            if (mixProduct.GetType() == typeof(GameConsumableV1))
            {
                GameConsumableV1 mixGameConsumable = (GameConsumableV1)mixProduct;
                SaveProductBaseInfo(catalog, mixGameConsumable, catMedia, 24);
                catalog.SaveChanges();
                return;
            }

            if (mixProduct.GetType() == typeof(AvatarItemV1))
            {
                AvatarItemV1 mixAvatarItem = (AvatarItemV1)mixProduct;
                SaveMediaBaseInfo(catalog, mixAvatarItem, catMedia, 47);
                catalog.SaveChanges();
                return;
            }

            if (mixProduct.GetType() == typeof(ImageV1))
            {
                ImageV1 mixImage = (ImageV1)mixProduct;
                SaveMediaBaseInfo(catalog, mixImage, catMedia, 14);
                SaveImageInfo(catalog, mixImage, catMedia);
                catalog.SaveChanges();
                return;
            }
            throw new XRLExceptionWithoutEvent(HResult.XONLINE_E_MIX_CONFIGUREPRODUCT, "Incorrect Product Type " + mixProduct.GetType().FullName + " for mixProduct " + mixProduct.ProductId.ToString(),false);
        }//end ConfigureProduct

        /// <summary>
        /// Sets and updates the ProductBase information for RawCatalogDB
        /// Uses for Game and GameContent
        /// </summary>
        /// <param name="catalog">RawCatalogDBEntities</param>
        /// <param name="mixMediaBase">MediaBaseV1</param>
        /// <param name="catMedia">Media</param>
        static private void SaveProductBaseInfo(RawCatalogDBEntities catalog, ProductBaseV1 mixProductBase, Media catMedia, int mediaType)
        {
            byte geoCheckPolicyByte = 0;
            if (mixProductBase.GeoCheckPolicy)
            {
                geoCheckPolicyByte = 1;
            }

            TableOperations.SavePrimitiveMedia(catalog, catMedia, mixProductBase.ProductId, mediaType, 123, (DateTime)mixProductBase.ReleaseDate, mixProductBase.ReleaseDate.ToString(), (DateTime)mixProductBase.VisibilityDate, mixProductBase.VisibilityStatus, geoCheckPolicyByte);
        }//end SaveProductBaseInfo

        /// <summary>
        /// /// Sets and updates the MediaBase information for RawCatalogDB
        /// Uses for Images and Video
        /// </summary>
        /// <param name="catalog">RawCatalogDBEntities</param>
        /// <param name="mixMediaBase">MediaBaseV1</param>
        /// <param name="catMedia">Media</param>
        static private void SaveMediaBaseInfo(RawCatalogDBEntities catalog, MediaBaseV1 mixMediaBase, Media catMedia, int mediaType)
        {
            TableOperations.SavePrimitiveMedia(catalog, catMedia, mixMediaBase.ProductId, mediaType, 123, DateTime.Now, string.Empty, (DateTime)mixMediaBase.VisibilityDate, mixMediaBase.VisibilityStatus, 0);
        }//end SaveProductBaseInfo

        /// <summary>
        /// Saves the Executables from Game
        /// </summary>
        /// <param name="catalog"></param>
        /// <param name="productPackage"></param>
        /// <param name="media"></param>
        static private void SaveProductPackages(RawCatalogDBEntities catalog, GameV1 game, Media catMedia)
        {
            if (game.Executables != null)
            {
                foreach (GameExecutableV1 executable in game.Executables)
                {
                    SaveProductPackageInfo(catalog, executable, catMedia);
                }
            }
        }
        /// <summary>
        /// Saves the gamecontentPackages from Game
        /// </summary>
        /// <param name="catalog"></param>
        /// <param name="productPackage"></param>
        /// <param name="media"></param>
        static private void SaveProductPackages(RawCatalogDBEntities catalog, GameContentV1 gameContent, Media catMedia)
        {
            if (gameContent.Packages != null)
            {
                foreach (GameContentPackageV1 contentPackage in gameContent.Packages)
                {
                    SaveProductPackageInfo(catalog, contentPackage, catMedia);
                }
            }
        }
        /// <summary>
        /// Saves productpackages to Database. 
        /// </summary>
        /// <typeparam name="T"></typeparam>
        /// <param name="catalog"></param>
        /// <param name="productPackage"></param>
        static private void SaveProductPackageInfo(RawCatalogDBEntities catalog, ProductPackageV1 productPackage, Media catMedia)
        {
            MediaInstance catMediaInstance = null;

            //Save the mediaInstance
            TableOperations.SavePrimitiveMediaInstance(catalog, catMedia, productPackage.PackageId, CatalogConstants.IsAcquirable, CatalogConstants.IsAdSupported, CatalogConstants.IsPreview, out catMediaInstance);

            //Delete the Primitive MediaInstanceClientTypes which are in the contract and not in database
            TableOperations.DeletePrimitiveMediaInstanceClientTypes(catalog, productPackage.ClientTypes, catMediaInstance);

            //Save the client types
            if (productPackage.ClientTypes != null)
            {
                foreach (int clientType in productPackage.ClientTypes)
                {
                    TableOperations.SavePrimitiveMediaInstanceClientTypes(catalog, clientType, catMediaInstance);
                }
            }

            GameContentInstance gameContentInstance = null;
            //Save the GameContentInstance
            TableOperations.SavePrimitiveGameContentInstance(catalog, productPackage.PackageId, catMediaInstance, (long)productPackage.InstallSize, (long)productPackage.PackageSize, productPackage.ContentId, productPackage.PackageType, productPackage.SupportedGameRegionMask, out gameContentInstance);

            //Save the GameContentInstanceEncryptedKey
            TableOperations.SavePrimitiveGameContentInstanceEncryptedKey(catalog, productPackage.Encryption.SymKey, productPackage.Encryption.PublicKey, gameContentInstance);

            //Save the GameContentInstanceFile
            if (productPackage.Files != null)
            {
                foreach (FileV1 file in productPackage.Files)
                {
                    TableOperations.SavePrimitiveGameContentInstanceFile(catalog, Guid.NewGuid(), gameContentInstance, file.FileUrl, file.SortOrder);
                }
            }
        }

        /// <summary>
        /// Saves the GameExecutables to Database
        /// </summary>
        /// <param name="catalog"></param>
        /// <param name="gameExecutable"></param>
        /// <param name="media"></param>
        static private void SaveGameExecutableInfo(RawCatalogDBEntities catalog, GameExecutableV1 gameExecutable, Media catMedia)
        {
            SaveProductPackageInfo(catalog, gameExecutable, catMedia);
        }

        /// <summary>
        /// Saves the GameContentPackage to Database
        /// </summary>
        /// <param name="catalog"></param>
        /// <param name="gameExecutable"></param>
        /// <param name="media"></param>
        static private void SaveGameContentPackageInfo(RawCatalogDBEntities catalog, GameContentPackageV1 gameContentPackage, Media catMedia)
        {
            SaveProductPackageInfo(catalog, gameContentPackage, catMedia);
        }
        /// <summary>
        /// Saves the images into the Database
        /// </summary>
        /// <param name="catalog"></param>
        /// <param name="image"></param>
        /// <param name="catMedia"></param>
        static private void SaveImageInfo(RawCatalogDBEntities catalog, ImageV1 image, Media catMedia)
        {
            TableOperations.SavePrimitiveImage(catalog, catMedia, image.ProductId, null, null);
            //save the imageInstances
            if (image.LocalizedImageFiles != null)
            {
                foreach (LocalizedImageFileV1 file in image.LocalizedImageFiles)
                {
                    MediaInstance imageMediaInstance = null;
                    TableOperations.SavePrimitiveMediaInstance(catalog, catMedia, file.LocalizedFileId, (byte)1, (byte)0, (byte)0, out imageMediaInstance);
                    TableOperations.SavePrimitiveImageInstance(catalog, imageMediaInstance, file.Locale, file.FileUrl, file.FormatId, file.SizeId, file.FileSize);
                }
            }
            //Save the mediarelationships
            if (image.ProductRelationships != null)
            {
                foreach (ProductRelationshipV1 item in image.ProductRelationships)
                {
                    TableOperations.SavePrimitiveMediaRelationShip(catalog, catMedia, item.ProductId, catMedia.mediaId, item.RelationshipTypeId, item.SortOrder);
                }
            }
        }
        /// <summary>
        /// Loads the Image from Database
        /// </summary>
        /// <param name="catalog"></param>
        /// <param name="image"></param>
        static private void LoadImageInfo(RawCatalogDBEntities catalog, ImageV1 image)
        {
            Image catImg = TableOperations.GetPrimitiveImage(catalog, image.ProductId);
            image.ProductId = catImg.imageMediaId;

            ImageInstance[] catImageInstance = TableOperations.GetPrimitiveImageInstances(catalog, image.ProductId);
            LocalizedImageFileV1[] localizedFiles = new LocalizedImageFileV1[catImageInstance.Length];

            MediaRelationship[] catMediaRelationShip = TableOperations.GetPrimitiveMediaRelationShip(catalog, image.ProductId);
            ProductRelationshipV1[] productRelationShips = new ProductRelationshipV1[catMediaRelationShip.Length];

            //Populate the LocalizedFiles
            for (int i = 0; i < catImageInstance.Length; i++)
            {
                if (!catImageInstance[i].ImageSizeReference.IsLoaded)
                {
                    catImageInstance[i].ImageSizeReference.Load();
                }
                if (!catImageInstance[i].ImageFormatReference.IsLoaded)
                {
                    catImageInstance[i].ImageFormatReference.Load();
                }
                if (!catImageInstance[i].LocaleReference.IsLoaded)
                {
                    catImageInstance[i].LocaleReference.Load();
                }

                localizedFiles[i] = new LocalizedImageFileV1();
                localizedFiles[i].LocalizedFileId = catImageInstance[i].imageMediaInstanceId;
                localizedFiles[i].FileUrl = catImageInstance[i].fileUrl;
                localizedFiles[i].FormatId = catImageInstance[i].ImageFormat.imageFormatId;
                localizedFiles[i].SizeId = catImageInstance[i].ImageSize.imageSizeId;
                if (catImageInstance[i].fileSize.HasValue)
                {
                    localizedFiles[i].FileSize = catImageInstance[i].fileSize.Value;
                }
                ImageInstance catImageInstanceItem = catImageInstance[i];
                Locale catLocale = catalog.Locale.Where(locale => locale.locale1 == catImageInstanceItem.Locale.locale1).First();
                localizedFiles[i].Locale = catLocale.locale1;
            }

            image.LocalizedImageFiles = localizedFiles;

            //Populate the ProductRelationShips
            for (int i = 0; i < catMediaRelationShip.Length; i++)
            {
                if (!catMediaRelationShip[i].MediaRelationshipTypeReference.IsLoaded)
                {
                    catMediaRelationShip[i].MediaRelationshipTypeReference.Load();
                }
                productRelationShips[i] = new ProductRelationshipV1();
                productRelationShips[i].RelationshipTypeId = catMediaRelationShip[i].MediaRelationshipType.mediaRelationshipTypeId;
                productRelationShips[i].ProductId = catMediaRelationShip[i].mediaId;
                productRelationShips[i].SortOrder = catMediaRelationShip[i].sortOrder;
            }

            image.ProductRelationships = productRelationShips;
        }
        /// <summary>
        /// Saves the game to Database
        /// </summary>
        /// <param name="catalog"></param>
        /// <param name="game"></param>
        static private void SaveGame(RawCatalogDBEntities catalog, GameV1 game, Media catMedia)
        {
            TableOperations.SavePrimitiveGame(catalog, game.ProductId, game.LiveTitleId, catMedia);
        }
        #endregion
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\marketplace\catalogutil\CatalogHelper.cs ===
using System;
using System.Web;
using System.Xml;

using xonline.common.fse;
using xonline.common.service;

namespace xonline.common.catalogutil
{
    public class CatalogHelper
    {
        private static FseResponse Query(FseService service, FseRequest request)
        {
            FseResponse response = service.Execute(request);

            if (HResult.Succeeded(response.HResult))
            {
                CatalogHelper.CacheControl(response.Expiration);
            }

            return response;
        }

        public static XmlNode Query(FseService service, string methodName, string[] names, string[] values)
        {
            return Query(service, new FseRequest(methodName, names, values)).XmlNode;
        }

        public static XmlNode Query(FseService service, string methodName, string[] names, string[] values, ulong hashValue)
        {
            return Query(service, new FseRequest(methodName, names, values, hashValue)).XmlNode;
        }

        private static void CacheControl(DateTime expiration)
        {
            DateTime now = DateTime.UtcNow;
            if (expiration < now) return;

            HttpContext context = HttpContext.Current;
            if (context == null) return;

            TimeSpan timespan = expiration - now;
            context.Items["FeAppCacheControl"] = ((int) timespan.TotalSeconds).ToString();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\marketplace\catalogutil\CatalogPageHandler.cs ===
// CatalogPageHandler.cs
// Copyright (c) Microsoft Corporation. All Rights Reserved.

using System;

using xonline.common.fse;

namespace xonline.common.catalogutil
{
    public class CatalogPageHandler : FsePageHandler
    {
        private FsePagedResult ExtractHistory(HistoryResult historyResult, int offset, int length)
        {
            // use history result to clone the base extract result
            HistoryResult extractedResult = new HistoryResult(historyResult);

            if (offset > historyResult.NumItems)
                extractedResult.Entries = null;
            else
            {
                // do not go past the end of the items in the  page

                if (offset + length > historyResult.NumItems)
                {
                    length = historyResult.NumItems - offset;
                    if (length < 0) length = 0;
                }

                // then transfer just the entries we are extracting

                HistoryEntry[] entries = null;

                if (length > 0) {
                    entries = new HistoryEntry[length];
                    Array.Copy(historyResult.Entries, offset, entries, 0, length);
                }

                // install the new entries into the page. this will
                // update the num items and the  updated  date/time

                extractedResult.Entries = entries;
            }

            return extractedResult;
        }

        private FsePagedResult ExtractFeed(FeedResult feedResult, int offset, int length)
        {
            // use feed result to clone the base extract result
            FeedResult extractedResult = new FeedResult(feedResult);

            if (offset > feedResult.NumItems)
                extractedResult.Entries = null;
            else
            {
                // do not go past the end of the items in the  page

                if (offset + length > feedResult.NumItems)
                {
                    length = feedResult.NumItems - offset;
                    if (length < 0) length = 0;
                }

                // then transfer just the entries we are extracting

                FeedEntry[] entries = null;

                if (length > 0)
                {
                    entries = new FeedEntry[length];
                    Array.Copy(feedResult.Entries, offset, entries, 0, length);
                }

                // install the new entries into the page. this will
                // update the num items and the  updated  date/time

                extractedResult.Entries = entries;
            }

            return extractedResult;
        }

        public override FsePagedResult Extract(FsePagedResult page, int offset, int length)
        {
            FsePagedResult extractResult;
            
            if (page is FeedResult)
                extractResult = ExtractFeed((FeedResult) page, offset, length);
            else if (page is HistoryResult)
                extractResult = ExtractHistory((HistoryResult) page, offset, length);
            else {
                throw new Exception("Unexpected type, " + page.ToString());
            }

            return extractResult;
        }


        private FsePagedResult MergeFeed(FeedResult pageA, FeedResult pageB)
        {
            // make some preliminary checks to see if the pages
            // are from  the  same  query  and  are  contiguous

            if (pageA.Title != pageB.Title)
                throw new Exception("Pages have different titles");
            else if (pageA.TotalItems != pageB.TotalItems)
                throw new Exception("Pages have different total items");
            else if (pageB.NumItems > 0)
            {
                if (pageA.LastItem + 1 != pageB.FirstItem)
                {
                    throw new Exception("Pages are not contiguous");
                }
            }

            // clone this page and use that to merge the others

            FeedResult mergedPage = new FeedResult(pageA);

            // combine the two entry arrays into a single array
            // and then insert that into  the  merged  document

            int numItems = mergedPage.NumItems + pageB.NumItems;
            FeedEntry[] entries = new FeedEntry[numItems];

            if (pageA.NumItems > 0)
            {
                Array.Copy(pageA.Entries, entries, pageA.NumItems);
            }

            if (pageB.NumItems > 0)
            {
                Array.Copy(pageB.Entries, 0, entries, pageA.NumItems, pageB.NumItems);
            }

            // install the new entries into the page. this will
            // update the num items and the  updated  date/time

            mergedPage.Entries = entries;
            return mergedPage;
        }

        private FsePagedResult MergeHistory(HistoryResult pageA, HistoryResult pageB)
        {
            // make some preliminary checks to see if the pages
            // are from  the  same  query  and  are  contiguous

            if (pageA.MethodName != pageB.MethodName)
                throw new Exception("Pages have different methodNames");
            else if (pageA.TotalItems != pageB.TotalItems)
                throw new Exception("Pages have different total items");
            else if (pageB.NumItems > 0) {
                if (pageA.LastItem + 1 != pageB.FirstItem) {
                    throw new Exception("Pages are not contiguous");
                }
            }

            // clone this page and use that to merge the others

            HistoryResult mergedPage = new HistoryResult(pageA);

            // combine the two entry arrays into a single array
            // and then insert that into  the  merged  document

            int numItems = mergedPage.NumItems + pageB.NumItems;
            HistoryEntry[] entries = new HistoryEntry[numItems];

            if (pageA.NumItems > 0) {
                Array.Copy(pageA.Entries, entries, pageA.NumItems);
            }

            if (pageB.NumItems > 0) {
                Array.Copy(pageB.Entries, 0, entries, pageA.NumItems, pageB.NumItems);
            }

            // install the new entries into the page. this will
            // update the num items and the  updated  date/time

            mergedPage.Entries = entries;
            return mergedPage;
        }

        public override FsePagedResult Merge(FsePagedResult pageA, FsePagedResult pageB)
        {
            FsePagedResult mergeResult;

            if (pageA is FeedResult)
                mergeResult = MergeFeed((FeedResult) pageA, (FeedResult) pageB);
            else if (pageA is HistoryResult)
                mergeResult = MergeHistory((HistoryResult) pageA, (HistoryResult) pageB);
            else {
                throw new Exception("Unexpected type, " + pageA.ToString());
            }

            return mergeResult;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\marketplace\catalogutil\CatalogDelegates.cs ===
//
// CatalogDelegates.cs
// Copyright (c) Microsoft Corporation. All Rights Reserved.
//

using System;
using System.Net;
using System.Web;

using xonline.common.config;
using xonline.common.fse;
using xonline.common.service;

namespace xonline.common.catalogutil
{

    // Defines the known delegates for overriding parameter values
    //  in the Catalog FSE web service. These methods must all
    //  implement the FseParamDelegate signature
    public class CatalogDelegates
    {
        private FseBookmark     _bookmark;

        private const int       _variations = 3;    // Only allowing 3 sets of offsets + ip lists

        private int []          _privs;             // [_variations]
        private int []          _offsetDays;        // [_variations]
        private IPAddress [][]  _ips;               // [ip][_variations]
        private IPAddress [][]  _ipMasks;           // [mask][_variations]

        private const int       _catalogPrivBrowseLive   = 1;
        private const int       _catalogPrivBrowseStaged = 2;

        private const string    _catalogPrivSetting     = "catalog_editorial_priv";
        private const string    _catalogTimeSetting     = "catalog_editorial_time";
        private const string    _catalogIpsSetting      = "catalog_editorial_ips";

        private string []       _settings;          // List of setting names we care about


        public CatalogDelegates()
        {
            _bookmark  = new FseBookmark();

            Config.SettingChange += new SettingChangeEventHandler(SettingChange);
            Load();
        }


        public void UpdateSetting(string setting, string value)
        {
            int marker = 0;
            int variation = -1;

            if (setting.StartsWith(_catalogTimeSetting))
            {
                marker = _catalogTimeSetting.Length;
            }
            else if (setting.StartsWith(_catalogIpsSetting))
            {
                marker = _catalogIpsSetting.Length;
            }
            else if (setting.StartsWith(_catalogPrivSetting))
            {
                marker = _catalogPrivSetting.Length;
            }

            Int32.TryParse(setting.Substring(marker), out variation);

            if (variation < 0 || variation >= _variations)
            {
                throw new ConfigException(
                    HResult.XONLINE_E_CATALOG_INVALID_SETTING, "Config setting " + setting + " could not be loaded");
            }

            if (setting.StartsWith(_catalogTimeSetting))
            {
                _offsetDays[variation] = int.Parse(value);
            }
            else if (setting.StartsWith(_catalogPrivSetting))
            {
                _privs[variation] = int.Parse(value);
            }
            else if (setting.StartsWith(_catalogIpsSetting))
            {
                // value = comma separated ip + mask pairs delineated by semicolons.
                string[] values = value.Split(new char[] { ';', ',' });

                if ((values.Length % 2) != 0)
                {
                    throw new ConfigException(
                        HResult.XONLINE_E_CATALOG_INVALID_SETTING, "Config setting " + setting + " could not be loaded");
                }

                IPAddress [] ips = new IPAddress[values.Length/2];
                IPAddress [] masks = new IPAddress[values.Length/2];

                for (int i = 0; i < values.Length/2; i++)
                {
                    ips[i] = IPAddress.Parse(values[i*2].Trim());
                    masks[i] = IPAddress.Parse(values[(i*2)+1].Trim());
                }

                _ips[variation] = ips;
                _ipMasks[variation] = masks;
            }
        }


        private void Load()
        {
            _settings = new string[_variations * 3];

            _privs = new int[_variations];
            _offsetDays = new int[_variations];
            _ips = new IPAddress[_variations][];
            _ipMasks = new IPAddress[_variations][];

            for (int i=0; i<_variations; i++)
            {
                // Time offset
                _settings[i*3] = _catalogTimeSetting + (i).ToString();
                // IPs and Masks
                _settings[(i*3)+1] = _catalogIpsSetting + (i).ToString();
                // Privs
                _settings[(i*3)+2] = _catalogPrivSetting + (i).ToString();
            }

            foreach (string setting in _settings)
            {
                try
                {
                    UpdateSetting(setting, Config.GetSetting(setting));
                }
                catch (Exception)
                {
                    // it's okay if there is no setting
                }
            }
        }


        // event handler after changes to t_settings or t_setting_overrides
        public void SettingChange(object sender, SettingChangeEventArgs eventArgs)
        {
            if (-1 != Array.IndexOf(_settings, eventArgs.Setting))
            {
                UpdateSetting(eventArgs.Setting, eventArgs.ValueNew);
            }
        }

        private int EditorialClientIndex()
        {
            // Figure out who is calling
            SGInfo sg = null;
            AAInfo aa = AAInfo.IsActiveAuthAvailable ? AAInfo.Current : null;    
            string ip ="0.0.0.0";

            if(aa != null)
            {
                ip = aa.IpAddressInternet.ToString();
            }
            else if (HttpContext.Current != null)
            {
                if((sg = SGInfo.Current) != null)
                {
                    ip = sg.ClientIP.ToString();
                }
            }

            IPAddress clientIP = IPAddress.Parse(ip);

            return EditorialClientIndex(clientIP);
        }

        private int EditorialClientIndex(IPAddress clientIP)
        {
            byte [] clientBytes = clientIP.GetAddressBytes();

            for (int i=0; i < _ips.Length; i++)
            {
                if (_ips[i] == null) continue;

                for (int j=0; j < _ips[i].Length; j++)
                {
                    byte [] ipBytes = _ips[i][j].GetAddressBytes();
                    byte [] ipMask = _ipMasks[i][j].GetAddressBytes();
                    bool matched = true;

                    if (ipBytes.Length != clientBytes.Length)
                    {
                        break;
                    }

                    for (int k=0; k<clientBytes.Length; k++)
                    {
                        if ( (ipBytes[k] & ipMask[k]) != (clientBytes[k] & ipMask[k]) )
                        {
                            matched = false;
                            break;
                        }
                    }

                    if (matched)
                    {
                        return i;
                    }
                }
            }

            // if we do not find them in our list of editorial
            // ips,  then they have  no  editorial  privileges

            return -1;
        }


        private int FindDaysOffset()
        {
            int i = EditorialClientIndex();
            return i == -1 ? 0 : _offsetDays[i];
        }


        public string [] AdjustBookmarkDelegate (string [] values)
        {
            if (values.Length != 1)
            {
                throw new ParameterException(
                    HResult.XONLINE_E_FSE_PARAM_INVALID_VALUE, "Delegate expected only a single value for the Bookmark parameter");
            }

            if (_bookmark != null)
            {
                DateTime    requestTime = DateTime.UtcNow;

                // Move the time into the future if the caller is on the white list
                requestTime = requestTime.AddDays(FindDaysOffset());

                // Now adjust the bookmark value appropriately
                values = new string[1];
                values[0] = _bookmark.Adjust(requestTime).ToString();
            }

            return values;
        }


        public string[] EditorialPrivilegeDelegate(string[] values)
        {
            if (values.Length != 1)
            {
                throw new ParameterException(
                    HResult.XONLINE_E_FSE_PARAM_INVALID_VALUE, "Delegate expected only a single value for the EditorialPrivilege parameter");
            }

            values = new string[1];

            // editorial privilege is not

            int i = EditorialClientIndex();

            if (i == -1)
                values[0] = "1";
            else
            {
                values[0] = _privs[i].ToString();

                // editorial clients read through the cache
                if (HttpContext.Current != null)
                {
                    HttpContext.Current.Items[FseService.CACHE_DURATION_OVERRIDE] = "0";
                }
            }

            return values;
        }

        public string [] AdjustVisibilityLevelDelegate (string [] values)
        {
            if (values.Length != 1)
            {
                throw new ParameterException(
                    HResult.XONLINE_E_FSE_PARAM_INVALID_VALUE, "Delegate expected only a single value for the VisibilityLevel parameter");
            }
            
            // Override whatever default/client passed value
            //  with the programmatic value
            if (String.Equals(Config.Environment, "partnernet"))
            {
                values[0] = "1";
            }
            else
            {
                values[0] = "2";
            }

            return values;
        }

        public bool IPGrantsStagingAccess(string ipAddress)
        {
            int i = EditorialClientIndex(IPAddress.Parse(ipAddress));

            if (i == -1)
                return false;

            return (_privs[i] == _catalogPrivBrowseStaged);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\marketplace\dll\obj\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("DEPOT")]
[assembly:System.Reflection.AssemblyCopyright("")]
[assembly:System.Reflection.AssemblyCompany("")]
[assembly:System.Reflection.AssemblyFileVersion("12.4.56.0")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\marketplace\catalog\Constants.cs ===
﻿using System;
using System.Collections.Generic;

namespace xonline.common.marketplace.catalog
{
    public class CatalogConstants
    {
        public static readonly int CategorySystemForPublisherBits = 12000;

        public static readonly int PegiAllCountriesRatingSystem = 14;
        public static readonly int PegiFinlandRatingSystem = 4;  

        public static readonly int GameSortOrder = 0;  //Games with MediaRelationships to themselves
        public static readonly int ContentBitFilter = 0;  //to be removed in bug 47816
        public static readonly bool GameInheritRating = false;  //Game should never inherit 

        public static readonly byte IsAdSupported = (byte)0;

        public static readonly float DefaultRatingDescriptorLevel = 1.0f;

        public static readonly int XboxOriginalGameEffectiveTitleId = -129070; // 0xFFFE07D2
        public static readonly int XnaCommunityGameEffectiveTitleId = 1481508818; // 0x584E07D2

        public enum MediaTypeEnum
        {
            //Games
            Game = 1,
            XboxOriginalGame = 21,
            ArcadeGame = 23,
            XNACommunityGame = 37,
            FullGame = 38,
            GamePackagedVideo = 42,
            LegacyXbox1Game = 43,
            PCGame = 44,
            ServerBackedGames = 45,
            Marketplace = 46,

            LiveApp = 56,
            WebGame = 57,
            MobileGame = 58,

            //GameContent
            GameTrial = 5,
            GameContent = 18,
            GameDemo = 19,
            Theme = 20,
            GamerTile = 22,
            GameVideo = 30,
            GameTrailer = 34,
            MobilePDLC = 59,

            //GameConsumable
            GameConsumable = 24,
            MobileConsumable = 60,

            //Images
            Poster = 12,
            Image = 14,
            BoxArt = 15,
            ArtistPicture = 16,
            ScreenShot = 17,
            AlbumArt = 28,
            BackgroundArt = 31,
            SlideshowPreviewImage = 41,

            //AvatarItems
            AvatarItem = 47,

            //Apps
            App = 61,

            //Bundles
            Bundle = 36,

            //Points Bundle
            PointsBundle = 49,

            //LiveSubscription
            LiveSubscription = 51,
            //LiveSubscription Family
            LiveSubscriptionFamily = 53,

            //GameSubscription
            GameSubscription = 50,
            //GameSubscriptionFamily
            GameSubscriptionFamily = 54,

            //ContentSubscription
            AddonSubscription = 52,
            //ContentSubscriptionFamily
            AddonSubscriptionFamily = 55



        }


        public enum MediaRelationshipTypeEnum
        {
            //GameContent
            MediaToAssociatedDownload = 2,

            //Image
            MediaToBoxArt = 33,

            //Bundle
            BundleToAssociatedMedia = 34,

            //Subscriptions
            SubscriptionFamilyToAllowedUpgrade = 35,

            SubscriptionFamilyToAllowedDownGrade = 36,

            SubscriptionFamilyToAllowedAddon = 37

        }



        public enum TermType
        {
            Keyword = 1,

            AlternateTitle = 2
        }

        public enum OfferRelationShipTypeEnum
        {
            ConvertPlusProRate = 1,

            ConvertPlusTimeExtend = 2,

            Renew = 3,

            DefaultRenew = 4
        }


        public enum OfferType
        {
            OneTimePurchase = 1,

            Subscription = 2,

            SubscriptionTrial=3,
        }
        public enum DurationType
        {
            Months = 1,

            Days = 2,

            NonTerminating = 3
        }

        public enum IsPreview : byte
        {
            False = 0,
            True = 1,
        }

        public enum IsAcquirable : byte
        {
            False = 0,
            True = 1,
        }

        public enum UserTier : int 
        {
            Silver =3,

            Gold=6,

            Family=9,
        }

        public enum SubscriptionFrequency : int
        {
            OneTimeCharge=1,

            Monthly=2,

            Quarterly=3,

            BiAnnually=4,

            Annually=5,
        }

        public enum UserType : int
        {
            Gold=2,
            
            Silver=3,
            
            Family=4,
        }

        public enum PaymentType : int
        {
            Points=1,
            
            Token=2,
            
            Card=3,
        }

        public enum VisiblityLevel : int 
        { 
            Default=1,
            
            NoEnumerateInPartnernet=2,

            NeverEnumerate=3,
        }

        public enum VisibilityStatus : int
        {
            Unpublished=1,
            Staging=2,
            Live=3,
            Withdrawn=4,
            Deleted=5,
        }

        public enum DataType : int
        {
            Boolean=1,
            Int32=2,
            Int64=3,
            Double=4,
        }

        #region OfferConstants
        // NOTE: Using pricing rule of zero for now, which is livetools parity

        public static readonly int OfferPricingRuleId = 0;
        #endregion

        #region LocalizedDataConstants

        public static readonly int ImageFileSize = 0; // File Size never used in the Catalog, default of 0 will be used
        public static readonly string MediaLocaleCopyright = string.Empty;

        //MediaLocaleMaps
        public static readonly int DefaultLocaleLcid = 1033;

        #endregion

        #region VideoPreviewConstants
        // NOTE: VideoPreview Section of Constants
        public static readonly byte IsDRM = (byte)0;
        public static readonly int VideoPreviewAudioEncodingId = 1; // WMA
        public static readonly int VideoPreviewVideoDefinitionId = 2; // SD 
        public static readonly string VideoPreviewAspectRatio = "1.78:1";
        public static readonly string VideoPreviewResolution = String.Empty;
        public static readonly int VideoPreviewEncodingId = 8; // WMV
        public static readonly int VideoPreviewBitRate = 700;

        public static readonly int VideoPreviewProviderId = 38; // "Microsoft"
        public static readonly string VideoPreviewExternalLicenseContentId = String.Empty;
        public static readonly int VideoPreviewDRMLicenseIssuerId = 38; // "Microsoft"
        public static readonly int VideoPreviewPreviewMediaInstanceTypeId = 30; // Game Video

        public static readonly byte VideoPreviewFileSize = 0;
        public static readonly byte VideoPreviewFileIndex = 1;
        #endregion

        #region GameCapabilityCountryConstants

        /// <summary>
        /// Game capabilities from GameCapabilityCountry table without foreign key relationships
        /// </summary>
        public static readonly string[] NonFKGameCapabilityCountryPropertyNames = { 
            "offlinePlayersMin",
            "offlinePlayersMax",
            "offlineCoopPlayersMin",
            "offlineCoopPlayersMax",
            "offlineCoopHardDriveRequired",
            "offlineCoopHardDriveStorageAmount",
            "offlineSaveStorageAmount",
            "offlineSystemLinkMin",
            "offlineSystemLinkMax",
            "offlineVoiceCommands",
            "offlinePeripheralWheel",
            "offlinePeripheralGamePad",
            "offlinePeripheralArcadeStick",
            "offlinePeripheralFlightStick",
            "offlinePeripheralDancePad",
            "offlinePeripheralForceFeedbackWheel",
            "offlinePeripheralCamera",
            "offlineCustomSoundtracks",
            "offlineDolbyDigital",
            "onlineMultiplayerMin",
            "onlineMultiplayerMax",
            "onlineMultiplayerHardDriveRequired",
            "onlineCoopPlayersMin",
            "onlineCoopPlayersMax",
            "onlineCoopHardDriveRequired",
            "onlineCoopHardDriveStorageAmount",
            "onlineHardDriveRequired",
            "onlinePlayStorageAmount",
            "onlineContentDownload",
            "onlineLeaderboards",
            "onlineSpectatorMode",
            "onlineVoice",
            "onlineOnly",
            "offlineHardDriveRequired",
            "pcProcessorType1",
            "pcProcessorSpeed1",
            "pcProcessorType2",
            "pcProcessorSpeed2",
            "pcSystemMemoryAmount",
            "pcHardDriveStorageAmount",
            "pcVideoMemoryAmount",
            "pcVideoCardType1",
            "pcVideoCardType2",
            "pcSoundCardType",
            "pcDirectXType",
            "pcWindowsOSType",
            "pcNetworkRequirements",
            "pcExtendedRequirements" };

        /// <summary>
        /// Game capabilities from GameCapabilityCountry table with foreign key relationships
        /// Key: catalog FK column name
        /// Value: Entity object property name
        /// 
        /// The entity object properties are generated from the catalog, and the reason they are
        /// indexed StorageUnit, StorageUnit1, StorageUnit2, etc. is because they represent
        /// foreign key constraints to the same table, StorageUnit.  If there was a second
        /// property for a foreign key constraint to the HDTVMode catalog table, the Value
        /// property in the KeyValuePair below would be HDTVMode1.
        /// 
        /// NOTE: If entries for entiy object types other than HDTVMode or StorageUnit are added,
        /// NOTE: the corresponding client (e.g. Mix) code may need to be updated to handle these types.
        /// </summary>
        public static readonly Dictionary<string, string> FKGameCapabilityCountryPropertyNameMap = new Dictionary<string, string>()
        {
            {"offlineMaxHDTVModeId", "HDTVMode"},
            {"offlineCoopHardDriveStorageAmountUnitId", "StorageUnit"},
            {"offlineSaveStorageAmountUnitId", "StorageUnit1"},
            {"onlineCoopHardDriveStorageAmountUnitId", "StorageUnit2"},
            {"onlinePlayStorageAmountUnitId", "StorageUnit3"},
            {"pcHardDriveStorageAmountUnitId", "StorageUnit4"},
            {"pcSystemMemoryAmountUnitId", "StorageUnit5"},
            {"pcVideoMemoryAmountUnitId", "StorageUnit6"}
        };

        #endregion
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\marketplace\dll\objd\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("DEPOT")]
[assembly:System.Reflection.AssemblyCopyright("")]
[assembly:System.Reflection.AssemblyCompany("")]
[assembly:System.Reflection.AssemblyFileVersion("12.4.56.0")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\marketplace\catalogutil\CatalogResultHandler.cs ===
// CatalogResultHandler.cs
// Copyright (c) Microsoft Corporation. All Rights Reserved.

using System;
using System.Diagnostics;
using System.IO;
using System.Xml;
using System.Xml.Serialization;

using xonline.common.fse;
using xonline.common.service;

namespace xonline.common.catalogutil
{
    public class CatalogResultHandler : FseResultHandler
    {
        public FseResult Create(XmlReader reader)
        {
            XmlSerializer serializer;
            serializer = new XmlSerializer(typeof(FeedResult), "http://www.w3.org/2005/Atom");

            if (serializer.CanDeserialize(reader))
            {
                FeedResult feedResult = (FeedResult)serializer.Deserialize(reader);

                // sanity check to avoid exception in formatting NULL
                if (feedResult != null)
                {
                    feedResult.FormatPriceForLocalCurrency();
                }

                return (FseResult) feedResult;
            }

            serializer = new XmlSerializer(typeof(SubscriptionOfferResult));

            if (serializer.CanDeserialize(reader))
            {
                return (FseResult)serializer.Deserialize(reader);
            }

            serializer = new XmlSerializer(typeof(HistoryResult));

            if (serializer.CanDeserialize(reader))
            {
                return (FseResult) serializer.Deserialize(reader);
            }

            serializer = new XmlSerializer(typeof(ExceptionResult));

            if (serializer.CanDeserialize(reader))
            {
                ExceptionResult exceptionResult = (ExceptionResult)serializer.Deserialize(reader);
                if (exceptionResult._stack == null) exceptionResult._stack = new StackTrace().ToString();
                if (exceptionResult._hResult == null) exceptionResult._hResult = "0x" + HResult.XONLINE_E_CATALOG_ERROR.ToString("X");

                return exceptionResult;
            }

            // last ditch result reader (reads anything that begins with
            // root tag <Result>.  Used by SubmitPodcast,  ReportConcern

            serializer = new XmlSerializer(typeof(ResultResult));

            if (serializer.CanDeserialize(reader))
            {
                return (FseResult) serializer.Deserialize(reader);
            }

            throw new Exception("Cannot deserialize result");
        }

        public FseResult Create(byte[] bytes)
        {
            using (MemoryStream memoryStream = new MemoryStream(bytes))
            {
                XmlReaderSettings settings = new XmlReaderSettings();
                settings.IgnoreWhitespace = true;
                settings.CloseInput = true;

                using (XmlReader reader = XmlReader.Create(memoryStream, settings))
                {
                    return Create(reader);
                }
            }
        }

        public FseResult Create(XmlDocument document)
        {
            XmlReaderSettings settings = new XmlReaderSettings();
            settings.IgnoreWhitespace = true;
            settings.CloseInput = true;

            using (StringReader stringReader = new StringReader(document.OuterXml))
            {
                using (XmlReader reader = XmlReader.Create(stringReader, settings))
                {
                    return Create(reader);
                }
            }
        }

        internal static XmlDocument Filter(
            XmlDocument document
        )
        {
            string innerXml = document.DocumentElement.InnerXml;
            int length = innerXml.Length;

            // find all namespaces on root element and remove
            // them from all inner elements in  the  document

            foreach (XmlAttribute attribute in document.DocumentElement.Attributes)
            {
                if (attribute.Name.StartsWith("xmlns"))
                {
                    string s = string.Format(" {0}=\"{1}\"", attribute.Name, attribute.Value);
                    innerXml = innerXml.Replace(s, string.Empty);
                }
            }

            // any replacements will cause  a  change in length.
            // only replace the document if the length  changed

            if (innerXml.Length != length)
            {
                document.DocumentElement.InnerXml = innerXml;
            }

            return document;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\marketplace\catalogutil\CatalogResult.cs ===
// CatalogResult.cs
// Copyright (c) Microsoft Corporation. All Rights Reserved.

using System;
using System.IO;
using System.Text;
using System.Xml;
using System.Xml.Serialization;

using xonline.common.fse;
using xonline.common.service;
using xonline.common.billing;

namespace xonline.common.catalogutil
{
    [XmlRootAttribute("Exception")]
    public class ExceptionResult : FseExceptionResult
    {
        [XmlElement(ElementName = "Type")]
        public string _type;

        [XmlElement(ElementName = "Message")]
        public string _message;

        [XmlElement(ElementName = "HResult")]
        public string _hResult;

        [XmlElement(ElementName = "EventId")]
        public uint _eventId;

        [XmlElement(ElementName = "Stack")]
        public string _stack;

        [XmlIgnore]
        public uint EventId
        {
            get { return _eventId; }
        }

        [XmlIgnore]
        public HResult HResult
        {
            get
            {
                if (string.IsNullOrEmpty(_hResult)) return xonline.common.service.HResult.XONLINE_E_CATALOG_ERROR;
                string hResult = _hResult.Trim();

                while (hResult.StartsWith("0")) hResult = hResult.Substring(1);
                if (hResult.StartsWith("x") || hResult.StartsWith("X")) hResult = hResult.Substring(1);
                return HResult.Parse(hResult);
            }

            set
            {
                _hResult = value.ToString();
            }
        }

        [XmlIgnore]
        public string Message
        {
            get { return _message == null ? string.Empty : _message; }
        }

        [XmlIgnore]
        public string Stack
        {
            get { return _stack == null ? string.Empty : _stack; }
        }

        [XmlIgnore]
        public string Type
        {
            get { return _type == null ? string.Empty : _type; }
        }

        public XmlDocument GetDocument()
        {
            StringWriter stringWriter = new StringWriter();
            XmlSerializer serializer = new XmlSerializer(typeof(ExceptionResult));
            serializer.Serialize(stringWriter, this);

            XmlDocument document = new XmlDocument();
            document.LoadXml(stringWriter.ToString());
            return document;
        }

        public byte[] GetBytes()
        {
            StringWriter stringWriter = new StringWriter();
            XmlSerializer serializer = new XmlSerializer(typeof(ExceptionResult));
            serializer.Serialize(stringWriter, this);

            UnicodeEncoding encoding = new UnicodeEncoding();
            return encoding.GetBytes(stringWriter.ToString());
        }
    }

    [XmlRootAttribute("Results")]
    public class ResultResult : FseResult
    {
        [XmlAnyElement]
        public XmlElement[] elements;

        public XmlDocument GetDocument()
        {
            StringWriter stringWriter = new StringWriter();
            XmlSerializer serializer = new XmlSerializer(typeof(ResultResult));
            serializer.Serialize(stringWriter, this);

            XmlDocument document = new XmlDocument();
            document.LoadXml(stringWriter.ToString());
            return document;
        }

        public byte[] GetBytes()
        {
            StringWriter stringWriter = new StringWriter();
            XmlSerializer serializer = new XmlSerializer(typeof(ResultResult));
            serializer.Serialize(stringWriter, this);

            UnicodeEncoding encoding = new UnicodeEncoding();
            return encoding.GetBytes(stringWriter.ToString());
        }
    }

    [XmlRootAttribute("feed")]
    public class FeedResult : FsePagedResult
    {
        public FeedResult()
        {
            this._updated = DateTime.UtcNow;
        }

        internal FeedResult(FeedResult page)
        {
            this._totalItems = page._totalItems;
            this._numItems = page._numItems;
            this._title = page._title;
            this._updated = page._updated;
            this._legalLcid = page._legalLcid;
            this._entries = page._entries;
        }

        [XmlElement(ElementName = "totalItems", Namespace = "http://www.live.com/marketplace")]
        public int _totalItems;

        [XmlElement(ElementName = "numItems", Namespace = "http://www.live.com/marketplace")]
        public int _numItems;

        [XmlElement(ElementName = "title")]
        public string _title;

        [XmlElement(ElementName = "updated")]
        public DateTime _updated;

        // appears for FindGameOffers only
        [XmlElement(ElementName = "legalLcid", Namespace = "http://www.live.com/marketplace")]
        public string _legalLcid; // like 1033

        // appears for FindSubscriptionProducts only
        [XmlElement(ElementName = "version", Namespace = "http://www.live.com/marketplace")]
        public string _version; 

        [XmlElement(ElementName = "entry")]
        public FeedEntry[] _entries;

        [XmlIgnore]
        internal FeedEntry[] Entries
        {
            get { return _entries; }

            set
            {
                _entries = value;

                if ((_entries == null) || (_entries.Length == 0))
                {
                    _numItems = 0;
                    _entries = null;
                }

                else
                {
                    _numItems = _entries.Length;
                    _updated = DateTime.MinValue;

                    if (LastItem - FirstItem + 1 != _entries.Length)
                    {
                        throw new Exception("Invalid item number");
                    }

                    // make sure the updated time  reflects
                    // the entries we just put in the array

                    foreach (FeedEntry entry in _entries)
                    {
                        if (entry.Updated > _updated) _updated = entry.Updated;
                    }
                }
            }
        }

        [XmlIgnore]
        public int FirstItem
        {
            get
            {
                if (_entries == null) return 0;
                return _entries[0].ItemNum - 1;
            }
        }

        [XmlIgnore]
        public int LastItem
        {
            get
            {
                if (_entries == null) return 0;
                return _entries[_entries.Length - 1].ItemNum - 1;
            }
        }

        [XmlIgnore]
        public int NumItems
        {
            get { return _numItems; }
        }

        [XmlIgnore]
        internal string Title
        {
            get { return _title; }
        }

        [XmlIgnore]
        public int TotalItems
        {
            get { return _totalItems; }
        }

        [XmlIgnore]
        internal DateTime Updated
        {
            get { return _updated; }
            set { _updated = value; }
        }

        [XmlIgnore] // this appears in output of FindGameOffers only
        internal int LegalLcid
        {
            get {
                   if (string.IsNullOrEmpty(_legalLcid)) return 0;
                   return Convert.ToInt32(_legalLcid); 
                }
        }

        //xml element any is added to support version attribute in findsubscriptionproducts
        [XmlAnyElement]
        public XmlElement[] elements;

        private MemoryStream Serialize()
        {
            XmlWriterSettings xmlWriterSettings = new XmlWriterSettings();
            xmlWriterSettings.Indent = false;

            MemoryStream memoryStream = new MemoryStream();
            XmlWriter xmlWriter = XmlWriter.Create(memoryStream, xmlWriterSettings);
            XmlSerializer serializer = new XmlSerializer(typeof(FeedResult), "http://www.w3.org/2005/Atom");

            XmlSerializerNamespaces serializerNamespaces = new XmlSerializerNamespaces();
            serializerNamespaces.Add("live", "http://www.live.com/marketplace");
            serializer.Serialize(xmlWriter, this, serializerNamespaces);

            memoryStream.Seek(0, SeekOrigin.Begin);
            return memoryStream;
        }

        public XmlDocument GetDocument()
        {
            XmlDocument document = new XmlDocument();
            document.Load(Serialize());
            return CatalogResultHandler.Filter(document);
        }

        public byte[] GetBytes()
        {
            return Serialize().ToArray();
        }

        public void FormatPriceForLocalCurrency()
        {
            // sanity check - no entries - do no formatting.
            if (_entries == null || _entries.Length < 1) return;

            // because public property accessor LegalLcid {get ... } converts "string" to "int" everytime it gets called
            // we cach its value in local variable for further use in the foreach loop (one conversion only)
            int legalLcid = LegalLcid;

            if (legalLcid == 0) return; // sanity check for missing legalLcid value

            foreach (FeedEntry entry in _entries)
            {
                if (entry.FeedSubscriptions != null)
                {
                    foreach (FeedSubscription feedSubscription in entry.FeedSubscriptions)
                    {
                        if (feedSubscription.feedSubscriptionOffers != null && feedSubscription.feedSubscriptionOffers.feedSubscriptionOffer != null)
                        {
                            foreach (FeedSubscriptionOffer feedoffer in feedSubscription.feedSubscriptionOffers.feedSubscriptionOffer)
                            {
                                if (feedoffer.feedSubscriptionOfferInstances != null && feedoffer.feedSubscriptionOfferInstances.feedSubscriptionOfferInstanceItems != null)
                                {
                                    foreach (FeedSubscriptionOfferInstance feedOfferInstance in feedoffer.feedSubscriptionOfferInstances.feedSubscriptionOfferInstanceItems)
                                    {
                                        if (feedOfferInstance.priceText != null)
                                        {
                                            feedOfferInstance.priceText = FormatPrice(feedOfferInstance.paymentType, feedOfferInstance.price, legalLcid);
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
                if (entry.Offer != null && entry.Offer.feedOfferInstances != null)
                {

                    FeedOfferInstance[] offerInstanceBag = entry.Offer.feedOfferInstances.feedOfferInstance;
                    if (offerInstanceBag == null || offerInstanceBag.Length < 1) break; // no offerInstances - nothing to format

                    // update priceText property according to local culture
                    foreach (FeedOfferInstance offerInstanceItem in offerInstanceBag)
                    {
                        // sanity check for offerInstanceItem.priceText value before running Price.XeFormatPrice()
                        if (string.IsNullOrEmpty(offerInstanceItem.priceText))
                        {
                            offerInstanceItem.priceText = null; // assign "null" to avoid back-serialization (nulls are ingnored by CLR).
                            break;
                        }
                        offerInstanceItem.priceText = FormatPrice(offerInstanceItem.paymentType, offerInstanceItem.price, legalLcid);
                    }
                }
            }
        }
        private string FormatPrice(uint paymentType, decimal price, int legalLcid)
        {
            // priceText XML node value, supplied by FindGmeOffers sproc comes enumerated as EMS paymentType (CatalogPaymentTypeEnum) 
            // but XeFormatPrice() expects UODB PaymentTypeEnum; so additional enum-to-enum convertion needed.
            uint currentPaymentType = CatalogUtil.CatalogPaymentTypeToUodbPaymentType(paymentType);  // converting EMSPaymentType into UODBPaymentType

            return Price.XeFormatPrice(currentPaymentType, Convert.ToDouble(price), legalLcid);
        }
    }


    public class FeedOfferInstance
    {
        [XmlElement(ElementName = "price")]
        public decimal price;

        [XmlElement(ElementName = "priceText")]
        public string priceText;

        [XmlElement(ElementName = "paymentType")]
        public uint paymentType;

        [XmlAnyElement]
        public XmlElement[] elements;
    }

    public class FeedOfferInstances
    {
        [XmlElement(ElementName = "offerInstance", Namespace = "http://www.live.com/marketplace")]
        public FeedOfferInstance[] feedOfferInstance;

        [XmlAnyElement]
        public XmlElement[] elements;
    }

    public class FeedOffer
    {
        [XmlElement(ElementName = "offerInstances")]
        public FeedOfferInstances feedOfferInstances;

        [XmlAnyElement]
        public XmlElement[] elements;
    }

    public class FeedEntry
    {
        [XmlAttribute(AttributeName = "itemNum", Namespace = "http://www.live.com/marketplace")]
        public int ItemNum;

        [XmlAttribute(AttributeName = "detailView", Namespace = "http://www.live.com/marketplace")]
        public int DetailView;

        public string id;

        [XmlElement(ElementName = "updated")]
        public DateTime Updated;

        // [AidynCh]: do we have always one offer by design and therefore is it safe to use FeedOffer instead of FeedOffer[] here
        [XmlElement(ElementName = "offer", Namespace = "http://www.live.com/marketplace")]
        public FeedOffer Offer;

        [XmlElement(ElementName = "subscription", Namespace = "http://www.live.com/marketplace")]
        public FeedSubscription[] FeedSubscriptions;

        [XmlAnyElement]
        public XmlElement[] elements;
    }

    /// <summary>
    /// Class/object to deserialize subscription results into
    /// Contains 1)Offers 2)Other xml elements like localized data, tier information and mediatypeid
    /// </summary>
    public class FeedSubscription
    {
        [XmlElement(ElementName = "offers")]
        public FeedSubscriptionOffers feedSubscriptionOffers;

        [XmlAnyElement]
        public XmlElement[] elements;
    }

    /// <summary>
    /// Class/Object to deserialize Offer collection in Subscription
    /// Contains 1)Collection of offers 2)Other xml elements like OfferId and LegacyOfferId
    /// </summary>
    public class FeedSubscriptionOffers
    {
        [XmlElement(ElementName = "offer")]
        public FeedSubscriptionOffer[] feedSubscriptionOffer;

        [XmlAnyElement]
        public XmlElement[] elements;
    }

    /// <summary>
    /// Class/object to deserialize every Offer in Offers
    /// Contains a)OfferInstances
    /// </summary>
    public class FeedSubscriptionOffer
    {
        [XmlElement(ElementName = "offerInstances")]
        public FeedSubscriptionOfferInstances feedSubscriptionOfferInstances;

        [XmlAnyElement]
        public XmlElement[] elements;
    }

    /// <summary>
    /// Class/Object to deserialialize OfferInstance collection within an Offer
    /// </summary>
    public class FeedSubscriptionOfferInstances
    {
        [XmlElement(ElementName = "offerInstance")]
        public FeedSubscriptionOfferInstance[] feedSubscriptionOfferInstanceItems;

        [XmlAnyElement]
        public XmlElement[] elements;
    }

    /// <summary>
    /// Class/Object to deserialize every OfferInstance in OfferInstance collection
    /// Contains price and payment information and localized price text
    /// </summary>
    public class FeedSubscriptionOfferInstance
    {
        [XmlElement(ElementName = "price")]
        public decimal price;

        [XmlElement(ElementName = "priceText")]
        public string priceText;

        [XmlElement(ElementName = "paymentType")]
        public uint paymentType;

        [XmlAnyElement]
        public XmlElement[] elements;
    }

    [XmlRootAttribute("results")]
    public class HistoryResult : FsePagedResult
    {
        public HistoryResult()
        {
        }

        internal HistoryResult(HistoryResult result)
        {
            this._methodName = result._methodName;
            this._totalItems = result._totalItems;
            this._numItems = result._numItems;
            this._entries = result._entries;
        }

        [XmlAttribute(AttributeName = "methodName")]
        public string _methodName;

        [XmlAttribute(AttributeName = "totalItems")]
        public int _totalItems;

        [XmlAttribute(AttributeName = "numItems")]
        public int _numItems;

        [XmlElement(ElementName = "a")]
        public HistoryEntry[] _entries;

        [XmlIgnore]
        internal HistoryEntry[] Entries
        {
            get { return _entries; }

            set
            {
                _entries = value;

                if ((_entries == null) || (_entries.Length == 0))
                {
                    _numItems = 0;
                    _entries = null;
                }

                else
                {
                    _numItems = _entries.Length;

                    if (LastItem - FirstItem + 1 != _entries.Length)
                    {
                        throw new Exception("Invalid item number");
                    }
                }
            }
        }

        [XmlIgnore]
        public int FirstItem
        {
            get
            {
                if (_entries == null) return 0;
                return _entries[0].ItemNum - 1;
            }
        }

        [XmlIgnore]
        public int LastItem
        {
            get
            {
                if (_entries == null) return 0;
                return _entries[_entries.Length - 1].ItemNum - 1;
            }
        }

        [XmlIgnore]
        internal string MethodName
        {
            get { return _methodName; }
        }

        [XmlIgnore]
        public int NumItems
        {
            get { return _numItems; }
        }

        [XmlIgnore]
        public int TotalItems
        {
            get { return _totalItems; }
        }

        private MemoryStream Serialize()
        {
            XmlWriterSettings xmlWriterSettings = new XmlWriterSettings();
            xmlWriterSettings.Indent = false;

            MemoryStream memoryStream = new MemoryStream();
            XmlWriter xmlWriter = XmlWriter.Create(memoryStream, xmlWriterSettings);
            XmlSerializer serializer = new XmlSerializer(typeof(HistoryResult));

            serializer.Serialize(xmlWriter, this);
            memoryStream.Seek(0, SeekOrigin.Begin);
            return memoryStream;
        }

        public XmlDocument GetDocument()
        {
            XmlDocument document = new XmlDocument();
            document.Load(Serialize());
            return CatalogResultHandler.Filter(document);
        }

        public byte[] GetBytes()
        {
            return Serialize().ToArray();
        }
    }


    public class HistoryEntry
    {
        [XmlAttribute(AttributeName = "sortIndex")]
        public int ItemNum;

        [XmlAnyAttribute]
        public XmlAttribute[] attributes;
    }


    [XmlRootAttribute("subscriptionresults")]
    public class SubscriptionOfferResult : FsePagedResult
    {
        public SubscriptionOfferResult()
        {
        }

        internal SubscriptionOfferResult(SubscriptionOfferResult result)
        {
            this._totalItems = result._totalItems;
            this._numItems = result._numItems;
            this._entries = result._entries;
            this._locale = result._locale;
            this._tier = result._tier;

        }

        [XmlAttribute(AttributeName = "tier")]
        public int _tier;

        [XmlAttribute(AttributeName = "locale")]
        public string _locale;

        [XmlAttribute(AttributeName = "numItems")]
        public int _numItems;

        [XmlAttribute(AttributeName = "totalItems")]
        public int _totalItems;

        [XmlElement(ElementName = "a")]
        public SubcriptionOfferEntry[] _entries;

        [XmlIgnore]
        internal SubcriptionOfferEntry[] Entries
        {
            get { return _entries; }

            set
            {
                _entries = value;

                if ((_entries == null) || (_entries.Length == 0))
                {
                    _numItems = 0;
                    _entries = null;
                }

                else
                {
                    _numItems = _entries.Length;

                    if (LastItem - FirstItem + 1 != _entries.Length)
                    {
                        throw new Exception("Invalid item number");
                    }
                }
            }
        }

        [XmlIgnore]
        public int FirstItem
        {
            get
            {
                if (_entries == null) return 0;
                return _entries[0].ItemNum - 1;
            }
        }

        [XmlIgnore]
        public int LastItem
        {
            get
            {
                if (_entries == null) return 0;
                return _entries[_entries.Length - 1].ItemNum - 1;
            }
        }


        [XmlIgnore]
        public int NumItems
        {
            get { return _numItems; }
        }

        [XmlIgnore]
        public int TotalItems
        {
            get { return _totalItems; }
        }

        private MemoryStream Serialize()
        {
            XmlWriterSettings xmlWriterSettings = new XmlWriterSettings();
            xmlWriterSettings.Indent = false;

            MemoryStream memoryStream = new MemoryStream();
            XmlWriter xmlWriter = XmlWriter.Create(memoryStream, xmlWriterSettings);
            XmlSerializer serializer = new XmlSerializer(typeof(SubscriptionOfferResult));

            serializer.Serialize(xmlWriter, this);
            memoryStream.Seek(0, SeekOrigin.Begin);
            return memoryStream;
        }

        public XmlDocument GetDocument()
        {
            XmlDocument document = new XmlDocument();
            document.Load(Serialize());
            return CatalogResultHandler.Filter(document);
        }

        public byte[] GetBytes()
        {
            return Serialize().ToArray();
        }
    }

    public class SubcriptionOfferEntry
    {
        [XmlAnyAttribute]
        public XmlAttribute[] attributes;

        [XmlAttribute(AttributeName = "itemNum")]
        public int ItemNum;
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\marketplace\dll\Installer.cs ===
using System;
using System.ComponentModel;

using xonline.common.installer;
using xonline.common.mgmt;

namespace xonline.marketplace
{
    [RunInstaller(true)]
    public class MarketplaceInstaller : XomConfiguratorInstall
    {
    }

    [RunInstaller(true)]
    public class MarketplacePerformanceCounterInstaller : XomPerformanceCounterInstall
    {
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\marketplace\espengine\EspEngine.cs ===
using System;
using System.Collections;
using System.Collections.Specialized;
using System.Collections.Generic;
using System.Xml;
using System.IO;
using System.Data;
using System.Data.SqlClient;
using System.Text;
using System.Security;
using System.Xml.XPath;
using System.Xml.Xsl;

using Com.FastSearch.Esp.Search;
using Com.FastSearch.Esp.Search.Query;
using Com.FastSearch.Esp.Search.Result;
using Com.FastSearch.Esp.Search.View;

using xonline.common.billing;
using xonline.common.service;
using xonline.common.sql.sqlclient;
using xonline.common.config;
using xonline.common.mgmt;
using xonline.common.fse;
using xonline.common.utilities;

[assembly: XomAreaDefinition(XomAreaName.espengine)]

namespace xonline.common.espengine
{
    /// <summary>
    /// EspEngine class
    ///
    /// This class handles querying the ESP server for data. It takes a Hashtable
    /// of all of the parameters passed up by the client via FSE, called the  Filter
    /// Criteria. These parameters will have already be checked for number of occurences,
    /// and values defaulted if appropriate.
    ///
    /// The following stages will occur for each query call
    ///
    /// First,  the filter criteria is converted into its equivalent FQL
    /// Second, the FQL is submitted to FAST ESP
    /// Third,  the resulting XML documents are parsed for rule information
    ///         (For example, offer instances are stripped out based on datetime values)
    /// Fourth, each individual XML document is converted into the overall
    ///         result set and returned as an XmlReader
    /// </summary>
    public class EspEngine : FsePlugin
    {
        private Dictionary<string, Dictionary<string, FqlType>> fqlMappingDictionary = new Dictionary<string, Dictionary<string, FqlType>>();
        private string virtualCollectionName = string.Empty;
        private ISearchView searchView = null;
        private string[] ignoreReturnNodesFromResults = { string.Intern("match"), string.Intern("matches") };
        private string[] nodeNamesToAtomize = { string.Intern("id"), string.Intern("title"), string.Intern("content"), string.Intern("updated") };

        private static readonly Char[] attributeRuleSplit = new Char[] { ';' };
        private static readonly Char[] syntaxSplit = new Char[] { '.', '_' };
        private static readonly string xmlHeader = "<?xml version=\"1.0\" encoding=\"UTF-8\"?> <a:feed xmlns:a=\"http://www.w3.org/2005/Atom\" xmlns=\"http://marketplace.xboxlive.com/resource/product/v1\">"
                                                 + "<a:author><a:name>Xbox LIVE</a:name></a:author>"
                                                 + "<a:id>http://marketplace.xboxlive.com/resource/product/v1</a:id>"
                                                 + "<a:title>Query Result</a:title>";
        private static readonly string xmlFooter = "</a:feed>";
        private static readonly Dictionary<Int32, string> NavigatorParameters = new Dictionary<int, string>();

        private static readonly Dictionary<Int32, SearchParameter> OrderByParameters = new Dictionary<int,SearchParameter>();
        private static readonly Dictionary<String, Hashtable> RemapParameters = new Dictionary<string, Hashtable>();
        private static readonly SearchParameter DefaultOrderByParameter = new SearchParameter(BaseParameter.SORT_BY, "+sorttitle");
        private static readonly int SEARCH_TERM_LENGTH = 255;
        private DateTime lastSearchViewSetup = DateTime.MinValue;
        private bool allowDebugXslt = false;

        public EspEngine()
        {
            Init();
        }

        /// <summary>
        /// Initialization will retrieve all of the appropriate FQL mappings. These vlaues will be stored in
        /// the fqlMappingDictionary.
        ///
        /// The appropriate FQL type can be retrieved by using the client parameter name as the key.
        /// </summary>
        private void Init()
        {
            try
            {
                SetupSearchView();

                // Get virtual collection name
                virtualCollectionName = Config.GetSetting("catalogwatcher_fast_esp_virtual_collection_name");

                // Setup FQL mapping table
                using (SqlClient sqlClient = new SqlClient(Interface.npdb, false))
                {
                    sqlClient.StoredProc = "dbo.p_fql_get_mapping";

                    using (SqlDataReader r = sqlClient.Execute())
                    {
                        while (r.Read())
                        {
                            bool isEnforceSyntax = r.GetByte(r.GetOrdinal("ti_enforce_syntax")) == 1;
                            bool isEnforceScope = r.GetByte(r.GetOrdinal("ti_enforce_scope")) == 1;
                            string fqlMapping = r.GetString(r.GetOrdinal("vc_fql_mapping"));
                            string clientParameter = r.GetString(r.GetOrdinal("vc_fql_parameter"));
                            string dataType = r.GetString(r.GetOrdinal("vc_data_type"));
                            string queryType = r.GetString(r.GetOrdinal("vc_query_type"));
                            bool isNonSearchable = r.GetByte(r.GetOrdinal("ti_non_searchable_filter")) == 1;
                            bool isOfferFilter = r.GetByte(r.GetOrdinal("ti_offer_filter")) == 1;
                            bool isFlatFilterFql = r.GetByte(r.GetOrdinal("ti_flat_filter")) == 1;
                            bool isRollupFilter = r.GetByte(r.GetOrdinal("ti_rollup_filter")) == 1;
                            bool isRootLevelSearch = r.GetByte(r.GetOrdinal("ti_root_level_search")) == 1;
                            string antiPhrasingMode = r.IsDBNull(r.GetOrdinal("vc_antiphrase_mode")) ? null : r.GetString(r.GetOrdinal("vc_antiphrase_mode"));

                            FqlType fqlType = FqlTypeFactory.GetFqlType(isEnforceSyntax, isEnforceScope,
                                                                    fqlMapping, clientParameter, dataType,
                                                                    isNonSearchable, isOfferFilter, isFlatFilterFql, isRollupFilter, isRootLevelSearch,
                                                                    antiPhrasingMode);

                            // Add to the dictionary..
                            if (!fqlMappingDictionary.ContainsKey(queryType))
                            {
                                fqlMappingDictionary[queryType] = new Dictionary<string, FqlType>();
                            }
                            fqlMappingDictionary[queryType].Add(clientParameter.ToLower(), fqlType);

                            Xom.Log(XomAreaName.espengine, String.Format("Adding FQL to mapping dictionary|queryType:{0}|clientParameter:{1}|fqlTypeInformation:{2}", queryType, clientParameter, fqlType.ToString()));
                        }
                    }
                }

                // Set up the 'order by' parameters.
                foreach (string orderby in Config.GetMultiSetting(MultiSetting.fastEspOrderByParameters))
                {
                    if (orderby.Contains("."))
                    {
                        string keyString = orderby.Split('.')[0];
                        int keyInt;
                        if (int.TryParse(keyString, out keyInt))
                        {
                            string value = orderby.Split('.')[1];
                            OrderByParameters[keyInt] = new SearchParameter(BaseParameter.SORT_BY, value);
                            Xom.Log(XomAreaName.espengine, String.Format("Adding order by|order by number:{0}|order by value:{1}", keyInt, value));
                        }
                        else
                        {
                            throw new Exception(String.Format("Unable to convert string to int: [{0}], for order by: [{1}]",keyString,orderby));
                        }
                    }
                    else
                    {
                        throw new Exception(String.Format("Deliminator . not in setting for order by: [{0}]", orderby));
                    }
                }

                // Set up the navigators
                foreach (string navigator in Config.GetMultiSetting(MultiSetting.fastEspNavigatorParameters))
                {
                    if (navigator.Contains("."))
                    {
                        string keyString = navigator.Split('.')[0];
                        int keyInt;
                        if (int.TryParse(keyString, out keyInt))
                        {
                            string value = navigator.Split('.')[1];
                            NavigatorParameters[keyInt] = value;
                            Xom.Log(XomAreaName.espengine, String.Format("Adding navigator|navigator number:{0}|navigator value:{1}", keyInt, value));
                        }
                        else
                        {
                            throw new Exception(String.Format("Unable to convert string to int: [{0}], for navigator: [{1}]", keyString, navigator));
                        }
                    }
                    else
                    {
                        throw new Exception(String.Format("Deliminator . not in setting for navigator: [{0}]", navigator));
                    }
                }

                // Check to see if we allow clients to pass up custom XSLT's for debugging purposes
                allowDebugXslt = Config.GetBoolSetting(Setting.fastEsp_allow_debug_xslt);

                foreach (string remapping in Config.GetMultiSetting(MultiSetting.fastEspRemappingParameters))
                {
                    if (remapping.Contains("."))
                    {
                        // Key is paramter for remapping
                        // Hashtable contains the values for that paramater to remap to
                        // IE: 
                        //      DetailView.Mobile.DetailLevel5
                        //  This will remap for Paramter DetailView the value Mobile -> DetailLevel5
                        List<string> remapStrings = new List<string>();                        
                        remapStrings.AddRange(remapping.Split('.'));
                        if (remapStrings.Count == 3)
                        {
                            string key = remapStrings[0];
                            if (RemapParameters.ContainsKey(key))
                            {
                                RemapParameters[key][remapStrings[1]] = remapStrings[2];
                            }
                            else
                            {
                                Hashtable ht = new Hashtable();
                                ht[remapStrings[1]] = remapStrings[2];
                                RemapParameters.Add(key, ht);                                
                            }
                            Xom.Log(XomAreaName.espengine, String.Format("Adding query remapping|parameter:[{0}]|from value:[{1}]|to value:[{2}]", remapStrings[0], remapStrings[1], remapStrings[2]));
                        }
                        else
                        {
                            throw new Exception(String.Format("Remapping did not contain required three values: [{0}]", remapping));
                        }                        
                    }
                    else
                    {
                        throw new Exception(String.Format("Deliminator . not in setting for remapping: [{0}]", remapping));
                    }
                }

            }
            catch (Exception ex)
            {
                // Clear the dictionary to be repopulated on the next execution
                fqlMappingDictionary.Clear();
                OrderByParameters.Clear();
                NavigatorParameters.Clear();
                Xom.Log(XomAreaName.espengine, "Error initializing EspEngine:" + ex.ToString());
                throw;
            }
        }

        private void SetupSearchView()
        {
            int fastEsp_persist_connection_in_secs = Config.GetIntSetting(Setting.fastEsp_persist_connection_in_secs);
            TimeSpan timeSpan = new TimeSpan(DateTime.Now.Ticks - lastSearchViewSetup.Ticks);
            if(timeSpan.TotalSeconds > fastEsp_persist_connection_in_secs)
            {
                lastSearchViewSetup = DateTime.Now;
                Xom.Log(XomAreaName.espengine, String.Format("Setting up search view at datetime [{0}]", lastSearchViewSetup));

                // Setup search view
                // Retrieve virtual interface information, construct connection string
                IVirtualInterfaceInfo interfaceInfo = Config.GetVirtualInterface(Component.fastEspMarketplaceSearch);
                NameValueCollection configuration = new NameValueCollection();
                configuration.Add("Com.FastSearch.Esp.Search.Http.QRServers", String.Format("{0}:{1}", interfaceInfo.IPAddressString, interfaceInfo.Port));

                ISearchFactory searchFactory = SearchFactory.NewInstance(configuration);
                searchView = searchFactory.GetSearchView(interfaceInfo.Info1.ToLower());
            }
        }

        /// <summary>
        /// Allows to dynamically add FQL mappings without updating the t_fql_mapping table
        /// </summary>
        public void AddFqlMapping(bool syntax, bool scope, string mapping, string parameter, string dataType, bool nonSearchable, bool offerFilter, bool flatFilter, bool rollupFilter, bool isRootLevelSearch, string queryType, string clientParameter, string antiPhraseMode)
        {
            FqlType fqlType = FqlTypeFactory.GetFqlType(syntax, scope, mapping, parameter, dataType,
                                                        nonSearchable, offerFilter, flatFilter, rollupFilter, isRootLevelSearch, antiPhraseMode);

            // Add to the dictionary..
            if (!fqlMappingDictionary.ContainsKey(queryType))
            {
                fqlMappingDictionary[queryType] = new Dictionary<string, FqlType>();
            }

            // Add the FQL if not present
            if(!fqlMappingDictionary[queryType].ContainsKey(clientParameter.ToLower()))
            {
                fqlMappingDictionary[queryType].Add(clientParameter.ToLower(), fqlType);
            }
        }

        /// <summary>
        /// Allows dynamic removal of FQL mappings without updating the t_fql_mapping table
        /// </summary>
        public void RemoveFqlMapping(string queryType, string clientParameter)
        {
            // Remove a specified FQL mapping..
            if (fqlMappingDictionary.ContainsKey(queryType) && fqlMappingDictionary[queryType].ContainsKey(clientParameter.ToLower()))
            {
                fqlMappingDictionary[queryType].Remove(clientParameter.ToLower());
            }
        }


        /// <summary>
        /// Uses the filterCriteria passed by the client to search ESP and return
        /// the results as an XmlReader
        /// </summary>
        /// <returns></returns>
        public byte[] Execute(Hashtable args, ref HResult hresult)
        {
            try
            {
                if (allowDebugXslt && !string.IsNullOrEmpty((string) args["xslt"]))
                {
                    args["detailview"] = "detaillevel5";
                }

                PerformRemapping(args);

                string fql = RetrieveFql(args);

                IQueryResult queryResult = SubmitQuery(args, fql);

                return HandleResponse(args, queryResult);
            }
            catch (Exception ex)
            {
                Xom.Log(XomAreaName.espengine, "Error executing search:" + ex.ToString());
                throw;
            }
        }

        /// <summary>
        /// Performs any remapping of arguments, if needed
        /// 
        /// Currently this will only do wholesale replacement of paramter values. If we need to replace
        /// an individual value in a dot seperated parameter passed in by the user, we would probably
        /// want to add the logic to do that here.
        /// </summary>
        private void PerformRemapping(Hashtable args)
        {           
            IDictionaryEnumerator enumerator = RemapParameters.GetEnumerator();
            while (enumerator.MoveNext())
            {
                // Retrieve the paramter. Think: DetailView
                // Check if it is passed in as an argument
                string parameter = string.Intern(((string)enumerator.Key).ToLower());
                if (args.ContainsKey(parameter))
                {
                    string value = (string)args[parameter];
                    // Retrieve the value for the above parameter, Think: DetailLevel3
                    // Check if the value needs to be remapped to something else
                    if (RemapParameters[parameter].ContainsKey(value))
                    {
                        args[parameter] = RemapParameters[parameter][value];
                    }
                }
            }           
        }

        /// <summary>
        /// Based on the parameters passed in, convert each to its FQL element
        /// and then to the larger FQL which will be used to search
        /// </summary>
        /// <returns></returns>
        public string RetrieveFql(Hashtable filterCriteria)
        {
            // Prepare start of search FQL
            StringBuilder fqlScope = new StringBuilder();
            StringBuilder fqlSearch = new StringBuilder();
            StringBuilder fqlFlatFieldSearch = new StringBuilder();
            StringBuilder fqlOfferInstance = new StringBuilder();
            StringBuilder fqlRollupSearch = new StringBuilder();
            string resource = string.Intern((string)filterCriteria["resource"]);
            bool isFirstSearch = true;
            bool isFirstOfferInstance = true;
            bool isFirstRollupFilter = true;

            if (resource == null || !fqlMappingDictionary.ContainsKey(resource))
            {
                throw new XRLException(
                    HResult.XONLINE_E_ESP_ENGINE_PARAMETER_NOT_FOUND,
                    XEvent.Id.ESP_ENGINE_EXCEPTION,
                    string.Format("Could not find resource in the filter criteria: [{0}]", resource));
            }

            // If the mapping dictionary has no values, perform initialization
            if (fqlMappingDictionary.Count == 0)
            {
                Init();
            }

            // Check that the length for the searchterm field is less then SEARCH_TERM_LENGTH
            string searchTerm = (string)filterCriteria[string.Intern("searchterm")];
            if (!string.IsNullOrEmpty(searchTerm) && searchTerm.Length > SEARCH_TERM_LENGTH)
            {
                throw new XRLException(
                        HResult.XONLINE_E_ESP_ENGINE_SEARCH_TERM_TO_LONG,
                        XEvent.Id.ESP_ENGINE_EXCEPTION,
                        string.Format("Search term used [{0}] characeters, more than the allowed amount of [{1}]. SeachTerm used: [{2}]", searchTerm.Length, SEARCH_TERM_LENGTH, searchTerm));
            }
            bool isOfferTargetTypesPresent = filterCriteria.ContainsKey(string.Intern("offertargettypes"));
            bool isOfferIdsPresent = (filterCriteria.ContainsKey(string.Intern("offers")) || filterCriteria.ContainsKey(string.Intern("hexoffers")));
            bool isParentProductsPresent = filterCriteria.ContainsKey(string.Intern("parentproducts"));
            if (isParentProductsPresent && isOfferTargetTypesPresent)
            {
                throw new XRLException(
                        HResult.XONLINE_E_ESP_ENGINE_INVALID_PARAMETER_GROUPING,
                        XEvent.Id.ESP_ENGINE_EXCEPTION,
                        "Parameter OfferTargetTypes and ParentProducts cannot be specified together in a query");
            }

            // Check for offer filtering
            //   If this field is set to 1, do not filter on the offer information
            //   If this field is not set OR set to 2, filter on all the offer information
            bool filterOnOffer = true;
            int offerFilter = (int)filterCriteria[string.Intern("offerfilter")];
            if (offerFilter == 1)
            {
                filterOnOffer = false;
            }

            // visibilityIndex supports 4 values
            //  1 = Live (3) only
            //  2 = Staging (2) + Live (3)
            //  3 = Live (3) + Withdrawn (4)
            //  4 = Staging (2) + Live (3) + Withdrawn (4)
            int visibilityIndex = (int)filterCriteria[string.Intern("editorialprivilege")];
            if (isOfferIdsPresent)
            {
                // When a specific offer is passed up, it is not contrained on the visibilitylevel
                filterCriteria[string.Intern("visibilitylevel")] = "1.2.3";

                if (!filterCriteria.ContainsKey(string.Intern("guid")) && !filterCriteria.ContainsKey(string.Intern("products")) && !filterCriteria.ContainsKey(string.Intern("hextitles")))
                {
                    switch (visibilityIndex)
                    {
                        case 1:
                            visibilityIndex = 3; // Do not filter on end date
                            break;
                        case 2:
                            visibilityIndex = 4; // Do not filter on start or end date
                            break;
                        default:
                            // Unchanged
                            break;
                    }
                }
            }
            // Callers with visibilityIndex 2 or 4 can see Offers that have not started yet
            // Callers with visibilityIndex 3 or 4 can see Offers that are withdrawn or ended

            if (filterCriteria.ContainsKey("maxrating") && filterCriteria.ContainsKey("allowunrated"))
            {
                if ((string)filterCriteria["allowunrated"] == "1")
                {
                    // Special rating flag goes into games which DO NOT HAVE ratings
                    filterCriteria["maxrating"] = filterCriteria["maxrating"] + "." + int.Parse("FFFF0001", System.Globalization.NumberStyles.HexNumber);
                }
            }
            else if (filterCriteria.ContainsKey("allowunrated"))
            {
                if ((string)filterCriteria["allowunrated"] == "0")
                {
                    // Special rating flag goes into games which HAVE ratings. We only want games which have a rating (any rating will do)
                    filterCriteria["maxrating"] = int.Parse("FFFE0001", System.Globalization.NumberStyles.HexNumber);
                }
            }

            fqlSearch.Append("xml:searchableXml:and(");
            // If we are searching within a virtual collection, use that, otherwise ommit this parameter
            if (virtualCollectionName != string.Empty)
            {
                fqlSearch.AppendFormat("filter(virtualCollection:\"{0}\")", virtualCollectionName);
                isFirstSearch = false;
            }
            // Loop through each filter criteria, AND'ing together each of them. The non searchable filters
            // such as page or page size will be ignored.
            IDictionaryEnumerator enumerator = filterCriteria.GetEnumerator();
            while (enumerator.MoveNext())
            {
                string parameter = string.Intern(((string)enumerator.Key).ToLower());
                string value = enumerator.Value.ToString();

                if((visibilityIndex == 2 || visibilityIndex == 4) && parameter.CompareTo("startdate")==0)
                {
                    continue;
                }
                if ((visibilityIndex == 3 || visibilityIndex == 4) && parameter.CompareTo("enddate") == 0)
                {
                    continue;
                }

                if (parameter != null && !fqlMappingDictionary[resource].ContainsKey(parameter))
                {
                    throw new XRLException(
                        HResult.XONLINE_E_ESP_ENGINE_PARAMETER_NOT_FOUND,
                        XEvent.Id.ESP_ENGINE_EXCEPTION,
                        string.Format("Could not map parameter [{0}] into FQL, please check the FQL mapping table that it contains this parameter", parameter));
                }
                FqlType fqltype = fqlMappingDictionary[resource][parameter];

                string fqlValue = fqltype.GetFql(value, filterOnOffer);

                if (fqlValue != string.Empty)
                {
                    if (fqltype.IsFlatFilterFql)
                    {
                        fqlFlatFieldSearch.Append(" and " + fqlValue);
                    }
                    if (fqltype.IsEnforceScope) // Determine if we add this to the searchableXml section of the scope section.
                    {
                        fqlScope.Append(" and " + fqlValue);
                    }
                    if (fqltype.IsOfferFilter) // If this is an offerinstance, we need to add all the criteria together
                    {
                        if (isFirstOfferInstance)
                        {
                            fqlOfferInstance.Append("filter(offerInstances:offerInstance:and(");
                            isFirstOfferInstance = false;
                        }
                        else
                        {
                            fqlOfferInstance.Append(" and ");
                        }
                        fqlOfferInstance.Append(fqlValue);
                    }
                    // PS 170871: FAST: The new FD can potentially return children documents to the client even though there may not be an offer against them
                    //If the query is for children (parentProducts parameter is passed in), then there is a possibility that we will return some special children that does not have
                    // any offerInstance but has a childRollup. Examples of these special children are 360 GOND, Xbox Originals, Arcade and XNA that are a children of their own.
                    // In that case, we want to avoid returning such children. So we should not filter on the ChildRollup.
                    // If however, offerTargetMediaTypes is passed in, we still want to filter by ChildRollup
                    if (fqltype.IsRollupFilter && (isOfferTargetTypesPresent || !isParentProductsPresent))
                    {
                        if (isFirstRollupFilter)
                        {
                            fqlRollupSearch.Append("filter(childRollup:and(");
                            isFirstRollupFilter = false;
                        }
                        else
                        {
                            fqlRollupSearch.Append(" and ");
                        }
                        fqlRollupSearch.Append(fqlValue);
                    }
                    if(fqltype.IsRootLevelSearch)
                    {
                        // If this is the first FQL element to be added to the searchable section, we will
                        // not include the 'AND' keyword. Everything afterwards must be AND'd with the
                        // previous statements
                        if (!isFirstSearch)
                        {
                            fqlSearch.Append(" and ");
                        }
                        else
                        {
                            isFirstSearch = false;
                        }
                        fqlSearch.Append(fqlValue);
                    }
                }
            }
            if (filterOnOffer)
            {
                if (fqlRollupSearch.Length != 0)    // If Rollup is present, complete the sub-fql
                {
                    fqlRollupSearch.Append("))");
                }
                if (fqlOfferInstance.Length != 0)   // If offerInstance is present, complete the sub-fql
                {
                    fqlOfferInstance.Append("))");
                }

                if (fqlRollupSearch.Length != 0 || fqlOfferInstance.Length != 0 || offerFilter == 3)
                {
                    // If both are present then we need to generate fql of the form: and( or(childRollupFilterFql, offerInstanceFilterFql)) )
                    // See dev spec: onenote:http://sharepoint/sites/xbox/triads/marketplace/documents/Berlin%202010/Feature%20Specs/Catalog%20Specs/FAST%20Catalog%20APIs.one#Rollups%20Dev%20Spec&section-id={9A7338EC-FEB7-4FF8-84E5-32224D6676CE}&page-id={F5D980FF-2C91-4B57-8F7B-FD7CCAF68C7B}&end
                    bool shouldAddComma = false;
                    // This is the heart of the rollup logic in the FD
                    fqlSearch.Append("and ( or (");
                    if (fqlRollupSearch.Length != 0)
                    {
                        shouldAddComma = true;
                        fqlSearch.Append(fqlRollupSearch);
                    }
                    if (!isOfferTargetTypesPresent && fqlOfferInstance.Length != 0)
                    {
                        if (shouldAddComma)
                        {
                            fqlSearch.Append(" , ");
                        }
                        else
                        {
                            shouldAddComma = true;
                        }
                        fqlSearch.Append(fqlOfferInstance);
                    }
                    if (!isOfferTargetTypesPresent && !isOfferIdsPresent && offerFilter == 3)
                    {
                        if (shouldAddComma)
                        {
                            fqlSearch.Append(" , ");
                        }
                        else
                        {
                            shouldAddComma = true;
                        }
                        // Summary: if offerFilter = 3, we want to return products that match offerFilter = 2 (products with offers or rollups that match the filter criteria) OR products "Available" in the given country
                        // 1 = Available in country
                        // 0 = Not applicable
                        fqlSearch.Append(" filter(isGameBrowsable:(1)) ");
                    }
                    fqlSearch.Append(" ) )"); // Matching the OR clause above
                }
            }
            // Add to the filterCriteria for later rule processing
            filterCriteria[string.Intern("visibilityindex")] = visibilityIndex;

            fqlSearch.Append(")");

            return fqlSearch.ToString() + fqlFlatFieldSearch.ToString() + fqlScope.ToString();
        }

        /// <summary>
        /// Calculates the entry number offset given the page number and page size
        /// </summary>
        /// <param name="pageNumber">page number we are starting from</param>
        /// <param name="pageSize">how large each individual page is</param>
        /// <returns></returns>
        private int CalculateItemOffset(int pageNumber, int pageSize)
        {
            return (pageNumber - 1) * pageSize;
        }

        /// <summary>
        /// Submits the query to ESP and handles any error conditions
        /// </summary>
        /// <param name="filterCriteria">Filter criteria for additional parameters</param>
        /// <param name="fql">FQL to search on</param>
        /// <returns></returns>
        public IQueryResult SubmitQuery(Hashtable filterCriteria, string fql)
        {
            string navigatorIntegerList = (string)filterCriteria["navigators"];
            int pageNumber = (int)filterCriteria["pagenum"];
            int pageSize =(int)filterCriteria["pagesize"];
            int orderBy = (int)filterCriteria["orderby"];
            String locale = (String)filterCriteria["locale"];
            if ( (int)filterCriteria["orderdirection"] == 2 )
            {
                orderBy = -1 * orderBy;
            }

            IQuery query = new Query(fql);

            // Set appropriate parameters
            String queryLanguage = locale.Substring(0,2);
            query.SetParameter(new SearchParameter(BaseParameter.OFFSET, CalculateItemOffset(pageNumber, pageSize)));
            query.SetParameter(new SearchParameter(BaseParameter.HITS, pageSize));
            query.SetParameter(new SearchParameter(BaseParameter.LANGUAGE, queryLanguage));

            // Determine if the language of the query requires spell-check and resubmission
            String[] spellCheckLanguageList = Config.GetMultiSetting(MultiSetting.fastEspSpellCheckLanguage);
            if ((spellCheckLanguageList != null) && (Array.IndexOf(spellCheckLanguageList, queryLanguage ) >= 0 ))
            {
                // Enable spell check on resubmt only (0x00001F30)
                // These settings cause the exact string, as specified by the user to go to
                // ESP first, without any spell checking having happened. Only is NO results
                // are returned, is spell checking applied and the query re-submitted.
                query.SetParameter(new SearchParameter(BaseParameter.RESUBMITFLAGS, "7984"));
            }

            SearchParameter orderByParameter;
            OrderByParameters.TryGetValue( orderBy, out orderByParameter );
            orderByParameter = orderByParameter == null ? DefaultOrderByParameter : orderByParameter;
            query.SetParameter(orderByParameter);

            StringBuilder navigatorStringList = new StringBuilder();
            String navigatorLogInfo = String.Empty;
            // Set navigation parmeters, only if navigation is present
            if (!string.IsNullOrEmpty(navigatorIntegerList))
            {
                // Troll through all of the navigators passed in, and create a comma seperated list.
                // Example:
                //      1.2.3
                // Translates:
                //      letterjumpnavigator,producttypenavigator,genrenavigator
                foreach (string navigatorInteger in navigatorIntegerList.Split('.'))
                {
                    string navigatorString;
                    if (NavigatorParameters.TryGetValue(Int32.Parse(navigatorInteger), out navigatorString))
                    {
                        // If it is not the first navigator, pre pend with comma
                        if (navigatorStringList.Length > 0)
                        {
                            navigatorStringList.Append(",");
                        }
                        navigatorStringList.Append(navigatorString);
                    }
                }

                query.SetParameter(new SearchParameter(BaseParameter.NAVIGATION, 1));           // Tell FAST ESP to return navigators
                query.SetParameter(new SearchParameter(BaseParameter.NAVIGATORS, navigatorStringList.ToString()));  // Navigators to pivot on
                navigatorLogInfo = navigatorIntegerList + ":" + navigatorStringList.ToString();
            }
            else
            {
                query.SetParameter(new SearchParameter(BaseParameter.NAVIGATION, 0));           // Tell FAST ESP to NOT return navigators
            }

            // Determine if we should use result views or not
            bool useResultViews = Config.GetBoolSetting(Setting.fastEsp_use_result_views);
            string resultview = string.Empty;
            if (useResultViews)
            {
                resultview = (string)filterCriteria["detailview"];
                query.SetParameter(new SearchParameter(BaseParameter.RESULT_VIEW, resultview));
            }

            // Retrieve other information to log:
            int visibilityindex = (int)filterCriteria[string.Intern("visibilityindex")];
            int editorialprivilege = (int)filterCriteria[string.Intern("editorialprivilege")];
            int offerFilter = (int)filterCriteria[string.Intern("offerfilter")];
            Xom.Log(XomAreaName.espengine, String.Format("Submitting Search|pageNumber:[{0}]|pageSize:[{1}]|orderBy:[{2}:{3}]|visibilityIndex:[{4}]|editorialprivilege:[{5}]|navigators:[{6}]|offerfilter:[{7}]|resultview:[{9}]|{8}", pageNumber, pageSize, orderBy, orderByParameter.StringValue, visibilityindex, editorialprivilege, navigatorLogInfo, offerFilter, fql, resultview));

            SetupSearchView();

            return searchView.Search(query);
        }

        /// <summary>
        /// Based on the rule data, will determine if the given rule data should
        /// be returned to the caller. If any of the criteria fails, the entire
        /// rule data will be rejected.
        ///
        /// The editorial privledge will be based on the visibilityIndex which is
        /// calculated when the search query is first submitted. It will be added
        /// to the filterCriteria at that point and used here to determine if the
        /// rule data should be included in the response or not.
        /// </summary>
        /// <param name="filterCriteria">Criteria passed up by the client to process</param>
        /// <param name="reader">Reader which is currently pointed at the filterrule</param>
        /// <returns>String which represents the offer data information</returns>
        public string ProcessRule(Hashtable filterCriteria, XmlReader reader)
        {
            int visibilityIndex = (int)filterCriteria[string.Intern("visibilityindex")];

            bool rulePassed = true;
            // Read all of the attributes in the offer rule
            if (!reader.MoveToFirstAttribute())
            {
                throw new XRLException(
                    HResult.XONLINE_E_ESP_ENGINE_INVALID_RULE,
                    XEvent.Id.ESP_ENGINE_EXCEPTION,
                    "Rule is not valid, no attributes found");
            }
            do
            {
                string attributeName = reader.Name.ToLower();

                object filterCriteriaValue = null;
                // startDate and endDate are special cases where we need to see if
                // the filterCrtieria value comes before or after. Any other values
                // should be pulled from the filter criteria and checked
                switch (attributeName)
                {
                    case "startdate":
                        // When we get the request we always put this startdate filter criteria in
                        // this is just extra precaution to make sure this filter criteria is always set
                        if (!filterCriteria.ContainsKey("startdate"))
                        {
                            throw new XRLException(
                                HResult.XONLINE_E_ESP_ENGINE_PARAMETER_NOT_FOUND,
                                XEvent.Id.ESP_ENGINE_EXCEPTION,
                                string.Format("Could not find attribute in the filter criteria: [{0}]", attributeName));
                        }

                        if ((visibilityIndex == 2 || visibilityIndex == 4))
                        {
                            continue;
                        }
                        filterCriteriaValue = DateTime.Parse((string)filterCriteria[attributeName]);
                        // The offer instance startDate must be before the filter criteria startDate passed up.
                        // If the startDate passed up is after the startDate in the OI, then reject this OI
                        if (DateTime.Compare((DateTime)filterCriteriaValue, DateTime.Parse(reader.Value)) < 0)
                        {
                            rulePassed = false;
                        }
                        break;
                    case "enddate":
                        // When we get the request we always put this enddate filter criteria in
                        // this is just extra precaution to make sure this filter criteria is always set
                        if (!filterCriteria.ContainsKey("enddate"))
                        {
                            throw new XRLException(
                                HResult.XONLINE_E_ESP_ENGINE_PARAMETER_NOT_FOUND,
                                XEvent.Id.ESP_ENGINE_EXCEPTION,
                                string.Format("Could not find attribute in the filter criteria: [{0}]", attributeName));
                        }
                        if ((visibilityIndex == 3 || visibilityIndex == 4))
                        {
                            continue;
                        }
                        filterCriteriaValue = DateTime.Parse((string)filterCriteria[attributeName]);
                        // The offer instance endDate must be after the filter criteria endDate passed up
                        // If the endDate passed up is before the endDate in the OI, then reject this OI
                        if (DateTime.Compare((DateTime)filterCriteriaValue, DateTime.Parse(reader.Value)) > 0)
                        {
                            rulePassed = false;
                        }
                        break;
                    default:
                        // if the client has not passed this paramter, she does not want to filter on it
                        // so ignore it
                        if (filterCriteria.ContainsKey(attributeName))
                        {
                            // Other values:
                            //    Take value out of the filterCriteria
                            //         If it splits on ., ensure that AT LEAST one of the values exists in the attributeValue
                            //         If it splits on _, ensure that ALL of the values exist in attributeValue
                            filterCriteriaValue = filterCriteria[attributeName].ToString();
                            string[] attributeValueSplit = SecurityElement.Escape(reader.Value).Split(attributeRuleSplit, StringSplitOptions.RemoveEmptyEntries);
                            string[] filterCriteriaValueSplit = ((string)filterCriteriaValue).Split(syntaxSplit);

                            if (((string)filterCriteriaValue).Contains(".")) // Ensure AT LEAST one of the values exists in attributeValue
                            {
                                // We just need one match to make this thing happen
                                bool oneMatch = false;
                                foreach (string filterStr in filterCriteriaValueSplit)
                                {
                                    if (Array.Exists(attributeValueSplit, delegate(string str) { return str.Equals(filterStr); }))
                                    {
                                        oneMatch = true;
                                        break;
                                    }
                                }

                                if (!oneMatch)
                                {
                                    rulePassed = false; // We never found a match, rule did not pass
                                }
                            }
                            else if (((string)filterCriteriaValue).Contains("_")) // ensure that ALL of the values exist in attributeValue
                            {
                                // If the lengths don't match, we have no hope of all the values matching
                                if (attributeValueSplit.Length != filterCriteriaValueSplit.Length)
                                {
                                    rulePassed = false;
                                }

                                if (rulePassed)
                                {
                                    // Arrays are the same size, lets troll through them all
                                    foreach (string filterStr in filterCriteriaValueSplit)
                                    {
                                        if (!Array.Exists(attributeValueSplit, delegate(string str) { return str.Equals(filterStr); }))
                                        {
                                            rulePassed = false; // Each attribute is required, but we didn't find this one. Rule did not pass
                                        }
                                    }
                                }
                            }
                            else // No split, means individual value was passed up by client
                            {
                                // See that the value passed up exists in the attributes
                                if (Array.Exists(attributeValueSplit, delegate(string str) { return str.Equals(filterCriteriaValue); }))
                                {
                                    break;
                                }
                                else
                                {
                                    rulePassed = false;
                                }
                            }
                        }
                        break;
                }
            } while (rulePassed && reader.MoveToNextAttribute());

            // If we did not pass rule validation - move to the next element and return empty string
            if (!rulePassed)
            {
                //reader.Read();
                reader.MoveToElement();
                reader.ReadInnerXml();
                return String.Empty;
            }

            // Now process the rest of the Xml contained within this node. For now, we assume that
            // we do not have nested rules, but if ths were a requirement, it could be implemented
            // by calling this same function from this point in a recursive manner, concatinating the
            // returned strings as it goes. For now, we simple do price pricessing
            //
            // Run through all siblings of the current node
            reader.MoveToElement();
            StringBuilder innerXml = new StringBuilder();
            Boolean loop = true;
            while (loop == true)
            {
                // Is this a price element - if so, format for the current locale
                if ((reader.NodeType == XmlNodeType.Element) && (reader.Name == "price"))
                {
                    innerXml.Append(FormatPrice(filterCriteria, reader));
                    loop = true; // do not read since we are already advanced
                }
                else if ((reader.NodeType == XmlNodeType.Element) && (reader.Name == "RULE"))
                {
                    // skip
                    loop = reader.Read();
                }
                else if ((reader.NodeType == XmlNodeType.EndElement) && (reader.Name == "RULE"))
                {
                    // jump out of the loop
                    reader.Read();
                    loop = false;
                }
                else
                {
                    switch (reader.NodeType)
                    {
                        case XmlNodeType.Element:
                            innerXml.AppendFormat("<{0}", reader.Name);
                            for (Boolean attributeExists = reader.MoveToFirstAttribute();
                                attributeExists == true;
                                attributeExists = reader.MoveToNextAttribute()
                                )
                            {
                                innerXml.AppendFormat(" {0}=\"{1}\"", reader.Name, SecurityElement.Escape(reader.Value));
                            }

                            innerXml.Append( reader.IsEmptyElement ? "/>" : ">");
                            reader.MoveToElement();
                            break;
                        case XmlNodeType.Text:
                            innerXml.Append(SecurityElement.Escape(reader.Value));
                            break;
                        case XmlNodeType.EndElement:
                            innerXml.AppendFormat("</{0}>", reader.Name);
                            break;
                    }
                    loop = reader.Read();
                }
            }

            // move to the next element
            return innerXml.ToString();
        }

        private int GetLcidFromLocaleCode(string locale)
        {
            // Locales en-HK, en-IN, and en-SG do not map properly to its LCID, this is
            // a bug in .NET
            //
            // We use locale to format the price of the offer instance data
            // that is returned
            //
            // We will use zh-HK to format the price for this locale
            if (string.Equals(locale, "en-HK", StringComparison.CurrentCultureIgnoreCase))
            {
                locale = "zh-HK";
            }
            else if (string.Equals(locale, "en-IN", StringComparison.CurrentCultureIgnoreCase))
            {
                locale = "hi-IN";
            }
            else if (string.Equals(locale, "en-SG", StringComparison.CurrentCultureIgnoreCase))
            {
                locale = "zh-SG";
            }

            return Locale.GetLcidFromLocaleCode(locale);

        }


        private string FormatPrice(Hashtable filterCriteria, XmlReader reader)
        {
            String node = String.Empty;

            // At this point the reader is placed on the price element which looks like ....
            //
            //  <price paymentTypeId="2" >23.66</price>
            //
            // We need to pull out the payment type id and the actual price string

            // temporary back-compat - if the price element does not have any attributes, it is old
            // style. We cannot do any formatting, so just return the element as is. Otherwise format
            // and create three new elements (<paymentTypeId>, <price>, <pricetext>)
            if (reader.HasAttributes)
            {
                String locale = (String)filterCriteria["locale"];
                String paymentTypeIdString = reader.GetAttribute("paymentTypeId");
                uint currentPaymentType = CatalogUtil.CatalogPaymentTypeToUodbPaymentType(System.Convert.ToUInt32(paymentTypeIdString));  // converting EMSPaymentType into UODBPaymentType
                Double price = reader.ReadElementContentAsDouble();
                String formattedPriceString = Price.XeFormatPrice(currentPaymentType, price, GetLcidFromLocaleCode(locale));
                node = String.Format("<paymentType>{0}</paymentType><price>{1}</price><pricetext>{2}</pricetext>", paymentTypeIdString, price, formattedPriceString);
            }
            else
            {
                node = String.Format( "<price>{0}</price>", reader.ReadElementContentAsString());
            }

            reader.MoveToElement();
            return node;
        }

        private void SetUpdatedTime( String dateTimeString, ref DateTime mostRecentUpdated)
        {
            DateTime thisDateTime;
            if (DateTime.TryParse(dateTimeString, out thisDateTime))
            {
                if (thisDateTime > mostRecentUpdated)
                {
                    mostRecentUpdated = thisDateTime;
                }
            }
        }

        private void EventAndLog(string contentId, string detailLevel)
        {
            string msg = String.Format("For contentId [{0}], the detail level [{1}] could not be found. Examine FAST ESP to determine if the detail level data is present",
                                                      contentId,
                                                      detailLevel
                                                      );
            XRLException e = new XRLException(
                                    HResult.XONLINE_E_MARKETPLACECATALOG_DETAIL_LEVEL_MISSING,
                                    XEvent.Id.MARKETPLACECATALOG_DETAIL_LEVEL_MISSING,
                                    msg
                                   );


            // Write to the event log
            Xom.NtEvent(XEvent.Id.MARKETPLACECATALOG_DETAIL_LEVEL_MISSING, e, msg);
            // Write to the log
            Xom.Log(XomAreaName.espengine, msg);
        }

        /// <summary>
        /// Takes the results from ESP, and creates the XML node with
        /// all the search results included
        /// </summary>
        /// <param name="queryResult"></param>
        /// <returns></returns>
        private Byte[] HandleResponse(Hashtable filterCriteria, IQueryResult queryResult)
        {
            // Convert XML into class
            // foreach through offerinstances
            //    Each offer instance willhave a method, pass up visilbity index
            //
            // Converts the results into the atom feed and return it
            // During parsing into the atom feed, rule process occurs

            int pageNumber = (int)filterCriteria["pagenum"];
            int pageSize = (int)filterCriteria["pagesize"];
            string detailLevel = (string)filterCriteria["detailview"];

            DateTime mostRecentUpdated = DateTime.MinValue;
            StringBuilder concatenatedXml = new StringBuilder();
            int actualNumberOfHits = 0;
            for (int i = 0; i < queryResult.Hits; i++)
            {
                String espDocument = queryResult.GetDocument(CalculateItemOffset(pageNumber, pageSize) + i + 1).GetSummaryField(detailLevel).StringValue;
                if (espDocument == null)
                {
                    string contentId = queryResult.GetDocument(CalculateItemOffset(pageNumber, pageSize) + i + 1).GetSummaryField("contentid").StringValue;
                    EventAndLog(contentId, detailLevel);
                    continue;
                }

                ++actualNumberOfHits;

                if (allowDebugXslt && !string.IsNullOrEmpty((string)filterCriteria["xslt"]))
                {
                    XslCompiledTransform transform = new XslCompiledTransform();
                    XmlTextReader transformReader = new XmlTextReader(new StringReader((string)filterCriteria["xslt"]));
                    transform.Load(transformReader);

                    StringBuilder sbOutput = new StringBuilder();
                    XPathDocument xpathDoc = new XPathDocument(new StringReader(espDocument));

                    transform.Transform(xpathDoc, XmlWriter.Create(sbOutput));

                    espDocument = sbOutput.ToString();
                }

                XmlTextReader reader = new XmlTextReader(new StringReader(espDocument));
                // We want to ignore namespaces for this parsing
                reader.Namespaces = false;
                bool detailLevelStartElementFound = false;
                bool skipRead = true; // After rule processing, the XMLReader is already advanced
                                      // to the next node. We must have the reader not advance
                                      // so that it can process the current node as appopriate.
                                      // This boolean will be set to control that action
                while (true)
                {
                    if (!skipRead)
                    {
                        if (!reader.Read())
                        {
                            break;
                        }
                    }
                    else
                    {
                        skipRead = false;
                    }
                    if (reader.NodeType == XmlNodeType.Element)
                    {
                        // Check if its the RULE node
                        if (reader.Name == "RULE")
                        {
                            string node = ProcessRule(filterCriteria, reader);
                            skipRead = true;
                            concatenatedXml.Append(node);
                        }
                        else if (!Array.Exists(ignoreReturnNodesFromResults, delegate(string str) { return str.Equals(reader.Name); })) //  If this is a node that should not be ignored, then process the node
                        {
                            String nodeName = reader.Name;

                            // The 'updated' value for the result set is the most recent 'updated' value for
                            // any of its constituents. So, check this constituent and if it is more recent
                            // than any previous constituent, update the 'mostRecentUpdated' to be this value.
                            if (nodeName == "updated")
                            {
                                SetUpdatedTime(reader.Value, ref mostRecentUpdated);
                            }

                            if (!detailLevelStartElementFound)
                            {
                                if (reader.Name.StartsWith("detail"))
                                {
                                    nodeName = String.Format("a:entry itemNum=\"{0}\"", CalculateItemOffset(pageNumber, pageSize) + i + 1);
                                    detailLevelStartElementFound = true;
                                }
                            }
                            // Check if this is a special node that needs to be atomized
                            if (Array.Exists(nodeNamesToAtomize, delegate(string str) { return str.Equals(nodeName); }))
                            {
                                nodeName = "a:" + nodeName;
                            }
                            // put in the name
                            concatenatedXml.Append(String.Format("<{0}", nodeName));
                            // put in the attributes
                            if (reader.MoveToFirstAttribute())
                            {
                                while (true)
                                {
                                    concatenatedXml.Append(String.Format(" {0}=\"{1}\"", reader.Name, reader.Value));
                                    if (!reader.MoveToNextAttribute())
                                    {
                                        break;
                                    }
                                }
                            }
                            // Check if its an empty element, for example <MyElement/>
                            if (reader.IsEmptyElement)
                            {
                                concatenatedXml.Append("/>");
                            }
                            else
                            {
                                concatenatedXml.Append(">");
                            }
                        }

                    }
                    else if (reader.NodeType == XmlNodeType.Text)
                    {
                        // Put in the node value, being sure to escape any elements first
                        concatenatedXml.Append(SecurityElement.Escape(reader.Value));
                    }
                    else if (reader.NodeType == XmlNodeType.EndElement)
                    {
                        if (!Array.Exists(ignoreReturnNodesFromResults, delegate(string str) { return str.Equals(reader.Name); }))
                        {
                            // Put in the end element
                            String nodeName = reader.Name.StartsWith("detail") ? "a:entry" : reader.Name;
                            // Check if this is a special node that needs to be atomized
                            if (Array.Exists(nodeNamesToAtomize, delegate(string str) { return str.Equals(nodeName); }))
                            {
                                nodeName = "a:" + nodeName;
                            }
                            concatenatedXml.Append(String.Format("</{0}>", nodeName));
                        }
                    }
                }
            }

            // Create navigator response XML
            StringBuilder navigatorString = new StringBuilder();
            if (queryResult.Navigators().Count > 0)
            {
                navigatorString.Append("<navigators>");

                foreach (Com.FastSearch.Esp.Search.Result.INavigator navigator in queryResult.Navigators())
                {
                    StringBuilder individualNavigator = new StringBuilder();
                    individualNavigator.Append("<navigator>");
                    individualNavigator.AppendFormat("<navigatorName>{0}</navigatorName>", navigator.DisplayName);
                    individualNavigator.AppendFormat("<navigatorHits>{0}</navigatorHits>", navigator.Hits);

                    IDictionaryEnumerator navigatorDictionary = NavigatorParameters.GetEnumerator();
                    while(navigatorDictionary.MoveNext())
                    {
                        if((String)navigatorDictionary.Value == navigator.Name)
                        {
                            individualNavigator.AppendFormat("<navigatorId>{0}</navigatorId>", (Int32)navigatorDictionary.Key);
                            break;
                        }
                    }

                    IEnumerator modifierEnum = navigator.Modifiers().GetEnumerator();
                    while (modifierEnum.MoveNext())
                    {
                        individualNavigator.Append("<navigationElement>");
                        IModifier modifier = (IModifier)modifierEnum.Current;

                        // Modifier, for example "Action" Genre
                        String navigatorName = modifier.Name;

                        String[] nameValuePair = navigatorName.Split('#');

                        //
                        //
                        // If no name is available, the format will be:
                        //      {Identifier}
                        // In XML will look like:
                        //      <NavigationElementName />
                        //      <NavigationElementId>{Identifier}</NavigationElementId>
                        //
                        // If a name is available, the format will be:
                        //      {Name}#{Identifier}
                        // In XML will look like:
                        //      <NavigationElementName>{Name}</NavigationElementName>
                        //      <NavigationElementId>{Identifier}</NavigationElementId>
                        // Note: The name is first to allow for the navigators to be sorted alphabetically when returned
                        //
                        // If the field contais 3 sections, the format will be:
                        //      {SortOrder}#{Name}#{Identifier}
                        // In XML will look like:
                        //      <NavigationElementName>{Name}</NavigationElementName>
                        //      <NavigationElementId>{Identifier}</NavigationElementId>
                        // The sort order section will typically be formatted somthing like '0001' and '0002',
                        // The nvaigator is then sorted alphabetically, allowing specific orderings to be supported
                        // The sort order field is not added to the result

                        if (nameValuePair.Length == 1)
                        {
                            individualNavigator.AppendFormat("<navigationElementName />");
                            individualNavigator.AppendFormat("<navigationElementId>{0}</navigationElementId>", nameValuePair[0]);
                        }
                        else if (nameValuePair.Length == 2)
                        {
                            nameValuePair[0] = nameValuePair[0].Replace("%23", "#");
                            individualNavigator.AppendFormat("<navigationElementName>{0}</navigationElementName>", nameValuePair[0]);
                            individualNavigator.AppendFormat("<navigationElementId>{0}</navigationElementId>", nameValuePair[1]);
                        }
                        else if (nameValuePair.Length == 3)
                        {
                            nameValuePair[1] = nameValuePair[1].Replace("%23", "#");
                            individualNavigator.AppendFormat("<navigationElementName>{0}</navigationElementName>", nameValuePair[1]);
                            individualNavigator.AppendFormat("<navigationElementId>{0}</navigationElementId>", nameValuePair[2]);
                        }
                        else
                        {
                            // Only 1, 2 or 3 are valid. Purposely Leaving empty else in case we need another seperated value..
                        }

                        // Number of hits for this modifier, eg "10 hits for Action"
                        individualNavigator.AppendFormat("<navigationElementHits>{0}</navigationElementHits>", modifier.Count);
                        individualNavigator.Append("</navigationElement>");
                    }
                    individualNavigator.Append("</navigator>");
                    navigatorString.Append(individualNavigator.ToString());
                }

                navigatorString.Append("</navigators>");
            }

            StringBuilder feedXml = new StringBuilder();
            feedXml.Append(xmlHeader);
            feedXml.AppendFormat("<a:updated>{0:u}</a:updated>", mostRecentUpdated == DateTime.MinValue ? DateTime.UtcNow : mostRecentUpdated );
            feedXml.AppendFormat("<totalItems>{0}</totalItems>", queryResult.DocCount);
            feedXml.AppendFormat("<numItems>{0}</numItems>", actualNumberOfHits);
            feedXml.AppendFormat("<locale>{0}</locale>", filterCriteria["locale"]);
            feedXml.Append(navigatorString.ToString());
            feedXml.Append(concatenatedXml.ToString());
            feedXml.Append(xmlFooter);

            return Encoding.UTF8.GetBytes(feedXml.ToString());
        }

   }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\marketplace\family\FamilyUtils.cs ===
using System;
using System.Web;
using xonline.common.config;
using xonline.common.protocol;
using xonline.common.service;
using xonline.common.mgmt;
using xonline.common.user;
using xonline.common.exceptions;
using xonline.common.billing;
using xonline.core.history;
using System.Text;

namespace xonline.common.family
{
    public class FamilyUtils
    {
        // This is used to ensure that an operation involved in adding a user to a gold seat in a family subscription is valid.
        // - The MergeSubscriptionPreview operation can be done with a user that's not a part of the family yet, and the operation
        //   lets the caller know what would happen with the subscriptions if the user were added to the family.
        // - Actually assigning a user to a gold seat requires that the user already be in the family.
        // Validation is similar in both scenarios (a gold seat must be available, billing region must be the same, throttling
        // must not prevent it, etc).
        // To support the two modes, we require that the owner passport puid must be supplied if the secondary (dependent) is not
        // already a member of the family.
        public static HResult VerifyFamilyGoldEligiblityForDependent(User primary, User dependent, PassportToken ownerPassportToken)
        {
            // If the prospective dependent already has a family gold subscription and is not
            // in a downgrade state, they're not eligible. If they are in a downgrade state,
            // this operation counts as picking a paid subscription, so the caller should handle it.
            if (!dependent.IsDowngraded && XeSubscriptionUtil.GetUserGoldLimit(dependent.Puid) > 0)
            {
                return HResult.XONLINE_E_ACCOUNTS_FAMILY_GOLD_DEPENDENT_HAS_FAMILY;
            }

            // Find out how many gold seats the caller's subscription allows
            uint goldRemain = XeSubscriptionUtil.GetUserGoldLimit(primary.Puid);
            if (goldRemain == 0)
            {
                return HResult.XONLINE_E_ACCOUNTS_FAMILY_GOLD_NO_SEATS_REMAIN_ERROR;
            }

            // The owner occupies a gold seat, so account for that.
            --goldRemain;

            // Load the owner's family and verify that the dependent's eligible
            FamilyMember[] familyMembers;
            primary.GetFamilyMembers(out familyMembers);

            bool found = false;

            foreach (FamilyMember familyMember in familyMembers)
            {
                if (familyMember.userPuid == dependent.Puid)
                {
                    // The member being assigned a gold seat shouldn't already occupy one
                    if ((familyMember.userFlags & FamilyDefs.FAMILY_SUBSCRIPTION_GOLD) == FamilyDefs.FAMILY_SUBSCRIPTION_GOLD)
                    {
                        return HResult.XONLINE_E_ACCOUNTS_FAMILY_GOLD_ALREADY_ASSIGNED_ERROR;
                    }

                    found = true;
                }

                if ((familyMember.userFlags & FamilyDefs.FAMILY_SUBSCRIPTION_GOLD) == FamilyDefs.FAMILY_SUBSCRIPTION_GOLD &&
                    goldRemain > 0)
                {
                    --goldRemain;
                }
            }

            // If there are no gold seats left, they can't have a seat.
            if (goldRemain == 0)
            {
                return HResult.XONLINE_E_ACCOUNTS_FAMILY_GOLD_NO_SEATS_REMAIN_ERROR;
            }

            // If the user's not a dependent, check the owner passport token now
            if (!found)
            {
                if (ownerPassportToken == null)
                {
                    return HResult.XONLINE_E_ACCOUNTS_FAMILY_GOLD_NOT_DEPENDENT_ERROR;
                }

                ulong ownerPassportPuid;
                if (!dependent.IsChildOf(ownerPassportToken, out ownerPassportPuid))
                {
                    return HResult.XONLINE_E_ACCOUNTS_INVALID_OWNER_PASSPORT_ERROR;
                }
            }

            // Check the dependent's billing region. It must match the owner's to be added to the subscription
            if (primary.CountryId != dependent.CountryId)
            {
                return HResult.XONLINE_E_ACCOUNTS_FAMILY_GOLD_BILLING_REGION_ERROR;
            }

            // Check console trust
            int waitHours = Config.GetIntSetting(Setting.xuacs_familyGoldChangeWaitIntervalHours);
            if (!UserMachineHistory.IsTrusted(primary.Puid, SGInfo.Current.MachineId, waitHours))
            {
                return HResult.XONLINE_E_ACCOUNTS_FAMILY_GOLD_UNTRUSTED_CONSOLE_ERROR;
            }

            if (!UserMachineHistory.IsTrusted(dependent.Puid, SGInfo.Current.MachineId, waitHours))
            {
                return HResult.XONLINE_E_ACCOUNTS_FAMILY_GOLD_UNTRUSTED_CONSOLE_ERROR;
            }

            // Check history to throttle rate of changes.
            int cooldownWaitDays = Config.GetIntSetting(Setting.xuacs_familyGoldAssignmentCoolDownWaitIntervalDays);
            int distinctAllowed = Config.GetIntSetting(Setting.xuacs_familyGoldAssignmentDistinctUsers);
            int throttlingWindowDays = Config.GetIntSetting(Setting.xuacs_familyGoldAssignmentThrottlingWindowDays);

            FamilyHistory history = FamilyHistory.GetByOwnerPassportPuid(primary.PassportPuid, null, DateTime.Now.AddDays(-throttlingWindowDays), true);
            FamilyHistoryDetails[] details = history.Details;

            // Find the most recent subscription-related entry within the cooldown time related to the dependent
            FamilyHistoryDetails[] dependentDetails =
                Array.FindAll(details, d =>
                    (d.DependentPuid == dependent.Puid &&
                    d.Timestamp > DateTime.Now.AddDays(-cooldownWaitDays) &&
                    d.HResult == HResult.S_OK &&
                    (d.Reason == HistoryReason.Support || d.Reason == HistoryReason.ExpireFamilyGold || d.Reason == HistoryReason.RemoveFamilyGold)
                    )
                );
            Array.Sort(dependentDetails, (l, r) => -l.Timestamp.CompareTo(r.Timestamp));
            if (dependentDetails.Length > 0)
            {
                // We have activity related to the dependent within the cooldown window.
                // If the most recent event was a CSS override or a subscription expiration, allow the assignment.
                // For any other reason, disallow the assignment because of the cooldown.
                if (dependentDetails[0].Reason != HistoryReason.Support && dependentDetails[0].Reason != HistoryReason.ExpireFamilyGold)
                {
                    return HResult.XONLINE_E_ACCOUNTS_FAMILY_GOLD_COOLDOWN_ERROR;
                }
            }
            else
            {
                // If the user wasn't seen within the cooldown window, check that this assignment doesn't cause
                // the subscription to exceed the count of distinct users that can be added to the subscription within a year.

                // Start by checking if the user's been seen at all. If so, this user won't cause the count to increase.
                if (Array.FindIndex(details, d => (d.DependentPuid == dependent.Puid && d.Reason == HistoryReason.AssignFamilyGold)) == -1)
                {
                    // Now find all of the users that have been added in the past year
                    FamilyHistoryDetails[] addDetails = Array.FindAll(details, d =>
                        d.HResult == HResult.S_OK &&
                        d.Reason == HistoryReason.AssignFamilyGold);
                    Array.Sort(addDetails, (l, r) => (l.DependentPuid < r.DependentPuid ? -1 : (l.DependentPuid == r.DependentPuid ? 0 : 1)));

                    int distinctUsers = 0;
                    Puid? current = null;
                    foreach (FamilyHistoryDetails detail in addDetails)
                    {
                        if (detail.DependentPuid != current)
                        {
                            current = detail.DependentPuid;
                            ++distinctUsers;
                        }
                    }

                    if (distinctUsers >= distinctAllowed)
                    {
                        return HResult.XONLINE_E_ACCOUNTS_FAMILY_GOLD_TOO_MANY_USERS_ERROR;
                    }
                }
            }

            return HResult.S_OK;
        }

    }
    public class FamilyRiskData
    {
        //Initialize with defaults
        public FamilyRiskData()
        {
            this.FamilyMemberRemovedCount = 0;
            this.FamilyMemberRemovedCount = 0;
            this.MemberGamertagLastAdded = null;
            this.MemberGamertagLastRemoved = null;
            this.MemberLastAddedTimestamp = null;
            this.MemberLastRemovedTimestamp = null;
            this.RemovedMemberGamertags = null;

        }
        public int FamilyMemberAddedCount
        {
            get;
            set;
        }
        public int FamilyMemberRemovedCount
        {
            get;
            set;
        }
        public string MemberGamertagLastAdded
        {
            get;
            set;
        }
        public DateTime? MemberLastAddedTimestamp
        {
            get;
            set;
        }
        public string MemberGamertagLastRemoved
        {
            get;
            set;
        }
        public DateTime? MemberLastRemovedTimestamp
        {
            get;
            set;
        }
        public string RemovedMemberGamertags
        {
            get;
            set;
        }
        public static FamilyRiskData GetFamilyRiskInfo(Puid ownerPassportPuid)
        {
            FamilyRiskData familyRiskData = new FamilyRiskData();
            

            FamilyHistoryDetails[] familyHistoryDetails = FamilyHistory.GetByOwnerPassportPuid(ownerPassportPuid, null, null, true).Details;

            if (familyHistoryDetails != null && familyHistoryDetails.Length > 0)
            {
                //get the details for assign gold seat
                FamilyHistoryDetails[] assignGoldSeatHistoryDetails = Array.FindAll(familyHistoryDetails, detail=>detail.Reason==HistoryReason.AssignFamilyGold);

                //get the details for removefamilygold/expirefamilygold
                FamilyHistoryDetails[] removeGoldSeatHistoryDetails = Array.FindAll(familyHistoryDetails, detail=>
                                                                                                           (
                                                                                                              detail.Reason == HistoryReason.RemoveFamilyGold
                                                                                                            || detail.Reason == HistoryReason.ExpireFamilyGold
                                                                                                            )
                                                                                                        );

                if (assignGoldSeatHistoryDetails!=null && assignGoldSeatHistoryDetails.Length > 0)
                {
                    FamilyHistoryDetails latestAssignGoldSeatHistory = assignGoldSeatHistoryDetails[0];
                    for (int i = 1; i < assignGoldSeatHistoryDetails.Length; i++)
                    {
                        //get the latest assign gold seat user history detail
                        if (assignGoldSeatHistoryDetails[i].Timestamp > latestAssignGoldSeatHistory.Timestamp)
                        {
                            latestAssignGoldSeatHistory = assignGoldSeatHistoryDetails[i];
                        }
                    }

                    familyRiskData.FamilyMemberAddedCount = assignGoldSeatHistoryDetails.Length;

                    XCacheUserResponseData xcurd = XCache.LookupUserByXUID(latestAssignGoldSeatHistory.DependentPuid);
                    familyRiskData.MemberGamertagLastAdded = xcurd.szGamertag;

                    familyRiskData.MemberLastAddedTimestamp = latestAssignGoldSeatHistory.Timestamp;

                }

                if (removeGoldSeatHistoryDetails  !=null && removeGoldSeatHistoryDetails.Length > 0)
                {
                    FamilyHistoryDetails latestRemoveGoldSeatHistory = removeGoldSeatHistoryDetails[0];
                    XCacheUserResponseData xcurd = XCache.LookupUserByXUID(latestRemoveGoldSeatHistory.DependentPuid);
                    StringBuilder removedGamerTagList = new StringBuilder(xcurd.szGamertag);

                    string latestRemovedGamerTag = xcurd.szGamertag;

                    for (int i = 1; i < removeGoldSeatHistoryDetails.Length; i++)
                    {
                        //generate the remove gold user dependent gamertag list
                        //Dont add first index since we have already added that
                        xcurd = XCache.LookupUserByXUID(removeGoldSeatHistoryDetails[i].DependentPuid);
                        removedGamerTagList.Append(";" + xcurd.szGamertag);

                        if (removeGoldSeatHistoryDetails[i].Timestamp > latestRemoveGoldSeatHistory.Timestamp)
                        {
                            //get the latest remove gold user history detail
                            latestRemoveGoldSeatHistory = removeGoldSeatHistoryDetails[i];
                            latestRemovedGamerTag = xcurd.szGamertag;
                        }
                    }

                    familyRiskData.FamilyMemberRemovedCount = removeGoldSeatHistoryDetails.Length;

                    familyRiskData.MemberGamertagLastRemoved = latestRemovedGamerTag;

                    familyRiskData.MemberLastRemovedTimestamp = latestRemoveGoldSeatHistory.Timestamp;

                    familyRiskData.RemovedMemberGamertags = removedGamerTagList.ToString();
                }
            }
            return familyRiskData;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\marketplace\finbus\FinBusItem.cs ===
using System;
using System.Collections.Generic;
using System.IO;
using System.Text;
using System.Xml;
using System.Xml.Serialization;

using Microsoft.Webstore.WstClient;

using xonline.common.billing;
using xonline.common.config;
using xonline.common.mgmt;
using xonline.common.offer;
using xonline.common.service;
using xonline.common.sql.webstore;
using xonline.common.user;
using xonline.common.utilities;

namespace xonline.common.finbus
{
    public enum FinBusItemType : byte
    {
        PurchaseOrder = 1,
        TokenRedemption = 2,
    }

    public abstract class FinBusItem
    {
        public Puid UserPuid { get; set; }

        public Puid UserPassportPuid { get; set; }

        public byte UserCountryId { get; set; }

        public int UserTier { get; set; }

        public string AccountId { get; set; }

        public int StoreId { get; set; }

        public uint TitleId { get; set; }

        public Guid TransactionGuid { get; set; }

        public Guid TrackingGuid { get; set; }

        public byte PurchaseOrigin { get; set; }

        public string IpAddress { get; set; }

        public string DeviceId { get; set; }

        public DateTime TransactionDate { get; set; }

        [XmlIgnoreAttribute]
        public string BehaviorInjection { get; set; }

        protected enum TokenMask : int
        {
            None = 0,
            RevenueBearing = 2,
            Legacy = 4,
            Test = 8,
            RoyaltyBearing = 16
        }

        protected enum ChannelTypeEnum : int
        {
            Marketplace = 1,
            Etailer = 2,
            Retailer = 3
        }

        protected const string DefaultUnitOfMeasure = "EA";

        /// <summary>
        /// Default constructor called when item is deserialized
        /// </summary>
        public FinBusItem()
        {
        }

        /// <summary>
        /// Method used to convert the FinBusItem into an XML string for storage in db
        /// </summary>
        /// <param name="serializableObject">the object that is being converted</param>
        /// <param name="type">The .NET type of the object used to create the XML Serializer</param>
        /// <returns>string containing the valid XML</returns>
        public static string ConvertObjectToXml(Object serializableObject, Type type)
        {
            XmlSerializer serializer = new XmlSerializer(type);
            StringWriter stringWriter = new StringWriter();
            XmlTextWriterMinimalist xmlWriter = new XmlTextWriterMinimalist(stringWriter);
            string xml = null;
            try
            {
                serializer.Serialize(xmlWriter, serializableObject);
                xml = stringWriter.ToString();
            }
            finally
            {
                xmlWriter.Close();
                stringWriter.Close();
            }

            return xml;
        }

        /// <summary>
        /// Method to reconstitute the FinBusItem from the XML string stored in the DB
        /// </summary>
        /// <param name="xml">the data as an xml blob</param>
        /// <param name="type">the full .net type that we are going reconstitute</param>
        /// <returns>The rehydrated FinBusItem (either FinBusPurchaseOrderItem or FinBusTokenRedemptionItem</returns>
        public static FinBusItem GetObjectFromXml(string xml, Type type)
        {
            XmlSerializer serializer = new XmlSerializer(type);
            StringReader stream = new StringReader(xml);
            XmlTextReader reader = new XmlTextReader(stream);
            FinBusItem item = (FinBusItem)serializer.Deserialize(reader);
            return item;
        }

        /// <summary>
        /// Method to return the XNA Creator Id (if one exists) from an OfferInfo object
        /// </summary>
        /// <param name="offerInfo">OfferInfo for the purchased offer</param>
        /// <returns>The XNA Creator Id (if any) associated with the OfferInfo</returns>
        public static string GetXnaCreatorId(OfferInfo offerInfo)
        {
            string xnaCreatorId = null;

            for (int i = 0; i < offerInfo.mediaInstanceInfos.Count; i++)
            {
                if (offerInfo.mediaInstanceInfos[i].mediaContributorId != Guid.Empty)
                {
                    xnaCreatorId = offerInfo.mediaInstanceInfos[i].mediaContributorId.ToString();
                    break;
                }
            }

            return xnaCreatorId;
        }

        /// <summary>
        /// Return the oldest maxItem pending FinBus items from a given UserCommerceDB partition
        /// </summary>
        /// <param name="partition">index of the physical partition to check</param>
        /// <returns>An array of pending FinBusItem objects</returns>
        public static FinBusItem[] GetPendingItems(int partition)
        {
            List<FinBusItem> pendingItems = new List<FinBusItem>();

            int maxItems = Config.GetIntSetting(Setting.finbus_getPendingItemsMaxItems);

            // this stored procedure acquires locks and must be executed on the primary write partition
            using (WSClient ws = new WSClient(ConfigUtil.GetUserCommerceWebstoreApp(), CmdType.WRITEONLY_COMMANDTYPE))
            {
                ws.StoredProc = "dbo.p_finbus_get_pending_items_v2";
                ws.PhysicalPartition = partition;

                ws.AddParameter(ParamType.RETVAL, "@hr", 0);
                ws.AddParameter("@i_max_items", maxItems);
                ws.AddParameter("@i_consider_failed_seconds", Config.GetIntSetting(Setting.finbus_transactionConsiderFailureSeconds));

                using (WstDataReader r = ws.Execute())
                {
                    while ( r.Read() )
                    {
                        short version = r.GetInt16(r.GetOrdinal("si_version"));
                        FinBusItemType itemType = (FinBusItemType) r.GetByte(r.GetOrdinal("ti_finbus_item_type"));
                        string finbusItemXml = r.GetString(r.GetOrdinal("vc_finbus_item_xml"));
                        string behaviorInjection = r.GetString(r.GetOrdinal("vc_behavior_injection"));

                        Type t = ( itemType == FinBusItemType.PurchaseOrder) ? typeof(FinBusPurchaseOrderItem) : typeof(FinBusTokenRedemptionItem);

                        FinBusItem item = FinBusItem.GetObjectFromXml(finbusItemXml, t);
                        item.BehaviorInjection = behaviorInjection;

                        pendingItems.Add(item);
                    }

                    r.Close();

                    HResult hr = (uint)ws.GetIntParameter("@hr");

                    if (HResult.Failed(hr))
                    {
                        string msg = ws.GetCallSignature() + " failed with hr = " + hr;

                        Xom.Trace(XomAreaName.finbusTrace, LogLevel.L_ERROR, msg);

                        throw new XRLException(hr, XEvent.Id.FINBUS_QUEUE_GET_ITEM_FOR_RETRY_ERROR, msg);
                    }
                }
            }

            return pendingItems.ToArray();
        }

        /// <summary>
        /// Method used to serialize a FinBusItem into the database with it's status sent as -1.
        /// This is an unkonwn state which will prevent the object from being picked up by the
        /// FinBusQueue and resent.
        /// </summary>
        public void RecordFinBusItemPreIntent()
        {
            string behaviorInjection = this.BehaviorInjection;

            byte itemType = (byte) ( (this is FinBusPurchaseOrderItem) ? FinBusItemType.PurchaseOrder : FinBusItemType.TokenRedemption );
            Type t = (this is FinBusPurchaseOrderItem) ? typeof(FinBusPurchaseOrderItem) : typeof(FinBusTokenRedemptionItem);

            using (WSClient ws = new WSClient(ConfigUtil.GetUserCommerceWebstoreApp(), CmdType.WRITEONLY_COMMANDTYPE))
            {
                // Data is partitioned by user puid
                ws.PartitionType = WstPartitionType.Logical;
                ws.SetHashVal(this.UserPuid);

                ws.StoredProc = "dbo.p_finbus_record_item_preintent_v2";
                ws.AddParameter(ParamType.RETVAL, "@hr", 0);
                ws.AddParameter("@bi_user_puid", this.UserPuid);
                ws.AddParameter("@uid_tracking_guid", this.TrackingGuid);
                ws.AddParameter("@si_version", 2);
                ws.AddParameter("@ti_finbus_item_type", itemType);
                ws.AddParameter("@vc_finbus_item_xml", ConvertObjectToXml(this, t));
                ws.AddParameter("@i_consider_expired_seconds", Config.GetIntSetting(Setting.finbus_transactionExpiredSeconds));
                ws.AddParameter("@vc_behavior_injection", behaviorInjection ?? string.Empty);
                ws.AddParameter("@si_hash_bucket", ws.Partition);

                ws.ExecuteNonQuery();

                HResult hr = (uint)ws.GetIntParameter("@hr");
                if (HResult.Failed(hr))
                {
                    string msg = ws.GetCallSignature() + " failed with hr = " + hr;

                    Xom.Trace(XomAreaName.finbusTrace, LogLevel.L_ERROR, msg);

                    // if there is another purchase pending, an event does not need to be logged
                    if ( hr == HResult.XONLINE_E_PURCHASE_PENDING )
                    {
                        throw new XRLExceptionWithoutEvent(hr, "RecordFinBusItemStatus: user: 0x{0} already has a pending transaction, throttling to prevent possible double-purchase attempt...", this.UserPuid.ToString());
                    }

                    throw new XRLException(hr, XEvent.Id.FINBUS_RECORD_TRANSACTION_PREINTENT_FAILURE, msg);
                }
            }
        }

        /// <summary>
        /// If the transaction was successful, the FinBus transaction will be moved from the PreIntent to the Intent state
        /// <param name="userPuid">user puid used to figure out what db partition we are on</param>
        /// <param name="transactionGuid">the GUID of the transaction object in the database to retrieve</param>
        public static void RecordFinBusItemIntent(ulong userPuid, Guid trackingGuid)
        {
            using (WSClient ws = new WSClient(ConfigUtil.GetUserCommerceWebstoreApp(), CmdType.WRITEONLY_COMMANDTYPE))
            {
                // Data is partitioned by user puid
                ws.PartitionType = WstPartitionType.Logical;
                ws.SetHashVal(userPuid);

                ws.StoredProc = "dbo.p_finbus_record_item_intent_v2";
                ws.AddParameter(ParamType.RETVAL, "@hr", 0);

                ws.AddParameter("@bi_user_puid", userPuid);
                ws.AddParameter("@uid_tracking_guid", trackingGuid);
                ws.ExecuteNonQuery();

                HResult hr = (uint)ws.GetIntParameter("@hr");
                if (HResult.Failed(hr))
                {
                    string msg = ws.GetCallSignature() + " failed with hr = " + hr;

                    Xom.Trace(XomAreaName.finbusTrace, LogLevel.L_ERROR, msg);

                    throw new XRLException(hr, XEvent.Id.FINBUS_RECORD_TRANSACTION_INTENT_FAILURE, msg);
                }
            }
        }

        public static void RecordFinBusItemSuccess(ulong userPuid, Guid trackingGuid, Guid messageId, DateTime messageDate)
        {
            using (WSClient ws = new WSClient(ConfigUtil.GetUserCommerceWebstoreApp(), CmdType.WRITEONLY_COMMANDTYPE))
            {
                // Data is partitioned by user puid
                ws.PartitionType = WstPartitionType.Logical;
                ws.SetHashVal(userPuid);

                ws.StoredProc = "dbo.p_finbus_record_item_result_v2";

                ws.AddParameter(ParamType.RETVAL, "@hr", 0);
                ws.AddParameter("@bi_user_puid", userPuid);
                ws.AddParameter("@uid_tracking_guid", trackingGuid);
                ws.AddParameter("@i_status_id", (int)DMPClient.DMPTransactionStatus.Success);
                ws.AddParameter("@i_hresult", HResult.S_OK);
                ws.AddParameter("@i_error_code", 0);
                ws.AddParameter("@vc_error_detail", string.Empty);
                ws.AddParameter("@uid_message_id", messageId);
                ws.AddParameter("@dt_message_date", messageDate);

                ws.ExecuteNonQuery();

                HResult hr = (uint)ws.GetIntParameter("@hr");
                if (HResult.Failed(hr))
                {
                    string msg = ws.GetCallSignature() + " failed with hr = " + hr;

                    Xom.Trace(XomAreaName.finbusTrace, LogLevel.L_ERROR, msg);

                    throw new XRLException(hr, XEvent.Id.FINBUS_RECORD_TRANSACTION_RESULT_FAILURE, msg);
                }
            }
        }

        public static void RecordFinBusItemFailure(ulong userPuid, Guid trackingGuid, HResult finbusHResult, int errorCode, string errorDetail)
        {
            using (WSClient ws = new WSClient(ConfigUtil.GetUserCommerceWebstoreApp(), CmdType.WRITEONLY_COMMANDTYPE))
            {
                // Data is partitioned by user puid
                ws.PartitionType = WstPartitionType.Logical;
                ws.SetHashVal(userPuid);

                ws.StoredProc = "dbo.p_finbus_record_item_result_v2";

                ws.AddParameter(ParamType.RETVAL, "@hr", 0);
                ws.AddParameter("@bi_user_puid", userPuid);
                ws.AddParameter("@uid_tracking_guid", trackingGuid);
                ws.AddParameter("@i_status_id", (int)DMPClient.DMPTransactionStatus.Pending);
                ws.AddParameter("@i_hresult", finbusHResult);
                ws.AddParameter("@i_error_code", errorCode);
                ws.AddParameter("@vc_error_detail", errorDetail);

                ws.ExecuteNonQuery();

                HResult hr = (uint)ws.GetIntParameter("@hr");
                if (HResult.Failed(hr))
                {
                    string msg = ws.GetCallSignature() + " failed with hr = " + hr;

                    Xom.Trace(XomAreaName.finbusTrace, LogLevel.L_ERROR, msg);

                    throw new XRLException(hr, XEvent.Id.FINBUS_RECORD_TRANSACTION_RESULT_FAILURE, msg);
                }
            }
        }

        public static void ClearFinBusItemPreIntent(ulong userPuid, Guid trackingGuid)
        {
            using (WSClient ws = new WSClient(ConfigUtil.GetUserCommerceWebstoreApp(), CmdType.WRITEONLY_COMMANDTYPE))
            {
                // Data is partitioned by user puid
                ws.PartitionType = WstPartitionType.Logical;
                ws.SetHashVal(userPuid);

                ws.StoredProc = "dbo.p_finbus_clear_item_preintent_v2";

                ws.AddParameter(ParamType.RETVAL, "@hr", 0);
                ws.AddParameter("@bi_user_puid", userPuid);
                ws.AddParameter("@uid_tracking_guid", trackingGuid);

                ws.ExecuteNonQuery();

                HResult hr = (uint)ws.GetIntParameter("@hr");
                if (HResult.Failed(hr))
                {
                    string msg = ws.GetCallSignature() + " failed with hr = " + hr;

                    Xom.Trace(XomAreaName.finbusTrace, LogLevel.L_ERROR, msg);

                    throw new XRLException(hr, XEvent.Id.FINBUS_RECORD_TRANSACTION_RESULT_FAILURE, msg);
                }
            }
        }

    #region FinBusItem Management
        #region Create
        public static FinBusItem CreateFinBusItem(User u, Guid trackingGuid, DateTime transactionDate,
            int storeId, byte purchaseOrigin, PaymentTypeEnum paymentType, string paymentInstrumentId, uint titleId,
            Guid tokenCategoryId, byte[] tokenHash, List<OfferInfo> offerInfoList, string ipAddress, string deviceId, string behaviorInjections)
        {
            FinBusItem item = null;

            if (paymentType == PaymentTypeEnum.Token)
            {
                item = FinBusTokenRedemptionItem.CreateTokenRedemption(u, trackingGuid, transactionDate, purchaseOrigin, titleId, storeId, tokenCategoryId, tokenHash, offerInfoList, ipAddress, deviceId, behaviorInjections);
            }
            else
            {
                item = FinBusPurchaseOrderItem.CreatePurchaseOrder(u, trackingGuid, transactionDate, purchaseOrigin, paymentType, paymentInstrumentId, titleId, offerInfoList, storeId, ipAddress, deviceId, behaviorInjections);
            }


            return item;
        }
        #endregion

        protected static bool IsBundleOffer(OfferInfo offerInfo)
        {
            return (offerInfo != null && offerInfo.mediaTypeId == MediaTypeInfo.Bundle);
        }

    #endregion
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\marketplace\espengine\FqlTypes.cs ===
using System;
using System.Text;

using xonline.common.service;
using xonline.common.config;

namespace xonline.common.espengine
{
    /// <summary>
    /// Constructs an appropriate FqlType based on the parameters passed in
    /// </summary>
    public static class FqlTypeFactory
    {
        /// <summary>
        /// Create an FQL type based on the parameters passed in
        /// </summary>
        /// <param name="syntax">If syntax is turned on</param>
        /// <param name="scope">If scope is turned on</param>
        /// <param name="mapping">What the client parameter maps to in FQL</param>
        /// <param name="parameter">What the client parameter is</param>
        /// <param name="dataType">Data type of the parameter</param>
        /// <returns></returns>
        public static FqlType GetFqlType(bool syntax, bool scope, string mapping, 
                                        string parameter, string dataType, bool nonSearchableFilter, 
                                        bool offerFilter, bool flatFilter, bool rollupFilter, bool isRootLevelSearch,
                                        String antiPhraseMode )
        {
            FqlType.AntiPhraseMode mode = FqlType.GetAntiPhraseMode(antiPhraseMode);

            return new BasicFqlType(syntax, scope, mapping, parameter, dataType, nonSearchableFilter, offerFilter, flatFilter, rollupFilter, isRootLevelSearch, mode);
        }
    }

    /// <summary>
    /// Base FQL type 
    /// 
    /// Specific FQL types will implement this abstract class
    /// </summary>
    public abstract class FqlType
    {
        public enum AntiPhraseMode
        {
            NotSet = 0,
            Phrase = 1,
            And = 2,
            Or = 3,
            Any = 4,
            Near = 5,
            ONear = 6,
            SimpleAny = 7,
            SimpleAll = 8
        }

        public static String[] AntiPhraseModeString = new String[9];
        static FqlType()
        {
            AntiPhraseModeString[(Int32)AntiPhraseMode.NotSet]      = null;
            AntiPhraseModeString[(Int32)AntiPhraseMode.Phrase]      = "phrase";
            AntiPhraseModeString[(Int32)AntiPhraseMode.And]         = "and";
            AntiPhraseModeString[(Int32)AntiPhraseMode.Or]          = "or";
            AntiPhraseModeString[(Int32)AntiPhraseMode.Any]         = "any";
            AntiPhraseModeString[(Int32)AntiPhraseMode.Near]        = "near";
            AntiPhraseModeString[(Int32)AntiPhraseMode.ONear]       = "onear";
            AntiPhraseModeString[(Int32)AntiPhraseMode.SimpleAny]   = "simpleany";
            AntiPhraseModeString[(Int32)AntiPhraseMode.SimpleAll]   = "simpleall";
        }

        public bool IsEnforceSyntax;        // FQL will use syntax for AND/OR
        public bool IsEnforceScope;         // FQL will take advantage of SCOPE keyword
        public string FqlMapping;           // What this parameter maps to in FQL
        public string ClientParameter;      // What the client passes up
        public System.Type DataType;        // Data type of individual elements in the FQL statement
        public bool IsOfferFilter;          // FQL is filtering on offer data
        public bool IsNonSearchableFql;     // Search term is not used for FQL filtering
        public bool IsFlatFilterFql;         // Search term is a flat field
        public bool IsRollupFilter;         // Should we use this parameter for filtering the childRollups
        public bool IsRootLevelSearch;      // Should we use this parameter for filtering the root level searchableXml nodes?
        public AntiPhraseMode PhraseMode; // Determines whether the string searches are for exact phrases, containing all words, or any words

        public FqlType() { }

        // Overridden by implementing class to retrieve the FQL for that specific type
        public abstract String GetFql(String value, bool filterOnOffer);

        public override string ToString()
        {
            String updatedFqlMapping = String.Empty;
            String value = String.Empty;
            FqlMappingReplaceDash(ref updatedFqlMapping, ref value);
            return string.Format("IsEnforceScope:[{0}]\tIsEnforceSyntax:[{1}]\tIsFlatFilterFql:[{2}]\tFqlMapping:[{3}]\tdatatype:[{4}]\tclientParameter:[{5}]", IsEnforceScope, IsEnforceSyntax, IsFlatFilterFql, updatedFqlMapping, DataType.ToString(), ClientParameter);
        }

        /// <summary>
        /// Given a string representation of the anti phrase mode, converts it to an enum.
        /// </summary>
        /// <param name="modeString">The string version of the mode. Not case sensitive. One of 'phrase', 'and' or 'or'.</param>
        /// <returns></returns>
        public static AntiPhraseMode GetAntiPhraseMode(String modeString)
        {
            if ( String.IsNullOrEmpty( modeString ))
            {
                return AntiPhraseMode.NotSet;
            }

            try
            {
                return (AntiPhraseMode)(Enum.Parse(typeof(AntiPhraseMode), modeString, true));
            }
            catch (Exception)
            {
                throw new XRLException(HResult.XONLINE_E_ESP_ENGINE_INVALID_PARAMETER,
                    XEvent.Id.ESP_ENGINE_EXCEPTION,
                    "Antiphrase mode {0} is invalid");
            }
        }

        /// <summary>
        /// Detects and replaces the - in each FQL statement as necessary
        /// </summary>
        public void FqlMappingReplaceDash(ref String fqlMapping, ref String value)
        {
            String[] fastEspReplaceDashForParameter = Config.GetMultiSetting(MultiSetting.fastEspReplaceDashForParameter);

            // If the parameter exists in the multisetting telling us to strip dashes, we need to replace those
            // dash values with Z
            if (Array.Exists(fastEspReplaceDashForParameter,
                    delegate(String str)
                    {
                        return String.Compare(str, FqlMapping, StringComparison.OrdinalIgnoreCase) == 0;
                    }
                    )
                )
            {
                value = value.Replace('-', 'Z');
                fqlMapping = FqlMapping + "NoDash";
            }
            else
            {
                fqlMapping = FqlMapping;
            }

        }
    }

    /// <summary>
    /// Basic FQL type 
    /// 
    /// Used for basic FQL types like integers and strings. It also
    /// can take advantage of the special syntax using . and _ to indicate
    /// OR/AND respectively.
    /// 
    /// For example, a basic FQL type using integer and special syntax
    /// productType = 19.21
    /// productType:or(19, 21)
    /// 
    /// Basic FQL type using integer and scope:
    /// avatarBodyType=1.3
    /// filter(avatarBodyType:or("1", "3")), not(scope(avatarBodyType))
    /// 
    /// Basic FQL without using the special syntax:
    /// filter(locale:("en-us"))
    /// </summary>
    public class BasicFqlType : FqlType
    {
        private static readonly Char[] syntaxSplit = new Char[] { '.', '_' };
        /// <summary>
        /// 
        /// </summary>
        /// <param name="syntax"></param>
        /// <param name="scope"></param>
        /// <param name="mapping"></param>
        /// <param name="parameter"></param>
        /// <param name="dataType"></param>
        public BasicFqlType(bool syntax, bool scope, string mapping, string parameter, string dataType, bool isNonSearchable, bool isOfferFilter, bool isFlatFilter, bool isRollupFilter, bool isRootLevelSearch, FqlType.AntiPhraseMode antiPhraseMode)
        {
            try
            {
                DataType = System.Type.GetType(dataType);
            }
            catch (Exception ex)
            {
                throw new XRLException(HResult.XONLINE_E_ESP_ENGINE_INVALID_DATA_TYPE,
                                        XEvent.Id.ESP_ENGINE_EXCEPTION,
                                        string.Format("Invalid datatype was used for parameter [{0}]. Datatype: [{1}]", parameter, dataType),
                                        ex);
            }
            if (DataType == null)
            {
                throw new XRLException(HResult.XONLINE_E_ESP_ENGINE_INVALID_DATA_TYPE,
                        XEvent.Id.ESP_ENGINE_EXCEPTION,
                        string.Format("Invalid datatype was used for parameter [{0}]. Datatype: [{1}]", parameter, dataType));
            }
            IsEnforceSyntax = syntax;
            IsEnforceScope = scope;
            FqlMapping = mapping;
            ClientParameter = parameter;
            IsFlatFilterFql = isFlatFilter;
            IsOfferFilter = isOfferFilter;
            IsNonSearchableFql = isNonSearchable;
            IsRollupFilter = isRollupFilter;
            IsRootLevelSearch = isRootLevelSearch;
            PhraseMode = antiPhraseMode;
        }

        public override String GetFql(System.String value, bool filterOnOffer)
        {
            // There are two parts to this IF statement:
            //       1) If the FQL is filtering on the offer instance, allow the client to 'turn off' filtering on offer instance
            //       2) If the FQL is 'nonsearchable', like pagesize or page num, there is no valid FQL for it
            if (( !filterOnOffer && (IsOfferFilter || IsRollupFilter) ) || IsNonSearchableFql)
            {
                return string.Empty;
            }

            String updatedFqlMapping = String.Empty;
            FqlMappingReplaceDash(ref updatedFqlMapping, ref value);
            StringBuilder fqlStringBuilder = new StringBuilder();

            if (DataType == System.Type.GetType("System.DateTime"))
            {
                if (ClientParameter.ToLower().CompareTo("startdate") == 0 || ClientParameter.ToLower().CompareTo("mediavisibilitydate") == 0)
                {
                    return string.Format("filter({0}:range(min,{1}))", updatedFqlMapping, value);
                }
                else if (ClientParameter.ToLower().CompareTo("enddate") == 0)
                {
                    return string.Format("filter({0}:range({1}, max))", updatedFqlMapping, value);
                }
                else
                {
                    throw new XRLException(HResult.XONLINE_E_ESP_ENGINE_INVALID_PARAMETER,
                        XEvent.Id.ESP_ENGINE_EXCEPTION,
                        string.Format("DateTime datatype can only be used for startDate, endDate, or mediavisibilitydate. value [{0}]", value));
                }
            }

            // If Scope'd we OR the results of the values passed in with the scope keyword
            if (IsEnforceScope)
            {
                fqlStringBuilder.Append("xml:or(");
            }

            // Special case, we do not want to filter on search term. If we filter on search term it will not
            // be used for calculating the relevancy
            if (updatedFqlMapping.ToLower().CompareTo("searchterm") == 0)
            {
                fqlStringBuilder.Append("searchterm:string(");
            }
            else
            {
                fqlStringBuilder.AppendFormat("filter({0}{1}:", IsEnforceScope ? "searchableXml:" : "", updatedFqlMapping);
            }
            
            if (IsEnforceSyntax)
            {
                // If we are going to OR parameters together, the FQL will look like:
                //      filter(tier:or(2,3))
                // If we are going to AND parameters together, the FQL will look like:
                //      filter(categoryId:(3002)) and filter(categoryId:3011) and filter(categoryId:3027) 

                // Check to ensure only one or the other available syntax types is in use
                if (value.Contains(".") && value.Contains("_"))
                {
                    throw new XRLException(HResult.XONLINE_E_ESP_ENGINE_INVALID_SYNTAX,
                                        XEvent.Id.ESP_ENGINE_EXCEPTION,
                                        string.Format("value used mix syntax. Use either . or _ syntax and not both", value));
                }
                else if (value.Contains("."))
                {
                    fqlStringBuilder = new StringBuilder();
                    fqlStringBuilder.AppendFormat("filter({0}:or(", updatedFqlMapping);

                    // Split accross . or _
                    string[] split = value.Split(syntaxSplit);
                    int i = 0;
                    while (i < split.Length)
                    {
                        System.String str = split[i];

                        // To quote or not to quote
                        switch (DataType.ToString())
                        {
                            case "System.Int32":
                                fqlStringBuilder.Append(str);
                                break;
                            case "System.String":
                            case "System.Guid":

                                fqlStringBuilder.AppendFormat("\"{0}\"", str);
                                break;
                            default:
                                throw new XRLException(HResult.XONLINE_E_ESP_ENGINE_INVALID_PARAMETER,
                                    XEvent.Id.ESP_ENGINE_EXCEPTION,
                                    string.Format("Invalid data type for value [{0}]", value));
                        }

                        // Check if we are at the last element, don't add additional coma for the last element
                        if (i < split.Length - 1)
                        {
                            fqlStringBuilder.Append(",");
                        }
                        ++i;
                    }

                    fqlStringBuilder.Append("))");
                }
                else if (value.Contains("_"))
                {
                    bool isFirst = true;
                    fqlStringBuilder = new StringBuilder();

                    // Split accross . or _
                    string[] split = value.Split(syntaxSplit);
                    int i = 0;
                    while (i < split.Length)
                    {
                        System.String val = split[i];

                        // To quote or not to quote
                        switch (DataType.ToString())
                        {
                            case "System.Int32":
                                fqlStringBuilder.AppendFormat("{0}filter({1}:{2})", isFirst ? "" : " and ", updatedFqlMapping, val);
                                break;
                            case "System.String":
                            case "System.Guid":
                                fqlStringBuilder.AppendFormat("{0}filter({1}:\"{2}\")", isFirst ? "" : " and ", updatedFqlMapping, val);
                                break;
                            default:
                                throw new XRLException(HResult.XONLINE_E_ESP_ENGINE_INVALID_PARAMETER,
                                    XEvent.Id.ESP_ENGINE_EXCEPTION,
                                    string.Format("Invalid data type for value [{0}]", value));
                        }

                        isFirst = false;

                        ++i;
                    }
                }
                else // We just have one value
                {
                    fqlStringBuilder = new StringBuilder();

                    // To quote or not to quote
                    switch (DataType.ToString())
                    {
                        case "System.Int32":
                            fqlStringBuilder.AppendFormat("filter({0}:{1})", updatedFqlMapping, value);
                            break;
                        case "System.String":
                        case "System.Guid":
                            fqlStringBuilder.AppendFormat("filter({0}:\"{1}\")", updatedFqlMapping, value);
                            break;
                        default:
                            throw new XRLException(HResult.XONLINE_E_ESP_ENGINE_INVALID_PARAMETER,
                                XEvent.Id.ESP_ENGINE_EXCEPTION,
                                string.Format("Invalid data type for value [{0}]", value));
                    }
                }
            }
            else
            {
                switch (DataType.ToString())
                {
                    case "System.Int32":
                        fqlStringBuilder.Append(value);
                        break;
                    case "System.String":
                    case "System.Guid":
                        fqlStringBuilder.AppendFormat("\"{0}\"", FqlEscape(value));
                        break;
                    default:
                        throw new XRLException(HResult.XONLINE_E_ESP_ENGINE_INVALID_PARAMETER,
                            XEvent.Id.ESP_ENGINE_EXCEPTION,
                            string.Format("Invalid data type for value [{0}]", value));
                }

                // The beginning of the FQL for 'searchterm' was special cased. This is the special casing for
                // the closure of the 'searchterm' FQL
                if (updatedFqlMapping.ToLower().CompareTo("searchterm") == 0)
                {
                    if (PhraseMode != AntiPhraseMode.NotSet)
                    {
                        fqlStringBuilder.AppendFormat(", mode=\"{0}\"", AntiPhraseModeString[(Int32)PhraseMode] );
                    }
                }

                fqlStringBuilder.Append(")");
            }

            // Add in scope field information
            if (IsEnforceScope)
            {
                fqlStringBuilder.AppendFormat(", not(scope({0})))", updatedFqlMapping);               
            }

            return fqlStringBuilder.ToString();
        }

        private string FqlEscape(string str)
        {
            return str.Replace("\"", "\\\"");
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\marketplace\family\MergeSubscriptionUtils.cs ===
using System;
using System.Web;

using CTPTransactionService;

using xonline.common.billing;
using xonline.common.config;
using xonline.common.mgmt;
using xonline.common.protocol;
using xonline.common.service;
using XonlineUser=xonline.common.user;
using xonline.common.exceptions;
using xonline.common.offer;



namespace xonline.common.family
{
    public class MergeSubscriptionUtils
    {
        /// <summary>
        /// Merge subscription method , return previewMerge when called in preview mode
        /// </summary>
        public static void MergeSubscription(Puid primaryFamilyUser, Puid dependentGoldUser, PassportToken ownerPassportToken, string ipAddress, string deviceId, bool isPreview, out PreviewMergeSubscriptionResponse previewMergeSubscriptionResponse)
        {

            previewMergeSubscriptionResponse = null;

            SubscriptionInfo activePrimarySubscriptionInfo = null;

            SubscriptionInfo activeDependentSubscriptionInfo = null;

            //Reconcile before we do anything with user's subscription
            SubscriptionInfoCollection primarySubInfoCollection= XeSubscriptionUtil.ReconcileSubscriptions(primaryFamilyUser, true);

            SubscriptionInfoCollection dependentSubInfoCollection=XeSubscriptionUtil.ReconcileSubscriptions(dependentGoldUser, true);

            //load the primary user
            XonlineUser.User primary = new XonlineUser.User();
            primary.Load(primaryFamilyUser);

            //load the dependent user
            XonlineUser.User dependent = new XonlineUser.User();
            dependent.Load(dependentGoldUser);

            activePrimarySubscriptionInfo = GetBaseSubscriptionInfoFromCollection(primarySubInfoCollection, primary);

            activeDependentSubscriptionInfo = GetBaseSubscriptionInfoFromCollection(dependentSubInfoCollection, dependent);

            //if tier is not silver and user still does not have a base subscription in CTP then it is an error.
            if (primary.Tier != (int)TierEnum.Silver)
            {
                if (activePrimarySubscriptionInfo == null)
                {
                    throw new XRLExceptionWithoutEvent(HResult.XONLINE_E_ACCOUNTS_NO_ACTIVE_BASE_SUBSCRIPTION, "Primary User {0} has no active base subscriptions", primaryFamilyUser);
                }
            }

            if (dependent.Tier != (int)TierEnum.Silver)
            {
                if (activeDependentSubscriptionInfo == null)
                {
                    throw new XRLExceptionWithoutEvent(HResult.XONLINE_E_ACCOUNTS_NO_ACTIVE_BASE_SUBSCRIPTION, "Dependent User {0} has no active base subscriptions", dependentGoldUser);
                }
            }

            //check for eligibility
            ValidateUsers(primary, dependent, ownerPassportToken);

            //if dependent is silver then return the response now if ispreview bit is set
            if (dependent.Tier == (int)TierEnum.Silver && isPreview)
            {

                previewMergeSubscriptionResponse = new PreviewMergeSubscriptionResponse();

                previewMergeSubscriptionResponse.monthsTransferred = 0;

                previewMergeSubscriptionResponse.nextChargeDate = activePrimarySubscriptionInfo.EndDate;

                return;

            }
            //rest of the logic has to be executed only if user is not belonginng to silver tier
            else if (dependent.Tier != (int)TierEnum.Silver)
            {
                //get the Join subscription request
                JoinSubscriptionInput request = GetJoinSubscriptionRequest(primary, dependent, activePrimarySubscriptionInfo, activeDependentSubscriptionInfo, isPreview, Guid.NewGuid());

                CTPTransactionServiceWrapper ctpTransactionServiceWrapper = new CTPTransactionServiceWrapper();

                JoinSubscriptionOutput response = null;

                //Make primary a sub admin for the dependent before we call preview
                AddSubscriptionRoleAssignment(activePrimarySubscriptionInfo.SubscriptionId, dependent.BillingPMN, primary.PassportPuid, dependent.PassportPuid);

                //if it is not a preview call and dependent is on monthly subscription then we want to make sure that we make the preview request
                //first and then use the SourceSubsRemainingDaysPrejoin to make actual merge
                if (!isPreview)
                {
                    if (IsMonthlyCycleChargedOffer(activeDependentSubscriptionInfo))
                    {

                        request.JoinSubsContext.ComputeOnly = true;

                        response = ctpTransactionServiceWrapper.JoinSubscription(request);

                        //create a new request for actual call
                        //get time extension info from the compute only call
                        //no other properties need to change
                        request.JoinSubsContext.ComputeOnly = false;

                        request.APIContext.TrackingGuid = Guid.NewGuid();

                        request.JoinSubscriptionInfoInput.SubsTimeExtensionInfo.ExtendedLength = GetEquivalentFamilyGoldMonths(response.JoinSubscriptionInfoOutput.SourceSubsRemainingDaysPrejoin);

                        response = null;

                    }
                }

                //Make the API Call
                response = ctpTransactionServiceWrapper.JoinSubscription(request);

                //construct response only if ispreview bit is set
                if (isPreview)
                {
                    previewMergeSubscriptionResponse = new PreviewMergeSubscriptionResponse();

                    //special treatment for 1 month. Display the months transferred and next charge date from SourceSubsRemainingDaysPrejoin
                    //this is because , this is the only way to know how much time is remaining on sourceSub when source sub is on cycle charged offer.
                    //with this logic in place , there are cases where preview might succeed but actual merge will fail.However those cases are edge case scenarios
                    if (IsMonthlyCycleChargedOffer(activeDependentSubscriptionInfo))
                    {
                        previewMergeSubscriptionResponse.monthsTransferred = (uint)GetEquivalentFamilyGoldMonths(response.JoinSubscriptionInfoOutput.SourceSubsRemainingDaysPrejoin);

                        previewMergeSubscriptionResponse.nextChargeDate = activePrimarySubscriptionInfo.EndDate.AddMonths((int)previewMergeSubscriptionResponse.monthsTransferred);

                    }
                    else
                    {
                        previewMergeSubscriptionResponse.monthsTransferred = (uint)XeSubscriptionUtil.GetMonthsFromDateDiff(activePrimarySubscriptionInfo.EndDate, response.JoinSubscriptionInfoOutput.DestinationSubscriptionStatus.NewEndDate);

                        previewMergeSubscriptionResponse.nextChargeDate = response.JoinSubscriptionInfoOutput.DestinationSubscriptionStatus.NewEndDate;
                    }

                }

                //Undo the assignment making primary a sub admin for the dependent after we call preview
                RemoveSubscriptionRoleAssignment(activePrimarySubscriptionInfo.SubscriptionId, dependent.BillingPMN, primary.PassportPuid, dependent.PassportPuid);
            }

        }

        /// <summary>
        /// Overloaded method gets called from Assigndependent to gold
        /// </summary>
        public static void MergeSubscription(Puid primaryFamilyUser, Puid dependentGoldUser)
        {
            PreviewMergeSubscriptionResponse response = null;

            string ipAddress = string.Empty;
            ulong machineId = 0;
            XRLUtil.GetClientInfo(out ipAddress, out machineId);

            MergeSubscription(primaryFamilyUser, dependentGoldUser, null, ipAddress, machineId.ToString("x"), false, out response);
        }

        private static SubscriptionInfo GetBaseSubscriptionInfoFromCollection(SubscriptionInfoCollection subInfoCollection, XonlineUser.User user)
        {
            string instanceId=string.Empty;

            int subscriptionStatusId=0;

            Guid catalogOfferId=Guid.Empty;

            Guid catalogOfferInstanceId=Guid.Empty;

            user.XeGetBaseSubscription(out instanceId, out subscriptionStatusId, out catalogOfferId, out catalogOfferInstanceId);
            for (int i = 0; i < subInfoCollection.SubscriptionInfoList.Count; i++)
            {
                SubscriptionInfo subInfo = (SubscriptionInfo)subInfoCollection.SubscriptionInfoList[i];

                if (subInfo.Instance.ServiceInstanceId == instanceId)
                {
                    return subInfo;
                }
            }

            return null;
        }
        /// <summary>
        /// Addrole assignment gets called before merge subscription is called.
        /// </summary>
        private static void AddSubscriptionRoleAssignment(string subscriptionId, string pmn, ulong primaryPassportPuid, ulong secondaryPassportPuid)
        {
            uint xboxPuidHigh;
            uint xboxPuidLow;
            Int64Convert.ToUintPair((long)primaryPassportPuid, out xboxPuidHigh, out xboxPuidLow);

            BillingProvider bp = new BillingProvider();

            string roleXml = GetRoleXml("SubscriptionAdmin", pmn, secondaryPassportPuid);

            string errorXml = "";

            bp.AddRoleAssignment(
                0, 0,                                   // delegate puid
                (int)xboxPuidHigh, (int)xboxPuidLow,   // requester puid
                subscriptionId,                         // object id
                roleXml,                                // role assignment XML
                out errorXml);                          // error XML
        }

        /// <summary>
        /// Removerole assignment gets called after merge subscription is called.
        /// </summary>
        private static void RemoveSubscriptionRoleAssignment(string subscriptionId, string pmn, ulong primaryPassportPuid, ulong secondaryPassportPuid)
        {
            uint xboxPuidHigh;
            uint xboxPuidLow;
            Int64Convert.ToUintPair((long)primaryPassportPuid, out xboxPuidHigh, out xboxPuidLow);

            BillingProvider bp = new BillingProvider();

            string roleXml = GetRoleXml("SubscriptionAdmin", pmn, secondaryPassportPuid);

            string errorXml = "";

            bp.RemoveRoleAssignment(
                0, 0,                                   // delegate puid
                (int)xboxPuidHigh, (int)xboxPuidLow,   // requester puid
                subscriptionId,                         // object id
                roleXml,                                // role assignment XML
                out errorXml);                          // error XML
        }

        /// <summary>
        /// Construct the role xml to be passed into AddRoleAssignment
        /// </summary>
        private static string GetRoleXml(string role, string pmn, ulong puid)
        {
            uint puidHigh;
            uint puidLow;
            Int64Convert.ToUintPair((long)puid, out puidHigh, out puidLow);

            string roleXml =
                "<RoleAssignment xmlns=\"urn:schemas-microsoft-com:billing-data\">" +
                    "<Role>" + role + "</Role>" +
                    "<PUIDHigh>" + (int)puidHigh + "</PUIDHigh>" +
                    "<PUIDLow>" + (int)puidLow + "</PUIDLow>" +
                    "<PMN>" + pmn + "</PMN>" +
                "</RoleAssignment>";

            return roleXml;
        }

        /// <summary>
        /// Validates the primary and secondary,calls the utility method in familyutils.
        /// </summary>
        private static void ValidateUsers(XonlineUser.User primaryFamilyUser, XonlineUser.User dependentGoldUser, PassportToken ownerPassportToken)
        {
            //verify eligibility. Although this is preview, it goes through all the same validation which AssignGoldDependent goes through
            HResult hr = FamilyUtils.VerifyFamilyGoldEligiblityForDependent(primaryFamilyUser, dependentGoldUser, ownerPassportToken);
            if (HResult.Failed(hr))
            {
                throw new XRLExceptionWithoutEvent(hr, "Dependent is ineligible for Gold seat assignment.Primary Puid {0},Dependent Puid {1}", primaryFamilyUser, dependentGoldUser);
            }
        }

        /// <summary>
        /// COnstruct the JoinSubscriptionInfoInput and return the request
        /// </summary>
        private static JoinSubscriptionInput GetJoinSubscriptionRequest(XonlineUser.User primaryFamilyUser, XonlineUser.User dependentGoldUser, SubscriptionInfo primarySubInfo, SubscriptionInfo dependentSubInfo, bool isPreview, Guid trackingGuid)
        {
            JoinSubscriptionInput request = new JoinSubscriptionInput();

            request.CallerInfo = GetCallerInfo(dependentGoldUser);

            request.APIContext = new APIContext();

            request.APIContext.TrackingGuid = trackingGuid;

            request.APIContext.PropertyBag = null;

            request.JoinSubsContext = new JoinSubsContext();

            request.JoinSubsContext.ComputeOnly = isPreview;

            // the ProductGuid property determines the banner in the generated e-mail
            var property = new Property()
            {
                Namespace = "Platform",
                Name = "ProductGuid",
                Value = Config.GetSetting(Setting.xbos_xbox360OrderAttributeGuid),
            };

            request.JoinSubsContext.PropertyBag = new Property[] { property };

            request.JoinSubsContext.TimeStamp = DateTime.UtcNow;

            //Fraud detection gets populated in the wrapper code
            request.JoinSubsContext.FraudDetectionContext = null;

            request.JoinSubscriptionInfoInput = new JoinSubscriptionInfoInput();

            request.JoinSubscriptionInfoInput.DestinationSubscriptionId = primarySubInfo.SubscriptionId;

            request.JoinSubscriptionInfoInput.SourceSubscriptionId = dependentSubInfo.SubscriptionId;

            request.JoinSubscriptionInfoInput.SubsTimeExtensionInfo = GetSubsTimeInfo(dependentGoldUser,dependentSubInfo);

            request.ExtensionData = null;

            return request;
        }

        /// <summary>
        /// Gets the subscription time extension info
        /// </summary>
        private static SubsTimeExtensionInfo GetSubsTimeInfo(XonlineUser.User dependentGoldUser, SubscriptionInfo dependentSubInfo)
        {
            SubsTimeExtensionInfo subTimeInfo = new SubsTimeExtensionInfo();

            //this is right now the best way to determine if an offer is cycle charged.
            //Alternative approach here would be to query rating rules but there is not easy way to do so.
            if (IsMonthlyCycleChargedOffer(dependentSubInfo))
            {
                //always give a month and be nice to user
                subTimeInfo.ExtendedLength = 1;
            }
            else
            {
                //get the equivalent family months and set it to ExtendedLength
                subTimeInfo.ExtendedLength = GetEquivalentFamilyGoldMonths(dependentGoldUser, dependentSubInfo.EndDate);
            }

            //Months for now
            subTimeInfo.ExtendedUnit = TimeExtensionUnit.Month;

            subTimeInfo.ExtendReasonCode = null;

            subTimeInfo.PropertyBag = null;

            return subTimeInfo;
        }



        /// <summary>
        /// Gets the equivalent family gold months
        /// </summary>
        private static int GetEquivalentFamilyGoldMonths(XonlineUser.User user, DateTime activeSubEndDate)
        {

            DateTime dtActiveSubscriptionEndDate = DateTime.MinValue;

            int goldMonthsRemaining = XeSubscriptionUtil.GetMonthsFromDateDiff(DateTime.UtcNow, activeSubEndDate);

            decimal familyGoldConvertionRatio = 0;

            if (!Decimal.TryParse(Config.GetSetting(Setting.xuacs_FamilyGoldConvertionRatio), out familyGoldConvertionRatio))
            {
                throw new XRLException(HResult.XONLINE_E_ACCOUNTS_INVALID_FAMILYGOLD_CONVERTION_VALUE, XEvent.Id.BILLING_ACCOUNTS_INVALID_FAMILY_CONVERSION_VALUE, "Invalid family convertion value");
            }
            else
            {
                if (familyGoldConvertionRatio < 0)
                {
                    throw new XRLException(HResult.XONLINE_E_ACCOUNTS_INVALID_FAMILYGOLD_CONVERTION_VALUE, XEvent.Id.BILLING_ACCOUNTS_INVALID_FAMILY_CONVERSION_VALUE, "Invalid family convertion value");
                }
            }

            //round to nearest integer.move away from zero.
             int familyGoldMonths = (int)Math.Ceiling(goldMonthsRemaining * familyGoldConvertionRatio);
             return familyGoldMonths;
        }

        private static int GetEquivalentFamilyGoldMonths(int sourceSubPreJoinDays)
        {

            decimal familyGoldConvertionRatio = 0;

            if (!Decimal.TryParse(Config.GetSetting(Setting.xuacs_FamilyGoldConvertionRatio), out familyGoldConvertionRatio))
            {
                throw new XRLException(HResult.XONLINE_E_ACCOUNTS_INVALID_FAMILYGOLD_CONVERTION_VALUE, XEvent.Id.BILLING_ACCOUNTS_INVALID_FAMILY_CONVERSION_VALUE, "Invalid family convertion value");
            }
            else
            {
                if (familyGoldConvertionRatio < 0)
                {
                    throw new XRLException(HResult.XONLINE_E_ACCOUNTS_INVALID_FAMILYGOLD_CONVERTION_VALUE, XEvent.Id.BILLING_ACCOUNTS_INVALID_FAMILY_CONVERSION_VALUE, "Invalid family convertion value {0}", familyGoldConvertionRatio.ToString());
                }
            }
            int goldMonthsRemaining = XeSubscriptionUtil.GetMonthsFromDateDiff(DateTime.UtcNow, DateTime.UtcNow.AddDays(sourceSubPreJoinDays));

            //round to nearest integer.move away from zero.
            int familyGoldMonths = (int)Math.Ceiling(goldMonthsRemaining * familyGoldConvertionRatio);
            return familyGoldMonths;
        }


        /// <summary>
        /// Construct caller info xml for a user
        /// </summary>
        private static CallerInfo GetCallerInfo(XonlineUser.User user)
        {
            CallerInfo callerInfo = new CallerInfo();

            callerInfo.AccountId = user.AccountId;
            callerInfo.AddressId = null;
            callerInfo.Delegator = new Identity();
            callerInfo.Delegator.IdentityType = "PUID";
            callerInfo.Delegator.IdentityValue = user.BillingPuid.ToString();
            callerInfo.Requester = new Identity();
            callerInfo.Requester.IdentityType = "PUID";
            callerInfo.Requester.IdentityValue = user.BillingPuid.ToString();

            return callerInfo;
        }

        private static bool IsMonthlyCycleChargedOffer(SubscriptionInfo subInfo)
        {
            if (subInfo.EndDate.Year.Equals(9999))
            {
                BillingOfferInfo billingOfferInfo = BillingOfferInfo.GetInstance(new Guid(subInfo.OfferingGUID));

                if (billingOfferInfo.DurationType == DurationType.Months && billingOfferInfo.Duration == 1)
                {
                    return true;
                }
            }

            return false;
        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\marketplace\finbus\FinBusPurchaseOrderItem.cs ===
using System;
using System.Collections.Generic;
using System.Diagnostics;

using xonline.common.config;
using xonline.common.billing;
using xonline.common.mgmt;
using xonline.common.offer;
using xonline.common.service;
using xonline.common.user;

namespace xonline.common.finbus
{
    /// <summary>
    /// Wrapper for FinBus purchase Order
    /// </summary>
    public class FinBusPurchaseOrderItem : FinBusItem
    {
        public FinBusPurchaseOrderItem() : base()
        {
        }

        public PurchaseOrderV2 PurchaseOrder
        {
            get; set;
        }

        internal static FinBusPurchaseOrderItem CreatePurchaseOrder
        (
            User u,
            Guid purchaseTrackingGuid,
            DateTime transactionDate,
            byte purchaseOrigin,
            PaymentTypeEnum paymentType,
            string paymentInstrumentId,
            uint titleId,
            List<OfferInfo> offerInfoList,
            int storeId,
            string ipAddress,
            string deviceId,
            string behaviorInjection
        )
        {
            Guid finbusTrackingGuid = Guid.NewGuid();

            FinBusPurchaseOrderItem purchaseOrderItem = new FinBusPurchaseOrderItem();
            purchaseOrderItem.UserPuid = u.Puid;
            purchaseOrderItem.UserPassportPuid = u.PassportPuid;
            purchaseOrderItem.UserCountryId = u.CountryId;
            purchaseOrderItem.UserTier = u.Tier;
            purchaseOrderItem.AccountId = u.AccountId;
            purchaseOrderItem.TitleId = titleId;
            purchaseOrderItem.StoreId = storeId;
            purchaseOrderItem.TransactionGuid = purchaseTrackingGuid; // TODO: this seems redundant
            purchaseOrderItem.TrackingGuid = purchaseTrackingGuid;
            purchaseOrderItem.PurchaseOrigin = purchaseOrigin;
            purchaseOrderItem.IpAddress = ipAddress;
            purchaseOrderItem.DeviceId = deviceId;
            purchaseOrderItem.TransactionDate = transactionDate;
            purchaseOrderItem.BehaviorInjection = behaviorInjection;

            purchaseOrderItem.PurchaseOrder = CreatePurchaseOrderV2(u, finbusTrackingGuid, purchaseTrackingGuid, transactionDate, paymentType, paymentInstrumentId, offerInfoList);

            return purchaseOrderItem;
        }

        protected static PurchaseOrderV2 CreatePurchaseOrderV2
        (
            User u,
            Guid finbusTrackingGuid,
            Guid purchaseTrackingGuid,
            DateTime transactionDate,
            PaymentTypeEnum paymentType,
            string paymentInstrumentId,
            List<OfferInfo> offerInfoList
        )
        {
            var purchaseOrder = new PurchaseOrderV2();

            purchaseOrder.Header = CreatePurchaseOrderHeaderV2(u, finbusTrackingGuid, purchaseTrackingGuid, transactionDate, paymentType, paymentInstrumentId, offerInfoList);

            var lineItemList = new List<PurchaseOrderLineItemV2>();
            foreach (OfferInfo offerInfo in offerInfoList)
            {
                PurchaseOrderLineItemV2 lineItem = CreatePurchaseOrderLineItemV2(paymentType, offerInfo);
                lineItemList.Add(lineItem);
            }
            purchaseOrder.LineItems = lineItemList.ToArray();

            return purchaseOrder;
        }

        protected static PurchaseOrderHeaderV2 CreatePurchaseOrderHeaderV2
        (
            User u,
            Guid finbusTrackingGuid,
            Guid purchaseTrackingGuid,
            DateTime transactionDate,
            PaymentTypeEnum paymentType,
            string paymentInstrumentId,
            List<OfferInfo> offerInfoList
        )
        {
            var header = new PurchaseOrderHeaderV2();

            header.PaymentInstrumentId = paymentInstrumentId;
            header.TransmissionId = finbusTrackingGuid;
            header.ChannelTypeId = (int) ChannelTypeEnum.Marketplace;
            header.TransactionDateTime = transactionDate;
            header.PurchaseTransactionId = purchaseTrackingGuid;

            return header;
        }

        protected static PurchaseOrderLineItemV2 CreatePurchaseOrderLineItemV2(PaymentTypeEnum paymentType, OfferInfo offerInfo)
        {
            var lineItem = new PurchaseOrderLineItemV2();

            lineItem.ProductId = offerInfo.mediaId;
            lineItem.ProductType = offerInfo.mediaTypeId;

            for (int i = 0; i < offerInfo.mediaInstanceInfos.Count; i++)
            {
                if (!string.IsNullOrEmpty(offerInfo.mediaInstanceInfos[i].mediaTitle))
                {
                    lineItem.ProductName = offerInfo.mediaInstanceInfos[i].mediaTitle;
                    break;
                }
            }

            lineItem.CurrencyCode = offerInfo.currencyCode;
            lineItem.OfferId = offerInfo.offerId;
            lineItem.OfferInstanceId = offerInfo.offerInstanceId;

            if (paymentType == PaymentTypeEnum.Points)
            {
                lineItem.PointsUsedQuantity = offerInfo.retailPricePoints;
                lineItem.BilledUnitPriceExcludingTax = 0;
                lineItem.TaxAmount = 0;
                lineItem.SuggestedRetailPricePointsQuantity = (int)offerInfo.suggestedRetailPrice;
                lineItem.WholesalePricePointsQuantity = (int)offerInfo.wholesalePrice;
                lineItem.PaymentMethodId = (int)PaymentTypeEnum.Points;
            }
            else if (paymentType == PaymentTypeEnum.CreditCard)
            {
                lineItem.PointsUsedQuantity = 0;
                lineItem.TaxAmount = offerInfo.taxAmount;
                if (Offer.IsTaxIncludedInPrices((TaxTypeEnum)offerInfo.taxTypeId))
                {
                    lineItem.BilledUnitPriceExcludingTax = offerInfo.currencyPrice - offerInfo.taxAmount;
                }
                else
                {
                    lineItem.BilledUnitPriceExcludingTax = offerInfo.currencyPrice;
                }

                lineItem.SuggestedRetailPriceCurrency = offerInfo.suggestedRetailPrice;
                lineItem.WholesalePriceCurrency = offerInfo.wholesalePrice;
                lineItem.PaymentMethodId = (int)PaymentTypeEnum.CreditCard;
            }

            lineItem.PointsDiscountAmount = 0;
            lineItem.PriceDiscountAmount = 0;

            lineItem.SubLineItems = CreatePurchaseOrderSubLineItemsV2(offerInfo);

            lineItem.XnaCreatorId = GetXnaCreatorId(offerInfo);

            if ( offerInfo.mediaTypeId == MediaTypeInfo.XNACommunityGame && string.IsNullOrEmpty(lineItem.XnaCreatorId) )
            {
                throw new XRLException(HResult.XONLINE_E_BILLING_FINBUS_MISSING_XNA_CREATOR_ID_ERROR,
                    XEvent.Id.FINBUS_MISSING_XNA_CREATOR_ID_ERROR,
                    "The media that was purchased has a media type of XNA Community Game, however the data returned from the stored procedure is missing an XNA Creator Id.");
            }

            return lineItem;
        }

        protected static PurchaseOrderSubLineItemV2[] CreatePurchaseOrderSubLineItemsV2(OfferInfo offerInfo)
        {
            Debug.Assert(offerInfo != null && offerInfo.mediaInstanceInfos != null && offerInfo.mediaInstanceInfos.Count > 0);
            if (offerInfo == null || offerInfo.mediaInstanceInfos == null || offerInfo.mediaInstanceInfos.Count <= 0)
            {
                throw new ArgumentNullException("offerInfo");
            }

            if ( IsBundleOffer(offerInfo) )
            {
                throw new ArgumentException("offerInfo: item bundles are not supported in June XSR timeframe.");
            }

            // This code is simplified due to the absence of bundle support. Once bundles are officially
            // supported, individual media instances will need to be considered (but only in bundle cases --
            // not in video purchases, which may also have multiple media instances)

            var subLineItem = new PurchaseOrderSubLineItemV2();

            subLineItem.ProductId = offerInfo.mediaId;
            subLineItem.ProductType = offerInfo.mediaTypeId;
            subLineItem.RevenueSKU = offerInfo.sku;
            subLineItem.RevenueAllocationPercentage = 100.0m; // Hardcoded to 100% for 7/3/2010

            return new PurchaseOrderSubLineItemV2[] { subLineItem };
        }
    }

    public class PurchaseOrderV2
    {
        public PurchaseOrderHeaderV2 Header
        {
            get; set;
        }

        public PurchaseOrderLineItemV2[] LineItems
        {
            get; set;
        }
    }

    public class PurchaseOrderHeaderV2
    {
        public string PaymentInstrumentId
        {
            get; set;
        }

        public int ChannelTypeId
        {
            get; set;
        }

        public Guid PurchaseTransactionId
        {
            get; set;
        }

        public DateTime TransactionDateTime
        {
            get; set;
        }

        public Guid TransmissionId
        {
            get; set;
        }
    }

    public class PurchaseOrderLineItemV2
    {
        public Guid ProductId
        {
            get; set;
        }

        public int ProductType
        {
            get; set;
        }

        public string ProductName
        {
            get; set;
        }

        public int SuggestedRetailPricePointsQuantity
        {
            get; set;
        }

        public decimal SuggestedRetailPriceCurrency
        {
            get; set;
        }

        public int WholesalePricePointsQuantity
        {
            get; set;
        }

        public decimal WholesalePriceCurrency
        {
            get; set;
        }

        public string Promotion
        {
            get; set;
        }

        public string ChannelSKU
        {
            get; set;
        }

        public Guid OfferId
        {
            get; set;
        }

        public Guid OfferInstanceId
        {
            get; set;
        }

        public int PaymentMethodId
        {
            get; set;
        }

        public string CurrencyCode
        {
            get; set;
        }

        public int PointsUsedQuantity
        {
            get; set;
        }

        public decimal BilledUnitPriceExcludingTax
        {
            get; set;
        }

        public decimal TaxAmount
        {
            get; set;
        }

        public decimal PointsDiscountAmount
        {
            get; set;
        }

        public decimal PriceDiscountAmount
        {
            get; set;
        }

        public PurchaseOrderSubLineItemV2[] SubLineItems
        {
            get; set;
        }

        public string XnaCreatorId
        {
            get; set;
        }
    }

    public class PurchaseOrderSubLineItemV2
    {
        public Guid ProductId
        {
            get; set;
        }

        public int ProductType
        {
            get; set;
        }

        public string RevenueSKU
        {
            get; set;
        }

        public decimal RevenueAllocationPercentage
        {
            get; set;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\marketplace\fse\FseBookmark.cs ===
// FseBookmark.cs
// Copyright (c) Microsoft Corporation. All Rights Reserved.

using System;

using xonline.common.config;
using xonline.common.service;

namespace xonline.common.fse
{
    public class FseBookmark
    {

        private int          _minutesFloor = 0;
        private const string _minutesFloorSetting = "MinutesFloor";

        private int          _minutesThreshold = 60;
        private const string _minutesThresholdSetting = "MinutesThreshold";

        private int          _hoursFloor = 0;
        private const string _hoursFloorSetting = "HoursFloor";

        private int          _hoursThreshold = 24;
        private const string _hoursThresholdSetting = "HoursThreshold";

        private int          _daysFloor = 0;
        private const string _daysFloorSetting = "DaysFloor";

        private int          _daysThreshold = 14;
        private const string _daysThresholdSetting = "DaysThreshold";

        // prefix for settings to allow for per service bookmark settings
        private string _prefix;

        public FseBookmark() : this("fse") {
        }

        public FseBookmark(string prefix)
        {
            _prefix = (string.IsNullOrEmpty(prefix) ? "fse" : prefix) + "_bookmark";
            Config.SettingChange += new SettingChangeEventHandler(SettingChange);
            Load();
        }

        public DateTime Adjust(DateTime bookmark)
        {
            bool daysAdjust = false;
            bool hoursAdjust = false;
            DateTime now = DateTime.UtcNow;

            try
            {
                // we always get rid of the seconds and milliseconds
                bookmark = bookmark.AddSeconds(-bookmark.Second);
                bookmark = bookmark.AddMilliseconds(-bookmark.Millisecond);

                //
                if (Math.Abs((bookmark -now).TotalMinutes) >= _minutesThreshold)
                {
                    if (Math.Abs((bookmark -now).TotalHours) >= _hoursThreshold)
                    {
                        hoursAdjust = true;
                        
                        if (Math.Abs((bookmark -now).TotalDays) >= _daysThreshold)
                        {
                            daysAdjust = true;
                        }
                    }

                    if (bookmark.Minute < _minutesFloor) bookmark = bookmark.AddHours(-1);
                    bookmark = bookmark.AddMinutes(_minutesFloor - bookmark.Minute);
                }

                if (hoursAdjust)
                {
                    if (bookmark.Hour < _hoursFloor) bookmark = bookmark.AddDays(-1);
                    bookmark = bookmark.AddHours(_hoursFloor - bookmark.Hour);
                }

                if (daysAdjust)
                {
                    if ((int)bookmark.DayOfWeek < _daysFloor) bookmark = bookmark.AddDays(-7);
                    bookmark = bookmark.AddDays(_daysFloor - (int)bookmark.DayOfWeek);
                }
            }
            catch (ArgumentOutOfRangeException aoore)
            {
                throw new ParameterException(HResult.XONLINE_E_FSE_PARAM_INVALID_VALUE, "Invalid value for parameter 'Bookmark'", aoore);
            }

            return bookmark;
        }


        public int CheckSetting(string setting, string value, int minimum, int maximum) {

            int result;

            if (int.TryParse(value, out result))
            {
                if (minimum <= result && result <= maximum) return result;

                throw new ConfigException(
                    HResult.XONLINE_E_FSE_BOOKMARK_INVALID_SETTING,
                    string.Format("Bookmark setting '{0}' is out of range [{1}-{2}]", setting, minimum, maximum)
                );
            }

            throw new ConfigException(
                HResult.XONLINE_E_FSE_BOOKMARK_INVALID_SETTING,
                string.Format("Bookmark setting '{0}' is not an integer", setting)
            );
        }

        
        public void UpdateSetting(string setting, string value)
        {
            // settings coming into here have the prefix on them
            // strip that off to normalize to the  known  values

            switch (setting.Substring(_prefix.Length))
            {
                case _minutesThresholdSetting:
                    _minutesThreshold = CheckSetting(setting, value, 0, int.MaxValue);
                    break;

                case _minutesFloorSetting:
                    _minutesFloor = CheckSetting(setting, value, 0, 59);
                    break;

                case _hoursThresholdSetting:
                    _hoursThreshold = CheckSetting(setting, value, 0, int.MaxValue);
                    break;

                case _hoursFloorSetting:
                    _hoursFloor = CheckSetting(setting, value, 0, 23);
                    break;

                case _daysThresholdSetting:
                    _daysThreshold = CheckSetting(setting, value, 0, int.MaxValue);
                    break;

                case _daysFloorSetting: // 0 = Sunday, ... 6 = Saturday
                    _daysFloor = CheckSetting(setting, value, 0, 6);
                    break;
            }
        }

       // event handler after changes to t_settings or t_setting_overrides
        public void SettingChange(object sender, SettingChangeEventArgs eventArgs)
        {
            if (!eventArgs.Setting.StartsWith(_prefix)) return;
            UpdateSetting(eventArgs.Setting, eventArgs.ValueNew);
        }

        private string[] _settings = {
            _minutesFloorSetting, _minutesThresholdSetting,
            _hoursFloorSetting,   _hoursThresholdSetting,
            _daysFloorSetting,    _daysThresholdSetting
        };

        private void Load()
        {
            foreach (string setting in _settings) {
                try {
                    // update and config expects settings to be prefixed.
                    UpdateSetting(_prefix + setting, Config.GetSetting(_prefix + setting));
                } catch (ApplicationException) {
                    // it's okay if there is no setting
                }
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\marketplace\finbus\FinBusTokenRedemptionItem.cs ===
﻿using System;
using System.Collections.Generic;
using System.Diagnostics;

using xonline.common.billing;
using xonline.common.config;
using xonline.common.mgmt;
using xonline.common.offer;
using xonline.common.service;
using xonline.common.user;

namespace xonline.common.finbus
{
    /// <summary>
    /// Wrapper for FinBus Token Redemption
    /// </summary>
    public class FinBusTokenRedemptionItem : FinBusItem
    {
        public FinBusTokenRedemptionItem() : base()
        {
        }

        public TokenRedemptionV2 TokenRedemption
        {
            get; set;
        }

        internal static FinBusTokenRedemptionItem CreateTokenRedemption
        (
            User u,
            Guid purchaseTrackingGuid,
            DateTime transactionDate,
            byte purchaseOrigin,
            uint titleId,
            int storeId,
            Guid tokenCategoryId,
            byte[] tokenHash,
            List<OfferInfo> offerInfoList,
            string ipAddress,
            string deviceId,
            string behaviorInjection
        )
        {
            FinBusTokenRedemptionItem tokenRedemptionItem = new FinBusTokenRedemptionItem();
            tokenRedemptionItem.UserPuid = u.Puid;
            tokenRedemptionItem.UserPassportPuid = u.PassportPuid;
            tokenRedemptionItem.UserCountryId = u.CountryId;
            tokenRedemptionItem.UserTier = u.Tier;
            tokenRedemptionItem.AccountId = u.AccountId;
            tokenRedemptionItem.TitleId = titleId;
            tokenRedemptionItem.StoreId = storeId;
            tokenRedemptionItem.TransactionGuid = purchaseTrackingGuid; // TODO: this seems redundant
            tokenRedemptionItem.TrackingGuid = purchaseTrackingGuid;
            tokenRedemptionItem.PurchaseOrigin = purchaseOrigin;
            tokenRedemptionItem.IpAddress = ipAddress;
            tokenRedemptionItem.DeviceId = deviceId;
            tokenRedemptionItem.TransactionDate = transactionDate;
            tokenRedemptionItem.BehaviorInjection = behaviorInjection;

            tokenRedemptionItem.TokenRedemption = CreateTokenRedemptionV2(u, purchaseTrackingGuid, transactionDate, tokenCategoryId, tokenHash, offerInfoList);

            return tokenRedemptionItem;
        }

        protected static TokenRedemptionV2 CreateTokenRedemptionV2
        (
            User u,
            Guid purchaseTrackingGuid,
            DateTime transactionDate,
            Guid tokenCategoryId,
            byte[] tokenHash,
            List<OfferInfo> offerInfoList
        )
        {
            var tokenRedemption = new TokenRedemptionV2();

            tokenRedemption.Header = CreateTokenRedemptionHeaderV2(purchaseTrackingGuid, transactionDate);

            var lineItemList = new List<TokenRedemptionLineItemV2>();
            foreach (OfferInfo offerInfo in offerInfoList)
            {
                TokenRedemptionLineItemV2 lineItem = CreateTokenRedemptionLineItemV2(tokenCategoryId, tokenHash, offerInfo);
                lineItemList.Add(lineItem);
            }
            tokenRedemption.LineItems = lineItemList.ToArray();

            return tokenRedemption;
        }

        protected static TokenRedemptionHeaderV2 CreateTokenRedemptionHeaderV2
        (
            Guid purchaseTrackingGuid,
            DateTime transactionDate
        )
        {
            var header = new TokenRedemptionHeaderV2();

            header.TransmissionId = purchaseTrackingGuid;
            header.ChannelTypeId = (int) ChannelTypeEnum.Marketplace;
            header.TransactionDateTime = transactionDate;
            header.PurchaseTransactionId = purchaseTrackingGuid;

            return header;
        }

        protected static TokenRedemptionLineItemV2 CreateTokenRedemptionLineItemV2(Guid tokenCategoryId, byte[] tokenHash, OfferInfo offerInfo)
        {
            var lineItem = new TokenRedemptionLineItemV2();

            lineItem.ProductId = offerInfo.mediaId;
            lineItem.ProductType = offerInfo.mediaTypeId;

            for (int i = 0; i < offerInfo.mediaInstanceInfos.Count; i++)
            {
                if (!string.IsNullOrEmpty(offerInfo.mediaInstanceInfos[i].mediaTitle))
                {
                    lineItem.ProductName = offerInfo.mediaInstanceInfos[i].mediaTitle;
                    break;
                }
            }

            lineItem.ChannelSKU = string.Empty; // TODO: get channel SKU from token category?
            lineItem.OfferId = offerInfo.offerId;
            lineItem.OfferInstanceId = offerInfo.offerInstanceId;
            lineItem.SubLineItems = CreateTokenRedemptionSubLineItemsV2(offerInfo);
            lineItem.TokenCategoryId = tokenCategoryId;
            lineItem.TokenHash = tokenHash;
            lineItem.TokenTypeId = (int) TokenMask.Legacy; // TODO: is this sufficient now that LIVE-generated tokens are in use?
            lineItem.XnaCreatorId = GetXnaCreatorId(offerInfo);

            if ( offerInfo.mediaTypeId == MediaTypeInfo.XNACommunityGame && string.IsNullOrEmpty(lineItem.XnaCreatorId) )
            {
                throw new XRLException(HResult.XONLINE_E_BILLING_FINBUS_MISSING_XNA_CREATOR_ID_ERROR,
                    XEvent.Id.FINBUS_MISSING_XNA_CREATOR_ID_ERROR,
                    "The media that was purchased has a media type of XNA Community Game, however the data returned from the stored procedure is missing an XNA Creator Id.");
            }

            return lineItem;
        }

        protected static TokenRedemptionSubLineItemV2[] CreateTokenRedemptionSubLineItemsV2(OfferInfo offerInfo)
        {
            Debug.Assert(offerInfo != null && offerInfo.mediaInstanceInfos != null && offerInfo.mediaInstanceInfos.Count > 0);
            if (offerInfo == null || offerInfo.mediaInstanceInfos == null || offerInfo.mediaInstanceInfos.Count <= 0)
            {
                throw new ArgumentNullException("offerInfo");
            }

            if ( IsBundleOffer(offerInfo) )
            {
                throw new ArgumentException("offerInfo: item bundles are not supported in June XSR timeframe.");
            }

            var subLineItem = new TokenRedemptionSubLineItemV2();

            subLineItem.ProductId = offerInfo.mediaId;
            subLineItem.ProductType = offerInfo.mediaTypeId;
            subLineItem.RevenueAllocationPercentage = 100.0m; // Hardcoded to 100% for 7/3/2010
            subLineItem.RevenueSKU = offerInfo.sku;

            return new TokenRedemptionSubLineItemV2[] { subLineItem };
        }

#if false
        // TODO: this legacy method was never used (and never will be as-is) but is being left commented-out
        // because it serves as something of a functional spec as to what the TokenTypeId is meant to be
        protected static int GetTokenTypeId(string billingTokenHash)
        {
            // this is out of scope for 7/3 so just return legacy
            return (int)TokenMask.Legacy;

            //using (WSClient ws = new WSClient(ConfigUtil.TokendbWebstoreApp, CmdType.WRITETHENREAD_COMMANDTYPE))
            //{
            //    StringBuilder sql = new StringBuilder("SELECT TC.f_in_scg, TC.f_is_rsm, TC.f_is_revenue_bearing ");
            //    sql.Append("FROM t_token_category as TC ");
            //    sql.Append("JOIN t_tokens_v2 as TV2 ON TC.uid_token_category_id = TV2.uid_token_category_id ");
            //    sql.Append("WHERE TV2.bin_token_hash = @tokenHash");

            //    ws.CommandSql = sql.ToString();
            //    ws.AddParameter("@tokenHash", billingTokenHash);

            //    WstDataReader reader = ws.Execute();
            //    bool isRoyalty = false;
            //    bool isRevenue = false;
            //    bool isTest = false;
            //    bool isLegacy = true;

            //    if (reader.Read())
            //    {
            //        isLegacy = false;
            //        isRevenue = Convert.ToBoolean(reader.GetByte(2));
            //    }

            //    reader.Close();

            //    int tokenType = (int)TokenMask.None;
            //    if (isRevenue)
            //    {
            //        tokenType |= (int)TokenMask.RevenueBearing;
            //    }

            //    if (isLegacy)
            //    {
            //        tokenType |= (int)TokenMask.Legacy;
            //    }

            //    if (isTest)
            //    {
            //        tokenType |= (int)TokenMask.Test;
            //    }

            //    if (isRoyalty)
            //    {
            //        tokenType |= (int)TokenMask.RoyaltyBearing;
            //    }

            //    return tokenType;
            //}
        }
#endif
    }

    public class TokenRedemptionV2
    {
        public TokenRedemptionHeaderV2 Header
        {
            get; set;
        }

        public TokenRedemptionLineItemV2[] LineItems
        {
            get; set;
        }
    }

    public class TokenRedemptionHeaderV2
    {
        public int ChannelTypeId
        {
            get; set;
        }

        public Guid PurchaseTransactionId
        {
            get; set;
        }

        public DateTime TransactionDateTime
        {
            get; set;
        }

        public Guid TransmissionId
        {
            get; set;
        }
    }

    public class TokenRedemptionLineItemV2
    {
        public Guid ProductId
        {
            get; set;
        }

        public int ProductType
        {
            get; set;
        }

        public string ProductName
        {
            get; set;
        }

        public string ChannelSKU
        {
            get; set;
        }

        public Guid OfferId
        {
            get; set;
        }

        public Guid OfferInstanceId
        {
            get; set;
        }

        public Guid TokenCategoryId
        {
            get; set;
        }

        public byte[] TokenHash
        {
            get; set;
        }

        public int TokenTypeId
        {
            get; set;
        }

        public TokenRedemptionSubLineItemV2[] SubLineItems
        {
            get; set;
        }

        public string XnaCreatorId
        {
            get; set;
        }
   }

    public class TokenRedemptionSubLineItemV2
    {
        public Guid ProductId
        {
            get; set;
        }

        public int ProductType
        {
            get; set;
        }

        public string RevenueSKU
        {
            get; set;
        }

        public decimal RevenueAllocationPercentage
        {
            get; set;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\marketplace\fse\FseDataReader.cs ===
//
// FseDb.cs
// Copyright (c) Microsoft Corporation. All Rights Reserved.
//

using System;
using System.Data.SqlClient;


using Microsoft.Webstore.WstClient;

namespace xonline.common.fse
{
    internal interface FseDataReader : IDisposable {
        bool     GetBoolean(int i);
        string   GetDataTypeName(int i);
        DateTime GetDateTime(int i);
        decimal  GetDecimal(int i);
        double   GetDouble(int i);
        Type     GetFieldType(int i);
        float    GetFloat(int i);
        Guid     GetGuid(int i);
        short    GetInt16(int i);
        int      GetInt32(int i);
        long     GetInt64(int i);
        string   GetString(int i);

        string   GetName(int i);
        int      GetOrdinal(string name);
        bool     IsDBNull(int i);
        bool     NextResult();
        bool     Read();
    }


    internal class FseSqlDataReader {

        internal SqlDataReader _reader;

        internal FseSqlDataReader(SqlDataReader reader) {
            _reader = reader;
        }

        public bool GetBoolean(int i) {
            return _reader.GetBoolean(i);
        }

        public string GetDataTypeName(int i) {
            return _reader.GetDataTypeName(i);
        }

        public DateTime GetDateTime(int i) {
            return _reader.GetDateTime(i);
        }

        public decimal GetDecimal(int i) {
            return _reader.GetDecimal(i);
        }

        public double GetDouble(int i) {
            return _reader.GetDouble(i);
        }

        public Type GetFieldType(int i) {
            return _reader.GetFieldType(i);
        }

        public float GetFloat(int i) {
            return _reader.GetFloat(i);
        }

        public Guid GetGuid(int i) {
            return _reader.GetGuid(i);
        }

        public short GetInt16(int i) {
            return _reader.GetInt16(i);
        }

        public int GetInt32(int i) {
            return _reader.GetInt32(i);
        }

        public long GetInt64(int i) {
            return _reader.GetInt64(i);
        }

        public string GetName(int i) {
            return _reader.GetName(i);
        }

        public int GetOrdinal(string name) {
            return _reader.GetOrdinal(name);
        }

        public string GetString(int i) {
            return _reader.GetName(i);
        }

        public bool IsDBNull(int i) {
            return _reader.IsDBNull(i);
        }

        public bool NextResult() {
            return _reader.NextResult();
        }

        public bool Read() {
            return _reader.Read();
        }

        public void Dispose() {
            if (_reader != null) _reader.Dispose();
            _reader = null;
        }
    }


    internal class FseWsDataReader {

        private WstDataReader _reader;

        internal FseWsDataReader(WstDataReader reader) {
            _reader = reader;
        }

        public bool GetBoolean(int i)
        {
            return _reader.GetBoolean(i);
        }

        public string GetDataTypeName(int i)
        {
            return _reader.GetDataTypeName(i);
        }

        public DateTime GetDateTime(int i)
        {
            return _reader.GetDateTime(i);
        }

        public decimal GetDecimal(int i)
        {
            return _reader.GetDecimal(i);
        }

        public double GetDouble(int i)
        {
            return _reader.GetDouble(i);
        }

        public Type GetFieldType(int i)
        {
            return _reader.GetFieldType(i);
        }

        public float GetFloat(int i)
        {
            return _reader.GetFloat(i);
        }

        public Guid GetGuid(int i)
        {
            return _reader.GetGuid(i);
        }

        public short GetInt16(int i)
        {
            return _reader.GetInt16(i);
        }

        public int GetInt32(int i)
        {
            return _reader.GetInt32(i);
        }

        public long GetInt64(int i)
        {
            return _reader.GetInt64(i);
        }

        public string GetName(int i)
        {
            return _reader.GetName(i);
        }

        public int GetOrdinal(string name)
        {
            return _reader.GetOrdinal(name);
        }

        public string GetString(int i)
        {
            return _reader.GetName(i);
        }

        public bool IsDBNull(int i)
        {
            return _reader.IsDBNull(i);
        }

        public bool NextResult()
        {
            return _reader.NextResult();
        }

        public bool Read()
        {
            return _reader.Read();
        }

        public void Dispose()
        {
            if (_reader != null) _reader.Close();
            _reader = null;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\marketplace\fse\FseCommand.cs ===
//
// FseCommand.cs
// Copyright (c) Microsoft Corporation. All Rights Reserved.
//

using System;
using System.Data;
using System.Text;
using System.Web;
using System.Xml;
using System.Collections;
using System.Reflection;
using System.IO;

using xonline.common.config;
using xonline.common.service;
using xonline.common.sql.sqlclient;
using xonline.common.sql.webstore;
using xonline.common.mgmt;

using Microsoft.Webstore.WstClient;

namespace xonline.common.fse
{
    internal interface FseCommand : IDisposable {
        FseDataReader Execute();
        XmlReader ExecuteXml();
        Byte[] ExecuteBytes();
        void AddParameter(FseValue value);
        string ProcedureName { get; set; }
        HResult ReturnValue { get; }
    }

    internal class FseBinCommand : FseCommandBase, FseCommand
    {
        private static Hashtable commandCache = new Hashtable();

        private string className;
        private Hashtable parameters = new Hashtable();
        private HResult hr;
        private FsePlugin _cmd;

        internal FseBinCommand() {}

        private void AddParameter(string name, object value)
        {
            parameters[name] = value;
        }

        protected override void AddNullParameter(string name)
        {
            // Null parameters will not be added
        }

        protected override void AddParameter(string name, int value)
        {
            AddParameter(name, value);
        }

        protected override void AddParameter(string name, long value)
        {
            AddParameter(name, value);
        }

        protected override void AddParameter(string name, Guid value)
        {
            AddParameter(name, value);
        }

        protected override void AddParameter(string name, string value)
        {
            AddParameter(name, value);
        }

        protected override void AddParameter(string name, object value, DbType dbType)
        {
            AddParameter(name, value);
        }

        public HResult ReturnValue
        {
            get { return hr; }
        }

        /// <summary>
        /// Not implemented for bin commands
        /// </summary>
        /// <returns></returns>
        public FseDataReader Execute()
        {
            throw new NotImplementedException();
        }

        /// <summary>
        /// Not implemented for bin commands
        /// </summary>
        /// <returns></returns>
        public XmlReader ExecuteXml()
        {
            throw new NotImplementedException();
        }

        /// <summary>
        /// Execute the FsePlugin and return the byte arrray
        /// </summary>
        /// <returns></returns>
        public byte[] ExecuteBytes()
        {
            RetrieveFseCommand();
            // Try and execute the FsePlugin
            //
            // If the exception is a FileLoadException, this can mean that a dll underneath 
            // has changed. If this is the case, try and re construct the class and
            // re execute it
            //
            // Otherwise, process the exception normally

            try
            {                
                return _cmd.Execute(parameters, ref hr);
            }
            catch (FileLoadException fle)
            {
                try
                {
                    // Log the instance of this occurring
                    Xom.Log(XomAreaName.fseLog, fle.ToString());
                    
                    // Force the class to be reconstructed
                    commandCache[this.className] = null;
                    RetrieveFseCommand();

                    // Execute the command
                    return _cmd.Execute(parameters, ref hr);
                }
                catch (Exception e)
                {
                    throw new ApplicationException(
                        HResult.XONLINE_E_FSE_BIN_ERROR_EXECUTING,
                        "Error executing class '" + this.className + "'", e
                    );
                }
            }
            catch (Exception e)
            {
                throw new ApplicationException(
                    HResult.XONLINE_E_FSE_BIN_ERROR_EXECUTING,
                    "Error executing class '" + this.className + "'", e
                );
            }
        }

        /// <summary>
        /// Sets the _cmd by either retrieving it from the cache or reconstructing it
        /// </summary>
        private void RetrieveFseCommand()
        {
            Assembly asm;
            object ob;
            string key = this.className;

            // Try and retrieve from the command cache
            _cmd = (FsePlugin)commandCache[key];

            // If it is null, construct a new one
            if (_cmd == null)
            {
                lock (commandCache)
                {
                    _cmd = (FsePlugin)commandCache[key];
                    if (_cmd == null)
                    {
                        // create the plugin class
                        asm = Assembly.GetCallingAssembly();
                        ob = asm.CreateInstance(this.className, false);
                        if (ob == null)
                        {
                            throw new ApplicationException(HResult.XONLINE_E_FSE_BIN_ERROR_CONSTRUCTING, "Type " + this.className + " not found in assembly " + asm.GetName() + "!");
                        }
                        if (!(ob is FsePlugin))
                        {
                            throw new ApplicationException(HResult.XONLINE_E_FSE_BIN_ERROR_CONSTRUCTING, "Type " + this.className + " is not of type FsePlugin!");
                        }
                        _cmd = (FsePlugin)ob;
                        commandCache[key] = _cmd;
                    }
                }
            }
        }

        public string ProcedureName
        {
            get { return className; }
            set { className = value; }
        }

        public void Dispose()
        {
 
        }
    }

    internal class FseSqlCommand : FseCommandBase, FseCommand {

        private SqlClient _cmd;

        internal FseSqlCommand(
            string interfaceName,
            bool   isVirtual
        ) {
            try {
                _cmd = new SqlClient(interfaceName, isVirtual);
            }

            catch (Exception e)
            {
                throw new DatabaseException(
                    HResult.XONLINE_E_FSE_DATABASE_CONNECT_ERROR,
                    "Error connection to database '" + interfaceName + "'", e
                );
            }

        }

        protected override void AddNullParameter(string name) {
            _cmd.AddParameterObject(name, DBNull.Value);
        }

        protected override void AddParameter(string name, int value) {
            _cmd.AddParameter(name, value);
        }

        protected override void AddParameter(string name, long value) {
            _cmd.AddParameter(name, value);
        }

        protected override void AddParameter(string name, Guid value) {
            _cmd.AddParameter(name, value);
        }

        protected override void AddParameter(string name, string value) {
            _cmd.AddParameter(name, value);
        }

        protected override void AddParameter(string name, object value, DbType dbType) {
            _cmd.AddParameter(name, value, dbType);
        }

        public HResult ReturnValue {
            get
            {
                HResult hr;
                
                try 
                {
                    hr = (uint) _cmd.GetIntParameter(RETVAL);
                }
                catch
                {
                    hr = HResult.S_OK;
                }

                return hr;
            }
        }

        public FseDataReader Execute()
        {
            try {
                _cmd.AddParameter(ParameterDirection.ReturnValue, RETVAL, (int) 0);
                return (FseDataReader) new FseSqlDataReader(_cmd.Execute());
            }

            catch (Exception e) {
                throw new DatabaseException(
                    HResult.XONLINE_E_FSE_DATABASE_EXECUTE_ERROR,
                    "Error executing stored procedure '" + ProcedureName + "'", e
                );
            }
        }

        public XmlReader ExecuteXml()
        {
            try {
                _cmd.AddParameter(ParameterDirection.ReturnValue, RETVAL, (int) 0);
                return _cmd.ExecuteXmlReader();
            }

            catch (Exception e) {
                throw new DatabaseException(
                    HResult.XONLINE_E_FSE_DATABASE_EXECUTE_ERROR,
                    "Error executing stored procedure '" + ProcedureName + "'", e
                );
            }
        }

        public byte[] ExecuteBytes()
        {
            throw new NotImplementedException();
        }

        public string ProcedureName
        {
            get { return _cmd.StoredProc;  }
            set { _cmd.StoredProc = value; }
        }

        public void Dispose() {
            if (_cmd != null) _cmd.Dispose();
            _cmd = null;
        }
    }


    internal class FseWsCommand : FseCommandBase, FseCommand {

        private WSClient _cmd;

        internal FseWsCommand(
            string applicationName,
            WstFailoverMode failoverMode
        ) {
            try
            {
                _cmd = new WSClient(ConfigUtil.GetWebstoreApp(applicationName), failoverMode);
                _cmd.PartitionType = WstPartitionType.Physical;
                _cmd.Partition = WstContext.PartitionAny;
            }

            catch (Exception e) {
                throw new DatabaseException(
                    HResult.XONLINE_E_FSE_DATABASE_CONNECT_ERROR,
                    "Error connection to database '" + applicationName + "'", e
                );
            }
        }

        public override void AddParameter(FseValue value)
        {
            FseParam param = value.Param;

            if (param.IsWebstore)
            {
                _cmd.SetHashVal(long.Parse(value.Values[0]));
                _cmd.PartitionType = WstPartitionType.Logical;
            }

            base.AddParameter(value);
        }

        protected override void AddNullParameter(string name) {
            _cmd.AddParameterObject(name, DBNull.Value);
        }

        protected override void AddParameter(string name, int value)  {
            _cmd.AddParameter(name, value);
        }

        protected override void AddParameter(string name, long value)  {
            _cmd.AddParameter(name, value);
        }

        protected override void AddParameter(string name, Guid value) {
            _cmd.AddParameter(name, value);
        }

        protected override void AddParameter(string name, string value) {
            _cmd.AddParameter(name, value);
        }

        protected override void AddParameter(string name, object value, DbType dbType) {
            _cmd.AddParameter(name, value, dbType);
        }

        public HResult ReturnValue
        {
            get
            {
                HResult hr;

                try
                {
                    hr = (uint) _cmd.GetIntParameter(RETVAL);
                }
                catch
                {
                    hr = HResult.S_OK;
                }

                return hr;
            }
        }

        public FseDataReader Execute() 
        {
            try {
                _cmd.AddParameter(ParamType.RETVAL, RETVAL, (int) 0);
                return (FseDataReader)new FseWsDataReader(_cmd.Execute());
            }

            catch (Exception e) {
                throw new DatabaseException(
                    HResult.XONLINE_E_FSE_DATABASE_EXECUTE_ERROR,
                    "Error executing stored procedure '" + ProcedureName + "'", e
                );
            }
        }

        public XmlReader ExecuteXml()
        {
            XmlReaderSettings settings = new XmlReaderSettings();
            settings.ConformanceLevel = ConformanceLevel.Auto;
            settings.IgnoreWhitespace = true;
            settings.CloseInput = true;

            try {
                _cmd.AddParameter(ParamType.RETVAL, RETVAL, (int) 0);
                return XmlReader.Create((XmlReader) _cmd.ExecuteXmlReader(), settings);
            }

            catch (Exception e) {
                throw new DatabaseException(
                    HResult.XONLINE_E_FSE_DATABASE_EXECUTE_ERROR,
                    "Error executing stored procedure '" + ProcedureName + "'", e
                );
            }
        }

        public byte[] ExecuteBytes()
        {
            throw new NotImplementedException();
        }

        public string ProcedureName
        {
            get { return _cmd.StoredProc;  }
            set { _cmd.StoredProc = value; }
        }

        public void Dispose() {
            if (_cmd != null) _cmd.Dispose();
            _cmd = null;
        }
    }


    internal abstract class FseCommandBase {

        internal const string RETVAL = "@fseretval";

        public virtual void AddParameter(FseValue value)
        {
            FseParam param = value.Param;

            if (param.IsArray)
            {
                // arrays are encoded as xml using this format
                // <a b="value"><a b="value"><a b="value"> ...

                StringBuilder stringBuilder = new StringBuilder();

                foreach (string s in value.Values)
                {
                    if (s.ToLower() != "null")
                    {
                        string t = FseUtil.UnescapeString(s);
                        if (value.Param.Type == typeof(String)) t = HttpUtility.HtmlEncode(t);
                        stringBuilder.Append("<a b=\"" + t + "\" />");
                    }
                }

                // if all the values were null, then the string
                // is empty and we pass fown a  null  parameter

                if (stringBuilder.Length == 0)
                    AddNullParameter(param.NameInSproc);
                else
                {
                    AddParameter(value.Param.NameInSproc, stringBuilder.ToString());
                }
            }

            else
            {
                if (value.Values[0].ToLower() == "null")
                    AddNullParameter(param.NameInSproc);
                else if (param.Type == typeof(string))
                    AddParameter(param.NameInSproc, param.Convert(FseUtil.UnescapeString(value.Values[0])), param.DbType);
                else
                {
                    AddParameter(param.NameInSproc, param.Convert(value.Values[0]), param.DbType);
                }
            }
        }

        protected abstract void AddNullParameter(
            string name
        );

        protected abstract void AddParameter(
            string name, int value
        );

        protected abstract void AddParameter(
            string name, long value
        );

        protected abstract void AddParameter(
            string name, Guid value
        );

        protected abstract void AddParameter(
            string name, string value
        );

        protected abstract void AddParameter(
            string name, object value, DbType dbType
        );
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\marketplace\catalog\TableOperations.cs ===
﻿// Mix information can be found here:
// General - http://xblwiki/default.aspx/XboxLive/MIX%20-%20MetaData%20Ingestion%20for%20Xbox.html
// Error handling - http://xblwiki/default.aspx/XboxLive/MixErrorHandling.html

using System;
using System.Collections.Generic;
using System.Data.SqlTypes;
using System.Linq;
using xonline.common.service;

namespace xonline.common.marketplace.catalog
{
    static public class TableOperations
    {

        #region Saving Entities and Triggering Fast Catalog Watcher

        /// <summary>
        /// Invokes the Entity Framework Save
        /// </summary>
        /// <param name="catalog"></param>
        static private void Save(this RawCatalogDBEntities catalog)
        {
            catalog.SaveChanges();
        }

        /// <summary>
        /// Invokes a call to Trigger the Fast Catalog Watcher for a Product
        /// and Saves the Entity
        /// </summary>
        /// <param name="catalog"></param>
        /// <param name="catalogMedia"></param>
        static public void Save(this RawCatalogDBEntities catalog, Media catalogMedia)
        {
            catalog.TriggerCatalogWatcherMediaForParentAndChildren(catalogMedia);
            catalog.Save();
        }

        /// <summary>
        /// Invokes a call to Trigger the Fast Catalog Watcher for an Offer
        /// and Saves the Entity
        /// </summary>
        /// <param name="catalog"></param>
        /// <param name="catalogMedia"></param>
        static public void Save(this RawCatalogDBEntities catalog, Offer catalogOffer)
        {
            catalog.TriggerCatalogWatcherOffers(catalogOffer);
            catalog.Save();
        }

        /// <summary>
        /// Triggers Catalog Watcher by updating the Media table row
        /// Catalog Watcher detects when a new FAST document needs to be generated
        /// </summary>
        /// <param name="catalog"></param>
        /// <param name="catalogMedia">Null value will be ignored</param>
        static private void TriggerCatalogWatcher(this RawCatalogDBEntities catalog, Media catalogMedia)
        {
            // Trigger FAST update for this product
            if (catalogMedia != null)
            {
                catalogMedia.modifiedDate = DateTime.UtcNow;
            }
        }

        /// <summary>
        /// Triggers Catalog Watcher for Offer Products
        /// </summary>
        /// <param name="catalog"></param>
        /// <param name="catalogOffer"></param>
        static private void TriggerCatalogWatcherOffers(this RawCatalogDBEntities catalog, Offer catalogOffer)
        {
            if (catalogOffer.Media == null && !catalogOffer.MediaReference.IsLoaded)
            {
                catalogOffer.MediaReference.Load();
            }

            //Trigger FAST update for the offer's product
            if (catalogOffer.Media != null)
            {
                catalog.TriggerCatalogWatcher(catalogOffer.Media);
            
                // Trigger FAST update for any possible parent products
                catalog.TriggerCatalogWatcherParentProducts(catalogOffer.Media);
            }
        }

        /// <summary>
        /// Triggers Catalog Watcher for Products
        /// and their child products that inherit images or ratings
        /// </summary>
        /// <param name="catalog"></param>
        /// <param name="catalogMedia"></param>
        static private void TriggerCatalogWatcherMediaForParentAndChildren(this RawCatalogDBEntities catalog, Media catalogMedia)
        {
            //Trigger FAST update for this product
            catalog.TriggerCatalogWatcher(catalogMedia);

            // Trigger FAST update for any possible parent products
            catalog.TriggerCatalogWatcherParentProducts(catalogMedia);

            // Trigger FAST update for any possible children products
            catalog.TriggerCatalogWatcherChildrenProducts(catalogMedia);

            // Triggering FAST for all Images and Children Products that Inherit this Image
            catalog.TriggerCatalogWatcherImage(catalogMedia);
        }
        
        /// <summary>
        /// Triggers Catalog Watcher for Child Products 
        /// Scenario Example:  Child Product Documents need to be regenerated to include Parent's latest sortTitles, Ratings, and BoxArt
        /// </summary>
        /// <param name="catalog"></param>
        /// <param name="catalogMedia"></param>
        static private void TriggerCatalogWatcherChildrenProducts(this RawCatalogDBEntities catalog, Media catalogMedia)
        {
            List<MediaRelationship> catalogMediaRelationships = new List<MediaRelationship>();

            // Add existing relationships from the catalog
            catalogMediaRelationships.AddRange(catalog.GetPrimitiveMediaRelationShipByMedia(catalogMedia.mediaId,
                (int)CatalogConstants.MediaRelationshipTypeEnum.MediaToAssociatedDownload));

            // Add new relationships 
            foreach (MediaRelationship newRelatedRelationship in catalogMedia.MediaRelationship)
            {
                if (newRelatedRelationship.MediaRelationshipType == null && !newRelatedRelationship.MediaRelationshipTypeReference.IsLoaded)
                {
                    newRelatedRelationship.MediaRelationshipTypeReference.Load();
                }

                if (newRelatedRelationship.MediaRelationshipType != null && 
                    newRelatedRelationship.MediaRelationshipType.mediaRelationshipTypeId == (int)CatalogConstants.MediaRelationshipTypeEnum.MediaToAssociatedDownload)
                {
                    catalogMediaRelationships.Add(newRelatedRelationship);
                }
            }

            foreach (MediaRelationship catalogMediaRelationship in catalogMediaRelationships)
            {
                try
                {
                    if (catalogMediaRelationship.Media1 == null && !catalogMediaRelationship.Media1Reference.IsLoaded)
                    {
                        catalogMediaRelationship.Media1Reference.Load();
                    }

                    if (catalogMediaRelationship.Media1 != null)
                    {
                        catalog.TriggerCatalogWatcher(catalogMediaRelationship.Media1); // Child Media
                    }
                }
                catch (InvalidOperationException)
                {
                    // Related Media media may not exist due to relationship having been deleted and yet to be saved to the catalog
                    // or
                    // GameContent does not exist in the catalog because this is not a GameContent Type
                }
                //Trigger FAST update on the child product that inherits Ratings

            }
        }
        
        /// <summary>
        /// Triggers Catalog Watcher for Parent Products 
        /// Scenario Example:  Parent Product Documents need to be regenerated to include new Children Products
        /// </summary>
        /// <param name="catalog"></param>
        /// <param name="catalogMedia"></param>
        static private void TriggerCatalogWatcherParentProducts(this RawCatalogDBEntities catalog, Media catalogMedia)
        {
            List<MediaRelationship> catalogMediaRelationships = new List<MediaRelationship>();
            
            // Add existing relationships from the catalog
            catalogMediaRelationships.AddRange(catalog.GetPrimitiveMediaRelationShip(catalogMedia.mediaId,
                (int)CatalogConstants.MediaRelationshipTypeEnum.MediaToAssociatedDownload));

            // Add new relationships 
            foreach (MediaRelationship newRelatedRelationship in catalogMedia.MediaRelationship1)
            {
                if (newRelatedRelationship.MediaRelationshipType == null && !newRelatedRelationship.MediaRelationshipTypeReference.IsLoaded)
                {
                    newRelatedRelationship.MediaRelationshipTypeReference.Load();
                }

                if (newRelatedRelationship.MediaRelationshipType != null && 
                    newRelatedRelationship.MediaRelationshipType.mediaRelationshipTypeId == (int)CatalogConstants.MediaRelationshipTypeEnum.MediaToAssociatedDownload)
                {
                    catalogMediaRelationships.Add(newRelatedRelationship); 
                } 
            }
            
            foreach (MediaRelationship catalogMediaRelationship in catalogMediaRelationships)
            {
                try
                {
                    if (catalogMediaRelationship.Media == null && !catalogMediaRelationship.MediaReference.IsLoaded)
                    {
                        catalogMediaRelationship.MediaReference.Load();
                    }

                    if (catalogMediaRelationship.Media != null)
                    {
                        catalog.TriggerCatalogWatcher(catalogMediaRelationship.Media); // Parent Media
                    }
                }
                catch (InvalidOperationException)
                {
                    // Related Media media may not exist due to relationship having been deleted and yet to be saved to the catalog
                    // or
                    // GameContent does not exist in the catalog because this is not a GameContent Type
                }
                //Trigger FAST update on the child product that inherits Ratings

            }
        }
        
        /// <summary>
        /// Triggers Catalog Watcher for Image Products and their related Products
        /// </summary>
        /// <param name="catalog"></param>
        /// <param name="catalogMedia"></param>
        static private void TriggerCatalogWatcherImage(this RawCatalogDBEntities catalog, Media catalogMedia)
        {
            // Checking if this Media is an Image
            try
            {
                if (catalogMedia.Image == null && !catalogMedia.ImageReference.IsLoaded)
                {
                    catalogMedia.ImageReference.Load();
                }
            }
            catch (InvalidOperationException)
            {
                // Not an Image
                return;
            }

            // Foreach Parent Product
            foreach (MediaRelationship catalogParentMediaRelationship in catalogMedia.MediaRelationship1)
            {
                if (catalogParentMediaRelationship.Media == null && !catalogParentMediaRelationship.MediaReference.IsLoaded)
                {
                    catalogParentMediaRelationship.MediaReference.Load();
                }
                if (catalogParentMediaRelationship.MediaRelationshipType == null && !catalogParentMediaRelationship.MediaRelationshipTypeReference.IsLoaded)
                {
                    catalogParentMediaRelationship.MediaRelationshipTypeReference.Load();
                }

                // Triggering FAST for all Products Related to the Image
                if (catalogParentMediaRelationship.Media != null)
                {
                    catalog.TriggerCatalogWatcher(catalogParentMediaRelationship.Media);
                }

                // Check if this Image has a MediaToBoxArt relationship to any products
                int relationshipTypeId = (int)CatalogConstants.MediaRelationshipTypeEnum.MediaToBoxArt;
                if (catalogParentMediaRelationship.MediaRelationshipType != null && 
                    catalogParentMediaRelationship.MediaRelationshipType.mediaRelationshipTypeId == relationshipTypeId)
                {
                    // Update Children products so they can update their inherited images
                    catalog.TriggerCatalogWatcherChildrenProducts(catalogParentMediaRelationship.Media);
                }
            }

        }

        /// <summary>
        /// Triggers Catalog Watcher for Child Products that inherit images
        /// </summary>
        /// <param name="catalog"></param>
        /// <param name="catalogMedia"></param>
        static private void TriggerCatalogWatcherGameContentInheritImages(this RawCatalogDBEntities catalog, Media catalogParentMedia, int relationshipTypeId)
        {
            // If related gamecontent inherit Ratings from this Parent Product
            List<MediaRelationship> catalogChildMediaRelationships = new List<MediaRelationship>(catalog.GetPrimitiveMediaRelationShipByMedia(
                catalogParentMedia.mediaId, (int)CatalogConstants.MediaRelationshipTypeEnum.MediaToAssociatedDownload));

            foreach (MediaRelationship catalogChildMediaRelationship in catalogChildMediaRelationships)
            {
                if (catalogChildMediaRelationship.Media1 == null && !catalogChildMediaRelationship.Media1Reference.IsLoaded)
                {
                    catalogChildMediaRelationship.Media1Reference.Load();
                }

                if (catalogChildMediaRelationship.Media1 != null) // To check that the relationship hasn't been deleted during this save
                {
                    Media catalogChildMedia = catalogChildMediaRelationship.Media1;

                    // scenarios are only for GameContent types
                    try
                    {
                        if (catalogChildMedia.GameContent == null && !catalogChildMedia.GameContentReference.IsLoaded)
                        {
                            catalogChildMedia.GameContentReference.Load();
                        }
                    }
                    catch (InvalidOperationException)
                    {
                        // Not an GameContent                    
                    }

                    // GameContent is loaded, check if this is a GameContent type
                    if (catalogChildMedia.GameContent != null)
                    {
                        // Get a list of relationships
                        MediaRelationship[] catalogRelationships = catalogChildMedia.MediaRelationship.ToArray();

                        int catalogMediaCount = 0;
                        foreach (MediaRelationship catalogRelationship in catalogRelationships)
                        {
                            if (catalogRelationship.MediaRelationshipType == null && !catalogRelationship.MediaRelationshipTypeReference.IsLoaded)
                            {
                                catalogRelationship.MediaRelationshipTypeReference.Load();
                            }

                            if (catalogRelationship.MediaRelationshipType.mediaRelationshipTypeId == relationshipTypeId)
                            {
                                catalogMediaCount++;
                            }

                        }

                        // Image will be inherited if none exists
                        if (catalogMediaCount == 0)
                        {
                            //Trigger FAST update on an child product that needs to inherit images
                            catalog.TriggerCatalogWatcher(catalogChildMedia);
                        }
                    }
                }
            }
        }

        #endregion

        #region Validation methods
        static private void ThrowIfNull(object o, string errorMessage)
        {
            if (o == null)
            {
                throw new XRLExceptionWithoutEvent(HResult.XONLINE_E_MIX_ARGUMENT_NULL_INTERNAL, errorMessage, false);
            }
        }
        #endregion

        #region Table Get methods

        /// <summary>
        /// Gets the App for a given appMediaId
        /// </summary>
        /// <param name="catalog"></param>
        /// <param name="appMediaId"></param>
        /// <returns></returns>
        static public App GetPrimitiveApp(this RawCatalogDBEntities catalog, Guid appMediaId)
        {
            return catalog.App.Where(a => a.appMediaId == appMediaId).FirstOrDefault();
        }

        /// <summary>
        /// Gets the AppLocale items for a given appMediaId
        /// </summary>
        /// <param name="catalog"></param>
        /// <param name="appMediaId"></param>
        /// <returns></returns>
        static public AppLocale[] GetPrimitiveAppLocales(this RawCatalogDBEntities catalog, Guid appMediaId)
        {
            return catalog.AppLocale.Where(al => al.App.appMediaId == appMediaId).ToArray();
        }

        /// <summary>
        /// Gets the AppLocale for a given appMediaId and locale
        /// </summary>
        /// <param name="catalog"></param>
        /// <param name="mediaId"></param>
        /// <param name="mediaLocale"></param>
        /// <returns></returns>
        static public AppLocale GetPrimitiveAppLocale(this RawCatalogDBEntities catalog, Guid appMediaId, Locale mediaLocale)
        {
            return catalog.AppLocale.Where(al => al.App.appMediaId == appMediaId 
                                            && al.Locale.lcid == mediaLocale.lcid).FirstOrDefault();
        }

        /// <summary>
        /// Gets the AppType for a given appTypeId
        /// </summary>
        /// <param name="catalog"></param>
        /// <param name="appTypeId"></param>
        /// <returns></returns>
        static public AppType GetPrimitiveAppType(this RawCatalogDBEntities catalog, int appTypeId)
        {
            return catalog.AppType.Where(at => at.appTypeId == appTypeId).FirstOrDefault();
        }

        /// <summary>
        /// Gets the AppAppType items for a given appMediaId
        /// </summary>
        /// <param name="catalog"></param>
        /// <param name="appMediaId"></param>
        /// <returns></returns>
        static public AppAppType[] GetPrimitiveAppAppTypes(this RawCatalogDBEntities catalog, Guid appMediaId)
        {
            return catalog.AppAppType.Where(aat => aat.App.appMediaId == appMediaId).ToArray();
        }

        /// <summary>
        /// Gets the AppAppType for a given media and appType
        /// </summary>
        /// <param name="catalog"></param>
        /// <param name="appMediaId"></param>
        /// <param name="appTypeId"></param>
        /// <returns></returns>
        static public AppAppType GetPrimitiveAppAppType(this RawCatalogDBEntities catalog, Guid appMediaId, int appTypeId)
        {
            return catalog.AppAppType.Where(aat => aat.App.appMediaId == appMediaId
                                            && aat.AppType.appTypeId == appTypeId).FirstOrDefault();
        }

        /// <summary>
        /// Gets the AppInstance for a given Guid
        /// </summary>
        /// <param name="catalog"></param>
        /// <param name="appInstanceId"></param>
        /// <returns></returns>
        static public AppInstance GetPrimitiveAppInstance(this RawCatalogDBEntities catalog, Guid appInstanceId)
        {
            return catalog.AppInstance.Where(ai => ai.appInstanceId == appInstanceId).FirstOrDefault();
        }

        /// <summary>
        /// Gets the AppInstanceEncryptedKey for a given Guid
        /// </summary>
        /// <param name="catalog"></param>
        /// <param name="appInstanceId"></param>
        /// <returns></returns>
        static public AppInstanceEncryptedKey GetPrimitiveAppInstanceEncryptedKey(this RawCatalogDBEntities catalog, Guid appInstanceId)
        {
            return catalog.AppInstanceEncryptedKey.Where(aiek => aiek.AppInstance.appInstanceId == appInstanceId).FirstOrDefault();
        }

        /// <summary>
        /// Gets the AppInstanceFile items for a given AppInstance
        /// </summary>
        /// <param name="catalog"></param>
        /// <param name="appInstanceId"></param>
        /// <returns></returns>
        static public AppInstanceFile[] GetPrimitiveAppInstanceFiles(this RawCatalogDBEntities catalog, Guid appInstanceId)
        {
            return catalog.AppInstanceFile.Where(aif => aif.AppInstance.appInstanceId == appInstanceId).ToArray();
        }

        /// <summary>
        /// Gets the AppInstanceFile for a given AppInstance and AppInstanceFile
        /// </summary>
        /// <param name="catalog"></param>
        /// <param name="appInstanceId"></param>
        /// <param name="appInstanceFileId"></param>
        /// <returns></returns>
        static public AppInstanceFile GetPrimitiveAppInstanceFile(this RawCatalogDBEntities catalog, Guid appInstanceId, Guid appInstanceFileId)
        {
            return catalog.AppInstanceFile.Where(aif => aif.AppInstance.appInstanceId == appInstanceId 
                                                        && aif.appInstanceFileId == appInstanceFileId).FirstOrDefault();
        }

        /// <summary>
        /// Gets the CapabilityType for a given capabilityTypeId, dataTypeId, and unitTypeId
        /// </summary>
        /// <param name="catalog"></param>
        /// <param name="capabilityTypeId"></param>
        /// <returns></returns>
        static public CapabilityType GetPrimitiveCapabilityType(this RawCatalogDBEntities catalog, int capabilityTypeId)
        {
            return catalog.CapabilityType.Where(ct => ct.capabilityTypeId == capabilityTypeId).FirstOrDefault();
        }

        /// <summary>
        /// Gets the CapabilityType for a given capabilityTypeId, dataTypeId, and unitTypeId
        /// </summary>
        /// <param name="catalog"></param>
        /// <param name="capabilityTypeName"></param>
        /// <returns></returns>
        static public CapabilityType GetPrimitiveCapabilityType(this RawCatalogDBEntities catalog, string capabilityTypeName)
        {
            return catalog.CapabilityType.Where(ct => ct.internalName == capabilityTypeName).FirstOrDefault();
        }


        /// <summary>
        /// Gets the GameCapabilityCountry items for a given media
        /// </summary>
        /// <param name="catalog"></param>
        /// <param name="mediaId"></param>
        /// <returns></returns>
        static public GameCapabilityCountry[] GetPrimitiveGameCapabilityCountries(this RawCatalogDBEntities catalog, Guid mediaId)
        {
            return catalog.GameCapabilityCountry.Where(gcc => gcc.gameMediaId == mediaId).ToArray();
        }

        /// <summary>
        /// Gets the GameCapabilityCountryMap for a given media and country
        /// NOTE: Country1 == GameCapabilityCountryMap.countryCodeMap catalog column
        /// </summary>
        /// <param name="catalog"></param>
        /// <param name="mediaId"></param>
        /// <param name="countryCode"></param>
        /// <returns></returns>
        static public GameCapabilityCountryMap[] GetPrimitiveGameCapabilityCountryMaps(this RawCatalogDBEntities catalog, Guid mediaId, string countryCode)
        {
            return catalog.GameCapabilityCountryMap.Where(gccm => gccm.gameMediaId == mediaId && gccm.Country1.countryCode == countryCode).ToArray();
        }


        /// <summary>
        /// Gets the GameConsumable for given Id
        /// </summary>
        /// <param name="catalog"></param>
        /// <param name="mediaId"></param>
        /// <returns></returns>
        static public GameConsumable GetPrimitiveGameConsumable(this RawCatalogDBEntities catalog, Guid mediaId)
        {
            return catalog.GameConsumable.Where(gc => gc.gameAssetMediaId == mediaId).FirstOrDefault();
        }

        /// <summary>
        /// Gets the GameContentAvatarItem for given Id
        /// </summary>
        /// <param name="catalog"></param>
        /// <param name="mediaId"></param>
        /// <returns></returns>
        static public GameContentAvatarItem GetPrimitiveGameContentAvatarItem(this RawCatalogDBEntities catalog, Guid mediaId)
        {
            return catalog.GameContentAvatarItem.Where(gcai => gcai.gameContentAvatarItemMediaId == mediaId).FirstOrDefault();
        }

        /// <summary>
        /// Gets the GameContentInstance for given InstanceId
        /// </summary>
        /// <param name="catalog"></param>
        /// <param name="mediaInstanceId"></param>
        /// <returns></returns>
        static public GameContentInstance GetPrimitiveGameContentInstance(this RawCatalogDBEntities catalog, Guid mediaInstanceId)
        {
            return catalog.GameContentInstance.Where(gci => gci