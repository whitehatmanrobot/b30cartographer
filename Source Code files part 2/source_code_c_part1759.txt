 {
            dwTotal += *pdwData;
            dwExecute += *pdwData;
            bCounter = TRUE;
        }
    }

    if (pCounter = FindCounter (pObj, ExecuteIndex3)) {
        pdwData = (DWORD *) CounterData (pInst, pCounter);
        if (pdwData) {
            dwTotal += *pdwData;
            dwExecute += *pdwData;
            bCounter = TRUE;
        }
    }

    if (pCounter = FindCounter (pObj, ExecuteIndex4)) {
        pdwData = (DWORD *) CounterData (pInst, pCounter);
        if (pdwData) {
            dwTotal += *pdwData;
            dwExecute += *pdwData;
            bCounter = TRUE;
        }
    }

    if (bCounter) {
        wsprintf (szTemp, TEXT("%ld KB"), dwExecute/1024);
        SetDlgItemText (hMemDlg, ExecuteID, szTemp);
    } else
        SetDlgItemText (hMemDlg, ExecuteID, NODATA);

    wsprintf (szTemp, TEXT("%ld KB"), dwTotal/1024);
    SetDlgItemText (hMemDlg, TotalID, szTemp);

}




//*********************************************************************
//
//      PaintMemDlgAddrData
//
//  Paint the memory dialog address space data.
//
void    PaintMemDlgAddrData(HWND            hMemDlg,
                            PPERF_INSTANCE  pInst,
                            PPERF_OBJECT    pObj)
{
    PaintAddressSpace (hMemDlg, pInst, pObj,
                       MEMORY_TOTALPRIVATE_COMMIT,
                       MEMORY_PRIVATE_NOACCESS,  PX_PROCESS_PRIVATE_NOACCESS,
                       MEMORY_PRIVATE_READONLY,  PX_PROCESS_PRIVATE_READONLY,
                       MEMORY_PRIVATE_READWRITE, PX_PROCESS_PRIVATE_READWRITE,
                       MEMORY_PRIVATE_WRITECOPY, PX_PROCESS_PRIVATE_WRITECOPY,
                       MEMORY_PRIVATE_EXECUTE,   PX_PROCESS_PRIVATE_EXECUTABLE,
                       PX_PROCESS_PRIVATE_EXE_READONLY,
                       PX_PROCESS_PRIVATE_EXE_READWRITE,
                       PX_PROCESS_PRIVATE_EXE_WRITECOPY);

    PaintAddressSpace (hMemDlg, pInst, pObj,
                       MEMORY_TOTALMAPPED_COMMIT,
                       MEMORY_MAPPED_NOACCESS,  PX_PROCESS_MAPPED_NOACCESS,
                       MEMORY_MAPPED_READONLY,  PX_PROCESS_MAPPED_READONLY,
                       MEMORY_MAPPED_READWRITE, PX_PROCESS_MAPPED_READWRITE,
                       MEMORY_MAPPED_WRITECOPY, PX_PROCESS_MAPPED_WRITECOPY,
                       MEMORY_MAPPED_EXECUTE,   PX_PROCESS_MAPPED_EXECUTABLE,
                       PX_PROCESS_MAPPED_EXE_READONLY,
                       PX_PROCESS_MAPPED_EXE_READWRITE,
                       PX_PROCESS_MAPPED_EXE_WRITECOPY);

    PaintAddressSpace (hMemDlg, pInst, pObj,
                       MEMORY_TOTALIMAGE_COMMIT,
                       MEMORY_IMAGE_NOACCESS,   PX_PROCESS_IMAGE_NOACCESS,
                       MEMORY_IMAGE_READONLY,   PX_PROCESS_IMAGE_READONLY,
                       MEMORY_IMAGE_READWRITE,  PX_PROCESS_IMAGE_READWRITE,
                       MEMORY_IMAGE_WRITECOPY,  PX_PROCESS_IMAGE_WRITECOPY,
                       MEMORY_IMAGE_EXECUTE,    PX_PROCESS_IMAGE_EXECUTABLE,
                       PX_PROCESS_IMAGE_EXE_READONLY,
                       PX_PROCESS_IMAGE_EXE_READWRITE,
                       PX_PROCESS_IMAGE_EXE_WRITECOPY);
}




//*********************************************************************
//
//      PaintMemDlgVMData
//
//  Paint the memory dialog Virtual Memory data.
//
void    PaintMemDlgVMData  (HWND            hMemDlg,
                            PPERF_INSTANCE  pInst,
                            PPERF_OBJECT    pObj)
{

    PutCounterDWKB (hMemDlg, MEMORY_WS,           pInst, pObj, PX_PROCESS_WORKING_SET);
    PutCounterDWKB (hMemDlg, MEMORY_PEAK_WS,      pInst, pObj, PX_PROCESS_PEAK_WS);
    PutCounterDWKB (hMemDlg, MEMORY_PRIVATE_PAGE, pInst, pObj, PX_PROCESS_PRIVATE_PAGE);
    PutCounterDWKB (hMemDlg, MEMORY_VSIZE,        pInst, pObj, PX_PROCESS_VIRTUAL_SIZE);
    PutCounterDWKB (hMemDlg, MEMORY_PEAK_VSIZE,   pInst, pObj, PX_PROCESS_PEAK_VS);
    PutCounterDWKB (hMemDlg, MEMORY_PFCOUNT,      pInst, pObj, PX_PROCESS_FAULT_COUNT);

}




//*********************************************************************
//
//      PaintPviewDlgMemoryData
//
//  Paint the memory data for pview dialog.
//
void    PaintPviewDlgMemoryData    (HWND            hPviewDlg,
                                    PPERF_INSTANCE  pInst,
                                    PPERF_OBJECT    pObj)
{
    PPERF_COUNTER   pCounter;
    TCHAR           str[20];
    DWORD           *pdwData;
    DWORD           dwData = 0;
    BOOL            bCounter = FALSE;


    if (pCounter = FindCounter (pObj, PX_PROCESS_PRIVATE_NOACCESS)) {
        pdwData = (DWORD *) CounterData (pInst, pCounter);
        if (pdwData) {
            dwData += *pdwData;
            bCounter = TRUE;
        }
    }

    if (pCounter = FindCounter (pObj, PX_PROCESS_PRIVATE_READONLY)) {
        pdwData = (DWORD *) CounterData (pInst, pCounter);
        if (pdwData) {
            dwData += *pdwData;
            bCounter = TRUE;
        }
    }

    if (pCounter = FindCounter (pObj, PX_PROCESS_PRIVATE_READWRITE)) {
        pdwData = (DWORD *) CounterData (pInst, pCounter);
        if (pdwData) {
            dwData += *pdwData;
            bCounter = TRUE;
        }
    }

    if (pCounter = FindCounter (pObj, PX_PROCESS_PRIVATE_WRITECOPY)) {
        pdwData = (DWORD *) CounterData (pInst, pCounter);
        if (pdwData) {
            dwData += *pdwData;
            bCounter = TRUE;
        }
    }

    if (pCounter = FindCounter (pObj, PX_PROCESS_PRIVATE_EXECUTABLE)) {
        pdwData = (DWORD *) CounterData (pInst, pCounter);
        if (pdwData) {
            dwData += *pdwData;
            bCounter = TRUE;
        }
    }

    if (pCounter = FindCounter (pObj, PX_PROCESS_PRIVATE_EXE_READONLY)) {
        pdwData = (DWORD *) CounterData (pInst, pCounter);
        if (pdwData) {
            dwData += *pdwData;
            bCounter = TRUE;
        }
    }

    if (pCounter = FindCounter (pObj, PX_PROCESS_PRIVATE_EXE_READWRITE)) {
        pdwData = (DWORD *) CounterData (pInst, pCounter);
        if (pdwData) {
            dwData += *pdwData;
            bCounter = TRUE;
        }
    }

    if (pCounter = FindCounter (pObj, PX_PROCESS_PRIVATE_EXE_WRITECOPY)) {
        pdwData = (DWORD *) CounterData (pInst, pCounter);
        if (pdwData) {
            dwData += *pdwData;
            bCounter = TRUE;
        }
    }

    if (bCounter) {
        wsprintf (str, TEXT("%ld KB"), dwData/1024);
        SetDlgItemText (hPviewDlg, PVIEW_TOTALPRIVATE_COMMIT, str);
    } else
        SetDlgItemText (hPviewDlg, PVIEW_TOTALPRIVATE_COMMIT, NODATA);

}




//*********************************************************************
//
//      RefreshMemoryDlg
//
//  Refresh the memory detail dialog.
//
BOOL    RefreshMemoryDlg   (HWND            hMemDlg,
                            PPERF_INSTANCE  pProcessInstance,
                            PPERF_OBJECT    pProcessObject,
                            PPERF_OBJECT    pAddressObject,
                            PPERF_OBJECT    pImageObject)
{
    DWORD           *pProcessID1;
    DWORD           *pProcessID2;
    PPERF_COUNTER   pCounter1;
    PPERF_COUNTER   pCounter2;
    PPERF_INSTANCE  pAddressInstance;
    HWND            hImageList;
    TCHAR           szTemp[40];
    BOOL            bStat = FALSE;
    INT             InstIndex = 0;


    if ((pCounter1 = FindCounter (pProcessObject, PX_PROCESS_ID)) &&
        (pCounter2 = FindCounter (pAddressObject, PX_PROCESS_ID))) {
        pProcessID1 = (DWORD *) CounterData (pProcessInstance, pCounter1);
        if (pProcessID1) {
            wsprintf (szTemp, TEXT("%s (%#x)"), InstanceName (pProcessInstance), *pProcessID1);
            SetDlgItemText (hMemDlg, MEMORY_PROCESS_ID, szTemp);

            pAddressInstance = FirstInstance (pAddressObject);

            while (pAddressInstance && InstIndex < pAddressObject->NumInstances) {
                pProcessID2 = (DWORD *) CounterData (pAddressInstance, pCounter2);
                if (pProcessID2) {
                    if (*pProcessID1 == *pProcessID2) {
                        PaintMemDlgAddrData (hMemDlg, pAddressInstance, pAddressObject);
                        PaintMemDlgVMData (hMemDlg, pProcessInstance, pProcessObject);
    
                        hImageList = GetDlgItem (hMemDlg, MEMORY_IMAGE);
                        RefreshMemoryDlgImageList (hImageList, InstIndex, pImageObject);
    
                        bStat = TRUE;
                        break;
                    }
                }

                pAddressInstance = NextInstance (pAddressInstance);
                InstIndex++;
            }
        }
    }

    return bStat;

}




//*********************************************************************
//
//      RefreshMemoryDlgImageList
//
//  Refresh the image list for memory dialog.
//
void    RefreshMemoryDlgImageList  (HWND            hImageList,
                                    DWORD           ParentIndex,
                                    PPERF_OBJECT    pImageObj)
{
    PPERF_INSTANCE  pImageInst;
    INT_PTR         ListIndex;
    INT_PTR             InstIndex = 0;


    ListIndex = SendMessage (hImageList, CB_ADDSTRING, 0, (DWORD_PTR)TEXT(" Total Commit"));
    SendMessage (hImageList, CB_SETITEMDATA, ListIndex, 0xFFFFFFFF);

    if (pImageObj) {
        pImageInst = FirstInstance (pImageObj);

        while (pImageInst && InstIndex < pImageObj->NumInstances) {
            if (ParentIndex == pImageInst->ParentObjectInstance) {
                ListIndex = SendMessage (hImageList,
                                         CB_ADDSTRING,
                                         0,
                                         (LPARAM)InstanceName(pImageInst));
                SendMessage (hImageList, CB_SETITEMDATA, ListIndex, InstIndex);
            }

            pImageInst = NextInstance (pImageInst);
            InstIndex++;
        }
    }
}




//*********************************************************************
//
//      RefreshMemoryDlgImage
//
//
void RefreshMemoryDlgImage (HWND            hMemDlg,
                            DWORD           dwIndex,
                            PPERF_OBJECT    pImageObject)
{
    PPERF_INSTANCE  pInst;

    if (pInst = FindInstanceN (pImageObject, dwIndex))
        PaintAddressSpace (hMemDlg, pInst, pImageObject,
                           MEMORY_TOTALIMAGE_COMMIT,
                           MEMORY_IMAGE_NOACCESS,   PX_IMAGE_NOACCESS,
                           MEMORY_IMAGE_READONLY,   PX_IMAGE_READONLY,
                           MEMORY_IMAGE_READWRITE,  PX_IMAGE_READWRITE,
                           MEMORY_IMAGE_WRITECOPY,  PX_IMAGE_WRITECOPY,
                           MEMORY_IMAGE_EXECUTE,    PX_IMAGE_EXECUTABLE,
                           PX_IMAGE_EXE_READONLY,
                           PX_IMAGE_EXE_READWRITE,
                           PX_IMAGE_EXE_WRITECOPY);
}


//*********************************************************************
//
//      RefreshPviewDlgMemoryData
//
//  Update the memory data for pview dialog.  This should be done
//  after the ghCostlyData is collected and is not refreshing.
//
void RefreshPviewDlgMemoryData (HWND            hPviewDlg,
                                PPERF_INSTANCE  pProcessInstance,
                                PPERF_OBJECT    pProcessObject,
                                PPERF_OBJECT    pAddressObject)
{
    DWORD           *pProcessID1;
    DWORD           *pProcessID2;
    PPERF_COUNTER   pCounter1;
    PPERF_COUNTER   pCounter2;
    PPERF_INSTANCE  pAddressInstance;
    INT             i = 0;


    if ((pCounter1 = FindCounter (pProcessObject, PX_PROCESS_ID)) &&
        (pCounter2 = FindCounter (pAddressObject, PX_PROCESS_ID))) {
        pProcessID1 = (DWORD *) CounterData (pProcessInstance, pCounter1);
        if (pProcessID1) {
            pAddressInstance = FirstInstance (pAddressObject);
    
            while (pAddressInstance && i < pAddressObject->NumInstances) {
                pProcessID2 = (DWORD *) CounterData (pAddressInstance, pCounter2);
                if (pProcessID2){
                    if (*pProcessID1 == *pProcessID2) {
                        PaintPviewDlgMemoryData (hPviewDlg, pAddressInstance, pAddressObject);
                        break;
                    }
        
                    pAddressInstance = NextInstance (pAddressInstance);
                    i++;
                }
            }
        }
    }
}




//*********************************************************************
//
//      RefreshPviewDlgThreadPC
//
//  Update the thread PC value.  This should be done after the ghCostlyData
//  is collected and is no refreshing.
//
void RefreshPviewDlgThreadPC   (HWND            hPviewDlg,
                                LPTSTR          szProcessName,
                                LPTSTR          szThreadName,
                                PPERF_OBJECT    pThreadDetailsObject,
                                PPERF_DATA      pCostlyData)
{
    PPERF_COUNTER   pCounter;
    PPERF_INSTANCE  pInstance;
    PPERF_INSTANCE  pParent;
    LPTSTR          szInstanceName;
    LPTSTR          szParentName;
    TCHAR           str[20];
    DWORD           *pdwData;
    INT             i = 0;


    if (pCounter = FindCounter (pThreadDetailsObject, PX_THREAD_PC)) {
        pInstance = FirstInstance (pThreadDetailsObject);

        while (pInstance && i < pThreadDetailsObject->NumInstances) {
            if (!(szInstanceName = InstanceName (pInstance)))
                // can't find name
                ;
            else if (lstrcmp (szThreadName, szInstanceName))
                // the thread name is different
                ;
            else if (!(pParent = FindInstanceParent (pInstance, pCostlyData)))
                // can't find parent
                ;
            else if (!(szParentName = InstanceName (pParent)))
                // can't find parent's name
                ;
            else if (!lstrcmp (szProcessName, szParentName)) {
                // Parent's name matches, this is the right one.
                //

                pdwData = CounterData (pInstance, pCounter);
                if (pdwData) {
                    wsprintf (str, TEXT("0x%08x"), *pdwData);
                    SetDlgItemText (hPviewDlg, PVIEW_THREAD_PC, str);
                }

                return;
            }

            pInstance = NextInstance (pInstance);
            i++;
        }
    }


    // We are here only because we can't find the data to display.
    //

    SetDlgItemText (hPviewDlg, PVIEW_THREAD_PC, NODATA);

}




//*********************************************************************
//
//      ProcessPriority
//
//  Returns the process priority dialog item id.
//
WORD    ProcessPriority    (PPERF_OBJECT    pObject,
                            PPERF_INSTANCE  pInstance)
{
    PPERF_COUNTER   pCounter;
    DWORD           *pdwData;


    if (pCounter = FindCounter (pObject, PX_PROCESS_PRIO)) {
        pdwData = (DWORD *) CounterData (pInstance, pCounter);
        if (pdwData) {

            if (*pdwData < 7)
                return PVIEW_PRIORITY_IDL;
            else if (*pdwData < 10)
                return PVIEW_PRIORITY_NORMAL;
            else
                return PVIEW_PRIORITY_HIGH;
        } else {
            return PVIEW_PRIORITY_NORMAL;
        }
    } else
        return PVIEW_PRIORITY_NORMAL;
}




//*********************************************************************
//
//      RefreshPerfData
//
//  Get a new set of performance data.  pData should be NULL initially.
//
PPERF_DATA RefreshPerfData (HKEY        hPerfKey,
                            LPTSTR      szObjectIndex,
                            PPERF_DATA  pData,
                            DWORD       *pDataSize)
{
    if (GetPerfData (hPerfKey, szObjectIndex, &pData, pDataSize) == ERROR_SUCCESS)
        return pData;
    else
        return NULL;
}




//*********************************************************************
//
//      SetProcessListText
//
//  Format the process list text.
//
void SetProcessListText (PPERF_INSTANCE pInst,
                         PPERF_COUNTER  pCPU,
                         PPERF_COUNTER  pPRIV,
                         PPERF_COUNTER  pProcID,
                         double         fTime,
                         LPTSTR         str)
{
    DWORD           *pdwProcID;
    LARGE_INTEGER   *liCPU;
    LARGE_INTEGER   *liPRIV;
    double          fCPU = 0;
    double          fPRIV = 0;
    INT             PcntPRIV = 0;
    INT             PcntUSER = 0;
    TIME_FIELD      TimeFld;
    TCHAR           szTemp[100];


    if (pCPU) {
        liCPU = (LARGE_INTEGER *) CounterData (pInst, pCPU);
        if (liCPU) {
            fCPU  = Li2Double (*liCPU);
        }
    }

    if (pPRIV) {
        liPRIV = (LARGE_INTEGER *) CounterData (pInst, pPRIV);
        if (liPRIV) 
            fPRIV  = Li2Double (*liPRIV);
    }

    if (fCPU > 0) {
        PcntPRIV = (INT)(fPRIV / fCPU * 100 + 0.5);
        PcntUSER = 100 - PcntPRIV;
    }



    if (pProcID) {
        pdwProcID = (DWORD *) CounterData (pInst, pProcID);
        if (pdwProcID) 
            wsprintf (szTemp, TEXT("%ls (%#x)"), InstanceName(pInst), *pdwProcID);
        else
            wsprintf (szTemp, TEXT("%ls"), InstanceName(pInst));
    } else
        wsprintf (szTemp, TEXT("%ls"), InstanceName(pInst));



    FormatTimeFields (fCPU/1.0e7, &TimeFld);

    wsprintf (str,
              TEXT("%s\t%3ld:%02ld:%02ld.%03ld\t%3ld%%\t%3ld%%"),
              szTemp,
              TimeFld.Hours,
              TimeFld.Mins,
              TimeFld.Secs,
              TimeFld.mSecs,
              PcntPRIV,
              PcntUSER);
}




//*********************************************************************
//
//      RefreshProcessList
//
//  Find all process and update the process list.
//
void RefreshProcessList (HWND           hProcessList,
                         PPERF_OBJECT   pObject)
{
    PPERF_INSTANCE  pInstance;
    TCHAR           szListText[256];
    INT_PTR         ListIndex;

    PPERF_COUNTER   pCounterCPU;
    PPERF_COUNTER   pCounterPRIV;
    PPERF_COUNTER   pCounterProcID;
    double          fObjectFreq;
    double          fObjectTime;
    double          fTime;

    INT             InstanceIndex = 0;

    if (pObject) {
        if ((pCounterCPU    = FindCounter (pObject, PX_PROCESS_CPU))  &&
            (pCounterPRIV   = FindCounter (pObject, PX_PROCESS_PRIV)) &&
            (pCounterProcID = FindCounter (pObject, PX_PROCESS_ID))) {

            fObjectFreq = Li2Double (pObject->PerfFreq);
            fObjectTime = Li2Double (pObject->PerfTime);
            fTime = fObjectTime / fObjectFreq;

            pInstance = FirstInstance (pObject);

            while (pInstance && InstanceIndex < pObject->NumInstances) {
                SetProcessListText (pInstance,
                                    pCounterCPU,
                                    pCounterPRIV,
                                    pCounterProcID,
                                    fTime,
                                    szListText);

                ListIndex = SendMessage (hProcessList, LB_ADDSTRING, 0, (LPARAM)szListText);
                SendMessage (hProcessList, LB_SETITEMDATA, ListIndex, InstanceIndex);

                pInstance = NextInstance (pInstance);
                InstanceIndex++;
            }
        }
    }
}




//*********************************************************************
//
//      RefreshProcessData
//
//  Find data for a given process and update.
//
void RefreshProcessData    (HWND            hWnd,
                            PPERF_OBJECT    pObject,
                            DWORD           ProcessIndex)
{
    PPERF_INSTANCE  pInstance;


    if (pInstance = FindInstanceN (pObject, ProcessIndex)) {
        PutCounterDWKB (hWnd, PVIEW_WS, pInstance, pObject, PX_PROCESS_WORKING_SET);


        SetDlgItemText (hWnd, PVIEW_TOTALPRIVATE_COMMIT, NODATA);

        // set priority
        //
        CheckRadioButton (hWnd,
                          PVIEW_PRIORITY_HIGH,
                          PVIEW_PRIORITY_IDL,
                          ProcessPriority (pObject, pInstance));
    }
}




//*********************************************************************
//
//      SetThreadListText
//
//  Format the thread list text.
//
void SetThreadListText (PPERF_INSTANCE  pInst,
                        PPERF_COUNTER   pCPU,
                        PPERF_COUNTER   pPRIV,
                        double          fTime,
                        LPTSTR          str)
{
    LARGE_INTEGER   *liCPU;
    LARGE_INTEGER   *liPRIV;
    double          fCPU = 0;
    double          fPRIV = 0;
    INT             PcntPRIV = 0;
    INT             PcntUSER = 0;
    TIME_FIELD      TimeFld;
    TCHAR           szTemp[100];


    if (pCPU) {
        liCPU = (LARGE_INTEGER *) CounterData (pInst, pCPU);
        if (liCPU)
            fCPU  = Li2Double (*liCPU);
    }

    if (pPRIV) {
        liPRIV = (LARGE_INTEGER *) CounterData (pInst, pPRIV);
        if (liPRIV)
            fPRIV  = Li2Double (*liPRIV);
    }

    if (fCPU > 0) {
        PcntPRIV = (INT)(fPRIV / fCPU * 100 + 0.5);
        PcntUSER = 100 - PcntPRIV;
    }



    if (pInst->UniqueID != PERF_NO_UNIQUE_ID)
        wsprintf (szTemp, TEXT("%ls (%#x)"), InstanceName(pInst), pInst->UniqueID);
    else
        wsprintf (szTemp, TEXT("%ls"), InstanceName(pInst));




    FormatTimeFields (fCPU/1.0e7, &TimeFld);

    wsprintf (str,
              TEXT("%s\t%3ld:%02ld:%02ld.%03ld\t%3ld%%\t%3ld %%"),
              szTemp,
              TimeFld.Hours,
              TimeFld.Mins,
              TimeFld.Secs,
              TimeFld.mSecs,
              PcntPRIV,
              PcntUSER);

}




//*********************************************************************
//
//      RefreshThreadList
//
//  Find all threads for a given process and update the thread list.
//
void RefreshThreadList (HWND            hThreadList,
                        PPERF_OBJECT    pObject,
                        DWORD           ParentIndex)
{
    PPERF_INSTANCE  pInstance;
    TCHAR           szListText[256];
    INT_PTR         ListIndex;

    PPERF_COUNTER   pCounterCPU;
    PPERF_COUNTER   pCounterPRIV;
    double          fObjectFreq;
    double          fObjectTime;
    double          fTime;

    INT             InstanceIndex = 0;

    if (pObject) {
        if ((pCounterCPU  = FindCounter (pObject, PX_THREAD_CPU)) &&
            (pCounterPRIV = FindCounter (pObject, PX_THREAD_PRIV))) {

            fObjectFreq = Li2Double (pObject->PerfFreq);
            fObjectTime = Li2Double (pObject->PerfTime);
            fTime = fObjectTime / fObjectFreq;


            pInstance = FirstInstance (pObject);

            while (pInstance && InstanceIndex < pObject->NumInstances) {
                if (ParentIndex == pInstance->ParentObjectInstance) {
                    SetThreadListText (pInstance,
                                       pCounterCPU,
                                       pCounterPRIV,
                                       fTime,
                                       szListText);

                    ListIndex = SendMessage (hThreadList,
                                             LB_INSERTSTRING,
                                             (WPARAM)-1,
                                             (LPARAM)szListText);
                    SendMessage (hThreadList, LB_SETITEMDATA, ListIndex, InstanceIndex);
                }

                pInstance = NextInstance (pInstance);
                InstanceIndex++;
            }
        }
    }

}




//*********************************************************************
//
//      RefreshThreadData
//
//  Find data for a given thread and update.
//
void RefreshThreadData (HWND              hWnd,
                        PPERF_OBJECT      pThreadObj,
                        DWORD             ThreadIndex,
                        PPERF_OBJECT      pProcessObj,
                        PPERF_INSTANCE    pProcessInst)
{
    PPERF_INSTANCE  pInstance;
    PPERF_COUNTER   pCounter;
    DWORD           *pdwData;
    DWORD           *pdwProcPrio;
    BOOL            bPrioCounter = TRUE;



    if (pInstance = FindInstanceN (pThreadObj, ThreadIndex)) {
        SetDlgItemText (hWnd, PVIEW_THREAD_PC, NODATA);

        PutCounterHEX (hWnd, PVIEW_THREAD_START,    pInstance, pThreadObj, PX_THREAD_START);
        PutCounterDW  (hWnd, PVIEW_THREAD_SWITCHES, pInstance, pThreadObj, PX_THREAD_SWITCHES);
        PutCounterDW  (hWnd, PVIEW_THREAD_DYNAMIC,  pInstance, pThreadObj, PX_THREAD_PRIO);
    }




    if (pInstance) {
        // get thread base priority
        //

        if (pCounter = FindCounter (pThreadObj, PX_THREAD_BASE_PRIO)) {
            pdwData = CounterData (pInstance, pCounter);
            if (!pdwData) {
                bPrioCounter = FALSE;
            }
        } else
            bPrioCounter = FALSE;


        // get process priority
        //

        if (pCounter = FindCounter (pProcessObj, PX_PROCESS_PRIO)) {
            pdwProcPrio = CounterData (pProcessInst, pCounter);
            if (!pdwProcPrio) {
                bPrioCounter = FALSE;
            }
        } else
            bPrioCounter = FALSE;
    } else
        bPrioCounter = FALSE;





    // set thread base priority
    //

    if (!bPrioCounter)
        CheckRadioButton (hWnd,
                          PVIEW_THREAD_HIGHEST,
                          PVIEW_THREAD_LOWEST,
                          PVIEW_THREAD_NORMAL);
    else {
        switch (*pdwData - *pdwProcPrio) {
            case 2:
                CheckRadioButton (hWnd,
                                  PVIEW_THREAD_HIGHEST,
                                  PVIEW_THREAD_LOWEST,
                                  PVIEW_THREAD_HIGHEST);
                break;

            case 1:
                CheckRadioButton (hWnd,
                                  PVIEW_THREAD_HIGHEST,
                                  PVIEW_THREAD_LOWEST,
                                  PVIEW_THREAD_ABOVE);
                break;

            case -1:
                CheckRadioButton (hWnd,
                                  PVIEW_THREAD_HIGHEST,
                                  PVIEW_THREAD_LOWEST,
                                  PVIEW_THREAD_BELOW);
                break;

            case -2:
                CheckRadioButton (hWnd,
                                  PVIEW_THREAD_HIGHEST,
                                  PVIEW_THREAD_LOWEST,
                                  PVIEW_THREAD_LOWEST);
                break;

            case 0:
                default:
                CheckRadioButton (hWnd,
                                  PVIEW_THREAD_HIGHEST,
                                  PVIEW_THREAD_LOWEST,
                                  PVIEW_THREAD_NORMAL);
                break;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\pviewer\perfdata.h ===
/******************************************************************************

                    P E R F O R M A N C E   D A T A

    Name:       perfdata.h

    Description:
        This module contains function prototypes and defines used in
        objdata.c, instdata.c, and cntrdata.c.

******************************************************************************/






typedef PERF_DATA_BLOCK             PERF_DATA,      *PPERF_DATA;
typedef PERF_OBJECT_TYPE            PERF_OBJECT,    *PPERF_OBJECT;
typedef PERF_INSTANCE_DEFINITION    PERF_INSTANCE,  *PPERF_INSTANCE;
typedef PERF_COUNTER_DEFINITION     PERF_COUNTER,   *PPERF_COUNTER;














DWORD   GetPerfData (HKEY       hPerfKey,
                     LPTSTR     szObjectIndex,
                     PPERF_DATA *ppData,
                     DWORD      *pDataSize);

DWORD   GetPerfTitleSz
                    (HKEY       hKeyMachine,
                     HKEY       hKeyPerf,
                     LPTSTR     *TitleBuffer,
                     LPTSTR     *TitleSz[],
                     DWORD      *TitleLastIdx);


PPERF_OBJECT    FirstObject (PPERF_DATA pData);
PPERF_OBJECT    NextObject (PPERF_OBJECT pObject);
PPERF_OBJECT    FindObject (PPERF_DATA pData, DWORD TitleIndex);
PPERF_OBJECT    FindObjectN (PPERF_DATA pData, DWORD N);

PPERF_INSTANCE  FirstInstance (PPERF_OBJECT pObject);
PPERF_INSTANCE  NextInstance (PPERF_INSTANCE pInst);
PPERF_INSTANCE  FindInstanceN (PPERF_OBJECT pObject, DWORD N);
PPERF_INSTANCE  FindInstanceParent (PPERF_INSTANCE pInst, PPERF_DATA pData);
LPTSTR          InstanceName (PPERF_INSTANCE pInst);

PPERF_COUNTER   FirstCounter (PPERF_OBJECT pObject);
PPERF_COUNTER   NextCounter (PPERF_COUNTER pCounter);
PPERF_COUNTER   FindCounter (PPERF_OBJECT pObject, DWORD TitleIndex);
PVOID           CounterData (PPERF_INSTANCE pInst, PPERF_COUNTER pCount);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\pviewer\perfdata.c ===
/******************************************************************************

                        P E R F O R M A N C E   D A T A

    Name:       perfdata.c

    Description:
        This module together with objdata.c, instdata.c, and cntrdata.c
        access the performance data.

******************************************************************************/

#include <windows.h>
#include <winperf.h>
#include "perfdata.h"
#include <stdlib.h>




LPTSTR      *gPerfTitleSz;
LPTSTR      TitleData;




//*********************************************************************
//
//  GetPerfData
//
//      Get a new set of performance data.
//
//      *ppData should be NULL initially.
//      This function will allocate a buffer big enough to hold the
//      data requested by szObjectIndex.
//
//      *pDataSize specifies the initial buffer size.  If the size is
//      too small, the function will increase it until it is big enough
//      then return the size through *pDataSize.  Caller should
//      deallocate *ppData if it is no longer being used.
//
//      Returns ERROR_SUCCESS if no error occurs.
//
//      Note: the trial and error loop is quite different from the normal
//            registry operation.  Normally if the buffer is too small,
//            RegQueryValueEx returns the required size.  In this case,
//            the perflib, since the data is dynamic, a buffer big enough
//            for the moment may not be enough for the next. Therefor,
//            the required size is not returned.
//
//            One should start with a resonable size to avoid the overhead
//            of reallocation of memory.
//
DWORD   GetPerfData    (HKEY        hPerfKey,
                        LPTSTR      szObjectIndex,
                        PPERF_DATA  *ppData,
                        DWORD       *pDataSize)
{
DWORD   DataSize;
DWORD   dwR;
DWORD   Type;


    if (!*ppData)
        *ppData = (PPERF_DATA) LocalAlloc (LMEM_FIXED, *pDataSize);


    do  {
        DataSize = *pDataSize;
        dwR = RegQueryValueEx (hPerfKey,
                               szObjectIndex,
                               NULL,
                               &Type,
                               (BYTE *)*ppData,
                               &DataSize);

        if (dwR == ERROR_MORE_DATA)
            {
            LocalFree (*ppData);
            *pDataSize += 1024;
            *ppData = (PPERF_DATA) LocalAlloc (LMEM_FIXED, *pDataSize);
            }

        if (!*ppData)
            {
            LocalFree (*ppData);
            return ERROR_NOT_ENOUGH_MEMORY;
            }

        } while (dwR == ERROR_MORE_DATA);

    return dwR;
}




#ifdef UNICODE

#define atoi    atoiW


//*********************************************************************
//
//  atoiW
//
//      Unicode version of atoi.
//
INT atoiW (LPTSTR s)
{
INT i = 0;

    while (iswdigit (*s))
        {
        i = i*10 + (BYTE)*s - L'0';
        s++;
        }

    return i;
}

#endif




//*********************************************************************
//
//  GetPerfTitleSz
//
//      Retrieves the performance data title strings.
//
//      This call retrieves english version of the title strings.
//
//      For NT 1.0, the counter names are stored in the "Counters" value
//      in the ...\perflib\009 key.  For 1.0a and later, the 009 key is no
//      longer used.  The counter names should be retrieved from "Counter 009"
//      value of HKEY_PERFORMANCE_KEY.
//
//      Caller should provide two pointers, one for buffering the title
//      strings the other for indexing the title strings.  This function will
//      allocate memory for the TitleBuffer and TitleSz.  To get the title
//      string for a particular title index one would just index the TitleSz.
//      *TitleLastIdx returns the highest index can be used.  If TitleSz[N] is
//      NULL then there is no Title for index N.
//
//      Example:  TitleSz[20] points to titile string for title index 20.
//
//      When done with the TitleSz, caller should LocalFree(*TitleBuffer).
//
//      This function returns ERROR_SUCCESS if no error.
//
DWORD   GetPerfTitleSz (HKEY    hKeyMachine,
                        HKEY    hKeyPerf,
                        LPTSTR  *TitleBuffer,
                        LPTSTR  *TitleSz[],
                        DWORD   *TitleLastIdx)
{
HKEY    hKey1;
HKEY    hKey2;
DWORD   Type;
DWORD   DataSize;
DWORD   dwR;
DWORD   Len;
DWORD   Index;
DWORD   dwTemp;
BOOL    bNT10;
LPTSTR  szCounterValueName;
LPTSTR  szTitle;




    // Initialize
    //
    hKey1        = NULL;
    hKey2        = NULL;
    *TitleBuffer = NULL;
    *TitleSz     = NULL;




    // Open the perflib key to find out the last counter's index and system version.
    //
    dwR = RegOpenKeyEx (hKeyMachine,
                        TEXT("software\\microsoft\\windows nt\\currentversion\\perflib"),
                        0,
                        KEY_READ,
                        &hKey1);
    if (dwR != ERROR_SUCCESS)
        goto done;



    // Get the last counter's index so we know how much memory to allocate for TitleSz
    //
    DataSize = sizeof (DWORD);
    dwR = RegQueryValueEx (hKey1, TEXT("Last Counter"), 0, &Type, (LPBYTE)TitleLastIdx, &DataSize);
    if (dwR != ERROR_SUCCESS)
        goto done;



    // Find system version, for system earlier than 1.0a, there's no version value.
    //
    dwR = RegQueryValueEx (hKey1, TEXT("Version"), 0, &Type, (LPBYTE)&dwTemp, &DataSize);

    if (dwR != ERROR_SUCCESS)
        // unable to read the value, assume NT 1.0
        bNT10 = TRUE;
    else
        // found the value, so, NT 1.0a or later
        bNT10 = FALSE;









    // Now, get ready for the counter names and indexes.
    //
    if (bNT10)
        {
        // NT 1.0, so make hKey2 point to ...\perflib\009 and get
        //  the counters from value "Counters"
        //
        szCounterValueName = TEXT("Counters");
        dwR = RegOpenKeyEx (hKeyMachine,
                            TEXT("software\\microsoft\\windows nt\\currentversion\\perflib\\009"),
                            0,
                            KEY_READ,
                            &hKey2);
        if (dwR != ERROR_SUCCESS)
            goto done;
        }
    else
        {
        // NT 1.0a or later.  Get the counters in key HKEY_PERFORMANCE_KEY
        //  and from value "Counter 009"
        //
        szCounterValueName = TEXT("Counter 009");
        hKey2 = hKeyPerf;
        }





    // Find out the size of the data.
    //
    dwR = RegQueryValueEx (hKey2, szCounterValueName, 0, &Type, 0, &DataSize);
    if (dwR != ERROR_SUCCESS)
        goto done;



    // Allocate memory
    //
    *TitleBuffer = (LPTSTR)LocalAlloc (LMEM_FIXED, DataSize);
    if (!*TitleBuffer)
        {
        dwR = ERROR_NOT_ENOUGH_MEMORY;
        goto done;
        }

    *TitleSz = (LPTSTR *)LocalAlloc (LPTR, (*TitleLastIdx+1) * sizeof (LPTSTR));
    if (!*TitleSz)
        {
        dwR = ERROR_NOT_ENOUGH_MEMORY;
        goto done;
        }





    // Query the data
    //
    dwR = RegQueryValueEx (hKey2, szCounterValueName, 0, &Type, (BYTE *)*TitleBuffer, &DataSize);
    if (dwR != ERROR_SUCCESS)
        goto done;




    // Setup the TitleSz array of pointers to point to beginning of each title string.
    // TitleBuffer is type REG_MULTI_SZ.
    //
    szTitle = *TitleBuffer;

    while (Len = lstrlen (szTitle))
        {
        Index = atoi (szTitle);

        szTitle = szTitle + Len +1;

        if (Index <= *TitleLastIdx)
            (*TitleSz)[Index] = szTitle;

        szTitle = szTitle + lstrlen (szTitle) +1;
        }



done:

    // Done. Now cleanup!
    //
    if (dwR != ERROR_SUCCESS)
        {
        // There was an error, free the allocated memory
        //
        if (*TitleBuffer) LocalFree (*TitleBuffer);
        if (*TitleSz)     LocalFree (*TitleSz);
        }

    // Close the hKeys.
    //
    if (hKey1) RegCloseKey (hKey1);
    if (hKey2 && hKey2 != hKeyPerf) RegCloseKey (hKey2);



    return dwR;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\pviewer\objdata.c ===
/******************************************************************************

                                O B J E C T   D A T A

    Name:       objdata.c

    Description:
        This module contains functions that access objects in performance
        data.

    Functions:
        FirstObject
        NextObject
        FindObject
        FindObjectN

******************************************************************************/

#include <windows.h>
#include <winperf.h>
#include "perfdata.h"




//*********************************************************************
//
//  FirstObject
//
//      Returns pointer to the first object in pData.
//      If pData is NULL then NULL is returned.
//
PPERF_OBJECT FirstObject (PPERF_DATA pData)
{
    if (pData)
        return ((PPERF_OBJECT) ((PBYTE) pData + pData->HeaderLength));
    else
        return NULL;
}




//*********************************************************************
//
//  NextObject
//
//      Returns pointer to the next object following pObject.
//
//      If pObject is the last object, bogus data maybe returned.
//      The caller should do the checking.
//
//      If pObject is NULL, then NULL is returned.
//
PPERF_OBJECT NextObject (PPERF_OBJECT pObject)
{
    if (pObject)
        return ((PPERF_OBJECT) ((PBYTE) pObject + pObject->TotalByteLength));
    else
        return NULL;
}




//*********************************************************************
//
//  FindObject
//
//      Returns pointer to object with TitleIndex.  If not found, NULL
//      is returned.
//
PPERF_OBJECT FindObject (PPERF_DATA pData, DWORD TitleIndex)
{
PPERF_OBJECT pObject;
DWORD        i = 0;

    if (pObject = FirstObject (pData))
        while (i < pData->NumObjectTypes)
            {
            if (pObject->ObjectNameTitleIndex == TitleIndex)
                return pObject;

            pObject = NextObject (pObject);
            i++;
            }

    return NULL;
}




//*********************************************************************
//
//  FindObjectN
//
//      Find the Nth object in pData.  If not found, NULL is returned.
//      0 <= N < NumObjectTypes.
//
PPERF_OBJECT FindObjectN (PPERF_DATA pData, DWORD N)
{
PPERF_OBJECT pObject;
DWORD        i = 0;

    if (!pData)
        return NULL;
    else if (N >= pData->NumObjectTypes)
        return NULL;
    else
        {
        pObject = FirstObject (pData);

        while (i != N)
            {
            pObject = NextObject (pObject);
            i++;
            }

        return pObject;
        }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\pviewer\pviewdlg.h ===
#define PVIEW_DLG                   100
#define PVIEW_EXIT                  101
#define PVIEW_MEMORY_DETAIL         102
#define PVIEW_TERMINATE             103
#define PVIEW_REFRESH               104
#define PVIEW_COMPUTER              105
#define PVIEW_CONNECT               106
#define PVIEW_PROCESS_LIST          107
#define PVIEW_WS                    108
#define PVIEW_TOTALPRIVATE_COMMIT   109
#define PVIEW_PRIORITY_HIGH         110
#define PVIEW_PRIORITY_NORMAL       111
#define PVIEW_PRIORITY_IDL          112
#define PVIEW_THREAD_HIGHEST        113
#define PVIEW_THREAD_ABOVE          114
#define PVIEW_THREAD_NORMAL         115
#define PVIEW_THREAD_BELOW          116
#define PVIEW_THREAD_LOWEST         117
#define PVIEW_THREAD_LIST           118
#define PVIEW_THREAD_PC             119
#define PVIEW_THREAD_START          120
#define PVIEW_THREAD_SWITCHES       121
#define PVIEW_THREAD_DYNAMIC        122
#define MEMORY_DLG                  1000
#define MEMORY_PROCESS_ID           1001
#define MEMORY_IMAGE_EXECUTE        1002
#define MEMORY_IMAGE_WRITECOPY      1003
#define MEMORY_IMAGE_READWRITE      1004
#define MEMORY_TOTALIMAGE_COMMIT    1005
#define MEMORY_IMAGE_NOACCESS       1006
#define MEMORY_IMAGE_READONLY       1007
#define MEMORY_TOTALMAPPED_COMMIT   1008
#define MEMORY_MAPPED_NOACCESS      1009
#define MEMORY_MAPPED_READONLY      1010
#define MEMORY_MAPPED_READWRITE     1011
#define MEMORY_MAPPED_WRITECOPY     1012
#define MEMORY_MAPPED_EXECUTE       1013
#define MEMORY_TOTALPRIVATE_COMMIT  1014
#define MEMORY_PRIVATE_NOACCESS     1015
#define MEMORY_PRIVATE_READONLY     1016
#define MEMORY_PRIVATE_READWRITE    1017
#define MEMORY_PRIVATE_WRITECOPY    1018
#define MEMORY_PRIVATE_EXECUTE      1019
#define MEMORY_WS                   1020
#define MEMORY_PEAK_WS              1021
#define MEMORY_PRIVATE_PAGE         1022
#define MEMORY_VSIZE                1023
#define MEMORY_PEAK_VSIZE           1024
#define MEMORY_PFCOUNT              1025
#define MEMORY_PAGED                1026
#define MEMORY_PEAK_PAGED           1027
#define MEMORY_NONPAGED             1028
#define MEMORY_QPGPEAK              1029
#define MEMORY_QNONPEAK             1030
#define MEMORY_QPGCUR               1031
#define MEMORY_QNONCUR              1032
#define MEMORY_QPGLIM               1033
#define MEMORY_QNONLIM              1034
#define PVIEW_PROCESS_PRIORITY      124
#define PVIEW_THREAD_PRIORITY       123
#define MEMORY_IMAGE                1035
#define MEMORY_REFRESH              2000
#define MEMORY_REFRESH_ALL          2002
#define PVIEW_REFRESH_COSTLY_DATA   2001
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\pviewer\pviewdat.h ===
/******************************************************************************

                            P V I E W   D A T A

    Name:       pviewdat.h

    Description:
        Prototypes of functions used in pviewdat.c

******************************************************************************/





//******************************************************************************
//
//  Titles and indexes.
//
//  See GetPerfTitleSz() in perfdata.c on how to retrieve these data.
//
//  This is not complete, for complete listing
//  see under hkey_local_system
//               \software
//                   \microsoft
//                       \windows nt
//                           \currentversion
//                               \perflib
//                                   \###
//

#define PN_PROCESS                          TEXT("Process")
#define PN_PROCESS_CPU                      TEXT("% Processor Time")
#define PN_PROCESS_PRIV                     TEXT("% Privileged Time")
#define PN_PROCESS_USER                     TEXT("% User Time")
#define PN_PROCESS_WORKING_SET              TEXT("Working Set")
#define PN_PROCESS_PEAK_WS                  TEXT("Working Set Peak")
#define PN_PROCESS_PRIO                     TEXT("Priority Base")
#define PN_PROCESS_ELAPSE                   TEXT("Elapsed Time")
#define PN_PROCESS_ID                       TEXT("ID Process")
#define PN_PROCESS_PRIVATE_PAGE             TEXT("Private Bytes")
#define PN_PROCESS_VIRTUAL_SIZE             TEXT("Virtual Bytes")
#define PN_PROCESS_PEAK_VS                  TEXT("Virtual Bytes Peak")
#define PN_PROCESS_FAULT_COUNT              TEXT("Page Faults/sec")


#define PN_THREAD                           TEXT("Thread")
#define PN_THREAD_CPU                       TEXT("% Processor Time")
#define PN_THREAD_PRIV                      TEXT("% Privileged Time")
#define PN_THREAD_USER                      TEXT("% User Time")
#define PN_THREAD_START                     TEXT("Start Address")
#define PN_THREAD_SWITCHES                  TEXT("Context Switches/sec")
#define PN_THREAD_PRIO                      TEXT("Priority Current")
#define PN_THREAD_BASE_PRIO                 TEXT("Priority Base")
#define PN_THREAD_ELAPSE                    TEXT("Elapsed Time")

#define PN_THREAD_DETAILS                   TEXT("Thread Details")
#define PN_THREAD_PC                        TEXT("User PC")

#define PN_IMAGE                            TEXT("Image")
#define PN_IMAGE_NOACCESS                   TEXT("No Access")
#define PN_IMAGE_READONLY                   TEXT("Read Only")
#define PN_IMAGE_READWRITE                  TEXT("Read/Write")
#define PN_IMAGE_WRITECOPY                  TEXT("Write Copy")
#define PN_IMAGE_EXECUTABLE                 TEXT("Executable")
#define PN_IMAGE_EXE_READONLY               TEXT("Exec Read Only")
#define PN_IMAGE_EXE_READWRITE              TEXT("Exec Read/Write")
#define PN_IMAGE_EXE_WRITECOPY              TEXT("Exec Write Copy")


#define PN_PROCESS_ADDRESS_SPACE            TEXT("Process Address Space")
#define PN_PROCESS_PRIVATE_NOACCESS         TEXT("Reserved Space No Access")
#define PN_PROCESS_PRIVATE_READONLY         TEXT("Reserved Space Read Only")
#define PN_PROCESS_PRIVATE_READWRITE        TEXT("Reserved Space Read/Write")
#define PN_PROCESS_PRIVATE_WRITECOPY        TEXT("Reserved Space Write Copy")
#define PN_PROCESS_PRIVATE_EXECUTABLE       TEXT("Reserved Space Executable")
#define PN_PROCESS_PRIVATE_EXE_READONLY     TEXT("Reserved Space Exec Read Only")
#define PN_PROCESS_PRIVATE_EXE_READWRITE    TEXT("Reserved Space Exec Read/Write")
#define PN_PROCESS_PRIVATE_EXE_WRITECOPY    TEXT("Reserved Space Exec Write Copy")


#define PN_PROCESS_MAPPED_NOACCESS          TEXT("Mapped Space No Access")
#define PN_PROCESS_MAPPED_READONLY          TEXT("Mapped Space Read Only")
#define PN_PROCESS_MAPPED_READWRITE         TEXT("Mapped Space Read/Write")
#define PN_PROCESS_MAPPED_WRITECOPY         TEXT("Mapped Space Write Copy")
#define PN_PROCESS_MAPPED_EXECUTABLE        TEXT("Mapped Space Executable")
#define PN_PROCESS_MAPPED_EXE_READONLY      TEXT("Mapped Space Exec Read Only")
#define PN_PROCESS_MAPPED_EXE_READWRITE     TEXT("Mapped Space Exec Read/Write")
#define PN_PROCESS_MAPPED_EXE_WRITECOPY     TEXT("Mapped Space Exec Write Copy")


#define PN_PROCESS_IMAGE_NOACCESS           TEXT("Image Space No Access")
#define PN_PROCESS_IMAGE_READONLY           TEXT("Image Space Read Only")
#define PN_PROCESS_IMAGE_READWRITE          TEXT("Image Space Read/Write")
#define PN_PROCESS_IMAGE_WRITECOPY          TEXT("Image Space Write Copy")
#define PN_PROCESS_IMAGE_EXECUTABLE         TEXT("Image Space Executable")
#define PN_PROCESS_IMAGE_EXE_READONLY       TEXT("Image Space Exec Read Only")
#define PN_PROCESS_IMAGE_EXE_READWRITE      TEXT("Image Space Exec Read/Write")
#define PN_PROCESS_IMAGE_EXE_WRITECOPY      TEXT("Image Space Exec Write Copy")







DWORD   PX_PROCESS;
DWORD   PX_PROCESS_CPU;
DWORD   PX_PROCESS_PRIV;
DWORD   PX_PROCESS_USER;
DWORD   PX_PROCESS_WORKING_SET;
DWORD   PX_PROCESS_PEAK_WS;
DWORD   PX_PROCESS_PRIO;
DWORD   PX_PROCESS_ELAPSE;
DWORD   PX_PROCESS_ID;
DWORD   PX_PROCESS_PRIVATE_PAGE;
DWORD   PX_PROCESS_VIRTUAL_SIZE;
DWORD   PX_PROCESS_PEAK_VS;
DWORD   PX_PROCESS_FAULT_COUNT;
DWORD   PX_PROCESS_PAGED_POOL_QUOTA;
DWORD   PX_PROCESS_PEAK_PAGED_POOL_QUOTA;
DWORD   PX_PROCESS_NONPAGED_POOL_QUOTA;
DWORD   PX_PROCESS_PEAK_PAGED_POOL;
DWORD   PX_PROCESS_PEAK_NONPAGED_POOL;
DWORD   PX_PROCESS_CUR_PAGED_POOL;
DWORD   PX_PROCESS_CUR_NONPAGED_POOL;
DWORD   PX_PROCESS_PAGED_POOL_LIMIT;
DWORD   PX_PROCESS_NONPAGED_POOL_LIMIT;


DWORD   PX_THREAD;
DWORD   PX_THREAD_CPU;
DWORD   PX_THREAD_PRIV;
DWORD   PX_THREAD_USER;
DWORD   PX_THREAD_START;
DWORD   PX_THREAD_SWITCHES;
DWORD   PX_THREAD_PRIO;
DWORD   PX_THREAD_BASE_PRIO;
DWORD   PX_THREAD_ELAPSE;

DWORD   PX_THREAD_DETAILS;
DWORD   PX_THREAD_PC;

DWORD   PX_IMAGE;
DWORD   PX_IMAGE_NOACCESS;
DWORD   PX_IMAGE_READONLY;
DWORD   PX_IMAGE_READWRITE;
DWORD   PX_IMAGE_WRITECOPY;
DWORD   PX_IMAGE_EXECUTABLE;
DWORD   PX_IMAGE_EXE_READONLY;
DWORD   PX_IMAGE_EXE_READWRITE;
DWORD   PX_IMAGE_EXE_WRITECOPY;


DWORD   PX_PROCESS_ADDRESS_SPACE;
DWORD   PX_PROCESS_PRIVATE_NOACCESS;
DWORD   PX_PROCESS_PRIVATE_READONLY;
DWORD   PX_PROCESS_PRIVATE_READWRITE;
DWORD   PX_PROCESS_PRIVATE_WRITECOPY;
DWORD   PX_PROCESS_PRIVATE_EXECUTABLE;
DWORD   PX_PROCESS_PRIVATE_EXE_READONLY;
DWORD   PX_PROCESS_PRIVATE_EXE_READWRITE;
DWORD   PX_PROCESS_PRIVATE_EXE_WRITECOPY;


DWORD   PX_PROCESS_MAPPED_NOACCESS;
DWORD   PX_PROCESS_MAPPED_READONLY;
DWORD   PX_PROCESS_MAPPED_READWRITE;
DWORD   PX_PROCESS_MAPPED_WRITECOPY;
DWORD   PX_PROCESS_MAPPED_EXECUTABLE;
DWORD   PX_PROCESS_MAPPED_EXE_READONLY;
DWORD   PX_PROCESS_MAPPED_EXE_READWRITE;
DWORD   PX_PROCESS_MAPPED_EXE_WRITECOPY;


DWORD   PX_PROCESS_IMAGE_NOACCESS;
DWORD   PX_PROCESS_IMAGE_READONLY;
DWORD   PX_PROCESS_IMAGE_READWRITE;
DWORD   PX_PROCESS_IMAGE_WRITECOPY;
DWORD   PX_PROCESS_IMAGE_EXECUTABLE;
DWORD   PX_PROCESS_IMAGE_EXE_READONLY;
DWORD   PX_PROCESS_IMAGE_EXE_READWRITE;
DWORD   PX_PROCESS_IMAGE_EXE_WRITECOPY;











#define Li2Double(x) ((double)((x).HighPart) * 4.294967296E9 + (double)((x).LowPart))







typedef     struct _TIME_FIELD
    TIME_FIELD,
    *PTIME_FIELD;

struct _TIME_FIELD
    {
    INT     Hours;
    INT     Mins;
    INT     Secs;
    INT     mSecs;
    };








void RefreshPviewDlgThreadPC
           (HWND            hPviewDlg,
            LPTSTR          szProcessName,
            LPTSTR          szThreadName,
            PPERF_OBJECT    pThreadDetailsObject,
            PPERF_DATA      pCostlyData);


BOOL RefreshMemoryDlg
           (HWND            hMemDlg,
            PPERF_INSTANCE  pProcessInstance,
            PPERF_OBJECT    pProcessObject,
            PPERF_OBJECT    pAddressObject,
            PPERF_OBJECT    pImageObject);


void RefreshMemoryDlgImage
           (HWND            hMemDlg,
            DWORD           dwIndex,
            PPERF_OBJECT    pImageObject);


void RefreshPviewDlgMemoryData
           (HWND            hPviewDlg,
            PPERF_INSTANCE  pProcessInstance,
            PPERF_OBJECT    pProcessObject,
            PPERF_OBJECT    pAddressObject);


PPERF_DATA RefreshPerfData
           (HKEY            hPerfKey,
            LPTSTR          szObjectIndex,
            PPERF_DATA      pData,
            DWORD           *pDataSize);


void RefreshProcessList
           (HWND            hProcessList,
            PPERF_OBJECT    pObject);


void RefreshProcessData
           (HWND            hWnd,
            PPERF_OBJECT    pObject,
            DWORD           ProcessIndex);


void RefreshThreadList
           (HWND            hThreadList,
            PPERF_OBJECT    pObject,
            DWORD           ParentIndex);


void RefreshThreadData
           (HWND            hWnd,
            PPERF_OBJECT    pThreadObj,
            DWORD           ThreadIndex,
            PPERF_OBJECT    pProcessObj,
            PPERF_INSTANCE  pProcessInst);


WORD ProcessPriority
           (PPERF_OBJECT    pObject,
            PPERF_INSTANCE  pInstance);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\pviewer\pviewer.c ===
/******************************************************************************

                        P R O C E S S   V I E W E R

    Name:       pviewer.c

    Description:
        This program demonstrates the usage of special registry APIs
        for collecting performance data.

        C files used in this app:
            pviewer.c       - this file
            pviewdat.c      - updates the dialog
            perfdata.c      - gets performance data structures
            objdata.c       - access performance data objects
            instdata.c      - access performance data instances
            cntrdata.c      - access performance data counters

******************************************************************************/




#include <windows.h>
#include <winperf.h>
#include "perfdata.h"
#include "pviewdat.h"
#include "pviewdlg.h"
#include <string.h>
#include <stdio.h>



#define INDEX_STR_LEN       10
#define MACHINE_NAME_LEN    MAX_COMPUTERNAME_LENGTH+2
#define MACHINE_NAME_SIZE   MACHINE_NAME_LEN+1


/****
Globals
****/

TCHAR           INDEX_PROCTHRD_OBJ[2*INDEX_STR_LEN];
TCHAR           INDEX_COSTLY_OBJ[3*INDEX_STR_LEN];

TCHAR           gszMachineName[MACHINE_NAME_SIZE];
TCHAR           gszCurrentMachine[MACHINE_NAME_SIZE];

DWORD           gPerfDataSize = 50*1024;            // start with 50K
PPERF_DATA      gpPerfData;

DWORD           gCostlyDataSize = 100*1024;         // start wiih 100K
PPERF_DATA      gpCostlyData;


PPERF_OBJECT    gpProcessObject;                    // pointer to process objects
PPERF_OBJECT    gpThreadObject;                     // pointer to thread objects
PPERF_OBJECT    gpThreadDetailsObject;              // pointer to thread detail objects
PPERF_OBJECT    gpAddressSpaceObject;               // pointer to address space objects
PPERF_OBJECT    gpImageObject;                      // pointer to image objects


HKEY            ghPerfKey = HKEY_PERFORMANCE_DATA;  // get perf data from this key
HKEY            ghMachineKey = HKEY_LOCAL_MACHINE;  // get title index from this key


HCURSOR         ghCursor[2];                        // 0 = arrow, 1 = hourglass

HANDLE          ghMemUpdateEvent;                   // to signal a refresh of mem stats
HANDLE          ghMemUpdateMutex;                   // to restrict overlapping refreshes

HINSTANCE       ghInstance;                         // handle for pviewer app



/****
Prototypes
****/

INT_PTR CALLBACK   PviewDlgProc (HWND hWnd, UINT wMsg, WPARAM wParam, LPARAM lParam);
void    PviewDlgRefresh (HWND hWnd);
void    PviewDlgRefreshCostlyData (HWND hPviewDlg);
void    PviewDlgRefreshProcess (HWND hWnd);
void    PviewDlgRefreshThread (HWND hWnd);
void    PviewDlgRefreshCurSelProcess (HWND hWnd);
void    PviewDlgRefreshCurSelThread (HWND hWnd);
WORD    PviewDlgGetCurSelPriority (HWND hWnd);
BOOL    PviewDlgChangePriority (HWND hWnd, WPARAM wParam, WORD wItem);
BOOL    PviewDlgTerminateProcess (HWND hPviewDlg);

INT_PTR CALLBACK   MemDlgProc (HWND hWnd, UINT wMsg, WPARAM wParam, LPARAM lParam);
void    MemDlgUpdateThread (HWND hWnd);
void    MemDlgRefresh (HWND hWnd, HWND hPviewDlg);
void    MemDlgRefreshCurSelImage (HWND hMemDlg, HWND hPviewDlg);

INT     GetCurSelText (HWND hList, LPTSTR str);
DWORD   GetCurSelData (HWND hWnd, DWORD dwList);
INT     ReSelectText (HWND hList, INT StartIndex, LPTSTR str);
void    SetPerfIndexes (HWND hWnd);
DWORD   GetTitleIdx (HWND hWnd, LPTSTR TitleSz[], DWORD LastIndex, LPTSTR Name);
void    SetListBoxTabStops (HWND hWnd);
void    SetLocalMachine (void);
BOOL    ConnectComputer (HWND hWnd);
void    DisableControls (HWND hPviewDlg);
void    EnableControls (HWND hPviewDlg);




//********************************************************
//
//  WinMain --
//
//      Build Up: create the program's dialog box,
//          load the desired icons, enter the message
//          loop.
//
//      Tear Down: free up the memory allocated by the
//          dialog box proc, and exit.
//
int WINAPI WinMain (HINSTANCE   hInstance,
                    HINSTANCE   hPrevInstance,
                    LPSTR       lpCmdLine,
                    int         nCmdShow)
{
    HANDLE  hWndDialog;
    MSG     msg;


    ghInstance = hInstance;


    // load our default cursors
    //
    ghCursor[0] = LoadCursor (0, IDC_ARROW);
    ghCursor[1] = LoadCursor (0, IDC_WAIT);

    // open our dialog box
    //
    hWndDialog = CreateDialogParam (hInstance,
                                    MAKEINTRESOURCE (PVIEW_DLG),
                                    NULL,
                                    PviewDlgProc,
                                    0);

    // the almighty Windows message loop:
    //
    while (GetMessage (&msg, NULL, 0, 0))
        if (!IsDialogMessage (hWndDialog, &msg)) {
            TranslateMessage (&msg);
            DispatchMessage (&msg);
        }

        // close up shop
        //
    DestroyWindow (hWndDialog);
    LocalFree (gpPerfData);

    return 0;
}




/*****************
PviewDlg functions
*****************/

//********************************************************
//
//  PviewDlgProc --
//
//      Pview dialog procedure
//
INT_PTR CALLBACK   PviewDlgProc   (HWND    hWnd,
                                   UINT    wMsg,
                                   WPARAM  wParam,
                                   LPARAM  lParam)
{
    WORD    wItem;
    MSG     Msg;


    switch (wMsg) {

        case WM_INITDIALOG:
            SetClassLongPtr (hWnd, GCLP_HICON, (LONG_PTR)LoadIcon(ghInstance, TEXT("VIEWPICON")) );
            SetListBoxTabStops (hWnd);
            SendDlgItemMessage (hWnd, PVIEW_COMPUTER, EM_LIMITTEXT, MACHINE_NAME_LEN, 0);
            PostMessage (hWnd, WM_COMMAND, PVIEW_REFRESH, 0);
            break;

        case WM_CLOSE:
            PostQuitMessage (0);
            break;

        case WM_COMMAND:
            //
            // handle our app-specific controls:
            //
            switch (LOWORD (wParam)) {
                // works just like "close"
                //
                case PVIEW_EXIT:
                    PostQuitMessage (0);
                    break;

                    // if somebody moved the highlight in the thread list,
                    //  update the view
                    //
                case PVIEW_THREAD_LIST:
                    if (HIWORD(wParam) == LBN_DBLCLK || HIWORD(wParam) == LBN_SELCHANGE) {
                        PviewDlgRefreshCurSelThread (hWnd);
                        PostMessage (hWnd, WM_COMMAND, PVIEW_REFRESH_COSTLY_DATA, 0);
                    }
                    break;

                    // if somebody clicked on a new process, update all of the
                    //  affected information.
                    //
                case PVIEW_PROCESS_LIST:
                    if (HIWORD(wParam) == CBN_DBLCLK || HIWORD(wParam) == CBN_SELCHANGE) {
                        PviewDlgRefreshCurSelProcess (hWnd);
                        PostMessage (hWnd, WM_COMMAND, PVIEW_REFRESH_COSTLY_DATA, 0);
                        if (HIWORD(wParam) == CBN_DBLCLK)
                            PostMessage (hWnd, WM_COMMAND, PVIEW_MEMORY_DETAIL, 0);
                    }
                    break;

                    // the user wishes to view the memory stats in detail:
                    //
                case PVIEW_MEMORY_DETAIL:
                    //
                    // check to see if we can get exclusive access
                    //  to the memory statistics
                    //
                    if (WaitForSingleObject (ghMemUpdateMutex, 0))

                        // we can't, so just return.
                        //
                        return FALSE;

                    else {
                        // we have exclusive access, so start up the
                        //  memory statistics dialog.
                        //
                        // release the mutex first so the dialog can use it.
                        //
                        ReleaseMutex (ghMemUpdateMutex);
                        DialogBoxParam (NULL,
                                        MAKEINTRESOURCE (MEMORY_DLG),
                                        hWnd,
                                        MemDlgProc,
                                        (LPARAM)hWnd);
                    }
                    break;

                    // somebody clicked one of the priority radio
                    //  buttons.  Find out which one was selected...
                    //
                case PVIEW_PRIORITY_HIGH:
                case PVIEW_PRIORITY_NORMAL:
                case PVIEW_PRIORITY_IDL:

                    if (SendDlgItemMessage (hWnd, PVIEW_PRIORITY_HIGH, BM_GETCHECK, 0, 0))
                        wItem = PVIEW_PRIORITY_HIGH;
                    else if (SendDlgItemMessage (hWnd, PVIEW_PRIORITY_NORMAL, BM_GETCHECK, 0, 0))
                        wItem = PVIEW_PRIORITY_NORMAL;
                    else
                        wItem = PVIEW_PRIORITY_IDL;

                    // if the user actually clicked on a NEW state,
                    //  do the change.
                    //
                    if (LOWORD(wParam) != wItem) {
                        // of course, if it's a remote machine, disallow
                        //  the modification.
                        //
                        if (lstrcmp (gszCurrentMachine, gszMachineName)) {
                            SendDlgItemMessage (hWnd, wItem, BM_SETCHECK, 1, 0);
                            SetFocus (GetDlgItem (hWnd, wItem));
                            MessageBox (hWnd,
                                        TEXT("Cannot change process priority on remote machine"),
                                        TEXT("Set priority"),
                                        MB_ICONEXCLAMATION|MB_OK);
                        }

                        // at this point, we know we are affecting the local
                        //  machine, and a change has to be made.
                        //  Just Do It(TM).
                        //
                        else if (PviewDlgChangePriority (hWnd, wParam, wItem))
                            PviewDlgRefresh (hWnd);

                    }
                    break;

                case PVIEW_THREAD_HIGHEST:
                case PVIEW_THREAD_ABOVE:
                case PVIEW_THREAD_NORMAL:
                case PVIEW_THREAD_BELOW:
                case PVIEW_THREAD_LOWEST:
                    //
                    // this selection hasn't been fleshed out yet.
                    //
                    PviewDlgRefreshCurSelThread (hWnd);
                    break;

                    // terminate the selected process
                    //
                case PVIEW_TERMINATE:
                    if (PviewDlgTerminateProcess (hWnd))
                        PviewDlgRefresh (hWnd);
                    break;

                    // if the text has changed, we want to connect and
                    //  view another system's processes...
                    //
                case PVIEW_COMPUTER:
                    if (HIWORD(wParam) == EN_CHANGE)
                        EnableWindow (GetDlgItem (hWnd, PVIEW_CONNECT), TRUE);
                    else
                        return FALSE;
                    break;

                    // we were told to connect, go ahead and try...
                    //
                case PVIEW_CONNECT:
                    if (ConnectComputer (hWnd)) {
                        SetPerfIndexes (hWnd);
                        PviewDlgRefresh (hWnd);
                    }
                    break;

                    // refresh the current information displayed
                    //
                case PVIEW_REFRESH:
                    if (ConnectComputer (hWnd))
                        SetPerfIndexes (hWnd);
                    PviewDlgRefresh (hWnd);
                    break;

                    // refresh the currently updated costly
                    //  statistics
                    //
                case PVIEW_REFRESH_COSTLY_DATA:
                    if (WaitForSingleObject (ghMemUpdateMutex, 0))
                        return FALSE;

                    PviewDlgRefreshCostlyData (hWnd);
                    ReleaseMutex (ghMemUpdateMutex);
                    break;

                default:
                    return FALSE;
            }
            break;

        default:
            return FALSE;
    }

    return TRUE;
}




//********************************************************
//
//  PviewDlgRefresh --
//
//      Refresh the pview dialog.
//
void    PviewDlgRefresh (HWND hWnd)
{
    static  HANDLE  hMemUpdateThread = NULL;
    static  DWORD   MemUpdateThreadID;
    MSG     Msg;


    SetCursor (ghCursor[1]);


    if (hMemUpdateThread)       // get memory data
        SetEvent (ghMemUpdateEvent);
    else
        hMemUpdateThread = CreateThread (NULL,
                                         0,
                                         (LPTHREAD_START_ROUTINE)MemDlgUpdateThread,
                                         (LPVOID)hWnd,
                                         0,
                                         &MemUpdateThreadID);


    // get performance data
    //
    gpPerfData = RefreshPerfData (ghPerfKey, INDEX_PROCTHRD_OBJ, gpPerfData, &gPerfDataSize);

    gpProcessObject = FindObject (gpPerfData, PX_PROCESS);
    gpThreadObject  = FindObject (gpPerfData, PX_THREAD);


    // refresh
    //
    PviewDlgRefreshProcess (hWnd);
    PviewDlgRefreshThread (hWnd);



    // Remove all mouse and key messages. They are not accepted
    //  while the cursor is a hourglass.
    //
    while (PeekMessage (&Msg, hWnd, WM_MOUSEFIRST, WM_MOUSELAST, PM_REMOVE));
    while (PeekMessage (&Msg, hWnd, WM_KEYFIRST, WM_KEYLAST, PM_REMOVE));

    SetCursor (ghCursor[0]);

}




//********************************************************
//
//  PviewDlgRefreshCostlyData --
//
//      Refresh the costly data.
//
void    PviewDlgRefreshCostlyData (HWND hPviewDlg)
{
    LPTSTR          szProcessName;
    LPTSTR          szThreadName;
    PPERF_INSTANCE  pInstance;
    DWORD           dwIndex;


    dwIndex       = GetCurSelData (hPviewDlg, PVIEW_PROCESS_LIST);
    pInstance     = FindInstanceN (gpProcessObject, dwIndex);
    szProcessName = InstanceName (pInstance);

    RefreshPviewDlgMemoryData (hPviewDlg,
                               pInstance,
                               gpProcessObject,
                               gpAddressSpaceObject);


    dwIndex      = GetCurSelData (hPviewDlg, PVIEW_THREAD_LIST);
    pInstance    = FindInstanceN (gpThreadObject, dwIndex);
    szThreadName = InstanceName (pInstance);

    RefreshPviewDlgThreadPC (hPviewDlg,
                             szProcessName,
                             szThreadName ? szThreadName : TEXT("UNKNOWN"),
                             gpThreadDetailsObject,
                             gpCostlyData);

}




//********************************************************
//
//  PviewDlgRefreshProcess --
//
//      Refresh the process list and data in pview dialog.
//
void    PviewDlgRefreshProcess (HWND hWnd)
{
    TCHAR   szProcessString[256];
    INT     nProcess;
    INT     nIndex;
    HWND    hProcessList;
    DWORD   dwProcessIndex;


    // refresh process list
    //
    hProcessList = GetDlgItem (hWnd, PVIEW_PROCESS_LIST);
    nProcess     = GetCurSelText (hProcessList, szProcessString);

    SendMessage (hProcessList, WM_SETREDRAW, FALSE, 0);
    SendMessage (hProcessList, LB_RESETCONTENT, 0, 0);
    SendMessage (hProcessList, LB_SETITEMDATA, 0, 0);


    RefreshProcessList (hProcessList, gpProcessObject);

    // refresh process data
    //
    if (nProcess != LB_ERR)
        nIndex = ReSelectText (hProcessList, nProcess, szProcessString);
    else
        nIndex = 0;


    dwProcessIndex = (DWORD)SendMessage (hProcessList, LB_GETITEMDATA, nIndex, 0);

    RefreshProcessData (hWnd, gpProcessObject, dwProcessIndex);

    SendMessage (hProcessList, WM_SETREDRAW, TRUE, 0);

}




//********************************************************
//
//  PviewDlgRefreshThread --
//
//      Refresh the thread list and data in pview dialog.
//
void    PviewDlgRefreshThread (HWND hWnd)
{
    TCHAR           szThreadString[256];
    INT             nThread;
    INT             nIndex;
    HWND            hThreadList;
    DWORD           dwThreadIndex;

    PPERF_INSTANCE  pProcessInstance;
    DWORD           dwProcessIndex;


    // get process info
    //
    dwProcessIndex = GetCurSelData (hWnd, PVIEW_PROCESS_LIST);
    pProcessInstance = FindInstanceN (gpProcessObject, dwProcessIndex);


    // refresh thread list
    //
    hThreadList  = GetDlgItem (hWnd, PVIEW_THREAD_LIST);
    nThread      = GetCurSelText (hThreadList, szThreadString);

    SendMessage (hThreadList, WM_SETREDRAW, FALSE, 0);
    SendMessage (hThreadList, LB_RESETCONTENT, 0, 0);
    SendMessage (hThreadList, LB_SETITEMDATA, 0, 0);

    RefreshThreadList (hThreadList, gpThreadObject, dwProcessIndex);


    // refresh thread data
    //
    if (nThread != LB_ERR)
        nIndex = ReSelectText (hThreadList, nThread, szThreadString);
    else
        nIndex = 0;

    dwThreadIndex    = (DWORD)SendMessage (hThreadList, LB_GETITEMDATA, nIndex, 0);

    RefreshThreadData (hWnd,
                       gpThreadObject,
                       dwThreadIndex,
                       gpProcessObject,
                       pProcessInstance);

    SendMessage (hThreadList, WM_SETREDRAW, TRUE, 0);

}




//********************************************************
//
//  PviewDlgGetCurSelPriority --
//
//      Get the process priority of currently selected process.
//
WORD    PviewDlgGetCurSelPriority (HWND hWnd)
{
    DWORD           dwIndex;
    PPERF_INSTANCE  pInst;

    dwIndex = GetCurSelData (hWnd, PVIEW_PROCESS_LIST);
    pInst = FindInstanceN (gpProcessObject, dwIndex);
    return ProcessPriority (gpProcessObject, pInst);
}




//********************************************************
//
//  PviewDlgRefreshCurSelProcess --
//
//      Refresh the data of currently selected process.
//
void    PviewDlgRefreshCurSelProcess (HWND hWnd)
{
    DWORD   dwIndex;

    dwIndex = GetCurSelData (hWnd, PVIEW_PROCESS_LIST);
    RefreshProcessData (hWnd, gpProcessObject, dwIndex);

    PviewDlgRefreshThread (hWnd);
}




//********************************************************
//
//  PviewDlgRefreshCurSelThread --
//
//      Refresh the data of currently selected thread.
//
void    PviewDlgRefreshCurSelThread (HWND hWnd)
{
    PPERF_INSTANCE  pProcessInstance;
    DWORD           dwIndex;

    dwIndex = GetCurSelData (hWnd, PVIEW_PROCESS_LIST);
    pProcessInstance = FindInstanceN (gpProcessObject, dwIndex);

    dwIndex = GetCurSelData (hWnd, PVIEW_THREAD_LIST);

    RefreshThreadData (hWnd,
                       gpThreadObject,
                       dwIndex,
                       gpProcessObject,
                       pProcessInstance);
}




//********************************************************
//
//  PviewDlgChangePriority --
//
//      Change process priority.
//
BOOL PviewDlgChangePriority (HWND hWnd, WPARAM wParam, WORD wItem)
{
    DWORD           dwIndex;
    PPERF_INSTANCE  pInst;
    PPERF_COUNTER   pCountID;
    DWORD           *pProcessID;
    DWORD           ProcessID = 0;
    HANDLE          hProcess;
    BOOL            bStat;



    dwIndex = GetCurSelData (hWnd, PVIEW_PROCESS_LIST);
    pInst = FindInstanceN (gpProcessObject, dwIndex);


    if (pCountID = FindCounter (gpProcessObject, PX_PROCESS_ID)) {
        pProcessID = (DWORD *) CounterData (pInst, pCountID);
        if (pProcessID) {
            ProcessID = *pProcessID;
        }
    } else {
        SendDlgItemMessage (hWnd, wItem, BM_SETCHECK, 1, 0);
        SetFocus (GetDlgItem (hWnd, wItem));
        MessageBox (hWnd,
                    TEXT("Cannot find ID for this process"),
                    TEXT("Set priority"),
                    MB_ICONEXCLAMATION|MB_OK);
        return FALSE;
    }


    hProcess = OpenProcess (PROCESS_SET_INFORMATION, FALSE, ProcessID);
    if (!hProcess) {
        SendDlgItemMessage (hWnd, wItem, BM_SETCHECK, 1, 0);
        SetFocus (GetDlgItem (hWnd, wItem));
        MessageBox (hWnd,
                    TEXT("Unable to open the process; Priority not changed"),
                    TEXT("Set priority"),
                    MB_ICONEXCLAMATION|MB_OK);
        return FALSE;
    }



    switch (wParam) {
        case PVIEW_PRIORITY_HIGH:
            bStat = SetPriorityClass (hProcess, HIGH_PRIORITY_CLASS);
            break;

        case PVIEW_PRIORITY_NORMAL:
            bStat = SetPriorityClass (hProcess, NORMAL_PRIORITY_CLASS);
            break;

        case PVIEW_PRIORITY_IDL:
            bStat = SetPriorityClass (hProcess, IDLE_PRIORITY_CLASS);
            break;

        default:
            break;
    }


    CloseHandle (hProcess);

    if (!bStat) {
        SendDlgItemMessage (hWnd, wItem, BM_SETCHECK, 1, 0);
        SetFocus (GetDlgItem (hWnd, wItem));
        MessageBox (hWnd,
                    TEXT("Unable to change priority"),
                    TEXT("Set priority"),
                    MB_ICONEXCLAMATION|MB_OK);
        return FALSE;
    }


    return TRUE;

}




//********************************************************
//
//  PviewDlgTerminateProcess --
//
//      Terminate the current selected process.
//
BOOL    PviewDlgTerminateProcess (HWND hPviewDlg)
{
    DWORD           dwIndex;
    PPERF_INSTANCE  pInst;
    PPERF_COUNTER   pCountID;
    DWORD           *pProcessID;
    DWORD           ProcessID;
    HANDLE          hProcess;
    TCHAR           szTemp[50];


    dwIndex = GetCurSelData (hPviewDlg, PVIEW_PROCESS_LIST);
    pInst = FindInstanceN (gpProcessObject, dwIndex);


    if (pCountID = FindCounter (gpProcessObject, PX_PROCESS_ID)) {
        pProcessID = (DWORD *) CounterData (pInst, pCountID);
        if (pProcessID) {
            ProcessID = *pProcessID;
        }
    } else {
        MessageBox (hPviewDlg,
                    TEXT("Cannot find ID for this process"),
                    TEXT("Terminate Process"),
                    MB_ICONEXCLAMATION|MB_OK);
        return FALSE;
    }


    wsprintf (szTemp, TEXT("Terminate process %s (ID %#x)?"),
              InstanceName (pInst), ProcessID);

    if (MessageBox (hPviewDlg, szTemp, TEXT("Terminate Process"), MB_ICONSTOP|MB_OKCANCEL) != IDOK)
        return FALSE;


    hProcess = OpenProcess (PROCESS_ALL_ACCESS, FALSE, ProcessID);
    if (!hProcess) {
        MessageBox (hPviewDlg,
                    TEXT("Unable to open the process; Process not terminated"),
                    TEXT("Terminate Process"),
                    MB_ICONEXCLAMATION|MB_OK);
        return FALSE;
    }


    if (!TerminateProcess (hProcess, 99)) {
        MessageBox (hPviewDlg,
                    TEXT("Unable to terminate the process."),
                    TEXT("Terminate Process"),
                    MB_ICONEXCLAMATION|MB_OK);

        CloseHandle (hProcess);
        return FALSE;
    }


    CloseHandle (hProcess);

    return TRUE;

}




/***************
MemDlg functions
***************/

//********************************************************
//
//  MemDlgProc --
//
//      MemoryDlg procedure
//
INT_PTR CALLBACK   MemDlgProc (HWND    hWnd,
                               UINT    wMsg,
                               WPARAM  wParam,
                               LPARAM  lParam)
{
    static HWND hPviewDlg;


    switch (wMsg) {
        case WM_INITDIALOG:
            hPviewDlg = (HWND)lParam;
            PostMessage (hWnd, WM_COMMAND, MEMORY_REFRESH, 0);
            break;

        case WM_QUIT:
        case WM_CLOSE:
            EndDialog (hWnd, TRUE);
            break;

        case WM_COMMAND:
            switch (LOWORD (wParam)) {
                // get the memory statistics for the currently selected
                //  process/thread
                //
                case MEMORY_IMAGE:
                    if (HIWORD(wParam) == CBN_DBLCLK || HIWORD(wParam) == CBN_SELCHANGE) {
                        if (WaitForSingleObject (ghMemUpdateMutex, 0))
                            return FALSE;

                        MemDlgRefreshCurSelImage (hWnd, hPviewDlg);
                        ReleaseMutex (ghMemUpdateMutex);
                    } else
                        return FALSE;
                    break;

                    // refresh the current memory statistics,
                    //  retry if we can't get the mutex
                    //
                case MEMORY_REFRESH:
                    if (WaitForSingleObject (ghMemUpdateMutex, 1000)) {
                        // can't get the mutex, retry...
                        //
                        PostMessage (hWnd, WM_COMMAND, MEMORY_REFRESH, 0);
                        return FALSE;
                    }

                    MemDlgRefresh (hWnd, hPviewDlg);
                    ReleaseMutex (ghMemUpdateMutex);
                    break;

                case IDCANCEL:
                case IDOK:
                    EndDialog (hWnd, TRUE);
                    break;

                default:
                    return FALSE;
            }
        default:
            return FALSE;
    }


    return TRUE;

}




//********************************************************
//
//  MemDlgUpdateThread --
//
//      This function runs in a separate thread to collect memory data.
//
void MemDlgUpdateThread (HWND hPviewDlg)
{

    ghMemUpdateMutex = CreateMutex (NULL, TRUE, NULL);
    ghMemUpdateEvent = CreateEvent (NULL, FALSE, FALSE, NULL);


    while (TRUE) {
        EnableWindow (GetDlgItem (hPviewDlg, PVIEW_MEMORY_DETAIL), FALSE);


        gpCostlyData = RefreshPerfData (ghPerfKey,
                                        INDEX_COSTLY_OBJ,
                                        gpCostlyData,
                                        &gCostlyDataSize);


        gpAddressSpaceObject  = FindObject (gpCostlyData, PX_PROCESS_ADDRESS_SPACE);
        gpThreadDetailsObject = FindObject (gpCostlyData, PX_THREAD_DETAILS);
        gpImageObject         = FindObject (gpCostlyData, PX_IMAGE);


        EnableWindow (GetDlgItem (hPviewDlg, PVIEW_MEMORY_DETAIL), TRUE);

        ReleaseMutex (ghMemUpdateMutex);

        PostMessage (hPviewDlg, WM_COMMAND, PVIEW_REFRESH_COSTLY_DATA, 0);


        WaitForSingleObject (ghMemUpdateEvent, INFINITE);
        WaitForSingleObject (ghMemUpdateMutex, INFINITE);
    }

}




//********************************************************
//
//  MemDlgRefresh --
//
//      Refresh the memory dialog.
//
void MemDlgRefresh (HWND hMemDlg, HWND hPviewDlg)
{
    HWND            hImageList;
    DWORD           dwIndex;
    BOOL            bStat;
    PPERF_INSTANCE  pInstance;


    hImageList = GetDlgItem (hMemDlg, MEMORY_IMAGE);

    SendMessage (hImageList, WM_SETREDRAW, FALSE, 0);
    SendMessage (hImageList, CB_RESETCONTENT, 0, 0);
    SendMessage (hImageList, CB_SETITEMDATA, 0, 0);

    dwIndex = GetCurSelData (hPviewDlg, PVIEW_PROCESS_LIST);
    pInstance = FindInstanceN (gpProcessObject, dwIndex);

    bStat = RefreshMemoryDlg (hMemDlg,
                              pInstance,
                              gpProcessObject,
                              gpAddressSpaceObject,
                              gpImageObject);

    SendMessage (hImageList, WM_SETREDRAW, TRUE, 0);
    SendMessage (hImageList, CB_SETCURSEL, 0, 0);

    if (!bStat) {
        MessageBox (hMemDlg,
                    TEXT("Unable to retrieve memory detail"),
                    TEXT("Memory detail"),
                    MB_ICONSTOP|MB_OK);
        PostMessage (hMemDlg, WM_CLOSE, 0, 0);
    }

}




//********************************************************
//
//  MemDlgRefreshCurSelImage --
//
//      Refresh the current selected image for memory dialog.
//
void    MemDlgRefreshCurSelImage (HWND hMemDlg, HWND hPviewDlg)
{
    HWND    hList;
    INT     nIndex;
    DWORD   dwIndex;


    hList = GetDlgItem (hMemDlg, MEMORY_IMAGE);
    nIndex = (INT)SendMessage (hList, CB_GETCURSEL, 0, 0);

    if (nIndex == CB_ERR)
        nIndex = 0;

    dwIndex = (DWORD)SendMessage (hList, CB_GETITEMDATA, nIndex, 0);

    if (dwIndex == 0xFFFFFFFF)
        MemDlgRefresh (hMemDlg, hPviewDlg);
    else
        RefreshMemoryDlgImage (hMemDlg, dwIndex, gpImageObject);

}




/****************
utility functions
****************/

//********************************************************
//
//  GetCurSelText --
//
//      Get the text of current selection.  Used for later ReSelectText().
//
INT     GetCurSelText (HWND hList, LPTSTR str)
{
    INT     Index;
    INT     Length;

    Index = (INT)SendMessage (hList, LB_GETCURSEL, 0, 0);
    SendMessage (hList, LB_GETTEXT, Index, (LPARAM)str);

    return Index;
}




//********************************************************
//
//  GetCurSelData --
//
//      Get the data associated with the current selection.
//
DWORD   GetCurSelData (HWND hWnd, DWORD dwList)
{
    HWND    hList;
    INT     nIndex;
    DWORD   dwIndex;


    hList  = GetDlgItem (hWnd, dwList);
    nIndex = (INT)SendMessage (hList, LB_GETCURSEL, 0, 0);

    if (nIndex == LB_ERR)
        nIndex = 0;

    dwIndex = (DWORD)SendMessage (hList, LB_GETITEMDATA, nIndex, 0);

    return dwIndex;
}




//********************************************************
//
//  ReSelectText --
//
//      Reselect the line specified by str.  Returns the new index.  If cannot
//      find the line or any error, then 0 is returned.
//
INT     ReSelectText (HWND hList, INT StartIndex, LPTSTR str)
{
    INT_PTR Index;
    INT     Length;
    TCHAR   SaveChar = TEXT('\0');


    Index = SendMessage (hList, LB_FINDSTRING, StartIndex, (LPARAM)str);

    if (Index == LB_ERR) {
        Length = lstrlen (str);

        while (Index == LB_ERR && Length) {
            SaveChar = str[Length-1];
            str[Length-1] = TEXT('\0');

            Index = SendMessage (hList, LB_FINDSTRING, StartIndex, (LPARAM)str);

            str[Length-1] = SaveChar;
            Length--;
        }
    }

    if (Index == LB_ERR)
        return 0;
    else {
        SendMessage (hList, LB_SETCURSEL, Index, 0);
        return (INT)Index;
    }

}




//********************************************************
//
//  SetPerfIndexes
//
//      Setup the perf data indexes.
//
void    SetPerfIndexes (HWND hWnd)
{
    LPTSTR  TitleBuffer;
    LPTSTR  *Title;
    DWORD   Last;
    TCHAR   szTemp[50];
    DWORD   dwR;


    dwR = GetPerfTitleSz (ghMachineKey, ghPerfKey, &TitleBuffer, &Title, &Last);

    if (dwR != ERROR_SUCCESS) {
        wsprintf (szTemp, TEXT("Unable to retrieve counter indexes, ERROR -> %#x"), dwR);
        MessageBox (hWnd, szTemp, TEXT("Pviewer"), MB_OK|MB_ICONEXCLAMATION);
        return;
    }


    PX_PROCESS                       = GetTitleIdx (hWnd, Title, Last, PN_PROCESS);
    PX_PROCESS_CPU                   = GetTitleIdx (hWnd, Title, Last, PN_PROCESS_CPU);
    PX_PROCESS_PRIV                  = GetTitleIdx (hWnd, Title, Last, PN_PROCESS_PRIV);
    PX_PROCESS_USER                  = GetTitleIdx (hWnd, Title, Last, PN_PROCESS_USER);
    PX_PROCESS_WORKING_SET           = GetTitleIdx (hWnd, Title, Last, PN_PROCESS_WORKING_SET);
    PX_PROCESS_PEAK_WS               = GetTitleIdx (hWnd, Title, Last, PN_PROCESS_PEAK_WS);
    PX_PROCESS_PRIO                  = GetTitleIdx (hWnd, Title, Last, PN_PROCESS_PRIO);
    PX_PROCESS_ELAPSE                = GetTitleIdx (hWnd, Title, Last, PN_PROCESS_ELAPSE);
    PX_PROCESS_ID                    = GetTitleIdx (hWnd, Title, Last, PN_PROCESS_ID);
    PX_PROCESS_PRIVATE_PAGE          = GetTitleIdx (hWnd, Title, Last, PN_PROCESS_PRIVATE_PAGE);
    PX_PROCESS_VIRTUAL_SIZE          = GetTitleIdx (hWnd, Title, Last, PN_PROCESS_VIRTUAL_SIZE);
    PX_PROCESS_PEAK_VS               = GetTitleIdx (hWnd, Title, Last, PN_PROCESS_PEAK_VS);
    PX_PROCESS_FAULT_COUNT           = GetTitleIdx (hWnd, Title, Last, PN_PROCESS_FAULT_COUNT);

    PX_THREAD                        = GetTitleIdx (hWnd, Title, Last, PN_THREAD);
    PX_THREAD_CPU                    = GetTitleIdx (hWnd, Title, Last, PN_THREAD_CPU);
    PX_THREAD_PRIV                   = GetTitleIdx (hWnd, Title, Last, PN_THREAD_PRIV);
    PX_THREAD_USER                   = GetTitleIdx (hWnd, Title, Last, PN_THREAD_USER);
    PX_THREAD_START                  = GetTitleIdx (hWnd, Title, Last, PN_THREAD_START);
    PX_THREAD_SWITCHES               = GetTitleIdx (hWnd, Title, Last, PN_THREAD_SWITCHES);
    PX_THREAD_PRIO                   = GetTitleIdx (hWnd, Title, Last, PN_THREAD_PRIO);
    PX_THREAD_BASE_PRIO              = GetTitleIdx (hWnd, Title, Last, PN_THREAD_BASE_PRIO);
    PX_THREAD_ELAPSE                 = GetTitleIdx (hWnd, Title, Last, PN_THREAD_ELAPSE);

    PX_THREAD_DETAILS                = GetTitleIdx (hWnd, Title, Last, PN_THREAD_DETAILS);
    PX_THREAD_PC                     = GetTitleIdx (hWnd, Title, Last, PN_THREAD_PC);

    PX_IMAGE                         = GetTitleIdx (hWnd, Title, Last, PN_IMAGE);
    PX_IMAGE_NOACCESS                = GetTitleIdx (hWnd, Title, Last, PN_IMAGE_NOACCESS);
    PX_IMAGE_READONLY                = GetTitleIdx (hWnd, Title, Last, PN_IMAGE_READONLY);
    PX_IMAGE_READWRITE               = GetTitleIdx (hWnd, Title, Last, PN_IMAGE_READWRITE);
    PX_IMAGE_WRITECOPY               = GetTitleIdx (hWnd, Title, Last, PN_IMAGE_WRITECOPY);
    PX_IMAGE_EXECUTABLE              = GetTitleIdx (hWnd, Title, Last, PN_IMAGE_EXECUTABLE);
    PX_IMAGE_EXE_READONLY            = GetTitleIdx (hWnd, Title, Last, PN_IMAGE_EXE_READONLY);
    PX_IMAGE_EXE_READWRITE           = GetTitleIdx (hWnd, Title, Last, PN_IMAGE_EXE_READWRITE);
    PX_IMAGE_EXE_WRITECOPY           = GetTitleIdx (hWnd, Title, Last, PN_IMAGE_EXE_WRITECOPY);

    PX_PROCESS_ADDRESS_SPACE         = GetTitleIdx (hWnd, Title, Last, PN_PROCESS_ADDRESS_SPACE);
    PX_PROCESS_PRIVATE_NOACCESS      = GetTitleIdx (hWnd, Title, Last, PN_PROCESS_PRIVATE_NOACCESS);
    PX_PROCESS_PRIVATE_READONLY      = GetTitleIdx (hWnd, Title, Last, PN_PROCESS_PRIVATE_READONLY);
    PX_PROCESS_PRIVATE_READWRITE     = GetTitleIdx (hWnd, Title, Last, PN_PROCESS_PRIVATE_READWRITE);
    PX_PROCESS_PRIVATE_WRITECOPY     = GetTitleIdx (hWnd, Title, Last, PN_PROCESS_PRIVATE_WRITECOPY);
    PX_PROCESS_PRIVATE_EXECUTABLE    = GetTitleIdx (hWnd, Title, Last, PN_PROCESS_PRIVATE_EXECUTABLE);
    PX_PROCESS_PRIVATE_EXE_READONLY  = GetTitleIdx (hWnd, Title, Last, PN_PROCESS_PRIVATE_EXE_READONLY);
    PX_PROCESS_PRIVATE_EXE_READWRITE = GetTitleIdx (hWnd, Title, Last, PN_PROCESS_PRIVATE_EXE_READWRITE);
    PX_PROCESS_PRIVATE_EXE_WRITECOPY = GetTitleIdx (hWnd, Title, Last, PN_PROCESS_PRIVATE_EXE_WRITECOPY);

    PX_PROCESS_MAPPED_NOACCESS       = GetTitleIdx (hWnd, Title, Last, PN_PROCESS_MAPPED_NOACCESS);
    PX_PROCESS_MAPPED_READONLY       = GetTitleIdx (hWnd, Title, Last, PN_PROCESS_MAPPED_READONLY);
    PX_PROCESS_MAPPED_READWRITE      = GetTitleIdx (hWnd, Title, Last, PN_PROCESS_MAPPED_READWRITE);
    PX_PROCESS_MAPPED_WRITECOPY      = GetTitleIdx (hWnd, Title, Last, PN_PROCESS_MAPPED_WRITECOPY);
    PX_PROCESS_MAPPED_EXECUTABLE     = GetTitleIdx (hWnd, Title, Last, PN_PROCESS_MAPPED_EXECUTABLE);
    PX_PROCESS_MAPPED_EXE_READONLY   = GetTitleIdx (hWnd, Title, Last, PN_PROCESS_MAPPED_EXE_READONLY);
    PX_PROCESS_MAPPED_EXE_READWRITE  = GetTitleIdx (hWnd, Title, Last, PN_PROCESS_MAPPED_EXE_READWRITE);
    PX_PROCESS_MAPPED_EXE_WRITECOPY  = GetTitleIdx (hWnd, Title, Last, PN_PROCESS_MAPPED_EXE_WRITECOPY);

    PX_PROCESS_IMAGE_NOACCESS        = GetTitleIdx (hWnd, Title, Last, PN_PROCESS_IMAGE_NOACCESS);
    PX_PROCESS_IMAGE_READONLY        = GetTitleIdx (hWnd, Title, Last, PN_PROCESS_IMAGE_READONLY);
    PX_PROCESS_IMAGE_READWRITE       = GetTitleIdx (hWnd, Title, Last, PN_PROCESS_IMAGE_READWRITE);
    PX_PROCESS_IMAGE_WRITECOPY       = GetTitleIdx (hWnd, Title, Last, PN_PROCESS_IMAGE_WRITECOPY);
    PX_PROCESS_IMAGE_EXECUTABLE      = GetTitleIdx (hWnd, Title, Last, PN_PROCESS_IMAGE_EXECUTABLE);
    PX_PROCESS_IMAGE_EXE_READONLY    = GetTitleIdx (hWnd, Title, Last, PN_PROCESS_IMAGE_EXE_READONLY);
    PX_PROCESS_IMAGE_EXE_READWRITE   = GetTitleIdx (hWnd, Title, Last, PN_PROCESS_IMAGE_EXE_READWRITE);
    PX_PROCESS_IMAGE_EXE_WRITECOPY   = GetTitleIdx (hWnd, Title, Last, PN_PROCESS_IMAGE_EXE_WRITECOPY);


    wsprintf (INDEX_PROCTHRD_OBJ, TEXT("%ld %ld"), PX_PROCESS, PX_THREAD);
    wsprintf (INDEX_COSTLY_OBJ, TEXT("%ld %ld %ld"),
              PX_PROCESS_ADDRESS_SPACE, PX_IMAGE, PX_THREAD_DETAILS);


    LocalFree (TitleBuffer);
    LocalFree (Title);

}




//********************************************************
//
//  GetTitleIdx
//
//      Searches Titles[] for Name.  Returns the index found.
//
DWORD   GetTitleIdx (HWND hWnd, LPTSTR Title[], DWORD LastIndex, LPTSTR Name)
{
    DWORD   Index;

    for (Index = 0; Index <= LastIndex; Index++)
        if (Title[Index])
            if (!lstrcmpi (Title[Index], Name))
                return Index;

    MessageBox (hWnd, Name, TEXT("Pviewer cannot find index"), MB_OK);
    return 0;
}




//********************************************************
//
//  SetListBoxTabStops --
//
//      Set tab stops in the two list boxes.
//
void    SetListBoxTabStops (HWND hWnd)
{
    HWND    hListBox;
    INT     Tabs[4] = {22*4, 36*4, 44*4};

    hListBox = GetDlgItem (hWnd, PVIEW_PROCESS_LIST);
    SendMessage (hListBox, LB_SETTABSTOPS, 3, (DWORD_PTR)Tabs);

    hListBox = GetDlgItem (hWnd, PVIEW_THREAD_LIST);
    SendMessage (hListBox, LB_SETTABSTOPS, 3, (DWORD_PTR)Tabs);
}




//********************************************************
//
//  SetLocalMachine --
//
//      Set local machine as performance data focus.
//
//      Sets    ghPerfKey
//              ghMachineKey
//              gszMachineName
//              gszCurrentMachine
//
void    SetLocalMachine (void)
{
    TCHAR   szName[MACHINE_NAME_SIZE];
    DWORD   dwSize = MACHINE_NAME_SIZE;


    // close remote connections, if any
    //
    if (ghPerfKey != HKEY_PERFORMANCE_DATA)
        RegCloseKey (ghPerfKey);

    if (ghMachineKey != HKEY_LOCAL_MACHINE)
        RegCloseKey (ghMachineKey);


    // set to registry keys on local machine
    //
    ghPerfKey    = HKEY_PERFORMANCE_DATA;
    ghMachineKey = HKEY_LOCAL_MACHINE;



    // get computer name
    GetComputerName (szName, &dwSize);



    if (szName[0] != '\\' || szName[1] != '\\') {     // must have two '\\'
        wsprintf (gszMachineName, TEXT("\\\\%s"), szName);
        lstrcpy (gszCurrentMachine, gszMachineName);
    } else {
        lstrcpy (gszMachineName, szName);
        lstrcpy (gszCurrentMachine, gszMachineName);
    }

}




//********************************************************
//
//  ConnectComputer --
//
//      Connect to a computer with name entered in PVIEW_COMPUTER.
//      If a new connection is made, then return TRUE else return FALSE.
//
//      Sets    gszCurrentMachine
//              ghPerfKey
//              ghMachineKey
//
BOOL    ConnectComputer (HWND hWnd)
{
    DWORD   dwR;
    HKEY    hKey;
    TCHAR   szTemp[MACHINE_NAME_SIZE];
    TCHAR   szTemp2[MACHINE_NAME_SIZE+100];
    BOOL    bResult = TRUE;
    MSG     Msg;

    SetCursor (ghCursor[1]);

    if (!GetDlgItemText (hWnd, PVIEW_COMPUTER, szTemp, sizeof (szTemp)/sizeof(TCHAR))) {
        SetLocalMachine ();
        SetDlgItemText (hWnd, PVIEW_COMPUTER, gszCurrentMachine);
    }

    else if (!lstrcmpi (szTemp, gszCurrentMachine))     // didn't change name
        bResult = FALSE;

    else if (!lstrcmpi (szTemp, gszMachineName)) {        // local machine
        SetLocalMachine ();
        EnableControls (hWnd);
    }

    else {
        // a remote machine, connect to it
        //
        dwR = RegConnectRegistry (szTemp, HKEY_PERFORMANCE_DATA, &hKey);

        if (dwR != ERROR_SUCCESS) {
            wsprintf (szTemp2, TEXT("Cannot connect to computer %s"), szTemp);
            MessageBox (hWnd, szTemp2, TEXT(""), MB_ICONEXCLAMATION|MB_OK);

            SetDlgItemText (hWnd, PVIEW_COMPUTER, gszCurrentMachine);

            bResult = FALSE;
        } else {
            // connected
            //
            lstrcpy (gszCurrentMachine, szTemp);

            if (ghPerfKey != HKEY_PERFORMANCE_DATA)
                RegCloseKey (ghPerfKey);

            ghPerfKey = hKey;



            DisableControls (hWnd);



            // we also need to get the remote machine's title indexes.
            //
            dwR = RegConnectRegistry (gszCurrentMachine, HKEY_LOCAL_MACHINE, &hKey);

            if (ghMachineKey != HKEY_LOCAL_MACHINE)
                RegCloseKey (ghMachineKey);

            if (dwR == ERROR_SUCCESS)
                ghMachineKey = hKey;
            else
                // unable to connect, so we'll use our own indexes.
                //
                ghMachineKey = HKEY_LOCAL_MACHINE;
        }
    }



    // Remove all mouse and key messages. They are not accepted
    //  while the cursor is a hourglass.
    //
    while (PeekMessage (&Msg, hWnd, WM_MOUSEFIRST, WM_MOUSELAST, PM_REMOVE));
    while (PeekMessage (&Msg, hWnd, WM_KEYFIRST, WM_KEYLAST, PM_REMOVE));

    SetCursor (ghCursor[0]);


    EnableWindow (GetDlgItem (hWnd, PVIEW_CONNECT), FALSE);


    return bResult;

}




//********************************************************
//
//  DisableControls --
//
//      Disable controls that don't make sense on remote machine
//
void DisableControls (HWND hPviewDlg)
{
    EnableWindow (GetDlgItem (hPviewDlg, PVIEW_TERMINATE), FALSE);
    EnableWindow (GetDlgItem (hPviewDlg, PVIEW_PRIORITY_HIGH), FALSE);
    EnableWindow (GetDlgItem (hPviewDlg, PVIEW_PRIORITY_NORMAL), FALSE);
    EnableWindow (GetDlgItem (hPviewDlg, PVIEW_PRIORITY_IDL), FALSE);
}




//********************************************************
//
//  EnableControls --
//
//      Enable controls disabled by DisableControl().
//
void EnableControls (HWND hPviewDlg)
{
    EnableWindow (GetDlgItem (hPviewDlg, PVIEW_TERMINATE), TRUE);
    EnableWindow (GetDlgItem (hPviewDlg, PVIEW_PRIORITY_HIGH), TRUE);
    EnableWindow (GetDlgItem (hPviewDlg, PVIEW_PRIORITY_NORMAL), TRUE);
    EnableWindow (GetDlgItem (hPviewDlg, PVIEW_PRIORITY_IDL), TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\qfecheck\qfecheck.c ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    qfecheck.c

Abstract:



Author:

    Alan Back (alanbac) 11-30-00

Environment:

    Windows 2000

Revision History:

--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ctype.h>
#include <stdio.h>

#include <windows.h>    // includes basic windows functionality
#include <string.h>     // includes the string functions
#include <stdlib.h>
#include <imagehlp.h>

#include "setupapi.h"   // includes the inf setup api
#include "spapip.h"

#include <tchar.h>
#include <mscat.h>
#include <softpub.h>

#include "qfecheck.h"

#define MISC_BUF_SIZE 4096

//
// Globals
//
CHAR MiscBuffer2[ MISC_BUF_SIZE * 2];
CHAR System32Directory[ MAX_PATH ];
CHAR CmdLineLocation[MAX_PATH * 2 ];
CHAR ComputerName[ MAX_PATH ];
HANDLE LogFile = NULL;
BOOL QuietMode = FALSE;
BOOL Verbose = FALSE;
BOOL DoLogging = FALSE;
OSVERSIONINFOEX osvi;
GUID DriverVerifyGuid = DRIVER_ACTION_VERIFY;

//
// pointers to the crypto functions we call
//
PCRYPTCATADMINACQUIRECONTEXT pCryptCATAdminAcquireContext;
PCRYPTCATADMINRELEASECONTEXT pCryptCATAdminReleaseContext;
PCRYPTCATADMINCALCHASHFROMFILEHANDLE pCryptCATAdminCalcHashFromFileHandle;
PCRYPTCATADMINENUMCATALOGFROMHASH pCryptCATAdminEnumCatalogFromHash;
PCRYPTCATCATALOGINFOFROMCONTEXT pCryptCATCatalogInfoFromContext;
PCRYPTCATADMINRELEASECATALOGCONTEXT pCryptCATAdminReleaseCatalogContext;
PWINVERIFYTRUST pWinVerifyTrust;

PMULTIBYTETOUNICODE pMultiByteToUnicode;

typedef HANDLE (WINAPI *CONNECTTOSFCSERVER)(PCWSTR);
typedef BOOL   (WINAPI *ISFILEPROTECTED)(HANDLE, LPCWSTR);
typedef VOID   (WINAPI *CLOSESFC)(HANDLE);


VOID _cdecl
main(
    int argc,
    char * argv[]
    )
{
    CHAR   MiscBuffer[ MISC_BUF_SIZE ];
    LPSTR  p;
    CHAR   szSourcePath[ MAX_PATH ];
    CHAR   LogName[ MAX_PATH ];
    DWORD  LogNameSize = sizeof( LogName );

    //
    // Get the command line stuff
    //
    if ( !ParseArgs( argc, argv )) {
        LoadString(NULL, STR_USAGE, MiscBuffer, sizeof(MiscBuffer));
        PrintStringToConsole( MiscBuffer );
        return;
    }



    //
    // Get Version and SP info
    //
    osvi.dwOSVersionInfoSize = sizeof( osvi );
    GetVersionEx( (LPOSVERSIONINFO)&osvi );

    //
    // Don't run on anything less than Windows 2000
    //
    if ( osvi.dwMajorVersion < 5 ) {
        LoadString(NULL, STR_USAGE, MiscBuffer, sizeof(MiscBuffer));
        PrintStringToConsole( MiscBuffer );
        return;
    }


    if ( !GetSystemDirectory( System32Directory, sizeof( System32Directory ))) {
        LoadString(NULL, STR_NO_SYSDIR, MiscBuffer, sizeof(MiscBuffer));
        PrintStringToConsole( MiscBuffer );
        return;
    }


    //
    // Get the computername and use it for the log file name.
    // If the user input a path location for the logfile, use it.
    // Otherwise, use the current directory (or failing that, system32).
    //
    if ( !GetComputerName( ComputerName, &LogNameSize )) {
        LoadString(NULL, STR_GETCOMPUTERNAME_FAILED, MiscBuffer, sizeof(MiscBuffer));
        PrintStringToConsole( MiscBuffer );
        return;
    }

    if ( DoLogging ) {

        strcpy( LogName, ComputerName );
        strcat( LogName, ".log" );


        if ( CmdLineLocation[0] ) {

            if (( GetFileAttributes( CmdLineLocation ) & FILE_ATTRIBUTE_DIRECTORY ) == 0 ) {
                LoadString(NULL, STR_USAGE, MiscBuffer, sizeof(MiscBuffer));
                PrintStringToConsole( MiscBuffer );
                return;
            }
            CombinePaths( CmdLineLocation, LogName, szSourcePath );

        } else {

            GetModuleFileName( NULL, szSourcePath, sizeof( szSourcePath ));

            p = strrchr( szSourcePath, '\\' );

            if ( p ) {
                *p = 0;
            } else {
                strcpy( szSourcePath, System32Directory );
            }

            CombinePaths( szSourcePath, LogName, szSourcePath );
        }


        //
        // Initialize the logfile using the machinename for the logfilename.
        //
        if ( !InitializeLog( TRUE, szSourcePath ) ) {
            LoadString(NULL, STR_LOGFILE_INIT_FAILED, MiscBuffer, sizeof(MiscBuffer));
            PrintStringToConsole( MiscBuffer );
            return;
        }
    }



    //
    // OK, now check that each of the files on the system match
    // what the hotfix info says should be there.
    //
    LogHeader();

    if ( !ListNonMatchingHotfixes()) {
        LogItem( STR_NO_HOTFIXES_FOUND, NULL );
    }
    LogItem( 0, "\r\n" );

    if ( DoLogging ) {
        TerminateLog();
    }

    return;

}



DWORD GetCSDVersion(VOID)

/*++

Routine Description:

    Get the CSD Version number (to compare Service Pack number with)

Return Value:

    The CSD Version number from the registry.

--*/
{
    NTSTATUS status;
    HKEY     hCSDKey;
    DWORD    cbValue;
    DWORD    dwType;
    DWORD    dwLocalCSDVersion;
    TCHAR    szWindows[] = TEXT("SYSTEM\\CurrentControlSet\\Control\\Windows");
    TCHAR    szCSD[]   = TEXT("CSDVersion");

    status = RegOpenKeyEx(
                HKEY_LOCAL_MACHINE,
                szWindows,
                0,
                KEY_READ,
                &hCSDKey
                );

    if (status != ERROR_SUCCESS){
        return(0);
    }

    cbValue = sizeof(DWORD);
    status  = RegQueryValueEx(
                 hCSDKey,
                 szCSD,
                 NULL,     // Reserved
                 &dwType,
                 (PVOID)&dwLocalCSDVersion,
                 &cbValue  // size in bytes returned
                 );

    RegCloseKey(hCSDKey);

    if ((status != ERROR_SUCCESS) ||
        (dwType != REG_DWORD)) {
        return(0);
    }

    return (dwLocalCSDVersion);
}




VOID
LogHeader(
    VOID
    )
{
    CHAR   szInstallDate[MAX_PATH];
    LARGE_INTEGER CurrentTime;
    LARGE_INTEGER LocalTime;
    TIME_FIELDS TimeFields;


    //
    //  Log the product name.  Prior check for < W2K prevents
    //  need for additional checks here.
    //
    if (( osvi.dwMajorVersion == 5 ) &&
        ( osvi.dwMinorVersion == 0 )) {

        LogItem( STR_VALIDATION_REPORT_W2K , NULL );

    } else if (( osvi.dwMajorVersion == 5 ) &&
               ( osvi.dwMinorVersion == 1 )) {

        LogItem( STR_VALIDATION_REPORT_XP, NULL );

    }


    LogItem( 0, ComputerName );
    //
    // Get the current system time
    //
    NtQuerySystemTime ( &CurrentTime );
    RtlSystemTimeToLocalTime( &CurrentTime, &LocalTime );
    RtlTimeToTimeFields( &LocalTime, &TimeFields );
    sprintf( szInstallDate,
             "%d/%d/%d  %d:%02d%s",
             TimeFields.Month,
             TimeFields.Day,
             TimeFields.Year,
             (TimeFields.Hour % 12 == 0 ) ? 12 : TimeFields.Hour % 12,
             TimeFields.Minute,
             TimeFields.Hour >= 12 ? "pm" : "am" );
    LogItem( STR_REPORT_DATE, NULL );
    LogItem( 0, szInstallDate );

    LogItem( STR_SP_LEVEL, NULL );
    if ( GetCSDVersion() != 0 ) {
        LogItem( 0, osvi.szCSDVersion );
    } else {
        LogItem( STR_NO_SP_INSTALLED, NULL );
    }
    LogItem( STR_HOTFIXES_ID, NULL );
}


LPSTR
CombinePaths(
    IN  LPCSTR ParentPath,
    IN  LPCSTR ChildPath,
    OUT LPSTR  TargetPath   // can be same as ParentPath if want to append
    )
{
    ULONG ParentLength = strlen( ParentPath );
    LPSTR p;

    if ( ParentPath != TargetPath ) {
        memcpy( TargetPath, ParentPath, ParentLength );
        }

    p = TargetPath + ParentLength;

    if (( ParentLength > 0 )   &&
        ( *( p - 1 ) != '\\' ) &&
        ( *( p - 1 ) != '/'  )) {
        *p++ = '\\';
        }

    strcpy( p, (ChildPath[0] != '\\') ? ChildPath : ChildPath+1 );

    return TargetPath;
}


BOOL
ListNonMatchingHotfixes(
    VOID
    )
/*++

Routine Description:

    Check out each of the files listed under each SP and hotfix, and
    1) Check that the files present on the system have correct version info and
    2) Check that the files present on the system have valid signatures in the
       installed catalogs.

Arguments:

    None

Return Value:

    FALSE if no hotfixes were found on the system.

--*/
{
    char psz[MAX_PATH];
    DWORD cch = MAX_PATH;
    FILETIME ft;
    NTSTATUS status;
    DWORD i;
    DWORD j;
    DWORD h;
    DWORD cbValue;
    DWORD dwType;
    char lpFileName[MAX_PATH];
    char lpFileLocation[MAX_PATH];
    char lpFileVersion[MAX_PATH];
    char szRegW2K[MAX_PATH];
    char szRegSP[MAX_PATH];
    char szRegHotfix[MAX_PATH];
    char szFilelist[MAX_PATH];
    char szHotfixNumber[MAX_PATH];
    char szSPNumber[MAX_PATH];
    HKEY hW2KMainKey = 0;
    HKEY hHotfixMainKey = 0;
    HKEY hHotfixKey = 0;
    HKEY hFilelistKey = 0;
    DWORDLONG FileVersion;
    DWORDLONG TargetVersion;
    CHAR MiscBuffer1[ MISC_BUF_SIZE ];
    CHAR LogBuffer[ MISC_BUF_SIZE ];
    BOOL bIsHotfixWhacked;
    BOOL bIsSigInvalid;
    BOOL bAnyHotfixesInstalled = FALSE;
    LPWSTR FileName;
    LPWSTR FileLocation;
    HCATADMIN hCat = NULL;
    HANDLE hFileHandle = NULL;
    HANDLE hSfcServer = NULL;
    HINSTANCE hLibSfc = NULL;
    HMODULE hModuleWinTrust = NULL;
    HMODULE hModuleMsCat = NULL;
    HMODULE hModuleSetupApi = NULL;
    ISFILEPROTECTED IsFileProtected;
    CONNECTTOSFCSERVER ConnectToSfcServer;

    if (( osvi.dwMajorVersion == 5 ) &&
        ( osvi.dwMinorVersion == 0 )) {

        strcpy( szRegW2K, "SOFTWARE\\Microsoft\\Updates\\Windows 2000\\" );

    } else if (( osvi.dwMajorVersion == 5 ) &&
               ( osvi.dwMinorVersion == 1 )) {

        strcpy( szRegW2K, "SOFTWARE\\Microsoft\\Updates\\Windows XP\\" );
   }

    if (RegOpenKeyEx(
           HKEY_LOCAL_MACHINE,
           szRegW2K,
           0,
           KEY_READ,
           &hW2KMainKey
           ) != ERROR_SUCCESS) {

        goto BailOut;
    }

    //
    // Get function names for all the crypto routines that we're going to call
    //
    hModuleWinTrust = LoadLibrary( "wintrust.dll" );
    if ( hModuleWinTrust == NULL ) {
        goto BailOut;
    }

    hModuleMsCat = LoadLibrary( "mscat32.dll" );
    if ( hModuleMsCat == NULL ) {
        goto BailOut;
    }

    hModuleSetupApi = LoadLibrary("setupapi.dll");
    if(hModuleSetupApi == NULL) {
        goto BailOut;
    }

    pWinVerifyTrust = (PWINVERIFYTRUST)GetProcAddress( hModuleWinTrust, "WinVerifyTrust" );

    pCryptCATAdminAcquireContext = (PCRYPTCATADMINACQUIRECONTEXT)GetProcAddress( hModuleMsCat, "CryptCATAdminAcquireContext" );
    pCryptCATAdminReleaseContext = (PCRYPTCATADMINRELEASECONTEXT)GetProcAddress( hModuleMsCat, "CryptCATAdminReleaseContext" );
    pCryptCATAdminCalcHashFromFileHandle = (PCRYPTCATADMINCALCHASHFROMFILEHANDLE)GetProcAddress( hModuleMsCat, "CryptCATAdminCalcHashFromFileHandle" );
    pCryptCATAdminEnumCatalogFromHash = (PCRYPTCATADMINENUMCATALOGFROMHASH)GetProcAddress( hModuleMsCat, "CryptCATAdminEnumCatalogFromHash" );
    pCryptCATCatalogInfoFromContext = (PCRYPTCATCATALOGINFOFROMCONTEXT)GetProcAddress( hModuleMsCat, "CryptCATCatalogInfoFromContext" );
    pCryptCATAdminReleaseCatalogContext = (PCRYPTCATADMINRELEASECATALOGCONTEXT)GetProcAddress( hModuleMsCat, "CryptCATAdminReleaseCatalogContext" );

    // Attempt to get Win2k version
    pMultiByteToUnicode = (PMULTIBYTETOUNICODE)GetProcAddress(hModuleSetupApi, "MultiByteToUnicode");

    // Attempt to get Whistler version
    if(pMultiByteToUnicode == NULL) {
        pMultiByteToUnicode = (PMULTIBYTETOUNICODE)GetProcAddress(hModuleSetupApi, "pSetupMultiByteToUnicode");
    }

    // Fail
    if(pMultiByteToUnicode == NULL) {
        goto BailOut;
    }


    pCryptCATAdminAcquireContext( &hCat, &DriverVerifyGuid, 0 );


    //
    // Get the addresses for the SFC function calls
    //
    if ( (hLibSfc = LoadLibrary("SFC.DLL")) != NULL ) {

        ConnectToSfcServer = (CONNECTTOSFCSERVER)GetProcAddress( hLibSfc, (LPCSTR)0x00000003 );
        if ( ConnectToSfcServer == NULL ) {
            goto BailOut;
        }

        hSfcServer = ConnectToSfcServer( NULL );
        if ( hSfcServer == NULL ) {
            goto BailOut;
        }

        IsFileProtected = (ISFILEPROTECTED)GetProcAddress( hLibSfc, "SfcIsFileProtected" );
        if ( IsFileProtected == NULL ) {
            goto BailOut;
        }
    } else {
        goto BailOut;
    }


    //
    // Now cycle through all the hotfixes stored in the registry
    //
    h = 0;
    while ( RegEnumKeyEx( hW2KMainKey,
                          h,
                          szSPNumber,
                          &cch,
                          NULL,
                          NULL,
                          NULL,
                          &ft ) == ERROR_SUCCESS ) {


        strcpy( szRegSP, szRegW2K );
        strcat( szRegSP, szSPNumber );
        strcat( szRegSP, "\\" );

        if (RegOpenKeyEx(
               HKEY_LOCAL_MACHINE,
               szRegSP,
               0,
               KEY_READ,
               &hHotfixMainKey
               ) != ERROR_SUCCESS) {

            goto BailOut;
        }

        i = 0;
        cch = MAX_PATH;
        while ( RegEnumKeyEx( hHotfixMainKey,
                              i,
                              szHotfixNumber,
                              &cch,
                              NULL,
                              NULL,
                              NULL,
                              &ft ) == ERROR_SUCCESS ) {

            strcpy( szRegHotfix, szRegSP );
            strcat( szRegHotfix, szHotfixNumber );
            strcat( szRegHotfix, "\\Filelist\\" );

            strcpy( LogBuffer, szHotfixNumber );
            strcat( LogBuffer, ":  " );
            LogItem( 0, "\r\n" );
            LogItem( 0, LogBuffer );
            bIsHotfixWhacked = FALSE;
            bIsSigInvalid = FALSE;
            bAnyHotfixesInstalled = TRUE;

            if ( RegOpenKeyEx(
                    HKEY_LOCAL_MACHINE,
                    szRegHotfix,
                    0,
                    KEY_READ,
                    &hHotfixKey
                    ) == ERROR_SUCCESS) {

                j = 0;
                cch = MAX_PATH;
                while ( RegEnumKeyEx( hHotfixKey,
                                      j,
                                      psz,
                                      &cch,
                                      NULL,
                                      NULL,
                                      NULL,
                                      &ft ) == ERROR_SUCCESS ) {

                     //
                     // At this point, szFilelist is something like:
                     // HKLM\SOFTWARE\Microsoft\Updates\Windows 2000\SP2\Q123456\Filelist
                     //

                     strcpy( szFilelist, szRegHotfix );
                     strcat( szFilelist, psz );

                     if ( RegOpenKeyEx(
                             HKEY_LOCAL_MACHINE,
                             szFilelist,
                             0,
                             KEY_READ,
                             &hFilelistKey
                             ) == ERROR_SUCCESS) {

                         //
                         // Get all the values out of the registry we care about:
                         // File location, name, and version string.
                         //
                         cbValue = MAX_PATH;
                         status  = RegQueryValueEx(
                                        hFilelistKey,
                                        "FileName",
                                        NULL,     // Reserved
                                        &dwType,
                                        lpFileName,     // Buffer
                                        &cbValue  // size in bytes returned
                                        );

                         if ( status != ERROR_SUCCESS ) {
                             goto BailOut;
                         }

                         cbValue = MAX_PATH;
                         status  = RegQueryValueEx(
                                        hFilelistKey,
                                        "Location",
                                        NULL,     // Reserved
                                        &dwType,
                                        lpFileLocation,     // Buffer
                                        &cbValue  // size in bytes returned
                                        );

                         if ( status != ERROR_SUCCESS ) {
                             goto BailOut;
                         }

                         cbValue = MAX_PATH;
                         status  = RegQueryValueEx(
                                        hFilelistKey,
                                        "Version",
                                        NULL,     // Reserved
                                        &dwType,
                                        lpFileVersion,     // Buffer
                                        &cbValue  // size in bytes returned
                                        );

                         if ( status != ERROR_SUCCESS ) {
                             continue;
                         }

                         //
                         // Now see if the file in question got whacked by SFC
                         //
                         if ( ConvertVersionStringToQuad( lpFileVersion, &FileVersion )) {

                             CombinePaths( lpFileLocation, lpFileName, lpFileLocation );

                             if (( MyGetFileVersion( lpFileLocation, &TargetVersion )) &&
                                 ( TargetVersion < FileVersion )) {

                                 if ( !bIsHotfixWhacked ) {
                                     LogItem( STR_REINSTALL_HOTFIX, NULL );
                                     if ( Verbose ) {
                                         LogItem( STR_FILES_MISSING, NULL );
                                     }
                                 }
                                 if ( Verbose ) {
                                     LogItem( 0, "\t\t" );
                                     LogItem( 0, _strupr( lpFileLocation ));
                                     LogItem( 0, "\r\n" );
                                 }
                                 bIsHotfixWhacked = TRUE;
                             }
                         }
                     }
                     j++;
                     cch = MAX_PATH;
                }

                //
                // Now do it again, but this time check each files' hash
                // against the installed catalog files.
                //
                j = 0;
                cch = MAX_PATH;
                while ( RegEnumKeyEx( hHotfixKey,
                                      j,
                                      psz,
                                      &cch,
                                      NULL,
                                      NULL,
                                      NULL,
                                      &ft ) == ERROR_SUCCESS ) {

                     //
                     // At this point, szFilelist is something like:
                     // HKLM\SOFTWARE\Microsoft\Updates\Windows 2000\SP2\Q123456\Filelist
                     //

                     strcpy( szFilelist, szRegHotfix );
                     strcat( szFilelist, psz );

                     if ( RegOpenKeyEx(
                             HKEY_LOCAL_MACHINE,
                             szFilelist,
                             0,
                             KEY_READ,
                             &hFilelistKey
                             ) == ERROR_SUCCESS) {

                         //
                         // Get all the values out of the registry we care about:
                         // File location, name, and version string.
                         //
                         cbValue = MAX_PATH;
                         status  = RegQueryValueEx(
                                        hFilelistKey,
                                        "FileName",
                                        NULL,     // Reserved
                                        &dwType,
                                        lpFileName,     // Buffer
                                        &cbValue  // size in bytes returned
                                        );

                         if ( status != ERROR_SUCCESS ) {
                             goto BailOut;
                         }

                         cbValue = MAX_PATH;
                         status  = RegQueryValueEx(
                                        hFilelistKey,
                                        "Location",
                                        NULL,     // Reserved
                                        &dwType,
                                        lpFileLocation,     // Buffer
                                        &cbValue  // size in bytes returned
                                        );

                         if ( status != ERROR_SUCCESS ) {
                             goto BailOut;
                         }

                         //
                         // Now see if the file in question has a hash
                         // in an installed cat file.
                         //
                         CombinePaths( lpFileLocation, lpFileName, lpFileLocation );
                         FileName     = pMultiByteToUnicode( (LPSTR)lpFileName, CP_ACP );
                         FileLocation = pMultiByteToUnicode( (LPSTR)lpFileLocation, CP_ACP );
                         hFileHandle = CreateFile( lpFileLocation,
                                                   GENERIC_READ,
                                                   FILE_SHARE_READ,
                                                   NULL,
                                                   OPEN_EXISTING,
                                                   0,
                                                   NULL
                                                   );
                         if ( hFileHandle == INVALID_HANDLE_VALUE ) {
                             continue;
                         }

                         if ( IsFileProtected( hSfcServer, FileLocation )) {
                             if ( !ValidateFileSignature(
                                                         hCat,
                                                         hFileHandle,
                                                         FileName,
                                                         FileLocation
                                                         )) {

                                 if ( !bIsHotfixWhacked && !bIsSigInvalid ) {
                                     LogItem( STR_REINSTALL_HOTFIX, NULL );
                                 }
                                 if ( Verbose && !bIsSigInvalid ) {
                                     LogItem( STR_NO_MATCHING_SIG, NULL );
                                 }
                                 if ( Verbose ) {
                                     LogItem( 0, "\t\t" );
                                     LogItem( 0, _strupr( lpFileLocation ));
                                     LogItem( 0, "\r\n" );
                                 }
                                 bIsSigInvalid = TRUE;
                             }
                         }
                         if ( hFileHandle ) {
                             CloseHandle( hFileHandle );
                         }
                     }
                     j++;
                     cch = MAX_PATH;
                }
            }
            i++;
            cch = MAX_PATH;
            if ( !bIsHotfixWhacked && !bIsSigInvalid ) {
                LogItem( STR_HOTFIX_CURRENT, NULL );
            }
        }
        h++;
        cch = MAX_PATH;
    }
BailOut:

    if ( hHotfixMainKey ) {
        CloseHandle( hHotfixMainKey );
    }
    if ( hHotfixKey ) {
        CloseHandle( hHotfixKey );
    }
    if ( hFilelistKey ) {
        CloseHandle( hFilelistKey );
    }
    if ( hSfcServer ) {
        CLOSESFC CloseSfc = (CLOSESFC)GetProcAddress( hLibSfc, (LPCSTR)0x00000004 );
        if ( CloseSfc != NULL ) {
            CloseSfc( hSfcServer );
        }
    }
    if ( hCat ) {
        pCryptCATAdminReleaseContext( hCat, 0 );
    }
    if ( hLibSfc ) {
        FreeLibrary( hLibSfc );
    }
    if ( hModuleWinTrust ) {
        FreeLibrary( hModuleWinTrust );
    }
    if ( hModuleMsCat ) {
        FreeLibrary( hModuleMsCat );
    }
    if(hModuleSetupApi) {
        FreeLibrary(hModuleSetupApi);
    }

    return bAnyHotfixesInstalled;
}


BOOL
MyGetFileVersion(
    IN  LPCSTR     FileName,
    OUT DWORDLONG *Version
    )
    {
    BOOL  Success = FALSE;
    DWORD Blah;
    DWORD Size;

    Size = GetFileVersionInfoSize( (LPSTR)FileName, &Blah );

    if ( Size ) {

        PVOID Buffer = malloc( Size );

        if ( Buffer ) {

            if ( GetFileVersionInfo( (LPSTR)FileName, 0, Size, Buffer )) {

                VS_FIXEDFILEINFO *VersionInfo;

                if ( VerQueryValue( Buffer, "\\", &VersionInfo, &Blah )) {

                    *Version = (DWORDLONG)( VersionInfo->dwFileVersionMS ) << 32
                             | (DWORDLONG)( VersionInfo->dwFileVersionLS );

                    Success = TRUE;

                    }
                }

            free( Buffer );

            }
        }

    return Success;
    }


BOOL
ConvertVersionStringToQuad(
    IN  LPCSTR     lpFileVersion,
    OUT DWORDLONG *FileVersion
    )
{
    WORD FileverMSUW = 0;
    WORD FileverMSLW = 0;
    WORD FileverLSUW = 0;
    WORD FileverLSLW = 0;
    CHAR *p, *q, *r, *s, *t, *u, *w;

    p = strchr( lpFileVersion, '.' );

    if ( p ) {
        q = p + 1;
        *p = 0;
	FileverMSUW = (WORD)atoi( lpFileVersion );

        r = strchr( q, '.' );
        if ( r ) {
            s = r + 1;
            *r = 0;
	    FileverMSLW = (WORD)atoi( q );

            t = strchr( s, '.' );
            if ( t ) {
                u = t + 1;
                *t = 0;
		FileverLSUW = (WORD)atoi( s );
		FileverLSLW = (WORD)atoi( u );

            } else {
               return FALSE;
            }
        } else {
           return FALSE;
        }
    } else {
       return FALSE;
    }

    *FileVersion = (DWORDLONG)( FileverMSUW ) << 48
                 | (DWORDLONG)( FileverMSLW ) << 32
                 | (DWORDLONG)( FileverLSUW ) << 16
                 | (DWORDLONG)( FileverLSLW );


    return TRUE;
}



BOOL
InitializeLog(
    BOOL WipeLogFile,
    LPCSTR NameOfLogFile
    )
{
    //
    // If we're wiping the logfile clean, attempt to delete
    // what's there.
    //
    if ( WipeLogFile ) {
        SetFileAttributes( NameOfLogFile, FILE_ATTRIBUTE_NORMAL );
        DeleteFile( NameOfLogFile );
    }

    //
    // Open/create the file.
    //
    LogFile = CreateFile(
                        NameOfLogFile,
                        GENERIC_READ | GENERIC_WRITE,
                        FILE_SHARE_READ | FILE_SHARE_WRITE,
                        NULL,
                        OPEN_ALWAYS,
                        FILE_ATTRIBUTE_NORMAL,
                        NULL
                        );

    if ( LogFile == INVALID_HANDLE_VALUE ) {
        LogFile = NULL;
    }

    return( LogFile != NULL );
}


VOID
TerminateLog(
    VOID
    )
{
    if( LogFile ) {
        CloseHandle( LogFile );
        LogFile = NULL;
    }
}


BOOL
LogItem(
    IN DWORD  Description,
    IN LPCSTR LogString
    )
{
    BOOL b = FALSE;
    DWORD BytesWritten;
    CHAR TextBuffer[ MISC_BUF_SIZE ];

    if ( !Description ) {
        //
        // Description of 0 means use the passed in LogString instead
        //
        strcpy( TextBuffer, LogString );

    } else {
        //
        // Get the string from the resource
        //
        LoadString( NULL, Description, TextBuffer, sizeof(TextBuffer) );
    }

    PrintStringToConsole( TextBuffer );

    if ( LogFile ) {
        //
        // Make sure we write to current end of file.
        //
        SetFilePointer( LogFile, 0, NULL, FILE_END );

        //
        // Write the text.
        //
        b = WriteFile(
                      LogFile,
                      TextBuffer,
                      strlen(TextBuffer),
                      &BytesWritten,
                      NULL
                      );
    } else {
        //
        // No logging, just return success
        //
        b = TRUE;
    }

    return( b );
}


void
MyLowerString(
    IN PWSTR String,
    IN ULONG StringLength  // in characters
    )
{
    ULONG i;

    for (i=0; i<StringLength; i++) {
        String[i] = towlower(String[i]);
    }
}



BOOL
ValidateFileSignature(
    IN HCATADMIN hCatAdmin,
    IN HANDLE RealFileHandle,
    IN PCWSTR BaseFileName,
    IN PCWSTR CompleteFileName
    )
/*++

Routine Description:

    Checks if the signature for a given file is valid using WinVerifyTrust

Arguments:

    hCatAdmin      - admin context handle for checking file signature
    RealFileHandle - file handle to the file to be verified
    BaseFileName   - filename without the path of the file to be verified
    CompleteFileName - fully qualified filename with path

Return Value:

    TRUE if the file has a valid signature.

--*/
{
    BOOL rVal = FALSE;
    DWORD HashSize;
    LPBYTE Hash = NULL;
    ULONG SigErr = ERROR_SUCCESS;
    WINTRUST_DATA WintrustData;
    WINTRUST_CATALOG_INFO WintrustCatalogInfo;
    WINTRUST_FILE_INFO WintrustFileInfo;
    WCHAR UnicodeKey[MAX_PATH];
    HCATINFO PrevCat;
    HCATINFO hCatInfo;
    CATALOG_INFO CatInfo;

    //
    // initialize some of the structure that we will pass into winverifytrust.
    // we don't know if we're checking against a catalog or directly against a
    // file at this point
    //
    ZeroMemory(&WintrustData, sizeof(WINTRUST_DATA));
    WintrustData.cbStruct = sizeof(WINTRUST_DATA);
    WintrustData.dwUIChoice = WTD_UI_NONE;
    WintrustData.fdwRevocationChecks = WTD_REVOKE_NONE;
    WintrustData.dwStateAction = WTD_STATEACTION_IGNORE;
    WintrustData.pCatalog = &WintrustCatalogInfo;
    WintrustData.dwProvFlags = WTD_REVOCATION_CHECK_NONE;
    Hash = NULL;

    //
    // we first calculate a hash for our file.  start with a reasonable
    // hash size and grow larger as needed
    //
    HashSize = 100;
    do {
        Hash = LocalAlloc( LPTR, HashSize );
        if(!Hash) {
            SigErr = ERROR_NOT_ENOUGH_MEMORY;
            break;
        }
        if(pCryptCATAdminCalcHashFromFileHandle(RealFileHandle,
                                                &HashSize,
                                                Hash,
                                                0)) {
            SigErr = ERROR_SUCCESS;
        } else {
            SigErr = GetLastError();
            //
            // If this API did screw up and not set last error, go ahead
            // and set something.
            //
            if(SigErr == ERROR_SUCCESS) {
                SigErr = ERROR_INVALID_DATA;
            }
            LocalFree( Hash );
            Hash = NULL;  // reset this so we won't try to free it later
            if(SigErr != ERROR_INSUFFICIENT_BUFFER) {
                //
                // The API failed for some reason other than
                // buffer-too-small.  We gotta bail.
                //
                break;
            }
        }
    } while (SigErr != ERROR_SUCCESS);

    if (SigErr != ERROR_SUCCESS) {
        //
        // if we failed at this point there are a few reasons:
        //
        //
        // 1) a bug in this code
        // 2) we are in a low memory situation
        // 3) the file's hash cannot be calculated on purpose (in the case
        //    of a catalog file, a hash cannot be calculated because a catalog
        //    cannot sign another catalog.  In this case, we check to see if
        //    the file is "self-signed".
        hCatInfo = NULL;
        goto selfsign;
    }

    //
    // Now we have the file's hash.  Initialize the structures that
    // will be used later on in calls to WinVerifyTrust.
    //
    WintrustData.dwUnionChoice = WTD_CHOICE_CATALOG;
    ZeroMemory(&WintrustCatalogInfo, sizeof(WINTRUST_CATALOG_INFO));
    WintrustCatalogInfo.cbStruct = sizeof(WINTRUST_CATALOG_INFO);
    WintrustCatalogInfo.pbCalculatedFileHash = Hash;
    WintrustCatalogInfo.cbCalculatedFileHash = HashSize;

    //
    // WinVerifyTrust is case-sensitive, so ensure that the key
    // being used is all lower-case!
    //
    // Copy the key to a writable Unicode character buffer so we
    // can lower-case it.
    //
    wcsncpy(UnicodeKey, BaseFileName, (sizeof(UnicodeKey)/sizeof(WCHAR)));
    MyLowerString(UnicodeKey, wcslen(UnicodeKey));
    WintrustCatalogInfo.pcwszMemberTag = UnicodeKey;

    //
    // Search through installed catalogs looking for those that
    // contain data for a file with the hash we just calculated.
    //
    PrevCat = NULL;
    hCatInfo = pCryptCATAdminEnumCatalogFromHash(
        hCatAdmin,
        Hash,
        HashSize,
        0,
        &PrevCat
        );
    if (hCatInfo == NULL) {
        SigErr = GetLastError();
    }

    while(hCatInfo) {

        CatInfo.cbStruct = sizeof(CATALOG_INFO);
        if (pCryptCATCatalogInfoFromContext(hCatInfo, &CatInfo, 0)) {

            //
            // Attempt to validate against each catalog we
            // enumerate.  Note that the catalog file info we
            // get back gives us a fully qualified path.
            //

            WintrustData.dwStateAction = WTD_STATEACTION_AUTO_CACHE_FLUSH;
            WintrustCatalogInfo.pcwszCatalogFilePath = CatInfo.wszCatalogFile;

            SigErr = (DWORD)pWinVerifyTrust(
                    NULL,
                    &DriverVerifyGuid,
                    &WintrustData
                    );


            WintrustData.dwStateAction = WTD_STATEACTION_IGNORE;

            //
            // NOTE:  Because we're using cached
            // catalog information (i.e., the
            // WTD_STATEACTION_AUTO_CACHE flag), we
            // don't need to explicitly validate the
            // catalog itself first.
            //
            WintrustCatalogInfo.pcwszCatalogFilePath = CatInfo.wszCatalogFile;

            SigErr = (DWORD)pWinVerifyTrust(
                NULL,
                &DriverVerifyGuid,
                &WintrustData
                );

            //
            // If the result of the above validations is
            // success, then we're done.
            //
            if(SigErr == ERROR_SUCCESS) {
                //
                // BugBug: wierd API :
                // in the success case, we must release the catalog info handle
                // in the failure case, we implicitly free PrevCat
                // if we explicitly free the catalog, we will double free the
                // handle!!!
                //
                pCryptCATAdminReleaseCatalogContext(hCatAdmin,hCatInfo,0);
                break;
            }
        }

        PrevCat = hCatInfo;
        hCatInfo = pCryptCATAdminEnumCatalogFromHash(hCatAdmin, Hash, HashSize, 0, &PrevCat);
    }

selfsign:

    if (hCatInfo == NULL) {
        //
        // We exhausted all the applicable catalogs without
        // finding the one we needed.
        //
        SigErr = GetLastError();
        //
        // Make sure we have a valid error code.
        //
        if(SigErr == ERROR_SUCCESS) {
            SigErr = ERROR_INVALID_DATA;
        }

        //
        // The file failed to validate using the specified
        // catalog.  See if the file validates without a
        // catalog (i.e., the file contains its own
        // signature).
        //
        WintrustData.dwUnionChoice = WTD_CHOICE_FILE;
        WintrustData.pFile = &WintrustFileInfo;
        ZeroMemory(&WintrustFileInfo, sizeof(WINTRUST_FILE_INFO));
        WintrustFileInfo.cbStruct = sizeof(WINTRUST_FILE_INFO);
        WintrustFileInfo.pcwszFilePath = CompleteFileName;
        WintrustFileInfo.hFile = RealFileHandle;

        SigErr = (DWORD)pWinVerifyTrust(
            NULL,
            &DriverVerifyGuid,
            &WintrustData
            );
        if(SigErr != ERROR_SUCCESS) {
            //
            // in this case the file is not in any of our catalogs
            // and it does not contain its own signature
            //
        }
    }

    if(SigErr == ERROR_SUCCESS) {
        rVal = TRUE;
    }

    if (Hash) {
        LocalFree( Hash );
    }
    return rVal;
}


VOID
PrintStringToConsole(
    IN LPCSTR StringToPrint
    )
{
    if ( !QuietMode ) {
        printf( StringToPrint );
    }
}



BOOL
ParseArgs(
    IN int  argc,
    IN char **argv
    )
{
    int i = 1;
    int j;

    while( i < argc ) {
        switch (*argv[i]) {

        case '/' :
            case '-' :

                ++argv[i];

                switch( *argv[i] ) {

                    case 'v':
                    case 'V':
                        Verbose = TRUE;
                        break;

                    case 'q':
                    case 'Q':
                        QuietMode = TRUE;
                        break;

                    case 'l':
                    case 'L':
                        DoLogging = TRUE;
                        ++argv[i];
                        if ( *argv[i] == ':' ) {
                            ++argv[i];
                        } else {
                            break;
                        }
                        if ( *argv[i] ) {
                            strcpy( CmdLineLocation, argv[i]);
                        } else {
                            return FALSE;
                        }
                        break;

                    default:
                        return FALSE;
                }
                break;

            default:
                return FALSE;

        }
    i++;
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\qfecheck\qfecheck.h ===
//
// Function prototypes
//

LPSTR
CombinePaths(
    IN  LPCSTR ParentPath,
    IN  LPCSTR ChildPath,
    OUT LPSTR  TargetPath
    );

BOOL
MyGetFileVersion(
    IN  LPCSTR     FileName,
    OUT DWORDLONG *Version
    );

BOOL
ConvertVersionStringToQuad(
    IN  LPCSTR     lpFileVersion,
    OUT DWORDLONG *FileVersion
    );

BOOL
InitializeLog(
    BOOL WipeLogFile,
    LPCSTR NameOfLogFile
    );

VOID
TerminateLog(
    VOID
    );

BOOL
LogItem(
    IN DWORD  Description,
    IN LPCSTR LogString
    );

BOOL
ValidateFileSignature(
    IN HCATADMIN hCatAdmin,
    IN HANDLE RealFileHandle,
    IN PCWSTR BaseFileName,
    IN PCWSTR CompleteFileName
    );

VOID
PrintStringToConsole(
    IN LPCSTR StringToPrint
    );

VOID
LogHeader(
    VOID
    );

BOOL
ParseArgs(
    IN int  argc,
    IN char **argv
    );

BOOL
ListNonMatchingHotfixes(
    VOID
    );

VOID _cdecl main( int,char ** );

//
// more prototypes
//

typedef BOOL
(WINAPI *PCRYPTCATADMINACQUIRECONTEXT)(
    OUT HCATADMIN *phCatAdmin,
    IN const GUID *pgSubsystem,
    IN DWORD dwFlags
    );

typedef BOOL
(WINAPI *PCRYPTCATADMINRELEASECONTEXT)(
    IN HCATADMIN hCatAdmin,
    IN DWORD dwFlags
    );

typedef BOOL
(WINAPI *PCRYPTCATADMINCALCHASHFROMFILEHANDLE)(
    IN HANDLE hFile,
    IN OUT DWORD *pcbHash,
    OUT OPTIONAL BYTE *pbHash,
    IN DWORD dwFlags
    );

typedef HCATINFO
(WINAPI *PCRYPTCATADMINENUMCATALOGFROMHASH)(
    IN HCATADMIN hCatAdmin,
    IN BYTE *pbHash,
    IN DWORD cbHash,
    IN DWORD dwFlags,
    IN OUT HCATINFO *phPrevCatInfo
    );

typedef LONG
(WINAPI *PWINVERIFYTRUST)(
    HWND hwnd,
    GUID *pgActionID,
    LPVOID pWVTData
    );

typedef BOOL
(WINAPI *PCRYPTCATCATALOGINFOFROMCONTEXT)(
    IN HCATINFO hCatInfo,
    IN OUT CATALOG_INFO *psCatInfo,
    IN DWORD dwFlags
    );

typedef BOOL
(WINAPI *PCRYPTCATADMINRELEASECATALOGCONTEXT)(
    IN HCATADMIN hCatAdmin,
    IN HCATINFO hCatInfo,
    IN DWORD dwFlags
    );

typedef PWSTR
(WINAPI *PMULTIBYTETOUNICODE)(
    IN PCSTR String,
    IN UINT Code
    );

extern PCRYPTCATADMINACQUIRECONTEXT pCryptCATAdminAcquireContext;
extern PCRYPTCATADMINRELEASECONTEXT pCryptCATAdminReleaseContext;
extern PCRYPTCATADMINCALCHASHFROMFILEHANDLE pCryptCATAdminCalcHashFromFileHandle;
extern PCRYPTCATADMINENUMCATALOGFROMHASH pCryptCATAdminEnumCatalogFromHash;
extern PCRYPTCATCATALOGINFOFROMCONTEXT pCryptCATCatalogInfoFromContext;
extern PCRYPTCATADMINRELEASECATALOGCONTEXT pCryptCATAdminReleaseCatalogContext;
extern PWINVERIFYTRUST pWinVerifyTrust;


//
// Strings
//
#define STR_NO_SYSDIR                        0xff00
#define STR_INVALID_OS_VER                   0xff01
#define STR_USAGE                            0xff02
#define STR_LOGFILE_INIT_FAILED              0xff03
#define STR_FILES_MISSING                    0xff04
#define STR_HOTFIX_CURRENT                   0xff05
#define STR_GETCOMPUTERNAME_FAILED           0xff06
//      available                            0xff07
#define STR_REPORT_DATE                      0xff08
#define STR_SP_LEVEL                         0xff09
#define STR_HOTFIXES_ID                      0xff0a
#define STR_NO_HOTFIXES_FOUND                0xff0b
#define STR_NO_MATCHING_SIG                  0xff0c
#define STR_REINSTALL_HOTFIX                 0xff0d
#define STR_NO_SP_INSTALLED                  0xff0e
//      available                            0xff0f
#define STR_VALIDATION_REPORT_W2K            0xff10
#define STR_VALIDATION_REPORT_XP             0xff11
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\qgrep\qgrep.c ===
/*static char *SCCSID = "@(#)qgrep.c    13.11 90/08/14";*/
/*
 * QGrep
 *
 * Modification History:
 *
 *         Aug 1990     PeteS       Created.
 *             1990     DaveGi      Ported to Cruiser
 *      31-Oct-1990     W-Barry     Removed the #ifdef M_I386 'cause this
 *                                  code will never see 16bit again.
 */

#include                <stdio.h>
#include                <time.h>
#include                <stdlib.h>
#include                <string.h>
#include                <fcntl.h>
#include                <io.h>
#include                <windows.h>
#include                <ctype.h>
#include                <assert.h>

/*
 *  Miscellaneous constants and macros
 */

#define FILBUFLEN       (SECTORLEN*16)  /* File buffer length */
#define FILNAMLEN       80              /* File name length */
#define ISCOT           0x0002          /* Handle is console output */
#define LG2SECLEN       10              /* Log base two of sector length */
#define LNOLEN          12              /* Maximum line number length */
#define MAXSTRLEN       128             /* Maximum search string length */
#define OUTBUFLEN       (SECTORLEN*2)   /* Output buffer length */
#define PATHLEN         128             /* Path buffer length */
#define SECTORLEN       (1 << LG2SECLEN)/* Sector length */
#define STKLEN          512             /* Stack length in bytes */
#define TRTABLEN        256             /* Translation table length */
#define s_text(x)       (((char *)(x)) - ((x)->s_must))
/* Text field access macro */
#define EOS             ('\r')          /* End of string */


/*
 *  Bit flag definitions
 */

#define SHOWNAME        0x01            /* Print filename */
#define NAMEONLY        0x02            /* Print filename only */
#define LINENOS         0x04            /* Print line numbers */
#define BEGLINE         0x08            /* Match at beginning of line */
#define ENDLINE         0x10            /* Match at end of line */
#define DEBUG           0x20            /* Print debugging output */
#define TIMER           0x40            /* Time execution */
#define SEEKOFF         0x80            /* Print seek offsets */
#define ZLINENOS        0x100           /* Print MEP style line numbers */
#define DOQUOTES        0x200           /* Handle quoted strings in -f search file */


/*
 *  Type definitions
 */

typedef struct stringnode {
    struct stringnode   *s_alt;         /* List of alternates */
    struct stringnode   *s_suf;         /* List of suffixes */
    size_t               s_must;        /* Length of portion that must match */
}
STRINGNODE;     /* String node */

typedef ULONG           CBIO;           /* I/O byte count */
typedef ULONG           PARM;           /* Generic parameter */

typedef CBIO            *PCBIO;         /* Pointer to I/O byte count */
typedef PARM            *PPARM;         /* Pointer to generic parameter */


/*
 *  Global data
 */

char                    filbuf[FILBUFLEN*2L + 12];
char                    outbuf[OUTBUFLEN*2];
char                    td1[TRTABLEN] = { 0};
UINT_PTR                cchmin = (UINT_PTR)-1; /* Minimum string length */
UINT_PTR                chmax = 0;      /* Maximum character */
UINT_PTR                chmin = (UINT_PTR)-1; /* Minimum character */
char                    transtab[TRTABLEN] = { 0};
STRINGNODE              *stringlist[TRTABLEN/2];
int                     casesen = 1;    /* Assume case-sensitivity */
long                    cbfile;         /* Number of bytes in file */
static int              clists = 1;     /* One is first available index */
int                     filbuflen = FILBUFLEN;
/* File buffer length */
int                     flags;          /* Flags */
unsigned                lineno;         /* Current line number */
char                    *program;       /* Program name */
int                     status = 1;     /* Assume failure */
int                     strcnt = 0;     /* String count */
char                    target[MAXSTRLEN];
/* Last string added */
size_t                  targetlen;      /* Length of last string added */
unsigned                waste;          /* Wasted storage in heap */
int                     arrc;           /* I/O return code for DOSREAD */
char                    asyncio;        /* Asynchronous I/O flag */
int                     awrc = TRUE;    /* I/O return code for DOSWRITE */
char                    *bufptr[] = { filbuf + 4, filbuf + FILBUFLEN + 8};
CBIO                    cbread;         /* Bytes read by DOSREAD */
CBIO                    cbwrite;        /* Bytes written by DOSWRITE */
char                    *obuf[] = { outbuf, outbuf + OUTBUFLEN};
int                     ocnt[] = { OUTBUFLEN, OUTBUFLEN};
int                     oi = 0;         /* Output buffer index */
char                    *optr[] = { outbuf, outbuf + OUTBUFLEN};
char                    pmode;          /* Protected mode flag */
char                    *t2buf;         /* Async read buffer */
int                     t2buflen;       /* Async read buffer length */
HANDLE                  t2fd;           /* Async read file */
char                    *t3buf;         /* Async write buffer */
int                     t3buflen;       /* Async write buffer length */
HANDLE                  t3fd;           /* Async write file */

HANDLE                  readdone;       /* Async read done semaphore */
HANDLE                  readpending;    /* Async read pending semaphore */
HANDLE                  writedone;      /* Async write done semaphore */
HANDLE                  writepending;   /* Async write pending semaphore */

/*
 *  External functions and forward references
 */

void    addexpr( char *, int );                      /* See QMATCH.C */
void    addstring( char *, int );                    /* See below */
int     countlines( char *, char * );
char    *findexpr( unsigned char *, char *);         /* See QMATCH.C */
char    *findlist( unsigned char *, char * );
char    *findone( unsigned char *buffer, char *bufend );
void    flush1buf( void );                           /* See below */
void    flush1nobuf( void );                         /* See below */
int     grepbuffer( char *, char *, char * );        /* See below */
int     isexpr( unsigned char *, int );              /* See QMATCH.C */
void    matchstrings( char *, char *, int, size_t *, int * );
size_t  preveol( char * );
size_t  strncspn( char *, char *, size_t );
size_t  strnspn( char *, char *, size_t );
char    *strnupr( char *pch, int cch );
void    write1buf( char *, size_t );                    /* See below */
void    (*addstr)( char *, int ) = NULL;
char    *(*find)( unsigned char *, char * ) = NULL;
void    (*flush1)( void ) = flush1buf;
int     (*grep)( char *, char *, char * ) = grepbuffer;
void    (*write1)( char *, size_t ) = write1buf;


#include "windows.h"


void
ConvertAppToOem(
                unsigned argc,
                char* argv[]
                )
/*++

Routine Description:

    Converts the command line from ANSI to OEM, and force the app
    to use OEM APIs

Arguments:

    argc - Standard C argument count.

    argv - Standard C argument strings.

Return Value:

    None.

--*/

{
    unsigned i;

    for ( i=0; i<argc; i++ ) {
        CharToOem( argv[i], argv[i] );
    }
    SetFileApisToOEM();
}




void
error(
      char *mes
      )
{
    fprintf(stderr,"%s: %s\n",program,mes);
    /* Print message */
    exit(2);                            /* Die */
}


char *
alloc(
      size_t size
      )
{
    char                *cp;            /* Char pointer */

    if ((cp = malloc(size)) == NULL) {     /* If allocation fails */
        fprintf(stderr,"%s: Out of memory (%u)\n",program,waste);
        /* Write error message */
        exit(2);                        /* Die */
    }
    return(cp);                         /* Return pointer to buffer */
}


void
freenode(
         STRINGNODE *x
         )
{
    register STRINGNODE *y;             /* Pointer to next node in list */

    while (x != NULL) {                 /* While not at end of list */
        if (x->s_suf != NULL)
            freenode(x->s_suf);         /* Free suffix list if not end */
        else
            --strcnt;                   /* Else decrement string count */
        y = x;                          /* Save pointer */
        x = x->s_alt;                   /* Move down the list */
        free((char *)((INT_PTR) s_text(y) & ~(sizeof(DWORD_PTR)-1)));
        /* Free the node */
    }
}


STRINGNODE *
newnode(
        char *s,
        size_t n
        )
{
    register STRINGNODE *new;           /* Pointer to new node */
    char                *t;             /* String pointer */
    size_t               d;             /* rounds to a dword boundary */

    d = n & (sizeof(DWORD_PTR)-1) ? sizeof(DWORD_PTR) - (n & (sizeof(DWORD_PTR)-1)) : 0;        /* offset to next dword past n */
    t = alloc(sizeof(STRINGNODE) + n + d);
    /* Allocate string node */
    t += d;                             /* END of string word-aligned */
    strncpy(t,s,n);                     /* Copy string text */
    new = (STRINGNODE *)(t + n);        /* Set pointer to node */
    new->s_alt = NULL;                  /* No alternates yet */
    new->s_suf = NULL;                  /* No suffixes yet */
    new->s_must = n;                    /* Set string length */
    return(new);                        /* Return pointer to new node */
}


STRINGNODE *
reallocnode(
            STRINGNODE *node,
            char *s,
            int n
            )
{
    register char       *cp;            /* Char pointer */

    assert(n <= node->s_must);          /* Node must not grow */
    waste += (unsigned)(node->s_must - n);
    /* Add in wasted space */
    assert(sizeof(char *) == sizeof(INT_PTR));
    /* Optimizer should eliminate this */
    cp = (char *)((INT_PTR) s_text(node) & ~(sizeof(DWORD_PTR)-1));
    /* Point to start of text */
    node->s_must = n;                   /* Set new length */
    if (n & (sizeof(DWORD_PTR)-1)) 
         cp += sizeof(DWORD_PTR) - (n & (sizeof(DWORD_PTR)-1));        /* Adjust non dword-aligned string */
    memmove(cp,s,n);                    /* Copy new text */
    cp += n;                            /* Skip over new text */
    memmove(cp,node,sizeof(STRINGNODE));/* Copy the node */
    return((STRINGNODE *) cp);          /* Return pointer to moved node */
}


/***    maketd1 - add entry for TD1 shift table
 *
 *      This function fills in the TD1 table for the given
 *      search string.  The idea is adapted from Daniel M.
 *      Sunday's QuickSearch algorithm as described in an
 *      article in the August 1990 issue of "Communications
 *      of the ACM".  As described, the algorithm is suitable
 *      for single-string searches.  The idea to extend it for
 *      multiple search strings is mine and is described below.
 *
 *              Think of searching for a match as shifting the search
 *              pattern p of length n over the source text s until the
 *              search pattern is aligned with matching text or until
 *              the end of the source text is reached.
 *
 *              At any point when we find a mismatch, we know
 *              we will shift our pattern to the right in the
 *              source text at least one position.  Thus,
 *              whenever we find a mismatch, we know the character
 *              s[n] will figure in our next attempt to match.
 *
 *              For some character c, TD1[c] is the 1-based index
 *              from right to left of the first occurrence of c
 *              in p.  Put another way, it is the count of places
 *              to shift p to the right on s so that the rightmost
 *              c in p is aligned with s[n].  If p does not contain
 *              c, then TD1[c] = n + 1, meaning we shift p to align
 *              p[0] with s[n + 1] and try our next match there.
 *
 *              Computing TD1 for a single string is easy:
 *
 *                      memset(TD1,n + 1,sizeof TD1);
 *                      for (i = 0; i < n; ++i) {
 *                          TD1[p[i]] = n - i;
 *                      }
 *
 *              Generalizing this computation to a case where there
 *              are multiple strings of differing lengths is trickier.
 *              The key is to generate a TD1 that is as conservative
 *              as necessary, meaning that no shift value can be larger
 *              than one plus the length of the shortest string for
 *              which you are looking.  The other key is to realize
 *              that you must treat each string as though it were only
 *              as long as the shortest string.  This is best illustrated
 *              with an example.  Consider the following two strings:
 *
 *              DYNAMIC PROCEDURE
 *              7654321 927614321
 *
 *              The numbers under each letter indicate the values of the
 *              TD1 entries if we computed the array for each string
 *              separately.  Taking the union of these two sets, and taking
 *              the smallest value where there are conflicts would yield
 *              the following TD1:
 *
 *              DYNAMICPODURE
 *              7654321974321
 *
 *              Note that TD1['P'] equals 9; since n, the length of our
 *              shortest string is 7, we know we should not have any
 *              shift value larger than 8.  If we clamp our shift values
 *              to this value, then we get
 *
 *              DYNAMICPODURE
 *              7654321874321
 *
 *              Already, this looks fishy, but let's try it out on
 *              s = "DYNAMPROCEDURE".  We know we should match on
 *              the trailing procedure, but watch:
 *
 *              DYNAMPROCEDURE
 *              ^^^^^^^|
 *
 *              Since DYNAMPR doesn't match one of our search strings,
 *              we look at TD1[s[n]] == TD1['O'] == 7.  Applying this
 *              shift, we get
 *
 *              DYNAMPROCEDURE
 *                     ^^^^^^^
 *
 *              As you can see, by shifting 7, we have gone too far, and
 *              we miss our match.  When computing TD1 for "PROCEDURE",
 *              we must take only the first 7 characters, "PROCEDU".
 *              Any trailing characters can be ignored (!) since they
 *              have no effect on matching the first 7 characters of
 *              the string.  Our modified TD1 then becomes
 *
 *              DYNAMICPODURE
 *              7654321752163
 *
 *              When applied to s, we get TD1[s[n]] == TD1['O'] == 5,
 *              leaving us with
 *
 *              DYNAMPROCEDURE
 *                   ^^^^^^^
 *              which is just where we need to be to match on "PROCEDURE".
 *
 *      Going to this algorithm has speeded qgrep up on multi-string
 *      searches from 20-30%.  The all-C version with this algorithm
 *      became as fast or faster than the C+ASM version of the old
 *      algorithm.  Thank you, Daniel Sunday, for your inspiration!
 *
 *      Note: if we are case-insensitive, then we expect the input
 *      string to be upper-cased on entry to this routine.
 *
 *      Pete Stewart, August 14, 1990.
 */

void
maketd1(
        unsigned char *pch,
        UINT_PTR cch,
        UINT_PTR cchstart
        )
{
    UINT_PTR ch;                        /* Character */
    UINT_PTR i;                         /* String index */

    if ((cch += cchstart) > cchmin)
        cch = cchmin;                   /* Use smaller count */
    for (i = cchstart; i < cch; ++i) {  /* Examine each char left to right */
        ch = *pch++;                    /* Get the character */
        for (;;) {                      /* Loop to set up entries */
            if (ch < chmin)
                chmin = ch;             /* Remember if smallest */
            if (ch > chmax)
                chmax = ch;             /* Remember if largest */
            if (cchmin - i < (UINT_PTR) td1[ch])
                td1[ch] = (unsigned char)(cchmin - i);
            /* Set value if smaller than previous */
            if (casesen || !isascii((int)ch) || !isupper((int)ch))
                break;                  /* Exit loop if done */
            ch = tolower((int)ch);          /* Force to lower case */
        }
    }
}

static int
newstring(
          char *s,
          size_t n
          )
{
    register STRINGNODE *cur;           /* Current string */
    register STRINGNODE **pprev;        /* Pointer to previous link */
    STRINGNODE          *new;           /* New string */
    size_t              i;              /* Index */
    size_t              j;              /* Count */
    int                 k;              /* Count */

    if ( (UINT_PTR)n < cchmin)
        cchmin = n;                     /* Remember length of shortest string */
    if ((i = transtab[*s]) == 0) {         /* If no existing list */
        /*
         *  We have to start a new list
         */
        if ((i = clists++) >= TRTABLEN/2) error("Too many string lists");
        /* Die if too many string lists */
        stringlist[i] = NULL;           /* Initialize */
        transtab[*s] = (char) i;        /* Set pointer to new list */
        if (!casesen && isalpha(*s)) transtab[*s ^ '\040'] = (char) i;
        /* Set pointer for other case */
    } else if (stringlist[i] == NULL) return(0);
    /* Check for existing 1-byte string */
    if (--n == 0) {                        /* If 1-byte string */
        freenode(stringlist[i]);        /* Free any existing stuff */
        stringlist[i] = NULL;           /* No record here */
        ++strcnt;                       /* We have a new string */
        return(1);                      /* String added */
    }
    ++s;                                /* Skip first char */
    pprev = stringlist + i;             /* Get pointer to link */
    cur = *pprev;                       /* Get pointer to node */
    while (cur != NULL) {                  /* Loop to traverse match tree */
        i = (n > cur->s_must)? cur->s_must: n;
        /* Find minimum of string lengths */
        matchstrings(s,s_text(cur),i,&j,&k);
        /* Compare the strings */
        if (j == 0) {                      /* If complete mismatch */
            if (k < 0) break;            /* Break if insertion point found */
            pprev = &(cur->s_alt);      /* Get pointer to alternate link */
            cur = *pprev;               /* Follow the link */
        } else if (i == j) {                 /* Else if strings matched */
            if (i == n) {                  /* If new is prefix of current */
                cur = *pprev = reallocnode(cur,s_text(cur),n);
                /* Shorten text of node */
                if (cur->s_suf != NULL) {  /* If there are suffixes */
                    freenode(cur->s_suf);
                    /* Suffixes no longer needed */
                    cur->s_suf = NULL;
                    ++strcnt;           /* Account for this string */
                }
                return(1);              /* String added */
            }
            pprev = &(cur->s_suf);      /* Get pointer to suffix link */
            if ((cur = *pprev) == NULL) return(0);
            /* Done if current is prefix of new */
            s += i;                     /* Skip matched portion */
            n -= i;
        } else                            /* Else partial match */ {
            /*
             *  We must split an existing node.
             *  This is the trickiest case.
             */
            new = newnode(s_text(cur) + j,cur->s_must - j);
            /* Unmatched part of current string */
            cur = *pprev = reallocnode(cur,s_text(cur),j);
            /* Set length to matched portion */
            new->s_suf = cur->s_suf;    /* Current string's suffixes */
            if (k < 0) {                   /* If new preceded current */
                cur->s_suf = newnode(s + j,n - j);
                /* FIrst suffix is new string */
                cur->s_suf->s_alt = new;/* Alternate is part of current */
            } else                        /* Else new followed current */ {
                new->s_alt = newnode(s + j,n - j);
                /* Unmatched new string is alternate */
                cur->s_suf = new;       /* New suffix list */
            }
            ++strcnt;                   /* One more string */
            return(1);                  /* String added */
        }
    }
    *pprev = newnode(s,n);              /* Set pointer to new node */
    (*pprev)->s_alt = cur;              /* Attach alternates */
    ++strcnt;                           /* One more string */
    return(1);                          /* String added */
}


void
addstring(
          char *s,
          int n
          )
{
    int                 endline;        /* Match-at-end-of-line flag */
    register char       *pch;           /* Char pointer */

    endline = flags & ENDLINE;          /* Initialize flag */
    pch = target;                       /* Initialize pointer */
    while (n-- > 0) {                      /* While not at end of string */
        switch (*pch = *s++) {             /* Switch on character */
            case '\\':                  /* Escape */
                if (n > 0 && !isalnum(*s)) { /* If next character "special" */
                    --n;                  /* Decrement counter */
                    *pch = *s++;          /* Copy next character */
                }
                ++pch;                    /* Increment pointer */
                break;

            case '$':                   /* Special end character */
                if (n == 0) {                /* If end of string */
                    endline = ENDLINE;    /* Set flag */
                    break;                /* Exit switch */
                }
                /* Drop through */

            default:                    /* All others */
                ++pch;                    /* Increment pointer */
                break;
        }
    }
    if (endline)
        *pch++ = EOS;           /* Add end character if needed */
    targetlen = (int)(pch - target);     /* Compute target string length */
    if (!casesen)
        strnupr(target, targetlen);      /* Force to upper case if necessary */
    newstring(target, targetlen);        /* Add string */
}


int
addstrings(
           char *buffer,
           char *bufend,
           char *seplist
           )
{
    size_t len;            /* String length */

    while (buffer < bufend) {              /* While buffer not empty */
        len = strnspn(buffer, seplist, (size_t)(bufend - buffer));
        /* Count leading separators */
        if ((buffer += len) >= bufend) {
            break;                      /* Skip leading separators */
        }
        len = strncspn(buffer,seplist,(size_t)(bufend - buffer));
        /* Get length of search string */
        if (addstr == NULL) {
            addstr = isexpr( buffer, len ) ? addexpr : addstring;
            /* Select search string type */
        }
        if ( addstr == addexpr || (flags & BEGLINE) ||
             findlist( buffer, buffer + len ) == NULL) {                             /* If no match within string */
            (*addstr)(buffer,len);      /* Add string to list */
        }
        buffer += len;                  /* Skip the string */
    }
    return(0);                          /* Keep looking */
}


int
enumlist(
         STRINGNODE *node,
         int cchprev
         )
{
    int                 i;              /* Counter */
    int                 strcnt;         /* String count */

    strcnt = 0;                         /* Initialize */
    while (node != NULL) {                 /* While not at end of list */
        maketd1(s_text(node),node->s_must,cchprev);
        /* Make TD1 entries */
        if (flags & DEBUG) {              /* If verbose output wanted */
            for (i = 0; i < cchprev; ++i)
                fputc(' ',stderr);      /* Indent line */
            fwrite(s_text(node),sizeof(char),node->s_must,stderr);
            /* Write this portion */
            fprintf(stderr,"\n");       /* Newline */
        }
        strcnt += (node->s_suf != NULL)?
                  enumlist(node->s_suf,cchprev + node->s_must): 1;
        /* Recurse to do suffixes */
        node = node->s_alt;             /* Do next alternate in list */
    }
    return(strcnt? strcnt: 1);          /* Return string count */
}


int
enumstrings()
{
    char                ch;             /* Character */
    int                 i;              /* Index */
    int                 strcnt;         /* String count */

    strcnt = 0;                         /* Initialize */
    for (i = 0; i < TRTABLEN; ++i) {       /* Loop through translation table */
        if (casesen || !isascii(i) || !islower(i)) {                             /* If case sensitive or not lower */
            if (transtab[i] == 0)
                continue;               /* Skip null entries */
            ch = (char) i;              /* Get character */
            maketd1(&ch,1,0);           /* Make TD1 entry */
            if (flags & DEBUG)
                fprintf(stderr,"%c\n",i);
            /* Print the first byte */
            strcnt += enumlist(stringlist[transtab[i]],1);
            /* Enumerate the list */
        }
    }
    return(strcnt);                     /* Return string count */
}

HANDLE
openfile(
         char *name
         )
{
    HANDLE              fd;             /* File descriptor */
    DWORD               er;

    if ((fd = CreateFile( name, GENERIC_READ, FILE_SHARE_READ | FILE_SHARE_WRITE, NULL, OPEN_EXISTING, 0, NULL ) ) == (HANDLE)-1)
    /* If error opening file */
    {
        er = GetLastError();
        fprintf(stderr,"%s: Cannot open %s (error = %x)\n",program,name,er);
        /* Print error message */
    }
    return( fd );                       /* Return file descriptor */
}

void
thread2()       /* Read thread */
{
    for (;;) {                             /* Loop while there is work to do */
        if ((WaitForSingleObject(readpending, (DWORD)-1L) != NO_ERROR)
            || (ResetEvent(readpending)              != TRUE)) {
            break;                      /* Exit loop if event error */
        }
        arrc = ReadFile(t2fd,(PVOID)t2buf,t2buflen, &cbread, NULL);
        /* Do the read */
        SetEvent( readdone );           /* Signal read completed */
    }
    error("Thread 2 semaphore error");  /* Print error message and die */
}


void
thread3()       /* Write thread */
{
    for (;;) {                             /* Loop while there is work to do */
        if ((WaitForSingleObject(writepending,(DWORD)-1L) != NO_ERROR)
            || (ResetEvent(writepending)              != TRUE)) {
            break;              /* Exit loop if event error */
        }
        awrc = WriteFile(t3fd,(PVOID)t3buf,t3buflen, &cbwrite, NULL);
        /* Do the write */
        SetEvent( writedone );          /* Signal write completed */
    }
    error("Thread 3 semaphore error");  /* Print error message and die */
}


void
startread(
          HANDLE fd,
          char *buffer,
          int buflen
          )
{
    if ( asyncio ) {                               /* If asynchronous I/O */
        if ((WaitForSingleObject(readdone,(DWORD)-1L) != NO_ERROR)
            || (ResetEvent(readdone)              != TRUE)) {
            error("read synch error");  /* Die if we fail to get semaphore */
        }
        t2fd = fd;                      /* Set parameters for read */
        t2buf = buffer;
        t2buflen = buflen;
        SetEvent( readpending );        /* Signal read to start */
        Sleep( 0L );                    /* Yield the CPU */
    } else {
        arrc = ReadFile(fd,(PVOID)buffer,buflen, &cbread, NULL);
    }
}


int
finishread()
{
    if (asyncio) {                         /* If asynchronous I/O */
        if ( WaitForSingleObject( readdone, (DWORD)-1L ) != NO_ERROR ) {
            error("read wait error");   /* Die if wait fails */
        }
    }
    return(arrc ? cbread : -1); /* Return number of bytes read */
}


void
startwrite(
           HANDLE fd,
           char *buffer,
           int buflen
           )
{
    if (asyncio) {                         /* If asynchronous I/O */
        if ((WaitForSingleObject(writedone,(DWORD)-1L) != NO_ERROR)
            || (ResetEvent(writedone)              != TRUE)) {
            error("write synch error"); /* Die if we fail to get semaphore */
        }
        t3fd = fd;                      /* Set parameters for write */
        t3buf = buffer;
        t3buflen = buflen;
        SetEvent( writepending );       /* Signal read completed */
        Sleep( 0L );                    /* Yield the CPU */
    } else {
        awrc = WriteFile(fd,(PVOID)buffer,buflen, &cbwrite, NULL);
    }
}


int
finishwrite()
{
    if (asyncio) {                         /* If asynchronous I/O */
        if ( WaitForSingleObject( writedone, (DWORD)-1L ) != NO_ERROR ) {
            error("write wait error");  /* Die if wait fails */
        }
    }
    return(awrc ? cbwrite : -1);    /* Return number of bytes written */
}


void
write1nobuf(
            char *buffer,
            size_t buflen
            )
{
    CBIO                cb;             /* Count of bytes written */

    if (!WriteFile(GetStdHandle(STD_OUTPUT_HANDLE),(PVOID)buffer,buflen, &cb, NULL)
        ||  (cb != (CBIO)buflen))
    {
        error("Write error");           /* Die if write fails */
    }
}


void
write1buf(
          char *buffer,
          size_t buflen
          )
{
    register size_t cb;             /* Byte count */

    while (buflen > 0) {                   /* While bytes remain */
        if (!awrc) {                       /* If previous write failed */
            fprintf(stderr,"%s: Write error %d\n",program,GetLastError());
            /* Print error message */
            exit(2);                    /* Die */
        }
        if ((cb = ocnt[oi]) == 0) {        /* If buffer full */
            startwrite( GetStdHandle( STD_OUTPUT_HANDLE ), obuf[oi], OUTBUFLEN );
            /* Write the buffer */
            ocnt[oi] = OUTBUFLEN;       /* Reset count and pointer */
            optr[oi] = obuf[oi];
            oi ^= 1;                    /* Switch buffers */
            cb = ocnt[oi];              /* Get space remaining */
        }
        if (cb > buflen)
            cb = buflen;    /* Get minimum */
        memmove(optr[oi],buffer,cb);    /* Copy bytes to buffer */
        ocnt[oi] -= cb;                 /* Update buffer length and pointers */
        optr[oi] += cb;
        buflen -= cb;
        buffer += cb;
    }
}


void
flush1nobuf(void)
{
}


void
flush1buf(void)
{
    register int        cb;             /* Byte count */

    if ((cb = OUTBUFLEN - ocnt[oi]) > 0) { /* If buffer not empty */
        startwrite( GetStdHandle( STD_OUTPUT_HANDLE ), obuf[oi], cb );  /* Start write */
        if (finishwrite() != cb) {         /* If write failed */
            fprintf(stderr,"%s: Write error %d\n",program,GetLastError());
            /* Print error message */
            exit(2);                    /* Die */
        }
    }
}


int
grepnull(
         char *cp,
         char *endbuf,
         char *name
         )
{
    /* keep compiler happy */
    cp = cp;
    endbuf = endbuf;
    name = name;
    return(0);                          /* Do nothing */
}


int
grepbuffer(
           char *startbuf,
           char *endbuf,
           char *name
           )
{
    char                *cp;            /* Buffer pointer */
    char                *lastmatch;     /* Last matching line */
    int                 linelen;        /* Line length */
    int                 namlen = 0;     /* Length of name */
    char                lnobuf[LNOLEN]; /* Line number buffer */
    char                nambuf[PATHLEN];/* Name buffer */

    cp = startbuf;                      /* Initialize to start of buffer */
    lastmatch = cp;                     /* No previous match yet */
    while ((cp = (*find)(cp,endbuf)) != NULL) {                                 /* While matches are found */
        --cp;                           /* Back up to previous character */
        if ((flags & BEGLINE) && *cp != '\n') {                             /* If begin line conditions not met */
            cp += strncspn(cp,"\n", (size_t)(endbuf - cp)) + 1;
            /* Skip line */
            continue;                   /* Keep looking */
        }
        status = 0;                     /* Match found */
        if (flags & NAMEONLY) return(1); /* Return if filename only wanted */
        cp -= preveol(cp) - 1;          /* Point at start of line */
        if (flags & SHOWNAME) {            /* If name wanted */
            if (namlen == 0) {             /* If name not formatted yet */
                if (flags & ZLINENOS)
                    namlen = sprintf(nambuf,"%s",name);
                else
                    namlen = sprintf(nambuf,"%s:",name);
                /* Format name if not done already */
            }
            (*write1)(nambuf, namlen);   /* Show name */
        }
        if (flags & LINENOS) {             /* If line number wanted */
            lineno += countlines(lastmatch,cp);
            /* Count lines since last match */
            if (flags & ZLINENOS)
                (*write1)(lnobuf,sprintf(lnobuf,"(%u) : ",lineno));
            else
                (*write1)(lnobuf,sprintf(lnobuf,"%u:",lineno));
            /* Print line number */
            lastmatch = cp;             /* New last match */
        }
        if (flags & SEEKOFF) {             /* If seek offset wanted */
            (*write1)(lnobuf,sprintf(lnobuf,"%lu:",
                                     cbfile + (long)(cp - startbuf)));
            /* Print seek offset */
        }
        linelen = strncspn(cp,"\n",(size_t)(endbuf - cp)) + 1;
        /* Calculate line length */
        (*write1)(cp,linelen);          /* Print the line */
        cp += linelen;                  /* Skip the line */
    }
    if (flags & LINENOS)
        lineno += countlines(lastmatch,endbuf);
    /* Count remaining lines in buffer */
    return(0);                          /* Keep searching */
}


void
showv(
      char *name,
      char *startbuf,
      char *lastmatch,
      char *thismatch
      )
{
    register int        linelen;
    int                 namlen = 0;     /* Length of name */
    char                lnobuf[LNOLEN]; /* Line number buffer */
    char                nambuf[PATHLEN];/* Name buffer */

    if (flags & (SHOWNAME | LINENOS | SEEKOFF)) {
        while (lastmatch < thismatch) {
            if (flags & SHOWNAME) {        /* If name wanted */
                if (namlen == 0) {         /* If name not formatted yet */
                    if (flags & ZLINENOS)
                        namlen = sprintf(nambuf,"%s",name);
                    else
                        namlen = sprintf(nambuf,"%s:",name);
                    /* Format name if not done already */
                }
                (*write1)(nambuf,namlen);
                /* Write the name */
            }
            if (flags & LINENOS) {         /* If line numbers wanted */
                if (flags & ZLINENOS)
                    (*write1)(lnobuf,sprintf(lnobuf,"(%u) : ",lineno++));
                else
                    (*write1)(lnobuf,sprintf(lnobuf,"%u:",lineno++));
                /* Print the line number */
            }
            if (flags & SEEKOFF) {         /* If seek offsets wanted */
                (*write1)(lnobuf,sprintf(lnobuf,"%lu:",
                                         cbfile + (long)(lastmatch - startbuf)));
                /* Print the line number */
            }
            linelen = strncspn(lastmatch,"\n",(size_t)(thismatch - lastmatch)) + 1;
            (*write1)(lastmatch,linelen);
            lastmatch += linelen;
        }
    } else (*write1)(lastmatch, (size_t)(thismatch - lastmatch));
}


int
grepvbuffer(
            char *startbuf,
            char *endbuf,
            char *name
            )
{
    register char       *cp;            /* Buffer pointer */
    register char       *lastmatch;     /* Pointer to line after last match */

    cp = startbuf;                      /* Initialize to start of buffer */
    lastmatch = cp;
    while ((cp = (*find)(cp,endbuf)) != NULL) {
        --cp;                           /* Back up to previous character */
        if ((flags & BEGLINE) && *cp != '\n') {                             /* If begin line conditions not met */
            cp += strncspn(cp,"\n", (size_t)(endbuf - cp)) + 1;
            /* Skip line */
            continue;                   /* Keep looking */
        }
        cp -= preveol(cp) - 1;          /* Point at start of line */
        if (cp > lastmatch) {              /* If we have lines without matches */
            status = 0;                 /* Lines without matches found */
            if (flags & NAMEONLY) return(1);
            /* Skip rest of file if NAMEONLY */
            showv(name,startbuf,lastmatch,cp);
            /* Show from last match to this */
        }
        cp += strncspn(cp,"\n",(size_t)(endbuf - cp)) + 1;
        /* Skip over line with match */
        lastmatch = cp;                 /* New "last" match */
        ++lineno;                       /* Increment line count */
    }
    if (endbuf > lastmatch) {              /* If we have lines without matches */
        status = 0;                     /* Lines without matches found */
        if (flags & NAMEONLY) return(1); /* Skip rest of file if NAMEONLY */
        showv(name,startbuf,lastmatch,endbuf);
        /* Show buffer tail */
    }
    return(0);                          /* Keep searching file */
}

void
qgrep(
      int (*grep)( char *, char *, char * ),
      char *name,
      HANDLE fd
      )
{
    int                 cb;             /* Byte count */
    register char       *cp;            /* Buffer pointer */
    char                *endbuf;        /* End of buffer */
    int                 taillen;        /* Length of buffer tail */
    int                 bufi;           /* Buffer index */

    cbfile = 0L;                        /* File empty so far */
    lineno = 1;                         /* File starts on line 1 */
    taillen = 0;                        /* No buffer tail yet */
    bufi = 0;                           /* Initialize buffer index */
    cp = bufptr[0];                     /* Initialize to start of buffer */
    finishread();                       /* Make sure no I/O activity */
    arrc = ReadFile(fd,(PVOID)cp,filbuflen, &cbread, NULL);
    while ((cb = finishread()) + taillen > 0) {                                 /* While search incomplete */
        if (cb == 0) {                     /* If buffer tail is all that's left */
            taillen = 0;                /* Set tail length to zero */
            *cp++ = '\r';               /* Add end of line sequence */
            *cp++ = '\n';
            endbuf = cp;                /* Note end of buffer */
        } else                            /* Else start next read */ {
            taillen = preveol(cp + cb - 1);
            /* Find length of partial line */
            endbuf = cp + cb - taillen; /* Get pointer to end of buffer */
            cp = bufptr[bufi ^ 1];      /* Pointer to other buffer */
            memmove(cp,endbuf,taillen); /* Copy tail to head of other buffer */
            cp += taillen;              /* Skip over tail */
            startread(fd,cp,(filbuflen - taillen) & (~0 << LG2SECLEN));
            /* Start next read */
        }
        if ((*grep)(bufptr[bufi],endbuf,name)) {                             /* If rest of file can be skipped */
            (*write1)(name,strlen(name));
            /* Write file name */
            (*write1)("\r\n",2);        /* Write newline sequence */
            return;                     /* Skip rest of file */
        }
        cbfile += (long)(endbuf - bufptr[bufi]);
        /* Increment count of bytes in file */
        bufi ^= 1;                      /* Switch buffers */
    }
}


void
usage(
      char *errmes
      )
{
    static const char szUsage[] =
    {
        "-? - print this message\n"
        "-B - match pattern if at beginning of line\n"
        "-E - match pattern if at end of line\n"
        "-L - treat search strings literally (fgrep)\n"
        "-O - print seek offset before each matching line\n"
        "-X - treat search strings as regular expressions (grep)\n"
        "-l - print only file name if file contains match\n"
        "-n - print line number before each matching line\n"
        "-z - print matching lines in MSC error message format\n"
        "-v - print only lines not containing a match\n"
        "-x - print lines that match exactly (-BE)\n"
        "-y - treat upper and lower case as equivalent\n"
        "-e - treat next argument literally as a search string\n"
        "-f - read search strings from file named by next argument (- = stdin)\n"
        "-i - read file list from file named by next argument (- = stdin)\n"
        "White space separates search strings unless the argument is prefixed\n"
        "with -e, e.g., 'qgrep \"all out\" x.y' means find either \"all\" or\n"
        "\"out\" in x.y, while 'qgrep -e \"all out\" x.y' means find \"all out\".\n"
    };

    if (errmes != NULL)
        fprintf(stderr,"%s: %s\n", program, errmes);
    /* Print error message */
    fprintf(stderr,"usage: %s [-?BELOXlnzvxy][-e string][-f file][-i file][strings][files]\n", program);
    /* Print command line format */
    if (errmes == NULL) {                  /* If verbose message wanted */
        fputs(szUsage, stderr);
    }
    exit(2);                            /* Error exit */
}

char *
rmpath(
       char *name
       )
{
    char                *cp;            /* Char pointer */

    if (name[0] != '\0' && name[1] == ':') name += 2;
    /* Skip drive spec if any */
    cp = name;                          /* Point to start */
    while (*name != '\0') {                /* While not at end */
        ++name;                         /* Skip to next character */
        if (name[-1] == '/' || name[-1] == '\\') cp = name;
        /* Point past path separator */
    }
    return(cp);                         /* Return pointer to name */
}


int
__cdecl
main(
    int argc,
    char **argv
    )
{
    char                *cp;

    HANDLE              fd;
    DWORD               dwTmp;

    FILE                *fi;
    int                 i;
    int                 j;
    char                *inpfile = NULL;
    char                *strfile = NULL;
    unsigned long       tstart, tend;   /* Start time */
    char                filnam[FILNAMLEN];

    tstart = clock();                   /* Get start time */

    ConvertAppToOem( argc, argv );
    asyncio = pmode = 1;                /* Do asynchronous I/O */

    program = rmpath(argv[0]);          /* Set program name */
    memset(td1,1,TRTABLEN);             /* Set up TD1 for startup */
    flags = 0;
    for (i = 1; i < argc && strchr("/-",argv[i][0]) != NULL; ++i) {
        if (argv[i][1] == '\0' ||
            strchr("?BELNOSXdlntvxyz",argv[i][1]) == NULL) break;
        /* Break if unrecognized switch */
        for (cp = &argv[i][1]; *cp != '\0'; ++cp) {
            switch (*cp) {
                case '?':
                    usage(NULL);          /* Verbose usage message */

                case 'B':
                    flags |= BEGLINE;
                    break;

                case 'E':
                    flags |= ENDLINE;
                    break;

                case 'L':
                    addstr = addstring;   /* Treat strings literally */
                    break;

                case 'N':
                    grep = grepnull;
                    break;

                case 'O':
                    flags |= SEEKOFF;
                    break;

                case 'S':
                    asyncio = 0;          /* Force synchronous I/O */
                    break;

                case 'X':
                    addstr = addexpr;     /* Add expression to list */
                    break;

                case 'd':
                    flags |= DEBUG;
                    break;

                case 'l':
                    flags |= NAMEONLY;
                    break;

                case 'n':
                    flags |= LINENOS;
                    break;

                case 'z':
                    flags |= ZLINENOS | LINENOS;
                    break;

                case 't':
                    flags |= TIMER;
                    break;

                case 'v':
                    grep = grepvbuffer;
                    break;

                case 'x':
                    flags |= BEGLINE | ENDLINE;
                    break;

                case 'y':
                    casesen = 0;
                    break;

                default:
                    fprintf(stderr,"%s: -%c ignored\n",program,*cp);
                    break;
            }
        }
    }
    for (; i < argc && argv[i][0] == '-'; ++i) {
        if (argv[i][2] == '\0') {          /* No multi-character switches */
            switch (argv[i][1]) {
                case 'e':               /* Explicit string (no separators) */
                    if (++i == argc) usage("Argument missing after -e");
                    /* Argument missing after -e */
                    cp = argv[i];         /* Point to string */
                    addstrings( cp, cp + strlen(cp), "" );
                    /* Add string "as is" */
                    continue;

                case 'F':
                    flags |= DOQUOTES;    /* Handle quoted patterns in file */
                case 'f':               /* Patterns in file */
                case 'i':               /* Names of files to search in file */
                    if (i == argc - 1) usage("Argument missing after switch");
                    /* Argument missing */
                    if (argv[i++][1] == 'i') inpfile = argv[i];
                    else strfile = argv[i];
                    continue;
            }
        }
        fprintf(stderr,"%s: %s ignored\n",program,argv[i]);
    }
    if (i == argc && strcnt == 0 && strfile == NULL) usage("Bad command line");
    /* Usage message if arg error */

    if (asyncio) {                         /* Initialize semaphores and threads */
        if ( !( readdone = CreateEvent( NULL, TRUE, TRUE,NULL ) ) ||
             !( readpending = CreateEvent( NULL, TRUE, FALSE,NULL ) ) ||
             !( writedone = CreateEvent( NULL, TRUE, TRUE,NULL ) ) ||
             !( writepending = CreateEvent( NULL, TRUE, FALSE,NULL ) ) ) {
            error("Semaphore creation error");
        }
        if ((CreateThread( NULL,
                           STKLEN,
                           (LPTHREAD_START_ROUTINE)thread2,
                           NULL,
                           0,
                           (LPDWORD)&dwTmp)
             == NULL)
            ||
            (CreateThread( NULL,
                           STKLEN,
                           (LPTHREAD_START_ROUTINE)thread3,
                           NULL,
                           0,
                           (LPDWORD)&dwTmp)
             == NULL)) {
            error("Thread creation error");
        }
        /* Die if thread creation fails */
    }
    _setmode(_fileno(stdout),O_BINARY);   /* No linefeed translation on output */

    bufptr[0][-1] = bufptr[1][-1] = '\n';
    /* Mark beginnings with newline */

    if (_isatty(_fileno(stdout))) {          /* If stdout is a device */
        write1 = write1nobuf;           /* Use unbuffered output */
        flush1 = flush1nobuf;
    }

    if (strfile != NULL) {                 /* If strings from file */
        if (strcmp(strfile,"-") != 0) {    /* If strings not from std. input */
            if ( ( fd = CreateFile( strfile, GENERIC_READ, 0, NULL, OPEN_EXISTING, 0, NULL ) ) == (HANDLE)-1 ) {                         /* If open fails */
                fprintf(stderr,"%s: Cannot read strings from %s\n",
                        program,strfile);     /* Print message */
                exit(2);                /* Die */
            }
        } else {
            fd = GetStdHandle( STD_INPUT_HANDLE );     /* Else use std. input */
        }
        qgrep( addstrings, "\r\n", fd );/* Do the work */
        if ( fd != GetStdHandle( STD_INPUT_HANDLE ) ) {
            CloseHandle( fd );          /* Close strings file */
        }
    }
    else if (strcnt == 0) {                /* Else if strings on command line */
        cp = argv[i++];                 /* Set pointer to strings */
        addstrings(cp,cp + strlen(cp)," \t");
        /* Add strings to list */
    }
    if (strcnt == 0) error("No search strings");
    /* Die if no strings */
    if (addstr != addexpr) {               /* If not using expressions */
        memset(td1,(int)(cchmin + 1),TRTABLEN);/* Initialize table */
        find = findlist;                /* Assume finding many */
        if ((j = enumstrings()) != strcnt)
            fprintf(stderr,"String count error (%d != %d)\n",j,strcnt);
        /* Enumerate strings and verify count */
        if (flags & DEBUG) {               /* If debugging output wanted */
            fprintf(stderr,"%u bytes wasted in heap\n",waste);
            /* Print storage waste */
            assert(chmin <= chmax);     /* Must have some entries */
            fprintf(stderr,
                    "chmin = %u, chmax = %u, cchmin = %u\n",chmin,chmax,cchmin);
            /* Print range info */
            for (j = (int)chmin; j <= (int)chmax; ++j) {                         /* Loop to print TD1 table */
                if ( td1[j] <= (char)cchmin ) {    /* If not maximum shift */
                    if (isascii(j) && isprint(j))
                        fprintf(stderr,"'%c'=%2u  ",j,td1[j]);
                    /* Show literally if printable */
                    else fprintf(stderr,"\\%02x=%2u  ",j,td1[j]);
                    /* Else show hex value */
                }
            }
            fprintf(stderr,"\n");
        }
        if (strcnt == 1 && casesen)
            find = findone;             /* Find one case-sensitive string */
    } else if (find == NULL) {
        find = findexpr;                /* Else find expressions */
    }
    if (inpfile != NULL) {                 /* If file list from file */
        flags |= SHOWNAME;              /* Always show name of file */
        if (strcmp(inpfile,"-") != 0) {    /* If name is not "-" */
            if ((fi = fopen(inpfile,"r")) == NULL) {                         /* If open fails */
                fprintf(stderr,"%s: Cannot read file list from %s\n",
                        program,inpfile);     /* Error message */
                exit(2);                /* Error exit */
            }
        } else fi = stdin;                /* Else read file list from stdin */
        while (fgets(filnam,FILNAMLEN,fi) != NULL) {                             /* While there are names */
            filnam[strcspn(filnam,"\r\n")] = '\0';
            /* Null-terminate the name */
            if ((fd = openfile(filnam)) == (HANDLE)-1) {
                continue;               /* Skip file if it cannot be opened */
            }
            qgrep(grep,filnam,fd);      /* Do the work */
            CloseHandle( fd );
        }
        if (fi != stdin) fclose(fi);     /* Close the list file */
    } else if (i == argc) {
        flags &= ~(NAMEONLY | SHOWNAME);
        qgrep( grep, NULL, GetStdHandle( STD_INPUT_HANDLE ) );
    }
    if (argc > i + 1) flags |= SHOWNAME;
    for (; i < argc; ++i) {
        _strlwr(argv[i]);
        if ((fd = openfile(argv[i])) == (HANDLE)-1) {
            continue;
        }
        qgrep(grep,argv[i],fd);
        CloseHandle( fd );
    }
    (*flush1)();
    if ( flags & TIMER ) {                 /* If timing wanted */
        tend = clock();
        tstart = tend - tstart;     /* Get time in milliseconds */
        fprintf(stderr,"%lu.%03lu seconds\n", ( tstart / CLK_TCK ), ( tstart % CLK_TCK ) );
        /* Print total elapsed time */
    }

    return( status );
}


char *findsub();     /* Findlist() worker */
char *findsubi();    /* Findlist() worker */


char *(*flworker[])() =
{             /* Table of workers */
    findsubi,
    findsub
};


char *
strnupr(
        char *pch,
        int cch
        )
{
    while (cch-- > 0) {                 /* Convert string to upper case */
        if (isascii(pch[cch]))
            pch[cch] = (char)toupper(pch[cch]);
    }
    return(pch);
}


/*
 *  This is an implementation of the QuickSearch algorith described
 *  by Daniel M. Sunday in the August 1990 issue of CACM.  The TD1
 *  table is computed before this routine is called.
 */

char *
findone(
        unsigned char *buffer,
        char *bufend
        )
{
    if ((bufend -= targetlen - 1) <= buffer)
        return((char *) 0);             /* Fail if buffer too small */
    while (buffer < bufend) {           /* While space remains */
        int cch;                        /* Character count */
        register char *pch1;            /* Char pointer */
        register char *pch2;            /* Char pointer */

        pch1 = target;                  /* Point at pattern */
        pch2 = buffer;                  /* Point at buffer */
        for (cch = targetlen; cch > 0; --cch) {
            /* Loop to try match */
            if (*pch1++ != *pch2++)
                break;                  /* Exit loop on mismatch */
        }
        if (cch == 0)
            return(buffer);             /* Return pointer to match */
        buffer += td1[buffer[targetlen]];
        /* Skip ahead */
    }
    return((char *) 0);                 /* No match */
}


size_t
preveol(
        char *s
        )
{
    register char       *cp;            /* Char pointer */

    cp = s + 1;                         /* Initialize pointer */
    while (*--cp != '\n') ;              /* Find previous end-of-line */
    return((size_t)(s - cp));                     /* Return distance to match */
}


int
countlines(
           char *start,
           char *finish
           )
{
    register int        count;          /* Line count */

    for (count = 0; start < finish; ) {                                 /* Loop to count lines */
        if (*start++ == '\n') ++count;   /* Increment count if linefeed found */
    }
    return(count);                      /* Return count */
}


char *
findlist(
         unsigned char *buffer,
         char *bufend
         )
{
    char                *match;         /* Pointer to matching string */
    char                endbyte;        /* First byte past end */

    endbyte = *bufend;                  /* Save byte */
    *bufend = '\177';                   /* Mark end of buffer */
    match = (*flworker[casesen])(buffer,bufend);
    /* Call worker */
    *bufend = endbyte;                  /* Restore end of buffer */
    return(match);                      /* Return matching string */
}


char *
findsub(
        unsigned char *buffer,
        char *bufend
        )
{
    register char       *cp;            /* Char pointer */
    STRINGNODE          *s;             /* String node pointer */
    int                 i;              /* Index */

    if ((bufend -= cchmin - 1) < buffer)
        return((char *) 0);             /* Compute effective buffer length */

    while (buffer < bufend) {              /* Loop to find match */
        if ((i = transtab[*buffer]) != 0) {                             /* If valid first character */
            if ((s = stringlist[i]) == 0)
                return(buffer);         /* Check for 1-byte match */
            for (cp = buffer + 1; ; ) {    /* Loop to search list */
                if ((i = memcmp(cp,s_text(s),s->s_must)) == 0) {                     /* If portions match */
                    cp += s->s_must;    /* Skip matching portion */
                    if ((s = s->s_suf) == 0)
                        return(buffer); /* Return match if end of list */
                    continue;           /* Else continue */
                }
                if (i < 0 || (s = s->s_alt) == 0)
                    break;              /* Break if not in this list */
            }
        }
        buffer += td1[buffer[cchmin]];  /* Shift as much as possible */
    }
    return((char *) 0);                 /* No match */
}


char *
findsubi(
         unsigned char *buffer,
         char *bufend
         )
{
    register char       *cp;            /* Char pointer */
    STRINGNODE          *s;             /* String node pointer */
    int                 i;              /* Index */

    if ((bufend -= cchmin - 1) < buffer)
        return((char *) 0);             /* Compute effective buffer length */
    while (buffer < bufend) {              /* Loop to find match */
        if ((i = transtab[*buffer]) != 0) {                             /* If valid first character */
            if ((s = stringlist[i]) == 0)
                return(buffer);         /* Check for 1-byte match */
            for (cp = buffer + 1; ; ) {    /* Loop to search list */
                if ((i = _memicmp(cp,s_text(s),s->s_must)) == 0) {                     /* If portions match */
                    cp += s->s_must;    /* Skip matching portion */
                    if ((s = s->s_suf) == 0)
                        return(buffer); /* Return match if end of list */
                    continue;           /* And continue */
                }
                if (i < 0 || (s = s->s_alt) == 0)
                    break;              /* Break if not in this list */
            }
        }
        buffer += td1[buffer[cchmin]];  /* Shift as much as possible */
    }
    return((char *) 0);                 /* No match */
}


size_t
strnspn(
        char *s,
        char *t,
        size_t n
        )
{
    char                *s1;            /* String pointer */
    char                *t1;            /* String pointer */

    for (s1 = s; n-- != 0; ++s1) {         /* While not at end of s */
        for (t1 = t; *t1 != '\0'; ++t1) {  /* While not at end of t */
            if (*s1 == *t1) break;       /* Break if match found */
        }
        if (*t1 == '\0') break;          /* Break if no match found */
    }
    return((size_t)(s1 - s));                     /* Return length */
}


size_t
strncspn(
         char *s,
         char *t,
         size_t n
         )
{
    char                *s1;            /* String pointer */
    char                *t1;            /* String pointer */

    for (s1 = s; n-- != 0; ++s1) {         /* While not at end of s */
        for (t1 = t; *t1 != '\0'; ++t1) {  /* While not at end of t */
            if (*s1 == *t1)
                return((size_t)(s1 - s));
            /* Return if match found */
        }
    }
    return((size_t)(s1 - s));                     /* Return length */
}


void
matchstrings(
             char *s1,
             char *s2,
             int len,
             size_t *nmatched,
             int *leg
             )
{
    register char  *cp;            /* Char pointer */
    register int (__cdecl *cmp)(const char*,const char*, size_t);       /* Comparison function pointer */

    cmp = casesen? strncmp: _strnicmp;
    /* Set pointer */
    if ((*leg = (*cmp)(s1,s2,len)) != 0) { /* If strings don't match */
        for (cp = s1; (*cmp)(cp,s2++,1) == 0; ++cp)
            ;
        /* Find mismatch */
        *nmatched = (size_t)(cp - s1);            /* Return number matched */
    } else
        *nmatched = len;               /* Else all matched */
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\qgrep\qmatch.c ===
/*static char *SCCSID = "@(#)qmatch.c   13.7 90/08/13";*/


#include                <stdio.h>
#include                <ctype.h>
#include                <assert.h>
#include                <stdlib.h>
#include                <string.h>


#define ASCLEN          128             /* Number of ascii characters */
#define BUFLEN          256             /* Temporary buffer length */
#define EOS             ('\r')          /* End of string character */
#define PATMAX          512             /* Maximum parsed pattern length */

#define BEGLINE         0x08            /* Match at beginning of line */
#define DEBUG           0x20            /* Print debugging output */
#define ENDLINE         0x10            /* Match at end of line */

#define T_END           0               /* End of expression */
#define T_STRING        1               /* String to match */
#define T_SINGLE        2               /* Single character to match */
#define T_CLASS         3               /* Class to match */
#define T_ANY           4               /* Match any character */
#define T_STAR          5               /* *-expr */


typedef struct exprnode
  {
    struct exprnode     *ex_next;       /* Next node in list */
    unsigned char       *ex_pattern;    /* Pointer to pattern to match */
  }
                        EXPR;           /* Expression node */


static int              clists = 1;     /* One is first available index */
static int              toklen[] =      /* Table of token lengths */
                          {
                            32767,      /* T_END: invalid */
                            32767,      /* T_STRING: invalid */
                            2,          /* T_SINGLE */
                            ASCLEN/8+1, /* T_CLASS */
                            1,          /* T_ANY */
                            32767       /* T_STAR: invalid */
                          };
int               ( __cdecl *ncmp)(const char *,const char *,size_t);
                                        /* String comparison pointer */

unsigned char           *exprparse(unsigned char *p);

extern int              casesen;        /* Case-sensitivity flag */
extern char             *(*find)();     /* Pointer to search function */
extern int              flags;          /* Flags */
extern int              strcnt;         /* String count */
extern char             transtab[];     /* Translation table */
EXPR                    *stringlist[ASCLEN];
                                        /* String table */


void                    addexpr(char *e, int n);      /* Add expression */
char                    *get1stcharset(unsigned char *e, char *bitvec);
extern char             *alloc();       /* User-defined heap allocator */
unsigned char           *simpleprefix();/* Match simple prefix */
char                    *strnupr();     /* See QGREPSUB.ASM */


unsigned char           *simpleprefix(s,pp)
register unsigned char  *s;             /* String pointer */
unsigned char           **pp;           /* Pointer to pattern pointer */
  {
    register unsigned char *p;          /* Simple pattern pointer */
    register int        c;              /* Single character */

    p = *pp;                            /* Initialize */
    while(*p != T_END && *p != T_STAR)  /* While not at end of pattern */
      {
        switch(*p++)                    /* Switch on token type */
          {
            case T_STRING:              /* String to compare */
              if((*ncmp)(s,p + 1,*p) != 0) return(NULL);
                                        /* Fail if mismatch found */
              s += *p;                  /* Skip matched portion */
              p += *p + 1;              /* Skip to next token */
              break;

            case T_SINGLE:              /* Single character */
              c = *s++;                 /* Get character */
              if(!casesen) c = toupper(c);
                                        /* Map to upper case if necessary */
              if(c != (int)*p++) return(NULL);
                                        /* Fail if mismatch found */
              break;

            case T_CLASS:               /* Class of characters */
              if(!isascii(*s) || !(p[*s >> 3] & (1 << (*s & 7)))) return(NULL);
                                        /* Failure if bit not set */
              p += ASCLEN/8;            /* Skip bit vector */
              ++s;                      /* Skip character */
              break;

            case T_ANY:                 /* Any character */
              if(*s++ == EOS) return(NULL);
                                        /* Match all but end of string */
              break;
          }
      }
    *pp = p;                            /* Update pointer */
    return(s);                          /* Pattern is prefix of s */
  }


int                     match(s,p)
register unsigned char  *s;             /* String to match */
unsigned char           *p;             /* Pattern to match against */
  {
    register unsigned char *q;          /* Temporary pointer */
    unsigned char       *r;             /* Temporary pointer */
    register int        c;              /* Character */

    if(*p != T_END && *p != T_STAR && (s = simpleprefix(s,&p)) == NULL)
      return(0);                        /* Failure if prefix mismatch */
    if(*p++ == T_END) return(1);        /* Match if end of pattern */
    q = r = p;                          /* Point to repeated token */
    r += toklen[*q];                    /* Skip repeated token */
    switch(*q++)                        /* Switch on token type */
      {
        case T_ANY:                     /* Any character */
          while(match(s,r) == 0)        /* While match not found */
            {
              if(*s++ == EOS) return(0);/* Match all but end of string */
            }
          return(1);                    /* Success */

        case T_SINGLE:                  /* Single character */
          while(match(s,r) == 0)        /* While match not found */
            {
              c = *s++;                 /* Get character */
              if(!casesen) c = toupper(c);
                                        /* Map to upper case if necessary */
              if((unsigned char) c != *q) return(0);
                                        /* Fail if mismatch found */
            }
          return(1);                    /* Success */

        case T_CLASS:                   /* Class of characters */
          while(match(s,r) == 0)        /* While match not found */
            {
              if(!isascii(*s) || !(q[*s >> 3] & (1 << (*s & 7)))) return(0);
                                        /* Fail if bit not set */
              ++s;                      /* Else skip character */
            }
          return(1);                    /* Success */
      }
    return(0);                          /* Return failure */
  }


int                     exprmatch(s,p)
char                    *s;             /* String */
char                    *p;             /* Pattern */
  {
    ncmp = strncmp;                     /* Assume case-sensitive */
    if(!casesen)
      {
        ncmp = _strnicmp;
      }                                 /* Be case-insensitive if flag set */
    return(match(s,p));                 /* See if pattern matches string */
  }


void                    bitset(bitvec,first,last,bitval)
char                    *bitvec;        /* Bit vector */
int                     first;          /* First character */
int                     last;           /* Last character */
int                     bitval;         /* Bit value (0 or 1) */
  {
    int                 bitno;          /* Bit number */

    bitvec += first >> 3;               /* Point at first byte */
    bitno = first & 7;                  /* Calculate first bit number */
    while(first <= last)                /* Loop to set bits */
      {
        if(bitno == 0 && first + 8 <= last)
          {                             /* If we have a whole byte's worth */
            *bitvec++ = (char)(bitval? '\xFF': '\0');
                                        /* Set the bits */
            first += 8;                 /* Increment the counter */
            continue;                   /* Next iteration */
          }
        *bitvec=(char)(*bitvec & (unsigned char)(~(1 << bitno))) | (unsigned char)(bitval << bitno);
                                        /* Set the appropriate bit */
        if(++bitno == 8)                /* If we wrap into next byte */
          {
            ++bitvec;                   /* Increment pointer */
            bitno = 0;                  /* Reset bit index */
          }
        ++first;                        /* Increment bit index */
      }
  }


unsigned char           *exprparse(p)
register unsigned char  *p;             /* Raw pattern */
  {
    register char       *cp;            /* Char pointer */
    unsigned char       *cp2;           /* Char pointer */
    int                 i;              /* Counter/index */
    int                 j;              /* Counter/index */
    int                 m;              /* Counter/index */
    int                 n;              /* Counter/index */
    int                 bitval;         /* Bit value */
    char                buffer[PATMAX]; /* Temporary buffer */

    if(!casesen) strnupr(p,strlen(p));  /* Force pattern to upper case */
    cp = buffer;                        /* Initialize pointer */
    if(*p == '^') *cp++ = *p++;         /* Copy leading caret if any */
    while(*p != '\0')                   /* While not end of pattern */
      {
        i = -2;                         /* Initialize */
        for(n = 0;;)                    /* Loop to delimit ordinary string */
          {
            n += strcspn(p + n,".\\[*");/* Look for a special character */
            if(p[n] != '\\') break;     /* Break if not backslash */
            i = n;                      /* Remember where backslash is */
            if(p[++n] == '\0') return(NULL);
                                        /* Cannot be at very end */
            ++n;                        /* Skip escaped character */
          }
        if(p[n] == '*')                 /* If we found a *-expr. */
          {
            if(n-- == 0) return(NULL);  /* Illegal first character */
            if(i == n - 1) n = i;       /* Escaped single-char. *-expr. */
          }
        if(n > 0)                       /* If we have string or single */
          {
            if(n == 1 || (n == 2 && *p == '\\'))
              {                         /* If single character */
                *cp++ = T_SINGLE;       /* Set type */
                if(*p == '\\') ++p;     /* Skip escape if any */
                *cp++ = *p++;           /* Copy single character */
              }
            else                        /* Else we have a string */
              {
                *cp++ = T_STRING;       /* Set type */
                cp2 = cp++;             /* Save pointer to length byte */
                while(n-- > 0)          /* While bytes to copy remain */
                  {
                    if(*p == '\\')      /* If escape found */
                      {
                        ++p;            /* Skip escape */
                        --n;            /* Adjust length */
                      }
                    *cp++ = *p++;       /* Copy character */
                  }
                *cp2 = (char)((cp - cp2) - 1);
                                        /* Set string length */
              }
          }
        if(*p == '\0') break;           /* Break if end of pattern */
        if(*p == '.')                   /* If matching any */
          {
            if(*++p == '*')             /* If star follows any */
              {
                ++p;                    /* Skip star, too */
                *cp++ = T_STAR;         /* Insert prefix ahead of token */
              }
            *cp++ = T_ANY;              /* Match any character */
            continue;                   /* Next iteration */
          }
        if(*p == '[')                   /* If character class */
          {
            if(*++p == '\0') return(NULL);
                                        /* Skip '[' */
            *cp++ = T_CLASS;            /* Set type */
            memset(cp,'\0',ASCLEN/8);   /* Clear the vector */
            bitval = 1;                 /* Assume we're setting bits */
            if(*p == '^')               /* If inverted class */
              {
                ++p;                    /* Skip '^' */
                memset(cp,'\xFF',ASCLEN/8);
                                        /* Set all bits */
                bitset(cp,EOS,EOS,0);   /* All except end-of-string */
                bitset(cp,'\n','\n',0); /* And linefeed! */
                bitval = 0;             /* Now we're clearing bits */
              }
            while(*p != ']')            /* Loop to find ']' */
              {
                if(*p == '\0') return(NULL);
                                        /* Check for malformed string */
                if(*p == '\\')          /* If escape found */
                  {
                    if(*++p == '\0') return(NULL);
                                        /* Skip escape */
                  }
                i = *p++;               /* Get first character in range */
                if(*p == '-' && p[1] != '\0' && p[1] != ']')
                  {                     /* If range found */
                    ++p;                /* Skip hyphen */
                    if(*p == '\\' && p[1] != '\0') ++p;
                                        /* Skip escape character */
                    j = *p++;           /* Get end of range */
                  }
                else j = i;             /* Else just one character */
                bitset(cp,i,j,bitval);  /* Set bits in vector */
                if(!casesen)            /* If ignoring case */
                  {
                    m = (i < 'A')? 'A': i;
                                        /* m = max(i,'A') */
                    n = (j > 'Z')? 'Z': j;
                                        /* n = min(j,'Z') */
                    if(m <= n) bitset(cp,tolower(m),tolower(n),bitval);
                                        /* Whack corresponding lower case */
                    m = (i < 'a')? 'a': i;
                                        /* m = max(i,'a') */
                    n = (j > 'z')? 'z': j;
                                        /* n = min(j,'z') */
                    if(m <= n) bitset(cp,toupper(m),toupper(n),bitval);
                                        /* Whack corresponding upper case */
                  }
              }
            if(*++p == '*')             /* If repeated class */
              {
                memmove(cp,cp - 1,ASCLEN/8 + 1);
                                        /* Move vector forward 1 byte */
                cp[-1] = T_STAR;        /* Insert prefix */
                ++cp;                   /* Skip to start of vector */
                ++p;                    /* Skip star */
              }
            cp += ASCLEN/8;             /* Skip over vector */
            continue;                   /* Next iteration */
          }
        *cp++ = T_STAR;                 /* Repeated single character */
        *cp++ = T_SINGLE;
        if(*p == '\\') ++p;             /* Skip escape if any */
        *cp++ = *p++;                   /* Copy the character */
        assert(*p == '*');              /* Validate assumption */
        ++p;                            /* Skip the star */
      }
    *cp++ = T_END;                      /* Mark end of parsed expression */
    cp2 = alloc(cp - buffer);           /* Allocate buffer */
    memmove(cp2,buffer,(size_t)(cp - buffer));    /* Copy expression to buffer */
    return(cp2);                        /* Return buffer pointer */
  }


int                     istoken(s,n)
unsigned char           *s;             /* String */
int                     n;              /* Length */
  {
    if(n >= 2 && s[0] == '\\' && s[1] == '<') return(1);
                                        /* Token if starts with '\<' */
    while(n-- > 0)                      /* Loop to find end of string */
      {
        if(*s++ == '\\')                /* If escape found */
          {
            if(--n == 0 && *s == '>') return(1);
                                        /* Token if ends with '\>' */
            ++s;                        /* Skip escaped character */
          }
      }
    return(0);                          /* Not a token */
  }


int                     isexpr(s,n)
unsigned char           *s;             /* String */
int                     n;              /* Length */
  {
    unsigned char       *cp;            /* Char pointer */
    int                 status;         /* Return status */
    char                buffer[BUFLEN]; /* Temporary buffer */

    if(istoken(s,n)) return(1);         /* Tokens are exprs */
    memmove(buffer,s,n);                /* Copy string to buffer */
    buffer[n] = '\0';                   /* Null-terminate string */
    if((s = exprparse(buffer)) == NULL) return(0);
                                        /* Not an expression if parse fails */
    status = 1;                         /* Assume we have an expression */
    if(*s != '^' && *s != T_END)        /* If no caret and not empty */
      {
        status = 0;                     /* Assume not an expression */
        cp = s;                         /* Initialize */
        do                              /* Loop to find special tokens */
          {
            switch(*cp++)               /* Switch on token type */
              {
                case T_STAR:            /* Repeat prefix */
                case T_CLASS:           /* Character class */
                case T_ANY:             /* Any character */
                  ++status;             /* This is an expression */
                  break;

                case T_SINGLE:          /* Single character */
                  ++cp;                 /* Skip character */
                  break;

                case T_STRING:          /* String */
                  cp += *cp + 1;        /* Skip string */
                  break;
              }
          }
        while(!status && *cp != T_END); /* Do while not at end of expression */
      }
    free(s);                            /* Free expression */
    return(status);                     /* Return status */
  }


void                    exprprint(p,fo)
unsigned char           *p;             /* Pointer to expression */
FILE                    *fo;            /* File pointer */
  {
    int                 bit;            /* Bit value */
    int                 count;          /* Count of characters in string */
    int                 first;          /* First character in range */
    int                 last;           /* Last character in range */
    int                 star;           /* Repeat prefix flag */

    if(*p == '^') fputc(*p++,fo);       /* Print leading caret */
    while(*p != T_END)                  /* While not at end of expression */
      {
        star = 0;                       /* Assume no prefix */
        if(*p == T_STAR)                /* If repeat prefix found */
          {
            ++star;                     /* Set flag */
            ++p;                        /* Skip prefix */
          }
        switch(*p++)                    /* Switch on token type */
          {
            case T_END:                 /* End of expression */
            case T_STAR:                /* Repeat prefix */
              fprintf(stderr,"Internal error: exprprint\n");
                                        /* Not valid */
              exit(2);                  /* Die abnormal death */

            case T_STRING:              /* String */
              count = *p++;             /* Get string length */
              goto common;              /* Forgive me, Djikstra! */

            case T_SINGLE:              /* Single character */
              count = 1;                /* Only one character */
            common:
              while(count-- > 0)        /* While bytes remain */
                {
                  if(*p == EOS)         /* If end-of-string found */
                    {
                      ++p;              /* Skip character */
                      fputc('$',fo);    /* Emit special marker */
                      continue;         /* Next iteration */
                    }
                  if(strchr("*.[\\$",*p) != NULL) fputc('\\',fo);
                                        /* Emit escape if needed */
                  fputc(*p++,fo);       /* Emit the character */
                }
              break;

            case T_ANY:                 /* Match any */
              fputc('.',fo);            /* Emit dot */
              break;

            case T_CLASS:
              first = -1;               /* Initialize */
              fputc('[',fo);            /* Open braces */
              for(count = ' '; count <= '~'; ++count)
                {                       /* Loop through printable characters */
                  if((bit = p[count >> 3] & (1 << (count & 7))) != 0)
                    {                   /* If bit is set */
                      if(first == -1) first = count;
                                        /* Set first bit */
                      last = count;     /* Set last bit */
                    }
                  if((!bit || count == '~') && first != -1)
                    {                   /* If range to print */
                      if(strchr("\\]-",first) != NULL) fputc('\\',fo);
                                        /* Emit escape if needed */
                      fputc(first,fo);  /* Print first character in range */
                      if(last != first) /* If we have a range */
                        {
                          if(last > first + 1) fputc('-',fo);
                                        /* Emit hyphen if needed */
                          if(strchr("\\]-",last) != NULL) fputc('\\',fo);
                                        /* Emit escape if needed */
                          fputc(last,fo);
                                        /* Print last character in range */
                        }
                      first = -1;       /* Range printed */
                    }
                }
              fputc(']',fo);            /* Close braces */
              p += ASCLEN/8;            /* Skip bit vector */
              break;
          }
        if(star) fputc('*',fo);         /* Print star if needed */
      }
    fputc('\n',fo);                     /* Print newline */
  }


char                    *get1stcharset(e,bitvec)
unsigned char           *e;             /* Pointer to expression */
char                    *bitvec;        /* Pointer to bit vector */
  {
    unsigned char       *cp;            /* Char pointer */
    int                 i;              /* Index/counter */
    int                 star;           /* Repeat prefix flag */

    if(*e == '^') ++e;                  /* Skip leading caret if any */
    memset(bitvec,'\0',ASCLEN/8);       /* Clear bit vector */
    cp = e;                             /* Initialize */
    while(*e != T_END)                  /* Loop to process leading *-expr.s */
      {
        star = 0;                       /* Assume no repeat prefix */
        if(*e == T_STAR)                /* If repeat prefix found */
          {
            ++star;                     /* Set flag */
            ++e;                        /* Skip repeat prefix */
          }
        switch(*e++)                    /* Switch on token type */
          {
            case T_END:                 /* End of expression */
            case T_STAR:                /* Repeat prefix */
              fprintf(stderr,"Internal error: get1stcharset\n");
                                        /* Not valid */
              exit(2);                  /* Die abnormal death */

            case T_STRING:              /* String */
              if(star || *e++ == '\0')  /* If repeat prefix or zero count */
                {
                  fprintf(stderr,"Internal error: get1stcharset\n");
                                        /* Not valid */
                  exit(2);              /* Die abnormal death */
                }
              /* Drop through */

            case T_SINGLE:              /* Single character */
              bitset(bitvec,*e,*e,1);   /* Set the bit */
              ++e;                      /* Skip the character */
              break;

            case T_ANY:                 /* Match any */
              memset(bitvec,'\xFF',ASCLEN/8);
                                        /* Set all the bits */
              bitset(bitvec,EOS,EOS,0); /* Except end-of-string */
              bitset(bitvec,'\n','\n',0);
                                        /* And linefeed! */
              break;

            case T_CLASS:
              for(i = 0; i < ASCLEN/8; ++i) bitvec[i] |= *e++;
                                        /* Or in all the bits */
              break;
          }
        if(!star) break;                /* Break if not repeated */
        cp = e;                         /* Update pointer */
      }
    return(cp);                         /* Point to 1st non-repeated expr. */
  }


char                    *findall(buffer,bufend)
char                    *buffer;        /* Buffer in which to search */
char                    *bufend;        /* End of buffer */
  {
    return(buffer < bufend? buffer: NULL);
                                        /* Fail only on empty buffer */
  }


void                    addtoken(e,n)
char                    *e;             /* Raw token expression */
int                     n;              /* Length of expression */
  {
    static char         achpref[] = "^";/* Prefix */
    static char         achprefsuf[] = "[^A-Za-z0-9_]";
                                        /* Prefix/suffix */
    static char         achsuf[] = "$"; /* Suffix */
    char                buffer[BUFLEN]; /* Temporary buffer */

    assert(n >= 2);                     /* Must have at least two characters */
    if(e[0] == '\\' && e[1] == '<')     /* If begin token */
      {
        if(!(flags & BEGLINE))          /* If not matching at beginning only */
          {
            memcpy(buffer,achprefsuf,sizeof achprefsuf - 1);
                                        /* Copy first prefix */
            memcpy(buffer + sizeof achprefsuf - 1,e + 2,n - 2);
                                        /* Attach expression */
            addexpr(buffer,n + sizeof achprefsuf - 3);
                                        /* Add expression */
          }
        memcpy(buffer,achpref,sizeof achpref - 1);
                                        /* Copy second prefix */
        memcpy(buffer + sizeof achpref - 1,e + 2,n - 2);
                                        /* Attach expression */
        addexpr(buffer,n + sizeof achpref - 3);
                                        /* Add expression */
        return;                         /* Done */
      }
    assert(e[n-2] == '\\' && e[n - 1] == '>');
                                        /* Must be end token */
    if(!(flags & ENDLINE))              /* If not matching at end only */
      {
        memcpy(buffer,e,n - 2);         /* Copy expression */
        memcpy(buffer + n - 2,achprefsuf,sizeof achprefsuf - 1);
                                        /* Attach first suffix */
        addexpr(buffer,n + sizeof achprefsuf - 3);
                                        /* Add expression */
      }
    memcpy(buffer,e,n - 2);             /* Copy expression */
    memcpy(buffer + n - 2,achsuf,sizeof achsuf - 1);
                                        /* Attach second suffix */
    addexpr(buffer,n + sizeof achsuf - 3);
                                        /* Add expression */
  }


void                    addexpr(e,n)
char                    *e;             /* Expression to add */
int                     n;              /* Length of expression */
  {
    EXPR                *expr;          /* Expression node pointer */
    int                 i;              /* Index */
    int                 j;              /* Index */
    int                 locflags;       /* Local copy of flags */
    char                bitvec[ASCLEN/8];
                                        /* First char. bit vector */
    char                buffer[BUFLEN]; /* Temporary buffer */

    if(find == findall) return;         /* Return if matching everything */
    if(istoken(e,n))                    /* If expr is token */
      {
        addtoken(e,n);                  /* Convert and add tokens */
        return;                         /* Done */
      }
    locflags = flags;                   /* Initialize local copy */
    if(*e == '^') locflags |= BEGLINE;  /* Set flag if match must begin line */
    j = -2;                             /* Assume no escapes in string */
    for(i = 0; i < n - 1; ++i)          /* Loop to find last escape */
      {
        if(e[i] == '\\') j = i++;       /* Save index of last escape */
      }
    if(n > 0 && e[n-1] == '$' && j != n-2)
      {                                 /* If expr. ends in unescaped '$' */
        --n;                            /* Skip dollar sign */
        locflags |= ENDLINE;            /* Match must be at end */
      }
    strncpy(buffer,e,n);                /* Copy pattern to buffer */
    if(locflags & ENDLINE) buffer[n++] = EOS;
                                        /* Add end character if needed */
    buffer[n] = '\0';                   /* Null-terminate string */
    if((e = exprparse(buffer)) == NULL) return;
                                        /* Return if invalid expression */
    ++strcnt;                           /* Increment string count */
    if(!(locflags & BEGLINE))           /* If match needn't be at beginning */
      {
        e = get1stcharset(e,bitvec);    /* Remove leading *-expr.s */
      }

    /*
     *  E now points to a buffer containing a preprocessed expression.
     *  We need to find the set of allowable first characters and make
     *  the appropriate entries in the string node table.
     */

    if(*get1stcharset(e,bitvec) == T_END)
      {                                 /* If expression will match anything */
        find = findall;                 /* Match everything */
        return;                         /* All done */
      }
    for(j = 0; j < ASCLEN; ++j)         /* Loop to examine bit vector */
      {
        if(bitvec[j >> 3] & (1 << (j & 7)))
          {                             /* If the bit is set */
            expr = (EXPR *) alloc(sizeof(EXPR));
                                        /* Allocate record */
            expr->ex_pattern = e;       /* Point it at pattern */
            if((i = transtab[j]) == 0)  /* If no existing list */
              {
                if((i = clists++) >= ASCLEN)
                  {                     /* If too many string lists */
                    fprintf(stderr,"Too many string lists\n");
                                        /* Error message */
                    exit(2);            /* Die */
                  }
                stringlist[i] = NULL;   /* Initialize */
                transtab[j] = (char) i; /* Set pointer to new list */
                if(!casesen && isalpha(j)) transtab[j ^ 0x20] = (char) i;
                                        /* Set pointer for other case */
              }
            expr->ex_next = stringlist[i];
                                        /* Link new record into table */
            stringlist[i] = expr;
          }
      }
    if(locflags & DEBUG) exprprint(e,stderr);
                                        /* Print the expression if debugging */
  }


char                    *findexpr(buffer,bufend)
unsigned char           *buffer;        /* Buffer in which to search */
char                    *bufend;        /* End of buffer */
  {
    EXPR        *expr;          /* Expression list pointer */
    unsigned char *pattern;     /* Pattern */
    int                 i;              /* Index */

    while(buffer < bufend)              /* Loop to find match */
      {
        if((i = transtab[*buffer++]) == 0) continue;
                                        /* Continue if not valid 1st char */
        if((expr = (EXPR *) stringlist[i]) == NULL)
          {                             /* If null pointer */
            fprintf(stderr,"Internal error: findexpr\n");
                                        /* Print error message */
            exit(2);                    /* Die */
          }
        --buffer;                       /* Back up to first character */
        while(expr != NULL)             /* Loop to find match */
          {
            pattern = expr->ex_pattern; /* Point to pattern */
            expr = expr->ex_next;       /* Point to next record */
            if(pattern[0] == '^')       /* If match begin line */
              {
                ++pattern;              /* Skip caret */
                if(buffer[-1] != '\n') continue;
                                        /* Don't bother if not at beginning */
              }
            if(exprmatch(buffer,pattern)) return(buffer);
                                        /* Return pointer if match found */
          }
        ++buffer;                       /* Skip first character */
      }
    return(NULL);                       /* No match */
  }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\rasdiag\common\capture.h ===
/*++

Copyright (C) 1992-2001 Microsoft Corporation. All rights reserved.

Module Name:

    capture.h

Abstract:

    Netmon-abstraction-related defines
                                                     

Author:

    Anthony Leibovitz (tonyle) 02-01-2001

Revision History:


--*/

#ifndef _CAPTURE_H_
#define _CAPTURE_H_

/*
NETMON
*/
#define  NETMON_INF_STRING              TEXT("ms_netmon")
#define  NETCFG_LIBRARY_NAME            TEXT("netcfgx.dll")
#define  NETCFG_NETINSTALL_ENTRYPOINT   "NetCfgDiagFromCommandArgs"
#define  MAX_LAN_CAPTURE_COUNT          10

typedef struct _RASDIAGCAPTURE {
    BOOL        bWan;
    WCHAR       *pszMacAddr;
    WCHAR       szCaptureFileName[MAX_PATH+1];
    IDelaydC*   pIDelaydC;
    HBLOB       hBlob;
    STATISTICS  stats;
} *PRASDIAGCAPTURE,RASDIAGCAPTURE;

BOOL
DoNetmonInstall(void);

BOOL
IdentifyInterfaces(PRASDIAGCAPTURE *hLAN, DWORD *pdwLanCount);

BOOL
InitIDelaydC(HBLOB hBlob, IDelaydC **ppIDelaydC);

BOOL
DiagStartCapturing(PRASDIAGCAPTURE pNetInterfaces, DWORD dwNetCount);

BOOL
DiagStopCapturing(PRASDIAGCAPTURE pNetInterfaces, DWORD dwNetCount, SYSTEMTIME *pDiagTime, WCHAR *szRasDiagDir);

typedef void (*LPFNNetCfgDiagFromCommandArgs)(DIAG_OPTIONS *);

BOOL
SetAddressFilter(HBLOB hBlob);

BOOL
MoveCaptureFile(PRASDIAGCAPTURE pCapInfo, DWORD dwCapCount, SYSTEMTIME *pDiagTime, WCHAR *pszRasDiagDir);

BOOL
NetmonCleanup(PRASDIAGCAPTURE pNetInterfaces, DWORD dwNetCount);

#endif // _CAPTURE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\ramdiskctrl\ramdiskctrl.c ===
#define UNICODE 1

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntdddisk.h>
#include <ntddscsi.h>
#include <initguid.h>
#include <mountmgr.h>
#include <ntddramd.h>

#define _NTSCSI_USER_MODE_
#include <scsi.h>

#define PAGE_SIZE 4096
#define ROUND_TO_PAGE_SIZE(_x) (((_x) + PAGE_SIZE - 1) & ~(PAGE_SIZE - 1))

#include <windows.h>
#include <devioctl.h>
#include <setupapi.h>
#include <cfgmgr32.h>

#include <rpc.h>

#include <stdio.h>
#include <stddef.h>
#include <stdlib.h>
#include <string.h>

#include <sdistructs.h>

#define SECTOR_SIZE 0x200
#define SECTORS_PER_TRACK 0x80
#define TRACKS_PER_CYLINDER 0x10
#define CYLINDER_SIZE (SECTOR_SIZE * SECTORS_PER_TRACK * TRACKS_PER_CYLINDER)

#define arrayof(a)      (sizeof(a)/sizeof(a[0]))

typedef struct _RAMCTRL_HEADER {
    char Signature[8]; // "ramctrl"
    GUID DiskGuid;
    ULONG DiskOffset;
    ULONG DiskType;
    RAMDISK_CREATE_OPTIONS Options;
} RAMCTRL_HEADER, *PRAMCTRL_HEADER;

typedef union _RAMDISK_HEADER {

    RAMCTRL_HEADER Ramctrl;
    SDI_HEADER Sdi;

} RAMDISK_HEADER, *PRAMDISK_HEADER;

VOID
PrintError(
    ULONG ErrorCode
    )
{
    WCHAR errorBuffer[512];
    ULONG count;

    count = FormatMessage(
                FORMAT_MESSAGE_FROM_SYSTEM,
                NULL,
                ErrorCode,
                0,
                errorBuffer,
                arrayof(errorBuffer),
                NULL
                );

    if ( count != 0 ) {
        printf( "%ws\n", errorBuffer );
    } else {
        printf( "Format message failed. Error: %d\n", GetLastError() );
    }

    return;

} // PrintError

VOID
ListDisks (
    HANDLE ControlHandle
    )
{
    BOOL ok;
    WCHAR actualDeviceName[MAX_PATH];
    WCHAR foundDeviceName[MAX_PATH];
    WCHAR dosDeviceName[MAX_PATH];
    WCHAR driveLetterString[3] = L"A:";
    BOOL foundRamDisk;
    BOOL foundDriveLetter;
    LPCGUID interfaceGuid;
    GUID foundGuid;
    PWSTR guidPtr;
    UNICODE_STRING guidString;
    GUID diskGuid;
    HDEVINFO devinfo;
    SP_DEVICE_INTERFACE_DATA interfaceData;
    BYTE detailBuffer[sizeof(SP_DEVICE_INTERFACE_DETAIL_DATA) + (MAX_PATH * sizeof(WCHAR))];
    PSP_DEVICE_INTERFACE_DETAIL_DATA interfaceDetailData;
    SP_DEVINFO_DATA devinfoData;
    DWORD i;
    RAMDISK_QUERY_INPUT queryInput;
    BYTE queryOutputBuffer[sizeof(RAMDISK_QUERY_OUTPUT) + (MAX_PATH * sizeof(WCHAR))];
    PRAMDISK_QUERY_OUTPUT queryOutput;
    DWORD returnedLength;

    interfaceDetailData = (PSP_DEVICE_INTERFACE_DETAIL_DATA)detailBuffer;
    queryOutput = (PRAMDISK_QUERY_OUTPUT)queryOutputBuffer;

    interfaceGuid = &RamdiskDiskInterface;

    foundRamDisk = FALSE;

    do {

        devinfo = SetupDiGetClassDevs(
                    interfaceGuid,
                    NULL,
                    NULL,
                    DIGCF_PRESENT | DIGCF_DEVICEINTERFACE
                    );
    
        if ( devinfo == NULL ) {
    
            printf( "ListDisks: SetupDiGetClassDevs failed: %d\n", GetLastError() );
            return;
        }

        ZeroMemory( &interfaceData, sizeof(interfaceData) );
        interfaceData.cbSize = sizeof(interfaceData);

        //
        // Enumerate the device interfaces of the class.
        //

        for (i = 0;
             SetupDiEnumDeviceInterfaces( devinfo, NULL, interfaceGuid, i, &interfaceData );
             i++ ) {

            interfaceDetailData->cbSize = sizeof(*interfaceDetailData);
            devinfoData.cbSize = sizeof(devinfoData);

            if ( !SetupDiGetDeviceInterfaceDetail(
                    devinfo,
                    &interfaceData,
                    interfaceDetailData,
                    sizeof(detailBuffer),
                    NULL,
                    &devinfoData
                    ) ) {

                //printf( "ListDisks: SetupDiGetDeviceInterfaceDetail failed for item %d. (%d)\n", i, GetLastError() );

                wcscpy( interfaceDetailData->DevicePath, L"<couldn't retrieve name>" );
            }

            //printf( "Enumerated device %ws\n", interfaceDetailData->DevicePath );

            if ( !SetupDiGetDeviceRegistryProperty(
                    devinfo,
                    &devinfoData,
                    SPDRP_BUSTYPEGUID,
                    NULL,
                    (PBYTE)&foundGuid,
                    sizeof(foundGuid),
                    NULL
                    ) ) {

                DWORD error = GetLastError();
                //printf( "ListDisks: SetupDiGetDeviceRegistryProperty (bus GUID) failed for %ws: %d\n", interfaceDetailData->DevicePath, error );
                continue;
            }

            if ( memcmp( &foundGuid, &GUID_BUS_TYPE_RAMDISK, sizeof(GUID) ) != 0 ) {

                //printf( "ListDisks: skipping non-ramdisk device %ws\n", interfaceDetailData->DevicePath );
                continue;
            }

            if ( !SetupDiGetDeviceRegistryProperty(
                    devinfo,
                    &devinfoData,
                    SPDRP_PHYSICAL_DEVICE_OBJECT_NAME,
                    NULL,
                    (PBYTE)actualDeviceName,
                    sizeof(actualDeviceName),
                    NULL
                    ) ) {

                DWORD error = GetLastError();
                printf( "ListDisks: SetupDiGetDeviceRegistryProperty (name) failed for %ws: %d\n", interfaceDetailData->DevicePath, error );
                continue;
            }

            foundRamDisk = TRUE;

            printf( "\n%ws\n", interfaceDetailData->DevicePath );
            printf( "  Device name: %ws\n", actualDeviceName );

            guidPtr = wcschr( actualDeviceName, L'{' );
            swprintf( dosDeviceName, L"Ramdisk%ws", guidPtr );

            if ( QueryDosDeviceW(dosDeviceName, foundDeviceName, arrayof(foundDeviceName)) ) {

                printf( "  DosDevice name %ws is assigned to this device\n", dosDeviceName );

            } else {

                printf( "  No DosDevice name was assigned to this device\n" );
            }

            foundDriveLetter = FALSE;

            for ( driveLetterString[0] = 'A';
                  driveLetterString[0] <= 'Z';
                  driveLetterString[0]++ ) {
    
                if ( QueryDosDeviceW(driveLetterString, foundDeviceName, arrayof(foundDeviceName)) &&
                     (_wcsicmp(actualDeviceName, foundDeviceName) == 0) ) {
    
                    printf( "  Drive letter %ws is assigned to this device\n", driveLetterString );
                    foundDriveLetter = TRUE;
                    break;
                }
            }
    
            if ( !foundDriveLetter ) {
                printf( "  No letter was assigned to this device\n" );
            }

            guidString.Buffer = guidPtr;
            guidString.Length = (USHORT)(wcslen(guidPtr) * sizeof(WCHAR));
            guidString.MaximumLength = guidString.Length;

            RtlGUIDFromString( &guidString, &diskGuid );

            queryInput.Version = sizeof(RAMDISK_QUERY_INPUT);
            queryInput.DiskGuid = diskGuid;

            ok = DeviceIoControl(
                    ControlHandle,
                    FSCTL_QUERY_RAM_DISK,
                    &queryInput,
                    sizeof(queryInput),
                    queryOutput,
                    sizeof(queryOutputBuffer),
                    &returnedLength,
                    FALSE
                    );
        
            if ( !ok ) {

               DWORD errorCode = GetLastError();
               printf( "Error querying RAM disk: %d\n", errorCode );
               PrintError( errorCode );

            } else {

                printf( "  RAM disk information:\n" );
                if ( queryOutput->DiskType == RAMDISK_TYPE_BOOT_DISK ) {
                    printf( "    Type: boot disk\n" );
                    printf( "    Base page: 0x%x\n", queryOutput->BasePage );
                } else {
                    printf( "    Type: %s\n",
                                queryOutput->DiskType == RAMDISK_TYPE_FILE_BACKED_VOLUME ? "volume" : "disk" );
                    printf( "    File: %ws\n", queryOutput->FileName );
                }
                printf( "    Length: 0x%I64x\n", queryOutput->DiskLength );
                printf( "    Offset: 0x%x\n", queryOutput->DiskOffset );
                if ( queryOutput->DiskType != RAMDISK_TYPE_BOOT_DISK ) {
                    printf( "    View count: 0x%x\n", queryOutput->ViewCount );
                    printf( "    View length: 0x%x\n", queryOutput->ViewLength );
                }
                printf( "    Options: " );
                printf( "%s; ", queryOutput->Options.Fixed ? "fixed" : "removable" );
                printf( "%s; ", queryOutput->Options.Readonly ? "readonly" : "writeable" );
                printf( "%s; ", queryOutput->Options.NoDriveLetter ? "no drive letter" : "drive letter" );
                printf( "%s; ", queryOutput->Options.Hidden ? "hidden" : "visible" );
                printf( "%s\n", queryOutput->Options.NoDosDevice ? "no DosDevice" : "DosDevice" );
            }
        }

        SetupDiDestroyDeviceInfoList( devinfo );

        if ( interfaceGuid == &RamdiskDiskInterface ) {
            interfaceGuid = &MOUNTDEV_MOUNTED_DEVICE_GUID;
        } else {
            break;
        }

    } while ( TRUE );

    if ( !foundRamDisk ) {
        printf( "No RAM disks found\n" );
    }

    return;

} // ListDisks

VOID
FindDisk (
    ULONG DiskType,
    PUNICODE_STRING DiskGuidString,
    BOOL WaitForDeletion
    )
{
    WCHAR actualDeviceName[MAX_PATH];
    WCHAR foundDeviceName[MAX_PATH];
    WCHAR dosDeviceName[MAX_PATH];
    WCHAR driveLetterString[3] = L"A:";
    BOOL found;
    LPCGUID interfaceGuid;
    HDEVINFO devinfo;
    SP_DEVICE_INTERFACE_DATA interfaceData;
    BYTE detailBuffer[sizeof(SP_DEVICE_INTERFACE_DETAIL_DATA) + (MAX_PATH * sizeof(WCHAR))];
    PSP_DEVICE_INTERFACE_DETAIL_DATA interfaceDetailData;
    SP_DEVINFO_DATA devinfoData;
    DWORD i;

    interfaceDetailData = (PSP_DEVICE_INTERFACE_DETAIL_DATA)detailBuffer;

    swprintf( actualDeviceName, L"\\Device\\Ramdisk%wZ", DiskGuidString );

    printf( "Waiting for device %ws to be %s...",
            actualDeviceName,
            WaitForDeletion ? "deleted" : "ready" );

    if ( DiskType == RAMDISK_TYPE_FILE_BACKED_DISK ) {
        interfaceGuid = &RamdiskDiskInterface;
    } else {
        interfaceGuid = &MOUNTDEV_MOUNTED_DEVICE_GUID;
    }

    found = FALSE;

    do {

        devinfo = SetupDiGetClassDevs(
                    interfaceGuid,
                    NULL,
                    NULL,
                    DIGCF_PRESENT | DIGCF_DEVICEINTERFACE
                    );
    
        if ( devinfo == NULL ) {
    
            printf( "\nFindDisk: SetupDiGetClassDevs failed: %d\n", GetLastError() );
            return;
        }

        ZeroMemory( &interfaceData, sizeof(interfaceData) );
        interfaceData.cbSize = sizeof(interfaceData);

        //
        // Enumerate the device interfaces of the class.
        //

        for (i = 0;
             SetupDiEnumDeviceInterfaces( devinfo, NULL, interfaceGuid, i, &interfaceData );
             i++ ) {

            interfaceDetailData->cbSize = sizeof(*interfaceDetailData);
            devinfoData.cbSize = sizeof(devinfoData);

            if ( !SetupDiGetDeviceInterfaceDetail(
                    devinfo,
                    &interfaceData,
                    interfaceDetailData,
                    sizeof(detailBuffer),
                    NULL,
                    &devinfoData
                    ) ) {

                //printf( "\nFindDisk: SetupDiGetDeviceInterfaceDetail failed for item %d. (%d)\n", i, GetLastError() );

                wcscpy( interfaceDetailData->DevicePath, L"<couldn't retrieve name>" );
            }

            //printf( "\nEnumerated device %ws\n", interfaceDetailData->DevicePath );

            if ( !SetupDiGetDeviceRegistryProperty(
                    devinfo,
                    &devinfoData,
                    SPDRP_PHYSICAL_DEVICE_OBJECT_NAME,
                    NULL,
                    (PBYTE)foundDeviceName,
                    sizeof(foundDeviceName),
                    NULL
                    ) ) {

                DWORD error = GetLastError();
                //printf( "\nFindDisk: SetupDiGetDeviceRegistryProperty (name) failed for %ws: %d\n", interfaceDetailData->DevicePath, error );
                continue;
            }

            //printf( "\nTarget device %ws\n", foundDeviceName );

            if ( _wcsicmp( actualDeviceName, foundDeviceName ) != 0 ) {
                continue;
            }

            found = TRUE;
            break;
        }

        SetupDiDestroyDeviceInfoList( devinfo );

        if ( !found ) {

            if ( WaitForDeletion ) {

                printf( "\nRAM disk is now gone\n" );
                return;
            }

            //printf( "Enumeration failed to find target device; sleeping\n" );
            printf( "." );

            Sleep( 500 );

        } else {

            if ( !WaitForDeletion ) {

                printf( "\nRAM disk is now ready\n" );
                break;
            }

            //printf( "Enumeration found target device; sleeping\n" );
            printf( "." );

            Sleep( 500 );

            found = FALSE;
        }

    } while ( TRUE );

    if ( found ) {

        swprintf( dosDeviceName, L"Ramdisk%wZ", DiskGuidString );

        if ( QueryDosDeviceW(dosDeviceName, foundDeviceName, arrayof(foundDeviceName)) ) {

            printf( "  DosDevice name %ws is assigned to this device\n", dosDeviceName );

        } else {

            printf( "  No DosDevice name was assigned to this device\n" );
        }

        found = FALSE;

        for ( driveLetterString[0] = 'A';
              driveLetterString[0] <= 'Z';
              driveLetterString[0]++ ) {

            if ( QueryDosDeviceW(driveLetterString, foundDeviceName, arrayof(foundDeviceName)) &&
                 (_wcsicmp(actualDeviceName, foundDeviceName) == 0) ) {

                printf( "  Drive letter %ws is assigned to this device\n", driveLetterString );
                found = TRUE;
                break;
            }
        }

        if ( !found ) {
            printf( "  No letter was assigned to this device\n" );
        }
    }

    return;

} // FindDisk
                 
VOID
FullFilePath (
    PWCHAR pwzPath
    )
{
    WCHAR wzDevPath[512] = L"";
    WCHAR wzDosPath[512] = L"";
    PWCHAR pwzDosName = wzDosPath;
    DWORD dw;
    WCHAR c;

    dw = GetFullPathNameW(pwzPath, arrayof(wzDosPath), wzDosPath, NULL);
    if (0 != dw) {
        if (NULL != (pwzDosName = wcschr(wzDosPath, ':'))) {
            pwzDosName++;
            c = *pwzDosName;
            *pwzDosName = '\0';

            dw = QueryDosDeviceW(wzDosPath, wzDevPath, arrayof(wzDevPath));
            if (0 != dw) {
                *pwzDosName = c;
            
                swprintf(pwzPath, L"%ls%ls", wzDevPath, pwzDosName);
            }
            else {
                printf("QueryDosDeviceW(%ls) failed: %d\n", wzDosPath, GetLastError());
                PrintError(GetLastError());
            }
        }
    }
}

BOOLEAN
IsDriveLetter (
    PWCHAR Name
        )
{
    if ((((Name[0] >= L'A') && (Name[0] <= L'Z')) ||
         ((Name[0] >= L'a') && (Name[0] <= L'z'))) &&
        (Name[1] == L':') &&
        (Name[2] == 0)) {
        return TRUE;
    }
    return FALSE;
}

VOID
DeleteRamdisk (
    IN HANDLE ControlHandle,
    IN PWSTR FileName
    )
{
    BOOL ok;
    ULONG errorCode = 0;
    ULONG returnedLength = 0;
    UNICODE_STRING ustr;
    OBJECT_ATTRIBUTES obja;
    IO_STATUS_BLOCK iosb;
    NTSTATUS status;
    HANDLE imageFileHandle;
    HANDLE volumeHandle;
    RAMDISK_HEADER ramdiskHeader;
    UNICODE_STRING guidString;
    LARGE_INTEGER offset;
    LPCGUID diskGuid;
    ULONG diskType;
    RAMDISK_QUERY_INPUT queryInput;
    RAMDISK_MARK_FOR_DELETION_INPUT markInput;
    BYTE queryOutputBuffer[sizeof(RAMDISK_QUERY_OUTPUT) + (MAX_PATH * sizeof(WCHAR))];
    PRAMDISK_QUERY_OUTPUT queryOutput;
    CONFIGRET cr;
    DEVNODE devnode;
    WCHAR devinst[MAX_PATH];
    PNP_VETO_TYPE vetoType;
    WCHAR vetoName[MAX_PATH];
    WCHAR foundDeviceName[MAX_PATH];

    queryOutput = (PRAMDISK_QUERY_OUTPUT)queryOutputBuffer;

    if ( FileName[0] == L'{' ) {

        guidString.Buffer = FileName;
        guidString.Length = (USHORT)(wcslen(FileName) * sizeof(WCHAR));
        guidString.MaximumLength = guidString.Length;

        queryInput.Version = sizeof(RAMDISK_QUERY_INPUT);
        RtlGUIDFromString( &guidString, &queryInput.DiskGuid );

        ok = DeviceIoControl(
                ControlHandle,
                FSCTL_QUERY_RAM_DISK,
                &queryInput,
                sizeof(queryInput),
                queryOutput,
                sizeof(queryOutputBuffer),
                &returnedLength,
                FALSE
                );
    
        if ( !ok ) {

           DWORD errorCode = GetLastError();
           printf( "Error querying RAM disk: %d\n", errorCode );
           PrintError( errorCode );
           return;

        }

        diskGuid = &queryOutput->DiskGuid;
        diskType = queryOutput->DiskType;

    } else if (IsDriveLetter ( FileName ) ) {

        //
        // Treat FileName as a drive letter.  See if this the supplied
        // drive letter corresponds to a ramdisk.
        //

        if ((QueryDosDeviceW(FileName, foundDeviceName, arrayof(foundDeviceName)) == 0) ||
            wcsncmp(foundDeviceName, L"\\Device\\Ramdisk", wcslen(L"\\Device\\Ramdisk"))) {
            DWORD errorCode = GetLastError();
            printf( "Drive letter \"%ws\" is not assigned to a RAM disk.\n",
                    FileName);
            PrintError( errorCode );
            return;
        }
        guidString.Buffer = wcschr( foundDeviceName, L'{' );
        guidString.Length = (USHORT)(wcslen(guidString.Buffer) * sizeof(WCHAR));
        guidString.MaximumLength = guidString.Length;

        RtlGUIDFromString( &guidString, &queryInput.DiskGuid );

        ok = DeviceIoControl(
                ControlHandle,
                FSCTL_QUERY_RAM_DISK,
                &queryInput,
                sizeof(queryInput),
                queryOutput,
                sizeof(queryOutputBuffer),
                &returnedLength,
                FALSE
                );
    
        if ( !ok ) {

           DWORD errorCode = GetLastError();
           printf( "Error querying RAM disk: %d\n", errorCode );
           PrintError( errorCode );
           return;

        }

        diskGuid = &queryOutput->DiskGuid;
        diskType = queryOutput->DiskType;

    } else {
    
        RtlInitUnicodeString( &ustr, FileName );
        InitializeObjectAttributes( &obja, &ustr, OBJ_CASE_INSENSITIVE, NULL, NULL );
    
        status = NtOpenFile(
                    &imageFileHandle,
                    SYNCHRONIZE | FILE_READ_DATA | FILE_READ_ATTRIBUTES,
                    &obja,
                    &iosb,
                    FILE_SHARE_READ,
                    FILE_SYNCHRONOUS_IO_ALERT
                    );
        if ( !NT_SUCCESS(status) ) {
            printf( "Can't open target file %ws: %x\n", FileName, status );
            errorCode = RtlNtStatusToDosError( status );
            PrintError( errorCode );
            return;
        }
    
        //
        // Read and verify the header.
        //

        offset.QuadPart = 0;

        status = NtReadFile(
                    imageFileHandle,
                    NULL,
                    NULL,
                    NULL,
                    &iosb,
                    &ramdiskHeader,
                    sizeof(ramdiskHeader),
                    &offset,
                    NULL
                    );
        if ( !NT_SUCCESS(status) ) {
            printf( "Can't read header from target file %ws: %x\n", FileName, status );
            errorCode = RtlNtStatusToDosError( status );
            PrintError( errorCode );
            return;
        }

        if ( strcmp( ramdiskHeader.Ramctrl.Signature, "ramctrl" ) == 0 ) {

            diskGuid = &ramdiskHeader.Ramctrl.DiskGuid;
            diskType = ramdiskHeader.Ramctrl.DiskType;

        } else if ( strncmp( ramdiskHeader.Sdi.Signature, SDI_SIGNATURE, strlen(SDI_SIGNATURE) ) == 0 ) {

            diskGuid = (LPCGUID)ramdiskHeader.Sdi.RuntimeGUID;
            diskType = RAMDISK_TYPE_FILE_BACKED_VOLUME;

        } else {

            printf( "Header in target file not recognized\n" );
            return;
        }

    
        NtClose( imageFileHandle );

        RtlStringFromGUID( diskGuid, &guidString );
    }

    printf("Attempting to delete \\Device\\Ramdisk%wZ\n", &guidString );

    swprintf( devinst, L"\\Device\\Ramdisk%ws", guidString.Buffer );

    RtlInitUnicodeString( &ustr, devinst );
    InitializeObjectAttributes( &obja, &ustr, OBJ_CASE_INSENSITIVE, NULL, NULL );

    status = NtOpenFile(
                &volumeHandle,
                SYNCHRONIZE | FILE_READ_DATA | FILE_WRITE_DATA,
                &obja,
                &iosb,
                FILE_SHARE_READ | FILE_SHARE_WRITE,
                FILE_SYNCHRONOUS_IO_ALERT
                );
    if ( !NT_SUCCESS(status) ) {
        printf( "Can't open target device %ws: %x\n", devinst, status );
        errorCode = RtlNtStatusToDosError( status );
        PrintError( errorCode );
        return;
    }

    printf( "Syncing %ws ... ", devinst );

    if ( !FlushFileBuffers( volumeHandle ) ) {

        errorCode = GetLastError();
        // NOTE: [bassamt] FlushFileBuffers can fail with error code 
        // ERROR_INVALID_FUNCTION if the volume is not formatted.
        // NOTE: [brimo] FlushFileBuffers can fail with error code
        // ERROR_WRITE_PROTECT if the volume is mounted read-only
        if ((errorCode != ERROR_INVALID_FUNCTION) && (errorCode != ERROR_WRITE_PROTECT)) {
            printf( "flush failed (%u)\n", errorCode );
            PrintError( errorCode );
            return;
        }
    }

    if ( !DeviceIoControl(
            volumeHandle,
            FSCTL_LOCK_VOLUME,
            NULL,
            0,
            NULL,
            0,
            &returnedLength,
            NULL
            ) ) {
        
        errorCode = GetLastError();
        printf( "lock volume failed (%u)\n", errorCode );
        PrintError( errorCode );
        return;
    }

    if ( !DeviceIoControl(
            volumeHandle,
            FSCTL_DISMOUNT_VOLUME,
            NULL,
            0,
            NULL,
            0,
            &returnedLength,
            NULL
            ) ) {

        errorCode = GetLastError();
        printf( "dismount volume failed (%u)\n", errorCode );
        PrintError( errorCode );
        return;
    }

    printf( "done\n" );

    NtClose( volumeHandle );

    markInput.Version = sizeof(RAMDISK_MARK_FOR_DELETION_INPUT);
    markInput.DiskGuid = *diskGuid;

    ok = DeviceIoControl(
            ControlHandle,
            FSCTL_MARK_RAM_DISK_FOR_DELETION,
            &markInput,
            sizeof(markInput),
            NULL,
            0,
            &returnedLength,
            FALSE
            );

    if ( !ok ) {

       DWORD errorCode = GetLastError();
       printf( "Error marking RAM disk: %d\n", errorCode );
       PrintError( errorCode );
       return;
    }

    if ( diskType == RAMDISK_TYPE_FILE_BACKED_DISK ) {
        swprintf( devinst, L"Ramdisk\\Ramdisk\\%ws", guidString.Buffer );
    } else {
        swprintf( devinst, L"Ramdisk\\Ramvolume\\%ws", guidString.Buffer );
    }
    
    cr = CM_Locate_DevNode( &devnode, devinst, 0 );
    if ( cr != CR_SUCCESS ) {
        printf( "Unable to locate devnode: %d\n", cr );
        return;
    }
    cr = CM_Query_And_Remove_SubTree_Ex( devnode, &vetoType, vetoName, MAX_PATH, 0, NULL );
    if ( cr != CR_SUCCESS ) {
        printf( "Unable to remove devnode: %d\n", cr );
        if ( cr == CR_REMOVE_VETOED ) {
            printf( "  veto type = 0x%x\n", vetoType );
            printf( "  veto name = %ws\n", vetoName );
        }
        return;
    }

    FindDisk( diskType, &guidString, TRUE );

    printf( "RAM disk %wZ deleted\n", &guidString );

    return;

} // DeleteRamdisk

void
AddBootFilesToSdi(
    PWCHAR SdiFile,
    PWCHAR StartromFile,
    PWCHAR OsloaderFile
    )
{
    NTSTATUS status;
    UNICODE_STRING ustr;
    OBJECT_ATTRIBUTES obja;
    IO_STATUS_BLOCK iosb;
    HANDLE imageFileHandle;
    HANDLE startromHandle;
    HANDLE osloaderHandle;
    WCHAR dataFileName[512];
    FILE_STANDARD_INFORMATION fileInfo;
    FILE_ALLOCATION_INFORMATION allocInfo;
    SDI_HEADER sdiHeader;
    LARGE_INTEGER offset;
    ULONGLONG diskOffset;
    ULONGLONG diskLength;
    ULONGLONG startromOffset;
    ULONGLONG startromLength;
    ULONGLONG startromLengthAligned;
    ULONGLONG osloaderOffset;
    ULONGLONG osloaderLength;
    ULONGLONG osloaderLengthAligned;
    ULONGLONG finalFileLength;
    ULONG errorCode = 0;
    PUCHAR buffer;

    printf( "Adding boot files to SDI file %ws\n", SdiFile );

    RtlInitUnicodeString( &ustr, SdiFile );
    InitializeObjectAttributes( &obja, &ustr, OBJ_CASE_INSENSITIVE, NULL, NULL );

    status = NtOpenFile(
                &imageFileHandle,
                SYNCHRONIZE | FILE_READ_DATA | FILE_WRITE_DATA | FILE_READ_ATTRIBUTES,
                &obja,
                &iosb,
                0,
                FILE_SYNCHRONOUS_IO_ALERT
                );
    if ( !NT_SUCCESS(status) ) {
        printf( "Can't open target file %ws: %x\n", SdiFile, status );
        errorCode = RtlNtStatusToDosError( status );
        PrintError( errorCode );
        return;
    }

    //
    // Read and verify the header.
    //

    offset.QuadPart = 0;

    status = NtReadFile(
                imageFileHandle,
                NULL,
                NULL,
                NULL,
                &iosb,
                &sdiHeader,
                sizeof(sdiHeader),
                &offset,
                NULL
                );
    if ( !NT_SUCCESS(status) ) {
        printf( "Can't read header from target file %ws: %x\n", SdiFile, status );
        errorCode = RtlNtStatusToDosError( status );
        PrintError( errorCode );
        return;
    }

    if ( strncmp( sdiHeader.Signature, SDI_SIGNATURE, strlen(SDI_SIGNATURE) ) != 0 ) {

        printf( "Header in target file not recognized\n" );
        return;
    }

    diskOffset = sdiHeader.ToC[0].llOffset.LowPart;
    diskLength = sdiHeader.ToC[0].llSize.QuadPart;

    startromOffset = ROUND_TO_PAGE_SIZE( diskOffset + diskLength );

    //
    // Get the length of startrom.com.
    //

    wcscpy( dataFileName, StartromFile );
    FullFilePath( dataFileName );

    RtlInitUnicodeString( &ustr, dataFileName );
    InitializeObjectAttributes( &obja, &ustr, OBJ_CASE_INSENSITIVE, NULL, NULL );

    status = NtOpenFile(
                &startromHandle,
                SYNCHRONIZE | FILE_READ_DATA | FILE_WRITE_DATA | FILE_READ_ATTRIBUTES,
                &obja,
                &iosb,
                0,
                FILE_SYNCHRONOUS_IO_ALERT
                );
    if ( !NT_SUCCESS(status) ) {
        printf( "Can't open startrom file %ws: %x\n", dataFileName, status );
        errorCode = RtlNtStatusToDosError( status );
        PrintError( errorCode );
        return;
    }

    status = NtQueryInformationFile(
                startromHandle,
                &iosb,
                &fileInfo,
                sizeof(fileInfo),
                FileStandardInformation
                );

    if ( !NT_SUCCESS(status) ) {

        printf( "Can't query info for startrom file %ws: %x\n", dataFileName, status );
        errorCode = RtlNtStatusToDosError( status );
        PrintError( errorCode );
        return;
    }

    startromLength = fileInfo.EndOfFile.QuadPart;
    startromLengthAligned = ROUND_TO_PAGE_SIZE( startromLength );

    osloaderOffset = startromOffset + startromLengthAligned;

    //
    // Get the length of osloader.exe.
    //

    wcscpy( dataFileName, OsloaderFile );
    FullFilePath( dataFileName );

    RtlInitUnicodeString( &ustr, dataFileName );
    InitializeObjectAttributes( &obja, &ustr, OBJ_CASE_INSENSITIVE, NULL, NULL );

    status = NtOpenFile(
                &osloaderHandle,
                SYNCHRONIZE | FILE_READ_DATA | FILE_WRITE_DATA | FILE_READ_ATTRIBUTES,
                &obja,
                &iosb,
                0,
                FILE_SYNCHRONOUS_IO_ALERT
                );
    if ( !NT_SUCCESS(status) ) {
        printf( "Can't open osloader file %ws: %x\n", dataFileName, status );
        errorCode = RtlNtStatusToDosError( status );
        PrintError( errorCode );
        return;
    }

    status = NtQueryInformationFile(
                osloaderHandle,
                &iosb,
                &fileInfo,
                sizeof(fileInfo),
                FileStandardInformation
                );

    if ( !NT_SUCCESS(status) ) {

        printf( "Can't query info for osloader file %ws: %x\n", dataFileName, status );
        errorCode = RtlNtStatusToDosError( status );
        PrintError( errorCode );
        return;
    }

    osloaderLength = fileInfo.EndOfFile.QuadPart;
    osloaderLengthAligned = ROUND_TO_PAGE_SIZE( startromLength );

    finalFileLength = osloaderOffset + osloaderLengthAligned;

    //
    // Truncate the file at the end of the disk image, then extend it back.
    //

    printf( "  truncating SDI file at end of ramdisk image %I64d [0x%I64x]\n",
            startromOffset, startromOffset );

    allocInfo.AllocationSize.QuadPart = startromOffset;

    status = NtSetInformationFile(
                imageFileHandle,
                &iosb,
                &allocInfo,
                sizeof(allocInfo),
                FileAllocationInformation
                );
    if ( !NT_SUCCESS(status) ) {

        printf( "Can't set allocation size for image file %ws: %x\n", SdiFile, status );
        errorCode = RtlNtStatusToDosError( status );
        PrintError( errorCode );
        return;
    }

    allocInfo.AllocationSize.QuadPart = finalFileLength;

    status = NtSetInformationFile(
                imageFileHandle,
                &iosb,
                &allocInfo,
                sizeof(allocInfo),
                FileAllocationInformation
                );
    if ( !NT_SUCCESS(status) ) {

        printf( "Can't set allocation size for image file %ws: %x\n", SdiFile, status );
        errorCode = RtlNtStatusToDosError( status );
        PrintError( errorCode );
        return;
    }

    //
    // Copy startrom into the image file.
    //

    printf( "  adding boot file %ws, length %I64d [0x%I64x]\n",
            StartromFile, startromLength, startromLength );

    buffer = malloc( (ULONG)startromLength );

    offset.QuadPart = 0;

    status = NtReadFile(
                startromHandle,
                NULL,
                NULL,
                NULL,
                &iosb,
                buffer,
                (ULONG)startromLength,
                &offset,
                NULL
                );
    if ( !NT_SUCCESS(status) ) {
        printf( "Can't read from startrom file %ws: %x\n", SdiFile, status );
        errorCode = RtlNtStatusToDosError( status );
        PrintError( errorCode );
        return;
    }

    offset.QuadPart = startromOffset;

    status = NtWriteFile(
                imageFileHandle,
                NULL,
                NULL,
                NULL,
                &iosb,
                buffer,
                (ULONG)startromLength,
                &offset,
                NULL
                );
    if ( !NT_SUCCESS(status) ) {
        printf( "Can't write startrom to image file %ws: %x\n", SdiFile, status );
        errorCode = RtlNtStatusToDosError( status );
        PrintError( errorCode );
        return;
    }

    free( buffer );

    //
    // Copy osloader into the image file.
    //

    printf( "  adding load file %ws, length %I64d [0x%I64x]\n",
            OsloaderFile, osloaderLength, osloaderLength );

    buffer = malloc( (ULONG)osloaderLength );

    offset.QuadPart = 0;

    status = NtReadFile(
                osloaderHandle,
                NULL,
                NULL,
                NULL,
                &iosb,
                buffer,
                (ULONG)osloaderLength,
                &offset,
                NULL
                );
    if ( !NT_SUCCESS(status) ) {
        printf( "Can't read from osloader file %ws: %x\n", SdiFile, status );
        errorCode = RtlNtStatusToDosError( status );
        PrintError( errorCode );
        return;
    }

    offset.QuadPart = osloaderOffset;

    status = NtWriteFile(
                imageFileHandle,
                NULL,
                NULL,
                NULL,
                &iosb,
                buffer,
                (ULONG)osloaderLength,
                &offset,
                NULL
                );
    if ( !NT_SUCCESS(status) ) {
        printf( "Can't write osloader to image file %ws: %x\n", SdiFile, status );
        errorCode = RtlNtStatusToDosError( status );
        PrintError( errorCode );
        return;
    }

    free( buffer );

    //
    // Update the header.
    //

    printf( "  updating header\n" );

    sdiHeader.liBootCodeOffset.QuadPart = startromOffset;
    sdiHeader.liBootCodeSize.QuadPart = startromLength;

    sdiHeader.ToC[1].dwType = SDI_BLOBTYPE_BOOT;
    sdiHeader.ToC[1].llOffset.QuadPart = startromOffset;
    sdiHeader.ToC[1].llSize.QuadPart = startromLength;

    sdiHeader.ToC[2].dwType = SDI_BLOBTYPE_LOAD;
    sdiHeader.ToC[2].llOffset.QuadPart = osloaderOffset;
    sdiHeader.ToC[2].llSize.QuadPart = osloaderLength;

    offset.QuadPart = 0;

    status = NtWriteFile(
                imageFileHandle,
                NULL,
                NULL,
                NULL,
                &iosb,
                &sdiHeader,
                sizeof(sdiHeader),
                &offset,
                NULL
                );
    if ( !NT_SUCCESS(status) ) {
        printf( "Can't write header to image file %ws: %x\n", SdiFile, status );
        errorCode = RtlNtStatusToDosError( status );
        PrintError( errorCode );
        return;
    }

    printf( "  done\n" );

    NtClose( osloaderHandle );
    NtClose( startromHandle );
    NtClose( imageFileHandle );

    return;
}

int
__cdecl
wmain (
    ULONG argc,
    WCHAR *argv[])
{
    BOOL ok;
    HANDLE controlHandle = NULL;
    PUCHAR dataBuffer = NULL;
    UCHAR buffer[2048];
    WCHAR string[25];
    ULONG length = 0;
    ULONG errorCode = 0;
    ULONG returned = 0;
    ULONG sizeInMb;
    ULONG diskType;
    WCHAR fileName[512];
    ULONG desiredSize;
    ULONG actualSize;
    ULONG controlSize;
    UNICODE_STRING ustr;
    OBJECT_ATTRIBUTES obja;
    IO_STATUS_BLOCK iosb;
    NTSTATUS status;
    PRAMDISK_CREATE_INPUT createInput;
    ULONG arg;
    BOOL fNeedHelp = FALSE;
    HANDLE imageFileHandle;
    LARGE_INTEGER allocation;
    BOOL fixed;
    BOOL readonly;
    BOOL delete = FALSE;
    ULONG diskNumber;
    BOOL noDriveLetter;
    BOOL hidden;
    BOOL noDosDevice;
    BOOL ignoreHeader;
    BOOL bootDisk;
    BOOL useSdi;
    ULONG diskOffset;
    RAMDISK_HEADER ramdiskHeader;
    UNICODE_STRING guidString;
    LARGE_INTEGER offset;
    PWCHAR startromFile = NULL;
    PWCHAR osloaderFile = NULL;

    sizeInMb = 64;
    diskType = RAMDISK_TYPE_FILE_BACKED_VOLUME;
    fileName[0] = 0;
    fixed = TRUE;
    readonly = FALSE;
    noDriveLetter = FALSE;
    hidden = FALSE;
    noDosDevice = FALSE;
    ignoreHeader = FALSE;
    bootDisk = FALSE;
    diskOffset = PAGE_SIZE;
    useSdi = FALSE;

    for ( arg = 1; arg < argc; arg++ ) {

        // process options
        if ( (argv[arg][0] == '-') || (argv[arg][0] == '/') ) {

            PWCHAR argn = argv[arg]+1;                   // Argument name
            PWCHAR argp = argn;							// Argument parameter

            while ( *argp && (*argp != ':') ) {
                argp++;
            }
            if ( *argp == ':' ) {
                *argp++ = '\0';
            }

            switch ( argn[0] ) {
            
            case 's':                                 // Size in MB
            case 'S':

                if ( _wcsicmp( argn, L"sdi" ) == 0 ) {
                    useSdi = TRUE;
                } else {
                    sizeInMb = _wtoi(argp);
                }
                break;

            case 'a':
                if ( _wcsicmp( argn, L"addboot" ) == 0 ) {
                    if ( arg+2 < argc ) {
                        startromFile = argv[++arg];
                        osloaderFile = argv[++arg];
                    } else {
                        printf( "Missing startrom/osloader file name\n" );
                        fNeedHelp = TRUE;
                        arg = argc - 1;
                    }
                } else {
                    printf( "Unknown argument: %s\n", argv[arg] );
                    fNeedHelp = TRUE;
                    arg = argc - 1;
                }

            case 'i':                                 // ignore header
            case 'I':
                ignoreHeader = TRUE;
                break;

            case 'b':                                 // use boot disk GUID
            case 'B':
                bootDisk = TRUE;
                break;

            case 'd':                                 // disk offset
            case 'D':
                diskOffset = _wtol(argp);             
                break;

            case 'o':
            case 'O':                                 // Readonly, or options
                if ( *argp ) {

                    BOOL sense = TRUE;

                    do {

                        if ( *argp == '-' ) {
                            sense = FALSE;
                            argp++;
                        } else if ( *argp == '+' ) {
                            sense = TRUE;
                            argp++;
                        }

                        switch ( *argp ) {
                        
                        case 'v':
                        case 'V':
                            diskType = sense ? RAMDISK_TYPE_FILE_BACKED_VOLUME :
                                               RAMDISK_TYPE_FILE_BACKED_DISK;
                            break;

                        case 'r':
                        case 'R':
                            readonly = sense;
                            break;

                        case 'f':
                        case 'F':
                            fixed = sense;
                            break;

                        case 'l':
                        case 'L':
                            noDriveLetter = !sense;
                            break;

                        case 'h':
                        case 'H':
                            hidden = sense;
                            break;

                        case 'd':
                        case 'D':
                            noDosDevice = !sense;
                            break;

                        }

                        sense = TRUE;

                        argp++;

                    } while ( *argp );

                } else {

                    readonly = TRUE;

                }

                break;

            case 'x':                                 // Delete device, not create
            case 'X':
                delete = TRUE;
                break;

            case 'h':									// Help
            case 'H':
            case '?':
                fNeedHelp = TRUE;
                arg = argc - 1;
                break;
                
            default:
                printf( "Unknown argument: %s\n", argv[arg] );
                fNeedHelp = TRUE;
                arg = argc - 1;
                break;
            }

        } else {
            wcscpy( fileName, argv[arg] );
        }
    }

    if ( fNeedHelp ) {

        printf(
            "Usage (to create):\n"
            "    ramdiskctrl [options] win32_disk_file_name\n"
            "or (to delete)\n"
            "    ramdiskctrl -x win32_disk_file_name | {guid} | drive_letter:\n"
            "\n"
            "Options:\n"
            "    -s:N         Set size of disk image in MB (default: 64)\n"
            "    -i           Ignore ramctrl header in existing ramdisk file.\n"
            "    -d:N         Ramdisk offset from start of file. (default: 4096).\n"
            "    -o:options   Options: (use - or + to set sense)\n"
            "        v          Volume (vs. disk) (default: volume)\n"
            "        r          Readonly (default: writeable)\n"
            "        f          Fixed (default: removable)\n"
            "        l          Assign drive letter (default: assign)\n"
            "        h          Hidden (default: visible)\n"
            "        d          Assign DosDevice name (default: assign)\n"
            "    -h or -?  Display this help text.\n"
            );
        return 1;
    }

    if ( !delete ||
        ((fileName[0] != L'{') &&
        !IsDriveLetter(fileName))) {
        FullFilePath( fileName );
    }

    if ( startromFile != NULL ) {

        AddBootFilesToSdi( fileName, startromFile, osloaderFile );

        return 0;
    }

    wcscpy( string, L"\\device\\ramdisk" );
    RtlInitUnicodeString( &ustr, string );

    InitializeObjectAttributes( &obja, &ustr, OBJ_CASE_INSENSITIVE, NULL, NULL );
    //printf( "Opening %ws\n", string );

    status = NtOpenFile(
                &controlHandle,
                GENERIC_READ | GENERIC_WRITE,
                &obja,
                &iosb,
                FILE_SHARE_READ | FILE_SHARE_WRITE,
                FILE_OPEN
                );

    if ( !NT_SUCCESS(status) ) {
        printf( "Error opening control device %ws. Error: %x\n", string, status );
        errorCode = RtlNtStatusToDosError( status );
        PrintError( errorCode );
        return 1;
    }

    if ( delete ) {

        //
        // Delete the disk.
        //

        DeleteRamdisk( controlHandle, fileName );

        return 0;
    }

    if ( fileName[0] == 0 ) {

        //
        // Just list the disks.
        //
    
        ListDisks( controlHandle );
        return 0;
    }

    //
    // If SDI, force the disk type to emulated volume, etc.
    //

    if ( useSdi ) {
        diskType = RAMDISK_TYPE_FILE_BACKED_VOLUME;
        bootDisk = FALSE;
        fixed = TRUE;
        readonly = FALSE;
        noDriveLetter = FALSE;
        hidden = FALSE;
        noDosDevice = FALSE;
    }

    //
    // Create the disk.
    //

    desiredSize = sizeInMb * 1024 * 1024;
    actualSize = ((desiredSize + CYLINDER_SIZE - 1) / CYLINDER_SIZE) * CYLINDER_SIZE;
    if ( actualSize != desiredSize ) {
        printf( "Using rounded-up disk size of %d instead of %d\n", actualSize, desiredSize );
    }

    controlSize = sizeof(RAMDISK_CREATE_INPUT) + (wcslen(fileName) * sizeof(WCHAR));

    createInput = malloc( controlSize );
    if ( createInput == NULL ) {
        printf( "Can't allocate %d bytes for RAMDISK_CREATE_INPUT struct\n", controlSize );
        return 1;
    }

    RtlZeroMemory( createInput, controlSize );
              
    createInput->Version = sizeof(RAMDISK_CREATE_INPUT);
    wcscpy( createInput->FileName, fileName );

    allocation.QuadPart = actualSize + diskOffset;

    RtlInitUnicodeString( &ustr, fileName );
    InitializeObjectAttributes( &obja, &ustr, OBJ_CASE_INSENSITIVE, NULL, NULL );

    status = NtCreateFile(
                &imageFileHandle,
                SYNCHRONIZE | FILE_READ_DATA | FILE_WRITE_DATA | FILE_READ_ATTRIBUTES,
                &obja,
                &iosb,
                &allocation,
                0,
                0,
                FILE_OPEN_IF,
                FILE_SYNCHRONOUS_IO_ALERT,
                NULL,
                0
                );
    if ( !NT_SUCCESS(status) ) {
        printf( "Can't create target file %ws: %x\n", fileName, status );
        errorCode = RtlNtStatusToDosError( status );
        PrintError( errorCode );
        return 1;
    }

    if ( iosb.Information == FILE_CREATED || ignoreHeader ) {

        if ( !bootDisk ) {
            UuidCreate( &createInput->DiskGuid );
        } else {
            createInput->DiskGuid = RamdiskBootDiskGuid;
        }

        createInput->DiskOffset = diskOffset;
        createInput->DiskLength = actualSize;
        createInput->DiskType = diskType;
        createInput->Options.Fixed = (BOOLEAN)fixed;
        createInput->Options.Readonly = (BOOLEAN)readonly;
        createInput->Options.NoDriveLetter = (BOOLEAN)noDriveLetter;
        createInput->Options.Hidden = (BOOLEAN)hidden;
        createInput->Options.NoDosDevice = (BOOLEAN)noDosDevice;

    }

    if ( iosb.Information == FILE_CREATED ) {

        UCHAR byte = 0;

        printf( "Created target file %ws\n", fileName );

        //
        // Extend the file to the desired length.
        //

        offset.QuadPart = actualSize + diskOffset - 1;

        status = NtWriteFile(
                    imageFileHandle,
                    NULL,
                    NULL,
                    NULL,
                    &iosb,
                    &byte,
                    1,
                    &offset,
                    NULL
                    );
        if ( !NT_SUCCESS(status) ) {
            printf( "Can't write to target file %ws: %x\n", fileName, status );
            errorCode = RtlNtStatusToDosError( status );
            PrintError( errorCode );
            return 0;
        }

        //
        // Write the header.
        //

        RtlZeroMemory( &ramdiskHeader, sizeof(ramdiskHeader) );

        if ( !useSdi ) {
        
            strcpy( ramdiskHeader.Ramctrl.Signature, "ramctrl" );
            ramdiskHeader.Ramctrl.DiskGuid = createInput->DiskGuid;
            ramdiskHeader.Ramctrl.DiskOffset = diskOffset;
            ramdiskHeader.Ramctrl.DiskType = diskType;
            ramdiskHeader.Ramctrl.Options = createInput->Options;

        } else {

            memcpy( ramdiskHeader.Sdi.Signature, SDI_SIGNATURE, strlen(SDI_SIGNATURE) );
            ramdiskHeader.Sdi.dwMDBType = SDI_MDBTYPE_VOLATILE;
            memcpy( ramdiskHeader.Sdi.RuntimeGUID, &createInput->DiskGuid, sizeof(GUID) );
            ramdiskHeader.Sdi.dwPageAlignmentFactor = SDI_DEFAULTPAGEALIGNMENT;
            ramdiskHeader.Sdi.ToC[0].dwType = SDI_BLOBTYPE_PART;
            ramdiskHeader.Sdi.ToC[0].llOffset.QuadPart = diskOffset;
            ramdiskHeader.Sdi.ToC[0].llSize.QuadPart = createInput->DiskLength;
        }

        offset.QuadPart = 0;

        status = NtWriteFile(
                    imageFileHandle,
                    NULL,
                    NULL,
                    NULL,
                    &iosb,
                    &ramdiskHeader,
                    sizeof(ramdiskHeader),
                    &offset,
                    NULL
                    );
        if ( !NT_SUCCESS(status) ) {
            printf( "Can't write to target file %ws: %x\n", fileName, status );
            errorCode = RtlNtStatusToDosError( status );
            PrintError( errorCode );
            return 0;
        }

    } else {

        FILE_STANDARD_INFORMATION fileInfo;

        printf( "Using existing target file %ws\n", fileName );

        //
        // Get the length of the existing file.
        //

        status = NtQueryInformationFile(
                    imageFileHandle,
                    &iosb,
                    &fileInfo,
                    sizeof(fileInfo),
                    FileStandardInformation
                    );

        if ( !NT_SUCCESS(status) ) {

            printf( "Can't query info for target file %ws: %x\n", fileName, status );
            errorCode = RtlNtStatusToDosError( status );
            PrintError( errorCode );
            return 0;
        }

        //
        // Read and verify the header.
        //
        if ( !ignoreHeader ) {

            offset.QuadPart = 0;

            status = NtReadFile(
                        imageFileHandle,
                        NULL,
                        NULL,
                        NULL,
                        &iosb,
                        &ramdiskHeader,
                        sizeof(ramdiskHeader),
                        &offset,
                        NULL
                        );
            if ( !NT_SUCCESS(status) ) {
                printf( "Can't read header from target file %ws: %x\n", fileName, status );
                errorCode = RtlNtStatusToDosError( status );
                PrintError( errorCode );
                return 0;
            }

            if ( strcmp( ramdiskHeader.Ramctrl.Signature, "ramctrl" ) == 0 ) {

                createInput->DiskGuid = ramdiskHeader.Ramctrl.DiskGuid;
                createInput->DiskOffset = ramdiskHeader.Ramctrl.DiskOffset;
                createInput->DiskLength = fileInfo.EndOfFile.QuadPart - createInput->DiskOffset;
                diskType = createInput->DiskType = ramdiskHeader.Ramctrl.DiskType;
                createInput->Options = ramdiskHeader.Ramctrl.Options;

            } else if ( strncmp( ramdiskHeader.Sdi.Signature, SDI_SIGNATURE, strlen(SDI_SIGNATURE) ) == 0 ) {

                memcpy( &createInput->DiskGuid, ramdiskHeader.Sdi.RuntimeGUID, sizeof(GUID) );
                createInput->DiskOffset = ramdiskHeader.Sdi.ToC[0].llOffset.LowPart;
                createInput->DiskLength = ramdiskHeader.Sdi.ToC[0].llSize.QuadPart;
                diskType = createInput->DiskType = RAMDISK_TYPE_FILE_BACKED_VOLUME;
                bootDisk = FALSE;
                fixed = TRUE;
                readonly = FALSE;
                noDriveLetter = FALSE;
                hidden = FALSE;
                noDosDevice = FALSE;
                createInput->Options.Fixed = (BOOLEAN)fixed;
                createInput->Options.Readonly = (BOOLEAN)readonly;
                createInput->Options.NoDriveLetter = (BOOLEAN)noDriveLetter;
                createInput->Options.Hidden = (BOOLEAN)hidden;
                createInput->Options.NoDosDevice = (BOOLEAN)noDosDevice;

            } else {
            
                printf( "Header in target file not recognized\n" );
                return 0;
            }
        }

    }

    NtClose( imageFileHandle );

    RtlStringFromGUID( &createInput->DiskGuid, &guidString );

    printf( "Creating RAM disk:\n" );
    printf( "     File: %ws\n", createInput->FileName );
    printf( "     Type: %s\n",
                    createInput->DiskType == RAMDISK_TYPE_FILE_BACKED_VOLUME ? "volume" : "disk" );
    printf( "   Length: 0x%I64x\n", createInput->DiskLength );
    printf( "   Offset: 0x%x\n", createInput->DiskOffset );
    printf( "     GUID: %wZ\n", &guidString );
    printf( "  Options:" );
    printf( "%s; ", createInput->Options.Fixed ? "fixed" : "removable" );
    printf( "%s; ", createInput->Options.Readonly ? "readonly" : "writeable" );
    printf( "%s; ", createInput->Options.NoDriveLetter ? "no drive letter" : "drive letter" );
    printf( "%s; ", createInput->Options.Hidden ? "hidden" : "visible" );
    printf( "%s\n", createInput->Options.NoDosDevice ? "no DosDevice" : "DosDevice" );

    ok = DeviceIoControl(
            controlHandle,
            FSCTL_CREATE_RAM_DISK,
            createInput,
            controlSize,
            NULL,
            0,
            &returned,
            FALSE
            );

    if ( !ok ) {
       errorCode = GetLastError();
       printf( "Error creating RAM disk: %d\n", errorCode );
       PrintError( errorCode );
       return 1;
    }
   
    printf( "RAM disk created\n" );

    FindDisk( createInput->DiskType, &guidString, FALSE );

    return 0;

} // wmain
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\qfecheck\spapip.h ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    spapip.h

Abstract:

    Header file for routines exported from setupapi.dll that are NOT
    part of the setup API, and are thus intended for private/internal use.

Author:

    Ted Miller (tedm) 31-Mar-1995

Revision History:

--*/


#ifdef UNICODE
typedef LPCWSTR  PCTSTR;
#else
typedef LPCSTR   PCTSTR;
#endif

//
// Work around weirdness with Win32 typedef...
//
#ifdef NT_INCLUDED

//
// __int64 is only supported by 2.0 and later midl.
// __midl is set by the 2.0 midl and not by 1.0 midl.
//
#if (!defined(MIDL_PASS) || defined(__midl)) && (!defined(_M_IX86) || (defined(_INTEGRAL_MAX_BITS) && _INTEGRAL_MAX_BITS >= 64))
typedef unsigned __int64 DWORDLONG;
#else
typedef double DWORDLONG;
#endif
typedef DWORDLONG *PDWORDLONG;

#endif /* NT_INCLUDED */

//
// Memory allocation functions
//
BOOL
MemoryInitialize(
    IN BOOL Attach
    );

PVOID
MyMalloc(
    IN DWORD Size
    );

PVOID
MyRealloc(
    IN PVOID Block,
    IN DWORD NewSize
    );

VOID
MyFree(
    IN CONST VOID *Block
    );

VOID
OutOfMemory(
    IN HWND Owner OPTIONAL
    );


//
// String table functions
//
PVOID
StringTableInitialize(
    VOID
    );

PVOID
StringTableInitializeEx(
    IN UINT ExtraDataSize,  OPTIONAL
    IN UINT Reserved
    );

VOID
StringTableDestroy(
    IN PVOID StringTable
    );

//
// Flags to be used by StringTableAddString and StringTableLookUpString
//
#define STRTAB_CASE_INSENSITIVE 0x00000000
#define STRTAB_CASE_SENSITIVE   0x00000001
#define STRTAB_BUFFER_WRITEABLE 0x00000002
#define STRTAB_NEW_EXTRADATA    0x00000004

LONG
StringTableAddString(
    IN     PVOID StringTable,
    IN OUT PTSTR String,
    IN     DWORD Flags
    );

LONG
StringTableAddStringEx(
    IN PVOID StringTable,
    IN PTSTR String,
    IN DWORD Flags,
    IN PVOID ExtraData,     OPTIONAL
    IN UINT  ExtraDataSize  OPTIONAL
    );

LONG
StringTableLookUpString(
    IN     PVOID StringTable,
    IN OUT PTSTR String,
    IN     DWORD Flags
    );

LONG
StringTableLookUpStringEx(
    IN     PVOID StringTable,
    IN OUT PTSTR String,
    IN     DWORD Flags,
       OUT PVOID ExtraData,             OPTIONAL
    IN     UINT  ExtraDataBufferSize    OPTIONAL
    );

BOOL
StringTableGetExtraData(
    IN  PVOID StringTable,
    IN  LONG  StringId,
    OUT PVOID ExtraData,
    IN  UINT  ExtraDataBufferSize
    );

BOOL
StringTableSetExtraData(
    IN PVOID StringTable,
    IN LONG  StringId,
    IN PVOID ExtraData,
    IN UINT  ExtraDataSize
    );

//
// Type for StringTableEnum
//
typedef
BOOL
(*PSTRTAB_ENUM_ROUTINE)(
    IN PVOID  StringTable,
    IN LONG   StringId,
    IN PCTSTR String,
    IN PVOID  ExtraData,
    IN UINT   ExtraDataSize,
    IN LPARAM lParam
    );

BOOL
StringTableEnum(
    IN  PVOID                StringTable,
    OUT PVOID                ExtraDataBuffer,     OPTIONAL
    IN  UINT                 ExtraDataBufferSize, OPTIONAL
    IN  PSTRTAB_ENUM_ROUTINE Callback,
    IN  LPARAM               lParam               OPTIONAL
    );

PTSTR
StringTableStringFromId(
    IN PVOID StringTable,
    IN LONG  StringId
    );

BOOL
StringTableStringFromIdEx(
    IN PVOID StringTable,
    IN LONG  StringId,
    IN OUT PTSTR pBuffer,
    IN OUT PULONG pBufSize
    );



VOID
StringTableTrim(
    IN PVOID StringTable
    );

PVOID
StringTableDuplicate(
    IN PVOID StringTable
    );


//
// Global flags / overrides 
//
VOID
pSetupSetGlobalFlags(
    IN DWORD flags
    );

DWORD
pSetupGetGlobalFlags(
    VOID
    );

#define PSPGF_NO_RUNONCE          0x00000001 // set to inhibit runonce calls
#define PSPGF_NO_BACKUP           0x00000002 // set to inhibit automatic backup 
#define PSPGF_NONINTERACTIVE      0x00000004 // set to inhibit all UI
#define PSPGF_SERVER_SIDE_RUNONCE 0x00000008 // batch RunOnce entries for server-side processing
#define PSPGF_NO_VERIFY_INF       0x00000010 // set to inhibit verification (digital signature) of INFs

//
// Server-side (non-interactive mode) RunOnce processing support
//
typedef struct _RUNONCE_NODE {

    struct _RUNONCE_NODE *Next;

    PCWSTR DllFullPath;
    PCSTR  DllEntryPointName;
    PCWSTR DllParams;

} RUNONCE_NODE, *PRUNONCE_NODE;

PRUNONCE_NODE
pSetupAccessRunOnceNodeList(
    VOID
    );

VOID
pSetupDestroyRunOnceNodeList(
    VOID
    );

//
// per queue overrides 
//
BOOL
pSetupSetQueueFlags(
    IN HSPFILEQ QueueHandle,
    IN DWORD flags
    );

DWORD
pSetupGetQueueFlags(
    IN HSPFILEQ QueueHandle
    );

//
// Queue flags.
//
#define FQF_TRY_SIS_COPY                    0x00000001  // try SIS copy first
#define FQF_BACKUP_AWARE                    0x00010000  // allow callbacks
#define FQF_DID_CATALOGS_OK                 0x00020000  // catalog/inf verification has run
#define FQF_DID_CATALOGS_FAILED             0x00040000  // catalog/inf verification has run
#define FQF_DIGSIG_ERRORS_NOUI              0x00080000  // prompt user on failed signature
                                                        // verification
#define FQF_DEVICE_INSTALL                  0x00100000  // file queue is for device install
#define FQF_USE_ALT_PLATFORM                0x00200000  // use AltPlatformInfo for digital
                                                        // signature verification
#define FQF_QUEUE_ALREADY_COMMITTED         0x00400000  // file queue has already been committed
#define FQF_QUEUE_FORCE_BLOCK_POLICY        0x01000000  // force policy to block so we never
                                                        // install unsigned files
#define FQF_KEEP_INF_AND_CAT_ORIGINAL_NAMES 0x02000000  // install INF/CAT from 3rd-party location
                                                        // using original names (for exception INFs)

//
// File functions in fileutil.c
//
DWORD
OpenAndMapFileForRead(
    IN  PCTSTR   FileName,
    OUT PDWORD   FileSize,
    OUT PHANDLE  FileHandle,
    OUT PHANDLE  MappingHandle,
    OUT PVOID   *BaseAddress
    );

BOOL
UnmapAndCloseFile(
    IN HANDLE FileHandle,
    IN HANDLE MappingHandle,
    IN PVOID  BaseAddress
    );

typedef struct _TEXTFILE_READ_BUFFER {
    PCTSTR TextBuffer;
    DWORD  TextBufferSize;
    HANDLE FileHandle;
    HANDLE MappingHandle;
    PVOID  ViewAddress;
} TEXTFILE_READ_BUFFER, *PTEXTFILE_READ_BUFFER;

DWORD
ReadAsciiOrUnicodeTextFile(
    IN  HANDLE                FileHandle,
    OUT PTEXTFILE_READ_BUFFER Result
    );

BOOL
DestroyTextFileReadBuffer(
    IN PTEXTFILE_READ_BUFFER ReadBuffer
    );

BOOL
GetVersionInfoFromImage(
    IN  PCTSTR      FileName,
    OUT PDWORDLONG  Version,
    OUT LANGID     *Language
    );

BOOL
FileExists(
    IN  PCTSTR           FileName,
    OUT PWIN32_FIND_DATA FindData   OPTIONAL
    );

DWORD
GetSetFileTimestamp(
    IN  PCTSTR    FileName,
    OUT FILETIME *CreateTime,   OPTIONAL
    OUT FILETIME *AccessTime,   OPTIONAL
    OUT FILETIME *WriteTime,    OPTIONAL
    IN  BOOL      Set
    );

DWORD
RetreiveFileSecurity(
    IN  PCTSTR                FileName,
    OUT PSECURITY_DESCRIPTOR *SecurityDescriptor
    );

DWORD
StampFileSecurity(
    IN PCTSTR               FileName,
    IN PSECURITY_DESCRIPTOR SecurityInfo
    );

DWORD
TakeOwnershipOfFile(
    IN PCTSTR Filename
    );

DWORD
SearchForInfFile(
    IN  PCTSTR            InfName,
    OUT LPWIN32_FIND_DATA FindData,
    IN  DWORD             SearchControl,
    OUT PTSTR             FullInfPath,
    IN  UINT              FullInfPathSize,
    OUT PUINT             RequiredSize     OPTIONAL
    );

DWORD
MultiSzFromSearchControl(
    IN  DWORD  SearchControl,
    OUT PTCHAR PathList,
    IN  DWORD  PathListSize,
    OUT PDWORD RequiredSize  OPTIONAL
    );


//
// Non-file-related security routines in security.c.
//
BOOL
IsUserAdmin(
    VOID
    );

BOOL
DoesUserHavePrivilege(
    PCTSTR PrivilegeName
    );

BOOL
EnablePrivilege(
    IN PCTSTR PrivilegeName,
    IN BOOL   Enable
    );

//
// Private INF routines
//
PCTSTR
pSetupGetField(
    IN PINFCONTEXT Context,
    IN DWORD       FieldIndex
    );


//
// Registry interface routines
//
DWORD
QueryRegistryValue(
    IN  HKEY    KeyHandle,
    IN  PCTSTR  ValueName,
    OUT PTSTR  *Value,
    OUT PDWORD  DataType,
    OUT PDWORD  DataSizeBytes
    );

DWORD
QueryMultiSzValueToArray(
    IN  HKEY     Root,
    IN  PCTSTR   Subkey,
    IN  PCTSTR   ValueName,
    OUT PTSTR  **Array,
    OUT PUINT    StringCount,
    IN  BOOL     FailIfDoesntExist
    );

DWORD
SetArrayToMultiSzValue(
    IN HKEY     Root,
    IN PCTSTR   Subkey,
    IN PCTSTR   ValueName,
    IN PTSTR   *Array,
    IN UINT     StringCount
    );

VOID
FreeStringArray(
    IN PTSTR *Array,
    IN UINT   StringCount
    );

DWORD
AppendStringToMultiSz(
    IN HKEY   Key,
    IN PCTSTR SubKeyName,       OPTIONAL
    IN DWORD  DevInst,          OPTIONAL
    IN PCTSTR ValueName,        OPTIONAL
    IN PCTSTR String,
    IN BOOL   AllowDuplicates
    );

DWORD
RegistryDelnode(
    IN  HKEY   RootKey,
    IN  PCTSTR SubKeyName
    );

//
// Service controller helper functions
//
DWORD
RetrieveServiceConfig(
    IN  SC_HANDLE               ServiceHandle,
    OUT LPQUERY_SERVICE_CONFIG *ServiceConfig
    );

DWORD
AddTagToGroupOrderListEntry(
    IN PCTSTR LoadOrderGroup,
    IN DWORD  TagId,
    IN BOOL   MoveToFront
    );

DWORD
AcquireSCMLock(
    IN  SC_HANDLE  SCMHandle,
    OUT SC_LOCK   *pSCMLock
    );


//
// Miscellaneous utility functions
//
PTSTR
DuplicateString(
    IN PCTSTR String
    );

PSTR
UnicodeToMultiByte(
    IN PCWSTR UnicodeString,
    IN UINT   Codepage
    );

PWSTR
MultiByteToUnicode(
    IN PCSTR String,
    IN UINT  Codepage
    );

DWORD
CaptureStringArg(
    IN  PCTSTR  String,
    OUT PCTSTR *CapturedString
    );

DWORD
CaptureAndConvertAnsiArg(
    IN  PCSTR   AnsiString,
    OUT PCWSTR *UnicodeString
    );

DWORD
DelimStringToMultiSz(
    IN PTSTR String,
    IN DWORD StringLen,
    IN TCHAR Delim
    );

VOID
CenterWindowRelativeToParent(
    HWND hwnd
    );

BOOL
pAToI(
    IN  PCTSTR Field,
    OUT PINT   IntegerValue
    );

#define UnicodeToAnsi(UnicodeString)    UnicodeToMultiByte((UnicodeString),CP_ACP)
#define UnicodeToOem(UnicodeString)     UnicodeToMultiByte((UnicodeString),CP_OEMCP)
#define AnsiToUnicode(AnsiString)       MultiByteToUnicode((AnsiString),CP_ACP)
#define OemToUnicode(OemString)         MultiByteToUnicode((OemString),CP_OEMCP)

BOOL
ConcatenatePaths(
    IN OUT PTSTR  Target,
    IN     PCTSTR Path,
    IN     UINT   TargetBufferSize,
    OUT    PUINT  RequiredSize
    );

DWORD
pSetupMakeSurePathExists(
    IN PCTSTR FullFilespec
    );

PCTSTR
MyGetFileTitle(
    IN PCTSTR FilePath
    );

BOOL
InfIsFromOemLocation(
    IN PCTSTR InfFileName,
    IN BOOL   InfDirectoryOnly
    );

DWORD
pSetupGetOsLoaderDriveAndPath(
    IN  BOOL   RootOnly,
    OUT PTSTR  CallerBuffer,
    IN  DWORD  CallerBufferSize,
    OUT PDWORD RequiredSize      OPTIONAL
    );

BOOL
pSetupSetSystemSourcePath(
    IN PCTSTR NewSourcePath,
    IN PCTSTR NewSvcPackSourcePath
    );

BOOL
ShouldDeviceBeExcluded(
    IN  PCTSTR DeviceId,
    IN  HINF   hInf,
    OUT PBOOL  ArchitectureSpecificExclude OPTIONAL
    );

BOOL
pSetupDiSetDeviceInfoContext(
    IN HDEVINFO         DeviceInfoSet,
    IN PSP_DEVINFO_DATA DeviceInfoData,
    IN DWORD            Context
    );

BOOL
pSetupDiGetDeviceInfoContext(
    IN  HDEVINFO         DeviceInfoSet,
    IN  PSP_DEVINFO_DATA DeviceInfoData,
    OUT PDWORD           Context
    );

#define SETUP_HAS_OPEN_DIALOG_EVENT     TEXT("MS_SETUPAPI_DIALOG")

//
// Define flags for DoInstallActionWithParams
//
#define INSTALLACTION_CALL_CI    0x00000001
#define INSTALLACTION_NO_DEFAULT 0x00000002

DWORD
DoInstallActionWithParams(
    IN DI_FUNCTION             InstallFunction,
    IN HDEVINFO                DeviceInfoSet,
    IN PSP_DEVINFO_DATA        DeviceInfoData,         OPTIONAL
    IN PSP_CLASSINSTALL_HEADER ClassInstallParams,     OPTIONAL
    IN DWORD                   ClassInstallParamsSize,
    IN DWORD                   Flags
    );

INT
AddMiniIconToList(
    IN HBITMAP hbmImage,
    IN HBITMAP hbmMask
    );

PCTSTR
pSetupDirectoryIdToPath(
    IN     PCTSTR  DirectoryId,    OPTIONAL
    IN OUT PUINT   DirectoryIdInt, OPTIONAL
    IN     PCTSTR  SubDirectory,   OPTIONAL
    IN     PCTSTR  InfSourcePath,  OPTIONAL
    IN OUT PCTSTR *OsLoaderPath    OPTIONAL
    );

typedef struct _STRING_TO_DATA {
    PCTSTR String;
    UINT   Data;
} STRING_TO_DATA, *PSTRING_TO_DATA;

BOOL
LookUpStringInTable(
    IN  PSTRING_TO_DATA Table,
    IN  PCTSTR          String,
    OUT PUINT           Data
    );

#define SIZECHARS(x)    (sizeof((x))/sizeof(TCHAR))
#define CSTRLEN(x)      ((sizeof((x))/sizeof(TCHAR)) - 1)
#define ARRAYSIZE(x)    (sizeof((x))/sizeof((x)[0]))


//
// Routine to perform right-click install action on INFs (previously
// implemented in syssetup.dll--moved to setupapi.dll because it's
// needed on both NT and Win95).  SysSetup.DLL still provides this
// entry point for backward compatibility, but calls into setupapi
// to do the work.
//
VOID
WINAPI
InstallHinfSectionA(
    IN HWND      Window,
    IN HINSTANCE ModuleHandle,
    IN PCSTR     CommandLine,
    IN INT       ShowCommand
    );

VOID
WINAPI
InstallHinfSectionW(
    IN HWND      Window,
    IN HINSTANCE ModuleHandle,
    IN PCWSTR    CommandLine,
    IN INT       ShowCommand
    );

#ifdef UNICODE
#define InstallHinfSection InstallHinfSectionW
#else
#define InstallHinfSection InstallHinfSectionA
#endif


//
// Routine used by optional components code in syssetup to setup runonce/grpconv.
//
DWORD
InstallStop(
    IN BOOL DoRunOnce
    );

DWORD
InstallStopEx(
    IN BOOL DoRunOnce,
    IN DWORD Flags,
    IN PVOID Reserved
    );

#define INSTALLSTOP_NO_UI        0x00000001     // InstallStop should do no UI
#define INSTALLSTOP_NO_GRPCONV   0x00000002     // Don't do GrpConv

//
// Section access for INF file
//

BOOL
SetupGetInfSections (
    IN  HINF        InfHandle,
    OUT PTSTR       Buffer,         OPTIONAL
    IN  UINT        Size,           OPTIONAL
    OUT UINT        *SizeNeeded     OPTIONAL
    );


//
// GUID handling routines (avoid linking to ole32.dll!)
//
DWORD
pSetupGuidFromString(
   IN  PCTSTR GuidString,
   OUT LPGUID Guid
   );

DWORD
pSetupStringFromGuid(
   IN  CONST GUID *Guid,
   OUT PTSTR       GuidString,
   IN  DWORD       GuidStringSize
   );

BOOL
pSetupIsGuidNull(
    IN CONST GUID *Guid
    );

//
// Digital signature verification routines
//

typedef enum {
    SetupapiVerifyNoProblem,
    SetupapiVerifyCatalogProblem,   // catalog file couldn't be verified
    SetupapiVerifyInfProblem,       // inf file couldn't be installed/verified
    SetupapiVerifyFileNotSigned,    // file is not signed, no verification attempted
    SetupapiVerifyFileProblem,      // file may be signed, but couldn't be verified
    SetupapiVerifyClassInstProblem, // class installer is unsigned
    SetupapiVerifyCoInstProblem     // co-installer is unsigned
} SetupapiVerifyProblem;


DWORD
pSetupVerifyQueuedCatalogs(
    IN HSPFILEQ FileQueue
    );

DWORD
VerifyCatalogFile(
    IN LPCTSTR CatalogFullPath
    );

DWORD
VerifyFile(
    IN  LPVOID                 LogContext,
    IN  LPCTSTR                Catalog,                OPTIONAL
    IN  PVOID                  CatalogBaseAddress,     OPTIONAL
    IN  DWORD                  CatalogImageSize,
    IN  LPCTSTR                Key,
    IN  LPCTSTR                FileFullPath,
    OUT SetupapiVerifyProblem *Problem,                OPTIONAL
    OUT LPTSTR                 ProblemFile,            OPTIONAL
    IN  BOOL                   CatalogAlreadyVerified,
    IN  PSP_ALTPLATFORM_INFO   AltPlatformInfo,        OPTIONAL
    OUT LPTSTR                 CatalogFileUsed,        OPTIONAL
    OUT PDWORD                 NumCatalogsConsidered   OPTIONAL
    );

DWORD
InstallCatalog(
    IN  LPCTSTR CatalogFullPath,
    IN  LPCTSTR NewBaseName,        OPTIONAL
    OUT LPTSTR  NewCatalogFullPath
    );

BOOL
HandleFailedVerification(
    IN HWND                  Owner,
    IN SetupapiVerifyProblem Problem,
    IN LPCTSTR               ProblemFile,
    IN LPCTSTR               DeviceDesc,          OPTIONAL
    IN DWORD                 DriverSigningPolicy,
    IN BOOL                  NoUI,
    IN DWORD                 Error,
    IN PVOID                 LogContext,          OPTIONAL
    OUT PDWORD               Flags,               OPTIONAL
    IN LPCTSTR               TargetName           OPTIONAL
    );

DWORD
GetCurrentDriverSigningPolicy(
    IN BOOL IsDeviceInstallation
    );

//
// Diagnostic/debug functions in debug.c
//

//
// Allow assertion checking to be turned on independently
// of DBG, like by specifying C_DEFINES=-DASSERTS_ON=1 in sources file.
//
#ifndef ASSERTS_ON
#if DBG
#define ASSERTS_ON 1
#else
#define ASSERTS_ON 0
#endif
#endif

#if ASSERTS_ON

#define MYASSERT(x)     if(!(x)) { AssertFail(__FILE__,__LINE__,#x); }

VOID
AssertFail(
    IN PSTR FileName,
    IN UINT LineNumber,
    IN PSTR Condition
    );

#else

#define MYASSERT(x)

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\rasdiag\common\diagcommon.h ===
/*++

Copyright (C) 1992-2001 Microsoft Corporation. All rights reserved.

Module Name:

    diagcommon.h

Abstract:

    Header containing rasdiag forward defintions, strings, etc
                                                     

Author:

    Anthony Leibovitz (tonyle) 02-01-2001

Revision History:


--*/

#ifndef _DIAGCOMMON_H_
#define _DIAGCOMMON_H_

/*
RASDIAG
*/
#define  APPLICATION_TITLE              TEXT("RASDIAG")
#define  LOG_FILE_NAME                  TEXT("RASDIAG.TXT")
#define  RASDIAG_DIRECTORY              TEXT("RASDIAG")
#define  RASDIAG_NET_TEMP               TEXT("RASDIAGNET.TXT")
#define  RASDIAG_EXT                    TEXT("RDG")
#define  SYSTEM_TEXT_EDITOR             TEXT("NOTEPAD.EXE")
#define  LOG_SEPARATION_TXT             TEXT("--------------------------------------------------------------------------------\r\n")
#define  OPTION_DONETTESTS              0x00000001  // do net tests - currently none b/c app doesn't know net context - use NLA in future?
#define  IOBUFF_SIZE                    1024

#define  CMDOPTION_DISABLE_QUESTION2    TEXT("/?")
#define  CMDOPTION_DISABLE_QUESTION1    TEXT("-?")
#define  CMDOPTION_ENABLE_NETTESTS      TEXT("-n")
#define  CMDOPTION_REMOTE_SNIFF         TEXT("-r")
#define  CMDOPTION_REMOTE_ROUTINGTABLE  TEXT("-t")
#define  MAX_CHECKFILEACCESS_ATTEMPTS   10

/*
RAS TRACING
*/
#define  TRACING_ENABLE_VALUE_NAME      TEXT("EnableFileTracing")
#define  TRACING_EXTENSION              TEXT("LOG")
#define  TRACING_SUBDIRECTORY           TEXT("TRACING")
#define  TRACING_SUBKEY                 TEXT("SOFTWARE\\Microsoft\\Tracing")

/*
RAS PBK
*/
#define  PBK_PATH                       TEXT("\\Application Data\\Microsoft\\Network\\Connections\\Pbk\\rasphone.pbk")

/*
CM 
*/
#define  CM_LOGGING_VALUE               TEXT("EnableLogging")
#define  CM_LOGGING_PATH_ALLUSER        TEXT("%ALLUSERSPROFILE%")
#define  CM_LOGGING_PATH_CURUSER        TEXT("%USERPROFILE%")
#define  CM_SECTIONNAME                 TEXT("Connection Manager")
#define  CM_SERVICENAME                 TEXT("ServiceName")
#define  CM_LOGGING_SECTIONNAME         TEXT("Logging")
#define  CM_LOGGING_KEYNAME             TEXT("FileDirectory")
#define  CM_LOGGING_DEFAULT_KEYNAME     TEXT("%TEMP%")
#define  CM_LOGGING_FILENAME_EXT        TEXT(".LOG")
//#define  CM_LOGGING_KEY                 TEXT("Software\\Microsoft\\Connection Manager\\UserInfo")
#define  CM_LOGGING_KEY_CURUSER         TEXT("Software\\Microsoft\\Connection Manager\\UserInfo")
#define  CM_LOGGING_KEY_ALLUSER         TEXT("Software\\Microsoft\\Connection Manager")

/*
OAKLEY
*/
#define  OAKLEY_TRACING_KEY             TEXT("SYSTEM\\CurrentControlSet\\Services\\PolicyAgent\\Oakley")
#define  OAKLEY_VALUE                   TEXT("EnableLogging")
#define  LOG_TITLE_OAKLEY               TEXT("OAKLEY/IKE")
#define  OAKLEY_LOG_LOCATION            TEXT("%WINDIR%\\DEBUG\\OAKLEY.LOG")
#define  POLICYAGENT_SVC_NAME           TEXT("POLICYAGENT")
#define  MAX_SECURITY_EVENTS_REPORTED   10 // Last # of events to include in rasdiag log 

/*
UNIMODEM
*/
#define  LOG_TITLE_UNIMODEM             TEXT("UNIMODEM")
#define  MODEM_LOG_FILENAME             TEXT("%WINDIR%\\ModemLog*.TXT")
#define  UNIMODEM_ENABLE_LOGGING_VALUE  TEXT("Logging")
#define  MODEM_SUBKEY                   TEXT("SYSTEM\\CurrentControlSet\\Control\\Class\\{4D36E96D-E325-11CE-BFC1-08002BE10318}")

#define  MAX_FULLYQUALIFIED_DN          1025
#define  SVCBUFFER_SIZE                 2048*1024


BOOL
Logprintf(HANDLE hWrite, WCHAR *pFmt, ...); 

BOOL
PrintLogHeader(HANDLE hWrite, WCHAR *pFmt, ...); 

#endif // _DIAGCOMMON_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\rasdiag\common\rasdiag.h ===
/*++

Copyright (C) 1992-2001 Microsoft Corporation. All rights reserved.

Module Name:

    rasdiag.h

Abstract:

    Header containing rasdiag forward defintions, etc
                                                     

Author:

    Anthony Leibovitz (tonyle) 02-01-2001

Revision History:


--*/


#ifndef _RASDIAG_H_
#define _RASDIAG_H_

/* Forward definitions */
#include "diagcommon.h"
#include "capture.h"

#ifdef BUILD_RSNIFF
#include "rsniffclnt.h"
#endif

typedef struct _RDGHDR {
    DWORD       dwVer;
    DWORD       dwRDGMajVer;
    DWORD       dwRDGMinVer;
    SYSTEMTIME  CreationTime;
} *PRDGHDR, RDGHDR;

typedef struct _RDGHDR_VER5 {
    DWORD       dwVer;
    SYSTEMTIME  CreationTime;
} *PRDGHDR_VER5, RDGHDR_VER5;

typedef struct _RDGFILEHDR {
    DWORD       dwVer;
    WCHAR       szFilename[MAX_PATH+1];
    DWORD       dwFileSize;
} *PRDGFILEHDR, RDGFILEHDR;

typedef struct _RDGFILEHDR_VER5 {
    DWORD       dwVer;
    CHAR        szFilename[MAX_PATH+1];
    DWORD       dwFileSize;
} *PRDGFILEHDR_VER5, RDGFILEHDR_VER5;

typedef struct _tagCMINFO {
    DWORD   fStatus;
    WCHAR   *pwcRegKey;
    WCHAR   *pwcCurUserRegKey;
    WCHAR   *pszCmsFileName;
    WCHAR   *pwcLogFileName;
    WCHAR   *pwcServiceName;
    DWORD   dwPrevLogState; // save off current state (put back when done)
    struct _tagCMINFO *pNext;
} *PCMINFO, CMINFO;

typedef struct _tagRASDIAGCONFIG {
    DWORD            dwUserOptions;
    WCHAR            szTempDir[MAX_PATH+1];
    WCHAR            szRasDiagDir[MAX_PATH+1];
    WCHAR            szWindowsDirectory[MAX_PATH+1];
    WCHAR            szTracingDir[MAX_PATH+1];
    WCHAR            szSysPbk[MAX_PATH+1];
    WCHAR            szUserPbk[MAX_PATH+1];
    SYSTEMTIME       DiagTime;
    PRASDIAGCAPTURE  pNetInterfaces;
    DWORD            dwNetCount;
#ifdef BUILD_RSNIFF
    PSOCKCB          pSockCb;
#endif    
    WCHAR            **pCmFileName;
    DWORD            dwCmLogs;
    PCMINFO          pCmInfo;
} *PRASDIAGCONFIG, RASDIAGCONFIG;

#ifndef _RASDIAG_P_H_
#include "rasdiag_p.h"
#endif //_RASDIAG_P_H_

typedef void (*LPFNNetCfgDiagFromCommandArgs)(DIAG_OPTIONS *);

#define CMINFO_STATUS_ALLUSER 0x00000001
#define CMINFO_STATUS_CURUSER 0x00000002

BOOL
DoCMLogSetup(PCMINFO *ppCmInfo);

void
DeleteCMLogs(PCMINFO pCmInfo);

BOOL
SetCmLogState(PCMINFO pCmInfo, BOOL bEnabled);

void
FindCmLog(WCHAR *pszSource, PCMINFO *ppCmInfo, DWORD dwOpt);

BOOL
GetCmLogInfo(PCMINFO pCmInfo);

void
FreeCmInfoResources(PCMINFO pCmInfo);

BOOL
AddLog(HANDLE hWrite, WCHAR *pszSrcFileName, BOOL bSrcUnicode, WCHAR *pszLogTitle);

BOOL
AddModemLogs(HANDLE hWrite);

void
SetModemTracing(BOOL bState);

void
DeleteModemLogs(WCHAR *szWindowsDirectory);

void
DeviceDump(HANDLE hWrite);

BOOL
SetTracing(BOOL bState);

void
DeleteTracingLogs(WCHAR *pszTracingDir);

void
OpenLogFileWithEditor(WCHAR *pszTracingDirectory, WCHAR *szWindowsDirectory);

void
AddHeader(HANDLE hFile, PRASDIAGCONFIG);

BOOL
BuildRasDiagLog(PRASDIAGCONFIG pRdc);

BOOL
CheckFileAccess(WCHAR *pszTracingDir);

BOOL
GetPbkPaths(WCHAR *szSysPbk, WCHAR *szUserPbk);

BOOL
EnableOakleyLogging(BOOL bEnable);

BOOL
AddOakleyLog(HANDLE hWrite);

BOOL
AddNetworkLog(HANDLE hWrite);

BOOL
DeleteOakleyLog(void);
                    
BOOL
CreateRasdiagDirectory(WCHAR *pszRasdiagDirectory);

void
RaiseFolderUI(WCHAR *pszDir);

BOOL
ProcessArgs(int argc, WCHAR **argv, DWORD *pdwUserOptions);

///// Service

void
MonitorState(SC_HANDLE hService, WCHAR *pServiceName, DWORD dwStateToEnforce);

BOOL
MyStartService(SC_HANDLE hService, WCHAR *pServiceName);

BOOL
StopService(SC_HANDLE hService, WCHAR *pServiceName);
                 
BOOL
StopStartService(WCHAR *pServiceName, BOOL bStart);

///// CM

BOOL
EnableCMLogging(BOOL bEnable, WCHAR ***ppPathArray, DWORD *pdwCount, WCHAR *szTempDir);

void
CleanupCMLogFiles(WCHAR **pFileAry, DWORD dwCount);

void
DeleteCMLogFiles(WCHAR **pFileAry, DWORD dwCount);

///// Package

BOOL
UnpackFile(HANDLE hSrcFile, PRDGFILEHDR pHdr, OPTIONAL IN WCHAR *pszDestinationPath);

BOOL
ClosePackage(HANDLE hFile);

BOOL
CreatePackage(HANDLE *phFile, SYSTEMTIME *pDiagTime, WCHAR *szRasDiagDir);

BOOL
AddFileToPackage(HANDLE hPkgFile, WCHAR *pszFileName);

BOOL
BuildPackage(PRASDIAGCAPTURE pCaptures, DWORD dwCaptureCount, WCHAR *pszRasDiagDir, SYSTEMTIME *pDiagTime);

BOOL
PrintUserMsg(int iMsgID,...);

void
ExecNetUtils(void);

BOOL
DoNetTests(void);

BOOL
DumpProcessInfo(HANDLE hWrite);

BOOL
ResolveProcessServices(LPENUM_SERVICE_STATUS_PROCESS pServices, DWORD dwServiceCount, HANDLE hWrite);

void
PrintHelp(void);

void
PrintUserInstructions(void);

BOOL
RegisterRdgFileAssociation(WCHAR *pszPath);

BOOL
WINAPI
HandlerRoutine(
  DWORD dwCtrlType   //  control signal type
);      

#endif //  _RASDIAG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\rasdiag\common\rsniffclnt.h ===
/*++

Copyright (C) 1992-2001 Microsoft Corporation. All rights reserved.

Module Name:

    rsniffclnt.h

Abstract:

    Forward definitions for rsniffclnt.cpp
                                                     

Author:

    Anthony Leibovitz (tonyle) 03-24-2001

Revision History:


--*/


#ifndef _RSNIFFCLNT_H_
#define _RSNIFFCLNT_H_

#define  TCP_SERV_PORT                  2222   

                                                
typedef struct _tagSOCKCB {
   SOCKET      s;
} *PSOCKCB, SOCKCB;

#define RSNIFF_OPT1_DOSNIFF             0x00000001
#define RSNIFF_OPT1_GETSRVROUTINGINFO   0x00000002


typedef struct _REMOTECAPTURE_V6 {
    DWORD       dwVer;
    WCHAR       szMachine[MAX_COMPUTERNAME_LENGTH+1];
} *PREMOTECAPTURE_V6,REMOTECAPTURE_V6;

typedef struct _REMOTECAPTURE {
    DWORD       dwVer;
    WCHAR       szMachine[MAX_COMPUTERNAME_LENGTH+1];
    DWORD       dwOpt1;
    DWORD       dwOpt2;
} *PREMOTECAPTURE,REMOTECAPTURE;

typedef struct _REMOTECAPTURE_V5 {
    DWORD       dwVer;
    CHAR        szMachine[MAX_COMPUTERNAME_LENGTH+1];
} *PREMOTECAPTURE_V5,REMOTECAPTURE_V5;

BOOL
DoRemoteSniff(PSOCKCB *ppSockCb, WCHAR *szAddr, DWORD dwOptions);

BOOL
SendStartSniffPacket(PSOCKCB pSock, DWORD dwOptions);

PSOCKCB
CreateSocket(int Af, int Type, int Proto);

BOOL
ConnectSock(PSOCKCB pSock, SOCKADDR* pDstAddr, int size);

PSOCKCB
TcpConnectRoutine(WCHAR *pAddr);

BOOL
InitWinsock(void);

BOOL
SendBuffer(SOCKET s, LPBYTE pBuffer, ULONG uSize);

BOOL
RecvBuffer(SOCKET s, LPBYTE pBuffer, ULONG uSize);

#endif // _RSNIFFCLNT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\rasdiag\common\rasdiag_p.h ===
/*++

Copyright (C) 1992-2001 Microsoft Corporation. All rights reserved.

Module Name:

    rasdiag_p.h

Abstract:

    Principle interface to RASDIAG
                                                     

Author:

    Anthony Leibovitz (tonyle) 04-23-2001

Revision History:


--*/

#ifndef _RASDIAG_P_H_
#define _RASDIAG_P_H_

#ifndef _RASDIAG_H_
#include "rasdiag.h"
#endif //_RASDIAG_H_

#define  RASDIAG_MAJOR_VERSION     8
#define  RASDIAG_MINOR_VERSION     1

//
//  StartRasDiag    
//  
//      BOOL StartRasDiag(OUT PRASDIAGCONFIG *ppRdc, IN DWORD dwOptions);
//
//  Parameters
//
//      ppRdc      
//          [OUT] Pointer to a PRASDIAGCONFIG. 
//
//      DWORD
//          [IN] DWORD bitmask consisting of one or more of the following:  
//                                                                               
//          OPTION_DOREMOTESNIFF    = Attempt to start a remote sniff with RSNIFF
//          
//          OPTION_DONETTESTS       = Attempt network tests (currently, there are no net tests defined
//                                    b/c we don't know the context - Possible enhancement with NLA
//          
//  Return Value
//      
//      BOOL - Indicates success (TRUE) or failure (FALSE)
//
//  Remarks
//
//      Use this function to initialize rasdiag and begin the data collection process.
//
BOOL
StartRasDiag(OUT PRASDIAGCONFIG *ppRdc, IN DWORD dwOptions);

//
//  StopRasDiag    
//  
//      BOOL StopRasDiag(IN PRASDIAGCONFIG pRdc);
//
//  Parameters
//  
//      pRdc
//          [IN] Pointer to RASDIAGCONFIG structure created by StartRasDiag. On return, this pointer will point
//          to a RASDIAGCONFIG structure.
//
//  Return Value
//
//      BOOL - Indicates success (TRUE) or failure (FALSE)
//      
//  Remarks
//
//      Use this function to cease data collection process. Captures, RASDIAG log and
//      compsite RDG file will be located in the RASDIAG directory. To obtain this
//      directory, call GetRasDiagDirectory().
//
BOOL
StopRasDiag(IN PRASDIAGCONFIG pRdc);

//
//  GetRasDiagDirectory
//
//      WCHAR *
//      GetRasDiagDirectory(IN OUT WCHAR *pszRasDiagDirectory);
//  
//  Parameters
//          
//      pszRasDiagDirectory
//          [IN/OUT] Pointer to a user-supplied buffer of MAX_PATH+1.
//
//  Return Value
//
//      WCHAR * - The function returns a pointer to pszRasDiagDirectory
//      
//  Remarks
//
//      Use this function to obtain the RASDIAG path.
//
WCHAR *
GetRasDiagDirectory(IN OUT WCHAR *pszRasDiagDirectory);

//
//  CrackRasDiagFile
//
//      BOOL CrackRasDiagFile(IN WCHAR *pszRdgFile, OPTIONAL IN WCHAR *pszDestinationPath);
//  
//  Parameters
//          
//      pszRdgFile
//          [IN] Pointer to a valid composite RASDIAG file(.RDG)
//
//      pszDestinationPath
//          [OPTIONAL IN] Pointer to UNICODE string specifying the output
//          path for the output files (ie., L"C:" or L"C:\\MyStuff").
//          To use the default path (current directory), specific NULL.
// 
//  Return Value
//
//      BOOL - Indicates success (TRUE) or failure (FALSE)
//
//  Remarks
//
//      Function unpackages NETMON captures files, rasdiag log, etc.
BOOL
CrackRasDiagFile(IN WCHAR *pszRdgFile, OPTIONAL IN WCHAR *pszDestinationPath);

//
//  Misc Notes
//
//  RSNIFF
//
//  RSNIFF is disabled by default - define BUILD_RSNIFF in sources to build this feature. 
//

#endif //_RASDIAG_P_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\rasdiag\private\diagctx.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1999.
//
//  File:       D I A G C T X . H
//
//  Contents:   Implements the optional diagnostic context used by
//              CNetConfig.
//
//  Notes:
//
//  Author:     shaunco   10 Feb 1999
//
//----------------------------------------------------------------------------

#pragma once

#include <tracetag.h>

enum DIAG_FLAGS
{
    DF_SHOW_CONSOLE_OUTPUT      = 0x00000001,
    DF_DONT_START_SERVICES      = 0x00000002,
    DF_DONT_DO_PNP_BINDS        = 0x00000004,
    DF_SUPRESS_E_NEED_REBOOT    = 0x00000010,
};

// This structure is allocated dynamically by CDiagContext.  Place anything
// big in this structure (as opposed to CDiagContext) so that the size of
// CNetConfig is not directly increased.
//
struct DIAG_CONTEXT
{
    CHAR szPrintBuffer [4096];
};

class CDiagContext
{
private:
    DWORD           m_dwFlags;  // DIAG_FLAGS
    DIAG_CONTEXT*   m_pCtx;

public:
    CDiagContext ()
    {
        m_dwFlags = 0;
        m_pCtx = NULL;
    }

    ~CDiagContext ()
    {
        MemFree (m_pCtx);
    }

    VOID
    SetFlags (
        DWORD dwFlags /* DIAG_FLAGS */);

    DWORD
    Flags () const;

    VOID
    Printf (
        TRACETAGID ttid,
        PCSTR pszFormat,
        ...);
};

extern CDiagContext* g_pDiagCtx;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\rasdiag\private\dbgflags.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       D B G F L A G S . H
//
//  Contents:   Debug Flag definitions for the Netcfg project
//
//  Notes:
//
//  Author:     jeffspr   27 May 1997
//
//----------------------------------------------------------------------------

#pragma once
#ifndef _DBGFLAGS_H_
#define _DBGFLAGS_H_

// None of this should get compiled in unless we're in the debug version
// or we need to enable tracing code.
//

//+---------------------------------------------------------------------------
//
// DBG (checked) or ENABLETRACE build
//
#if defined(DBG) || defined(ENABLETRACE)


// DebugFlagIds are the identifiers for debug flags, and are used in calls
// to FIsDebugFlagSet()
//
// Hungarian == dfid
//
enum DebugFlagId
{
    dfidBreakOnAlloc = 0,
    dfidBreakOnDoUnattend,
    dfidBreakOnError,
    dfidBreakOnHr,
    dfidBreakOnHrIteration,
    dfidBreakOnIteration,
    dfidBreakOnNetInstall,
    dfidBreakOnNotifySinkRelease,
    dfidBreakOnPrematureDllUnload,
    dfidBreakOnWizard,
    dfidBreakOnStartOfUpgrade,
    dfidBreakOnEndOfUpgrade,
    dfidCheckLegacyMenusAtRuntime,
    dfidCheckLegacyMenusOnStartup,
    dfidDisableShellThreading,
    dfidDisableTray,
    dfidDontCacheShellIcons,
    dfidExtremeTracing,
    dfidNetShellBreakOnInit,
    dfidNoErrorText,
    dfidShowIgnoredErrors,
    dfidShowProcessAndThreadIds,
    dfidSkipLanEnum,
    dfidTraceCallStackOnError,
    dfidTraceFileFunc,
    dfidTraceMultiLevel,
    dfidTraceSource,
    dfidTracingTimeStamps
};

// Just for kicks
//
typedef enum DebugFlagId    DEBUGFLAGID;

// Maximum sizes for the trace tag elements.
const int c_iMaxDebugFlagShortName      = 32;
const int c_iMaxDebugFlagDescription    = 128;

// For each element in the debug flag list
//
struct DebugFlagElement
{
    DEBUGFLAGID dfid;
    CHAR        szShortName[c_iMaxDebugFlagShortName+1];
    CHAR        szDescription[c_iMaxDebugFlagDescription+1];
    DWORD       dwValue;
};

typedef struct DebugFlagElement DEBUGFLAGELEMENT;

//---[ Externs ]--------------------------------------------------------------

extern DEBUGFLAGELEMENT g_DebugFlags[];
extern const INT        g_nDebugFlagCount;

BOOL    FIsDebugFlagSet( DEBUGFLAGID    dfid );
DWORD   DwReturnDebugFlagValue( DEBUGFLAGID dfid );

//+---------------------------------------------------------------------------
//
// !DBG (retail) and !ENABLETRACE build
//
#else

#define FIsDebugFlagSet(dfid)           0
#define DwReturnDebugFlagValue(dfid)    0

#endif //! DBG || ENABLETRACE

#endif  // _DBGFLAGS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\rasdiag\private\diag.h ===
#pragma once
#include "diagctx.h"
#include "ncstring.h"
#include "netcon.h"

enum COMMAND
{
    CMD_INVALID = 0,
    CMD_SHOW_BINDINGS,
    CMD_SHOW_COMPONENTS,
    CMD_SHOW_STACK_TABLE,
    CMD_SHOW_LAN_ADAPTER_PNPIDS,
    CMD_ADD_COMPONENT,
    CMD_REMOVE_COMPONENT,
    CMD_UPDATE_COMPONENT,
    CMD_REMOVE_REFS,
    CMD_ENABLE_BINDING,
    CMD_DISABLE_BINDING,
    CMD_MOVE_BINDING,
    CMD_WRITE_BINDINGS,
    CMD_SET_WANORDER,
    CMD_FULL_DIAGNOSTIC,
    CMD_CLEANUP,
    CMD_ADD_REMOVE_STRESS,
    CMD_SHOW_LANA_DIAG,
    CMD_SHOW_LANA_PATHS,
    CMD_SET_LANA_NUMBER,
    CMD_REWRITE_LANA_INFO,

    CMD_SHOW_LAN_CONNECTIONS,
    CMD_SHOW_LAN_DETAILS,
    CMD_LAN_CHANGE_STATE,
    CMD_SHOW_ALL_DEVICES,
};

//+---------------------------------------------------------------------------
// Parameters for SZ_CMD_SHOW_BINDINGS
//
enum SHOW_BINDINGS_PARAM
{
    SHOW_INVALID = 0,
    SHOW_BELOW,
    SHOW_INVOLVING,
    SHOW_UPPER,
    SHOW_DISABLED,
};

enum COMPONENT_SPECIFIER_TYPE
{
    CST_INVALID = 0,
    CST_ALL,
    CST_BY_NAME,
};

struct COMPONENT_SPECIFIER
{
    COMPONENT_SPECIFIER_TYPE    Type;
    PCWSTR                      pszInfOrPnpId;
};


struct DIAG_OPTIONS
{
    CDiagContext*   pDiagCtx;

    COMMAND         Command;

    // Valid for CMD_ADD_COMPONENT
    GUID            ClassGuid;
    PCWSTR          pszInfId;

    // Valid for SZ_CMD_SHOW_BINDINGS
    //
    SHOW_BINDINGS_PARAM     ShowBindParam;
    COMPONENT_SPECIFIER     CompSpecifier;

    // Valid for SZ_CMD_ENABLE_BINDING and SZ_CMD_DISABLE_BINDING
    //
    PCWSTR          pszBindPath;

    // Valid for SZ_CMD_MOVE_BINDING
    //
    PCWSTR          pszOtherBindPath;
    BOOL            fMoveBefore;

    // Valid for SZ_CMD_SET_WANORDER
    //
    BOOL            fWanAdaptersFirst;

    // Valid for SZ_CMD_FULL_DIAGNOSTIC
    //
    BOOL            fLeakCheck;

    // Valid for SZ_SET_LANA_NUMBER
    //
    BYTE            OldLanaNumber;
    BYTE            NewLanaNumber;

    // Used by CMD_SHOW_LAN_DETAILS
    PCWSTR          szLanConnection;

    // Used by CMD_LAN_CHANGE_STATE & CMD_SHOW_LAN_DETAILS
    BOOL            fConnect;
};

VOID
SzFromCharacteristics (
    DWORD dwChars,
    tstring *pstrChars);

PCWSTR
SzFromNetconStatus (
    NETCON_STATUS Status);

PCWSTR
SzFromCmProb (
    ULONG ulProb);

VOID
SzFromCmStatus (
    ULONG ulStatus, tstring *pstrStatus);

EXTERN_C
VOID
WINAPI
NetCfgDiagFromCommandArgs (
    IN DIAG_OPTIONS *pOptions);

EXTERN_C
VOID
WINAPI
LanaCfgFromCommandArgs (
    IN DIAG_OPTIONS *pOptions);

EXTERN_C
VOID
WINAPI
NetManDiagFromCommandArgs (
    IN DIAG_OPTIONS *pOptions);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\rasdiag\private\ncdefine.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997-1999.
//
//  File:       N C D E F I N E . H
//
//  Contents:   Very generic defines for netcfg. Don't throw non-generic crap
//              in here! No iterators for NetCfgBindingPaths, etc. etc.
//
//  Notes:      Pollute this under penalty of death.
//
//  Author:     jeffspr   20 Sep 1997
//
//----------------------------------------------------------------------------

#pragma once
#ifndef _NCDEFINE_H_
#define _NCDEFINE_H_

#define BEGIN_CONST_SECTION     data_seg(".rdata")
#define END_CONST_SECTION       data_seg()

#define celems(_x)          (sizeof(_x) / sizeof(_x[0]))

#ifdef NOTHROW
#undef NOTHROW
#endif
#define NOTHROW __declspec(nothrow)

// Defines for C source files including us.
//
#ifndef __cplusplus
#ifndef inline
#define inline  __inline
#endif
#endif


// Generic flags used when inserting elements into collections.
//
enum INS_FLAGS
{
    INS_ASSERT_IF_DUP   = 0x00000100,
    INS_IGNORE_IF_DUP   = 0x00000200,
    INS_APPEND          = 0x00000400,
    INS_INSERT          = 0x00000800,
    INS_SORTED          = 0x00001000,
    INS_NON_SORTED      = 0x00002000,
};


#endif // _NCDEFINE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\rasdiag\private\ncmem.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       N C M E M . H
//
//  Contents:   Common memory management routines.
//
//  Notes:
//
//  Author:     shaunco   24 Mar 1997
//
//----------------------------------------------------------------------------

#pragma once
#ifndef _NCMEM_H_
#define _NCMEM_H_

#include <malloc.h>

VOID*
MemAlloc (
    size_t cb);

VOID*
MemAllocRaiseException (
    size_t  cb);

VOID
MemFree (
    VOID* pv);


// A simple wrapper around malloc that returns E_OUTOFMEMORY if the
// allocation fails.  Avoids having to explicitly do this at each
// call site of malloc.
//
HRESULT
HrMalloc (
    size_t  cb,
    PVOID*  ppv);


// This CANNOT be an inline function.  If it is ever not inlined,
// the memory allocated will be destroyed.  (We're dealing with the stack
// here.)
//
#define PvAllocOnStack(_st)  _alloca(_st)


// Define a structure so that we can overload operator new with a
// signature specific to our purpose.
//
struct raiseexception_t {};
extern const raiseexception_t raiseexception;

VOID*
__cdecl
operator new (
    size_t cb,
    const raiseexception_t&
    );


// Define a structure so that we can overload operator new with a
// signature specific to our purpose.
//
struct extrabytes_t {};
extern const extrabytes_t extrabytes;

VOID*
__cdecl
operator new (
    size_t cb,
    const extrabytes_t&,
    size_t cbExtra);



#ifdef USE_HEAP_ALLOC

inline
void *  Nccalloc(size_t n, size_t s)
{
    return HeapAlloc (GetProcessHeap(), HEAP_ZERO_MEMORY, (n * s));
}

inline
void Ncfree(void * p)
{
    HeapFree (GetProcessHeap(), 0, p);
}

inline
void * Ncmalloc(size_t n)
{
    return HeapAlloc (GetProcessHeap(), 0, n);
}

inline
void * Ncrealloc(void * p, size_t n)
{
    return (NULL == p)
        ? HeapAlloc (GetProcessHeap(), 0, n)
        : HeapReAlloc (GetProcessHeap(), 0, p, n);
}

#define calloc  Nccalloc
#define free    Ncfree
#define malloc  Ncmalloc
#define realloc Ncrealloc

#endif // USE_HEAP_ALLOC

#endif // _NCMEM_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\rasdiag\private\ncmsz.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       N C M S Z . H
//
//  Contents:   Common multi-sz routines.
//
//  Notes:      Split out from ncstring.h and included by ncstring.h
//
//  Author:     shaunco   7 Jun 1998
//
//----------------------------------------------------------------------------

#pragma once
#ifndef _NCMSZ_H_
#define _NCMSZ_H_

ULONG
CchOfMultiSzSafe (
    IN PCWSTR pmsz);

ULONG
CchOfMultiSzAndTermSafe (
    IN PCWSTR pmsz);

inline ULONG
CbOfMultiSzAndTermSafe (
    IN PCWSTR pmsz)
{
    return CchOfMultiSzAndTermSafe (pmsz) * sizeof(WCHAR);
}


BOOL
FGetSzPositionInMultiSzSafe (
    IN PCWSTR psz,
    IN PCWSTR pmsz,
    OUT DWORD* pdwIndex,
    OUT BOOL *pfDuplicatePresent,
    OUT DWORD* pcStrings);

BOOL
FIsSzInMultiSzSafe (
    IN PCWSTR psz,
    IN PCWSTR pmsz);

// flags for HrAddSzToMultiSz and RemoveSzFromMultiSz
const   DWORD   STRING_FLAG_ALLOW_DUPLICATES       =   0x00000001;
const   DWORD   STRING_FLAG_ENSURE_AT_FRONT        =   0x00000002;
const   DWORD   STRING_FLAG_ENSURE_AT_END          =   0x00000004;
const   DWORD   STRING_FLAG_ENSURE_AT_INDEX        =   0x00000008;
const   DWORD   STRING_FLAG_DONT_MODIFY_IF_PRESENT =   0x00000010;
const   DWORD   STRING_FLAG_REMOVE_SINGLE          =   0x00000020;
const   DWORD   STRING_FLAG_REMOVE_ALL             =   0x00000040;

HRESULT
HrAddSzToMultiSz (
    IN PCWSTR pszAddString,
    IN PCWSTR pmszIn,
    IN DWORD dwFlags,
    IN DWORD dwStringIndex,
    OUT PWSTR* ppmszOut,
    OUT BOOL* pfChanged);


HRESULT
HrCreateArrayOfStringPointersIntoMultiSz (
    IN PCWSTR     pmszSrc,
    OUT UINT*       pcStrings,
    OUT PCWSTR**   papsz);

VOID
RemoveSzFromMultiSz (
    IN PCWSTR psz,
    IN OUT PWSTR  pmsz,
    IN DWORD   dwFlags,
    OUT BOOL*   pfRemoved);

VOID
SzListToMultiSz (
    IN PCWSTR psz,
    OUT DWORD*  pcb,
    OUT PWSTR* ppszOut);


#endif // _NCMSZ_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\rasdiag\private\ncstl.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       N C S T L . H
//
//  Contents:   STL utilities.
//
//  Notes:      Pollute this under penalty of death.
//
//  Author:     shaunco   09 Oct 1997
//
//----------------------------------------------------------------------------

#pragma once
#ifndef _NCSTL_H_
#define _NCSTL_H_

#include "ncstlstr.h"   // CWideString
#include "stllist.h"    // list
#include "stlvec.h"     // vector
using namespace std;


typedef CWideString tstring;
typedef list<tstring*> ListStrings;

//+--------------------------------------------------------------------------
//
//  Funct:  DumpListStrings
//
//  Desc:   debug utility function to dump out the given list
//
//  Args:
//
//  Return: (void)
//
//  Notes:
//
// History: 1-Dec-97    SumitC      Created
//
//---------------------------------------------------------------------------
inline
PCWSTR
DumpListStrings(
    IN  const list<tstring *>&  lstr,
    OUT tstring*                pstrOut)
{
    WCHAR szBuf [1024];
    INT i;
    list<tstring *>::const_iterator iter;

    pstrOut->erase();

    for (iter = lstr.begin(), i = 1;
         iter != lstr.end();
         iter++, i++)
    {
        wsprintfW(szBuf, L"   %2i: %s\n", i, (*iter)->c_str());
        pstrOut->append(szBuf);
    }

    return pstrOut->c_str();
}


template<class T>
void
FreeCollectionAndItem (
    T& col)
{
    for(T::iterator iter = col.begin(); iter != col.end(); ++iter)
    {
        T::value_type pElem = *iter;
        delete pElem;
    }

    col.erase (col.begin(), col.end());
}


template<class T>
void
FreeVectorItem (
    vector<T>& v,
    UINT i)
{

    if ((v.size()>0) && (i<v.size()))
    {
       delete v[i];
       vector<T>::iterator iterItem = v.begin() + i;
       v.erase (iterItem);
    }
}


#endif // _NCSTL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\rasdiag\private\ncdebug.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       N C D E B U G . H
//
//  Contents:   Debug routines.
//
//  Notes:
//
//  Author:     danielwe   24 Mar 1997
//
//----------------------------------------------------------------------------

#pragma once
#ifndef _NCDEBUG_H_
#define _NCDEBUG_H_

#include "dbgflags.h"       // For debugflags id definitions
#include "trace.h"

NOTHROW void InitializeDebugging ();
NOTHROW void UnInitializeDebugging ();


//
//  Useful macros to use with Asserts.
//  Eg,     Assert(FImplies(sz, !*sz));
//          Assert(FIff(sz, cch));
//
#define FImplies(a,b)       (!(a) || (b))
#define FIff(a,b)           (!(a) == !(b))


//
//  "Normal" assertion checking.  Provided for compatibility with
//  imported code.
//
//      Assert(a)       Displays a message indicating the file and line number
//                      of this Assert() if a == 0.
//      AssertSz(a,b)   As Assert(); also displays the message b (which should
//                      be a string literal.)
//      SideAssert(a)   As Assert(); the expression a is evaluated even if
//                      asserts are disabled.
//
#undef AssertSz
#undef Assert


//+---------------------------------------------------------------------------
//
// DBG (checked) build
//
#ifdef DBG

VOID
DbgCheckPrematureDllUnload (
    PCSTR pszaDllName,
    UINT ModuleLockCount);

typedef VOID     (CALLBACK * PFNASSERTHOOK)(PCSTR, PCSTR, int);
VOID    WINAPI   SetAssertFn           (PFNASSERTHOOK);
BOOL    WINAPI   FInAssert             (VOID);
VOID    WINAPI   AssertSzFn            (PCSTR pszaMsg, PCSTR pszaFile, int nLine);
VOID    WINAPI   AssertSzFn            (PCSTR pszaMsg, PCSTR pszaFile, int nLine, PCSTR pszaFunc);
VOID    CALLBACK DefAssertSzFn         (PCSTR pszaMsg, PCSTR pszaFile, int nLine);

#define Assert(a)       AssertSz(a, "Assert(" #a ")\r\n")
#define AssertSz(a,b)   if (!(a)) AssertSzFn(b, __FILE__, __LINE__);
//#define Assert(exp)       if (!(exp)) RtlAssert(#exp, __FILE__, __LINE__, NULL)
//#define AssertSz(exp,msg) if (!(exp)) RtlAssert(#exp, __FILE__, __LINE__, msg)

#define AssertH         Assert
#define AssertSzH       AssertSz

void WINAPIV AssertFmt(BOOL fExp, PCSTR pszaFile, int nLine, PCSTR pszaFmt, ...);

#define AssertValidReadPtrSz(p,msg)     AssertSz(!IsBadReadPtr(p, sizeof(*p)),  msg)
#define AssertValidWritePtrSz(p,msg)    AssertSz(!IsBadWritePtr(p, sizeof(*p)), msg)
#define AssertValidReadPtr(p)           AssertValidReadPtrSz(p,"Bad read pointer:" #p)
#define AssertValidWritePtr(p)          AssertValidWritePtrSz(p,"Bad write pointer:" #p)

#define SideAssert(a)                   Assert(a)
#define SideAssertH(a)                  AssertH(a)
#define SideAssertSz(a,b)               AssertSz(a,b)
#define SideAssertSzH(a,b)              AssertSzH(a,b)
#define NYI(a)                          AssertSz(FALSE, "NYI: " a)
#define NYIH(a)                         AssertSzH(FALSE, "NYI: " a)


//+---------------------------------------------------------------------------
//
// !DBG (retail) build
//
#else

#define DbgCheckPrematureDllUnload(a,b) NOP_FUNCTION

#define AssertH(a)
#define AssertSzH(a,b)
#define Assert(a)
#define AssertSz(a,b)
#define AssertFmt                       NOP_FUNCTION
#define AssertValidReadPtrSz(p,msg)     NOP_FUNCTION
#define AssertValidWritePtrSz(p,msg)    NOP_FUNCTION
#define AssertValidReadPtr(p)           NOP_FUNCTION
#define AssertValidWritePtr(p)          NOP_FUNCTION

#define SideAssert(a)                   (a)
#define SideAssertH(a)                  (a)
#define SideAssertSz(a,b)               (a)
#define SideAssertSzH(a,b)              (a)
#define NYI(a)                          NOP_FUNCTION

#endif  // DBG


#endif // _NCDEBUG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\rasdiag\private\ncvalid.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       N C V A L I D . H
//
//  Contents:   Generic validation functions.
//
//  Notes:
//
//  Author:     danielwe   19 Mar 1997
//
//----------------------------------------------------------------------------

#pragma once
#ifndef _NCVALID_H_
#define _NCVALID_H_


#define FBadInPtr(_p)           IsBadReadPtr(_p, sizeof(*_p))
#define FBadOutPtr(_p)          IsBadWritePtr(_p, sizeof(*_p))

#define FBadInPtrOptional(_p)   ((NULL != _p) && IsBadReadPtr(_p, sizeof(*_p)))
#define FBadOutPtrOptional(_p)  ((NULL != _p) && IsBadWritePtr(_p, sizeof(*_p)))


inline BOOL FBadInRefiid (REFIID riid)
{
    return IsBadReadPtr(&riid, sizeof(IID));
}


#endif // _NCVALID_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\rasdiag\private\stlmem.h ===
#pragma once
#ifndef _STLMEM_H_
#define _STLMEM_H_
//#include <memory>

#include <stlxmem.h>

#ifdef  _MSC_VER
#pragma pack(push,8)
#endif  /* _MSC_VER */

// TEMPLATE OPERATOR new
template<class _Ty> inline
void *operator new(size_t _N, std::allocator<_Ty>& _Al)
{
    return (_Al._Charalloc(_N));
}

_STD_BEGIN

// TEMPLATE FUNCTION get_temporary_buffer
template<class _Ty> inline
pair<_Ty _FARQ *, _PDFT>
get_temporary_buffer(_PDFT _N, _Ty _FARQ *)
{
    _Ty _FARQ *_P;
    for (_P = 0; 0 < _N; _N /= 2)
        if ((_P = (_Ty _FARQ *)operator new(
                                           (_SIZT)_N * sizeof (_Ty), nothrow)) != 0)
            break;
    return (pair<_Ty _FARQ *, _PDFT>(_P, _N));
}

// TEMPLATE FUNCTION return_temporary_buffer
template<class _Ty> inline
void return_temporary_buffer(_Ty *_P)
{
    operator delete(_P);
}

// TEMPLATE FUNCTION uninitialized_copy
template<class _II, class _FI> inline
_FI uninitialized_copy(_II _F, _II _L, _FI _X)
{
    for (; _F != _L; ++_X, ++_F)
        _Construct(&*_X, *_F);
    return (_X);
}

// TEMPLATE FUNCTION uninitialized_fill
template<class _FI, class _Ty> inline
void uninitialized_fill(_FI _F, _FI _L, const _Ty& _X)
{
    for (; _F != _L; ++_F)
        _Construct(&*_F, _X);
}

// TEMPLATE FUNCTION uninitialized_fill_n
template<class _FI, class _S, class _Ty> inline
void uninitialized_fill_n(_FI _F, _S _N, const _Ty& _X)
{
    for (; 0 < _N; --_N, ++_F)
        _Construct(&*_F, _X);
}

// TEMPLATE CLASS raw_storage_iterator
template<class _OI, class _Ty>
class raw_storage_iterator : public iterator<output_iterator_tag, void, void>
{
public:
    typedef _OI iterator_type;
    typedef _Ty element_type;
    explicit raw_storage_iterator(_OI _X) : _Next(_X)
    {
    }
    raw_storage_iterator<_OI, _Ty>& operator*()
    {
        return (*this);
    }
    raw_storage_iterator<_OI, _Ty>& operator=(const _Ty& _X)
    {
        _Construct(&*_Next, _X);
        return (*this);
    }
    raw_storage_iterator<_OI, _Ty>& operator++()
    {
        ++_Next;
        return (*this);
    }
    raw_storage_iterator<_OI, _Ty> operator++(int)
    {
        raw_storage_iterator<_OI, _Ty> _Ans = *this;
        ++_Next;
        return (_Ans);
    }
private:
    _OI _Next;
};

// TEMPLATE CLASS _Temp_iterator
template<class _Ty>
class _Temp_iterator : public iterator<output_iterator_tag, void, void>
{
public:
    typedef _Ty _FARQ *_Pty;
    _Temp_iterator(_PDFT _N = 0)
    {
        pair<_Pty, _PDFT> _Pair =
        get_temporary_buffer(_N, (_Pty)0);
        _Buf._Begin = _Pair.first;
        _Buf._Cur = _Pair.first;
        _Buf._Hiwater = _Pair.first;
        _Buf._Len = _Pair.second;
        _Pb = &_Buf;
    }
    _Temp_iterator(const _Temp_iterator<_Ty>& _X)
    {
        _Buf._Begin = 0;
        _Buf._Cur = 0;
        _Buf._Hiwater = 0;
        _Buf._Len = 0;
        *this = _X;
    }
    ~_Temp_iterator()
    {
        if (_Buf._Begin != 0)
        {
            for (_Pty _F = _Buf._Begin;
                _F != _Buf._Hiwater; ++_F)
                _Destroy(&*_F);
            return_temporary_buffer(_Buf._Begin);
        }
    }
    _Temp_iterator<_Ty>& operator=(const _Temp_iterator<_Ty>& _X)
    {
        _Pb = _X._Pb;
        return (*this);
    }
    _Temp_iterator<_Ty>& operator=(const _Ty& _V)
    {
        if (_Pb->_Cur < _Pb->_Hiwater)
            *_Pb->_Cur++ = _V;
        else
        {
            _Construct(&*_Pb->_Cur, _V);
            _Pb->_Hiwater = ++_Pb->_Cur;
        }
        return (*this);
    }
    _Temp_iterator<_Ty>& operator*()
    {
        return (*this);
    }
    _Temp_iterator<_Ty>& operator++()
    {
        return (*this);
    }
    _Temp_iterator<_Ty>& operator++(int)
    {
        return (*this);
    }
    _Temp_iterator<_Ty>& _Init()
    {
        _Pb->_Cur = _Pb->_Begin;
        return (*this);
    }
    _Pty _First() const
    {
        return (_Pb->_Begin);
    }
    _Pty _Last() const
    {
        return (_Pb->_Cur);
    }
    _PDFT _Maxlen() const
    {
        return (_Pb->_Len);
    }
private:
    struct _Bufpar
    {
        _Pty _Begin;
        _Pty _Cur;
        _Pty _Hiwater;
        _PDFT _Len;
    } _Buf, *_Pb;
};

// TEMPLATE CLASS auto_ptr
template<class _Ty>
class auto_ptr
{
public:
    typedef _Ty element_type;
    explicit auto_ptr(_Ty *_P = 0) _THROW0() : _Owns(_P != 0), _Ptr(_P)
    {
    }
    auto_ptr(const auto_ptr<_Ty>& _Y) _THROW0()
        : _Owns(_Y._Owns), _Ptr(_Y.release())
    {
    }
    auto_ptr<_Ty>& operator=(const auto_ptr<_Ty>& _Y) _THROW0()
    {
        if (_Ptr != _Y.get())
        {
            if (_Owns)
                delete _Ptr;
            _Owns = _Y._Owns;
            _Ptr = _Y.release();
        }
        else if (_Y._Owns)
            _Owns = true;
        return (*this);
    }
    ~auto_ptr()
    {
        if (_Owns)
            delete _Ptr;
    }
    _Ty& operator*() const _THROW0()
    {
        return (*get());
    }
    _Ty *operator->() const _THROW0()
    {
        return (get());
    }
    _Ty *get() const _THROW0()
    {
        return (_Ptr);
    }
    _Ty *release() const _THROW0()
    {
        ((auto_ptr<_Ty> *)this)->_Owns = false;
        return (_Ptr);
    }
private:
    bool _Owns;
    _Ty *_Ptr;
};

_STD_END

#ifdef  _MSC_VER
#pragma pack(pop)
#endif  /* _MSC_VER */

#endif /* _STLMEM_H_ */

/*
 * Copyright (c) 1995 by P.J. Plauger.  ALL RIGHTS RESERVED.
 * Consult your license regarding permissions and restrictions.
 */

/*
 * This file is derived from software bearing the following
 * restrictions:
 *
 * Copyright (c) 1994
 * Hewlett-Packard Company
 *
 * Permission to use, copy, modify, distribute and sell this
 * software and its documentation for any purpose is hereby
 * granted without fee, provided that the above copyright notice
 * appear in all copies and that both that copyright notice and
 * this permission notice appear in supporting documentation.
 * Hewlett-Packard Company makes no representations about the
 * suitability of this software for any purpose. It is provided
 * "as is" without express or implied warranty.
 */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\rasdiag\private\ncstring.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       N C S T R I N G . H
//
//  Contents:   Common string routines.
//
//  Notes:
//
//  Author:     shaunco   24 Mar 1997
//
//----------------------------------------------------------------------------

#pragma once

#include "ncdebug.h"
#include "ncvalid.h"
#include "ncmsz.h"
#include "ncstl.h"


const int c_cchGuidWithTerm = 39; // includes terminating null
const int c_cbGuidWithTerm   = c_cchGuidWithTerm * sizeof(WCHAR);


inline ULONG CbOfSz         (PCWSTR psz)   { AssertH(psz); return wcslen (psz) * sizeof(WCHAR); }
inline ULONG CbOfSza        (PCSTR  psza)  { AssertH(psza); return strlen (psza) * sizeof(CHAR); }

inline ULONG CbOfSzAndTerm  (PCWSTR psz)   { AssertH(psz); return (wcslen (psz) + 1) * sizeof(WCHAR); }
inline ULONG CbOfSzaAndTerm (PCSTR  psza)  { AssertH(psza); return (strlen (psza) + 1) * sizeof(CHAR); }

ULONG CbOfSzSafe            (PCWSTR psz);
ULONG CbOfSzaSafe           (PCSTR  psza);

ULONG CbOfSzAndTermSafe     (PCWSTR psz);
ULONG CbOfSzaAndTermSafe    (PCSTR  psza);

ULONG
CchOfSzSafe (
    PCWSTR psz);

inline ULONG CchToCb        (ULONG cch)     { return cch * sizeof(WCHAR); }


struct MAP_SZ_DWORD
{
    PCWSTR pszValue;
    DWORD  dwValue;
};


PWSTR
PszAllocateAndCopyPsz (
    PCWSTR pszSrc);

extern const WCHAR c_szEmpty[];

template<class T>
VOID
ConvertStringToColString (
    IN  PCWSTR psz,
    IN  const WCHAR chSeparator,
    OUT T& coll)
{
    AssertSz(chSeparator, "Separator can not be \0");

    FreeCollectionAndItem(coll);

    if (NULL == psz)
    {
        return;
    }

    PWSTR  pszBuf = new WCHAR[wcslen(psz) + 1];

    wcscpy(pszBuf, psz);
    WCHAR* pchString = pszBuf;
    WCHAR* pchSeparator;
    while (*pchString)
    {
        pchSeparator = wcschr(pchString, chSeparator);
        if (pchSeparator)
        {
            *pchSeparator = 0;
        }

        if (*pchString)
        {
            coll.push_back(new tstring(pchString));
        }

        if (pchSeparator)
        {
            pchString = pchSeparator + 1;
        }
        else
        {
            break;
        }
    }

    delete [] pszBuf;
}


template<class T>
VOID
ConvertColStringToString (
    IN  const T& coll,
    IN  const WCHAR chSeparator,
    OUT tstring& str)
{
    AssertSz(chSeparator, "Separator can not be \0");

    if (chSeparator)
    {
        T::const_iterator iter = coll.begin();

        while (iter != coll.end())
        {
            str += (*iter)->c_str();

            ++iter;
            if (iter != coll.end())
            {
                str += chSeparator;
            }
        }
    }
}


DWORD
WINAPIV
DwFormatString (
    PCWSTR pszFmt,
    PWSTR  pszBuf,
    DWORD   cchBuf,
    ...);

DWORD
WINAPIV
DwFormatStringWithLocalAlloc (
    PCWSTR pszFmt,
    PWSTR* ppszBuf,
    ...);

enum NC_IGNORE_SPACES
{
    NC_IGNORE,
    NC_DONT_IGNORE,
};


BOOL
FFindStringInCommaSeparatedList (
    PCWSTR pszSubString,
    PCWSTR pszList,
    NC_IGNORE_SPACES eIgnoreSpaces,
    DWORD* pdwPosition);

enum NC_FIND_ACTION
{
    NC_NO_ACTION,
    NC_REMOVE_FIRST_MATCH,
    NC_REMOVE_ALL_MATCHES,
};

inline BOOL
FFindFirstMatch (
    NC_FIND_ACTION eAction)
{
    return (NC_NO_ACTION == eAction) || (NC_REMOVE_FIRST_MATCH == eAction);
}

//+---------------------------------------------------------------------------
//
//  Function:   FIsBstrEmpty
//
//  Purpose:    Determines if the given BSTR is "empty" meaning the pointer
//              is NULL or the string is 0-length.
//
//  Arguments:
//      bstr [in]   BSTR to check.
//
//  Returns:    TRUE if the BSTR is empty, FALSE if not.
//
//  Author:     danielwe   20 May 1997
//
//  Notes:
//
inline
BOOL
FIsBstrEmpty (
    BSTR    bstr)
{
    return !(bstr && *bstr);
}

//+---------------------------------------------------------------------------
//
//  Function:   FIsStrEmpty
//
//  Purpose:    Determines if the given PCWSTR is "empty" meaning the pointer
//              is NULL or the string is 0-length.
//
//  Arguments:
//      bstr [in]   BSTR to check.
//
//  Returns:    TRUE if the BSTR is empty, FALSE if not.
//
//  Author:     danielwe   20 May 1997
//
//  Notes:
//
inline
BOOL
FIsStrEmpty (
    PCWSTR    psz)
{
    return !(psz && *psz);
}

//+---------------------------------------------------------------------------
//
//  Function:   FIsPrefix
//
//  Purpose:    Returns whether a string is a prefix of another string.
//
//  Arguments:
//      pszPrefix [in]   Potential prefix
//      pszString [in]   String that may begin with the prefix
//
//  Returns:    TRUE if given prefix string is a prefix of the target string.
//
//  Author:     danielwe   24 Mar 1997
//
//  Notes:      Uses CompareString with the default locale.
//
inline
BOOL
FIsPrefix (
    PCWSTR pszPrefix,
    PCWSTR pszString)
{
    Assert (pszPrefix);
    Assert (pszString);

    return (0 == _wcsnicmp(pszPrefix, pszString, wcslen(pszPrefix)));
}

BOOL
FIsSubstr (
    PCWSTR pszSubString,
    PCWSTR pszString);

HRESULT
HrAddStringToDelimitedSz (
    PCWSTR pszAddString,
    PCWSTR pszIn,
    WCHAR chDelimiter,
    DWORD dwFlags,
    DWORD dwStringIndex,
    PWSTR* ppszOut);

HRESULT
HrRemoveStringFromDelimitedSz (
    PCWSTR pszRemove,
    PCWSTR pszIn,
    WCHAR chDelimiter,
    DWORD dwFlags,
    PWSTR* ppszOut);


//+---------------------------------------------------------------------------
//
//  Function:   template<class T> ColStringToMultiSz
//
//  Purpose:    Convert an STL collection of tstring pointers to a multi-sz.
//
//  Arguments:
//      listStr [in]    list of tstring pointers to put in the multi-sz.
//      ppszOut [out]   the returned multi-sz.
//
//  Returns:    nothing.
//
//  Author:     shaunco   10 Apr 1997
//
//  Notes:      The output multi-sz should be freed using delete.
//
template<class T>
VOID
ColStringToMultiSz (
    const T&    colStr,
    PWSTR*     ppszOut)
{
    Assert (ppszOut);

    // Count up the count of characters consumed by the list of strings.
    // This count includes the null terminator of each string.
    //
    T::const_iterator iter;
    UINT cch = 0;
    for (iter = colStr.begin(); iter != colStr.end(); iter++)
    {
        tstring* pstr = *iter;
        if (!pstr->empty())
        {
            cch += (UINT)(pstr->length() + 1);
        }
    }

    if (cch)
    {
        // Allocate the multi-sz.  Assumes new will throw on error.
        //
        PWSTR pszOut = new WCHAR [cch + 1];
        *ppszOut = pszOut;

        // Copy the strings to the multi-sz.
        //
        for (iter = colStr.begin(); iter != colStr.end(); iter++)
        {
            tstring* pstr = *iter;
            if (!pstr->empty())
            {
                lstrcpyW (pszOut, pstr->c_str());
                pszOut += pstr->length() + 1;
            }
        }

        // Null terminate the multi-sz.
        Assert (pszOut == *ppszOut + cch);
        *pszOut = 0;
    }
    else
    {
        *ppszOut = NULL;
    }
}

//+---------------------------------------------------------------------------
//
//  Function:   template<class T> DeleteColString
//
//  Purpose:    Empty a list of tstring and delete each tstring as it is
//              removed.
//
//  Arguments:
//      pcolstr [inout] Collection of tstring pointers to delete and empty
//
//  Returns:    nothing
//
//  Author:     mikemi   30 Apr 1997
//
//  Notes:
//
template<class T>
VOID
DeleteColString (
    T*  pcolstr)
{
    Assert( pcolstr );

    T::const_iterator iter;
    tstring* pstr;

    for (iter = pcolstr->begin(); iter != pcolstr->end(); iter++)
    {
        pstr = *iter;
        delete pstr;
    }
    pcolstr->erase( pcolstr->begin(), pcolstr->end() );
}

//+---------------------------------------------------------------------------
//
//  Function:   template<class T> MultiSzToColString
//
//  Purpose:    Convert an multi-sz buffer to a STL collection of tstring
//              pointers.
//
//  Arguments:
//      pmsz    [in]    the multi-sz to convert (Can be NULL)
//      pcolstr [out]   list of tstring pointers to add allocated tstrings to
//
//  Returns:    nothing
//
//  Author:     mikemi   30 Apr 1997
//
//  Notes:      The output collection should be freed using DeleteColString.
//              This function will delete the collection list passed
//
template<class T>
VOID
MultiSzToColString (
    PCWSTR pmsz,
    T*      pcolstr)
{
    Assert (pcolstr);

    if (!pcolstr->empty())
    {
        DeleteColString (pcolstr);
    }

    if (pmsz)
    {
        while (*pmsz)
        {
            tstring* pstr = new tstring;
            if (pstr)
            {
                *pstr = pmsz;
                pcolstr->push_back (pstr);
            }
            // get the next string even if new failed
            pmsz += lstrlen (pmsz) + 1;
        }
    }
}

//+---------------------------------------------------------------------------
//
//  Function:   template<class T> RemoveDupsInColPtr
//
//  Purpose:    Remove all duplicate entries in an STL collection of pointers
//              to objects.
//
//  Arguments:
//      pcol [inout]    Collection of pointers to objects.
//
//  Returns:    nothing
//
//  Author:     mikemi   03 May 1997
//
//  Notes:      The objects pointed at should have a comparison operator
//
template<class T>
VOID
RemoveDupsInColPtr (
    T*  pcol)
{
    Assert (pcol);

    // remove duplicates
    //
    T::iterator     posItem;
    T::iterator     pos;
    T::value_type   pItem;
    T::value_type   p;

    posItem = pcol->begin();
    while (posItem != pcol->end())
    {
        pItem = *posItem;

        // for every other item, remove the duplicates
        pos = posItem;
        pos++;
        while (pos != pcol->end())
        {
            p = *pos;

            if ( *pItem == *p )
            {
                pos = pcol->erase( pos );
                delete p;
            }
            else
            {
                pos++;
            }
        }
        // increment afterwards due to fact that we are removing,
        // and otherwise could have removed the item it pointed to
        posItem++;
    }
}

//+---------------------------------------------------------------------------
//
//  Function:   template<class T> CopyColPtr
//
//  Purpose:    Copies one collection of pointers into another.
//
//  Arguments:
//      pcolDest [out]  Collection of pointers to objects.
//      pcolSrc  [in]   Collection of pointers to objects.
//
//  Returns:    nothing
//
//  Author:     BillBe   13 Jun 1998
//
//  Notes:
//
template<class T>
VOID
CopyColPtr (T* pcolDest, const T& colSrc)
{
    Assert (pcolDest);

    T::iterator     posItem;

    // Clear out destination
    pcolDest->erase(pcolDest->begin(), pcolDest->end());

    // Go through each item in pcolSrc and add to pcolDest
    //
    posItem = colSrc.begin();
    while (posItem != colSrc.end())
    {
        pcolDest->push_back(*posItem);
        posItem++;
    }
}


PCWSTR
SzLoadStringPcch (
    HINSTANCE   hinst,
    UINT        unId,
    int*        pcch);

//+---------------------------------------------------------------------------
//
//  Function:   SzLoadString
//
//  Purpose:    Load a resource string.  (This function will never return NULL.)
//
//  Arguments:
//      hinst [in]  Instance handle of module with the string resource.
//      unId  [in]  Resource ID of the string to load.
//
//  Returns:    Pointer to the constant string.
//
//  Author:     shaunco   24 Mar 1997
//
//  Notes:      See SzLoadStringPcch()
//
inline
PCWSTR
SzLoadString (
    HINSTANCE   hinst,
    UINT        unId)
{
    int cch;
    return SzLoadStringPcch(hinst, unId, &cch);
}

PSTR
SzaDupSza (
    IN PCSTR  pszaSrc);

PWSTR
SzDupSz (
    IN PCWSTR pszSrc);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\rasdiag\private\stlnew.h ===
#pragma once
#ifndef _STLNEW_H_
#define _STLNEW_H_
//#include <exception>

#include <stlexcep.h>
#include "ncmem.h"

#ifdef  _MSC_VER
#pragma pack(push,8)
#endif  /* _MSC_VER */

_STD_BEGIN

// CLASS bad_alloc
class /*_CRTIMP*/ bad_alloc : public exception
{
public:
    bad_alloc(const char *_S = "bad allocation") _THROW0() : exception(_S)
    {
    }
    virtual ~bad_alloc() _THROW0()
    {
    }
protected:
    virtual void _Doraise() const
    {
        _RAISE(*this);
    }
};

// SUPPORT TYPES
struct nothrow_t
{
};
extern /*_CRTIMP*/ const nothrow_t nothrow;

_STD_END

/*
typedef void (__cdecl *new_handler)();
extern new_handler _New_hand;

// new AND delete DECLARATIONS
void  __cdecl operator delete(void *) _THROW0();
void* __cdecl operator new(size_t) _THROW1(std::bad_alloc);
void* __cdecl operator new(size_t, const std::nothrow_t&) _THROW0();
*/

#ifndef __PLACEMENT_NEW_INLINE
#define __PLACEMENT_NEW_INLINE
inline void *__cdecl operator new(size_t, void *_P)
{
    return (_P);
}
#if  _MSC_VER >= 1200
inline void __cdecl operator delete(void *, void*)
{
    return;
}
#endif
#endif

/*
#ifdef _CRTIMP
_CRTIMP
#endif
new_handler __cdecl set_new_handler(new_handler) _THROW0();
*/

#ifdef  _MSC_VER
#pragma pack(pop)
#endif  /* _MSC_VER */

#endif /* _STLNEW_H_ */

/*
 * Copyright (c) 1994 by P.J. Plauger.  ALL RIGHTS RESERVED.
 * Consult your license regarding permissions and restrictions.
 */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\rasdiag\private\ncstlstr.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       N C S T L S T R . H
//
//  Contents:   STL string class renamed so as to remove our dependance
//              from msvcp50.dll.
//
//  Notes:
//
//  Author:     shaunco   12 Apr 1998
//
//----------------------------------------------------------------------------

#pragma once
#ifndef _NCSTLSTR_H_
#define _NCSTLSTR_H_

#include <stliter.h>
#include <stlxutil.h>
#include <limits.h>
#include <wchar.h>
#include "ncdebug.h"
using namespace std;


//template<class _E,
//class _Tr = char_traits<_E>,
//class _A  = allocator<_E> >

struct wchar_traits
{
    typedef wchar_t     _E;
    typedef _E          char_type;   // for overloads
    typedef wint_t      int_type;
    typedef mbstate_t   state_type;

    static void __cdecl assign(_E& _X, const _E& _Y)
    {
        _X = _Y;
    }
    static bool __cdecl eq(const _E& _X, const _E& _Y)
    {
        return (_X == _Y);
    }
    static bool __cdecl lt(const _E& _X, const _E& _Y)
    {
        return (_X < _Y);
    }
    static int __cdecl compare(const _E *_U, const _E *_V, size_t _N)
    {
        return (wmemcmp(_U, _V, _N));
    }
    static size_t __cdecl length(const _E *_U)
    {
        return (wcslen(_U));
    }
    static _E *__cdecl copy(_E *_U, const _E *_V, size_t _N)
    {
        return (wmemcpy(_U, _V, _N));
    }
    static const _E * __cdecl find(const _E *_U, size_t _N,
                                   const _E& _C)
    {
        return ((const _E *)wmemchr(_U, _C, _N));
    }
    static _E * __cdecl move(_E *_U, const _E *_V, size_t _N)
    {
        return (wmemmove(_U, _V, _N));
    }
    static _E * __cdecl assign(_E *_U, size_t _N, const _E& _C)
    {
        return (wmemset(_U, _C, _N));
    }
    static _E __cdecl to_char_type(const int_type& _C)
    {
        return (_C);
    }
    static int_type __cdecl to_int_type(const _E& _C)
    {
        return (_C);
    }
    static bool __cdecl eq_int_type(const int_type& _X,
                                    const int_type& _Y)
    {
        return (_X == _Y);
    }
    static int_type __cdecl eof()
    {
        return (WEOF);
    }
    static int_type __cdecl not_eof(const int_type& _C)
    {
        return (_C != eof() ? _C : !eof());
    }
};


class CWideString
{
public:
    typedef CWideString     _Myt;
    typedef wchar_traits    _Tr;
    typedef _Tr::_E         _E;
    typedef size_t          size_type;
    typedef ptrdiff_t       difference_type;
    typedef _E*             pointer;
    typedef const _E*       const_pointer;
    typedef _E&             reference;
    typedef const _E&       const_reference;
    typedef _E              value_type;
    typedef pointer         iterator;
    typedef const_pointer   const_iterator;

    typedef reverse_iterator<const_iterator, value_type, const_reference,
                                const_pointer, difference_type>
                const_reverse_iterator;

    typedef reverse_iterator<iterator, value_type, reference, pointer,
                                difference_type>
                reverse_iterator;

    typedef const_iterator _It;

    explicit CWideString()
    {
        _Tidy();
    }
    CWideString(const _Myt& _X)
    {
        _Tidy(), assign(_X, 0, npos);
    }
    CWideString(const _Myt& _X, size_type _P, size_type _M)
    {
        _Tidy(), assign(_X, _P, _M);
    }
    CWideString(const _E *_S, size_type _N)
    {
        _Tidy(), assign(_S, _N);
    }
    CWideString(const _E *_S)
    {
        _Tidy(), assign(_S);
    }
    CWideString(size_type _N, _E _C)
    {
        _Tidy(), assign(_N, _C);
    }
    CWideString(_It _F, _It _L)
    {
        _Tidy(); assign(_F, _L);
    }
    ~CWideString()
    {
        _Tidy(true);
    }
    enum _Mref
    {
        _FROZEN = USHRT_MAX
    };
    enum _Npos
    {
        // -1 is not arbitrary.  It is chosen because it works in math
        // operations.  npos is treated as size_type and is inolved in
        // arithmetic.
        //
        npos = -1
    };
    _Myt& operator=(const _Myt& _X)
    {
        return (assign(_X));
    }
    _Myt& operator=(const _E *_S)
    {
        return (assign(_S));
    }
    _Myt& operator=(_E _C)
    {
        return (assign(1, _C));
    }
    _Myt& operator+=(const _Myt& _X)
    {
        return (append(_X));
    }
    _Myt& operator+=(const _E *_S)
    {
        return (append(_S));
    }
    _Myt& operator+=(_E _C)
    {
        return (append(1, _C));
    }
    _Myt& append(const _Myt& _X)
    {
        return (append(_X, 0, npos));
    }
    _Myt& append(const _Myt& _X, size_type _P, size_type _M)
    {
        AssertH (_X.size() >= _P);
        //if (_X.size() < _P)
        //    _Xran();

        size_type _N = _X.size() - _P;
        if (_N < _M)
            _M = _N;

        AssertH ((_Len + _M < npos));
        //if (npos - _Len <= _M)
        //    _Xlen();

        if (0 < _M && _Grow(_N = _Len + _M))
        {
            _Tr::copy(_Ptr + _Len, &_X.c_str()[_P], _M);
            _Eos(_N);
        }
        return (*this);
    }
    _Myt& append(const _E *_S, size_type _M)
    {
        AssertH ((_Len + _M < npos));
        //if (npos - _Len <= _M)
        //    _Xlen();

        size_type _N;
        if (0 < _M && _Grow(_N = _Len + _M))
        {
            _Tr::copy(_Ptr + _Len, _S, _M);
            _Eos(_N);
        }
        return (*this);
    }
    _Myt& append(const _E *_S)
    {
        return (append(_S, _Tr::length(_S)));
    }
    _Myt& append(size_type _M, _E _C)
    {
        AssertH ((_Len + _M < npos));
        //if (npos - _Len <= _M)
        //    _Xlen();

        size_type _N;
        if (0 < _M && _Grow(_N = _Len + _M))
        {
            _Tr::assign(_Ptr + _Len, _M, _C);
            _Eos(_N);
        }
        return (*this);
    }
    _Myt& append(_It _F, _It _L)
    {
        return (replace(end(), end(), _F, _L));
    }
    _Myt& assign(const _Myt& _X)
    {
        return (assign(_X, 0, npos));
    }
    _Myt& assign(const _Myt& _X, size_type _P, size_type _M)
    {
        AssertH (_X.size() >= _P);
        //if (_X.size() < _P)
        //    _Xran();

        size_type _N = _X.size() - _P;
        if (_M < _N)
            _N = _M;

        if (this == &_X)
        {
            erase((size_type)(_P + _N)), erase(0, _P);
        }
        else if (0 < _N && _N == _X.size()
                 && _Refcnt(_X.c_str()) < _FROZEN - 1)
        {
            _Tidy(true);
            _Ptr = (_E *)_X.c_str();
            _Len = _X.size();
            _Res = _X.capacity();
            ++_Refcnt(_Ptr);
        }
        else if (_Grow(_N, true))
        {
            _Tr::copy(_Ptr, &_X.c_str()[_P], _N);
            _Eos(_N);
        }
        return (*this);
    }
    _Myt& assign(const _E *_S, size_type _N)
    {
        if (_Grow(_N))
        {
            _Tr::copy(_Ptr, _S, _N);
            _Eos(_N);
        }
        return (*this);
    }
    _Myt& assign(const _E *_S)
    {
        return (assign(_S, _Tr::length(_S)));
    }
    _Myt& assignSafe(const _E *_S)
    {
        return (_S) ? assign(_S, _Tr::length(_S)) : erase();
    }
    _Myt& assign(size_type _N, _E _C)
    {
        AssertH (npos != _N);
        //if (_N == npos)
        //    _Xlen();

        if (_Grow(_N))
        {
            _Tr::assign(_Ptr, _N, _C);
            _Eos(_N);
        }
        return (*this);
    }
    _Myt& assign(_It _F, _It _L)
    {
        return (replace(begin(), end(), _F, _L));
    }
    _Myt& insert(size_type _P0, const _Myt& _X)
    {
        return (insert(_P0, _X, 0, npos));
    }
    _Myt& insert(size_type _P0, const _Myt& _X, size_type _P, size_type _M)
    {
        AssertH ((_Len >= _P0) && (_X.size() >= _P));
        //if (_Len < _P0 || _X.size() < _P)
        //    _Xran();

        size_type _N = _X.size() - _P;
        if (_N < _M)
            _M = _N;

        AssertH ((_Len + _M < npos));
        //if (npos - _Len <= _M)
        //    _Xlen();

        if (0 < _M && _Grow(_N = _Len + _M))
        {
            _Tr::move(_Ptr + _P0 + _M, _Ptr + _P0, _Len - _P0);
            _Tr::copy(_Ptr + _P0, &_X.c_str()[_P], _M);
            _Eos(_N);
        }
        return (*this);
    }
    _Myt& insert(size_type _P0, const _E *_S, size_type _M)
    {
        AssertH (_Len >= _P0);
        //if (_Len < _P0)
        //    _Xran();

        AssertH ((_Len + _M < npos));
        //if (npos - _Len <= _M)
        //    _Xlen();

        size_type _N;
        if (0 < _M && _Grow(_N = _Len + _M))
        {
            _Tr::move(_Ptr + _P0 + _M, _Ptr + _P0, _Len - _P0);
            _Tr::copy(_Ptr + _P0, _S, _M);
            _Eos(_N);
        }
        return (*this);
    }
    _Myt& insert(size_type _P0, const _E *_S)
    {
        return (insert(_P0, _S, _Tr::length(_S)));
    }
    _Myt& insert(size_type _P0, size_type _M, _E _C)
    {
        AssertH (_Len >= _P0);
        //if (_Len < _P0)
        //    _Xran();

        AssertH ((_Len + _M < npos));
        //if (npos - _Len <= _M)
        //    _Xlen();

        size_type _N;
        if (0 < _M && _Grow(_N = _Len + _M))
        {
            _Tr::move(_Ptr + _P0 + _M, _Ptr + _P0, _Len - _P0);
            _Tr::assign(_Ptr + _P0, _M, _C);
            _Eos(_N);
        }
        return (*this);
    }
    iterator insert(iterator _P, _E _C)
    {
        size_type _P0 = _Pdif(_P, begin());
        insert(_P0, 1, _C);
        return (begin() + _P0);
    }
    void insert(iterator _P, size_type _M, _E _C)
    {
        size_type _P0 = _Pdif(_P, begin());
        insert(_P0, _M, _C);
    }
    void insert(iterator _P, _It _F, _It _L)
    {
        replace(_P, _P, _F, _L);
    }
    _Myt& erase(size_type _P0 = 0, size_type _M = npos)
    {
        AssertH (_Len >= _P0);
        //if (_Len < _P0)
        //    _Xran();

        _Split();
        if (_Len - _P0 < _M)
            _M = _Len - _P0;
        if (0 < _M)
        {
            _Tr::move(_Ptr + _P0, _Ptr + _P0 + _M,
                      _Len - _P0 - _M);
            size_type _N = _Len - _M;
            if (_Grow(_N))
                _Eos(_N);
        }
        return (*this);
    }
    iterator erase(iterator _P)
    {
        size_t _M = _Pdif(_P, begin());
        erase(_M, 1);
        return (_Psum(_Ptr, _M));
    }
    iterator erase(iterator _F, iterator _L)
    {
        size_t _M = _Pdif(_F, begin());
        erase(_M, _Pdif(_L, _F));
        return (_Psum(_Ptr, _M));
    }
    _Myt& replace(size_type _P0, size_type _N0, const _Myt& _X)
    {
        return (replace(_P0, _N0, _X, 0, npos));
    }
    _Myt& replace(size_type _P0, size_type _N0, const _Myt& _X,
                  size_type _P, size_type _M)
    {
        AssertH ((_Len >= _P0) && (_X.size() >= _P));
        //if (_Len < _P0 || _X.size() < _P)
        //    _Xran();

        if (_Len - _P0 < _N0)
            _N0 = _Len - _P0;

        size_type _N = _X.size() - _P;
        if (_N < _M)
            _M = _N;

        AssertH (npos - _M > _Len - _N0);
        //if (npos - _M <= _Len - _N0)
        //    _Xlen();

        _Split();
        size_type _Nm = _Len - _N0 - _P0;
        if (_M < _N0)
            _Tr::move(_Ptr + _P0 + _M, _Ptr + _P0 + _N0, _Nm);

        if ((0 < _M || 0 < _N0) && _Grow(_N = _Len + _M - _N0))
        {
            if (_N0 < _M)
                _Tr::move(_Ptr + _P0 + _M, _Ptr + _P0 + _N0, _Nm);
            _Tr::copy(_Ptr + _P0, &_X.c_str()[_P], _M);
            _Eos(_N);
        }
        return (*this);
    }
    _Myt& replace(size_type _P0, size_type _N0, const _E *_S,
                  size_type _M)
    {
        AssertH (_Len >= _P0);
        //if (_Len < _P0)
        //    _Xran();

        if (_Len - _P0 < _N0)
            _N0 = _Len - _P0;

        AssertH (npos - _M > _Len - _N0);
        //if (npos - _M <= _Len - _N0)
        //    _Xlen();

        _Split();
        size_type _Nm = _Len - _N0 - _P0;
        if (_M < _N0)
            _Tr::move(_Ptr + _P0 + _M, _Ptr + _P0 + _N0, _Nm);
        size_type _N;
        if ((0 < _M || 0 < _N0) && _Grow(_N = _Len + _M - _N0))
        {
            if (_N0 < _M)
                _Tr::move(_Ptr + _P0 + _M, _Ptr + _P0 + _N0, _Nm);
            _Tr::copy(_Ptr + _P0, _S, _M);
            _Eos(_N);
        }
        return (*this);
    }
    _Myt& replace(size_type _P0, size_type _N0, const _E *_S)
    {
        return (replace(_P0, _N0, _S, _Tr::length(_S)));
    }
    _Myt& replace(size_type _P0, size_type _N0,
                  size_type _M, _E _C)
    {
        AssertH (_Len >= _P0);
        //if (_Len < _P0)
        //    _Xran();

        if (_Len - _P0 < _N0)
            _N0 = _Len - _P0;

        AssertH (npos - _M > _Len - _N0);
        //if (npos - _M <= _Len - _N0)
        //    _Xlen();

        _Split();
        size_type _Nm = _Len - _N0 - _P0;
        if (_M < _N0)
            _Tr::move(_Ptr + _P0 + _M, _Ptr + _P0 + _N0, _Nm);
        size_type _N;
        if ((0 < _M || 0 < _N0) && _Grow(_N = _Len + _M - _N0))
        {
            if (_N0 < _M)
                _Tr::move(_Ptr + _P0 + _M, _Ptr + _P0 + _N0,
                          _Nm);
            _Tr::assign(_Ptr + _P0, _M, _C);
            _Eos(_N);
        }
        return (*this);
    }
    _Myt& replace(iterator _F, iterator _L, const _Myt& _X)
    {
        return (replace(_Pdif(_F, begin()), _Pdif(_L, _F), _X));
    }
    _Myt& replace(iterator _F, iterator _L, const _E *_S,
                  size_type _M)
    {
        return (replace(_Pdif(_F, begin()), _Pdif(_L, _F), _S, _M));
    }
    _Myt& replace(iterator _F, iterator _L, const _E *_S)
    {
        return (replace(_Pdif(_F, begin()), _Pdif(_L, _F), _S));
    }
    _Myt& replace(iterator _F, iterator _L, size_type _M, _E _C)
    {
        return (replace(_Pdif(_F, begin()), _Pdif(_L, _F), _M, _C));
    }
    _Myt& replace(iterator _F1, iterator _L1,
                  _It _F2, _It _L2)
    {
        size_type _P0 = _Pdif(_F1, begin());
        size_type _M = 0;
        _Distance(_F2, _L2, _M);
        replace(_P0, _Pdif(_L1, _F1), _M, _E(0));
        for (_F1 = begin() + _P0; 0 < _M; ++_F1, ++_F2, --_M)
            *_F1 = *_F2;
        return (*this);
    }
    iterator begin()
    {
        _Freeze();
        return (_Ptr);
    }
    const_iterator begin() const
    {
        return (_Ptr);
    }
    iterator end()
    {
        _Freeze();
        return ((iterator)_Psum(_Ptr, _Len));
    }
    const_iterator end() const
    {
        return ((const_iterator)_Psum(_Ptr, _Len));
    }
    reverse_iterator rbegin()
    {
        return (reverse_iterator(end()));
    }
    const_reverse_iterator rbegin() const
    {
        return (const_reverse_iterator(end()));
    }
    reverse_iterator rend()
    {
        return (reverse_iterator(begin()));
    }
    const_reverse_iterator rend() const
    {
        return (const_reverse_iterator(begin()));
    }
    reference at(size_type _P0)
    {
        AssertH (_Len > _P0);
        //if (_Len <= _P0)
        //    _Xran();

        _Freeze();
        return (_Ptr[_P0]);
    }
    const_reference at(size_type _P0) const
    {
        AssertH (_Len > _P0);
        //if (_Len <= _P0)
        //    _Xran();

        return (_Ptr[_P0]);
    }
    reference operator[](size_type _P0)
    {
        if (_Len < _P0 || _Ptr == 0)
            return ((reference)*_Nullstr());

        _Freeze();
        return (_Ptr[_P0]);
    }
    const_reference operator[](size_type _P0) const
    {
        if (_Ptr == 0)
            return (*_Nullstr());
        else
            return (_Ptr[_P0]);
    }
    const _E *c_str() const
    {
        return (_Ptr == 0 ? _Nullstr() : _Ptr);
    }
    const _E *data() const
    {
        return (c_str());
    }
    size_type length() const
    {
        return (_Len);
    }
    size_type size() const
    {
        return (_Len);
    }
    void resize(size_type _N, _E _C)
    {
        _N <= _Len ? erase(_N) : append(_N - _Len, _C);
    }
    void resize(size_type _N)
    {
        _N <= _Len ? erase(_N) : append(_N - _Len, _E(0));
    }
    size_type capacity() const
    {
        return (_Res);
    }
    void reserve(size_type _N = 0)
    {
        if (_Res < _N)
            _Grow(_N);
    }
    bool empty() const
    {
        return (_Len == 0);
    }
    size_type copy(_E *_S, size_type _N, size_type _P0 = 0) const
    {
        AssertH (_Len >= _P0);
        //if (_Len < _P0)
        //    _Xran();

        if (_Len - _P0 < _N)
            _N = _Len - _P0;
        if (0 < _N)
            _Tr::copy(_S, _Ptr + _P0, _N);
        return (_N);
    }
    void swap(_Myt& _X)
    {
        std::swap(_Ptr, _X._Ptr);
        std::swap(_Len, _X._Len);
        std::swap(_Res, _X._Res);
    }
    void swap(_Myt& _X, _Myt& _Y)
    {
        _X.swap(_Y);
    }
    size_type find(const _Myt& _X, size_type _P = 0) const
    {
        return (find(_X.c_str(), _P, _X.size()));
    }
    size_type find(const _E *_S, size_type _P,
                   size_type _N) const
    {
        if (_N == 0 && _P <= _Len)
            return (_P);
        size_type _Nm;
        if (_P < _Len && _N <= (_Nm = _Len - _P))
        {
            const _E *_U, *_V;
            for (_Nm -= _N - 1, _V = _Ptr + _P;
                (_U = _Tr::find(_V, _Nm, *_S)) != 0;
                _Nm -= (size_type)(_U - _V + 1), _V = _U + 1)
                if (_Tr::compare(_U, _S, _N) == 0)
                    return (_U - _Ptr);
        }
        return (npos);
    }
    size_type find(const _E *_S, size_type _P = 0) const
    {
        return (find(_S, _P, _Tr::length(_S)));
    }
    size_type find(_E _C, size_type _P = 0) const
    {
        return (find((const _E *)&_C, _P, 1));
    }
    size_type rfind(const _Myt& _X, size_type _P = npos) const
    {
        return (rfind(_X.c_str(), _P, _X.size()));
    }
    size_type rfind(const _E *_S, size_type _P,
                    size_type _N) const
    {
        if (_N == 0)
            return (_P < _Len ? _P : _Len);
        if (_N <= _Len)
            for (const _E *_U = _Ptr +
                 + (_P < _Len - _N ? _P : _Len - _N); ; --_U)
                if (_Tr::eq(*_U, *_S)
                    && _Tr::compare(_U, _S, _N) == 0)
                    return (_U - _Ptr);
                else if (_U == _Ptr)
                    break;
        return (npos);
    }
    size_type rfind(const _E *_S, size_type _P = npos) const
    {
        return (rfind(_S, _P, _Tr::length(_S)));
    }
    size_type rfind(_E _C, size_type _P = npos) const
    {
        return (rfind((const _E *)&_C, _P, 1));
    }
    size_type find_first_of(const _Myt& _X,
                            size_type _P = 0) const
    {
        return (find_first_of(_X.c_str(), _P, _X.size()));
    }
    size_type find_first_of(const _E *_S, size_type _P,
                            size_type _N) const
    {
        if (0 < _N && _P < _Len)
        {
            const _E *const _V = _Ptr + _Len;
            for (const _E *_U = _Ptr + _P; _U < _V; ++_U)
                if (_Tr::find(_S, _N, *_U) != 0)
                    return (_U - _Ptr);
        }
        return (npos);
    }
    size_type find_first_of(const _E *_S, size_type _P = 0) const
    {
        return (find_first_of(_S, _P, _Tr::length(_S)));
    }
    size_type find_first_of(_E _C, size_type _P = 0) const
    {
        return (find((const _E *)&_C, _P, 1));
    }
    size_type find_last_of(const _Myt& _X,
                           size_type _P = npos) const
    {
        return (find_last_of(_X.c_str(), _P, _X.size()));
    }
    size_type find_last_of(const _E *_S, size_type _P,
                           size_type _N) const
    {
        if (0 < _N && 0 < _Len)
            for (const _E *_U = _Ptr
                 + (_P < _Len ? _P : _Len - 1); ; --_U)
                if (_Tr::find(_S, _N, *_U) != 0)
                    return (_U - _Ptr);
                else if (_U == _Ptr)
                    break;
        return (npos);
    }
    size_type find_last_of(const _E *_S,
                           size_type _P = npos) const
    {
        return (find_last_of(_S, _P, _Tr::length(_S)));
    }
    size_type find_last_of(_E _C, size_type _P = npos) const
    {
        return (rfind((const _E *)&_C, _P, 1));
    }
    size_type find_first_not_of(const _Myt& _X,
                                size_type _P = 0) const
    {
        return (find_first_not_of(_X.c_str(), _P,
                                  _X.size()));
    }
    size_type find_first_not_of(const _E *_S, size_type _P,
                                size_type _N) const
    {
        if (_P < _Len)
        {
            const _E *const _V = _Ptr + _Len;
            for (const _E *_U = _Ptr + _P; _U < _V; ++_U)
                if (_Tr::find(_S, _N, *_U) == 0)
                    return (_U - _Ptr);
        }
        return (npos);
    }
    size_type find_first_not_of(const _E *_S,
                                size_type _P = 0) const
    {
        return (find_first_not_of(_S, _P, _Tr::length(_S)));
    }
    size_type find_first_not_of(_E _C, size_type _P = 0) const
    {
        return (find_first_not_of((const _E *)&_C, _P, 1));
    }
    size_type find_last_not_of(const _Myt& _X,
                               size_type _P = npos) const
    {
        return (find_last_not_of(_X.c_str(), _P, _X.size()));
    }
    size_type find_last_not_of(const _E *_S, size_type _P,
                               size_type _N) const
    {
        if (0 < _Len)
            for (const _E *_U = _Ptr
                 + (_P < _Len ? _P : _Len - 1); ; --_U)
                if (_Tr::find(_S, _N, *_U) == 0)
                    return (_U - _Ptr);
                else if (_U == _Ptr)
                    break;
        return (npos);
    }
    size_type find_last_not_of(const _E *_S,
                               size_type _P = npos) const
    {
        return (find_last_not_of(_S, _P, _Tr::length(_S)));
    }
    size_type find_last_not_of(_E _C, size_type _P = npos) const
    {
        return (find_last_not_of((const _E *)&_C, _P, 1));
    }
    _Myt substr(size_type _P = 0, size_type _M = npos) const
    {
        return (_Myt(*this, _P, _M));
    }
    int compare(const _Myt& _X) const
    {
        return (compare(0, _Len, _X.c_str(), _X.size()));
    }
    int compare(size_type _P0, size_type _N0,
                const _Myt& _X) const
    {
        return (compare(_P0, _N0, _X, 0, npos));
    }
    int compare(size_type _P0, size_type _N0, const _Myt& _X,
                size_type _P, size_type _M) const
    {
        AssertH (_X.size() >= _P);
        //if (_X.size() < _P)
        //    _Xran();

        if (_X._Len - _P < _M)
            _M = _X._Len - _P;
        return (compare(_P0, _N0, _X.c_str() + _P, _M));
    }
    int compare(const _E *_S) const
    {
        return (compare(0, _Len, _S, _Tr::length(_S)));
    }
    int compare(size_type _P0, size_type _N0, const _E *_S) const
    {
        return (compare(_P0, _N0, _S, _Tr::length(_S)));
    }
    int compare(size_type _P0, size_type _N0, const _E *_S,
                size_type _M) const
    {
        AssertH (_Len >= _P0);
        //if (_Len < _P0)
        //    _Xran();

        if (_Len - _P0 < _N0)
            _N0 = _Len - _P0;
        size_type _Ans = _Tr::compare(_Psum(_Ptr, _P0), _S,
                                      _N0 < _M ? _N0 : _M);
        return (_Ans != 0 ? _Ans : _N0 < _M ? -1
                : _N0 == _M ? 0 : +1);
    }
private:
    enum
    {
        // the number of characters that, when multiplied by sizeof(_E) will
        // still fit within the range of size_type.  (We allocate two extra
        // characters -- one for the refcount, the other for the terminator.)
        //
        _MAX_SIZE = (((unsigned int)(-1)) / sizeof(_E)) - 2,

        // _MIN_SIZE seems to be an allocation granularity (in characters).
        // Allocation requests are bit ORed with _MIN_SIZE.
        //
        _MIN_SIZE = 7,
        //_MIN_SIZE = sizeof (_E) <= 32 ? 31 : 7
    };
    void _Copy(size_type _N)
    {
        //AssertSzH (_Len <= _N, "Can't allocate less than we need to copy");
        size_type _Ns = _N | _MIN_SIZE;

        if (_MAX_SIZE < _Ns)
            _Ns = _N;

        size_type _NewLen = (_Ns < _Len) ? _Ns : _Len;

        _E *_S = (_E*) MemAllocRaiseException ((_Ns + 2) * sizeof(_E));

        //_TRY_BEGIN
        //_S = allocator.allocate(_Ns + 2, (void *)0);
        //_CATCH_ALL
        //_Ns = _N;
        //_S = allocator.allocate(_Ns + 2, (void *)0);
        //_CATCH_END

        if (_Len)
        {
            _Tr::copy(_S + 1, _Ptr, _NewLen);
        }

        _Tidy(true);
        _Ptr = _S + 1;
        _Refcnt(_Ptr) = 0;
        _Res = _Ns;
        _Eos(_NewLen);
    }
    void _Eos(size_type _N)
    {
        _Tr::assign(_Ptr[_Len = _N], _E(0));
    }
    void _Freeze()
    {
        if (_Ptr != 0
            && _Refcnt(_Ptr) != 0 && _Refcnt(_Ptr) != _FROZEN)
            _Grow(_Len);
        if (_Ptr != 0)
            _Refcnt(_Ptr) = _FROZEN;
    }
    bool _Grow(size_type _N, bool _Trim = false)
    {
        AssertH (_N < _MAX_SIZE);
        //if (_MAX_SIZE < _N)
        //    _Xlen();

        if (_Ptr != 0 && _Refcnt(_Ptr) != 0 && _Refcnt(_Ptr) != _FROZEN)
        {
            if (_N == 0)
            {
                --_Refcnt(_Ptr), _Tidy();
                return (false);
            }
            else
            {
                _Copy(_N);
                return (true);
            }
        }
        else if (_N == 0)
        {
            if (_Trim)
            {
                _Tidy(true);
            }
            else if (_Ptr != 0)
            {
                _Eos(0);
            }

            return (false);
        }
        else
        {
            if (_Trim && (_N > _Res || _Res > _MIN_SIZE))
            {
                _Tidy(true);
                _Copy(_N);
            }
            else if (!_Trim && (_N > _Res))
            {
                _Copy(_N);
            }

            return (true);
        }
    }
    static const _E * __cdecl _Nullstr()
    {
        static const _E _C = _E(0);
        return (&_C);
    }
    static size_type _Pdif(const_pointer _P2, const_pointer _P1)
    {
        return (_P2 == 0 ? 0 : _P2 - _P1);
    }
    static const_pointer _Psum(const_pointer _P, size_type _N)
    {
        return (_P == 0 ? 0 : _P + _N);
    }
    static pointer _Psum(pointer _P, size_type _N)
    {
        return (_P == 0 ? 0 : _P + _N);
    }
    unsigned short& _Refcnt(const _E *_U)
    {
        return (((unsigned short *)_U)[-1]);
    }
    void _Split()
    {
        if (_Ptr != 0 && _Refcnt(_Ptr) != 0 && _Refcnt(_Ptr) != _FROZEN)
        {
            _E *_Temp = _Ptr;
            _Tidy(true);
            assign(_Temp);
        }
    }
    void _Tidy(bool _Built = false)
    {
        if (!_Built || _Ptr == 0)
        {
            ;
        }
        else if (_Refcnt(_Ptr) == 0 || _Refcnt(_Ptr) == _FROZEN)
        {
            MemFree(_Ptr - 1);
            //allocator.deallocate(_Ptr - 1, _Res + 2);
        }
        else
        {
            --_Refcnt(_Ptr);
        }
        _Ptr = 0, _Len = 0, _Res = 0;
    }
    _E *_Ptr;
    size_type _Len, _Res;
};



inline
CWideString __cdecl operator+(
    const CWideString& _L,
    const CWideString& _R)
{return (CWideString(_L) += _R); }

inline
CWideString __cdecl operator+(
    const CWideString::_E *_L,
    const CWideString& _R)
{return (CWideString(_L) += _R); }

inline
CWideString __cdecl operator+(
    const CWideString::_E _L,
    const CWideString& _R)
{return (CWideString(1, _L) += _R); }

inline
CWideString __cdecl operator+(
    const CWideString& _L,
    const CWideString::_E *_R)
{return (CWideString(_L) += _R); }

inline
CWideString __cdecl operator+(
    const CWideString& _L,
    const CWideString::_E _R)
{return (CWideString(_L) += _R); }

inline
bool __cdecl operator==(
    const CWideString& _L,
    const CWideString& _R)
{return (_L.compare(_R) == 0); }

inline
bool __cdecl operator==(
    const CWideString::_E * _L,
    const CWideString& _R)
{return (_R.compare(_L) == 0); }

inline
bool __cdecl operator==(
    const CWideString& _L,
    const CWideString::_E *_R)
{return (_L.compare(_R) == 0); }

inline
bool __cdecl operator!=(
    const CWideString& _L,
    const CWideString& _R)
{return (!(_L == _R)); }

inline
bool __cdecl operator!=(
    const CWideString::_E *_L,
    const CWideString& _R)
{return (!(_L == _R)); }

inline
bool __cdecl operator!=(
    const CWideString& _L,
    const CWideString::_E *_R)
{return (!(_L == _R)); }

inline
bool __cdecl operator<(
    const CWideString& _L,
    const CWideString& _R)
{return (_L.compare(_R) < 0); }

inline
bool __cdecl operator<(
    const CWideString::_E * _L,
    const CWideString& _R)
{return (_R.compare(_L) > 0); }

inline
bool __cdecl operator<(
    const CWideString& _L,
    const CWideString::_E *_R)
{return (_L.compare(_R) < 0); }

inline
bool __cdecl operator>(
    const CWideString& _L,
    const CWideString& _R)
{return (_R < _L); }

inline
bool __cdecl operator>(
    const CWideString::_E * _L,
    const CWideString& _R)
{return (_R < _L); }

inline
bool __cdecl operator>(
    const CWideString& _L,
    const CWideString::_E *_R)
{return (_R < _L); }

inline
bool __cdecl operator<=(
    const CWideString& _L,
    const CWideString& _R)
{return (!(_R < _L)); }

inline
bool __cdecl operator<=(
    const CWideString::_E * _L,
    const CWideString& _R)
{return (!(_R < _L)); }

inline
bool __cdecl operator<=(
    const CWideString& _L,
    const CWideString::_E *_R)
{return (!(_R < _L)); }

inline
bool __cdecl operator>=(
    const CWideString& _L,
    const CWideString& _R)
{return (!(_L < _R)); }

inline
bool __cdecl operator>=(
    const CWideString::_E * _L,
    const CWideString& _R)
{return (!(_L < _R)); }

inline
bool __cdecl operator>=(
    const CWideString& _L,
    const CWideString::_E *_R)
{return (!(_L < _R)); }

#endif // _NCSTLSTR_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\rasdiag\private\stlexcep.h ===
/***
*exception - Defines class exception and related functions
*
*   Copyright (c) 1994-1997, Microsoft Corporation. All rights reserved.
*   Modified January 1996 by P.J. Plauger
*
*Purpose:
*       Defines class exception (and derived class bad_exception)
*       plus new and unexpected handler functions.
*
*       [Public]
*
****/

#ifndef _STLEXCEP_H_
#define _STLEXCEP_H_
//#include <xstddef>
//#include <eh.h>

#include <stlxstdd.h>

#ifdef  _MSC_VER
#pragma pack(push,8)
#endif  /* _MSC_VER */

#if !defined(_WIN32) && !defined(_MAC)
#error ERROR: Only Mac or Win32 targets supported!
#endif

/*
#ifndef _CRTIMP
#ifdef  _NTSDK
// definition compatible with NT SDK
#define _CRTIMP
#else   // ndef _NTSDK
// current definition
#ifdef  _DLL
#define _CRTIMP __declspec(dllimport)
#else   // ndef _DLL
#define _CRTIMP
#endif  // _DLL
#endif  // _NTSDK
#endif  // _CRTIMP
*/

typedef const char *__exString;

class /*_CRTIMP*/ exception
{
public:
    exception();
    exception(const __exString&);
    exception(const exception&);
    exception& operator= (const exception&);
    virtual ~exception();
    virtual __exString what() const;
private:
    __exString _m_what;
    int _m_doFree;
};

_STD_BEGIN
using ::exception;

// CLASS bad_exception
class /*_CRTIMP*/ bad_exception : public exception
{
public:
    bad_exception(const char *_S = "bad exception") _THROW0()
    : exception(_S)
    {
    }
    virtual ~bad_exception() _THROW0()
    {
    }
protected:
    virtual void _Doraise() const
    {
        _RAISE(*this);
    }
};

/*_CRTIMP*/
bool __cdecl uncaught_exception();

_STD_END

#ifdef __RTTI_OLDNAMES
typedef exception xmsg;        // A synonym for folks using older standard
#endif

#ifdef  _MSC_VER
#pragma pack(pop)
#endif  /* _MSC_VER */

#endif /* _STLEXCEP_H_ */

/*
 * 1994-1995, Microsoft Corporation. All rights reserved.
 * Modified January 1996 by P.J. Plauger
 * Consult your license regarding permissions and restrictions.
 */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\rasdiag\private\stldeque.h ===
#pragma once
#ifndef _STLDEQUE_H_
#define _STLDEQUE_H_
//#include <cstddef>
//#include <functional>
//#include <iterator>
//#include <memory>
//#include <stdexcept>
//#include <xutility>

#include <stlxstdd.h>
#include <stlfunc.h>
#include <stliter.h>
#include <stlmem.h>
#include <stlxutil.h>

#ifdef  _MSC_VER
#pragma pack(push,8)
#endif  /* _MSC_VER */

_STD_BEGIN
#define _DEQUEMAPSIZ	2
#define _DEQUESIZ (4096 < sizeof (_Ty) ? 1 : 4096 / sizeof (_Ty))
		// TEMPLATE CLASS deque
template<class _Ty, class _A = allocator<_Ty> >
	class deque {
public:
	typedef deque<_Ty, _A> _Myt;
	typedef _A allocator_type;
	typedef _A::size_type size_type;
	typedef _A::difference_type difference_type;
	typedef _A::pointer _Tptr;
	typedef _A::const_pointer _Ctptr;
	typedef _POINTER_X(_Tptr, _A) _Mapptr;
	typedef _A::reference reference;
	typedef _A::const_reference const_reference;
	typedef _A::value_type value_type;
		// CLASS const_iterator
	class iterator;
	class const_iterator : public _Ranit<_Ty, difference_type> {
	public:
		friend class deque<_Ty, _A>;
		const_iterator()
			: _First(0), _Last(0), _Next(0), _Map(0) {}
		const_iterator(_Tptr _P, _Mapptr _M)
			: _First(*_M), _Last(*_M + _DEQUESIZ),
				_Next(_P), _Map(_M) {}
		const_iterator(const iterator& _X)
			: _First(_X._First), _Last(_X._Last), _Next(_X._Next), 
			  _Map(_X._Map) {}
		const_reference operator*() const
			{return (*_Next); }
		_Ctptr operator->() const
			{return (&**this); }
		const_iterator& operator++()
			{if (++_Next == _Last)
				{_First = *++_Map;
				_Last = _First + _DEQUESIZ;
				_Next = _First; }
			return (*this); }
		const_iterator operator++(int)
			{const_iterator _Tmp = *this;
			++*this;
			return (_Tmp); }
		const_iterator& operator--()
			{if (_Next == _First)
				{_First = *--_Map;
				_Last = _First + _DEQUESIZ;
				_Next = _Last; }
			--_Next;
			return (*this); }
		const_iterator operator--(int)
			{const_iterator _Tmp = *this;
			--*this;
			return (_Tmp); }
		const_iterator& operator+=(difference_type _N)
			{_Add(_N);
			return (*this); }
		const_iterator& operator-=(difference_type _N)
			{return (*this += -_N); }
		const_iterator operator+(difference_type _N) const
			{const_iterator _Tmp = *this;
			return (_Tmp += _N); }
		const_iterator operator-(difference_type _N) const
			{const_iterator _Tmp = *this;
			return (_Tmp -= _N); }
		difference_type operator-(const const_iterator& _X) const
			{return (_Map == _X._Map ? _Next - _X._Next
				: _DEQUESIZ * (_Map - _X._Map - 1)
				+ (_Next - _First) + (_X._Last - _X._Next)); }
		const_reference operator[](difference_type _N) const
			{return (*(*this + _N)); }
		bool operator==(const const_iterator& _X) const
			{return (_Next == _X._Next); }
		bool operator!=(const const_iterator& _X) const
			{return (!(*this == _X)); }
		bool operator<(const const_iterator& _X) const
			{return (_Map < _X._Map
				|| _Map == _X._Map && _Next < _X._Next); }
		bool operator<=(const const_iterator& _X) const
			{return (!(_X < *this)); }
		bool operator>(const const_iterator& _X) const
			{return (_X < *this); }
		bool operator>=(const const_iterator& _X) const
			{return (!(*this < _X)); }
	protected:
		void _Add(difference_type _N)
			{difference_type _Off = _N + _Next - _First;
			difference_type _Moff = (0 <= _Off)
				? _Off / _DEQUESIZ
				: -((_DEQUESIZ - 1 - _Off) / _DEQUESIZ);
			if (_Moff == 0)
				_Next += _N;
			else
				{_Map += _Moff;
				_First = *_Map;
				_Last = _First + _DEQUESIZ;
				_Next = _First + (_Off - _Moff * _DEQUESIZ); }}
	_PROTECTED:
		_Tptr _First, _Last, _Next;
		_Mapptr _Map;
		};
		// CLASS iterator
	class iterator : public const_iterator {
	public:
		iterator()
			{}
		iterator(_Tptr _P, _Mapptr _M)
			: const_iterator(_P, _M) {}
		reference operator*() const
			{return (*_Next); }
		_Tptr operator->() const
			{return (&**this); }
		iterator& operator++()
			{if (++_Next == _Last)
				{_First = *++_Map;
				_Last = _First + _DEQUESIZ;
				_Next = _First; }
			return (*this); }
		iterator operator++(int)
			{iterator _Tmp = *this;
			++*this;
			return (_Tmp); }
		iterator& operator--()
			{if (_Next == _First)
				{_First = *--_Map;
				_Last = _First + _DEQUESIZ;
				_Next = _Last; }
			--_Next;
			return (*this); }
		iterator operator--(int)
			{iterator _Tmp = *this;
			--*this;
			return (_Tmp); }
		iterator& operator+=(difference_type _N)
			{_Add(_N);
			return (*this); }
		iterator& operator-=(difference_type _N)
			{return (*this += -_N); }
		iterator operator+(difference_type _N) const
			{iterator _Tmp = *this;
			return (_Tmp += _N); }
		iterator operator-(difference_type _N) const
			{iterator _Tmp = *this;
			return (_Tmp -= _N); }
		difference_type operator-(const iterator& _X) const
			{return (_Map == _X._Map ? _Next - _X._Next
				: _DEQUESIZ * (_Map - _X._Map - 1)
				+ (_Next - _First) + (_X._Last - _X._Next)); }
		reference operator[](difference_type _N) const
			{return (*(*this + _N)); }
		bool operator==(const iterator& _X) const
			{return (_Next == _X._Next); }
		bool operator!=(const iterator& _X) const
			{return (!(*this == _X)); }
		bool operator<(const iterator& _X) const
			{return (_Map < _X._Map
				|| _Map == _X._Map && _Next < _X._Next); }
		bool operator<=(const iterator& _X) const
			{return (!(_X < *this)); }
		bool operator>(const iterator& _X) const
			{return (_X < *this); }
		bool operator>=(const iterator& _X) const
			{return (!(*this < _X)); }
		};
	typedef reverse_iterator<const_iterator, value_type,
		const_reference, _Ctptr, difference_type>
			const_reverse_iterator;
	typedef reverse_iterator<iterator, value_type,
		reference, _Tptr, difference_type>
			reverse_iterator;
	explicit deque(const _A& _Al = _A())
		: allocator(_Al),
			_First(), _Last(), _Map(0), _Mapsize(0), _Size(0)
		{}
	explicit deque(size_type _N, const _Ty& _V = _Ty(),
		const _A& _Al = _A())
		: allocator(_Al),
			_First(), _Last(), _Map(0), _Mapsize(0), _Size(0)
		{insert(begin(), _N, _V); }
	deque(const _Myt& _X)
		: allocator(_X.allocator),
			_First(), _Last(), _Map(0), _Mapsize(0), _Size(0)
		{copy(_X.begin(), _X.end(), back_inserter(*this)); }
	typedef const_iterator _It;
		deque(_It _F, _It _L, const _A& _Al = _A())
		: allocator(_Al),
			_First(), _Last(), _Map(0), _Mapsize(0), _Size(0)
		{copy(_F, _L, back_inserter(*this)); }
	~deque()
		{while (!empty())
			pop_front(); }
	_Myt& operator=(const _Myt& _X)
		{if (this != &_X)
			{iterator _S;
			if (_X.size() <= size())
				{_S = copy(_X.begin(), _X.end(), begin());
				erase(_S, end()); }
			else
				{const_iterator _Sx = _X.begin() + size();
				_S = copy(_X.begin(), _Sx, begin());
				copy(_Sx, _X.end(), inserter(*this, _S)); }}
		return (*this); }
	iterator begin()
		{return (_First); }
	const_iterator begin() const
		{return ((const_iterator)_First); }
	iterator end()
		{return (_Last); }
	const_iterator end() const
		{return ((const_iterator)_Last); }
	reverse_iterator rbegin()
		{return (reverse_iterator(end())); }
	const_reverse_iterator rbegin() const
		{return (const_reverse_iterator(end())); }
	reverse_iterator rend()
		{return (reverse_iterator(begin())); }
	const_reverse_iterator rend() const
		{return (const_reverse_iterator(begin())); }
	void resize(size_type _N, _Ty _X = _Ty())
		{if (size() < _N)
			insert(end(), _N - size(), _X);
		else if (_N < size())
			erase(begin() + _N, end()); }
	size_type size() const
		{return (_Size); }
	size_type max_size() const
		{return (allocator.max_size()); }
	bool empty() const
		{return (size() == 0); }
	_A get_allocator() const
		{return (allocator); }
	const_reference at(size_type _P) const
		{if (size() <= _P)
			_Xran();
		return (*(begin() + _P)); }
	reference at(size_type _P)
		{if (size() <= _P)
			_Xran();
		return (*(begin() + _P)); }
	const_reference operator[](size_type _P) const
		{return (*(begin() + _P)); }
	reference operator[](size_type _P)
		{return (*(begin() + _P)); }
	reference front()
		{return (*begin()); }
	const_reference front() const
		{return (*begin()); }
	reference back()
		{return (*(end() - 1)); }
	const_reference back() const
		{return (*(end() - 1)); }
	void push_front(const _Ty& _X)
		{if (empty() || _First._Next == _First._First)
			_Buyfront();
		allocator.construct(--_First._Next, _X);
		++_Size; }
	void pop_front()
		{allocator.destroy(_First._Next++);
		--_Size;
		if (empty() || _First._Next == _First._Last)
			_Freefront(); }
	void push_back(const _Ty& _X)
		{
		if (empty() || (_Last._Next == _Last._Last))
        {
            _Buyback();
            allocator.construct(_Last._Next++, _X);
        }
        else if (_Last._Next + 1 == _Last._Last)
        {
            allocator.construct(_Last._Next++, _X);
            _Buyback();
        }
        else
            allocator.construct(_Last._Next++, _X);
        ++_Size; }
	void pop_back()
		{
        if (_Last._Next == _Last._First)
			_Freeback();
		if (!empty())
			allocator.destroy(--_Last._Next);
		--_Size;
		if (empty())
			_Freeback(); }
	void assign(_It _F, _It _L)
		{erase(begin(), end());
		insert(begin(), _F, _L); }
	void assign(size_type _N, const _Ty& _X = _Ty())
		{erase(begin(), end());
		insert(begin(), _N, _X); }
	iterator insert(iterator _P, const _Ty& _X = _Ty())
		{if (_P == begin())
			{push_front(_X);
			return (begin()); }
		else if (_P == end())
			{push_back(_X);
			return (end() - 1); }
		else
			{iterator _S;
			size_type _Off = _P - begin();
			if (_Off < size() / 2)
				{push_front(front());
				_S = begin() + _Off;
				copy(begin() + 2, _S + 1, begin() + 1); }
			else
				{push_back(back());
				_S = begin() + _Off;
				copy_backward(_S, end() - 2, end() - 1); }
			*_S = _X;
			return (_S); }}
	void insert(iterator _P, size_type _M, const _Ty& _X)
		{iterator _S;
		size_type _I;
		size_type _Off = _P - begin();
		size_type _Rem = _Size - _Off;
		if (_Off < _Rem)
			if (_Off < _M)
				{for (_I = _M - _Off; 0 < _I; --_I)
					push_front(_X);
				for (_I = _Off; 0 < _I; --_I)
					push_front(begin()[_M - 1]);
				_S = begin() + _M;
				fill(_S, _S + _Off, _X); }
			else
				{for (_I = _M; 0 < _I; --_I)
					push_front(begin()[_M - 1]);
				_S = begin() + _M;
				copy(_S + _M, _S + _Off, _S);
				fill(begin() + _Off, _S + _Off, _X); }
		else
			if (_Rem < _M)
				{for (_I = _M - _Rem; 0 < _I; --_I)
					push_back(_X);
				for (_I = 0; _I < _Rem; ++_I)
					push_back(begin()[_Off + _I]);
				_S = begin() + _Off;
				fill(_S, _S + _Rem, _X); }
			else
				{for (_I = 0; _I < _M; ++_I)
					push_back(begin()[_Off + _Rem - _M + _I]);
				_S = begin() + _Off;
				copy_backward(_S, _S + _Rem - _M, _S + _Rem);
				fill(_S, _S + _M, _X); }}
	void insert(iterator _P, _It _F, _It _L)
		{size_type _M = 0;
		_Distance(_F, _L, _M);
		size_type _I;
		size_type _Off = _P - begin();
		size_type _Rem = _Size - _Off;
		if (_Off < _Rem)
			if (_Off < _M)
				{_It _Qx = _F;
				advance(_Qx, _M - _Off);
				for (_It _Q = _Qx; _F != _Q; )
					push_front(*--_Q);
				for (_I = _Off; 0 < _I; --_I)
					push_front(begin()[_M - 1]);
				copy(_Qx, _L, begin() + _M); }
			else
				{for (_I = _M; 0 < _I; --_I)
					push_front(begin()[_M - 1]);
				iterator _S = begin() + _M;
				copy(_S + _M, _S + _Off, _S);
				copy(_F, _L, begin() + _Off); }
		else
			if (_Rem < _M)
				{_It _Qx = _F;
				advance(_Qx, _Rem);
				for (_It _Q = _Qx; _Q != _L; ++_Q)
					push_back(*_Q);
				for (_I = 0; _I < _Rem; ++_I)
					push_back(begin()[_Off + _I]);
				copy(_F, _Qx, begin() + _Off); }
			else
				{for (_I = 0; _I < _M; ++_I)
					push_back(begin()[_Off + _Rem - _M + _I]);
				iterator _S = begin() + _Off;
				copy_backward(_S, _S + _Rem - _M, _S + _Rem);
				copy(_F, _L, _S); }}
	iterator erase(iterator _P)
		{return (erase(_P, _P + 1)); }
	iterator erase(iterator _F, iterator _L)
		{size_type _N = _L - _F;
		size_type _M = _F - begin();
		if (_M < end() - _L)
			{copy_backward(begin(), _F, _L);
			for (; 0 < _N; --_N)
				pop_front(); }
		else
			{copy(_L, end(), _F);
			for (; 0 < _N; --_N)
				pop_back(); }
		return (_M == 0 ? begin() : begin() + _M); }
	void clear()
		{erase(begin(), end()); }
	void swap(_Myt& _X)
		{if (allocator == _X.allocator)
			{std::swap(_First, _X._First);
			std::swap(_Last, _X._Last);
			std::swap(_Map, _X._Map);
			std::swap(_Mapsize, _X._Mapsize);
			std::swap(_Size, _X._Size); }
		else
			{_Myt _Ts = *this; *this = _X, _X = _Ts; }}
	friend void swap(_Myt& _X, _Myt& _Y)
		{_X.swap(_Y); }
protected:
	void _Buyback()
		{_Tptr _P = allocator.allocate(_DEQUESIZ, (void *)0);
		if (empty())
			{_Mapsize = _DEQUEMAPSIZ;
			size_type _N = _Mapsize / 2;
			_Getmap();
			_Setptr(_Map + _N, _P);
			_First = iterator(_P + _DEQUESIZ / 2, _Map + _N);
			_Last = _First; }
		else if (_Last._Map < _Map + (_Mapsize - 1))
			{_Setptr(++_Last._Map, _P);
			_Last = iterator(_P, _Last._Map); }
		else
			{difference_type _I = _Last._Map - _First._Map + 1;
			_Mapptr _M = _Growmap(2 * _I);
			_Setptr(_M + _I, _P);
			_First = iterator(_First._Next, _M);
			_Last = iterator(_P, _M + _I); }}
	void _Buyfront()
		{_Tptr _P = allocator.allocate(_DEQUESIZ, (void *)0);
		if (empty())
			{_Mapsize = _DEQUEMAPSIZ;
			size_type _N = _Mapsize / 2;
			_Getmap();
			_Setptr(_Map + _N, _P);
			_First = iterator(_P + (_DEQUESIZ / 2 + 1),
				_Map + _N);
			_Last = _First; }
		else if (_Map < _First._Map)
			{_Setptr(--_First._Map, _P);
			_First = iterator(_P + _DEQUESIZ, _First._Map); }
		else if (_Last._Map == _First._Map)
			{_Setptr(_Last._Map++, *_First._Map);
			_Setptr(_First._Map+1, *_First._Map);
			_Setptr(_First._Map, _P);
			_First = iterator(_P + _DEQUESIZ, _First._Map); }
		else
			{difference_type _I = _Last._Map - _First._Map + 1;
			_Mapptr _M = _Growmap(2 * _I);
			_Setptr(--_M, _P);
			_First = iterator(_P + _DEQUESIZ, _M);
			_Last = iterator(_Last._Next, _M + _I); }}
	void _Freeback()
		{_Freeptr(_Last._Map--);
		if (empty())
			{if (_First._Map == _Last._Map)
                _Freeptr(_First._Map);
			_First = iterator();
			_Last = _First;
			_Freemap(); }
		else
			_Last = iterator(*_Last._Map + _DEQUESIZ,
				_Last._Map); }
	void _Freefront()
		{_Freeptr(_First._Map++);
		if (empty())
			{_First = iterator();
			_Last = _First;
			_Freemap(); }
		else
			_First = iterator(*_First._Map, _First._Map); }
	void _Xran() const
		{_THROW(out_of_range, "invalid deque<T> subscript"); }
	void _Freemap()
		{allocator.deallocate(_Map, _Mapsize); }
	void _Freeptr(_Mapptr _M)
		{allocator.deallocate(*_M, _DEQUESIZ); }
	void _Getmap()
		{_Map = (_Mapptr)allocator._Charalloc(
			_Mapsize * sizeof (_Tptr)); }
	_Mapptr _Growmap(size_type _Newsize)
		{_Mapptr _M = (_Mapptr)allocator._Charalloc(
			_Newsize * sizeof (_Tptr));
		copy(_First._Map, _Last._Map + 1,
			_M + _Newsize / 4);
		allocator.deallocate(_Map, _Mapsize);
		_Map = _M;
		_Mapsize = _Newsize;
		return (_M + _Newsize / 4); }
	void _Setptr(_Mapptr _M, _Tptr _P)
		{*_M = _P; }
	_A allocator;
	iterator _First, _Last;
	_Mapptr _Map;
	size_type _Mapsize, _Size;
	};
		// deque TEMPLATE OPERATORS
template<class _Ty, class _A> inline
	bool operator==(const deque<_Ty, _A>& _X,
		const deque<_Ty, _A>& _Y)
	{return (_X.size() == _Y.size()
		&& equal(_X.begin(), _X.end(), _Y.begin())); }
template<class _Ty, class _A> inline
	bool operator!=(const deque<_Ty, _A>& _X,
		const deque<_Ty, _A>& _Y)
	{return (!(_X == _Y)); }
template<class _Ty, class _A> inline
	bool operator<(const deque<_Ty, _A>& _X,
		const deque<_Ty, _A>& _Y)
	{return (lexicographical_compare(_X.begin(), _X.end(),
		_Y.begin(), _Y.end())); }
template<class _Ty, class _A> inline
	bool operator<=(const deque<_Ty, _A>& _X,
		const deque<_Ty, _A>& _Y)
	{return (!(_Y < _X)); }
template<class _Ty, class _A> inline
	bool operator>(const deque<_Ty, _A>& _X,
		const deque<_Ty, _A>& _Y)
	{return (_Y < _X); }
template<class _Ty, class _A> inline
	bool operator>=(const deque<_Ty, _A>& _X,
		const deque<_Ty, _A>& _Y)
	{return (!(_X < _Y)); }
_STD_END
#ifdef  _MSC_VER
#pragma pack(pop)
#endif  /* _MSC_VER */

#endif /* _DEQUE_ */

/*
 * Copyright (c) 1995 by P.J. Plauger.  ALL RIGHTS RESERVED. 
 * Consult your license regarding permissions and restrictions.
 */

/*
 * This file is derived from software bearing the following
 * restrictions:
 *
 * Copyright (c) 1994
 * Hewlett-Packard Company
 *
 * Permission to use, copy, modify, distribute and sell this
 * software and its documentation for any purpose is hereby
 * granted without fee, provided that the above copyright notice
 * appear in all copies and that both that copyright notice and
 * this permission notice appear in supporting documentation.
 * Hewlett-Packard Company makes no representations about the
 * suitability of this software for any purpose. It is provided
 * "as is" without express or implied warranty.
 */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\rasdiag\private\stliter.h ===
#pragma once
#ifndef _STLITER_H_
#define _STLITER_H_
//#include <utility>

#include <stlutil.h>

#ifdef  _MSC_VER
#pragma pack(push,8)
#endif  /* _MSC_VER */

_STD_BEGIN

// TEMPLATE CLASS reverse_bidirectional_iterator
template<class _BI, class _Ty, class _Rt = _Ty&,
class _Pt = _Ty *, class _D = ptrdiff_t>
class reverse_bidirectional_iterator : public _Bidit<_Ty, _D>
{
public:
    typedef reverse_bidirectional_iterator<_BI,
    _Ty, _Rt, _Pt, _D> _Myt;
    typedef _BI iter_type;
    typedef _Rt reference_type;
    typedef _Pt pointer_type;
    reverse_bidirectional_iterator()
    {
    }
    explicit reverse_bidirectional_iterator(_BI _X) : current(_X)
    {
    }
    _BI base() const
    {
        return (current);
    }
    _Rt operator*() const
    {
        _BI _Tmp = current;
        return (*--_Tmp);
    }
    _Pt operator->() const
    {
        return (&**this);
    }
    _Myt& operator++()
    {
        --current;
        return (*this);
    }
    _Myt operator++(int)
    {
        _Myt _Tmp = *this;
        --current;
        return (_Tmp);
    }
    _Myt& operator--()
    {
        ++current;
        return (*this);
    }
    _Myt operator--(int)
    {
        _Myt _Tmp = *this;
        ++current;
        return (_Tmp);
    }
protected:
    _BI current;
};
template<class _BI, class _Ty, class _Rt, class _Pt,
class _D> inline
bool operator==(const reverse_bidirectional_iterator<_BI,
                _Ty, _Rt, _Pt, _D>& _X,
                const reverse_bidirectional_iterator<_BI,
                _Ty, _Rt, _Pt, _D>& _Y)
{
    return (_X.base() == _Y.base());
}
template<class _BI, class _Ty, class _Rt, class _Pt, class _D> inline
bool operator!=(const reverse_bidirectional_iterator<_BI,
                _Ty, _Rt, _Pt, _D>& _X,
                const reverse_bidirectional_iterator<_BI,
                _Ty, _Rt, _Pt, _D>& _Y)
{
    return (!(_X == _Y));
}

// TEMPLATE CLASS back_insert_iterator
template<class _C>
class back_insert_iterator : public iterator<output_iterator_tag, void, void>
{
public:
    typedef _C container_type;
    typedef _C::value_type value_type;
    explicit back_insert_iterator(_C& _X) : container(_X)
    {
    }
    back_insert_iterator<_C>& operator=(const value_type& _V)
    {
        container.push_back(_V);
        return (*this);
    }
    back_insert_iterator<_C>& operator*()
    {
        return (*this);
    }
    back_insert_iterator<_C>& operator++()
    {
        return (*this);
    }
    back_insert_iterator<_C> operator++(int)
    {
        return (*this);
    }protected:
    _C& container;
};
template<class _C> inline
back_insert_iterator<_C> back_inserter(_C& _X)
{
    return (back_insert_iterator<_C>(_X));
}

// TEMPLATE CLASS front_insert_iterator
template<class _C>
class front_insert_iterator : public iterator<output_iterator_tag, void, void>
{
public:
    typedef _C container_type;
    typedef _C::value_type value_type;
    explicit front_insert_iterator(_C& _X) : container(_X)
    {
    }
    front_insert_iterator<_C>& operator=(
                                        const value_type& _V)
    {
        container.push_front(_V);
        return (*this);
    }
    front_insert_iterator<_C>& operator*()
    {
        return (*this);
    }
    front_insert_iterator<_C>& operator++()
    {
        return (*this);
    }
    front_insert_iterator<_C> operator++(int)
    {
        return (*this);
    }
protected:
    _C& container;
};

template<class _C> inline
front_insert_iterator<_C> front_inserter(_C& _X)
{
    return (front_insert_iterator<_C>(_X));
}

// TEMPLATE CLASS insert_iterator
template<class _C>
class insert_iterator : public iterator<output_iterator_tag, void, void>
{
public:
    typedef _C container_type;
    typedef _C::value_type value_type;
    insert_iterator(_C& _X, _C::iterator _I) : container(_X), iter(_I)
    {
    }
    insert_iterator<_C>& operator=(
                                  const value_type& _V)
    {
        iter = container.insert(iter, _V);
        ++iter;
        return (*this);
    }
    insert_iterator<_C>& operator*()
    {
        return (*this);
    }
    insert_iterator<_C>& operator++()
    {
        return (*this);
    }
    insert_iterator<_C>& operator++(int)
    {
        return (*this);
    }
protected:
    _C& container;
    _C::iterator iter;
};

template<class _C, class _XI> inline
insert_iterator<_C> inserter(_C& _X, _XI _I)
{
    return (insert_iterator<_C>(_X, _C::iterator(_I)));
}

/*
// TEMPLATE CLASS istream_iterator
template<class _U, class _E = char, class _Tr = char_traits<_E> >
class istream_iterator : public iterator<input_iterator_tag, _U, ptrdiff_t>
{
public:
    typedef _E char_type;
    typedef _Tr traits_type;
    typedef basic_istream<_E, _Tr> istream_type;
    istream_iterator() : _Istr(0)
    {
    }
    istream_iterator(istream_type& _I) : _Istr(&_I)
    {
        _Getval();
    }
    const _U& operator*() const
    {
        return (_Val);
    }
    const _U *operator->() const
    {
        return (&**this);
    }
    istream_iterator<_U, _E, _Tr>& operator++()
    {
        _Getval();
        return (*this);
    }
    istream_iterator<_U, _E, _Tr> operator++(int)
    {
        istream_iterator<_U, _E, _Tr> _Tmp = *this;
        _Getval();
        return (_Tmp);
    }
    bool _Equal(const istream_iterator<_U, _E, _Tr>& _X) const
    {
        return (_Istr == _X._Istr);
    }
protected:
    void _Getval()
    {
        if (_Istr != 0 && !(*_Istr >> _Val))
            _Istr = 0;
    }
    istream_type *_Istr;
    _U _Val;
};
template<class _U, class _E, class _Tr> inline
bool operator==(const istream_iterator<_U, _E, _Tr>& _X,
                const istream_iterator<_U, _E, _Tr>& _Y)
{
    return (_X._Equal(_Y));
}
template<class _U, class _E, class _Tr> inline
bool operator!=(const istream_iterator<_U, _E, _Tr>& _X,
                const istream_iterator<_U, _E, _Tr>& _Y)
{
    return (!(_X == _Y));
}
// TEMPLATE CLASS ostream_iterator
template<class _U, class _E = char,
class _Tr = char_traits<_E> >
class ostream_iterator : public iterator<output_iterator_tag, void, void>
{
public:
    typedef _U value_type;
    typedef _E char_type;
    typedef _Tr traits_type;
    typedef basic_ostream<_E, _Tr> ostream_type;
    ostream_iterator(ostream_type& _O,
                     const _E *_D = 0) : _Ostr(&_O), _Delim(_D)
    {
    }
    ostream_iterator<_U, _E, _Tr>& operator=(const _U& _X)
    {
        *_Ostr << _X;
        if (_Delim != 0)
            *_Ostr << _Delim;
        return (*this);
    }
    ostream_iterator<_U, _E, _Tr>& operator*()
    {
        return (*this);
    }
    ostream_iterator<_U, _E, _Tr>& operator++()
    {
        return (*this);
    }
    ostream_iterator<_U, _E, _Tr> operator++(int)
    {
        return (*this);
    }
protected:
    const _E *_Delim;
    ostream_type *_Ostr;
};
*/

// TEMPLATE FUNCTION _Val_type
template<class _C, class _Ty, class _D> inline
_Ty *_Val_type(const iterator<_C, _Ty, _D>&)
{
    return ((_Ty *)0);
}
template<class _Ty> inline
_Ty *_Val_type(const _Ty *)
{
    return ((_Ty *)0);
}
// TEMPLATE FUNCTION advance
template<class _II, class _D> inline
void advance(_II& _I, _D _N)
{
    _Advance(_I, _N, _Iter_cat(_I));
}
template<class _II, class _D> inline
void _Advance(_II& _I, _D _N, input_iterator_tag)
{
    for (; 0 < _N; --_N)
        ++_I;
}
template<class _FI, class _D> inline
void _Advance(_FI& _I, _D _N, forward_iterator_tag)
{
    for (; 0 < _N; --_N)
        ++_I;
}
template<class _BI, class _D> inline
void _Advance(_BI& _I, _D _N, bidirectional_iterator_tag)
{
    for (; 0 < _N; --_N)
        ++_I;
    for (; _N < 0; ++_N)
        --_I;
}
template<class _RI, class _D> inline
void _Advance(_RI& _I, _D _N, random_access_iterator_tag)
{
    _I += _N;
}
// TEMPLATE FUNCTION _Dist_type
template<class _C, class _Ty, class _D> inline
_D *_Dist_type(const iterator<_C, _Ty, _D>&)
{
    return ((_D *)0);
}
template<class _Ty> inline
ptrdiff_t *_Dist_type(const _Ty *)
{
    return ((ptrdiff_t *)0);
}

_STD_END

#ifdef  _MSC_VER
#pragma pack(pop)
#endif  /* _MSC_VER */

#endif /* _STLITER_H_ */

/*
 * Copyright (c) 1995 by P.J. Plauger.  ALL RIGHTS RESERVED.
 * Consult your license regarding permissions and restrictions.
 */

/*
 * This file is derived from software bearing the following
 * restrictions:
 *
 * Copyright (c) 1994
 * Hewlett-Packard Company
 *
 * Permission to use, copy, modify, distribute and sell this
 * software and its documentation for any purpose is hereby
 * granted without fee, provided that the above copyright notice
 * appear in all copies and that both that copyright notice and
 * this permission notice appear in supporting documentation.
 * Hewlett-Packard Company makes no representations about the
 * suitability of this software for any purpose. It is provided
 * "as is" without express or implied warranty.
 */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\rasdiag\private\stllist.h ===
#pragma once
#ifndef _STLLIST_H_
#define _STLLIST_H_
//#include <cstddef>
//#include <functional>
//#include <iterator>
//#include <memory>
//#include <stdexcept>
//#include <xutility>

#include <stlxstdd.h>
#include <stlfunc.h>
#include <stliter.h>
#include <stlmem.h>
#include <stlxutil.h>

#ifdef  _MSC_VER
#pragma pack(push,8)
#endif  /* _MSC_VER */

_STD_BEGIN

// TEMPLATE CLASS list
template<class _Ty, class _A = allocator<_Ty> >
class list
{
protected:
    typedef _POINTER_X(void, _A) _Genptr;
    struct _Node;
    friend struct _Node;
    struct _Node
    {
        _Genptr _Next, _Prev;
        _Ty _Value;
    };
    typedef _POINTER_X(_Node, _A) _Nodeptr;
    struct _Acc;
    friend struct _Acc;
    struct _Acc
    {
        typedef _REFERENCE_X(_Nodeptr, _A) _Nodepref;
        typedef _A::reference _Vref;
        static _Nodepref _Next(_Nodeptr _P)
        {
            return ((_Nodepref)(*_P)._Next);
        }
        static _Nodepref _Prev(_Nodeptr _P)
        {
            return ((_Nodepref)(*_P)._Prev);
        }
        static _Vref _Value(_Nodeptr _P)
        {
            return ((_Vref)(*_P)._Value);
        }
    };
public:
    typedef list<_Ty, _A> _Myt;
    typedef _A allocator_type;
    typedef _A::size_type size_type;
    typedef _A::difference_type difference_type;
    typedef _A::pointer _Tptr;
    typedef _A::const_pointer _Ctptr;
    typedef _A::reference reference;
    typedef _A::const_reference const_reference;
    typedef _A::value_type value_type;
    // CLASS iterator
    class iterator;
    friend class iterator;
    class iterator : public _Bidit<_Ty, difference_type>
    {
    public:
        iterator()
        {

        }
        iterator(_Nodeptr _P)
        : _Ptr(_P)
        {

        }
        reference operator*() const
        {
            return (_Acc::_Value(_Ptr));
        }
        _Tptr operator->() const
        {
            return (&**this);
        }
        iterator& operator++()
        {
            _Ptr = _Acc::_Next(_Ptr);
            return (*this);
        }
        iterator operator++(int)
        {
            iterator _Tmp = *this;
            ++*this;
            return (_Tmp);
        }
        iterator& operator--()
        {
            _Ptr = _Acc::_Prev(_Ptr);
            return (*this);
        }
        iterator operator--(int)
        {
            iterator _Tmp = *this;
            --*this;
            return (_Tmp);
        }
        bool operator==(const iterator& _X) const
        {
            return (_Ptr == _X._Ptr);
        }
        bool operator!=(const iterator& _X) const
        {
            return (!(*this == _X));
        }
        _Nodeptr _Mynode() const
        {
            return (_Ptr);
        }
    protected:
        _Nodeptr _Ptr;
    };
    // CLASS const_iterator
    class const_iterator;
    friend class const_iterator;
    class const_iterator : public iterator
    {
    public:
        const_iterator()
        {

        }
        const_iterator(_Nodeptr _P)
        : iterator(_P)
        {

        }
        const_iterator(const iterator& _X)
        : iterator(_X)
        {

        }
        const_reference operator*() const
        {
            return (_Acc::_Value(_Ptr));
        }
        _Ctptr operator->() const
        {
            return (&**this);
        }
        const_iterator& operator++()
        {
            _Ptr = _Acc::_Next(_Ptr);
            return (*this);
        }
        const_iterator operator++(int)
        {
            iterator _Tmp = *this;
            ++*this;
            return (_Tmp);
        }
        const_iterator& operator--()
        {
            _Ptr = _Acc::_Prev(_Ptr);
            return (*this);
        }
        const_iterator operator--(int)
        {
            iterator _Tmp = *this;
            --*this;
            return (_Tmp);
        }
        bool operator==(const const_iterator& _X) const
        {
            return (_Ptr == _X._Ptr);
        }
        bool operator!=(const const_iterator& _X) const
        {
            return (!(*this == _X));
        }
    };
    typedef reverse_bidirectional_iterator<iterator,
    value_type, reference, _Tptr, difference_type>
    reverse_iterator;
    typedef reverse_bidirectional_iterator<const_iterator,
    value_type, const_reference, _Ctptr, difference_type>
    const_reverse_iterator;
    explicit list(const _A& _Al = _A())
    : allocator(_Al),
    _Head(_Buynode()), _Size(0)
    {

    }
    explicit list(size_type _N, const _Ty& _V = _Ty(),
                  const _A& _Al = _A())
    : allocator(_Al),
    _Head(_Buynode()), _Size(0)
    {
        insert(begin(), _N, _V);
    }
    list(const _Myt& _X)
    : allocator(_X.allocator),
    _Head(_Buynode()), _Size(0)
    {
        insert(begin(), _X.begin(), _X.end());
    }
    typedef const_iterator _It;
    list(_It _F, _It _L, const _A& _Al = _A())
    : allocator(_Al),
    _Head(_Buynode()), _Size(0)
    {
        insert(begin(), _F, _L);
    }
    ~list()
    {
        erase(begin(), end());
        _Freenode(_Head);
        _Head = 0, _Size = 0;
    }
    _Myt& operator=(const _Myt& _X)
    {
        if (this != &_X)
        {
            iterator _F1 = begin();
            iterator _L1 = end();
            const_iterator _F2 = _X.begin();
            const_iterator _L2 = _X.end();
            for (; _F1 != _L1 && _F2 != _L2; ++_F1, ++_F2)
                *_F1 = *_F2;
            erase(_F1, _L1);
            insert(_L1, _F2, _L2);
        }
        return (*this);
    }
    iterator begin()
    {
        return (iterator(_Acc::_Next(_Head)));
    }
    const_iterator begin() const
    {
        return (const_iterator(_Acc::_Next(_Head)));
    }
    iterator end()
    {
        return (iterator(_Head));
    }
    const_iterator end() const
    {
        return (const_iterator(_Head));
    }
    reverse_iterator rbegin()
    {
        return (reverse_iterator(end()));
    }
    const_reverse_iterator rbegin() const
    {
        return (const_reverse_iterator(end()));
    }
    reverse_iterator rend()
    {
        return (reverse_iterator(begin()));
    }
    const_reverse_iterator rend() const
    {
        return (const_reverse_iterator(begin()));
    }
    void resize(size_type _N, _Ty _X = _Ty())
    {
        if (size() < _N)
            insert(end(), _N - size(), _X);
        else
            while (_N < size())
                pop_back();
    }
    size_type size() const
    {
        return (_Size);
    }
    size_type max_size() const
    {
        return (allocator.max_size());
    }
    bool empty() const
    {
        return (size() == 0);
    }
    _A get_allocator() const
    {
        return (allocator);
    }
    reference front()
    {
        return (*begin());
    }
    const_reference front() const
    {
        return (*begin());
    }
    reference back()
    {
        return (*(--end()));
    }
    const_reference back() const
    {
        return (*(--end()));
    }
    void push_front(const _Ty& _X)
    {
        insert(begin(), _X);
    }
    void pop_front()
    {
        erase(begin());
    }
    void push_back(const _Ty& _X)
    {
        insert(end(), _X);
    }
    void pop_back()
    {
        erase(--end());
    }
    void assign(_It _F, _It _L)
    {
        erase(begin(), end());
        insert(begin(), _F, _L);
    }
    void assign(size_type _N, const _Ty& _X = _Ty())
    {
        erase(begin(), end());
        insert(begin(), _N, _X);
    }
    iterator insert(iterator _P, const _Ty& _X = _Ty())
    {
        _Nodeptr _S = _P._Mynode();
        _Acc::_Prev(_S) = _Buynode(_S, _Acc::_Prev(_S));
        _S = _Acc::_Prev(_S);
        _Acc::_Next(_Acc::_Prev(_S)) = _S;
        allocator.construct(&_Acc::_Value(_S), _X);
        ++_Size;
        return (iterator(_S));
    }
    void insert(iterator _P, size_type _M, const _Ty& _X)
    {
        for (; 0 < _M; --_M)
            insert(_P, _X);
    }
    void insert(iterator _P, const _Ty *_F, const _Ty *_L)
    {
        for (; _F != _L; ++_F)
            insert(_P, *_F);
    }
    void insert(iterator _P, _It _F, _It _L)
    {
        for (; _F != _L; ++_F)
            insert(_P, *_F);
    }
    iterator erase(iterator _P)
    {
        _Nodeptr _S = (_P++)._Mynode();
        _Acc::_Next(_Acc::_Prev(_S)) = _Acc::_Next(_S);
        _Acc::_Prev(_Acc::_Next(_S)) = _Acc::_Prev(_S);
        allocator.destroy(&_Acc::_Value(_S));
        _Freenode(_S);
        --_Size;
        return (_P);
    }
    iterator erase(iterator _F, iterator _L)
    {
        while (_F != _L)
            erase(_F++);
        return (_F);
    }
    void clear()
    {
        erase(begin(), end());
    }
    void swap(_Myt& _X)
    {
        if (allocator == _X.allocator)
        {
            std::swap(_Head, _X._Head);
            std::swap(_Size, _X._Size);
        }
        else
        {
            iterator _P = begin();
            splice(_P, _X);
            _X.splice(_X.begin(), *this, _P, end());
        }
    }
    friend void swap(_Myt& _X, _Myt& _Y)
    {
        _X.swap(_Y);
    }
    void splice(iterator _P, _Myt& _X)
    {
        if (!_X.empty())
        {
            _Splice(_P, _X, _X.begin(), _X.end());
            _Size += _X._Size;
            _X._Size = 0;
        }
    }
    void splice(iterator _P, _Myt& _X, iterator _F)
    {
        iterator _L = _F;
        if (_P != _F && _P != ++_L)
        {
            _Splice(_P, _X, _F, _L);
            ++_Size;
            --_X._Size;
        }
    }
    void splice(iterator _P, _Myt& _X, iterator _F, iterator _L)
    {
        if (_F != _L)
        {
            if (&_X != this)
            {
                size_type _N = 0;
                _Distance(_F, _L, _N);
                _Size += _N;
                _X._Size -= _N;
            }
            _Splice(_P, _X, _F, _L);
        }
    }
    void remove(const _Ty& _V)
    {
        iterator _L = end();
        for (iterator _F = begin(); _F != _L; )
            if (*_F == _V)
                erase(_F++);
            else
                ++_F;
    }
    typedef binder2nd<not_equal_to<_Ty> > _Pr1;
    void remove_if(_Pr1 _Pr)
    {
        iterator _L = end();
        for (iterator _F = begin(); _F != _L; )
            if (_Pr(*_F))
                erase(_F++);
            else
                ++_F;
    }
    void unique()
    {
        iterator _F = begin(), _L = end();
        if (_F != _L)
            for (iterator _M = _F; ++_M != _L; _M = _F)
                if (*_F == *_M)
                    erase(_M);
                else
                    _F = _M;
    }
    typedef not_equal_to<_Ty> _Pr2;
    void unique(_Pr2 _Pr)
    {
        iterator _F = begin(), _L = end();
        if (_F != _L)
            for (iterator _M = _F; ++_M != _L; _M = _F)
                if (_Pr(*_F, *_M))
                    erase(_M);
                else
                    _F = _M;
    }
    void merge(_Myt& _X)
    {
        if (&_X != this)
        {
            iterator _F1 = begin(), _L1 = end();
            iterator _F2 = _X.begin(), _L2 = _X.end();
            while (_F1 != _L1 && _F2 != _L2)
                if (*_F2 < *_F1)
                {
                    iterator _Mid2 = _F2;
                    _Splice(_F1, _X, _F2, ++_Mid2);
                    _F2 = _Mid2;
                }
                else
                    ++_F1;
            if (_F2 != _L2)
                _Splice(_L1, _X, _F2, _L2);
            _Size += _X._Size;
            _X._Size = 0;
        }
    }
    typedef greater<_Ty> _Pr3;
    void merge(_Myt& _X, _Pr3 _Pr)
    {
        if (&_X != this)
        {
            iterator _F1 = begin(), _L1 = end();
            iterator _F2 = _X.begin(), _L2 = _X.end();
            while (_F1 != _L1 && _F2 != _L2)
                if (_Pr(*_F2, *_F1))
                {
                    iterator _Mid2 = _F2;
                    _Splice(_F1, _X, _F2, ++_Mid2);
                    _F2 = _Mid2;
                }
                else
                    ++_F1;
            if (_F2 != _L2)
                _Splice(_L1, _X, _F2, _L2);
            _Size += _X._Size;
            _X._Size = 0;
        }
    }
    void sort()
    {
        if (2 <= size())
        {
            const size_t _MAXN = 15;
            _Myt _X(allocator), _A[_MAXN + 1];
            size_t _N = 0;
            while (!empty())
            {
                _X.splice(_X.begin(), *this, begin());
                size_t _I;
                for (_I = 0; _I < _N && !_A[_I].empty(); ++_I)
                {
                    _A[_I].merge(_X);
                    _A[_I].swap(_X);
                }
                if (_I == _MAXN)
                    _A[_I].merge(_X);
                else
                {
                    _A[_I].swap(_X);
                    if (_I == _N)
                        ++_N;
                }
            }
            while (0 < _N)
                merge(_A[--_N]);
        }
    }
    void sort(_Pr3 _Pr)
    {
        if (2 <= size())
        {
            const size_t _MAXN = 15;
            _Myt _X(allocator), _A[_MAXN + 1];
            size_t _N = 0;
            while (!empty())
            {
                _X.splice(_X.begin(), *this, begin());
                size_t _I;
                for (_I = 0; _I < _N && !_A[_I].empty(); ++_I)
                {
                    _A[_I].merge(_X, _Pr);
                    _A[_I].swap(_X);
                }
                if (_I == _MAXN)
                    _A[_I].merge(_X, _Pr);
                else
                {
                    _A[_I].swap(_X);
                    if (_I == _N)
                        ++_N;
                }
            }
            while (0 < _N)
                merge(_A[--_N], _Pr);
        }
    }
    void reverse()
    {
        if (2 <= size())
        {
            iterator _L = end();
            for (iterator _F = ++begin(); _F != _L; )
            {
                iterator _M = _F;
                _Splice(begin(), *this, _M, ++_F);
            }
        }
    }
protected:
    _Nodeptr _Buynode(_Nodeptr _Narg = 0, _Nodeptr _Parg = 0)
    {
        _Nodeptr _S = (_Nodeptr)allocator._Charalloc(
                                                    1 * sizeof (_Node));
        _Acc::_Next(_S) = _Narg != 0 ? _Narg : _S;
        _Acc::_Prev(_S) = _Parg != 0 ? _Parg : _S;
        return (_S);
    }
    void _Freenode(_Nodeptr _S)
    {
        allocator.deallocate(_S, 1);
    }
    void _Splice(iterator _P, _Myt& _X, iterator _F, iterator _L)
    {
        if (allocator == _X.allocator)
        {
            _Acc::_Next(_Acc::_Prev(_L._Mynode())) =
            _P._Mynode();
            _Acc::_Next(_Acc::_Prev(_F._Mynode())) =
            _L._Mynode();
            _Acc::_Next(_Acc::_Prev(_P._Mynode())) =
            _F._Mynode();
            _Nodeptr _S = _Acc::_Prev(_P._Mynode());
            _Acc::_Prev(_P._Mynode()) =
            _Acc::_Prev(_L._Mynode());
            _Acc::_Prev(_L._Mynode()) =
            _Acc::_Prev(_F._Mynode());
            _Acc::_Prev(_F._Mynode()) = _S;
        }
        else
        {
            insert(_P, _F, _L);
            _X.erase(_F, _L);
        }
    }
    void _Xran() const
    {
        _THROW(out_of_range, "invalid list<T> subscript");
    }
    _A allocator;
    _Nodeptr _Head;
    size_type _Size;
};

// list TEMPLATE OPERATORS
template<class _Ty, class _A> inline
bool operator==(const list<_Ty, _A>& _X,
                const list<_Ty, _A>& _Y)
{
    return (_X.size() == _Y.size()
            && equal(_X.begin(), _X.end(), _Y.begin()));
}
template<class _Ty, class _A> inline
bool operator!=(const list<_Ty, _A>& _X,
                const list<_Ty, _A>& _Y)
{
    return (!(_X == _Y));
}
template<class _Ty, class _A> inline
bool operator<(const list<_Ty, _A>& _X,
               const list<_Ty, _A>& _Y)
{
    return (lexicographical_compare(_X.begin(), _X.end(),
                                    _Y.begin(), _Y.end()));
}
template<class _Ty, class _A> inline
bool operator>(const list<_Ty, _A>& _X,
               const list<_Ty, _A>& _Y)
{
    return (_Y < _X);
}
template<class _Ty, class _A> inline
bool operator<=(const list<_Ty, _A>& _X,
                const list<_Ty, _A>& _Y)
{
    return (!(_Y < _X));
}
template<class _Ty, class _A> inline
bool operator>=(const list<_Ty, _A>& _X,
                const list<_Ty, _A>& _Y)
{
    return (!(_X < _Y));
}

_STD_END

#ifdef  _MSC_VER
#pragma pack(pop)
#endif  /* _MSC_VER */

#endif /* _STLLIST_H_ */

/*
 * Copyright (c) 1995 by P.J. Plauger.  ALL RIGHTS RESERVED.
 * Consult your license regarding permissions and restrictions.
 */

/*
 * This file is derived from software bearing the following
 * restrictions:
 *
 * Copyright (c) 1994
 * Hewlett-Packard Company
 *
 * Permission to use, copy, modify, distribute and sell this
 * software and its documentation for any purpose is hereby
 * granted without fee, provided that the above copyright notice
 * appear in all copies and that both that copyright notice and
 * this permission notice appear in supporting documentation.
 * Hewlett-Packard Company makes no representations about the
 * suitability of this software for any purpose. It is provided
 * "as is" without express or implied warranty.
 */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\rasdiag\private\stlvec.h ===
#pragma once
#ifndef _STLVEC_H_
#define _STLVEC_H_
//#include <climits>
//#include <memory>
//#include <stdexcept>

#include <limits.h>
#include <stlmem.h>
#include <stlxutil.h>

#ifdef  _MSC_VER
#pragma pack(push,8)
#endif  /* _MSC_VER */

_STD_BEGIN

// TEMPLATE CLASS vector
template<class _Ty, class _A = allocator<_Ty> >
class vector
{
public:
    typedef vector<_Ty, _A>     _Myt;
    typedef _A                  allocator_type;
    typedef _A::size_type       size_type;
    typedef _A::difference_type difference_type;
    typedef _A::pointer         _Tptr;
    typedef _A::const_pointer   _Ctptr;
    typedef _A::reference       reference;
    typedef _A::const_reference const_reference;
    typedef _A::value_type      value_type;
    typedef _Tptr               iterator;
    typedef _Ctptr              const_iterator;
    typedef reverse_iterator<const_iterator, value_type, const_reference,
                                _Ctptr, difference_type>
                const_reverse_iterator;

    typedef reverse_iterator<iterator, value_type,reference, _Tptr,
                                difference_type>
                reverse_iterator;

    explicit vector(const _A& _Al = _A())
    : allocator(_Al), _First(0), _Last(0), _End(0)
    {

    }
    explicit vector(size_type _N, const _Ty& _V = _Ty(),
                    const _A& _Al = _A())
    : allocator(_Al)
    {
        _First = allocator.allocate(_N, (void *)0);
        _Ufill(_First, _N, _V);
        _Last = _First + _N;
        _End = _Last;
    }
    vector(const _Myt& _X)
    : allocator(_X.allocator)
    {
        _First = allocator.allocate(_X.size(), (void *)0);
        _Last = _Ucopy(_X.begin(), _X.end(), _First);
        _End = _Last;
    }
    typedef const_iterator _It;
    vector(_It _F, _It _L, const _A& _Al = _A())
    : allocator(_Al), _First(0), _Last(0), _End(0)
    {
        insert(begin(), _F, _L);
    }
    ~vector()
    {
        _Destroy(_First, _Last);
        allocator.deallocate(_First, _End - _First);
        _First = 0, _Last = 0, _End = 0;
    }
    _Myt& operator=(const _Myt& _X)
    {
        if (this == &_X)
            ;
        else if (_X.size() <= size())
        {
            iterator _S = copy(_X.begin(), _X.end(), _First);
            _Destroy(_S, _Last);
            _Last = _First + _X.size();
        }
        else if (_X.size() <= capacity())
        {
            const_iterator _S = _X.begin() + size();
            copy(_X.begin(), _S, _First);
            _Ucopy(_S, _X.end(), _Last);
            _Last = _First + _X.size();
        }
        else
        {
            _Destroy(_First, _Last);
            allocator.deallocate(_First, _End - _First);
            _First = allocator.allocate(_X.size(), (void *)0);
            _Last = _Ucopy(_X.begin(), _X.end(),
                           _First);
            _End = _Last;
        }
        return (*this);
    }
    void reserve(size_type _N)
    {
        if (capacity() < _N)
        {
            iterator _S = allocator.allocate(_N, (void *)0);
            _Ucopy(_First, _Last, _S);
            _Destroy(_First, _Last);
            allocator.deallocate(_First, _End - _First);
            _End = _S + _N;
            _Last = _S + size();
            _First = _S;
        }
    }
    size_type capacity() const
    {
        return (_First == 0 ? 0 : _End - _First);
    }
    iterator begin()
    {
        return (_First);
    }
    const_iterator begin() const
    {
        return ((const_iterator)_First);
    }
    iterator end()
    {
        return (_Last);
    }
    const_iterator end() const
    {
        return ((const_iterator)_Last);
    }
    reverse_iterator rbegin()
    {
        return (reverse_iterator(end()));
    }
    const_reverse_iterator rbegin() const
    {
        return (const_reverse_iterator(end()));
    }
    reverse_iterator rend()
    {
        return (reverse_iterator(begin()));
    }
    const_reverse_iterator rend() const
    {
        return (const_reverse_iterator(begin()));
    }
    void resize(size_type _N, const _Ty& _X = _Ty())
    {
        if (size() < _N)
            insert(end(), _N - size(), _X);
        else if (_N < size())
            erase(begin() + _N, end());
    }
    size_type size() const
    {
        return (_First == 0 ? 0 : _Last - _First);
    }
    size_type max_size() const
    {
        return (allocator.max_size());
    }
    bool empty() const
    {
        return (size() == 0);
    }
    _A get_allocator() const
    {
        return (allocator);
    }
    const_reference at(size_type _P) const
    {
        ASSERT (_P < size());
        return (*(begin() + _P));
    }
    reference at(size_type _P)
    {
        ASSERT (_P < size());
        return (*(begin() + _P));
    }
    const_reference operator[](size_type _P) const
    {
        return (*(begin() + _P));
    }
    reference operator[](size_type _P)
    {
        return (*(begin() + _P));
    }
    reference front()
    {
        return (*begin());
    }
    const_reference front() const
    {
        return (*begin());
    }
    reference back()
    {
        return (*(end() - 1));
    }
    const_reference back() const
    {
        return (*(end() - 1));
    }
    void push_back(const _Ty& _X)
    {
        insert(end(), _X);
    }
    void pop_back()
    {
        erase(end() - 1);
    }
    void assign(_It _F, _It _L)
    {
        erase(begin(), end());
        insert(begin(), _F, _L);
    }
    void assign(size_type _N, const _Ty& _X = _Ty())
    {
        erase(begin(), end());
        insert(begin(), _N, _X);
    }
    iterator insert(iterator _P, const _Ty& _X = _Ty())
    {
        size_type _O = _P - begin();
        insert(_P, 1, _X);
        return (begin() + _O);
    }
    void insert(iterator _P, size_type _M, const _Ty& _X)
    {
        if ((size_type)(_End - _Last) < _M)
        {
            size_type _N = size() + (_M < size() ? size() : _M);
            iterator _S = allocator.allocate(_N, (void *)0);
            iterator _Q = _Ucopy(_First, _P, _S);
            _Ufill(_Q, _M, _X);
            _Ucopy(_P, _Last, _Q + _M);
            _Destroy(_First, _Last);
            allocator.deallocate(_First, _End - _First);
            _End = _S + _N;
            _Last = _S + size() + _M;
            _First = _S;
        }
        else if ((size_type)(_Last - _P) < _M)
        {
            _Ucopy(_P, _Last, _P + _M);
            _Ufill(_Last, _M - (_Last - _P), _X);
            fill(_P, _Last, _X);
            _Last += _M;
        }
        else if (0 < _M)
        {
            _Ucopy(_Last - _M, _Last, _Last);
            copy_backward(_P, _Last - _M, _Last);
            fill(_P, _P + _M, _X);
            _Last += _M;
        }
    }
    void insert(iterator _P, _It _F, _It _L)
    {
        difference_type _M = 0;
        _Distance(_F, _L, _M);
        if (_End - _Last < _M)
        {
            size_type _N = size() + (_M < (difference_type)size() ? size() : _M);
            iterator _S = allocator.allocate(_N, (void *)0);
            iterator _Q = _Ucopy(_First, _P, _S);
            _Q = _Ucopy(_F, _L, _Q);
            _Ucopy(_P, _Last, _Q);
            _Destroy(_First, _Last);
            allocator.deallocate(_First, _End - _First);
            _End = _S + _N;
            _Last = _S + size() + _M;
            _First = _S;
        }
        else if (_Last - _P < _M)
        {
            _Ucopy(_P, _Last, _P + _M);
            _Ucopy(_F + (_Last - _P), _L, _Last);
            copy(_F, _F + (_Last - _P), _P);
            _Last += _M;
        }
        else if (0 < _M)
        {
            _Ucopy(_Last - _M, _Last, _Last);
            copy_backward(_P, _Last - _M, _Last);
            copy(_F, _L, _P);
            _Last += _M;
        }
    }
    iterator erase(iterator _P)
    {
        copy(_P + 1, end(), _P);
        _Destroy(_Last - 1, _Last);
        --_Last;
        return (_P);
    }
    iterator erase(iterator _F, iterator _L)
    {
        iterator _S = copy(_L, end(), _F);
        _Destroy(_S, end());
        _Last = _S;
        return (_F);
    }
    void clear()
    {
        erase(begin(), end());
    }
/*
    bool operator==(const _Myt& _X) const
    {
        return (size() == _X.size()
                && equal(begin(), end(), _X.begin()));
    }
    bool operator!=(const _Myt& _X) const
    {
        return (!(*this == _X));
    }
    bool operator<(const _Myt& _X) const
    {
        return (lexicographical_compare(begin(), end(),
                                        _X.begin(), _X.end()));
    }
    bool operator>(const _Myt& _X) const
    {
        return (_X < *this);
    }
    bool operator<=(const _Myt& _X) const
    {
        return (!(_X < *this));
    }
    bool operator>=(const _Myt& _X) const
    {
        return (!(*this < _X));
    }
*/
    void swap(_Myt& _X)
    {
        if (allocator == _X.allocator)
        {
            std::swap(_First, _X._First);
            std::swap(_Last, _X._Last);
            std::swap(_End, _X._End);
        }
        else
        {
            _Myt _Ts = *this; *this = _X, _X = _Ts;
        }
    }
    friend void swap(_Myt& _X, _Myt& _Y)
    {
        _X.swap(_Y);
    }
protected:
    void _Destroy(iterator _F, iterator _L)
    {
        for (; _F != _L; ++_F)
            allocator.destroy(_F);
    }
    iterator _Ucopy(const_iterator _F, const_iterator _L,
                    iterator _P)
    {
        for (; _F != _L; ++_P, ++_F)
            allocator.construct(_P, *_F);
        return (_P);
    }
    void _Ufill(iterator _F, size_type _N, const _Ty &_X)
    {
        for (; 0 < _N; --_N, ++_F)
            allocator.construct(_F, _X);
    }
    _A allocator;
    iterator _First, _Last, _End;
};

/*
// CLASS vector<_Bool, allocator>
typedef unsigned int _Vbase;
const int _VBITS = CHAR_BIT * sizeof (_Vbase);
typedef allocator<_Vbase> _Bool_allocator;
class vector<_Bool, _Bool_allocator>
{
public:
    typedef _Bool_allocator _A;
    typedef _Bool _Ty;
    typedef vector<_Ty, _A> _Myt;
    typedef vector<_Vbase, _A> _Vbtype;
    typedef _A allocator_type;
    typedef _A::size_type size_type;
    typedef _A::difference_type difference_type;
    // CLASS reference
    class reference
    {
    public:
        reference()
        : _Mask(0), _Ptr(0)
        {

        }
        reference(size_t _O, _Vbase *_P)
        : _Mask((_Vbase)1 << _O), _Ptr(_P)
        {

        }
        reference& operator=(const reference& _X)
        {
            return (*this = bool(_X));
        }
        reference& operator=(bool _V)
        {
            if (_V)
                *_Ptr |= _Mask;
            else
                *_Ptr &= ~_Mask;
            return (*this);
        }
        void flip()
        {
            *_Ptr ^= _Mask;
        }
        bool operator~() const
        {
            return (!bool(*this));
        }
        operator bool() const
        {
            return ((*_Ptr & _Mask) != 0);
        }
    protected:
        _Vbase _Mask, *_Ptr;
    };
    typedef const reference const_reference;
    typedef bool value_type;
    // CLASS iterator
    class iterator : public _Ranit<_Bool, difference_type>
    {
    public:
        iterator()
        : _Off(0), _Ptr(0)
        {

        }
        iterator(size_t _O, _Vbase *_P)
        : _Off(_O), _Ptr(_P)
        {

        }
        reference operator*() const
        {
            return (reference(_Off, _Ptr));
        }
        iterator& operator++()
        {
            _Inc();
            return (*this);
        }
        iterator operator++(int)
        {
            iterator _Tmp = *this;
            _Inc();
            return (_Tmp);
        }
        iterator& operator--()
        {
            _Dec();
            return (*this);
        }
        iterator operator--(int)
        {
            iterator _Tmp = *this;
            _Dec();
            return (_Tmp);
        }
        iterator& operator+=(difference_type _N)
        {
            _Off += (size_t)_N;
            _Ptr += _Off / _VBITS;
            _Off %= _VBITS;
            return (*this);
        }
        iterator& operator-=(difference_type _N)
        {
            return (*this += -_N);
        }
        iterator operator+(difference_type _N) const
        {
            iterator _Tmp = *this;
            return (_Tmp += _N);
        }
        iterator operator-(difference_type _N) const
        {
            iterator _Tmp = *this;
            return (_Tmp -= _N);
        }
        difference_type operator-(const iterator _X) const
        {
            return (_VBITS * (_Ptr - _X._Ptr)
                    + (difference_type)_Off
                    - (difference_type)_X._Off);
        }
        reference operator[](difference_type _N) const
        {
            return (*(*this + _N));
        }
        bool operator==(const iterator& _X) const
        {
            return (_Ptr == _X._Ptr && _Off == _X._Off);
        }
        bool operator!=(const iterator& _X) const
        {
            return (!(*this == _X));
        }
        bool operator<(const iterator& _X) const
        {
            return (_Ptr < _X._Ptr
                    || _Ptr == _X._Ptr && _Off < _X._Off);
        }
        bool operator>(const iterator& _X) const
        {
            return (_X < *this);
        }
        bool operator<=(const iterator& _X) const
        {
            return (!(_X < *this));
        }
        bool operator>=(const iterator& _X) const
        {
            return (!(*this < _X));
        }
    protected:
        void _Dec()
        {
            if (_Off != 0)
                --_Off;
            else
                _Off = _VBITS - 1, --_Ptr;
        }
        void _Inc()
        {
            if (_Off < _VBITS - 1)
                ++_Off;
            else
                _Off = 0, ++_Ptr;
        }
        size_t _Off;
        _Vbase *_Ptr;
    };
    // CLASS const_iterator
    class const_iterator : public iterator
    {
    public:
        const_iterator()
        : iterator()
        {

        }
        const_iterator(size_t _O, const _Vbase *_P)
        : iterator(_O, (_Vbase *)_P)
        {

        }
        const_iterator(const iterator& _X)
        : iterator(_X)
        {

        }
        const_reference operator*() const
        {
            return (reference(_Off, _Ptr));
        }
        const_iterator& operator++()
        {
            _Inc();
            return (*this);
        }
        const_iterator operator++(int)
        {
            const_iterator _Tmp = *this;
            _Inc();
            return (_Tmp);
        }
        const_iterator& operator--()
        {
            _Dec();
            return (*this);
        }
        const_iterator operator--(int)
        {
            const_iterator _Tmp = *this;
            _Dec();
            return (_Tmp);
        }
        const_iterator& operator+=(difference_type _N)
        {
            _Off += (size_t)_N;
            _Ptr += _Off / _VBITS;
            _Off %= _VBITS;
            return (*this);
        }
        const_iterator& operator-=(difference_type _N)
        {
            return (*this += -_N);
        }
        const_iterator operator+(difference_type _N) const
        {
            const_iterator _Tmp = *this;
            return (_Tmp += _N);
        }
        const_iterator operator-(difference_type _N) const
        {
            const_iterator _Tmp = *this;
            return (_Tmp -= _N);
        }
        difference_type operator-(const const_iterator _X) const
        {
            return (_VBITS * (_Ptr - _X._Ptr)
                    + (difference_type)_Off
                    - (difference_type)_X._Off);
        }
        const_reference operator[](difference_type _N) const
        {
            return (*(*this + _N));
        }
        bool operator==(const const_iterator& _X) const
        {
            return (_Ptr == _X._Ptr && _Off == _X._Off);
        }
        bool operator!=(const const_iterator& _X) const
        {
            return (!(*this == _X));
        }
        bool operator<(const const_iterator& _X) const
        {
            return (_Ptr < _X._Ptr
                    || _Ptr == _X._Ptr && _Off < _X._Off);
        }
        bool operator>(const const_iterator& _X) const
        {
            return (_X < *this);
        }
        bool operator<=(const const_iterator& _X) const
        {
            return (!(_X < *this));
        }
        bool operator>=(const const_iterator& _X) const
        {
            return (!(*this < _X));
        }
    };
    typedef reverse_iterator<const_iterator, value_type,
    const_reference, const_reference *, difference_type>
    const_reverse_iterator;
    typedef reverse_iterator<iterator, value_type,
    reference, reference *, difference_type>
    reverse_iterator;
    explicit vector(const _A& _Al = _A())
    : _Size(0), _Vec(_Al)
    {

    }
    explicit vector(size_type _N, const bool _V = false,
                    const _A& _Al = _A())
    : _Vec(_Nw(_N), _V ? -1 : 0, _Al)
    {
        _Trim(_N);
    }
    typedef const_iterator _It;
    vector(_It _F, _It _L, const _A& _Al = _A())
    : _Size(0), _Vec(_Al)
    {
        insert(begin(), _F, _L);
    }
    ~vector()
    {
        _Size = 0;
    }
    void reserve(size_type _N)
    {
        _Vec.reserve(_Nw(_N));
    }
    size_type capacity() const
    {
        return (_Vec.capacity() * _VBITS);
    }
    iterator begin()
    {
        return (iterator(0, _Vec.begin()));
    }
    const_iterator begin() const
    {
        return (const_iterator(0, _Vec.begin()));
    }
    iterator end()
    {
        iterator _Tmp = begin();
        if (0 < _Size)
            _Tmp += _Size;
        return (_Tmp);
    }
    const_iterator end() const
    {
        const_iterator _Tmp = begin();
        if (0 < _Size)
            _Tmp += _Size;
        return (_Tmp);
    }
    reverse_iterator rbegin()
    {
        return (reverse_iterator(end()));
    }
    const_reverse_iterator rbegin() const
    {
        return (const_reverse_iterator(end()));
    }
    reverse_iterator rend()
    {
        return (reverse_iterator(begin()));
    }
    const_reverse_iterator rend() const
    {
        return (const_reverse_iterator(begin()));
    }
    void resize(size_type _N, bool _X = false)
    {
        if (size() < _N)
            insert(end(), _N - size(), _X);
        else if (_N < size())
            erase(begin() + _N, end());
    }
    size_type size() const
    {
        return (_Size);
    }
    size_type max_size() const
    {
        return (_Vec.max_size() * _VBITS);
    }
    bool empty() const
    {
        return (size() == 0);
    }
    _A get_allocator() const
    {
        return (_Vec.get_allocator());
    }
    const_reference at(size_type _P) const
    {
        if (size() <= _P)
            _Xran();
        return (*(begin() + _P));
    }
    reference at(size_type _P)
    {
        if (size() <= _P)
            _Xran();
        return (*(begin() + _P));
    }
    const_reference operator[](size_type _P) const
    {
        return (*(begin() + _P));
    }
    reference operator[](size_type _P)
    {
        return (*(begin() + _P));
    }
    reference front()
    {
        return (*begin());
    }
    const_reference front() const
    {
        return (*begin());
    }
    reference back()
    {
        return (*(end() - 1));
    }
    const_reference back() const
    {
        return (*(end() - 1));
    }
    void push_back(const bool _X)
    {
        insert(end(), _X);
    }
    void pop_back()
    {
        erase(end() - 1);
    }
    void assign(_It _F, _It _L)
    {
        erase(begin(), end());
        insert(begin(), _F, _L);
    }
    void assign(size_type _N, const bool _X = false)
    {
        erase(begin(), end());
        insert(begin(), _N, _X);
    }
    iterator insert(iterator _P, const bool _X = false)
    {
        size_type _O = _P - begin();
        insert(_P, 1, _X);
        return (begin() + _O);
    }
    void insert(iterator _P, size_type _M, const bool _X)
    {
        if (0 < _M)
        {
            if (capacity() - size() < _M)
            {
                size_type _O = _P - begin();
                _Vec.resize(_Nw(size() + _M), 0);
                _P = begin() + _O;
            }
            copy_backward(_P, end(), end() + _M);
            fill(_P, _P + _M, _X);
            _Size += _M;
        }
    }
    void insert(iterator _P, _It _F, _It _L)
    {
        size_type _M = 0;
        _Distance(_F, _L, _M);
        if (0 < _M)
        {
            if (capacity() - size() < _M)
            {
                size_type _O = _P - begin();
                _Vec.resize(_Nw(size() + _M), 0);
                _P = begin() + _O;
            }
            copy_backward(_P, end(), end() + _M);
            copy(_F, _L, _P);
            _Size += _M;
        }
    }
    iterator erase(iterator _P)
    {
        copy(_P + 1, end(), _P);
        _Trim(_Size - 1);
        return (_P);
    }
    iterator erase(iterator _F, iterator _L)
    {
        iterator _S = copy(_L, end(), _F);
        _Trim(_S - begin());
        return (_F);
    }
    void clear()
    {
        erase(begin(), end());
    }
    void flip()
    {
        for (_Vbtype::iterator _S = _Vec.begin();
            _S != _Vec.end(); ++_S)
            *_S = ~*_S;
        _Trim(_Size);
    }
    bool operator==(const _Myt& _X) const
    {
        return (_Size == _X._Size && _Vec == _X._Vec);
    }
    bool operator!=(const _Myt& _X) const
    {
        return (!(*this == _X));
    }
    bool operator<(const _Myt& _X) const
    {
        return (_Size < _X._Size
                || _Size == _X._Size && _Vec < _X._Vec);
    }
    bool operator>(const _Myt& _X) const
    {
        return (_X < *this);
    }
    bool operator<=(const _Myt& _X) const
    {
        return (!(_X < *this));
    }
    bool operator>=(const _Myt& _X) const
    {
        return (!(*this < _X));
    }
    void swap(_Myt& _X)
    {
        std::swap(_Size, _X._Size);
        _Vec.swap(_X._Vec);
    }
    friend void swap(_Myt& _X, _Myt& _Y)
    {
        _X.swap(_Y);
    }
    static void swap(reference _X, reference _Y)
    {
        bool _V = _X;
        _X = _Y;
        _Y = _V;
    }
protected:
    static size_type _Nw(size_type _N)
    {
        return ((_N + _VBITS - 1) / _VBITS);
    }
    void _Trim(size_type _N)
    {
        size_type _M = _Nw(_N);
        if (_M < _Vec.size())
            _Vec.erase(_Vec.begin() + _M, _Vec.end());
        _Size = _N;
        _N %= _VBITS;
        if (0 < _N)
            _Vec[_M - 1] &= ((_Vbase)1 << _N) - 1;
    }
    void _Xran() const
    {
        _THROW(out_of_range, "invalid vector<bool> subscript");
    }
    size_type _Size;
    _Vbtype _Vec;
};
typedef vector<_Bool, _Bool_allocator> _Bvector;
*/

_STD_END

#ifdef  _MSC_VER
#pragma pack(pop)
#endif  /* _MSC_VER */

#endif /* _STLVEC_H_ */

/*
 * Copyright (c) 1995 by P.J. Plauger.  ALL RIGHTS RESERVED.
 * Consult your license regarding permissions and restrictions.
 */

/*
 * This file is derived from software bearing the following
 * restrictions:
 *
 * Copyright (c) 1994
 * Hewlett-Packard Company
 *
 * Permission to use, copy, modify, distribute and sell this
 * software and its documentation for any purpose is hereby
 * granted without fee, provided that the above copyright notice
 * appear in all copies and that both that copyright notice and
 * this permission notice appear in supporting documentation.
 * Hewlett-Packard Company makes no representations about the
 * suitability of this software for any purpose. It is provided
 * "as is" without express or implied warranty.
 */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\rasdiag\private\stlxstdd.h ===
#pragma once
#ifndef _STLXSTDD_H_
#define _STLXSTDD_H_

//#ifndef _YVALS
//#include <yvals.h>
//#endif
//#include <cstddef>

#include <stddef.h>

/*
// Define _CRTIMP
#ifndef _CRTIMP
#ifdef  CRTDLL2
#define _CRTIMP __declspec(dllexport)
#else   // ndef CRTDLL2
#ifdef  _DLL
#define _CRTIMP __declspec(dllimport)
#else   // ndef _DLL
#define _CRTIMP
#endif  // _DLL
#endif  // CRTDLL2
#endif  // _CRTIMP
*/

#ifdef  _MSC_VER
#pragma pack(push,8)
#endif  /* _MSC_VER */


// begin yyvals.h include

#pragma warning(disable: 4244)

//#pragma warning(4: 4018 4114 4146 4244 4245)
//#pragma warning(4: 4663 4664 4665)
//#pragma warning(disable: 4237 4514)

// 4284:
// return type for 'identifier::operator >' is not a UDT or reference to a
// UDT. Will produce errors if applied using infix notation
//
#pragma warning(disable: 4284)

// 4290: C++ Exception Specification ignored
// A function was declared using exception specification.
// At this time the implementation details of exception specification have
// not been standardized, and are accepted but not implemented in Microsoft
// Visual C++.
//
#pragma warning(disable: 4290)



// NAMESPACE
#if defined(__cplusplus)
#define _STD            std::
#define _STD_BEGIN      namespace std {
#define _STD_END        };
#define _STD_USING
#else
#define _STD            ::
#define _STD_BEGIN
#define _STD_END
#endif // __cplusplus

_STD_BEGIN

// TYPE bool
#if defined(__cplusplus)
typedef bool _Bool;
#endif // __cplusplus

// INTEGER PROPERTIES
#define _MAX_EXP_DIG    8   // for parsing numerics
#define _MAX_INT_DIG    32
#define _MAX_SIG_DIG    36

// STDIO PROPERTIES
#define _Filet _iobuf

#ifndef _FPOS_T_DEFINED
#define _FPOSOFF(fp)    ((long)(fp))
#endif // _FPOS_T_DEFINED

// NAMING PROPERTIES
#if defined(__cplusplus)
#define _C_LIB_DECL extern "C" {
#define _END_C_LIB_DECL }
#else
#define _C_LIB_DECL
#define _END_C_LIB_DECL
#endif // __cplusplus
#define _CDECL

/*
// CLASS _Lockit
#if defined(__cplusplus)
class _CRTIMP _Lockit
{   // lock while object in existence
public:
    #ifdef _MT
        #define _LOCKIT(x)  lockit x
        _Lockit();
        ~_Lockit();
    #else
        #define _LOCKIT(x)
        _Lockit()
        {
        }
        ~_Lockit()
        {
        }
    #endif // _MT
};
#endif // __cplusplus
*/

// MISCELLANEOUS MACROS
#define _L(c)   L##c
#define _Mbstinit(x)    mbstate_t x = {0}
#define _MAX    _cpp_max
#define _MIN    _cpp_min

// end yyvals.h include


// EXCEPTION MACROS
//#define _TRY_BEGIN              try {
//#define _CATCH(x)               } catch (x) {
//#define _CATCH_ALL              } catch (...) {
//#define _CATCH_END              }
#define _RAISE(x)               throw (x)
//#define _RERAISE                throw
#define _THROW0()               throw ()
#define _THROW1(x)              throw (x)
#define _THROW(x, y)            throw x(y)

// explicit KEYWORD
// BITMASK MACROS
#define _BITMASK(E, T)          typedef int T
#define _BITMASK_OPS(T)

// MISCELLANEOUS MACROS
#define _DESTRUCTOR(ty, ptr)    (ptr)->~ty()
#define _PROTECTED              public
#define _TDEF(x)                = x
#define _TDEF2(x, y)            = x, y
#define _CNTSIZ(iter)           ptrdiff_t
#define _TDEFP(x)
#define _STCONS(ty, name, val)  enum {name = val}

// TYPE DEFINITIONS
enum _Uninitialized
{
    _Noinit
};

// FUNCTIONS
/*_CRTIMP*/
void __cdecl _Nomemory();

_STD_END

#ifdef  _MSC_VER
#pragma pack(pop)
#endif  /* _MSC_VER */

#endif /* _STLXSTDD_H_ */

/*
 * Copyright (c) 1995 by P.J. Plauger.  ALL RIGHTS RESERVED.
 * Consult your license regarding permissions and restrictions.
 */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\rasdiag\private\stlxmem.h ===
#pragma once
#ifndef _STLXMEM_H_
#define _STLXMEM_H_
//#include <cstdlib>
//#include <new>
//#include <utility>

#include <stdlib.h>
#include <stlnew.h>
#include <stlutil.h>

#ifdef  _MSC_VER
#pragma pack(push,8)
#endif  /* _MSC_VER */

#ifndef _FARQ   /* specify standard memory model */
#define _FARQ
#define _PDFT  ptrdiff_t
#define _SIZT  size_t
#endif
#define _POINTER_X(T, A)   T _FARQ *
#define _REFERENCE_X(T, A) T _FARQ &

_STD_BEGIN

// TEMPLATE FUNCTION _Allocate
template<class _Ty> inline
_Ty _FARQ *_Allocate(_PDFT _N, _Ty _FARQ *)
{
    if (_N < 0)
        _N = 0;
    return ((_Ty _FARQ *)operator new((_SIZT)_N * sizeof (_Ty), raiseexception));
}

// TEMPLATE FUNCTION _Construct
template<class _T1, class _T2> inline
void _Construct(_T1 _FARQ *_P, const _T2& _V)
{
    new ((void _FARQ *)_P) _T1(_V);
}

// TEMPLATE FUNCTION _Destroy
template<class _Ty> inline
void _Destroy(_Ty _FARQ *_P)
{
    _DESTRUCTOR(_Ty, _P);
}
inline void _Destroy(char _FARQ *_P)
{

}
inline void _Destroy(wchar_t _FARQ *_P)
{

}

// TEMPLATE CLASS allocator
template<class _Ty>
class allocator
{
public:
    typedef _SIZT size_type;
    typedef _PDFT difference_type;
    typedef _Ty _FARQ *pointer;
    typedef const _Ty _FARQ *const_pointer;
    typedef _Ty _FARQ& reference;
    typedef const _Ty _FARQ& const_reference;
    typedef _Ty value_type;
    pointer address(reference _X) const
    {
        return (&_X);
    }
    const_pointer address(const_reference _X) const
    {
        return (&_X);
    }
    pointer allocate(size_type _N, const void *)
    {
        return (_Allocate((difference_type)_N, (pointer)0));
    }
    char _FARQ *_Charalloc(size_type _N)
    {
        return (_Allocate((difference_type)_N, (char _FARQ *)0));
    }
    void deallocate(void _FARQ *_P, size_type)
    {
        operator delete(_P);
    }
    void construct(pointer _P, const _Ty& _V)
    {
        _Construct(_P, _V);
    }
    void destroy(pointer _P)
    {
        _Destroy(_P);
    }
    _SIZT max_size() const
    {
        _SIZT _N = (_SIZT)(-1) / sizeof (_Ty);
        return (0 < _N ? _N : 1);
    }
};
template<class _Ty, class _U> inline
bool operator==(const allocator<_Ty>&, const allocator<_U>&)
{
    return (true);
}
template<class _Ty, class _U> inline
bool operator!=(const allocator<_Ty>&, const allocator<_U>&)
{
    return (false);
}

// CLASS allocator<void>
class /*_CRTIMP*/ allocator<void>
{
public:
    typedef void _Ty;
    typedef _Ty _FARQ *pointer;
    typedef const _Ty _FARQ *const_pointer;
    typedef _Ty value_type;
};

_STD_END

#ifdef  _MSC_VER
#pragma pack(pop)
#endif  /* _MSC_VER */

#endif /* _STLXMEM_H_ */

/*
 * Copyright (c) 1995 by P.J. Plauger.  ALL RIGHTS RESERVED.
 * Consult your license regarding permissions and restrictions.
 */

/*
 * This file is derived from software bearing the following
 * restrictions:
 *
 * Copyright (c) 1994
 * Hewlett-Packard Company
 *
 * Permission to use, copy, modify, distribute and sell this
 * software and its documentation for any purpose is hereby
 * granted without fee, provided that the above copyright notice
 * appear in all copies and that both that copyright notice and
 * this permission notice appear in supporting documentation.
 * Hewlett-Packard Company makes no representations about the
 * suitability of this software for any purpose. It is provided
 * "as is" without express or implied warranty.
 */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\rasdiag\private\stlfunc.h ===
#pragma once
#ifndef _STLFUNC_H_
#define _STLFUNC_H_
//#include <xstddef>

#include <stddef.h>

#ifdef  _MSC_VER
#pragma pack(push,8)
#endif  /* _MSC_VER */

_STD_BEGIN

// TEMPLATE STRUCT unary_function
template<class _A, class _R>
struct unary_function
{
    typedef _A argument_type;
    typedef _R result_type;
};

// TEMPLATE STRUCT binary_function
template<class _A1, class _A2, class _R>
struct binary_function
{
    typedef _A1 first_argument_type;
    typedef _A2 second_argument_type;
    typedef _R result_type;
};

// TEMPLATE STRUCT plus
template<class _Ty>
struct plus : binary_function<_Ty, _Ty, _Ty>
{
    _Ty operator()(const _Ty& _X, const _Ty& _Y) const
    {
        return (_X + _Y);
    }
};

// TEMPLATE STRUCT minus
template<class _Ty>
struct minus : binary_function<_Ty, _Ty, _Ty>
{
    _Ty operator()(const _Ty& _X, const _Ty& _Y) const
    {
        return (_X - _Y);
    }
};

// TEMPLATE STRUCT multiplies
template<class _Ty>
struct multiplies : binary_function<_Ty, _Ty, _Ty>
{
    _Ty operator()(const _Ty& _X, const _Ty& _Y) const
    {
        return (_X * _Y);
    }
};

// TEMPLATE STRUCT divides
template<class _Ty>
struct divides : binary_function<_Ty, _Ty, _Ty>
{
    _Ty operator()(const _Ty& _X, const _Ty& _Y) const
    {
        return (_X / _Y);
    }
};

// TEMPLATE STRUCT modulus
template<class _Ty>
struct modulus : binary_function<_Ty, _Ty, _Ty>
{
    _Ty operator()(const _Ty& _X, const _Ty& _Y) const
    {
        return (_X % _Y);
    }
};

// TEMPLATE STRUCT negate
template<class _Ty>
struct negate : unary_function<_Ty, _Ty>
{
    _Ty operator()(const _Ty& _X) const
    {
        return (-_X);
    }
};

// TEMPLATE STRUCT equal_to
template<class _Ty>
struct equal_to : binary_function<_Ty, _Ty, bool>
{
    bool operator()(const _Ty& _X, const _Ty& _Y) const
    {
        return (_X == _Y);
    }
};

// TEMPLATE STRUCT not_equal_to
template<class _Ty>
struct not_equal_to : binary_function<_Ty, _Ty, bool>
{
    bool operator()(const _Ty& _X, const _Ty& _Y) const
    {
        return (_X != _Y);
    }
};

// TEMPLATE STRUCT greater
template<class _Ty>
struct greater : binary_function<_Ty, _Ty, bool>
{
    bool operator()(const _Ty& _X, const _Ty& _Y) const
    {
        return (_X > _Y);
    }
};

// TEMPLATE STRUCT less
template<class _Ty>
struct less : binary_function<_Ty, _Ty, bool>
{
    bool operator()(const _Ty& _X, const _Ty& _Y) const
    {
        return (_X < _Y);
    }
};

// TEMPLATE STRUCT greater_equal
template<class _Ty>
struct greater_equal : binary_function<_Ty, _Ty, bool>
{
    bool operator()(const _Ty& _X, const _Ty& _Y) const
    {
        return (_X >= _Y);
    }
};

// TEMPLATE STRUCT less_equal
template<class _Ty>
struct less_equal : binary_function<_Ty, _Ty, bool>
{
    bool operator()(const _Ty& _X, const _Ty& _Y) const
    {
        return (_X <= _Y);
    }
};

// TEMPLATE STRUCT logical_and
template<class _Ty>
struct logical_and : binary_function<_Ty, _Ty, bool>
{
    bool operator()(const _Ty& _X, const _Ty& _Y) const
    {
        return (_X && _Y);
    }
};

// TEMPLATE STRUCT logical_or
template<class _Ty>
struct logical_or : binary_function<_Ty, _Ty, bool>
{
    bool operator()(const _Ty& _X, const _Ty& _Y) const
    {
        return (_X || _Y);
    }
};

// TEMPLATE STRUCT logical_not
template<class _Ty>
struct logical_not : unary_function<_Ty, bool>
{
    bool operator()(const _Ty& _X) const
    {
        return (!_X);
    }
};

// TEMPLATE CLASS unary_negate
template<class _Ufn>
class unary_negate
: public unary_function<_Ufn::argument_type, bool>
{
public:
    explicit unary_negate(const _Ufn& _X)
    : _Fn(_X)
    {

    }
    bool operator()(const _Ufn::argument_type& _X) const
    {
        return (!_Fn(_X));
    }
protected:
    _Ufn _Fn;
};

// TEMPLATE FUNCTION not1
template<class _Ufn> inline
unary_negate<_Ufn> not1(const _Ufn& _X)
{
    return (unary_negate<_Ufn>(_X));
}

// TEMPLATE CLASS binary_negate
template<class _Bfn>
class binary_negate
: public binary_function<_Bfn::first_argument_type,
_Bfn::second_argument_type, bool>
{
public:
    explicit binary_negate(const _Bfn& _X)
    : _Fn(_X)
    {

    }
    bool operator()(const _Bfn::first_argument_type& _X,
                    const _Bfn::second_argument_type& _Y) const
    {
        return (!_Fn(_X, _Y));
    }
protected:
    _Bfn _Fn;
};

// TEMPLATE FUNCTION not2
template<class _Bfn> inline
binary_negate<_Bfn> not2(const _Bfn& _X)
{
    return (binary_negate<_Bfn>(_X));
}

// TEMPLATE CLASS binder1st
template<class _Bfn>
class binder1st
: public unary_function<_Bfn::second_argument_type,
_Bfn::result_type>
{
public:
    binder1st(const _Bfn& _X,
              const _Bfn::first_argument_type& _Y)
    : op(_X), value(_Y)
    {

    }
    result_type operator()(const argument_type& _X) const
    {
        return (op(value, _X));
    }
protected:
    _Bfn op;
    _Bfn::first_argument_type value;
};

// TEMPLATE FUNCTION bind1st
template<class _Bfn, class _Ty> inline
binder1st<_Bfn> bind1st(const _Bfn& _X, const _Ty& _Y)
{
    return (binder1st<_Bfn>(_X,
                            _Bfn::first_argument_type(_Y)));
}

// TEMPLATE CLASS binder2nd
template<class _Bfn>
class binder2nd
: public unary_function<_Bfn::first_argument_type,
_Bfn::result_type>
{
public:
    binder2nd(const _Bfn& _X,
              const _Bfn::second_argument_type& _Y)
    : op(_X), value(_Y)
    {

    }
    result_type operator()(const argument_type& _X) const
    {
        return (op(_X, value));
    }
protected:
    _Bfn op;
    _Bfn::second_argument_type value;
};

// TEMPLATE FUNCTION bind2nd
template<class _Bfn, class _Ty> inline
binder2nd<_Bfn> bind2nd(const _Bfn& _X, const _Ty& _Y)
{
    return (binder2nd<_Bfn>(_X,
                            _Bfn::second_argument_type(_Y)));
}

// TEMPLATE CLASS pointer_to_unary_function
template<class _A, class _R>
class pointer_to_unary_function
: public unary_function<_A, _R>
{
public:
    explicit pointer_to_unary_function(_R (__cdecl *_X)(_A))
    : _Fn(_X)
    {

    }
    _R operator()(_A _X) const
    {
        return (_Fn(_X));
    }
protected:
    _R (__cdecl *_Fn)(_A);
};

// TEMPLATE CLASS pointer_to_binary_function
template<class _A1, class _A2, class _R>
class pointer_to_binary_function
: public binary_function<_A1, _A2, _R>
{
public:
    explicit pointer_to_binary_function(
                                       _R (__cdecl *_X)(_A1, _A2))
    : _Fn(_X)
    {

    }
    _R operator()(_A1 _X, _A2 _Y) const
    {
        return (_Fn(_X, _Y));
    }
protected:
    _R (__cdecl *_Fn)(_A1, _A2);
};

// TEMPLATE FUNCTION ptr_fun
template<class _A, class _R> inline
pointer_to_unary_function<_A, _R>
ptr_fun(_R (__cdecl *_X)(_A))
{
    return (pointer_to_unary_function<_A, _R>(_X));
}
template<class _A1, class _A2, class _R> inline
pointer_to_binary_function<_A1, _A2, _R>
ptr_fun(_R (__cdecl *_X)(_A1, _A2))
{
    return (pointer_to_binary_function<_A1, _A2, _R>(_X));
}

// TEMPLATE CLASS mem_fun_t
template<class _R, class _Ty>
class mem_fun_t : public unary_function<_Ty *, _R>
{
public:
    explicit mem_fun_t(_R (_Ty::*_Pm)())
    : _Ptr(_Pm)
    {

    }
    _R operator()(_Ty *_P)
    {
        return ((_P->*_Ptr)());
    }
private:
    _R (_Ty::*_Ptr)();
};

// TEMPLATE FUNCTION mem_fun
template<class _R, class _Ty> inline
mem_fun_t<_R, _Ty> mem_fun(_R (_Ty::*_Pm)())
{
    return (mem_fun_t<_R, _Ty>(_Pm));
}

// TEMPLATE CLASS mem_fun1_t
template<class _R, class _Ty, class _A>
class mem_fun1_t : public binary_function<_Ty *, _A, _R>
{
public:
    explicit mem_fun1_t(_R (_Ty::*_Pm)(_A))
    : _Ptr(_Pm)
    {

    }
    _R operator()(_Ty *_P, _A _Arg)
    {
        return ((_P->*_Ptr)(_Arg));
    }
private:
    _R (_Ty::*_Ptr)(_A);
};

// TEMPLATE FUNCTION mem_fun1
template<class _R, class _Ty, class _A> inline
mem_fun1_t<_R, _Ty, _A> mem_fun1(_R (_Ty::*_Pm)(_A))
{
    return (mem_fun1_t<_R, _Ty, _A>(_Pm));
}

// TEMPLATE CLASS mem_fun_ref_t
template<class _R, class _Ty>
class mem_fun_ref_t : public unary_function<_Ty *, _R>
{
public:
    explicit mem_fun_ref_t(_R (_Ty::*_Pm)())
    : _Ptr(_Pm)
    {

    }
    _R operator()(_Ty& _X)
    {
        return ((_X.*_Ptr)());
    }
private:
    _R (_Ty::*_Ptr)();
};

// TEMPLATE FUNCTION mem_fun_ref
template<class _R, class _Ty> inline
mem_fun_ref_t<_R, _Ty> mem_fun_ref(_R (_Ty::*_Pm)())
{
    return (mem_fun_ref_t<_R, _Ty>(_Pm));
}

// TEMPLATE CLASS mem_fun1_ref_t
template<class _R, class _Ty, class _A>
class mem_fun1_ref_t : public binary_function<_Ty *, _A, _R>
{
public:
    explicit mem_fun1_ref_t(_R (_Ty::*_Pm)(_A))
    : _Ptr(_Pm)
    {

    }
    _R operator()(_Ty& _X, _A _Arg)
    {
        return ((_X.*_Ptr)(_Arg));
    }
private:
    _R (_Ty::*_Ptr)(_A);
};

// TEMPLATE FUNCTION mem_fun1_ref
template<class _R, class _Ty, class _A> inline
mem_fun1_ref_t<_R, _Ty, _A> mem_fun1_ref(_R (_Ty::*_Pm)(_A))
{
    return (mem_fun1_ref_t<_R, _Ty, _A>(_Pm));
}

_STD_END

#ifdef  _MSC_VER
#pragma pack(pop)
#endif  /* _MSC_VER */

#endif /* _STLFUNC_H_ */

/*
 * Copyright (c) 1995 by P.J. Plauger.  ALL RIGHTS RESERVED.
 * Consult your license regarding permissions and restrictions.
 */

/*
 * This file is derived from software bearing the following
 * restrictions:
 *
 * Copyright (c) 1994
 * Hewlett-Packard Company
 *
 * Permission to use, copy, modify, distribute and sell this
 * software and its documentation for any purpose is hereby
 * granted without fee, provided that the above copyright notice
 * appear in all copies and that both that copyright notice and
 * this permission notice appear in supporting documentation.
 * Hewlett-Packard Company makes no representations about the
 * suitability of this software for any purpose. It is provided
 * "as is" without express or implied warranty.
 */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\rasdiag\private\stlutil.h ===
#pragma once
#ifndef _STLUTIL_H_
#define _STLUTIL_H_

#include <stlxstdd.h>

#ifdef  _MSC_VER
#pragma pack(push,8)
#endif  /* _MSC_VER */

_STD_BEGIN

// TEMPLATE STRUCT pair
template<class _T1, class _T2> struct pair
{
    typedef _T1 first_type;
    typedef _T2 second_type;
    pair()
    : first(_T1()), second(_T2())
    {

    }
    pair(const _T1& _V1, const _T2& _V2)
    : first(_V1), second(_V2)
    {

    }
    _T1 first;
    _T2 second;
};
template<class _T1, class _T2> inline
bool __cdecl operator==(const pair<_T1, _T2>& _X,
                        const pair<_T1, _T2>& _Y)
{
    return (_X.first == _Y.first && _X.second == _Y.second);
}
template<class _T1, class _T2> inline
bool __cdecl operator!=(const pair<_T1, _T2>& _X,
                        const pair<_T1, _T2>& _Y)
{
    return (!(_X == _Y));
}
template<class _T1, class _T2> inline
bool __cdecl operator<(const pair<_T1, _T2>& _X,
                       const pair<_T1, _T2>& _Y)
{
    return (_X.first < _Y.first ||
            !(_Y.first < _X.first) && _X.second < _Y.second);
}
template<class _T1, class _T2> inline
bool __cdecl operator>(const pair<_T1, _T2>& _X,
                       const pair<_T1, _T2>& _Y)
{
    return (_Y < _X);
}
template<class _T1, class _T2> inline
bool __cdecl operator<=(const pair<_T1, _T2>& _X,
                        const pair<_T1, _T2>& _Y)
{
    return (!(_Y < _X));
}
template<class _T1, class _T2> inline
bool __cdecl operator>=(const pair<_T1, _T2>& _X,
                        const pair<_T1, _T2>& _Y)
{
    return (!(_X < _Y));
}
template<class _T1, class _T2> inline
pair<_T1, _T2> __cdecl make_pair(const _T1& _X, const _T2& _Y)
{
    return (pair<_T1, _T2>(_X, _Y));
}


// ITERATOR TAGS (from <iterator>)
struct input_iterator_tag
{
};
struct output_iterator_tag
{
};
struct forward_iterator_tag
: public input_iterator_tag
{
};
struct bidirectional_iterator_tag
: public forward_iterator_tag
{
};
struct random_access_iterator_tag
: public bidirectional_iterator_tag
{
};


// TEMPLATE CLASS iterator (from <iterator>)
template<class _C, class _Ty, class _D = ptrdiff_t>
struct iterator
{
   typedef _C iterator_category;
   typedef _Ty value_type;
   typedef _D distance_type;
};

template<class _Ty, class _D>
struct _Bidit : public iterator<bidirectional_iterator_tag, _Ty, _D>
{
};

template<class _Ty, class _D>
struct _Ranit : public iterator<random_access_iterator_tag, _Ty, _D>
{
};

// TEMPLATE CLASS iterator_traits (from <iterator>)
template<class _It>
struct iterator_traits
{
   typedef _It::iterator_category iterator_category;
   typedef _It::value_type value_type;
   typedef _It::distance_type distance_type;
};

// TEMPLATE FUNCTION _Iter_cat (from <iterator>)

#if _MSC_VER >= 1200
#pragma warning(push)
#endif
#pragma warning(disable:4700)

template<class _C, class _Ty, class _D>
inline
_C __cdecl _Iter_cat(const iterator<_C, _Ty, _D>&)
{
    _C _X;
    return (_X);
}

template<class _Ty>
inline
random_access_iterator_tag __cdecl _Iter_cat(const _Ty *)
{
    random_access_iterator_tag _X;
    return (_X);
}

#if _MSC_VER >= 1200
#pragma warning(pop)
#else
#pragma warning(default:4700)
#endif

// TEMPLATE FUNCTION _Distance
template<class _II>
inline
_CNTSIZ(_II) __cdecl distance(_II _F, _II _L)
{
    _CNTSIZ(_II) _N = 0;
    _Distance(_F, _L, _N, _Iter_cat(_F));
    return (_N);
}

template<class _II, class _D>
inline
void __cdecl _Distance(_II _F, _II _L, _D& _N)
{
    _Distance(_F, _L, _N, _Iter_cat(_F));
}

template<class _II, class _D>
inline
void __cdecl _Distance(_II _F, _II _L, _D& _N, input_iterator_tag)
{
    for (; _F != _L; ++_F)
        ++_N;
}

template<class _II, class _D>
inline
void __cdecl _Distance(_II _F, _II _L, _D& _N, forward_iterator_tag)
{
    for (; _F != _L; ++_F)
        ++_N;
}

template<class _II, class _D>
inline
void __cdecl _Distance(_II _F, _II _L, _D& _N,
                       bidirectional_iterator_tag)
{
    for (; _F != _L; ++_F)
        ++_N;
}

template<class _RI, class _D>
inline
void __cdecl _Distance(_RI _F, _RI _L, _D& _N,
                       random_access_iterator_tag)
{
    _N += (_D)(_L - _F);
}

// TEMPLATE CLASS reverse_iterator (from <iterator>)
template<class _RI, class _Ty, class _Rt = _Ty&, class _Pt = _Ty *,
            class _D = ptrdiff_t>
class reverse_iterator : public _Ranit<_Ty, _D>
{
public:
   typedef reverse_iterator<_RI, _Ty, _Rt, _Pt, _D> _Myt;
   typedef _RI iter_type;
   typedef _Rt reference_type;
   typedef _Pt pointer_type;
   reverse_iterator()
   {
   }
   explicit reverse_iterator(_RI _X)
   : current(_X)
   {
   }
   _RI base() const
   {
       return (current);
   }
   _Rt operator*() const
   {
       return (*(current - 1));
   }
   _Pt operator->() const
   {
       return (&**this);
   }
   _Myt& operator++()
   {
       --current;
       return (*this);
   }
   _Myt operator++(int)
   {
       _Myt _Tmp = *this;
       --current;
       return (_Tmp);
   }
   _Myt& operator--()
   {
       ++current;
       return (*this);
   }
   _Myt operator--(int)
   {
       _Myt _Tmp = *this;
       ++current;
       return (_Tmp);
   }
   _Myt& operator+=(_D _N)
   {
       current -= _N;
       return (*this);
   }
   _Myt operator+(_D _N) const
   {
       return (_Myt(current - _N));
   }
   _Myt& operator-=(_D _N)
   {
       current += _N;
       return (*this);
   }
   _Myt operator-(_D _N) const
   {
       return (_Myt(current + _N));
   }
   _Rt operator[](_D _N) const
   {
       return (*(*this + _N));
   }
protected:
   _RI current;
};

template<class _RI, class _Ty, class _Rt, class _Pt, class _D>
inline
bool __cdecl operator==(
                      const reverse_iterator<_RI, _Ty, _Rt, _Pt, _D>& _X,
                      const reverse_iterator<_RI, _Ty, _Rt, _Pt, _D>& _Y)
{
    return (_X.base() == _Y.base());
}

template<class _RI, class _Ty, class _Rt, class _Pt, class _D>
inline
bool __cdecl operator!=(
                       const reverse_iterator<_RI, _Ty, _Rt, _Pt, _D>& _X,
                       const reverse_iterator<_RI, _Ty, _Rt, _Pt, _D>& _Y)
{
    return (!(_X == _Y));
}

template<class _RI, class _Ty, class _Rt, class _Pt, class _D>
inline
bool __cdecl operator<(
                      const reverse_iterator<_RI, _Ty, _Rt, _Pt, _D>& _X,
                      const reverse_iterator<_RI, _Ty, _Rt, _Pt, _D>& _Y)
{
    return (_Y.base() < _X.base());
}

template<class _RI, class _Ty, class _Rt, class _Pt, class _D>
inline
bool __cdecl operator>(
                      const reverse_iterator<_RI, _Ty, _Rt, _Pt, _D>& _X,
                      const reverse_iterator<_RI, _Ty, _Rt, _Pt, _D>& _Y)
{
    return (_Y < _X);
}

template<class _RI, class _Ty, class _Rt, class _Pt, class _D>
inline
bool __cdecl operator<=(
                       const reverse_iterator<_RI, _Ty, _Rt, _Pt, _D>& _X,
                       const reverse_iterator<_RI, _Ty, _Rt, _Pt, _D>& _Y)
{
    return (!(_Y < _X));
}

template<class _RI, class _Ty, class _Rt, class _Pt, class _D>
inline
bool __cdecl operator>=(
                       const reverse_iterator<_RI, _Ty, _Rt, _Pt, _D>& _X,
                       const reverse_iterator<_RI, _Ty, _Rt, _Pt, _D>& _Y)
{
    return (!(_X < _Y));
}

template<class _RI, class _Ty, class _Rt, class _Pt, class _D>
inline
_D __cdecl operator-(
                    const reverse_iterator<_RI, _Ty, _Rt, _Pt, _D>& _X,
                    const reverse_iterator<_RI, _Ty, _Rt, _Pt, _D>& _Y)
{
    return (_Y.base() - _X.base());
}

template<class _RI, class _Ty, class _Rt, class _Pt, class _D>
inline
reverse_iterator<_RI, _Ty, _Rt, _Pt, _D> __cdecl operator+(_D _N,
               const reverse_iterator<_RI, _Ty, _Rt, _Pt, _D>& _Y)
{
    return (reverse_iterator<_RI, _Ty, _Rt, _Pt, _D>(
                                                    _Y.base() - _N));
}

/*
// TEMPLATE CLASS istreambuf_iterator (from <iterator>)
template<class _E, class _Tr = char_traits<_E> >
class istreambuf_iterator :
    public iterator<input_iterator_tag, _E, _Tr::off_type>
{
public:
    typedef istreambuf_iterator<_E, _Tr> _Myt;
    typedef _E char_type;
    typedef _Tr traits_type;
    typedef _Tr::int_type int_type;
    typedef basic_streambuf<_E, _Tr> streambuf_type;
    typedef basic_istream<_E, _Tr> istream_type;
    istreambuf_iterator(streambuf_type *_Sb = 0) _THROW0()
    : _Sbuf(_Sb), _Got(_Sb == 0)
    {

    }
    istreambuf_iterator(istream_type& _I) _THROW0()
    : _Sbuf(_I.rdbuf()), _Got(_I.rdbuf() == 0)
    {

    }
    const _E& operator*() const
    {
        if (!_Got)
            ((_Myt *)this)->_Peek();
        return (_Val);
    }
    const _E *operator->() const
    {
        return (&**this);
    }
    _Myt& operator++()
    {
        _Inc();
        return (*this);
    }
    _Myt operator++(int)
    {
        if (!_Got)
            _Peek();
        _Myt _Tmp = *this;
        _Inc();
        return (_Tmp);
    }
    bool equal(const _Myt& _X) const
    {
        if (!_Got)
            ((_Myt *)this)->_Peek();
        if (!_X._Got)
            ((_Myt *)&_X)->_Peek();
        return (_Sbuf == 0 && _X._Sbuf == 0
                || _Sbuf != 0 && _X._Sbuf != 0);
    }
private:
    void _Inc()
    {
        if (_Sbuf == 0
            || _Tr::eq_int_type(_Tr::eof(), _Sbuf->sbumpc()))
            _Sbuf = 0, _Got = true;
        else
            _Got = false;
    }
    _E _Peek()
    {
        int_type _C;
        if (_Sbuf == 0
            || _Tr::eq_int_type(_Tr::eof(), _C = _Sbuf->sgetc()))
            _Sbuf = 0;
        else
            _Val = _Tr::to_char_type(_C);
        _Got = true;
        return (_Val);
    }
    streambuf_type *_Sbuf;
    bool _Got;
    _E _Val;
};
template<class _E, class _Tr> inline
bool __cdecl operator==(const istreambuf_iterator<_E, _Tr>& _X,
                        const istreambuf_iterator<_E, _Tr>& _Y)
{
    return (_X.equal(_Y));
}
template<class _E, class _Tr> inline
bool __cdecl operator!=(const istreambuf_iterator<_E, _Tr>& _X,
                        const istreambuf_iterator<_E, _Tr>& _Y)
{
    return (!(_X == _Y));
}

// TEMPLATE CLASS ostreambuf_iterator (from <iterator>)
template<class _E, class _Tr = char_traits<_E> >
class ostreambuf_iterator :
    public iterator<output_iterator_tag, void, void>
{
    typedef ostreambuf_iterator<_E, _Tr> _Myt;
public:
    typedef _E char_type;
    typedef _Tr traits_type;
    typedef basic_streambuf<_E, _Tr> streambuf_type;
    typedef basic_ostream<_E, _Tr> ostream_type;
    ostreambuf_iterator(streambuf_type *_Sb) _THROW0()
    : _Failed(false), _Sbuf(_Sb)
    {

    }
    ostreambuf_iterator(ostream_type& _O) _THROW0()
    : _Failed(false), _Sbuf(_O.rdbuf())
    {

    }
    _Myt& operator=(_E _X)
    {
        if (_Sbuf == 0
            || _Tr::eq_int_type(_Tr::eof(), _Sbuf->sputc(_X)))
            _Failed = true;
        return (*this);
    }
    _Myt& operator*()
    {
        return (*this);
    }
    _Myt& operator++()
    {
        return (*this);
    }
    _Myt& operator++(int)
    {
        return (*this);
    }
    bool failed() const _THROW0()
    {
        return (_Failed);
    }
private:
    bool _Failed;
    streambuf_type *_Sbuf;
};
*/

// TEMPLATE OPERATORS
namespace rel_ops
{
    template<class _Ty> inline
    bool __cdecl operator!=(const _Ty& _X, const _Ty& _Y)
    {
        return (!(_X == _Y));
    }
    template<class _Ty> inline
    bool __cdecl operator>(const _Ty& _X, const _Ty& _Y)
    {
        return (_Y < _X);
    }
    template<class _Ty> inline
    bool __cdecl operator<=(const _Ty& _X, const _Ty& _Y)
    {
        return (!(_Y < _X));
    }
    template<class _Ty> inline
    bool __cdecl operator>=(const _Ty& _X, const _Ty& _Y)
    {
        return (!(_X < _Y));
    }
}

_STD_END

#ifdef  _MSC_VER
#pragma pack(pop)
#endif  /* _MSC_VER */

#endif /* _STLUTIL_H_ */

/*
 * Copyright (c) 1995 by P.J. Plauger.  ALL RIGHTS RESERVED.
 * Consult your license regarding permissions and restrictions.
 */

/*
 * This file is derived from software bearing the following
 * restrictions:
 *
 * Copyright (c) 1994
 * Hewlett-Packard Company
 *
 * Permission to use, copy, modify, distribute and sell this
 * software and its documentation for any purpose is hereby
 * granted without fee, provided that the above copyright notice
 * appear in all copies and that both that copyright notice and
 * this permission notice appear in supporting documentation.
 * Hewlett-Packard Company makes no representations about the
 * suitability of this software for any purpose. It is provided
 * "as is" without express or implied warranty.
 */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\rasdiag\private\stlxutil.h ===
#pragma once
#ifndef _STLXUTIL_H_
#define _STLXUTIL_H_
//#include <utility>

#include <stlutil.h>

#ifdef  _MSC_VER
#pragma pack(push,8)
#endif  /* _MSC_VER */

_STD_BEGIN

// TEMPLATE FUNCTION copy
template<class _II, class _OI> inline
_OI copy(_II _F, _II _L, _OI _X)
{
    for (; _F != _L; ++_X, ++_F)
        *_X = *_F;
    return (_X);
}
// TEMPLATE FUNCTION copy_backward
template<class _BI1, class _BI2> inline
_BI2 copy_backward(_BI1 _F, _BI1 _L, _BI2 _X)
{
    while (_F != _L)
        *--_X = *--_L;
    return (_X);
}
// TEMPLATE FUNCTION equal
template<class _II1, class _II2> inline
bool equal(_II1 _F, _II1 _L, _II2 _X)
{
    return (mismatch(_F, _L, _X).first == _L);
}
// TEMPLATE FUNCTION equal WITH PRED
template<class _II1, class _II2, class _Pr> inline
bool equal(_II1 _F, _II1 _L, _II2 _X, _Pr _P)
{
    return (mismatch(_F, _L, _X, _P).first == _L);
}
// TEMPLATE FUNCTION fill
template<class _FI, class _Ty> inline
void fill(_FI _F, _FI _L, const _Ty& _X)
{
    for (; _F != _L; ++_F)
        *_F = _X;
}
// TEMPLATE FUNCTION fill_n
template<class _OI, class _Sz, class _Ty> inline
void fill_n(_OI _F, _Sz _N, const _Ty& _X)
{
    for (; 0 < _N; --_N, ++_F)
        *_F = _X;
}
// TEMPLATE FUNCTION lexicographical_compare
template<class _II1, class _II2> inline
bool lexicographical_compare(_II1 _F1, _II1 _L1,
                             _II2 _F2, _II2 _L2)
{
    for (; _F1 != _L1 && _F2 != _L2; ++_F1, ++_F2)
        if (*_F1 < *_F2)
            return (true);
        else if (*_F2 < *_F1)
            return (false);
    return (_F1 == _L1 && _F2 != _L2);
}
// TEMPLATE FUNCTION lexicographical_compare WITH PRED
template<class _II1, class _II2, class _Pr> inline
bool lexicographical_compare(_II1 _F1, _II1 _L1,
                             _II2 _F2, _II2 _L2, _Pr _P)
{
    for (; _F1 != _L1 && _F2 != _L2; ++_F1, ++_F2)
        if (_P(*_F1, *_F2))
            return (true);
        else if (_P(*_F2, *_F1))
            return (false);
    return (_F1 == _L1 && _F2 != _L2);
}
// TEMPLATE FUNCTION max
#ifndef _MAX
 #define _MAX   _cpp_max
 #define _MIN   _cpp_min
#endif
template<class _Ty> inline
const _Ty& _cpp_max(const _Ty& _X, const _Ty& _Y)
{
    return (_X < _Y ? _Y : _X);
}
// TEMPLATE FUNCTION max WITH PRED
template<class _Ty, class _Pr> inline
const _Ty& _cpp_max(const _Ty& _X, const _Ty& _Y, _Pr _P)
{
    return (_P(_X, _Y) ? _Y : _X);
}
// TEMPLATE FUNCTION min
template<class _Ty> inline
const _Ty& _cpp_min(const _Ty& _X, const _Ty& _Y)
{
    return (_Y < _X ? _Y : _X);
}
// TEMPLATE FUNCTION min WITH PRED
template<class _Ty, class _Pr> inline
const _Ty& _cpp_min(const _Ty& _X, const _Ty& _Y, _Pr _P)
{
    return (_P(_Y, _X) ? _Y : _X);
}
// TEMPLATE FUNCTION mismatch
template<class _II1, class _II2> inline
pair<_II1, _II2> mismatch(_II1 _F, _II1 _L, _II2 _X)
{
    for (; _F != _L && *_F == *_X; ++_F, ++_X)
        ;
    return (pair<_II1, _II2>(_F, _X));
}
// TEMPLATE FUNCTION mismatch WITH PRED
template<class _II1, class _II2, class _Pr> inline
pair<_II1, _II2> mismatch(_II1 _F, _II1 _L, _II2 _X, _Pr _P)
{
    for (; _F != _L && _P(*_F, *_X); ++_F, ++_X)
        ;
    return (pair<_II1, _II2>(_F, _X));
}
// TEMPLATE FUNCTION swap
template<class _Ty> inline
void swap(_Ty& _X, _Ty& _Y)
{
    _Ty _Tmp = _X;
    _X = _Y, _Y = _Tmp;
}

_STD_END

#ifdef  _MSC_VER
#pragma pack(pop)
#endif  /* _MSC_VER */

#endif /* _STLXUTIL_H_ */

/*
 * Copyright (c) 1995 by P.J. Plauger.  ALL RIGHTS RESERVED.
 * Consult your license regarding permissions and restrictions.
 */

/*
 * This file is derived from software bearing the following
 * restrictions:
 *
 * Copyright (c) 1994
 * Hewlett-Packard Company
 *
 * Permission to use, copy, modify, distribute and sell this
 * software and its documentation for any purpose is hereby
 * granted without fee, provided that the above copyright notice
 * appear in all copies and that both that copyright notice and
 * this permission notice appear in supporting documentation.
 * Hewlett-Packard Company makes no representations about the
 * suitability of this software for any purpose. It is provided
 * "as is" without express or implied warranty.
 */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\rasdiag\rasdiag\capture.cpp ===
/*++

Copyright (C) 1992-2001 Microsoft Corporation. All rights reserved.

Module Name:

    capture.h

Abstract:

    Netmon-abstraction for rasdiag
                                                     

Author:

    Anthony Leibovitz (tonyle) 02-01-2001

Revision History:


--*/


#include <conio.h>
#include <stdio.h>
#include <stdarg.h>
#include <stdlib.h>
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <lmcons.h>
#include <userenv.h>
#include <ras.h>
#include <raserror.h>
#include <process.h>
#include <netmon.h>
#include <ncdefine.h>
#include <ncmem.h>
#include <diag.h>
#include <winsock.h>
#include <devguid.h>
#include "capture.h"

BOOL
DoNetmonInstall(void)
{
    LPFNNetCfgDiagFromCommandArgs pF=NULL;
    HMODULE hMod;
    DIAG_OPTIONS    diag_o;

    HRESULT hr = CoInitializeEx (
                NULL,
                COINIT_DISABLE_OLE1DDE | COINIT_APARTMENTTHREADED);

    ZeroMemory(&diag_o, sizeof(DIAG_OPTIONS));

    hMod=LoadLibrary(NETCFG_LIBRARY_NAME);
    if(hMod==NULL)
    {
        CoUninitialize();
        return FALSE;
    }

    pF = (LPFNNetCfgDiagFromCommandArgs) GetProcAddress(hMod, NETCFG_NETINSTALL_ENTRYPOINT);
    if(pF==NULL) {
        CoUninitialize();
        FreeLibrary(hMod);
        return FALSE;
    }

    diag_o.Command = CMD_ADD_COMPONENT;
    diag_o.ClassGuid = GUID_DEVCLASS_NETTRANS;
    diag_o.pszInfId = NETMON_INF_STRING;

    // Install ms_netmon
    pF(&diag_o);

    FreeLibrary(hMod);
    CoUninitialize();
    return TRUE;
}


BOOL
IdentifyInterfaces(PRASDIAGCAPTURE *hLAN, DWORD *pdwLanCount)
{
    DWORD   dwStatus;
    HBLOB   hBlob;
    BLOB_TABLE *pTable=NULL;
    DWORD   i;
    BOOL    bRas=FALSE;
    DWORD   dwLanCount=0;
    PRASDIAGCAPTURE hLanAr=NULL;

    *hLAN = NULL;
    *pdwLanCount = 0;

    if((hLanAr = (PRASDIAGCAPTURE)LocalAlloc(LMEM_ZEROINIT, sizeof(RASDIAGCAPTURE) * MAX_LAN_CAPTURE_COUNT))
       == NULL) return FALSE;

    // Create blob for blob table
    dwStatus = CreateBlob(&hBlob);

    if(dwStatus != NMERR_SUCCESS) {
        return FALSE;
    }

    // Get the blob table
    dwStatus = GetNPPBlobTable(hBlob, &pTable);

    if(dwStatus != NMERR_SUCCESS) {
        DestroyBlob(hBlob);
        return FALSE;
    }   

    for(i=0;i<pTable->dwNumBlobs && (dwLanCount < MAX_LAN_CAPTURE_COUNT);i++)
    {
        NETWORKINFO ni;
        
        dwStatus = GetNetworkInfoFromBlob(pTable->hBlobs[i], &ni);

        if(dwStatus == NMERR_SUCCESS)
        {
            if(NMERR_SUCCESS != GetBoolFromBlob( pTable->hBlobs[i],
                        OWNER_NPP,
                        CATEGORY_LOCATION, //CATEGORY_NETWORKINFO, 
                        TAG_RAS,
                        &bRas)) 
            {
                DestroyBlob(hBlob);
                return FALSE;
            }  

            if(bRas) 
            {
                hLanAr[dwLanCount].hBlob=pTable->hBlobs[i];
                hLanAr[dwLanCount++].bWan=TRUE;
            
            } else {

                const CHAR *pString=NULL;

                GetStringFromBlob(pTable->hBlobs[i], OWNER_NPP, CATEGORY_LOCATION, TAG_MACADDRESS, &pString);            
                                    
                // use this interface only if the mac type
                // is one of the following:
                if(ni.MacType == MAC_TYPE_ETHERNET ||
                   ni.MacType == MAC_TYPE_TOKENRING ||
                   ni.MacType == MAC_TYPE_ATM)
                {
                    if(pString)
                    {                                                                                                        
                        if((hLanAr[dwLanCount].pszMacAddr = (WCHAR *)LocalAlloc(LMEM_ZEROINIT, sizeof(WCHAR) * (lstrlenA(pString)+1)))
                            != NULL)
                        {
                            mbstowcs(hLanAr[dwLanCount].pszMacAddr, pString, lstrlenA(pString)); 
                        }
                    }

                    hLanAr[dwLanCount++].hBlob = pTable->hBlobs[i];

                }
            }                                        

        } else {
            
            DestroyBlob(hBlob);
            return FALSE;
        }

    }
    DestroyBlob(hBlob);

    if(dwLanCount)
    {
        *pdwLanCount = dwLanCount;
        *hLAN = hLanAr;
    }                  
    return TRUE;

}

BOOL
InitIDelaydC(HBLOB hBlob, IDelaydC **ppIDelaydC)
{
    DWORD       dwStatus;
    const char *sterrLSID;
    IDelaydC    *pIDelaydC=NULL;

    if(NMERR_SUCCESS != GetStringFromBlob(hBlob,OWNER_NPP,CATEGORY_LOCATION,TAG_CLASSID,&sterrLSID))
    {
        return FALSE;
    }

    dwStatus = CreateNPPInterface(hBlob,IID_IDelaydC,(void**)&pIDelaydC);
    
    if(dwStatus != NMERR_SUCCESS)
    {
        return FALSE;
    }

    dwStatus = pIDelaydC->Connect(hBlob,NULL,NULL,NULL);
    
    if(dwStatus != NMERR_SUCCESS)
    {
        return FALSE;
    }

    *ppIDelaydC = pIDelaydC; 

    return TRUE;

}

BOOL
DiagStartCapturing(PRASDIAGCAPTURE pNetInterfaces, DWORD dwNetCount)
{
    DWORD i,dwStatus;

    // Set filters/Start captures
    for(i=0;i<dwNetCount;i++)
    {
        // Set filters only on LAN interfaces
        if(!pNetInterfaces[i].bWan)
        {
            // If SetAddressFilter() fails, that's OK b/c we'll just get more info in the capture
            SetAddressFilter(pNetInterfaces[i].hBlob);
        }   

        // Initialize this interface...
        if(InitIDelaydC(pNetInterfaces[i].hBlob, &pNetInterfaces[i].pIDelaydC))
        {
            CHAR szCaptureFileName[MAX_PATH+1];
            
            if((dwStatus = pNetInterfaces[i].pIDelaydC->Start(szCaptureFileName)) 
               != NMERR_SUCCESS)
            {
                pNetInterfaces[i].pIDelaydC->Disconnect();
                return FALSE;
            } else {
                // Store this string in unicode 
                mbstowcs(pNetInterfaces[i].szCaptureFileName, szCaptureFileName, lstrlenA(szCaptureFileName));
            }
        
        } else {

            DWORD   n;
            
            // need to halt captures, cleanup...
            for(n=0;n<i;n++)
            {
                pNetInterfaces[n].pIDelaydC->Stop(&pNetInterfaces[n].stats);
                pNetInterfaces[n].pIDelaydC->Disconnect();
            }
            return FALSE;   
        }
    }
    return TRUE;
}

BOOL
NetmonCleanup(PRASDIAGCAPTURE pNetInterfaces, DWORD dwNetCount)
{
    // Since Disconnect() does all cleanup, all we need to do is free the array
    if(pNetInterfaces) LocalFree(pNetInterfaces);
    return TRUE;
}

BOOL
MoveCaptureFile(PRASDIAGCAPTURE pCapInfo, DWORD dwCapCount, SYSTEMTIME *pDiagTime, WCHAR *pszRasDiagDir)
{
    WCHAR       szDstPath[MAX_PATH+1];

    wsprintf(szDstPath, TEXT("%s\\%04d%02d%02d-%02d%02d%02d_%s_%02d.CAP"),
             pszRasDiagDir,
             pDiagTime->wYear,
             pDiagTime->wMonth,
             pDiagTime->wDay,
             pDiagTime->wHour,
             pDiagTime->wMinute,
             pDiagTime->wSecond,
             pCapInfo->bWan ? TEXT("WAN") : TEXT("LAN"),
             dwCapCount);

    if(CopyFile(pCapInfo->szCaptureFileName, szDstPath, FALSE) == FALSE) {
        return FALSE;
    }

    // Old file is no longer necessary
    DeleteFile(pCapInfo->szCaptureFileName);

    lstrcpy(pCapInfo->szCaptureFileName,szDstPath);

    return TRUE;
}

BOOL
DiagStopCapturing(PRASDIAGCAPTURE pNetInterfaces, DWORD dwNetCount, SYSTEMTIME *pDiagTime, WCHAR*szRasDiagDir)
{
    DWORD i,dwStatus,dwCapCount=0;

    // Stop the captures
    for(i=0;i<dwNetCount;i++)
    {
        dwStatus = pNetInterfaces[i].pIDelaydC->Stop(&pNetInterfaces[i].stats);
        if(dwStatus != NMERR_SUCCESS)
        {
            pNetInterfaces[i].pIDelaydC->Disconnect();
            return FALSE;
        }

        if(pNetInterfaces[i].stats.TotalBytesCaptured)
        {
            // have capture.. now rename sensibly & move...
            MoveCaptureFile(&pNetInterfaces[i], ++dwCapCount, pDiagTime, szRasDiagDir);

        } else {
            pNetInterfaces[i].szCaptureFileName[0] = L'\0';
        }

        // Disconnect
        if(pNetInterfaces[i].pIDelaydC)
        {
            pNetInterfaces[i].pIDelaydC->Disconnect();
        }                                             
    }           
    return TRUE;
}

BOOL
SetAddressFilter(HBLOB hBlob)
{
    ADDRESSTABLE    at;
    NETWORKINFO     ni;
    DWORD rc;

    if(GetNetworkInfoFromBlob(hBlob,&ni) != NMERR_SUCCESS)
    {
        return FALSE;
    }

    ZeroMemory(&at, sizeof(ADDRESSTABLE));

    // 2 address pairs...
    at.nAddressPairs = 2;

    // Set src filter -> any frame with src address == this interface's mac addr
    at.AddressPair[0].AddressFlags = ADDRESS_FLAGS_MATCH_SRC;
    memcpy(&at.AddressPair[0].SrcAddress.MACAddress, &ni.CurrentAddr, MAC_ADDRESS_SIZE);
    at.AddressPair[0].SrcAddress.Type = ADDRESS_TYPE_ETHERNET;

    at.AddressPair[1].AddressFlags = ADDRESS_FLAGS_MATCH_DST;
    memcpy(&at.AddressPair[1].DstAddress.MACAddress, &ni.CurrentAddr, MAC_ADDRESS_SIZE);
    at.AddressPair[1].DstAddress.Type = ADDRESS_TYPE_ETHERNET;

    if((rc=SetNPPAddressFilterInBlob(hBlob,&at)) != NMERR_SUCCESS)
    {
        return FALSE;
    }
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\rasdiag\private\trace.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       T R A C E . H
//
//  Contents:   Class definition for CTracing
//
//  Notes:
//
//  Author:     jeffspr   15 Apr 1997
//
//----------------------------------------------------------------------------

#pragma once

#include "tracetag.h"
#include "stldeque.h"

#ifdef ENABLETRACE

// This is needed for TraceHr, since we can't use a macro (vargs), but we
// need to get the file and line from the source.
#define FAL __FILE__,__LINE__,__FUNCTION__

// The Trace Stack functions
#if defined (_IA64_)
#include <ia64reg.h>

extern "C" unsigned __int64 __getReg(int whichReg);
extern "C" void __setReg(int whichReg, __int64 value);
#pragma intrinsic(__getReg)
#pragma intrinsic(__setReg)

#define GetR32 __getReg(CV_IA64_IntR32)
#define GetR33 __getReg(CV_IA64_IntR33)
#define GetR34 __getReg(CV_IA64_IntR34)
#endif // defined(_IA64_)

class CTracingIndent;

class CTracingFuncCall
{
public:
#if defined (_X86_) 
    CTracingFuncCall(LPCSTR szFunctionName, LPCSTR szFunctionDName, LPCSTR szFile, const DWORD dwLine, const DWORD dwFramePointer);
#elif defined (_IA64_) 
    CTracingFuncCall(LPCSTR szFunctionName, LPCSTR szFunctionDName, LPCSTR szFile, const DWORD dwLine, const __int64 Args1, const __int64 Args2, const __int64 Args3);
#else
    CTracingFuncCall(LPCSTR szFunctionName, LPCSTR szFunctionDName, LPCSTR szFile, const DWORD dwLine);
#endif
    
    CTracingFuncCall(const CTracingFuncCall& TracingFuncCall);
    ~CTracingFuncCall();

public:
    LPSTR   m_szFunctionName;
    LPSTR   m_szFunctionDName;
    LPSTR   m_szFile;
    DWORD   m_dwLine;

#if defined (_X86_) 
    DWORD   m_arguments[3];
#elif defined (_IA64_ )
    __int64 m_arguments[3];
#else
    // ... add other processors here
#endif

    DWORD   m_dwFramePointer;
    DWORD   m_dwThreadId;
    
    friend CTracingIndent;
};

class CTracingThreadInfo
{
public:
    CTracingThreadInfo();
    ~CTracingThreadInfo();

public:
    LPVOID m_pfnStack;
    DWORD m_dwLevel;
    DWORD m_dwThreadId;
    friend CTracingIndent;
};

class CTracingIndent
{
    LPSTR   m_szFunctionDName;
    DWORD   m_dwFramePointer;
    BOOL    bFirstTrace;
    
public:
#if defined (_X86_) 
    void AddTrace(LPCSTR szFunctionName, LPCSTR szFunctionDName, LPCSTR szFile, const DWORD dwLine, const DWORD dwFramePointer);
#elif defined (_IA64_) 
    void AddTrace(LPCSTR szFunctionName, LPCSTR szFunctionDName, LPCSTR szFile, const DWORD dwLine, const __int64 Args1, const __int64 Args2, const __int64 Args3);
#else
    void AddTrace(LPCSTR szFunctionName, LPCSTR szFunctionDName, LPCSTR szFile, const DWORD dwLine);
#endif
    void RemoveTrace(LPCSTR szFunctionDName, const DWORD dwFramePointer);

    CTracingIndent();
    ~CTracingIndent();

    static CTracingThreadInfo* GetThreadInfo();
    static DWORD getspaces();
    static void TraceStackFn(TRACETAGID TraceTagId);
};


#define IDENT_ADD2(x) indent ## x
#define IDENT_ADD(x)  IDENT_ADD2(x)
#define __INDENT__ IDENT_ADD(__LINE__)

#define FP_ADD2(x) FP ## x
#define FP_ADD(x)  FP_ADD2(x)
#define __FP__ FP_ADD(__LINE__)

#if defined (_X86_) 
#define AddTraceLevel \
    __if_not_exists(NetCfgFramePointer) \
    { \
        DWORD NetCfgFramePointer;  \
        BOOL fForceC4715Check = TRUE;  \
    } \
    if (fForceC4715Check) \
    { \
        __asm { mov NetCfgFramePointer, ebp }; \
    } \
    __if_not_exists(NetCfgIndent) \
    { \
        CTracingIndent NetCfgIndent; \
    } \
    NetCfgIndent.AddTrace(__FUNCTION__, __FUNCDNAME__, __FILE__, __LINE__, NetCfgFramePointer);
#elif defined (_IA64_) 
#define AddTraceLevel \
    __if_not_exists(NetCfgIndent) \
    { \
        CTracingIndent NetCfgIndent; \
    } \
    NetCfgIndent.AddTrace(__FUNCTION__, __FUNCDNAME__, __FILE__, __LINE__, GetR32, GetR33, GetR34);
#else
#define AddTraceLevel \
    __if_not_exists(NetCfgIndent) \
    { \
        CTracingIndent NetCfgIndent; \
    } \
    NetCfgIndent.AddTrace(__FUNCTION__, __FUNCDNAME__, __FILE__, __LINE__);
#endif

// Trace error functions. The leaading _ is to establish the real function,
// while adding a new macro so we can add __FILE__ and __LINE__ to the output.
//
VOID    WINAPI   TraceErrorFn           (PCSTR pszaFile, INT nLine, PCSTR psza, HRESULT hr);
VOID    WINAPI   TraceErrorOptionalFn   (PCSTR pszaFile, INT nLine, PCSTR psza, HRESULT hr, BOOL fOpt);
VOID    WINAPI   TraceErrorSkipFn       (PCSTR pszaFile, INT nLine, PCSTR psza, HRESULT hr, UINT c, ...);
VOID    WINAPIV  TraceLastWin32ErrorFn  (PCSTR pszaFile, INT nLine, PCSTR psza);

#define TraceError(sz, hr)                      TraceErrorFn(__FILE__, __LINE__, sz, hr);
#define TraceErrorOptional(sz, hr, _bool)       TraceErrorOptionalFn(__FILE__, __LINE__, sz, hr, _bool);
#define TraceErrorSkip1(sz, hr, hr1)            TraceErrorSkipFn(__FILE__, __LINE__, sz, hr, 1, hr1);
#define TraceErrorSkip2(sz, hr, hr1, hr2)       TraceErrorSkipFn(__FILE__, __LINE__, sz, hr, 2, hr1, hr2);
#define TraceErrorSkip3(sz, hr, hr1, hr2, hr3)  TraceErrorSkipFn(__FILE__, __LINE__, sz, hr, 3, hr1, hr2, hr3);
#define TraceLastWin32Error(sz)                 TraceLastWin32ErrorFn(__FILE__,__LINE__, sz);

VOID
WINAPIV
TraceHrFn (
    TRACETAGID  ttid,
    PCSTR       pszaFile,
    INT         nLine,
    HRESULT     hr,
    BOOL        fIgnore,
    PCSTR       pszaFmt,
    ...);

VOID
WINAPIV
TraceHrFn (
    TRACETAGID  ttid,
    PCSTR       pszaFile,
    INT         nLine,
    PCSTR       pszaFunc,
    HRESULT     hr,
    BOOL        fIgnore,
    PCSTR       pszaFmt,
    ...);

VOID
WINAPIV
TraceTagFn (
    TRACETAGID  ttid,
    PCSTR       pszaFmt,
    ...);

VOID
WINAPIV
TraceFileFuncFn (
            TRACETAGID  ttid);

#define TraceFileFunc(ttidWhich) AddTraceLevel; TraceFileFuncFn(ttidWhich);
#define TraceStack(ttidWhich) AddTraceLevel; CTracingIndent::TraceStackFn(ttidWhich);
#define TraceHr AddTraceLevel; TraceHrFn
#define TraceTag AddTraceLevel; TraceTagFn

#define TraceException(hr, szExceptionName) TraceHr(ttidError, FAL, hr, FALSE, "A (%s) exception occurred", szExceptionName);

LPCSTR DbgEvents(DWORD Event);
LPCSTR DbgEventManager(DWORD EventManager);
LPCSTR DbgNcm(DWORD ncm);
LPCSTR DbgNcs(DWORD ncs);
LPCSTR DbgNccf(DWORD nccf);
LPCSTR DbgNcsm(DWORD ncsm);

#else   // !ENABLETRACE

#define FAL                                         (void)0
#define TraceError(_sz, _hr)
#define TraceErrorOptional(_sz, _hr, _bool)
#define TraceErrorSkip1(_sz, _hr, _hr1)
#define TraceErrorSkip2(_sz, _hr, _hr1, _hr2)
#define TraceErrorSkip3(_sz, _hr, _hr1, _hr2, _hr3)
#define TraceLastWin32Error(_sz)
#define TraceHr                                     NOP_FUNCTION
#define TraceTag                                    NOP_FUNCTION
#define TraceFileFunc(ttidWhich)                    NOP_FUNCTION
#define TraceException(hr, szExceptionName)         NOP_FUNCTION
#define TraceStack(ttidWhich)                       NOP_FUNCTION

#define DbgEvents(Event) ""
#define DbgEventManager(EventManager) ""
#define DbgNcm(ncm) ""
#define DbgNcs(ncs) ""
#define DbgNccf(nccf) ""
#define DbgNcsm(nccf) ""

#endif  // ENABLETRACE

#ifdef ENABLETRACE


//---[ Initialization stuff ]-------------------------------------------------

HRESULT HrInitTracing();
HRESULT HrUnInitTracing();
HRESULT HrOpenTraceUI(HWND  hwndOwner);

#endif // ENABLETRACE
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\rasdiag\private\tracetag.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       T R A C E T A G . H
//
//  Contents:   Trace tag definitions for the Netcfg project
//
//  Notes:      B-flat, C-sharp
//
//  Author:     jeffspr   9 Apr 1997
//
//----------------------------------------------------------------------------

#pragma once
#ifndef _TRACETAG_H_
#define _TRACETAG_H_


// TraceTagIds are the identifiers for tracing areas, and are used in calls
// to TraceTag.  We need this defined outside of of ENABLETRACE so that
// calls to the TraceTag macro don't break when ENABLETRACE is not defined.
//
// Hungarian == ttid
//
enum TraceTagId
{
    ttidDefault         = 0,
    ttidAdvCfg,
    ttidAnswerFile,
    ttidAtmArps,
    ttidAtmLane,
    ttidAtmUni,
    ttidBeDiag,
    ttidBenchmark,
    ttidBrdgCfg,
    ttidClassInst,
    ttidConFoldEntry,
    ttidConman,
    ttidConnectionList,
    ttidDHCPServer,
    ttidDun,
    ttidEAPOL,
    ttidError,
    ttidEsLock,
    ttidEvents,
    ttidFilter,
    ttidGPNLA,
    ttidGuiModeSetup,
    ttidIcons,
    ttidInfExt,
    ttidInstallQueue,
    ttidISDNCfg,
    ttidLana,
    ttidLanCon,
    ttidLanUi,
    ttidMenus,
    ttidMSCliCfg,
    ttidNcDiag,
    ttidNetAfx,
    ttidNetBios,
    ttidNetComm,
    ttidNetOc,
    ttidNetSetup,
    ttidNetUpgrade,
    ttidNetcfgBase,
    ttidNetCfgBind,
    ttidNetCfgPnp,
    ttidNotifySink,
    ttidNWClientCfg,
    ttidNWClientCfgFn,
    ttidRasCfg,
    ttidSFNCfg,
    ttidSecTest,
    ttidShellEnum,
    ttidShellFolder,
    ttidShellFolderIface,
    ttidShellViewMsgs,
    ttidSrvrCfg,
    ttidStatMon,
    ttidSvcCtl,
    ttidSystray,
    ttidTcpip,
    ttidWanCon,
    ttidWanOrder,
    ttidWizard,
    ttidWlbs, /* maiken 5.25.00 */
    ttidWmi   /* AlanWar */
};


// Just for kicks
//
typedef enum TraceTagId TRACETAGID;

#ifdef ENABLETRACE

// Maximum sizes for the trace tag elements.
const int c_iMaxTraceTagShortName   = 16;
const int c_iMaxTraceTagDescription = 128;

// For each element in the tracetag list
//
struct TraceTagElement
{
    TRACETAGID  ttid;
    CHAR        szShortName[c_iMaxTraceTagShortName+1];
    CHAR        szDescription[c_iMaxTraceTagDescription+1];
    BOOL        fOutputDebugString;
    BOOL        fOutputToFile;
    BOOL        fVerboseOnly;
};

typedef struct TraceTagElement  TRACETAGELEMENT;

//---[ Externs ]--------------------------------------------------------------

extern TRACETAGELEMENT      g_TraceTags[];
extern const INT            g_nTraceTagCount;

#endif // ENABLETRACE

#endif  // _TRACETAG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\rasdiag\rasdiag\event.cpp ===
/*++

Copyright (C) 1992-01 Microsoft Corporation. All rights reserved.

Module Name:

    event.cpp

Abstract:

    Implements audit-enabling and event code for l2tp/ipsec diag info

Author:

    Anthony Leibovitz (tonyle) 02-01-2001

Revision History:


--*/

#include <stdio.h>
#include <stdlib.h>
#include <nt.h>
#include <ntlsa.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include "diagcommon.h"
#include "event.h"

BOOL
GetEventLogInfo(HANDLE hWriteFile, DWORD dwMaxEvents)
{
    HANDLE  hLog;
    DWORD   dwBytesToRead=0,dwBytesRead=0,dwMinNumberOfBytesNeeded=0;
    LPBYTE  pEventLog=NULL;
    DWORD   dwBytesWritten;
    DWORD   dwEvtCount=0;
    BOOL    bContinue=TRUE;

    if((hLog =  OpenEventLog(NULL, SECURITY_LOGNAME))
       == NULL) return FALSE;

    dwBytesToRead = sizeof(EVENTLOGRECORD) * MAX_EVENT_BUFF; 

    if((pEventLog=(LPBYTE)LocalAlloc(LMEM_ZEROINIT, dwBytesToRead))
       == NULL) {
        CloseEventLog(hLog);
        return FALSE;
    }                                                            

    PrintLogHeader(hWriteFile, TEXT("SECURITY EVENTLOG (Last %d events)\r\n"), dwMaxEvents);
    
    while(bContinue)
    {
        if(ReadEventLog(hLog,
                           EVENTLOG_SEQUENTIAL_READ | EVENTLOG_BACKWARDS_READ,
                           0,
                           (LPVOID)pEventLog,
                           dwBytesToRead,
                           &dwBytesRead,
                           &dwMinNumberOfBytesNeeded))
        {
            LPBYTE          pRecord;
            DWORD           dwTotBuffRemaining;
            
            for(pRecord=pEventLog,
                dwTotBuffRemaining=dwBytesRead;
                dwTotBuffRemaining;
                dwTotBuffRemaining -= ((EVENTLOGRECORD*)pRecord)->Length,
                pRecord += ((EVENTLOGRECORD*)pRecord)->Length)
            {
                EVENTLOGRECORD *pElr=(EVENTLOGRECORD*)pRecord;
            
                ProcessEvent(hWriteFile, pElr);
    
                if(dwEvtCount++ > dwMaxEvents) break;
    
            }
        } else {

            DWORD dwRet = GetLastError();

            if(dwRet == ERROR_INSUFFICIENT_BUFFER)
            {
                LPBYTE  pNew;

                if((pNew=(LPBYTE)LocalReAlloc(pEventLog, dwMinNumberOfBytesNeeded, LMEM_ZEROINIT|LMEM_MOVEABLE))
                   == NULL) {
                    bContinue = FALSE;
                    break;
                }                     
                pEventLog = pNew;
            } else {

                bContinue=FALSE;
            }
        }
    
    }

    LocalFree(pEventLog);

    CloseEventLog(hLog);
        
    return TRUE;

}

BOOL
ProcessEvent(HANDLE hWriteFile, EVENTLOGRECORD *pElr)
{
    LPBYTE  pInsert;
    LPBYTE  pTemplateString;
    DWORD   i,dwBytesWritten;
    HMODULE hMod;
    WCHAR   **pStringAry=NULL;
    DWORD   dwStrCount=0;

    if((hMod=LoadLibrary(SECURITY_AUDIT_INSERTION_LIB))
       == NULL) return FALSE; 
        
    if(FormatMessage((FORMAT_MESSAGE_FROM_SYSTEM|FORMAT_MESSAGE_IGNORE_INSERTS|FORMAT_MESSAGE_ALLOCATE_BUFFER|FORMAT_MESSAGE_FROM_HMODULE),
                       hMod,pElr->EventID,0,(LPTSTR)&pTemplateString,0,NULL) > 0) 
    {   
        if(CreateStringArray((LPBYTE)pElr + pElr->StringOffset,pElr->NumStrings, &pStringAry, &dwStrCount))
        {
            WCHAR   *pStr;
    
            pStr=ResolveEvent((WCHAR *)pTemplateString, pStringAry, dwStrCount);
    
            if(pStr) {
                
                WCHAR *   pFmtBuf;
                
                pStr = RemoveMiscChars(pStr);
                                       
                if((pFmtBuf=(WCHAR *)LocalAlloc(LMEM_ZEROINIT,((lstrlen(pStr)+lstrlen(EVENT_FORMAT_STRING)+1)*sizeof(WCHAR)*2)))
                   != NULL)
                {
                    
                    Logprintf(hWriteFile, EVENT_FORMAT_STRING,pElr->EventID, (LPBYTE)pElr+sizeof(EVENTLOGRECORD), pStr); 
                    
                    LocalFree(pFmtBuf);
                }

                LocalFree(pStr);

            }
        
            MyFreeStrings(pStringAry, dwStrCount);
        }
    
    } 

    Logprintf(hWriteFile, LOG_SEPARATION_TXT);

    FreeLibrary(hMod);

    return TRUE;
}


BOOL
CreateStringArray(LPBYTE pSrcString, DWORD dwStringCount, WCHAR ***ppStrings, DWORD *pdwCount)
{
   DWORD i;
   WCHAR *pSrcString2=(WCHAR*)pSrcString;
   WCHAR **pStrs;

   // Eventlog record reports str count...
   if(dwStringCount==0)
   {
      *pdwCount=0;
      *ppStrings=NULL;
      return TRUE;
   }

   // Alloc array for strings
   if((*ppStrings = pStrs = (WCHAR**)LocalAlloc(LMEM_ZEROINIT, sizeof(WCHAR *) * dwStringCount))
      == NULL) return FALSE;

   // Store string pointers
   for(i=0;i<dwStringCount;i++)
   {
      pStrs[i] = pSrcString2;
      while ( *pSrcString2++ != L'\0' );
   }
   *pdwCount = i;
   return TRUE;
}

ULONG
SumInsertionSize(WCHAR * *ppInsertionString, DWORD dwStrCount)
{
   DWORD i;
   DWORD dwSize=0;

   for(i=0;i<dwStrCount;i++)
   {
      dwSize += lstrlen(ppInsertionString[i])+1;
   }
   return dwSize;
}


WCHAR *
ResolveEvent(WCHAR * pTemplateStr, WCHAR * *ppInsertionString, DWORD dwStrCount)
{
   WCHAR *   pCpyStr=NULL, *pFinalStr=NULL, *pPtr=NULL;
   DWORD    i,dwTempLen,iPos,dwMaxSize;

   /*
    * Estimate size...
    * Most events will use each insert one time... therefore, the min string size will be something
    * like len(insert strings) + their nulls + len(template string) + its null - all of which
    * multiplied by the sizeof WCHAR... I've doubled this size just in case.
   */
   dwTempLen = lstrlen(pTemplateStr) + 1;
   dwMaxSize = (SumInsertionSize(ppInsertionString, dwStrCount) + dwTempLen)*10; // 10x the size

   if((pPtr = pFinalStr = (WCHAR *)LocalAlloc(LMEM_ZEROINIT, sizeof(WCHAR) * dwMaxSize))
      == NULL) return NULL;
                       
   for(i=0,iPos=0;i<dwTempLen;i++)
   {
      if(pTemplateStr[i] == L'%') 
      {
         if(pTemplateStr[i+1] >= L'0' &&
            pTemplateStr[i+1] <= L'9') // this is a number
         {
            WCHAR *pNumStart=&pTemplateStr[i+1];
            WCHAR num[MAX_TCHAR_ID_ULONG_SIZE];         
            ULONG val=0,n=0;
   
            //
            // get the insertion string index
            //
            while((*pNumStart >= L'0' && *pNumStart <= L'9') &&
                  *pNumStart != L'\0' && n<MAX_TCHAR_ID_ULONG_SIZE) {
               num[n++] = *pNumStart++;   
            }         
            num[n] = L'\0'; // terminate string
            
            // convert index to number less one (zero-based index)
            val = wcstol(num, NULL, 10) - 1;

            // if the index is in range, insert the string
            if(val < dwStrCount)
            {  
               WCHAR *pInsert=ppInsertionString[val];
   
               // copy the string into the buffer
               while(*pInsert != L'\0') {
                  pPtr[iPos++] = *pInsert++;
                  if(!(iPos<dwMaxSize)) {
                     LocalFree(pFinalStr);
                     return NULL;
                  }
               }
            }

            i+=n; // move the cpy ptr past the number... ptr is incremented past pcnt
                  // on next iteration 
            
         } else 
            pPtr[iPos++] = pTemplateStr[i++];
            
         
      } else pPtr[iPos++] = pTemplateStr[i];

      // check size of buffer
      if(!(iPos<dwMaxSize)) {
         LocalFree(pFinalStr);
         return NULL;
      }                      
   }                         
   
   //
   // Save some memory...
   //
   if((pPtr=(WCHAR*)LocalAlloc(LMEM_ZEROINIT, (lstrlen(pFinalStr)+1) * sizeof(WCHAR)))
      == NULL) return pFinalStr;

   lstrcpy(pPtr, pFinalStr);
   LocalFree(pFinalStr);

   return pPtr;
   
}



WCHAR *
RemoveMiscChars(WCHAR *pString)
{
   WCHAR *pNew;
   ULONG i,iSize,iPos;
   
   // Get length
   iSize = lstrlen(pString);

   // Alloc work buffer
   if((pNew=(WCHAR*)LocalAlloc(LMEM_ZEROINIT, (iSize+1)*sizeof(WCHAR)))
      == NULL) return pString;

   // Remove tabs, linefeeds, etc.
   for(i=0; i<iSize ; i++)
   {
      switch(pString[i])
      {   
      
      case L'\n':
      case L'\r':
      case L'\t':
          pString[i]=L' ';
          break;          
      }
   
   }                  
   
   // Remove extraneous spaces
   for(i=0,iPos=0;i<iSize;i++)
   {
       if(pString[i] == L' ')
       {
           while(pString[i+1] == L' ' && i<iSize)
           {
               i++;
           }
       }
       pNew[iPos++] = pString[i];
   }

   lstrcpy(pString,pNew);

   LocalFree(pNew);

   return pString;
}

void
MyFreeStrings(WCHAR **pStringAry, DWORD dwCount)
{                  
   if(dwCount == 0) return;
   if (pStringAry) LocalFree(pStringAry);
}

BOOL
EnableAuditing(BOOL bEnable)
{
    LSA_HANDLE                      policy_handle;
    POLICY_AUDIT_EVENT_OPTIONS      options[1];
    PPOLICY_AUDIT_EVENTS_INFO        info;
    OBJECT_ATTRIBUTES               obj_attr;
    SECURITY_QUALITY_OF_SERVICE     sqos;
    DWORD                           result,i;

    InitializeObjectAttributes(& obj_attr, NULL, 0L, 0L, NULL);
    
    sqos.Length = sizeof(sqos);
    sqos.ImpersonationLevel = SecurityIdentification;
    sqos.ContextTrackingMode = SECURITY_STATIC_TRACKING;
    sqos.EffectiveOnly = FALSE;
    
    obj_attr.SecurityQualityOfService = & sqos;
    
    /* First open the local LSA policy */
    
    result = LsaOpenPolicy(NULL,& obj_attr,
                           POLICY_VIEW_AUDIT_INFORMATION | 
                           POLICY_SET_AUDIT_REQUIREMENTS | 
                           POLICY_AUDIT_LOG_ADMIN,
                           &policy_handle);
    
    if (! NT_SUCCESS(result))
    {
        LsaClose(policy_handle);
        return FALSE;
    }


    result = LsaQueryInformationPolicy(policy_handle, PolicyAuditEventsInformation, (PVOID *)&info);
    if (! NT_SUCCESS(result))
    {
        LsaClose(policy_handle);
        return FALSE;
    }        
    
    // Set the audit mode
    info->AuditingMode = (BOOLEAN)bEnable;
        
    for(i=0;i<info->MaximumAuditEventCount;i++)
    {
        if(i == AuditCategoryAccountLogon)
        {
            if(bEnable)
            {
                info->EventAuditingOptions[i] = POLICY_AUDIT_EVENT_FAILURE|POLICY_AUDIT_EVENT_SUCCESS; 
            
            } else {

                info->EventAuditingOptions[i] = POLICY_AUDIT_EVENT_NONE; 
            }
        }                                                                                        
        
        if(i == AuditCategoryLogon)
        {
            if(bEnable)
            {
                info->EventAuditingOptions[i] = POLICY_AUDIT_EVENT_FAILURE|POLICY_AUDIT_EVENT_SUCCESS; 
            
            } else {

                info->EventAuditingOptions[i] = POLICY_AUDIT_EVENT_NONE; 
            }
        }                                                                                        
    }
    
    result = LsaSetInformationPolicy(policy_handle, PolicyAuditEventsInformation, (PVOID)info);
    
    if (! NT_SUCCESS(result))
    {
        LsaClose(policy_handle);
        return FALSE;
    }                                                
    LsaClose(policy_handle);
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\rasdiag\rasdiag\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by rasdiag.rc
//
#define IDS_USER_INPUT_STRING           1
#define IDS_USER_PREPARING_CLIENT       2
#define IDS_USER_WORKING                3
#define IDS_USER_DOT                    4
#define IDS_USER_WRONGFILEVER           5
#define IDS_USER_NOTRASDIAGFILE         6
#define IDS_USER_UNPACKING_FILE         7
#define IDS_USER_COULDNOTUNPACKFILE     8
#define IDI_X                           102

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NO_MFC                     1
#define _APS_NEXT_RESOURCE_VALUE        103
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\rasdiag\rasdiag\rasdiag.cpp ===
/*++

Copyright (C) 1992-2001 Microsoft Corporation. All rights reserved.

Module Name:

    rasdiag.cpp

Abstract:

    Module implementing core rasdiag functionality
                                                     

Author:

    Anthony Leibovitz (tonyle) 02-01-2001

Revision History:


--*/

#include <conio.h>
#include <stdio.h>
#include <stdarg.h>
#include <stdlib.h>
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <shlobj.h>
#include <lmcons.h>
#include <userenv.h>
#include <ras.h>
#include <raserror.h>
#include <process.h>
#include <netmon.h>
#include <ncdefine.h>
#include <ncmem.h>
#include <diag.h>
#include <winsock.h>
#include <devguid.h>
#include "rasdiag.h"
#include "event.h"
#include "resource.h"

#include "rsniffclnt.h"

#ifdef BUILD_RSNIFF
#include "rsniffclnt.cpp"
#endif

struct {
   WCHAR * pszTraceType;
   WCHAR * pszKey;
   BOOL  fDefaultState;
} Logs[] = {

   TEXT("BAP"),
   TEXT("BAP"),
   TRUE,

   TEXT("RASMAN"),
   TEXT("RASMAN"),
   TRUE,
   
   TEXT("EAPOL"),
   TEXT("EAPOL"),
   TRUE,
   
   TEXT("IASHLPR"),
   TEXT("IASHLPR"),
   TRUE,

   TEXT("IASRAD"),
   TEXT("IASRAD"),
   TRUE,
   
   TEXT("IASSAM"),
   TEXT("IASSAM"),
   TRUE,

   TEXT("IASSDO"),
   TEXT("IASSDO"),
   TRUE,

   TEXT("IPMGM"),
   TEXT("IPMGM"),
   TRUE,

   TEXT("KMDDSP"),
   TEXT("KMDDSP"),
   TRUE,

   TEXT("NDPTSP"),
   TEXT("NDPTSP"),
   TRUE,

   TEXT("RASADHLP"),
   TEXT("RASADHLP"),
   TRUE,

   TEXT("RASDLG"),
   TEXT("RASDLG"),
   TRUE,

   TEXT("RASPHONE"),
   TEXT("RASPHONE"),
   TRUE,

   TEXT("TAPISRV"),
   TEXT("TAPISRV"),
   TRUE,

   TEXT("TAPI32"),
   TEXT("TAPI32"),
   TRUE,

   TEXT("TAPI3"),
   TEXT("TAPI3"),
   TRUE,

   TEXT("RASTLSUI"),
   TEXT("RASTLSUI"),
   TRUE,

   TEXT("RASSPAP"),
   TEXT("RASSPAP"),
   TRUE,

   TEXT("RASSCRIPT"),
   TEXT("RASSCRIPT"),
   TRUE,

   TEXT("RASTAPI"),
   TEXT("RASTAPI"),
   TRUE,

   TEXT("IPRouterManager"),
   TEXT("IPRouterManager"),
   TRUE,
   
   TEXT("PPP"),
   TEXT("PPP"),
   TRUE,

   TEXT("RASAPI32"),
   TEXT("RASAPI32"),
   TRUE,

   TEXT("RASAUTH"),
   TEXT("RASAUTH"),
   TRUE,

   TEXT("RASBACP"),
   TEXT("RASBACP"),
   TRUE,

   TEXT("RASCCP"),
   TEXT("RASCCP"),
   TRUE,

   TEXT("RASCHAP"),
   TEXT("RASCHAP"),
   TRUE,

   TEXT("RASEAP"),
   TEXT("RASEAP"),
   TRUE,

   TEXT("RASIPCP"),
   TEXT("RASIPCP"),
   TRUE,

   TEXT("RASIPHLP"),
   TEXT("RASIPHLP"),
   TRUE,
   
   TEXT("RASNBFCP"),
   TEXT("RASNBFCP"),
   TRUE,

   TEXT("RASPAP"),
   TEXT("RASPAP"),
   TRUE,

   TEXT("RASTLS"),
   TEXT("RASTLS"),
   TRUE,

   TEXT("Router"),
   TEXT("Router"),
   TRUE

};
#define  TOT_LOG_COUNT (sizeof(Logs)/sizeof(Logs[0]))

WCHAR   g_wcRSniff[MAX_PATH+1];
WCHAR   g_wcNetTarget[MAX_PATH+1];

int
__cdecl
wmain(int argc, WCHAR **argv)
{
    RASDIAGCONFIG   *pRdc;
    DWORD           dwOptions=0;
    WCHAR           wcCompleteFn[MAX_PATH+1];
    WCHAR           *pFn=NULL;
    BOOL            bResult;

    SetConsoleCtrlHandler(HandlerRoutine, TRUE);

    // get my path... used to locate file when cracking rdg files
    GetFullPathName(argv[0],MAX_PATH+1, wcCompleteFn, &pFn);
    
    // Find filename & construct path this this file
    pFn = wcCompleteFn + lstrlenW(wcCompleteFn) - 1;

    while(*pFn != ':' && *pFn != '\\' && pFn != wcCompleteFn)
        pFn--;

    if(*pFn == L':') pFn++;

    *pFn = '\0';

    lstrcat(pFn, L"\\RASDIAG.EXE");
                  
    // Create fle association
    RegisterRdgFileAssociation(wcCompleteFn);

    // Process config options
    if(ProcessArgs(argc,argv, &dwOptions) == FALSE) {
        SetConsoleCtrlHandler(HandlerRoutine, FALSE);
        return 0;
    }

    PrintUserMsg(IDS_USER_PREPARING_CLIENT);

    if(StartRasDiag(&pRdc, dwOptions) == FALSE)
    {
        wprintf(L"\nCould not start RASDIAG! (Err=%d)\n", GetLastError());
        SetConsoleCtrlHandler(HandlerRoutine, FALSE);
        return -1;
    }                             

    PrintUserInstructions();
    
    PrintUserMsg(IDS_USER_INPUT_STRING);
    
    // Wait for user input
    _getch();
    
    PrintUserMsg(IDS_USER_WORKING);
    
    bResult = StopRasDiag(pRdc);
    

    SetConsoleCtrlHandler(HandlerRoutine, FALSE);

    return bResult;
}

BOOL
PrintUserMsg(int iMsgID, ...)
{
    WCHAR           MsgBuf[256];
    WCHAR           MsgBuf2[512];
    va_list         marker;
    
    if(!LoadString(GetModuleHandle(NULL), iMsgID, MsgBuf, sizeof(MsgBuf) / sizeof(MsgBuf[0])))
    {   
        return FALSE;
    }   
    
    // form string
    va_start(marker, iMsgID);
    vswprintf(MsgBuf2, MsgBuf, marker);
    va_end(marker);
    
    wprintf(TEXT("%s"), MsgBuf2);
    return TRUE;              
}

BOOL
StartRasDiag(PRASDIAGCONFIG *ppRdc, DWORD dwOptions)
{
    PRASDIAGCONFIG  pRdc;
    DWORD           dwStatus,i;

    // Alloc config structure
    if((pRdc=(PRASDIAGCONFIG)LocalAlloc(LMEM_ZEROINIT, sizeof(RASDIAGCONFIG)))
        == NULL) return FALSE;

    // Store user-requested options
    pRdc->dwUserOptions = dwOptions;

    // Store time of repro
    GetLocalTime(&pRdc->DiagTime);
    
    // Store Windows directory
    if(GetWindowsDirectory(pRdc->szWindowsDirectory, MAX_PATH+1) == 0)
    {
        LocalFree(pRdc);
        return FALSE;
    }
    
    // Store Temp Directory
    if(GetTempPath(MAX_PATH+1, pRdc->szTempDir) == 0)
    {
        LocalFree(pRdc);
        return FALSE;
    }
    
    // Store User and System PBK paths
    if(GetPbkPaths(pRdc->szSysPbk,pRdc->szUserPbk) == FALSE)
    {
        LocalFree(pRdc);
        return FALSE;
    }
                                                                             
    // Store tracing directory
    wsprintf(pRdc->szTracingDir, TEXT("%s\\%s"), pRdc->szWindowsDirectory, TRACING_SUBDIRECTORY);

    // Create RASDIAG directory
    if(CreateRasdiagDirectory(pRdc->szRasDiagDir) == FALSE)
    {
        LocalFree(pRdc);
        return FALSE;
    }
                                                     
    // Get possible CM logs
    DoCMLogSetup(&pRdc->pCmInfo);
                        
    // Disable CM logging
    SetCmLogState(pRdc->pCmInfo, FALSE);

    // Delete logs
    DeleteCMLogs(pRdc->pCmInfo);
    
    // Reenable CM logging
    SetCmLogState(pRdc->pCmInfo, TRUE);
                                                                  
    // enable security auditing in GPO
    EnableAuditing(TRUE);

    // Stop the policy agent service so that the log can be deleted
    if(StopStartService(POLICYAGENT_SVC_NAME, FALSE) == FALSE)
    {
        LocalFree(pRdc);
        return FALSE;
    }

    // Turn off all logs
    SetTracing(FALSE);
    SetModemTracing(FALSE);
    EnableOakleyLogging(FALSE);

    // Delete existing logs
    DeleteTracingLogs(pRdc->szTracingDir);
    DeleteModemLogs(pRdc->szWindowsDirectory);
    DeleteOakleyLog();
    
    // Re-Enable Logging
    EnableOakleyLogging(TRUE);
    SetTracing(TRUE);
    SetModemTracing(TRUE);
                        
    // Restart the policy agent 
    if(StopStartService(POLICYAGENT_SVC_NAME, TRUE) == FALSE)
    {
        LocalFree(pRdc);
        return FALSE;
    }
    
    // Initialize COM for NetMON
    if(FAILED(CoInitialize(NULL))) {
        LocalFree(pRdc);
        return FALSE;
    }
    
    // Do install (or check install)
    if(DoNetmonInstall() == FALSE) {
        CoUninitialize();
        LocalFree(pRdc);
        return FALSE;
    }
    
    // Learn what interfaces exist
    if(IdentifyInterfaces(&pRdc->pNetInterfaces, &pRdc->dwNetCount) == FALSE)
    {
        CoUninitialize();
        LocalFree(pRdc);
        return FALSE;
    }
    
    // Start capturing
    if(DiagStartCapturing(pRdc->pNetInterfaces, pRdc->dwNetCount) == FALSE)
    {
        CoUninitialize();
        NetmonCleanup(pRdc->pNetInterfaces, pRdc->dwNetCount);
        LocalFree(pRdc);
        return FALSE;

    }
    
    if(pRdc->dwUserOptions & RSNIFF_OPT1_DOSNIFF)
    {   
#ifdef BUILD_RSNIFF
        // Failure on setting remote sniff is not fatal to initialization b/c net problems
        // may prevent socket connection (always request sniff here)
        if(DoRemoteSniff(&pRdc->pSockCb, g_wcRSniff, (pRdc->dwUserOptions | RSNIFF_OPT1_DOSNIFF)) == FALSE)
        {
            // could not connect to rsniff; turn this bit off
            pRdc->dwUserOptions &= ~(RSNIFF_OPT1_DOSNIFF);
        } 

#else
        // Since bit is on, turn it off 
        pRdc->dwUserOptions &= ~(RSNIFF_OPT1_DOSNIFF);
        
#endif
    
    }

    // Return ptr to completed config struct
    *ppRdc = pRdc;
    return TRUE;
}

BOOL
StopRasDiag(PRASDIAGCONFIG pRdc)
{
    DWORD i;
    DWORD dwStatus;
    DWORD dwCapCount=0;

#ifdef BUILD_RSNIFF
    if(pRdc->dwUserOptions & RSNIFF_OPT1_DOSNIFF) {
        closesocket(pRdc->pSockCb->s);
        LocalFree(pRdc->pSockCb);
    }
#endif
    

    // Enable CM logging
    SetCmLogState(pRdc->pCmInfo, FALSE);
    
    DiagStopCapturing(pRdc->pNetInterfaces, pRdc->dwNetCount, &pRdc->DiagTime, pRdc->szRasDiagDir);

    SetTracing(FALSE);

    EnableOakleyLogging(FALSE);

    SetModemTracing(FALSE);

    DWORD   iAttempts=0;
    while(!CheckFileAccess(pRdc->szTracingDir) && iAttempts++ < MAX_CHECKFILEACCESS_ATTEMPTS)
       Sleep(750);
    
    // Get routing table, etc
    ExecNetUtils();

    if(pRdc->dwUserOptions & OPTION_DONETTESTS)
    {
        DoNetTests();
    }

    BuildRasDiagLog(pRdc);
    
    FreeCmInfoResources(pRdc->pCmInfo);

    //OpenLogFileWithEditor(pRdc->szRasDiagDir, pRdc->szWindowsDirectory);

    if(BuildPackage(pRdc->pNetInterfaces, pRdc->dwNetCount, pRdc->szRasDiagDir, &pRdc->DiagTime) == FALSE)
    {
        // could not build package... should provide error code
    }

    EnableAuditing(FALSE);

    RaiseFolderUI(pRdc->szRasDiagDir);

    NetmonCleanup(pRdc->pNetInterfaces, pRdc->dwNetCount);
        
    CoUninitialize();

    LocalFree(pRdc);
    return TRUE;
}

BOOL
DoNetTests(void)
{
    // What net tests to do given we don't know net context??
    
    return TRUE;
}

void
ExecNetUtils(void)
{
    // Exec misc utitlities: collect more info
    _wsystem(TEXT("ipconfig /all > ")RASDIAG_NET_TEMP);
    _wsystem(TEXT("route print >> ")RASDIAG_NET_TEMP);
    _wsystem(TEXT("netstat -e >> ")RASDIAG_NET_TEMP);
    _wsystem(TEXT("netstat -o >> ")RASDIAG_NET_TEMP);
    _wsystem(TEXT("netstat -s >> ")RASDIAG_NET_TEMP);
    _wsystem(TEXT("netstat -n >> ")RASDIAG_NET_TEMP);

}

BOOL
DumpProcessInfo(HANDLE hWrite)
{ 

   DWORD       dwNumServices = 0;
   SC_HANDLE   hScm;

   // Connect to the service controller.
   hScm = OpenSCManager(
               NULL,
               NULL,
               SC_MANAGER_CONNECT | SC_MANAGER_ENUMERATE_SERVICE);
   
   if (hScm) 
   {
       // Try a first guess of 2K for the buffer required to satisfy
       // EnumServicesStatusEx.  If that fails, retry with the buffer
       // size returned from EnumServicesStatusEx.
       //
       LPENUM_SERVICE_STATUS_PROCESS   pInfo    = NULL;
       DWORD                           cbInfo   = 2 * 1024;
       DWORD                           dwErr    = ERROR_SUCCESS;
       DWORD                           dwResume = 0;
       DWORD                           cLoop    = 0;
       const DWORD                     cLoopMax = 2;

       do {
           
           if(pInfo) LocalFree(pInfo);

           if((pInfo = (LPENUM_SERVICE_STATUS_PROCESS)LocalAlloc(LMEM_ZEROINIT, cbInfo))
              == NULL)
           {
               CloseServiceHandle(hScm);
               return FALSE;
           }

           dwErr = ERROR_SUCCESS;
           if (!EnumServicesStatusEx(
                   hScm,
                   SC_ENUM_PROCESS_INFO,
                   SERVICE_WIN32,
                   SERVICE_STATE_ALL,
                   (LPBYTE)pInfo,
                   cbInfo,
                   &cbInfo,
                   &dwNumServices,
                   &dwResume,
                   NULL))
           {
               dwErr = GetLastError();
           }
       }
       while ((ERROR_MORE_DATA == dwErr) && (++cLoop < cLoopMax));

       if ((ERROR_SUCCESS == dwErr) && dwNumServices)
       {
          BOOL bResult;
          
          CloseServiceHandle(hScm);

          bResult = ResolveProcessServices(pInfo, dwNumServices, hWrite);
          LocalFree(pInfo);
          return bResult;
       
       } else {
           LocalFree(pInfo);
           dwNumServices = 0;
       }
       
       CloseServiceHandle(hScm);

   }        
   return FALSE;
}

BOOL
ResolveProcessServices(LPENUM_SERVICE_STATUS_PROCESS pServices, DWORD dwServiceCount, HANDLE hWrite)
{
   ULONG                         uBuffSize=SVCBUFFER_SIZE;
   NTSTATUS                      Status;
   PBYTE                         pBuff=NULL;
   
   // Alloc for process info
   if((pBuff = (PBYTE)LocalAlloc(LMEM_ZEROINIT,uBuffSize))
      == NULL)
   {
      return FALSE;
   }

   //
   // Query for system info
   //
   Status = NtQuerySystemInformation(SystemProcessInformation,
                                     pBuff,
                                     uBuffSize,
                                     NULL);

   if(NT_SUCCESS(Status))
   {
      PSYSTEM_PROCESS_INFORMATION   pFirst;
      PSYSTEM_PROCESS_INFORMATION   pCurrent;
      ANSI_STRING                   pname;
      ULONG                         TotalOffset=0;

      ZeroMemory(&pname,sizeof(ANSI_STRING));

      pFirst = pCurrent = (PSYSTEM_PROCESS_INFORMATION)&pBuff[0];
      if(!pFirst)
         return FALSE;

      Logprintf(hWrite,LOG_SEPARATION_TXT);
      Logprintf(hWrite, TEXT("PROCESS INFO\r\n"));
      Logprintf(hWrite,LOG_SEPARATION_TXT);                                                 

      for(TotalOffset=0;pCurrent->NextEntryOffset;TotalOffset+=pCurrent->NextEntryOffset)
      {
          DWORD i;

         pCurrent = (PSYSTEM_PROCESS_INFORMATION)&pBuff[TotalOffset];
                                          
         Logprintf(hWrite, TEXT("%-5d SVCS: "), (INT_PTR)(pCurrent->UniqueProcessId));
                                          
         for(i=0;i<dwServiceCount;i++)
         {
             if(pServices[i].ServiceStatusProcess.dwProcessId == (INT_PTR)(pCurrent->UniqueProcessId))
             {
                 Logprintf(hWrite, TEXT("%s "), pServices[i].lpServiceName);
             }
                 
         }

         Logprintf(hWrite, TEXT("\r\n"));
      }

      //
      // Free the memory
      //
      LocalFree(pBuff);

      return TRUE;


   }
   LocalFree(pBuff);
   return FALSE;

}

BOOL
BuildPackage(PRASDIAGCAPTURE pCaptures, DWORD dwCaptureCount, WCHAR *pszRasDiagDir, SYSTEMTIME *pDiagTime)
{
    HANDLE  hFile;
    WCHAR   szDiagLogFile[MAX_PATH+1];
    DWORD   i;

    if(CreatePackage(&hFile, pDiagTime, pszRasDiagDir) == FALSE)
    {
        return FALSE;
    }

    for(i=0;i<dwCaptureCount;i++)
    {
        if(pCaptures[i].szCaptureFileName[0]!=L'\0')
        {
            if(AddFileToPackage(hFile, (WCHAR*)pCaptures[i].szCaptureFileName) == FALSE) {
                ClosePackage(hFile);
                return FALSE;

            } else {

                // Delete the capture... don't need this anymore
                DeleteFile(pCaptures[i].szCaptureFileName);
            }

        }                                                            
    }

    wsprintf(szDiagLogFile, TEXT("%s\\%s"), pszRasDiagDir, LOG_FILE_NAME);

    if(AddFileToPackage(hFile, szDiagLogFile) == FALSE) {
        ClosePackage(hFile);
        return FALSE;
    } else {
        DeleteFile(szDiagLogFile);
    }

    ClosePackage(hFile);
    return TRUE;
}

BOOL
BuildRasDiagLog(PRASDIAGCONFIG pRdc)
{
   HANDLE    hWrite;
   ULONG     i;
   WCHAR     szFile[MAX_PATH+1];
   BYTE      buff[IOBUFF_SIZE];
   DWORD     dwBytesRead,dwBytesWritten;

   wsprintf(szFile, TEXT("%s\\%s"), pRdc->szRasDiagDir, LOG_FILE_NAME);

   if((hWrite=CreateFile(szFile,
                        GENERIC_READ | GENERIC_WRITE,
                        0,
                        NULL,
                        CREATE_ALWAYS,
                        0,
                        NULL))
       == INVALID_HANDLE_VALUE)
   {
      return FALSE;
   }

   AddHeader(hWrite, pRdc); 
             
   for(i=0;i<TOT_LOG_COUNT;i++)
   {
       wsprintf(szFile, TEXT("%s\\%s.%s"), pRdc->szTracingDir, Logs[i].pszKey, TRACING_EXTENSION);
       AddLog(hWrite, szFile, FALSE, Logs[i].pszKey);
   }


#if 0
   // Add CM logs
   for(i=0;i<pRdc->dwCmLogs;i++)
   {
      AddLog(hWrite, pRdc->pCmFileName[i], TRUE, TEXT("CM"));
   }
#endif

   // Add CM logs
   for(PCMINFO pCur=pRdc->pCmInfo;pCur;pCur=pCur->pNext)
   {
       AddLog(hWrite, pCur->pwcLogFileName, TRUE, TEXT("CM"));
   }

   //
   // Add modem report...
   //
   AddModemLogs(hWrite);
   
   AddOakleyLog(hWrite);

   AddNetworkLog(hWrite);

   AddLog(hWrite, pRdc->szSysPbk, FALSE, TEXT("SYSTEM PBK")); 
   AddLog(hWrite, pRdc->szUserPbk, FALSE, TEXT("CURRENT USER PBK")); 

   // Add Events
   GetEventLogInfo(hWrite,MAX_SECURITY_EVENTS_REPORTED);
   
   // Add Process Info
   DumpProcessInfo(hWrite);

   Logprintf(hWrite,LOG_SEPARATION_TXT);
   Logprintf(hWrite, TEXT("END OF RASDIAG LOG\r\n"));
   Logprintf(hWrite,LOG_SEPARATION_TXT);                                                 

   CloseHandle(hWrite);
   
   return TRUE;

}

BOOL
Logprintf(HANDLE hWrite, WCHAR *pFmt, ...) 
{
    WCHAR   buff[1048*4];
    DWORD   dwBytesWritten;
    va_list marker;
    
    // form string
    va_start(marker, pFmt);
    vswprintf(buff, pFmt, marker);
    va_end(marker);
    
    // write string to file
    return WriteFile(hWrite,buff,lstrlen(buff)*sizeof(WCHAR), &dwBytesWritten, NULL);
}

BOOL
PrintLogHeader(HANDLE hWrite, WCHAR *pFmt, ...) 
{
    WCHAR   buff[512];
    DWORD   dwBytesWritten;
    va_list marker;
    
    // form string
    va_start(marker, pFmt);
    vswprintf(buff, pFmt, marker);
    va_end(marker);
    
    if(Logprintf(hWrite, LOG_SEPARATION_TXT) == FALSE)
    {
        return FALSE;
    }
      
    if(Logprintf(hWrite, TEXT("%s"), buff) == FALSE)
    {
        return FALSE;
    }                            
    return Logprintf(hWrite, LOG_SEPARATION_TXT);

}


BOOL
AddLog(HANDLE hWrite, WCHAR *pszSrcFileName, BOOL bSrcUnicode, WCHAR *pszLogTitle)
{
    HANDLE            hFile;
    WCHAR             szFileSpec[MAX_PATH+1];
    WCHAR             szRoot[MAX_PATH+1];
    WCHAR             *pPath;
    WIN32_FIND_DATA   fd;
    BYTE              buff[IOBUFF_SIZE];
    
    if(pszSrcFileName == NULL) return FALSE;
    
    lstrcpy(szFileSpec, pszSrcFileName);
    
    // Find first file...
    if((hFile=FindFirstFile(szFileSpec,&fd))
       == INVALID_HANDLE_VALUE)
    {
        PrintLogHeader(hWrite, TEXT("%s (%s)\r\n"), pszLogTitle, pszSrcFileName);
        Logprintf(hWrite, TEXT("N/A (%d).\r\n"), GetLastError());
        return FALSE;
    }

    lstrcpy(szRoot,szFileSpec);

    // Find the root path
    pPath = szRoot + lstrlen(szRoot);

    while(*pPath != L'\\' && pPath != szRoot) {
        pPath--;
    }
    
    if(pPath!=szRoot) {
        // found '\\' 
        *pPath = L'\0';
        pPath = szRoot;
    } else {
        pPath=NULL;
    }

    do {

       BOOL     bResult;
       WCHAR    szFile[MAX_PATH+1];
       HANDLE   hRead;

       //
       // Add the file to the log
       //
       
       if(pPath)
           wsprintf(szFile, TEXT("%s\\%s"), pPath, fd.cFileName);
       else
           wsprintf(szFile, TEXT("%s"), fd.cFileName);

       PrintLogHeader(hWrite, TEXT("%s (%s)\r\n"), pszLogTitle, szFile);

       if((hRead=CreateFile(szFile,
                            GENERIC_READ,
                            FILE_SHARE_READ | FILE_SHARE_WRITE,
                            NULL,
                            OPEN_EXISTING,
                            0,
                            NULL))
           != INVALID_HANDLE_VALUE)
       {
          DWORD     dwBytesRead=0,dwBytesWritten=0;
          DWORD     dwFileSize=0,dwFileSizeHigh=0;
          LPBYTE    pBuff=NULL;

          dwFileSize = GetFileSize(hRead, &dwFileSizeHigh);

          if(dwFileSize != -1 && dwFileSize != 0)
          {
              // Allocate a buffer for the file
              if((pBuff=(LPBYTE)LocalAlloc(LMEM_ZEROINIT, dwFileSize+1))
                 != NULL)
              {
                  if(ReadFile(hRead,pBuff,dwFileSize,&dwBytesRead,NULL))
                  {
                      // If the source file is not unicode, convert the buffer to UNICODE
                      if(bSrcUnicode == FALSE)
                      {
                          WCHAR *pWide=NULL;

                          // Alloc a buffer for string conversion
                          if((pWide=(WCHAR*)LocalAlloc(LMEM_ZEROINIT, sizeof(WCHAR) * (dwBytesRead+1)))
                             != NULL)
                          {
                              // Need to convert buffer from ANSI->WIDE
                              if(mbstowcs(pWide, (CHAR *)pBuff, dwBytesRead) != -1)
                              {
                                  // Free the original buffer
                                  LocalFree(pBuff);
                                  
                                  // swap pBuff for pWide (new buff)
                                  pBuff = (LPBYTE)pWide;

                                  // dwBytesRead need to reflect unicode size
                                  dwBytesRead *= sizeof(WCHAR);
                                  
                              } else {

                                  // could not convert string - log must be corrupt. Close up shop
                                  LocalFree(pWide);
                                  LocalFree(pBuff);
                                  CloseHandle(hRead);
                                  Logprintf(hWrite, TEXT("\r\n** Log Truncated (%d bytes).\r\n"), dwBytesRead);
                                  
                                  break; // next iteration
                              }
                          }           
                          
                      }
                      
                      // Write the buffer *BYTES* to disk
                      WriteFile(hWrite,pBuff,dwBytesRead,&dwBytesWritten, NULL);
                  
                  }
                  LocalFree(pBuff);
              }


          }
          
          if(dwFileSize != -1)
              Logprintf(hWrite, TEXT("** Complete (%d bytes).\r\n"), dwBytesRead);
          
          CloseHandle(hRead);     
       }

    } while ( FindNextFile(hFile, &fd) );

    FindClose(hFile);                                 

    return TRUE;
}

BOOL
AddModemLogs(HANDLE hWrite)
{
    WCHAR szFile[MAX_PATH+1];
    DWORD dwRet;

   if((dwRet = ExpandEnvironmentStrings(MODEM_LOG_FILENAME, szFile, MAX_PATH+1))
      == 0) return FALSE;

   if(dwRet > MAX_PATH+1) return FALSE; // string is larger than MAX_PATH+NULL - which is invalid.

   return AddLog(hWrite, szFile, TRUE, TEXT("UNIMODEM"));
}

BOOL
AddOakleyLog(HANDLE hWrite)
{
  WCHAR szFile[MAX_PATH+1];
  DWORD dwRet;

  if((dwRet = ExpandEnvironmentStrings(OAKLEY_LOG_LOCATION, szFile, MAX_PATH+1))
     == 0) return FALSE;
  
  if(dwRet > MAX_PATH+1) return FALSE; // string is larger than MAX_PATH+NULL - which is invalid.

  return AddLog(hWrite, szFile, FALSE, LOG_TITLE_OAKLEY);

}

BOOL
AddNetworkLog(HANDLE hWrite)
{
  BOOL   bReturn;
  WCHAR  szFile[MAX_PATH+1];

  GetCurrentDirectory(MAX_PATH+1, szFile);

  wsprintf(szFile, TEXT("%s\\%s"), szFile, RASDIAG_NET_TEMP);
  
  bReturn = AddLog(hWrite, szFile, FALSE, TEXT("NETWORK"));

  DeleteFile(szFile);

  return bReturn;

}

void
DeleteTracingLogs(WCHAR *pszTracingDir)
{
   HANDLE            hFile;
   WCHAR              szFileSpec[MAX_PATH+1];
   WIN32_FIND_DATA   fd;
   
   wsprintf(szFileSpec, TEXT("%s\\*.LOG"), pszTracingDir);

   if((hFile=FindFirstFile(szFileSpec,&fd))
      == INVALID_HANDLE_VALUE)
   {
      return;
   }

   do {

      BOOL  bResult;
      ULONG iTries=10;
      WCHAR  szFile[MAX_PATH+1];

      //
      // Delete the file
      //
      wsprintf(szFile, TEXT("%s\\%s"), pszTracingDir, fd.cFileName);
      
      do {
         
         if(!(bResult = DeleteFile(szFile)))
         {
            
            switch(GetLastError())
            {
            case ERROR_FILE_NOT_FOUND:
               iTries = 0;
               break;
            
            case ERROR_SHARING_VIOLATION:
               PrintUserMsg(IDS_USER_DOT);
               Sleep(50);
               iTries--;
               break;
               
            default:
               Sleep(50);
               iTries--;
               break;
               
            }
         } 
               
      } while (iTries > 0  );



   } while ( FindNextFile(hFile, &fd) );

   FindClose(hFile);

   //
   // Delete the modem logs as well....
   //

}

void
DeleteModemLogs(WCHAR *szWindowsDirectory)
{
   HANDLE            hFile;
   WCHAR             szFileSpec[MAX_PATH+1];
   WIN32_FIND_DATA   fd;
   DWORD             dwRet;

   dwRet = ExpandEnvironmentStrings(MODEM_LOG_FILENAME, szFileSpec, MAX_PATH+1);

   if(dwRet == 0 || dwRet > MAX_PATH+1) return;

   if((hFile=FindFirstFile(szFileSpec,&fd))
      == INVALID_HANDLE_VALUE)
   {
      return;
   }

   do {

      BOOL  bResult;
      ULONG iTries=10;
      WCHAR  szFile[MAX_PATH+1];

      //
      // Delete the file
      //
      wsprintf(szFile, TEXT("%s\\%s"), szWindowsDirectory, fd.cFileName);

      do {
         
         if(!(bResult = DeleteFile(szFile)))
         {
            
            switch(GetLastError())
            {
            case ERROR_FILE_NOT_FOUND:
               iTries = 0;
               break;
            
            case ERROR_SHARING_VIOLATION:
               Sleep(50);
               iTries--;
               break;
               
            default:
               Sleep(50);
               iTries--;
               break;
               
            }
         } 

      } while (iTries > 0  );



   } while ( FindNextFile(hFile, &fd) );

   FindClose(hFile);

}

BOOL
SetTracing(BOOL bState)
{
   ULONG i;
   HKEY  hKey;
   DWORD dwRet=0,dwState = bState;
   BOOL  bResult=TRUE;
   
   //
   // Set RAS Tracing Values
   //
   for(i=0;i<TOT_LOG_COUNT;i++)
   {
      
      if(Logs[i].fDefaultState)
      {                                                                                   
   
         WCHAR  szValue[MAX_PATH+1];
         
         wsprintf(szValue, TEXT("%s\\%s"), TRACING_SUBKEY, Logs[i].pszKey);
   
         //
         // Open Tracing Key
         //
         if((dwRet=RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                                szValue,
                                0,
                                KEY_ALL_ACCESS,
                                &hKey))
            == ERROR_SUCCESS)
         {
            if(RegSetValueEx(hKey, 
                             TRACING_ENABLE_VALUE_NAME, 
                             0,
                             REG_DWORD,
                             (LPBYTE)&dwState, 
                             sizeof(DWORD)) 
               != ERROR_SUCCESS)
            {
               bResult = FALSE;
            }             
            RegCloseKey(hKey);
         } else 
             bResult = FALSE;
      }
   }
   return bResult;
}

void
SetModemTracing(BOOL bState)
{
   ULONG i;
   HKEY  hKey;
   DWORD dwRet=0,dwState = bState;
   WCHAR  szValue[MAX_PATH+1];
      
   //
   // Enumerate count of unimodem devices
   //
   if((dwRet=RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                          MODEM_SUBKEY,
                          0,
                          KEY_ALL_ACCESS,
                          &hKey))
      == ERROR_SUCCESS)
   {
      DWORD index=0;

      do {

         WCHAR  szSubkeyName[MAX_PATH+1];
         DWORD dwSubkeySize=MAX_PATH+1;  
         FILETIME ft;

         //
         // Enum device values
         //
         dwRet = RegEnumKeyEx(hKey,
                              index++,
                              szSubkeyName,
                              &dwSubkeySize,
                              NULL,
                              NULL,
                              NULL,
                              &ft);

         //
         // If a subkey was found...
         //
         if (dwRet == ERROR_SUCCESS) {

            WCHAR  szOpenKey[MAX_PATH+1];
            BYTE  value;
            HKEY  hKey2;

            if(bState) value = 1;
            else value = 0;


            wsprintf(szOpenKey,
                     TEXT("%s"),
                     szSubkeyName);
            
            if((dwRet=RegOpenKeyEx(hKey,
                                   szOpenKey,
                                   0,
                                   KEY_ALL_ACCESS,
                                   &hKey2))
               == ERROR_SUCCESS)
            {
               //
               // Enumerate count of unimodem devices
               //
               if((dwRet=RegSetValueEx(hKey2,
                                       UNIMODEM_ENABLE_LOGGING_VALUE,
                                       0,
                                       REG_BINARY,
                                       &value,
                                       1))
                  == ERROR_SUCCESS)
               {
                  ;
               }  
               RegCloseKey(hKey2);

            }       

         }                           

      } while ( dwRet == ERROR_SUCCESS );

      RegCloseKey(hKey);
   }

}

void
OpenLogFileWithEditor(WCHAR *pszTracingDirectory, WCHAR *szWindowsDirectory)
{
   
   WCHAR        szPath[MAX_PATH+1];
   WCHAR        szTemp[MAX_PATH+1];
   WCHAR        szFileName[MAX_PATH+1];
   STARTUPINFO si;
   PROCESS_INFORMATION pi;
   OSVERSIONINFO  osverinfo;

   if(szWindowsDirectory == NULL || pszTracingDirectory == NULL) return;

   osverinfo.dwOSVersionInfoSize=sizeof(OSVERSIONINFO);
   GetVersionEx(&osverinfo);

   if(osverinfo.dwPlatformId == VER_PLATFORM_WIN32_WINDOWS)
      lstrcpy(szPath, szWindowsDirectory);
   else
      GetSystemDirectory(szPath, MAX_PATH+1);

   wsprintf(szTemp, TEXT("%s\\%s"),
            szPath,
            SYSTEM_TEXT_EDITOR);

   wsprintf(szFileName, TEXT(" %s\\%s"),
            pszTracingDirectory, LOG_FILE_NAME);

   ZeroMemory(&si, sizeof(STARTUPINFO));
   ZeroMemory(&pi, sizeof(PROCESS_INFORMATION));

   si.cb = sizeof(STARTUPINFO);

   if(!CreateProcess(szTemp,
                 szFileName,
                 NULL,
                 NULL,
                 FALSE,
                 0,
                 NULL,
                 NULL,
                 &si,
                 &pi))
   {
      ;
   }

}

BOOL
CheckFileAccess(WCHAR * pszTracingDir)
{
     
   HANDLE    hFile;
   ULONG     i;
   WCHAR      szFile[MAX_PATH+1];

   for(i=0;i<TOT_LOG_COUNT;i++)
   {
      HANDLE   hRead;
      
      wsprintf(szFile, TEXT("%s\\%s.log"), pszTracingDir, Logs[i].pszKey);

      if((hFile=CreateFile(szFile,
                           GENERIC_READ,
                           0,
                           NULL,
                           OPEN_EXISTING,
                           0,
                           NULL))
          == INVALID_HANDLE_VALUE)
      {

         switch(GetLastError())
         {
         case ERROR_SHARING_VIOLATION:
            return FALSE;
            break;
         }

      } else {
         CloseHandle(hFile);
      }                     
   }
   return TRUE;

}

void
AddHeader(HANDLE hFile, PRASDIAGCONFIG pRdc)
{
   BYTE  line[MAX_PATH+1];
   DWORD dwBytesWritten;
   OSVERSIONINFO osverinfo;
   WCHAR  szComputerName[MAX_COMPUTERNAME_LENGTH+1];
   DWORD size=MAX_COMPUTERNAME_LENGTH+1;
   DWORD    i;

   GetComputerName(szComputerName, &size);

   ZeroMemory(&osverinfo, sizeof(OSVERSIONINFO));
   osverinfo.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
                                                       
   GetVersionEx(&osverinfo);

   Logprintf(hFile, LOG_SEPARATION_TXT); 
   Logprintf(hFile, TEXT("RASDIAG SUMMARY (v%d.%d)\r\n"), RASDIAG_MAJOR_VERSION, RASDIAG_MINOR_VERSION);
   Logprintf(hFile, LOG_SEPARATION_TXT); 

   Logprintf(hFile, TEXT("An %s file has been created in %s.\r\n"), RASDIAG_EXT, pRdc->szRasDiagDir);
   
   Logprintf(hFile, TEXT("Please forward this file to your support contact.\r\n"));
                                                                      
   Logprintf(hFile, TEXT("The %s folder should now be open on your desktop.\r\n"), APPLICATION_TITLE);
   
   Logprintf(hFile, LOG_SEPARATION_TXT);
     
   Logprintf(hFile, TEXT("COMPUTER   : %s\r\n"), szComputerName);
   
   Logprintf(hFile, TEXT("BUILD      : %d\r\n"), osverinfo.dwBuildNumber);
   
   Logprintf(hFile, TEXT("SYSPBK     : %s\r\n"), pRdc->szSysPbk);

   Logprintf(hFile, TEXT("USRPBK     : %s\r\n"), pRdc->szUserPbk);
                                                    
   Logprintf(hFile, LOG_SEPARATION_TXT);
   
   for(i=0;i<pRdc->dwNetCount;i++)
   {
       Logprintf(hFile, TEXT("%s CAPTURE (%s): %s\r\n"), 
                pRdc->pNetInterfaces[i].bWan ? TEXT("WAN") : TEXT("LAN"),
                pRdc->pNetInterfaces[i].pszMacAddr ? pRdc->pNetInterfaces[i].pszMacAddr : TEXT("PPP"),
                pRdc->pNetInterfaces[i].szCaptureFileName[0] != L'\0' ? pRdc->pNetInterfaces[i].szCaptureFileName : TEXT("Zero Bytes Captured."));
   }
   
   if(pRdc->dwUserOptions & RSNIFF_OPT1_DOSNIFF)
   {
       Logprintf(hFile, TEXT("** REMOTE SNIFF AVAILABLE **\r\n"));
   }

   Logprintf(hFile, LOG_SEPARATION_TXT);
   
   DeviceDump(hFile);
   
   Logprintf(hFile, LOG_SEPARATION_TXT);

   Logprintf(hFile, TEXT("\r\n"));    
}

void
DeviceDump(HANDLE hWrite)
{
   RASDEVINFO  *pRdi=NULL;
   ULONG       uCount=0,uSize=0;
   DWORD       dwBytesWritten;
   BYTE        line[MAX_PATH+1];
               
   Logprintf(hWrite, TEXT("RAS DEVICES\r\n"));
   
   Logprintf(hWrite, LOG_SEPARATION_TXT);
      
   RasEnumDevices(pRdi, &uSize, &uCount);

   uSize = sizeof(RASDEVINFO) * uCount;

   if((pRdi=(RASDEVINFO  *)LocalAlloc(LMEM_ZEROINIT, uSize))
      == NULL) {
      return;
   }

   pRdi->dwSize = sizeof(RASDEVINFO);
   
   if(RasEnumDevices(pRdi, &uSize, &uCount)
      == ERROR_SUCCESS)
   {
      ULONG i;

      for(i=0;i<uCount;i++)
      {
         Logprintf(hWrite, TEXT("%02d. %-45.45s %-15.15s\r\n"),
                i+1, pRdi[i].szDeviceName, pRdi[i].szDeviceType);
      }
   }
   LocalFree(pRdi);
}

BOOL
EnableOakleyLogging(BOOL bEnable)
{
    HKEY    hKey;
    DWORD   dwRet,dwDisposition,dwState;
    WCHAR    szValue[MAX_PATH+1];
    
    dwState = bEnable;
    
    wsprintf(szValue, TEXT("%s"), OAKLEY_TRACING_KEY);
    
    dwRet=RegCreateKeyEx(HKEY_LOCAL_MACHINE,szValue,0,NULL,REG_OPTION_NON_VOLATILE,KEY_SET_VALUE,NULL,&hKey,&dwDisposition);

    if(dwRet != ERROR_SUCCESS)
    {
        return FALSE;
    }

    dwRet = RegSetValueEx(hKey, OAKLEY_VALUE, 0, REG_DWORD, (LPBYTE)&dwState, sizeof(DWORD));
        
    RegCloseKey(hKey);

    if(dwRet == ERROR_SUCCESS)
    {
        return TRUE;
    }
    return FALSE;
    
}

BOOL
DeleteOakleyLog(void)
{
    WCHAR   szOak[MAX_PATH+1];
    DWORD   ret;

    ret = ExpandEnvironmentStrings(OAKLEY_LOG_LOCATION, szOak, MAX_PATH+1);
    if(ret == 0 || ret > MAX_PATH+1) return FALSE;

    ret = DeleteFile(szOak);

    if(ret != ERROR_SUCCESS)
    {
        switch(ret)
        {
        
        case ERROR_FILE_NOT_FOUND:
            return TRUE;

        default:
            return FALSE;

        }
    }
    return TRUE;
}

BOOL
StopStartService(WCHAR * pServiceName, BOOL bStart)
{
   SC_HANDLE      hSrvControlMgr,hService;
   SERVICE_STATUS ss;
   SERVICE_STATUS_PROCESS ssp;
   DWORD          dwBytesRequired;
   BOOL           bStatus = FALSE;

   if((hSrvControlMgr = OpenSCManager(NULL,NULL,SC_MANAGER_ALL_ACCESS))
      == NULL)
   {
      return FALSE;
   }

   if((hService=OpenService(hSrvControlMgr,pServiceName,SERVICE_ALL_ACCESS))
      == NULL) {
      CloseServiceHandle(hSrvControlMgr);
      return FALSE;
   }

   if(bStart == TRUE)
   {
       bStatus = MyStartService(hService, pServiceName);
   
   } else bStatus = StopService(hService, pServiceName);
                 
   CloseServiceHandle(hService);
   CloseServiceHandle(hSrvControlMgr);
   return bStatus;
}

BOOL
MyStartService(SC_HANDLE hService, WCHAR * pServiceName)
{
   SERVICE_STATUS ss;

   //
   // Start the service
   //
   if(StartService(hService, 0, NULL) == FALSE) {

      return FALSE;
   }

   MonitorState(hService, pServiceName, SERVICE_RUNNING);

   return TRUE;
}

BOOL
StopService(SC_HANDLE hService, WCHAR * pServiceName)
{
   SERVICE_STATUS ss;

   //
   // Stop the service
   //
   if(ControlService(hService, SERVICE_CONTROL_STOP, &ss) == FALSE) {
      return FALSE;
   }

   MonitorState(hService, pServiceName, SERVICE_STOPPED);

   return TRUE;

}

void
MonitorState(SC_HANDLE hService, WCHAR * pServiceName, DWORD dwStateToEnforce)
{

   SERVICE_STATUS ss;

   do {

      QueryServiceStatus(hService,&ss);
      Sleep(1000);

   } while (ss.dwCurrentState != dwStateToEnforce);

}

BOOL
CreatePackage(HANDLE *phFile, SYSTEMTIME *pDiagTime, WCHAR *szRasDiagDir)
{

    RDGHDR      Rdg;
    HANDLE      hFile;
    WCHAR        szFileName[MAX_PATH+1];
    DWORD dwBytesWritten;
    
    wsprintf(szFileName, TEXT("%s\\%04d%02d%02d-%02d%02d%02d.%s"),
         szRasDiagDir, 
         pDiagTime->wYear,
         pDiagTime->wMonth,
         pDiagTime->wDay,
         pDiagTime->wHour,
         pDiagTime->wMinute,
         pDiagTime->wSecond,
         RASDIAG_EXT);
                       
    ZeroMemory(&Rdg, sizeof(RDGHDR));
    
    if((hFile = CreateFile(szFileName,GENERIC_READ|GENERIC_WRITE,0,NULL,CREATE_ALWAYS,0,NULL))
       == INVALID_HANDLE_VALUE) {
        return FALSE;

    }                       

    Rdg.dwVer = sizeof(RDGHDR);
    Rdg.dwRDGMajVer = RASDIAG_MAJOR_VERSION;
    Rdg.dwRDGMinVer = RASDIAG_MINOR_VERSION;

    GetLocalTime(&Rdg.CreationTime);
    
    if(WriteFile(hFile, (LPBYTE)&Rdg, sizeof(RDGHDR), &dwBytesWritten, NULL) == FALSE)
    {
        CloseHandle(hFile);
        return FALSE;
    }

    *phFile = hFile;

    return TRUE;

}

BOOL
AddFileToPackage(HANDLE hPkgFile, WCHAR *pszFileName)
{
    HANDLE      hSrcFile;
    RDGFILEHDR  hdr;
    DWORD       dwBytesWritten=0,dwBytesRead=0;
    DWORD       dwFileSizeHigh=0;
    BYTE        buff[IOBUFF_SIZE];
    WCHAR       *pFn=NULL;
    
    ZeroMemory(&hdr, sizeof(RDGFILEHDR));

    if((hSrcFile=CreateFile(pszFileName, GENERIC_READ, 0, NULL, OPEN_EXISTING,0,NULL))
       == INVALID_HANDLE_VALUE) {
        return FALSE;
    }
    
    // get short file name
    pFn = pszFileName + lstrlenW(pszFileName);

    while(*pFn != L'\\' && pFn != pszFileName )
    {
        pFn--;
    }

    if(*pFn == L'\\') pFn++;
    
    hdr.dwVer = sizeof(RDGFILEHDR);
    lstrcpy(hdr.szFilename, pFn);
    hdr.dwFileSize = GetFileSize(hSrcFile, &dwFileSizeHigh);
    
    // write the header
    if(WriteFile(hPkgFile, (LPBYTE)&hdr, sizeof(RDGFILEHDR), &dwBytesWritten, NULL) == FALSE)
    {
        CloseHandle(hSrcFile);
        return FALSE;
    }
    
    // open the file and pump the src file into it...
    
    while(ReadFile(hSrcFile, buff, IOBUFF_SIZE, &dwBytesRead, NULL) == TRUE && dwBytesRead)
    {
        if(WriteFile(hPkgFile, buff, dwBytesRead, &dwBytesWritten, NULL) == FALSE)
        {
            CloseHandle(hSrcFile);
            return FALSE;
        }
    }

    CloseHandle(hSrcFile);
    return TRUE;
}

BOOL
ClosePackage(HANDLE hFile)
{
    CloseHandle(hFile);
    return TRUE;
}

BOOL
CrackRasDiagFile(IN WCHAR *pszRdgFile, OPTIONAL IN WCHAR *pszDestinationPath)
{
    HANDLE      hSrcFile;
    RDGHDR      hdr;
    DWORD       dwBytesWritten=0,dwBytesRead=0;
    DWORD       dwFileSizeHigh=0;
    DWORD       dwFileSize;
    BYTE        buff[IOBUFF_SIZE];
    RDGFILEHDR  filehdr;
    RDGFILEHDR_VER5  hdr_ver5;

    if((hSrcFile=CreateFile(pszRdgFile, 
                            GENERIC_READ, 
                            0, 
                            NULL, 
                            OPEN_EXISTING,0,NULL))
       == INVALID_HANDLE_VALUE) {
        return FALSE;
    }
    
    dwFileSize = GetFileSize(hSrcFile, &dwFileSizeHigh);
       
    if(dwFileSize < sizeof(RDGHDR) || dwFileSize == -1)
    {
        CloseHandle(hSrcFile);
        return FALSE;
    }

    // read the header
    if(ReadFile(hSrcFile, (LPBYTE)&hdr, sizeof(RDGHDR), &dwBytesRead, NULL) == FALSE && dwBytesRead)
    {
        CloseHandle(hSrcFile);
        return FALSE;
    }
    
    // Check version
    if(hdr.dwVer == sizeof(RDGHDR_VER5))
    {
        // Return file pointer to start of file...
        SetFilePointer(hSrcFile, 0, NULL, FILE_BEGIN);
        
        // read the header
        if(ReadFile(hSrcFile, (LPBYTE)&hdr_ver5, sizeof(RDGHDR_VER5), &dwBytesRead, NULL) == FALSE && dwBytesRead)
        {
            CloseHandle(hSrcFile);
            return FALSE;
        }

    } else if(hdr.dwRDGMajVer != RASDIAG_MAJOR_VERSION) {
        
        if(hdr.dwRDGMajVer < RASDIAG_MAJOR_VERSION)
            PrintUserMsg(IDS_USER_WRONGFILEVER);
        else {
            PrintUserMsg(IDS_USER_NOTRASDIAGFILE);
        }
        
        CloseHandle(hSrcFile);
        
        Sleep(5000);

        return FALSE;
    }

    if(hdr.dwVer == sizeof(RDGHDR_VER5))
    {
        RDGFILEHDR_VER5 filehdr_ver5;
        
        // Read file header
        while(ReadFile(hSrcFile, &filehdr_ver5, sizeof(RDGFILEHDR_VER5), &dwBytesRead, NULL) == TRUE && dwBytesRead)
        {   
            filehdr.dwVer = sizeof(RDGFILEHDR);
            filehdr.dwFileSize = filehdr_ver5.dwFileSize;

            mbstowcs(filehdr.szFilename, filehdr_ver5.szFilename, MAX_PATH+1);

            if(UnpackFile(hSrcFile, &filehdr, pszDestinationPath) == FALSE) {
                CloseHandle(hSrcFile);
                return FALSE;
            }
        }

    } else {
        
        // Read file header
        while(ReadFile(hSrcFile, &filehdr, sizeof(RDGFILEHDR), &dwBytesRead, NULL) == TRUE && dwBytesRead)
        {   
            if(UnpackFile(hSrcFile, &filehdr, pszDestinationPath) == FALSE) {
                CloseHandle(hSrcFile);
                return FALSE;
            }
        }
    }

    CloseHandle(hSrcFile);

    return TRUE;
}

BOOL
UnpackFile(HANDLE hSrcFile, PRDGFILEHDR pHdr, WCHAR *pszDestinationPath)
{
    HANDLE hDstFile;
    BYTE    buff[IOBUFF_SIZE];
    DWORD   dwBytesWritten=0,dwBytesRead=0,dwBytesRemain=0;
    WCHAR   szFile[MAX_PATH+1];

    if(pszDestinationPath) {
        wsprintf(szFile,TEXT("%s\\%s"), pszDestinationPath, pHdr->szFilename);
    } else {
        // use current directory
        lstrcpy(szFile, pHdr->szFilename);
    }

    PrintUserMsg(IDS_USER_UNPACKING_FILE, szFile);

    if((hDstFile=CreateFile(szFile, 
                            GENERIC_WRITE, 
                            0, 
                            NULL, 
                            CREATE_ALWAYS,0,NULL))
       == INVALID_HANDLE_VALUE) {
        return FALSE;
    }

    dwBytesRemain = pHdr->dwFileSize;

    while(ReadFile(hSrcFile, buff, dwBytesRemain > IOBUFF_SIZE ? IOBUFF_SIZE : dwBytesRemain, &dwBytesRead, NULL) && dwBytesRead)
    {   
        if(WriteFile(hDstFile, buff, dwBytesRead, &dwBytesWritten, NULL) == FALSE)
        {
            CloseHandle(hDstFile);
            return FALSE;
        }

        dwBytesRemain -= dwBytesRead; 
        
        if(dwBytesRemain == 0)
        {
            CloseHandle(hDstFile);
            return TRUE;
        }               
    }                   
    CloseHandle(hDstFile);
    return FALSE;
}

BOOL
GetPbkPaths(WCHAR *szSysPbk, WCHAR *szUserPbk)
{
   WCHAR  szPath[MAX_PATH+1];
   DWORD  size;
   WCHAR  szUser[UNLEN+1];

   size=UNLEN+1;
   if(GetUserName(szUser,&size) == FALSE)
   {
       return FALSE;
   }

   size=MAX_PATH+1;
   if(GetAllUsersProfileDirectory(szPath,&size) == FALSE)
   {
       return FALSE;
   }
   wsprintf(szSysPbk, TEXT("%s%s"), szPath, PBK_PATH);

   if(GetProfilesDirectory(szPath,&size) == FALSE)
   {
       return FALSE;
   }
   wsprintf(szUserPbk, TEXT("%s\\%s%s"), szPath,szUser,PBK_PATH);
   return TRUE;
}

BOOL
CreateRasdiagDirectory(WCHAR *pszRasdiagDirectory)
{
    BOOL    bResult;

    GetRasDiagDirectory(pszRasdiagDirectory);
    
    if((bResult = CreateDirectory(pszRasdiagDirectory, NULL)) == FALSE)
    {
        DWORD   dwRet=GetLastError();
        
        if(dwRet == ERROR_ALREADY_EXISTS)
        {
            bResult = TRUE;
        } 
    }               
    return bResult;
}

WCHAR *
GetRasDiagDirectory(WCHAR *pszRasDiagDirectory)
{
    WCHAR   szPath[MAX_PATH+1];

    GetTempPath(MAX_PATH+1, szPath);

    wsprintf(szPath, TEXT("%s%s"), szPath, RASDIAG_DIRECTORY); 
    
    lstrcpy(pszRasDiagDirectory, szPath);

    return pszRasDiagDirectory;
}

void
RaiseFolderUI(WCHAR *pszDir)
{
    CHAR    szDir[MAX_PATH+1];

    wsprintfA(szDir, "start %ws\\.", pszDir);
    
    system(szDir);                      
}

BOOL
ProcessArgs(int argc, WCHAR **argv, DWORD *pdwUserOptions)
{
    int   i;
    BOOL  bCrackFile=TRUE;
    DWORD   dwOptions=0;

    for(i=1;i<argc;i++)
    {

#ifdef BUILD_RSNIFF
        if(lstrcmpi(argv[i], CMDOPTION_REMOTE_ROUTINGTABLE) == 0) {
            
            dwOptions |= RSNIFF_OPT1_GETSRVROUTINGINFO;
            bCrackFile=FALSE;
        
        } 
        
        if(lstrcmpi(argv[i], CMDOPTION_REMOTE_SNIFF) == 0 && (i+1 < argc)) {
            
            if(argv[i+1][0] != L'-')
            {
                lstrcpy(g_wcRSniff, argv[i+1]);
                bCrackFile=FALSE;
                dwOptions |= RSNIFF_OPT1_DOSNIFF;
                i++;
            } else {        
                PrintHelp();
                return FALSE;
            } 
        }
#endif            

#if 0 // no net tests at present
        if (lstrcmpi(argv[i], CMDOPTION_ENABLE_NETTESTS) == 0 && (i+1 < argc)) 
        {
            
            if(argv[i+1][0] != L'-')
            {
                // probably an address
                lstrcpy(g_wcNetTarget, argv[i+1]);
                bCrackFile=FALSE;
                *pdwUserOptions |= OPTION_DONETTESTS;
                i++;

            } else {        
                PrintHelp();
                return FALSE;
            }       
        } 
#endif // no net tests at present

        if(lstrcmpi(argv[i], CMDOPTION_DISABLE_QUESTION1) == 0 || lstrcmpi(argv[i], CMDOPTION_DISABLE_QUESTION2) == 0) {
            PrintHelp();
            return FALSE;
        }         
    }


#ifdef BUILD_RSNIFF

    if( (dwOptions & RSNIFF_OPT1_GETSRVROUTINGINFO) && !(dwOptions & RSNIFF_OPT1_DOSNIFF))
    {
        wprintf(L"Remote routing table option requires remote sniff. Please provide both parameters\n");
        return FALSE;
    }
#endif
    
    // Since there is only 1 param and it was not one of the above... must be a filename
    if((argc == 2) && (bCrackFile==TRUE))
    {
        WCHAR   szNewFile[MAX_PATH+1]=L"";

        if(CrackRasDiagFile((WCHAR *)argv[1], NULL) == FALSE)
        {
            PrintUserMsg(IDS_USER_COULDNOTUNPACKFILE,argv[1]);
        } 
        return FALSE;
    }           

    *pdwUserOptions = dwOptions;

    return TRUE;
}

void
PrintHelp(void)
{
    wprintf(L"%s", LOG_SEPARATION_TXT);
    wprintf(L"RASDIAG HELP (%d.%d) - Microsoft Corporation\n", RASDIAG_MAJOR_VERSION, RASDIAG_MINOR_VERSION);
    wprintf(L"%s", LOG_SEPARATION_TXT);
#ifdef BUILD_RSNIFF
    wprintf(L"%-15.15s %s\n", CMDOPTION_REMOTE_SNIFF L" <ipaddr>", L"Enable remote sniff");
    wprintf(L"%-15.15s %s\n", CMDOPTION_REMOTE_ROUTINGTABLE, L"Enable remote routing table collection (requires -r param)");
#endif    
    wprintf(L"%-15.15s %s\n", L"<.RDG file>", L"Extract RASDIAG file (example: rasdiag.exe sample.rdg)");
    wprintf(L"%-15.15s %s\n", CMDOPTION_DISABLE_QUESTION2, L"Help");
    wprintf(L"%-15.15s %s\n", CMDOPTION_DISABLE_QUESTION1, L"Help");
    wprintf(L"%s\n", LOG_SEPARATION_TXT);

}


#ifdef BUILD_SELFHOST

void
PrintSelfhostHelp(void)
{
    wprintf(L"\n\n");
    wprintf(L"%s", LOG_SEPARATION_TXT);
    wprintf(L"SENTRY/INTERNET-RAS HELP\n");
    wprintf(L"%s", LOG_SEPARATION_TXT);
    wprintf(L"\n");
    wprintf(L"%s", LOG_SEPARATION_TXT);   
}

#endif

void
PrintUserInstructions(void)
{
    wprintf(L"\n\n"
            LOG_SEPARATION_TXT
            L"RASDIAG - RAS Diagnostic/Troubleshooting Tool\n"
            LOG_SEPARATION_TXT
            L"\n"
           L"INSTRUCTIONS\n"
           L"\n"
           L"1) At this time, please reproduce the problem you are seeing.\n"
           L"2) Once the problem has been reproduced, please return to this console\n"
           L"   and press the space bar.\n"
           L"3) Wait for diagnostics and data collection process to complete. This\n"
           L"   process will be complete the RASDIAG folder has opened on your\n"
           L"   desktop. In this folder, you will find an .RDG file.\n"
           L"4) Please provide this .RDG file to your support contact.\n"
           L"\n"
#ifdef BUILD_SELFHOST
           L"   HOW TO:\n"
           LOG_SEPARATION_TXT
            L"   On Corp - Visit http://selfhost/status/issues.asp, complete\n"
           L"             a new issue and upload your .RDG file\n"
           L"\n"
           L"   On the Internet - Visit http://selfhost.rte.microsoft.com/status,\n"
           L"                     complete a new issue and upload your .RDG file\n"
           L"\n"
           L"   Please contact 'RASHOST' via email if you encounter trouble with this\n"
           L"   mechanism.\n"
           L"\n"
           LOG_SEPARATION_TXT
#endif           
           L"NOTE: The netmon driver is actively capturing on this machine's\n"
           L"      WAN and LAN interfaces. If you are able to successfully make a\n"
           L"      connection, and the problem you are seeing is related to network-layer\n"
           L"      connectivity, please perform the data-related action at this time\n"
            LOG_SEPARATION_TXT
            L"\n"
           );
}

#define RASDIAG_FILE_EXT        L".RDG"
#define RASDIAG_FN              L"RASDIAGFILE"
#define RASDIAG_FRIENDLY_NAME   L"RASDIAG Transport Container"

BOOL
RegisterRdgFileAssociation(WCHAR *pszPath)
{
    HKEY    hkeyRoot     = NULL;
    HKEY    hKeySubKey  =NULL;
    HKEY    hkeyRootDunFile = NULL;
    HKEY    hkeyCommand     = NULL;
    HKEY    hkeyIcon        = NULL;
    HKEY    hKeyShell       =NULL;
    DWORD   dwDisposition;
    WCHAR   wcDir[MAX_PATH+1];
    WCHAR   wcIconPath[MAX_PATH+1];
    WCHAR   wcExePath[MAX_PATH+1];

    wsprintf(wcIconPath, L"%s,0", pszPath);
    wsprintf(wcExePath, L"%s %%1", pszPath);


    // Create or open HKEY_CLASSES_ROOT\.dun
    if(RegCreateKeyEx(HKEY_CLASSES_ROOT, 
                        RASDIAG_FILE_EXT,
                        0, 
                        NULL, 
                        REG_OPTION_NON_VOLATILE,
                        KEY_ALL_ACCESS,
                        NULL,
                        &hkeyRoot, 
                        &dwDisposition)
       != ERROR_SUCCESS) {
        return FALSE;
    }


    if (1)
    {
        if(RegSetValueEx(hkeyRoot,
                         L"",
                         0,
                         REG_SZ,
                         (LPBYTE)RASDIAG_FN,
                         lstrlenW(RASDIAG_FN) * sizeof(WCHAR))
           != ERROR_SUCCESS) 
        {

            RegCloseKey(hkeyRoot);
            return FALSE;
            
        }

        if(RegCloseKey(hkeyRoot) == ERROR_SUCCESS)
        {
            if(RegCreateKeyEx(HKEY_CLASSES_ROOT,
                              RASDIAG_FN,
                              0,
                              NULL,
                              REG_OPTION_NON_VOLATILE,
                              KEY_ALL_ACCESS,
                              NULL,
                              &hkeyRootDunFile,
                              &dwDisposition)
               != ERROR_SUCCESS)
            {
                return FALSE;
            }

            if(RegSetValueEx(hkeyRootDunFile,
                             L"",
                             0,
                             REG_SZ,
                             (LPBYTE)RASDIAG_FRIENDLY_NAME,
                             lstrlenW(RASDIAG_FRIENDLY_NAME) * sizeof(WCHAR))
               != ERROR_SUCCESS)
            {
                RegCloseKey(hkeyRootDunFile);
                return FALSE;
            }

            if(RegCreateKeyEx(hkeyRootDunFile,
                              L"DefaultIcon",
                              0,
                              NULL,
                              REG_OPTION_NON_VOLATILE,
                              KEY_ALL_ACCESS,
                              NULL,
                              &hkeyIcon,
                              &dwDisposition)
               != ERROR_SUCCESS)
            {
                return FALSE;
            }

            if(RegSetValueEx(hkeyIcon,
                             L"",
                             0,
                             REG_EXPAND_SZ,
                             (LPBYTE)wcIconPath,
                             lstrlenW(wcIconPath) * sizeof(WCHAR))
               != ERROR_SUCCESS)
            {
                RegCloseKey(hkeyRootDunFile);
                return FALSE;
            }
            
            if(RegCreateKeyEx(hkeyRootDunFile,
                              L"Shell",
                              0,
                              NULL,
                              REG_OPTION_NON_VOLATILE,
                              KEY_ALL_ACCESS,
                              NULL,
                              &hKeyShell,
                              &dwDisposition)
               != ERROR_SUCCESS)
            {
                return FALSE;
            }


            if(RegCreateKeyEx(hKeyShell,
                              L"Open",
                              0,
                              NULL,
                              REG_OPTION_NON_VOLATILE,
                              KEY_ALL_ACCESS,
                              NULL,
                              &hKeySubKey,
                              &dwDisposition)
               != ERROR_SUCCESS)
            {
                return FALSE;
            }
            
            if(RegCreateKeyEx(hKeySubKey,
                              L"command",
                              0,
                              NULL,
                              REG_OPTION_NON_VOLATILE,
                              KEY_ALL_ACCESS,
                              NULL,
                              &hKeySubKey,
                              &dwDisposition)
               != ERROR_SUCCESS)
            {
                return FALSE;
            }


            if(RegSetValueEx(hKeySubKey,
                             L"",
                             0,
                             REG_EXPAND_SZ,
                             (LPBYTE)wcExePath,
                             lstrlenW(wcExePath) * sizeof(WCHAR))
               != ERROR_SUCCESS)
            {
                RegCloseKey(hkeyRootDunFile);
                return FALSE;
            }

            SHChangeNotify(SHCNE_ASSOCCHANGED,SHCNF_IDLIST,NULL,NULL);
            
            return TRUE;
        }
        return FALSE;

    
    }

    return FALSE;

}

BOOL
WINAPI
HandlerRoutine(
  DWORD dwCtrlType   //  control signal type
)
{
    wprintf(L"Working\n");
    return TRUE; // handle everything... don't want user breaking-in during sniff
}

BOOL
GetCmLogInfo(PCMINFO pCmInfo)
{   
    for(PCMINFO pCur=pCmInfo;pCur;pCur=pCur->pNext)
    {   
        WCHAR   pwcServiceName[MAX_PATH+1];
        
        if(GetPrivateProfileString(CM_SECTIONNAME,        // section name
                                   CM_SERVICENAME,        // key name
                                   L"",        // default string
                                   pwcServiceName,  // destination buffer
                                   MAX_PATH+1,              // size of destination buffer
                                   pCur->pszCmsFileName))
        {
            
            WCHAR   wcDirectory[MAX_PATH+1];
            WCHAR   wcFinal[MAX_PATH+1];

            if(GetPrivateProfileString(CM_LOGGING_SECTIONNAME,        // section name
                                       CM_LOGGING_KEYNAME,        // key name
                                       CM_LOGGING_DEFAULT_KEYNAME,        // default string
                                       wcFinal,  // destination buffer
                                       MAX_PATH+1,              // size of destination buffer
                                       pCur->pszCmsFileName))
            {
                wsprintf(wcDirectory, L"%s\\%s%s", wcFinal, pwcServiceName, CM_LOGGING_FILENAME_EXT);

                // expand environment strings, if necessary
                ExpandEnvironmentStrings(wcDirectory, wcFinal, MAX_PATH+1);

                if((pCur->pwcLogFileName = new WCHAR [ lstrlenW(wcFinal) + 1 ]))
                {
                    lstrcpyW(pCur->pwcLogFileName, wcFinal);
                }                                                  

                if((pCur->pwcServiceName = new WCHAR [ lstrlenW(pwcServiceName) + 1 ] ))
                {
                    lstrcpyW(pCur->pwcServiceName, pwcServiceName); 
                }

                // Store both b/c don't know which one will exist
                if((pCur->pwcRegKey = new WCHAR [ MAX_PATH + 1 ]))
                {
                    wsprintf(pCur->pwcRegKey, L"%s\\%s", CM_LOGGING_KEY_ALLUSER, pCur->pwcServiceName);  
                }

                if((pCur->pwcCurUserRegKey = new WCHAR [ MAX_PATH + 1 ]))
                {
                    wsprintf(pCur->pwcCurUserRegKey, L"%s\\%s", CM_LOGGING_KEY_CURUSER, pCur->pwcServiceName);  
                }
                
            }
        }
    }
    return TRUE;
}

void
FreeCmInfoResources(PCMINFO pCmInfo)
{
    if(pCmInfo == NULL) return;

    FreeCmInfoResources(pCmInfo->pNext);

    if(pCmInfo->pwcCurUserRegKey) {
        delete[] pCmInfo->pwcCurUserRegKey;
    }

    if(pCmInfo->pwcRegKey) {
        delete[] pCmInfo->pwcRegKey;
    }
    if(pCmInfo->pszCmsFileName) {
        delete[] pCmInfo->pszCmsFileName;
    }
    if(pCmInfo->pwcLogFileName) {
        delete[] pCmInfo->pwcLogFileName;
    }
    if(pCmInfo->pwcServiceName) {
        delete[] pCmInfo->pwcServiceName;
    }

    delete pCmInfo;
}

BOOL
SetCmLogState(PCMINFO pCmInfo, BOOL bEnabled)
{
    HKEY    hKey;
    DWORD   rc;

    for(PCMINFO pCur=pCmInfo;pCur;pCur=pCur->pNext)
    {
        // Set for all user
        if((rc=RegOpenKeyEx(HKEY_LOCAL_MACHINE,pCur->pwcRegKey,0,KEY_ALL_ACCESS, &hKey))
           == ERROR_SUCCESS) {                                                          
            
            if((rc=RegSetValueEx(hKey, CM_LOGGING_VALUE,0,REG_DWORD, (CONST BYTE *)&bEnabled, sizeof(BOOL)))
               != ERROR_SUCCESS) {
                return FALSE; // could open key, but couldn't set value    
            }                                                              
            RegCloseKey(hKey);

        } else {
            // not going to worry about it if key cannot be opened... this may be caused by a profile that has not been
            // attempted yet... in which case, the user has no reason to attempt diagnosis yet. Key will exist if user
            // tries profile and it fails for some reason.
        }   
        
        // Set for current user
        if((rc=RegOpenKeyEx(HKEY_CURRENT_USER,pCur->pwcCurUserRegKey,0,KEY_ALL_ACCESS, &hKey))
           == ERROR_SUCCESS) {                                                          
            
            if((rc=RegSetValueEx(hKey, CM_LOGGING_VALUE,0,REG_DWORD, (CONST BYTE *)&bEnabled, sizeof(BOOL)))
               != ERROR_SUCCESS) {
                return FALSE; // could open key, but couldn't set value    
            }                                                              
            RegCloseKey(hKey);

        } else {
            // not going to worry about it if key cannot be opened... this may be caused by a profile that has not been
            // attempted yet... in which case, the user has no reason to attempt diagnosis yet. Key will exist if user
            // tries profile and it fails for some reason.
        }   
        
    }                                                     
    return TRUE;
}

BOOL
DoCMLogSetup(PCMINFO *ppCmInfo)
{
    PCMINFO pCmInfo=NULL;
    WCHAR   wcCurUser[MAX_PATH+1];
    WCHAR   wcAllUser[MAX_PATH+1];

    ExpandEnvironmentStrings(CM_LOGGING_PATH_ALLUSER,wcAllUser,MAX_PATH+1);
    ExpandEnvironmentStrings(CM_LOGGING_PATH_CURUSER,wcCurUser,MAX_PATH+1);
    
    FindCmLog(wcAllUser, &pCmInfo, CMINFO_STATUS_ALLUSER);
    FindCmLog(wcCurUser, &pCmInfo, CMINFO_STATUS_CURUSER);

    GetCmLogInfo(pCmInfo);

    DeleteCMLogs(pCmInfo);

    *ppCmInfo = pCmInfo;

    return TRUE;
}

void
DeleteCMLogs(PCMINFO pCmInfo)
{
    for(PCMINFO pCur=pCmInfo;pCur;pCur=pCur->pNext)
    {
        DeleteFile(pCur->pwcLogFileName);
    }
}

void
FindCmLog(WCHAR *pszSource, PCMINFO *ppCmInfo, DWORD dwOpt)
{
    HANDLE  hFile;
    WIN32_FIND_DATA fd;
    WCHAR   wcFirst[MAX_PATH+1];

    wsprintf(wcFirst, L"%s\\*",pszSource);        

    if((hFile = FindFirstFile(wcFirst, &fd)) 
       == INVALID_HANDLE_VALUE) return;

    do {

        if(wcsstr(CharUpper(fd.cFileName), L".CMS"))
        {
            PCMINFO pCmInfo;

            pCmInfo=new CMINFO; 
            
            if(pCmInfo)
            {
                WCHAR   wcFileName[MAX_PATH+1];
                
                ZeroMemory(pCmInfo, sizeof(CMINFO));

                wsprintf(wcFileName, L"%s\\%s", pszSource, fd.cFileName);
                
                if((pCmInfo->pszCmsFileName = new WCHAR[ lstrlen(wcFileName) + 1 ]))
                {
                    lstrcpy(pCmInfo->pszCmsFileName, wcFileName);
                }                            
                
                pCmInfo->fStatus = dwOpt;

                pCmInfo->pNext = (*ppCmInfo);

                *ppCmInfo=pCmInfo;

            }                                                    

        }                                                        
            
        if(fd.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY &&
           fd.cFileName[0] != L'.') {
            
            WCHAR   wcPath[MAX_PATH+1];
            
            wsprintf(wcPath, L"%s\\%s", pszSource, fd.cFileName);

            FindCmLog(wcPath, ppCmInfo, dwOpt);
        }

    } while ( FindNextFile(hFile, &fd) );
     
    FindClose(hFile);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\rasdiag\rasdiag\event.h ===
/*++

Copyright (C) 1992-01 Microsoft Corporation. All rights reserved.

Module Name:

    event.h

Abstract:

    Forward definitions for event.cpp

Author:

    Anthony Leibovitz (tonyle) 02-01-2001

Revision History:


--*/

#ifndef _EVENT_H_
#define _EVENT_H_

#define     EVENT_FORMAT_STRING             TEXT("EVENT[%d/%s]: %s\r\n")
#define     SECURITY_AUDIT_INSERTION_LIB    TEXT("msaudite.dll")
#define     SECURITY_LOGNAME                TEXT("Security")
#define     MAX_EVENT_BUFF  2048*4
#define     MAX_TCHAR_ID_ULONG_SIZE 20

BOOL
GetEventLogInfo(HANDLE hWriteFile, DWORD dwMaxEvents);

BOOL
EnableAuditing(BOOL bEnable);

WCHAR *
ResolveEvent(WCHAR * pTemplateStr, WCHAR * *ppInsertionString, DWORD dwStrCount);

ULONG
SumInsertionSize(WCHAR * *ppInsertionString, DWORD dwStrCount);

BOOL
CreateStringArray(LPBYTE pSrcString, DWORD dwStringCount, WCHAR ***ppStrings, DWORD *pdwCount);

void
MyFreeStrings(WCHAR **pStringAry, DWORD dwCount);

WCHAR *
RemoveMiscChars(WCHAR *pString);

BOOL
ProcessEvent(HANDLE hWriteFile, EVENTLOGRECORD *pElr);

#endif //_EVENT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\rc\rc.c ===
#include "rc.h"

int CALLBACK RC(HWND hWnd, int fStatus,
                RC_MESSAGE_CALLBACK lpfnMsg, RC_PARSE_CALLBACK lpfnParse,
                int argc, PCHAR *argv);

extern BOOL WINAPI     Handler(DWORD fdwCtrlType);

int CALLBACK UpdateRCStatus(ULONG u, ULONG dw, PCHAR p)
{
    int i = strlen(p);
    PCHAR ppercent = strchr(p, '%');

    if (i >= 2 && ((p[i - 1] == '\n' && p[i - 2] == '\r') ||
                   (p[i - 1] == '\r' && p[i - 2] == '\n')))
        p[i-2] = '\0';

    if (*p) {
        if (ppercent) {
            for (ppercent=p,i=0 ; *ppercent ; ppercent++)
                if (*ppercent == '%')
                    i++;
            ppercent = malloc(strlen(p) + 1 + i);
            if (ppercent) {
                PCHAR pT = ppercent;

                while (*p) {
                    if (*p == '%')
                        *pT++ = '%';
                    *pT++ = *p++;
                }
                *pT++ = '\0';
                printf(ppercent);
            } else {
                while (strchr(p, '%'))
                    *strchr(p, '%') = ' ';
                printf(p);
            }
        } else {
            printf(p);
        }
    }
    printf("\n");

    return (0);
}

int __cdecl main(int nArgC, char** pArgV)
{
    int rc;

    SetConsoleCtrlHandler(Handler, TRUE);
    rc = RC(NULL, 0, UpdateRCStatus, NULL, nArgC, (PCHAR*)pArgV);
    SetConsoleCtrlHandler(Handler, FALSE);
    exit(rc);
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\rasdiag\rsniffsvc\rsniff.cpp ===
#include <conio.h>
#include <stdio.h>
#include <stdlib.h>
#include <windows.h>
#include <lmcons.h>
#include <userenv.h>
#include <ras.h>
#include <raserror.h>
#include <process.h>
#include <netmon.h>
#include <ncdefine.h>
#include <ncmem.h>
#include <diag.h>
#include <winsock.h>
#include <devguid.h>
#include "rsniffclnt.h"
#include "rasdiag.h"

SERVICE_STATUS_HANDLE   g_hSs=NULL;
SOCKET                  g_sock;
HANDLE                  g_hTerminateEvent=NULL;

#define RSNIFF_SERVICE_NAME     TEXT("RSNIFF") 
#define RSNIFF_DISPLAY_NAME     TEXT("RAS REMOTE SNIFF AGENT")
#define INSTALL_PATH            TEXT("C:\\RSNIFF")

BOOL
WriteLogEntry(HANDLE hFile, DWORD dwCallID, WCHAR *szClientName, WCHAR *pszTextMsg);

BOOL
CreateNewService(void);

BOOL
UninstallService(void);

void
RSniffServiceMain(DWORD argc, LPTSTR *argv);
                                 
void
BeSniffServer(SOCKET s,PRASDIAGCAPTURE pInterfaces, DWORD dwInterfaces);

DWORD
WINAPI
RSniffSvcHandler(DWORD dwControl,DWORD dwEventType,LPVOID lpEventData,LPVOID lpContext);

BOOL
SetupListen(SOCKET *ps);

BOOL
Init(PRASDIAGCAPTURE *ppInterfaces, DWORD *pdwInterfaces, SOCKET *ps);
                                                                    
BOOL
Init(PRASDIAGCAPTURE *ppInterfaces, DWORD *pdwInterfaces, SOCKET *ps)
{
    PRASDIAGCAPTURE pInterfaces=NULL;
    DWORD           dwInterfaces=0;
    HRESULT         hr;
    SOCKET          s;
    
    *ppInterfaces = NULL;
    *pdwInterfaces = 0;
    
    hr = CoInitialize(NULL);
    
    if(!SUCCEEDED(hr)) {
        return FALSE;
    }

    // Create a termination event
   if((g_hTerminateEvent = CreateEvent(NULL, TRUE, FALSE, NULL))
      == NULL) return FALSE;

    if(InitWinsock() == FALSE) {
        wprintf(L"could not init winsock\n");
        return FALSE;
    }
    
    if(IdentifyInterfaces(&pInterfaces, &dwInterfaces) == FALSE) {
        wprintf(L"Could not ID interfaces\n");
        return FALSE;
    }

    if(SetupListen(&s) == FALSE) {
        wprintf(L"Could not listen!\n");
        return FALSE;
    }
    
    *ps = s;
    *ppInterfaces = pInterfaces;
    *pdwInterfaces = dwInterfaces;

    return TRUE;
}

int
__cdecl
wmain(int argc, TCHAR **argv)
{
   SERVICE_TABLE_ENTRY  ste[] = {

      RSNIFF_SERVICE_NAME, RSniffServiceMain,
      NULL, NULL
   };
                    
    if (argc>1) {

        if(lstrcmpi(argv[1], L"-i") == 0) {
            wprintf(L"Installing RSNIFF. Result = %s\n", CreateNewService() ? L"Done" : L"Failed!!");
            return 0;
        }

        if(lstrcmpi(argv[1], L"-u") == 0) {
            wprintf(L"Uninstalling RSNIFF. Result = %s\n", UninstallService() ? L"Done" : L"Failed!!");
            return 0;
        }
        
        if(lstrcmpi(argv[1], L"-?") == 0 || lstrcmpi(argv[1], L"/?") == 0) {
            wprintf(L"\n"
                   L"------------------------------------------------\n"
                   L"RSNIFF - RAS REMOTE SNIFFING AGENT SERVICE (%d.%d)\n"
                   L"------------------------------------------------\n"
                   L"-i         Install RSNIFF service\n"
                   L"-u         Uninstall RSNIFF service\n"
                   L"-?         This menu\n"
                   L"/?         This menu\n"
                   L"------------------------------------------------\n", RASDIAG_MAJOR_VERSION, RASDIAG_MINOR_VERSION
                   );
            return 0;
        }
        
        return 0;
    }

    if(StartServiceCtrlDispatcher(ste) == FALSE) 
    {
        return 0;
    }
    return 1;
}

DWORD
WINAPI
RSniffSvcHandler(DWORD dwControl,DWORD dwEventType,LPVOID lpEventData,LPVOID lpContext)
{  
   SERVICE_STATUS ss;

   switch(dwControl)
   {
   
   case SERVICE_CONTROL_STOP:

      ss.dwServiceType        = SERVICE_WIN32; 
      ss.dwCurrentState       = SERVICE_STOP_PENDING; 
      ss.dwControlsAccepted   = SERVICE_CONTROL_INTERROGATE; 
      ss.dwWin32ExitCode      = 0; 
      ss.dwServiceSpecificExitCode = 0; 
      ss.dwCheckPoint         = 1; 
      ss.dwWaitHint           = 60*1000; 
      SetServiceStatus(g_hSs, &ss);
      
      //
      // set event that causes service to exit
      //
      SetEvent(g_hTerminateEvent);
      closesocket(g_sock);
      return NO_ERROR;
      break;

   }
   return ERROR_CALL_NOT_IMPLEMENTED;
}  

void
RSniffServiceMain(DWORD argc, LPTSTR *argv)
{
   SERVICE_STATUS_HANDLE  hSs;
   SERVICE_STATUS         ss;
   PRASDIAGCAPTURE        pInterfaces=NULL;
   DWORD                  dwInterfaces=0;
   SOCKET                 s;
   
   ZeroMemory(&ss, sizeof(SERVICE_STATUS));
   
   if((g_hSs=hSs=RegisterServiceCtrlHandlerEx(RSNIFF_SERVICE_NAME, RSniffSvcHandler,0))
      == 0) return;
   
   ss.dwServiceType        = SERVICE_WIN32; 
   ss.dwCurrentState       = SERVICE_START_PENDING; 
   ss.dwControlsAccepted   = SERVICE_ACCEPT_STOP; 
   ss.dwWin32ExitCode      = 0; 
   ss.dwServiceSpecificExitCode = 0; 
   ss.dwCheckPoint         = 0; 
   ss.dwWaitHint           = 0; 
                                          
   if(Init(&pInterfaces, &dwInterfaces, &s)==TRUE) {
      
      ss.dwCurrentState       = SERVICE_RUNNING; 
      
      SetServiceStatus (hSs, &ss);
      
      //
      // Report start event to eventlog
      //
      //MyReportEvent(BEACONMSG_STARTED, EVENTLOG_INFORMATION_TYPE, NULL, 0);
      
      //
      // Execute the service - run until term event is signalled
      //
      BeSniffServer(s,pInterfaces,dwInterfaces);

      //
      // Unload winsock
      //
      WSACleanup();
   
      //
      // Report halt to event log
      //
      //MyReportEvent(BEACONMSG_STOPPED, EVENTLOG_INFORMATION_TYPE, NULL, 0);

   } else {
      
      //
      // Report the init failure
      //
      //MyReportEvent(BEACONMSG_STOPPED, EVENTLOG_INFORMATION_TYPE, NULL, 0);
   }                                                                                    
   
   ss.dwServiceType        = SERVICE_WIN32; 
   ss.dwCurrentState       = SERVICE_STOPPED; 
   ss.dwControlsAccepted   = 0; 
   ss.dwWin32ExitCode      = 0; 
   ss.dwServiceSpecificExitCode = 0; 
   ss.dwCheckPoint         = 0; 
   ss.dwWaitHint           = 0; 

   //
   // Tell service controller that service is halted.
   //
   SetServiceStatus(g_hSs, &ss);

   //DBGPRINTF(D, TEXT("Beacon service is halting\n"));
   
   return;
}

BOOL
SetupListen(SOCKET *ps)
{
    SOCKADDR_IN    ServSockAddr  = { AF_INET };
    SOCKET         s;

    ServSockAddr.sin_port        = htons(TCP_SERV_PORT);
    ServSockAddr.sin_addr.s_addr = INADDR_ANY;
    ServSockAddr.sin_family      = AF_INET;

    wprintf(L"Create listen socket...\n");
    if((g_sock=s=socket(AF_INET, SOCK_STREAM, 0)) == INVALID_SOCKET)
    {
       wprintf(L"Create listen socket failed! (%d)", WSAGetLastError());
       return FALSE;
    }

    //
    // Bind an address to the socket
    //
    wprintf(L"Bind listen socket...\n");
    if (bind(s, (const struct sockaddr *) &ServSockAddr,
      sizeof(SOCKADDR_IN)) == SOCKET_ERROR)
    {
        wprintf(L"Bind failed...\n");
       //
       // Close the socket
       //
       closesocket(s);           
       return FALSE;                   
    }

    //
    // Attempt to listen
    //
    wprintf(L"Listen...\n");
    if(listen(s, 1) == SOCKET_ERROR)
    {

       wprintf(L"Could not listen...\n");

       //
       // Close the socket
       //
       closesocket(s);

       return FALSE;
       
    }

    *ps = s;

    return TRUE;
}

void
BeSniffServer(SOCKET s,PRASDIAGCAPTURE pInt, DWORD dwIntCount)
{
    HANDLE hLog;
    WCHAR  szLogFileName[MAX_PATH+1];
    SYSTEMTIME  st;
    DWORD   dwCallerID=0;

    GetLocalTime(&st);
    
    wsprintf(szLogFileName, L"%s\\%04d%02d%02d%02d%02d-RSNIFFLOG.TXT",
             INSTALL_PATH,
             st.wYear,
             st.wMonth,
             st.wDay,
             st.wHour,
             st.wMinute,
             st.wSecond);

    hLog = CreateFile(szLogFileName,
                      GENERIC_READ|GENERIC_WRITE,
                      FILE_SHARE_READ,
                      NULL,
                      CREATE_ALWAYS,
                      0,NULL);

    if(hLog == INVALID_HANDLE_VALUE)
        hLog = NULL;

    WriteLogEntry(hLog, 0, L"RSNIFFSVC", L"Service Started");

    while(1)
    {
        REMOTECAPTURE       rc;
        REMOTECAPTURE_V5    rc_v5;
        SOCKADDR_IN         PeerSockAddr;
        SOCKET              NewSock=0;
        BYTE                x;
        int                 iSize = sizeof(SOCKADDR_IN);
        DWORD               i,dwStatus;
        SYSTEMTIME  st;
        WCHAR               wcRootDir[MAX_PATH+1];

        // should always be signalled except when we're going to quit.
        if(WaitForSingleObject(g_hTerminateEvent, 0) != WAIT_TIMEOUT) {
            CloseHandle(hLog);
            return; 
        }                                       

        wprintf(L"Waiting for connection\n");
        if((NewSock = accept(s, (struct sockaddr *) &PeerSockAddr,
                             &iSize)) == INVALID_SOCKET)
        {
            wprintf(L"accept() failed\n");
            continue;

        }

        // Increment the caller count
        dwCallerID++;

        GetLocalTime(&st);

        // Receive least common denominator...
        if(RecvBuffer(NewSock, (LPBYTE)&rc_v5, sizeof(REMOTECAPTURE_V5)) == FALSE)
        {
            wprintf(L"Recv invalid REMOTECAPTURE (rc.dwVer=%d)\n", rc.dwVer); 
            closesocket(NewSock);
            continue;
        }

        // Convert v5 -> v7 structure
        if(rc_v5.dwVer == sizeof(REMOTECAPTURE_V5))
        {   
            REMOTECAPTURE        rc_new;
            PREMOTECAPTURE_V5    pRc5=(PREMOTECAPTURE_V5)&rc_v5;
            
            ZeroMemory(&rc_new, sizeof(REMOTECAPTURE));

            rc_new.dwVer = sizeof(REMOTECAPTURE);
            mbstowcs(rc_new.szMachine, pRc5->szMachine, lstrlenA(pRc5->szMachine)+1);
            
            WriteLogEntry(hLog, dwCallerID, rc_new.szMachine, L"Version 5 client");

            // All pre v7 clients will want to do sniff.
            rc_new.dwOpt1 = RSNIFF_OPT1_DOSNIFF;

            memcpy(&rc,&rc_new,sizeof(REMOTECAPTURE));
        
        } else   // Convert v6 -> v7 structure 
            if(rc_v5.dwVer == sizeof(REMOTECAPTURE_V6)) {   

            REMOTECAPTURE        rc_new;
            PREMOTECAPTURE_V5    pRc5=(PREMOTECAPTURE_V5)&rc_v5;

            // copy portion of struct received.
            memcpy(&rc_new, pRc5, sizeof(REMOTECAPTURE_V5));
            
            WriteLogEntry(hLog, dwCallerID, rc_new.szMachine, L"Version 6 client");

            // Receive the remaining part of the v6 structure...
            if(RecvBuffer(NewSock, (LPBYTE)&rc_new + sizeof(REMOTECAPTURE_V5), (sizeof(REMOTECAPTURE_V6) - sizeof(REMOTECAPTURE_V5))) == FALSE)
            {
                WriteLogEntry(hLog, dwCallerID, rc_new.szMachine, L"Recv err!");
                wprintf(L"Recv invalid REMOTECAPTURE (rc.dwVer=%d)\n", rc.dwVer); 
                closesocket(NewSock);
                continue;
            }

            // Covert structure (since copied from V6, just change version number
            rc_new.dwVer = sizeof(REMOTECAPTURE);
            
            // All pre v7 clients will want to do sniff.
            rc_new.dwOpt1 = RSNIFF_OPT1_DOSNIFF;

            // copy structure 
            memcpy(&rc,&rc_new,sizeof(REMOTECAPTURE));
            

        } else if(rc_v5.dwVer == sizeof(REMOTECAPTURE)) {

            REMOTECAPTURE        rc_new;
            PREMOTECAPTURE_V5    pRc5=(PREMOTECAPTURE_V5)&rc_v5;

            // copy portion of struct received.
            memcpy(&rc_new, pRc5, sizeof(REMOTECAPTURE_V5));
            
            WriteLogEntry(hLog, dwCallerID, rc_new.szMachine, L"Version 7 client");
                
            // Receive the remaining part of the v6 structure...
            if(RecvBuffer(NewSock, (LPBYTE)&rc_new + sizeof(REMOTECAPTURE_V5), (sizeof(REMOTECAPTURE) - sizeof(REMOTECAPTURE_V5))) == FALSE)
            {
                WriteLogEntry(hLog, dwCallerID, rc_new.szMachine, L"Recv err!");
                wprintf(L"Recv invalid REMOTECAPTURE (rc.dwVer=%d)\n", rc.dwVer); 
                closesocket(NewSock);
                continue;
            }                                                            

            // valid v7 structure - read remaining bytes; no conversion necessary

            // copy structure 
            memcpy(&rc,&rc_new,sizeof(REMOTECAPTURE));


        } else {
            // no idea what this is...
            WriteLogEntry(hLog, dwCallerID, L"UNKNOWN CLIENT!", NULL);
            wprintf(L"Recv invalid REMOTECAPTURE version (rc.dwVer=%d)\n", rc.dwVer); 
            closesocket(NewSock);
            continue;
        }
        
        wsprintf(wcRootDir, L"%s\\%04d%02d%02d%02d%02d%02d-%s-SID_%03d",
                 INSTALL_PATH,
                 st.wYear,
                 st.wMonth,
                 st.wDay,
                 st.wHour,
                 st.wMinute,
                 st.wSecond,
                 rc.szMachine,
                 dwCallerID);

        CreateDirectory(wcRootDir,NULL);

        if(rc.dwOpt1 & RSNIFF_OPT1_DOSNIFF)
        {
            WriteLogEntry(hLog, dwCallerID, rc.szMachine, L"Request for local network sniff");

            wprintf(L"Sniffing traffic for caller: %s\n", rc.szMachine);

            // start sniffing
            for(i=0;i<dwIntCount;i++)
            {
                // Initialize this interface...
                if(InitIDelaydC(pInt[i].hBlob, &pInt[i].pIDelaydC) == TRUE)
                {
                    if(pInt[i].pIDelaydC)
                    {
                        CHAR    szCaptureFile[MAX_PATH+1];

                        dwStatus = pInt[i].pIDelaydC->Start(szCaptureFile);
                        if(dwStatus != NMERR_SUCCESS)
                        {
                            wprintf(L"pIDelaydC->Start() FAILED! Start rtn %x\n", dwStatus);
                            pInt[i].pIDelaydC->Disconnect();
                        } else {
                            // convert mbs to wide 
                            mbstowcs(pInt[i].szCaptureFileName, szCaptureFile, lstrlenA(szCaptureFile)+1);
                        }
                    }                                                                   

                } else {
                    wprintf(L"InitIDelaydC() failed\n");
                }

            }

        }
        
        // Get pre-connect routing table info
        if(rc.dwOpt1 & RSNIFF_OPT1_GETSRVROUTINGINFO)
        {
            WCHAR       szRoutingInfo[MAX_PATH+1];

            WriteLogEntry(hLog, dwCallerID, rc.szMachine, L"Request for local routing table");
            
            wsprintf(szRoutingInfo, L"route print > %s\\ROUTINGINFO.TXT", wcRootDir);
            _wsystem(szRoutingInfo);

            wsprintf(szRoutingInfo, L"ipconfig >> %s\\ROUTINGINFO.TXT", wcRootDir);
            _wsystem(szRoutingInfo);
            
        }

        // wait until remote closes socket
        RecvBuffer(NewSock, (LPBYTE)&x, 1);
        
        closesocket(NewSock);

        // Get the routing table info
        if(rc.dwOpt1 & RSNIFF_OPT1_GETSRVROUTINGINFO)
        {
            WCHAR   szRoutingInfo[MAX_PATH+1];

            wsprintf(szRoutingInfo, L"route print >> %s\\ROUTINGINFO.TXT", wcRootDir);
            _wsystem(szRoutingInfo);

            wsprintf(szRoutingInfo, L"ipconfig >> %s\\ROUTINGINFO.TXT", wcRootDir);
            _wsystem(szRoutingInfo);
            
        }

        if(rc.dwOpt1 & RSNIFF_OPT1_DOSNIFF)
        {
        
            wprintf(L"Sniffing complete\n");
    
            // Stop sniffing...
            for(i=0;i<dwIntCount;i++)
            {
                dwStatus = pInt[i].pIDelaydC->Stop(&pInt[i].stats);
                if(dwStatus != NMERR_SUCCESS)
                {
                    wprintf(L"pIDelaydC->Stop() rtn %x\n", dwStatus);
                    pInt[i].pIDelaydC->Disconnect();
                }
    
                if(pInt[i].stats.TotalBytesCaptured)
                {
                    WCHAR   szNewFileName[MAX_PATH+1];
                    WCHAR   *pChar=NULL;
                    WCHAR   *pFn=NULL;
    
                    pFn = pInt[i].szCaptureFileName + lstrlenW(pInt[i].szCaptureFileName) + 1;

                    // Get the filename
                    while(*pFn != '\\' && pFn!=pInt[i].szCaptureFileName) pFn--;
                    pFn++;

                    wprintf(L"%d LAN bytes captured (%s)\n", pInt[i].stats.TotalBytesCaptured, pInt[i].szCaptureFileName);
    
                    wsprintf(szNewFileName,L"%s\\%s__%s_SID_%d.CAP", wcRootDir, pFn, rc.szMachine, dwCallerID);
    
                    if((pChar=wcsstr(szNewFileName, L"."))
                       != NULL) {
                        *pChar='_';
                       }
    
                    wprintf(L"Saving %s\n", szNewFileName);
    
                    MoveFile(pInt[i].szCaptureFileName, szNewFileName);
    
    
                } else {
                    wprintf(L"%d bytes captured (%s)\n", pInt[i].stats.TotalBytesCaptured, pInt[i].szCaptureFileName);
                }
    
                // Disconnect
                if(pInt[i].pIDelaydC)
                {
                    pInt[i].pIDelaydC->Disconnect();
                }                              
            }
    
            WriteLogEntry(hLog, dwCallerID, rc.szMachine, L"Client processing complete.");

            wprintf(L"Sniffing complete\n");
        }
    }

}

void
Listen(PRASDIAGCAPTURE pInt, DWORD dwIntCount)
{
   SOCKADDR_IN    ServSockAddr  = { AF_INET };
   SOCKET         s;

   ServSockAddr.sin_port        = htons(TCP_SERV_PORT);
   ServSockAddr.sin_addr.s_addr = INADDR_ANY;
   ServSockAddr.sin_family      = AF_INET;
   
   wprintf(L"Create listen socket...\n");
   if((s=socket(AF_INET, SOCK_STREAM, 0)) == INVALID_SOCKET)
   {
      wprintf(L"Create listen socket failed! (%d)", WSAGetLastError());
   }

   //
   // Bind an address to the socket
   //
   wprintf(L"Bind listen socket...\n");
   if (bind(s, (const struct sockaddr *) &ServSockAddr,
     sizeof(SOCKADDR_IN)) == SOCKET_ERROR)
   {
       wprintf(L"Bind failed...\n");
      //
      // Close the socket
      //
      closesocket(s);           
      return;                   
   }

   //
   // Attempt to listen
   //
   wprintf(L"Listen...\n");
   if(listen(s, 1) == SOCKET_ERROR)
   {
      
      wprintf(L"Could not listen...\n");

      //
      // Close the socket
      //
      closesocket(s);

      return;
         
   }

   while(1)
   {
       REMOTECAPTURE  rc;
       SOCKADDR_IN    PeerSockAddr;
       SOCKET         NewSock=0;
       BYTE           x;
       int           iSize = sizeof(SOCKADDR_IN);
       DWORD            i,dwStatus;

       wprintf(L"Waiting for connection\n");
       if((NewSock = accept(s, (struct sockaddr *) &PeerSockAddr,
                            &iSize)) == INVALID_SOCKET)
       {
           wprintf(L"accept() failed\n");
           continue;

       }
       
       if(RecvBuffer(NewSock, (LPBYTE)&rc, sizeof(REMOTECAPTURE)) == FALSE)
       {
           wprintf(L"Recv invalid REMOTECAPTURE (rc.dwVer=%d)\n", rc.dwVer); 
           closesocket(NewSock);
           continue;
       }

       wprintf(L"Sniffing traffic for caller: %s\n", rc.szMachine);
                                              
       // start sniffing
       for(i=0;i<dwIntCount;i++)
       {
           // Initialize this interface...
           if(InitIDelaydC(pInt[i].hBlob, &pInt[i].pIDelaydC) == TRUE)
           {
               if(pInt[i].pIDelaydC)
               {
                   CHAR szCaptureName[MAX_PATH+1];

                   dwStatus = pInt[i].pIDelaydC->Start(szCaptureName);
                   if(dwStatus != NMERR_SUCCESS)
                   {
                       wprintf(L"pIDelaydC->Start() FAILED! Start rtn %x\n", dwStatus);
                       pInt[i].pIDelaydC->Disconnect();
                   } else {

                       mbstowcs(pInt[i].szCaptureFileName, szCaptureName, lstrlenA(szCaptureName)+1);
                   }
               }                                                                   

           } else {
               wprintf(L"InitIDelaydC() failed\n");
           }

       }

       // wait until remote closes socket
       RecvBuffer(NewSock, (LPBYTE)&x, 1);
       
       closesocket(NewSock);

       wprintf(L"Sniffing complete\n");
       
       // Stop sniffing...
       for(i=0;i<dwIntCount;i++)
       {
           dwStatus = pInt[i].pIDelaydC->Stop(&pInt[i].stats);
           if(dwStatus != NMERR_SUCCESS)
           {
               wprintf(L"pIDelaydC->Stop() rtn %x\n", dwStatus);
               pInt[i].pIDelaydC->Disconnect();
           }

           if(pInt[i].stats.TotalBytesCaptured)
           {
               WCHAR szNewFileName[MAX_PATH+1];
               WCHAR *pChar=NULL;

               wprintf(L"%d LAN bytes captured (%s)\n", pInt[i].stats.TotalBytesCaptured, pInt[i].szCaptureFileName);
               
               wsprintf(szNewFileName, L"%s__%s.CAP", pInt[i].szCaptureFileName, rc.szMachine);
               
               if((pChar=wcsstr(szNewFileName, L"."))
                  != NULL) {
                   *pChar='_';
                  }

               wprintf(L"Saving %s\n", szNewFileName);

               MoveFile(pInt[i].szCaptureFileName, szNewFileName);

               
           } else {
               wprintf(L"%d bytes captured (%s)\n", pInt[i].stats.TotalBytesCaptured, pInt[i].szCaptureFileName);
           }

           // Disconnect
           if(pInt[i].pIDelaydC)
           {
               pInt[i].pIDelaydC->Disconnect();
           }                              
       }
       
       wprintf(L"Sniffing complete\n");
       
       
   }

}

BOOL
IdentifyInterfaces(PRASDIAGCAPTURE *hLAN, DWORD *pdwLanCount)
{
    DWORD   dwStatus;
    HBLOB   hBlob;
    BLOB_TABLE *pTable=NULL;
    DWORD   i;
    BOOL    bRas=FALSE;
    DWORD   dwLanCount=0;
    PRASDIAGCAPTURE hLanAr=NULL;

    *hLAN = NULL;
    *pdwLanCount = 0;

    if((hLanAr = (PRASDIAGCAPTURE)LocalAlloc(LMEM_ZEROINIT, sizeof(RASDIAGCAPTURE) * MAX_LAN_CAPTURE_COUNT))
       == NULL) return FALSE;

    wprintf(L"Identifying Network Interfaces\n");

    // Create blob for blob table
    dwStatus = CreateBlob(&hBlob);

    if(dwStatus != NMERR_SUCCESS) {
        wprintf(L"Blob not created!\n");
        return FALSE;
    }

    // Get the blob table
    dwStatus = GetNPPBlobTable(hBlob, &pTable);

    if(dwStatus != NMERR_SUCCESS) {
        wprintf(L"GetNPPBlobTable failed (%d)!\n",dwStatus);
        DestroyBlob(hBlob);
        return FALSE;
    }   

    wprintf(L"Interface Count: %d\n",pTable->dwNumBlobs);

    for(i=0;i<pTable->dwNumBlobs && (dwLanCount < MAX_LAN_CAPTURE_COUNT);i++)
    {
        NETWORKINFO ni;
        
        dwStatus = GetNetworkInfoFromBlob(pTable->hBlobs[i], &ni);

        if(dwStatus == NMERR_SUCCESS)
        {
            wprintf(L"----------------------------------------\n");
            wprintf(L"%d. LinkSpeed: %d (%d)\n", i,ni.LinkSpeed, ni.MacType );
            
            if(NMERR_SUCCESS != GetBoolFromBlob( pTable->hBlobs[i],
                        OWNER_NPP,
                        CATEGORY_LOCATION, //CATEGORY_NETWORKINFO, 
                        TAG_RAS,
                        &bRas)) 
            {
                DestroyBlob(hBlob);
                return FALSE;
            }  

            if(bRas) 
            {
                wprintf(L"Interface %d: %s\n", i, TAG_RAS);
                hLanAr[dwLanCount].hBlob=pTable->hBlobs[i];
                hLanAr[dwLanCount++].bWan=TRUE;
            
            } else {

                const char *pString=NULL;

                if(GetStringFromBlob(pTable->hBlobs[i],
                                  OWNER_NPP,
                                  CATEGORY_LOCATION,
                                  TAG_MACADDRESS,
                                  &pString)
                   == NMERR_SUCCESS)
                {
                    //wprintf(L"Interface %d: %s (MAC: %s)\n", i, "LAN", pString);

                } else {
                    //wprintf(L"Interface %d: %s (UNKNOWN)\n", i, "LAN");
                }
            
                                    
                // use this interface only if the mac type
                // is one of the following:
                if(ni.MacType == MAC_TYPE_ETHERNET ||
                   ni.MacType == MAC_TYPE_TOKENRING ||
                   ni.MacType == MAC_TYPE_ATM)
                                       
                    if(pString)
                    {                                                                                                        
                        if((hLanAr[dwLanCount].pszMacAddr = (WCHAR*)LocalAlloc(LMEM_ZEROINIT, sizeof(WCHAR) * (lstrlenA(pString) + 1)))
                            != NULL)
                            mbstowcs(hLanAr[dwLanCount].pszMacAddr, pString, lstrlenA(pString));
                    }

                    hLanAr[dwLanCount++].hBlob = pTable->hBlobs[i];
                                       
            }                                        

        } else {
            
            wprintf(L"GetNetworkInfoFromBlob rtn %d\n", dwStatus);

            DestroyBlob(hBlob);
            return FALSE;
        }

    }
    wprintf(L"----------------------------------------\n");
    DestroyBlob(hBlob);

    if(dwLanCount)
    {
        *pdwLanCount = dwLanCount;
        *hLAN = hLanAr;
    }                  
    
    return TRUE;

}

BOOL
InitWinsock(void)
{
   WSADATA     WSAData;
   WORD        WSAVerReq = MAKEWORD(2,0);

   if (WSAStartup(WSAVerReq, &WSAData)) {
      return FALSE;
   } else
      return TRUE;

}

PSOCKCB
TcpConnectRoutine(LPSTR pAddr)
{

   SOCKADDR_IN    DstAddrIP  = { AF_INET };
   HOSTENT        *pHost;
   ULONG          uAddr;
   PSOCKCB        pSock;
   BOOL           bResult;
   ULONG          ulHostAddr=0;

   //
   // Resolve name
   //

   if ((ulHostAddr = inet_addr(pAddr)) == -1L)
   {
      return NULL;
   }

   uAddr = ntohl(ulHostAddr);

   wprintf(L"Connecting to remote server sniffing agent (ADDR: %d.%d.%d.%d)\n",
        ((struct in_addr *) &uAddr)->S_un.S_un_b.s_b4,
        ((struct in_addr *) &uAddr)->S_un.S_un_b.s_b3,
        ((struct in_addr *) &uAddr)->S_un.S_un_b.s_b2,
        ((struct in_addr *) &uAddr)->S_un.S_un_b.s_b1);

   DstAddrIP.sin_port        = htons(TCP_SERV_PORT);
   DstAddrIP.sin_addr.s_addr = htonl(uAddr);

   //
   // Create socket
   //
   pSock = CreateSocket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
   if(pSock == NULL)
      return NULL;

   //
   // Connect the socket
   //
   if(ConnectSock(pSock, (struct sockaddr *)&DstAddrIP, sizeof(SOCKADDR_IN))
      != TRUE)
   {
      wprintf(L"Could not connect to remote server sniffing agent!\n");
      closesocket(pSock->s);
      LocalFree(pSock);
      return NULL;
   }
   return pSock;
}

BOOL
ConnectSock(PSOCKCB pSock, SOCKADDR* pDstAddr, int size)
{
   int   err;

   //
   // Connect the socket
   //
   err = connect(pSock->s, pDstAddr, size);
   if(err==SOCKET_ERROR)
   {
      return FALSE;
   }
   return TRUE;

}

PSOCKCB
CreateSocket(int Af, int Type, int Proto)
{
   PSOCKCB   pSock;

   if((pSock = (PSOCKCB)LocalAlloc(LMEM_ZEROINIT, sizeof(SOCKCB)))
      == NULL)
      return NULL;

   //
   // Create a socket
   //
   if((pSock->s = socket(Af, Type, Proto))
      == INVALID_SOCKET)
   {
      LocalFree(pSock);
      return NULL;
   }

   return pSock;
}

BOOL
SendStartSniffPacket(PSOCKCB pSock)
{
    REMOTECAPTURE   rc;
    DWORD           dwSize = MAX_COMPUTERNAME_LENGTH+1;

    ZeroMemory(&rc, sizeof(REMOTECAPTURE));

    rc.dwVer = sizeof(REMOTECAPTURE);

    GetComputerName(rc.szMachine, &dwSize);
                                                            
    return SendBuffer(pSock->s, (LPBYTE)&rc, sizeof(REMOTECAPTURE));

}

BOOL
SendBuffer(SOCKET s, LPBYTE pBuffer, ULONG uSize)
{
   ULONG err,uSent, uBytesSent=0;

   while(uBytesSent != uSize)
   {
       uSent = send(s, (const char *)(pBuffer+uBytesSent), uSize-uBytesSent, 0);

      switch(uSent)
      {
      case SOCKET_ERROR:
         err = WSAGetLastError();
         return FALSE;
         break;

      case 0:
         return FALSE;

      default:
         uBytesSent+=uSent;
         break;
      }
   }
   return TRUE;
}


BOOL
RecvBuffer(SOCKET s, LPBYTE pBuffer, ULONG uSize)
{
   ULONG err=0,uRecv=0, uBytesRecv=0;

   while(uBytesRecv != uSize)
   {
       wprintf(L"Recv...\n");
       uRecv = recv(s, (char *)pBuffer+uBytesRecv, uSize-uBytesRecv, 0);

      switch(uRecv)
      {
      case SOCKET_ERROR:
         err=WSAGetLastError();
         wprintf(L"err=%d\n",err);
         return FALSE;
         break;

      case 0:
         wprintf(L"Socket gracefully closed by peer\n");
         return FALSE;

      default:
         uBytesRecv += uRecv;
         wprintf(L"rtn %d bytes recv\n", uBytesRecv);
         break;
      }
   }
   wprintf(L"RecvBuffer complete\n");
   return TRUE;
}

BOOL
InitIDelaydC(HBLOB hBlob, IDelaydC **ppIDelaydC)
{
    DWORD       dwStatus;
    const char *sterrLSID;
    IDelaydC    *pIDelaydC=NULL;

    wprintf(L"hBlob: %p\n", hBlob);

    if(NMERR_SUCCESS != GetStringFromBlob(hBlob,OWNER_NPP,CATEGORY_LOCATION,TAG_CLASSID,&sterrLSID))
    {
        wprintf(L"GetStringFromBlob failed\n");
        return FALSE;
    }

    wprintf(L"ClassID: %s\n",sterrLSID); 

    dwStatus = CreateNPPInterface(hBlob,IID_IDelaydC,(void**)&pIDelaydC);
    
    if(dwStatus != NMERR_SUCCESS)
    {
        wprintf(L"CreateNPPInterface rtn %x (%p)\n", dwStatus, pIDelaydC);
        return FALSE;
    }

    dwStatus = pIDelaydC->Connect(hBlob,NULL,NULL,NULL);
    
    if(dwStatus != NMERR_SUCCESS)
    {
        wprintf(L"Connect rtn %x\n", dwStatus);
        return FALSE;
    }

    *ppIDelaydC = pIDelaydC; 

    return TRUE;

}
                      

BOOL
CreateNewService(void)
{
   SC_HANDLE    schService, schSCManager;
   WCHAR        szPath[MAX_PATH+1];
   LPCTSTR      lpszBinaryPathName = szPath; 

   wsprintf(szPath, L"%s\\RSNIFF.EXE", INSTALL_PATH);
                                       
   if((schSCManager= OpenSCManager(NULL,NULL,SC_MANAGER_CREATE_SERVICE))
      == NULL) return FALSE;

   if((schService = CreateService( 
        schSCManager,              // SCManager database 
        RSNIFF_SERVICE_NAME,              // name of service 
        RSNIFF_DISPLAY_NAME,           // service name to display 
        SERVICE_ALL_ACCESS,        // desired access 
        SERVICE_WIN32_OWN_PROCESS | SERVICE_INTERACTIVE_PROCESS, // service type 
        SERVICE_AUTO_START,      // start type 
        SERVICE_ERROR_NORMAL,      // error control type 
        lpszBinaryPathName,        // service's binary 
        NULL,                      // no load ordering group 
        NULL,                      // no tag identifier 
        NULL,                      // no dependencies 
        NULL,                      // LocalSystem account 
        NULL))                     // no password 
 
      == NULL)
   {                                   
      
      WCHAR szErrTxt[MAX_PATH+1];
       
      wsprintf(szErrTxt, L"Could not install Beacon service. Err=%d", GetLastError());
      
      wprintf(L"%s\n", szErrTxt);

      CloseServiceHandle(schSCManager);
      return FALSE;
   }

   CloseServiceHandle(schService);
   CloseServiceHandle(schSCManager);   
  
   return TRUE;

}

BOOL
UninstallService(void)
{
   SC_HANDLE  schService, schSCManager;
   
   if((schSCManager=OpenSCManager(NULL,NULL,SC_MANAGER_CREATE_SERVICE))
      == NULL) return FALSE;

   if((schService = OpenService(schSCManager,RSNIFF_SERVICE_NAME, SERVICE_ALL_ACCESS))
      == NULL) {

      WCHAR szErrTxt[MAX_PATH+1];

      wsprintf(szErrTxt, L"Could not uninstall Beacon service. Err=%d", GetLastError());

      wprintf(L"%s\n", szErrTxt);

      CloseServiceHandle(schSCManager);
      return FALSE;
   }
                             
   DeleteService(schService);
        
   CloseServiceHandle(schService);
        
   CloseServiceHandle(schSCManager);

   return TRUE;

}


BOOL
WriteLogEntry(HANDLE hFile, DWORD dwCallID, WCHAR *szClientName, WCHAR *pszTextMsg)
{   
    WCHAR       *pBuff;
    SYSTEMTIME  st;
    DWORD       dwBytesWritten;

    if(hFile == NULL) return FALSE;

    if(pszTextMsg)
        pBuff = new WCHAR[(MAX_COMPUTERNAME_LENGTH + lstrlenW(pszTextMsg) + 1 + 100)];
    else
        pBuff = new WCHAR[(MAX_COMPUTERNAME_LENGTH + 1 + 100)]; // no text msg

    // got buffer?
    if(pBuff == NULL) return FALSE;
    
    GetLocalTime(&st);
    
    wsprintf(pBuff, L"%04d%02d%02d%02d%02d%02d %05d %-15.15s %s\r\n",
             st.wYear,
             st.wMonth,
             st.wDay,
             st.wHour,
             st.wMinute,
             st.wSecond,
             dwCallID,
             szClientName,
             pszTextMsg ? pszTextMsg : L"");

    return WriteFile(hFile, pBuff, lstrlenW(pBuff) * sizeof(WCHAR), &dwBytesWritten, NULL);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\rcdll\charmap.h ===
/*
**  charmap.h : P0 specific, also included by charmap.c
**  it defines the mapping used to go from simple chars to these predefined
**  values. this enables the compiler to use a compact switch stmt.
**  they have been grouped in what is believed to be the most beneficial
**  way, in that most switches will be checking those values which have
**  been grouped together.
*/
#define EOS_CHAR                L'\0'    /* end of string/buffer marker char */

#define LX_WHITE                0
#define LX_CR                   1
#define LX_SLASH                2              /* /, /=, comment start  */
#define LX_EOS                  3
#define LX_STAR                 4              /* *, *=, comment stop  */
#define LX_NL                   5
#define LX_BACKSLASH            6
#define LX_SQUOTE               7
#define LX_DQUOTE               8

#define LX_DOT                  9              /* . ... */
#define LX_BANG                 10             /* ! !=  */
#define LX_POUND                11             /* # ##  */
#define LX_PERCENT              12             /* % %=  */
#define LX_EQ                   13             /* = ==  */
#define LX_HAT                  14             /* ^ ^=  */
#define LX_OR                   15             /* | |= || */
#define LX_AND                  16             /* & && &= */
#define LX_PLUS                 17             /* + ++ += */
#define LX_MINUS                18             /* - -- -= ->  */
#define LX_LT                   19             /* < << <<= <= */
#define LX_GT                   20             /* > >= >> >>= */
#define LX_LSHIFT               21             /* << */
#define LX_RSHIFT               22             /* >> */

#define LX_ILL                  23
#define LX_CBRACE               24
#define LX_CBRACK               25
#define LX_COLON                26
#define LX_COMMA                27
#define LX_CPAREN               28
#define LX_NUMBER               29
#define LX_OBRACE               30
#define LX_OBRACK               31
#define LX_OPAREN               32
#define LX_QUEST                33
#define LX_SEMI                 34
#define LX_TILDE                35
#define LX_MACFORMAL            36
#define LX_STRFORMAL            37
#define LX_CHARFORMAL           38
#define LX_NOEXPAND             39
#define LX_ID                   40
#define LX_EACH                 41

#define LX_LEADBYTE             42
#define LX_ASCII                43             /* to use for 'non-illegal' illegals */
#define LX_BOM                  44             /* Byte Order Mark */

#define LX_FORMALMARK           0x01
#define LX_FORMALSTR            0x02
#define LX_FORMALCHAR           0x03
#define LX_NOEXPANDMARK         0x04
#define CONTROL_Z               0x1a
/*
**  Charmap is indexed with a character value plus the above offset
*/
#define CHARMAP(c)              GetCharMap(c)
#define SETCHARMAP(c,val)       SetCharMap(c, val)

#define LX_IS_IDENT(c)  (CHARMAP(c) == LX_ID)
#define LX_IS_WHITE(c)  (CHARMAP(c) == LX_WHITE)
#define LX_IS_NUMBER(c) (CHARMAP(c) == LX_NUMBER)

#define LXC_BDIGIT      0x01            /* 0 - 1 */
#define LXC_ODIGIT      0x02            /* 0 - 7 */
#define LXC_DIGIT       0x04            /* 0 - 9 */
#define LXC_XDIGIT      0x08            /* a-f A-F 0-9 */
#define LXC_ID          0x10            /* continuation is part of an identifier */
#define LXC_RADIX       0x20            /* BbDdHhOoQq */
#define LXC_WHITE       0x40            /* whitespace */
#define LXC_SPECIAL     0x80            /* the char may have a special meaning */

#define CONTMAP(c)           GetContMap(c)
#define SETCONTMAP(c, val)   SetContMap(c, val)
/*
**      LXC_IS_ID(c) : is c part of an identifier
*/
#define LXC_IS_BDIGIT(c)        (CONTMAP(c) & LXC_BDIGIT)
#define LXC_IS_ODIGIT(c)        (CONTMAP(c) & LXC_ODIGIT)
#define LXC_IS_DIGIT(c)         (CONTMAP(c) & LXC_DIGIT)
#define LXC_IS_XDIGIT(c)        (CONTMAP(c) & LXC_XDIGIT)
#define LXC_IS_IDENT(c)         (CONTMAP(c) & LXC_ID)
#define LXC_IS_RADIX(c)         (CONTMAP(c) & LXC_RADIX)
#define LXC_IS_WHITE(c)         (CONTMAP(c) & LXC_WHITE)
#define IS_SPECIAL(c)           (CONTMAP(c) & LXC_SPECIAL)


// Function prototypes

WCHAR GetCharMap (WCHAR);
void  SetCharMap (WCHAR, WCHAR);
WCHAR GetContMap (WCHAR);
void  SetContMap (WCHAR, WCHAR);


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\rasdiag\rasdiag\rsniffclnt.cpp ===
/*++

Copyright (C) 1992-2001 Microsoft Corporation. All rights reserved.

Module Name:

    rsniffclnt.cpp

Abstract:

    Implements client-side of rniff (remote sniff) functionality
                                                     

Author:

    Anthony Leibovitz (tonyle) 03-24-2001

Revision History:


--*/

#include <stdio.h>
#include <stdlib.h>
#include <windows.h>
#include <winsock.h>
#include "diagcommon.h"
#include "rsniffclnt.h"

#pragma message( "COMPILING WITH RSNIFF" )

BOOL
InitWinsock(void)
{
   WSADATA     WSAData;
   WORD        WSAVerReq = MAKEWORD(2,0);

   if (WSAStartup(WSAVerReq, &WSAData)) {
      return FALSE;
   } else
      return TRUE;
}

PSOCKCB
TcpConnectRoutine(WCHAR * pAddr)
{

   SOCKADDR_IN    DstAddrIP  = { AF_INET };
   HOSTENT        *pHost;
   ULONG          uAddr;
   PSOCKCB        pSock;
   BOOL           bResult;
   ULONG          ulHostAddr=0;
   CHAR           szAddr[MAX_FULLYQUALIFIED_DN+1];

   //
   // Resolve name
   //                                       
   wcstombs(szAddr, pAddr, lstrlenW(pAddr)+1);

   if ((ulHostAddr = inet_addr(szAddr)) == -1L)
   {
      return NULL;
   }

   uAddr = ntohl(ulHostAddr);

   DstAddrIP.sin_port        = htons(TCP_SERV_PORT);
   DstAddrIP.sin_addr.s_addr = htonl(uAddr);

   //
   // Create socket
   //
   pSock = CreateSocket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
   if(pSock == NULL)
      return NULL;

   //
   // Connect the socket
   //
   if(ConnectSock(pSock, (struct sockaddr *)&DstAddrIP, sizeof(SOCKADDR_IN))
      != TRUE)
   {
      closesocket(pSock->s);
      LocalFree(pSock);
      return NULL;
   }
   return pSock;
}

BOOL
ConnectSock(PSOCKCB pSock, SOCKADDR* pDstAddr, int size)
{
   int   err;

   //
   // Connect the socket
   //
   err = connect(pSock->s, pDstAddr, size);
   if(err==SOCKET_ERROR)
   {
      return FALSE;
   }
   return TRUE;

}

PSOCKCB
CreateSocket(int Af, int Type, int Proto)
{
   PSOCKCB   pSock;

   if((pSock = (PSOCKCB)LocalAlloc(LMEM_ZEROINIT, sizeof(SOCKCB)))
      == NULL)
      return NULL;

   //
   // Create a socket
   //
   if((pSock->s = socket(Af, Type, Proto))
      == INVALID_SOCKET)
   {
      LocalFree(pSock);
      return NULL;
   }

   return pSock;
}

BOOL
SendStartSniffPacket(PSOCKCB pSock, DWORD dwOptions)
{
    REMOTECAPTURE   rc;
    DWORD           dwSize = MAX_COMPUTERNAME_LENGTH+1;

    ZeroMemory(&rc, sizeof(REMOTECAPTURE));

    rc.dwVer = sizeof(REMOTECAPTURE);

    GetComputerName(rc.szMachine, &dwSize);

    rc.dwOpt1 = dwOptions;
                                                            
    return SendBuffer(pSock->s, (LPBYTE)&rc, sizeof(REMOTECAPTURE));

}

BOOL
SendBuffer(SOCKET s, LPBYTE pBuffer, ULONG uSize)
{
   ULONG err,uSent=0, uBytesSent=0;

   while(uBytesSent != uSize)
   {
      uSent = send(s, (const char *)(pBuffer+uBytesSent), uSize-uBytesSent, 0);

      switch(uSent)
      {
      
      case SOCKET_ERROR:
         err = WSAGetLastError();
         return FALSE;
         break;

      default:
         uBytesSent+=uSent;
         break;
      }
   }
   return TRUE;
}

BOOL
DoRemoteSniff(PSOCKCB *ppSockCb, WCHAR *szAddr, DWORD dwOptions)
{
    PSOCKCB pSockCb=NULL;
     
    if(InitWinsock() == FALSE) {
        return FALSE;
    }
    
    // setup connection to sentry2
    pSockCb = TcpConnectRoutine(szAddr);
    if(pSockCb == NULL) {
        return FALSE;
    }
    
    if(SendStartSniffPacket(pSockCb, dwOptions) == FALSE)
    {
        closesocket(pSockCb->s);
        LocalFree(pSockCb);
        return FALSE;
    }           

    *ppSockCb=pSockCb;

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\rcdll\charmap.c ===
/************************************************************************/
/*                                                                      */
/* RCPP - Resource Compiler Pre-Processor for NT system                 */
/*                                                                      */
/* CHARMAP.C - Character mapping arrays                                 */
/*                                                                      */
/* 06-Dec-90 w-BrianM  Update for NT from PM SDK RCPP                   */
/*                                                                      */
/************************************************************************/

#include "rc.h"
//#include "rcpptype.h"
//#include "charmap.h"

#define CHARMAP_SIZE    256

WCHAR Charmap[CHARMAP_SIZE] = {
    LX_EOS,                 /* 0x0, <end of string marker> */
    LX_ILL,                 /* 0x1 */
    LX_ILL,                 /* 0x2 */
    LX_ILL,                 /* 0x3 */
    LX_ILL,                 /* 0x4 */
    LX_ILL,                 /* 0x5 */
    LX_ILL,                 /* 0x6 */
    LX_ILL,                 /* 0x7 */
    LX_ILL,                 /* 0x8 */
    LX_WHITE,               /* <horizontal tab> */
    LX_NL,                  /* <newline> */
    LX_WHITE,               /* <vertical tab> */
    LX_WHITE,               /* <form feed> */
    LX_CR,                  /* <really a carriage return> */
    LX_ILL,                 /* 0xe */
    LX_ILL,                 /* 0xf */
    LX_ILL,                 /* 0x10 */
    LX_ILL,                 /* 0x11 */
    LX_ILL,                 /* 0x12 */
    LX_ILL,                 /* 0x13 */
    LX_ILL,                 /* 0x14 */
    LX_ILL,                 /* 0x15 */
    LX_ILL,                 /* 0x16 */
    LX_ILL,                 /* 0x17 */
    LX_ILL,                 /* 0x18 */
    LX_ILL,                 /* 0x19 */
    LX_EOS,                 /* 0x1a, ^Z */
    LX_ILL,                 /* 0x1b */
    LX_ILL,                 /* 0x1c */
    LX_ILL,                 /* 0x1d */
    LX_ILL,                 /* 0x1e */
    LX_ILL,                 /* 0x1f */
    LX_WHITE,               /* 0x20 */
    LX_BANG,                /* ! */
    LX_DQUOTE,              /* " */
    LX_POUND,               /* # */
    LX_ASCII,               /* $ */
    LX_PERCENT,             /* % */
    LX_AND,                 /* & */
    LX_SQUOTE,              /* ' */
    LX_OPAREN,              /* ( */
    LX_CPAREN,              /* ) */
    LX_STAR,                /* * */
    LX_PLUS,                /* + */
    LX_COMMA,               /* , */
    LX_MINUS,               /* - */
    LX_DOT,                 /* . */
    LX_SLASH,               /* / */
    LX_NUMBER,              /* 0 */
    LX_NUMBER,              /* 1 */
    LX_NUMBER,              /* 2 */
    LX_NUMBER,              /* 3 */
    LX_NUMBER,              /* 4 */
    LX_NUMBER,              /* 5 */
    LX_NUMBER,              /* 6 */
    LX_NUMBER,              /* 7 */
    LX_NUMBER,              /* 8 */
    LX_NUMBER,              /* 9 */
    LX_COLON,               /* : */
    LX_SEMI,                /* ; */
    LX_LT,                  /* < */
    LX_EQ,                  /* = */
    LX_GT,                  /* > */
    LX_QUEST,               /* ? */
    LX_EACH,                /* @ */
    LX_ID,                  /* A */
    LX_ID,                  /* B */
    LX_ID,                  /* C */
    LX_ID,                  /* D */
    LX_ID,                  /* E */
    LX_ID,                  /* F */
    LX_ID,                  /* G */
    LX_ID,                  /* H */
    LX_ID,                  /* I */
    LX_ID,                  /* J */
    LX_ID,                  /* K */
    LX_ID,                  /* L */
    LX_ID,                  /* M */
    LX_ID,                  /* N */
    LX_ID,                  /* O */
    LX_ID,                  /* P */
    LX_ID,                  /* Q */
    LX_ID,                  /* R */
    LX_ID,                  /* S */
    LX_ID,                  /* T */
    LX_ID,                  /* U */
    LX_ID,                  /* V */
    LX_ID,                  /* W */
    LX_ID,                  /* X */
    LX_ID,                  /* Y */
    LX_ID,                  /* Z */
    LX_OBRACK,              /* [ */
    LX_EOS,                 /* \ */
    LX_CBRACK,              /* ] */
    LX_HAT,                 /* ^ */
    LX_ID,                  /* _ */
    LX_ASCII,               /* ` */
    LX_ID,                  /* a */
    LX_ID,                  /* b */
    LX_ID,                  /* c */
    LX_ID,                  /* d */
    LX_ID,                  /* e */
    LX_ID,                  /* f */
    LX_ID,                  /* g */
    LX_ID,                  /* h */
    LX_ID,                  /* i */
    LX_ID,                  /* j */
    LX_ID,                  /* k */
    LX_ID,                  /* l */
    LX_ID,                  /* m */
    LX_ID,                  /* n */
    LX_ID,                  /* o */
    LX_ID,                  /* p */
    LX_ID,                  /* q */
    LX_ID,                  /* r */
    LX_ID,                  /* s */
    LX_ID,                  /* t */
    LX_ID,                  /* u */
    LX_ID,                  /* v */
    LX_ID,                  /* w */
    LX_ID,                  /* x */
    LX_ID,                  /* y */
    LX_ID,                  /* z */
    LX_OBRACE,              /* { */
    LX_OR,                  /* | */
    LX_CBRACE,              /* } */
    LX_TILDE,               /* ~ */
    LX_ILL,                 /* 0x7f */
    LX_ILL, LX_ILL, LX_ILL, LX_ILL, LX_ILL, LX_ILL, LX_ILL, LX_ILL,
    LX_ILL, LX_ILL, LX_ILL, LX_ILL, LX_ILL, LX_ILL, LX_ILL, LX_ILL,
    LX_ILL, LX_ILL, LX_ILL, LX_ILL, LX_ILL, LX_ILL, LX_ILL, LX_ILL,
    LX_ILL, LX_ILL, LX_ILL, LX_ILL, LX_ILL, LX_ILL, LX_ILL, LX_ILL,
    LX_ILL, LX_ILL, LX_ILL, LX_ILL, LX_ILL, LX_ILL, LX_ILL, LX_ILL,
    LX_ILL, LX_ILL, LX_ILL, LX_ILL, LX_ILL, LX_ILL, LX_ILL, LX_ILL,
    LX_ILL, LX_ILL, LX_ILL, LX_ILL, LX_ILL, LX_ILL, LX_ILL, LX_ILL,
    LX_ILL, LX_ILL, LX_ILL, LX_ILL, LX_ILL, LX_ILL, LX_ILL, LX_ILL,
    LX_ILL, LX_ILL, LX_ILL, LX_ILL, LX_ILL, LX_ILL, LX_ILL, LX_ILL,
    LX_ILL, LX_ILL, LX_ILL, LX_ILL, LX_ILL, LX_ILL, LX_ILL, LX_ILL,
    LX_ILL, LX_ILL, LX_ILL, LX_ILL, LX_ILL, LX_ILL, LX_ILL, LX_ILL,
    LX_ILL, LX_ILL, LX_ILL, LX_ILL, LX_ILL, LX_ILL, LX_ILL, LX_ILL,
    LX_ILL, LX_ILL, LX_ILL, LX_ILL, LX_ILL, LX_ILL, LX_ILL, LX_ILL,
    LX_ILL, LX_ILL, LX_ILL, LX_ILL, LX_ILL, LX_ILL, LX_ILL, LX_ILL,
    LX_ILL, LX_ILL, LX_ILL, LX_ILL, LX_ILL, LX_ILL, LX_ILL, LX_ILL,
    LX_ILL, LX_ILL, LX_ILL, LX_ILL, LX_ILL, LX_ILL, LX_ILL, LX_ILL,
};

WCHAR Contmap[CHARMAP_SIZE] = {
    LXC_SPECIAL,                                                /* 0x0, <end of string marker> */
    0,                                                          /* 0x1 */
    0,                                                          /* 0x2 */
    0,                                                          /* 0x3 */
    0,                                                          /* 0x4 */
    0,                                                          /* 0x5 */
    0,                                                          /* <end of buffer marker> */
    0,                                                          /* 0x7 */
    0,                                                          /* 0x8 */
    LXC_WHITE,                                                  /* <horizontal tab> */
    LXC_SPECIAL,                                                /* <newline>, this is NOT considered whitespace */
    LXC_WHITE,                                                  /* <vertical tab> */
    LXC_WHITE,                                                  /* <form feed> */
    0,                                                          /* <really a carriage return> */
    0,                                                          /* 0xe */
    0,                                                          /* 0xf */
    0,                                                          /* 0x10 */
    0,                                                          /* 0x11 */
    0,                                                          /* 0x12 */
    0,                                                          /* 0x13 */
    0,                                                          /* 0x14 */
    0,                                                          /* 0x15 */
    0,                                                          /* 0x16 */
    0,                                                          /* 0x17 */
    0,                                                          /* 0x18 */
    0,                                                          /* 0x19 */
    LXC_SPECIAL,                                                /* 0x1a */
    0,                                                          /* 0x1b */
    0,                                                          /* 0x1c */
    0,                                                          /* 0x1d */
    0,                                                          /* 0x1e */
    0,                                                          /* 0x1f */
    LXC_WHITE,                                                  /* 0x20 */
    0,                                                          /* ! */
    0,                                                          /* " */
    0,                                                          /* # */
    0,                                                          /* $ */
    0,                                                          /* % */
    0,                                                          /* & */
    0,                                                          /* ' */
    0,                                                          /* ( */
    0,                                                          /* ) */
    LXC_SPECIAL,                                                /* * */
    0,                                                          /* + */
    0,                                                          /* , */
    0,                                                          /* - */
    0,                                                          /* . */
    0,                                                          /* / */
    LXC_ID | LXC_XDIGIT | LXC_DIGIT | LXC_ODIGIT | LXC_BDIGIT,  /* 0 */
    LXC_ID | LXC_XDIGIT | LXC_DIGIT | LXC_ODIGIT | LXC_BDIGIT,  /* 1 */
    LXC_ID | LXC_XDIGIT | LXC_DIGIT | LXC_ODIGIT,               /* 2 */
    LXC_ID | LXC_XDIGIT | LXC_DIGIT | LXC_ODIGIT,               /* 3 */
    LXC_ID | LXC_XDIGIT | LXC_DIGIT | LXC_ODIGIT,               /* 4 */
    LXC_ID | LXC_XDIGIT | LXC_DIGIT | LXC_ODIGIT,               /* 5 */
    LXC_ID | LXC_XDIGIT | LXC_DIGIT | LXC_ODIGIT,               /* 6 */
    LXC_ID | LXC_XDIGIT | LXC_DIGIT | LXC_ODIGIT,               /* 7 */
    LXC_ID | LXC_XDIGIT | LXC_DIGIT,                            /* 8 */
    LXC_ID | LXC_XDIGIT | LXC_DIGIT,                            /* 9 */
    0,                                                          /* : */
    0,                                                          /* ; */
    0,                                                          /* < */
    0,                                                          /* = */
    0,                                                          /* > */
    0,                                                          /* ? */
    0,                                                          /* @ */
    LXC_ID | LXC_XDIGIT,                                        /* A */
    LXC_ID | LXC_XDIGIT     | LXC_RADIX,                        /* B */
    LXC_ID | LXC_XDIGIT,                                        /* C */
    LXC_ID | LXC_XDIGIT | LXC_RADIX,                            /* D */
    LXC_ID | LXC_XDIGIT,                                        /* E */
    LXC_ID | LXC_XDIGIT,                                        /* F */
    LXC_ID,                                                     /* G */
    LXC_ID | LXC_RADIX,                                         /* H */
    LXC_ID,                                                     /* I */
    LXC_ID,                                                     /* J */
    LXC_ID,                                                     /* K */
    LXC_ID,                                                     /* L */
    LXC_ID,                                                     /* M */
    LXC_ID,                                                     /* N */
    LXC_ID | LXC_RADIX,                                         /* O */
    LXC_ID,                                                     /* P */
    LXC_ID | LXC_RADIX,                                         /* Q */
    LXC_ID,                                                     /* R */
    LXC_ID,                                                     /* S */
    LXC_ID,                                                     /* T */
    LXC_ID,                                                     /* U */
    LXC_ID,                                                     /* V */
    LXC_ID,                                                     /* W */
    LXC_ID,                                                     /* X */
    LXC_ID,                                                     /* Y */
    LXC_ID,                                                     /* Z */
    0,                                                          /* [ */
    0,                                                          /* \ */
    0,                                                          /* ] */
    0,                                                          /* ^ */
    LXC_ID,                                                     /* _ */
    0,                                                          /* ` */
    LXC_ID | LXC_XDIGIT,                                        /* a */
    LXC_ID | LXC_XDIGIT | LXC_RADIX,                            /* b */
    LXC_ID | LXC_XDIGIT,                                        /* c */
    LXC_ID | LXC_XDIGIT | LXC_RADIX,                            /* d */
    LXC_ID | LXC_XDIGIT,                                        /* e */
    LXC_ID | LXC_XDIGIT,                                        /* f */
    LXC_ID,                                                     /* g */
    LXC_ID | LXC_RADIX,                                         /* h */
    LXC_ID,                                                     /* i */
    LXC_ID,                                                     /* j */
    LXC_ID,                                                     /* k */
    LXC_ID,                                                     /* l */
    LXC_ID,                                                     /* m */
    LXC_ID,                                                     /* n */
    LXC_ID | LXC_RADIX,                                         /* o */
    LXC_ID,                                                     /* p */
    LXC_ID | LXC_RADIX,                                         /* q */
    LXC_ID,                                                     /* r */
    LXC_ID,                                                     /* s */
    LXC_ID,                                                     /* t */
    LXC_ID,                                                     /* u */
    LXC_ID,                                                     /* v */
    LXC_ID,                                                     /* w */
    LXC_ID,                                                     /* x */
    LXC_ID,                                                     /* y */
    LXC_ID,                                                     /* z */
    0,                                                          /* { */
    0,                                                          /* | */
    0,                                                          /* } */
    0,                                                          /* ~ */
    0,                                                          /* 0x7f */
};


WCHAR
GetCharMap (
    WCHAR c
    )
{
    if (c == 0xFEFF)           // Byte Order Mark
        return (LX_BOM);
    else if (c > CHARMAP_SIZE)
        return (LX_ID);        // character beyond the ANSI set

    return (Charmap[c]);
}


void
SetCharMap (
    WCHAR c,
    WCHAR val
    )
{
    if (c > CHARMAP_SIZE)
       return;

    Charmap[((UCHAR)(c))] = val;
}


WCHAR
GetContMap (
    WCHAR c
    )
{
    if (c > CHARMAP_SIZE)
        return (LXC_ID);       // character beyong the ANSI set

    return (Contmap[c]);
}


void
SetContMap (
    WCHAR c,
    WCHAR val
    )
{
    if (c > CHARMAP_SIZE)
       return;

    Contmap[c] = val;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\rcdll\common.h ===
/*++

(C) Copyright Microsoft Corporation 1988-1992

Module Name:

    common.h

Author:

    Floyd A Rogers 2/7/92

Revision History:
        Floyd Rogers
        Created
--*/

#define IN
#define OUT
#define INOUT

//
// An ID_WORD indicates the following WORD is an ordinal rather 
// than a string
// 

#define ID_WORD 0xffff

typedef struct _STRING {
        DWORD discriminant;       // long to make the rest of the struct aligned
	union u {
		struct {
		  struct _STRING *pnext;
                  DWORD  ulOffsetToString;
		  USHORT cbD;
		  USHORT cb;
		  WCHAR  sz[1];
		} ss;
		WORD     Ordinal;
	} uu;
} STRING, *PSTRING, **PPSTRING;

#define IS_STRING 1
#define IS_ID     2

// defines to make deferencing easier
#define OffsetToString uu.ss.ulOffsetToString
#define cbData         uu.ss.cbD
#define cbsz           uu.ss.cb
#define szStr          uu.ss.sz
#define pn             uu.ss.pnext

typedef struct _RESNAME {
    struct _RESNAME *pnext;    // The first three fields should be the
    PSTRING Name;              // same in both res structures
    DWORD   OffsetToData;      //

    PSTRING Type;
    struct _RESNAME *pnextRes;
    RESADDITIONAL	*pAdditional;
    DWORD   OffsetToDataEntry;
    USHORT  ResourceNumber;
    USHORT  NumberOfLanguages;
    POBJLST pObjLst;
} RESNAME, *PRESNAME, **PPRESNAME;

typedef struct _RESTYPE {
    struct _RESTYPE *pnext;    // The first three fields should be the
    PSTRING Type;              // same in both res structures
    DWORD   OffsetToData;      //

    struct _RESNAME *NameHeadID;
    struct _RESNAME *NameHeadName;
    DWORD  NumberOfNamesID;
    DWORD  NumberOfNamesName;
    POBJLST pObjLst;
} RESTYPE, *PRESTYPE, **PPRESTYPE;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\rcdll\error.c ===
/************************************************************************/
/*                                                                      */
/* RCPP - Resource Compiler Pre-Processor for NT system                 */
/*                                                                      */
/* ERROR.C - Error Handler Routines                                     */
/*                                                                      */
/* 04-Dec-90 w-BrianM  Update for NT from PM SDK RCPP                   */
/*                                                                      */
/************************************************************************/

#include "rc.h"
#include "rcmsgs.h"


/* defines for message types */
#define W_MSG   4000
#define E_MSG   2000
#define F_MSG   1000

static CHAR  Errbuff[128] = {0};


/************************************************************************/
/* Local Function Prototypes                                            */
/************************************************************************/
void message (int, int, PCHAR);


/************************************************************************/
/* ERROR - Print an error message to STDOUT.                            */
/************************************************************************/
#define MAX_ERRORS 100

void
error (
    int msgnum
    )
{
    message(E_MSG, msgnum, Msg_Text);
    if (++Nerrors > MAX_ERRORS) {
        Msg_Temp = GET_MSG (1003);
        SET_MSG (Msg_Text, sizeof(Msg_Text), Msg_Temp, MAX_ERRORS);
        fatal(1003);            /* die - too many errors */
    }
    return;
}


/************************************************************************/
/* FATAL - Print an error message to STDOUT and exit.                   */
/************************************************************************/
void
fatal (
    int msgnum
    )
{
    message(F_MSG, msgnum, Msg_Text);
    quit(NULL);
}


/************************************************************************/
/* WARNING - Print an error message to STDOUT.                          */
/************************************************************************/
void
warning (
    int msgnum
    )
{
    message(W_MSG, msgnum, Msg_Text);
}


/************************************************************************/
/* MESSAGE - format and print the message to STDERR.                    */
/* The msg goes out in the form :                                       */
/*     <file>(<line>) : <msgtype> <errnum> <expanded msg>               */
/************************************************************************/
void
message(
    int msgtype,
    int msgnum,
    PCHAR msg
    )
{
    static CHAR mbuff[512];
    static CHAR mbuffT[512];
    PCHAR   p = mbuff;
    PCHAR   pT;
    PCHAR   msgname;
    CHAR    msgnumstr[32];

    if (Linenumber > 0 && Filename) {
        wsprintfA(p, "%ws(%d) : ", Filename, Linenumber);
        p += strlen(p);
    }
    if (msgtype) {
        switch (msgtype) {
            case W_MSG:
                msgname = GET_MSG(MSG_WARN);
                break;
            case E_MSG:
                msgname = GET_MSG(MSG_ERROR);
                break;
            case F_MSG:
                msgname = GET_MSG(MSG_FATAL);
                break;
        }
        /* remove CR and LF from message */
        for (pT = msgname ; *pT && *pT != '\n' && *pT != '\r' ; pT++)
            ;
        *pT = '\0';
        strcpy(p, msgname);
        p += strlen(msgname);
        wsprintfA(msgnumstr, " %s%d: ", "RC", msgnum);
        strcpy(p, msgnumstr);
        p += strlen(msgnumstr);
        strcpy(p, msg);
        p += strlen(p);
    }

    p = mbuff;
    pT = mbuffT;
    while (*p) {
        if (*p == '\\' && p[1] == '\\')
            p++;
        *pT++ = *p++;
    }

    *pT = '\0';
    p = mbuffT; // error message to print

    if (lpfnMessageCallback)
        (*lpfnMessageCallback)(0, 0, mbuff);
    if (hWndCaller) {
        if (SendMessageA(hWndCaller, WM_RC_ERROR, TRUE, (LPARAM) mbuff) != 0)
            quit("\n");
    }
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\rcdll\getflags.c ===
/************************************************************************/
/*                                                                      */
/* RCPP - Resource Compiler Pre-Processor for NT system                 */
/*                                                                      */
/* GETFLAGS.C - Parse Command Line Flags                                */
/*                                                                      */
/* 27-Nov-90 w-BrianM  Update for NT from PM SDK RCPP                   */
/*                                                                      */
/************************************************************************/
#include "rc.h"


/************************************************************************/
/* Define function specific macros and global vars                      */
/************************************************************************/
static WCHAR     *ErrString;   /* Store string pointer in case of error */


/************************************************************************/
/* Local Function Prototypes                                            */
/************************************************************************/
int getnumber   (WCHAR *);
int isita       (WCHAR *, WCHAR);
void substr     (struct cmdtab *, WCHAR *, int);
int tailmatch   (WCHAR *, WCHAR *);



/************************************************************************
 *      crack_cmd(table, string, func, dup)
 *              set flags determined by the string based on table.
 *              func will get the next word.
 *              if dup is set, any strings stored away will get pstrduped
 * see getflags.h for specific matching and setting operators
 *
 *  for flags which take parameters, a 'char' following the flag where 'char' is
 *  '#' : says the parameter string may be separated from the option.
 *              ie, "-M#" accepts "-Mabc" and "-M abc"
 *  '*' : says the parameter must be concatenated with the flag
 *              ie, "-A*" accepts only "-Axyz" not "-A xyz"
 *  if neither is specified a space is required between parameter and flag
 *              ie, "-o" accepts only "-o file" and not "-ofile"
 *
 * Modified by:         Dave Weil                       D001
 *                              recognize '-' and '/' as equivalent on MSDOS
 *
 ************************************************************************/

int
crack_cmd(
    struct cmdtab *tab,
    WCHAR *string,
    WCHAR *(*next)(void),
    int _dup
    )
{
    register WCHAR      *format, *str;

    if (!string) {
        return(0);
    }

    ErrString = string;
    for (; tab->type; tab++)            /* for each format */ {
        format = tab->format;
        str = string;
        for (; ; )                              /* scan the string */
            switch (*format) {
                /*  optional space between flag and parameter  */
                case L'#':
                    if ( !*str ) {
                        substr(tab, (*next)(), _dup);
                    } else {
                        substr(tab, str, _dup);
                    }
                    return(tab->retval);
                    break;

                /*  no space allowed between flag and parameter  */
                case L'*':
                    if (*str && tailmatch(format, str))
                        substr(tab, str, _dup);
                    else
                        goto notmatch;
                    return(tab->retval);
                    break;

                /*  space required between flag and parameter  */
                case 0:
                    if (*str) {                         /*  str left, no good  */
                        goto notmatch;
                    } else if (tab->type & TAKESARG) {  /*  if it takes an arg  */
                        substr(tab, (*next)(), _dup);
                    } else {                            /*  doesn't want an arg  */
                        substr(tab, (WCHAR *)0, _dup);
                    }
                    return(tab->retval);
                    break;
                case L'-':
                    if (L'-' == *str) {
                        str++;
                        format++;
                        continue;
                    } else {
                        goto notmatch;
                    }

                default:
                    if (*format++ == *str++)
                        continue;
                    goto notmatch;
            }
notmatch:
        ;
    }
    return(0);
}


/************************************************************************/
/* set the appropriate flag(s).  called only when we know we have a match */
/************************************************************************/
void
substr(
    struct cmdtab *tab,
    register WCHAR *str,
    int _dup
    )
{
    register struct subtab *q;
    LIST * list;
    WCHAR        *string = str;

    switch (tab->type) {
        case FLAG:
            *(int *)(tab->flag) = 1;
            return;
        case UNFLAG:
            *(int *)(tab->flag) = 0;
            return;
        case NOVSTR:
            if (*(WCHAR **)(tab->flag)) {
                /* before we print it out in the error message get rid of the
                 * arg specifier (e.g. #) at the end of the format.
                 */
//                string = _wcsdup(tab->format);
//                string[wcslen(string)-1] = L'\0';
//
// message 1046 doesn't exist and don't know what it should be
//            Msg_Temp = GET_MSG(1046);
//            SET_MSG (Msg_Text, sizeof(Msg_Text), Msg_Temp, string, *(WCHAR **)(tab->flag), str);
                Msg_Temp = GET_MSG(1000);
                fatal(1000);
                return;
            }
            /* fall through */
        case STRING:
            *(WCHAR **)(tab->flag) = (_dup ? _wcsdup(str) : str);
            return;
        case NUMBER:
            *(int *)(tab->flag) = getnumber (str);
            return;
        case PSHSTR:
            list = (LIST * )(tab->flag);
            if (list->li_top > 0)
                list->li_defns[--list->li_top] = (_dup ? _wcsdup(str) : str);
            else {
                Msg_Temp = GET_MSG(1047);
                SET_MSG (Msg_Text, sizeof(Msg_Text), Msg_Temp, tab->format, str);
                fatal(1047);
            }
            return;
        case SUBSTR:
            for ( ; *str; ++str) {  /*  walk the substring  */
                for (q = (struct subtab *)tab->flag; q->letter; q++) {
                    /*
                                    **  for every member in the table
                                    */
                    if (*str == (WCHAR)q->letter)
                        switch (q->type) {
                        case FLAG:
                            *(q->flag) = 1;
                            goto got_letter;
                        case UNFLAG:
                            *(q->flag) = 0;
                            goto got_letter;
                        default:
                            goto got_letter;
                        }
                }
got_letter:
                if (!q->letter) {
                    Msg_Temp = GET_MSG(1048);
                    SET_MSG (Msg_Text, sizeof(Msg_Text), Msg_Temp, *str, ErrString);
                    fatal(1048);
                }
            }
            return;
        default:
            return;
    }
}


/************************************************************************/
/* Parse the string and return a number 0 <= x < 0xffff (64K)           */
/************************************************************************/
int
getnumber (
    WCHAR *str
    )
{
    long        i = 0;
    WCHAR       *ptr = str;

    for (; iswspace(*ptr); ptr++)
        ;
    if (!iswdigit(*ptr) || (((i = wcstol(ptr, NULL, 10)) >= 65535) ||  i < 0)) {
        Msg_Temp = GET_MSG(1049);
        SET_MSG (Msg_Text, sizeof(Msg_Text), Msg_Temp, str);
        fatal(1049);            /* invalid numerical argument, 'str' */
    }
    return ((int) i);
}


/************************************************************************/
/*  is the letter in the string?                                        */
/************************************************************************/
int
isita (
    register WCHAR *str,
    register WCHAR let
    )
{
    if (str)
        while (*str)
            if (*str++ == let)
                return(1);
    return(0);
}


/************************************************************************/
/* compare a tail format (as in *.c) with a string.  if there is no     */
/* tail, anything matches.  (null strings are detected elsewhere)       */
/* the current implementation only allows one wild card                 */
/************************************************************************/
int
tailmatch (
    WCHAR *format,
    WCHAR *str
    )
{
    register WCHAR      *f = format;
    register WCHAR      *s = str;

    if (f[1] == 0)      /*  wild card is the last thing in the format, it matches */
        return(1);
    while (f[1])                /*  find char in front of null in format  */
        f++;
    while (s[1])                /*  find char in front of null in string to check  */
        s++;
    while (*s == *f) {  /*  check chars walking towards front */
        s--;
        f--;
    }
    /*
**  if we're back at the beginning of the format
**  and
**  the string is either at the beginning or somewhere inside
**  then we have a match.
**
**  ex format == "*.c", str == "file.c"
**      at this point *f = '*' and *s == 'e', since we've kicked out of the above
**  loop. since f==format and s>=str this is a match.
**  but if format == "*.c" and str == "file.asm" then
**  *f == 'c' and *s = 'm', f != format and no match.
*/
    return((f == format) && (s >= str));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\rcdll\getmsg.c ===
/************************************************************************/
/*                                                                      */
/* RCPP - Resource Compiler Pre-Processor for NT system                 */
/*                                                                      */
/* GETMSG.C - Replaces NMSGHDR.ASM and MSGS.ASM                         */
/*                                                                      */
/* 28-Nov-90 w-BrianM  Created to remove need for MKMSG.EXE             */
/*                                                                      */
/************************************************************************/

#include "rc.h"


CHAR msgbuf[4096];

/************************************************************************/
/* GET_MSG - Given a message number, get the correct format string      */
/************************************************************************/
PCHAR
GET_MSG (
    int msgnumber
    )
{
    int cb;

    cb = FormatMessageA(FORMAT_MESSAGE_FROM_HMODULE|FORMAT_MESSAGE_IGNORE_INSERTS,
                   (HMODULE)hInstance, msgnumber, 0, msgbuf, 4096, NULL);
    if (cb)
        return msgbuf;
    else {
#if DBG
        printf("Internal error : message not found: %d\n", msgnumber);
#endif
        return ("");
    }
}


/************************************************************************/
/* SET_MSG - Given a format string, format it and store it in first parm*/
/************************************************************************/
void
__cdecl
SET_MSG (
    PCHAR exp,
    UINT n,
    PCHAR fmt,
    ...
    )
{
    va_list     arg_list;

    va_start (arg_list, fmt);

    FormatMessageA (FORMAT_MESSAGE_FROM_STRING, fmt, 0, 0,
                    exp, n, &arg_list);

    va_end (arg_list);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\rcdll\makefile.inc ===
msg00001.bin rcmsgs.h rcmsgs.rc: rcmsgs.mc
	mc -v rcmsgs.mc

$(NTTARGETFILE0): msg00001.bin rcdll.rc rcmsgs.h
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\rcdll\globals.c ===
/************************************************************************/
/*                                                                      */
/* RCPP - Resource Compiler Pre-Processor for NT system                 */
/*                                                                      */
/* GLOBALS.C - Global variable definitions                              */
/*                                                                      */
/* 27-Nov-90 w-BrianM  Update for NT from PM SDK RCPP                   */
/*                                                                      */
/************************************************************************/

#include "rc.h"

/* shared strings */
WCHAR   Union_str[] = L"union";
WCHAR   Struct_str[] = L"struct";
WCHAR   Cdecl_str[] = L"cdecl";
WCHAR   Cdecl1_str[] = L"cdecl L";
WCHAR   Fortran_str[] = L"fortran";
WCHAR   Fortran1_str[] = L"fortran L";
WCHAR   Pascal_str[] = L"pascal";
WCHAR   Pascal1_str[] = L"pascal L";
WCHAR   PPelse_str[] = L"#else";
WCHAR   PPendif_str[] = L"#endif";
WCHAR   PPifel_str[] = L"#if/#elif";
WCHAR   Syntax_str[] = L"syntax error";


PFILE   OUTPUTFILE;                     /* File for output of program */

WCHAR   *A_string;                      /* model encoding */
WCHAR   *Debug;                         /* debugging switches */
WCHAR   *Input_file;                    /* the input .rc file */
WCHAR   *Output_file;                   /* the output .res file */
WCHAR   *Q_string;                      /* hardware characteristics */
WCHAR   *Version;
UINT    uiDefaultCodePage;
UINT    uiCodePage;

int     In_alloc_text;
int     Bad_pragma;
int     Cross_compile;                  /* is this a cross compile ? */
int     Ehxtension;                     /* near/far keywords, but no huge */
int     HugeModel;                      /* Huge Model program ?? */
int     Inteltypes;                     /* using strict Intel types or not */
int     Nerrors;
int     NoPasFor;                       /* no fortran/pascal keywords ? */
int     Out_funcdef;                    /* output function definitions */
int     Plm;                            /* non-C calling sequence */
int     Prep;                           /* preprocess */
int     Srclist;                        /* put msgs to il file if source listing */

int     Cmd_intrinsic;                  /* implicit intrinsics */
int     Cmd_loop_opt;
int     Cmd_pointer_check;

int     Symbolic_debug;                 /* Whether to put out dbil info or not */
int     Cflag;                          /* leave in comments */
int     Eflag;                          /* insert #line */
int     Jflag;                          /* no Kanji */
int     Pflag;                          /* no #line */
int     Rflag;                          /* mkhives - no exponent missing error */
int     ZcFlag;                         /* case insensitive compare */
int     In_define;
int     InInclude;
int     InIf;
int     Macro_depth;
int     Linenumber;

CHAR    chBuf[MED_BUFFER+1];
WCHAR   Reuse_W[BIG_BUFFER];
WCHAR   Filebuff[MED_BUFFER+1];
WCHAR   Macro_buffer[BIG_BUFFER * 4];

WCHAR   Reuse_Include[MED_BUFFER+1];

token_t Basic_token = L_NOTOKEN;
LIST    Defs = {MAXLIST};               /* -D list */
LIST    UnDefs = {MAXLIST};             /* -U list */
LIST    Includes = {MAXLIST, {0}};      /* for include file names */
WCHAR   *Path_chars = L"/";             /* path delimiter chars */
WCHAR   *Basename = L"";                /* base IL file name */
WCHAR   *Filename = Filebuff;

int     Char_align = 1;                 /* alignment of chars in structs */
int     Cmd_stack_check = TRUE;
int     Stack_check = TRUE;
int     Prep_ifstack = -1;
int     Switch_check = TRUE;
int     Load_ds_with;
int     Plmn;
int     Plmf;
int     On_pound_line;
int     Listing_value;
hash_t  Reuse_W_hash;
UINT    Reuse_W_length;
token_t Currtok = L_NOTOKEN;

int     Extension = TRUE;               /* near/far keywords? */
int     Cmd_pack_size = 2;
int     Pack_size = 2;

lextype_t yylval;

/*** I/O Variable for PreProcessor ***/
ptext_t Current_char;

/*** w-BrianM - Re-write of fatal(), error() ***/
CHAR     Msg_Text[MSG_BUFF_SIZE];
PCHAR    Msg_Temp;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\rcdll\grammar.h ===
/************************************************************************/
/*                                                                      */
/* RCPP - Resource Compiler Pre-Processor for NT system                 */
/*                                                                      */
/* GRAMMAR.H - Grammar definitions for terminals                        */
/*                                                                      */
/* 27-Nov-90 w-BrianM  Update for NT from PM SDK RCPP                   */
/*                                                                      */
/************************************************************************/

#define L_NOTOKEN       1L
#define L_IDENT         2L
#define L_STRING        3L
#define L_CFLOAT        4L
#define L_CDOUBLE       5L
#define L_CLDOUBLE      6L
#define L_CINTEGER      7L
#define L_LONGINT       8L
#define L_CUNSIGNED     9L
#define L_LONGUNSIGNED  10L
#define L_AUTO          11L
#define L_STATIC        12L
#define L_EXTERN        13L
#define L_REGISTER      14L
#define L_TYPEDEF       15L
#define L_FORTRAN       16L
#define L_PASCAL        17L
#define L_C             18L
#define L_INTERRUPT     19L
#define L_SAVEREGS      20L
#define L_LOADDS        21L
#define L_EXPORT        22L
#define L_ASM           23L
#define L_NEAR          24L
#define L_FAR           25L
#define L_HUGE          26L
#define L_CONST         27L
#define L_VOLATILE      28L
#define L_CHAR          29L
#define L_INT           30L
#define L_FLOAT         31L
#define L_DOUBLE        32L
#define L_SHORT         33L
#define L_LONG          34L
#define L_VOID          35L
#define L_SIGNED        36L
#define L_UNSIGNED      37L
#define L_ENUM          38L
#define L_ENUM_TAG      39L
#define L_STRUCT        40L
#define L_STRUCT_TAG    41L
#define L_UNION         42L
#define L_UNION_TAG     43L
#define L_AND           44L
#define L_ANDAND        45L
#define L_ANDEQ         46L
#define L_ASSIGN        47L
#define L_BIT           48L
#define L_COLON         49L
#define L_COMMA         50L
#define L_DECR          51L
#define L_DIV           52L
#define L_DIVEQ         53L
#define L_EQUALS        54L
#define L_EXCLAIM       55L
#define L_EXTRACT       56L
#define L_GT            57L
#define L_GTEQ          58L
#define L_INCR          59L
#define L_LBRACK        60L
#define L_LSHFTEQ       61L
#define L_LSHIFT        62L
#define L_LT            63L
#define L_LTEQ          64L
#define L_MINUS         65L
#define L_MINUSEQ       66L
#define L_MOD           67L
#define L_MODEQ         68L
#define L_MULT          69L
#define L_MULTEQ        70L
#define L_NOTEQ         71L
#define L_OR            72L
#define L_OREQ          73L
#define L_OROR          74L
#define L_PERIOD        75L
#define L_PLUS          76L
#define L_PLUSEQ        77L
#define L_POINTSTO      78L
#define L_PREDECR       79L
#define L_PREINCR       80L
#define L_QUEST         81L
#define L_RSHFTEQ       82L
#define L_RSHIFT        83L
#define L_TILDE         84L
#define L_UMINUS        85L
#define L_XOR           86L
#define L_XOREQ         87L
#define L_ARG           88L
#define L_ASOP          89L
#define L_BREAK         90L
#define L_CASE          91L
#define L_CAST          92L
#define L_CLASS         93L
#define L_CONSTANT      94L
#define L_CONTINUE      95L
#define L_DEFAULT       96L
#define L_DIVOP         97L
#define L_DO            98L
#define L_ELLIPSIS      99L
#define L_ELSE          100L
#define L_ENTRY         101L
#define L_EOF           102L
#define L_EQUOP         103L
#define L_FILE          104L
#define L_FOR           105L
#define L_FUNCTION      106L
#define L_GOTO          107L
#define L_IF            108L
#define L_INCOP         109L
#define L_INIT          110L
#define L_LCURLY        111L
#define L_LINE          112L
#define L_LPAREN        113L
#define L_INTRINSIC     114L
#define L_MODIFIER      115L
#define L_MODULE        116L
#define L_RBRACK        117L
#define L_RCURLY        118L
#define L_RELOP         119L
#define L_RETURN        120L
#define L_RPAREN        121L
#define L_SELF          122L
#define L_SEMI          123L
#define L_SHIFTOP       124L
#define L_SIZEOF        125L
#define L_STUNOP        126L
#define L_SW            127L
#define L_SWEXP         128L
#define L_TYPE          129L
#define L_TYPENAME      130L
#define L_UPLUS         131L
#define L_WHILE         132L

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\rcdll\getflags.h ===
/*
 * the format strings may be:
 *              .*                      must match exactly
 *              .*\*.*          head and tail must match, with wild card in middle
 *              .*#                     head must match. tail can either be adjacent or next word
 *      at the moment '-' is not treated specialy
 *  note that 'middle' may be at either end since '.*' matches null.
 */

#define TAKESARG  0x20           /* tag to indicate argument or not */
#define FLAG      1              /* set the flag */
#define STRING    2 | TAKESARG   /* set the string, either from here, or next word */
#define SUBSTR    3 | TAKESARG   /* set single letter flags from substring */
#define NUMBER    4 | TAKESARG   /* set read in the number */
#define UNFLAG    5              /* turn the flag off */
#define PSHSTR    6 | TAKESARG   /* like string, but puts it on a LIST structure */
#define NOVSTR    7 | TAKESARG   /* like string, but complains about overwriting */

#define NUM_ARGS                50   /* Limit of flags passed from driver to pass */
#define MSC_ENVFLAGS            "MSC_CMD_FLAGS"
            /* Environment variable flags passed in, used for getenv() */
#define PUT_MSC_ENVFLAGS        "MSC_CMD_FLAGS="
            /* Environment variable flags passed in, used for putenv() */

/* return values from getflags */
#define R_SWITCH        1
#define R_CFILE         2
#define R_ASMFILE       3
#define R_OBJFILE       4
#define R_ERROR         5
#define R_FILE          6
#define R_EXIT          7
#define R_FFILE         8
#define R_PFILE         9
#define R_AFILE         10
#define R_OFILE         11
/* r. nevin, 1/11/85 */
#define R_HELP          12
/* b. nguyen, 4/7/86 */
#define R_HELPC         13
#define R_HELPF         14

struct cmdtab
        {
        WCHAR *format;           /* format matching string */
        char  *flag;             /* pointer to what to fill in */
/*  this is really a
 *      union
 *              {
 *              WCHAR **str;
 *              int  *flag;
 *              struct subtab *sub;
 *              struct LIST *list;
 *              } cm;
 *      but you cant initialize unions so we have to fake it.
 */
        char retval;            /* crack_cmd will return whatever is here */
        UCHAR type;             /* control mask */
        };

struct subtab
        {
        int letter;
        int type;
        int *flag;
        };


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\rcdll\p0io.h ===
/************************************************************************/
/*									*/
/* RCPP - Resource Compiler Pre-Processor for NT system			*/
/*									*/
/* P0IO.H - Preprocessor I/O macros					*/
/*									*/
/* 27-Nov-90 w-BrianM  Update for NT from PM SDK RCPP			*/
/*									*/
/************************************************************************/
#define	MUST_OPEN	1
#define	MAY_OPEN	0
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\rcdll\newexe.h ===
/*static WCHAR *SCCSID = L"@(#)newexe.h:2.9";*/
/*
 *  Title
 *
 *      newexe.h
 *      Pete Stewart
 *      (C) Copyright Microsoft Corp 1984
 *      17 August 1984
 *
 *  Description
 *
 *      Data structure definitions for the DOS 4.0/Windows 2.0
 *      executable file format.
 *
 *  Modification History
 *
 *      84/08/17        Pete Stewart    Initial version
 *      84/10/17        Pete Stewart    Changed some constants to match OMF
 *      84/10/23        Pete Stewart    Updates to match .EXE format revision
 *      84/11/20        Pete Stewart    Substantial .EXE format revision
 *      85/01/09        Pete Stewart    Added constants ENEWEXE and ENEWHDR
 *      85/01/10        Steve Wood      Added resource definitions
 *      85/03/04        Vic Heller      Reconciled Windows and DOS 4.0 versions
 *      85/03/07        Pete Stewart    Added movable entry count
 *      85/04/01        Pete Stewart    Segment alignment field, error bit
 *      88/03/28        Craig Critchley Version 3.00 stuff
 */

#define EMAGIC          0x5A4D          /* Old magic number */
#define ENEWEXE         sizeof(struct exe_hdr)
                                        /* Value of E_LFARLC for new .EXEs */
#define ENEWHDR         0x003C          /* Offset in old hdr. of ptr. to new */
#define ERESWDS         0x0010          /* No. of reserved words in header */
#define ECP             0x0004          /* Offset in struct of E_CP */
#define ECBLP           0x0002          /* Offset in struct of E_CBLP */
#define EMINALLOC       0x000A          /* Offset in struct of E_MINALLOC */

struct exe_hdr                          /* DOS 1, 2, 3 .EXE header */
  {
    USHORT      e_magic;        /* Magic number */
    USHORT      e_cblp;         /* Bytes on last page of file */
    USHORT      e_cp;           /* Pages in file */
    USHORT      e_crlc;         /* Relocations */
    USHORT      e_cparhdr;      /* Size of header in paragraphs */
    USHORT      e_minalloc;     /* Minimum extra paragraphs needed */
    USHORT      e_maxalloc;     /* Maximum extra paragraphs needed */
    USHORT      e_ss;           /* Initial (relative) SS value */
    USHORT      e_sp;           /* Initial SP value */
    USHORT      e_csum;         /* Checksum */
    USHORT      e_ip;           /* Initial IP value */
    USHORT      e_cs;           /* Initial (relative) CS value */
    USHORT      e_lfarlc;       /* File address of relocation table */
    USHORT      e_ovno;         /* Overlay number */
    USHORT      e_res[ERESWDS]; /* Reserved words */
    LONG        e_lfanew;       /* File address of new exe header */
  };

#define E_MAGIC(x)      (x).e_magic
#define E_CBLP(x)       (x).e_cblp
#define E_CP(x)         (x).e_cp
#define E_CRLC(x)       (x).e_crlc
#define E_CPARHDR(x)    (x).e_cparhdr
#define E_MINALLOC(x)   (x).e_minalloc
#define E_MAXALLOC(x)   (x).e_maxalloc
#define E_SS(x)         (x).e_ss
#define E_SP(x)         (x).e_sp
#define E_CSUM(x)       (x).e_csum
#define E_IP(x)         (x).e_ip
#define E_CS(x)         (x).e_cs
#define E_LFARLC(x)     (x).e_lfarlc
#define E_OVNO(x)       (x).e_ovno
#define E_RES(x)        (x).e_res
#define E_LFANEW(x)     (x).e_lfanew

#define NEMAGIC         0x454E          /* New magic number */
#define NERESBYTES      0

struct new_exe                          /* New .EXE header */
  {
    USHORT      ne_magic;       /* Magic number NE_MAGIC */
    BYTE        ne_ver;         /* Version number */
    BYTE        ne_rev;         /* Revision number */
    USHORT      ne_enttab;      /* Offset of Entry Table */
    USHORT      ne_cbenttab;    /* Number of bytes in Entry Table */
    LONG        ne_crc;         /* Checksum of whole file */
    USHORT      ne_flags;       /* Flag word */
    USHORT      ne_autodata;    /* Automatic data segment number */
    USHORT      ne_heap;        /* Initial heap allocation */
    USHORT      ne_stack;       /* Initial stack allocation */
    LONG        ne_csip;        /* Initial CS:IP setting */
    LONG        ne_sssp;        /* Initial SS:SP setting */
    USHORT      ne_cseg;        /* Count of file segments */
    USHORT      ne_cmod;        /* Entries in Module Reference Table */
    USHORT      ne_cbnrestab;   /* Size of non-resident name table */
    USHORT      ne_segtab;      /* Offset of Segment Table */
    USHORT      ne_rsrctab;     /* Offset of Resource Table */
    USHORT      ne_restab;      /* Offset of resident name table */
    USHORT      ne_modtab;      /* Offset of Module Reference Table */
    USHORT      ne_imptab;      /* Offset of Imported Names Table */
    LONG        ne_nrestab;     /* Offset of Non-resident Names Table */
    USHORT      ne_cmovent;     /* Count of movable entries */
    USHORT      ne_align;       /* Segment alignment shift count */
    USHORT      ne_cres;        /* Count of resource segments */
    BYTE        ne_exetyp;      /* Target operating system */
    BYTE        ne_flagsother;  /* Additional exe flags */
    USHORT      ne_gangstart;   /* offset to gangload area */
    USHORT      ne_ganglength;  /* length of gangload area */
    USHORT      ne_swaparea;    /* Minimum code swap area size */
    USHORT      ne_expver;      /* Expected Windows version number */
  };

#define NE_MAGIC(x)     (x).ne_magic
#define NE_VER(x)       (x).ne_ver
#define NE_REV(x)       (x).ne_rev
#define NE_ENTTAB(x)    (x).ne_enttab
#define NE_CBENTTAB(x)  (x).ne_cbenttab
#define NE_CRC(x)       (x).ne_crc
#define NE_FLAGS(x)     (x).ne_flags
#define NE_AUTODATA(x)  (x).ne_autodata
#define NE_HEAP(x)      (x).ne_heap
#define NE_STACK(x)     (x).ne_stack
#define NE_CSIP(x)      (x).ne_csip
#define NE_SSSP(x)      (x).ne_sssp
#define NE_CSEG(x)      (x).ne_cseg
#define NE_CMOD(x)      (x).ne_cmod
#define NE_CBNRESTAB(x) (x).ne_cbnrestab
#define NE_SEGTAB(x)    (x).ne_segtab
#define NE_RSRCTAB(x)   (x).ne_rsrctab
#define NE_RESTAB(x)    (x).ne_restab
#define NE_MODTAB(x)    (x).ne_modtab
#define NE_IMPTAB(x)    (x).ne_imptab
#define NE_NRESTAB(x)   (x).ne_nrestab
#define NE_CMOVENT(x)   (x).ne_cmovent
#define NE_ALIGN(x)     (x).ne_align
#define NE_RES(x)       (x).ne_res

#define NE_USAGE(x)     (WORD)*((WORD FAR *)(x)+1)
#define NE_PNEXTEXE(x)  (WORD)(x).ne_cbenttab
#define NE_PAUTODATA(x) (WORD)(x).ne_crc
#define NE_PFILEINFO(x) (WORD)((DWORD)(x).ne_crc >> 16)

#ifdef DOS5
#define NE_MTE(x)   (x).ne_psegcsum /* DOS 5 MTE handle for this module */
#endif


/*
 *  Format of NE_FLAGS(x):
 *
 *  p                                   Not-a-process
 *   l                                  Private Library
 *    e                                 Errors in image
 *     xxxx                             Unused
 *         ww                           Uses PM API
 *           G                          Library GlobalAlloc above the line
 *            M                         Multiple Instance
 *             L                        Uses LIM 3.2
 *              P                       Runs in protected mode
 *               r                      Runs in real mode
 *                i                     Instance data
 *                 s                    Solo data
 */
#define NENOTP          0x8000          /* Not a process */
#define NEPRIVLIB       0x4000          /* Private Library */
#define NENONC          0x4000          /* Non-conforming program */
#define NEIERR          0x2000          /* Errors in image */
#define NEWINAPI        0x0300          /* Uses PM API. For binary compat */
#define NEEMSLIB        0x0040          /* Library GA above EMS line */
#define NEMULTINST      0x0020          /* multiple instance flag */
#define NELIM32         0x0010          /* LIM 32 expanded memory */
#define NEPROT          0x0008          /* Runs in protected mode */
#define NEREAL          0x0004          /* Runs in real mode */
#define NEINST          0x0002          /* Instance data */
#define NESOLO          0x0001          /* Solo data */

/*
 *  Format of additional flags:
 *
 *  xxxx
 *      p                               Preload area defined after seg table
 *       P                              2.X supports protected mode
 *        F                             2.X supports proportional font
 *         L                            Long file name support
 */

#define NEPRELOAD       0x08            /* preload segments */
#define NEINPROT        0x04            /* protect mode */
#define NEINFONT        0x02            /* prop. system font */
#define NELONGNAMES     0x01            /* long file names */

struct new_seg                          /* New .EXE segment table entry */
  {
    USHORT      ns_sector;      /* File sector of start of segment */
    USHORT      ns_cbseg;       /* Number of bytes in file */
    USHORT      ns_flags;       /* Attribute flags */
    USHORT      ns_minalloc;    /* Minimum allocation in bytes */
  };

struct new_seg1                         /* New .EXE segment table entry */
  {
    USHORT      ns_sector;      /* File sector of start of segment */
    USHORT      ns_cbseg;       /* Number of bytes in file */
    USHORT      ns_flags;       /* Attribute flags */
    USHORT      ns_minalloc;    /* Minimum allocation in bytes */
    USHORT      ns_handle;      /* Handle of segment */
  };

#define NS_SECTOR(x)    (x).ns_sector
#define NS_CBSEG(x)     (x).ns_cbseg
#define NS_FLAGS(x)     (x).ns_flags
#define NS_MINALLOC(x)  (x).ns_minalloc

/*
 *  Format of NS_FLAGS(x):
 *
 *  xxxx                                Unused
 *      DD                              286 DPL bits
 *        d                             Segment has debug info
 *         r                            Segment has relocations
 *          e                           Execute/read only
 *           p                          Preload segment
 *            P                         Pure segment
 *             m                        Movable segment
 *              i                       Iterated segment
 *               ttt                    Segment type
 */
#define NSTYPE          0x0007          /* Segment type mask */
#define NSCODE          0x0000          /* Code segment */
#define NSDATA          0x0001          /* Data segment */
#define NSITER          0x0008          /* Iterated segment flag */
#define NSMOVE          0x0010          /* Movable segment flag */
#define NSPURE          0x0020          /* Pure segment flag */
#define NSPRELOAD       0x0040          /* Preload segment flag */
#define NSEXRD          0x0080          /* Execute-only (code segment), or
                                        *  read-only (data segment)
                                        */
#define NSRELOC         0x0100          /* Segment has relocations */
#define NSDEBUG         0x0200          /* Segment has debug info */
#define NSDPL           0x0C00          /* 286 DPL bits */
#define NSDISCARD       0x1000          /* Discard bit for segment */

#define NSALIGN 9       /* Segment data aligned on 512 byte boundaries */

struct new_segdata                      /* Segment data */
  {
    union
      {
        struct
          {
            USHORT      ns_niter;       /* number of iterations */
            USHORT      ns_nbytes;      /* number of bytes */
            BYTE        ns_iterdata;    /* iterated data bytes */
          } ns_iter;
        struct
          {
            BYTE        ns_data;        /* data bytes */
          } ns_noniter;
      } ns_union;
  };

struct new_rlcinfo                      /* Relocation info */
  {
    USHORT      nr_nreloc;      /* number of relocation items that */
  };                                    /* follow */

struct new_rlc                          /* Relocation item */
  {
    BYTE        nr_stype;       /* Source type */
    BYTE        nr_flags;       /* Flag byte */
    USHORT      nr_soff;        /* Source offset */
    union
      {
        struct
          {
            BYTE        nr_segno;       /* Target segment number */
            BYTE        nr_res;         /* Reserved */
            USHORT nr_entry;    /* Target Entry Table offset */
          }             nr_intref;      /* Internal reference */
        struct
          {
            USHORT nr_mod;      /* Index into Module Reference Table */
            USHORT nr_proc;     /* Procedure ordinal or name offset */
          }             nr_import;      /* Import */
      }                 nr_union;       /* Union */
  };

#define NR_STYPE(x)     (x).nr_stype
#define NR_FLAGS(x)     (x).nr_flags
#define NR_SOFF(x)      (x).nr_soff
#define NR_SEGNO(x)     (x).nr_union.nr_intref.nr_segno
#define NR_RES(x)       (x).nr_union.nr_intref.nr_res
#define NR_ENTRY(x)     (x).nr_union.nr_intref.nr_entry
#define NR_MOD(x)       (x).nr_union.nr_import.nr_mod
#define NR_PROC(x)      (x).nr_union.nr_import.nr_proc

/*
 *  Format of NR_STYPE(x):
 *
 *  xxxxx                               Unused
 *       sss                            Source type
 */
#define NRSTYP          0x07            /* Source type mask */
#define NRSSEG          0x02            /* 16-bit segment */
#define NRSPTR          0x03            /* 32-bit pointer */
#define NRSOFF          0x05            /* 16-bit offset */

/*
 *  Format of NR_FLAGS(x):
 *
 *  xxxxx                               Unused
 *       a                              Additive fixup
 *        rr                            Reference type
 */
#define NRADD           0x04            /* Additive fixup */
#define NRRTYP          0x03            /* Reference type mask */
#define NRRINT          0x00            /* Internal reference */
#define NRRORD          0x01            /* Import by ordinal */
#define NRRNAM          0x02            /* Import by name */


/* Resource type or name string */
struct rsrc_string
    {
    USHORT rs_len;            /* number of bytes in string */
    WCHAR  rs_string[ 1 ];    /* text of string */
    };

#define RS_LEN( x )    (x).rs_len
#define RS_STRING( x ) (x).rs_string

/* Resource type information block */
struct rsrc_typeinfo
    {
    USHORT rt_id;
    USHORT rt_nres;
    LONG   rt_proc;
    };

#define RT_ID( x )   (x).rt_id
#define RT_NRES( x ) (x).rt_nres
#define RT_PROC( x ) (x).rt_proc

/* Resource name information block */
struct rsrc_nameinfo
    {
    /* The following two fields must be shifted left by the value of  */
    /* the rs_align field to compute their actual value.  This allows */
    /* resources to be larger than 64k, but they do not need to be    */
    /* aligned on 512 byte boundaries, the way segments are           */
    USHORT rn_offset;   /* file offset to resource data */
    USHORT rn_length;   /* length of resource data */
    USHORT rn_flags;    /* resource flags */
    USHORT rn_id;       /* resource name id */
    USHORT rn_handle;   /* If loaded, then global handle */
    USHORT rn_usage;    /* Initially zero.  Number of times */
                                /* the handle for this resource has */
                                /* been given out */
    };

#define RN_OFFSET( x ) (x).rn_offset
#define RN_LENGTH( x ) (x).rn_length
#define RN_FLAGS( x )  (x).rn_flags
#define RN_ID( x )     (x).rn_id
#define RN_HANDLE( x ) (x).rn_handle
#define RN_USAGE( x )  (x).rn_usage

#define RSORDID     0x8000      /* if high bit of ID set then integer id */
                                /* otherwise ID is offset of string from
                                   the beginning of the resource table */

                                /* Ideally these are the same as the */
                                /* corresponding segment flags */
#define RNMOVE      0x0010      /* Moveable resource */
#define RNPURE      0x0020      /* Pure (read-only) resource */
#define RNPRELOAD   0x0040      /* Preloaded resource */
#define RNDISCARD   0x1000      /* Discard bit for resource */

#define RNLOADED    0x0004      /* True if handler proc return handle */

/* Resource table */
struct new_rsrc
    {
    USHORT rs_align;    /* alignment shift count for resources */
    struct rsrc_typeinfo rs_typeinfo;
    };

#define RS_ALIGN( x ) (x).rs_align

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\rcdll\ltoa.c ===
#include "rcpptype.h"

/* Long to ASCII conversion routine - used by print, and those programs
 * which want to do low level formatted output without hauling in a great
 * deal of extraneous code.  This will convert a long value to an ascii
 * string in any radix from 2 - 16.
 * RETURNS - the number of characters in the converted buffer.
 */

static WCHAR digits[] = {
    L'0', L'1', L'2', L'3', L'4',
    L'5', L'6', L'7', L'8', L'9',
    L'a', L'b', L'c', L'd', L'e', L'f'
};

#define BITS_IN_LONG  (8*sizeof(long))

int
zltoa(
    long aval,
    register WCHAR *buf,
    int base
    )
{
    // if unsigned long wont work on your host, you will probably have
    // to use signed long and accept this as not working for negative
    // numbers.

    register unsigned long val;
    register WCHAR *p;
    WCHAR tbuf[BITS_IN_LONG];
    int size = 0;

    p = tbuf;
    *p++ = L'\0';

    if (aval < 0 && base == 10) {
        *buf++ = L'-';
        val = -aval;
        size++;
    } else {
        val = aval;
    }

    do {
        *p++ = digits[val % base];
    } while (val /= base);

    while ((*buf++ = *--p) != 0) {
        ++size;
    }

    return(size);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\rcdll\mktable.c ===
/*****************************************************************************
 * mktable - table-building program to ease table maintenance problems
 *
 * DESCRIPTION
 *  Several parts of the FORTRAN compiler need large tables.
 *  For example, the lexer contains tables of keywords and multicharacter
 *  tokens; the intrinsic-function handler contains a table of all the
 *  FORTRAN intrinsic functions.
 *  Maintaining these tables can be aggravating, since they are typically
 *  large and involve lots of drudge work (like changing many sequentially-
 *  numbered macro definitions) to modify.
 *
 *  `mktable' can be used to build tables automatically as part of the
 *  usual compiler building process.  Its usages and semantics are as
 *  follows.
 *
 *  `mktable' takes a "table" file on its standard input.  Each line of
 *  the table file has one of the following forms:
 *
 *      # commentary information
 *      "key-string" [index-macro-name [arbitrary-stuff]]
 *      <blank line>
 *
 *  The key string and arbitrary-stuff form the contents of a single
 *  table record.  The index-macro-name is #define'd to be the index
 *  of the given record in the table.  If the index-macro-name is absent or
 *  is an empty string ("") then no macro definition is produced for the
 *  record.
 *
 *  `mktable' produces its output on four files:
 *      mktable.keys: the key string
 *      mktable.defs: #define <index_macro_name> <index to mktable.keys>
 *      mktable.indx: contains the initialization part of a definition
 *          for an index array for key-letter indexed tables,
 *          or the initialization part of a collision-resolution
 *          table for linear-list hashed tables.
 *          (not generated for sorted or _open-addressed tables.)
 *      mktable.info: contains arbitrary-stuff
 *
 *  For example, if the table to be defined were named "symtab" and the
 *  table being constructed was of the "sorted" type (suitable for binary
 *  search),
 *
 *      # contents of symtab:
 *      "alpha" ST_ALPHA    2, 4, MONADIC
 *      "gamma" ST_GAMMA    2, 3, MONADIC
 *      "delta" ST_DELTA    2, 1, DYADIC
 *      "epsilon"
 *
 *  then `mktable' produces the following in mktable.keys:
 *
 *      "alpha","delta","epsilon","gamma"
 *
 *  and the following in mktable.defs:
 *
 *      #define ST_ALPHA 0
 *      #define ST_DELTA 1
 *      #define ST_GAMMA 2
 *
 *  and in mktable.info :
 *
 *      {2, 4, MONADIC}, {2, 1, DYADIC}, {0}, {2, 3, MONADIC}
 *
 *  The files might be included in a C source program in the
 *  following way:
 *
 *      #include "mktable.defs"
 *      ...
 *      char    *symname[] = {
 *      #   include "mktable.keys"
 *          };
 *      struct syminfo
 *          {
 *          int size;
 *          int cycles;
 *          int arity;
 *          };
 *      struct syminfo symtab[] = {
 *      #   include "mktable.info"
 *          };
 *
 *  The `mktable' command itself is used in one of the following ways:
 *
 *  mktable "open" size <tablefile
 *      This form creates an _open-addressed hash table, keyed on
 *      the string fields at the beginning of each record in the
 *      table file.  The hash function used is the absolute value
 *      of the sum of all the characters in a key, modulo the table
 *      size.  The collision resolution function is simply one plus
 *      the last hash, modulo the table size.
 *      Since some of the entries in the hash table may be empty,
 *      and `mktable' has no way of knowing how to fill them,
 *      one of the records supplied by the user will be replicated
 *      in the empty entries with its key value set to NULL.
 *      "table.c" will be created with the hash table itself, and
 *      "table.h" will be created with index-macro definitions that
 *      may be used to index directly into the table in "table.c".
 *
 *  mktable "hashed" size <tablefile
 *      This form creates a hash table keyed on the string fields
 *      at the beginning of each table file record.  The hash function
 *      is the absolute value of the sum of all the characters in a
 *      key, modulo the table size.  Collision resolution is handled
 *      with linear chaining, as follows:  If two keys hash to the
 *      same table location, the first one will be placed in the table,
 *      and the corresponding entry of the collision resolution vector
 *      will contain the (integer) index of the next table slot to be
 *      checked for the hash synonym.  When the collision resolution
 *      vector entry is -1, the end of the chain has been reached.
 *      Note that since all entries are stored in the main table, the
 *      `size' must be at least as large as the number of entries.
 *      As with _open addressing, some slots in the table may be
 *      padded with a replicated entry (key value set to NULL).
 *      "table.c" receives the hash table.  "table.h" receives the
 *      index-macro definitions that will index into the table in
 *      "table.c".  "tabindex.c" receives the conflict resolution
 *      vector.
 *
 *  mktable "sorted" <tablefile
 *      This form creates a table sorted in ascending order, keyed
 *      on the string fields at the beginning of each record in the
 *      table file.  Comparisons are ordered according to the ASCII
 *      values of the characters being compared.
 *      "table.c" will be created with the sorted table itself, and
 *      "table.h" will be created with index-macro definitions that
 *      may be used to index directly into the table in "table.c".
 *
 *  mktable "key-letter" <tablefile
 *      This form creates a key-letter-indexed table.
 *      The string fields serve as the
 *      key letter.  An auxiliary table indexed from 'A' to 'Z'+1
 *      gives the starting index of all the entries whose keys begin
 *      with each letter (the last entry duplicates the entry for 'Z').
 *      "table.c" will contain the sorted table.  "tabindex.c" will
 *      contain the auxiliary index table information.  "table.h" will
 *      contain the index-macro definitions that may be used to index
 *      directly into the "table.c" table.
 *      Note that key-letter tables are sorted in a peculiar way;
 *      in ascending order by first letter of the key, but descending
 *      order by the remainder of the key.  This is required by
 *      FORTRAN, to insure that longer keywords are matched before
 *      shorter keywords that are initial substrings of the longer
 *      keywords.
 *      Also note that the key strings themselves are missing the first
 *      char, since by indexing into the table, we are always assured
 *      of having matched the first char.
 *
 * AUTHOR
 *      February, 1984      Allen Akin
 *
 * MODIFICATIONS
 *  March 8, 1984       Allen Akin
 *      Added linear-list resolved hashing.
 *****************************************************************************/

#include <stdio.h>
#include <ctype.h>
#include <stdlib.h>
#include <string.h>

#define MAXRECORDS  300     /* maximum-size table we can handle */
#define MAXLINE     82      /* maximum line length (incl "\n\0") */

#define HASHED      0       /* flag used by table loader */
#define LINEAR      1       /* ditto */
#define OPENADDR    2       /* ditto */

#define KEYFILE         "mktable.key"   /* name of table output file */
#define DEFFILE         "mktable.def"   /* name of index defs output file */
#define INDEXFILE       "mktable.ind"   /* name of table index output file */
#define INFOFILE        "mktable.inf"   /* gots the infos in it */

typedef struct rec {
    char *key;      /* key-string field */
    char *id;       /* index macro identifier */
    char *other;    /* other stuff in the record - output untouched */
    struct rec *link;   /* pointer to next record in hash synonyms list */
} Rec_t;

int Upper = 0;

FILE *Fkeys, *Findex, *Fdefs, *Finfo;

/************************************************************************/
/* Function Prototypes                          */
/************************************************************************/
void main (int argc, char **argv);
void usage (void);
void error(char * message);
void open_addr(int size);
void hash_linear(int size);
void sorted(void);
void key_letter(void);
int load(Rec_t *record, int method, int size);
void startoutput(void);
void endoutput(void);
void outrec(Rec_t *rec);
void outdef(char *name, int value);
void outinx(int value);
void sortrec(Rec_t **rptr, int size);
int hash(register char *name);


/************************************************************************/
/* Program code                             */
/************************************************************************/
void  __cdecl
main (
    int argc,
    char **argv
    )
{
    if (argc <= 1)
        usage();

    if(strcmp(argv[1], "-U") == 0) {
        Upper = 1;
        argv++;
        argc--;
    }

    if (strcmp(argv[1], "open") == 0) {
        if (argc != 3)
            usage();
        open_addr(atoi(argv[2]));
    } else if (strcmp(argv[1], "hashed") == 0) {
        if (argc != 3)
            usage();
        hash_linear(atoi(argv[2]));
    } else if (strcmp(argv[1], "sorted") == 0) {
        if (argc != 2)
            usage();
        sorted();
    } else if (strcmp(argv[1], "key-letter") == 0) {
        if (argc != 2)
            usage();
        key_letter();
    } else
        usage();
    exit(0);
}

void
usage (
    void
    )
{
    error("usage: mktable (open SIZE | hashed SIZE | sorted | key-letter) <table-master");
}

void
error(
    char * message
    )
{
    fprintf(stderr, "%s\n", message);
    exit(1);
}

void
open_addr(
    int size
    )
{
    register Rec_t *record;     /* points to array storing all records */
    Rec_t defrec;               /* "default" record for empty array slot */
    register int i;

    if (size <= 0)
        error("hash table size specified is less than zero");

    if ((record = (Rec_t *)calloc(size, sizeof(Rec_t))) == NULL)
        error("insufficient memory for hash table");

    for (i = 0; i < size; ++i)
        record[i].key = NULL;

    if (load(record, OPENADDR, size) == 0)
        error("couldn't find any input records");

    defrec.key = NULL;
    defrec.id = NULL;
    for (i = 0; i < size; ++i)
    if (record[i].key != NULL)
        break;
    defrec.other = record[i].other;

    startoutput();

    for (i = 0; i < size; ++i) {
        if (record[i].key == NULL) {
            outrec(&defrec);
        } else {
            outrec(&record[i]);
            outdef(record[i].id, i);
        }
    }

    endoutput();
    _unlink(INDEXFILE);
}

void
hash_linear(
    int size
    )
{
    register Rec_t *record,     /* stores some records, all buckets */
                    *rp;
    Rec_t defrec;               /* default record for empty hash table slots */
    register int i,
                 nextslot,      /* next empty slot in main hash table */
                 prev;

    if (size <= 0)
        error("hash table size specified is less than zero");

    if ((record = (Rec_t *)calloc(size, sizeof(Rec_t))) == NULL)
        error("insufficient memory for hash table");

    for (i = 0; i < size; ++i) {
        record[i].key = NULL;
        record[i].link = NULL;
    }

    if ((i = load(record, HASHED, size)) == 0)
        error("couldn't find any input records");

    if (i > size)
        error("too many records to hold in table");

    defrec.key = NULL;
    defrec.id = NULL;
    for (i = 0; i < size; ++i) {
        if (record[i].key != NULL)
            break;
    }
    defrec.other = record[i].other;
    defrec.link = NULL;
    /*
     * The `load' routine has built a hash table `record'.
     * Each entry in `record' is either empty (key == NULL) or contains a record.
     * Each record may have a NULL link field, or a link field that points to
     * a hash synonym.
     * With this section of code, we rearrange the linked lists of hash synonyms
     * so that all the entries are stored in `record'.
     */
    nextslot = 0;
    for (i = 0; i < size; ++i) {
        if ((record[i].key != NULL) &&
            (record[i].link != NULL) &&
            ((record[i].link < record) || (record[i].link >= (record + size))))
        {
            for (prev = i, rp = record[i].link; rp != NULL; rp = rp->link) {
                while (record[nextslot].key != NULL)
                    ++nextslot;
                record[prev].link = &record[nextslot];
                record[nextslot] = *rp;
                prev = nextslot;
            }
        }
    }

    startoutput();

    for (i = 0; i < size; ++i) {
        if (record[i].key == NULL) {
            outrec(&defrec);
            outinx(-1);
        } else {
            outrec(&record[i]);
            if (record[i].link == NULL)
                outinx(-1);
            else
                outinx(record[i].link - record);    /* cvt. to inx in table */
            outdef(record[i].id, i);
        }
    }

    endoutput();
}

void
sorted(
    void
    )
{
    Rec_t  record[MAXRECORDS],
          *rptr[MAXRECORDS];
    register int i, size;

    size = load(record, LINEAR, MAXRECORDS);

    for (i = 0; i < size; ++i)
        rptr[i] = &record[i];

    sortrec(rptr, size);

    startoutput();

    for (i = 0; i < size; ++i) {
        outrec(rptr[i]);
        outdef(rptr[i]->id, i);
    }

    endoutput();
    _unlink(INDEXFILE);
}

void
key_letter(
    void
    )
{
    Rec_t  record[MAXRECORDS],
          *rptr[MAXRECORDS],
          *temp;
    register int i, size, j, k, l;

    register char lastletter;

    size = load(record, LINEAR, MAXRECORDS);

    for (i = 0; i < size; ++i)
        rptr[i] = &record[i];

    sortrec(rptr, size);

    for (i = 0; i < size; i = j) {
        for (j = i; j < size; ++j) {
            if (rptr[i]->key[0] != rptr[j]->key[0])
                break;
        }

        l = j - 1;

        for (k = i; k < l; ++k, --l) {
            temp = rptr[k];
            rptr[k] = rptr[l];
            rptr[l] = temp;
        }
    }

    startoutput();

    lastletter = (char)((Upper ? 'A' : '_') - 1);
    for (i = 0; i < size; ++i)
    {
        while (rptr[i]->key[0] > lastletter) {
            outinx(i);
            ++lastletter;
        }
        outrec(rptr[i]);
        outdef(rptr[i]->id, i);
    }


    for (; lastletter < (char)((Upper ? 'Z' : 'z') + 1); ++lastletter)
        outinx(size);

    endoutput();
}

int
load(
    Rec_t *record,
    int method,
    int size
    )
{
    char *line;
    register char *p;
    int rec, h, chainlen, maxchainlen = 0, collisions = 0;
    Rec_t r;

    for (rec = 0; ; ++rec)
    {
        if ((line = malloc(MAXLINE)) == NULL)
            error("insufficient memory to load records");

        if (fgets(line, MAXLINE, stdin) == NULL)
            break;

        if (rec >= size)
            error("too many records to handle");

        r.key = r.id = r.other = NULL;
        r.link = NULL;

        for (p = line; *p && isspace(*p); ++p)
            ;
        if (*p != '"') {
            free(line);
            --rec;
            continue;
        }
        r.key = ++p;
        for (; *p != '"'; ++p) {
            if(Upper && (islower(*p)))
                *p = (char)toupper(*p);
        }

        *p++ = '\0';

        for (; *p && isspace(*p); ++p)          /* skip space key and id */
            ;
        if (*p == '"' && *(p + 1) == '"') {     /* no id */
            r.id = NULL;
            p += 2;
        } else if (*p) {
            r.id = p++;                         /* id start */
            for (; *p && ( ! isspace(*p)); ++p) /* til first space */
                ;
            if(*p) {
                *p++ = '\0';                    /* terminate id */
            }
        }

        for (; *p && isspace(*p); ++p)      /* skip space til other info */
            ;
        if(*p) {
            r.other = p++;
            for (; *p != '\n' && *p != '\0'; ++p)
                ;
            *p = '\0';
        }

        if (method == LINEAR) {
            record[rec] = r;
        } else if (method == OPENADDR) {
            chainlen = 0;
            for(h = hash(r.key) % size; record[h].key; h = (h+1) % size) {
                ++chainlen;
                ++collisions;
            }
            maxchainlen = (chainlen < maxchainlen)? maxchainlen: chainlen;
            record[h] = r;
        } else { /* method == HASHED */
            Rec_t  *rp;

            h = hash(r.key) % size;
            if (record[h].key == NULL) {
                record[h] = r;
            } else {
                if ((rp = (Rec_t *)malloc(sizeof(Rec_t))) == NULL)
                    error("insufficient memory to store all records");
                *rp = record[h];
                r.link = rp;
                record[h] = r;
                ++collisions;
                chainlen = 1;
                for (rp = &record[h]; rp->link != NULL; rp = rp->link)
                    ++chainlen;
                maxchainlen = (chainlen < maxchainlen)? maxchainlen: chainlen;
            }
        }
    }

    if (method == HASHED || method == OPENADDR)
        fprintf(stderr, "%d collisions, max chain length %d\n", collisions, maxchainlen);

    return rec;
}

void
startoutput(
    void
    )
{
    if ((Fkeys = fopen(KEYFILE, "w")) == NULL)
        error("can't open keys output file");

    if ((Findex = fopen(INDEXFILE, "w")) == NULL)
        error("can't open index output file");

    if ((Fdefs = fopen(DEFFILE, "w")) == NULL)
        error("can't open definitions output file");

    if ((Finfo = fopen(INFOFILE, "w")) == NULL)
        error("can't open info output file");
}

void
endoutput(
    void
    )
{
    fclose(Fkeys);
    fclose(Findex);
    fclose(Fdefs);
    fclose(Finfo);
}

void outrec(Rec_t *rec)
{
    if (rec->key == NULL)
        fprintf(Fkeys, "NULL,\n");
    else
        fprintf(Fkeys, "\"%s\",\n", ((rec->key) + 1));

    if (rec->other == NULL)
        fprintf(Finfo, "{0},\n");
    else
        fprintf(Finfo, "{%s},\n", rec->other);
}

void
outdef(
    char *name,
    int value
    )
{
    if (name != NULL)
        fprintf(Fdefs, "#define %s %d\n", name, value);
}

void
outinx(
    int value
    )
{
    fprintf(Findex, "%d,\n", value);
}
/*
 * Following code defines the hash function used in `mktable' and in
 * the compiler.  Since we must guarantee they are the same function,
 * we use a single source file.
 *
 * `mktable' does not use the standard include file that the compiler
 * uses, so we define the allowable register declarations here.
 */
#define REG1 register
#define REG2 register
#define REG3 register

void
sortrec(
    Rec_t **rptr,
    int size
    )
{
    register int j, i, gap;
    Rec_t  *temp;

    for (gap = size / 2; gap > 0; gap /= 2) {
        for (i = gap; i < size; ++i) {
            for (j = i - gap; j >= 0; j -= gap) {
                if (strcmp(rptr[j]->key, rptr[j + gap]->key) <= 0)
                    break;
                temp = rptr[j];
                rptr[j] = rptr[j + gap];
                rptr[j + gap] = temp;
            }
        }
    }
}

int
hash(
    register char *name
    )
{
    register    int i;

    i = 0;
    while(*name) {
        i += *name++ ;
    }
    return(i) ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\rcdll\p0defs.h ===
/************************************************************************/
/*                                                                      */
/* RCPP - Resource Compiler Pre-Processor for NT system                 */
/*                                                                      */
/* P0DEFS.H - Defintions for PreProcessor parsing code                  */
/*                                                                      */
/* 06-Dec-90 w-BrianM  Update for NT from PM SDK RCPP                   */
/*                                                                      */
/************************************************************************/

struct  s_defn  {
    pdefn_t     defn_next;              /*  pointer to next ident  */
    PWCHAR      defn_ident;             /*  pointer to name */
    PWCHAR      defn_text;              /*  definition substitution string  */
    char        defn_nformals;          /*number of formal arguments - can be <0*/
    char        defn_expanding;         /* are we already expanding this one? */
};

#define DEFN_IDENT(P)           ((P)->defn_ident)
#define DEFN_NAME(P)            (DEFN_IDENT(P))
#define DEFN_NEXT(P)            ((P)->defn_next)
#define DEFN_TEXT(P)            ((P)->defn_text)
#define DEFN_NFORMALS(P)        ((P)->defn_nformals)
#define DEFN_EXPANDING(P)       ((P)->defn_expanding)

#define FILE_EOS                0x01L
#define ACTUAL_EOS              0x02L
#define DEFINITION_EOS          0x04L
#define RESCAN_EOS              0x08L
#define BACKSLASH_EOS           0x10L
#define ANY_EOS                 ( FILE_EOS | ACTUAL_EOS | DEFINITION_EOS \
                                                                         | RESCAN_EOS | BACKSLASH_EOS )

/*
**      arbitrarily chosen characters that get special treatment when found
**      after EOS in handle_eos()
*/
#define EOS_ACTUAL              L'A'
#define EOS_DEFINITION          L'D'
#define EOS_RESCAN              L'R'
#define EOS_PAD                 L'P'

#define FROM_COMMAND            -2
#define PRE_DEFINED(P)          (DEFN_NFORMALS(P) < FROM_COMMAND)

typedef struct s_expstr {
    ptext_t     exp_string;     /* ptr to next character in stream aft macro */
    WCHAR       *exp_actuals;   /* ptr to start of actuals linked list */
    ptext_t     exp_text;       /* ptr to expanded text for this macro */
    pdefn_t     exp_macro;      /* ptr to macro defn */
    UCHAR       exp_nactuals;   /* number of actuals */
    UCHAR       exp_nactsexpanded;/* number of expanded actuals for handle_eos*/
} expansion_t;

/*
**      note that CURRENT_STRING usually points into an area in the macro
**      expansion buffer, but the first item used (Macro_depth equals 1) points
**      to text read from a file.  In some versions, the heap is reshuffled
**      and this pointer must be updated for the first item.
*/
#define CURRENT_STRING          Macro_expansion[Macro_depth].exp_string
#define CURRENT_ACTUALS         Macro_expansion[Macro_depth].exp_actuals
#define CURRENT_TEXT            Macro_expansion[Macro_depth].exp_text
#define CURRENT_MACRO           Macro_expansion[Macro_depth].exp_macro
#define CURRENT_NACTUALS        Macro_expansion[Macro_depth].exp_nactuals
#define CURRENT_NACTSEXPANDED Macro_expansion[Macro_depth].exp_nactsexpanded

/*
**      finds address after last element in an array. Used to check for
**      buffer overflows.
*/
#define LIMIT(a)        &(a)[sizeof(a) / sizeof(*a)]

#define IS_CHAR(c,uc)   (towupper(c) == (uc))
#define IS_B(c)         IS_CHAR(c, L'B')
#define IS_D(c)         IS_CHAR(c, L'D')
#define IS_E(c)         IS_CHAR(c, L'E')
#define IS_F(c)         IS_CHAR(c, L'F')
#define IS_H(c)         IS_CHAR(c, L'H')
#define IS_EL(c)        IS_CHAR(c, L'L')
#define IS_O(c)         IS_CHAR(c, L'O')
#define IS_Q(c)         IS_CHAR(c, L'Q')
#define IS_U(c)         IS_CHAR(c, L'U')
#define IS_X(c)         IS_CHAR(c, L'X')
#define IS_DOT(c)       (c == L'.')
#define IS_SIGN(c)      ((c == L'+') || (c ==L'-'))

#define P0_IF           0
#define P0_ELIF         1
#define P0_ELSE         2
#define P0_ENDIF        3
#define P0_IFDEF        4
#define P0_IFNDEF       5
#define P0_DEFINE       6
#define P0_INCLUDE      7
#define P0_PRAGMA       8
#define P0_UNDEF        9
#define P0_LINE         10
#define P0_NOTOKEN      11
#define P0_ERROR        12
#define P0_IDENT        13


#define HLN_NAME(s)     ((s).hln_name)
#define HLN_HASH(s)     ((s).hln_hash)
#define HLN_LENGTH(s)   ((s).hln_length)
#define HLN_IDENT_HASH(p)       (HLN_HASH(*(p)))
#define HLN_IDENT_LENGTH(p)     (HLN_LENGTH(*(p)))
#define HLN_IDENTP_NAME(p)      (HLN_NAME(*(p)))
#define HLN_TO_NAME(S)          ((PWCHAR)pstrndup(HLN_IDENTP_NAME(S),HLN_IDENT_LENGTH(S)))

#define HASH_MASK               0x5f

#define LIMIT_ID_LENGTH         31
#define LIMIT_NESTED_INCLUDES   1024
#define LIMIT_MACRO_DEPTH       64
#define LIMIT_STRING_LENGTH     2043
#define LEVEL_0                 0xffL

#define MUST_OPEN       1
#define MAY_OPEN        0

/*** The following are defined to use on the Token Table ***/

#define TS_STR(idx)     (Tokstrings[idx-L_NOTOKEN].k_text)
#define TS_VALUE(idx)   (Tokstrings[idx-L_NOTOKEN].k_token)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\rcdll\p0keys.c ===
/************************************************************************/
/*                                                                      */
/* RCPP - Resource Compiler Pre-Processor for NT system                 */
/*                                                                      */
/* P0KEYS.C - Keycode stuff                                             */
/*                                                                      */
/* 06-Dec-90 w-BrianM  Update for NT from PM SDK RCPP                   */
/*                                                                      */
/************************************************************************/

#include "rc.h"

/************************************************************************/
/*  table for preprocessor id's                                         */
/************************************************************************/
WCHAR   * Pkeyw_Table[] = {
#include "pkeyw.key"
};
char    Pkeyw_Index[] = {
#include        "pkeyw.ind"
};
struct  s_pkinfo        {
    token_t     s_info;
} Pkeyw_Info[] = {
#include        "pkeyw.inf"
};


/************************************************************************/
/*  is_pkeyword : finds the token for the id if it's a preprocessor keyword.*/
/*  P0_NOTOKEN if not found.                                            */
/************************************************************************/
token_t
is_pkeyword(
    WCHAR *id
    )
{
    REG WCHAR   **start;
    REG WCHAR   **stop;
    PUCHAR      pi;

    if( (*id) < L'_') {
        return(P0_NOTOKEN);
    }
    /*
    **  the indx table tells us the start of
    **  the words which begin with the first char if the id.
    **  the 'stop' is the index of the word which does not have the
    **  give char as it's first.
    **  we can start checking after the first char since, we *know* that
    **  they match (hence the additions 'id++' and (*start) + 1
    */
    pi = (PUCHAR) &Pkeyw_Index[((*id) - L'_')];
    for(start = &Pkeyw_Table[*pi++], stop = &Pkeyw_Table[*pi], id++;
        start != stop;
        start++
        ) {
        if(wcscmp(*start, id) == 0) {
            return(Pkeyw_Info[(start - &Pkeyw_Table[0])].s_info);
        }
    }
    return(P0_NOTOKEN);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\rcdll\p0io.c ===
/************************************************************************/
/*                                                                      */
/* RCPP - Resource Compiler Pre-Processor for NT system                 */
/*                                                                      */
/* P0IO.C - Input/Output for Preprocessor                               */
/*                                                                      */
/* 27-Nov-90 w-BrianM  Update for NT from PM SDK RCPP                   */
/*                                                                      */
/************************************************************************/

#include "rc.h"


/************************************************************************/
/* Local Function Prototypes                                            */
/************************************************************************/
PWCHAR esc_sequence(PWCHAR, PWCHAR);


#define TEXT_TYPE ptext_t

/***  ASSUME : the trailing marker byte is only 1 character. ***/

#define PUSHBACK_BYTES  1

#define TRAILING_BYTES  1

#define EXTRA_BYTES             (PUSHBACK_BYTES + TRAILING_BYTES)
/*
**  here are some defines for the new handling of io buffers.
**  the buffer itself is 6k plus some extra bytes.
**  the main source file uses all 6k.
**  the first level of include files will use 4k starting 2k from the beginning.
**  the 2nd level - n level will use 2k starting 4k from the beginning.
**  this implies that some special handling may be necessary when we get
**  overlapping buffers. (unless the source file itself is < 2k
**  all the include files are < 2k and they do not nest more than 2 deep.)
**  first, the source file is read into the buffer (6k at a time).
**  at the first include file, (if the source from the parent file
**  is more than 2k chars) . . .
**              if the Current_char ptr is not pointing above the 2k boundary
**              (which is the beginning of the buffer for the include file)
**              then we pretend we've read in only 2k into the buffer and
**              place the terminator at the end of the parents 2k buffer.
**              else we pretend we've used up all chars in the parents buffer
**              so the next read for the parent will be the terminator, and
**              the buffer will get filled in the usual manner.
**  (if we're in a macro, the picture is slightly different in that we have
**  to update the 'real' source file pointer in the macro structure.)
**
**  the first nested include file is handled in a similar manner. (except
**  it starts up 4k away from the start.)
**
**  any further nesting will keep overlaying the upper 2k part.
*/
#define IO_BLOCK        (4 * 1024 + EXTRA_BYTES)

int vfCurrFileType = DFT_FILE_IS_UNKNOWN;   //- Added for 16-bit file support.

extern expansion_t Macro_expansion[];

typedef struct  s_filelist      filelist_t;
static struct s_filelist        {       /* list of input files (nested) */
    int         fl_bufsiz;      /* characters to read into the buffer */
    FILE *      fl_file;        /* FILE id */
    long        fl_lineno;      /* line number when file was pushed */
    PWCHAR      fl_name;        /* previous file text name */
    ptext_t     fl_currc;       /* ptr into our buffer for current c */
    TEXT_TYPE   fl_buffer;      /* type of buffer */
    int         fl_numread;     /* # of characters read from the file */
    int         fl_fFileType;   //- Added for 16-bit file support.
                                //- return from DetermineFileType.
    long        fl_seek;        //- Added for restart - contains seek
                                //  address of last read.
} Fstack[LIMIT_NESTED_INCLUDES];

static  FILE *Fp = NULL;
int           Findex = -1;


/************************************************************************
 * NEWINPUT - A new input file is to be opened, saving the old.
 *
 * ARGUMENTS
 *      WCHAR *newname - the name of the file
 *
 * RETURNS  - none
 *
 * SIDE EFFECTS
 *      - causes input stream to be switched
 *      - Linenumber is reset to 1
 *      - storage is allocated for the newname
 *      - Filename is set to the new name
 *
 * DESCRIPTION
 *      The file is opened, and if successful, the current input stream is saved
 *      and the stream is switched to the new file. If the newname is NULL,
 *      then stdin is taken as the new input.
 *
 * AUTHOR - Ralph Ryan, Sept. 9, 1982
 *
 * MODIFICATIONS - none
 *
 ************************************************************************/
int
newinput (
    WCHAR *newname,
    int m_open
    )
{
    filelist_t *pF;
    WCHAR      *p;

    if( newname == NULL ) {
        Fp = stdin;
    }
    else {
        // Note: Always use the Ansi codepage here.  uiCodePage may have been
        // modified by a codepage pragma in the source file.

        WideCharToMultiByte (GetACP(), 0, newname, -1, chBuf, sizeof(chBuf), NULL, NULL);
        if((Fp = fopen(chBuf, "rb")) == NULL) {
           if(m_open == MUST_OPEN) {
               Msg_Temp = GET_MSG (1005);
               SET_MSG (Msg_Text, sizeof(Msg_Text), Msg_Temp, chBuf);
               fatal(1005);
           }
           return(FALSE);
        }
    }

    /* now push it onto the file stack */
    ++Findex;
    if(Findex >= LIMIT_NESTED_INCLUDES) {
        Msg_Temp = GET_MSG (1014);
        SET_MSG (Msg_Text, sizeof(Msg_Text), Msg_Temp, LIMIT_NESTED_INCLUDES);
        fatal(1014);
    }
    pF = &Fstack[Findex];
    p = (WCHAR *) MyAlloc((IO_BLOCK + PUSHBACK_BYTES) * sizeof(WCHAR));
    if (!p) {
        strcpy (Msg_Text, GET_MSG (1002));
        fatal(1002);                  /* no memory */
        return 0;
    }
    pF->fl_bufsiz = IO_BLOCK;

    pF->fl_currc = Current_char;     /*  previous file's current char */
    pF->fl_lineno = Linenumber;      /*  previous file's line number  */
    pF->fl_file = Fp;                /*  the new file descriptor      */
    pF->fl_buffer = p;
    pF->fl_numread = 0;
    pF->fl_seek = 0;

    pF->fl_fFileType = DetermineFileType (Fp);

    if (pF->fl_fFileType == DFT_FILE_IS_UNKNOWN) {
        Msg_Temp = GET_MSG (4413);
        SET_MSG (Msg_Text, sizeof(Msg_Text), Msg_Temp, newname);
        warning (4413);
        pF->fl_fFileType = DFT_FILE_IS_8_BIT;
    }

    vfCurrFileType = pF->fl_fFileType;

    Current_char = p;
    io_eob();                                   /*  fill the buffer  */
    /*
        * Note that include filenames will live the entire compiland. This
        * puts the burden on the user with MANY include files.  Any other
        * scheme takes space out of static data.
        * Notice also, that we save the previous filename in the new file's
        * fl_name.
        */
    pF->fl_name = pstrdup(Filename);
    wcsncpy(Filebuff, newname, sizeof(Filebuff) / sizeof(WCHAR));
    Linenumber = 0;     /*  do_newline() will increment to the first line */
    if(Eflag) {
        emit_line();
        // must manually write '\r' with '\n' when writing 16-bit strings
        myfwrite(L"\r\n", 2 * sizeof(WCHAR), 1, OUTPUTFILE);  /* this line is inserted */
    }

    {
        defn_t d;
        int old_line = Linenumber;
        Linenumber = Findex;

        DEFN_IDENT(&d) = L"!";
        DEFN_TEXT(&d) = Reuse_Include;
        DEFN_NEXT(&d) = NULL;
        DEFN_NFORMALS(&d) = 0;
        DEFN_EXPANDING(&d) = FALSE;
        AfxOutputMacroDefn(&d);

        if (Findex > 0) {
            DEFN_IDENT(&d) = L"$";
            DEFN_TEXT(&d) = Filename;
            DEFN_NEXT(&d) = NULL;
            DEFN_NFORMALS(&d) = 0;
            DEFN_EXPANDING(&d) = FALSE;
            AfxOutputMacroDefn(&d);
        }

        Linenumber = old_line;
    }

    do_newline();       /*  a new file may have preproc cmd as first line  */
    return(TRUE);
}


/************************************************************************
 * FPOP - pop to a previous level of input stream
 *
 * ARGUMENTS - none
 *
 * RETURNS
 *      TRUE if successful, FALSE if the stack is empty
 *
 * SIDE EFFECTS
 *      - Linenumber is restored to the old files line number
 *      - Filename is reset to the old filename
 *  - frees storage allocated for filename
 *
 * DESCRIPTION
 *      Pop the top of the file stack, restoring the previous input stream.
 *
 * AUTHOR - Ralph Ryan, Sept. 9, 1982
 *
 * MODIFICATIONS - none
 *
 ************************************************************************/
WCHAR
fpop(
    void
    )
{
    int     OldLine;
    defn_t  DefType;

    if(Findex == -1) {          /* no files left */
        return(FALSE);
    }

    if (Fp)
        fclose(Fp);

    OldLine = Linenumber;

    --Findex;
    Linenumber = Findex;

    DEFN_IDENT(&DefType) = L"!";
    DEFN_TEXT(&DefType) = L"";
    DEFN_NEXT(&DefType) = NULL;
    DEFN_NFORMALS(&DefType) = 0;
    DEFN_EXPANDING(&DefType) = FALSE;
    AfxOutputMacroDefn(&DefType);
    Findex++;
    Linenumber = OldLine;

    strappend(Filebuff,Fstack[Findex].fl_name);
    OldLine = Linenumber;
    Linenumber = (int)Fstack[Findex].fl_lineno;
    Current_char = Fstack[Findex].fl_currc;
    MyFree(Fstack[Findex].fl_buffer);
    if(--Findex < 0) {                  /* popped the last file */
        Linenumber = OldLine;
        return(FALSE);
    }
    Fp = Fstack[Findex].fl_file;
    vfCurrFileType = Fstack[Findex].fl_fFileType;
    if(Eflag) {
        // If the last file didn't end in a \r\n, the #line from emit_line could
        // end up in whatever data structure it ended in... Emit a dummy newline
        // just in case.
        myfwrite(L"\r\n", 2 * sizeof(WCHAR), 1, OUTPUTFILE);  /* this line is inserted */
        emit_line();
    }
    return(TRUE);
}


/************************************************************************
**  nested_include : searches the parentage list of the currently
**              open files on the stack when a new include file is found.
**              Input : ptr to include file name.
**              Output : TRUE if the file was found, FALSE if not.
*************************************************************************/
int
nested_include(
    void
    )
{
    PWCHAR      p_tmp1;
    PWCHAR      p_file;
    PWCHAR      p_slash;
    int         tos;

    tos = Findex;
    p_file = Filename;          /* always start with the current file */
    for(;;) {
        p_tmp1 = p_file;
        p_slash = NULL;
        while(*p_tmp1) {        /* pt to end of filename, find trailing slash */
            if(wcschr(Path_chars, *p_tmp1)) {
                p_slash = p_tmp1;
            }
            p_tmp1++;
        }
        if(p_slash) {
            p_tmp1 = Reuse_W;
            while(p_file <= p_slash) {  /*  we want the trailing '/'  */
                *p_tmp1++ = *p_file++;  /*  copy the parent directory  */
            }
            p_file = yylval.yy_string.str_ptr;
            while((*p_tmp1++ = *p_file++)!=0) {  /*append include file name  */
                ;       /*  NULL  */
            }
        } else {
            wcscpy(Reuse_W, yylval.yy_string.str_ptr);
        }
        if(newinput(Reuse_W,MAY_OPEN)) {
            return(TRUE);
        }
        if(tos <= 0) {
            break;
        }
        p_file = Fstack[tos--].fl_name;
    }
    return(FALSE);
}


/************************************************************************/
/* esc_sequence()                                                       */
/************************************************************************/
PWCHAR
esc_sequence(
    PWCHAR dest,
    PWCHAR name
    )
{
    *dest = L'"';
    while((*++dest = *name) != 0) {
        if (CHARMAP(*name) == LX_EOS) {
            *++dest = L'\\';
        }
        name++;
    }
    *dest++ = L'"';              /* overwrite null */
    return( dest );
}


/************************************************************************/
/* emit_line()                                                          */
/************************************************************************/
void
emit_line(
    void
    )
{
    PWCHAR   p;

    swprintf(Reuse_W, L"#line %d ", Linenumber+1);
    myfwrite(Reuse_W, wcslen(Reuse_W) * sizeof(WCHAR), 1, OUTPUTFILE);

    p = esc_sequence(Reuse_W, Filename);
    myfwrite(Reuse_W, (size_t)(p - Reuse_W) * sizeof(WCHAR), 1, OUTPUTFILE);
}

/************************************************************************
**  io_eob : handle getting the next block from a file.
**  return TRUE if this is the real end of the buffer, FALSE if we have
**  more to do.
************************************************************************/
int
io_eob(
    void
    )
{
    int         n;
    TEXT_TYPE   p;

    static int   dc;

    p = Fstack[Findex].fl_buffer;
    if((Current_char - (ptext_t)p) < Fstack[Findex].fl_numread) {
        /*
        **  haven't used all the chars from the buffer yet.
        **  (some clown has a null/cntl z embedded in his source file.)
        */
        if(PREVCH() == CONTROL_Z) {     /* imbedded control z, real eof */
            UNGETCH();
            return(TRUE);
        }
        return(FALSE);
    }
    Current_char = p;

    //-
    //- The following section was added to support 16-bit resource files.
    //- It will just convert them to 8-bit files that the Resource Compiler
    //- can read.  Here is the basic strategy used.  An 8-bit file is
    //- read into the normal buffer and should be processed the old way.
    //- A 16-bit file is read into a wide character buffer identical to the
    //- normal 8-bit one.  The entire contents are then copied to the 8-bit
    //- buffer and processed normally.  The one exception to this is when
    //- a string literal is encountered.  We then return to the 16-bit buffer
    //- to read the characters.  These characters are written as backslashed
    //- escape characters inside an 8-bit string.  (ex. "\x004c\x523f").
    //- I'll be the first person to admit that this is an ugly solution, but
    //- hey, we're Microsoft :-).  8-2-91 David Marsyla.
    //-
    if (Fstack[Findex].fl_fFileType == DFT_FILE_IS_8_BIT) {
        REG int     i;
        REG PUCHAR  lpb;
        PUCHAR      Buf;

        Buf = (PUCHAR) MyAlloc(Fstack[Findex].fl_bufsiz + 1);
        if (Buf == NULL) {
            strcpy (Msg_Text, GET_MSG (1002));
            fatal(1002);                  /* no memory */
        }
        Fstack[Findex].fl_seek = fseek(Fp, 0, SEEK_CUR);
        n = fread (Buf, sizeof(char), Fstack[Findex].fl_bufsiz, Fp);

        //-
        //- Determine if the last byte is a DBCS lead byte
        //-     if YES (i will be greater than n), backup one byte
        //-
        for (i = 0, lpb = Buf; i < n; i++, lpb++) {
            if (IsDBCSLeadByteEx(uiCodePage, *lpb)) {
                i++;
                lpb++;
            }
        }
        if (i > n) {
            fseek (Fp, -1, SEEK_CUR);
            n--;
            *(Buf + n) = 0;
        }

        //-
        //- Convert the 8-bit buffer to the 16-bit buffer.
        //-
        Fstack[Findex].fl_numread = MultiByteToWideChar (uiCodePage, MB_PRECOMPOSED,
                                          (LPCSTR) Buf, n, p, Fstack[Findex].fl_bufsiz);
        MyFree (Buf);
    } else {

        Fstack[Findex].fl_numread = n =
            fread (p, sizeof(WCHAR), Fstack[Findex].fl_bufsiz, Fp);

        //-
        //- If the file is in reversed format, swap the bytes.
        //-
        if (Fstack[Findex].fl_fFileType == DFT_FILE_IS_16_BIT_REV && n > 0) {
            WCHAR  *pT = p;
            BYTE  jLowNibble;
            BYTE  jHighNibble;
            INT   cNumWords = n;

            while (cNumWords--) {
                jLowNibble = (BYTE)(*pT & 0xFF);
                jHighNibble = (BYTE)((*pT >> 8) & 0xFF);

                *pT++ = (WCHAR)(jHighNibble | (jLowNibble << 8));
            }
        }
    }

    /*
    **  the total read counts the total read *and* used.
    */

    if (n != 0) {                               /* we read something */
        *(p + Fstack[Findex].fl_numread) = EOS_CHAR;    /* sentinal at the end */
        return(FALSE);                          /* more to do */
    }
    *p = EOS_CHAR;                              /* read no chars */
    return(TRUE);                               /* real end of buffer */
}


/************************************************************************
** io_restart : restarts the current file with a new codepage
**  Method: figure out where the current character came from
**      using WideCharToMultiByte(...cch up to current char...)
**      Note that this assumes that roundtrip conversion to/from
**      Unicode results in the same # of characters out as in.
**      fseek to the right place, then read a new buffer
**
**      Note that uiCodePage controls the seek, so it must
**      remain set to the value used to do the translation
**      from multi-byte to Unicode until after io_restart returns.
**
************************************************************************/
int
io_restart(
    unsigned long cp
    )
{
    int         n;
    TEXT_TYPE   p;

    // If it's a Unicode file, nothing to do, so just return.
    if (Fstack[Findex].fl_fFileType != DFT_FILE_IS_8_BIT)
        return TRUE;

    p = Fstack[Findex].fl_buffer;
    n = Fstack[Findex].fl_numread - (int)(Current_char - p);

    if (n != 0) {
        if (Fstack[Findex].fl_fFileType == DFT_FILE_IS_8_BIT) {
            n = WideCharToMultiByte(uiCodePage, 0, Current_char, n, NULL, 0, NULL, NULL);
            if (n == 0)
                return TRUE;
        } else
            n *= sizeof(WCHAR);

        fseek(Fp, -n, SEEK_CUR);
    }
    Fstack[Findex].fl_numread = 0;
    // io_eob will return true if we're at the end of the file.
    // this is an error for restart (it means there's nothing more
    // to do here (ie: #pragma codepage is the last line in the file).
    return !io_eob();
}


/************************************************************************
**  p0_init : inits for prepocessing.
**              Input : ptr to file name to use as input.
**                      ptr to LIST containing predefined values.
**                                       ( -D's from cmd line )
**
**  Note : if "newinput" cannot open the file,
**                it gives a fatal msg and exits.
**
************************************************************************/
void
p0_init(
    WCHAR *p_fname,
    WCHAR *p_outname,
    LIST *p_defns,
    LIST *p_undefns
    )
{
    REG WCHAR  *p_dstr;
    REG WCHAR  *p_eq;
    int         ntop;

    SETCHARMAP(LX_FORMALMARK, LX_MACFORMAL);
    SETCHARMAP(LX_FORMALSTR, LX_STRFORMAL);
    SETCHARMAP(LX_FORMALCHAR, LX_CHARFORMAL);
    SETCHARMAP(LX_NOEXPANDMARK, LX_NOEXPAND);
    if(EXTENSION) {
        /*
        **      '$' is an identifier character under extensions.
        */
        SETCHARMAP(L'$', LX_ID);
        SETCONTMAP(L'$', LXC_ID);
    }

    for(ntop = p_defns->li_top; ntop < MAXLIST; ++ntop) {
        p_dstr = p_defns->li_defns[ntop];
        p_eq = Reuse_W;
        while ((*p_eq = *p_dstr++) != 0)  {  /* copy the name to Reuse_W */
            if(*p_eq == L'=') {     /* we're told what the value is */
                break;
            }
            p_eq++;
        }
        if(*p_eq == L'=') {
            WCHAR      *p_tmp;
            WCHAR      *last_space = NULL;

            *p_eq = L'\0';               /* null the = */
            for(p_tmp = p_dstr; *p_tmp; p_tmp++) {      /* find the end of it */
                if(iswspace(*p_tmp)) {
                    if(last_space == NULL) {
                        last_space = p_tmp;
                    }
                } else {
                    last_space = NULL;
                }
            }
            if(last_space != NULL) {
                *last_space = L'\0';
            }
            Reuse_W_hash = local_c_hash(Reuse_W);
            Reuse_W_length = wcslen(Reuse_W) + 1;
            if( *p_dstr ) {     /* non-empty string */
                definstall(p_dstr, (wcslen(p_dstr) + 2), FROM_COMMAND);
            } else {
                definstall((WCHAR *)0, 0, 0);
            }
        } else {
            Reuse_W_hash = local_c_hash(Reuse_W);
            Reuse_W_length = wcslen(Reuse_W) + 1;
            definstall(L"1\000", 3, FROM_COMMAND);   /* value of string is 1 */
        }
    }

    /* undefine */
    for(ntop = p_undefns->li_top; ntop < MAXLIST; ++ntop) {
        p_dstr = p_undefns->li_defns[ntop];
        p_eq = Reuse_W;
        while ((*p_eq = *p_dstr++) != 0)  {  /* copy the name to Reuse_W */
            if(*p_eq == L'=') {     /* we're told what the value is */
                break;
            }
            p_eq++;
        }
        if(*p_eq == L'=') {
            WCHAR      *p_tmp;
            WCHAR      *last_space = NULL;

            *p_eq = L'\0';               /* null the = */
            for(p_tmp = p_dstr; *p_tmp; p_tmp++) {      /* find the end of it */
                if(iswspace(*p_tmp)) {
                    if(last_space == NULL) {
                        last_space = p_tmp;
                    }
                } else {
                    last_space = NULL;
                }
            }
            if(last_space != NULL) {
                *last_space = L'\0';
            }
            Reuse_W_hash = local_c_hash(Reuse_W);
            Reuse_W_length = wcslen(Reuse_W) + 1;
            if( *p_dstr ) {     /* non-empty string */
                undefine();
            } else {
                undefine();
            }
        } else {
            Reuse_W_hash = local_c_hash(Reuse_W);
            Reuse_W_length = wcslen(Reuse_W) + 1;
            undefine();   /* value of string is 1 */
        }
    }

    // Note: Always use the Ansi codepage here.  uiCodePage may have been
    // modified by a codepage pragma in the source file.

    WideCharToMultiByte (GetACP(), 0, p_outname, -1, chBuf, sizeof(chBuf), NULL, NULL);
    if ((OUTPUTFILE = fopen (chBuf, "w+b")) == NULL) {
        Msg_Temp = GET_MSG (1023);
        SET_MSG (Msg_Text, sizeof(Msg_Text), Msg_Temp, chBuf);
        fatal (1023);
    }

    newinput(p_fname,MUST_OPEN);
}

/************************************************************************
**  p0_terminate : terminates prepocessing.
**
**
************************************************************************/
void
p0_terminate(
    void
    )
{
    for ( ;fpop(); )
        ;
    if (OUTPUTFILE)
        fclose(OUTPUTFILE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\rcdll\p0macros.c ===
/************************************************************************/
/*                                                                      */
/* RCPP - Resource Compiler Pre-Processor for NT system                 */
/*                                                                      */
/* P0MACROS.C - Preprocessor Macros definitions                         */
/*                                                                      */
/* 27-Nov-90 w-BrianM  Update for NT from PM SDK RCPP                   */
/*                                                                      */
/************************************************************************/

#include "rc.h"


/************************************************************************
**
**      WARNING:        gather_chars() depends ELIMIT being the boundary of
**              Macro_buffer.
************************************************************************/
#define ACT_BUFFER              &Macro_buffer[0]
#define EXP_BUFFER              &Macro_buffer[BIG_BUFFER * 2]
#define EXP_PAD                 5
#define ALIMIT                  &Macro_buffer[BIG_BUFFER * 2]
#define ELIMIT                  (&Macro_buffer[BIG_BUFFER * 4] - EXP_PAD)


/************************************************************************
**  actual argument lists are length preceeded strings which are copied
**  into ACT_BUFFER. the first argument is pt'd to by exp_actuals in the
**  expansion_t construct. the next actual is obtained by adding the length
**  of the current actual to the start of the current actual.
************************************************************************/
#define ACTUAL_SIZE(P)  (*(short *)(P))
#define ACTUAL_TEXT(P)  ((ptext_t)(((char *)(P)) + sizeof(short)))
#define ACTUAL_NEXT(P)  ((ptext_t)(((char *)(P)) + ACTUAL_SIZE(P)))


expansion_t     Macro_expansion[LIMIT_MACRO_DEPTH];

ptext_t P_defn_start;
int             N_formals;
pdefn_t Defn_level_0[LEVEL_0 + 1];


/************************************************************************
**      These are needed by p0scanner (Exp_ptr,Tiny_lexer_nesting)
************************************************************************/
ptext_t Exp_ptr = EXP_BUFFER;           /* ptr to free exp space */
int             Tiny_lexer_nesting;     /* stay in tiny lexer or back to main */

static  ptext_t Act_ptr = ACT_BUFFER;           /* ptr to free actuals space */
static  ptext_t Save_Exp_ptr = EXP_BUFFER;      /* for buffering unbal parens */

static  ptext_t P_actuals;              /* actuals for this (level) macro */
static  int             N_actuals;      /* number of actuals in invocation */
static  int             Macro_line;     /*  where we started the macro  */


/************************************************************************/
/* Local Function Prototypes                                            */
/************************************************************************/
void    chkbuf(ptext_t);
ptext_t do_strformal(void);
ptext_t do_macformal(int *);
void    expand_actual(UCHAR);
void    expand_definition(void);
void    expand_macro(void);
void    fatal_in_macro(int);
ptext_t gather_chars(ptext_t, WCHAR);
void    get_actuals(pdefn_t, int);
int     get_definition(void);
void    get_formals(void);
int     is_macro_arg(ptext_t);
void    move_to_actual(ptext_t, ptext_t);
void    move_to_exp(ptext_t);
void    move_to_exp_esc(int, ptext_t);
int     post_paste(void);
void    push_macro(pdefn_t);
int     redefn (ptext_t, ptext_t, int);
int     rescan_expansion(void);


/************************************************************************
** UNDEFINE - remove a symbol from the symbol table
**      No noise is made if the programmer attempts to undefine a predefined
**              macro, but it is not done.
************************************************************************/
void
undefine(
    void
    )
{
    pdefn_t     pdef;
    pdefn_t     prev;

    prev = NULL;
    pdef = Defn_level_0[Reuse_W_hash & LEVEL_0];
    while(pdef) {
        if(memcmp (Reuse_W, DEFN_IDENT(pdef), Reuse_W_length * sizeof(WCHAR)) == 0) {
            if(PRE_DEFINED(pdef)) {
                Msg_Temp = GET_MSG (4117);
                SET_MSG (Msg_Text, sizeof(Msg_Text), Msg_Temp, Reuse_W, "#undef");
                warning(4117);
                break;
            }
            if(prev == NULL)    /*  match at head of list  */
                Defn_level_0[Reuse_W_hash & LEVEL_0] = DEFN_NEXT(pdef);
            else
                DEFN_NEXT(prev) = DEFN_NEXT(pdef);

            if (wcscmp(DEFN_NAME(pdef), afxSzHiddenSymbols) == 0)
                afxHiddenSymbols = FALSE;
            if (wcscmp(DEFN_NAME(pdef), afxSzReadOnlySymbols) == 0)
                afxReadOnlySymbols = FALSE;

            break;
        }
        prev = pdef;
        pdef = DEFN_NEXT(pdef);
    }
}


/************************************************************************
**  BEGIN DEFINE A MACRO {
************************************************************************/
void
define(
    void
    )
{
    WCHAR       c;

    if (! (LX_IS_IDENT(c = skip_cwhite())) ) {
        strcpy (Msg_Text, GET_MSG (2007));
        error (2007); /* #define syntax */
        skip_cnew();
        return;
    }
    getid(c);
    N_formals = 0;
    P_defn_start = Macro_buffer;
/*
**  the next character must be white space or an open paren
*/
first_switch:
    switch(CHARMAP(c = GETCH())) {
        case LX_OPAREN:                 /*  we have formal parameters  */
            get_formals();              /*  changes N_formals and fills Macro_buffer */
            if(N_formals == 0) {        /*  empty formal list  */
                /*
                **  we must special case this since the expand() reads in the
                **  actual arguments iff there are formal parameters. thus if we
                **      #define foo()   bar()
                **              . . .
                **              foo()
                **  will expand as
                **              bar()()
                **  we put the right paren in to fool the expander into looking
                **  for actuals.
                */
                N_formals = -1;
            }
            break;
        case LX_WHITE:
            break;
        case LX_CR:
            goto first_switch;
        case LX_SLASH:
            if( ! skip_comment()) {
                Msg_Temp = GET_MSG (2008);
                SET_MSG (Msg_Text, sizeof(Msg_Text), Msg_Temp, L'/');
                error (2008);
            }
            break;
        case LX_NL:                 /* no definition */
            UNGETCH();
            definstall((ptext_t)0, 0, 0);
            return;
            break;
        case LX_EOS:
            if(handle_eos() != BACKSLASH_EOS) {
                goto first_switch;
            }
            /* got BACKSLASH_EOS */
            /*
            **  FALLTHROUGH
            */
        default:
            Msg_Temp = GET_MSG (2008);
            SET_MSG (Msg_Text, sizeof(Msg_Text), Msg_Temp, c);
            error (2008); /* unexpected character in macro definition */
    }
    definstall(P_defn_start, get_definition(), N_formals);
}


/************************************************************************
**  get_formals : collect comma separated idents until the first closing paren
**  (the openning paren has already been read)
**  since we can't be in a macro when we're asked for this, we can be assured
**  that we can use a single buffer to collect all the formal names.
************************************************************************/
void
get_formals(
    void
    )
{
    WCHAR       c;
    ptext_t     p_stop;
    ptext_t     p_id;

    p_id = p_stop = ACTUAL_TEXT(P_defn_start);
    for(;;) {
        switch(CHARMAP(c = skip_cwhite())) {
            case LX_ID:
                if( p_id != p_stop ) {
                    Msg_Temp = GET_MSG (2010);
                    SET_MSG (Msg_Text, sizeof(Msg_Text), Msg_Temp, c);
                    error (2010);
                }
                *p_stop++ = c;
                for(;;) {
                    while(LXC_IS_IDENT(c = GETCH())) {      /* while an id char */
                        *p_stop++ = c;                      /* collect it */
                    } if(c == EOS_CHAR) {
                            /*
                            **  found end of buffer marker, make sure it is,
                            **  then handle it.
                            */
                        if(io_eob()) {      /* end of buffer in here is bad */
                            strcpy (Msg_Text, GET_MSG (1004));
                            fatal (1004);
                        }
                        continue;
                    }
                    if((c == L'\\') && (checknl())) {
                        continue;
                    }
                    UNGETCH();
                    break;
                }
                *p_stop++ = L'\0';
                break;
            case LX_COMMA:
            case LX_CPAREN:
                if( p_stop > p_id ) {
                    /* make sure an identifier was read */
                    if((p_stop - p_id) >= TINY_BUFFER) {
                        p_id[TINY_BUFFER - 1] = L'\0';
                        strcpy (Msg_Text, GET_MSG (4111));
                        warning(4011);              /* id truncated */
                        p_stop = p_id + TINY_BUFFER;
                    }
                    if(is_macro_arg(p_id) >= 1) {
                        Msg_Temp = GET_MSG (2009);
                        SET_MSG (Msg_Text, sizeof(Msg_Text), Msg_Temp, p_id);
                        error(2009);                /* reuse of formal */
                    } else {
                        ACTUAL_SIZE(P_defn_start) = (short)(p_stop - P_defn_start) * sizeof(WCHAR);
                        P_defn_start = p_stop;
                        N_formals++;
                    }
                } else {
                    if( (CHARMAP(c) == LX_COMMA) || (N_formals > 0) ) {
                        Msg_Temp = GET_MSG (2010);
                        SET_MSG (Msg_Text, sizeof(Msg_Text), Msg_Temp, c);
                        error(2010);
                    }
                }
                if( CHARMAP(c) == LX_CPAREN ) {
                    return;
                }
                p_id = p_stop = ACTUAL_TEXT(P_defn_start);
                break;
            default:
                Msg_Temp = GET_MSG (2010);
                SET_MSG (Msg_Text, sizeof(Msg_Text), Msg_Temp, c);
                error(2010); /*  unexpected char in formal list */
                break;
        }
    }
}


/************************************************************************
** definstall - Install a new definition. id is in Reuse_W.
**      p_text : ptr to the definition
**      n : number of bytes in the definition (may contain embedded nulls)
**      number : number of formals
************************************************************************/
void
definstall(
    WCHAR * p_text,
    int n,
    int number
    )
{
    pdefn_t     p;

    if(n == 0) {
        p_text = NULL;
    }
    if( wcscmp (Reuse_W, L"defined") == 0) {
        Msg_Temp = GET_MSG (4117);
        SET_MSG (Msg_Text, sizeof(Msg_Text), Msg_Temp, Reuse_W, "#define");
        warning(4117);/* name reserved */
        return;
    }
    if((p = get_defined()) != 0) {
        if(PRE_DEFINED(p)) {
            Msg_Temp = GET_MSG (4117);
            SET_MSG (Msg_Text, sizeof(Msg_Text), Msg_Temp, Reuse_W, "#define");
            warning(4117);/* name reserved */
            return;
        } else {
            if(redefn(p_text, DEFN_TEXT(p), n)) {
                Msg_Temp = GET_MSG (4005);
                SET_MSG (Msg_Text, sizeof(Msg_Text), Msg_Temp, Reuse_W);
                warning(4005);/* redefinition */
            } else {
                return;
            }
        }
    } else {
        hln_t   ident;

        HLN_NAME(ident) = Reuse_W;
        HLN_HASH(ident) = Reuse_W_hash;
        HLN_LENGTH(ident) = (UINT)Reuse_W_length;
        p = (pdefn_t) MyAlloc(sizeof(defn_t));
        if (p == NULL) {
            strcpy (Msg_Text, GET_MSG (1002));
            error(1002);
            return;
        }
        DEFN_IDENT(p) = HLN_TO_NAME(&ident);
        DEFN_NEXT(p) = Defn_level_0[Reuse_W_hash & LEVEL_0];
        DEFN_TEXT(p) = (WCHAR*)NULL;
        DEFN_EXPANDING(p) = 0;
        Defn_level_0[Reuse_W_hash & LEVEL_0] = p;
    }
    if(n != 0) {
        DEFN_TEXT(p) = pstrndup(p_text, n);
        if(number == FROM_COMMAND) {    /* special case from cmd line */
            *(DEFN_TEXT(p) + n - 1) = EOS_DEFINITION;   /* for handle_eos */
        }
    }
    DEFN_NFORMALS(p) = (char)((number != FROM_COMMAND) ? number : 0);

    if (fAFXSymbols && !PRE_DEFINED(p) && DEFN_NFORMALS(p) == 0)
        AfxOutputMacroDefn(p);
}


/************************************************************************
**  get_defined : is the given id in the macro symbol table?
**  return a ptr to it if so, NULL if not.
************************************************************************/
pdefn_t
get_defined(
    void
    )
{
    pdefn_t     pdef;

    for( pdef = Defn_level_0[Reuse_W_hash & LEVEL_0]; pdef;
        pdef = DEFN_NEXT(pdef))         {
        if(memcmp (Reuse_W, DEFN_IDENT(pdef), Reuse_W_length * sizeof(WCHAR)) == 0) {
            return(pdef);
        }
    }
    return(NULL);
}


/************************************************************************
**  redefn : are the two definitions the same?
************************************************************************/
int
redefn(
    REG  PWCHAR p_new,
    PWCHAR p_old,
    int n
    )
{
    if(p_old && p_new) {
        if(wcsncmp(p_new, p_old, n) == 0) {     /* strings are exact */
            return(FALSE);
        }
        return(TRUE);
    }
    return((p_old != NULL) || (p_new != NULL));
}


/************************************************************************
**  get_definition : accumulate the macro definition, stops when it finds
**  a newline (it uses it). returns a ptr to the end of the string it builds.
**  builds the string in Macro_buffer. (given the start in P_defn_start)
************************************************************************/
int
get_definition(
    void
    )
{
    REG ptext_t p;
    WCHAR       c;
    int         stringize = FALSE;
    int         charize = FALSE;

    p = P_defn_start;
    c = skip_cwhite();
    for(;;) {
        chkbuf(p);
        switch(CHARMAP(c)) {
            case LX_EOS:
                if(handle_eos() == BACKSLASH_EOS) {
                    /* got backslash EOS */
                    /* \<anything else> goes out as is.  The <anything else>
                     * character must be emitted now, so that
                     *               #define FOO(name)       \name
                     *               . . .
                     *               FOO(bar)
                     *
                     * does NOT see occurence of name in the definition as an
                     * occurence of the formal param and emit \bar when it is
                     * expanded later,but if the definition is \nname it will
                     * find name as a formal paramater and emit \nbar
                     */
                    *p++ = c;       /* put in backslash, break'll add new char */
                    c = get_non_eof();
                } else {
                    c = GETCH();
                    continue;
                }
                break;
            case LX_NL:             /*  only way out  */
                UNGETCH();
                if(p == P_defn_start) {
                    return(0);
                }
                chkbuf(p);
                *p++ = EOS_CHAR;
                *p++ = EOS_DEFINITION;      /* tells handle_eos defn finished */
                return((int)(p - P_defn_start));/* p's last incr counts the 0*/
                break;
            case LX_DQUOTE:
            case LX_SQUOTE:
                p = gather_chars(p, c);
                c = GETCH();
                continue;
                break;
            case LX_POUND:
split_op:
                switch(CHARMAP(GETCH())) {
                    case LX_POUND:
                        /*
                        **  handle ## processing. cant be the first or the last.
                        */
                        if(p == P_defn_start) {
                            strcpy (Msg_Text, GET_MSG (2160));
                            error(2160);        /* ## not allowed as first entry */
                            continue;
                        }
                        if(*(p - 1) == L' ') {   /* hose the last blank */
                            p--;
                        }
                        if(CHARMAP(c = skip_cwhite()) == LX_NL) {
                            UNGETCH();
                            strcpy (Msg_Text, GET_MSG(2161));
                            error(2161);
                            continue;
                        }
                        /* this case does *not* fall through to LX_ID */
                        continue;
                        break;
                    case LX_EACH:
                        charize = TRUE;
                        break;
                    case LX_EOS:
                        if( handle_eos() != BACKSLASH_EOS ) {
                            goto split_op;
                        }
                        /*
                        **      FALLTHROUGH
                        */
                    default:
                        UNGETCH();
                        stringize = TRUE;
                        break;
                }
                if(CHARMAP(c = skip_cwhite()) != LX_ID) {
                    strcpy (Msg_Text, GET_MSG(2162));
                    error(2162);    /* must have id following */
                    continue;
                }
                /*
                **  FALLTHROUGH
                */
            case LX_ID:
                {
                    /* we have the start of an identifier - check it to see if
                     * its an occurence of a formal parameter name.
                     * we gather the id ourselves (instead of getid()) since this
                     * wil save us from having to copy it to our string if it's
                     * not a formal parameter.
                     */
                    int                     n;
                    ptext_t p_macformal;

                    p_macformal = p;
                    do {
                        chkbuf(p);
                        *p++ = c;
get_more_id:
                        c = GETCH();
                    } while(LXC_IS_IDENT(c));
                    if(CHARMAP(c) == LX_EOS) {
                        if(handle_eos() != BACKSLASH_EOS) {
                            goto get_more_id;
                        }
                    }
                    *p = L'\0'; /* term. string, but do not advance ptr */
                    if((n = is_macro_arg(p_macformal)) >= 1) {
                        /*
                        **  this is an occurance of formal 'n', replace the id with
                        **  the special MAC character.
                        */
                        p = p_macformal;
                        if(stringize) {
                            *p++ = LX_FORMALSTR;
                        } else {
                            if(charize) {
                                *p++ = LX_FORMALCHAR;
                            } else {
                                *p++ = LX_FORMALMARK;
                            }
                        }
                        *p++ = (WCHAR) n;
                    } else if(charize || stringize) {
                        strcpy (Msg_Text, GET_MSG(2162));
                        error(2162);
                    }
                    stringize = FALSE;
                    charize = FALSE;
                    continue;       /* we broke out of the loop with a new char */
                }
            case LX_SLASH:
                if( ! skip_comment() ) {    /* really is a slash */
                    break;
                }
                /*
                **  FALLTHROUGH
                */
            case LX_CR:
            case LX_WHITE:
                /*
                **  this is white space, all contiguous whitespace is transformed
                **  to 1 blank. (hence the skip_cwhite() and the continue).
                */
                if(CHARMAP(c = skip_cwhite()) != LX_NL) {
                    *p++ = L' ';
                }
                continue;                           /* restart loop */
            case LX_ILL:
                Msg_Temp = GET_MSG (2018);
                SET_MSG (Msg_Text, sizeof(Msg_Text), Msg_Temp, c);
                error(2018);
                c = GETCH();
                continue;
        }
        *p++ = c;
        c = GETCH();
    }
}


/************************************************************************/
/* is_macro_arg ()                                                      */
/************************************************************************/
int
is_macro_arg(
    ptext_t name
    )
{
    REG int     i;
    REG ptext_t p;

    p = Macro_buffer;
    for(i = 1; i <= N_formals; i++) {
        if( wcscmp(name, ACTUAL_TEXT(p)) == 0) {
            return(i);
        }
        p = ACTUAL_NEXT(p);
    }
    return(-1);
}



/************************************************************************/
/* chkbuf ()                                                            */
/************************************************************************/
void
chkbuf(
    ptext_t p
    )
{
    if( p >= ELIMIT ) {
        Msg_Temp = GET_MSG (1011);
        SET_MSG (Msg_Text, sizeof(Msg_Text), Msg_Temp, Reuse_W);
        fatal (1011);
    }
}


/************************************************************************
**  gather_chars : collect chars until a matching one is found.
**  skip backslashed chars. moves the chars into the buffer,
**  returns a ptr past the last char copied.
************************************************************************/
ptext_t
gather_chars(
    REG ptext_t p,
    WCHAR match_c
    )
{
    WCHAR       c;

    *p++ = match_c;
    for(;;) {
        if(p > ELIMIT) {
            return(ELIMIT);
        }
        switch(CHARMAP(c = GETCH())) {
            case LX_NL:
                strcpy (Msg_Text, GET_MSG(2001));
                error(2001);
                UNGETCH();
                c = match_c;
                /*
                **  FALLTHROUGH
                */
            case LX_DQUOTE:
            case LX_SQUOTE:
                if(c == match_c) {
                    *p++ = c;
                    return(p);              /* only way out */
                }
                break;
            case LX_EOS:
                if(handle_eos() != BACKSLASH_EOS) {
                    continue;
                } else {
                    /* got backslash */
                    *p++ = L'\\';
                    c = get_non_eof();
                    if((c == '\\') && (checknl())) {
                        continue;
                    }
                }
                break;
        }
        *p++ = c;
    }
}
/************************************************************************
**  END DEFINING MACROS }
************************************************************************/

/************************************************************************
**  BEGIN EXPANDING MACROS {
************************************************************************/
/************************************************************************
**      can_expand:             tries to expand the macro passed to it - returns
**              true if it succeeded in expanding it.  It will only return FALSE
**              if a macro name was found, a paren was expected, and a paren was
**              not the next non white character.
************************************************************************/
int
can_expand(
    pdefn_t pdef
    )
{
    WCHAR   c;
    int     n_formals;
    int     return_value = FALSE;

    Tiny_lexer_nesting = 0;
    Save_Exp_ptr = Exp_ptr;             /* not necessarily EXP_BUFFER */
    Macro_line = Linenumber;
expand_name:

    P_actuals = Act_ptr;
    N_actuals = 0;

    n_formals = DEFN_NFORMALS(pdef);
    if( PRE_DEFINED(pdef) ) {
        push_macro(pdef);
        DEFN_EXPANDING(CURRENT_MACRO)++;
        if(rescan_expansion()) {
            return(TRUE);                       /* could expand macro */
        }
    }
    else if( n_formals == 0 ) {
        return_value = TRUE;
        if(DEFN_TEXT(pdef)) {
            push_macro(pdef);
            expand_definition();
        } else {
            /*
            **      Macro expands to nothing (no definition).  Since it
            **      didn't have any actuals, Act_ptr is already correct.
            **      Exp_ptr must be changed however to delete the
            **      identifier from the expanded text.
            */
            Exp_ptr = Save_Exp_ptr;
        }
    } else {
        if( n_formals == -1 ) {
            n_formals = 0;
        }
name_comment_paren:
        if( can_get_non_white()) {
            if(CHARMAP(CHECKCH()) == LX_SLASH) {
                SKIPCH();
                if(skip_comment()) {
                    goto name_comment_paren;
                } else {
                    UNGETCH();
                }
            }
            if(CHARMAP(CHECKCH())==LX_OPAREN) {
                SKIPCH();
                return_value = TRUE;
                get_actuals(pdef, n_formals);
            } else {
                /*
                **      #define xx(a) a
                **  xx bar();
                **  don't lose white space between "xx" and "bar"
                */
                ptext_t p = Exp_ptr;

                push_macro(pdef);
                DEFN_EXPANDING(CURRENT_MACRO)++;
                Exp_ptr = p;
                if( rescan_expansion() ) {
                    return(FALSE);
                }
            }
        } else {
        }
    }
    /*
    **      makes sure a macro is being worked on. At this point, there will
    **      be a macro to expand, unless the macro expand_the_named_macro was
    **      passed had no definition text.  If it had no defintion text,
    **      Tiny_lexer_nesting was not incremented.
    */
    while(Tiny_lexer_nesting != 0) {
        if(Exp_ptr >= ELIMIT) {
            fatal_in_macro(10056);
        }
        switch(CHARMAP(c = GETCH())) {
            case LX_ID:
            case LX_MACFORMAL:
                Save_Exp_ptr = Exp_ptr;
                if(tl_getid(c) && ((pdef = get_defined())!= 0)) {
                    if(DEFN_EXPANDING(pdef)) {
                        /*
                        **      the macro is already being expanded, so just
                        **      write the do not expand marker and the
                        **      identifier to the expand area.  The do not
                        **      expand marker is necessary so this macro
                        **      doesn't get expanded on the rescan
                        */
                        int         len = Reuse_W_length - 1;

                        *Exp_ptr++ = LX_NOEXPANDMARK;
                        *Exp_ptr++ = ((WCHAR)len);
                    } else {
                        /*
                        ** a legal identifier was read, it is defined, and
                        ** it is not currently being expanded.  This means
                        ** there is reason to believe it can be expanded.
                        */
                        goto expand_name;
                    }
                }
                if(InIf &&(memcmp(Reuse_W, L"defined", 8 * sizeof(WCHAR)) ==0)) {
                    do_defined(Reuse_W);
                }
                continue;
                break;
            case LX_NUMBER:
                /* getnum with Prep on to keep leading 0x on number */
                {
                    int     Save_prep = Prep;
                    Prep = TRUE;
                    getnum(c);
                    Prep = Save_prep;
                }
                continue;
                break;
            case LX_DOT:
                *Exp_ptr++ = L'.';
dot_switch:
                switch(CHARMAP(c = GETCH())) {
                    case LX_EOS:
                        if(handle_eos() != BACKSLASH_EOS) {
                            if(Tiny_lexer_nesting > 0) {
                                goto dot_switch;
                            }
                            continue;
                        }
                        break;
                    case LX_DOT:
                        *Exp_ptr++ = L'.';
                        if( ! checkop(L'.')) {
                            break;      /* error will be caught on rescan */
                        }
                        *Exp_ptr++ = L'.';
                        continue;
                        break;
                    case LX_NUMBER:
                        *Exp_ptr++ = c;
                        get_real(Exp_ptr);
                        continue;
                }
                UNGETCH();
                continue;
            case LX_CHARFORMAL:
                move_to_exp_esc(L'\'', do_strformal());
                continue;
                break;
            case LX_STRFORMAL:
                move_to_exp_esc(L'"', do_strformal());
                continue;
                break;
            case LX_DQUOTE:
            case LX_SQUOTE:
                /*
                **  gather_chars is called even though the error reported
                **  on overflow may need to be changed.
                */
                Exp_ptr = gather_chars(Exp_ptr, c);
                continue;
                break;
            case LX_WHITE:
                while(LXC_IS_WHITE(GETCH())) {
                    ;
                }
                UNGETCH();
                c = L' ';
                break;
            case LX_EOS:
                if(handle_eos() == BACKSLASH_EOS) {
                    *Exp_ptr++ = c;
                    c = GETCH();
                    break;
                }
                continue;
                break;
        }
        *Exp_ptr++ = c;
    }
    return(return_value);
}


/************************************************************************
**  get_actuals :  Paren must already be found.  If all the actuals can
**              be read, the macro is pushed and expansion begins. Otherwise,
**              this function is quickly exited and lets the tiny lexer take
**              care of rescanning.
************************************************************************/
void
get_actuals(
    pdefn_t pdef,
    int n_formals
    )
{
    /*
    **  The only concern with this is that a rescan could finish while
    **  this is trying to collect actuals.  When a rescan finishes, it
    **  may reset Act_ptr and Exp_ptr.  Unless these are saved before the
    **  end of rescan is handled, the part of the actual collected so far
    **  would be lost.
    */
    REG ptext_t start;
    WCHAR       c;
    ptext_t     actuals_start;
    int         paste;
    int         level;

    *Exp_ptr++ = PREVCH();                      /* must be oparen */
    level = 0;
    actuals_start = Act_ptr;

    while( level >= 0) {
        if(Exp_ptr >= ELIMIT) {
            fatal_in_macro(10056);
        }
more_white:
        if( ! can_get_non_white()) {
            return;
        }
        if(CHARMAP(CHECKCH()) == LX_SLASH) {
            SKIPCH();
            if(skip_comment()) {
                goto more_white;
            } else {
                start = Exp_ptr;
                *Exp_ptr++ = L'/';
            }
        } else {
            start = Exp_ptr;
        }
        paste = FALSE;

        for(;;) {
            switch(CHARMAP(c = GETCH())) {
                case LX_CPAREN:
                    if(--level < 0) {
                        goto leave_loop;
                    }
                    break;
                case LX_COMMA:
                    /*
                    **      if the comma is not at level == 0, it is part of
                    **      a parenthesized list and not a delimiter
                    */
                    if(level == 0) {
                        goto leave_loop;
                    }
                    break;
                case LX_SLASH:
                    if( ! skip_comment()) {
                        break;
                    }
                    if(*(Exp_ptr - 1) == L' ') {
                        continue;
                    }
                    c = L' ';
                    break;
                case LX_CR:
                case LX_NL:
                case LX_WHITE:
                    UNGETCH();              /* This char is valid white space */
                    if( ! can_get_non_white()) {
                        return;
                    }
                    continue;
                    break;
                case LX_OPAREN:
                    ++level;
                    break;
                case LX_DQUOTE:
                case LX_SQUOTE:
                    Exp_ptr = gather_chars(Exp_ptr, c);
                    continue;
                    break;
                case LX_ID:
                    *Exp_ptr++ = c;
                    while(LXC_IS_IDENT(c = GETCH())) {
                        if(Exp_ptr >= ELIMIT) {
                            fatal_in_macro(10056);
                        }
                        *Exp_ptr++ = c;
                    }
                    if(CHARMAP(c) != LX_MACFORMAL) {
                        UNGETCH();
                        continue;
                    }
                    paste = TRUE;
                    /*
                    **      FALLTHROUGH
                    */
                case LX_MACFORMAL:
                    move_to_exp(do_macformal(&paste));
                    continue;
                    break;
                case LX_STRFORMAL:
                    move_to_exp_esc(L'"', do_strformal());
                    continue;
                    break;
                case LX_CHARFORMAL:
                    move_to_exp_esc(L'\'', do_strformal());
                    continue;
                    break;
                case LX_EOS:
                    /*
                    **      Will saving this pointers create dead space in the
                    **      buffers?  Yes, but only temporarily.
                    **
                    **      handle_eos() may reset Act_ptr and Exp_ptr to the
                    **      beginning of the buffers if a rescan is finishing
                    **      and Macro_depth is going to be 0.  ANSI allows
                    **      actuals to start within a macro defintion and be
                    **      completed (further actuals and closing paren) later
                    **      in the text.
                    **
                    **      These buffer pointers will eventually be reset to
                    **      the beginnings of their respective buffers when the
                    **      macro for the actuals being collected right now
                    **      finish rescan
                    **
                    **      This is special handling for folks who use
                    **      unbalanced parens in macro definitions
                    */
                    {
                        ptext_t     Exp_save;
                        ptext_t     Act_save;
                        int eos_res;

                        Exp_save = Exp_ptr;
                        Act_save = Act_ptr;
                        if((eos_res = handle_eos()) & (ACTUAL_EOS | RESCAN_EOS)) {
                            return;
                        }
                        Act_ptr = Act_save;
                        Exp_ptr = Exp_save;
                        if(eos_res == BACKSLASH_EOS) {      /* ??? DFP QUESTION  */
                            *Exp_ptr++ = c;         /*  save the \  */
                            c = get_non_eof();      /*  get char following \  */
                            break;
                        }
                    }
                    continue;
                    break;
            }
            *Exp_ptr++ = c;
        }
leave_loop:
        /*
                **      if the last character was whitespace, hose it
                */
        if(CHARMAP(*(Exp_ptr - 1)) == LX_WHITE) {
            Exp_ptr--;
        }
        /*
        **      if Exp_ptr <= start, foo() was read, don't incr N_actuals
        */
        if(Exp_ptr > start) {
            N_actuals++;
            move_to_actual(start, Exp_ptr);
        }
        *Exp_ptr++ = c;
    }

    P_actuals = actuals_start;
    if(n_formals < N_actuals) {
        Msg_Temp = GET_MSG (4002);
        SET_MSG (Msg_Text, sizeof(Msg_Text), Msg_Temp, Reuse_W);
        warning(4002);
    }
    else if(n_formals > N_actuals) {
        Msg_Temp = GET_MSG (4003);
        SET_MSG (Msg_Text, sizeof(Msg_Text), Msg_Temp, Reuse_W);
        warning(4003);
    }

    if(DEFN_TEXT(pdef)) {
        push_macro(pdef);
        expand_macro();
    } else {
        /*
        **      the macro expands to nothing (no definition)
        **      This essentially means delete the macro and its actuals
        **      from the expanded text
        */
        Act_ptr = P_actuals;    /* reset pointer to get rid of actuals */
        Exp_ptr = Save_Exp_ptr; /* delete macro & actuals from exp text */
    }
}

/************************************************************************
**      rescan_expansion:       pops a level off of tiny lexer.  If this is the
**              original macro called, the rescan is set up, otherwise the MACRO
**              (not only the tiny lexer level) is popped.
************************************************************************/
int
rescan_expansion(
    void
    )
{
    if(--Tiny_lexer_nesting == 0) {
        if(Exp_ptr >= ELIMIT) {
            fatal_in_macro(10056);
        }
        if (fAFXSymbols && !InIf && (DEFN_NFORMALS(CURRENT_MACRO)==0))
            AfxOutputMacroUse(CURRENT_MACRO);

        *Exp_ptr++ = EOS_CHAR;
        *Exp_ptr++ = EOS_RESCAN;
        Current_char = CURRENT_TEXT;
        return(TRUE);                   /* rescan the expanded text */
    } else {
        /* reset Current_char, pop the macro */

        Current_char = CURRENT_STRING;
        Act_ptr = CURRENT_ACTUALS;      /* don't need its actuals */
        DEFN_EXPANDING(CURRENT_MACRO)--;
        --Macro_depth;
        return(FALSE);                  /* do not rescan expanded text */
    }
}


/************************************************************************
** move_to_actual:      moves the string located between start and finish
**              inclusive to the current location in ACT_BUFFER as a new actual.
************************************************************************/
void
move_to_actual(
    ptext_t start,
    ptext_t finish
    )
{
    REG ptext_t p;
    REG int     len;

    len = (int)(finish - start);
    if(Act_ptr + len >= ALIMIT - 2) {
        fatal_in_macro(10056);
    }
    wcsncpy(ACTUAL_TEXT(Act_ptr), start, len);
    p = ACTUAL_TEXT(Act_ptr);
    p += len;
    if ((((ULONG_PTR)p) & 1) == 0) {
        *p++ = EOS_CHAR;
        *p++ = EOS_ACTUAL;
    } else {
        *p++ = EOS_CHAR;
        *p++ = EOS_PAD;
        *p++ = EOS_ACTUAL;
    }
    ACTUAL_SIZE(Act_ptr) = (short)(p - Act_ptr) * sizeof(WCHAR);
    Act_ptr = p;
}


/************************************************************************
** move_to_exp_esc:     moves zero terminated string starting at source to
**      the current position in EXP_BUFFER, with quotes placed around the
**      string and interior backslashes and dquotes are escaped with a
**      backslash.  The terminating null should not be copied.  The null
**      does not come from the property of a string, but rather is the
**      marker used to indicate there is no more actual.
************************************************************************/
void
move_to_exp_esc(
    int quote_char,
    REG ptext_t source
    )
{
    int     mapped_c;
    int     mapped_quote;
    int     in_quoted = FALSE;

    if( ! source ) {
        return;
    }

    *Exp_ptr++ = (WCHAR)quote_char;
    for(;;) {
        if(Exp_ptr >= ELIMIT) {
            fatal_in_macro(10056);
        }
        switch(mapped_c = CHARMAP(*source)) {
            case LX_EOS:
                if(*source == EOS_CHAR) {
                    goto leave_move_stringize;
                }
                /* got BACKSLASH */
                /* but it can't be backslash-newline combination because
                                    ** we are reprocessing text already read in
                                    */
                if(in_quoted) {
                    *Exp_ptr++ = L'\\';
                }
                break;

            case LX_DQUOTE:
                if(CHARMAP((WCHAR)quote_char) == LX_DQUOTE) {
                    *Exp_ptr++ = L'\\';
                }
                /*
                **      FALLTHROUGH
                */
            case LX_SQUOTE:
                if(CHARMAP((WCHAR)quote_char) == LX_SQUOTE) {
                    break;
                }
                if(in_quoted ) {
                    if(mapped_c == mapped_quote) {
                        in_quoted = FALSE;
                    }
                } else {
                    in_quoted = TRUE;
                    mapped_quote = mapped_c;
                }
                break;
        }
        *Exp_ptr++ = *source++;
    }

leave_move_stringize:
    *Exp_ptr++ = (WCHAR)quote_char;
}


/************************************************************************
**      move_to_exp:    moves zero terminated string starting at source to
**              the current position in EXP_BUFFER.  The terminating null should
**              not be copied.
************************************************************************/
void
move_to_exp(
    REG ptext_t source
    )
{
    if( ! source ) {
        return;
    }

    while( *source ) {
        if(Exp_ptr >= ELIMIT) {
            fatal_in_macro(10056);
        }
        *Exp_ptr++ = *source++;
    }
}


/************************************************************************
** push_macro:                  pushes macro information onto the macro stack.
**      Information such as the current location in the Exp and Act buffers
**      will be used by whatever macros this one may call.
************************************************************************/
void
push_macro(
    pdefn_t pdef
    )
{
    /*
    **      note that increment leaves element 0 of the macro stack unused.
    **      this element can be reserved for links to dynamically allocated
    **      macro expansion stacks, if they become desirable
    */
    if(++Macro_depth >= LIMIT_MACRO_DEPTH) {
        Msg_Temp = GET_MSG (1009);
        SET_MSG (Msg_Text, sizeof(Msg_Text), Msg_Temp, Reuse_W);
        fatal (1009);
    }
    Tiny_lexer_nesting++;
    CURRENT_MACRO = pdef;
    CURRENT_ACTUALS = P_actuals;
    CURRENT_NACTUALS = (UCHAR)N_actuals;
    CURRENT_NACTSEXPANDED = 0;
    CURRENT_STRING = Current_char;
    CURRENT_TEXT = Exp_ptr = Save_Exp_ptr;
}


/************************************************************************
**expand_definition:            sets the input stream to start reading from
**              the macro definition.  Also marks the macro as in the process of
**              expanding so if it eventually invokes itself, it will not expand
**              the new occurence.
************************************************************************/
void
expand_definition(
    void
    )
{
    Current_char = DEFN_TEXT(CURRENT_MACRO);
    DEFN_EXPANDING(CURRENT_MACRO)++;
}


/************************************************************************
**expand_actual:        sets the input stream to start reading from
**              the actual specified in actual.
************************************************************************/
void
expand_actual(
    UCHAR actual
    )
{
    ptext_t     p;
    p = CURRENT_ACTUALS;
    while(--actual) {
        p = ACTUAL_NEXT(p);
    }
    Current_char = ACTUAL_TEXT(p);
}

/************************************************************************
**      expand_macro:           if there are still actuals for this macro to be
**              expanded, the next one is set up, otherwise this sets up to
**              expand the macro definition
************************************************************************/
void
expand_macro(
    void
    )
{
    if(CURRENT_NACTUALS > CURRENT_NACTSEXPANDED) {
        expand_actual(++CURRENT_NACTSEXPANDED);
    } else {
        expand_definition();
    }
}


/************************************************************************
**post_paste:           looks ahead one character to find out if a paste has
**      been requested immediately after this identifier.  If the next
**      character can continue an identifier, or is the macformal marker,
**      a paste should be done.  This is called after a macformal is found
**      to find out if the expanded or unexpanded actual should be used.
************************************************************************/
int
post_paste(
    void
    )
{
    WCHAR       c;

    if((CHARMAP(c = GETCH()) == LX_MACFORMAL) || (LXC_IS_IDENT(c))) {
        UNGETCH();
        return(TRUE);
    }
    UNGETCH();
    return(FALSE);
}

/************************************************************************
**do_macformal:         This function is called after a macformal marker is
**      found.  It reads the next character to find out which macformal is
**      wanted.  Then it checks to see if a paste is wanted, to find out
**      if the expanded or unexpanded actual should be used.  The return
**      value is a pointer to the text of the actual wanted, or NULL if the
**      actual asked for was not provided.
************************************************************************/
ptext_t
do_macformal(
    int *pre_paste
    )
{
    WCHAR       n;
    ptext_t     p;
    int temp_paste;

    p = CURRENT_ACTUALS;
    n = GETCH();
    if(n > CURRENT_NACTUALS) {
        return(NULL);           /* already output warning */
    }
    temp_paste = post_paste();
    if(( ! (*pre_paste)) && ( ! temp_paste) ) {
        /*
        **      if the programmer provided x actuals, actuals x+1 to 2x are
        **      those actuals expanded
        */
        n += CURRENT_NACTUALS;
    }
    *pre_paste = temp_paste;
    if (n != 0)
        while(--n) {
            p = ACTUAL_NEXT(p);
        }

    return(ACTUAL_TEXT(p));
}


/************************************************************************
**tl_getid:             This function reads an identifier for the tiny lexer
**      into EXP_BUFFER.  if macformal is found, the text of that actual
**      (expanded or not) is appended to the identifier.  It is possible
**      that this text will contain characters that are not legal
**      identifiers so return value is whether checking to see if the
**      "identifier" is defined is worth the bother.
************************************************************************/
int
tl_getid(
    WCHAR c
    )
{
    WCHAR  *p;
    int     paste;
    int     legal_identifier;
    int     length = 0;

    p = Exp_ptr;
    paste = FALSE;
    legal_identifier = TRUE;

do_handle_macformal:
    if(CHARMAP(c) == LX_MACFORMAL) {
        ptext_t p_buf;

        if((p_buf = do_macformal(&paste)) != 0) {
            while( *p_buf ) {
                if( ! LXC_IS_IDENT(*p_buf)) {
                    legal_identifier = FALSE;
                }
                if(Exp_ptr >= ELIMIT) {
                    fatal_in_macro(10056);
                }
                *Exp_ptr++ = *p_buf++;
            }
        }
    } else {
        *Exp_ptr++ = c;
    }

do_handle_eos:
    while(LXC_IS_IDENT(c = GETCH())) {
        if(Exp_ptr >= ELIMIT) {
            fatal_in_macro(10056);
        }
        *Exp_ptr++ = c;
    }

    if(CHARMAP(c) == LX_NOEXPAND) {
        length = (int)GETCH();                  /* just skip length */
        goto do_handle_eos;
    }

    if(CHARMAP(c) == LX_MACFORMAL) {
        paste = TRUE;
        goto do_handle_macformal;
    }

    UNGETCH();
    if(legal_identifier && (length == (Exp_ptr - p))) {
        legal_identifier = FALSE;
    }

    if(legal_identifier) {
        if(((Exp_ptr - p) > LIMIT_ID_LENGTH) && ( ! Prep)) {
            Exp_ptr = &p[LIMIT_ID_LENGTH];
            *Exp_ptr = L'\0';    /* terminates identifier for warning */
            Msg_Temp = GET_MSG (4011);
            SET_MSG (Msg_Text, sizeof(Msg_Text), Msg_Temp, p);
            warning(4011);              /* id truncated */
        } else {
            *Exp_ptr = L'\0';    /* terminates identifier for expandable check */
        }
        /*
        **      Whether or not we are doing Prep output, we still have to make
        **      sure the identifier will fit in Reuse_W
        */
        if((Exp_ptr - p) > (sizeof(Reuse_W) / sizeof(WCHAR))) {
            Exp_ptr = &p[LIMIT_ID_LENGTH];
            *Exp_ptr = L'\0';
            Msg_Temp = GET_MSG (4011);
            SET_MSG (Msg_Text, sizeof(Msg_Text), Msg_Temp, p);
            warning(4011);
        }
        /*
        **      copy into Reuse_W for warnings about mismatched number of
        **      formals/actuals, and in case it's not expandable
        */
        memcpy(Reuse_W, p, (int)((Exp_ptr - p) + 1) * sizeof(WCHAR));
        Reuse_W_hash = local_c_hash(Reuse_W);
        /*
        **      the characters from Exp_ptr to p inclusive do not include the
        **      the hash character, the length character, and the terminating
        **      null.
        */
        Reuse_W_length = (UINT)((Exp_ptr - p) + 1);
    }
    return(legal_identifier);
}


/************************************************************************
**  do_strformal:   returns pointer to the actual requested without
**          checking for paste (a legal token is not possible, so if a paste
**          is being done on a strformal, the behavior is undefined
************************************************************************/
ptext_t
do_strformal(
    void
    )
{
    WCHAR   n;
    ptext_t p;

    /* use unexpanded actual */
    p = CURRENT_ACTUALS;
    n = GETCH();
    if(n > CURRENT_NACTUALS) {
        return(NULL);           /* already output warning */
    }
    if (n != 0)
        while(--n) {
            p = ACTUAL_NEXT(p);
        }
    return(ACTUAL_TEXT(p));
}


/************************************************************************
**  can_get_non_white:      tries to get the next non white character
**          using P1 rules for white space (NL included).  If the end of
**          an actual, or a rescan is found, this returns FALSE, so control
**          can drop into one of the lexers.
************************************************************************/
int
can_get_non_white(
    void
    )
{
    int return_value = FALSE;
    int white_found = FALSE;

    for(;;) {
        switch(CHARMAP(GETCH())) {
            case LX_NL:
                if(On_pound_line) {
                    UNGETCH();
                    goto leave_cgnw;
                }
                Linenumber++;
                /*
                **      FALLTHROUGH
                */
            case LX_WHITE:
            case LX_CR:
                white_found = TRUE;
                break;
            case LX_EOS:
                {
                    int     eos_res;
                    if((eos_res = handle_eos()) & (ACTUAL_EOS | RESCAN_EOS)) {
                        goto leave_cgnw;
                    }
                    if(eos_res != BACKSLASH_EOS) {
                        break;
                    }
                }
                /*
                **      FALLTHROUGH
                */
            default:
                UNGETCH();
                return_value = TRUE;
                goto leave_cgnw;
                break;
        }
    }
leave_cgnw:
    if(white_found) {
        if(Exp_ptr >= ELIMIT) {
            fatal_in_macro(10056);
        }
        if(*(Exp_ptr - 1) != L' ') {
            *Exp_ptr++ = L' ';
        }
    }
    return(return_value);               /* could you get next non white? */
}


/************************************************************************/
/* fatal_in_macro ()                                                    */
/************************************************************************/
void
fatal_in_macro(
    int e
    )
{
    Linenumber = Macro_line;
    strcpy (Msg_Text, GET_MSG(e));
    fatal (e);
}


/************************************************************************
**  handle_eos : handle the end of a string.
************************************************************************/
int
handle_eos(
    void
    )
{
    if(PREVCH() == L'\\') {
        if(checknl()) {
            return(FILE_EOS);
        } else {
            return(BACKSLASH_EOS);
        }
    }
    if(Macro_depth == 0) {      /* found end of file buffer or backslash */
        if(io_eob()) {          /* end of buffer in here is bad */
            strcpy (Msg_Text, GET_MSG(1004));
            fatal (1004);
        }
        return(FILE_EOS);
    }

again:
    switch(GETCH()) {
        case EOS_PAD:
            goto again;
        case EOS_ACTUAL:
            /*
            ** Just finished expanding actual.  Check to see if there are
            ** any more actuals to be expanded.  If there are, set up to
            ** expand them and return.  Otherwise, set up to expand defn
            */

            /* move expanded text of this actual to act_buffer */
            move_to_actual(CURRENT_TEXT, Exp_ptr);

            /* reset Exp_ptr for more expansions at this macro depth */
            Exp_ptr = CURRENT_TEXT;

            /* expand next actual if there, otherwise expand definition */
            expand_macro();

            return(ACTUAL_EOS);
            break;
        case EOS_DEFINITION:
            if(rescan_expansion()) {
                return(RESCAN_EOS);
            } else {
                return(DEFINITION_EOS);
            }
            break;
        case EOS_RESCAN:
            /*
            ** Reset Current_char, Exp_ptr and Act_ptr, pop the macro
            */

            /*      get input from the previous stream */
            Current_char = CURRENT_STRING;

            /* mark this macro as not expanding */
            DEFN_EXPANDING(CURRENT_MACRO)--;


            /*
            **      if looking for the actuals of a macro, these pointers
            **      should really not be reset, however, it is cleaner to
            **      save them before calling handle_eos, and restore them
            **      upon returning, than check a static variable here.
            */
            if(Macro_depth == 1) {
                Act_ptr = ACT_BUFFER;
                Exp_ptr = EXP_BUFFER;
            }
            --Macro_depth;
            return(DEFINITION_EOS);
            break;
            /* the following conditional compile is so brackets match */

        default:
            return(FILE_EOS);
    }
}
/************************************************************************
**      END EXPANDING MACRO }
************************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\rcdll\p0prepro.c ===
/************************************************************************/
/*                                                                      */
/* RCPP - Resource Compiler Pre-Processor for NT system                 */
/*                                                                      */
/* P0PREPRO.C - Main Preprocessor                                       */
/*                                                                      */
/* 27-Nov-90 w-BrianM  Update for NT from PM SDK RCPP                   */
/*                                                                      */
/************************************************************************/

#include "rc.h"
#include <ddeml.h>

/************************************************************************/
/* Internal constants                                                   */
/************************************************************************/
#define GOT_IF                  1       /* last nesting command was an if.. */
#define GOT_ELIF                2       /* last nesting command was an if.. */
#define GOT_ELSE                3       /* last nesting command was an else */
#define GOT_ENDIF               4       /* found endif */
#define ELSE_OR_ENDIF           5       /* skip to either #else or #endif */
#define ENDIF_ONLY              6       /* skip to #endif -- #else is an error*/

int     ifstack[IFSTACK_SIZE];


/************************************************************************/
/* Local Function Prototypes                                            */
/************************************************************************/
void chk_newline(PWCHAR);
void in_standard(void);
int incr_ifstack(void);
token_t next_control(void);
unsigned long int pragma(void);
int skipto(int);
void skip_quoted(int);
PWCHAR sysinclude(void);


/************************************************************************/
/* incr_ifstack - Increment the IF nesting stack                        */
/************************************************************************/

int
incr_ifstack(
    void
    )
{
    if(++Prep_ifstack >= IFSTACK_SIZE) {
        strcpy (Msg_Text, GET_MSG (1052));
        fatal (1052);
    }
    return(Prep_ifstack);
}


/************************************************************************
 * SYSINCLUDE - process a system include : #include <foo>
 *
 * ARGUMENTS - none
 *
 * RETURNS - none
 *
 * SIDE EFFECTS - none
 *
 * DESCRIPTION
 *      Get the system include file name.  Since the name is not a "string",
 *      the name must be built much the same as the -E option rebuilds the text
 *      by using the Tokstring expansion for tokens with no expansion already
 *
 *  NOTE : IS THIS ANSI? note we're just reading chars, and not expanding
 * any macros. NO, it's not. it must expand the macros.
 * TODO : have it call yylex() unless and until it finds a '>' or a newline.
 * (probably have to set On_pound_line to have yylex return the newline.)
 *
 * AUTHOR
 *                      Ralph Ryan      Sep. 1982
 *
 * MODIFICATIONS - none
 *
 *
 ************************************************************************/
PWCHAR
sysinclude(
    void
    )
{
    REG int     c;
    REG WCHAR  *p_fname;

    p_fname = Reuse_W;
    c = skip_cwhite();
    if( c == L'\n' ) {
        UNGETCH();
        strcpy (Msg_Text, GET_MSG (2012));
        error(2012);    /* missing name after '<' */
        return(NULL);
    }
    while( c != L'>' && c != L'\n' ) {
        *p_fname++ = (WCHAR)c;          /* check for buffer overflow ??? */
        c = get_non_eof();
    }
    if( c == L'\n' ) {
        UNGETCH();
        strcpy (Msg_Text, GET_MSG (2013));
        error(2013);    /* missing '>' */
        return(NULL);
    }
    if(p_fname != Reuse_W) {
        p_fname--;
        while((p_fname >= Reuse_W) && iswspace(*p_fname)) {
            p_fname--;
        }
        p_fname++;
    }
    *p_fname = L'\0';
    return(Reuse_W);
}


/************************************************************************
**  preprocess : the scanner found a # which was the first non-white char
**  on a line.
************************************************************************/
void
preprocess(
    void
    )
{
    REG WCHAR   c;
    long        eval;
    int         condition;
    token_t     deftok;
    hln_t       identifier;
    unsigned long int   cp;

    if(Macro_depth != 0) {      /* # only when not in a macro */
        return;
    }
    switch(CHARMAP(c = skip_cwhite())) {
        case LX_ID:
            getid(c);
            HLN_NAME(identifier) = Reuse_W;
            HLN_LENGTH(identifier) = (UINT)Reuse_W_length;
            HLN_HASH(identifier) = Reuse_W_hash;
            break;
        case LX_NL:
            UNGETCH();
            return;
        default:
            Msg_Temp = GET_MSG (2019);
            SET_MSG (Msg_Text, sizeof(Msg_Text), Msg_Temp, c);
            error(2019);    /* unknown preprocessor command */
            skip_cnew();    /* finds a newline */
            return;
    }

    On_pound_line = TRUE;
start:
    switch(deftok = is_pkeyword(HLN_IDENTP_NAME(&identifier))) {
        int                     old_prep;

        case P0_DEFINE :
            define();
            break;
        case P0_LINE :
            old_prep = Prep;
            Prep = FALSE;
            yylex();
            if(Basic_token != L_CINTEGER) {         /* #line needs line number */
                Msg_Temp = GET_MSG (2005);
                SET_MSG (Msg_Text, sizeof(Msg_Text), Msg_Temp, TS_STR(Basic_token));
                error(2005);        /* unknown preprocessor command */
                Prep = old_prep;
                skip_cnew();
                On_pound_line = FALSE;
                return;
            }
            /*
            **  -1 because there's a newline at the end of this line
            **  which will be counted later when we find it.
            **  the #line says the next line is the number we've given
            */
            Linenumber = TR_LVALUE(yylval.yy_tree) - 1;
            yylex();
            Prep = old_prep;
            switch(Basic_token) {
                case L_STRING:
                    if( wcscmp(Filename, yylval.yy_string.str_ptr) != 0) {
                        wcsncpy(Filename,
                            yylval.yy_string.str_ptr,
                            sizeof(Filebuff) / sizeof(WCHAR)
                            );
                    }
                case L_NOTOKEN:
                    break;
                default:
                    Msg_Temp = GET_MSG (2130);
                    SET_MSG (Msg_Text, sizeof(Msg_Text), Msg_Temp, TS_STR(Basic_token));
                    error(2130);         /* #line needs a string */
                    skip_cnew();
                    On_pound_line = FALSE;
                    return;
                    break;
            }
            emit_line();
            chk_newline(L"#line");
            break;
        case P0_INCLUDE :
            old_prep = Prep;
            Prep = FALSE;
            InInclude = TRUE;
            yylex();
            InInclude = FALSE;
            Prep = old_prep;
            switch(Basic_token) {
                case L_LT:
                    if((sysinclude()) == NULL) {
                        skip_cnew();
                        On_pound_line = FALSE;
                        return;
                        break;          /* error already emitted */
                    }
                    yylval.yy_string.str_ptr = Reuse_W;
                    break;
                case L_STRING:
                    break;
                default:
                    Msg_Temp = GET_MSG (2006);
                    SET_MSG (Msg_Text, sizeof(Msg_Text), Msg_Temp, TS_STR(Basic_token));
                    error(2006);        /* needs file name */
                    skip_cnew();
                    On_pound_line = FALSE;
                    return;
                    break;
            }
            wcscpy(Reuse_Include, yylval.yy_string.str_ptr);
            chk_newline(L"#include");
            if( wcschr(Path_chars, *yylval.yy_string.str_ptr) ||
                (wcschr(Path_chars, L':') && (yylval.yy_string.str_ptr[1] == L':'))) {
                /*
                **  we have a string which either has a 1st char which is a path
                **  delimiter or, if ':' is a path delimiter (DOS), which has
                **  "<drive letter>:" as the first two characters.  Such names
                **  specify a fully qualified pathnames. Do not append the search
                **  list, just look it up.
                */
                if( ! newinput(yylval.yy_string.str_ptr, MAY_OPEN)) {
                    Msg_Temp = GET_MSG (1015);
                    SET_MSG (Msg_Text, sizeof(Msg_Text), Msg_Temp, Reuse_W);
                    fatal (1015); /* can't find include file */
                }
            }
            else if( (Basic_token != L_STRING) || (! nested_include())) {
                in_standard();
            }
            break;
        case P0_IFDEF :
        case P0_IFNDEF :
            if(CHARMAP(c = skip_cwhite()) != LX_ID) {
                strcpy (Msg_Text, GET_MSG (1016));
                fatal (1016);
            }
            getid(c);
            eval = (get_defined()) ? TRUE : FALSE;
            chk_newline((deftok == P0_IFDEF) ? L"#ifdef" : L"#ifndef");
            if(deftok == P0_IFNDEF) {
                eval = ( ! eval );
            }
            if( eval || ((condition = skipto(ELSE_OR_ENDIF)) == GOT_ELSE) ) {
                /*
                **  expression is TRUE or when we skipped the false part
                **  we found a #else that will be expanded.
                */
                ifstack[incr_ifstack()] = GOT_IF;
            } else if(condition == GOT_ELIF) {
                /* hash is wrong, but it won't be used */
                HLN_NAME(identifier) = L"if";                /* sleazy HACK */
                goto start;
            }
            break;
        case P0_IF :
            old_prep = Prep;
            Prep = FALSE;
            InIf = TRUE;
            eval = do_constexpr();
            InIf = FALSE;
            Prep = old_prep;
            chk_newline(PPifel_str /* "#if/#elif" */);
            if((eval) || ((condition = skipto(ELSE_OR_ENDIF)) == GOT_ELSE) ) {
                /*
                **  expression is TRUE or when we skipped the false part
                **  we found a #else that will be expanded.
                */
                ifstack[incr_ifstack()] = GOT_IF;
                if(Eflag && !eval)
                    emit_line();
            } else {
                /*
                **  here the #if's expression was false, so we skipped until we found
                **  an #elif. we'll restart and fake that we're processing a #if
                */
                if(Eflag)
                    emit_line();
                if(condition == GOT_ELIF) {
                    /* hash is wrong, but it won't be needed */
                    HLN_NAME(identifier) = L"if";            /* sleazy HACK */
                    goto start;
                }
            }
            break;
        case P0_ELIF :
            /*
            **  here, we have found a #elif. first check to make sure that
            **  this is not an occurrance of a #elif with no preceding #if.
            **  (if Prep_ifstack < 0) then there is no preceding #if.
            */
            if(Prep_ifstack-- < 0) {
                strcpy (Msg_Text, GET_MSG (1018));
                fatal (1018);
            }
            /*
            **  now, the preceding #if/#elif was true, and we've
            **  just found the next #elif. we want to skip all #else's
            **  and #elif's from here until we find the enclosing #endif
            */
            while(skipto(ELSE_OR_ENDIF) != GOT_ENDIF) {
                ;
            }
            if(Eflag)
                emit_line();
            break;
        case P0_ELSE :      /*  the preceding #if/#elif was true  */
            if((Prep_ifstack < 0) || (ifstack[Prep_ifstack--] != GOT_IF)) {
                strcpy (Msg_Text, GET_MSG (1019));
                fatal (1019); /*  make sure there was one  */
            }
            chk_newline(PPelse_str /* "#else" */);
            skipto(ENDIF_ONLY);
            if(Eflag)
                emit_line();
            break;
        case P0_ENDIF :     /*  only way here is a lonely #endif  */
            if(Prep_ifstack-- < 0) {
                strcpy (Msg_Text, GET_MSG (1020));
                fatal (1020);
            }
            if(Eflag)
                emit_line();
            chk_newline(PPendif_str /* "#endif" */);
            break;
        case P0_PRAGMA :
            cp = pragma();
            if (cp != 0) {
                if (cp == CP_WINUNICODE) {
                    strcpy (Msg_Text, GET_MSG (4213));
                    if (fWarnInvalidCodePage) {
                        warning(4213);
                    } else {
                        fatal(4213);
                    }
                    break;
                }
                if (!IsValidCodePage(cp)) {
                    strcpy (Msg_Text, GET_MSG (4214));
                    if (fWarnInvalidCodePage) {
                        warning(4214);
                    } else {
                        fatal(4214);
                    }
                    break;
                }
                if (cp != uiCodePage) {
                    if (!io_restart(cp)) {
                        strcpy (Msg_Text, GET_MSG (1121));
                        fatal(1121);
                    }
                    uiCodePage = cp;    // can't be set until now!
                }
            }
            break;
        case P0_UNDEF :
            if(CHARMAP(c = skip_cwhite()) != LX_ID) {
                strcpy (Msg_Text, GET_MSG (4006));
                warning(4006);      /* missing identifier on #undef */
            } else {
                getid(c);
                undefine();
            }
            chk_newline(L"#undef");
            break;
        case P0_ERROR:
            {
                PWCHAR      p;

                p = Reuse_W;
                while((c = get_non_eof()) != LX_EOS) {
                    if(c == L'\n') {
                        UNGETCH();
                        break;
                    }
                    *p++ = c;
                }
                *p = L'\0';
            }
            Msg_Temp = GET_MSG (2189);
            SET_MSG (Msg_Text, sizeof(Msg_Text), Msg_Temp, Reuse_W);
            error(2188);
            chk_newline(L"#error");
            break;
        case P0_IDENT:
            old_prep = Prep ;
            Prep = FALSE;
            yylex();
            Prep = old_prep;
            if(Basic_token != L_STRING) {
                Msg_Temp = GET_MSG (4079);
                SET_MSG (Msg_Text, sizeof(Msg_Text), Msg_Temp, TS_STR(Basic_token));
                warning(4079);
            }
            chk_newline(L"#error");
            break;
        case P0_NOTOKEN:
            Msg_Temp = GET_MSG (1021);
            SET_MSG (Msg_Text, sizeof(Msg_Text), Msg_Temp, HLN_IDENTP_NAME(&identifier));
            fatal (1021);
            break;
    }
    On_pound_line = FALSE;
}


/************************************************************************
 * SKIPTO - skip code until the end of an undefined block is reached.
 *
 * ARGUMENTS
 *      short key - skip to an ELSE or ENDIF or just an ENDIF
 *
 * RETURNS  - none
 *
 * SIDE EFFECTS
 *      - throws away input
 *
 * DESCRIPTION
 *      The preprocessor is skipping code between failed ifdef, etc. and
 *      the corresponding ELSE or ENDIF (when key == ELSE_OR_ENDIF).
 *      Or it is skipping code between a failed ELSE and the ENDIF (when
 *      key == ENDIF_ONLY).
 *
 * AUTHOR - Ralph Ryan, Sept. 16, 1982
 *
 * MODIFICATIONS - none
 *
 ************************************************************************/
int
skipto(
    int key
    )
{
    REG int             level;
    REG token_t tok;

    level = 0;
    tok = P0_NOTOKEN;
    for(;;) {
        /* make sure that IF [ELSE] ENDIF s are balanced */
        switch(next_control()) {
            case P0_IFDEF:
            case P0_IFNDEF:
            case P0_IF:
                level++;
                break;
            case P0_ELSE:
                tok = P0_ELSE;
                /*
                            **  FALLTHROUGH
                            */
            case P0_ELIF:
                /*
                **  we found a #else or a #elif. these have their only chance
                **  at being valid if they're at level 0.
                **  if we're at any other level,
                **  then this else/elif belongs to some other #if and we skip them.
                **  if we were looking for an endif, the we have an error.
                */
                if(level != 0) {
                    tok = P0_NOTOKEN;
                    break;
                }
                if(key == ENDIF_ONLY) {
                    strcpy (Msg_Text, GET_MSG (1022));
                    fatal (1022);   /* expected #endif */
                } else if(tok == P0_ELSE) {
                    chk_newline(PPelse_str /* "#else" */);
                    return(GOT_ELSE);
                } else {
                    return(GOT_ELIF);
                }
                break;
            case P0_ENDIF:
                if(level == 0) {
                    chk_newline(PPendif_str /* "#endif" */);
                    return(GOT_ENDIF);
                } else {
                    level--;
                }
                break;
        }
    }
}


/*************************************************************************
**  in_standard : search for the given file name in the directory list.
**              Input : ptr to include file name.
**              Output : fatal error if not found.
*************************************************************************/
void
in_standard(
    void
    )
{
    int     i;
    int     stop;
    WCHAR   *p_dir;
    WCHAR   *p_file;
    WCHAR   *p_tmp;

    stop = Includes.li_top;

    for(i = MAXLIST-1; i >= stop; i--) {
        p_file = yylval.yy_string.str_ptr;
        if( ((p_dir = Includes.li_defns[i])!=0) &&(wcscmp(p_dir, L"./") != 0) ) {
            /*
            **  there is a directory to prepend and it's not './'
            */
            p_tmp = Exp_ptr;
            while((*p_tmp++ = *p_dir++) != 0)
                ;
            /*
            **  above loop increments p_tmp past null.
            **  this replaces that null with a '/' if needed.  Not needed if the
            **  last character of the directory spec is a path delimiter.
            **  we then point to the char after the '/'
            */
            if(wcschr(Path_chars, p_dir[-2]) == 0) {
                p_tmp[-1] = L'/';
            } else {
                --p_tmp;
            }
            while((*p_tmp++ = *p_file++) != 0)
                ;
            p_file = Exp_ptr;
        }
        if(newinput(p_file,MAY_OPEN)) { /* this is the non-error way out */
            return;
        }
    }
    Msg_Temp = GET_MSG (1015);
    SET_MSG (Msg_Text, sizeof(Msg_Text), Msg_Temp, yylval.yy_string.str_ptr);
    fatal (1015);       /* can't find include file */
}


/*************************************************************************
**  chk_newline : check for whitespace only before a newline.
**  eat the newline.
*************************************************************************/
void
chk_newline(
    PWCHAR cmd
    )
{
    if(skip_cwhite() != L'\n') {
        Msg_Temp = GET_MSG (4067);
        SET_MSG (Msg_Text, sizeof(Msg_Text), Msg_Temp, cmd);
        warning(4067);          /* cmd expected newline */
        skip_cnew();
    } else {
        UNGETCH();
    }
}

/*************************************************************************
**  skip_quoted : skips chars until it finds a char which matches its arg.
*************************************************************************/
void
skip_quoted(
    int sc
    )
{
    REG WCHAR   c;

    for(;;) {
        switch(CHARMAP(c = GETCH())) {
            case LX_NL:
                strcpy (Msg_Text, GET_MSG (4093));
                warning(4093);
                UNGETCH();
                return;
                break;
            case LX_DQUOTE:
            case LX_SQUOTE:
                if(c == (WCHAR)sc)
                    return;
                break;
            case LX_EOS:
                if(handle_eos() == BACKSLASH_EOS) {
                    SKIPCH();       /* might be /" !! */
                }
                break;
            case LX_LEADBYTE:
                get_non_eof();
                break;
        }
    }
}


/*************************************************************************
**  next_control : find a newline. find a pound sign as the first non-white.
**  find an id start char, build an id look it up and return the token.
**  this knows about strings/char const and such.
*************************************************************************/
token_t
next_control(
    void
    )
{
    REG WCHAR   c;

    for(;;) {
        c = skip_cwhite();
first_switch:
        switch(CHARMAP(c)) {
            case LX_NL:
                Linenumber++;
                // must manually write '\r' with '\n' when writing 16-bit strings
                if(Prep) {
                    myfwrite(L"\r\n", 2 * sizeof(WCHAR), 1, OUTPUTFILE);
                }
                if((c = skip_cwhite()) == L'#') {
                    if(LX_IS_IDENT(c = skip_cwhite())) {
                        /*
                        **  this is the only way to return to the caller.
                        */
                        getid(c);
                        return(is_pkeyword(Reuse_W));       /* if its predefined  */
                    }
                }
                goto first_switch;
                break;
            case LX_DQUOTE:
            case LX_SQUOTE:
                skip_quoted(c);
                break;
            case LX_EOS:
                if(handle_eos() == BACKSLASH_EOS) {
                    SKIPCH();       /* might be \" !! */
                }
                break;
        }
    }
}


/*************************************************************************
**  do_defined : does the work for the defined(id)
**              should parens be counted, or just be used as delimiters (ie the
**              first open paren matches the first close paren)? If this is ever
**              an issue, it really means that there is not a legal identifier
**              between the parens, causing an error anyway, but consider:
**              #if (defined(2*(x-1))) || 1
**              #endif
**              It is friendlier to allow compilation to continue
*************************************************************************/
int
do_defined(
    PWCHAR p_tmp
    )
{
    REG UINT    c;
    REG int     value=0;
    int         paren_level = 0;

    /*
    ** we want to allow:
    **      #define FOO             defined
    **      #define BAR(a,b)        a FOO | b
    **      #define SNAFOO          0
    **      #if FOO BAR
    **      print("BAR is defined");
    **      #endif
    **      #if BAR(defined, SNAFOO)
    **      print("FOO is defined");
    **      #endif
    */
    if(wcscmp(p_tmp,L"defined") != 0) {
        return(0);
    }
    if((!can_get_non_white()) && (Tiny_lexer_nesting == 0)) {
        /* NL encountered */
        return(value);
    }
    if((c = CHECKCH())== L'(') { /* assumes no other CHARMAP form of OPAREN */
        *Exp_ptr++ = (WCHAR)c;
        SKIPCH();
        paren_level++;
        if((!can_get_non_white()) && (Tiny_lexer_nesting == 0)) {
            /* NL encountered */
            return(value);
        }
    }
    if(Tiny_lexer_nesting>0) {
        if((CHARMAP((WCHAR)(c=CHECKCH()))==LX_MACFORMAL) || (CHARMAP((WCHAR)c)==LX_ID)) {
            SKIPCH();
            tl_getid((UCHAR)c);
        }
    } else {
        if(LX_IS_IDENT(((WCHAR)(c = CHECKCH())))) {
            SKIPCH();
            if(Macro_depth >0) {
                lex_getid((WCHAR)c);
            } else {
                getid((WCHAR)c);
            }
            value = (get_defined()) ? TRUE : FALSE;
        } else {
            if(paren_level==0) {
                strcpy (Msg_Text, GET_MSG (2003));
                error(2003);
            } else {
                strcpy (Msg_Text, GET_MSG (2004));
                error(2004);
            }
        }
    }
    if((CHARMAP(((WCHAR)(c = CHECKCH()))) == LX_WHITE) || (CHARMAP((WCHAR)c) == LX_EOS)) {
        if( ! can_get_non_white()) {
            return(value);
        }
    }
    if(paren_level) {
        if((CHARMAP(((WCHAR)(c = CHECKCH()))) == LX_CPAREN)) {
            SKIPCH();
            paren_level--;
            *Exp_ptr++ = (WCHAR)c;
        }
    }
    if((paren_level > 0) && (Tiny_lexer_nesting == 0)) {
        strcpy (Msg_Text, GET_MSG (4004));
        warning(4004);
    }
    return(value);
}


/*************************************************************************
 * NEXTIS - The lexical interface for #if expression parsing.
 * If the next token does not match what is wanted, return FALSE.
 * otherwise Set Currtok to L_NOTOKEN to force scanning on the next call.
 * Return TRUE.
 * will leave a newline as next char if it finds one.
 *************************************************************************/
int
nextis(
    register token_t tok
    )
{
    if(Currtok != L_NOTOKEN) {
        if(tok == Currtok) {
            Currtok = L_NOTOKEN;                        /*  use up the token  */
            return(TRUE);
        } else {
            return(FALSE);
        }
    }
    switch(yylex()) {                           /*  acquire a new token  */
        case 0:
            break;
        case L_CONSTANT:
            if( ! IS_INTEGRAL(TR_BTYPE(yylval.yy_tree))) {
                    strcpy (Msg_Text, GET_MSG (1017));
                    fatal (1017);
            } else {
                Currval = TR_LVALUE(yylval.yy_tree);
            }
            if(tok == L_CINTEGER) {
                return(TRUE);
            }
            Currtok = L_CINTEGER;
            break;
        case L_IDENT:
            Currval = do_defined(HLN_IDENTP_NAME(&yylval.yy_ident));
            if(tok == L_CINTEGER) {
                return(TRUE);
            }
            Currtok = L_CINTEGER;
            break;
        default:
            if(tok == Basic_token) {
                return(TRUE);
            }
            Currtok = Basic_token;
            break;
    }
    return(FALSE);
}


/************************************************************************
**  skip_cnew : reads up to and including the next newline.
************************************************************************/
void
skip_cnew(
    void
    )
{
    for(;;) {
        switch(CHARMAP(GETCH())) {
            case LX_NL:
                UNGETCH();
                return;
            case LX_SLASH:
                skip_comment();
                break;
            case LX_EOS:
                handle_eos();
                break;
        }
    }
}


/************************************************************************
**  skip_NLonly : reads up to the next newline, disallowing comments
************************************************************************/
void
skip_NLonly(
    void
    )
{
    for(;;) {
        switch(CHARMAP(GETCH())) {
            case LX_NL:
                UNGETCH();
                return;
            case LX_EOS:
                handle_eos();
                break;
        }
    }
}


/************************************************************************
**  pragma : handle processing the pragma directive
**  called by preprocess() after we have seen the #pragma
**  and are ready to handle the keyword which follows.
************************************************************************/
unsigned long
pragma(
    void
    )
{
    WCHAR   c;
    unsigned long int cp=0;

    c = skip_cwhite();
    if (c != L'\n') {
        getid(c);
        _wcsupr(Reuse_W);
        if (wcscmp(L"CODE_PAGE", Reuse_W) == 0) {
            if ((c = skip_cwhite()) == L'(') {
                c = skip_cwhite();  // peek token
                if (iswdigit(c)) {
                    token_t tok;
                    int old_prep = Prep;

                    Prep = FALSE;
                    tok = getnum(c);
                    Prep = old_prep;

                    switch(tok) {
                        default:
                        case L_CFLOAT:
                        case L_CDOUBLE:
                        case L_CLDOUBLE:
                        case L_FLOAT:
                        case L_DOUBLE:
                            break;
                        case L_CINTEGER:
                        case L_LONGINT:
                        case L_CUNSIGNED:
                        case L_LONGUNSIGNED:
                        case L_SHORT:
                        case L_LONG:
                        case L_SIGNED:
                        case L_UNSIGNED:
                            cp = TR_LVALUE(yylval.yy_tree);
                            break;
                    }
                }
                if (cp == 0) {
                    getid(c);
                    _wcsupr(Reuse_W);
                    if (wcscmp(L"DEFAULT", Reuse_W) == 0) {
                        cp = uiDefaultCodePage;
                    } else {
                        wsprintfA(Msg_Text, "%s%ws", GET_MSG(4212), Reuse_W);
                        error(4212);
                    }
                }
                if ((c = skip_cwhite()) != L')') {
                    UNGETCH();
                    strcpy (Msg_Text, GET_MSG (4211));
                    error(4211);
                }
            } else {
                UNGETCH();
                strcpy (Msg_Text, GET_MSG (4210));
                error(4210);
            }

            swprintf(Reuse_W, L"#pragma code_page %d\r\n", cp);
            myfwrite(Reuse_W, wcslen(Reuse_W) * sizeof(WCHAR), 1, OUTPUTFILE);
        }
    }
    // Skip #pragma statements
    while((c = get_non_eof()) != L'\n');
    UNGETCH();
    return cp;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\rcdll\p0gettok.c ===
/************************************************************************/
/*                                                                      */
/* RCPP - Resource Compiler Pre-Processor for NT system                 */
/*                                                                      */
/* P0GETTOK.C - Tokenization routines                                   */
/*                                                                      */
/* 29-Nov-90 w-BrianM  Update for NT from PM SDK RCPP                   */
/*                                                                      */
/************************************************************************/

#include "rc.h"

/************************************************************************
**      MAP_TOKEN : a token has two representations and additional information.
**      (ex : const, has basic token of L_CONST,
**                              mapped token of [L_TYPE | L_MODIFIER]
**                              and info based on what the map token is)
**      MAP_AND_FILL : has two representations, but none of the extra info.
**      (ex : '<', has basic of L_LT, and map of L_RELOP)
**  NOMAP_TOKEN : has 1 representation and additional info.
**      (ex: a string, basic and 'map' type L_STRING and ptrs to the actual str)
**      NOMAP_AND_FILL : has 1 representation and no additional info.
**      (ex : 'while', has basic and 'map' of L_WHILE)
**  the FILL versions fill the token with the basic token type.
************************************************************************/
#define MAP_TOKEN(otok)\
        (Basic_token = (otok), TS_VALUE(Basic_token))
#define MAP_AND_FILL(otok)\
        (yylval.yy_token = Basic_token = (otok), TS_VALUE(Basic_token))
#define NOMAP_TOKEN(otok)\
        (Basic_token = (otok))
#define NOMAP_AND_FILL(otok)\
        (yylval.yy_token = Basic_token = (otok))



/************************************************************************/
/* yylex - main tokenization routine                                    */
/************************************************************************/

token_t
yylex(
    void
    )
{
    REG WCHAR           last_mapped;
    WCHAR               mapped_c;
    WCHAR               buf[5];
    REG token_t         lex_token;

    for(;;) {
        last_mapped = mapped_c = CHARMAP(GETCH());
first_switch:
        switch(mapped_c) {
            case LX_EACH:
            case LX_ASCII:
                if (fAFXSymbols && PREVCH() == SYMUSESTART || PREVCH() == SYMDEFSTART
                    || PREVCH() == SYMDELIMIT) {
                    myfwrite(&(PREVCH()), sizeof(WCHAR), 1, OUTPUTFILE);
                    continue;
                }
                Msg_Temp = GET_MSG(2018);
                SET_MSG (Msg_Text, sizeof(Msg_Text), Msg_Temp, PREVCH());
                error(2018);
                continue;
                break;
            case LX_OBRACE:
                return(NOMAP_AND_FILL(L_LCURLY));
                break;
            case LX_CBRACE:
                return(NOMAP_AND_FILL(L_RCURLY));
                break;
            case LX_OBRACK:
                return(NOMAP_AND_FILL(L_LBRACK));
                break;
            case LX_CBRACK:
                return(NOMAP_AND_FILL(L_RBRACK));
                break;
            case LX_OPAREN:
                return(NOMAP_AND_FILL(L_LPAREN));
                break;
            case LX_CPAREN:
                return(NOMAP_AND_FILL(L_RPAREN));
                break;
            case LX_COMMA:
                return(NOMAP_AND_FILL(L_COMMA));
                break;
            case LX_QUEST:
                return(NOMAP_AND_FILL(L_QUEST));
                break;
            case LX_SEMI:
                return(NOMAP_AND_FILL(L_SEMI));
                break;
            case LX_TILDE:
                return(NOMAP_AND_FILL(L_TILDE));
                break;
            case LX_NUMBER:
                return(MAP_TOKEN(getnum(PREVCH())));
                break;

            case LX_MINUS:
                switch(last_mapped = CHARMAP(GETCH())) {
                    case LX_EQ:
                        return(MAP_AND_FILL(L_MINUSEQ));
                        break;
                    case LX_GT:
                        return(MAP_AND_FILL(L_POINTSTO));
                        break;
                    case LX_MINUS:
                        return(MAP_AND_FILL(L_DECR));
                        break;
                    default:
                        lex_token = L_MINUS;
                        break;
                }
                break;
            case LX_PLUS:
                switch(last_mapped = CHARMAP(GETCH())) {
                    case LX_EQ:
                        return(MAP_AND_FILL(L_PLUSEQ));
                        break;
                    case LX_PLUS:
                        return(MAP_AND_FILL(L_INCR));
                        break;
                    default:
                        lex_token = L_PLUS;
                        break;
                }
                break;
            case LX_AND:
                switch(last_mapped = CHARMAP(GETCH())) {
                    case LX_EQ:
                        return(MAP_AND_FILL(L_ANDEQ));
                        break;
                    case LX_AND:
                        return(MAP_AND_FILL(L_ANDAND));
                        break;
                    default:
                        lex_token = L_AND;
                        break;
                }
                break;
            case LX_OR:
                switch(last_mapped = CHARMAP(GETCH())) {
                    case LX_EQ:
                        return(MAP_AND_FILL(L_OREQ));
                        break;
                    case LX_OR:
                        return(MAP_AND_FILL(L_OROR));
                        break;
                    default:
                        lex_token = L_OR;
                        break;
                }
                break;
            case LX_COLON:
                return(NOMAP_AND_FILL(L_COLON));
                break;
            case LX_HAT:
                if((last_mapped = CHARMAP(GETCH())) == LX_EQ) {
                    return(MAP_AND_FILL(L_XOREQ));
                }
                lex_token = L_XOR;
                break;
            case LX_PERCENT:
                if((last_mapped = CHARMAP(GETCH())) == LX_EQ) {
                    return(MAP_AND_FILL(L_MODEQ));
                }
                lex_token = L_MOD;
                break;
            case LX_EQ:
                if((last_mapped = CHARMAP(GETCH())) == LX_EQ) {
                    return(MAP_AND_FILL(L_EQUALS));
                }
                lex_token = L_ASSIGN;
                break;
            case LX_BANG:
                if((last_mapped = CHARMAP(GETCH())) == LX_EQ) {
                    return(MAP_AND_FILL(L_NOTEQ));
                }
                lex_token = L_EXCLAIM;
                break;
            case LX_SLASH:
                switch(last_mapped = CHARMAP(GETCH())) {
                    case LX_STAR:
                        dump_comment();
                        continue;
                        break;
                    case LX_SLASH:
                        DumpSlashComment();
                        continue;
                        break;
                    case LX_EQ:
                        return(MAP_AND_FILL(L_DIVEQ));
                        break;
                    default:
                        lex_token = L_DIV;
                        break;
                }
                break;
            case LX_STAR:
                switch(last_mapped = CHARMAP(GETCH())) {
                    case LX_SLASH:
                        if( ! Prep ) {
                            strcpy (Msg_Text, GET_MSG(2138));
                            error(2138); /* (nested comments) */
                        } else {
                            myfwrite(L"*/", 2 * sizeof(WCHAR), 1, OUTPUTFILE);
                        }
                        continue;
                    case LX_EQ:
                        return(MAP_AND_FILL(L_MULTEQ));
                        break;
                    default:
                        lex_token = L_MULT;
                        break;
                }
                break;
            case LX_LT:
                switch(last_mapped = CHARMAP(GETCH())) {
                    case LX_LT:
                        if((last_mapped = CHARMAP(GETCH())) == LX_EQ) {
                            return(MAP_AND_FILL(L_LSHFTEQ));
                        }
                        mapped_c = LX_LSHIFT;
                        lex_token = L_LSHIFT;
                        break;
                    case LX_EQ:
                        return(MAP_AND_FILL(L_LTEQ));
                        break;
                    default:
                        lex_token = L_LT;
                        break;
                }
                break;
            case LX_LSHIFT:
                /*
                **  if the next char is not an =, then we unget and return,
                **  since the only way in here is if we broke on the char
                **  following '<<'. since we'll have already worked the handle_eos()
                **  code prior to getting here, we'll not see another eos,
                **  UNLESS i/o buffering is char by char. ???
                **  see also, LX_RSHIFT
                */
                if((last_mapped = CHARMAP(GETCH())) == LX_EQ) {
                    return(MAP_AND_FILL(L_LSHFTEQ));
                }
                UNGETCH();
                return(MAP_AND_FILL(L_LSHIFT));
                break;
            case LX_GT:
                switch(last_mapped = CHARMAP(GETCH())) {
                    case LX_EQ:
                        return(MAP_AND_FILL(L_GTEQ));
                    case LX_GT:
                        if((last_mapped = CHARMAP(GETCH())) == LX_EQ) {
                            return(MAP_AND_FILL(L_RSHFTEQ));
                        }
                        mapped_c = LX_RSHIFT;
                        lex_token = L_RSHIFT;
                        break;
                    default:
                        lex_token = L_GT;
                        break;
                }
                break;
            case LX_RSHIFT:
                if((last_mapped = CHARMAP(GETCH())) == LX_EQ) {
                    return(MAP_AND_FILL(L_RSHFTEQ));
                }
                UNGETCH();
                return(MAP_AND_FILL(L_RSHIFT));
                break;
            case LX_POUND:
                if( ! Prep ) {
                    strcpy (Msg_Text, GET_MSG(2014));
                    error(2014);/* # sign must be first non-whitespace */
                    UNGETCH();              /* replace it */
                    Linenumber--;   /* do_newline counts a newline */
                    do_newline();   /* may be a 'real' prepro line */
                } else {
                    myfwrite(L"#", sizeof(WCHAR), 1, OUTPUTFILE);
                }
                continue;
                break;
            case LX_EOS:
                if(PREVCH() == L'\\') {
                    if( ! Prep ) {
                        if( ! checknl()) {  /* ignore the new line */
                            strcpy (Msg_Text, GET_MSG(2017));
                            error(2017);/* illegal escape sequence */
                        }
                    } else {
                        myfwrite(L"\\", sizeof(WCHAR), 1, OUTPUTFILE);
                        *buf = get_non_eof();
                        myfwrite(buf, sizeof(WCHAR), 1, OUTPUTFILE);
                    }
                    continue;
                }
                if(Macro_depth == 0) {
                    if( ! io_eob()) {       /* not the end of the buffer */
                        continue;
                    }
                    if(fpop()) {            /* have more files to read */
                        continue;
                    }
                    return(MAP_AND_FILL(L_EOF));    /* all gone . . . */
                }
                handle_eos();                       /* found end of macro */
                continue;
                break;
            case LX_DQUOTE:
                if( ! Prep ) {
                    str_const();
                    return(NOMAP_TOKEN(L_STRING));
                }
                prep_string(L'\"');
                continue;
                break;
            case LX_SQUOTE:
                if( ! Prep ) {
                    return(MAP_TOKEN(char_const()));
                }
                prep_string(L'\'');
                continue;
                break;
            case LX_CR:             /*  ??? check for nl next  */
                continue;
                break;
            case LX_NL:
                if(On_pound_line) {
                    UNGETCH();
                    return(NOMAP_TOKEN(L_NOTOKEN));
                }
                if(Prep) {
                    // must manually write '\r' with '\n' when writing 16-bit strings
                    myfwrite(L"\r\n", 2 * sizeof(WCHAR), 1, OUTPUTFILE);
                }
                do_newline();
                continue;
                break;
            case LX_WHITE:          /* skip all white space */
                if( ! Prep ) {      /* check only once */
                    do {
                        ;
                    } while(LXC_IS_WHITE(GETCH()));
                }
                else {
                    WCHAR   c;

                    c = PREVCH();
                    do {
                        myfwrite(&c, sizeof(WCHAR), 1, OUTPUTFILE);
                    } while(LXC_IS_WHITE(c = GETCH()));
                }
                UNGETCH();
                continue;
                break;
            case LX_ILL:
                if( ! Prep ) {
                    Msg_Temp = GET_MSG(2018);
                    SET_MSG (Msg_Text, sizeof(Msg_Text), Msg_Temp, PREVCH());
                    error(2018);/* unknown character */
                } else {
                    myfwrite(&(PREVCH()), sizeof(WCHAR), 1, OUTPUTFILE);
                }
                continue;
                break;
            case LX_BACKSLASH:
                if( ! Prep ) {
                    if( ! checknl()) {      /* ignore the new line */
                        strcpy (Msg_Text, GET_MSG(2017));
                        error(2017);/* illegal escape sequence */
                    }
                }
                else {
                    myfwrite(L"\\", sizeof(WCHAR), 1, OUTPUTFILE);
                    *buf = get_non_eof();
                    myfwrite(buf, sizeof(WCHAR), 1, OUTPUTFILE);
                }
                continue;
                break;
            case LX_DOT:
dot_switch:
                switch(last_mapped = CHARMAP(GETCH())) {
                    case LX_BACKSLASH:
                        if(checknl()) {
                            goto dot_switch;
                        }
                        UNGETCH();
                        break;
                    case LX_EOS:
                        if(handle_eos() == BACKSLASH_EOS) {
                            break;
                        }
                        goto dot_switch;
                        break;
                    case LX_DOT:
                        if( ! checkop(L'.') ) {
                            strcpy (Msg_Text, GET_MSG(2142));
                            error(2142);/* ellipsis requires three '.'s */
                        }
                        return(NOMAP_AND_FILL(L_ELLIPSIS));
                        break;
                    case LX_NUMBER:
                        /*
                        **      don't worry about getting correct hash value.
                        **      The text equivalent of a real number is never
                        **      hashed
                        */
                        Reuse_W[0] = L'.';
                        Reuse_W[1] = PREVCH();
                        return(MAP_TOKEN(get_real(&Reuse_W[2])));
                        break;
                }
                UNGETCH();
                return(MAP_AND_FILL(L_PERIOD));
                break;
            case LX_NOEXPAND:
                SKIPCH();                   /* just skip length */
                continue;
            case LX_ID:
                {
                    pdefn_t pdef;

                    if(Macro_depth > 0) {
                        if( ! lex_getid(PREVCH())) {
                            goto avoid_expand;
                        }
                    }
                    else {
                        getid(PREVCH());
                    }

                    if( ((pdef = get_defined()) != 0)
                        &&
                        ( ! DEFN_EXPANDING(pdef))
                        &&
                        ( can_expand(pdef))
                        ) {
                        continue;
                    }

avoid_expand:
                    if( ! Prep ) {
                        /* M00BUG get near copy of identifier???? */
                        HLN_NAME(yylval.yy_ident) = Reuse_W;
                        HLN_HASH(yylval.yy_ident) = Reuse_W_hash;
                        HLN_LENGTH(yylval.yy_ident) = (UINT)Reuse_W_length;
                        return(L_IDENT);
                    } else {
                        myfwrite(Reuse_W, (Reuse_W_length - 1) * sizeof(WCHAR), 1, OUTPUTFILE);
                        return(NOMAP_TOKEN(L_NOTOKEN));
                    }
                }
                continue;
                break;
        }
        /*
        **  all the multichar ( -> -- -= etc ) operands
        **  must come through here. we've gotten the next char,
        **  and not matched one of the possiblities, but we have to check
        **  for the end of the buffer character and act accordingly
        **  if it is the eob, then we handle it and go back for another try.
        **  otherwise, we unget the char we got, and return the base token.
        */
        if(last_mapped == LX_EOS) {
            if(handle_eos() != BACKSLASH_EOS) {
                goto first_switch;
            }
        }
        UNGETCH();      /* cause we got an extra one to check */
        return(MAP_AND_FILL(lex_token));
    }
}


/************************************************************************
**
**      lex_getid: reads an identifier for the main lexer.  The
**              identifier is read into Reuse_W. This function should not handle
**              an end of string if it is rescanning a macro expansion, because
**              this could switch the context with regards to whether the macro
**            is expandable or not.  Similarly, the noexpand marker must only be
**           allowed if a macro is being rescanned, otherwise let this character
**              be caught as an illegal character in text
************************************************************************/
int
lex_getid(
    WCHAR c
    )
{
    REG WCHAR   *p;
    int         length = 0;

    p = Reuse_W;
    *p++ = c;
    c &= HASH_MASK;
    for(;;) {
        while(LXC_IS_IDENT(*p = GETCH())) { /* collect character */
            c += (*p & HASH_MASK);                      /* hash it */
            p++;
        }
        if(CHARMAP(*p) == LX_NOEXPAND ) {
            length = (int)GETCH();
            continue;
        }
        UNGETCH();
        break;                          /* out of for loop  -  only way out */
    }
    if(p >= LIMIT(Reuse_W)) {   /* is this error # correct? */
        strcpy (Msg_Text, GET_MSG(1067));
        fatal(1067);
    }
    if(((p - Reuse_W) > LIMIT_ID_LENGTH) && ( ! Prep )) {
        p = Reuse_W + LIMIT_ID_LENGTH;
        *p = L'\0';
        c = local_c_hash(Reuse_W);
        Msg_Temp = GET_MSG(4011);
        SET_MSG (Msg_Text, sizeof(Msg_Text), Msg_Temp, Reuse_W);
        warning(4011);  /* id truncated */
    } else {
        *p = L'\0';              /* terminates identifier for expandable check */
    }
    Reuse_W_hash = (hash_t)c;
    Reuse_W_length = (UINT)((p - Reuse_W) + 1);
    return(length != (p - Reuse_W));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\rcdll\p0expr.c ===
/************************************************************************/
/*                                                                      */
/* RCPP - Resource Compiler Pre-Processor for NT system                 */
/*                                                                      */
/* P0EXPR.C - Expression routines for Pre-Processor                     */
/*                                                                      */
/* AUTHOR - Ralph Ryan, Sept. 16, 1982                                  */
/* 06-Dec-90 w-BrianM  Update for NT from PM SDK RCPP                   */
/*                                                                      */
/************************************************************************/
/*
 * DESCRIPTION
 *      Evaluate the constant expression.  Since these routines are
 *      all recursively coupled, it is clearer NOT to document them
 *      with the standard header.  Instead, BML (British Meta Language,
 *      a BNF like meta language) will be given for each "production"
 *      of this recursive descent parser.
 *
 * Note - Sure, yeah, right. Frankly, I'm frightened! (w-BrianM)
 ************************************************************************/

#include "rc.h"

/************************************************************************/
/* Local Function Prototypes                                            */
/************************************************************************/
long and(void);
long andif(void);
long constant(void);
long constexpr(void);
long eqset(void);
long mult(void);
long or(void);
long orelse(void);
long plus(void);
long prim(void);
long relation(void);
long shift(void);
long xor(void);


/************************************************************************/
/* File Global Variables                                                */
/************************************************************************/
long    Currval = 0;
static  int             Parencnt = 0;


/************************************************************************/
/* do_constexpr()                                                       */
/************************************************************************/
long
do_constexpr(
    void
    )
{
    REG long    val;

    Parencnt = 0;
    Currtok = L_NOTOKEN;
    val = constexpr();
    if( Currtok == L_RPAREN ) {
        if( Parencnt-- == 0 ) {
            Msg_Temp = GET_MSG(1012);
            SET_MSG (Msg_Text, sizeof(Msg_Text), Msg_Temp, "(");
            fatal(1012);                /* missing left paren */
        }
    } else if( Currtok != L_NOTOKEN ) {
        Msg_Temp = GET_MSG(4067);
        SET_MSG (Msg_Text, sizeof(Msg_Text), Msg_Temp, PPifel_str);
        warning(4067);
    }

    if( Parencnt > 0 ) {
        Msg_Temp = GET_MSG(4012);
        SET_MSG (Msg_Text, sizeof(Msg_Text), Msg_Temp, ")");
        fatal(4012);    /* missing right paren */
    }
    return(val);
}

/************************************************************************/
/* constexpr ::= orelse [ '?' orelse ':' orelse ];                      */
/************************************************************************/
long
constexpr(
    void
    )
{
    REG long            val;
    REG long            val1;
    long                val2;

    val = orelse();
    if( nextis(L_QUEST) ) {
        val1 = orelse();
        if( nextis(L_COLON) )
            val2 = orelse();
        return(val ? val1 : val2);
    }
    return(val);
}


/************************************************************************/
/* orelse ::= andif [ '||' andif ]* ;                                   */
/************************************************************************/
long
orelse(
    void
    )
{
    REG long val;

    val = andif();
    while(nextis(L_OROR))
        val = andif() || val;
    return(val);
}


/************************************************************************/
/* andif ::= or [ '&&' or ]* ;                                          */
/************************************************************************/
long
andif(
    void
    )
{
    REG long val;

    val = or();
    while(nextis(L_ANDAND))
        val = or() && val;
    return(val);
}


/************************************************************************/
/* or ::= xor [ '|' xor]* ;                                             */
/************************************************************************/
long
or(
    void
    )
{
    REG long val;

    val = xor();
    while( nextis(L_OR) )
        val |= xor();
    return(val);
}


/************************************************************************/
/* xor ::= and [ '^' and]* ;                                            */
/************************************************************************/
long
xor(
    void
    )
{
    REG long val;

    val = and();
    while( nextis(L_XOR) )
        val ^= and();
    return(val);
}


/************************************************************************/
/*  and ::= eqset [ '&' eqset]* ;                                       */
/************************************************************************/
long
and(
    void
    )
{
    REG long val;

    val = eqset();
    while( nextis(L_AND) )
        val &= eqset();
    return(val);
}


/************************************************************************/
/* eqset ::= relation [ ('==' | '!=') eqset] ;                          */
/************************************************************************/
long
eqset(
    void
    )
{
    REG long val;

    val = relation();
    if( nextis(L_EQUALS) )
        return(val == relation());
    if( nextis(L_NOTEQ) )
        return(val != relation());
    return(val);
}

/************************************************************************/
/* relation ::= shift [ ('<' | '>' | '<=' | '>=' ) shift] ;             */
/************************************************************************/
long
relation(
    void
    )
{
    REG long val;

    val = shift();
    if( nextis(L_LT) )
        return(val < shift());
    if( nextis(L_GT) )
        return(val > shift());
    if( nextis(L_LTEQ) )
        return(val <= shift());
    if( nextis(L_GTEQ) )
        return(val >= shift());
    return(val);
}


/************************************************************************/
/* shift ::= plus [ ('<< | '>>') plus] ;                                */
/************************************************************************/
long
shift(
    void
    )
{
    REG long val;

    val = plus();
    if( nextis(L_RSHIFT) )
        return(val >> plus());
    if( nextis(L_LSHIFT) )
        return(val << plus());
    return(val);
}


/************************************************************************/
/* plus ::= mult [ ('+' | '-') mult ]* ;                                */
/************************************************************************/
long
plus(
    void
    )
{
    REG long val;

    val = mult();
    for(;;) {
        if( nextis(L_PLUS) )
            val += mult();
        else if( nextis(L_MINUS) )
            val -= mult();
        else
            break;
    }
    return(val);
}


/************************************************************************/
/* mult ::= prim [ ('*' | '/' | '%' ) prim ]* ;                         */
/************************************************************************/
long
mult(
    void
    )
{
    REG long val;
    long PrimVal;

    val = prim();
    for(;;) {
        if( nextis(L_MULT) )
            val *= prim();
        else if( nextis(L_DIV) ) {
            PrimVal = prim();
            if (PrimVal)
                val /= PrimVal;
            else
                val = PrimVal;
        }
        else if( nextis(L_MOD) ) {
            PrimVal = prim();
            if (PrimVal)
                val %= PrimVal;
            else
                val = 0;
        }
        else
            break;
    }
    return(val);
}


/************************************************************************/
/* prim ::= constant | ( '!' | '~' | '-' ) constant                     */
/************************************************************************/
long
prim(
    void
    )
{
    if( nextis(L_EXCLAIM) )
        return( ! constant());
    else if( nextis(L_TILDE) )
        return( ~ constant() );
    else if( nextis(L_MINUS) )
        return(-constant());
    else
        return(constant());
}


/************************************************************************/
/* constant - at last, a terminal symbol  | '(' constexpr ')'           */
/************************************************************************/
long
constant(
    void
    )
{
    REG long val;

    if( nextis(L_LPAREN) ) {
        Parencnt++;
        val = constexpr();
        if( nextis(L_RPAREN) ) {
            Parencnt--;
            return(val);
        } else {
            Msg_Temp = GET_MSG(1012);
            SET_MSG (Msg_Text, sizeof(Msg_Text), Msg_Temp, ")");
            fatal (1012);
        }
    } else if( ! nextis(L_CINTEGER) ) {
        Msg_Temp = GET_MSG(1017);
        SET_MSG (Msg_Text, sizeof(Msg_Text), Msg_Temp);
        fatal(1017);    /* invalid integer constant expression */
    }
    return(Currval);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\rcdll\p1sup.c ===
/************************************************************************/
/*                                                                      */
/* RCPP - Resource Compiler Pre-Processor for NT system                 */
/*                                                                      */
/* P1SUP.C - First pass C stuff which probably is not used              */
/*                                                                      */
/* 27-Nov-90 w-BrianM  Update for NT from PM SDK RCPP                   */
/*                                                                      */
/************************************************************************/

#include "rc.h"

/* trees */
#define LEFT                    1
#define RIGHT                   2

#define MORE_CHECKING   2

int TypeCount;
int TreeCount;

type_entry_t    *Type_table[TYPE_TABLE_SIZE];


/************************************************************************/
/* Local Function Prototypes                                            */
/************************************************************************/
ptype_t  hash_type(ptype_t);
int     types_equal(ptype_t, ptype_t);


/************************************************************************
**  hash_type : returns a pointer to an already built type, if it
**  exists, or builds one.
************************************************************************/
ptype_t
hash_type(
    type_t *p_type
    )
{
    REG type_entry_t    *p_tmp;
    type_entry_t        **p_start;

    /* Try to get a unique hash value for every type...keep
         * type_equal in mind if changing this
         */
    p_start = &Type_table[(TY_BTYPE(p_type) + TY_DTYPE(p_type) + (INT_PTR) TY_INDIR(p_type)) & (TYPE_TABLE_SIZE - 1)];

    for(p_tmp = *p_start; p_tmp; p_tmp = p_tmp->te_next ) {
        if(types_equal(p_type,&(p_tmp->te_type))) {
            return(&(p_tmp->te_type));
        }
    }
    p_tmp = (type_entry_t *) MyAlloc(sizeof(type_entry_t));
    if (p_tmp == NULL) {
        strcpy (Msg_Text, GET_MSG (1002));
        error(1002);
        return NULL;
    }
    p_tmp->te_next = *p_start;
    *p_start = p_tmp;
    p_tmp->te_type = *p_type;
    TY_TINDEX(&(p_tmp->te_type)) = 0;
    return(&(p_tmp->te_type));
}


/************************************************************************
**  types_equal : are two types equal?
************************************************************************/
int
types_equal(
    REG ptype_t p1,
    REG ptype_t p2
    )
{
    return((TY_BTYPE(p1) == TY_BTYPE(p2))
        &&
        (TY_DTYPE(p1) == TY_DTYPE(p2))
        &&
        TY_INDIR(p1) == TY_INDIR(p2)
        );
}

/************************************************************************
**      build_const - builds and returns a pointer to a constant tree.
**              Input   : constant type.
**                      : ptr to a union containing the value of the constant
**              Output  : Pointer to constant tree.
************************************************************************/
ptree_t
build_const(
    REG token_t type,
    value_t *value
    )
{
    REG ptree_t res;
    ptype_t     p_type;
    btype_t     btype;

    res = (ptree_t) MyAlloc(sizeof(tree_t));
    if (res == NULL) {
        strcpy (Msg_Text, GET_MSG (1002));
        error(1002);
        return NULL;
    }
    TR_SHAPE(res) = TTconstant;
    TR_TOKEN(res) = type;
    switch( type ) {
        case L_CINTEGER:
        case L_LONGINT:
        case L_CUNSIGNED:
        case L_LONGUNSIGNED:
            if( type == L_CUNSIGNED || type == L_LONGUNSIGNED ) {
                btype = (btype_t)(BT_UNSIGNED |
                     (btype_t)((type == L_CUNSIGNED) ? BTint : BTlong));
            } else {
                btype = (btype_t)((type == L_CINTEGER) ? BTint : BTlong);
            }

            if((TR_LVALUE(res) = PV_LONG(value)) == 0) {
                TR_SHAPE(res) |= TTzero;
            }
            break;
        case L_CFLOAT:
            btype = BTfloat;
            TR_RCON(res) = PV_RCON(value);
            break;
        case L_CDOUBLE:
            btype = BTdouble;
            TR_RCON(res) = PV_RCON(value);
            break;
        case L_CLDOUBLE:
            btype = BTldouble;
            TR_RCON(res) = PV_RCON(value);
            break;
        default:
            break;
    }
    p_type = (ptype_t) MyAlloc(sizeof(type_t));
    if (p_type == NULL) {
        strcpy (Msg_Text, GET_MSG (1002));
        error(1002);
        return NULL;
    }
    TY_BTYPE(p_type) = (btype_t)(btype | BT_CONST);
    TR_P1TYPE(res) = hash_type(p_type);
    return(res);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\rcdll\p1types.h ===
/*
**  symbols basic types
**  if the values are changed check : init'd arrays in globals.c
*/
#define BTundef         0
#define BTchar          1
#define BTshort         2
#define BTint           3
#define BTlong          4
#define BTenumuse       5
#define BTfloat         6
#define BTdouble        7
#define BTldouble       8
#define BTseg           9
#define BTBASIC         9   /* used elsewhere to indicate the last basic type */
#define BTvoid          10
#define BTenum          11
#define BTstruct        12
#define BTunion         13
#define BTstuse         14
#define BTunuse         15

#define BT_MASK         0x0f    /* basic type mask */

/*
**  the following are also used in indirection strings as modifiers
**  to the basic indirections.
**  NOTE THIS DOESN'T really work for C600, but for just one case.
**  if a typedef has 'near' on it, 'consolidate_types' will consider
**  it to be a 'signed' bit, and remove it, thus, near never gets
**  added to whatever the typedef is used on.
*/
#define BT_UNSIGNED             0x0010  /* unsigned keyword used */
#define BT_SIGNED               0x0020  /* signed keyword used */
#define SU_MASK                 0x0030  /* signed/unsigned mask */

#define BT_NEAR                 0x0040  /* near keyword used */
#define BT_FAR                  0x0080  /* far keyword used */
#define BT_HUGE                 0x00c0  /* huge keyword used */
#define NFH_MASK                0x00c0  /* near/far/huge mask */

#define BT_INTERRUPT            0x0100  /* interrupt seen */
#define BT_SAVEREGS             0x0200  /* dynalink seen */
#define BT_EXPORT               0x0400  /* export seen */
#define BT_LOADDS               0x0800  /* loadds seen */
#define CODEMOD_MASK            0x0f00  /* code modifiers */

#define BT_CONST                0x1000  /* constant keyword used */
#define BT_VOLATILE             0x2000  /* volatile keyword used */
#define CV_MASK                 0x3000  /* const/volatile mask */

#define BT_CDECL                0x4000  /* cdecl keyword used */
#define BT_FORTRAN              0x8000  /* fortran keyword used */
#define BT_PASCAL               0xc000  /* pascal keyword used */
#define LANGUAGE_MASK           0xc000  /* cdecl/fortran/pascal mask */

#define MODIFIER_MASK   (NFH_MASK | LANGUAGE_MASK | CODEMOD_MASK | CV_MASK)
#define ALL_MODIFIERS   (MODIFIER_MASK | SU_MASK)
/*
**      macros for getting/setting basic type information
**  Q_* to query the flag.
**      S_* to set the flag.
**  the Q_near/far/huge things are defined later, and are called IS_*.
*/
#define IS_BTBASIC(P)           ((P) <= BTBASIC)
#define IS_BTINTEGRAL(P)        ((P) <= BTenumuse)
#define IS_BTFLOAT(P)           ((BTfloat <= (P)) && ((P) <= BTldouble))
#define IS_BTVOID(P)            ((P) == BTvoid)

#define IS_BASIC(P)             (IS_BTBASIC(Q_BTYPE(P)))
#define IS_INTEGRAL(P)          (IS_BTINTEGRAL(Q_BTYPE(P)))
#define IS_FLOAT(P)             (IS_BTFLOAT(Q_BTYPE(P)))
#define IS_VOID(P)              (IS_BTVOID(Q_BTYPE(P)))

#define IS_MULTIBYTE(P) ((BTstruct <= (P)) && ((P) <= BTunuse))
#define IS_UNSIGNED(P)  ((P) & BT_UNSIGNED)
#define IS_SIGNED(P)    ((P) & BT_SIGNED)
#define CLR_SIGNED(P)   ((P) &= ~BT_SIGNED)

#define S_UNSIGNED(P)   ((P) |= BT_UNSIGNED)
#define S_SIGNED(P)     ((P) |= BT_SIGNED)
#define S_CONST(P)      ((P) |= BT_CONST)
#define S_VOLATILE(P)   ((P) |= BT_VOLATILE)
#define S_NEAR(P)       ((P) |= BT_NEAR)
#define S_FAR(P)        ((P) |= BT_FAR)
#define S_HUGE(P)       ((P) |= BT_HUGE)
#define S_CDECL(P)      ((P) |= BT_CDECL)
#define S_FORTRAN(P)    ((P) |= BT_FORTRAN)
#define S_PASCAL(P)     ((P) |= BT_PASCAL)
#define S_INTERRUPT(P)  ((P) |= BT_INTERRUPT)
#define S_SAVEREGS(P)   ((P) |= BT_SAVEREGS)

#define Q_BTYPE(P)      ((P) & ( BT_MASK ))
#define S_BTYPE(P,V)    ((P) = (((P) & ( ~ BT_MASK )) | V))

struct  s_flist         {                       /* formal parameter list of types */
        ptype_t         fl_type;                /* type of formal */
        pflist_t        fl_next;                /* next one */
        };

#define FL_NEXT(P)              ((P)->fl_next)
#define FL_TYPE(P)              ((P)->fl_type)

union   u_ivalue        {
        abnd_t          ind_subscr;             /*  array subscript size  */
        psym_t          ind_formals;    /*  formal symbol list  */
        pflist_t        ind_flist;              /*  formal type list  */
        psym_t          ind_basesym;    /*  segment we're based on  */
        ptype_t         ind_basetype;   /*  type we're based on  */
        phln_t          ind_baseid;             /*  id we're based on  */
        };

#define PIVALUE_ISUB(P)                 ((P)->ind_subscr)
#define PIVALUE_IFORMALS(P)             ((P)->ind_formals)
#define PIVALUE_IFLIST(P)               ((P)->ind_flist)
#define PIVALUE_BASEDSYM(P)             ((P)->ind_basesym)
#define PIVALUE_BASEDTYPE(P)            ((P)->ind_basetype)
#define PIVALUE_BASEDID(P)              ((P)->ind_baseid)

#define IVALUE_ISUB(P)                  (PIVALUE_ISUB(&(P)))
#define IVALUE_IFORMALS(P)              (PIVALUE_IFORMALS(&(P)))
#define IVALUE_IFLIST(P)                (PIVALUE_IFLIST(&(P)))
#define IVALUE_BASEDSYM(P)              (PIVALUE_BASEDSYM(&(P)))
#define IVALUE_BASEDTYPE(P)             (PIVALUE_BASEDTYPE(&(P)))
#define IVALUE_BASEDID(P)               (PIVALUE_BASEDID(&(P)))

struct  s_indir {
        btype_t         ind_type;               /*  what kind ?  */
        pindir_t        ind_next;               /*  next one  */
        ivalue_t        ind_info;               /*  subscript/function's params  */
        };

#define INDIR_INEXT(P)          ((P)->ind_next)
#define INDIR_ITYPE(P)          ((P)->ind_type)
#define INDIR_INFO(P)           ((P)->ind_info)
#define INDIR_ISUB(P)           (IVALUE_ISUB(INDIR_INFO(P)))
#define INDIR_IFORMALS(P)       (IVALUE_IFORMALS(INDIR_INFO(P)))
#define INDIR_IFLIST(P)         (IVALUE_IFLIST(INDIR_INFO(P)))
#define INDIR_BASEDSYM(P)       (IVALUE_BASEDSYM(INDIR_INFO(P)))
#define INDIR_BASEDTYPE(P)      (IVALUE_BASEDTYPE(INDIR_INFO(P)))
#define INDIR_BASEDID(P)        (IVALUE_BASEDID(INDIR_INFO(P)))
/*
**  optimal choices for these things.
**  however, everyone uses macros to test them, so if i'm wrong,
**  it should be easy to change the values, but think well !!!
*/
#define IN_FUNC                         0x00
#define IN_PFUNC                        0x01
#define IN_ARRAY                        0x02
#define IN_PDATA                        0x03
#define IN_VOIDLIST                     0x04
#define IN_VARARGS                      0x08
#define IN_MASK                         (IN_ARRAY | IN_PDATA | IN_PFUNC | IN_FUNC)
#define IN_ADDRESS                      (IN_ARRAY | IN_PDATA | IN_PFUNC)
#define IN_DATA_ADDRESS                 (IN_ARRAY & IN_PDATA)   /* yes, i meant '&' */
#define IN_POINTER                      (IN_PFUNC & IN_PDATA)   /* yes, i meant '&' */
#if IN_DATA_ADDRESS == 0
#error IN_DATA_ADDRESS is ZERO
#endif
#if IN_POINTER == 0
#error IN_POINTER is ZERO
#endif
#define IS_ARRAY(I)                     (((I) & IN_MASK) == IN_ARRAY)
#define IS_PDATA(I)                     (((I) & IN_MASK) == IN_PDATA)
#define IS_PFUNC(I)                     (((I) & IN_MASK) == IN_PFUNC)
#define IS_FUNC(I)                      (((I) & IN_MASK) == IN_FUNC)
#define IS_EXTRACT(I)                   ((I) & IN_POINTER)
#define IS_DATA_ADDRESS(I)              ((I) & IN_DATA_ADDRESS)
#define IS_ADDRESS(I)                   ((I) & IN_ADDRESS)
#define IS_INDIR(I)                     ((I) & IN_MASK)
#define MASK_INDIR(I)                   ((I) & IN_MASK)
#define IS_VOIDLIST(I)                  ((I) & IN_VOIDLIST)
#define IS_VARARGS(I)                   ((I) & IN_VARARGS)

#define IS_NFH(I)                       ((I) & NFH_MASK)
#define IS_NEARNFH(I)                   ((I) == BT_NEAR)
#define IS_FARNFH(I)                    ((I) == BT_FAR)
#define IS_HUGENFH(I)                   ((I) == BT_HUGE)
#define IS_BASEDNFH(I)                  ((I) >= BT_BASED)
#define IS_BASEDSELFNFH(I)              ((I) == BT_BASEDSELF)
#define IS_BASEDIDNFH(I)                ((I) == BT_BASEDID)
#define IS_BASEDSYMNFH(I)               ((I) == BT_BASEDSYM)
#define IS_BASEDTYPENFH(I)              ((I) == BT_BASEDTYPE)

#define IS_NEAR(I)                      (IS_NEARNFH(IS_NFH(I)))
#define IS_FAR(I)                       (IS_FARNFH(IS_NFH(I)))
#define IS_HUGE(I)                      (IS_HUGENFH(IS_NFH(I)))
#define IS_BASED(I)                     (IS_BASEDNFH(IS_NFH(I)))
#define IS_BASEDSELF(I)                 (IS_BASEDSELFNFH(IS_NFH(I)))
#define IS_BASEDID(I)                   (IS_BASEDIDNFH(IS_NFH(I)))
#define IS_BASEDSYM(I)                  (IS_BASEDSYMNFH(IS_NFH(I)))
#define IS_BASEDTYPE(I)                 (IS_BASEDTYPENFH(IS_NFH(I)))

#define IS_INTERRUPT(I)         ((I) & BT_INTERRUPT)
#define IS_SAVEREGS(I)          ((I) & BT_SAVEREGS)
#define IS_EXPORT(I)            ((I) & BT_EXPORT)
#define IS_LOADDS(I)            ((I) & BT_LOADDS)
#define IS_CODEMOD(I)           ((I) & CODEMOD_MASK)

#define IS_CONST(I)             ((I) & BT_CONST)
#define IS_VOLATILE(I)          ((I) & BT_VOLATILE)

#define IS_MODIFIED(I)          ((I) & (MODIFIER_MASK))
#define ANY_MODIFIER(I)         ((I) & (ALL_MODIFIERS))

#define INTERF(I)               (MASK_INDIR(I) + (((I) & NFH_MASK) > 4))

#define S_ITYPE(I,V)            ((I) = ((I) & ( ~ IN_MASK )) | (V))
#define S_INFH(I,V)             ((I) = ((I) & ( ~ NFH_MASK )) | (V))
/*
**  type info for symbols
*/
struct  s_type  {
        btype_t         ty_bt;          /*  base type specifiers  */
        pindir_t        ty_indir;       /*  indirection string  */
        p1key_t         ty_dtype;       /*  derived type */
        psym_t          ty_esu;         /*  enum/structure/union/static defining type  */
        USHORT          ty_index;       /*      unique index of type for debugger */
        };
/*
**  help getting type info. P is pointer to TYPE (struct s_type).
**      TYPE contains the basic type, adjectives and an optional pointer
**      to a symbol which is an enumeration, structure, union which is the type
**      of this TYPE.
*/
#define TY_BTYPE(P)             ((P)->ty_bt)    /*  basic type  */
#define TY_DTYPE(P)             ((P)->ty_dtype) /*  derived type  */
#define TY_ESU(P)               ((P)->ty_esu)   /*  ptr to parent enum/struct/union  */
#define TY_INDIR(P)             ((P)->ty_indir) /*  indirection string  */
#define TY_TINDEX(P)            ((P)->ty_index) /*  type index */
#define TY_INEXT(P)             (INDIR_INEXT(TY_INDIR(P)))
#define TY_ITYPE(P)             (INDIR_ITYPE(TY_INDIR(P)))
#define TY_ISUB(P)              (INDIR_ISUB(TY_INDIR(P)))
#define TY_IFORMALS(P)          (INDIR_IFORMALS(TY_INDIR(P)))
#define TY_IFLIST(P)            (INDIR_IFLIST(TY_INDIR(P)))

typedef struct  s_indir_entry   indir_entry_t;
typedef struct  s_type_entry    type_entry_t;

struct  s_indir_entry   {
        indir_entry_t   *ind_next;
        indir_t          ind_type;
        };

struct  s_type_entry    {
        type_entry_t    *te_next;
        type_t           te_type;
        };

#define TYPE_TABLE_SIZE         0x100
#define INDIR_TABLE_SIZE        0x040
/*
**  HASH_MASK : is a value which consists of the bits in common
**  between upper and lower case. we mask each char we read with this
**  to sum them for a hash value. we do this so that all names consisting
**  of the same chars (case insensitive), will hash to the same location.
*/
#define HASH_MASK                       0x5f

#define DATASEGMENT                     0
#define TEXTSEGMENT                     1

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\rcdll\prerc.c ===
#include "rc.h"
#pragma hdrstop
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\rcdll\rc.c ===
/****************************************************************************/
/*                                                                          */
/*  RC.C -                                                                  */
/*                                                                          */
/*    Windows 2.0 Resource Compiler - Main Module                           */
/*                                                                          */
/*                                                                          */
/****************************************************************************/

#include "rc.h"
#include <setjmp.h>
#include <ddeml.h>


#define READ_MAX        (MAXSTR+80)
#define MAX_CMD         256
#define cDefineMax      100

CHAR     resname[_MAX_PATH];

PCHAR    szRCPP[MAX_CMD];
BOOL     fRcppAlloc[MAX_CMD];

/************************************************************************/
/* Define Global Variables                                              */
/************************************************************************/


SHORT   ResCount;   /* number of resources */
PTYPEINFO pTypInfo;

SHORT   nFontsRead;
FONTDIR *pFontList;
FONTDIR *pFontLast;
TOKEN   token;
int     errorCount;
WCHAR   tokenbuf[ MAXSTR + 1 ];
UCHAR   exename[ _MAX_PATH ], fullname[ _MAX_PATH ];
UCHAR   curFile[ _MAX_PATH ];
HANDLE  hHeap = NULL;

PDLGHDR pLocDlg;
UINT    mnEndFlagLoc;       /* patch location for end of a menu. */
/* we set the high order bit there    */

/* BOOL fLeaveFontDir; */
BOOL fVerbose;          /* verbose mode (-v) */

BOOL fAFXSymbols;
BOOL fMacRsrcs;
BOOL fAppendNull;
BOOL fWarnInvalidCodePage;
BOOL fSkipDuplicateCtlIdWarning;
long lOffIndex;
WORD idBase;
BOOL fPreprocessOnly;
CHAR szBuf[_MAX_PATH * 2];
CHAR szPreProcessName[_MAX_PATH];


/* File global variables */
CHAR    inname[_MAX_PATH];
PCHAR   szTempFileName;
PCHAR   szTempFileName2;
PFILE   fhBin;
PFILE   fhInput;

/* array for include path stuff, initially empty */
PCHAR       pchInclude;

/* Substitute font name */
int     nBogusFontNames;
WCHAR  *pszBogusFontNames[16];
WCHAR   szSubstituteFontName[MAXTOKSTR];

static  jmp_buf jb;
extern ULONG lCPPTotalLinenumber;

/* Function prototypes for local functions */
HANDLE  RCInit(void);
BOOL    RC_PreProcess (PCHAR);
VOID    CleanUpFiles(void);


/*---------------------------------------------------------------------------*/
/*                                                                           */
/*  rc_main() -                                                              */
/*                                                                           */
/*---------------------------------------------------------------------------*/

int __cdecl
rc_main(
    int argc,
    char**argv
    )
{
    PCHAR       r;
    PCHAR       x;
    PCHAR       s1, s2, s3;
    int         n;
    PCHAR       pchIncludeT;
    ULONG       cchIncludeMax;
    int         fInclude = TRUE;        /* by default, search INCLUDE */
    int         fIncludeCurrentFirst = TRUE; /* by default, add current dir to start of includes */
    int         cDefine = 0;
    int         cUnDefine = 0;
    PCHAR       pszDefine[cDefineMax];
    PCHAR       pszUnDefine[cDefineMax];
    CHAR        szDrive[_MAX_DRIVE];
    CHAR        szDir[_MAX_DIR];
    CHAR        szFName[_MAX_FNAME];
    CHAR        szExt[_MAX_EXT];
    CHAR        szFullPath[_MAX_PATH];
    CHAR        szIncPath[_MAX_PATH];
    CHAR        buf[10];
    CHAR        *szRC;
    PCHAR       *ppargv;
    BOOL        *pfRcppAlloc;
    int         rcpp_argc;

    /* Set up for this run of RC */
    if (_setjmp(jb)) {
        return Nerrors;
    }

    hHeap = RCInit();
    if (hHeap == NULL) {
        SET_MSG(Msg_Text, sizeof(Msg_Text), GET_MSG(1120), 0x01000000);
        quit(Msg_Text);
    }

    pchInclude = pchIncludeT = (PCHAR) MyAlloc(_MAX_PATH*2);
    cchIncludeMax = _MAX_PATH*2;

    szRC = argv[0];

    /* process the command line switches */
    while ((argc > 1) && (IsSwitchChar(*argv[1]))) {
        switch (toupper(argv[1][1])) {
            case '?':
            case 'H':
                /* print out help, and quit */
                SendError("\n");
                SET_MSG(Msg_Text, sizeof(Msg_Text), GET_MSG(10001),
                        VER_PRODUCTVERSION_STR, VER_PRODUCTBUILD);
                SendError(Msg_Text);
                SendError(GET_MSG(10002));
                SendError(GET_MSG(20001));

                return 0;   /* can just return - nothing to cleanup, yet. */

            case 'B':
                if (toupper(argv[1][2]) == 'R') {   /* base resource id */
                    unsigned long id;
                    if (isdigit(argv[1][3]))
                        argv[1] += 3;
                    else if (argv[1][3] == ':')
                        argv[1] += 4;
                    else {
                        argc--;
                        argv++;
                        if (argc <= 1)
                            goto BadId;
                    }
                    if (*(argv[1]) == 0)
                        goto BadId;
                    id = atoi(argv[1]);
                    if (id < 1 || id > 32767)
                        quit(GET_MSG(1210));
                    idBase = (WORD)id;
                    break;

BadId:
                    quit(GET_MSG(1209));
                }
                break;

            case 'C':
                /* Check for the existence of CodePage Number */
                if (argv[1][2])
                    argv[1] += 2;
                else {
                    argc--;
                    argv++;
                }

                /* Now argv point to first digit of CodePage */

                if (!argv[1])
                    quit(GET_MSG(1204));

                uiCodePage = atoi(argv[1]);

                if (uiCodePage == 0)
                    quit(GET_MSG(1205));

                /* Check if uiCodePage exist in registry. */
                if (!IsValidCodePage (uiCodePage))
                    quit(GET_MSG(1206));
                break;

            case 'D':
                /* if not attached to switch, skip to next */
                if (argv[1][2])
                    argv[1] += 2;
                else {
                    argc--;
                    argv++;
                }

                /* remember pointer to string */
                pszDefine[cDefine++] = argv[1];
                if (cDefine > cDefineMax) {
                    SET_MSG(Msg_Text, sizeof(Msg_Text), GET_MSG(1105), argv[1]);
                    quit(Msg_Text);
                }
                break;

            case 'F':
                switch (toupper(argv[1][2])) {
                    case 'O':
                        if (argv[1][3])
                            argv[1] += 3;
                        else {
                            argc--;
                            argv++;
                        }
                        if (argc > 1)
                            strcpy(resname, argv[1]);
                        else
                            quit(GET_MSG(1101));

                        break;

                    default:
                        SET_MSG(Msg_Text, sizeof(Msg_Text), GET_MSG(1103), argv[1]);
                        quit(Msg_Text);
                }
                break;

            case 'I':
                /* add string to directories to search */
                /* note: format is <path>\0<path>\0\0 */

                /* if not attached to switch, skip to next */
                if (argv[1][2])
                    argv[1] += 2;
                else {
                    argc--;
                    argv++;
                }

                if (!argv[1])
                    quit(GET_MSG(1201));

                if ((strlen(argv[1]) + 1 + strlen(pchInclude)) >= cchIncludeMax) {
                    cchIncludeMax = strlen(pchInclude) + strlen(argv[1]) + _MAX_PATH*2;
                    pchIncludeT = (PCHAR) MyAlloc(cchIncludeMax);
                    strcpy(pchIncludeT, pchInclude);
                    MyFree(pchInclude);
                    pchInclude = pchIncludeT;
                    pchIncludeT = pchInclude + strlen(pchIncludeT) + 1;
                }

                /* if not first switch, write over terminator with semicolon */
                if (pchInclude != pchIncludeT)
                    pchIncludeT[-1] = ';';

                /* copy the path */
                while ((*pchIncludeT++ = *argv[1]++) != 0)
                    ;
                break;

            case 'L':
                /* if not attached to switch, skip to next */
                if (argv[1][2])
                    argv[1] += 2;
                else {
                    argc--;
                    argv++;
                }

                if (!argv[1])
                    quit(GET_MSG(1202));
                if (sscanf( argv[1], "%x", &language ) != 1)
                    quit(GET_MSG(1203));

                while (*argv[1]++ != 0)
                    ;

                break;

            case 'M':
                fMacRsrcs = TRUE;
                goto MaybeMore;

            case 'N':
                fAppendNull = TRUE;
                goto MaybeMore;

            case 'P':
                fPreprocessOnly = TRUE;
                break;

            case 'R':
                goto MaybeMore;

            case 'S':
                // find out from BRAD what -S does
                fAFXSymbols = TRUE;
                break;

            case 'U':
                /* if not attached to switch, skip to next */
                if (argv[1][2])
                    argv[1] += 2;
                else {
                    argc--;
                    argv++;
                }

                /* remember pointer to string */
                pszUnDefine[cUnDefine++] = argv[1];
                if (cUnDefine > cDefineMax) {
                    SET_MSG(Msg_Text, sizeof(Msg_Text), GET_MSG(1104), argv[1]);
                    quit(Msg_Text);
                }
                break;

            case 'V':
                fVerbose = TRUE; // AFX doesn't set this
                goto MaybeMore;

            case 'W':
                fWarnInvalidCodePage = TRUE; // Invalid Codepage is a warning, not an error.
                goto MaybeMore;

            case 'Y':
                fSkipDuplicateCtlIdWarning = TRUE;
                goto MaybeMore;

            case 'X':
                /* remember not to add INCLUDE path */
                fInclude = FALSE;

                // VC seems to feel the current dir s/b added first no matter what...
                // If -X! is specified, don't do that.
                if (argv[1][2] == '!') {
                    fIncludeCurrentFirst = FALSE;
                    argv[1]++;
                }

MaybeMore:      /* check to see if multiple switches, like -xrv */
                if (argv[1][2]) {
                    argv[1][1] = '-';
                    argv[1]++;
                    continue;
                }
                break;

            case 'Z':

                /* if not attached to switch, skip to next */
                if (argv[1][2])
                    argv[1] += 2;
                else {
                    argc--;
                    argv++;
                }

                if (!argv[1])
                    quit(GET_MSG(1211));

                s3 = strchr(argv[1], '/');
                if (s3 == NULL)
                    quit(GET_MSG(1212));

                *s3 = '\0';
                MultiByteToWideChar(CP_ACP, MB_PRECOMPOSED, s3+1, -1, szSubstituteFontName, MAXTOKSTR);

                s1 = argv[1];
                do {
                    s2 = strchr(s1, ',');
                    if (s2 != NULL)
                        *s2 = '\0';

                    if (strlen(s1)) {
                        if (nBogusFontNames >= 16)
                            quit(GET_MSG(1213));

                        pszBogusFontNames[nBogusFontNames] = (WCHAR *) MyAlloc((strlen(s1)+1) * sizeof(WCHAR));
                        MultiByteToWideChar(CP_ACP, MB_PRECOMPOSED, s1, -1, pszBogusFontNames[nBogusFontNames], MAXTOKSTR);
                        nBogusFontNames += 1;
                    }

                    if (s2 != NULL)
                        *s2++ = ',';
                    }
                while (s1 = s2);

                *s3 =  '/';

                while (*argv[1]++ != 0)
                    ;
                break;

            default:
                SET_MSG(Msg_Text, sizeof(Msg_Text), GET_MSG(1106), argv[1]);
                quit(Msg_Text);
        }

        /* get next argument or switch */
        argc--;
        argv++;
    }

    /* make sure we have at least one file name to work with */
    if (argc != 2 || *argv[1] == '\0')
        quit(GET_MSG(1107));

    if (fVerbose) {
        SET_MSG(Msg_Text, sizeof(Msg_Text), GET_MSG(10001),
                VER_PRODUCTVERSION_STR, VER_PRODUCTBUILD);
        printf(Msg_Text);
        printf("%s\n", GET_MSG(10002));
    }

    // Support Multi Code Page

    //  If user did NOT indicate code in command line, we have to set Default
    //     for NLS Conversion

    if (uiCodePage == 0) {

        CHAR *pchCodePageString;

        /* At first, search ENVIRONMENT VALUE */

        if ((pchCodePageString = getenv("RCCODEPAGE")) != NULL) {
            uiCodePage = atoi(pchCodePageString);

            if (uiCodePage == 0 || !IsValidCodePage(uiCodePage))
                quit(GET_MSG(1207));
        } else {
            /* We use System ANSI Code page (ACP) */
            uiCodePage = GetACP();
        }
    }
    uiDefaultCodePage = uiCodePage;
    if (fVerbose)
        printf("Using codepage %d as default\n", uiDefaultCodePage);

    /* If we have no extension, assumer .rc                             */
    /* If .res extension, make sure we have -fo set, or error           */
    /* Otherwise, just assume file is .rc and output .res (or resname)  */

    //
    // We have to be careful upper casing this, because the codepage
    // of the filename might be in something other than current codepage.
    //
//    MultiByteToWideChar(uiCodePage, MB_PRECOMPOSED, argv[1], -1, tokenbuf, MAXSTR+1);
//    if (CharUpperBuff(tokenbuf, wcslen(tokenbuf)) == 0)
//        _wcsupr(tokenbuf);
//    WideCharToMultiByte(uiCodePage, 0, tokenbuf, -1, argv[1], strlen(argv[1]), NULL, NULL);
    _splitpath(argv[1], szDrive, szDir, szFName, szExt);

    if (!(*szDir || *szDrive)) {
        strcpy(szIncPath, ".;");
    } else {
        strcpy(szIncPath, szDrive);
        strcat(szIncPath, szDir);
        strcat(szIncPath, ";.;");
    }

    if ((strlen(szIncPath) + 1 + strlen(pchInclude)) >= cchIncludeMax) {
        cchIncludeMax = strlen(pchInclude) + strlen(szIncPath) + _MAX_PATH*2;
        pchIncludeT = (PCHAR) MyAlloc(cchIncludeMax);
        strcpy(pchIncludeT, pchInclude);
        MyFree(pchInclude);
        pchInclude = pchIncludeT;
        pchIncludeT = pchInclude + strlen(pchIncludeT) + 1;
    }

    pchIncludeT = (PCHAR) MyAlloc(cchIncludeMax);

    if (fIncludeCurrentFirst) {
        strcpy(pchIncludeT, szIncPath);
        strcat(pchIncludeT, pchInclude);
    } else {
        strcpy(pchIncludeT, pchInclude);
        strcat(pchIncludeT, ";");
        strcat(pchIncludeT, szIncPath);
    }

    MyFree(pchInclude);
    pchInclude = pchIncludeT;
    pchIncludeT = pchInclude + strlen(pchIncludeT) + 1;

    if (!szExt[0]) {
        strcpy(szExt, ".RC");
    } else if (strcmp (szExt, ".RES") == 0) {
        quit (GET_MSG(1208));
    }

    _makepath(inname, szDrive, szDir, szFName, szExt);
    if (fPreprocessOnly) {
        _makepath(szPreProcessName, NULL, NULL, szFName, ".rcpp");
    }

    /* Create the name of the .RES file */
    if (resname[0] == 0) {
        // if building a Mac resource file, we use .rsc to match mrc's output
        _makepath(resname, szDrive, szDir, szFName, fMacRsrcs ? ".RSC" : ".RES");
    }

    /* create the temporary file names */
    szTempFileName = (PCHAR) MyAlloc(_MAX_PATH);

    _fullpath(szFullPath, resname, _MAX_PATH);
    _splitpath(szFullPath, szDrive, szDir, NULL, NULL);

    _makepath(szTempFileName, szDrive, szDir, "RCXXXXXX", "");
    _mktemp (szTempFileName);
    szTempFileName2 = (PCHAR) MyAlloc(_MAX_PATH);
    _makepath(szTempFileName2, szDrive, szDir, "RDXXXXXX", "");
    _mktemp (szTempFileName2);

    ppargv = szRCPP;
    pfRcppAlloc = fRcppAlloc;
    *ppargv++ = "RCPP";
    *pfRcppAlloc++ = FALSE;
    rcpp_argc = 1;

    /* Open the .RES file (deleting any old versions which exist). */
    if ((fhBin = fopen(resname, "w+b")) == NULL) {
        SET_MSG(Msg_Text, sizeof(Msg_Text), GET_MSG(1109), resname);
        quit(Msg_Text);
    } else {
        if (fMacRsrcs)
            MySeek(fhBin, MACDATAOFFSET, 0);
        if (fVerbose) {
            SET_MSG(Msg_Text, sizeof(Msg_Text), GET_MSG(10102), resname);
            printf(Msg_Text);
        }

        /* Set up for RCPP. This constructs the command line for it. */
        *ppargv++ = _strdup("-CP");
        *pfRcppAlloc++ = TRUE;
        rcpp_argc++;

        _itoa(uiCodePage, buf, 10);
        *ppargv++ = buf;
        *pfRcppAlloc++ = FALSE;
        rcpp_argc++;

        *ppargv++ = _strdup("-f");
        *pfRcppAlloc++ = TRUE;
        rcpp_argc++;

        *ppargv++ = _strdup(szTempFileName);
        *pfRcppAlloc++ = TRUE;
        rcpp_argc++;

        *ppargv++ = _strdup("-g");
        *pfRcppAlloc++ = TRUE;
        rcpp_argc++;
        if (fPreprocessOnly) {
            *ppargv++ = _strdup(szPreProcessName);
        } else {
            *ppargv++ = _strdup(szTempFileName2);
        }
        *pfRcppAlloc++ = TRUE;
        rcpp_argc++;

        *ppargv++ = _strdup("-DRC_INVOKED");
        *pfRcppAlloc++ = TRUE;
        rcpp_argc++;

        if (fAFXSymbols) {
            *ppargv++ = _strdup("-DAPSTUDIO_INVOKED");
            *pfRcppAlloc++ = TRUE;
            rcpp_argc++;
        }

        if (fMacRsrcs) {
            *ppargv++ = _strdup("-D_MAC");
            *pfRcppAlloc++ = TRUE;
            rcpp_argc++;
        }

        *ppargv++ = _strdup("-D_WIN32"); /* to be compatible with C9/VC++ */
        *pfRcppAlloc++ = TRUE;
        rcpp_argc++;

        *ppargv++ = _strdup("-pc\\:/");
        *pfRcppAlloc++ = TRUE;
        rcpp_argc++;

        *ppargv++ = _strdup("-E");
        *pfRcppAlloc++ = TRUE;
        rcpp_argc++;

        /* Parse the INCLUDE environment variable */

        if (fInclude) {

            *ppargv++ = _strdup("-I.");
            *pfRcppAlloc++ = TRUE;
            rcpp_argc++;

            /* add seperator if any -I switches */
            if (pchInclude != pchIncludeT)
                pchIncludeT[-1] = ';';

            /* read 'em */
            x = getenv("INCLUDE");
            if (x == (PCHAR)NULL) {
                *pchIncludeT = '\000';
            } else {
                if (strlen(pchInclude) + strlen(x) + 1 >= cchIncludeMax) {
                    cchIncludeMax = strlen(pchInclude) + strlen(x) + _MAX_PATH*2;
                    pchIncludeT = (PCHAR) MyAlloc(cchIncludeMax);
                    strcpy(pchIncludeT, pchInclude);
                    MyFree(pchInclude);
                    pchInclude = pchIncludeT;
                }

                strcat(pchInclude, x);
                pchIncludeT = pchInclude + strlen(pchInclude);
            }
        }

        /* now put includes on the RCPP command line */
        for (x = pchInclude ; *x ; ) {

            r = x;
            while (*x && *x != ';')
                x = CharNextA(x);

            /* mark if semicolon */
            if (*x)
                *x-- = 0;

            if (*r != '\0' &&       /* empty include path? */
                *r != '%'           /* check for un-expanded stuff */
                // && strchr(r, ' ') == NULL  /* check for whitespace */
                ) {
                /* add switch */
                *ppargv++ = _strdup("-I");
                *pfRcppAlloc++ = TRUE;
                rcpp_argc++;

                *ppargv++ = _strdup(r);
                *pfRcppAlloc++ = TRUE;
                rcpp_argc++;
            }

            /* was semicolon, need to fix for searchenv() */
            if (*x) {
                *++x = ';';
                x++;
            }
        }

        /* include defines */
        for (n = 0; n < cDefine; n++) {
            *ppargv++ = _strdup("-D");
            *pfRcppAlloc++ = TRUE;
            rcpp_argc++;

            *ppargv++ = pszDefine[n];
            *pfRcppAlloc++ = FALSE;
            rcpp_argc++;
        }

        /* include undefine */
        for (n = 0; n < cUnDefine; n++) {
            *ppargv++ = _strdup("-U");
            *pfRcppAlloc++ = TRUE;
            rcpp_argc++;

            *ppargv++ = pszUnDefine[n];
            *pfRcppAlloc++ = FALSE;
            rcpp_argc++;
        }

        if (rcpp_argc > MAX_CMD) {
            quit(GET_MSG(1102));
        }
        if (fVerbose) {
            /* echo the preprocessor command */
            printf("RC:");
            for (n = 0 ; n < rcpp_argc ; n++) {
                wsprintfA(Msg_Text, " %s", szRCPP[n]);
                printf(Msg_Text);
            }
            printf("\n");
        }

        /* Add .rc with rcincludes into szTempFileName */
        if (!RC_PreProcess(inname))
            quit(Msg_Text);

        /* Run the Preprocessor. */
        if (RCPP(rcpp_argc, szRCPP, NULL) != 0)
            quit(GET_MSG(1116));

        // All done.  Now free up the argv array.
        for (n = 0 ; n < rcpp_argc ; n++) {
            if (fRcppAlloc[n] == TRUE) {
                free(szRCPP[n]);
            }
        }
    }

    if (fPreprocessOnly) {
        sprintf(szBuf, "Preprocessed File Created in: %s\n", szPreProcessName);
        quit(szBuf);
    }

    if (fVerbose)
        printf("\n%s", inname);

    if ((fhInput = fopen(szTempFileName2, "rb")) == NULL_FILE)
        quit(GET_MSG(2180));

    if (!InitSymbolInfo())
        quit(GET_MSG(22103));

    LexInit (fhInput);
    uiCodePage = uiDefaultCodePage;
    ReadRF();               /* create .RES from .RC */
    if (!TermSymbolInfo(fhBin))
        quit(GET_MSG(22204));

    if (!fMacRsrcs)
        MyAlign(fhBin); // Pad end of file so that we can concatenate files

    CleanUpFiles();

    HeapDestroy(hHeap);

    return Nerrors;   // return success, not quitting.
}


/*  RCInit
 *      Initializes this run of RC.
 */

HANDLE
RCInit(
    void
    )
{
    Nerrors    = 0;
    uiCodePage = 0;
    nFontsRead = 0;

    szTempFileName = NULL;
    szTempFileName2 = NULL;

    lOffIndex = 0;
    idBase = 128;
    pTypInfo = NULL;

    fVerbose = FALSE;
    fMacRsrcs = FALSE;

    // Clear the filenames
    exename[0] = 0;
    resname[0] = 0;

    /* create growable local heap of 16MB minimum size */
    return HeapCreate(HEAP_NO_SERIALIZE, 0, 0);
}


/*---------------------------------------------------------------------------*/
/*                                                                           */
/*  skipblanks() -                                                           */
/*                                                                           */
/*---------------------------------------------------------------------------*/

PWCHAR
skipblanks(
    PWCHAR pstr,
    int fTerminate
    )
{
    /* search forward for first non-white character and save its address */
    while (*pstr && iswspace(*pstr))
        pstr++;

    if (fTerminate) {
        PWCHAR retval = pstr;

        /* search forward for first white character and zero to extract word */
        while (*pstr && !iswspace(*pstr))
            pstr++;
        *pstr = 0;
        return retval;
    } else {
        return pstr;
    }
}


/*---------------------------------------------------------------------------*/
/*                                                                           */
/*  RC_PreProcess() -                                                        */
/*                                                                           */
/*---------------------------------------------------------------------------*/

BOOL
RC_PreProcess(
    PCHAR szname
    )
{
    PFILE fhout;        /* fhout: is temp file with rcincluded stuff */
    PFILE fhin;
    CHAR nm[_MAX_PATH*2];
    PCHAR pch;
    PWCHAR pwch;
    PWCHAR pfilename;
    WCHAR readszbuf[READ_MAX];
    WCHAR szT[ MAXSTR ];
    UINT iLine = 0;
    int fBlanks = TRUE;
    INT fFileType;

    /* Open the .RC source file. */
    MultiByteToWideChar(uiCodePage, MB_PRECOMPOSED, szname, -1, Filename, MED_BUFFER+1);
    fhin = fopen(szname, "rb");
    if (!fhin) {
        SET_MSG(Msg_Text, sizeof(Msg_Text), GET_MSG(1110), szname);
        return(FALSE);
    }

    /* Open the temporary output file. */
    fhout = fopen(szTempFileName, "w+b");
    if (!fhout) {
        strcpy(Msg_Text, GET_MSG(2180));
        return(FALSE);
    }

    /* output the current filename for RCPP messages */
    for (pch=nm ; *szname ; szname = CharNextA(szname)) {
        *pch++ = *szname;
        if (IsDBCSLeadByteEx(uiCodePage, *szname))
            *pch++ = *(szname + 1);
        /* Hack to fix bug #8786: makes '\' to "\\" */
        else if (*szname == '\\')
            *pch++ = '\\';
    }
    *pch++ = '\000';

    /* Output the current filename for RCPP messages */
    wcscpy(szT, L"#line 1\"");
    // hack - strlen("#line 1\"") is 8.
    MultiByteToWideChar(uiCodePage, MB_PRECOMPOSED, nm, -1, szT+8, MAXSTR+1-8);
    wcscat(szT, L"\"\r\n");
    MyWrite(fhout, szT, wcslen(szT) * sizeof(WCHAR));

    /* Determine if the input file is Unicode */
    fFileType = DetermineFileType (fhin);

    /* Process each line of the input file. */
    while (fgetl(readszbuf, READ_MAX, fFileType == DFT_FILE_IS_16_BIT, fhin)) {

        /* keep track of the number of lines read */
        Linenumber = iLine++;

        if ((iLine & RC_PREPROCESS_UPDATE) == 0)
            UpdateStatus(1, iLine);

        /* Skip the Byte Order Mark and the leading bytes. */
        pwch = readszbuf;
        while (*pwch && (iswspace(*pwch) || *pwch == 0xFEFF))
            pwch++;

        /* if the line is a rcinclude line... */
        if (strpre(L"rcinclude", pwch)) {
            /* Get the name of the rcincluded file. */
            pfilename = skipblanks(pwch + 9, TRUE);

            MyWrite(fhout, L"#include \"", 10 * sizeof(WCHAR));
            MyWrite(fhout, pfilename, wcslen(pfilename) * sizeof(WCHAR));
            MyWrite(fhout, L"\"\r\n", 3 * sizeof(WCHAR));

        } else if (strpre(L"#pragma", pwch)) {
            WCHAR cSave;

            pfilename = skipblanks(pwch + 7, FALSE);
            if (strpre(L"code_page", pfilename)) {
                pfilename = skipblanks(pfilename + 9, FALSE);
                if (*pfilename == L'(') {
                    ULONG cp = 0;

                    pfilename = skipblanks(pfilename + 1, FALSE);
                    // really should allow hex/octal, but ...
                    if (iswdigit(*pfilename)) {
                        while (iswdigit(*pfilename)) {
                            cp = cp * 10 + (*pfilename++ - L'0');
                        }
                        pfilename = skipblanks(pfilename, FALSE);
                    } else if (strpre(L"default", pfilename)) {
                        cp = uiDefaultCodePage;
                        pfilename = skipblanks(pfilename + 7, FALSE);
                    }

                    if (cp == 0) {
                        wsprintfA(Msg_Text, "%s%ws", GET_MSG(4212), pfilename);
                        error(4212);
                    } else if (*pfilename != L')') {
                        strcpy (Msg_Text, GET_MSG (4211));
                        error(4211);
                    } else if (cp == CP_WINUNICODE) {
                        strcpy (Msg_Text, GET_MSG (4213));
                        if (fWarnInvalidCodePage) {
                            warning(4213);
                        } else {
                            fatal(4213);
                        }
                    } else if (!IsValidCodePage(cp)) {
                        strcpy (Msg_Text, GET_MSG (4214));
                        if (fWarnInvalidCodePage) {
                            warning(4214);
                        } else {
                            fatal(4214);
                        }
                    } else {
                        uiCodePage = cp;
                        /* Copy the #pragma line to the temp file. */
                        MyWrite(fhout, pwch, wcslen(pwch) * sizeof(WCHAR));
                        MyWrite(fhout, L"\r\n", 2 * sizeof(WCHAR));
                    }
                } else {
                    strcpy (Msg_Text, GET_MSG (4210));
                    error(4210);
                }
            }
        } else if (!*pwch) {
            fBlanks = TRUE;
        } else {
            if (fBlanks) {
                swprintf(szT, L"#line %d\r\n", iLine);
                MyWrite(fhout, szT, wcslen(szT) * sizeof(WCHAR));
                fBlanks = FALSE;
            }
            /* Copy the .RC line to the temp file. */
            MyWrite(fhout, pwch, wcslen(pwch) * sizeof(WCHAR));
            MyWrite(fhout, L"\r\n", 2 * sizeof(WCHAR));
        }
    }

    lCPPTotalLinenumber = iLine;
    Linenumber = 0;

    uiCodePage = uiDefaultCodePage;

    fclose(fhout);
    fclose(fhin);

    return(TRUE);
}


/*---------------------------------------------------------------------------*/
/*                                                                           */
/*  quit()                                                                   */
/*                                                                           */
/*---------------------------------------------------------------------------*/

VOID
quit(
    PSTR str
    )
{
    /* print out the error message */
    if (str) {
        SendError("\n");
        SendError(str);
        SendError("\n");
    }

    CleanUpFiles();

    /* delete output file */
    if (resname)
        remove(resname);

    if (hHeap)
        HeapDestroy(hHeap);

    Nerrors++;
    longjmp(jb, Nerrors);
}

#ifdef __cplusplus
extern "C"
#endif
BOOL WINAPI
Handler(
    DWORD fdwCtrlType
    )
{
    if (fdwCtrlType == CTRL_C_EVENT) {
        SendError("\n");
        SET_MSG(Msg_Text, sizeof(Msg_Text), GET_MSG(20101));
        SendError(Msg_Text);
        CleanUpFiles();

        HeapDestroy(hHeap);

        /* delete output file */
        if (resname)
            remove(resname);

        return(FALSE);
    }

    return(FALSE);
}


VOID
CleanUpFiles(
    void
    )
{
    TermSymbolInfo(NULL_FILE);

    /* Close ALL files. */
    if (fhBin != NULL)
        fclose(fhBin);
    if (fhInput != NULL)
        fclose(fhInput);
    if (fhCode != NULL)
        fclose(fhCode);
    p0_terminate();

    /* clean up after font directory temp file */
    if (nFontsRead)
        remove("rc$x.fdr");

    /* delete the temporary files */
    if (szTempFileName)
        remove(szTempFileName);
    if (szTempFileName2)
        remove(szTempFileName2);
    if (Nerrors > 0)
        remove(resname);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\rcdll\rcdefs.h ===
/*
** RCDEFS.H
**
** author:  JeffBog
**
** Change Log
**	FloydR	3/7/94	Renamed from rcdll.h
*/

#ifndef _RCDEFS_H
#define _RCDEFS_H

#ifdef __cplusplus
extern "C" {
#endif  /* __cplusplus */

#define RC_OK			1
#define RC_FAILED		0
#define RC_CANCELED		-1

#define WM_RC_ERROR 	(0x0400+0x0019)
#define WM_RC_STATUS    (0x0400+0x0020)


// How often do I update status information (lineo & RC_xxx == 0)
#define RC_PREPROCESS_UPDATE	63
#define RC_COMPILE_UPDATE		31
extern void UpdateStatus(unsigned nCode, unsigned long dwStatus);

#define MAX_SYMBOL 247 /* from ApStudio */

typedef int (CALLBACK *RC_MESSAGE_CALLBACK)(ULONG, ULONG, PCHAR);

typedef struct tagRESINFO_PARSE
{
	LONG size;
	PWCHAR type;
	USHORT typeord;
	PWCHAR name;
	USHORT nameord;
	WORD flags;
	WORD language;
	DWORD version;
	DWORD characteristics;
} RESINFO_PARSE, *PRESINFO_PARSE;

typedef struct tagCONTEXTINFO_PARSE
{
	HANDLE hHeap;
	HWND hWndCaller;
	RC_MESSAGE_CALLBACK lpfnMsg;
	unsigned line;
	PCHAR format;
} CONTEXTINFO_PARSE, *PCONTEXTINFO_PARSE;

typedef int (CALLBACK *RC_PARSE_CALLBACK)(PRESINFO_PARSE lpRes, void** lplpData,
	PCONTEXTINFO_PARSE lpContext);

typedef int (CALLBACK *RCPROC)(HWND hWndCaller, int fStatus,
		RC_MESSAGE_CALLBACK lpfnMsg, RC_PARSE_CALLBACK lpfnParse,
		int argc,	PCHAR* argv);

int CALLBACK RC(HWND hWndCaller, int fStatus,
		RC_MESSAGE_CALLBACK lpfnMsg, RC_PARSE_CALLBACK lpfnParse,
		int argc, PCHAR* argv);

int RCPP(int argc, PCHAR *argv, PCHAR env);

#define RC_ORDINAL (MAKEINTRESOURCE(2))

#ifdef __cplusplus
}
#endif

#endif // _RCDEFS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\rcdll\rcdll.c ===
/****************************************************************************/
/*                                                                          */
/*  RCDLL.C -                                                               */
/*                                                                          */
/*    Windows 3.5 Resource Compiler - Main Module                           */
/*                                                                          */
/*                                                                          */
/****************************************************************************/

#include "rc.h"
#include <setjmp.h>


/* Module handle */
HINSTANCE hInstance;
HWND      hWndCaller;

RC_MESSAGE_CALLBACK  lpfnMessageCallback;
RC_PARSE_CALLBACK lpfnParseCallback;


/* Function prototypes */
int __cdecl rc_main(int, char**);
int __cdecl rcpp_main(int argc, PWCHAR*argv);


#ifdef __cplusplus
extern "C"
#endif
BOOL
WINAPI
DllMain(
    HINSTANCE hDll,
    DWORD dwReason,
    LPVOID lpReserved
    )
{
    if (dwReason == DLL_PROCESS_ATTACH) {
        hInstance = hDll;
        DisableThreadLibraryCalls(hDll);
    }
    return TRUE;
}


#ifdef __cplusplus
extern "C"
#endif
int CALLBACK
RC(
    HWND hWnd,
    int fStatus,
    RC_MESSAGE_CALLBACK lpfnMsg,
    RC_PARSE_CALLBACK lpfnParse,
    int argc,
    char**argv
    )
{
    hWndCaller     = hWnd;

    lpfnMessageCallback = lpfnMsg;
    lpfnParseCallback = lpfnParse;

    return (rc_main(argc, argv));
}


int
RCPP(
    int argc,
    PCHAR *argv,
    PCHAR env
    )
{
    WCHAR    **wargv;

    wargv = UnicodeCommandLine(argc, argv);
    return rcpp_main(argc, wargv);
}


void
SendWarning(
    PSTR str
    )
{
    if (lpfnMessageCallback)
        (*lpfnMessageCallback)(0, 0, str);

    if (hWndCaller) {
        if (SendMessageA(hWndCaller, WM_RC_ERROR, FALSE, (LPARAM)str) != 0) {
            quit("\n");
        }
    }
}

void
SendError(
    PSTR str
    )
{
    static int cErrThisLine = 0;
    static int LastRow = 0;

    if (lpfnMessageCallback)
        (*lpfnMessageCallback)(0, 0, str);

    if (hWndCaller) {
        if (SendMessageA(hWndCaller, WM_RC_ERROR, FALSE, (LPARAM)str) != 0) {
            quit("\n");
        }
    }

    if (token.row == LastRow) {
        if (++cErrThisLine > 4 && strcmp(str, "\n"))
            quit("\n");
    } else {
        LastRow = token.row;
        cErrThisLine = 0;
    }
}


void
UpdateStatus(
    unsigned nCode,
    unsigned long dwStatus
    )
{
    if (hWndCaller) {
        if (SendMessageA(hWndCaller, WM_RC_STATUS, nCode, dwStatus) != 0) {
            quit("\n");
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\rcdll\rcl.c ===
/****************************************************************************/
/*                                                                          */
/*  RCL.C -                                                                 */
/*                                                                          */
/*    Windows 3.0 Resource Compiler - Lexical analyzer                      */
/*                                                                          */
/*                                                                          */
/****************************************************************************/

#include "rc.h"


#define EOLCHAR L';'
#define STRCHAR L'"'
#define CHRCHAR L'\''
#define SGNCHAR L'-'
#define iswhite( c ) ((c != SYMUSESTART) && (c != SYMDEFSTART) &&\
        ((WCHAR)c <= L' ') ? TRUE : FALSE)

static WCHAR  curChar;
static WCHAR  curCharFTB;   /* Cur char From Token Buf */
static PWCHAR CurPtrTB;
static PFILE  inpfh;
static int    curLin, curCol;

extern BOOL bExternParse;


/* Must be sorted */
KEY keyList[] =
{
    { L"ALT",              TKALT },
    { L"ASCII",            TKASCII },
    { L"AUTO3STATE",       TKAUTO3 },
    { L"AUTOCHECKBOX",     TKAUTOCHECK },
    { L"AUTORADIOBUTTON",  TKAUTORADIO },
    { L"BEGIN",            BEGIN },
    { L"BEDIT",            TKBEDIT },
    { L"BITMAP",           TKBITMAP },
    { L"BLOCK",            TKBLOCK },
    { L"BUTTON",           TKBUTTON },
    { L"CAPTION",          TKCAPTION },
    { L"CHARACTERISTICS",  TKCHARACTERISTICS },
    { L"CHECKBOX",         TKCHECKBOX },
    { L"CHECKED",          TKCHECKED },
    { L"CLASS",            TKCLASS },
    { L"COMBOBOX",         TKCOMBOBOX },
    { L"CONTROL",          TKCONTROL },
    { L"CTEXT",            TKCTEXT },
    { L"DEFPUSHBUTTON",    TKDEFPUSHBUTTON },
    { L"DISCARDABLE",      TKDISCARD },
    { L"DLGINCLUDE",       TKDLGINCLUDE },
    { L"DLGINIT",          TKDLGINIT },
    { L"EDIT",             TKEDIT },
    { L"EDITTEXT",         TKEDITTEXT },
    { L"END",              END },
    { L"EXSTYLE",          TKEXSTYLE },
    { L"FILEFLAGS",        TKFILEFLAGS },
    { L"FILEFLAGSMASK",    TKFILEFLAGSMASK },
    { L"FILEOS",           TKFILEOS },
    { L"FILESUBTYPE",      TKFILESUBTYPE },
    { L"FILETYPE",         TKFILETYPE },
    { L"FILEVERSION",      TKFILEVERSION },
    { L"FIXED",            TKFIXED },
    { L"FONT",             TKFONT },
    { L"GRAYED",           TKGRAYED },
    { L"GROUPBOX",         TKGROUPBOX },
    { L"HEDIT",            TKHEDIT },
    { L"HELP",             TKHELP },
    { L"ICON",             TKICON },
    { L"IEDIT",            TKIEDIT },
    { L"IMPURE",           TKIMPURE },
    { L"INACTIVE",         TKINACTIVE },
    { L"LANGUAGE",         TKLANGUAGE },
    { L"LISTBOX",          TKLISTBOX },
    { L"LOADONCALL",       TKLOADONCALL },
    { L"LTEXT",            TKLTEXT },
    { L"MENU",             TKMENU },
    { L"MENUBARBREAK",     TKBREAKWBAR },
    { L"MENUBREAK",        TKBREAK },
    { L"MENUITEM",         TKMENUITEM },
    { L"MESAGETABLE",      TKMESSAGETABLE },
    { L"MOVEABLE",         TKMOVEABLE },
    { L"NOINVERT",         TKNOINVERT },
    { L"NONSHARED",        TKIMPURE },
    { L"NOT",              TKNOT },
    { L"OWNERDRAW",        TKOWNERDRAW },
    { L"POPUP",            TKPOPUP },
    { L"PRELOAD",          TKPRELOAD },
    { L"PRODUCTVERSION",   TKPRODUCTVERSION },
    { L"PURE",             TKPURE },
    { L"PUSHBOX",          TKPUSHBOX },
    { L"PUSHBUTTON",       TKPUSHBUTTON },
    { L"RADIOBUTTON",      TKRADIOBUTTON },
    { L"RCDATA",           TKRCDATA },
    { L"RTEXT",            TKRTEXT },
    { L"SCROLLBAR",        TKSCROLLBAR },
    { L"SEPARATOR",        TKSEPARATOR },
    { L"SHARED",           TKPURE },
    { L"SHIFT",            TKSHIFT },
    { L"STATE3",           TK3STATE },
    { L"STATIC",           TKSTATIC },
    { L"STYLE",            TKSTYLE },
    { L"USERBUTTON",       TKUSERBUTTON },
    { L"VALUE",            TKVALUE },
    { L"VERSION",          TKVERSION },
    { L"VIRTKEY",          TKVIRTKEY },
    { NULL,                0 }
};


SKEY skeyList[] =
{
    { L',', COMMA },
    { L'|', OR },
    { L'(', LPAREN },
    { L')', RPAREN },
    { L'{', BEGIN },
    { L'}', END },
    { L'~', TILDE },
    { L'+', TKPLUS },
    { L'-', TKMINUS },
    { L'&', AND },
    { L'=', EQUAL },
    { EOFMARK, EOFMARK },
    { L'\000', 0 }
};


/*---------------------------------------------------------------------------*/
/*                                                                           */
/*  LexInit() -                                                              */
/*                                                                           */
/*---------------------------------------------------------------------------*/

int
LexInit(
    PFILE fh
    )
{
    /* zero errors so far */
    errorCount = 0;
    curLin = 1;
    curCol = 0;
    inpfh = fh;

    /* Read initial character */
    OurGetChar();

    return TRUE;
}


/*---------------------------------------------------------------------------*/
/*                                                                           */
/*  GetCharFTB() -                                                           */
/*                                                                           */
/*---------------------------------------------------------------------------*/
WCHAR
GetCharFTB(
    void
    )
{
    return(curCharFTB = *CurPtrTB++);
}


/*---------------------------------------------------------------------------*/
/*                                                                           */
/*  OurGetChar() -                                                           */
/*                                                                           */
/*  Read a character, treating semicolon as an end of line comment char      */
/*                                                                           */
/*---------------------------------------------------------------------------*/

WCHAR
OurGetChar(
    void
    )
{
    if ((LitChar() != EOFMARK) && (curChar == CHCOMMENT))
        // if comment, HARD LOOP until EOLN
        while ((LitChar() != EOFMARK) && (curChar != CHNEWLINE));

    return(curChar);
}


/*---------------------------------------------------------------------------*/
/*                                                                           */
/*  FileChar() -                                                             */
/*                                                                           */
/*---------------------------------------------------------------------------*/

int
FileChar(
    void
    )
{
    static WCHAR rgchLine[MAXSTR];
    static int   ibNext = MAXSTR;
    int          cch, ch;

    if (ibNext >= MAXSTR) {
        ibNext = 0;
        cch = MyRead (inpfh, rgchLine, MAXSTR * sizeof(WCHAR));
        if (cch < (MAXSTR * sizeof(WCHAR))) {
            fclose(inpfh);
            // NULL terminate the input buffer
            *(rgchLine + (cch / sizeof(WCHAR))) = L'\0';
        }
    }

    if ((ch = rgchLine[ibNext]) != 0)
        ibNext++;

    return(ch);
}

/*---------------------------------------------------------------------------*/
/*                                                                           */
/*  CopyToken() -                                                            */
/*                                                                           */
/*---------------------------------------------------------------------------*/
void
CopyToken(
    PTOKEN ptgt_token,
    PTOKEN psrc_token
    )
{
    ptgt_token->longval  = psrc_token->longval;
    ptgt_token->row      = psrc_token->row;
    ptgt_token->col      = psrc_token->col;
    ptgt_token->flongval = psrc_token->flongval;
    ptgt_token->val      = psrc_token->val;
    ptgt_token->type     = psrc_token->type;
    ptgt_token->realtype = psrc_token->realtype;

    wcscpy(ptgt_token->sym.name, psrc_token->sym.name);
    wcscpy(ptgt_token->sym.file, psrc_token->sym.file);
    ptgt_token->sym.line = psrc_token->sym.line;
    ptgt_token->sym.nID  = psrc_token->sym.nID;
}

/*---------------------------------------------------------------------------*/
/*                                                                           */
/*  LitChar() -                                                              */
/*                                                                           */
/*---------------------------------------------------------------------------*/

/* Read a literal character, without interpreting EOL comments */

WCHAR
LitChar(
    void
    )
{
    static int  fNewLine = TRUE;
    int fIgnore = FALSE;
    int fBackSlash = FALSE;
    int fDot;
    PWCHAR      pch;
    WCHAR buf[ _MAX_PATH ];
    TOKEN token_save;

    for (; ; ) {
        switch (curChar = (WCHAR)FileChar()) {
            case 0:
                curChar = EOFMARK;
                goto char_return;

            case 0xFEFF:     // skip Byte Order Mark
                continue;

            case SYMDEFSTART:
            {
                int fNewLineSave = fNewLine;
                GetSymbolDef(TRUE, curChar);
                fNewLine = fNewLineSave;
                break;
            }

            case CHCARRIAGE:
                curChar = CHSPACE;
                if (!fIgnore)
                    goto char_return;
                break;

            case CHNEWLINE:
                fNewLine = TRUE;
                curLin++;
                {
                    static long lTotalLin = 0;
                    if ((lTotalLin++ & RC_COMPILE_UPDATE) == 0)
                        UpdateStatus(2, lTotalLin);
                }

                if (!fIgnore)
                    goto char_return;
                break;

                /* skip whitespace before #line - don't clear fNewLine */
            case CHSPACE:
            case CHTAB:
                if (!fIgnore)
                    goto char_return;
                break;

            case CHDIRECTIVE:
                if (fNewLine) {
                    WCHAR tch;

                    fDot = FALSE;

                    /* also, leave fNewLine set, since we read thru \n */

                    /* read the 'line' part */
                    if ((tch = (WCHAR)FileChar()) != L'l') {
                        if (tch == L'p') {
                            if (FileChar() != L'r')
                                goto DirectiveError;
                            if (FileChar() != L'a')
                                goto DirectiveError;
                            if (FileChar() != L'g')
                                goto DirectiveError;
                            if (FileChar() != L'm')
                                goto DirectiveError;
                            if (FileChar() != L'a')
                                goto DirectiveError;

                            /*
                            ** This is very specific, as any #pragma will
                            ** be a code_page pragma written by p0prepro.c.
                            */
                            CopyToken( &token_save, &token );

                            GetToken(FALSE);        /* get #pragma and ignore */
                            GetToken(FALSE);        /* get code_page and ignore */
                            GetToken(TOKEN_NOEXPRESSION);   /* get codepage value only*/
                                            /* don't check return value */
                            uiCodePage = token.val;     /* assume ok */
                            /* read through end of line */
                            while (curChar != CHNEWLINE) {
                                curChar = (WCHAR)FileChar();
                            }
                            CopyToken( &token, &token_save );
                            continue;
                        } else {
                            goto DirectiveError;
                        }
                    }
                    if (FileChar() != L'i')
                        goto DirectiveError;
                    if (FileChar() != L'n')
                        goto DirectiveError;
                    if (FileChar() != L'e')
                        goto DirectiveError;

                    /* up to filename, grabbing line number as we go */
                    /* note that curChar first contains '#', because */
                    /* we don't read a new character into curChar */
                    curLin = 0;
                    do {
                        if (curChar >= L'0' && curChar <= L'9') {
                            curLin *= 10;
                            curLin += curChar - L'0';
                        }
                        curChar = (WCHAR)FileChar();
                    } while (curChar != CHQUOTE && curChar != CHNEWLINE);

                    /* don't change curFile or fIgnore if this is just a
                     * #line <lineno>
                     */
                    if (curChar == CHNEWLINE)
                        break;

                    /* read the filename.  detect the presence of .c or .h */
                    pch = buf;
                    do {
                        curChar = (WCHAR)FileChar();
                        switch (towlower(curChar)) {

                            /* treat backslash like normal char, set flag. */
                            case L'\\':
                                if (fBackSlash) {
                                    fBackSlash = FALSE;
                                } else {
                                    fBackSlash = TRUE;
                                    fIgnore = FALSE;
                                    fDot = FALSE;
                                    *pch++ = curChar;
                                }
                                break;

                                /* line format sanity check: no embedded newlines */
                            case CHNEWLINE:
                            case 0:
DirectiveError:
                                LexError1(2101);

                                /* stop reading filename when we hit a quote */
                            case CHQUOTE:
                                break;

                                /* if we see a ., prepare to find extension */
                            case CHEXTENSION:
                                fBackSlash = FALSE;
                                fDot = TRUE;
                                *pch++ = curChar;
                                break;

                                /* if there's a C or H after a '.', its not RCINCLUDE'd */
                            case CHCSOURCE:
                            case CHCHEADER:
                                fBackSlash = FALSE;
                                fIgnore = fDot;
                                fDot = FALSE;
                                *pch++ = curChar;
                                break;

                                /* any other character in a file means the next character
                                won't be after a dot, and the last char up to now
                                wasn't C or H.
                                */

                            default:
                                fIgnore = FALSE;
                                fDot = FALSE;
                                *pch++ = curChar;
                                break;
                        }
                    } while (curChar != CHQUOTE);
                    *pch = 0;
                    WideCharToMultiByte(uiCodePage, 0, buf, -1, (LPSTR) curFile, _MAX_PATH, NULL, NULL);

                    /* read through end of line */
                    do {
                        curChar = (WCHAR)FileChar();
                    } while (curChar != CHNEWLINE);

                    break;
                }
                /* else, fall through, treat like normal char */

            default:
                fNewLine = FALSE;
                if (!fIgnore)
                    goto char_return;
        }
    }

char_return:
    if (bExternParse)
        *((WCHAR*) GetSpace(sizeof(WCHAR))) = curChar;

    return curChar;
}


/*---------------------------------------------------------------------------*/
/*                                                                           */
/*  GetStr() -                                                               */
/*                                                                           */
/*---------------------------------------------------------------------------*/
VOID
GetStr(
    void
    )
{
    PWCHAR  s;
    WCHAR   ch;
    WCHAR   temptok[ MAXSTR ];
    SHORT   i = 0;
    int     inc;
    UCHAR   Octal_Num;
    UCHAR   HexNum;

    /* token type is string literal */
    token.realtype = STRLIT;

    /*
    **  NB:  FloydR
    **  The use of token.realtype is a hack for RCDATA.
    **
    **  When we converted RC to be Unicode-based, all the
    **  separate "case STRLIT:" code was removed, and the LSTRLIT
    **  cases took over for them.  Alternatively, we could have
    **  left the STRLIT case, but removed the code it accessed
    **  and move the STRLIT case prior/after the LSTRLIT case,
    **  since they were now identical.  They were removed in favor
    **  of smaller/faster code.
    **
    **  However, RCDATA still had a need to discern the difference,
    **  so I added token.realtype, set it to STRLIT in GetStr(),
    **  set it to LSTRLIT in GetLStr() (below), and check it in
    **  GetRCData() in rctg.c.
    **
    */
    token.type = LSTRLIT;
    token.val = 0;
    s = tokenbuf;

    /* read string until " or EOF */
    while (LitChar() != EOFMARK)  {
        if (curChar == STRCHAR)
            if (OurGetChar() != STRCHAR)
                goto gotstr;

        if (token.val++ == MAXSTR)
            LexError1(2102); //"string literal too long"
        else
            *s++ = curChar;
    }
    if (curChar == EOFMARK)
        LexError1(2103); //"unexpected end of file in string literal"

gotstr:
    *s++ = 0;
    s = tokenbuf;

    /* process escape characters in the string */

    while (*s != 0)  {
        if (*s == L'\\')  {
            s++;
            if (*s == L'\\')
                temptok[i++] = L'\\';
            else if (*s == L'T' || *s == L't')
                temptok[i++] = L'\011';            /* Tab */
            else if (*s == 0x0a)                   /* continuation slash */
                ; /* ignore and let it go trough the s++ at the end so we skip the 0x0a char*/
            else if (*s == L'A' || *s == L'a')
                temptok[i++] = L'\010';            /* Right Align */
            else if (*s == L'n')
                temptok[i++] = fMacRsrcs ? 13 : 10;   /* linefeed */
            else if (*s == L'r')
                temptok[i++] = fMacRsrcs ? 10 : 13;   /* carriage return */
            else if (*s == L'"')
                temptok[i++] = L'"';               /* quote character */
            else if (*s == L'X' || *s == L'x')  {  /* Hexidecimal digit */
                USHORT wCount;

                HexNum = 0;
                ++s;
                for (wCount = 2 ;
                    wCount && iswxdigit((ch=(WCHAR)towupper(*s)));
                    --wCount)  {
                    if (ch >= L'A')
                        inc = ch - L'A' + 10;
                    else
                        inc = ch - L'0';
                    HexNum = HexNum * 16 + inc;
                    s++;
                }
                MultiByteToWideChar(uiCodePage, MB_PRECOMPOSED, (LPCSTR) &HexNum, 1, &temptok[i], 1);
                i++;
                s--;
            } else if (*s >= L'0' && *s <= L'7') {    /* octal character */
                USHORT wCount;

                Octal_Num = 0;
                for (wCount = 3; wCount && *s >= L'0' && *s <= L'7'; --wCount)  {
                    Octal_Num = (Octal_Num * 8 + (*s - L'0'));
                    s++;
                }
                MultiByteToWideChar(uiCodePage, MB_PRECOMPOSED, (LPCSTR) &Octal_Num, 1, &temptok[i], 1);
                i++;
                s--;
            }
            else {
                temptok[i++] = L'\\';
                s--;
            }
        } else
            temptok[i++] = *s;
        s++;
    }

    /* zero terminate */
    temptok[i] = L'\0';
    memcpy ( tokenbuf, temptok, sizeof(WCHAR)*(i + 1));
    token.val = (USHORT)i;
}


/*---------------------------------------------------------------------------*/
/*                                                                           */
/*  GetLStr() -                                                              */
/*                                                                           */
/*---------------------------------------------------------------------------*/
VOID
GetLStr(
    void
    )
{
    PWCHAR  s;
    WCHAR   ch;
    WCHAR   temptok[ MAXSTR ];
    SHORT   i = 0;
    int     inc;
    int     Octal_Num;
    int     HexNum;

    /* token type is string literal */
    token.realtype = token.type = LSTRLIT;
    token.val = 0;
    s = tokenbuf;

    /* read string until " or EOF */
    while (LitChar() != EOFMARK)  {
        if (curChar == STRCHAR)
            if (OurGetChar() != STRCHAR)
                goto gotstr;

        if (token.val++ == MAXSTR)
            LexError1(2102); //"string literal too long"
        else
            *s++ = curChar;
    }
    if (curChar == EOFMARK)
        LexError1(2103); //"unexpected end of file in string literal"
    if (token.val >= 256) {
        SendError("\n");
        SET_MSG(Msg_Text, sizeof(Msg_Text), GET_MSG(4205), curFile, token.row);
        SendError(Msg_Text);
    }

gotstr:
    *s++ = 0;
    s = tokenbuf;

    /* process escape characters in the string */

    while (*s != 0)  {
        if (*s == L'\\')  {
            s++;
            if (*s == L'\\')
                temptok[i++] = L'\\';
            else if (*s == L'T' || *s == L't')
                temptok[i++] = L'\011';            /* Tab */
            else if (*s == L'A' || *s == L'a')
                temptok[i++] = L'\010';            /* Right Align */
            else if (*s == L'n')
                temptok[i++] = fMacRsrcs ? 13 : 10;   /* linefeed */
            else if (*s == L'r')
                temptok[i++] = fMacRsrcs ? 10 : 13;   /* carriage return */
            else if (*s == L'"')
                temptok[i++] = L'"';               /* quote character */
            else if (*s == L'X' || *s == L'x')  {  /* Hexidecimal digit */
                USHORT wCount;

                HexNum = 0;
                ++s;
                for (wCount = 4 ;
                    wCount && iswxdigit((ch=(WCHAR)towupper(*s)));
                    --wCount)  {
                    if (ch >= L'A')
                        inc = ch - L'A' + 10;
                    else
                        inc = ch - L'0';
                    HexNum = HexNum * 16 + inc;
                    s++;
                }
                temptok[i++] = (WCHAR)HexNum;
                s--;
            }
            else if (*s >= L'0' && *s <= L'7') {    /* octal character */
                USHORT wCount;

                Octal_Num = 0;
                for (wCount = 7; wCount && *s >= L'0' && *s <= L'7'; --wCount)  {
                    Octal_Num = (Octal_Num * 8 + (*s - L'0'));
                    s++;
                }
                temptok[i++] = (WCHAR)Octal_Num;
                s--;
            }

        }
        else
            temptok[i++] = *s;
        s++;
    }

    /* zero terminate */
    temptok[i] = L'\0';
    token.val = (USHORT)i;
    memcpy ( tokenbuf, temptok, sizeof(WCHAR)*(i + 1));
}

/*---------------------------------------------------------------------------*/
/*                                                                           */
/*  GetToken() -                                                             */
/*                                                                           */
/*---------------------------------------------------------------------------*/

int
GetToken(
    int fReportError
    )
{
    for (; ; )  {
        /* skip whitespace */
        while (iswhite( curChar))
            OurGetChar();

        /* take care of 'random' symbols use */
        if (curChar == SYMUSESTART)
            GetSymbol(fReportError, curChar);
        token.sym.name[0] = L'\0';

        /* remember location of token */
        token.row = curLin;
        token.col = curCol;

        /* determine if token is EOF, number, string, or keyword */
        token.type = EOFMARK;
        switch (curChar) {
            case EOFMARK:
                break;

            case SGNCHAR:
            case L'~':
                if (fReportError & TOKEN_NOEXPRESSION)
                    GetNumNoExpression();
                else
                    GetNum();
                break;

            case STRCHAR:
                GetStr();
                break;

            default:
                if (curChar == L'(' && !(fReportError & TOKEN_NOEXPRESSION))
                    GetNum();
                else if (iswdigit( curChar)) {
                    if (fReportError & TOKEN_NOEXPRESSION)
                        GetNumNoExpression();
                    else
                        GetNum();

                    if (curChar == SYMUSESTART)
                        GetSymbol(fReportError, curChar);
                } else {
                    if (!GetKwd( fReportError))
                        continue;
                    if (token.type == TKLSTR) {
                        GetLStr();
                        break;
                    }
                }
        }

        break;
    }

    return token.type;
}


/*---------------------------------------------------------------------------*/
/*                                                                           */
/*  GetXNum() -                                                              */
/*                                                                           */
/*---------------------------------------------------------------------------*/

/* get hexadecimal number */

LONG
GetXNum(
    void
    )
{
    LONG n = 0;

    while (iswxdigit (GetCharFTB()))
        n = n * 16 + ( ((curCharFTB = (WCHAR)towupper(curCharFTB)) >= L'A') ?
            (WCHAR)(curCharFTB - L'A' + 10) :
            (WCHAR)(curCharFTB - L'0'));
    return (n);
}


/*---------------------------------------------------------------------------*/
/*                                                                           */
/*  GetONum() -                                                              */
/*                                                                           */
/*---------------------------------------------------------------------------*/

/* get octal number */

LONG
GetONum(
    void
    )
{
    LONG n = 0;

    while (GetCharFTB() >= L'0' && curCharFTB <= L'7')
        n = n * 8 + (curCharFTB - L'0');
    return (n);
}


/*---------------------------------------------------------------------------*/
/*                                                                           */
/*  GetDNum() -                                                              */
/*                                                                           */
/*---------------------------------------------------------------------------*/

/* get decimal number */

LONG
GetDNum(
    void
    )
{
    LONG n = 0;

    while (iswdigit(curCharFTB)) {
        n = n * 10 + (curCharFTB - L'0');
        GetCharFTB();
    }
    return (n);
}


PWSTR
GetWord(
    PWSTR pStr
    )
{
    WCHAR   ch;
    PSKEY   pskey;

    *pStr++ = curCharFTB = curChar;
    while (TRUE) {
        ch = OurGetChar();

        if (ch <= L' ')
            goto FoundBreak;

        switch (ch) {
            case EOFMARK:
            case EOLCHAR:
            case STRCHAR:
            case CHRCHAR:
                goto FoundBreak;

            default:
                for (pskey = skeyList; pskey->skwd; pskey++)
                    if (pskey->skwd == ch)
                        goto FoundBreak;
        }

        *pStr++ = ch;
    }

FoundBreak:
    *pStr = 0;

    return(pStr);
}


/*  GetNumFTB
 *      This function was previously added as a hack to handle converting
 *      radices.  I'm treating this as a (ugly) black box to read a number.
 */

VOID
GetNumFTB(
    void
    )
{
    int signFlag;
    USHORT wNotFlag;
    LONG n;

    /* Small hack to support NOT:  If we have a tilde, skip whitespace
     *  before the number.
     */
    if (curChar == L'~')
        while (iswhite(curChar))
            OurGetChar();

    /* Get the entire number in tokenbuf before computing radix */
    GetWord(tokenbuf);

    /* Skip the first char.  It is already in curCharFTB */
    CurPtrTB = tokenbuf + 1;

    /* mark token type as numeric literal */
    token.type = NUMLIT;

    /* find sign of number */
    if (curCharFTB == SGNCHAR)  {
        signFlag = TRUE;
        GetCharFTB();
    } else {
        signFlag = FALSE;
    }

    /* Check for a NOT (~) */
    if (curCharFTB == L'~') {
        wNotFlag = TRUE;
        GetCharFTB();
    } else {
        wNotFlag = FALSE;
    }

    /* determine radix of number */
    if (curCharFTB == L'0')  {
        GetCharFTB();
        if (curCharFTB == L'x')
            n = GetXNum();
        else if (curCharFTB == L'o')
            n = GetONum();
        else
            n = GetDNum();
    } else {
        n = GetDNum();
    }

    /* find size of number */
    if ((curCharFTB == L'L') || (curCharFTB == L'l'))  {
        token.flongval = TRUE;
        GetCharFTB();
    } else {
        token.flongval = FALSE;
    }

    /* account for sign */
    if (signFlag)
        n = -n;

    /* Account for the NOT */
    if (wNotFlag)
        n = ~n;

    /* Set longval regardless of flongval because Dialog Styles
     *  always have to be be long
     */
    token.longval = n;
    token.val = (USHORT)n;
}


/* ----- Static information needed for parsing ----- */
static int      wLongFlag;
static int      nParenCount;

/*---------------------------------------------------------------------------*/
/*                                                                           */
/*  GetNum() -                                                               */
/*                                                                           */
/*---------------------------------------------------------------------------*/

VOID
GetNum(
    void
    )
{
    LONG lValue;

    /* Initialize */
    wLongFlag = 0;
    nParenCount = 0;

    /* Return the number */
    lValue = GetExpression();

    /* Make sure we had matched parens */
    if (nParenCount)
        ParseError1(1013); //"Mismatched parentheses"

    /* Return as the proper token */
    if (wLongFlag)
        token.flongval = TRUE;
    token.type = NUMLIT;
    token.longval = lValue;
    token.val = (USHORT)lValue;
}


/*  GetNumNoExpression
 *      Gets a number without doing expression parsing on it.
 */

VOID
GetNumNoExpression(
    VOID
    )
{
    /* Call the single number parser */
    GetNumFTB();
}


/*  GetExpression
 *      Gets an expression, which is defined as any number of
 *      operators and operands inside one set of parens.
 */

LONG
GetExpression(
    VOID
    )
{
    LONG op1;
    LONG op2;
    WCHAR byOperator;
    UINT wFlags;

    /* Get the first operand */
    op1 = GetOperand();

    /* take care of symbol use */
    if (curChar == SYMUSESTART) {
        GetSymbol(TRUE, curChar);
        token.sym.nID = token.val;
    }

    /* Loop until end of expression */
    for (; ; ) {
        /* Get the operator */
        wFlags = GetOperator(&byOperator);

        /* If this is a right paren, dec the count */
        if (byOperator == L')') {
            /* Bring the paren count back down */
            --nParenCount;

            /* Skip the paren and any trailing whitespace */
            OurGetChar();
            SkipWhitespace();
        }

        /* If this isn't an operator, we're done with the expression */
        if (!wFlags) {
            token.sym.nID = (unsigned)op1;
            return op1;
        }
        token.sym.name[0] = L'\0';

        /* Get the second operand */
        op2 = GetOperand();

        /* Compute the value of the expression */
        switch (byOperator) {
            case L'+':
                op1 += op2;
                break;

            case L'-':
                op1 -= op2;
                break;

            case L'&':
                op1 &= op2;
                break;

            case L'|':
                op1 |= op2;
                break;
        }
    }
}


/*  GetOperand
 *      Gets an operand, which may either be a single number or may
 *      be an entire expression.
 */

LONG
GetOperand(
    VOID
    )
{

    /* Check to see if we need to descend a level */
    if (curChar == L'(') {
        /* Bump paren count so we can match them up */
        ++nParenCount;

        /* Skip past the paren char */
        OurGetChar();
        SkipWhitespace();

        /* Return the value of the computed expression for the operand */
        return GetExpression();
    }

    /* If this isn't a number, return an error */
    if (curChar != L'-' && curChar != L'~' && !iswdigit(curChar)) {
        GetKwd(FALSE);
        ParseError2(2237, tokenbuf);
        return 0;
    }

    /* Get the number in the token structure */
    GetNumFTB();

    /* See if we need to force the result long */
    if (token.flongval)
        wLongFlag = TRUE;

    /* Skip trailing whitespace */
    SkipWhitespace();

    /* Return the value */
    return token.longval;
}


/*  GetOperator
 *      Gets the next character and decides if it should be an operator.
 *      If it should, it returns TRUE, which causes the expression
 *      parser to continue.  Otherwise, it returns FALSE which causes
 *      the expression parser to pop up a level.
 */

int
GetOperator(
    PWCHAR pOperator
    )
{
    static WCHAR byOps[] = L"+-|&";
    PWCHAR pOp;

    /* take care of symbol use */
    if (curChar == SYMUSESTART)
        GetSymbol(TRUE, curChar);

    /* See if this character is an operator */
    pOp = wcschr(byOps, curChar);
    *pOperator = curChar;

    /* If we didn't find it, get out */
    if (!pOp)
        return FALSE;

    /* Otherwise, read trailing whitespace */
    OurGetChar();
    SkipWhitespace();

    /* Return the operator */
    return TRUE;
}


/*  SkipWhitespace
 *      Skips past whitespace in the current stream.
 */

VOID
SkipWhitespace(
    VOID
    )
{
    while (iswhite(curChar))
        OurGetChar();
}


/*---------------------------------------------------------------------------*/
/*                                                                           */
/*  GetKwd() -                                                               */
/*                                                                           */
/*---------------------------------------------------------------------------*/

int
GetKwd(
    int fReportError
    )
{
    PSKEY sk;

    /* see if a special character */

    for (sk = &skeyList[ 0 ]; sk->skwd; sk++) {
        if (curChar == sk->skwd)  {
            token.type = (UCHAR)sk->skwdval;
            token.val = 0;
            OurGetChar();
            return (token.type >= FIRSTKWD);
        }
    }

    /* else read characters up to the next seperator */
    GetWord(tokenbuf);

    // Check for TKLSTR -- new for NT
    if (!tokenbuf[1] && (towupper(tokenbuf[0]) == L'L') && (curChar == STRCHAR)) {
        token.type = TKLSTR;
        return TRUE;
    }

    /* look up keyword in table */
    if ((token.val = FindKwd( tokenbuf)) != (USHORT)-1) {
        token.type = (UCHAR)token.val;
    } else if (fReportError)  {
        LexError2(2104, (PCHAR)tokenbuf); //"undefined keyword or key name: %ws"
        return FALSE;
    }
    else
        token.type = 0;

    return TRUE;
}


/*---------------------------------------------------------------------------*/
/*                                                                           */
/*  FindKwd() -                                                              */
/*                                                                           */
/*---------------------------------------------------------------------------*/

USHORT
FindKwd(
    PWCHAR str
    )
{
    PKEY   k;
    int    t;

    /* linear search the keyword table for the key */
    for (k = &keyList[0]; k->kwd; k++)
        if (!(t = _wcsicmp( str, k->kwd)))
            return k->kwdval;
        else if (t < 0)
            break;

    /* if not found, return -1 as keyword id */
    return (USHORT)-1;
}


/*---------------------------------------------------------------------------*/
/*                                                                           */
/*  LexError1() -                                                            */
/*                                                                           */
/*---------------------------------------------------------------------------*/

void
LexError1(
    int iMsg
    )
{
    SET_MSG(Msg_Text, sizeof(Msg_Text), GET_MSG(iMsg), curFile, curLin);
    SendError(Msg_Text);
    quit("\n");
}


/*---------------------------------------------------------------------------*/
/*                                                                           */
/*  LexError2() -                                                            */
/*                                                                           */
/*---------------------------------------------------------------------------*/

void
LexError2(
    int iMsg,
    PCHAR str
    )
{
    SET_MSG(Msg_Text, sizeof(Msg_Text), GET_MSG(iMsg), curFile, curLin, str);
    SendError(Msg_Text);
    quit("\n");
}


/*---------------------------------------------------------------------------*/
/*                                                                           */
/*  GetNameOrd() -                                                           */
/*                                                                           */
/*---------------------------------------------------------------------------*/

/* For reading in resource names and types.  */
int
GetNameOrd(
    void
    )
{
    PWCHAR pch;
    int fString;

    /* get space delimited string */
    if (!GetGenText())
        return FALSE;

    /* convert to upper case */
    _wcsupr(tokenbuf);

    /* is it a string or number */
    for (pch=tokenbuf,fString=0 ; *pch ; pch++ )
    if (!iswdigit(*pch))
        fString = 1;

    /* determine if ordinal */
    if (tokenbuf[0] == L'0' && tokenbuf[1] == L'X') {
        int         HexNum;
        int         inc;
        USHORT      wCount;
        PWCHAR      s;

        HexNum = 0;
        s = &tokenbuf[2];
        for (wCount = 4 ; wCount && iswxdigit(*s) ; --wCount)  {
            if (*s >= L'A')
                inc = *s - L'A' + 10;
            else
                inc = *s - L'0';
            HexNum = HexNum * 16 + inc;
            s++;
        }
        token.val = (USHORT)HexNum;
    } else if (fString) {
        token.val = 0;
    } else {
       token.val = (USHORT)wcsatoi(tokenbuf);
    }

    return TRUE;
}


/*---------------------------------------------------------------------------*/
/*                                                                           */
/*  GetGenText() -                                                           */
/*                                                                           */
/*---------------------------------------------------------------------------*/

/* returns a pointer to a string of generic text */

PWCHAR
GetGenText(
    void
    )
{
    PWCHAR  s;

    s = tokenbuf;

    /* skip white space */
    while (iswhite(curChar))
        OurGetChar();

    if (curChar == EOFMARK)  {
        token.type = EOFMARK;
        return NULL;
    }

    /* random symbol */
    if (curChar == SYMUSESTART)
        GetSymbol(TRUE, curChar);
    token.sym.name[0] = L'\0';

    /* read space delimited string */
    *s++ = curChar;
    while (( LitChar() != EOFMARK) && ( !iswhite(curChar)))
        *s++ = curChar;
    *s++ = 0;     /* put a \0 on the end of the string */

    OurGetChar();    /* read in the next character        */
    if (curChar == EOFMARK)
        token.type = EOFMARK;

    if (curChar == SYMUSESTART) {
        GetSymbol(TRUE, curChar);
        token.sym.nID = token.val;
    }

    return (tokenbuf);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\rcdll\rc.h ===
#include <windows.h>
#include <ntverp.h>
#include <stdio.h>
#include <windef.h>
#include <wchar.h>

typedef FILE    *PFILE;
typedef WCHAR   *PWCHAR;
typedef USHORT  *PUSHORT;
typedef SHORT   *PSHORT;
typedef UINT    *PUINT;
typedef UCHAR   *PUCHAR;

#include <ctype.h>
#include <errno.h>
#include <io.h>
#include <limits.h>
#include <malloc.h>
#include <memory.h>
#include <process.h>
#include <signal.h>
#include <stdarg.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>
#include <mmsystem.h>

#include "charmap.h"
#include "fcntl.h"
#include "getflags.h"
#include "grammar.h"

#include "rcpptype.h"
#include "rcppdecl.h"
#include "rcppext.h"
#include "p0defs.h"

#include "newexe.h"
#include "p1types.h"
#include "rcdefs.h"
#include "rcnewres.h"
#include "rcppx.h"
#include "rcunicod.h"
#include "resfile.h"
#include "strings.h"
#include "trees.h"


#define NULL_FILE ((PFILE) NULL)

/* ----- General symbols ----- */
#define VERSION_DUAL            0x202
#define BUFSIZE                 16384
#define EOF                     (-1)

#define TRUE    1
#define FALSE   0

/* The ResType field of NewHeader identifies the cursor/icon type */
#define  ICONTYPE      1
#define  CURSORTYPE    2

/* Identifies the menu item template version number */
#define OLDMENUITEMTEMPLATEVERSIONNUMBER    0
#define OLDMENUITEMTEMPLATEBYTESINHEADER    0

#define MENUITEMTEMPLATEVERSIONNUMBER       1
#define MENUITEMTEMPLATEBYTESINHEADER       sizeof(DWORD)   //dwHelpID in hdr

#define DIFFERENCE      11

/* Predefined resource types */
#define RT_NEWRESOURCE  0x2000
#define RT_ERROR        0x7fff
#define RT_NEWBITMAP    MAKEINTRESOURCE((DWORD)RT_BITMAP+DIFFERENCE)

// These are 'hidden' resources that users never see/use directly.
#define RT_MENUEX       MAKEINTRESOURCE(15)
#define RT_DIALOGEX     MAKEINTRESOURCE(18)

// These are here only temporary here they should in winuser.w
#define RT_ANICURSOR    MAKEINTRESOURCE(21)
#define RT_ANIICON      MAKEINTRESOURCE(22)

#define RT_LAST         MAKEINTRESOURCE(22)

// AFX resource types (Should these be in winuser.h?)
#define RT_DLGINIT      MAKEINTRESOURCE(240)
#define RT_TOOLBAR      MAKEINTRESOURCE(241)

#define GFE_ZEROINIT    0x0001
#define GFE_SHORT       0x0002

#ifdef MFR_POPUP
#if (MFR_POPUP != 0x01) && (MFR_END != 0x80)
#error MFR_POPUP or MFR_END definition(s) invalid
#endif
#else
#define MFR_POPUP       0x01
#define MFR_END         0x80
#endif

/* Single-byte control class IDs */
#define BUTTONCODE      0x80
#define EDITCODE        0x81
#define STATICCODE      0x82
#define LISTBOXCODE     0x83
#define SCROLLBARCODE   0x84
#define COMBOBOXCODE    0x85

/* Translator flag bits */
#define fVIRTKEY                1
#define fNOINVERT               2
#define fSHIFT                  4
#define fCONTROL                8
#define fALT                    16

/* Menu flag bits */
#define OPGRAYED                  0x0001
#define OPINACTIVE                0x0002    // INACTIVE | GRAYED
#define OPBITMAP                  0x0004
#define OPOWNERDRAW               0x0100
#define OPUSECHECKBITMAPS 0x0200
#define OPCHECKED                 0x0008
#define OPPOPUP                   0x0010
#define OPBREAKWBAR               0x0020
#define OPBREAK                   0x0040
#define OPENDMENU                 0x0080
#define OPHELP                    0x4000
#define OPSEPARATOR               0x0800
/*#define OPPOPHELP         0x0004*/


#define wcsdigit(w) (w >= 0x0030 && w <= 0x0039)

/*
** dialog & menu template tokens (these start at 40)
*/

/* buttons */
#define TKRADIOBUTTON       40
#define TKCHECKBOX          41
#define TKPUSHBUTTON        42
#define TKDEFPUSHBUTTON     43
#define TKAUTOCHECK         44
#define TK3STATE            45
#define TKAUTO3             46
#define TKUSERBUTTON        47
#define TKAUTORADIO         48
#define TKOWNERDRAW         50
#define TKGROUPBOX          51
#define TKPUSHBOX           52

/* static/edit */
#define TKBEDIT         57
#define TKHEDIT         58
#define TKIEDIT         59
#define TKEDITTEXT      60
#define TKLTEXT         61
#define TKRTEXT         62
#define TKCTEXT         63
#define TKEDIT          64
#define TKSTATIC        65
#define TKICON          66
#define TKBITMAP        67

/* menu stuff */
#define TKMENU          70
#define TKMENUITEM      71
#define TKSEPARATOR     72
#define TKCHECKED       73
#define TKGRAYED        74
#define TKINACTIVE      75
#define TKBREAKWBAR     76
#define TKBREAK         77
#define TKPOPUP         78
#define TKHELP          79

/* other controls */
#define TKLISTBOX       90
#define TKCOMBOBOX      91
#define TKRCDATA        92
#define TKSCROLLBAR     93
#define TKFONT          94
#define TKBUTTON        95
#define TKMESSAGETABLE  96

/* math expression tokens */
#define TKCLASS         100
#define TKPLUS          101
#define TKMINUS         102
#define TKNOINVERT      103
#define TKNOT           104
#define TKKANJI         105
#define TKSHIFT         106

/* Accel table */
#define TKALT           110
#define TKASCII         111
#define TKVIRTKEY       112
#define TKVALUE         113
#define TKBLOCK         114

/* verison */
#define TKFILEVERSION   120
#define TKPRODUCTVERSION        121
#define TKFILEFLAGSMASK 122
#define TKFILEFLAGS     123
#define TKFILEOS        124
#define TKFILETYPE      125
#define TKFILESUBTYPE   126

/* misc */
#define TKCHARACTERISTICS   130
#define TKLANGUAGE          131
#define TKVERSION           132
#define TKSTYLE             133
#define TKCONTROL           134
#define TKCAPTION           135
#define TKDLGINCLUDE        136
#define TKLSTR              137
#define TKDLGINIT           138
#define TKEXSTYLE           0xf7  /* so as not to conflict with x-coordinate */

/* memory and load flags */
#define TKFIXED         0xfff0
#define TKMOVEABLE      0xfff1
#define TKDISCARD       0xfff2
#define TKLOADONCALL    0xfff3
#define TKPRELOAD       0xfff4
#define TKPURE          0xfff5
#define TKIMPURE        0xfff6



/* special tokens */
#define CHCARRIAGE      L'\r'
#define CHSPACE         L' '
#define CHNEWLINE       L'\n'
//??#define CHTAB            9
#define CHTAB           L'\t'
#define CHDIRECTIVE     L'#'
#define CHQUOTE         L'"'
#define CHEXTENSION     L'.'
#define CHCSOURCE       L'c'
#define CHCHEADER       L'h'
#define CHCOMMENT       L';'

#define DEBUGLEX    1
#define DEBUGPAR    2
#define DEBUGGEN    4

/* End of file character/token */
#define EOFMARK         127

/* Single character keywords that we ignore */
#define LPAREN          1      /* ( */
#define RPAREN          2      /* ) */

/* multiple character keywords */
#define FIRSTKWD        11             /* for adding to table indices */

#define OR          FIRSTKWD+1
#define BEGIN       FIRSTKWD+2
#define END         FIRSTKWD+3
#define COMMA       FIRSTKWD+4
#define TILDE       FIRSTKWD+5
#define AND         FIRSTKWD+6
#define EQUAL       FIRSTKWD+7  // AFX
#define LASTKWD     FIRSTKWD+8  // 19

/* Token types */
#define NUMLIT      LASTKWD+1   // 20
#define STRLIT      LASTKWD+2
#define CHARLIT     LASTKWD+3
#define LSTRLIT     LASTKWD+4   // AFX

/* The following switches, when defined enable various options
**  #define DEBUG enables debugging output.  Use one or more of the
**  values defined above to enable debugging output for different modules */

/* Version number.  VERSION and REVISION are used to set the API number
** in an RCed file.  SIGNON_* are used just to print the signon banner.
** Changing VERSION and REVISION means that applications RCed with this
** version will not run with earlier versions of Windows.  */

//#define VERSION     2
#define REVISION    03
#define SIGNON_VER  4
#define SIGNON_REV  00

/* GetToken() flags */
#define TOKEN_NOEXPRESSION 0x8000

/* Current token structure */
#define MAXSTR (4096+1)     // AFX defines this as 255
#define MAXTOKSTR (256+1)

// New Menu Template Parsing structures/definitions

// New menu template format
//
//      MenuName MENUEX
//      BEGIN
//          [MENUITEM "text" [, [id] [, [type] [, [state]]]]]
//          [POPUP    "text" [, [id] [, [type] [, [state] [, [help id]]]]]
//          BEGIN
//              [MENUITEM "text" [, [id] [, [type] [, [state]]]]]
//              ...
//          END]
//          ...
//      END

typedef struct tagMENU
{
    DWORD   dwID;
    DWORD   dwType;
    DWORD   dwState;
    DWORD   dwHelpID;
    WORD    wResInfo;
    WCHAR   szText[MAXTOKSTR];
} MENU, *PMENU;


typedef enum
{
    PT_WORD = 0,
    PT_DWORD,
    PT_TEXT
}   PARSETYPE;

typedef enum
{
    PTO_WORD = 0x80,
    PTO_DWORD,
    PTO_TEXT
}   OPARSETYPE;

typedef enum
{
    PAR_POPUP = 0,
    PAR_MENUITEM,
    PAR_MENU
}   PARCELTYPE;

#define PT_OPTIONAL 0x80

typedef struct tagPARCEL
{
    WORD    *pwEnd;
    BYTE    *pwParms;
}   PARCEL;

typedef struct tagKEY
{
    PWCHAR  kwd;
    WORD    kwdval;
} KEY, *PKEY;

typedef struct tagSKEY
{
    WCHAR   skwd;
    UINT    skwdval; /* changed from a char */
} SKEY, *PSKEY;

#pragma pack(2)
typedef struct tagSYMINFO
{
    WCHAR   name[MAX_SYMBOL + 1];/* symbol for the resource if available */
    WCHAR   file[_MAX_PATH];
    WORD    line;
    WORD    nID;
} SYMINFO, *PSYMINFO;

typedef struct tagTOKEN
{
    LONG        longval;
    int         row;                    /* line number of current token */
    int         col;                    /* column number of current token */
    BOOL        flongval;               /* is parsed number a long? */
    USHORT      val;
    UCHAR       type;
    UCHAR       realtype;
    SYMINFO     sym;
} TOKEN, *PTOKEN;

typedef struct tagFONTDIR
{
    USHORT              ordinal;
    USHORT              nbyFont;
    struct tagFONTDIR   *next;
} FONTDIR, *PFONTDIR;

typedef struct tagOBJLST
{
    struct tagOBJLST    *next;
    DWORD               nObj;         /* objecty number */
    DWORD               cb;           /* number of bytes used */
    DWORD               cpg;          /* number of pages used */
    DWORD               flags;        /* object memory flags */
} OBJLST, *POBJLST;

typedef struct tagCTRL
{
    SHORT   x;
    SHORT   y;
    SHORT   cx;
    SHORT   cy;
    WCHAR   fOrdinalText;
    WCHAR   text[MAXTOKSTR];
    DWORD   id;
    WCHAR   Class[MAXTOKSTR];
    DWORD   dwStyle;
    DWORD   dwExStyle;
    DWORD   dwHelpID;
} CTRL, *PCTRL;

typedef struct tagDLGHDR
{
    SHORT   x;
    SHORT   y;
    SHORT   cx;
    SHORT   cy;
    UCHAR   fOrdinalMenu;
    UCHAR   fClassOrdinal;
    DWORD   dwStyle;
    DWORD   dwExStyle;
    WORD    bNumberOfItems;
    WCHAR   Title[MAXTOKSTR];
    WCHAR   MenuName[MAXTOKSTR];
    WCHAR   Class[MAXTOKSTR];
    WCHAR   Font[MAXTOKSTR];
    WORD    pointsize;
    WORD    wWeight;
    BYTE    bItalic;
    BYTE    bCharSet;
    DWORD   dwHelpID;
} DLGHDR, *PDLGHDR;

typedef struct tagMENUHDR
{
    USHORT   menuTemplateVersionNumber;
    USHORT   menuTemplateBytesInHeader;
} MENUHDR, *PMENUHDR;

typedef struct tagMENUITEM
{
    SHORT       id;
    WCHAR       szText[ MAXTOKSTR ];
    WORD        OptFlags;
    WORD        PopFlag;
} MENUITEM, *PMENUITEM;

#define BLOCKSIZE 16
typedef struct tagRCSTRING
{
    struct tagRCSTRING *next;
    DWORD       version;
    DWORD       characteristics;
    USHORT      hibits;
    SHORT       flags;
    WORD        language;
    PWCHAR      rgsz[ BLOCKSIZE ];
    PSYMINFO    rgsym[ BLOCKSIZE ];
} RCSTRING, *PRCSTRING;

typedef struct tagRCACCEL
{
    WORD        flags;
    WCHAR       ascii;
    USHORT      id;
    USHORT      unused;
} RCACCEL, *PRCACCEL;

typedef struct tagRESINFO
{
    DWORD       version;
    DWORD       characteristics;
    LONG        exstyleT;
    LONG        BinOffset;
    LONG        size;
    struct tagRESINFO *next;
    WORD        *poffset;
    PWCHAR      name;
    POBJLST     pObjLst;
    WORD        language;
    SHORT       flags;
    USHORT      nameord;
    USHORT      cLang;
    SYMINFO     sym;
} RESINFO, *PRESINFO;

typedef struct tagTYPEINFO
{
    struct tagTYPEINFO *next;
    PRESINFO    pres;
    PWCHAR      type;
    USHORT      typeord;
    USHORT      cTypeStr;
    USHORT      cNameStr;
    SHORT       nres;
} TYPEINFO, *PTYPEINFO;

#pragma pack()


/* ----- Global variables ----- */
extern  SHORT       ResCount;
extern  PTYPEINFO   pTypInfo;
extern  UINT        uiDefaultCodePage;
extern  UINT        uiCodePage;
extern  SHORT       nFontsRead;
extern  PFONTDIR    pFontList;
extern  PFONTDIR    pFontLast;
extern  TOKEN       token;
extern  int         errorCount;
extern  WCHAR       tokenbuf[MAXSTR + 1]; // +1 is to allow double sz termination
extern  UCHAR       exename[_MAX_PATH], fullname[_MAX_PATH];
extern  UCHAR       curFile[_MAX_PATH];
extern  WORD        language;
extern  LONG        version;
extern  LONG        characteristics;

extern  PDLGHDR     pLocDlg;
extern  UINT        mnEndFlagLoc;   /* patch location for end of a menu. */
                                    /* we set the high order bit there    */
extern  BOOL        fVerbose;       /* verbose mode (-v) */
extern  BOOL        fAFXSymbols;
extern  BOOL        fMacRsrcs;
extern  BOOL        fAppendNull;
extern  BOOL        fWarnInvalidCodePage;
extern  BOOL        fSkipDuplicateCtlIdWarning;
extern  long        lOffIndex;
extern  WORD        idBase;
extern  PCHAR       szTempFileName;
extern  PCHAR       szTempFileName2;
extern  CHAR        inname[_MAX_PATH];
extern  PFILE       fhBin;
extern  PFILE       fhInput;
extern  PFILE       fhCode;
extern  PCHAR       pchInclude;
extern  SHORT       k1,k2,k3,k4;
extern  PRESINFO    pResString;

extern  HINSTANCE   hInstance;
extern  HANDLE      hHeap;

extern  int         nBogusFontNames;
extern  WCHAR      *pszBogusFontNames[16];
extern  WCHAR       szSubstituteFontName[MAXTOKSTR];

/*---------------------------------------------------------------------------*/
/*                                                                           */
/*  rcl.c                                                                    */
/*                                                                           */
/*---------------------------------------------------------------------------*/

int     FileChar();
USHORT  FindKwd(PWCHAR);
WCHAR   GetCharFTB();
PWSTR   GetWord(PWSTR);
LONG    GetDNum();
LONG    GetExpression();
PWCHAR  GetGenText();
int     GetKwd(int);
int     GetNameOrd();
VOID    GetNum();
VOID    GetNumFTB();
VOID    GetNumNoExpression();
LONG    GetONum();
LONG    GetOperand();
int     GetOperator(PWCHAR pOperator);
VOID    GetStr();
int     GetToken(int);
LONG    GetXNum();
void    LexError1(int iMsg);
void    LexError2(int iMsg, PCHAR str);
int     LexInit(PFILE);
WCHAR   LitChar();
WCHAR   OurGetChar();
VOID    SkipWhitespace();

/*---------------------------------------------------------------------------*/
/*                                                                           */
/*  rcp.c                                                                    */
/*                                                                           */
/*---------------------------------------------------------------------------*/

VOID        AddBinEntry(PTYPEINFO, PRESINFO, PCHAR , int, LONG);
VOID        AddDefaultTypes();
VOID        AddFontDir();
VOID        AddResToResFile (PTYPEINFO, PRESINFO, PCHAR, int, LONG);
PTYPEINFO   AddResType (PWCHAR, LPWSTR);
VOID        AddStringToBin(USHORT, PWCHAR);
int         DGetMemFlags(PRESINFO);
LONG        GetFileName (VOID);
VOID        ParseError1(int);
VOID        ParseError2(int, PWCHAR); // AFX has 1&2 -- NT just has ParseError
VOID        ParseError3(int);
int         ReadRF(VOID);
WORD        GetLanguage(VOID);


/*---------------------------------------------------------------------------*/
/*                                                                           */
/*  rcstring.c                                                               */
/*                                                                           */
/*---------------------------------------------------------------------------*/

VOID        WriteTable (PRESINFO);
int         GetAccelerators (PRESINFO);
PRESINFO    GetTable (PRESINFO);
PCHAR       MyFAlloc(UINT, PCHAR);


/*---------------------------------------------------------------------------*/
/*                                                                           */
/*  rctg.c                                                                   */
/*                                                                           */
/*---------------------------------------------------------------------------*/

DWORD   GetNewBitmap(void);
BOOL    AddFontRes(PRESINFO);
VOID    AppendString(PWCHAR, BOOL);
VOID    CtlAlloc();
PFILE   CtlFile(PFILE);
VOID    CtlFree();
VOID    CtlInit();
VOID    FixMenuPatch();
VOID    GenWarning2(int iMsg, PCHAR arg);
VOID    GenWarning4(int iMsg, PCHAR arg1, PCHAR arg2, PCHAR arg3);
VOID    GenError1(int iMsg);
VOID    GenError2(int iMsg, PCHAR arg);
WORD    GetBufferLen();
void    SetItemCount(int Index, USHORT wCount);
USHORT  GetItemCount(int Index);
DWORD   GetIcon(LONG);
DWORD   GetAniIconsAniCursors(LONG nbyFile);
DWORD	FileIsAnimated(LONG nbyFile);
VOID    GetNewIconsCursors(PTYPEINFO, PRESINFO, LPWSTR);
WORD    GetRCData(PRESINFO);
PCHAR   GetSpace(WORD cb);
VOID    IncItemCount();
VOID    SwapItemCount(VOID);
void    FixMenuPatch    (WORD);
void    FixOldMenuPatch (WORD);
VOID    MarkAccelFlagsByte();
VOID    MarkMenuPatch();
VOID    PatchAccelEnd();
LONG    ResourceSize();
VOID    SaveResFile(PTYPEINFO, PRESINFO);
void    SetItemExtraCount(WORD, BOOL);
void    SetUpDlg        (PDLGHDR, BOOL);
void    SetUpItem       (PCTRL,   BOOL);
WORD    SetUpMenu       (PMENU);
WORD    SetUpOldMenu    (PMENUITEM);
VOID    WriteAlign();
VOID    WriteBuffer(PCHAR, USHORT);
int     WriteControl(PFILE, PCHAR, int, LONG);
VOID    WriteString(PWCHAR, BOOL);
VOID    WriteMacString(PWCHAR sz, BOOL fMacCP, BOOL fPascal);
int     ExpandString(BYTE* pb, int cb, BYTE* pbExpand);
WORD    SwapWord(WORD w);
DWORD   SwapLong(DWORD dw);

#define SwappedWord(w)  (fMacRsrcs ? SwapWord(w) : (w))
#define SwappedLong(dw) (fMacRsrcs ? SwapLong(dw) : (dw))

#define WriteByte(b)    (*GetSpace(sizeof(CHAR)) = (b))
#define WriteLong(dw)   (*((DWORD UNALIGNED*) GetSpace(sizeof(DWORD))) = SwappedLong(dw))
#define WriteWord(w)    (*((WORD UNALIGNED*)  GetSpace(sizeof(WORD))) = SwappedWord(w))


/*---------------------------------------------------------------------------*/
/*                                                                           */
/*  rctp.c                                                                   */
/*                                                                           */
/*---------------------------------------------------------------------------*/

#define GFE_ZEROINIT    0x0001
#define GFE_SHORT       0x0002

void    DGetClassName   (PDLGHDR);
void    DGetFont        (PDLGHDR, BOOL);
void    DGetMenuName    (PDLGHDR);
void    DGetTitle       (PDLGHDR);
BOOL    DLexOptionalArgs(PRESINFO, PDLGHDR, BOOL);
void    DlgIncludeParse (PRESINFO); // new for NT
WORD    DoMenuItem      (int);
void    GetCoords       (PSHORT, PSHORT, PSHORT, PSHORT);
VOID    GetCtlCoords    (PCTRL);
VOID    GetCtlID        (PCTRL, BOOL);
VOID    GetCtlText      (PCTRL);
int     GetDlg          (PRESINFO, PDLGHDR, BOOL);
int     GetDlgItems     (BOOL);
BOOL    GetFullExpression(void *pval, WORD wFlags);
USHORT  GetTokenNoComma (USHORT wFlags);
USHORT  ICGetTok        ();
int     IsmnOption      (UINT, PMENUITEM);
VOID    ParseCtl        (PCTRL, BOOL);
int     ParseMenu       (int, PRESINFO);
int     ParseOldMenu    (int, PRESINFO);
int     VersionBlockStruct(PWCHAR pstrKey, PCHAR pstrValue, USHORT LenValue);
int     VersionBlockVariable(PWCHAR pstrKey);
VOID    VersionGet4Words(PDWORD pdw);
VOID    VersionGetDWord(PDWORD pdw);
int     VersionParse();
USHORT  VersionParseBlock();
int     VersionParseFixed();
USHORT  VersionParseValue(int IndexType); // void arg list in AFX
int     GetToolbar (PRESINFO);


/*---------------------------------------------------------------------------*/
/*                                                                           */
/*  rcutil.c                                                                 */
/*                                                                           */
/*---------------------------------------------------------------------------*/

VOID    ExtractFileName(PWCHAR, PWCHAR);
int     iswhite (WCHAR);
BOOL    IsSwitchChar(CHAR);
UINT    MyAlign(PFILE);
PVOID   MyAlloc(UINT);
int     MyCopy (PFILE, PFILE, DWORD);
int     MyCopyAll (PFILE, PFILE);
PVOID   MyFree (PVOID);
PWCHAR  MyMakeStr(PWCHAR);
UINT    MyRead (PFILE, PVOID, UINT);
LONG    MySeek (PFILE, LONG, int);
UINT    MyWrite (PFILE, PVOID, UINT);
VOID    PreBeginParse(PRESINFO, int);
VOID    quit (PSTR);
VOID    searchenv(PCHAR, PCHAR, PCHAR);
int     strpre (PWCHAR, PWCHAR);
DWORD   wcsatoi(PWCHAR);
PWCHAR  wcsitow(LONG v, PWCHAR s, DWORD r);


/*---------------------------------------------------------------------------*/
/*                                                                           */
/*  rcfutil.c                                                                */
/*                                                                           */
/*---------------------------------------------------------------------------*/

int     fgetl (PWCHAR, int, BOOL, PFILE);


/* ----- AFX Functionality ----- */
#include "rcppx.h"

LONG    MakeFontDir();              // AFX only

void SendWarning(PSTR str);
void SendError(PSTR str);

extern RC_PARSE_CALLBACK lpfnParseCallback;
extern RC_MESSAGE_CALLBACK  lpfnMessageCallback;
extern HWND         hWndCaller;

#define fflush(errFile)

void GetSymbolDef(int fReportError, WCHAR curChar);
void GetSymbol(int fReportError, WCHAR curChar);
BOOL InitSymbolInfo();
BOOL TermSymbolInfo(PFILE fhresFile);
void WriteSymbolUse(PSYMINFO sym);
void WriteSymbolDef(PWCHAR name, PWCHAR value, PWCHAR file, WORD line, char flags);
void WriteFileInfo(PRESINFO pRes, PTYPEINFO pType, PWCHAR szFileName);
void WriteResInfo(PRESINFO pRes, PTYPEINFO pType, BOOL bWriteMapEntry);
void WriteResIndex(PRESINFO pRes, PTYPEINFO pType);
void UpdateStatus(unsigned nCode, unsigned long dwStatus);

// offset in a macintosh resource file of the start of the resource data
#define MACDATAOFFSET 256

void GetMacIcon(TYPEINFO *pType, RESINFO *pRes);
void GetMacCursor(TYPEINFO *pType, RESINFO *pRes);

void WriteMacMap(void);
BOOL IsIcon(TYPEINFO* ptype);

#define res_type(ch1,ch2,ch3,ch4) (((unsigned long)(unsigned char)(ch1)<<24)| \
                                ((unsigned long)(unsigned char)(ch2)<<16)| \
                                ((unsigned long)(unsigned char)(ch3)<<8)| \
                                ((unsigned long)(unsigned char)(ch4)))
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\rcdll\rcfutil.c ===
/***********************************************************************/
/*                                                                     */
/*  RCFUTIL.C -                                                        */
/*                                                                     */
/*     Windows 3.0 Resource compiler - File utility functions          */
/*                                                                     */
/*                                                                     */
/***********************************************************************/

#include "rc.h"


/* IsTextUnicode has to be here so this will run on Chicago and NT 1.0. */

#define UNICODE_FFFF              0xFFFF
#define REVERSE_BYTE_ORDER_MARK   0xFFFE
#define BYTE_ORDER_MARK           0xFEFF

#define PARAGRAPH_SEPARATOR       0x2029
#define LINE_SEPARATOR            0x2028

#define UNICODE_TAB               0x0009
#define UNICODE_LF                0x000A
#define UNICODE_CR                0x000D
#define UNICODE_SPACE             0x0020
#define UNICODE_CJK_SPACE         0x3000

#define UNICODE_R_TAB             0x0900
#define UNICODE_R_LF              0x0A00
#define UNICODE_R_CR              0x0D00
#define UNICODE_R_SPACE           0x2000
#define UNICODE_R_CJK_SPACE       0x0030  /* Ambiguous - same as ASCII '0' */

#define ASCII_CRLF                0x0A0D

#define __max(a,b)  (((a) > (b)) ? (a) : (b))
#define __min(a,b)  (((a) < (b)) ? (a) : (b))

#define ARGUMENT_PRESENT(a)     (a != NULL)

BOOL
WINAPI
LocalIsTextUnicode(
    CONST LPVOID Buffer,
    int Size,
    LPINT Result
    )

/*++

Routine Description:

    IsTextUnicode performs a series of inexpensive heuristic checks
    on a buffer in order to verify that it contains Unicode data.


    [[ need to fix this section, see at the end ]]

    Found            Return Result

    BOM              TRUE   BOM
    RBOM             FALSE  RBOM
    FFFF             FALSE  Binary
    NULL             FALSE  Binary
    null             TRUE   null bytes
    ASCII_CRLF       FALSE  CRLF
    UNICODE_TAB etc. TRUE   Zero Ext Controls
    UNICODE_TAB_R    FALSE  Reversed Controls
    UNICODE_ZW  etc. TRUE   Unicode specials

    1/3 as little variation in hi-byte as in lo byte: TRUE   Correl
    3/1 or worse   "                                  FALSE  AntiCorrel

Arguments:

    Buffer - pointer to buffer containing text to examine.

    Size - size of buffer in bytes.  At most 256 characters in this will
           be examined.  If the size is less than the size of a unicode
           character, then this function returns FALSE.

    Result - optional pointer to a flag word that contains additional information
             about the reason for the return value.  If specified, this value on
             input is a mask that is used to limit the factors this routine uses
             to make it decision.  On output, this flag word is set to contain
             those flags that were used to make its decision.

Return Value:

    Boolean value that is TRUE if Buffer contains unicode characters.

--*/
{
    CPINFO      cpinfo;
    UNALIGNED WCHAR *lpBuff = (UNALIGNED WCHAR *) Buffer;
    PCHAR lpb = (PCHAR) Buffer;
    ULONG iBOM = 0;
    ULONG iCR = 0;
    ULONG iLF = 0;
    ULONG iTAB = 0;
    ULONG iSPACE = 0;
    ULONG iCJK_SPACE = 0;
    ULONG iFFFF = 0;
    ULONG iPS = 0;
    ULONG iLS = 0;

    ULONG iRBOM = 0;
    ULONG iR_CR = 0;
    ULONG iR_LF = 0;
    ULONG iR_TAB = 0;
    ULONG iR_SPACE = 0;

    ULONG iNull = 0;
    ULONG iUNULL = 0;
    ULONG iCRLF = 0;
    ULONG iTmp;
    ULONG LastLo = 0;
    ULONG LastHi = 0;
    ULONG iHi, iLo;
    ULONG HiDiff = 0;
    ULONG LoDiff = 0;
    ULONG cLeadByte = 0;
    ULONG cWeird = 0;

    ULONG iResult = 0;

    ULONG iMaxTmp = __min(256, Size / sizeof(WCHAR));

    if (Size < 2 ) {
        if (ARGUMENT_PRESENT( Result )) {
            *Result = IS_TEXT_UNICODE_ASCII16 | IS_TEXT_UNICODE_CONTROLS;
            }

        return FALSE;
        }


    // Check at most 256 wide character, collect various statistics
    for (iTmp = 0; iTmp < iMaxTmp; iTmp++) {
        switch (lpBuff[iTmp]) {
            case BYTE_ORDER_MARK:
                iBOM++;
                break;
            case PARAGRAPH_SEPARATOR:
                iPS++;
                break;
            case LINE_SEPARATOR:
                iLS++;
                break;
            case UNICODE_LF:
                iLF++;
                break;
            case UNICODE_TAB:
                iTAB++;
                break;
            case UNICODE_SPACE:
                iSPACE++;
                break;
            case UNICODE_CJK_SPACE:
                iCJK_SPACE++;
                break;
            case UNICODE_CR:
                iCR++;
                break;

            // The following codes are expected to show up in
            // byte reversed files
            case REVERSE_BYTE_ORDER_MARK:
                iRBOM++;
                break;
            case UNICODE_R_LF:
                iR_LF++;
                break;
            case UNICODE_R_TAB:
                iR_TAB++;
                break;
            case UNICODE_R_CR:
                iR_CR++;
                break;
            case UNICODE_R_SPACE:
                iR_SPACE++;
                break;

            // The following codes are illegal and should never occur
            case UNICODE_FFFF:
                iFFFF++;
                break;
            case UNICODE_NULL:
                iUNULL++;
                break;

            // The following is not currently a Unicode character
            // but is expected to show up accidentally when reading
            // in ASCII files which use CRLF on a little endian machine
            case ASCII_CRLF:
                iCRLF++;
                break;       /* little endian */
        }

        // Collect statistics on the fluctuations of high bytes
        // versus low bytes

        iHi = HIBYTE (lpBuff[iTmp]);
        iLo = LOBYTE (lpBuff[iTmp]);

        // Count cr/lf and lf/cr that cross two words
        if ((iLo == '\r' && LastHi == '\n') ||
            (iLo == '\n' && LastHi == '\r')) {
            cWeird++;
        }

        iNull += (iHi ? 0 : 1) + (iLo ? 0 : 1);   /* count Null bytes */

        HiDiff += __max( iHi, LastHi ) - __min( LastHi, iHi );
        LoDiff += __max( iLo, LastLo ) - __min( LastLo, iLo );

        LastLo = iLo;
        LastHi = iHi;
    }

    // Count cr/lf and lf/cr that cross two words
    if ((iLo == '\r' && LastHi == '\n') ||
        (iLo == '\n' && LastHi == '\r')) {
        cWeird++;
    }

    if (iHi == '\0')     /* don't count the last null */
        iNull--;
    if (iHi == 26)       /* count ^Z at end as weird */
        cWeird++;

    iMaxTmp = (ULONG)__min(256 * sizeof(WCHAR), Size);
    GetCPInfo(CP_ACP, &cpinfo);
    if (cpinfo.MaxCharSize != 1) {
        for (iTmp = 0; iTmp < iMaxTmp; iTmp++) {
            if (IsDBCSLeadByteEx(uiCodePage, lpb[iTmp])) {
                cLeadByte++;
                iTmp++;         /* should check for trailing-byte range */
            }
        }
    }

    // sift the statistical evidence
    if (LoDiff < 127 && HiDiff == 0) {
        iResult |= IS_TEXT_UNICODE_ASCII16;         /* likely 16-bit ASCII */
    }

    if (HiDiff && LoDiff == 0) {
        iResult |= IS_TEXT_UNICODE_REVERSE_ASCII16; /* reverse 16-bit ASCII */
    }

    // Use leadbyte info to weight statistics.
    if (!cpinfo.MaxCharSize != 1 || cLeadByte == 0 ||
        !ARGUMENT_PRESENT(Result) || !(*Result & IS_TEXT_UNICODE_DBCS_LEADBYTE)) {
        iHi = 3;
    } else {
        // A ratio of cLeadByte:cb of 1:2 ==> dbcs
        // Very crude - should have a nice eq.
        iHi = __min(256, Size/sizeof(WCHAR)) / 2;
        if (cLeadByte < (iHi-1) / 3) {
            iHi = 3;
        } else if (cLeadByte < (2 * (iHi-1)) / 3) {
            iHi = 2;
        } else {
            iHi = 1;
        }
        iResult |= IS_TEXT_UNICODE_DBCS_LEADBYTE;
    }

    if (iHi * HiDiff < LoDiff) {
        iResult |= IS_TEXT_UNICODE_STATISTICS;
    }

    if (iHi * LoDiff < HiDiff) {
        iResult |= IS_TEXT_UNICODE_REVERSE_STATISTICS;
    }

    //
    // Any control codes widened to 16 bits? Any Unicode character
    // which contain one byte in the control code range?
    //

    if (iCR + iLF + iTAB + iSPACE + iCJK_SPACE /*+iPS+iLS*/) {
        iResult |= IS_TEXT_UNICODE_CONTROLS;
    }

    if (iR_LF + iR_CR + iR_TAB + iR_SPACE) {
        iResult |= IS_TEXT_UNICODE_REVERSE_CONTROLS;
    }

    //
    // Any characters that are illegal for Unicode?
    //

    if (((iRBOM + iFFFF + iUNULL + iCRLF) != 0) || ((cWeird != 0) && (cWeird >= iMaxTmp/40))) {
        iResult |= IS_TEXT_UNICODE_ILLEGAL_CHARS;
    }

    //
    // Odd buffer length cannot be Unicode
    //

    if (Size & 1) {
        iResult |= IS_TEXT_UNICODE_ODD_LENGTH;
    }

    //
    // Any NULL bytes? (Illegal in ANSI)
    //
    if (iNull) {
        iResult |= IS_TEXT_UNICODE_NULL_BYTES;
    }

    //
    // POSITIVE evidence, BOM or RBOM used as signature
    //

    if (*lpBuff == BYTE_ORDER_MARK) {
        iResult |= IS_TEXT_UNICODE_SIGNATURE;
    } else if (*lpBuff == REVERSE_BYTE_ORDER_MARK) {
        iResult |= IS_TEXT_UNICODE_REVERSE_SIGNATURE;
    }

    //
    // limit to desired categories if requested.
    //

    if (ARGUMENT_PRESENT( Result )) {
        iResult &= *Result;
        *Result = iResult;
    }

    //
    // There are four separate conclusions:
    //
    // 1: The file APPEARS to be Unicode     AU
    // 2: The file CANNOT be Unicode         CU
    // 3: The file CANNOT be ANSI            CA
    //
    //
    // This gives the following possible results
    //
    //      CU
    //      +        -
    //
    //      AU       AU
    //      +   -    +   -
    //      --------  --------
    //      CA +| 0   0    2   3
    //      |
    //      -| 1   1    4   5
    //
    //
    // Note that there are only 6 really different cases, not 8.
    //
    // 0 - This must be a binary file
    // 1 - ANSI file
    // 2 - Unicode file (High probability)
    // 3 - Unicode file (more than 50% chance)
    // 5 - No evidence for Unicode (ANSI is default)
    //
    // The whole thing is more complicated if we allow the assumption
    // of reverse polarity input. At this point we have a simplistic
    // model: some of the reverse Unicode evidence is very strong,
    // we ignore most weak evidence except statistics. If this kind of
    // strong evidence is found together with Unicode evidence, it means
    // its likely NOT Text at all. Furthermore if a REVERSE_BYTE_ORDER_MARK
    // is found, it precludes normal Unicode. If both byte order marks are
    // found it's not Unicode.
    //

    //
    // Unicode signature : uncontested signature outweighs reverse evidence
    //

    if ((iResult & IS_TEXT_UNICODE_SIGNATURE) &&
        !(iResult & (IS_TEXT_UNICODE_NOT_UNICODE_MASK&(~IS_TEXT_UNICODE_DBCS_LEADBYTE)))
       ) {
        return TRUE;
    }

    //
    // If we have conflicting evidence, it's not Unicode
    //

    if (iResult & IS_TEXT_UNICODE_REVERSE_MASK) {
        return FALSE;
    }

    //
    // Statistical and other results (cases 2 and 3)
    //

    if (!(iResult & IS_TEXT_UNICODE_NOT_UNICODE_MASK) &&
         ((iResult & IS_TEXT_UNICODE_NOT_ASCII_MASK) ||
          (iResult & IS_TEXT_UNICODE_UNICODE_MASK)
         )
       ) {
        return TRUE;
    }

    return FALSE;
}


/*------------------------------------------------------------------*/
/*                                                                  */
/* fgetl() -                                                        */
/*                                                                  */
/*------------------------------------------------------------------*/

/* fgetl expands tabs and return lines w/o separators */
/* returns line from file (no CRLFs); returns NULL if EOF */

int
fgetl (
    PWCHAR wbuf,
    int len,
    BOOL bUnicode,
    PFILE fh
    )
{
    int c = 0;
    int second;

    *wbuf = 0;

    if (bUnicode) {
        PWCHAR p;

        /* remember NUL at end */
        len--;
        p = wbuf;


        /* fill buffer from the file until EOF or EOLN or no space in buffer */
        while (len) {
            c = fgetc (fh);
            if (c == EOF)
                break;
            second = fgetc (fh);
            c = MAKEWORD (c, second);
            if (c == L'\n')
                break;

            if (c != L'\r') {
                if (c != L'\t') {
                    *p++ = (WCHAR)c;
                    len--;
                } else {

                    /* tabs: expand to spaces */
                    c = (int)(min (8 - ((p - wbuf) & 0x0007), len));
                    len -= c;
                    while (c) {
                        *p++ = L' ';
                        c--;
                    }
                }
            }
        }

        /* null terminate string */
        *p = 0;
    } else {
        PCHAR p;
        PCHAR lpbuf;

        p = lpbuf = (PCHAR) LocalAlloc (LPTR, len);

        if (p) {
            /* remember NUL at end */
            len--;
    
            /* fill buffer from the file until EOF or EOLN or no space in buffer */
            while (len) {
                c = fgetc (fh);
                if (c == EOF || c == '\n')
                    break;
    
                if (c != '\r') {
                    if (c != '\t') {
                        *p++ = (CHAR)c;
                        len--;
                    } else {
    
                        /* tabs: expand to spaces */
                        c = (int)(min (8 - ((p - lpbuf) & 0x0007), len));
                        len -= c;
                        while (c) {
                            *p++ = ' ';
                            c--;
                        }
                    }
                }
            }
    
            /* null terminate string and translate to Unicode */
            *p = 0;
            MultiByteToWideChar (uiCodePage, MB_PRECOMPOSED, lpbuf, -1, wbuf, (int)(p - lpbuf + 1));
    
            LocalFree (lpbuf);
        }
    }

    /* return false if EOF with no chars read */
    return !(c == EOF && !*wbuf);
}

/*----------------------------------------------------------*/
/*                                                          */
/* myfwrite() -                                             */
/*                                                          */
/*  Wrapper for fwrite to ensure data gets to the disk.     */
/*      returns if ok, calls quit if write fails            */
/*----------------------------------------------------------*/

void
myfwrite(
    const void *pv,
    size_t s,
    size_t n,
    PFILE fp
    )
{
    if (fwrite(pv, s, n, fp) == n)
        return;
    else
        quit(GET_MSG(1122));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\rcdll\rcmenu.c ===
/****************************************************************************/
/*                                                                          */
/*  RCTP.C -                                                                */
/*                                                                          */
/*    Windows 3.0 Resource Compiler - Resource Parser                       */
/*                                                                          */
/*                                                                          */
/****************************************************************************/

#include "rc.h"

extern KEY  keyList[];
extern SKEY skeyList[];
extern BOOL CheckStr(PWCHAR pStr);

WORD    wEndPOPUP[]     = { 1, BEGIN };
WORD    wEndMENUITEM[]  = { 3, TKPOPUP, TKMENUITEM, END };
WORD    wEndMENU[]      = { 0 };

BYTE    bParmsPOPUP[]   = { 5, PT_TEXT, PTO_DWORD, PTO_DWORD, PTO_DWORD, PTO_DWORD };
BYTE    bParmsMENUITEM[]= { 4, PT_TEXT, PTO_DWORD, PTO_DWORD, PTO_DWORD };
BYTE    bParmsMENU[]    = { 1, PTO_DWORD };

PARCEL  parcels[]= {
    { wEndPOPUP,       bParmsPOPUP    },    // PAR_POPUP
    { wEndMENUITEM,    bParmsMENUITEM },    // PAR_MENUITEM
    { wEndMENU,        bParmsMENU     }     // PAR_MENU
};

typedef enum {
    ERR_MOREARGS = 2235,
    ERR_NEEDARG,
    ERR_NEEDNUM,
    ERR_NEEDSTR,
    ERR_NEEDBEGIN,
    ERR_NEEDEND,
    ERR_NEEDPAREN,
    ERR_BADEXP,
    ERR_BADSTREXP,
    ERR_NOSEP,
    ERR_BADSUBMENU,
    ERR_NOEMPTYMENU
} ERRCODE;


BOOL
EndParcel(
    WORD *pwEnd
    )
{
    WORD i;

    if (!*pwEnd)
        return(TRUE);

    for (i = *pwEnd; i > 0; i--)
        if (token.type == pwEnd[i])
            return(TRUE);

    return(FALSE);
}

#define PARM_SET    0x0001
#define PARM_LAST   0x0002

BOOL MyGetExpression(DWORD *pdwExp, BOOL fRecursed);

BOOL
GetOp(
    DWORD *pdwExp,
    WORD opcode
    )
{
    DWORD dwOp2 = 0;
    BOOL    fNest = FALSE;

    switch (token.type) {
        case LPAREN:
            GetToken(TOKEN_NOEXPRESSION);
            if (!MyGetExpression(&dwOp2, TRUE))
                return(FALSE);
            fNest = TRUE;
            break;

        case TKMINUS:                   // -flag (unary minus)
            GetToken(TOKEN_NOEXPRESSION);
            dwOp2 = -token.longval;
            break;

        case TKPLUS:
            GetToken(TOKEN_NOEXPRESSION);
        case NUMLIT:
            dwOp2 = token.longval;
            break;

        case TKNOT:                     // (x | NOT flag) == (x & ~flag)
            opcode = AND;
        case TILDE:                     // ~flag
            GetToken(TOKEN_NOEXPRESSION);
            dwOp2 = ~token.longval;
            break;

        default:
            return(FALSE);
    }

    if (!fNest) {
        if (token.type != NUMLIT)
            ParseError2(ERR_NEEDNUM, tokenbuf);

        GetToken(TOKEN_NOEXPRESSION);
    }

    switch (opcode) {
        case TKPLUS:
            *pdwExp += dwOp2;
            break;

        case TKMINUS:
            *pdwExp -= dwOp2;
            break;

        case OR:
            *pdwExp |= dwOp2;
            break;

        case AND:
            *pdwExp &= dwOp2;
            break;
    }

    return(TRUE);
}

BOOL
GetFullExpression(
    void *pval,
    WORD wFlags
    )
{
    BOOL fRes;
    DWORD   dwExp = 0;

    if (!(wFlags & GFE_ZEROINIT))
        dwExp = (wFlags & GFE_SHORT) ? (DWORD) *((WORD *) pval) : *((DWORD UNALIGNED *) pval);

    fRes = MyGetExpression(&dwExp, FALSE);

    if (wFlags & GFE_SHORT)
        *((WORD *) pval) = (WORD) dwExp;
    else
        *((DWORD UNALIGNED *) pval) = dwExp;

    return(fRes);
}

BOOL
MyGetExpression(
    DWORD *pdwExp,
    BOOL fRecursed
    )
{
    WORD    opcode;

    if (!GetOp(pdwExp, OR))
        return(FALSE);

    while (TRUE) {    // break out as appropriate
        if (token.type == NUMLIT) {
            if (token.longval < 0) {
                *pdwExp += token.longval;
                GetToken(TOKEN_NOEXPRESSION);
                continue;
            }
            //
            // This is a hack to fix the problem of a space after a minus sign.
            //    - for example 10 - 5
            //    - if this is a problem, please speak to Jeff Bogden
            //
            if (token.longval == 0 && tokenbuf[0] == L'-' && tokenbuf[1] == L'\0')
                token.type = TKMINUS;
        }

        switch (token.type) {
            case TKPLUS:
            case TKMINUS:
            case OR:
            case AND:
            case TKNOT:
                opcode = token.type;
                GetToken(TOKEN_NOEXPRESSION);

                if (!GetOp(pdwExp, opcode))
                    ParseError2(ERR_NEEDNUM, tokenbuf);
                break;

            case RPAREN:
                if (fRecursed) {
                    GetToken(TOKEN_NOEXPRESSION);
                    return(TRUE);
                } else {
                    goto parenMismatch;
                }

            default:
                if (fRecursed)
parenMismatch:
                ParseError2(ERR_NEEDPAREN, tokenbuf);
                return(TRUE);
        }
    }
}

WORD
MyGetNum(
    WORD *pwEnd,
    BOOL fDouble,
    DWORD *pdwExp
    )
{
    WORD    wRes;
    DWORD   dwExp = 0;

    wRes = MyGetExpression(&dwExp, FALSE) ? PARM_SET : 0;

    if (EndParcel(pwEnd))
        wRes |= PARM_LAST;
    else if (!(token.type == COMMA))
        ParseError2(ERR_BADEXP, tokenbuf);

    if (fDouble)
        *pdwExp = dwExp;
    else
        *((WORD *) pdwExp) = (WORD) dwExp;

    return(wRes);
}

WORD
GetText(
    PWORD pwEnd,
    PWCHAR szDst
    )
{
    BOOL    fEnd;
    BOOL    fPlus = FALSE;
    WORD    wRes = 0;

    while (!(fEnd = EndParcel(pwEnd)) && (token.type != COMMA)) {
        if (CheckStr(szDst)) {
            szDst += wcslen(szDst);

            if (fPlus)
                fPlus = FALSE;
            else if (wRes)
                goto ErrBadStr;

            wRes = PARM_SET;
        } else if ((token.type == TKPLUS) && !fPlus && wRes) {
            fPlus = TRUE;
        } else {
ErrBadStr:
            ParseError2(ERR_BADSTREXP, tokenbuf);
        }

        GetToken(TOKEN_NOEXPRESSION);
    }

    if (fPlus)
        ParseError2(ERR_NEEDSTR, tokenbuf);

    if (fEnd)
        wRes |= PARM_LAST;

    return(wRes);
}

void __cdecl
GetParcel(
    PARCELTYPE parType,
    ...
    )
{
    PARCEL  par = parcels[parType];
    WORD    wParm;
    WORD    wRes;
    va_list ap;
    void    *pParm;
    BOOL    fOptional;
    BOOL    fWriteSymbol = FALSE;

    va_start(ap, parType);

    for (wParm = 1; wParm <= *par.pwParms; wParm++) {
        pParm = va_arg(ap, void *);
        fOptional = par.pwParms[wParm] & PT_OPTIONAL;
        switch (par.pwParms[wParm] & ~PT_OPTIONAL) {
            case PT_TEXT:
                wRes = GetText(par.pwEnd, (PWCHAR) pParm);
                fWriteSymbol = TRUE;
                break;

            case PT_WORD:
                wRes = MyGetNum(par.pwEnd, FALSE, (DWORD *) pParm);
                break;

            case PT_DWORD:
                wRes = MyGetNum(par.pwEnd, TRUE, (DWORD *) pParm);
                break;
        }

        if (!(wRes & PARM_SET) && !fOptional)
            goto ErrMissingParm;

        if (wRes & PARM_LAST) {
            while (wParm < *par.pwParms) {
                if (!(par.pwParms[++wParm] & PT_OPTIONAL))
ErrMissingParm:
                    ParseError2(ERR_NEEDARG, tokenbuf);
            }
            goto Exit;
        }

        GetToken(TOKEN_NOEXPRESSION);

        WriteSymbolUse(&token.sym);
    }

    if (!EndParcel(par.pwEnd))
        ParseError2(ERR_MOREARGS, tokenbuf);

Exit:
    va_end(ap);
}

/*---------------------------------------------------------------------------*/
/*                                                                                                                                                       */
/*      DoMenuItem() -                                                                                                                   */
/*                                                                                                                                                       */
/*---------------------------------------------------------------------------*/

WORD
DoMenuItem(
    int fPopup
    )
{
    MENU    mn;

    mn.wResInfo = fPopup ? MFR_POPUP : 0;
    mn.dwType = 0;
    mn.dwState = 0;
    mn.dwID = 0;
    mn.dwHelpID = 0;
    mn.szText[0] = 0;

    GetToken(TOKEN_NOEXPRESSION); //TRUE);

    if ((token.type == NUMLIT) && (token.val == MFT_SEPARATOR)) {
        if (fPopup)
            ParseError2(ERR_NOSEP, tokenbuf);

        mn.dwType = MFT_SEPARATOR;
        mn.dwState = 0;
        mn.dwID = 0;
        GetToken(TOKEN_NOEXPRESSION); //TRUE);
        if (!EndParcel(parcels[PAR_MENUITEM].pwEnd))
            ParseError2(ERR_MOREARGS, tokenbuf);
    } else if (fPopup) {
        GetParcel(PAR_POPUP, mn.szText, &mn.dwID, &mn.dwType, &mn.dwState, &mn.dwHelpID);
    } else {
        GetParcel(PAR_MENUITEM, mn.szText, &mn.dwID, &mn.dwType, &mn.dwState);
    }

    // set it up in the buffer (?)
    return(SetUpMenu(&mn));
}

/*---------------------------------------------------------------------------*/
/*                                                                                                                                                       */
/*      ParseMenu() -                                                                                                                    */
/*                                                                                                                                                       */
/*---------------------------------------------------------------------------*/

int
ParseMenu(
    int fRecursing,
    PRESINFO pRes           /* TRUE iff popup */
    )
{
    int     bItemRead = FALSE;
    WORD    wEndFlagLoc = 0;
    DWORD   dwHelpID = 0;

    if (!fRecursing) {
        // Write Help ID to header
        GetParcel(PAR_MENU, &dwHelpID);
        WriteLong(dwHelpID);
        PreBeginParse(pRes, 2121);
    } else {
        /* make sure its really a menu */
        if (token.type != BEGIN)
            ParseError1(2121); //"BEGIN expected in menu"
        GetToken(TRUE); // vs. TOKEN_NOEXPRESSION ??
    }

    /* get the individual menu items */
    while (token.type != END) {
        switch (token.type) {
            case TKMENUITEM:
                bItemRead = TRUE;
                wEndFlagLoc = DoMenuItem(FALSE);
                break;

            case TKPOPUP:
                bItemRead = TRUE;
                wEndFlagLoc = DoMenuItem(TRUE);
                ParseMenu(TRUE, pRes);
                break;

            default:
                ParseError2(ERR_BADSUBMENU, tokenbuf);
                break;
        }
    }

    /* did we die on an END? */
    if (token.type != END)
        ParseError2(ERR_NEEDEND, tokenbuf);

    /* make sure we have a menu item */
    if (!bItemRead)
        ParseError2(ERR_NOEMPTYMENU, tokenbuf);

    /* Get next token if this was NOT the last END*/
    if (fRecursing)
        GetToken(TOKEN_NOEXPRESSION);

    /* mark the last item in the menu */
    FixMenuPatch(wEndFlagLoc);

    return (TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\rcdll\rcnewres.h ===
/**
**      Header for the New version of RC.EXE. This contains the structures
**      for new format of BITMAP files.
**/

/*  The width of the name field in the Data for the group resources */

#define  NAMELEN    14

typedef struct tagNEWHEADER
{
    WORD    Reserved;
    WORD    ResType;
    WORD    ResCount;
} NEWHEADER, *PNEWHEADER;

typedef struct tagDESCRIPTOR
{
    BYTE    Width;      // 16, 32, 64
    BYTE    Height;     // 16, 32, 64
    BYTE    ColorCount; //  2,  8, 16
    BYTE    reserved;
    WORD    xHotSpot;
    WORD    yHotSpot;
    DWORD   BytesInRes;
    DWORD   OffsetToBits;
} DESCRIPTOR;

typedef struct tagICONRESDIR
{
    BYTE    Width;      // 16, 32, 64
    BYTE    Height;     // 16, 32, 64
    BYTE    ColorCount; //  2,  8, 16
    BYTE    reserved;
} ICONRESDIR;

typedef struct tagCURSORDIR
{
    WORD    Width;
    WORD    Height;
} CURSORDIR;

typedef struct tagRESDIR
{
    union
    {
        ICONRESDIR   Icon;
        CURSORDIR    Cursor;
    } ResInfo;
    WORD    Planes;
    WORD    BitCount;
    DWORD   BytesInRes;
} RESDIR;

typedef struct tagLOCALHEADER
{
    WORD    xHotSpot;
    WORD    yHotSpot;
} LOCALHEADER;

typedef struct tagBITMAPHEADER
{
    DWORD   biSize;
    DWORD   biWidth;
    DWORD   biHeight;
    WORD    biPlanes;
    WORD    biBitCount;
    DWORD   biStyle;
    DWORD   biSizeImage;
    DWORD   biXPelsPerMeter;
    DWORD   biYPelsPerMeter;
    DWORD   biClrUsed;
    DWORD   biClrImportant;
}  BITMAPHEADER;


#define BFOFFBITS(pbfh) MAKELONG(*(LPWORD)((LPWORD)pbfh+5), \
                                 *(LPWORD)((LPWORD)pbfh+6))

#define TOCORE(bi) (*(BITMAPCOREHEADER *)&(bi))

/****************************************************\
*                                                    *
*      Imported from asdf.h in windows\inc           *
*                                                    *
\****************************************************/

// RIFF chunk header.

typedef struct _RTAG {
    FOURCC ckID;
    DWORD ckSize;
} RTAG, *PRTAG;


// Valid TAG types.

// 'ANI ' - simple ANImation file

#define FOURCC_ACON  mmioFOURCC('A', 'C', 'O', 'N')


// 'anih' - ANImation Header
// Contains an ANIHEADER structure.

#define FOURCC_anih mmioFOURCC('a', 'n', 'i', 'h')


// 'rate' - RATE table (array of jiffies)
// Contains an array of JIFs.  Each JIF specifies how long the corresponding
// animation frame is to be displayed before advancing to the next frame.
// If the AF_SEQUENCE flag is set then the count of JIFs == anih.cSteps,
// otherwise the count == anih.cFrames.

#define FOURCC_rate mmioFOURCC('r', 'a', 't', 'e')


// 'seq ' - SEQuence table (array of frame index values)
// Countains an array of DWORD frame indices.  anih.cSteps specifies how
// many.

#define FOURCC_seq  mmioFOURCC('s', 'e', 'q', ' ')


// 'fram' - list type for the icon list that follows

#define FOURCC_fram mmioFOURCC('f', 'r', 'a', 'm')

// 'icon' - Windows ICON format image (replaces MPTR)

#define FOURCC_icon mmioFOURCC('i', 'c', 'o', 'n')


// Standard tags (but for some reason not defined in MMSYSTEM.H)

#define FOURCC_INFO mmioFOURCC('I', 'N', 'F', 'O')      // INFO list
#define FOURCC_IART mmioFOURCC('I', 'A', 'R', 'T')      // Artist
#define FOURCC_INAM mmioFOURCC('I', 'N', 'A', 'M')      // Name/Title

#if 0 //in winuser.w
typedef DWORD JIF;  // in winuser.w

typedef struct _ANIHEADER {     // anih
    DWORD cbSizeof;
    DWORD cFrames;
    DWORD cSteps;
    DWORD cx, cy;
    DWORD cBitCount, cPlanes;
    JIF   jifRate;
    DWORD fl;
} ANIHEADER, *PANIHEADER;

// If the AF_ICON flag is specified the fields cx, cy, cBitCount, and
// cPlanes are all unused.  Each frame will be of type ICON and will
// contain its own dimensional information.

#define AF_ICON     0x0001L     // Windows format icon/cursor animation

#define AF_SEQUENCE 0x0002L     // Animation is sequenced
#endif

/**************************\
*                          *
*  End Import from asdf.h  *
*                          *
\**************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\rcdll\rcp.c ===
/****************************************************************************/
/*                                                                          */
/*  RCP.C -                                                                 */
/*                                                                          */
/*      Resource Compiler 3.00 - Top Level Parsing routines                 */
/*                                                                          */
/****************************************************************************/

#include "rc.h"


static BOOL fFontDirRead = FALSE;

BOOL    bExternParse = FALSE;

WORD    language = MAKELANGID(LANG_ENGLISH, SUBLANG_ENGLISH_US);
LONG    version = 0;
LONG    characteristics = 0;

static int rowError = 0;
static int colError = 0;
static int idError = 0;


/*--------------------------------------------------------------------------*/
/*                                                                          */
/*  ParseError3() -                                                         */
/*                                                                          */
/*--------------------------------------------------------------------------*/

void
ParseError3(
    int id
    )
{
    // Don't get caught giving the same error over and over and over...
    if ((Nerrors > 0) && (idError == id) && (rowError == token.row) && (colError == token.col))
        quit("\n");

    SendError("\n");
    SendError(Msg_Text);

    if (++Nerrors > 25)
        quit("\n");

    rowError = token.row;
    colError = token.col;
    idError = id;
}

/*--------------------------------------------------------------------------*/
/*                                                                          */
/*  ParseError2() -                                                         */
/*                                                                          */
/*--------------------------------------------------------------------------*/

void
ParseError2(
    int id,
    PWCHAR arg
    )
{
    // Don't get caught giving the same error over and over and over...
    if ((Nerrors > 0) && (idError == id) && (rowError == token.row) && (colError == token.col))
        quit("\n");

    SendError("\n");
    SET_MSG(Msg_Text, sizeof(Msg_Text), GET_MSG(id), curFile, token.row, arg);
    SendError(Msg_Text);

    if (++Nerrors > 25)
        quit("\n");

    rowError = token.row;
    colError = token.col;
    idError = id;
}


/*--------------------------------------------------------------------------*/
/*                                                                          */
/*  ParseError1() -                                                         */
/*                                                                          */
/*--------------------------------------------------------------------------*/

void
ParseError1(
    int id
    )
{
    // Don't get caught giving the same error over and over and over...
    if ((Nerrors > 0) && (idError == id) && (rowError == token.row) && (colError == token.col))
        quit("\n");

    SendError("\n");
    SET_MSG(Msg_Text, sizeof(Msg_Text), GET_MSG(id), curFile, token.row);
    SendError(Msg_Text);

    if (++Nerrors > 25)
        quit("\n");

    rowError = token.row;
    colError = token.col;
    idError = id;
}


/*--------------------------------------------------------------------------*/
/*                                                                          */
/*  GetFileName() -                                                         */
/*                                                                          */
/*--------------------------------------------------------------------------*/

/* Read in a filename from the RC file. */

LONG
GetFileName(
    VOID
    )
{
    PFILE fh;
    LONG size;
    CHAR szFilename[_MAX_PATH];
    CHAR buf[_MAX_PATH];

    // Note: Always use the Ansi codepage here.  uiCodePage may have been
    // modified by a codepage pragma in the source file.

    WideCharToMultiByte(GetACP(), 0, tokenbuf, -1, buf, _MAX_PATH, NULL, NULL);
    searchenv(buf, "INCLUDE", szFilename);
    if ( szFilename[0] && ((fh = fopen(szFilename, "rb")) != NULL)) {
        size = MySeek(fh, 0L, SEEK_END);                /* find size of file */
        MySeek(fh, 0L, SEEK_SET);                       /* return to start of file */
        CtlFile(fh);
        return(size);
    } else {
        ParseError2(2135, (PWCHAR)buf);
        return 0;
    }
}


/*--------------------------------------------------------------------------*/
/*                                                                          */
/*  AddStringToBin() -                                                      */
/*                                                                          */
/*--------------------------------------------------------------------------*/

/* adds ordinal if non-zero, otherwise adds string.  In either case, puts */
/* it in a field of NCHARS [16] */

VOID
AddStringToBin(
    USHORT ord,
    WCHAR *sz
    )
{
    USHORT      n1 = 0xFFFF;

    /* Is this an ordinal type? */
    if (ord) {
        MyWrite(fhBin, (PCHAR)&n1, sizeof(USHORT));     /* 0xFFFF */
        MyWrite(fhBin, (PCHAR)&ord, sizeof(USHORT));
    } else {
        MyWrite(fhBin, (PVOID)sz, (wcslen(sz)+1) * sizeof(WCHAR));
    }
}


PWCHAR   pTypeName[] =
{
    NULL,                //  0
    L"CURSOR",           //  1 RT_CURSOR
    L"BITMAP",           //  2 RT_BITMAP
    L"ICON",             //  3 RT_ICON
    L"MENU",             //  4 RT_MENU
    L"DIALOG",           //  5 RT_DIALOG
    L"STRING",           //  6 RT_STRING
    L"FONTDIR",          //  7 RT_FONTDIR
    L"FONT",             //  8 RT_FONT
    L"ACCELERATOR",      //  9 RT_ACCELERATOR
    L"RCDATA",           // 10 RT_RCDATA
    L"MESSAGETABLE",     // 11 RT_MESSAGETABLE
    L"GROUP_CURSOR",     // 12 RT_GROUP_CURSOR
    NULL,                // 13 RT_NEWBITMAP -- according to NT
    L"GROUP_ICON",       // 14 RT_GROUP_ICON
    NULL,                // 15 RT_NAMETABLE
    L"VERSION",          // 16 RT_VERSION
    L"DIALOGEX",         // 17 RT_DIALOGEX     ;internal
    L"DLGINCLUDE",       // 18 RT_DLGINCLUDE
    L"PLUGPLAY",         // 19 RT_PLUGPLAY
    L"VXD",              // 20 RT_VXD
    L"ANICURSOR",        // 21 RT_ANICURSOR    ;internal
    L"ANIICON",          // 22 RT_ANIICON      ;internal
    L"HTML"              // 23 RT_HTML
};

// Note: Don't forget to update the same table in rcdump.c

/*--------------------------------------------------------------------------*/
/*                                                                          */
/*  AddBinEntry() -                                                         */
/*                                                                          */
/*--------------------------------------------------------------------------*/

/* FORMAT: type, name, flags, length, bytes */

VOID
AddBinEntry(
    PTYPEINFO pType,
    PRESINFO pRes,
    PCHAR Array,
    int ArrayCount,
    LONG FileCount
    )
{
    ULONG       hdrSize = sizeof(RESADDITIONAL);
    ULONG       t0 = 0;
    ULONG       cbPad=0;

    if (!pRes->size)
        pRes->size = ResourceSize();

    if (pType->typeord == 0) {
        hdrSize += (wcslen(pType->type) + 1) * sizeof(WCHAR);
        cbPad += (wcslen(pType->type) + 1) * sizeof(WCHAR);
    } else {
        hdrSize += 2 * sizeof(WORD);
    }

    if (pRes->nameord == 0) {
        hdrSize += (wcslen(pRes->name) + 1) * sizeof(WCHAR);
        cbPad += (wcslen(pRes->name) + 1) * sizeof(WCHAR);
    } else {
        hdrSize += 2 * sizeof(WORD);
    }

    if (cbPad % 4)
        hdrSize += sizeof(WORD);        // could only be off by 2

    if (fVerbose) {
        if (pType->typeord == 0) {
            if (pRes->nameord == 0)
                wsprintfA(Msg_Text, "\nWriting %ws:%ws,\tlang:0x%x,\tsize %d",
                        pType->type, pRes->name, pRes->language, pRes->size);
            else
                wsprintfA(Msg_Text, "\nWriting %ws:%d,\tlang:0x%x,\tsize %d",
                        pType->type, pRes->nameord, pRes->language, pRes->size);
        } else {
            if (pRes->nameord == 0) {
                if (pType->typeord <= (USHORT)(UINT_PTR)RT_LAST)
                    wsprintfA(Msg_Text, "\nWriting %ws:%ws,\tlang:0x%x,\tsize %d",
                              pTypeName[pType->typeord],
                              pRes->name, pRes->language, pRes->size);
                else
                    wsprintfA(Msg_Text, "\nWriting %d:%ws,\tlang:0x%x,\tsize %d",
                              pType->typeord,
                              pRes->name, pRes->language, pRes->size);
            } else {
                if (pType->typeord <= (USHORT)(UINT_PTR)RT_LAST)
                    wsprintfA(Msg_Text, "\nWriting %ws:%d,\tlang:0x%x,\tsize %d",
                              pTypeName[pType->typeord],
                              pRes->nameord, pRes->language, pRes->size);
                else
                    wsprintfA(Msg_Text, "\nWriting %d:%d,\tlang:0x%x,\tsize %d",
                              pType->typeord,
                              pRes->nameord, pRes->language, pRes->size);
            }
        }
        printf(Msg_Text);
    }

    if (fMacRsrcs) {
        /* record file location for the resource map and dump out
        resource's size */
        DWORD dwT;
        pRes->BinOffset = (long)MySeek(fhBin,0L,1) - MACDATAOFFSET;
        dwT = SwapLong(pRes->size);
        MyWrite(fhBin, &dwT, 4);
    } else {
        /* add type, name, flags, and resource length */
        MyWrite(fhBin, (PCHAR)&pRes->size, sizeof(ULONG));
        MyWrite(fhBin, (PCHAR)&hdrSize, sizeof(ULONG));

        AddStringToBin(pType->typeord, pType->type);
        AddStringToBin(pRes->nameord , pRes->name);
        MyAlign(fhBin);

        MyWrite(fhBin, (PCHAR)&t0, sizeof(ULONG));  /* data version */
        MyWrite(fhBin, (PCHAR)&pRes->flags, sizeof(WORD));
        MyWrite(fhBin, (PCHAR)&pRes->language, sizeof(WORD));
        MyWrite(fhBin, (PCHAR)&pRes->version, sizeof(ULONG));
        MyWrite(fhBin, (PCHAR)&pRes->characteristics, sizeof(ULONG));

        /* record file location for the .EXE construction */
        pRes->BinOffset = (LONG)MySeek(fhBin, 0L, SEEK_CUR);
    }

    /* write array plus contents of resource source file */
    WriteControl(fhBin, Array, ArrayCount, FileCount);
}


/*--------------------------------------------------------------------------*/
/*                                                                          */
/*  AddResToResFile(pType, pRes, Array, ArrayCount, FileCount)              */
/*                                                                          */
/*  Parameters:                                                             */
/*      pType  : Pointer to Res Type                                        */
/*      pRes   : Pointer to resource                                        */
/*      Array  : Pointer to array from which some data is to be copied into */
/*               the .RES file.                                             */
/*               This is ignored if ArrayCount is zero.                     */
/*      ArrayCount : This is the number of bytes to be copied from "Array"  */
/*                   into the .RES file. This is zero if no copy is required*/
/*      FileCount  : This specifies the number of bytes to be copied from   */
/*                   fhCode into fhOut. If this is -1, the complete input   */
/*                   file is to be copied into fhOut.                       */
/*                                                                          */
/*------------------------------------------------------------------------*/

VOID
AddResToResFile(
    PTYPEINFO pType,
    PRESINFO pRes,
    PCHAR Array,
    int ArrayCount,
    LONG FileCount
    )
{
    PRESINFO p;

    p = pType->pres;

    /* add resource to end of resource list for this type */
    if (p) {
        while (p->next)
            p = p->next;

        p->next = pRes;
    } else {
        pType->pres = pRes;
    }


    /* add the resource to the .RES File */
    AddBinEntry(pType, pRes, Array, ArrayCount, FileCount);

    /* keep track of number of resources and types */
    pType->nres++;
    ResCount++;
    WriteResInfo(pRes, pType, TRUE);
}


/*--------------------------------------------------------------------------*/
/*                                                                          */
/*  AddResType() -                                                          */
/*                                                                          */
/*--------------------------------------------------------------------------*/

PTYPEINFO
AddResType(
    PWCHAR s,
    LPWSTR l
    )
{
    PTYPEINFO  pType;

    if ((pType = pTypInfo) != 0) {
        for (; ; ) {
            /* search for resource type, return if already exists */
            if ((s && pType->type && !wcscmp(s, pType->type)) ||
                (!s && l && pType->typeord == (USHORT)l))
                return(pType);
            else if (!pType->next)
                break;
            else
                pType = pType->next;
        }

        /* if not in list, add space for it */
        pType->next = (PTYPEINFO)MyAlloc(sizeof(TYPEINFO));
        pType = pType->next;
    } else {
        /* allocate space for resource list */
        pTypInfo = (PTYPEINFO)MyAlloc(sizeof(TYPEINFO));
        pType = pTypInfo;
    }

    /* fill allocated space with name and ordinal, and clear the resources
         of this type */
    pType->type = MyMakeStr(s);
    pType->typeord = (USHORT)l;
    pType->nres = 0;
    pType->pres = NULL;

    return(pType);
}


/*--------------------------------------------------------------------------*/
/*                                                                          */
/*  DGetMemFlags() -                                                        */
/*                                                                          */
/*--------------------------------------------------------------------------*/

int
DGetMemFlags (
    PRESINFO pRes
    )
{
    if (token.type == NUMLIT)
        // this is a numeric value, not a mem flag -- this means we're done
        // processing memory flags
        return(FALSE);

    /* adjust memory flags of resource */
    switch (token.val) {
        case TKMOVEABLE:
            pRes->flags |= NSMOVE;
            break;

        case TKFIXED:
            pRes->flags &= ~(NSMOVE | NSDISCARD);
            break;

        case TKPURE :
            pRes->flags |= NSPURE;
            break;

        case TKIMPURE :
            pRes->flags &= ~(NSPURE | NSDISCARD);
            break;

        case TKPRELOAD:
            pRes->flags |= NSPRELOAD;
            break;

        case TKLOADONCALL:
            pRes->flags &= ~NSPRELOAD;
            break;

        case TKDISCARD:
            pRes->flags |= NSMOVE | NSPURE | NSDISCARD;
            break;

        case TKEXSTYLE:
            GetToken(FALSE);        /* ignore '=' */
            if (token.type != EQUAL)
                ParseError1(2136);
            GetTokenNoComma(TOKEN_NOEXPRESSION);
            GetFullExpression(&pRes->exstyleT, GFE_ZEROINIT);
            break;

            /* if current token not memory flag, return FALSE to indicate not
             to continue parsing flags */
        default:
            return(FALSE);
    }

    GetToken(FALSE);

    /* TRUE ==> found memory flag */
    return(TRUE);
}


/*--------------------------------------------------------------------------*/
/*                                                                          */
/*  AddDefaultTypes() -                                                     */
/*                                                                          */
/*--------------------------------------------------------------------------*/

VOID
AddDefaultTypes(
    VOID
    )
{
    AddResType(L"CURSOR", RT_GROUP_CURSOR);
    AddResType(L"ICON", RT_GROUP_ICON);
    AddResType(L"BITMAP", RT_BITMAP);
    AddResType(L"MENU", RT_MENU);
    AddResType(L"DIALOG", RT_DIALOG);
    AddResType(L"STRINGTABLE", RT_STRING);
    AddResType(L"FONTDIR", RT_FONTDIR);
    AddResType(L"FONT", RT_FONT);
    AddResType(L"ACCELERATORS", RT_ACCELERATOR);
    AddResType(L"RCDATA", RT_RCDATA);
    AddResType(L"MESSAGETABLE", RT_MESSAGETABLE);
    AddResType(L"VERSIONINFO", RT_VERSION);
    AddResType(L"DLGINCLUDE", RT_DLGINCLUDE);
    AddResType(L"MENUEX", RT_MENUEX);
    AddResType(L"DIALOGEX", RT_DIALOGEX);
    AddResType(L"PLUGPLAY", RT_PLUGPLAY);
    AddResType(L"VXD", RT_VXD);

    // AFX resource types.
    AddResType(L"DLGINIT", RT_DLGINIT);
    AddResType(L"TOOLBAR", RT_TOOLBAR);

    AddResType(L"ANIICON",   RT_ANIICON);
    AddResType(L"ANICURSOR", RT_ANICURSOR);

    AddResType(L"HTML", RT_HTML);
}


/*--------------------------------------------------------------------------*/
/*                                                                          */
/*  AddFontDir() -                                                          */
/*                                                                          */
/*--------------------------------------------------------------------------*/

VOID
AddFontDir(
    VOID
    )
{
    PRESINFO   pRes;
    PTYPEINFO  pType;
    PFONTDIR   pFont;

    /* make new resource */
    pRes = (PRESINFO)MyAlloc(sizeof(RESINFO));
    pRes->language = language;
    pRes->version = version;
    pRes->characteristics = characteristics;
    pRes->name = MyMakeStr(L"FONTDIR");

    /* find or create the type list */
    pType = AddResType(NULL, RT_FONTDIR);

    CtlInit();

    WriteWord(nFontsRead);

    pFont = pFontList;

    while (pFont) {
        WriteWord(pFont->ordinal);
        WriteBuffer((PCHAR)(pFont + 1), pFont->nbyFont);
        pFont = pFont->next;
    }

    pRes->flags = NSMOVE | NSPRELOAD;

    /* write to the .RES file */
    SaveResFile(pType, pRes);
}


/*--------------------------------------------------------------------------*/
/*                                                                          */
/*  ReadRF() -                                                              */
/*                                                                          */
/*--------------------------------------------------------------------------*/

/* top level parsing function: recognizes an RC script */

int
ReadRF(
    VOID
    )
{
    PRESINFO    pRes;
    PTYPEINFO   pType;
    ULONG       zero=0;
    WORD        ffff=0xffff;
    ULONG       hdrSize = sizeof(RESADDITIONAL) + 2 * (sizeof(WORD) * 2);

    ResCount = 0;
    nFontsRead = 0;

    /* Initialize data structures. */
    AddDefaultTypes();

    if (!fMacRsrcs) {
        /* write 32-bit header for empty resource/signature */
        MyWrite(fhBin, (PCHAR)&zero, sizeof(ULONG));
        MyWrite(fhBin, (PCHAR)&hdrSize, sizeof(ULONG));
        MyWrite(fhBin, (PCHAR)&ffff, sizeof(WORD));
        MyWrite(fhBin, (PCHAR)&zero, sizeof(WORD));
        MyWrite(fhBin, (PCHAR)&ffff, sizeof(WORD));
        MyWrite(fhBin, (PCHAR)&zero, sizeof(WORD));
        MyWrite(fhBin, (PCHAR)&zero, sizeof(ULONG));
        MyWrite(fhBin, (PCHAR)&zero, sizeof(WORD));
        MyWrite(fhBin, (PCHAR)&zero, sizeof(WORD));
        MyWrite(fhBin, (PCHAR)&zero, sizeof(ULONG));
        MyWrite(fhBin, (PCHAR)&zero, sizeof(ULONG));
    }

    CtlAlloc();

    if (fAFXSymbols) {
        char* pch = inname;
        // write out first HWB resource

        CtlInit();
        pRes = (PRESINFO)MyAlloc(sizeof(RESINFO));
        pRes->language = language;
        pRes->version = version;
        pRes->characteristics = characteristics;

        pRes->size = sizeof(DWORD);
        pRes->flags = 0;
        pRes->name = 0;
        pRes->nameord = 1;
        WriteLong(0);           /* space for file pointer */
        while (*pch) {
            WriteByte(*pch++);
            pRes->size++;
        }
        WriteByte(0);
        pRes->size++;

        pType = AddResType(L"HWB", 0);
        SaveResFile(pType, pRes);
        lOffIndex = pRes->BinOffset;
    }

    /* Process the RC file. */
    do {
        token.sym.name[0] = L'\0';
        token.sym.nID = 0;

        /* Find the beginning of the next resource. */
        if (!GetNameOrd())
            break;

        if (!wcscmp(tokenbuf, L"LANGUAGE")) {
            language = GetLanguage();
            continue;
        } else if (!wcscmp(tokenbuf, L"VERSION")) {
            GetToken(FALSE);
            if (token.type != NUMLIT)
                ParseError1(2139);
            version = token.longval;
            continue;
        } else if (!wcscmp(tokenbuf, L"CHARACTERISTICS")) {
            GetToken(FALSE);
            if (token.type != NUMLIT)
                ParseError1(2140);
            characteristics = token.longval;
            continue;
        }

        /* Print a dot for each resource processed. */
        if (fVerbose) {
            printf(".");
        }

        /* Allocate space for the new resources Info structure. */
        pRes = (PRESINFO)MyAlloc(sizeof(RESINFO));
        pRes->language = language;
        pRes->version = version;
        pRes->characteristics = characteristics;

        if (token.sym.name[0]) {
            /* token has a real symbol associated with it */
            memcpy(&pRes->sym, &token.sym, sizeof(SYMINFO));
        } else {
            pRes->sym.name[0] = L'\0';
        }

        if (!token.val) {
            if (wcslen(tokenbuf) > MAXTOKSTR-1) {
                SET_MSG(Msg_Text, sizeof(Msg_Text), GET_MSG(4206), curFile, token.row);
                SendError(Msg_Text);
                tokenbuf[MAXTOKSTR-1] = L'\0';
                token.val = MAXTOKSTR-2;
            }
            pRes->name = MyMakeStr(tokenbuf);
        } else {
            pRes->nameord = token.val;
        }

      /* If not a string table, find out what kind of resource follows.
       * The StringTable is a special case since the Name field is the
       * string's ID number mod 16.
       */
        if ((pRes->name == NULL) || wcscmp(pRes->name, L"STRINGTABLE")) {
            if (!GetNameOrd())
                break;

            if (!token.val) {
                if (wcslen(tokenbuf) > MAXTOKSTR-1) {
                    SET_MSG(Msg_Text, sizeof(Msg_Text), GET_MSG(4207), curFile, token.row);
                    SendError(Msg_Text);
                    tokenbuf[MAXTOKSTR-1] = L'\0';
                    token.val = MAXTOKSTR-2;
                }
                if (!wcscmp(tokenbuf, L"STRINGTABLE")) {
                    // User attempted to create a named string table... Bail
                    ParseError1(2255);
                    pRes->name = MyMakeStr(tokenbuf);
                    goto ItsAStringTable;
                }

                pType = AddResType(tokenbuf, MAKEINTRESOURCE(0));
            }
            else
                pType = AddResType(NULL, MAKEINTRESOURCE(token.val));

            if (!pType)
                return(errorCount == 0);

            /* Parse any user specified memory flags. */
            GetToken(FALSE);

            switch ((INT_PTR)pType->typeord) {
                    /* Calculated resources default to discardable. */
                case (INT_PTR)RT_ICON:
                case (INT_PTR)RT_CURSOR:
                case (INT_PTR)RT_FONT:
                case (INT_PTR)RT_DIALOG:
                case (INT_PTR)RT_MENU:
                case (INT_PTR)RT_DLGINCLUDE:
                case (INT_PTR)RT_DIALOGEX:
                case (INT_PTR)RT_MENUEX:
                    pRes->flags = NSMOVE | NSPURE | NSDISCARD;
                    break;

                case (INT_PTR)RT_GROUP_ICON:
                case (INT_PTR)RT_GROUP_CURSOR:
                    pRes->flags = NSMOVE | NSDISCARD;
                    break;

                    /* All other resources default to moveable. */
                default:
                    pRes->flags = NSMOVE | NSPURE;
                    break;
            }

            /* adjust according to the user's specifications
           */
            while (DGetMemFlags(pRes))
                ;

            // write out start of new resource
            WriteResInfo(pRes, pType, FALSE);
        } else {

ItsAStringTable:

            /* Parse any user specified memory flags. */
            GetToken(FALSE);

            /* String and Error resources default to discardable. */
            pRes->flags = NSMOVE | NSPURE | NSDISCARD;
            while (DGetMemFlags(pRes))
                ;

            pType = NULL;
        }

        if (!pType) {
            /* parse the string table, if that's what it is */
            if ((pRes->name != NULL) && (!wcscmp(pRes->name, L"STRINGTABLE"))) {
                if (GetTable(pRes) == NULL)
                    break;
            } else {
                ParseError1(2141);
            }
        } else {
            CtlInit();
            pRes->size = 0L;

            /* call parsing and generating functions specific to the various
             resource types */
            switch ((INT_PTR)pType->typeord) {
                case (INT_PTR)RT_DIALOGEX:
                    /* allocate dialog memory */
                    pLocDlg = (PDLGHDR) MyAlloc(sizeof(DLGHDR));

                    /* parse dialog box */
                    GetDlg(pRes, pLocDlg, TRUE);

                    /* write dialog box */
                    SaveResFile(AddResType(L"DIALOG", 0), pRes);

                    /* free dialog memory */
                    MyFree(pLocDlg);
                    break;

                case (INT_PTR)RT_DIALOG:
                    /* allocate dialog memory */
                    pLocDlg = (PDLGHDR) MyAlloc(sizeof(DLGHDR));

                    /* parse dialog box */
                    GetDlg(pRes, pLocDlg, FALSE);

                    /* write dialog box */
                    SaveResFile(pType, pRes);

                    /* free dialog memory */
                    MyFree(pLocDlg);
                    break;

                case (INT_PTR)RT_ACCELERATOR:
                    GetAccelerators(pRes);
                    SaveResFile(pType, pRes);
                    break;

                case (INT_PTR)RT_MENUEX:
                    WriteWord(MENUITEMTEMPLATEVERSIONNUMBER);
                    WriteWord(MENUITEMTEMPLATEBYTESINHEADER);
                    ParseMenu(FALSE, pRes);
                    SaveResFile(AddResType(L"MENU", 0), pRes);
                    break;

                case (INT_PTR)RT_MENU:
                    WriteWord(OLDMENUITEMTEMPLATEVERSIONNUMBER);
                    WriteWord(OLDMENUITEMTEMPLATEBYTESINHEADER);
                    ParseOldMenu(FALSE, pRes);
                    SaveResFile(pType, pRes);
                    break;

                case (INT_PTR)RT_ICON:
                case (INT_PTR)RT_CURSOR:
                    WriteFileInfo(pRes, pType, tokenbuf);
                    pRes->size = GetFileName();
                    if (pRes->size) {
                        if (FileIsAnimated(pRes->size)) {
                            goto ani;
                        } else {
                            pRes->size = GetIcon(pRes->size);
                            SaveResFile(pType, pRes);
                        }
                    }
                    break;

                case (INT_PTR) RT_ANIICON:
                case (INT_PTR) RT_ANICURSOR:
ani:
                    {
                        USHORT iLastTypeOrd = pType->typeord;

                        // Strictly speaking, ANIICON and ANICURSOR are not allowed.  However,
                        // we'll keep them around for the time being.  BryanT 8/14/96.
                        if ((pType->typeord == (USHORT)(INT_PTR)RT_ICON) ||
                            (pType->typeord == (USHORT)(INT_PTR)RT_GROUP_ICON))
                        {
                            pType->typeord = (USHORT)(INT_PTR)RT_ANIICON;
                        } else
                        if ((pType->typeord == (USHORT)(INT_PTR) RT_CURSOR) ||
                            (pType->typeord == (USHORT)(INT_PTR) RT_GROUP_CURSOR))
                        {
                            pType->typeord = (USHORT)(INT_PTR)RT_ANICURSOR;
                        }
                        WriteFileInfo(pRes, pType, tokenbuf);
                        pRes->size = GetFileName();
                        if (pRes->size) {
                            pRes->size = GetAniIconsAniCursors(pRes->size);
                            SaveResFile(pType, pRes);
                        }

                        pType->typeord = iLastTypeOrd;
                    }
                    break;

                case (INT_PTR)RT_BITMAP:
                    WriteFileInfo(pRes, pType, tokenbuf);
                    pRes->size = GetFileName();
                    if (pRes->size) {
                        /* Bitmap in DIB format */
                        pRes ->size = GetNewBitmap();
                        SaveResFile(pType, pRes);
                    }
                    break;

                case (INT_PTR)RT_GROUP_ICON:
                    WriteFileInfo(pRes, pType, tokenbuf);
                    pRes->size = GetFileName();
                    if (pRes->size) {
                        if (FileIsAnimated(pRes->size)) {
                            goto ani;
                        } else {
                            if (fMacRsrcs)
                                GetMacIcon(pType, pRes);
                            else
                                GetNewIconsCursors(pType, pRes, RT_ICON);
                        }
                    }
                    break;

                case (INT_PTR)RT_GROUP_CURSOR:
                    WriteFileInfo(pRes, pType, tokenbuf);
                    pRes->size = GetFileName();
                    if (pRes->size) {
                        if (FileIsAnimated(pRes->size)) {
                            goto ani;
                        } else {
                            if (fMacRsrcs)
                                GetMacCursor(pType, pRes);
                            else
                                GetNewIconsCursors(pType, pRes, RT_CURSOR);
                        }
                    }
                    break;

                case (INT_PTR)RT_FONT:
                    WriteFileInfo(pRes, pType, tokenbuf);
                    pRes->size = GetFileName();
                    if (pRes->name)
                        ParseError1(2143);
                    if (AddFontRes(pRes)) {
                        nFontsRead++;
                        SaveResFile(pType, pRes);
                    }
                    break;

                case (INT_PTR)RT_FONTDIR:
                    WriteFileInfo(pRes, pType, tokenbuf);
                    fFontDirRead = TRUE;
                    pRes->size = GetFileName();
                    if (pRes->size) {
                        SaveResFile(pType, pRes);
                    }
                    break;

                case (INT_PTR)RT_MESSAGETABLE:
                    pRes->size = GetFileName();
                    if (pRes->size) {
                        SaveResFile(pType, pRes);
                    }
                    break;

                case (INT_PTR)RT_VERSION:
                    VersionParse();
                    SaveResFile(pType, pRes);
                    break;

                case (INT_PTR)RT_DLGINCLUDE:
                    DlgIncludeParse(pRes);
                    SaveResFile(pType, pRes);
                    break;

                case (INT_PTR)RT_TOOLBAR:
                    GetToolbar(pRes);
                    SaveResFile(pType, pRes);
                    break;

                case (INT_PTR)RT_RCDATA:
                case (INT_PTR)RT_DLGINIT:
                default:
                    if (token.type != BEGIN) {
                        pRes->size = GetFileName();
                        if (pRes->size) {
                            WriteFileInfo(pRes, pType, tokenbuf);
                        }
                    } else {
                        RESINFO_PARSE rip;

                        bExternParse = FALSE;

                        // Check to see if caller wants to parse this.
                        if (lpfnParseCallback != NULL) {
                            rip.size = 0L;
                            rip.type = pType->type;
                            rip.typeord = pType->typeord;
                            rip.name = pRes->name;
                            rip.nameord = pRes->nameord;
                            rip.flags = pRes->flags;
                            rip.language = pRes->language;
                            rip.version = pRes->version;
                            rip.characteristics = pRes->characteristics;

                            bExternParse = (*lpfnParseCallback)(&rip, NULL, NULL);
                        }

                        if (!bExternParse) {
                            GetRCData(pRes);
                        } else {
                            CONTEXTINFO_PARSE cip;
                            CHAR mbuff[512];    // REVIEW: Long filenames??  See error.c also.

                            extern PCHAR CodeArray;
                            extern int CodeSize;
                            extern int CCount;

                            int nBegins = 1;
                            int nCountSave; // CCount before END token reached

                            cip.hHeap = hHeap;
                            cip.hWndCaller = hWndCaller;
                            cip.lpfnMsg = lpfnMessageCallback;
                            cip.line = token.row;

                            wsprintfA(mbuff, "%s(%%d) : %%s", curFile);
                            cip.format = mbuff;

                            // Collect data for caller to parse.
                            while(nBegins > 0) {
                                nCountSave = CCount;
                                GetToken(FALSE);
                                if (token.type == BEGIN)
                                    nBegins++;
                                else if (token.type == END)
                                    nBegins--;
                            }

                            bExternParse = FALSE;

                            if ((rip.size = nCountSave) > 0 &&
                                !(*lpfnParseCallback)(&rip, (void **) &CodeArray, &cip)) {
                                // Assume caller gave error message, and quit.
                                quit("\n");
                            }

                        pRes->size = CCount = CodeSize = rip.size;
                        }
                    }

                    SaveResFile(pType, pRes);
                    break;
            }
            // write out end of new resource
            WriteResInfo(NULL, NULL, FALSE);
        }
    } while (token.type != EOFMARK);

    /* if we added fonts without a font directory, add one */
    if (!fFontDirRead && nFontsRead)
        AddFontDir();

    /* write string table */
    if (pResString != NULL)
        WriteTable(pResString);

    /* write Mac resource map */
    if (fMacRsrcs)
        WriteMacMap();

    CtlFree();

    if (fVerbose) {
        printf("\n");
    }
    return(errorCount == 0);
}


WORD
GetLanguage()
{
    WORD    language;

    GetToken(FALSE);
    if (token.type != NUMLIT) {
        ParseError1(2144);
        return MAKELANGID(LANG_NEUTRAL, SUBLANG_NEUTRAL);
    }
    if (token.flongval) {
        ParseError1(2145);
        return MAKELANGID(LANG_NEUTRAL, SUBLANG_NEUTRAL);
    }
    language = token.val;
    GetToken(FALSE);
    if (token.type != COMMA) {
        ParseError1(2146);
        return MAKELANGID(LANG_NEUTRAL, SUBLANG_NEUTRAL);
    }
    GetToken(FALSE);
    if (token.type != NUMLIT) {
        ParseError1(2147);
        return MAKELANGID(LANG_NEUTRAL, SUBLANG_NEUTRAL);
    }
    if (token.flongval) {
        ParseError1(2148);
        return MAKELANGID(LANG_NEUTRAL, SUBLANG_NEUTRAL);
    }

    return MAKELANGID(language, token.val);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\rcdll\rcppext.h ===
extern  WCHAR   Union_str[];
extern  WCHAR   Struct_str[];
extern  WCHAR   Cdecl_str[];
extern  WCHAR   Cdecl1_str[];
extern  WCHAR   Fortran_str[];
extern  WCHAR   Fortran1_str[];
extern  WCHAR   Pascal_str[];
extern  WCHAR   Pascal1_str[];
extern  WCHAR   PPelse_str[];
extern  WCHAR   PPendif_str[];
extern  WCHAR   PPifel_str[];
extern  WCHAR   Syntax_str[];

extern  FILE    * OUTPUTFILE;

extern  WCHAR   * A_string;
extern  WCHAR   * Debug;
extern  WCHAR   * Input_file;
extern  WCHAR   * Output_file;
extern  WCHAR   * Q_string;
extern  WCHAR   * Version;
extern  int     In_alloc_text;
extern  int     Bad_pragma;
extern  int     Cross_compile;
extern  int     Ehxtension;
extern  int     HugeModel;
extern  LIST    Defs;
extern  LIST    UnDefs;
extern  LIST    Includes;
extern  lextype_t yylval;
extern  token_t Basic_token;
extern  WCHAR   * Basename;
extern  WCHAR   * Path_chars;
extern  int     Char_align;
extern  int     Dump_tables;
extern  int     StunOpSeen;
extern  int     Inteltypes;
extern  int     List_type;
extern  int     Need_enddata;
extern  int     Nerrors;
extern  int     NoPasFor;

extern  int     Cmd_intrinsic;
extern  int     Cmd_pointer_check;
extern  int     Pointer_check;
extern  int     Cmd_stack_check;
extern  int     Stack_check;
extern  int     Cmd_loop_opt;
extern  int     Loop_opt;
extern  int     Cmd_pack_size;
extern  int     Pack_size;

extern  int     N_types;
extern  int     Got_type;
extern  int     Out_funcdef;
extern  int     Plm;
extern  int     Prep;
extern  int     Prep_ifstack;
extern  int     Ret_seen;
extern  int     Srclist;
extern  int     Stack_depth;
extern  int     Symbolic_debug;
extern  int     Table_index;
extern  int     Switch_check;
extern  int     Load_ds_with;
extern  int     Plmn;
extern  int     Plmf;
extern  int     Cflag;
extern  int     Eflag;
extern  int     Jflag;
extern  int     Pflag;
extern  int     Rflag;
extern  int     ZcFlag;
extern  int     StunDepth;

extern  long    Enum_val;
extern  long    Max_ival[];
extern  table_t *Table_stack[];

extern  int     Extension;

extern  WCHAR   *Filename;
extern  int     Linenumber;
extern  WCHAR   Filebuff[MED_BUFFER + 1];
extern  CHAR    chBuf[MED_BUFFER+1];
extern  WCHAR   Reuse_W[BIG_BUFFER];
extern  hash_t  Reuse_W_hash;
extern  UINT    Reuse_W_length;
extern  WCHAR   Reuse_Include[MED_BUFFER+1];
extern  WCHAR   Macro_buffer[BIG_BUFFER * 4];
extern  int     In_define;
extern  int     InIf;
extern  int     InInclude;
extern  int     Macro_depth;
extern  int     On_pound_line;
extern  int     Listing_value;
extern  token_t Currtok;

extern  long    Currval;
extern  int     Comment_type;
extern  WCHAR   *Comment_string;
extern  int     Tiny_lexer_nesting;
extern  WCHAR   *Exp_ptr;
extern  int     ifstack[IFSTACK_SIZE];

extern WCHAR    Contmap[], Charmap[];

extern keytab_t Tokstrings[];

#define EXTENSION    (Extension || Ehxtension)

/*** I/O Variable for PreProcessor ***/
extern  ptext_t Current_char;

/*** w-BrianM - Re-write of fatal(), error() ***/
extern CHAR     Msg_Text[MSG_BUFF_SIZE];
extern PCHAR    Msg_Temp;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\rcdll\rcppdecl.h ===
/************************************************************************/
/*                                                                      */
/* RCPP - Resource Compiler Pre-Processor for NT system                 */
/*                                                                      */
/* RCPPDECL.H - RCPP function prototype declarations                    */
/*                                                                      */
/* 04-Dec-90 w-BrianM  Created                                          */
/*                                                                      */
/************************************************************************/

/************************************************************************/
/* ERROR.C                                                              */
/************************************************************************/
void error      (int);
void fatal      (int);
void warning    (int);

/************************************************************************/
/* GETMSG.C                                                             */
/************************************************************************/
PCHAR GET_MSG  (int);
void  __cdecl SET_MSG  (PCHAR, UINT, PCHAR, ...);

/************************************************************************/
/* GETFLAGS.C                                                           */
/************************************************************************/
#if i386 == 1
int crack_cmd   (struct cmdtab *, WCHAR *, WCHAR *(*)(void), int);
#else /* MIPS */
struct cmdtab;
int crack_cmd   (struct cmdtab *, WCHAR *, WCHAR *(*)(void), int);
#endif /* i386 */

/************************************************************************/
/* LTOA.C                                                               */
/************************************************************************/
int zltoa       (long, WCHAR *, int);

/************************************************************************/
/* P0EXPR.C                                                             */
/************************************************************************/
long do_constexpr       (void);

/************************************************************************/
/* P0GETTOK.C                                                           */
/************************************************************************/
token_t         yylex(void);
int             lex_getid (WCHAR);

/************************************************************************/
/* P0IO.C                                                               */
/************************************************************************/
void            emit_line (void);
WCHAR           fpop (void);
int             io_eob (void);
int             io_restart (unsigned long int);
int             newinput (WCHAR *, int);
int             nested_include (void);
void            p0_init (PWCHAR, PWCHAR, LIST *, LIST *);
void            p0_terminate (void);

/************************************************************************/
/* P0KEYS.C                                                             */
/************************************************************************/
token_t         is_pkeyword (WCHAR *);

/************************************************************************/
/* P0MACROS.C                                                           */
/************************************************************************/
int             can_get_non_white (void);
int             can_expand (pdefn_t);
void            define (void);
void            definstall (WCHAR *, int, int);
pdefn_t         get_defined (void);
int             handle_eos (void);
int             tl_getid (WCHAR);
void            undefine (void);

/************************************************************************/
/* P0PREPRO.C                                                           */
/************************************************************************/
int             do_defined (PWCHAR);
int             nextis (token_t);
void            preprocess (void);
void            skip_cnew (void);
void            skip_NLonly (void);

/************************************************************************/
/* P1SUP.C                                                              */
/************************************************************************/
ptree_t         build_const (token_t, value_t *);

/************************************************************************/
/* RCPPUTIL.C                                                           */
/************************************************************************/
WCHAR *         pstrdup (WCHAR *);
WCHAR *         pstrndup (WCHAR *, int);
WCHAR *         strappend (WCHAR *, WCHAR *);

/************************************************************************/
/* SCANNER.C                                                            */
/************************************************************************/
token_t         char_const (void);
int             checknl (void);
int             checkop (int);
void            do_newline (void);
void            dump_comment (void);
void            DumpSlashComment (void);
void            getid (UINT);
WCHAR           get_non_eof (void);
token_t         getnum (WCHAR);
token_t         get_real (PWCHAR);
hash_t          local_c_hash (WCHAR *);
void            prep_string (WCHAR);
WCHAR           skip_cwhite (void);
int             skip_comment (void);
void            str_const (void);

/************************************************************************/
/* P0 I/O MACROS                                                        */
/************************************************************************/

//
// These macros could be a problem when working with non-spacing marks.
//
#define GETCH()         (*Current_char++)
#define CHECKCH()       (*Current_char)
#define UNGETCH()       (Current_char--)
#define PREVCH()        (*(Current_char - 1))
#define SKIPCH()        (Current_char++)


/************************************************************************/
/* RCPPX extensions needed for symbols                                  */
/************************************************************************/
void AfxOutputMacroDefn(pdefn_t p);
void AfxOutputMacroUse(pdefn_t p);
void move_to_exp(ptext_t);

/************************************************************************/
/* RCFUTIL utility routine						*/
/************************************************************************/
void myfwrite(const void *pv, size_t s, size_t n, FILE *fp);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\rcdll\rcpp.c ===
/************************************************************************/
/*                                                                      */
/* RCPP - Resource Compiler Pre-Processor for NT system                 */
/*                                                                      */
/* MAIN.C - Main Program                                                */
/*                                                                      */
/* 27-Nov-90 w-BrianM  Update for NT from PM SDK RCPP                   */
/*                                                                      */
/************************************************************************/

#include "rc.h"


/************************************************************************/
/* Global Varialbes                                                     */
/************************************************************************/
WCHAR   *Unknown = NULL;                /* holder for bad flags */
int     Argc;
WCHAR   **Argv;

/************************************************************************/
/* Local Function Prototypes                                            */
/************************************************************************/
WCHAR   *nextword(void);
void    to_human(void);


struct  subtab  Ztab[] = {
    L'a',        UNFLAG, &Extension,
    L'e',        FLAG,   &Extension,
    L'E',        FLAG,   &Ehxtension,
    L'i',        FLAG,   &Symbolic_debug,
    L'g',        FLAG,   &Out_funcdef,
    L'p',        FLAG,   &Cmd_pack_size,
    L'I',        FLAG,   &Inteltypes,
    L'c',        FLAG,   &ZcFlag,
    0,           0,              0,
};

struct cmdtab cmdtab[] = {
    L"-pc#",             (char *)&Path_chars,            1,      STRING,
    L"-pf",              (char *)&NoPasFor,              1,      FLAG,
    L"-C",               (char *)&Cflag,                 1,      FLAG,
    L"-CP#",             (char *)&uiCodePage,            1,      NUMBER,
    L"-D#",              (char *)&Defs,                  1,      PSHSTR,
    L"-U#",              (char *)&UnDefs,                1,      PSHSTR,
    L"-E",               (char *)&Eflag,                 1,      FLAG,
    L"-I#",              (char *)&Includes,              1,      PSHSTR,
    L"-P",               (char *)&Pflag,                 1,      FLAG,
    L"-f",               (char *)&Input_file,            1,      STRING,
    L"-g",               (char *)&Output_file,           1,      STRING,
    L"-J",               (char *)&Jflag,                 1,      FLAG,
    L"-Zp",              (char *)&Cmd_pack_size,         1,      FLAG,
    L"-Zp#",             (char *)&Cmd_pack_size,         1,      NUMBER,
    L"-Z*",              (char *)Ztab,                   1,      SUBSTR,
    L"-Oi",              (char *)&Cmd_intrinsic,         1,      FLAG,
    L"-Ol",              (char *)&Cmd_loop_opt,          1,      FLAG,
    L"-db#",             (char *)&Debug,                 1,      STRING,
    L"-il#",             (char *)&Basename,              1,      STRING,
    L"-xc",              (char *)&Cross_compile,         1,      FLAG,
    L"-H",               (char *)&HugeModel,             1,      FLAG,
    L"-V#",              (char *)&Version,               1,      STRING,
    L"-Gs",              (char *)&Cmd_stack_check,       1,      UNFLAG,
    L"-Gc",              (char *)&Plm,                   1,      FLAG,
    L"-char#",           (char *)&Char_align,            1,      NUMBER,
    L"-A#",              (char *)&A_string,              1,      STRING,
    L"-Q#",              (char *)&Q_string,              1,      STRING,
    L"-Fs",              (char *)&Srclist,               1,      FLAG,
    L"-R",               (char *)&Rflag,                 1,      FLAG,
    L"*",                (char *)&Unknown,               0,      STRING,
    0,                   0,                              0,      0,
};

/************************************************************************/
/* nextword -                                                           */
/************************************************************************/
WCHAR   *nextword(void)
{
    return((--Argc > 0) ? (*++Argv) : 0);
}

/************************************************************************/
/* main -                                                               */
/************************************************************************/
int __cdecl
rcpp_main(
    int argc,
    PWCHAR*argv
    )
{
    Argc = argc;
    Argv = argv;

    if(Argv == NULL) {
        strcpy (Msg_Text, GET_MSG (1002));
        fatal(1007);    /* no memory */
    }

    while(crack_cmd(cmdtab, nextword(), nextword, 0)) ;

    if(Unknown) {
        Msg_Temp = GET_MSG (1007);
        SET_MSG (Msg_Text, sizeof(Msg_Text), Msg_Temp, Unknown, "c1");
        fatal(1007);    /* unknown flag */
    }

    if( ! Input_file) {
        strcpy (Msg_Text, GET_MSG (1008));
        fatal(1008);            /* no input file specified */
    }

    if( ! Output_file) {
        strcpy (Msg_Text, GET_MSG (1010));
        fatal(1010);            /* no output file specified */
    }

    Prep = TRUE;
    if( !Eflag && !Pflag ) {
        Eflag = TRUE;
    }

    wcsncpy(Filename,Input_file,128);

    p0_init(Input_file, Output_file, &Defs, &UnDefs);
    to_human();

    if( Prep_ifstack >= 0 ) {
        strcpy (Msg_Text, GET_MSG (1022));
        fatal(1022);            /* expected #endif */
    }

    p0_terminate();
    return Nerrors;
}


/************************************************************************/
/* to_human : outputs preprocessed text in human readable form.         */
/************************************************************************/
void
to_human(
    void
    )
{
    PWCHAR value;

    for(;;) {
        switch(yylex()) {
            case 0:
                return;
            case L_NOTOKEN:
                break;
            default:
                if (Basic_token == 0) {
                    strcpy (Msg_Text, GET_MSG (1011));
                    fatal(1011);
                }
                value = Tokstrings[Basic_token - L_NOTOKEN].k_text;
                myfwrite(value, wcslen(value) * sizeof(WCHAR), 1, OUTPUTFILE);
                break;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\rcdll\rcpputil.c ===
/************************************************************************/
/*                                                                      */
/* RCPP - Resource Compiler Pre-Processor for NT system                 */
/*                                                                      */
/* RCPPTIL.C - Utility routines for RCPP                                */
/*                                                                      */
/* 27-Nov-90 w-BrianM  Update for NT from PM SDK RCPP                   */
/*                                                                      */
/************************************************************************/

#include "rc.h"

extern void     error(int);
extern CHAR     Msg_Text[];
extern PCHAR    Msg_Temp;

/************************************************************************
 * PSTRDUP - Create a duplicate of string s and return a pointer to it.
 ************************************************************************/
WCHAR *
pstrdup(
    WCHAR *s
    )
{
    return(wcscpy((WCHAR *)MyAlloc((wcslen(s) + 1) * sizeof(WCHAR)), s));
}


/************************************************************************
**  pstrndup : copies n bytes from the string to a newly allocated
**  near memory location.
************************************************************************/
WCHAR *
pstrndup(
    WCHAR *s,
    int n
    )
{
    WCHAR   *r;
    WCHAR   *res;

    r = res = (WCHAR *) MyAlloc((n+1) * sizeof(WCHAR));
    if (res == NULL) {
        strcpy (Msg_Text, GET_MSG (1002));
        error(1002);
        return NULL;
    }

    __try {
        for (; n--; r++, s++) {
            *r = *s;
        }
    } __except(EXCEPTION_EXECUTE_HANDLER) {
        n++;
        while (n--) {
            *r++ = L'\0';
        }
    }
    *r = L'\0';
    return(res);
}


/************************************************************************
**      strappend : appends src to the dst,
**  returns a ptr in dst to the null terminator.
************************************************************************/
WCHAR *
strappend(
    register WCHAR *dst,
    register WCHAR *src
    )
{
    while ((*dst++ = *src++) != 0);
    return(--dst);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\rcdll\rcppx.c ===
/************************************************************************/
/*                                                                      */
/* RCPP - Resource Compiler Pre-Processor for NT system                 */
/*                                                                      */
/* P0MACROS.C - Preprocessor Macros definitions                         */
/*                                                                      */
/* 27-Nov-90 w-BrianM  Update for NT from PM SDK RCPP                   */
/*                                                                      */
/************************************************************************/

#include "rc.h"

int afxReadOnlySymbols = FALSE;
int afxHiddenSymbols = FALSE;
WCHAR* afxSzReadOnlySymbols = L"APSTUDIO_READONLY_SYMBOLS";
WCHAR* afxSzHiddenSymbols = L"APSTUDIO_HIDDEN_SYMBOLS";

static WCHAR lineBuffer[2048];


void
AfxOutputMacroUse(
    pdefn_t p
    )
{
    if (!fAFXSymbols)
        return;

    if (afxHiddenSymbols)
        return;

    swprintf(lineBuffer,
        L" %c\"%s%c%s%c%d\"",
         SYMUSESTART,
         DEFN_NAME(p),
         SYMDELIMIT,
         Filename,
         SYMDELIMIT,
         Linenumber);

    move_to_exp(lineBuffer);
}

void
AfxOutputMacroDefn(
    pdefn_t p
    )
{
    char flags;
    int nLen;

    if (!fAFXSymbols || OUTPUTFILE == NULL)
            return;

    if (wcscmp(DEFN_NAME(p), afxSzReadOnlySymbols) == 0) {
        afxReadOnlySymbols = TRUE;
        return;
    }

    if (wcscmp(DEFN_NAME(p), afxSzHiddenSymbols) == 0) {
        afxHiddenSymbols = TRUE;
        return;
    }

    if (afxHiddenSymbols || DEFN_TEXT(p) == NULL)
        return;

    if (afxReadOnlySymbols)
        flags = SYS_RESOURCE;
    else
        flags = 0;

    nLen = swprintf(lineBuffer,
            L"%c%s%c%s%c%d%c%c%c",
             SYMDEFSTART,
             DEFN_NAME(p),
             SYMDELIMIT,
             DEFN_TEXT(p),
             SYMDELIMIT,
#if 0
             Filename,
             SYMDELIMIT,
    // don't forget to add %s%c
#endif
             Linenumber,
             SYMDELIMIT,
             (char)flags | '\200',   // (char)0x80,
             SYMDELIMIT);

    myfwrite(lineBuffer, nLen * sizeof(WCHAR), 1, OUTPUTFILE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\rcdll\rcpptype.h ===
/************************************************************************/
/*                                                                      */
/* RCPP - Resource Compiler Pre-Processor for NT system                 */
/*                                                                      */
/* RCPPTYPE.H - Type definitions for RCPP                               */
/*                                                                      */
/* 04-Dec-90 w-BrianM  Update for NT from PM SDK RCPP                   */
/*                                                                      */
/************************************************************************/

/************************************************************************/
/* Define types for greater visibility and easier portability           */
/************************************************************************/

#ifndef _WINDOWS_
typedef char            CHAR;
typedef unsigned char   BYTE;
typedef CHAR *          PCHAR;
typedef unsigned short  WCHAR;
typedef unsigned char   UCHAR;
typedef UCHAR *         PUCHAR;
typedef WCHAR *         PWCHAR;

typedef short           SHORT;
typedef SHORT *         PSHORT;
typedef unsigned short  USHORT;
typedef USHORT *        PUSHORT;

typedef int             INT;
typedef INT             BOOL;
typedef INT *           PINT;
typedef unsigned int    UINT;
typedef UINT *          PUINT;

typedef long            LONG;
typedef LONG *          PLONG;
typedef unsigned long   ULONG;
typedef ULONG *         PULONG;

typedef void            VOID;
typedef VOID *          PVOID;
#endif

typedef double          DOUBLE;
typedef DOUBLE *        PDOUBLE;


/************************************************************************/
/*                                                                      */
/* Define internal types                                                */
/*                                                                      */
/************************************************************************/

#define TRUE    1
#define FALSE   0

#define EXTERN  extern
#define REG     register
#define STATIC  static


#define BIG_BUFFER      512
#define MED_BUFFER      256
#define SMALL_BUFFER    128
#define TINY_BUFFER     32
#define MSG_BUFF_SIZE   2048
#define IFSTACK_SIZE    TINY_BUFFER


/*
**      some commonly used typdefs for scalar items
*/
typedef UINT    p1key_t;
typedef UCHAR   hash_t;
typedef UCHAR   token_t;
typedef UCHAR   shape_t;

typedef UCHAR   blknum_t;       /*  lexical level  */
typedef UCHAR   class_t;

typedef USHORT  btype_t;        /*  basic type specifier  */
typedef USHORT  refcnt_t;       /*  symbol's reference count  */
typedef USHORT  hey_t;          /*  unique keys  */
typedef USHORT  offset_t;       /*  members offset within a struct  */

typedef ULONG   abnd_t;         /*  array bound type  */
typedef ULONG   len_t;          /*  number of bytes/bits of member/field  */

typedef struct  s_adj           symadj_t;
typedef struct  s_defn          defn_t;
typedef struct  s_flist         flist_t;
typedef struct  s_indir         indir_t;
typedef struct  s_stack         stack_t;
typedef struct  s_sym           sym_t;
typedef struct  s_table         table_t;
typedef struct  s_toklist       toklist_t;
typedef struct  s_tree          tree_t;
typedef struct  s_type          type_t;
typedef struct  s_case          case_t;

typedef union   u_ivalue        ivalue_t;

/*
**      abstract char pointer types
*/
typedef PWCHAR          ptext_t;        /* wherever input text comes from */

/*
**      other abstract pointer types
*/
typedef type_t *        ptype_t;        /* ptr to types */
typedef indir_t *       pindir_t;       /* ptr to indirections */
typedef flist_t *       pflist_t;       /* ptr to formal list type */
typedef sym_t *         psym_t;         /* symbol ptrs */
typedef defn_t *        pdefn_t;        /* #define names */

typedef tree_t *        ptree_t;


typedef struct s_realt {
    LONG        S_sizet;
    DOUBLE      S_realt;
} Srealt_t;


/* declspec type */
struct s_declspec {
    class_t ds_calss;
    ptype_t ds_type;
};
typedef struct s_declspec       declspec_t;
typedef declspec_t *            pdeclspec_t;


/* string type */
struct s_string {
    WCHAR *     str_ptr;
    USHORT      str_len;
};
typedef struct s_string         string_t;
typedef string_t *              pstring_t;


/* rcon type */
struct rcon {
    Srealt_t    rcon_real;
};
typedef struct rcon             rcon_t;
typedef struct rcon *           prcon_t;


/* hln type */
struct s_hln {
    PWCHAR hln_name;
    UCHAR hln_hash;
    UCHAR hln_length;
};
typedef struct  s_hln           hln_t;
typedef hln_t *                 phln_t;


/*
**      union used to return values from the lexer
*/
typedef union   s_lextype       {
        btype_t         yy_btype;
        PWCHAR          yy_cstr;
        int             yy_int;
        int             yy_class;
        long            yy_long;
        hln_t           yy_ident;
        declspec_t      yy_declspec;
        string_t        yy_string;
        psym_t          yy_symbol;
        token_t         yy_token;
        ptree_t         yy_tree;
        ptype_t         yy_type;
        } lextype_t;

/* value_t definition */
union u_value {
    prcon_t     v_rcon;
    long        v_long;
    string_t    v_string;
    psym_t      v_symbol;
};
typedef union   u_value         value_t;

/* keytab_t definition */
typedef struct {
    WCHAR *     k_text;
    UCHAR       k_token;
} keytab_t;


/************************************************************************/
/* LIST definition for \D values                                        */
/************************************************************************/
#define MAXLIST 100

typedef struct LIST {
        INT      li_top;
        WCHAR *  li_defns[MAXLIST];
} LIST;

#define UNREFERENCED_PARAMETER(x) (x)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\rcdll\rcppx.h ===
/* special characters for handling symbol information */
/* note that we use characters in the private use area, as */
/* these will never be emitted (hopefully) by MultiByteToWideChar */
#define SYMDEFSTART 0xe000
#define SYMUSESTART 0xe001
#define SYMDELIMIT  0xe002
#define USR_RESOURCE 0
#define SYS_RESOURCE 1
#define IGN_RESOURCE 2
#define WIN_RESOURCE 3

extern int afxReadOnlySymbols;
extern int afxHiddenSymbols;
extern WCHAR* afxSzReadOnlySymbols;
extern WCHAR* afxSzHiddenSymbols;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\rcdll\rcunicod.h ===
/*++

Copyright (c) 1991 Microsoft Corporation

Module Name:

    rcunicod.h

Abstract:

    This is the header file for rcpp 16-bit unicode support.  It contains
        the translatation table for codepage 1252.  This was taken from the
        nls1252.txt file.

Author:

    David J. Marsyla (t-davema) 25-Aug-1991

Revision History:


--*/

#define IN
#define OUT


#define DFT_TEST_SIZE                     250      // The number of bytes to test to get
                                                   //    an accurate determination of file type.

//
// The following may be retruned from DetermineFileType ().
//

#define DFT_FILE_IS_UNKNOWN             0       // File type not yet determined.
#define DFT_FILE_IS_8_BIT               1       // File is an 8-bit ascii file.
#define DFT_FILE_IS_16_BIT              2       // File is standard 16-bit unicode file.
#define DFT_FILE_IS_16_BIT_REV          3       // File is reversed 16-bit unicode file.

//
// This function can be used to determine the format of a disk file.
//
INT
DetermineFileType (
    IN      PFILE        fpInputFile
    );

//
// The following may be returned from DetermnineSysEndianType ().
//

#define DSE_SYS_LITTLE_ENDIAN   1       // Return values from determine system
#define DSE_SYS_BIG_ENDIAN      2       // endian type.

//
// This function will return the endian type of the current system.
//
INT
DetermineSysEndianType (
        VOID
    );


//
// This function converts command line arguments to Unicode buffer
//
WCHAR ** UnicodeCommandLine (
    int,
    char **
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\rcdll\rctg.c ===
/****************************************************************************/
/*                                                                          */
/*  RCTG.C -                                                                */
/*                                                                          */
/*    Windows 3.0 Resource Compiler - Resource generation functions         */
/*                                                                          */
/*                                                                          */
/****************************************************************************/

#include "rc.h"
#include "assert.h"


#define MAXCODE    128000 //AFX uses > 65000
#define DIBBITMAPFORMAT   0x4D42   /* 'BM' as in PM format */

#undef  min
#define min(a,b) ((a<b)?(a):(b))

PCHAR       CodeArray;      /* pointer to code buffer */
int         CodeSize;       /* size of code buffer */
int         CCount;         /* current code array address */
PFILE       fhCode;         /* file handle for remaining data */
static int  ItemCountLoc;   /* a patch location; this one for */
static int  ItemExtraLoc;   /* a patch location; this one for */

typedef struct {
    SHORT   csHotX;
    SHORT   csHotY;
    SHORT   csWidth;
    SHORT   csHeight;
    SHORT   csWidthBytes;
    SHORT   csColor;
} IconHeader;


typedef struct {
    UINT        dfVersion;              /* not in FONTINFO */
    DWORD       dfSize;                 /* not in FONTINFO */
    CHAR        dfCopyright[60];        /* not in FONTINFO */
    UINT        dfType;
    UINT        dfPoints;
    UINT        dfVertRes;
    UINT        dfHorizRes;
    UINT        dfAscent;
    UINT        dfInternalLeading;
    UINT        dfExternalLeading;
    BYTE        dfItalic;
    BYTE        dfUnderline;
    BYTE        dfStrikeOut;
    UINT        dfWeight;
    BYTE        dfCharSet;
    UINT        dfPixWidth;
    UINT        dfPixHeight;
    BYTE        dfPitchAndFamily;
    UINT        dfAvgWidth;
    UINT        dfMaxWidth;
    BYTE        dfFirstChar;
    BYTE        dfLastChar;
    BYTE        dfDefaultCHar;
    BYTE        dfBreakChar;
    UINT        dfWidthBytes;
    DWORD       dfDevice;           /* See Adaptation Guide 6.3.10 and 6.4 */
    DWORD       dfFace;             /* See Adaptation Guide 6.3.10 and 6.4 */
    DWORD       dfReserved;         /* See Adaptation Guide 6.3.10 and 6.4 */
} ffh;

#define FONT_FIXED sizeof(ffh)
#define FONT_ALL sizeof(ffh) + 64

struct MacCursor {
    char data[16];
    char mask[16];
    short hotSpotV;
    short hotSpotH;
};

typedef struct {
    unsigned short red;
    unsigned short green;
    unsigned short blue;
} RGBColor;

typedef struct {
    unsigned short value;
    RGBColor rgb;
} ColorSpec;


#define ccs2 2
ColorSpec rgcs2[ccs2] = {
    {0, {0xffff,0xffff,0xffff}},
    {1, {0x0000,0x0000,0x0000}}
};


#define ccs16 16
ColorSpec rgcs16[ccs16] = {
    {0x00, {0xffff,0xffff,0xffff}},
    {0x01, {0xfc00,0xf37d,0x052f}},
    {0x02, {0xffff,0x648a,0x028c}},
    {0x03, {0xdd6b,0x08c2,0x06a2}},
    {0x04, {0xf2d7,0x0856,0x84ec}},
    {0x05, {0x46e3,0x0000,0xa53e}},
    {0x06, {0x0000,0x0000,0xd400}},
    {0x07, {0x0241,0xab54,0xeaff}},
    {0x08, {0x1f21,0xb793,0x1431}},
    {0x09, {0x0000,0x64af,0x11b0}},
    {0x0a, {0x5600,0x2c9d,0x0524}},
    {0x0b, {0x90d7,0x7160,0x3a34}},
    {0x0c, {0xc000,0xc000,0xc000}},
    {0x0d, {0x8000,0x8000,0x8000}},
    {0x0e, {0x4000,0x4000,0x4000}},
    {0x0f, {0x0000,0x0000,0x0000}}
};


/*
 *  the 34 legal icon colors
 */
#define ccs256 34
ColorSpec rgcs256[ccs256] = {
    {0x01, {0xFFFF, 0xFFFF, 0xCCCC}},
    {0x08, {0xFFFF, 0xCCCC, 0x9999}},
    {0x33, {0xCCCC, 0x9999, 0x6666}},
    {0x16, {0xFFFF, 0x6666, 0x3333}},
    {0x92, {0x3333, 0xFFFF, 0x9999}},
    {0xE3, {0x0000, 0xBBBB, 0x0000}},
    {0x9F, {0x3333, 0x9999, 0x6666}},
    {0xA5, {0x3333, 0x6666, 0x6666}},
    {0x48, {0x9999, 0xFFFF, 0xFFFF}},
    {0xC0, {0x0000, 0x9999, 0xFFFF}},
    {0xEC, {0x0000, 0x0000, 0xDDDD}},
    {0xB0, {0x3333, 0x0000, 0x9999}},
    {0x2A, {0xCCCC, 0xCCCC, 0xFFFF}},
    {0x54, {0x9999, 0x9999, 0xFFFF}},
    {0x7F, {0x6666, 0x6666, 0xCCCC}},
    {0xAB, {0x3333, 0x3333, 0x6666}},
    {0x13, {0xFFFF, 0x6666, 0xCCCC}},
    {0x69, {0x9999, 0x0000, 0x6666}},
    {0x5C, {0x9999, 0x6666, 0x9999}},
    {0x00, {0xFFFF, 0xFFFF, 0xFFFF}},
    {0xF5, {0xEEEE, 0xEEEE, 0xEEEE}},
    {0xF6, {0xDDDD, 0xDDDD, 0xDDDD}},
    {0x2B, {0xCCCC, 0xCCCC, 0xCCCC}},
    {0xF7, {0xBBBB, 0xBBBB, 0xBBBB}},
    {0xF8, {0xAAAA, 0xAAAA, 0xAAAA}},
    {0xF9, {0x8888, 0x8888, 0x8888}},
    {0xFA, {0x7777, 0x7777, 0x7777}},
    {0xFB, {0x5555, 0x5555, 0x5555}},
    {0xFC, {0x4444, 0x4444, 0x4444}},
    {0xFD, {0x2222, 0x2222, 0x2222}},
    {0xFE, {0x1111, 0x1111, 0x1111}},
    {0xFF, {0x0000, 0x0000, 0x0000}},
    {0x05, {0xFFFF, 0xFFFF, 0x0000}},
    {0xD8, {0xDDDD, 0x0000, 0x0000}}
};

void ProcessMacIcons(RESINFO* pRes, int itBase, int ib1, int ib4, int ib8);
void ReadDIB(int ibDesc, struct tagDESCRIPTOR *pds, BITMAPINFOHEADER* pbmh, int* pcbWidth, void** ppBits, RGBQUAD** prgrgq, BOOL fIcon);
void CompactAndFlipIcon(BYTE* pBits, int cbRowCur, int cbRowMask, int cbRowNew, int cbRowMaskNew, int Height);
void WriteMacRsrc(void* pBits, int cbBits, RESINFO* pResBase, DWORD res);
void LookupIconColor(ColorSpec* rgcs, int ccs, RGBQUAD* pq);
long MungeResType(WCHAR *szType, short wOrd);
int IdUnique(TYPEINFO *ptype, RESINFO* pres);
RESINFO* LookupIconRes(TYPEINFO* ptypeIcon, RESINFO* pres);
void TranslateString(char* sz);
void TranslateBuffer(char* rgch, int cch);


/*---------------------------------------------------------------------------*/
/*                                                                           */
/*      GenWarning2() -                                                      */
/*                                                                           */
/*---------------------------------------------------------------------------*/
VOID
GenWarning2(
    int iMsg,
    PCHAR arg
    )
{
    SET_MSG(Msg_Text, sizeof(Msg_Text), GET_MSG(iMsg), curFile, token.row, arg);
    SendWarning(Msg_Text);
}


/*---------------------------------------------------------------------------*/
/*                                                                           */
/*      GenWarning4() -                                                      */
/*                                                                           */
/*---------------------------------------------------------------------------*/
VOID
GenWarning4(
    int iMsg,
    PCHAR arg1,
    PCHAR arg2,
    PCHAR arg3
    )
{
    SET_MSG(Msg_Text,
            sizeof(Msg_Text),
            GET_MSG(iMsg),
            curFile,
            token.row,
            arg1,
            arg2,
            arg3);
    SendWarning(Msg_Text);
}


/*---------------------------------------------------------------------------*/
/*                                                                           */
/*      GenError2() -                                                        */
/*                                                                           */
/*---------------------------------------------------------------------------*/

void
GenError2(
    int iMsg,
    PCHAR arg
    )
{
    if (fhCode > 0)
        fclose(fhCode);

    SET_MSG(Msg_Text, sizeof(Msg_Text), GET_MSG(iMsg), curFile, token.row, arg);
    SendError(Msg_Text);
    quit("\n");
}


/*---------------------------------------------------------------------------*/
/*                                                                                                                                                       */
/*      GenError1() -                                                                                                                    */
/*                                                                                                                                                       */
/*---------------------------------------------------------------------------*/

void
GenError1(
    int iMsg
    )
{
    if (fhCode > 0)
        fclose(fhCode);

    SET_MSG(Msg_Text, sizeof(Msg_Text), GET_MSG(iMsg), curFile, token.row);
    SendError(Msg_Text);
    quit("\n");
}


/*---------------------------------------------------------------------------*/
/*                                                                           */
/*  CtlAlloc() -                                                             */
/*                                                                           */
/*---------------------------------------------------------------------------*/
VOID
CtlAlloc(
    VOID
    )
{
    CodeSize = MAXCODE;
    CodeArray = (PCHAR) MyAlloc(MAXCODE);
}


/*---------------------------------------------------------------------------*/
/*                                                                           */
/*  CtlInit() -                                                              */
/*                                                                           */
/*---------------------------------------------------------------------------*/
VOID
CtlInit(
    VOID
    )
{
    CCount = 0;         /* absolute location in CodeArray */
    fhCode = NULL_FILE; /* don't copy file unless we need to */
}


/*---------------------------------------------------------------------------*/
/*                                                                           */
/*  CtlFile() -                                                              */
/*                                                                           */
/*---------------------------------------------------------------------------*/
PFILE
CtlFile(
    PFILE fh
    )
{
    if (fh != NULL_FILE)
        fhCode = fh;    /* set file handle to read remaining resource from */

    return(fhCode);
}


/*---------------------------------------------------------------------------*/
/*                                                                           */
/*  CtlFree() -                                                              */
/*                                                                           */
/*---------------------------------------------------------------------------*/
VOID
CtlFree(
    VOID
    )
{
    CodeSize = 0;
    MyFree(CodeArray);
}


/*---------------------------------------------------------------------------*/
/*                                                                           */
/*  GetSpace() -                                                             */
/*                                                                           */
/*---------------------------------------------------------------------------*/
PCHAR
GetSpace(
    WORD cb
    )
{
    PCHAR pch;

    if (CCount > (int) (CodeSize - cb)) {
        PVOID pv;
        if ((pv = HeapReAlloc(hHeap, HEAP_NO_SERIALIZE|HEAP_ZERO_MEMORY, ((PCHAR)CodeArray)-8, CodeSize+0x00010000+8)) == NULL) {
            GenError1(2168); //"Resource too large"
            /* GenError1 calls quit() and doesn't return! */
        }
        CodeArray = ((PCHAR)pv)+8;
        CodeSize += 0x00010000;
    }

    pch = CodeArray + CCount;
    CCount += cb;
    return(pch);
}


/*---------------------------------------------------------------------------*/
/*                                                                           */
/*  WriteString() -                                                          */
/*                                                                           */
/*---------------------------------------------------------------------------*/
VOID
WriteString(
    PWCHAR sz,
    BOOL fMacCP
    )
{
    /* add a string to the resource buffer */
    if (fMacRsrcs) {
        WriteMacString(sz, fMacCP, FALSE);
    } else {
        do {
            WriteWord(*sz);
        } while (*sz++ != 0);
    }
}


/*---------------------------------------------------------------------------*/
/*                                                                           */
/*  WriteMacString() -                                                       */
/*                                                                           */
/*---------------------------------------------------------------------------*/
VOID
WriteMacString(
    PWCHAR sz,
    BOOL fMacCP,
    BOOL fPascal
    )
{
    BYTE rgb[256];
    BYTE rgbExpand[256];
    BYTE* pb = rgb;
    BYTE* pbExpand = rgbExpand;
    int cch = 0;
    int cb = 0;

    if (sz != NULL)
    {
        UINT iCP;
        UINT nCP = uiCodePage;
        BOOL fAttemptTranslate = FALSE;
        static UINT rgnCP[] = {10029, 10007, 10000, 10006, 10081};    // Mac codepages
        static BOOL rgfCP[5];

        // If the codepage for the current resource text is one of the Windows
        // Latin 1, Greek, Cyrillic, Turkish, or Eastern European codepages, then
        // there exists a corresponding Macintosh codepage in Win32 and it is valid
        // to use WCToMB to map the Windows text to the Macintosh character set. If
        // the Windows text is in a different code page, we don't try to do any
        // mapping.
        iCP = uiCodePage - 1250;
        if (fMacCP && uiCodePage >= 1250 && uiCodePage <= 1254) {
            nCP = rgnCP[iCP];

            // unfortunately the Mac code pages are not supported under Windows 95.
            // To handle this, we check to see if the Mac code page we came up
            // with is actually available, and if it isn't, revert back to uiCodePage.

            if ((rgfCP[iCP] & 0x01) == 0) {  // is this fCP still uninitialized?
                rgfCP[iCP] |= 0x01;     // bit 0 set: has been initialized
                if (IsValidCodePage(nCP))
                    rgfCP[iCP] |= 0x02;     // bit 1 set: this CP is available
            }

            if ((rgfCP[iCP] & 0x02) == 0) {
                nCP = uiCodePage;
                fAttemptTranslate = TRUE;
            }
        }

        cch = wcslen(sz);

        cb = WideCharToMultiByte(nCP, 0, sz, cch, NULL, 0, NULL, NULL);
        if (cb > sizeof(rgb))
            pb = (BYTE *) MyAlloc(cb);
        WideCharToMultiByte(nCP, 0, sz, cch, (LPSTR) pb, cb, NULL, NULL);

        // if the Mac code page we wanted isn't available, try using our hard-coded tables
        if (fAttemptTranslate)
            TranslateBuffer((LPSTR) pb, cb);
    }

    if (fPascal) {
        WriteByte((char)cb);
        WriteBuffer((LPSTR) rgb, (USHORT)cb);
    } else {
        // at worst, we'll need one wide char for every single-byte char, plus a null terminator
        if (((cb + 1) * sizeof(WCHAR)) > sizeof(rgbExpand))
            pbExpand = (BYTE *) MyAlloc((cb + 1) * sizeof(WCHAR));

        cb = ExpandString(pb, cb, pbExpand);
        WriteBuffer((LPSTR) pbExpand, (USHORT)cb);

        if (pbExpand != rgbExpand)
            MyFree(pbExpand);
    }

    if (pb != rgb)
        MyFree(pb);
}


unsigned char* mpchchCodePage;

unsigned char mpchchLatin1ToMac[128] = {
    0x3f, /* 0x80 */
    0x3f, /* 0x81 */
    0xe2, /* 0x82 */
    0xc4, /* 0x83 */
    0xe3, /* 0x84 */
    0xc9, /* 0x85 */
    0xa0, /* 0x86 */
    0xe0, /* 0x87 */
    0xf6, /* 0x88 */
    0xe4, /* 0x89 */
    0x3f, /* 0x8a */
    0xdc, /* 0x8b */
    0xce, /* 0x8c */
    0x3f, /* 0x8d */
    0x3f, /* 0x8e */
    0x3f, /* 0x8f */
    0x3f, /* 0x90 */
    0xd4, /* 0x91 */
    0xd5, /* 0x92 */
    0xd2, /* 0x93 */
    0xd3, /* 0x94 */
    0xa5, /* 0x95 */
    0xd0, /* 0x96 */
    0xd1, /* 0x97 */
    0xf7, /* 0x98 */
    0x84, /* 0x99 */
    0x3f, /* 0x9a */
    0xdd, /* 0x9b */
    0xcf, /* 0x9c */
    0x3f, /* 0x9d */
    0x3f, /* 0x9e */
    0xd9, /* 0x9f */
    0xca, /* 0xa0 */
    0xc1, /* 0xa1 */
    0xa2, /* 0xa2 */
    0xa3, /* 0xa3 */
    0xdb, /* 0xa4 */
    0xb4, /* 0xa5 */
    0x3f, /* 0xa6 */
    0xa4, /* 0xa7 */
    0xac, /* 0xa8 */
    0xa9, /* 0xa9 */
    0xbb, /* 0xaa */
    0xc7, /* 0xab */
    0xc2, /* 0xac */
    0x3f, /* 0xad */
    0xa8, /* 0xae */
    0x3f, /* 0xaf */
    0xa1, /* 0xb0 */
    0xb1, /* 0xb1 */
    0x3f, /* 0xb2 */
    0x3f, /* 0xb3 */
    0xab, /* 0xb4 */
    0xb5, /* 0xb5 */
    0xa6, /* 0xb6 */
    0xe1, /* 0xb7 */
    0xfc, /* 0xb8 */
    0x3f, /* 0xb9 */
    0xbc, /* 0xba */
    0xc8, /* 0xbb */
    0x3f, /* 0xbc */
    0x3f, /* 0xbd */
    0x3f, /* 0xbe */
    0xc0, /* 0xbf */
    0xcb, /* 0xc0 */
    0xe7, /* 0xc1 */
    0xe5, /* 0xc2 */
    0xcc, /* 0xc3 */
    0x80, /* 0xc4 */
    0x81, /* 0xc5 */
    0xae, /* 0xc6 */
    0x82, /* 0xc7 */
    0xe9, /* 0xc8 */
    0x83, /* 0xc9 */
    0xe6, /* 0x3f */
    0xe8, /* 0xcb */
    0xed, /* 0xcc */
    0xea, /* 0xcd */
    0xeb, /* 0xce */
    0xec, /* 0xcf */
    0x3f, /* 0xd0 */
    0x84, /* 0xd1 */
    0xf1, /* 0xd2 */
    0xee, /* 0xd3 */
    0xef, /* 0xd4 */
    0xcd, /* 0xd5 */
    0x85, /* 0xd6 */
    0x3f, /* 0xd7 */
    0xaf, /* 0xd8 */
    0x84, /* 0xd9 */
    0xf2, /* 0xda */
    0xf3, /* 0xdb */
    0x86, /* 0xdc */
    0x3f, /* 0xdd */
    0x3f, /* 0xde */
    0xa7, /* 0xdf */
    0x88, /* 0xe0 */
    0x87, /* 0xe1 */
    0x89, /* 0xe2 */
    0x8b, /* 0xe3 */
    0x8a, /* 0xe4 */
    0x8c, /* 0xe5 */
    0xbe, /* 0xe6 */
    0x8d, /* 0xe7 */
    0x8f, /* 0xe8 */
    0x8e, /* 0xe9 */
    0x90, /* 0xea */
    0x91, /* 0xeb */
    0x93, /* 0xec */
    0x92, /* 0xed */
    0x94, /* 0xee */
    0x95, /* 0xef */
    0x3f, /* 0xf0 */
    0x96, /* 0xf1 */
    0x98, /* 0xf2 */
    0x97, /* 0xf3 */
    0x99, /* 0xf4 */
    0x9b, /* 0xf5 */
    0x9a, /* 0xf6 */
    0xd6, /* 0xf7 */
    0xbf, /* 0xf8 */
    0x9d, /* 0xf9 */
    0x9c, /* 0xfa */
    0x9e, /* 0xfb */
    0x9f, /* 0xfc */
    0x3f, /* 0xfd */
    0x3f, /* 0xfe */
    0xd8, /* 0xff */
};

/*---------------------------------------------------------------------------*/
/*                                                                           */
/*  BuildCodePage() -                                                         */
/*                                                                           */
/*---------------------------------------------------------------------------*/
void
BuildCodePage(
    int cp
    )
{
    mpchchCodePage = cp == 1252 ? mpchchLatin1ToMac : NULL;
}


/*---------------------------------------------------------------------------*/
/*                                                                           */
/*  TranslateString() -                                                         */
/*                                                                           */
/*---------------------------------------------------------------------------*/
void
TranslateString(
    char* sz
    )
{
    TranslateBuffer(sz, strlen(sz)+1);
}

/*---------------------------------------------------------------------------*/
/*                                                                           */
/*  TranslateBuffer() -                                                         */
/*                                                                           */
/*---------------------------------------------------------------------------*/
void
TranslateBuffer(
    char* rgch,
    int cch
    )
{
    if (mpchchCodePage == NULL)
        BuildCodePage(uiCodePage);
    if (mpchchCodePage == NULL)
        return;
    for (NULL; cch > 0; rgch++, cch--)
        if (*rgch & 0x80)
            *rgch = (char)mpchchCodePage[(unsigned char)(*rgch-0x80)];
}


/*---------------------------------------------------------------------------*/
/*                                                                           */
/*  ExpandString() -                                                         */
/*                                                                           */
/*---------------------------------------------------------------------------*/
int
ExpandString(
    BYTE* pb,
    int cb,
    BYTE* pbExpand
    )
{
    int cbWide = 2; // for null terminator

    while (cb > 0) {
        if (IsDBCSLeadByteEx(uiCodePage, *pb)) {
            *pbExpand++ = *pb++;
            cb--;
        } else {
            *pbExpand++ = 0;
        }

        *pbExpand++ = *pb++;
        cbWide += 2;
        cb--;
    }

    *(WORD*) pbExpand++ = L'\0';
    return cbWide;
}


/*---------------------------------------------------------------------------*/
/*                                                                           */
/*  AppendString() -                                                          */
/*                                                                           */
/*---------------------------------------------------------------------------*/
VOID
AppendString(
    PWCHAR sz,
    BOOL fMacCP
    )
{
    PWCHAR psz;

    /* add a string to the resource buffer */
    psz = (PWCHAR) (&CodeArray[CCount]);
    if (*(psz-1) == L'\0')
        CCount -= sizeof(WCHAR);
    WriteString(sz, fMacCP);
}


/*---------------------------------------------------------------------------*/
/*                                                                           */
/*  WriteAlign() -                                                           */
/*                                                                           */
/*---------------------------------------------------------------------------*/
VOID
WriteAlign(
    VOID
    )
{
    WORD    i = CCount % 4;

    while (i--)
        WriteByte(0);
}


/*---------------------------------------------------------------------------*/
/*                                                                           */
/*  WriteBuffer() -                                                          */
/*                                                                           */
/*---------------------------------------------------------------------------*/
VOID
WriteBuffer(
    PCHAR  pb,
    USHORT cb
    )
{
    while (cb--) {
        WriteByte(*pb++);
    }
}


/*--------------------------------------------------------------------------*/
/*                                                                          */
/* WriteControl() -                                                         */
/*                                                                          */
/*  Parameters:                                                             */
/*      outfh  : The handle of the RES file.                                */
/*      Array  : Pointer to array from which some data is to be copied into */
/*               the .RES file.                                             */
/*               This is ignored if ArrayCount is zero.                     */
/*      ArrayCount : This is the number of bytes to be copied from "Array"  */
/*                   into the .RES file. This is zero if no copy is required*/
/*      FileCount  : This specifies the number of bytes to be copied from   */
/*                   fhCode into fhOut. If this is -1, the complete input   */
/*                   file is to be copied into fhOut.                       */
/**/
/**/

int
WriteControl(
    PFILE outfh,
    PCHAR Array,
    int ArrayCount,
    LONG FileCount
    )
{

    /* Check if the Array is to be written to .RES file */
    if (ArrayCount > 0)
        /* write the array (resource) to .RES file */
        MyWrite(outfh, Array, ArrayCount);

    /* copy the extra input file - opened by generator functions */
    if (fhCode != NULL_FILE) {
        /* Check if the complete input file is to be copied or not */
        if (FileCount == -1) {
            MyCopyAll(fhCode, outfh);
            fclose(fhCode);
        } else {
            /* Only a part of the input file is to be copied */
            MyCopy(fhCode, outfh, FileCount);

            /* Note that the fhCode is NOT closed in this case */
        }
    }

    return(ArrayCount);
}


/*---------------------------------------------------------------------------*/
/*                                                                           */
/*  ResourceSize() -                                                         */
/*                                                                           */
/*---------------------------------------------------------------------------*/

LONG
ResourceSize (
    VOID
    )
{
    if (fhCode == NULL_FILE)
        return (LONG)CCount;            /* return size of array */
    else {
        /* note: currently all resources that use the fhCode file
         * compute their own resource sizes, and this shouldn't get
         * executed, but it is here in case of future modifications
         * which require it.
         */
        LONG lFPos = MySeek(fhCode, 0L, SEEK_CUR);
        LONG lcb = (LONG)CCount + MySeek(fhCode, 0L, SEEK_END) - lFPos;
        MySeek(fhCode, lFPos, SEEK_SET);
        return lcb;
    }
}


/*---------------------------------------------------------------------------*/
/*                                                                           */
/*  GetIcon() -                                                              */
/*                                                                           */
/*---------------------------------------------------------------------------*/

DWORD
GetIcon(
    LONG nbyFile
    )
{
    PFILE      infh = CtlFile(NULL_FILE);

    IconHeader header;
    LONG    nbyIconSize, nSeekLoc;
    LONG    nbyTransferred = 0;
    SHORT   IconID;
    int bHeaderWritten = FALSE;

    if (infh == NULL)
        return FALSE;
    /* read the header and find its size */
    if (!MyRead( infh, (PCHAR)&IconID, sizeof(SHORT))) {
        GenError2(2169, (PCHAR)tokenbuf); //"Resource file %ws is not in 2.03 format."
        return FALSE;
    }

    /* Check if the input file is in correct format */
    if (((CHAR)IconID != 1) && ((CHAR)IconID != 3))
        GenError2(2169, (PCHAR)tokenbuf); //"Resource file %ws is not in 2.03 format."

    if (!MyRead( infh, (PCHAR)(IconHeader *) &header, sizeof(IconHeader))) {
        GenError2(2169, (PCHAR)tokenbuf); //"Resource file %ws is not in 2.03 format."
        return FALSE;
    }
    nbyIconSize = (header.csWidthBytes * 2) * header.csHeight;

    /* if pre-shrunk version exists at eof */
    if ((nSeekLoc = ( sizeof (SHORT) + nbyIconSize + sizeof(IconHeader))) < nbyFile) {
        /* mark as device dependant */
        *(((PCHAR)&IconID) + 1) = 0;
        MySeek(infh, (LONG)nSeekLoc, SEEK_SET);
        WriteWord(IconID);
    } else {   /* only canonical version exists */

        *(((PCHAR)&IconID) + 1) = 1;   /* mark as device independent */
        WriteWord(IconID);
        WriteBuffer((PCHAR)&header, sizeof(IconHeader));
        bHeaderWritten = TRUE;
    }

    nbyTransferred = nbyFile - MySeek(infh, 0L, SEEK_CUR);

    /* return number of bytes in the temporary file */
    return (nbyTransferred + (bHeaderWritten ? sizeof(IconHeader) : 0)
         + sizeof(SHORT));
}


/*--------------------------------------------------------------------------*/
/*                                                                          */
/*  GetNewBitmap() -                                                        */
/*                                                                          */
/*   This loads the new bitmaps in DIB format (PM format)                   */
/*--------------------------------------------------------------------------*/

DWORD
GetNewBitmap(
    VOID
    )
{
    PFILE infh = CtlFile(NULL_FILE);
    BITMAPFILEHEADER bf;
    BITMAPCOREHEADER bc;
    BITMAPINFOHEADER *pBitMapInfo;
    int cbColorTable;
    PCHAR pColorTable;
    LONG        cbImage;
    int nbits;
    DWORD BitmapSize;

    if (infh == NULL)
        return FALSE;
    MyRead(infh, (PCHAR)&bf, sizeof(bf));

    /* Check if it is in correct format */
    if (bf.bfType != DIBBITMAPFORMAT)
        GenError2(2170, (PCHAR)tokenbuf); //"Bitmap file %ws is not in 3.00 format."

    /* get the header -- assume old format */
    MyRead(infh, (PCHAR)&bc, sizeof(bc));

    BitmapSize = bc.bcSize;

    if (BitmapSize >= sizeof(BITMAPINFOHEADER)) {
        /* V3 or better format */
        pBitMapInfo = (BITMAPINFOHEADER *) MyAlloc(BitmapSize);

        memcpy(pBitMapInfo, &bc, sizeof(bc));

        MyRead(infh, ((PCHAR)pBitMapInfo) + sizeof(bc), BitmapSize - sizeof(bc));

        nbits = pBitMapInfo->biPlanes * pBitMapInfo->biBitCount;

        if ( pBitMapInfo->biCompression == BI_BITFIELDS ) {
            if( (pBitMapInfo->biBitCount <= 8) ||
                (pBitMapInfo->biBitCount == 24) )
            {
                GenError2(2170, (PCHAR)tokenbuf); //"Bitmap file %ws is not in 3.00 format."
            }

            cbColorTable = 3 * sizeof(DWORD);
        } else {
            // Only pBitMapInfo->biBitCount 1,4,8,24. biBitCount 16 and 32 MUST have BI_BITFIELD specified
            cbColorTable = (int)pBitMapInfo->biClrUsed * sizeof(RGBQUAD);
            if ((cbColorTable  == 0) && (pBitMapInfo->biBitCount<=8))
                cbColorTable = (1 << nbits) * sizeof(RGBQUAD);
        }

        if (fMacRsrcs) {
            pBitMapInfo->biSize = SwapLong(pBitMapInfo->biSize);
            pBitMapInfo->biWidth = SwapLong(pBitMapInfo->biWidth);
            pBitMapInfo->biHeight = SwapLong(pBitMapInfo->biHeight);
            pBitMapInfo->biPlanes = SwapWord(pBitMapInfo->biPlanes);
            pBitMapInfo->biBitCount = SwapWord(pBitMapInfo->biBitCount);
            pBitMapInfo->biCompression = SwapLong(pBitMapInfo->biCompression);
            pBitMapInfo->biSizeImage = SwapLong(pBitMapInfo->biSizeImage);
            pBitMapInfo->biXPelsPerMeter = SwapLong(pBitMapInfo->biXPelsPerMeter);
            pBitMapInfo->biYPelsPerMeter = SwapLong(pBitMapInfo->biYPelsPerMeter);
            pBitMapInfo->biClrUsed = SwapLong(pBitMapInfo->biClrUsed);
            pBitMapInfo->biClrImportant = SwapLong(pBitMapInfo->biClrImportant);
        }
        WriteBuffer((PCHAR)pBitMapInfo, (USHORT)BitmapSize);
        MyFree(pBitMapInfo);
    } else if (BitmapSize == sizeof(BITMAPCOREHEADER)) {
        nbits = bc.bcPlanes * bc.bcBitCount;

        /* old format */
        if (nbits == 24)
            cbColorTable = 0;
        else
            cbColorTable = (1 << nbits) * sizeof(RGBTRIPLE);

        if (fMacRsrcs) {
            bc.bcSize = SwapLong(bc.bcSize);
            bc.bcWidth = SwapWord(bc.bcWidth);
            bc.bcHeight = SwapWord(bc.bcHeight);
            bc.bcPlanes = SwapWord(bc.bcPlanes);
            bc.bcBitCount = SwapWord(bc.bcBitCount);
        }
        WriteBuffer((PCHAR)&bc, (USHORT)BitmapSize);
    } else {
        GenError1(2171); //"Unknown DIB header format"
    }

    if (cbColorTable) {
        pColorTable = (PCHAR) MyAlloc(cbColorTable);
        MyRead(infh, pColorTable, cbColorTable);
        WriteBuffer(pColorTable, (USHORT)cbColorTable);
        MyFree(pColorTable);
    }

    /* get the length of the bits */
    cbImage = MySeek(infh, 0L, SEEK_END) - BFOFFBITS(&bf) + BitmapSize + cbColorTable;

    /* seek to the beginning of the bits... */
    MySeek(infh, BFOFFBITS(&bf), SEEK_SET);

    return cbImage;
}

VOID
WriteOrdCode(
    void
    )
{
    WriteWord(0xFFFF);
}


/*---------------------------------------------------------------------------*/
/*                                                                           */
/*  SetUpDlg() -                                                             */
/*                                                                           */
/*---------------------------------------------------------------------------*/

VOID
SetUpDlg(
    PDLGHDR pDlg,
    BOOL fDlgEx
    )
{
    if (fDlgEx) {
        // Hack -- this is how we version switch the dialog
        WriteWord(0x0001);          // store wDlgVer
        WriteWord(0xFFFF);          // store wSignature
        WriteLong(pDlg->dwHelpID);
        WriteLong(pDlg->dwExStyle); // store exstyle
    }

    /* write the style bits to the resource buffer */
    WriteLong(pDlg->dwStyle);   /* store style */

    if (!fDlgEx)
        WriteLong(pDlg->dwExStyle);   /* store exstyle */

    ItemCountLoc = CCount;        /* global marker for location of item cnt. */

    /* skip place for num of items */
    WriteWord(0);

    /* output the dialog position and size */
    WriteWord(pDlg->x);
    WriteWord(pDlg->y);
    WriteWord(pDlg->cx);
    WriteWord(pDlg->cy);

    /* output the menu identifier */
    if (pDlg->fOrdinalMenu) {
        WriteOrdCode();
        WriteWord((USHORT)wcsatoi(pDlg->MenuName));
    } else {
        WriteString(pDlg->MenuName, FALSE);
    }

    /* output the class identifier */
    if (pDlg->fClassOrdinal) {
        WriteOrdCode();
        WriteWord((USHORT)wcsatoi(pDlg->Class));
    } else {
        WriteString(pDlg->Class, FALSE);
    }

    /* output the title */
    WriteString(pDlg->Title, TRUE);

    /* add the font information */
    if (pDlg->pointsize) {
        WriteWord(pDlg->pointsize);
        if (fDlgEx) {
            WriteWord(pDlg->wWeight);
            WriteByte(pDlg->bItalic);
            WriteByte(pDlg->bCharSet);
        }
        WriteString(pDlg->Font, FALSE);
    }
}


/*---------------------------------------------------------------------------*/
/*                                                                           */
/*  SetUpItem() -                                                            */
/*                                                                           */
/*---------------------------------------------------------------------------*/

VOID
SetUpItem(
    PCTRL LocCtl,
    BOOL fDlgEx
    )
{
    PWCHAR  tempptr;

    /* control dimensions, id, and style bits */
    WriteAlign();

    // control dimensions, id, and style bits
    if (fDlgEx) {
        WriteLong(LocCtl->dwHelpID);
        WriteLong(LocCtl->dwExStyle);
        WriteLong(LocCtl->dwStyle);
    } else {
        WriteLong(LocCtl->dwStyle);
        WriteLong(LocCtl->dwExStyle);
    }

    WriteWord(LocCtl->x);
    WriteWord(LocCtl->y);
    WriteWord(LocCtl->cx);
    WriteWord(LocCtl->cy);

    if (fDlgEx)
        WriteLong(LocCtl->id);
    else
        WriteWord(LOWORD(LocCtl->id));

    /* control class */
    tempptr = LocCtl->Class;
    if (*tempptr == 0xFFFF) {
        /* special class code follows */
        WriteWord(*tempptr++);
        WriteWord(*tempptr++);
    } else {
        WriteString(tempptr, FALSE);
    }

    /* text */
    if (LocCtl->fOrdinalText) {
        WriteOrdCode();
        WriteWord((USHORT)wcsatoi(LocCtl->text));
    } else {
        WriteString(LocCtl->text, TRUE);
    }

    if (fDlgEx)
        ItemExtraLoc = CCount;

    WriteWord(0);   /* zero CreateParams count */

    IncItemCount();

}


void
SetItemExtraCount(
    WORD wCount,
    BOOL fDlgEx
    )
{
    if (fDlgEx)
        *((WORD *) (CodeArray + ItemExtraLoc)) = wCount;
}


/*---------------------------------------------------------------------------*/
/*                                                                           */
/*  IncItemCount() -                                                         */
/*                                                                           */
/*---------------------------------------------------------------------------*/

/* seemingly obscure way to increment # of items in a dialog */
/* ItemCountLoc indexes where we put the item count in the resource buffer, */
/* so we increment that counter when we add a control */

VOID
IncItemCount(
    VOID
    )
{
    PUSHORT     pus;

    pus = (PUSHORT)&CodeArray[ItemCountLoc];
    (*pus)++;
}


/*---------------------------------------------------------------------------*/
/*                                                                           */
/*  SwapItemCount() -                                                        */
/*                                                                           */
/*---------------------------------------------------------------------------*/
/* when writing a Mac resource fork, we need to swap this count before writing */
VOID
SwapItemCount(
    VOID
    )
{
    PUSHORT     pus;

    pus = (PUSHORT)&CodeArray[ItemCountLoc];
    *pus = SwapWord(*pus);
}


/*---------------------------------------------------------------------------*/
/*                                                                           */
/*  FixMenuPatch() -                                                         */
/*                                                                           */
/*---------------------------------------------------------------------------*/

VOID
FixMenuPatch(
    WORD wEndFlagLoc
    )
{
    if (fMacRsrcs)
        CodeArray[wEndFlagLoc + 1] |= MFR_END;
    else
        *((PWORD) (CodeArray + wEndFlagLoc)) |= MFR_END;
    // mark last menu item
//    CodeArray[wEndFlagLoc] |= MFR_END;
}


VOID
FixOldMenuPatch(
    WORD wEndFlagLoc
    )
{
    // mark last menu item
    if (fMacRsrcs)
        CodeArray[wEndFlagLoc + 1] |= OPENDMENU;
    else
        CodeArray[wEndFlagLoc] |= OPENDMENU;
}


/*---------------------------------------------------------------------------*/
/*                                                                           */
/*  MarkAccelFlagsByte() -                                                   */
/*                                                                           */
/*---------------------------------------------------------------------------*/

/* set the place where the accel end bit is going to be set */

VOID
MarkAccelFlagsByte (
    VOID
    )
{
    /* set the location to the current position in the resource buffer */
    mnEndFlagLoc = CCount;
}


/*---------------------------------------------------------------------------*/
/*                                                                           */
/*  PatchAccelEnd() -                                                        */
/*                                                                           */
/*---------------------------------------------------------------------------*/

VOID
PatchAccelEnd (
    VOID
    )
{
    if (fMacRsrcs)
        CodeArray[mnEndFlagLoc + 1] |= 0x80;
    else
        CodeArray[mnEndFlagLoc] |= 0x80;
}


// ----------------------------------------------------------------------------
//
//  SetUpMenu() -
//
// ----------------------------------------------------------------------------

WORD
SetUpMenu(
    PMENU pmn
    )
{
    WORD    wRes;

    WriteLong(pmn->dwType);
    WriteLong(pmn->dwState);
    WriteLong(pmn->dwID);

    // mark the last item added to the menu
    wRes = (WORD)CCount;

    WriteWord(pmn->wResInfo);
    WriteString(pmn->szText, TRUE);
    if (32)
        WriteAlign();
    if (pmn->wResInfo & MFR_POPUP)
        WriteLong(pmn->dwHelpID);

    return(wRes);
}


// ----------------------------------------------------------------------------
//
//  SetUpOldMenu() -
//
// ----------------------------------------------------------------------------

WORD
SetUpOldMenu(
    PMENUITEM mnTemp
    )
{
    WORD    wRes;

    /* mark the last item added to the menu */
    wRes = (WORD)CCount;

    /* write the menu flags */
    WriteWord(mnTemp->OptFlags);

    /* popup menus don't have id values */
    /* write ids of menuitems */
    if (!((mnTemp->OptFlags) & OPPOPUP))
        WriteWord(mnTemp->id);

    /* write text of selection */
    WriteString(mnTemp->szText, TRUE);

    return(wRes);
}


/*---------------------------------------------------------------------------*/
/*                                                                           */
/*  GetRCData() -                                                          */
/*                                                                           */
/*---------------------------------------------------------------------------*/

WORD
GetRCData (
    PRESINFO pRes
    )
{
    PCHAR       pch, pchT;
    PWCHAR      pwch;
    WORD        nBytes = 0;
    ULONG       cb = 0;

    /* look for BEGIN (after id RCDATA memflags) */
    // 2134 -- "BEGIN expected in RCData"
    PreBeginParse(pRes, 2134);

    /* add the users data to the resource buffer until we see an END */
    while (token.type != END) {
    /* see explanation in rcl.c in GetStr() */
        if (token.type == LSTRLIT)
            token.type = token.realtype;

        switch (token.type) {
            case LSTRLIT:
                pwch = tokenbuf;
                while (token.val--) {
                    WriteWord(*pwch++);
                    nBytes += sizeof(WCHAR);
                }
                break;

            case STRLIT:
                cb = WideCharToMultiByte(uiCodePage, 0, tokenbuf,
                                            token.val, NULL, 0, NULL, NULL);
                pchT = pch = (PCHAR) MyAlloc(cb);
                WideCharToMultiByte(uiCodePage, 0, tokenbuf,
                                            token.val, pch, cb, NULL, NULL);
                while (cb--) {
                    WriteByte(*pch++);
                    nBytes += sizeof(CHAR);
                }
                MyFree(pchT);
                break;

            case NUMLIT:
                if (token.flongval) {
                    WriteLong(token.longval);
                    nBytes += sizeof(LONG);
                } else {
                    WriteWord(token.val);
                    nBytes += sizeof(WORD);
                }
                break;

            default:
                ParseError1(2164);
                return 0;
        }
        ICGetTok();
    }

    return(nBytes);
}


/*---------------------------------------------------------------------------*/
/*                                                                           */
/*  AddFontRes() -                                                           */
/*                                                                           */
/*---------------------------------------------------------------------------*/

BOOL
AddFontRes(
    PRESINFO pRes
    )
{
    PFILE    fpFont;
    BYTE     font[FONT_ALL];
    PCHAR    pEnd, pDev, pFace;
    DWORD    offset;
    SHORT    nbyFont;
    PFONTDIR pFont;
    PFONTDIR pFontSearch;

    /* get handle to font file */
    fpFont = CtlFile(NULL_FILE);
    if (fpFont == NULL)
        return FALSE;
    MySeek(fpFont, 0L, SEEK_SET);

    /* copy font information to the font directory */
    /*    name strings are ANSI (8-bit) */
    MyRead(fpFont, (PCHAR)&font[0], sizeof(ffh));
    pEnd = (PCHAR) (&font[0] + sizeof(ffh));    /* pointer to end of font buffer */
    offset = ((ffh * )(&font[0]))->dfDevice;
    if (offset != (LONG)0)  {
        MySeek(fpFont, (LONG)offset, SEEK_SET);        /* seek to device name */
        pDev = pEnd;
        do {
            MyRead( fpFont, pEnd, 1);              /* copy device name */
        } while (*pEnd++);
    } else {
        (*pEnd++ = '\0');
    }
    offset = ((ffh * )(&font[0]))->dfFace;
    MySeek(fpFont, (LONG)offset, SEEK_SET);         /* seek to face name */
    pFace = pEnd;
    do {                                /* copy face name */
        MyRead( fpFont, pEnd, 1);
    } while (*pEnd++);

    nbyFont = (SHORT)(pEnd - (PCHAR) &font[0]);

    pFont = (FONTDIR * )MyAlloc(sizeof(FONTDIR) + nbyFont);
    pFont->nbyFont = nbyFont;
    pFont->ordinal = pRes->nameord;
    pFont->next = NULL;
    memcpy((PCHAR)(pFont + 1), (PCHAR)font, nbyFont);

    if (!nFontsRead) {
        pFontList = pFontLast = pFont;
    } else {
        for (pFontSearch=pFontList ; pFontSearch!=NULL ; pFontSearch=pFontSearch->next) {
            if (pFont->ordinal == pFontSearch->ordinal) {
                SET_MSG(Msg_Text, sizeof(Msg_Text), GET_MSG(2181), curFile, token.row, pFont->ordinal);
                SendError(Msg_Text);
                MyFree(pFont);
                return FALSE;
            }
        }
        pFontLast = pFontLast->next = pFont;
    }

    /* rewind font file for SaveResFile() */
    MySeek(fpFont, 0L, SEEK_SET);
    return TRUE;
}


/*--------------------------------------------------------------------------*/
/*                                                                          */
/*  SaveResFile() -                                                         */
/*                                                                          */
/*--------------------------------------------------------------------------*/


VOID
SaveResFile(
    PTYPEINFO pType,
    PRESINFO pRes
    )
{
    if (!fMacRsrcs)
        MyAlign(fhBin);

    AddResToResFile(pType, pRes, CodeArray, CCount, -1L);
}


/*--------------------------------------------------------------------------*/
/*                                                                          */
/*  GetNewIconsCursors(ResType)                                     */
/*                                                                          */
/*      This reads all the different forms of icons/cursors in 3.00 format  */
/*      in the input file                                                   */
/*                                                                          */
/*--------------------------------------------------------------------------*/

VOID
GetNewIconsCursors(
    PTYPEINFO pGroupType,
    PRESINFO pGroupRes,
    LPWSTR ResType
    )
{
    static SHORT  idIconUnique = 1;
    UINT          i;
    LONG          DescOffset;
    PTYPEINFO     pType;
    PRESINFO      pRes;
    NEWHEADER     NewHeader;
    DESCRIPTOR    Descriptor;
    BITMAPHEADER  BitMapHeader;
    RESDIR        ResDir;
    int           ArrayCount = 0;
    LOCALHEADER   LocHeader;

    /* Read the header of the bitmap file */
    MyRead(fhCode, (PCHAR)&NewHeader, sizeof(NEWHEADER));

    /* Check if the file is in correct format */
    if ((NewHeader.Reserved != 0) || ((NewHeader.ResType != 1) && (NewHeader.ResType != 2)))
        GenError2(2175, (PCHAR)tokenbuf); //"Resource file %ws is not in 3.00 format."
    /* Write the header into the Code array */
    WriteBuffer((PCHAR)&NewHeader, sizeof(NEWHEADER));

    /* Process all the forms one by one */
    for (i = 0; i < NewHeader.ResCount; i++) {
        /* Readin the Descriptor */
        MyRead(fhCode, (PCHAR)&Descriptor, sizeof(DESCRIPTOR));

        /* Save the current offset */
        DescOffset = MySeek(fhCode, 0L, SEEK_CUR);

        /* Seek to the Data */
        MySeek(fhCode, Descriptor.OffsetToBits, SEEK_SET);

        /* Get the bitcount and Planes data */
        MyRead(fhCode, (PCHAR)&BitMapHeader, sizeof(BITMAPHEADER));
        if (BitMapHeader.biSize != sizeof(BITMAPHEADER))
            GenError2(2176, (PCHAR)tokenbuf); //"Old DIB in %ws.  Pass it through SDKPAINT."

        ResDir.BitCount = BitMapHeader.biBitCount;
        ResDir.Planes = BitMapHeader.biPlanes;

        /* Seek to the Data */
        MySeek(fhCode, Descriptor.OffsetToBits, SEEK_SET);

        ArrayCount = 0;

        /* fill the fields of ResDir and LocHeader */
        switch (NewHeader.ResType) {
            case CURSORTYPE:

                LocHeader.xHotSpot = Descriptor.xHotSpot;
                LocHeader.yHotSpot = Descriptor.yHotSpot;
                ArrayCount = sizeof(LOCALHEADER);

                ResDir.ResInfo.Cursor.Width = (USHORT)BitMapHeader.biWidth;
                ResDir.ResInfo.Cursor.Height = (USHORT)BitMapHeader.biHeight;

                break;

            case ICONTYPE:

                ResDir.ResInfo.Icon.Width = Descriptor.Width;
                ResDir.ResInfo.Icon.Height = Descriptor.Height;
                ResDir.ResInfo.Icon.ColorCount = Descriptor.ColorCount;
                /* The following line is added to initialise the unused
                 * field "reserved".
                 * Fix for Bug #10382 --SANKAR-- 03-14-90
                 */
                ResDir.ResInfo.Icon.reserved = Descriptor.reserved;
                break;

        }

        ResDir.BytesInRes = Descriptor.BytesInRes + ArrayCount;


        /* Create a pRes with New name */
        pRes = (PRESINFO) MyAlloc(sizeof(RESINFO));
        pRes->language = language;
        pRes->version = version;
        pRes->characteristics = characteristics;
        pRes ->name = NULL;
        pRes ->nameord = idIconUnique++;

        /* The individual resources must have the same memory flags as the
            ** group.
            */
        pRes ->flags = pGroupRes ->flags;
        pRes ->size = Descriptor.BytesInRes + ArrayCount;

        /* Create a new pType, or find existing one */
        pType = AddResType(NULL, ResType);


        /* Put Resource Directory entry in CodeArray */
        WriteBuffer((PCHAR)&ResDir, sizeof(RESDIR));

        /*
         * Write the resource name ordinal.
         */
        WriteWord(pRes->nameord);

        MyAlign(fhBin);

        AddResToResFile(pType, pRes, (PCHAR)&LocHeader, ArrayCount,
            Descriptor.BytesInRes);

        /* Seek to the Next Descriptor */
        MySeek(fhCode, DescOffset, SEEK_SET);
    }

    pGroupRes ->size = sizeof(NEWHEADER) + NewHeader.ResCount * (sizeof(RESDIR) + sizeof(SHORT));

    /* If the group resource is marked as PRELOAD, then we should use
        ** the same flags. Otherwise, mark it as DISCARDABLE
        */
    if (!(pGroupRes ->flags & NSPRELOAD))
        pGroupRes ->flags = NSMOVE | NSPURE | NSDISCARD;

    /* Close the input file, nothing more to read */
    fclose(fhCode);
    fhCode = NULL_FILE;

    /* Copy the code array into RES file for Group items */
    SaveResFile(pGroupType, pGroupRes);
}

/*--------------------------------------------------------------------------*/
/*                                                                          */
/*  FileIsAnimated(LONG nbyFile)                                            */
/*                                                                          */
/*  This function checks to see if the file we have is 3.0 icon/cursor file */
/*  or an animated icon/cursor.                                             */
/*                                                                          */
/*  Returns RT_* of filetype.                                               */
/*--------------------------------------------------------------------------*/

DWORD
FileIsAnimated(
    LONG nbyFile
    )
{
    RTAG tag;
    LONG lRead;

    lRead = MyRead(fhCode, (PRTAG)&tag, sizeof(RTAG));
    MySeek(fhCode, 0L, SEEK_SET);             /* return to start of file */
    if (lRead != sizeof(RTAG))
        return FALSE;

    return tag.ckID == FOURCC_RIFF;
}

/*--------------------------------------------------------------------------*/
/*                                                                          */
/*  GetAniIconsAniCursors(ResType)                                          */
/*                                                                          */
/*  This function check if the file we have is a valid animated icon.       */
/*  All the work performed here is purelly optional and is done to make     */
/*  sure that the image we write in the res file is in the proper format.   */
/*  Just returning the nbyFile would be enough to copy the file in the res  */
/*  file.                                                                   */
/*                                                                          */
/*--------------------------------------------------------------------------*/

DWORD
GetAniIconsAniCursors(
    LONG nbyFile
    )
{
    RTAG tag;
    LONG lRead = nbyFile;

    /* Check if we have a RIFF file */
    lRead -= MyRead(fhCode, (PRTAG)&tag, sizeof(RTAG));

    if( tag.ckID!=FOURCC_RIFF )
        GenError2(2173, (PCHAR)tokenbuf);

    /* Read the next chunk */
    lRead -= MyRead(fhCode, (LPDWORD)&tag.ckID, sizeof(tag.ckID));
    if( tag.ckID!=FOURCC_ACON )
        GenError2(2173, (PCHAR)tokenbuf);

    /* so we have an animated icon file, make sure all the blocks are there */
    while( MyRead(fhCode, (PRTAG)&tag, sizeof(RTAG)) ) {
        lRead -= sizeof(RTAG)+tag.ckSize;
        MySeek(fhCode, tag.ckSize, SEEK_CUR);
    }

    if( lRead!=0 )
        GenError2(2173, (PCHAR)tokenbuf);

    /*
     * Now that we are sure this is a valid file, move the
     * file pointer back at the begining of the file.
     */
    MySeek(fhCode, 0L, SEEK_SET);

    return nbyFile;
}

/*  GetBufferLen
 *      Returns the current length of the buffer
 */

WORD
GetBufferLen(
    VOID
    )
{
    return (WORD)CCount;
}


USHORT
GetItemCount(
    int Index
    )
{
    return *((USHORT UNALIGNED*)(CodeArray + Index));
}

void
SetItemCount(
    int Index,
    USHORT wCount
    )
{
    *((USHORT UNALIGNED*)(CodeArray + Index)) = wCount;
}

DWORD
SwapLong(
    DWORD dw
    )
{
    return ((dw << 24) & 0xff000000L) |
    ((dw << 8) & 0x00ff0000L) |
    ((dw >> 8) & 0x0000ff00L) |
    ((dw >> 24) & 0x000000ffL);
}

WORD
SwapWord(
    WORD w
    )
{
    return ((w << 8) & 0xff00) |
        ((w >> 8) & 0x00ff);
}

enum {
    itNone = -1,

    itIcn_ = 0,
    itIcl4 = 1,
    itIcl8 = 2,

    itIcs_ = 3,
    itIcs4 = 4,
    itIcs8 = 5,

    itIcm_ = 6,
    itIcm4 = 7,
    itIcm8 = 8,

    itMax = 9
};

static DWORD mpitres[itMax] = {
    'ICN#',
    'icl4',
    'icl8',
    'ics#',
    'ics4',
    'ics8',
    'icm#',
    'icm4',
    'icm8'
};

enum {
    fitIcn_ = 1 << itIcn_,
    fitIcl4 = 1 << itIcl4,
    fitIcl8 = 1 << itIcl8,

    fitIcs_ = 1 << itIcs_,
    fitIcs4 = 1 << itIcs4,
    fitIcs8 = 1 << itIcs8,

    fitIcm_ = 1 << itIcm_,
    fitIcm4 = 1 << itIcm4,
    fitIcm8 = 1 << itIcm8
};

void
GetMacIcon(
    TYPEINFO *pType,
    RESINFO *pRes
    )
{
    struct tagNEWHEADER gh;
    struct tagDESCRIPTOR ds;
    BITMAPINFOHEADER bmh;
    int ibDescNext;
    int mpitib[itMax];
    int it;
    int ires;
    int fitFound;

    /* The input file has already been opened; read in the bitmap file header */

    MyRead(fhCode, (char*)&gh, sizeof(struct tagNEWHEADER));
    if (gh.Reserved != 0 || gh.ResType != 1)
        GenError2(2175, (PCHAR)tokenbuf);

    /* run through all the icons, keeping track of the useful ones */

    memset(mpitib, 0, sizeof(mpitib));
    ibDescNext = MySeek(fhCode, 0L, SEEK_CUR);
    fitFound = 0;
    for (ires = 0; ires < gh.ResCount; ires++) {
        /* Read in the descriptor */

        MySeek(fhCode, ibDescNext, SEEK_SET);
        MyRead(fhCode, (char*)&ds, sizeof(struct tagDESCRIPTOR));
        ibDescNext = MySeek(fhCode, 0L, SEEK_CUR);

        /* get bitmap header */

        MySeek(fhCode, ds.OffsetToBits, SEEK_SET);
        MyRead(fhCode, (char*)&bmh, sizeof(BITMAPINFOHEADER));
        if (bmh.biSize != sizeof(BITMAPINFOHEADER))
            GenError2(2176, (PCHAR)tokenbuf);

        /* find valid color cases */

        if (bmh.biPlanes != 1)
            continue;
        if (bmh.biBitCount == 1)
            it = itIcn_;
        else if (bmh.biBitCount == 4)
            it = itIcl4;
        else if (bmh.biBitCount == 8)
            it = itIcl8;
        else
            continue;

        /* find valid sizes */

        if (bmh.biWidth == 16 && bmh.biHeight == 24)
            it += itIcm_ - itIcn_;
        else if (bmh.biWidth == 16 && bmh.biHeight == 32)
            it += itIcs_ - itIcn_;
        else if (bmh.biWidth == 32 && bmh.biHeight == 64)
            it += itIcn_ - itIcn_;
        else
            continue;

        /* mark sizes we found */

        fitFound |= 1 << it;
        mpitib[it] = ibDescNext - sizeof(struct tagDESCRIPTOR);
    }

    /* if no usable icon found, bail out */

    if (fitFound == 0) {
        GenWarning2(4508, (PCHAR)tokenbuf);
    } else {
        if (fitFound & (fitIcn_|fitIcl4|fitIcl8))
            ProcessMacIcons(pRes, itIcn_, mpitib[itIcn_], mpitib[itIcl4], mpitib[itIcl8]);
        if (fitFound & (fitIcs_|fitIcs4|fitIcs8))
            ProcessMacIcons(pRes, itIcs_, mpitib[itIcs_], mpitib[itIcs4], mpitib[itIcs8]);
        if (fitFound & (fitIcm_|fitIcm4|fitIcm8))
            ProcessMacIcons(pRes, itIcm_, mpitib[itIcs_], mpitib[itIcs4], mpitib[itIcs8]);
    }

    fclose(fhCode);
    fhCode = NULL_FILE;
}


int
Luminance(
    RGBColor* prgb
    )
{
    return prgb->red/256*30 + prgb->green/256*59 + prgb->blue/256*11;
}

/* threshold = middle gray */

#define rThreshold 128
#define gThreshold 128
#define bThreshold 128
int lumThreshold = rThreshold*30 + gThreshold*59 + bThreshold*11;


void
ProcessMacIcons(
    RESINFO* pResBase,
    int itBase,
    int ib1,
    int ib4,
    int ib8
    )
{
    BITMAPINFOHEADER bmh;
    RGBQUAD* rgq;
    struct tagDESCRIPTOR ds;
    BYTE* pBits;
    int cbWidth, cbMask;
    int cbBits;
    int ib, iq;
    int y;
    BYTE *pbIn;
    BYTE* pbOut;
    BYTE bIn, bOut;

    /* create monochrome icon out of the best-looking icon */

    if (ib1 != 0) {
        /* read the DIB */

        ReadDIB(ib1, &ds, &bmh, &cbWidth, (void **) &pBits, &rgq, TRUE);

        /* invert bits, if color table is backwards */

        if (rgq[0].rgbReserved != 0)
            for (ib = cbWidth*bmh.biHeight/2; --ib >= 0; )
                pBits[ib] ^= 0xff;
    } else if (ib4 != 0) {
        /* read the DIB and create color-to-mono color mapping */

        ReadDIB(ib4, &ds, &bmh, &cbWidth, (void **) &pBits, &rgq, TRUE);
        for (iq = 0; iq < (int)bmh.biClrUsed; iq++)
            rgq[iq].rgbReserved =
                    Luminance(&rgcs16[rgq[iq].rgbReserved].rgb) < lumThreshold;

        /* map colors to black and white and convert to 1-bit/pixel */

        for (y = 0; y < (int)(bmh.biHeight/2); y++) {
            pbIn = pBits + y*cbWidth;
            pbOut = pbIn;
            assert(cbWidth % 4 == 0);   // we know it's 8 or 16 bytes wide
            for (ib = 0; ib < cbWidth; ) {
                bIn = *pbIn++;
                bOut = (bOut<<1) | rgq[bIn>>4].rgbReserved;
                bOut = (bOut<<1) | rgq[bIn&0xf].rgbReserved;
                ib++;
                if (ib % 4 == 0)
                    *pbOut++ = bOut;
            }
        }
    } else {
        /* read the DIB and create color-to-mono color mapping */

        ReadDIB(ib8, &ds, &bmh, &cbWidth, (void **) &pBits, &rgq, TRUE);
        for (iq = 0; iq < (int)bmh.biClrUsed; iq++)
            rgq[iq].rgbReserved =
                    Luminance(&rgcs256[rgq[iq].rgbReserved].rgb) < lumThreshold;

        /* map colors to black and white and convert to 1-bit/pixel */

        for (y = 0; y < (int)(bmh.biHeight/2); y++) {
            pbIn = pBits + y*cbWidth;
            pbOut = pbIn;
            assert(cbWidth % 8 == 0);   // we know it's 16 or 32 bytes wide
            for (ib = 0; ib < cbWidth; ) {
                bIn = *pbIn++;
                bOut = (bOut<<1) | rgq[bIn].rgbReserved;
                ib++;
                if (ib % 8 == 0)
                    *pbOut++ = bOut;
            }
        }
    }

    cbMask = (bmh.biWidth+31)/32*4;
    CompactAndFlipIcon(pBits, cbWidth, cbMask, bmh.biWidth/8, bmh.biWidth/8, bmh.biHeight/2);
    cbBits = bmh.biHeight * (bmh.biWidth/8);

    /* "xor" the mask back into image */
    pbOut = pBits; pbIn = pBits + cbBits/2;
    for (ib = cbBits/2; ib > 0; ib--)
        *pbOut++ ^= ~*pbIn++;

    /* and write out base icon */

    WriteMacRsrc(pBits, cbBits, pResBase, mpitres[itBase]);
    MyFree(pBits);
    MyFree(rgq);

    /* move over 16-color icon */

    if (ib4 != 0) {
        ReadDIB(ib4, &ds, &bmh, &cbWidth, (void **) &pBits, &rgq, TRUE);

        /* convert color table to mac standard palette */

        for (pbIn = pBits, ib = cbWidth*bmh.biHeight/2; ib > 0; pbIn++, ib--) {
            bIn = *pbIn;
            *pbIn = (rgq[bIn>>4].rgbReserved << 4) |
                    rgq[bIn&0x0f].rgbReserved;
        }

        /* compact and flip the image */

        cbMask = (bmh.biWidth+31)/32*4;
        CompactAndFlipIcon(pBits, cbWidth, cbMask, bmh.biWidth/2, bmh.biWidth/8, bmh.biHeight/2);
        cbBits = (bmh.biHeight/2) * (bmh.biWidth/2);

        /* "xor" the mask back into the image */

        pbOut = pBits; pbIn = pBits + cbBits;
        for (ib = 0; ib < cbBits; ib++, pbOut++) {
            if (ib % 4 == 0)
                bIn = *pbIn++;
            if ((bIn & 0x80) == 0)
                *pbOut ^= 0xf0;
            if ((bIn & 0x40) == 0)
                *pbOut ^= 0x0f;
            bIn <<= 2;
        }

        /* and write out the resource */

        WriteMacRsrc(pBits, cbBits, pResBase, mpitres[itBase+itIcs4-itIcs_]);
        MyFree(pBits);
        MyFree(rgq);
    }

    /* move over 256-color icon */

    if (ib8 != 0) {
        ReadDIB(ib8, &ds, &bmh, &cbWidth, (void **) &pBits, &rgq, TRUE);

        /* convert color table to mac standard palette */

        for (pbIn = pBits, ib = cbWidth*bmh.biHeight/2; ib > 0; pbIn++, ib--)
            *pbIn = rgq[*pbIn].rgbReserved;

        /* compact and flip the image */

        cbMask = (bmh.biWidth+31)/32*4;
        CompactAndFlipIcon(pBits, cbWidth, cbMask, bmh.biWidth, bmh.biWidth/8, bmh.biHeight/2);
        cbBits = (bmh.biHeight/2) * (bmh.biWidth);

        /* "xor" the mask back into the image */

        pbOut = pBits; pbIn = pBits + cbBits;
        for (ib = 0; ib < cbBits; ib++, pbOut++) {
            if (ib % 8 == 0)
                bIn = *pbIn++;
            if ((bIn & 0x80) == 0)
                *pbOut ^= 0xff;
            bIn <<= 1;
        }

        /* and write out the resource */

        WriteMacRsrc(pBits, cbBits, pResBase, mpitres[itBase+itIcs8-itIcs_]);

        MyFree(pBits);
        MyFree(rgq);
    }
}

void
WriteMacRsrc(
    void* pBits,
    int cbBits,
    RESINFO* pResBase,
    DWORD res
    )
{
    WCHAR sz[8];
    TYPEINFO* pType;
    RESINFO* pRes;

    sz[0] = (char)(res >> 24);
    sz[1] = (char)(res >> 16);
    sz[2] = (char)(res >> 8);
    sz[3] = (char)res;
    sz[4] = 0;
    pType = AddResType(sz, 0);

    pRes = (RESINFO *)MyAlloc(sizeof(RESINFO));
    *pRes = *pResBase;
    pRes->size = cbBits;

    AddResToResFile(pType, pRes, (PCHAR) pBits, (WORD)cbBits, 0);
}


void
CompactAndFlipIcon(
    BYTE* pBits,
    int cbRowCur,
    int cbRowMaskCur,
    int cbRowNew,
    int cbRowMaskNew,
    int Height
    )
{
    BYTE* pBitsNew;
    int y;
    BYTE* pbFrom, *pbTo;
    int cb;

    assert(cbRowCur >= cbRowNew);
    pBitsNew = (BYTE *) MyAlloc((WORD)(Height*(cbRowNew+cbRowMaskCur)));

    /* copy the bits over into the scratch space, compacting and
       flipping as we go */

    for (y = 0; y < Height; y++)
        memcpy(pBitsNew+y*cbRowNew, pBits+(Height-y-1)*cbRowCur, cbRowNew);

    /* copy over the mask, flipping and inverting as we go */

    for (y = 0; y < Height; y++) {
        pbTo = pBitsNew + cbRowNew*Height + y*cbRowMaskNew;
        pbFrom = pBits + cbRowCur*Height + (Height-y-1)*cbRowMaskCur;
        for (cb = cbRowMaskNew; cb > 0; cb--)
            *pbTo++ = ~*pbFrom++;
    }

    /* and move the result back to pBits */

    memcpy(pBits, pBitsNew, (cbRowNew+cbRowMaskCur)*Height);
    MyFree(pBitsNew);
}

void CrunchY(unsigned char* pbSrc, unsigned char* pbDst, int WidthBytes, int dySrc, int scale);
void CrunchX2(unsigned char* pbSrc, unsigned char* pbDst, int cbWidth, int dy);

void
GetMacCursor(
    TYPEINFO *pType,
    RESINFO *pRes
    )
{
    struct tagNEWHEADER gh;
    struct tagDESCRIPTOR ds;
    BITMAPINFOHEADER bmh;
    RGBQUAD *rgbq;
    short rgwMask[16];
    short rgwData[16];
    int xyBest;
    int xScale, yScale;
    char* pbBits;
    int ibDescNext, ibDescBest;
    int ires;
    int y, dy;
    int cbWidth;

    /* The input file has already been opened; read in the bitmap file header */

    MyRead(fhCode, (char*)&gh, sizeof(struct tagNEWHEADER));
    if (gh.Reserved != 0 || gh.ResType != 2)
        GenError2(2175, (PCHAR)tokenbuf);

    /* find the best-looking cursor */

    xyBest = 32767;
    ibDescBest = -1;
    ibDescNext = MySeek(fhCode, 0L, SEEK_CUR);
    for (ires = 0; ires < gh.ResCount; ires++) {
        /* Read in the descriptor */

        MySeek(fhCode, ibDescNext, SEEK_SET);
        MyRead(fhCode, (char*)&ds, sizeof(struct tagDESCRIPTOR));
        ibDescNext = MySeek(fhCode, 0L, SEEK_CUR);

        /* get bitmap header */

        MySeek(fhCode, ds.OffsetToBits, SEEK_SET);
        MyRead(fhCode, (char*)&bmh, sizeof(BITMAPINFOHEADER));
        if (bmh.biSize != sizeof(BITMAPINFOHEADER))
            GenError2(2176, (PCHAR)tokenbuf);
        /* !!! could we be smarter here about smaller cursors? */
        if (bmh.biBitCount != 1 || bmh.biPlanes != 1 ||
                bmh.biWidth % 16 != 0 || bmh.biHeight % 32 != 0)
            continue;
        xScale = bmh.biWidth / 16;
        yScale = bmh.biHeight / 32;
        if (xScale > 2)
            continue;
        if (xScale * yScale < xyBest) {
            xyBest = xScale * yScale;
            ibDescBest = ibDescNext - sizeof(struct tagDESCRIPTOR);
        }
    }

    /* if no usable cursor found, bail out */

    if (ibDescBest == -1) {
        GenWarning2(4507, (PCHAR)tokenbuf);
        return;
    }

    /* go back and get the best descriptor and bitmap header */

    ReadDIB(ibDescBest, &ds, &bmh, &cbWidth, (void **) &pbBits, &rgbq, FALSE);

    /* if our color table is backwards, invert the bits */

    if ((rgbq[0].rgbRed == 0xff) &&
        (rgbq[0].rgbGreen == 0xff) &&
        (rgbq[0].rgbBlue == 0xff))
    {
        int cb;
        for (cb = cbWidth * bmh.biHeight; cb > 0; cb--)
            pbBits[cb] = ~pbBits[cb];
    }

    /* if necessary, scale the bits down to 16x16 */

    if (xyBest != 1) {
        GenWarning2(4506, (PCHAR)tokenbuf);
        if (bmh.biWidth > 16) {
            assert(bmh.biWidth == 32);
            ds.xHotSpot /= (int)(bmh.biWidth / 16);
            CrunchX2((unsigned char *) pbBits, (unsigned char *) pbBits, cbWidth, bmh.biHeight);
            cbWidth = 2;
        }
        if (bmh.biHeight > 32) {
            ds.yHotSpot /= (int)(bmh.biHeight / 32);
            CrunchY((unsigned char *) pbBits, (unsigned char *) pbBits, cbWidth, bmh.biHeight, bmh.biHeight/32);
            bmh.biHeight = 32;
        }
    }

    /* now build the CURS resource mask and data */

    dy = bmh.biHeight/2;
    if (cbWidth == 1) {
        for (y = dy; y > 0; y--) {
            rgwMask[dy-y] = pbBits[y-1];
            rgwData[dy-y] = pbBits[dy+y-1] ^ ~rgwMask[dy-y];
        }
    } else {
        for (y = dy; y > 0; y--) {
            rgwMask[dy-y] = ~*(short*)&pbBits[(dy+y-1)*cbWidth];
            rgwData[dy-y] = *(short*)&pbBits[(y-1)*cbWidth] ^ rgwMask[dy-y];
        }
    }
    for (y = dy; y < 16; y++) {
        rgwMask[y] = 0;
        rgwData[y] = 0;
    }

    /* and write out the CURS resource data */

    WriteBuffer((char*)rgwData, 32);
    WriteBuffer((char*)rgwMask, 32);
    WriteWord(ds.yHotSpot);
    WriteWord(ds.xHotSpot);

    pRes->size = 32 + 32 + 2 + 2;

    /* and we're done - cleanup and return */

    MyFree(pbBits);
    MyFree(rgbq);
    fclose(fhCode);
    fhCode = NULL_FILE;
    AddResToResFile(pType, pRes, CodeArray, CCount, 0);
}


void
ReadDIB(
    int ibDesc,
    struct tagDESCRIPTOR* pds,
    BITMAPINFOHEADER* pbmh,
    int* pcbWidth,
    void** ppBits,
    RGBQUAD** prgq,
    BOOL fIcon
    )
{
    int cbBits;
    int iq;

    MySeek(fhCode, ibDesc, SEEK_SET);
    MyRead(fhCode, (char*)pds, sizeof(struct tagDESCRIPTOR));
    MySeek(fhCode, pds->OffsetToBits, SEEK_SET);
    MyRead(fhCode, (char *)pbmh, sizeof(BITMAPINFOHEADER));

    /* get the color table and map to macintosh color palette while we're
       looking at it */

    if (pbmh->biClrUsed == 0)
        pbmh->biClrUsed = 1 << pbmh->biBitCount;
    *prgq = (RGBQUAD*)MyAlloc((WORD)(pbmh->biClrUsed * sizeof(RGBQUAD)));
    MyRead(fhCode, (char *)*prgq, (WORD)(pbmh->biClrUsed*sizeof(RGBQUAD)));
    switch (pbmh->biBitCount) {
        case 1:
            for (iq = 0; iq < (int)pbmh->biClrUsed; iq++)
                LookupIconColor(rgcs2, ccs2, &(*prgq)[iq]);
            break;
        case 4:
            for (iq = 0; iq < (int)pbmh->biClrUsed; iq++)
                LookupIconColor(rgcs16, ccs16, &(*prgq)[iq]);
            break;
        case 8:
            // !!! should use 256-color palette
            for (iq = 0; iq < (int)pbmh->biClrUsed; iq++)
                LookupIconColor(rgcs256, ccs256, &(*prgq)[iq]);
            break;
        default:
            break;
    }

    /* allocate space for the bits, and load them in */

    *pcbWidth = (pbmh->biBitCount*pbmh->biWidth+31)/32*4;
    if (fIcon)
        cbBits = (*pcbWidth * pbmh->biHeight/2) + ((pbmh->biWidth+31)/32*4) * (pbmh->biHeight/2);
    else
        cbBits = *pcbWidth * pbmh->biHeight;
    *ppBits = MyAlloc((WORD)cbBits);
    MyRead(fhCode, *ppBits, (WORD)cbBits);
}


void
LookupIconColor(
    ColorSpec* rgcs,
    int ccs,
    RGBQUAD* pq
    )
{
    int ics, icsBest;
    int dred, dgreen, dblue;
    int drgb, drgbBest;

    drgbBest = 32767;
    icsBest = -1;
    for (ics = 0; ics < ccs; ics++) {
        dred = pq->rgbRed - (rgcs[ics].rgb.red>>8);
        dgreen = pq->rgbGreen - (rgcs[ics].rgb.green>>8);
        dblue = pq->rgbBlue - (rgcs[ics].rgb.blue>>8);
        drgb = abs(dred) + abs(dgreen) + abs(dblue);
        if (drgb < drgbBest) {
            drgbBest = drgb;
            icsBest = ics;
            if (drgbBest == 0)
                break;
        }
    }
    pq->rgbReserved = (BYTE)rgcs[icsBest].value;
}


BOOL
IsIcon(
    TYPEINFO* ptype
    )
{
    unsigned long rt;
    short it;

    if (ptype->type == 0)
        return FALSE;
    rt = res_type(ptype->type[0], ptype->type[1], ptype->type[2], ptype->type[3]);
    for (it = 0; it < itMax; it++)
        if (rt == mpitres[it])
            return TRUE;
    return FALSE;
}


void
CrunchX2(
    unsigned char* pbSrc,
    unsigned char* pbDst,
    int cbWidth,
    int dy
    )
{
    unsigned short cw, cwWidth;
    unsigned short w;
    unsigned char b = 0;
    short bit;

    assert(dy > 0);
    assert(cbWidth > 1);

    cwWidth = cbWidth / 2;
    do {
        cw = cwWidth;
        do {
            w = (*pbSrc << 8)|(*(pbSrc+1));
            pbSrc += 2;
            bit = 8;
            do {
                b >>= 1;
                if ((w & 3) == 3)   /* if both are white, keep white */
                    b += 0x80;
                w >>= 2;
            } while (--bit != 0);
            *pbDst++ = b;
        } while (--cw > 0);
        pbDst += cwWidth & 1;
    } while (--dy > 0);
}


void
CrunchY(
    unsigned char* pbSrc,
    unsigned char* pbDst,
    int WidthBytes,
    int dySrc,
    int scale
    )
{
    int cbGroup;
    int cwRow;
    int dyDst, dy;
    unsigned short w;
    unsigned char *pb;

    if (scale <= 1) {
        memcpy(pbDst, pbSrc, dySrc * WidthBytes);
        return;
    }
    dyDst = dySrc / scale;
    cbGroup = WidthBytes * (scale - 1);

    do {
        cwRow = WidthBytes / sizeof(unsigned short);
        do {
            pb = pbSrc;
            w = *(unsigned short*)pb;
            dy = scale - 1;
            do {
                pb += WidthBytes;
                w &= *(unsigned short*)pb;
            } while (--dy > 0);
            *((unsigned short*)pbDst) = w;
            pbDst += sizeof(unsigned short);
            pbSrc += sizeof(unsigned short);
        } while (--cwRow > 0);
        pbSrc += cbGroup;
    } while (--dyDst > 0);
}

/*  WriteMacMap
 *
 *  Writes out a macintosh resource map from the type and resource
 *  data stashed away in the type and resource lists
 *
 *  See Inside Mac, Volume I, for a fine description of the
 *  format of a macintosh resource file
 */
void
WriteMacMap(
    void
    )
{
    TYPEINFO *ptype;
    RESINFO *pres;
    int i;
    size_t cch;
    int cbNameTbl, ctype, cref, ibName;
    long cbData;
    int offRef;
    WCHAR *pch;
#define cbMacType 8
#define cbMacRef 12

    /* alright, we're done reading all this stuff in, run through all
       our type lists and see what we've accumulated */

    cbData = MySeek(fhBin, 0L, 1) - MACDATAOFFSET;
    ctype = 0;
    cref = 0;
    cbNameTbl = 0;

    for (ptype = pTypInfo; ptype != 0; ptype = ptype->next) {
        if (ptype->nres == 0)
            continue;
        ctype++;
        cref += ptype->nres;
        for (pres = ptype->pres; pres != 0; pres = pres->next) {
            /* make sure each reference has a unique resource id */
            if (pres->nameord == 0)
                pres->nameord = (USHORT)IdUnique(ptype, pres);
            if (pres->name != 0)
                cbNameTbl += wcslen(pres->name)+1;
        }
    }

    /* write out the resource header at offset 0 in the file */

    MySeek(fhBin, 0L, 0);
    CtlInit();
    WriteLong((long)MACDATAOFFSET);
    WriteLong((long)MACDATAOFFSET + cbData);
    WriteLong(cbData);
    WriteLong((long)(16+4+2+2+2+2+2 + ctype*cbMacType + cref*cbMacRef + cbNameTbl));
    for (i = (MACDATAOFFSET - 16)/4; i-- > 0; )
        WriteLong(0);
    MyWrite(fhBin, (LPSTR)CodeArray, CCount);

    /* we've already written out all the data, now write out the
       beginning of the map part of the resource file */

    MySeek(fhBin, (long)MACDATAOFFSET + cbData, 0);
    CtlInit();
    /* 24 bytes of 0s */
    for (i = 6; i-- > 0; )
        WriteLong(0);
    /* offset to start of type list */
    WriteWord(28);
    /* offset to start of name list */
    WriteWord((USHORT)(28 + 2 + ctype * cbMacType + cref * cbMacRef));

    /* dump out type table of the resource map */

    WriteWord((USHORT)(ctype - 1));
    offRef = 2 + ctype * cbMacType;
    for (ptype = pTypInfo; ptype != 0; ptype = ptype->next) {
        long rt;
        TYPEINFO *ptypeX;

        if (ptype->nres == 0)
            continue;
        /* 32-bit resource name - verify name truncation didn't
           cause conflicts */
        rt = MungeResType(ptype->type, ptype->typeord);
        for (ptypeX = ptype->next; ptypeX != 0; ptypeX = ptypeX->next) {
            if (rt == MungeResType(ptypeX->type, ptypeX->typeord)) {
                char szMac[8], szType1[128], szType2[128];
                szMac[0] = (BYTE)(rt>>24);
                szMac[1] = (BYTE)(rt>>16);
                szMac[2] = (BYTE)(rt>>8);
                szMac[3] = (BYTE)(rt);
                szMac[4] = 0;
                if (ptype->typeord)
                    wsprintfA(szType1, "%d", ptype->typeord);
                else
                    wsprintfA(szType1, "%ws", ptype->type);
                if (ptypeX->typeord)
                    wsprintfA(szType2, "%d", ptypeX->typeord);
                else
                    wsprintfA(szType2, "%ws", ptypeX->type);
                GenWarning4(4509, szType1, szType2, szMac);
            }
        }
        WriteLong(rt);
        /* number of references of this type */
        WriteWord((USHORT)(ptype->nres-1));
        /*  offset to the reference list for this type */
        WriteWord((USHORT)offRef);
        offRef += ptype->nres * cbMacRef;
    }

    /* dump out reference table of the resource map */

    ibName = 0;
    for (ptype = pTypInfo; ptype != 0; ptype = ptype->next) {
        if (ptype->nres == 0)
            continue;
        for (pres = ptype->pres; pres != 0; pres = pres->next) {
            /* resource id */
            WriteWord(pres->nameord);
            /* offset to name in namelist */
            if (pres->name == 0) {
                WriteWord(0xffff);  /* unnamed, use -1 */
            } else {
                WriteWord((USHORT)ibName);
                ibName += wcslen(pres->name)+1;
            }
            /* attributes and resource data offset */
            WriteLong(pres->BinOffset);
            /* must be 0 */
            WriteLong(0L);
        }
    }

    /* and finally, dump out name table */

    /* note that we've implemented the Unicode=>ASCII conversion here by
       simply dumping out the low byte of each Unicode character. Effectively,
       we're assuming that resource names will be ASCII. Changing this would
       require changing the output code here and also changing a few places
       where we use wcslen to calculate the number of bytes that the ASCII
       resource name will require. If the resource name can contain 2-byte
       characters we would need to convert the Unicode to multi-byte and
       then count characters instead of just calling wcslen. */

    for (ptype = pTypInfo; ptype != 0; ptype = ptype->next) {
        if (ptype->nres == 0)
            continue;
        for (pres = ptype->pres; pres != 0; pres = pres->next) {
            if (pres->name == 0)
                continue;
            WriteByte(cch = wcslen(pres->name));
            for (pch = pres->name; cch--; )
                WriteByte((BYTE)*pch++);
        }
    }
    MyWrite(fhBin, (LPSTR)CodeArray, CCount);
}


long
MungeResType(
    WCHAR *szType,
    short wOrd
    )
{
    long rt;
    int ich;

    switch (wOrd) {
        case 0:
            assert(szType != NULL && *szType != 0);
            rt = 0;
            for (ich = 0; ich < 4; ich++) {
                rt <<= 8;
                if (*szType)
                    rt |= (BYTE) (*szType++);
                else
                    rt |= ' ';
            }
            break;
        case RT_CURSOR:
            rt = 'CURS';
            break;
        case RT_BITMAP:
            rt = 'WBMP';
            break;
        case RT_ICON:
            rt = 'WICO';
            break;
        case RT_MENU:
            rt = 'WMNU';
            break;
        case RT_DIALOG:
            rt = 'WDLG';
            break;
        case RT_STRING:
            rt = 'STR#';
            break;
        case RT_ACCELERATOR:
            rt = 'WACC';
            break;
        case RT_RCDATA:
        case RT_DLGINIT:
            rt = 'HEXA';
            break;
        case RT_TOOLBAR:
            rt = 'TLBR';
            break;
        case RT_GROUP_CURSOR:
            rt = 'CURS';
            break;
        case RT_GROUP_ICON:
            rt = 'WGIC';
            break;
        case RT_VERSION:
            rt = 'WVER';
            break;
        case RT_FONTDIR:
        case RT_FONT:
        //case RT_ERRTABLE:
        //case RT_NAMETABLE:
        default: {
            static char rgchHex[] = "0123456789ABCDEF";
            char ch4 = rgchHex[wOrd & 0x0f];
            char ch3 = rgchHex[(wOrd >> 4) & 0x0f];
            char ch2 = rgchHex[(wOrd >> 8) & 0x0f];
            char ch1 = 'M' + ((wOrd >> 12) & 0x0f);
            rt = res_type(ch1,ch2,ch3,ch4);
            break;
        }
    }

    return rt;
}


/*  IdUnique
 *
 *  Searches through the items of the given type looking for
 *  an unused resource id.  Returns the smallest resource id
 *  that is not currently used.
 *
 *  This routine handles icon families in a particular annoying
 *  way, using a particularly inefficient algorithm.  But it
 *  does keep icon ids synchronized if they have the same name.
 *
 *  Entry:
 *      ptype - type to search
 *      pres - resource type needing the unique id
 *
 *  Exit:
 *      retunrs - a unique resource id
 */
int
IdUnique(
    TYPEINFO *ptype,
    RESINFO *pres
    )
{
    int id;
    RESINFO *presScan;
    TYPEINFO* ptypeIcon;

    assert(ptype->pres != 0);

    if (IsIcon(ptype)) {
        /* see if we've already found an id for an icon with the same name */

        assert(pres->name != NULL);
        for (ptypeIcon = pTypInfo; ptypeIcon != NULL; ptypeIcon = ptypeIcon->next) {
            if (!IsIcon(ptypeIcon))
                continue;
            for (presScan = ptypeIcon->pres; presScan != NULL; presScan = presScan->next) {
                if (presScan->name == NULL || presScan->nameord == 0)
                    continue;
                if (wcscmp(presScan->name, pres->name) == 0)
                    return presScan->nameord;
            }
        }

        /* rats, didn't find it, gotta find one that's unique in *all* the
           icon types */

        for (id = idBase; ; ) {
            for (ptypeIcon = pTypInfo; ptypeIcon != NULL; ptypeIcon = ptypeIcon->next) {
                if (!IsIcon(ptypeIcon))
                    continue;
                for (presScan = ptypeIcon->pres; presScan != NULL; presScan = presScan->next) {
                    if (presScan->nameord == id)
                        goto NextId;
                }
            }
            return id;
NextId:
            id = (id+1) & 0xffff;
            if (id == 0)
                id = 1;
        }
    } else {
        for (id = idBase; ; ) {
            for (presScan = ptype->pres; presScan->nameord != id; ) {
                presScan = presScan->next;
                if (presScan == 0)
                    return id;
            }
            id = (id+1) & 0xffff;
            if (id == 0)
                id = 1;
        }
    }
}

/*---------------------------------------------------------------------------*/
/*                                                                           */
/*      GetToolbar -                                                         */
/*                                                                           */
/*---------------------------------------------------------------------------*/

SHORT
GetToolbarValue(
    void
    )
{
    SHORT sVal;

    if (!GetFullExpression(&sVal, GFE_ZEROINIT | GFE_SHORT))
        ParseError1(2250); //"expected numerical toolbar constant"

    return(sVal);
}

void
GetButtonSize(
    PSHORT cx,
    PSHORT cy
    )
{
    *cx= GetToolbarValue();
    if (token.type == COMMA)
        GetToken(TOKEN_NOEXPRESSION);
    *cy= GetToolbarValue();
}

int
GetToolbar(
    PRESINFO pRes
    )
{
    SHORT cx, cy;
    BOOL    bItemRead = FALSE;

    WriteWord(0x0001);  // Version 1 of this resource.

    GetButtonSize(&cx, &cy);

    WriteWord(cx);
    WriteWord(cy);

    ItemCountLoc = CCount;        /* global marker for location of item cnt. */

    /* skip place for num of items */
    WriteWord(0);

    PreBeginParse(pRes, 2251);

    while (token.type != END) {
        switch (token.type) {
            case TKSEPARATOR:
                bItemRead = TRUE;
                GetToken(TOKEN_NOEXPRESSION);
                WriteWord(0);
                break;

            case TKBUTTON:
                bItemRead = TRUE;
                GetToken(TRUE);
                if (token.type != NUMLIT)
                    ParseError1(2250); //"expected numerical toolbar constant"

                WriteSymbolUse(&token.sym);

                WriteWord(GetToolbarValue());
                break;

            case EOFMARK:
                ParseError1(2252); //"END expected in toolbar"
                quit("\n");
                break;

            default:
                ParseError1(2253); //"unknown toolbar item type"
                GetToken(TOKEN_NOEXPRESSION);   // try to continue
                continue;
        }

        IncItemCount();
    }

    /* make sure we have a toolbar item */
    if (!bItemRead)
        ParseError1(2254); //"empty toolbars not allowed"

    if (fMacRsrcs)
        SwapItemCount();

    return (TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\rcdll\rctp.c ===
/****************************************************************************/
/*                                                                          */
/*  RCTP.C -                                                                */
/*                                                                          */
/*    Windows 3.0 Resource Compiler - Resource Parser                       */
/*                                                                          */
/*                                                                          */
/****************************************************************************/

#include "rc.h"


static BOOL fComma;

/* Dialog template format :

        dialogName DIALOGEX x, y, cx, cy [, helpID]
        [style ...]
        [exStyle ...]
        [FONT height, name [, [weight] [, [italic [, [charset]]]]]]
        [caption ...]
        [menu ...]
        [memFlags [pure] [discard n] [preload]]
        BEGIN
            [CONTROL "text", id, BUTTON | STATIC | EDIT | LISTBOX | SCROLLBAR | COMBOBOX | "class", style, x, y, cx, cy]
            [FONT height, name [, [weight] [, [italic]]]]
            [BEGIN
                data-element-1 [,
                data-element-2 [,
                ... ]]
            END]

            [LTEXT     "text", id, x, y, cx, cy]
            [RTEXT     "text", id, x, y, cx, cy]
            [CTEXT     "text", id, x, y, cx, cy]

            [AUTO3STATE         "text", id, x, y, cx, cy]
            [AUTOCHECKBOX       "text", id, x, y, cx, cy]
            [AUTORADIOBUTTON    "text", id, x, y, cx, cy]
            [CHECKBOX           "text", id, x, y, cx, cy]
            [PUSHBOX            "text", id, x, y, cx, cy]
            [PUSHBUTTON         "text", id, x, y, cx, cy]
            [RADIOBUTTON        "text", id, x, y, cx, cy]
            [STATE3             "text", id, x, y, cx, cy]
            [USERBUTTON         "text", id, x, y, cx, cy]

            [EDITTEXT   id, x, y, cx, cy]
            [BEDIT      id, x, y, cx, cy]
            [HEDIT      id, x, y, cx, cy]
            [IEDIT      id, x, y, cx, cy]
            ...
        END

        MenuName MENUEX
        BEGIN
            [MENUITEM "text" [, [id] [, [type] [, [state]]]]]
            [POPUP    "text" [, [id] [, [type] [, [state] [, [help id]]]]]
            BEGIN
                [MENUITEM "text" [, [id] [, [type] [, [state]]]]]
                ...
            END]
            ...
        END

    Menu template format

                MenuName MENU
                BEGIN
                        [MENUITEM "text", id [option, ...]]
                        [POPUP    "text" [, option, ...]
                                BEGIN
                                   [MENUITEM "text", id [option, ...]]
                                   ...
                                END ]
                                ...
                END
*/

/* Dialog template format :

          dialogname DIALOG  x, y, cx, cy
          [language ...]
          [style ...]
          [caption ...  ]
          [menu ... ]
          [memflags [pure] [discard n] [preload]]
          begin
                [CONTROL "text", id, BUTTON | STATIC | EDIT | LISTBOX | SCROLLBAR | COMBOBOX | "class", style, x, y, cx, cy]

                [LTEXT     "text", id, x, y, cx, cy]
                [RTEXT     "text", id, x, y, cx, cy]
                [CTEXT     "text", id, x, y, cx, cy]

                [CHECKBOX     "text", id, x, y, cx, cy]
                [PUSHBUTTON   "text", id, x, y, cx, cy]
                [RADIOBUTTON  "text", id, x, y, cx, cy]

                [EDITTEXT  id, x, y, cx, cy]
                ...
          end

   Menu template format

        MenuName MENU
        BEGIN
            [MENUITEM "text", id [option, ...]]
            [POPUP    "text" [, option, ...]
                BEGIN
                   [MENUITEM "text", id [option, ...]]
                   ...
                END ]
                ...
        END
*/


#define CTLSTYLE(s) (WS_CHILD | WS_VISIBLE | (s))

/* list of control id's to check for duplicates */
PDWORD  pid;
int     cidMac;
int     cidMax;

BOOL
CheckStr(
    PWCHAR pStr
    )
{
    if (token.type == STRLIT || token.type == LSTRLIT) {
        if (token.val > MAXTOKSTR-1) {
            SET_MSG(Msg_Text, sizeof(Msg_Text), GET_MSG(4208), curFile, token.row);
            SendError(Msg_Text);
            tokenbuf[MAXTOKSTR-1] = TEXT('\0');
            token.val = MAXTOKSTR-2;
        }
        memcpy(pStr, tokenbuf, (token.val+1)*sizeof(WCHAR));

        return(TRUE);
    }
    return(FALSE);
}


// ----------------------------------------------------------------------------
//
//  GetDlgValue
//
// ----------------------------------------------------------------------------

SHORT
GetDlgValue(
    void
    )
{
    SHORT sVal;

    if (!GetFullExpression(&sVal, GFE_ZEROINIT | GFE_SHORT))
        ParseError1(2109); //"Expected Numerical Dialog constant"

    return(sVal);
}

void
GetCoords(
    PSHORT x,
    PSHORT y,
    PSHORT cx,
    PSHORT cy
    )
{
    *x = GetDlgValue();
    if (token.type == COMMA)
        GetToken(TOKEN_NOEXPRESSION);
    *y = GetDlgValue();
    if (token.type == COMMA)
        GetToken(TOKEN_NOEXPRESSION);
    *cx= GetDlgValue();
    if (token.type == COMMA)
        GetToken(TOKEN_NOEXPRESSION);
    *cy= GetDlgValue();
}

typedef struct tagCTRLTYPE {
    WORD    type;
    DWORD   dwStyle;
    BYTE    bCode;
    BYTE    fHasText;
}   CTRLTYPE;

CTRLTYPE ctrlTypes[] = {
    { TKGROUPBOX,       BS_GROUPBOX,                    BUTTONCODE,     TRUE  },
    { TKPUSHBUTTON,     BS_PUSHBUTTON | WS_TABSTOP,     BUTTONCODE,     TRUE  },
    { TKDEFPUSHBUTTON,  BS_DEFPUSHBUTTON | WS_TABSTOP,  BUTTONCODE,     TRUE  },
    { TKCHECKBOX,       BS_CHECKBOX | WS_TABSTOP,       BUTTONCODE,     TRUE  },
    { TKRADIOBUTTON,    BS_RADIOBUTTON,                 BUTTONCODE,     TRUE  },
    { TKAUTO3,          BS_AUTO3STATE | WS_TABSTOP,     BUTTONCODE,     TRUE  },
    { TKAUTOCHECK,      BS_AUTOCHECKBOX | WS_TABSTOP,   BUTTONCODE,     TRUE  },
    { TKAUTORADIO,      BS_AUTORADIOBUTTON,             BUTTONCODE,     TRUE  },
    { TKPUSHBOX,        BS_PUSHBOX | WS_TABSTOP,        BUTTONCODE,     TRUE  },
    { TK3STATE,         BS_3STATE | WS_TABSTOP,         BUTTONCODE,     TRUE  },
    { TKUSERBUTTON,     BS_USERBUTTON | WS_TABSTOP,     BUTTONCODE,     TRUE  },
    { TKLTEXT,          ES_LEFT | WS_GROUP,             STATICCODE,     TRUE  },
    { TKRTEXT,          ES_RIGHT | WS_GROUP,            STATICCODE,     TRUE  },
    { TKCTEXT,          ES_CENTER | WS_GROUP,           STATICCODE,     TRUE  },
    { TKICON,           SS_ICON,                        STATICCODE,     TRUE  },
    { TKBEDIT,          ES_LEFT | WS_BORDER | WS_TABSTOP, 0,            FALSE },
    { TKHEDIT,          ES_LEFT | WS_BORDER | WS_TABSTOP, 0,            FALSE },
    { TKIEDIT,          ES_LEFT | WS_BORDER | WS_TABSTOP, 0,            FALSE },
    { TKEDITTEXT,       ES_LEFT | WS_BORDER | WS_TABSTOP, EDITCODE,     FALSE },
    { TKLISTBOX,        WS_BORDER | LBS_NOTIFY,         LISTBOXCODE,    FALSE },
    { TKCOMBOBOX,       0,                              COMBOBOXCODE,   FALSE },
    { TKSCROLLBAR,      0,                              SCROLLBARCODE,  FALSE }
};

#define C_CTRLTYPES (sizeof(ctrlTypes) / sizeof(CTRLTYPE))

// ----------------------------------------------------------------------------
//
//  GetDlgItems(fDlgEx) -
//
// ----------------------------------------------------------------------------

int
GetDlgItems(
    BOOL fDlgEx
    )
{
    CTRL ctrl;
    int i;

    cidMac = 0;
    cidMax = 100;
    pid = (PDWORD) MyAlloc(sizeof(DWORD)*cidMax);
    if (!pid)
        return FALSE;

    GetToken(TRUE);

    /* read all the controls in the dialog */

    ctrl.id = 0L;  // initialize the control's id to 0

    while (token.type != END) {
        ctrl.dwHelpID = 0L;
        ctrl.dwExStyle = 0L;
        ctrl.dwStyle = WS_CHILD | WS_VISIBLE;
        ctrl.text[0] = 0;
        ctrl.fOrdinalText = FALSE;

        if (token.type == TKCONTROL) {
            ParseCtl(&ctrl, fDlgEx);
        } else {
            for (i = 0; i < C_CTRLTYPES; i++)
                if (token.type == ctrlTypes[i].type)
                    break;

            if (i == C_CTRLTYPES) {
                ParseError1(2111); //"Invalid Control type : ", tokenbuf
                return(FALSE);
            }

            ctrl.dwStyle |= ctrlTypes[i].dwStyle;
            if (fMacRsrcs &&
                (token.type == TKPUSHBUTTON ||
                token.type == TKDEFPUSHBUTTON ||
                token.type == TKCHECKBOX ||
                token.type == TKAUTO3 ||
                token.type == TKAUTOCHECK ||
                token.type == TKPUSHBOX ||
                token.type == TK3STATE ||
                token.type == TKUSERBUTTON))
            {
                ctrl.dwStyle &= ~WS_TABSTOP;
            }
            if (ctrlTypes[i].bCode) {
                ctrl.Class[0] = 0xFFFF;
                ctrl.Class[1] = ctrlTypes[i].bCode;
            } else {
                CheckStr(ctrl.Class);
            }

            if (ctrlTypes[i].fHasText)
                GetCtlText(&ctrl);

            // find the ID and the coordinates
            GetCtlID(&ctrl, fDlgEx);
            GetCoords(&ctrl.x, &ctrl.y, &ctrl.cx, &ctrl.cy);

            // get optional style, exstyle, and helpid
            if (token.type == COMMA) {
                GetToken(TOKEN_NOEXPRESSION);
                GetFullExpression(&ctrl.dwStyle, 0);
            }
        }

        if (token.type == COMMA) {
            GetToken(TOKEN_NOEXPRESSION);
            GetFullExpression(&ctrl.dwExStyle, 0);

            if (fDlgEx && (token.type == COMMA)) {
                GetToken(TOKEN_NOEXPRESSION);
                GetFullExpression(&ctrl.dwHelpID, GFE_ZEROINIT);
            }
        }

        SetUpItem(&ctrl, fDlgEx); /* gen the code for it  */

        if (fDlgEx && (token.type == BEGIN)) {
            /* align any CreateParams are there */
            //WriteAlign(); not yet!!!

            // we're ok passing NULL in for pRes here because PreBeginParse
            // won't have to use pRes
            // Note that passing fDlgEx is actually redundant since it
            // will always be TRUE here, but we'll do it in case someone
            // else ever calls SetItemExtraCount
            SetItemExtraCount(GetRCData(NULL), fDlgEx);
            GetToken(TOKEN_NOEXPRESSION);
        }
    }
    MyFree(pid);
    return TRUE;
}

/*---------------------------------------------------------------------------*/
/*                                                                           */
/*  GetDlg() -                                                               */
/*                                                                           */
/*---------------------------------------------------------------------------*/

int
GetDlg(
    PRESINFO pRes,
    PDLGHDR pDlg,
    BOOL fDlgEx
    )
{
    /* initialize and defaults */
    pDlg->dwExStyle = pRes->exstyleT;
    pDlg->dwStyle = WS_POPUPWINDOW | WS_SYSMENU;
    pDlg->MenuName[0] = 0;
    pDlg->Title[0] = 0;
    pDlg->Class[0] = 0;
    pDlg->fOrdinalMenu = FALSE;
    pDlg->fClassOrdinal = FALSE;
    pDlg->pointsize = 0;

    // get x, y, cx, cy
    GetCoords(&pDlg->x, &pDlg->y, &pDlg->cx, &pDlg->cy);

    /* get optional parameters */
    if (!DLexOptionalArgs(pRes, pDlg, fDlgEx))
        return FALSE;

    if (pDlg->pointsize)
        pDlg->dwStyle |= DS_SETFONT;
    else
        pDlg->dwStyle &= ~DS_SETFONT;

    /* output header to the resource buffer */
    SetUpDlg(pDlg, fDlgEx);

    /* make sure we have a BEGIN */
    if (token.type != BEGIN)
        ParseError1(2112); //"BEGIN expected in Dialog"

    /* get the dialog items */
    GetDlgItems(fDlgEx);

    if (fMacRsrcs)
        SwapItemCount();

    /* make sure this ended on an END */
    if (token.type != END)
        ParseError1(2113); //"END expected in Dialog"

    return (TRUE);
}



typedef struct tagCTRLNAME {
    BYTE    bCode;
    WORD    wType;
    PWCHAR  pszName;
} CTRLNAME;

CTRLNAME    ctrlNames[] = {
    { BUTTONCODE,    TKBUTTON,    L"button"    },
    { EDITCODE,      TKEDIT,      L"edit"      },
    { STATICCODE,    TKSTATIC,    L"static"    },
    { LISTBOXCODE,   TKLISTBOX,   L"listbox"   },
    { SCROLLBARCODE, TKSCROLLBAR, L"scrollbar" },
    { COMBOBOXCODE,  TKCOMBOBOX,  L"combobox"  }
};

#define C_CTRLNAMES (sizeof(ctrlNames) / sizeof(CTRLNAME))

/*---------------------------------------------------------------------------*/
/*                                                                           */
/*      ParseCtl() -                                                         */
/*                                                                           */
/*---------------------------------------------------------------------------*/

// for a control of the form CTL

void
ParseCtl(
    PCTRL LocCtl,
    BOOL fDlgEx
    )
{   /* by now we've read the CTL */
    int i;

    /* get the control text and identifier */
    GetCtlText(LocCtl);
    GetCtlID(LocCtl, fDlgEx);

    if (token.type == NUMLIT) {
        LocCtl->Class[0] = (char) token.val;
        LocCtl->Class[1] = 0;
    } else if (token.type == LSTRLIT) {
        // We will now convert class name strings to short form magic
        // numbers. These magic numbers are order dependent as defined in
        // USER. This provides some space savings in resource files.
        for (i = C_CTRLNAMES; i; ) {
            if (!_wcsicmp(tokenbuf, ctrlNames[--i].pszName))
                goto Found1;
        }
        CheckStr(LocCtl->Class);
    } else {
        for (i = C_CTRLNAMES; i; ) {
            if (token.type == ctrlNames[--i].wType)
                goto Found1;
        }
        ParseError1(2114); //"Expected control class name"

Found1:
        LocCtl->Class[0] = 0xFFFF;
        LocCtl->Class[1] = ctrlNames[i].bCode;
    }

    /* get the style bits */
    GetTokenNoComma(TOKEN_NOEXPRESSION);
    GetFullExpression(&LocCtl->dwStyle, 0);

    /* get the coordinates of the control */
    ICGetTok();
    GetCoords(&LocCtl->x, &LocCtl->y, &LocCtl->cx, &LocCtl->cy);
}


/*---------------------------------------------------------------------------*/
/*                                                                           */
/*  GetCtlText() -                                                           */
/*                                                                           */
/*---------------------------------------------------------------------------*/

VOID
GetCtlText(
    PCTRL pLocCtl
    )
{
    GetTokenNoComma(TOKEN_NOEXPRESSION);
    if (CheckStr(pLocCtl->text)) {
        pLocCtl->fOrdinalText = FALSE;
        token.sym.name[0] = L'\0';
        token.sym.nID = 0;
    } else if (token.type == NUMLIT) {
        wcsitow(token.val, pLocCtl->text, 10);
        pLocCtl->fOrdinalText = TRUE;
        WriteSymbolUse(&token.sym);
    } else {
        ParseError1(2115); //"Text string or ordinal expected in Control"
    }
}


/*---------------------------------------------------------------------------*/
/*                                                                           */
/*  GetCtlID() -                                                             */
/*                                                                           */
/*---------------------------------------------------------------------------*/

VOID
GetCtlID(
    PCTRL pLocCtl,
    BOOL fDlgEx
    )
{
    WORD    wGFE = GFE_ZEROINIT;
    int i;

    ICGetTok();

    WriteSymbolUse(&token.sym);

    if (!fDlgEx)
        wGFE |= GFE_SHORT;

    if (GetFullExpression(&pLocCtl->id, wGFE)) {
        if (!fDlgEx && pLocCtl->id != (DWORD)(WORD)-1 ||
             fDlgEx && pLocCtl->id != (DWORD)-1) {
            for (i=0 ; i<cidMac ; i++) {
                if (pLocCtl->id == *(pid+i) && !fSkipDuplicateCtlIdWarning) {
                    i = (int)pLocCtl->id;
                    SET_MSG(Msg_Text, sizeof(Msg_Text), GET_MSG(2182),
                            curFile, token.row, i);
                    SendError(Msg_Text);
                    break;
                }
            }
            if (cidMac == cidMax) {
                PDWORD pidNew;

                cidMax += 100;
                pidNew = (PDWORD) MyAlloc(cidMax*sizeof(DWORD));
                memcpy(pidNew, pid, cidMac*sizeof(DWORD));
                MyFree(pid);
                pid = pidNew;
            }
            *(pid+cidMac++) = pLocCtl->id;
        }
    } else {
        ParseError1(2116); //"Expecting number for ID"
    }

    if (token.type == COMMA)
        ICGetTok();
}


// ----------------------------------------------------------------------------
//
//  DLexOptionArgs(pRes, fDlgEx) -
//
// ----------------------------------------------------------------------------
BOOL
DLexOptionalArgs(
    PRESINFO pRes,
    PDLGHDR pDlg,
    BOOL fDlgEx
    )
{
    /* read all the optional dialog items */

    if (fDlgEx && (token.type == COMMA)) {
        GetToken(TOKEN_NOEXPRESSION);
        GetFullExpression(&pDlg->dwHelpID, GFE_ZEROINIT);
    }

    while (token.type != BEGIN) {
        switch (token.type) {
            case TKLANGUAGE:
                pRes->language = GetLanguage();
                GetToken(FALSE);
                break;

            case TKVERSION:
                GetToken(FALSE);
                if (token.type != NUMLIT)
                    ParseError1(2139);
                pRes->version = token.longval;
                GetToken(FALSE);
                break;

            case TKCHARACTERISTICS:
                GetToken(FALSE);
                if (token.type != NUMLIT)
                    ParseError1(2140);
                pRes->characteristics = token.longval;
                GetToken(FALSE);
                break;

            case TKSTYLE:
                // If CAPTION statement preceded STYLE statement, then we
                // already must have WS_CAPTION bits set in the "style"
                // field and we must not lose it;

                if ((pDlg->dwStyle & WS_CAPTION) == WS_CAPTION)
                    pDlg->dwStyle = WS_CAPTION;
                else
                    pDlg->dwStyle = 0;

                GetTokenNoComma(TOKEN_NOEXPRESSION);
                GetFullExpression(&pDlg->dwStyle, 0);
                break;

            case TKEXSTYLE:
                GetTokenNoComma(TOKEN_NOEXPRESSION);
                GetFullExpression(&pDlg->dwExStyle, 0);
                break;

            case TKCAPTION:
                DGetTitle(pDlg);
                break;

            case TKMENU:
                DGetMenuName(pDlg);
                break;

            case TKCLASS:
                DGetClassName(pDlg);
                break;

            case TKFONT:
                DGetFont(pDlg, fDlgEx);
                break;

            default:
                ParseError1(2112); //"BEGIN expected in dialog");
                return FALSE;
        }
    }
    return TRUE;
}


/*---------------------------------------------------------------------------*/
/*                                                                           */
/*  DGetFont() -                                                             */
/*                                                                           */
/*---------------------------------------------------------------------------*/

void
DGetFont(
    PDLGHDR pDlg,
    BOOL fDlgEx
    )
{
    WORD w;
    int i;

    GetToken(TRUE);
    if (!GetFullExpression(&pDlg->pointsize, GFE_ZEROINIT | GFE_SHORT))
        ParseError1(2117); //"Expected numeric point size"

    if (token.type == COMMA)
        ICGetTok();

    if (!CheckStr(pDlg->Font))
        ParseError1(2118); //"Expected font face name"

    if (_wcsicmp(pDlg->Font, L"System") &&
        szSubstituteFontName[0] != UNICODE_NULL) {
        for (i=0; i<nBogusFontNames; i++) {
            if (!_wcsicmp(pszBogusFontNames[i], pDlg->Font)) {
                GenWarning4(4510, (PCHAR)pDlg->Font, (PCHAR)szSubstituteFontName, 0 ); // Warning for hard coded fonts
                wcscpy(pDlg->Font, szSubstituteFontName);
            }
        }
    }

    GetToken(TRUE);

    pDlg->bCharSet = DEFAULT_CHARSET;

    if (fDlgEx && (token.type == COMMA)) {
        GetToken(TOKEN_NOEXPRESSION);
        if (GetFullExpression(&w, GFE_ZEROINIT | GFE_SHORT))
            pDlg->wWeight = w;

        if (token.type == COMMA) {
            GetToken(TOKEN_NOEXPRESSION);
            if (token.type == NUMLIT) {
                pDlg->bItalic = (token.val) ? TRUE : FALSE;
                GetToken(TOKEN_NOEXPRESSION);

                if (token.type == COMMA) {
                    GetToken(TOKEN_NOEXPRESSION);
                    if (GetFullExpression(&w, GFE_ZEROINIT | GFE_SHORT))
                        pDlg->bCharSet = (UCHAR) w;
                }
            }
        }
    }
}

/*---------------------------------------------------------------------------*/
/*                                                                           */
/*  DGetMenuName() -                                                         */
/*                                                                           */
/*---------------------------------------------------------------------------*/

/*  gets the unquoted string of the name of the optional menu associated */
/*  with the dialog.  */

VOID
DGetMenuName(
    PDLGHDR pDlg
    )
{
    if (GetGenText()) {
        /* copy the menu name */
        token.type = LSTRLIT;
        CheckStr(pDlg->MenuName);

        /* check if menu name is an ordinal */
        if (wcsdigit(pDlg->MenuName[0]))
            pDlg->fOrdinalMenu = TRUE;
        GetToken(TRUE);
    }
}


/*---------------------------------------------------------------------------*/
/*                                                                           */
/*  DGetTitle() -                                                            */
/*                                                                           */
/*---------------------------------------------------------------------------*/

VOID
DGetTitle(
 PDLGHDR pDlg
 )
{
    GetToken(TRUE);

    if (CheckStr(pDlg->Title))
        pDlg->dwStyle |= WS_CAPTION;
    else
        ParseError1(2119); //"Expecting quoted string in dialog title"

    GetToken(TRUE);
}


/*---------------------------------------------------------------------------*/
/*                                                                           */
/*  DGetClassName() -                                                        */
/*                                                                           */
/*---------------------------------------------------------------------------*/

VOID
DGetClassName(
 PDLGHDR pDlg
 )
{
    GetToken(TRUE);
    if (!CheckStr(pDlg->Class)) {
        if (token.type == NUMLIT) {
            wcsitow(token.val, pDlg->Class, 10);
            pDlg->fClassOrdinal = TRUE;
        } else {
            ParseError1(2120); //"Expecting quoted string in dialog class"
        }
    }
    GetToken(TRUE);
}


/*---------------------------------------------------------------------------*/
/*      Gets a token, ignoring commas.  Returns the token type.              */
/*                                                                           */
/*  ICGetTok() -                                                             */
/*                                                                           */
/*---------------------------------------------------------------------------*/

/*  Get token, but ignore commas  */

USHORT
ICGetTok(
    VOID
    )
{
    fComma = FALSE; // NT added the use of this fComma flag
    GetToken(TRUE);
    while (token.type == COMMA) {
        GetToken(TRUE);
        fComma = TRUE; // and they set it here
    }
    return (USHORT)token.type;
}


/*  GetTokenNoComma
 *      This function replaces ICGetTok() but has a flag to support
 *      the turning off of expression parsing.
 */

USHORT
GetTokenNoComma(
    USHORT wFlags
    )
{
    /* Get a token */
    GetToken(TRUE | wFlags);

    /* Ignore any commas */
    while (token.type == COMMA)
        GetToken(TRUE | wFlags);

    return (USHORT)token.type;
}


/*************  Menu Parsing Routines *********************/


/*---------------------------------------------------------------------------*/
/*                                                                           */
/*  IsmnOption() -                                                           */
/*                                                                           */
/*---------------------------------------------------------------------------*/

int
IsmnOption(
    UINT arg,
    PMENUITEM pmn
    )
{
    /* if we have a valid flag, or it into the menu flags */
    switch (arg) {
        case TKOWNERDRAW:
            pmn->OptFlags |= OPOWNERDRAW;
            break;

        case TKCHECKED:
            pmn->OptFlags |= OPCHECKED;
            break;

        case TKGRAYED:
            pmn->OptFlags |= OPGRAYED;
            break;

        case TKINACTIVE:
            pmn->OptFlags |= OPINACTIVE;
            break;

        case TKBREAKWBAR:
            pmn->OptFlags |= OPBREAKWBAR;
            break;

        case TKBREAK:
            pmn->OptFlags |= OPBREAK;
            break;

        case TKHELP:
            pmn->OptFlags |= OPHELP;
            break;

        case TKBITMAP:
            pmn->OptFlags |= OPBITMAP;
            break;

        default:
            return(FALSE);
    }
    return(TRUE);

#if 0
    if ((arg == OPBREAKWBAR)       || (arg == OPHELP   ) || (arg == OPGRAYED) ||
        (arg == OPUSECHECKBITMAPS) || (arg == OPCHECKED) || (arg == OPBITMAP) ||
        (arg == OPOWNERDRAW)       || (arg == OPBREAK  ) || (arg == OPINACTIVE))
    {
        pmn->OptFlags |= arg;
        return TRUE;
    }
#if 0
    if (arg == OPHELP) {
        pmn->OptFlags |= OPPOPHELP;
        return TRUE;
    }
#endif
    return FALSE;
#endif
}



// ----------------------------------------------------------------------------
//
//  DoOldMenuItem() -
//
// ----------------------------------------------------------------------------

WORD
DoOldMenuItem(
    int fPopup
    )
{
    MENUITEM mnTemp;

    mnTemp.PopFlag  = (UCHAR)fPopup;
    GetToken(TRUE);

    /* menu choice string */
    if (CheckStr(mnTemp.szText)) {
        mnTemp.OptFlags = OPPOPUP;
        ICGetTok();
        if (!fPopup) {
            /* change the flag and get the ID if not a popup */
            mnTemp.OptFlags = 0;

            WriteSymbolUse(&token.sym);
            if (!GetFullExpression(&mnTemp.id, GFE_ZEROINIT | GFE_SHORT))
                ParseError1(2125); //"Expected ID value for Menuitem"

            if (token.type == COMMA)
                GetToken(TOKEN_NOEXPRESSION);
        }

        /* read the menu option flags */
        while (IsmnOption(token.type, &mnTemp))
            ICGetTok();
    } else if (token.type == TKSEPARATOR) {
        mnTemp.szText[0] = 0;       // MENUITEM SEPARATOR
        mnTemp.id = 0;
        mnTemp.OptFlags = 0;
        ICGetTok();
    } else {
        ParseError1(2126); //"Expected Menu String"
    }

    /* set it up in the buffer (?) */
    return(SetUpOldMenu(&mnTemp));
}


/*---------------------------------------------------------------------------*/
/*                                                                           */
/*  ParseOldMenu() -                                                         */
/*                                                                           */
/*---------------------------------------------------------------------------*/

int
ParseOldMenu(
    int fRecursing,
    PRESINFO pRes           // 8 char proc name limitation!
    )
{
    BOOL    bItemRead = FALSE;
    WORD    wEndFlagLoc = 0;

    if (!fRecursing) {
        PreBeginParse(pRes, 2121);
    } else {
        /* make sure its really a menu */
        if (token.type != BEGIN)
            ParseError1(2121); //"BEGIN expected in menu"
        GetToken(TRUE);
    }

    /* get the individual menu items */
    while (token.type != END) {
        switch (token.type) {
            case TKMENUITEM:
                bItemRead = TRUE;
                wEndFlagLoc = DoOldMenuItem(FALSE);
                break;

            case TKPOPUP:
                bItemRead = TRUE;
                wEndFlagLoc = DoOldMenuItem(TRUE);
                ParseOldMenu(TRUE, pRes);
                break;

            default:
                ParseError1(2122); //"Unknown Menu SubType :"
                break;
        }
    }

    /* did we die on an END? */
    if (token.type != END)
        ParseError1(2123); //"END expected in menu"

    /* make sure we have a menu item */
    if (!bItemRead)
        ParseError1(2124); //"Empty menus not allowed"

    /* Get next token if this was NOT the last END*/
    if (fRecursing)
        GetToken(TRUE);

    /* mark the last item in the menu */
    FixOldMenuPatch(wEndFlagLoc);

    return (TRUE);
}


/* ----- Version resource stuff ----- */

/*  VersionParse
 *      Parses the VERSION resource and places it in the global buffer
 *      so it can be written out by SaveResFile().
 */

int
VersionParse(
    VOID
    )
{
    int Index;

    /* Get the fixed structure entries */
    /* Note that VersionParseFixed doesn't actually fail! */
    /* This is because VersionBlockStruct doesn't fail. */
    Index = VersionParseFixed();

    /* Put the following blocks in as sub-blocks.  Fix up the length when
     *  we're done.
     */
    SetItemCount(Index, (USHORT)(GetItemCount(Index) + VersionParseBlock()));

    /* The return data buffer is global */
    return TRUE;
}


/*  VersionParseFixed
 *      Parses the fixed portion of the version resource.  Returns a pointer
 *      to the length word of the block.  This word has the length of
 *      the fixed portion precomputed and remains to have the variable
 *      portion added in.
 */

int
VersionParseFixed(
    VOID
    )
{
    VS_FIXEDFILEINFO FixedInfo;

    /* Initialize the structure fields */
    memset((PCHAR)&FixedInfo, 0, sizeof(FixedInfo));
    FixedInfo.dwSignature = 0xfeef04bdL;
    FixedInfo.dwStrucVersion = 0x00010000L;
    FixedInfo.dwFileDateMS = 0L;
    FixedInfo.dwFileDateLS = 0L;

    /* Loop through tokens until we get the "BEGIN" token which
     *  must be present to terminate the fixed portion of the VERSIONINFO
     *  resource.
     */
    while (token.type != BEGIN) {
        switch (token.type) {
            /* The following have four WORDS scrambled into two DWORDS */
            case TKFILEVERSION:
                VersionGet4Words(&FixedInfo.dwFileVersionMS);
                break;

            case TKPRODUCTVERSION:
                VersionGet4Words(&FixedInfo.dwProductVersionMS);
                break;

                /* The following have just one DWORD */
            case TKFILEFLAGSMASK:
                VersionGetDWord(&FixedInfo.dwFileFlagsMask);
                break;

            case TKFILEFLAGS:
                VersionGetDWord(&FixedInfo.dwFileFlags);
                break;

            case TKFILEOS:
                VersionGetDWord(&FixedInfo.dwFileOS);
                break;

            case TKFILETYPE:
                VersionGetDWord(&FixedInfo.dwFileType);
                break;

            case TKFILESUBTYPE:
                VersionGetDWord(&FixedInfo.dwFileSubtype);
                break;

                /* Other tokens are unknown */
            default:
                ParseError1(2167); //"Unrecognized VERSIONINFO field;"
        }
    }

    /* Write the block out and return the pointer to the length */
    return VersionBlockStruct(L"VS_VERSION_INFO", (PCHAR)&FixedInfo,
        sizeof(FixedInfo));
}


/*  VersionGet4Words
 *      Reads a version number from the source file and scrambles them
 *      to fit in two DWORDs.  We force them to put commas in here so
 *      that if they don't put in enough values we can fill in zeros.
 */

VOID
VersionGet4Words(
    ULONG *pdw
    )
{
    //    static CHAR szParseError[] = "Version WORDs separated by commas expected";

    /* Get the first number */
    GetToken(TRUE);
    if (token.type != NUMLIT || token.flongval)
        ParseError1(2127); //szParseError
    *pdw = ((LONG)token.val) << 16;

    /* Get the comma.  If none, we're done, so fill the rest with zeros */
    GetToken(TRUE);
    if (token.type != COMMA) {
        *++pdw = 0L;
        return;
    }

    /* Get the second number */
    GetToken(TRUE);
    if (token.type != NUMLIT || token.flongval)
        ParseError1(2127); //szParseError
    *(PUSHORT)pdw = token.val;

    /* Get the comma.  If none, we're done, so fill the rest with zeros */
    GetToken(TRUE);
    if (token.type != COMMA) {
        *++pdw = 0L;
        return;
    }

    /* Get the third number */
    GetToken(TRUE);
    if (token.type != NUMLIT || token.flongval)
        ParseError1(2127); //szParseError
    *++pdw = ((LONG)token.val) << 16;

    /* Get the comma.  If none, we're done */
    GetToken(TRUE);
    if (token.type != COMMA)
        return;

    /* Get the fourth number */
    GetToken(TRUE);
    if (token.type != NUMLIT || token.flongval)
        ParseError1(2127); //szParseError
    *(PUSHORT)pdw = token.val;

    /* Get the next token for the loop */
    GetToken(TRUE);
}


/*  VersionGetDWord
 *      Reads a single DWORD from the source file into the given variable.
 */

VOID
VersionGetDWord(
    ULONG *pdw
    )
{
    /* Get the token */
    GetToken(TRUE);
    if (token.type != NUMLIT)
        ParseError1(2128); //"DWORD expected"
    *pdw = token.longval;

    /* Get the next token for the loop */
    GetToken(TRUE);
}


/*  VersionParseBlock
 *      Parses a block of version information.  Note that this block may
 *      contain one or more additional blocks, causing this function to
 *      be called recursively.  Returns the length of the block which can
 *      be added to the length of the current block.  Returns 0xffff on error.
 */

USHORT
VersionParseBlock(
    VOID
    )
{
    USHORT      wLen;
    int         IndexLen;
    USHORT      wType;

    /* Get the current position in the buffer */
    wLen = GetBufferLen();

    /* The token has already been read.  This should be a BEGIN */
    if (token.type != BEGIN)
        ParseError1(2129); //"BEGIN expected in VERSIONINFO resource"

    /* Get the first token.  From here on, the VersionBlockVariable()
     *  routine gets the tokens as it searches for the end of the value
     *  field.
     */
    GetToken(TRUE);

    /* Loop until we get to the END for this BEGIN */
    for (; ; ) {
        /* Get and decode the next line type */
        switch (token.type) {
            case TKVALUE:
            case TKBLOCK:
                /* Save the type of this token */
                wType = token.type;

                /* Get the key string */
                GetToken(TRUE);
                if (token.type != LSTRLIT)
                    ParseError1(2131); //"Expecting quoted string for key"

                /* Now feed in the key string and value items */
                IndexLen = VersionBlockVariable(tokenbuf);

                /* A "BLOCK" item causes recursion.  Current token should be
                 *  "BEGIN"
                 */
                if (wType == TKBLOCK) {
                    SetItemCount(IndexLen, (USHORT)(GetItemCount(IndexLen) + VersionParseBlock()));
                    GetToken(TRUE);
                }
                break;

            case END:
                /* We're done with this block.  Get the next token
                 *  (read past the "END") and return the length of the block.
                 */
                return GetBufferLen() - wLen;

            default:
                ParseError1(2132); //"Expected VALUE, BLOCK, or, END keyword."
        }
    }
}


#define DWORDALIGN(w) \
    (((w) + (sizeof(ULONG) - 1)) & ~(USHORT)(sizeof(ULONG) - 1))

/*  VersionBlockStruct
 *      Writes a version block without sub-blocks.  Sub-blocks are to
 *      be written directly after this header.  To facilitate this,
 *      a pointer to the block length is returned so that it can be modified.
 *      This call uses a pre-parsed value item.  Use VersionBlockVariable()
 *      to parse the value items instead.
 *      Note that this actually can't fail!
 */

int
VersionBlockStruct(
    PWCHAR pstrKey,
    PCHAR pstrValue,
    USHORT wLenValue
    )
{
    USHORT wLen;
    int Index;
    ULONG dwPadding = 0L;
    USHORT wAlign;

    /* Pad the block data to DWORD align */
    wAlign = DWORDALIGN(GetBufferLen()) - GetBufferLen();
    if (wAlign)
        WriteBuffer((PCHAR)&dwPadding, wAlign);

    /* Save the current length so we can compute the new block length later */
    wLen = GetBufferLen();

    /* Write a zero for the length for now */
    Index = GetBufferLen();
    WriteWord(0);

    /* Write the length of the value field */
    WriteWord(wLenValue);

    /* data is binary */
    WriteWord(0);

    /* Write the key string now */
    WriteString(pstrKey, TRUE);

    /* Write the value data if there is any */
    if (wLenValue) {
        /* Now we have to DWORD align the value data */
        wAlign = DWORDALIGN(GetBufferLen()) - GetBufferLen();
        if (wAlign)
            WriteBuffer((PSTR)&dwPadding, wAlign);

        /* Write it to the buffer */
        WriteBuffer((PSTR)pstrValue, wLenValue);
    }

    /* Now fix up the block length and return a pointer to it */
    SetItemCount(Index, (USHORT)(GetBufferLen() - wLen));

    return Index;
}



/*  VersionBlockVariable
 *      Writes a version block without sub-blocks.  Sub-blocks are to
 *      bre written directly after this header.  To facilitate this,
 *      a pointer to the block length is returned so that it can be modified.
 *      VersionBlockVariable() gets the value items by parsing the
 *      RC script as RCDATA.
 */

int
VersionBlockVariable(
    PWCHAR pstrKey
    )
{
    USHORT wLen;
    int IndexLen;
    int IndexType;
    int IndexValueLen;
    ULONG dwPadding = 0L;
    USHORT wAlign;

    /* Pad the block data to DWORD align */
    wAlign = DWORDALIGN(GetBufferLen()) - GetBufferLen();
    if (wAlign)
        WriteBuffer((PCHAR)&dwPadding, wAlign);

    /* Save the current length so we can compute the new block length later */
    wLen = GetBufferLen();

    /* Write a zero for the length for now */
    IndexLen = GetBufferLen();
    WriteWord(0);

    /* Write the length of the value field.  We fill this in later */
    IndexValueLen = GetBufferLen();
    WriteWord(0);

    /* Assume string data */
    IndexType = GetBufferLen();
    WriteWord(1);

    /* Write the key string now */
    WriteString(pstrKey, TRUE);

    /* Parse and write the value data if there is any */
    SetItemCount(IndexValueLen, VersionParseValue(IndexType));

    /* Now fix up the block length and return a pointer to it */
    SetItemCount(IndexLen, (USHORT)(GetBufferLen() - wLen));

    return IndexLen;
}



/*  VersionParseValue
 *      Parses the fields following either BLOCK or VALUE and following
 *      their key string which is parsed by VersionParseBlock().
 *      Before writing the first value item out, the field has to be
 *      DWORD aligned.  Returns the length of the value block.
 */

USHORT
VersionParseValue(
    int IndexType
    )
{
    USHORT wFirst = FALSE;
    USHORT wToken;
    USHORT wAlign;
    ULONG dwPadding = 0L;
    USHORT wLen = 0;

    /* Decode all tokens until we get to the end of this item */
    for (; ; ) {
        /* ICGetTok is GetToken(TRUE) ignoring commas */
        wToken =  ICGetTok();

        /* If this is the first item, DWORD align it.  Since empty value
         *  sections are legal, we have to wait until we actually have data
         *  to do this.
         */
        if (!wFirst) {
            wFirst = TRUE;
            wAlign = DWORDALIGN(GetBufferLen()) - GetBufferLen();
            if (wAlign)
                WriteBuffer((PCHAR)&dwPadding, wAlign);
        }

        switch (wToken) {
            case TKVALUE:
            case TKBLOCK:
            case BEGIN:
            case END:
                return wLen;

            case LSTRLIT:                   /* String, write characters */
                if (tokenbuf[0] == L'\0')   /* ignore null strings */
                    break;

                /* remove extra nuls */
                while (tokenbuf[token.val-1] == L'\0')
                    token.val--;

                wAlign = token.val + 1;     /* want the character count */
                wLen += wAlign;
                if (fComma) {
                    WriteString(tokenbuf, TRUE);
                } else {
                    AppendString(tokenbuf, TRUE);
                    wLen--;
                }
                break;

            case NUMLIT:            /* Write the computed number out */
                SetItemCount(IndexType, 0);        /* mark data binary */
                if (token.flongval) {
                    WriteLong(token.longval);
                    wLen += sizeof(LONG);
                } else {
                    WriteWord(token.val);
                    wLen += sizeof(WORD);
                }
                break;

            default:
                ParseError1(2133); //"Unexpected value in value data"
                return 0;
        }
    }
}


VOID
DlgIncludeParse(
    PRESINFO pRes
    )
{
    INT     i;
    INT     nbytes;
    char *  lpbuf;

    if (token.type != LSTRLIT) {
        ParseError1(2165);
        return;
    }

    // the DLGINCLUDE statement must be written in ANSI (8-bit) for compatibility
    //    WriteString(tokenbuf);
    nbytes = WideCharToMultiByte (CP_ACP, 0, tokenbuf, -1, NULL, 0, NULL, NULL);
    lpbuf = (char *) MyAlloc (nbytes);
    WideCharToMultiByte (CP_ACP, 0, tokenbuf, -1, lpbuf, nbytes, NULL, NULL);

    for (i = 0; i < nbytes; i++)
         WriteByte (lpbuf[i]);

    MyFree(lpbuf);
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\rcdll\rcstring.c ===
/****************************************************************************/
/*                                                                          */
/*  RCSTRING.C -                                                            */
/*                                                                          */
/*      StringTable and Accelerators Parsing Code                           */
/*                                                                          */
/****************************************************************************/

#include "rc.h"

PRESINFO pResString = NULL;      /* Used to add a stringtable     */
/* at the end of processing if a stringtable */
/* was found.                                */

static PRCSTRING pSTHeader;
/* Ptr to the start of the parsed STRINGTABLE. */


/*--------------------------------------------------------------------------*/
/*                                                                          */
/*  MyFAlloc() -                                                            */
/*                                                                          */
/*--------------------------------------------------------------------------*/

PCHAR
MyFAlloc(
    UINT cb,
    PCHAR pb
    )
{
    PCHAR pbT;

    pbT = (PCHAR)MyAlloc(cb);
    if (!pbT)
        quit("RC : fatal error RW1025: Out of heap memory");
    if (pb) {
        memmove(pbT, pb, cb);
    } else {
        memset(pbT, 0, cb);
    }
    return pbT;
}


/*--------------------------------------------------------------------------*/
/*                                                                          */
/*  GetTable() -                                                            */
/*                                                                          */
/*--------------------------------------------------------------------------*/

PRESINFO
GetTable(
    PRESINFO pResTemp
    )
{
    PRCSTRING  pCurrent;
    PRCSTRING  pTrailer;
    CHAR       bDone = FALSE;
    USHORT     nStringID;
    PWCHAR     p;
    PSYMINFO   pCurrentSymbol;

    DWORD  TmpSize;
    PCHAR  TmpBuf;
    int    TmpRow;

    PreBeginParse(pResTemp, 2105);

    /* Does a string table already exist? */
    if (pResString == NULL) {
        /* No, start at the beginning - otherwise append. */
        pTrailer = (PRCSTRING)NULL;
        pSTHeader = (PRCSTRING)NULL;
    }

    do {
        pCurrent = pSTHeader;
        bDone = FALSE;
        if (token.type != NUMLIT)
            ParseError1(2149); //"Expected numeric constant in string table "

        nStringID = token.val;

        pCurrentSymbol = (SYMINFO*)MyFAlloc(sizeof(token.sym), (char*)&token.sym);

        if (!GetFullExpression(&nStringID, GFE_ZEROINIT | GFE_SHORT))
            ParseError1(2110); //"Expected numeric constant in v table "

        if (token.type == COMMA)
            GetToken(TOKEN_NOEXPRESSION);

        if (token.type != LSTRLIT)
            ParseError1(2150);

        tokenbuf[token.val + 1] = 0;

        TmpSize = sizeof(WCHAR) * (token.val + 2);
        TmpBuf = MyFAlloc(TmpSize, (PCHAR)tokenbuf);
        TmpRow = token.row;
        GetToken(TRUE);

//        printf("TmpSize: %d\tTmpBuf: %ws\tTmpRow: %d\n", TmpSize, TmpBuf, TmpRow);

        while ((token.row == TmpRow) && (token.type == LSTRLIT)) {
            ULONG NewSize = TmpSize + (sizeof(WCHAR) * (token.val));
            PCHAR NewBuf = (PCHAR)MyAlloc(NewSize);
            if (!NewBuf)
                quit("RC : fatal error RW1025: Out of heap memory");

            memmove(NewBuf, TmpBuf, TmpSize);
            memmove(NewBuf+TmpSize-4, tokenbuf, (token.val * sizeof(WCHAR)));

//            printf("NewSize: %d\tNewBuf: %ws\ttoken.row: %d\ttokenbuf: %ws\n", NewSize, NewBuf, token.row, tokenbuf);

            MyFree(TmpBuf);
            TmpSize = NewSize;
            TmpBuf = NewBuf;
            GetToken(TRUE);
        }

        while (!bDone && pCurrent) {
            if (pCurrent->language == pResTemp->language) {
                if (pCurrent->hibits == (USHORT)(nStringID / BLOCKSIZE)) {
                    bDone = TRUE;
                    if (!(pCurrent->rgsz[nStringID % BLOCKSIZE])) {
                        pCurrent->rgsz[nStringID % BLOCKSIZE] = (PWCHAR) TmpBuf;
                        pCurrent->rgsym[nStringID % BLOCKSIZE] = pCurrentSymbol;
                    }
                    else {
                        SET_MSG(Msg_Text, sizeof(Msg_Text),
                                GET_MSG(2151),
                                curFile,
                                TmpRow,
                                nStringID,
                                pCurrent->rgsz[nStringID % BLOCKSIZE],
                                TmpBuf
                                );

                        ParseError3(2151);
                        MyFree(TmpBuf);
                    }

                    TmpBuf = NULL; TmpSize = 0;
                }
            }
            pTrailer = pCurrent;
            pCurrent = pCurrent->next;
        }

        if (!bDone) {       /* and thus pCurrent == (PCHAR)NULL */
            pCurrent = (PRCSTRING)MyFAlloc(
                        sizeof(RCSTRING), (PCHAR)NULL);
            pCurrent->hibits = (short)(nStringID / BLOCKSIZE);
            pCurrent->flags  = pResTemp->flags;
            pCurrent->language = pResTemp->language;
            pCurrent->version = pResTemp->version;
            pCurrent->characteristics = pResTemp->characteristics;

            p = pCurrent->rgsz[nStringID%BLOCKSIZE] = (PWCHAR)TmpBuf;
            TmpBuf = NULL; TmpSize = 0;

            pCurrent->rgsym[nStringID%BLOCKSIZE] = pCurrentSymbol;

            if (pTrailer)
                pTrailer->next = pCurrent;

            if (!pSTHeader)
                pSTHeader = pCurrent;           /* First time only */
        }

//        GetToken(TRUE);
    } while (token.type != END);

    pResString = pResTemp;

    return pResString;
}


/*--------------------------------------------------------------------------*/
/*                                                                          */
/*  WriteTable() -                                                          */
/*                                                                          */
/*--------------------------------------------------------------------------*/

VOID
WriteTable(
    PRESINFO pResOld
    )
{
    PRCSTRING   p;
    int         i;
    PRESINFO    pRes;
    PTYPEINFO   pType;
    int         n;
    PWCHAR      s;
    UINT        nBytesWritten;
    SYMINFO     symInfo;

    /* Start at the start of the proper table. */
    p = pSTHeader;

    while (p) {
        nBytesWritten = 0;

        CtlInit();

        // 'STR#' resource starts with a count of strings
        if (fMacRsrcs)
            WriteWord(BLOCKSIZE);

        /* Write out the next block. */
        for (i = 0; i < BLOCKSIZE; i++) {
            n = 0;
            s = p->rgsz[i];

            if (fMacRsrcs) {
                WriteMacString(s, TRUE, TRUE);
                continue;
            }

            if (s) {
                while (s[n] || s[n + 1])
                    n++; // szsz terminated

                if (fAppendNull)
                    n++;
            }

            nBytesWritten += sizeof(WCHAR) * (n + 1);

            WriteWord((WORD)n);
            while (n--)
                WriteWord(*s++);
        }

        pRes = (RESINFO * )MyAlloc(sizeof(RESINFO));
        pRes->language = p->language;
        pRes->version = p->version;
        pRes->characteristics = p->characteristics;

        pType = AddResType(NULL, RT_STRING);

        pRes->size = nBytesWritten;

        /* Mark the resource as Moveable and Discardable. */
        pRes->flags = p->flags;

        /*We're in an origin 1 world here*/
        pRes->nameord = (short)(p->hibits + 1);
        SaveResFile(pType, pRes);

        memset(&symInfo, 0, sizeof(symInfo));
        WriteResInfo(pRes, pType, FALSE);
        for (i=0; i < BLOCKSIZE; i++) {
            WriteSymbolUse(p->rgsym[i] != NULL  && p->rgsz[i][0] != '\0' ? p->rgsym[i] : &symInfo);
        }
        WriteResInfo(NULL, NULL, FALSE);

        /* Move on to the next block. */
        p = p->next;
    }
}


/*--------------------------------------------------------------------------*/
/*                                                                          */
/*  GetAccelerators() _                                                     */
/*                                                                          */
/*--------------------------------------------------------------------------*/

int
GetAccelerators(
    PRESINFO pRes
    )
{
    int count = 0;
    int ntype;
    WCHAR                 c;
    int bTypeSpecified;
    RCACCEL Accel;

    PreBeginParse(pRes, 2106);

    do {
        if (token.type == END)
            continue;
        bTypeSpecified = FALSE;
        ntype = token.type;
        if (token.type == END) {
            MarkAccelFlagsByte();
            WriteWord(0);
            WriteWord(0);
            WriteWord(0);
            WriteWord(0);
            count++;
            continue;
        }
        else if (token.type == NUMLIT)
            Accel.ascii = token.val;
        else if (token.type == LSTRLIT) {
            if (tokenbuf[0] == L'^') {
                if (wcslen(tokenbuf) != 2)
                    ParseError1(2152);
                /* GetAccelerators() and support "^^" to put ^ */
                if (tokenbuf[1] == L'^')
                    Accel.ascii = L'^';
                else {
                    if (!iswalpha(c=towupper(tokenbuf[1])))
                        ParseError1(2154);

                    Accel.ascii = c - L'A' + 1;
                }
            }
            else if (wcslen(tokenbuf) == 2)
                Accel.ascii = (WCHAR)((tokenbuf[0] << 8) + tokenbuf[1]);
            else if (wcslen(tokenbuf) == 1)
                Accel.ascii = tokenbuf[0];
            else
                ParseError1(2155);
        }
        else
            ParseError1(2156);

        /* Get the trailing comma. */
        GetToken(TRUE);
        if (token.type != COMMA)
            ParseError1(2157);

        /* Get the next number. */
        GetToken(TRUE);
        if (token.type != NUMLIT)
            ParseError1(2107);

        Accel.id = token.val;

        WriteSymbolUse(&token.sym);

        if (!GetFullExpression(&Accel.id, GFE_ZEROINIT | GFE_SHORT))
            ParseError1(2107); //"Expected numeric command value"

        Accel.flags = 0;

        if (token.type == COMMA)
            do {
                GetToken(TRUE);
                switch (token.type) {
                    case TKVIRTKEY:
                        Accel.flags |= fVIRTKEY;
                        bTypeSpecified = TRUE;
                        break;
                    case TKASCII:
                        bTypeSpecified = TRUE;
                        break;  /* don't set the flag */
                    case TKNOINVERT:
                        Accel.flags |= fNOINVERT;
                        break;
                    case TKSHIFT:
                        Accel.flags |= fSHIFT;
                        break;
                    case TKCONTROL:
                        Accel.flags |= fCONTROL;
                        break;
                    case TKALT:
                        Accel.flags |= fALT;
                        break;
                    default:
                        ParseError1(2159);
                }
                GetToken(TRUE);
            } while (token.type == COMMA);

        if (ntype == NUMLIT && !bTypeSpecified)
            ParseError1(2163);

        if (!(Accel.flags & fVIRTKEY) && (Accel.flags & (fSHIFT | fCONTROL))) {
            SET_MSG(Msg_Text, sizeof(Msg_Text), GET_MSG(4203), curFile, token.row);
            SendError(Msg_Text);
        }

        if (Accel.flags & fVIRTKEY && ntype == LSTRLIT) {
            if (!iswalnum(Accel.ascii = (WCHAR)towupper(Accel.ascii))) {
                SET_MSG(Msg_Text, sizeof(Msg_Text), GET_MSG(4204), curFile, token.row);
                SendError(Msg_Text);
            }
        }

        MarkAccelFlagsByte();
        WriteWord(Accel.flags);
        WriteWord(Accel.ascii);
        if (fMacRsrcs) {
            WriteLong(Accel.id);
        } else {
            WriteWord(Accel.id);
            WriteWord(0);
        }

        count++;

    } while (token.type != END);

    PatchAccelEnd();

    return(5 * count);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\rcdll\rcunicod.c ===
/*++

Copyright (c) 1991 Microsoft Corporation

Module Name:

    rcunicod.c

Abstract:

    Routines added to rcpp to support 16-bit unicode file parsing.
        Note that as of Aug 91, rcpp will not fully transfer the unicode
        characters but only the string constants are guaranteed to be passed
        cleanly.

Author:

    David J. Marsyla (t-davema) 25-Aug-1991

Revision History:


--*/


#include "rc.h"

extern BOOL WINAPI LocalIsTextUnicode(CONST LPVOID Buffer, int Size, LPINT Result);

INT
DetermineFileType (
    IN      PFILE        fpInputFile
    )

/*++

Routine Description:

    This function is used to determine what type of file is being read.
        Note, the file is returned to it's proper position after function.

Arguments:

    fpInputFile                 - File pointer to file we are checking, must be
                                                  open with read permissions.

Return Value:

        DFT_FILE_IS_UNKNOWN     - It was impossible to determine what type of file
                                                          we were checking.  This usually happens when EOF
                                                          is unexpectedly reached.
        DFT_FILE_IS_8_BIT       - File was determined to be in standard 8-bit
                                                          format.
        DFT_FILE_IS_16_BIT      - File was determined to be a 16 bit unicode file
                                                          which can be directly read into a WCHAR array.
        DFT_FILE_IS_16_BIT_REV  - File was determined to be a 16 bit unicode file
                                                          which has it's bytes reversed in order.

--*/

{
   LONG   lStartFilePos;                     // Storage for file position.
   BYTE   buf[DFT_TEST_SIZE+2];
   LONG   chRead;
   INT    val = 0xFFFF;
   INT    fFileType;

    //
    // Store position so we can get back to it.
    //
    lStartFilePos = ftell (fpInputFile);

    //
    // Make sure we start on an even byte to simplify routines.
    //
    if (lStartFilePos % 2)
        fgetc (fpInputFile);

    chRead = fread (buf, 1, DFT_TEST_SIZE, fpInputFile);
    memset (buf + chRead, 0, sizeof(WCHAR));

    if (LocalIsTextUnicode (buf, chRead, &val))
    {
        if ((val & IS_TEXT_UNICODE_REVERSE_SIGNATURE) == IS_TEXT_UNICODE_REVERSE_SIGNATURE)
            fFileType = DFT_FILE_IS_16_BIT_REV;
        else
            fFileType = DFT_FILE_IS_16_BIT;
    }
    else
        fFileType = DFT_FILE_IS_8_BIT;

    //
    // Return to starting file position.  (usually beginning)
    //

    fseek (fpInputFile, lStartFilePos, SEEK_SET);

    return (fFileType);
}


INT
DetermineSysEndianType (
        VOID
    )

/*++

Routine Description:

    This function is used to determine how the current system stores its
        integers in memory.

    For those of us who are confused by little endian and big endian formats,
        here is a brief recap.

    Little Endian:  (This is used on Intel 80x86 chips.  The MIPS RS4000 chip
                 is switchable, but will run in little endian format for NT.)
       This is where the high order bytes of a short or long are stored higher
       in memory.  For example the number 0x80402010 is stored as follows.
         Address:        Value:
             00            10
             01            20
             02            40
             03            80
       This looks backwards when memory is dumped in order: 10 20 40 80

    Big Endian:  (This is not currently used on any NT systems but hey, this
         is supposed to be portable!!)
       This is where the high order bytes of a short or long are stored lower
       in memory.  For example the number 0x80402010 is stored as follows.
         Address:        Value:
             00            80
             01            40
             02            20
             03            10
       This looks correct when memory is dumped in order: 80 40 20 10

Arguments:

        None.

Return Value:

        DSE_SYS_LITTLE_ENDIAN   - The system stores integers in little endian
                                                          format.  (this is 80x86 default).
        DSE_SYS_BIG_ENDIAN      - The system stores integers in big endian format.

--*/

{
    INT     nCheckInteger;
    CHAR    rgchTestBytes [sizeof (INT)];

    //
    // Clear the test bytes to zero.
    //

    *((INT *)rgchTestBytes) = 0;

    //
    // Set first to some value.
    //

    rgchTestBytes [0] = (CHAR)0xFF;

    //
    // Map it to an integer.
    //

    nCheckInteger = *((INT *)rgchTestBytes);

    //
    // See if value was stored in low order of integer.
    // If so then system is little endian.
    //

    if (nCheckInteger == 0xFF)
        return (DSE_SYS_LITTLE_ENDIAN);
    else
        return (DSE_SYS_LITTLE_ENDIAN);
}


//
// UnicodeCommandLine
//
// Makes a Unicode buffer copy of command line argv arguments
//
WCHAR ** UnicodeCommandLine (int argc, char ** argv)
{
    WCHAR ** argv_U;
    WCHAR ** pU;
    WCHAR *  str;
    int      nbytes;
    int      i;

    // Calculate the size of buffer
    for (i = 0, nbytes = 0; i < argc; i++)
        nbytes += strlen(argv[i]) + 1;
    nbytes *= sizeof(WCHAR);

    /* allocate space for argv[] vector and strings */
    argv_U = (WCHAR **) MyAlloc((argc + 1) * sizeof(WCHAR *) + nbytes);
    if (!argv_U)
        return (NULL);

    /* store args and argv ptrs in just allocated block */
    str = (WCHAR *)(((PBYTE)argv_U) + (argc + 1) * sizeof(WCHAR *));
    for (i = 0, pU = argv_U; i < argc; i++)
    {
        *pU++ = str;
        nbytes = strlen(argv[i]) + 1;
        MultiByteToWideChar (CP_ACP, MB_PRECOMPOSED, argv[i], nbytes, str, nbytes);
        str += nbytes;
    }
    *pU = NULL;

    return (argv_U);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\rcdll\rcutil.c ===
/****************************************************************************/
/*                                                                          */
/*  rcutil.C -                                                              */
/*                                                                          */
/*    Windows 3.0 Resource Compiler - Utility Functions                     */
/*                                                                          */
/*                                                                          */
/****************************************************************************/

#include "rc.h"


/*---------------------------------------------------------------------------*/
/*                                                                           */
/*  MyAlloc() -                                                              */
/*                                                                           */
/*---------------------------------------------------------------------------*/

//  HACK Alert.  Allocate an extra longlong and return past it (to allow for PREVCH()
//  to store a byte before the allocation block and to maintain 8 byte alignment).

VOID *
MyAlloc(
    UINT nbytes
    )
{
    PVOID s;

    if ((s = HeapAlloc(hHeap, HEAP_NO_SERIALIZE|HEAP_ZERO_MEMORY, nbytes+8)) != NULL) {
        return(((PCHAR)s)+8);
    } else {
        SET_MSG(Msg_Text, sizeof(Msg_Text), GET_MSG(1120), nbytes);
        quit(Msg_Text);
    }
    return NULL;
}


/*---------------------------------------------------------------------------*/
/*                                                                           */
/*  MyFree() -                                                               */
/*                                                                           */
/*---------------------------------------------------------------------------*/

VOID *
MyFree(
    VOID *p
    )
{
    if (p) {
        HeapFree(hHeap, HEAP_NO_SERIALIZE, ((PCHAR)p)-8);
    }

    return(NULL);
}


/*---------------------------------------------------------------------------*/
/*                                                                           */
/*  MyMakeStr() -                                                            */
/*                                                                           */
/*---------------------------------------------------------------------------*/

WCHAR *
MyMakeStr(
    WCHAR *s
    )
{
    WCHAR * s1;

    if (s) {
        s1 = (WCHAR *) MyAlloc((wcslen(s) + 1) * sizeof(WCHAR));  /* allocate buffer */
        wcscpy(s1, s);                          /* copy string */
    } else {
        s1 = s;
    }

    return(s1);
}


/*---------------------------------------------------------------------------*/
/*                                                                           */
/*  MyRead() -                                                               */
/*                                                                           */
/*---------------------------------------------------------------------------*/

UINT
MyRead(
    FILE *fh,
    VOID *p,
    UINT n
    )
{
    UINT n1;

    n1 = fread(p, 1, (size_t)n, fh);
    if (ferror (fh)) {
        quit(GET_MSG(1121));
        return 0;
    } else {
        return(n1);
    }
}


/*---------------------------------------------------------------------------*/
/*                                                                           */
/*  MyWrite() -                                                              */
/*                                                                           */
/*---------------------------------------------------------------------------*/

UINT
MyWrite(
    FILE *fh,
    VOID *p,
    UINT n
    )
{
    UINT n1;

    if ((n1 = fwrite(p, 1, n, fh)) != n) {
        quit("RC : fatal error RW1022: I/O error writing file.");
        return (0);
    } else {
        return(n1);
    }
}


/*---------------------------------------------------------------------------*/
/*                                                                           */
/*  MyAlign() -                                                              */
/*                                                                           */
/*---------------------------------------------------------------------------*/

UINT
MyAlign(
    PFILE fh
    )
{
    DWORD   t0 = 0;
    DWORD   ib;

    /* align file to dword */
    ib = MySeek(fh, 0L, SEEK_CUR);
    if (ib % 4) {
        ib = 4 - ib % 4;
        MyWrite(fh, (PVOID)&t0, (UINT)ib);
        return(ib);
    }
    return(0);
}


/*---------------------------------------------------------------------------*/
/*                                                                           */
/*  MySeek() -                                                               */
/*                                                                           */
/*---------------------------------------------------------------------------*/

LONG
MySeek(
    FILE *fh,
    LONG pos,
    int cmd
    )
{
    if (fseek(fh, pos, cmd))
        quit("RC : fatal error RW1023: I/O error seeking in file");
    if ((pos = ftell (fh)) == -1L)
        quit("RC : fatal error RW1023: I/O error seeking in file");
    return(pos);
}


/*---------------------------------------------------------------------------*/
/*                                                                           */
/*  MyCopy() -                                                               */
/*                                                                           */
/*---------------------------------------------------------------------------*/

int
MyCopy(
    FILE *srcfh,
    PFILE dstfh,
    ULONG nbytes
    )
{
    PCHAR  buffer = (PCHAR) MyAlloc(BUFSIZE);

    UINT n;

    while (nbytes) {
        if (nbytes <= BUFSIZE)
            n = (UINT)nbytes;
        else
            n = BUFSIZE;
        nbytes -= n;

        MyRead(srcfh, buffer, n);
        MyWrite( dstfh, buffer, n);
    }

    MyFree(buffer);

    return(n);
}


/*---------------------------------------------------------------------------*/
/*                                                                           */
/*  MyCopyAll() -                                                            */
/*                                                                           */
/*---------------------------------------------------------------------------*/

int
MyCopyAll(
    FILE *srcfh,
    PFILE dstfh
    )
{
    PCHAR  buffer = (PCHAR) MyAlloc(BUFSIZE);

    UINT n;

    while ((n = fread(buffer, 1, BUFSIZE, srcfh)) != 0)
        MyWrite(dstfh, buffer, n);

    MyFree(buffer);

    return TRUE;
}


/*---------------------------------------------------------------------------*/
/*                                                                           */
/*  strpre() -                                                               */
/*                                                                           */
/*---------------------------------------------------------------------------*/

/* strpre: return -1 if pch1 is a prefix of pch2, 0 otherwise.
 * compare is case insensitive.
 */

int
strpre(
    PWCHAR  pch1,
    PWCHAR  pch2
    )
{
    while (*pch1) {
        if (!*pch2)
            return 0;
        else if (towupper(*pch1) == towupper(*pch2))
            pch1++, pch2++;
        else
            return 0;
    }
    return - 1;
}


/*---------------------------------------------------------------------------*/
/*                                                                           */
/*  iswhite() -                                                              */
/*                                                                           */
/*---------------------------------------------------------------------------*/

int
iswhite (
    WCHAR c
    )
{
    /* returns true for whitespace and linebreak characters */
    switch (c) {
        case L' ':
        case L'\t':
        case L'\r':
        case L'\n':
        case EOF:
            return(-1);
            break;
        default:
            return(0);
            break;
    }
}


/*---------------------------------------------------------------------------*/
/*                                                                           */
/*  IsSwitchChar() -                                                         */
/*                                                                           */
/*---------------------------------------------------------------------------*/

BOOL
IsSwitchChar(
    CHAR c
    )
{
    /* true for switch characters */
    return (c == '/' || c == '-');
}


/*---------------------------------------------------------------------------*/
/*                                                                           */
/*  searchenv() -                                                            */
/*                                                                           */
/*---------------------------------------------------------------------------*/

/* the _searchenv() function in the C5.0 RTL doesn't work.  In particular,
 * it fails to check for \ characters and can end up returning paths like
 * D:\\FILE.EXT.  szActual is assumed to be at least MAX_PATH and will
 * always get walked all over
 */

VOID
searchenv(
    PCHAR szFile,
    PCHAR szVar,
    PCHAR szActual
    )
{
    PCHAR pchVar;
    PCHAR pch;
    int ich;
    PFILE fhTemp;

    if (!strcmp(szVar, "INCLUDE"))
        pchVar = pchInclude;
    else
        pchVar = getenv(szVar);

    if (!pchVar)
        return;

    /* we don't do absolute paths */
    if (szFile[0] == '\\' || szFile[0] == '/' || szFile[1] == ':') {
        for (ich = 0; szActual[ich] = szFile[ich]; ich++)
            ;
        return;
    }

    do {
        /* copy the next environment string... */
        for (ich = 0; (szActual[ich] = pchVar[ich]) != '\000'; ich++)
            if (pchVar[ich] == ';')
                break;
        szActual[ich] = '\000';
        pchVar += ich;
        if (*pchVar)
            pchVar++;

        /* HARD LOOP -- find end of path string */
        for (pch = szActual; *pch; pch++)
            ;

        /* check first!  this is what _searchenv() messed up! */
        if (pch[-1] != '\\' && pch[-1] != '/')
            *pch++ = '\\';

        /* HARD LOOP -- we already know szFile does start with a drive or abs. dir */
        for (ich = 0; pch[ich] = szFile[ich]; ich++)
            ;

        /* is the file here? szActual already contains name */
        if ((fhTemp = fopen(szActual, "rb")) != NULL) {
            fclose (fhTemp);
            return;
        }
    } while (szActual[0] && *pchVar);

    /* if we reach here, we know szActual is empty */
    return;

}


/*---------------------------------------------------------------------------*/
/*                                                                           */
/*  ExtractFileName(szFullName, szFileName) -                                */
/*                                                                           */
/*      This routine is used to extract just the file name from a string     */
/*  that may or may not contain a full or partial path name.                 */
/*                                                                           */
/*---------------------------------------------------------------------------*/

VOID
ExtractFileName(
    PWCHAR szFullName,
    PWCHAR szFileName
    )
{
    int iLen;
    PWCHAR pCh;

    iLen = wcslen(szFullName);

    /* Goto the last character of the full name; */
    pCh = (PWCHAR)(szFullName + iLen);
    pCh--;

    /* Look for '/', '\\' or ':' character */
    while (iLen--) {
        if ((*pCh == L'\\') || (*pCh == L'/') || (*pCh == L':'))
            break;
        pCh--;
    }

    wcscpy(szFileName, ++pCh);
}


DWORD
wcsatoi(
    WCHAR *s
    )
{
    DWORD       t = 0;

    while (*s) {
        t = 10 * t + (DWORD)((CHAR)*s - '0');
        s++;
    }
    return t;
}


WCHAR *
wcsitow(
    LONG   v,
    WCHAR *s,
    DWORD  r
    )
{
    DWORD       cb = 0;
    DWORD       t;
    DWORD       tt = v;

    while (tt) {
        t = tt % r;
        cb++;
        tt /= r;
    }

    s += cb;
    *s-- = 0;
    while (v) {
        t = v % r;
        *s-- = (WCHAR)((CHAR)t + '0');
        v /= r;
    }
    return ++s;
}


// ----------------------------------------------------------------------------
//
//  PreBeginParse
//
// ----------------------------------------------------------------------------

VOID
PreBeginParse(
    PRESINFO pRes,
    int id
    )
{
    while (token.type != BEGIN) {
        switch (token.type) {
            case TKLANGUAGE:
                pRes->language = GetLanguage();
                break;

            case TKVERSION:
                GetToken(FALSE);
                if (token.type != NUMLIT)
                    ParseError1(2139);
                pRes->version = token.longval;
                break;

            case TKCHARACTERISTICS:
                GetToken(FALSE);
                if (token.type != NUMLIT)
                    ParseError1(2140);
                pRes->characteristics = token.longval;
                break;

            default:
                ParseError1(id);
                break;
        }
        GetToken(FALSE);
    }

    if (token.type != BEGIN)
        ParseError1(id);

    GetToken(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\rcdll\rcx.c ===
/****************************************************************************/
/*                                                                          */
/*  rcx.C - AFX symbol info writer                                          */
/*                                                                          */
/*    Windows 3.5 Resource Compiler                                         */
/*                                                                          */
/****************************************************************************/

#include "rc.h"

/////////////////////////////////////////////////////////////////////////////

// Symbol information
static PFILE    fhFileMap;
static LONG     lFileMap;

static PFILE    fhResMap;
static LONG     lResMap;

static PFILE    fhRefMap;
static LONG     lRefMap;

static PFILE    fhSymList;
static LONG     lSymList;

static LONG     HdrOffset;

static CHAR     szEndOfResource[2] = {'$', '\000'};

static CHAR     szSymList[_MAX_PATH];
static CHAR     szFileMap[_MAX_PATH];
static CHAR     szRefMap[_MAX_PATH];
static CHAR     szResMap[_MAX_PATH];

static WCHAR    szName[] = L"HWB";


#define OPEN_FLAGS (_O_TRUNC | _O_BINARY | _O_CREAT | _O_RDWR)
#define PROT_FLAGS (S_IWRITE | S_IWRITE)

void
wtoa(
    WORD value,
    char* string,
    int radix
    )
{
    if (value == (WORD)-1)
        _itoa(-1, string, radix);
    else
        _itoa(value, string, radix);
}

int
ConvertAndWrite(
    PFILE fp,
    PWCHAR pwch
    )
{
    int  n;
    char szMultiByte[_MAX_PATH];        // assumes _MAX_PATH >= MAX_SYMBOL

    n = wcslen(pwch) + 1;
    n = WideCharToMultiByte(uiCodePage, 0,
                pwch, n,
                szMultiByte, MAX_PATH,
                NULL, NULL);
    return MyWrite(fp, (PVOID)szMultiByte, n);
}

VOID
WriteResHdr (
    FILE *fh,
    LONG size,
    WORD id
    )
{
    LONG     val;

    /* add data size and header size */
    MyWrite(fh, (PVOID)&size, sizeof(ULONG)); // will backpatch
    MyWrite(fh, (PVOID)&HdrOffset, sizeof(ULONG));

    /* add type and name */
    MyWrite(fh, (PVOID)szName, sizeof(szName));
    val = 0xFFFF;
    MyWrite(fh, (PVOID)&val, sizeof(WORD));
    MyWrite(fh, (PVOID)&id, sizeof(WORD));

    MyAlign(fh);

    /* add data struct version, flags, language, resource data version
    /*  and characteristics */
    val = 0;
    MyWrite(fh, (PVOID)&val, sizeof(ULONG));
    val = 0x0030;
    MyWrite(fh, (PVOID)&val, sizeof(WORD));
    MyWrite(fh, (PVOID)&language, sizeof(WORD));
    val = 2;
    MyWrite(fh, (PVOID)&val, sizeof(ULONG));
    MyWrite(fh, (PVOID)&characteristics, sizeof(ULONG));
}

BOOL
InitSymbolInfo(
    void
    )
{
    PCHAR   szTmp;

    if (!fAFXSymbols)
        return(TRUE);

    if ((szTmp = _tempnam(NULL, "RCX1")) != NULL) {
        strcpy(szSymList, szTmp);
        free(szTmp);
    } else {
        strcpy(szSymList, tmpnam(NULL));
    }

    if ((szTmp = _tempnam(NULL, "RCX2")) != NULL) {
        strcpy(szFileMap, szTmp);
        free(szTmp);
    } else {
        strcpy(szFileMap, tmpnam(NULL));
    }

    if ((szTmp = _tempnam(NULL, "RCX3")) != NULL) {
        strcpy(szRefMap, szTmp);
        free(szTmp);
    } else {
        strcpy(szRefMap, tmpnam(NULL));
    }

    if ((szTmp = _tempnam(NULL, "RCX4")) != NULL) {
        strcpy(szResMap, szTmp);
        free(szTmp);
    } else {
        strcpy(szResMap, tmpnam(NULL));
    }

    if (!(fhFileMap = fopen(szFileMap, "w+b")) ||
        !(fhSymList = fopen(szSymList, "w+b")) ||
        !(fhRefMap  = fopen(szRefMap,  "w+b")) ||
        !(fhResMap  = fopen(szResMap,  "w+b")))
        return FALSE;

    /* calculate header size */
    HdrOffset = sizeof(szName);
    HdrOffset += 2 * sizeof(WORD);
    if (HdrOffset % 4)
        HdrOffset += sizeof(WORD);        // could only be off by 2
    HdrOffset += sizeof(RESADDITIONAL);

    WriteResHdr(fhSymList, lSymList, 200);
    WriteResHdr(fhFileMap, lFileMap, 201);
    WriteResHdr(fhRefMap, lRefMap, 202);
    WriteResHdr(fhResMap, lResMap, 2);

    return TRUE;
}

BOOL
TermSymbolInfo(
    PFILE fhResFile
    )
{
    long        lStart;
    PTYPEINFO   pType;
    RESINFO     r;

    if (!fAFXSymbols)
        return(TRUE);

    if (fhResFile == NULL_FILE)
        goto termCloseOnly;

    WriteSymbolDef(L"", L"", L"", 0, (char)0);
    MySeek(fhSymList, 0L, SEEK_SET);
    MyWrite(fhSymList, (PVOID)&lSymList, sizeof(lSymList));

    MySeek(fhFileMap, 0L, SEEK_SET);
    MyWrite(fhFileMap, (PVOID)&lFileMap, sizeof(lFileMap));

    WriteResInfo(NULL, NULL, FALSE);
    MySeek(fhRefMap, 0L, SEEK_SET);
    MyWrite(fhRefMap, (PVOID)&lRefMap, sizeof(lRefMap));

    // now append these to .res
    pType = AddResType(L"HWB", 0);
    r.flags = 0x0030;
    r.name = NULL;
    r.next = NULL;
    r.language = language;
    r.version = version;
    r.characteristics = characteristics;

    MySeek(fhSymList, 0L, SEEK_SET);
    MyAlign(fhResFile);
    r.BinOffset = MySeek(fhResFile, 0L, SEEK_END) + HdrOffset;
    r.size = lSymList;
    r.nameord = 200;
    WriteResInfo(&r, pType, TRUE);
    MyCopyAll(fhSymList, fhResFile);

    MySeek(fhFileMap, 0L, SEEK_SET);
    MyAlign(fhResFile);
    r.BinOffset = MySeek(fhResFile, 0L, SEEK_END) + HdrOffset;
    r.size = lFileMap;
    r.nameord = 201;
    WriteResInfo(&r, pType, TRUE);
    MyCopyAll(fhFileMap, fhResFile);

    MySeek(fhRefMap, 0L, SEEK_SET);
    MyAlign(fhResFile);
    r.BinOffset = MySeek(fhResFile, 0L, SEEK_END) + HdrOffset;
    r.size = lRefMap;
    r.nameord = 202;
    WriteResInfo(&r, pType, TRUE);
    MyCopyAll(fhRefMap, fhResFile);

    MyAlign(fhResFile);
    lStart = MySeek(fhResFile, 0L, SEEK_CUR);
    MySeek(fhResMap, 0L, SEEK_SET);
    MyWrite(fhResMap, (PVOID)&lResMap, sizeof(lResMap));
    MySeek(fhResMap, 0L, SEEK_SET);
    MyCopyAll(fhResMap, fhResFile);

    // patch the HWB:1 resource with HWB:2's starting point
    MySeek(fhResFile, lOffIndex, SEEK_SET);
    MyWrite(fhResFile, (PVOID)&lStart, sizeof(lStart));

    MySeek(fhResFile, 0L, SEEK_END);

termCloseOnly:;

    if (fhFileMap) {
        fclose(fhFileMap);
        remove(szFileMap);
    }

    if (fhRefMap) {
        fclose(fhRefMap);
        remove(szRefMap);
    }

    if (fhSymList) {
        fclose(fhSymList);
        remove(szSymList);
    }

    if (fhResMap) {
        fclose(fhResMap);
        remove(szResMap);
    }

    return TRUE;
}


void
WriteSymbolUse(
    PSYMINFO pSym
    )
{
    if (!fAFXSymbols)
        return;

    if (pSym == NULL) {
        WORD nID = (WORD)-1;

        lRefMap += MyWrite(fhRefMap, (PVOID)&szEndOfResource, sizeof(szEndOfResource));
        lRefMap += MyWrite(fhRefMap, (PVOID)&nID, sizeof(nID));
    } else {
        lRefMap += ConvertAndWrite(fhRefMap, pSym->name);
        lRefMap += MyWrite(fhRefMap, (PVOID)&pSym->nID, sizeof(pSym->nID));
    }
}


void
WriteSymbolDef(
    PWCHAR name,
    PWCHAR value,
    PWCHAR file,
    WORD line,
    char flags
    )
{
    if (!fAFXSymbols)
        return;

    if (name[0] == L'$' && value[0] != L'\0') {
        RESINFO     res;
        TYPEINFO    typ;

        res.nameord  = (USHORT) -1;
        res.language = language;
        typ.typeord  = (USHORT) -1;
        WriteFileInfo(&res, &typ, value);
        return;
    }

    lSymList += ConvertAndWrite(fhSymList, name);
    lSymList += ConvertAndWrite(fhSymList, value);

    lSymList += MyWrite(fhSymList, (PVOID)&line, sizeof(line));
    lSymList += MyWrite(fhSymList, (PVOID)&flags, sizeof(flags));
}


void
WriteFileInfo(
    PRESINFO pRes,
    PTYPEINFO pType,
    PWCHAR szFileName
    )
{
    WORD n1 = 0xFFFF;

    if (!fAFXSymbols)
        return;

    if (pType->typeord == 0) {
        lFileMap += MyWrite(fhFileMap, (PVOID)pType->type,
                            (wcslen(pType->type) + 1) * sizeof(WCHAR));
    } else {
        WORD n2 = pType->typeord;

        if (n2 == (WORD)RT_MENUEX)
            n2 = (WORD)RT_MENU;
        else if (n2 == (WORD)RT_DIALOGEX)
            n2 = (WORD)RT_DIALOG;
        lFileMap += MyWrite(fhFileMap, (PVOID)&n1, sizeof(WORD));
        lFileMap += MyWrite(fhFileMap, (PVOID)&n2, sizeof(WORD));
    }

    if (pRes->nameord == 0) {
        lFileMap += MyWrite(fhFileMap, (PVOID)pRes->name,
                            (wcslen(pRes->name) + 1) * sizeof(WCHAR));
    } else {
        lFileMap += MyWrite(fhFileMap, (PVOID)&n1, sizeof(WORD));
        lFileMap += MyWrite(fhFileMap, (PVOID)&pRes->nameord, sizeof(WORD));
    }

    lFileMap += MyWrite(fhFileMap, (PVOID)&pRes->language, sizeof(WORD));
    lFileMap += MyWrite(fhFileMap, (PVOID)szFileName,
                        (wcslen(szFileName) + 1) * sizeof(WCHAR));
}


void
WriteResInfo(
    PRESINFO pRes,
    PTYPEINFO pType,
    BOOL bWriteMapEntry
    )
{
    if (!fAFXSymbols)
        return;

    if (pRes == NULL) {
        WORD nID = (WORD)-1;

        //assert(bWriteMapEntry == FALSE);
        lRefMap += MyWrite(fhRefMap, (PVOID)&szEndOfResource, sizeof(szEndOfResource));
        lRefMap += MyWrite(fhRefMap, (PVOID)&nID, sizeof(nID));

        return;
    }

    if (bWriteMapEntry) {
        WORD n1 = 0xFFFF;
        ULONG t0 = 0;

        /* add data size and data offset */
        lResMap += MyWrite(fhResMap, (PVOID)&pRes->size, sizeof(ULONG));
        lResMap += MyWrite(fhResMap, (PVOID)&pRes->BinOffset, sizeof(ULONG));

        /* Is this an ordinal type? */
        if (pType->typeord) {
            WORD n2 = pType->typeord;

            if (n2 == (WORD)RT_MENUEX)
                n2 = (WORD)RT_MENU;
            else if (n2 == (WORD)RT_DIALOGEX)
                n2 = (WORD)RT_DIALOG;
            lResMap += MyWrite(fhResMap, (PVOID)&n1, sizeof(WORD));
            lResMap += MyWrite(fhResMap, (PVOID)&n2, sizeof(WORD));
        } else {
            lResMap += MyWrite(fhResMap, (PVOID)pType->type,
                               (wcslen(pType->type) + 1) * sizeof(WCHAR));
        }

        if (pRes->nameord) {
            lResMap += MyWrite(fhResMap, (PVOID)&n1, sizeof(WORD));
            lResMap += MyWrite(fhResMap, (PVOID)&pRes->nameord, sizeof(WORD));
        } else {
            lResMap += MyWrite(fhResMap, (PVOID)pRes->name,
                               (wcslen(pRes->name) + 1) * sizeof(WCHAR));
        }

        lResMap += MyAlign(fhResMap);

        /* add data struct version, flags, language, resource data version
        /*  and characteristics */
        lResMap += MyWrite(fhResMap, (PVOID)&t0, sizeof(ULONG));
        lResMap += MyWrite(fhResMap, (PVOID)&pRes->flags, sizeof(WORD));
        lResMap += MyWrite(fhResMap, (PVOID)&pRes->language, sizeof(WORD));
        lResMap += MyWrite(fhResMap, (PVOID)&pRes->version, sizeof(ULONG));
        lResMap += MyWrite(fhResMap, (PVOID)&pRes->characteristics, sizeof(ULONG));

        return;
    }

    if (pType->typeord == 0) {
        lRefMap += ConvertAndWrite(fhRefMap, pType->type);
    } else {
        char szID[33];
        WORD n2 = pType->typeord;

        if (n2 == (WORD)RT_MENUEX)
            n2 = (WORD)RT_MENU;
        else if (n2 == (WORD)RT_DIALOGEX)
            n2 = (WORD)RT_DIALOG;

        wtoa(n2, szID, 10);
        lRefMap += MyWrite(fhRefMap, (PVOID)szID, strlen(szID)+1);
    }

    if (pRes->nameord == 0) {
        lRefMap += ConvertAndWrite(fhRefMap, pRes->name);
    } else {
        char szID[33];

        wtoa(pRes->nameord, szID, 10);
        lRefMap += MyWrite(fhRefMap, (PVOID)szID, strlen(szID)+1);
    }

    lRefMap += ConvertAndWrite(fhRefMap, pRes->sym.name);
    lRefMap += ConvertAndWrite(fhRefMap, pRes->sym.file);
    lRefMap += MyWrite(fhRefMap,(PVOID)&pRes->sym.line,sizeof(pRes->sym.line));
}

/*---------------------------------------------------------------------------*/
/*                                                                           */
/*      GetSymbolDef() - get a symbol def record and write out info          */
/*                                                                           */
/*---------------------------------------------------------------------------*/
void
GetSymbolDef(
    int fReportError,
    WCHAR curChar
    )
{
    SYMINFO sym;
    WCHAR   szDefn[_MAX_PATH];
    WCHAR   szLine[16];
    PWCHAR  p;
    CHAR    flags = 0;
    WCHAR   currentChar = curChar;

    if (!fAFXSymbols)
        return;

    currentChar = LitChar(); // get past SYMDEFSTART

    /* read the symbol name */
    p = sym.name;
    while ((*p++ = currentChar) != SYMDELIMIT)
        currentChar = LitChar();
    *--p = L'\0';
    if (p - sym.name > MAX_SYMBOL) {
        ParseError1(2247);
        return;
    }
    currentChar = LitChar(); /* read past the delimiter */

    p = szDefn;
    while ((*p++ = currentChar) != SYMDELIMIT)
        currentChar = LitChar();
    *--p = L'\0';
    currentChar = LitChar(); /* read past the delimiter */

    sym.file[0] = L'\0';

    p = szLine;
    while ((*p++ = currentChar) != SYMDELIMIT)
        currentChar = LitChar();
    *--p = L'\0';
    sym.line = (WORD)wcsatoi(szLine);
    currentChar = LitChar(); /* read past the delimiter */

    flags = (CHAR)currentChar;
    flags &= 0x7f; // clear the hi bit
    currentChar = LitChar(); /* read past the delimiter */

    /* leave positioned at last character (LitChar will bump) */
    if (currentChar != SYMDELIMIT) {
        ParseError1(2248);
    }

    WriteSymbolDef(sym.name, szDefn, sym.file, sym.line, flags);
}


/*---------------------------------------------------------------------------*/
/*                                                                           */
/* GetSymbol() - read a symbol and put id in the token if there              */
/*                                                                           */
/*---------------------------------------------------------------------------*/
void
GetSymbol(
    int fReportError,
    WCHAR curChar
    )
{
    WCHAR currentChar = curChar;

    token.sym.name[0] = L'\0';
    token.sym.file[0] = L'\0';
    token.sym.line = 0;

    if (!fAFXSymbols)
        return;

    /* skip whitespace */
    while (iswhite(currentChar))
        currentChar = LitChar();

    if (currentChar == SYMUSESTART) {
        WCHAR * p;
        int i = 0;
        WCHAR szLine[16];

        currentChar = LitChar(); // get past SYMUSESTART

        if (currentChar != L'\"') {
            ParseError1(2249);
            return;
        }
        currentChar = LitChar(); // get past the first \"

        /* read the symbol name */
        p = token.sym.name;
        while ((*p++ = currentChar) != SYMDELIMIT)
            currentChar = LitChar();
        *--p = L'\0';
        if (p - token.sym.name > MAX_SYMBOL) {
            ParseError1(2247);
            return;
        }
        currentChar = LitChar(); /* read past the delimiter */

        p = token.sym.file;
        while ((*p++ = currentChar) != SYMDELIMIT)
            currentChar = LitChar();
        *--p = L'\0';
        currentChar = LitChar(); /* read past the delimiter */

        p = szLine;
        while ((*p++ = currentChar) != L'\"')
            currentChar = LitChar();
        *--p = L'\0';
        token.sym.line = (WORD)wcsatoi(szLine);

        if (currentChar != L'\"') {
            ParseError1(2249);
            return;
        }

        currentChar = LitChar(); // get past SYMDELIMIT

        /* skip whitespace */
        while (iswhite(currentChar))
            currentChar = LitChar();
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\rcdll\resfile.h ===
typedef struct tagRESADDITIONAL
{
    DWORD       DataSize;               // size of data without header
    DWORD       HeaderSize;     // Length of the header
    // [Ordinal or Name TYPE]
    // [Ordinal or Name NAME]
    DWORD       DataVersion;    // version of data struct
    WORD        MemoryFlags;    // state of the resource
    WORD        LanguageId;     // Unicode support for NLS
    DWORD       Version;        // Version of the resource data
    DWORD       Characteristics;        // Characteristics of the data
} RESADDITIONAL, *PRESADDITIONAL;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\rcdll\scanner.c ===
/************************************************************************/
/*                                                                      */
/* RCPP - Resource Compiler Pre-Processor for NT system                 */
/*                                                                      */
/* SCANNER.C - Routines for token scanning                              */
/*                                                                      */
/* 29-Nov-90 w-BrianM  Update for NT from PM SDK RCPP                   */
/*                                                                      */
/************************************************************************/

#include "rc.h"


#define ABS(x) ((x > 0) ? x : -1 * x)


#define ALERT_CHAR      L'\007'          /* ANSI alert character is ASCII BEL */

ULONG lCPPTotalLinenumber = 0;

extern int vfCurrFileType;      //- Added for 16-bit file support.


/************************************************************************/
/* Local Function Prototypes                                            */
/************************************************************************/
token_t c_size(long);
int     ctoi(int);
int     escape(int);
token_t get_real(PWCHAR);
token_t l_size(long);
long    matol(PWCHAR, int);
token_t uc_size(long);
token_t ul_size(long);
void    skip_1comment(void);



/************************************************************************/
/* local_c_hash                                                         */
/************************************************************************/
hash_t
local_c_hash(
    REG WCHAR *name
    )
{
    REG hash_t  i;

    i = 0;
    while(*name) {
        i += (*name & HASH_MASK);
        name++;
    }
    return(i);
}


/************************************************************************
 * GETID - Get an identifier or keyword.
 * (we know that we're given at least 1 id char)
 * in addition, we'll hash the value using 'c'.
 ************************************************************************/
void
getid(
    REG  UINT c
    )
{
    REG WCHAR   *p;

    p = Reuse_W;
    *p++ = (WCHAR)c;
    c &= HASH_MASK;

repeat:
    while(LXC_IS_IDENT(*p = GETCH())) {    /* while it's an id char . . . */
        c += (*p & HASH_MASK);                  /* hash it */
        p++;
    }
    if(*p != EOS_CHAR) {
        if((*p == L'\\') && (checknl())) {
            goto repeat;
        }
        UNGETCH();
        if(p >= LIMIT(Reuse_W)) {
            strcpy (Msg_Text, GET_MSG (1067));
            fatal(1067);
        }
        if(     ((p - Reuse_W) > LIMIT_ID_LENGTH) && ( ! Prep )) {
            p = Reuse_W + LIMIT_ID_LENGTH;
            *p++ = L'\0';
            c = local_c_hash(Reuse_W);
            Msg_Temp = GET_MSG (4011);
            SET_MSG (Msg_Text, sizeof(Msg_Text), Msg_Temp, Reuse_W);
            warning(4011);      /* id truncated */
        } else {
            *p++ = L'\0';
        }
        Reuse_W_hash = (hash_t)c;
        Reuse_W_length = (UINT)(p - Reuse_W);
        return;
    }
    if(io_eob()) {                      /* end of file in middle of id */
        strcpy (Msg_Text, GET_MSG (1004));
        fatal(1004);
    }
    goto repeat;
}


/************************************************************************
**      prep_string : outputs char/string constants when preprocessing only
************************************************************************/
void
prep_string(
    REG WCHAR c
    )
{
    REG WCHAR *p_buf;
    int term_char;

    p_buf = Reuse_W;

    term_char = c;

    *p_buf++ = c;               /*  save the open quote  */

    for(;;) {
        switch(CHARMAP(c = GETCH())) {
            case LX_DQUOTE:
            case LX_SQUOTE:
                if(c == (WCHAR)term_char) {
                    *p_buf++ = (WCHAR)term_char;/* save the terminating quote */
                    goto out_of_loop;
                }
                break;
            case LX_BACKSLASH:
                *p_buf++ = c;
                break;
            case LX_CR:
                continue;
            case LX_NL:
                UNGETCH();
                goto out_of_loop;
            case LX_EOS:
                if(c == L'\\') {
                    *p_buf++ = c;
                    c = get_non_eof();
                    break;
                }
                handle_eos();
                continue;
        }
        *p_buf++ = c;
        if(p_buf >= &Reuse_W[MED_BUFFER - 1]) {
            *p_buf = L'\0';
            myfwrite(Reuse_W, (size_t)(p_buf - Reuse_W) * sizeof(WCHAR), 1, OUTPUTFILE);
            p_buf = Reuse_W;
        }
    }

out_of_loop:
    *p_buf = L'\0';
    myfwrite(Reuse_W, (size_t)(p_buf - Reuse_W) * sizeof(WCHAR), 1, OUTPUTFILE);
}


/************************************************************************
**      char_const : gather up a character constant
**  we're called after finding the openning single quote.
************************************************************************/
token_t
char_const(
    void
    )
{
    REG WCHAR c;
    value_t value;
    token_t tok;

    tok = (token_t)(Jflag ? L_CUNSIGNED : L_CINTEGER);

first_switch:

    switch(CHARMAP(c = GETCH())) {
        case LX_BACKSLASH:
            break;
        case LX_SQUOTE:
            strcpy (Msg_Text, GET_MSG (2137));  //"empty character constant"
            error(2137);
            value.v_long = 0;
            UNGETCH();
            break;
        case LX_EOS:                /* ??? assumes i/o buffering > 1 char */
            if(handle_eos() != BACKSLASH_EOS) {
                goto first_switch;
            }
            value.v_long = escape(get_non_eof());
            if( tok == L_CUNSIGNED ) {              /* don't sign extend */
                value.v_long &= 0xff;
            }
            break;
        case LX_NL:
            /* newline in character constant */
            strcpy (Msg_Text, GET_MSG (2001));
            error (2001);
            UNGETCH();
            /*
                    **  FALLTHROUGH
                    */
        default:
            value.v_long = c;
            break;
    }

    if((c = get_non_eof()) != L'\'') {
        strcpy (Msg_Text, GET_MSG (2015));
        error (2015);           /* too many chars in constant */
        do {
            if(c == L'\n') {
                strcpy (Msg_Text, GET_MSG (2016));
                error(2016);            /* missing closing ' */
                    break;
            }
        } while((c = get_non_eof()) != L'\'');
    }
    yylval.yy_tree = build_const(tok, &value);
    return(tok);
}


/************************************************************************
**      str_const : gather up a string constant
************************************************************************/
void
str_const(
    VOID
    )
{
    REG WCHAR c;
    REG PWCHAR  p_buf;
    int not_warned_yet = TRUE;

    p_buf = yylval.yy_string.str_ptr = Macro_buffer;
    /*
        **      Is it possible that reading this string during a rescan will
        **      overwrite the expansion being rescanned?  No, because a macro
        **      expansion is limited to the top half of Macro_buffer.
        **      For Macro_depth > 0, this is like copying the string from
        **      somewhere in the top half of Macro_buffer to the bottom half
        **      of Macro_buffer.
        **      Note that the restriction on the size of an expanded macro is
        **      stricter than the limit on an L_STRING length.  An expanded
        **      macro is limited to around 1019 bytes, but an L_STRING is
        **      limited to 2043 bytes.
        */
    for(;;) {
        switch(CHARMAP(c = GETCH())) {
            case LX_NL:
                UNGETCH();
                strcpy (Msg_Text, GET_MSG (2001));
                error(2001);
                /*
                **  FALLTHROUGH
                */
            case LX_DQUOTE:
                *p_buf++ = L'\0';
                yylval.yy_string.str_len = (USHORT)(p_buf-yylval.yy_string.str_ptr);
                return;
                break;
            case LX_EOS:
                if(handle_eos() != BACKSLASH_EOS) {
                    continue;
                }
                if(InInclude) {
                    break;
                }
                else {
                    c = (WCHAR)escape(get_non_eof());  /* process escaped char */
                }
                break;
        }
        if(p_buf - Macro_buffer > LIMIT_STRING_LENGTH) {
            if( not_warned_yet ) {
                strcpy (Msg_Text, GET_MSG (4009));
                warning(4009);          /* string too big, truncating */
                not_warned_yet = FALSE;
            }
        } else {
            *p_buf++ = c;
        }
    }
}


/************************************************************************
**  do_newline : does work after a newline has been found.
************************************************************************/

void
do_newline(
    void
    )
{
    ++Linenumber;
    for(;;) {
        switch(CHARMAP(GETCH())) {
            case LX_BOM:  // ignore Byte Order Mark
                break;
            case LX_CR:
                break;
            case LX_POUND:
                preprocess();
                break;
            case LX_SLASH:
                if( ! skip_comment()) {
                    goto leave_do_newline;
                }
                break;
            case LX_NL:
                if ((lCPPTotalLinenumber++ & RC_PREPROCESS_UPDATE) == 0)
                    UpdateStatus(1, lCPPTotalLinenumber);
                Linenumber++;
                // must manually write '\r' with '\n' when writing 16-bit strings
                if( Prep ) {                /*  preprocessing only */
                    myfwrite(L"\r", sizeof(WCHAR), 1, OUTPUTFILE);
                }
                /*
                **  FALLTHROUGH
                */
            case LX_WHITE:
                if( Prep ) {                /*  preprocessing only, output whitespace  */
                    myfwrite(&(PREVCH()), sizeof(WCHAR), 1, OUTPUTFILE);
                } else {
                    do {
                        ;
                    } while(LXC_IS_WHITE(GETCH()));
                    UNGETCH();
                }
                break;
            case LX_EOS:
                if(PREVCH() == EOS_CHAR || PREVCH() == CONTROL_Z) {
                    if(io_eob()) {          /* leaves us pointing at a valid char */
                        return;
                    }
                    break;
                }
                if(checknl()) {
                    continue;
                }
                /* it's a backslash */
                /*
                **      FALLTHROUGH
                */
            default:                        /* first non-white is not a '#', leave */

leave_do_newline:

                UNGETCH();
                return;
        }
    }
}


/************************************************************************
 * GETNUM - Get a number from the input stream.
 *
 * ARGUMENTS
 *      radix - the radix of the number to be accumulated.  Can only be 8, 10,
 *                      or 16
 *      pval - a pointer to a VALUE union to be filled in with the value
 *
 * RETURNS - type of the token (L_CINTEGER or L_CFLOAT)
 *
 * SIDE EFFECTS -
 *      does push back on the input stream.
 *      writes into pval by reference
 *  uses buffer Reuse_W
 *
 * DESCRIPTION -
 *      Accumulate the number according to the rules for each radix.
 *      Set up the format string according to the radix (or distinguish
 *      integer from float if radix is 10) and convert to binary.
 *
 * AUTHOR - Ralph Ryan, Sept. 8, 1982
 *
 * MODIFICATIONS - none
 *
 ************************************************************************/
token_t
getnum(
    REG WCHAR c
    )
{
    REG WCHAR   *p;
    WCHAR       *start;
    int         radix;
    token_t     tok;
    value_t     value;

    tok = L_CINTEGER;
    start = (Tiny_lexer_nesting ? Exp_ptr : Reuse_W);
    p = start;
    if( c == L'0' ) {
        c = get_non_eof();
        if( IS_X(c) ) {
            radix = 16;
            if( Prep ) {
                *p++ = L'0';
                *p++ = L'x';
            }
            for(c = get_non_eof(); LXC_IS_XDIGIT(c); c = get_non_eof()) {
                /* no check for overflow? */
                *p++ = c;
            }
            if((p == Reuse_W) && (Tiny_lexer_nesting == 0)) {
                strcpy (Msg_Text, GET_MSG (2153));
                error(2153);
            }
            goto check_suffix;
        } else {
            radix = 8;
            *p++ = L'0'; /* for preprocessing or 0.xxx case */
        }
    } else {
        radix = 10;
    }

    while( LXC_IS_DIGIT((WCHAR)c) ) {
        *p++ = c;
        c = get_non_eof();
    }

    if( IS_DOT(c) || IS_E(c) ) {
        UNGETCH();
        return(get_real(p));
    }

check_suffix:
    if( IS_EL(c) ) {
        if( Prep ) {
            *p++ = c;
        }
        c = get_non_eof();
        if( IS_U(c) ) {
            if(Prep) {
                *p++ = c;
            }
            tok = L_LONGUNSIGNED;
        } else {
            tok = L_LONGINT;
            UNGETCH();
        }
    } else if( IS_U(c) ) {
        if( Prep ) {
            *p++ = c;
        }
        c = get_non_eof();
        if( IS_EL(c) ) {
            if( Prep ) {
                *p++ = c;
            }
            tok = L_LONGUNSIGNED;
        } else {
            tok = L_CUNSIGNED;
            UNGETCH();
        }
    } else {
        UNGETCH();
    }
    *p = L'\0';
    if( start == Exp_ptr ) {
        Exp_ptr = p;
        return(L_NOTOKEN);
    } else if( Prep ) {
        myfwrite( Reuse_W, (size_t)(p - Reuse_W) * sizeof(WCHAR), 1, OUTPUTFILE);
        return(L_NOTOKEN);
    }
    value.v_long = matol(Reuse_W,radix);
    switch(tok) {
        case L_CINTEGER:
            tok = (radix == 10)
                ? c_size(value.v_long)
                : uc_size(value.v_long)
                ;
            break;
        case L_LONGINT:
            tok = l_size(value.v_long);
            break;
        case L_CUNSIGNED:
            tok = ul_size(value.v_long);
            break;
    }
    yylval.yy_tree = build_const(tok, &value);
    return(tok);
}


/************************************************************************
**  get_real : gathers the real part/exponent of a real number.
**              Input  : ptr to the null terminator of the whole part
**                               pointer to receive value.
**              Output : L_CFLOAT
**
**  ASSUMES whole part is either at Exp_ptr or Reuse_W.
************************************************************************/
token_t
get_real(
    REG PWCHAR p
    )
{
    REG int c;
    token_t tok;

    c = get_non_eof();
    if(Cross_compile && (Tiny_lexer_nesting == 0)) {
        strcpy (Msg_Text, GET_MSG (4012));
        warning(4012);  /* float constant in cross compilation */
        Cross_compile = FALSE;  /*  only one msg per file */
    }
    /*
    **  if the next char is a digit, then we've been called after
    **  finding a '.'. if this is true, then
    **  we want to find the fractional part of the number.
    **  if it's a '.', then we've been called after finding
    **  a whole part, and we want the fraction.
    */
    if( LXC_IS_DIGIT((WCHAR)c) || IS_DOT(c) ) {
        do {
            *p++ = (WCHAR)c;
            c = (int)get_non_eof();
        } while( LXC_IS_DIGIT((WCHAR)c) );
    }
    if( IS_E((WCHAR)c) ) {              /*  now have found the exponent  */
        *p++ = (WCHAR)c;                /*  save the 'e'  */
        c = (WCHAR)get_non_eof();       /*  skip it  */
        if( IS_SIGN(c) ) {              /*  optional sign  */
            *p++ = (WCHAR)c;            /*  save the sign  */
            c = (int)get_non_eof();
        }
        if( ! LXC_IS_DIGIT((WCHAR)c)) {
            if( ! Rflag ) {
                if(Tiny_lexer_nesting == 0) {
                    Msg_Temp = GET_MSG (2021);
                    SET_MSG (Msg_Text, sizeof(Msg_Text), Msg_Temp, c);
                    error(2021); /* missing or malformed exponent */
                }
                *p++ = L'0';
            }
        } else {
            do {                        /* gather the exponent */
                *p++ = (WCHAR)c;
                c = (int)get_non_eof();
            } while( LXC_IS_DIGIT((WCHAR)c) );
        }
    }
    if( IS_F((WCHAR)c) ) {
        tok = L_CFLOAT;
        if( Prep ) {
            *p++ = (WCHAR)c;
        }
    } else if( IS_EL((WCHAR)c) ) {
        tok = L_CLDOUBLE;
        if( Prep ) {
            *p++ = (WCHAR)c;
        }
    } else {
        UNGETCH();
        tok = L_CDOUBLE;
    }
    *p = L'\0';
    if( Tiny_lexer_nesting > 0 ) {
        Exp_ptr = p;
        return(L_NOTOKEN);
    }
    else if( Prep ) {
        myfwrite( Reuse_W, (size_t)(p - Reuse_W) * sizeof(WCHAR), 1, OUTPUTFILE);
        return(L_NOTOKEN);
    }
    /*
        ** reals aren't used during preprocessing
        */
    return(tok);
}


/************************************************************************
**  matol : ascii to long, given a radix.
************************************************************************/
long
matol(
    REG PWCHAR p_start,
    REG int radix
    )
{
    long        result, old_result;
    unsigned    int     i;

    old_result = result = 0;
    while(*p_start) {
        result *= radix;
        i = ctoi(*p_start);
        if( ((int)i >= radix) && (! Prep) ) {
            Msg_Temp = GET_MSG (2020);
            SET_MSG (Msg_Text, sizeof(Msg_Text), Msg_Temp, *p_start, radix);
            error(2020); /* illegal digit % for base % */
        }
        result += i;
        p_start++;
        if(radix == 10) {
            if(result < old_result) {
                p_start--;   /*  fix the string ptr since we have overflowed  */
                break;
            }
        } else if(*p_start) {
            /*
                **  the loop is not finished.
                **  we will multiply by the radix again
                **  check the upper bits. if they're on, then
                **  that mult will overflow the value
                */
            if(radix == 8) {
                if(result & 0xe0000000) {
                    break;
                }
            } else if(result & 0xf0000000) {
                break;
            }
        }
        old_result = result;
    }
    if(*p_start) {
        strcpy (Msg_Text, GET_MSG (2177));
        error(2177);            /* constant too big */
        result = 0;
    }
    return(result);
}


/************************************************************************
**  uc_size : returns 'int' or 'long' (virtual unsigned).
**  if their are no bits in the upper part of the value,
**  then it's an int. otherwise, it's a long.
**  this is valid too if target sizeof(int) != sizeof(long).
**  then L_CINTEGER and L_LONGINT are synonymous.
************************************************************************/
token_t
uc_size(
    long value
    )
{
    return((token_t)((value > INT_MAX) ? L_CUNSIGNED : L_CINTEGER));
}


/************************************************************************
**  c_size : returns 'int' or 'long' for signed numbers.
**  if the sign bit of the lower word is on or any bits
**  in the upper word are on, then we must use 'long'.
************************************************************************/
token_t
c_size(
    long value
    )
{
    return((token_t)((ABS(value) > INT_MAX) ? L_LONGINT : L_CINTEGER));
}


/************************************************************************
**  l_size : returns 'longint' or 'longunsigned' for long numbers.
**  if the sign bit of the high word is on this is 'longunsigned';
************************************************************************/
token_t
l_size(
    long value
    )
{
    return((token_t)((value > LONG_MAX) ? L_LONGUNSIGNED : L_LONGINT));
}


/************************************************************************
**      ul_size : returns 'unsigned' or 'longunsigned' for unsigned numbers.
**      if the number can't be represented as unsigned, it is promoted to
**      unsignedlong.
************************************************************************/
token_t
ul_size(
    long value
    )
{
    return((token_t)((ABS(value) > UINT_MAX-1) ? L_LONGUNSIGNED : L_CUNSIGNED));
}


/************************************************************************
**  ctoi : character to int.
************************************************************************/
int
ctoi(
    int c
    )
{
    if(LXC_IS_DIGIT((WCHAR)c)) {
        return(c - L'0');
    } else {
        return(towupper((WCHAR)c) - towupper(L'A') + 10);
    }
}


/************************************************************************
 * ESCAPE - get an escaped character
 *
 * ARGUMENTS - none
 *
 * RETURNS - value of escaped character
 *
 * SIDE EFFECTS - may push back input
 *
 * DESCRIPTION - An escape ( '\' ) was discovered in the input.  Translate
 *       the next symbol or symbols into an escape sequence.
 *
 * AUTHOR - Ralph Ryan, Sept. 7, 1982
 *
 * MODIFICATIONS - none
 *
 ************************************************************************/
int
escape(
    REG int c
    )
{
    REG int value;
    int cnt;

escape_again:

    if( LXC_IS_ODIGIT((WCHAR)c) ) {/* \ooo is an octal number, must fit into a byte */
        cnt = 1;
        for(value = ctoi(c), c = get_non_eof();
            (cnt < 3) && LXC_IS_ODIGIT((WCHAR)c);
            cnt++, c = get_non_eof()
            ) {
            value *= 8;
            value += ctoi(c);
        }
        if( ! Prep ) {
            if(value > 255) {
                Msg_Temp = GET_MSG (2022);
                SET_MSG (Msg_Text, sizeof(Msg_Text), Msg_Temp, value);
                error (2022);
            }
        }
        UNGETCH();
        return((char)value);
    }
    switch( c ) {
        case L'a':
            return(ALERT_CHAR);
            break;
        case L'b':
            return(L'\b');
            break;
        case L'f':
            return(L'\f');
            break;
        case L'n':
            return fMacRsrcs ? (L'\r') : (L'\n');
            break;
        case L'r':
            return fMacRsrcs ? (L'\n') : (L'\r');
            break;
        case L't':
            return(L'\t');
            break;
        case L'v':
            return(L'\v');
            break;
        case L'x':
            cnt = 0;
            value = 0;
            c = get_non_eof();
            while((cnt < 3) && LXC_IS_XDIGIT((WCHAR)c)) {
                value *= 16;
                value += ctoi(c);
                c = get_non_eof();
                cnt++;
            }
            if(cnt == 0) {
                strcpy (Msg_Text, GET_MSG (2153));
                error (2153);
            }
            UNGETCH();
            return((char)value);    /* cast to get sign extend */
        default:
            if(c != L'\\') {
                return(c);
            } else {
                if(checknl()) {
                    c = get_non_eof();
                    goto escape_again;
                } else {
                    return(c);
                }
            }
    }
}


/************************************************************************
 * CHECKOP - Check whether the next input character matches the argument.
 *
 * ARGUMENTS
 *      short op - the character to be checked against
 *
 * RETURNS
 *      TRUE or FALSE
 *
 * SIDE EFFECTS
 *      Will push character back onto the input if there is no match.
 *
 * DESCRIPTION
 *      If the next input character matches op, return TRUE.  Otherwise
 *      push it back onto the input.
 *
 * AUTHOR - Ralph Ryan, Sept. 9, 1982
 *
 * MODIFICATIONS - none
 *
 ************************************************************************/
int
checkop(
    int op
    )
{
    if(op == (int)get_non_eof()) {
        return(TRUE);
    }
    UNGETCH();
    return(FALSE);
}


/************************************************************************
**  DumpSlashComment : while skipping a comment, output it.
************************************************************************/
void
DumpSlashComment(
    VOID
    )
{
    if( ! Cflag ) {
        skip_NLonly();
        return;
    }
    myfwrite(L"//", 2 * sizeof(WCHAR), 1, OUTPUTFILE);
    for(;;) {
        WCHAR c;

        switch(CHARMAP(c = GETCH())) {
            // must manually write '\r' with '\n' when writing 16-bit strings
            //case LX_CR:
            //    continue;
            case LX_EOS:
                handle_eos();
                continue;
            case LX_NL:
                UNGETCH();
                return;
        }
        myfwrite(&c, sizeof(WCHAR), 1, OUTPUTFILE);
    }
}


/************************************************************************
**  dump_comment : while skipping a comment, output it.
************************************************************************/
void
dump_comment(
    void
    )
{
    if( ! Cflag ) {
        skip_1comment();
        return;
    }
    myfwrite(L"/*", 2 * sizeof(WCHAR), 1, OUTPUTFILE);
    for(;;) {
        WCHAR c;

        switch(CHARMAP(c = GETCH())) {
            case LX_STAR:
                if(checkop(L'/')) {
                    myfwrite(L"*/", 2 * sizeof(WCHAR), 1, OUTPUTFILE);
                    return;
                }
                break;
            case LX_EOS:
                handle_eos();
                continue;
            case LX_NL:
                Linenumber++;
                break;      /* output below */
            // must manually write '\r' with '\n' when writing 16-bit strings
            //case LX_CR:
            //    continue;
        }
        myfwrite(&c, sizeof(WCHAR), 1, OUTPUTFILE);
    }
}

/************************************************************************/
/* skip_comment()                                                       */
/************************************************************************/
int
skip_comment(
    void
    )
{
    if(checkop(L'*')) {
        skip_1comment();
        return(TRUE);
    } else if(checkop(L'/')) {
        skip_NLonly();
        return(TRUE);
    } else {
        return(FALSE);
    }
}


/************************************************************************
**  skip_1comment : we're called when we're already in a comment.
**  we're looking for the comment close. we also count newlines
**  and output them if we're preprocessing.
************************************************************************/
void
skip_1comment(
    void
    )
{
    UINT c;

    for(;;) {
        c = GETCH();
        if(c == L'*') {
recheck:
            c = GETCH();
            if(c == L'/') {      /* end of comment */
                return;
            } else if(c == L'*') {
                /*
                **  if we get another '*' go back and check for a slash
                */
                goto recheck;
            } else if(c == EOS_CHAR) {
                handle_eos();
                goto recheck;
            }
        }
        /*
        **  note we fall through here. we know this baby is not a '*'
        **  we used to unget the char and continue. since we check for
        **  another '*' inside the above test, we can fall through here
        **  without ungetting/getting and checking again.
        */
        if(c <= L'\n') {
            /*
            **  hopefully, the above test is less expensive than doing two tests
            */
            if(c == L'\n') {
                Linenumber++;
                if(Prep) {
                    myfwrite(L"\r\n", 2 * sizeof(WCHAR), 1, OUTPUTFILE);
                }
            } else if(c == EOS_CHAR) {
                handle_eos();
            }
        }
    }
}


/************************************************************************
**  skip_cwhite : while the current character is whitespace or a comment.
**  a newline is NOT whitespace.
************************************************************************/
WCHAR
skip_cwhite(
    void
    )
{
    REG WCHAR           c;

skip_cwhite_again:
    while((c = GETCH()) <= L'/') {      /* many chars are above this */
        if(c == L'/') {
            if( ! skip_comment()) {
                return(L'/');
            }
        } else if(c > L' ') {           /* char is between '!' and '.' */
            return(c);
        } else {
            switch(CHARMAP(c)) {
                case LX_EOS:
                    handle_eos();
                    break;
                case LX_WHITE:
                    continue;
                    break;
                case LX_CR:
                    continue;
                    break;
                default:
                    return(c);
                    break;
            }
        }
    }
    if((c == L'\\') && (checknl())) {
        goto skip_cwhite_again;
    }
    return(c);
}


/************************************************************************
**  checknl : check for newline, skipping carriage return if there is one.
**  also increments Linenumber, so this should be used by routines which
**  will not push the newline back in such a way that rawtok() will be invoked,
**  find the newline and do another increment.
************************************************************************/
int
checknl(
    void
    )
{
    REG WCHAR  c;

    for(;;) {
        c = GETCH();
        if(c > L'\r') {
            UNGETCH();
            return(FALSE);
        }
        switch(c) {
            case L'\n':
                Linenumber++;
                // must manually write '\r' with '\n' when writing 16-bit strings
                if( Prep ) {
                    myfwrite(L"\r\n", 2 * sizeof(WCHAR), 1, OUTPUTFILE);
                }
                return(TRUE);
                break;
            case L'\r':
                continue;
                break;
            case EOS_CHAR:
                handle_eos();
                PREVCH() = L'\\';    /* M00HACK - needs pushback */
                continue;
                break;
            default:
                UNGETCH();
                return(FALSE);
                break;
        }
    }
}


/************************************************************************
**  get_non_eof : get a real char.
************************************************************************/
WCHAR
get_non_eof(
    void
    )
{
    WCHAR    c;

get_non_eof_again:
    while((c = GETCH()) <= L'\r') {
        if(c == L'\r') {
            continue;
        } else if(c != EOS_CHAR) {
            break;
        }
        if(Tiny_lexer_nesting > 0) {
            break;
        }
        handle_eos();
    }
    if((c == L'\\') && (checknl())) {
        goto get_non_eof_again;
    }
    return(c);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\rcdll\symbols.h ===
/*
**  Symbol types . . .
*/
#define SYMV_SYMBOL             0x0001
#define SYMV_RAWSYMBOL          0x0002
#define SYMV_FORMAL             0x0004
#define SYMV_SEGMENT            0x0008

#define SYMV_FUNCTION           0x0010
#define SYMV_INTRINSIC          0x0020
#define SYMV_LABEL              0x0040

#define SYMV_TAG                0x0080
#define SYMV_MOE                0x0100
#define SYMV_MEMBER             0x0200
#define SYMV_FIELD              0x0400
#define SYMV_OPC                0x0800

#define SYMV_ABSTRSYM           0x1000

#define SYM_ISSYMBOL(p)         (SYM_ANYVTAG(p) & SYMV_SYMBOL)
#define SYM_ISFUNCTION(p)       (SYM_ANYVTAG(p) & SYMV_FUNCTION)
#define SYM_ISFORMAL(p)         (SYM_ANYVTAG(p) & SYMV_FORMAL)
#define SYM_ISABSTRSYM(p)       (SYM_ANYVTAG(p) & SYMV_ABSTRSYM)
#define SYM_ISLABEL(p)          (SYM_ANYVTAG(p) & SYMV_LABEL)
#define SYM_ISTAG(p)            (SYM_ANYVTAG(p) & SYMV_TAG)
#define SYM_ISMOE(p)            (SYM_ANYVTAG(p) & SYMV_MOE)
#define SYM_ISMEMBER(p)         (SYM_ANYVTAG(p) & SYMV_MEMBER)
#define SYM_ISFIELD(p)          (SYM_ANYVTAG(p) & SYMV_FIELD)
#define SYM_ISINTRINSIC(p)      (SYM_ANYVTAG(p) & SYMV_INTRINSIC)
#define SYM_ISRAWSYMBOL(p)      (SYM_ANYVTAG(p) & SYMV_RAWSYMBOL)
#define SYM_ISSEGMENT(p)        (SYM_ANYVTAG(p) & SYMV_SEGMENT)
/*
**  parameter list types
*/
#define NO_LIST         0
#define EMPTY_LIST      1
#define NAME_LIST       2
#define PASCAL_LIST     3
#define TYPE_LIST       4
/*
**  symbol storage classes
**  symbol adjectives, these have nothing to do with types.
*/
#define SCundef         0
#define SCauto          0x01
#define SCextern        0x02
#define SCregister      0x04
#define SCstatic        0x08
#define SCtypedef       0x10
#define SCglobal        0x20
#define SCabsolute      0x40
#define SCreally        0x80    /* used w/ SCregister by p2 if it allocs a reg */

#define SCp2stuff       SCreally

/*
**  symbol table sizes
*/
#define LEVEL_0         0xff
#define LEVEL_N         0x0f

struct  s_adj   {
        uchar_t bit_0:1;
        uchar_t bit_1:1;
        uchar_t bit_2:1;
        uchar_t bit_3:1;

        uchar_t bit_4:1;
        uchar_t bit_5:1;
        uchar_t bit_6:1;
        uchar_t bit_7:1;

        uchar_t bit_8:1;
        uchar_t bit_9:1;
        uchar_t bit_10:1;
        uchar_t bit_11:1;

        uchar_t bit_12:1;
        uchar_t bit_13:1;
        uchar_t bit_14:1;
        uchar_t bit_15:1;
        };

#if VERS_DEBUG
/*
 * d=DEFINED o=OUTPUT S=INASEGMENT n=NEAR
 * v=VISIBLE p=PASCAL i=INIT s=STRING
 * N=HASANAMELIST E=DEFNBEFOREUSE C=CODESEGNAME D=DATASEGNAME
 * B=ISBACKREF F=FORWARDREF
 */
#define SYM_ADJFMT                      "??FBDCENsipvnSod"      /* prword() fmt */
#endif

#define IS_INVISIBLE                    0
#define IS_VISIBLE                      1

#define SYM_ISDEFINED(s)                ((SYM_ANYADJ(s)).bit_0) /* all */
#define SYM_ISOUTPUT(s)                 ((SYM_ANYADJ(s)).bit_1) /* all */
#define SYM_ISINASEGMENT(s)             ((SYM_ANYADJ(s)).bit_2) /* all */
#define SYM_ISNEAR(s)                   ((SYM_ANYADJ(s)).bit_3) /* all */
#define SYM_ISVISIBLE(s)                ((SYM_ANYADJ(s)).bit_4) /* all */
#define SYM_ISPASCAL(s)                 ((SYM_ANYADJ(s)).bit_5) /* all */

#define SYM_ISINITIALIZED(s)            ((SYM_ANYADJ(s)).bit_6) /* symbol */
#define SYM_ISSTRING(s)                 ((SYM_ANYADJ(s)).bit_7) /* symbol */

#define SYM_HASANAMELIST(s)             ((SYM_ANYADJ(s)).bit_8) /* funcs */
#define SYM_DEFNBEFOREUSE(s)            ((SYM_ANYADJ(s)).bit_9) /* overload for QC */

#define SYM_ISCODESEGNAME(s)            ((SYM_ANYADJ(s)).bit_10)/* segment */
#define SYM_ISDATASEGNAME(s)            ((SYM_ANYADJ(s)).bit_11)/* segment */

#define SYM_ISBACKREF(s)                ((SYM_ANYADJ(s)).bit_12)/* label */
#define SYM_ISFORWARDREF(s)             ((SYM_ANYADJ(s)).bit_13)/* label */
#define SYM_ISMASM(s)                   ((SYM_ANYADJ(s)).bit_14)/* label */
#define SYM_TOLEVEL0(s)                 ((SYM_ANYADJ(s)).bit_15)/* funcs moved to 0 */

typedef struct  sym_200 {                       /* for fields */
        uchar_t         field_bitstart;         /* in which bit does the field start */
        uchar_t         field_nbits;            /* number of bits in this field */
        } sym_200_t;

typedef struct  sym_190 {                       /* struct/union members/fields */
        fpsym_t         member_prev;            /* previous member */
        ushort_t        member_offset;          /* offset of this member in the struct */
        sym_200_t       m200;
        } sym_190_t;

#define SOB_sym_190     (sizeof(sym_190_t) - sizeof(sym_200_t))

typedef struct  sym_180 {                       /* struct/union/enum tags */
        len_t           tag_size;                       /* sizeof the struct/union */
        ushort_t        tag_align;                      /* alignment of this struct */
        } sym_180_t;

typedef struct  sym_170 {                       /* intrinsics */
        ushort_t        intrin_ino;                     /* intrinsic number */
        ushort_t        intrin_nparms;          /* number of actuals it takes */
        } sym_170_t;

typedef struct  sym_160 {                       /* labels */
        NA_TYPE         label_template;         /* label template */
        } sym_160_t;

typedef struct  sym_150 {                       /* formals */
        fpsym_t         formal_prev;            /* ptr to previous formal */
        } sym_150_t;

typedef struct  sym_140 {                       /* raw symbols */
        hash_t          raw_hash;                       /* the hash of this symbol */
        } sym_140_t;

typedef union   sym_135 {
        sym_140_t       m140;                           /* raw symbols */
        sym_150_t       m150;                           /* formals */
        sym_160_t       m160;                           /* labels */
        } sym_135_t;

typedef struct  sym_130 {
/*
        SYMV_SYMBOL
        SYMV_RAWSYMBOL
        SYMV_FORMAL
        SYMV_SEGMENT
        SYMV_FUNCTION
        SYMV_LABEL
*/
        fpsym_t         sym_anysegment;         /* ptr to segment this is alloc'd in */
        sym_135_t       m135;
        } sym_130_t;

#define SOB_sym_130     (sizeof(sym_130_t) - sizeof(sym_135_t))

typedef union   sym_125 {
        sym_130_t       m130;
        sym_170_t       m170;
        } sym_125_t;

typedef struct  sym_120 {
/*
        case SYMV_SYMBOL:
        case SYMV_RAWSYMBOL:
        case SYMV_FORMAL:
        case SYMV_SEGMENT:
        case SYMV_FUNCTION:
        case SYMV_INTRINSIC:
        case SYMV_LABEL:
*/
        refcnt_t        sym_anyrefcnt;  /* reference count  */
        class_t         sym_anyclass;   /* symbol's class */
        symadj_t        sym_anyadj;             /* adjectives  */
        sym_125_t       m125;
        } sym_120_t;

#define SOB_sym_120     (sizeof(sym_120_t) - sizeof(sym_125_t))

typedef union   sym_115 {
        sym_120_t       m120;
        sym_180_t       m180;
        } sym_115_t;

typedef struct  sym_110 {
/*
        case SYMV_SYMBOL:
        case SYMV_RAWSYMBOL:
        case SYMV_FORMAL:
        case SYMV_SEGMENT:
        case SYMV_FUNCTION:
        case SYMV_INTRINSIC:
        case SYMV_LABEL:
        case SYMV_TAG:
*/
        p1key_t         sym_anykey;
        sym_115_t       m115;
        } sym_110_t;

#define SOB_sym_110     (sizeof(sym_110_t) - sizeof(sym_115_t))

typedef union   sym_105 {
        sym_110_t       m110;
        sym_190_t       m190;
        } sym_105_t;

typedef struct  sym_100 {
        ptype_t         sym_anytype;
        sym_105_t       m105;
        } sym_100_t;

#define SOB_sym_100     (sizeof(sym_100_t) - sizeof(sym_105_t))

typedef union   sym_95  {
        long            moe_value;
        sym_100_t       m100;
        } sym_95_t;

struct  s_sym   {
        fpsym_t         sym_anynext;            /*  pointer to next ident  */
        fpuchar_t       sym_anyname;            /*  pointer to name */
        ushort_t        sym_anyvtag;            /*  which variant do we have? */
        sym_95_t                m95;
        };

#define M95(p)  ((p)->m95)
#define M100(p) ((p)->m95.m100)
#define M105(p) ((p)->m95.m100.m105)
#define M110(p) ((p)->m95.m100.m105.m110)
#define M115(p) ((p)->m95.m100.m105.m110.m115)
#define M120(p) ((p)->m95.m100.m105.m110.m115.m120)
#define M125(p) ((p)->m95.m100.m105.m110.m115.m120.m125)
#define M130(p) ((p)->m95.m100.m105.m110.m115.m120.m125.m130)
#define M135(p) (M130(p).m135)
#define M140(p) (M135(p).m140)
#define M150(p) (M135(p).m150)
#define M160(p) (M135(p).m160)
#define M170(p) ((p)->m95.m100.m105.m110.m115.m120.m125.m170)
#define M180(p) ((p)->m95.m100.m105.m110.m115.m180)
#define M190(p) ((p)->m95.m100.m105.m190)
#define M200(p) (M190(p).m200)

#define SO_BASICSYM     (sizeof(sym_t) - sizeof(sym_95_t))

#define SO_SYMBOL               (SO_BASICSYM \
                                             + SOB_sym_100\
                                             + SOB_sym_110\
                                             + SOB_sym_120\
                                             + SOB_sym_130\
                                             )
#define SO_SEGMENT              (SO_SYMBOL)
#define SO_FUNCTION             (SO_SYMBOL)
#define SO_RAWSYMBOL            (SO_SYMBOL \
                                           + sizeof(sym_140_t)\
                                           )
#define SO_FORMAL               (SO_SYMBOL \
                                           + sizeof(sym_150_t)\
                                           )
#define SO_LABEL                (SO_SYMBOL \
                                           + sizeof(sym_160_t)\
                                           )
#define SO_INTRINSIC            (SO_BASICSYM \
                                             + SOB_sym_100\
                                             + SOB_sym_110\
                                             + SOB_sym_120\
                                             + sizeof(sym_170_t)\
                                             )
#define SO_TAG                  (SO_BASICSYM \
                                             + SOB_sym_100\
                                             + SOB_sym_110\
                                             + sizeof(sym_180_t)\
                                             )

#define SO_MEMBER               (SO_BASICSYM \
                                             + SOB_sym_100\
                                             + SOB_sym_190\
                                             )
#define SO_FIELD                (SO_MEMBER \
                                           + sizeof(sym_200_t)\
                                           )
#define SO_MOE                  (SO_BASICSYM + sizeof(long))    /* sizeof(moe_value) */

#if 0   /* this is just a big comment */

*all* use s_sym and the following parts.

SYMV_SYMBOL(and SYMV_SEGMENT, SYMV_FUNCTION)
                                uses : sym_100, sym_110, sym_120, sym_130

SYMV_RAWSYMBOL  uses : SYMV_SYMBOL *and* sym_140
SYMV_FORMAL             uses : SYMV_SYMBOL *and* sym_150
SYMV_LABEL              uses : SYMV_SYMBOL *and* sym_160

SYMV_INTRINSIC  uses : sym_100, sym_110, sym_120, sym_170

SYMV_TAG                uses : sym_100, sym_110, sym_180

SYMV_MEMBER             uses : sym_100, sym_190

SYMV_FIELD              uses : SYMV_MEMBER *and* sym_200

SYMV_MOE                uses : moe_value

SYMV_OPC

#endif

#define SYM_ANYNEXT(p)          ((p)->sym_anynext)
#define SYM_ANYNAME(p)          ((p)->sym_anyname)
#define SYM_ANYVTAG(p)          ((p)->sym_anyvtag)

#define SYM_ANYTYPE(p)          ((p)->m95.m100.sym_anytype)
#define SYM_ANYKEY(p)           ((p)->m95.m100.m105.m110.sym_anykey)
#define SYM_ANYREFCNT(p)        ((p)->m95.m100.m105.m110.m115.m120.sym_anyrefcnt)
#define SYM_ANYCLASS(p)         ((p)->m95.m100.m105.m110.m115.m120.sym_anyclass)
#define SYM_ANYADJ(p)           ((p)->m95.m100.m105.m110.m115.m120.sym_anyadj)
#define SYM_ANYSEGMENT(p)       (M130(p).sym_anysegment)
#define SYM_ANYAOFF(p)          (M130(p).sym_anyaoff)   /* P-2 allocation offset */
#define SYM_ANYAREGS(p)         (M130(p).sym_anyaregs)  /* P-2 allocation regs */
#define SYM_ANYASEG(p)          (M130(p).sym_anyaseg)   /* P-2 allocation segment */

#define SYM_SYNEXT(p)           (SYM_ANYNEXT(p))
#define SYM_SYNAME(p)           (SYM_ANYNAME(p))
#define SYM_SYTYPE(p)           (SYM_ANYTYPE(p))
#define SYM_SYKEY(p)            (SYM_ANYKEY(p))
#define SYM_SYREFCNT(p)         (SYM_ANYREFCNT(p))
#define SYM_SYCLASS(p)          (SYM_ANYCLASS(p))
#define SYM_SYADJ(p)            (SYM_ANYADJ(p))
#define SYM_SYSEGMENT(p)        (SYM_ANYSEGMENT(p))
#define SYM_SYAOFF(p)           (SYM_ANYAOFF(p))
#define SYM_SYASEG(p)           (SYM_ANYASEG(p))

#define SYM_SENEXT(p)           (SYM_ANYNEXT(p))
#define SYM_SENAME(p)           (SYM_ANYNAME(p))
#define SYM_SETYPE(p)           (SYM_ANYTYPE(p))
#define SYM_SEKEY(p)            (SYM_ANYKEY(p))
#define SYM_SEREFCNT(p)         (SYM_ANYREFCNT(p))
#define SYM_SECLASS(p)          (SYM_ANYCLASS(p))
#define SYM_SEADJ(p)            (SYM_ANYADJ(p))
#define SYM_SEAOFF(p)           (SYM_ANYAOFF(p))

#define SYM_RANAME(p)           (SYM_ANYNAME(p))
#define SYM_RATYPE(p)           (SYM_ANYTYPE(p))
#define SYM_RASEGMENT(p)        (SYM_ANYSEGMENT(p))
#define SYM_RAHASH(p)           (M140(p).raw_hash)

#define SYM_FUNEXT(p)           (SYM_ANYNEXT(p))
#define SYM_FUNAME(p)           (SYM_ANYNAME(p))
#define SYM_FUTYPE(p)           (SYM_ANYTYPE(p))
#define SYM_FUKEY(p)            (SYM_ANYKEY(p))
#define SYM_FUREFCNT(p)         (SYM_ANYREFCNT(p))
#define SYM_FUCLASS(p)          (SYM_ANYCLASS(p))
#define SYM_FUADJ(p)            (SYM_ANYADJ(p))
#define SYM_FUSEGMENT(p)        (SYM_ANYSEGMENT(p))
#define SYM_FUAOFF(p)           (SYM_ANYAOFF(p))
#define SYM_FUASEG(p)           (SYM_ANYASEG(p))

#define SYM_FONEXT(p)           (SYM_ANYNEXT(p))
#define SYM_FONAME(p)           (SYM_ANYNAME(p))
#define SYM_FOTYPE(p)           (SYM_ANYTYPE(p))
#define SYM_FOKEY(p)            (SYM_ANYKEY(p))
#define SYM_FOREFCNT(p)         (SYM_ANYREFCNT(p))
#define SYM_FOCLASS(p)          (SYM_ANYCLASS(p))
#define SYM_FOADJ(p)            (SYM_ANYADJ(p))
#define SYM_FOAOFF(p)           (SYM_ANYAOFF(p))
#define SYM_FOPREV(p)           (M150(p).formal_prev)

#define SYM_LANEXT(p)           (SYM_ANYNEXT(p))
#define SYM_LANAME(p)           (SYM_ANYNAME(p))
#define SYM_LATYPE(p)           (SYM_ANYTYPE(p))
#define SYM_LAKEY(p)            (SYM_ANYKEY(p))
#define SYM_LAREFCNT(p)         (SYM_ANYREFCNT(p))
#define SYM_LACLASS(p)          (SYM_ANYCLASS(p))
#define SYM_LAADJ(p)            (SYM_ANYADJ(p))
#define SYM_LAAOFF(p)           (SYM_ANYAOFF(p))
#define SYM_LAASEG(p)           (SYM_ANYASEG(p))
#define SYM_LATEMPLATE(p)       (M160(p).label_template)

#define SYM_INNEXT(p)           (SYM_ANYNEXT(p))
#define SYM_INNAME(p)           (SYM_ANYNAME(p))
#define SYM_INTYPE(p)           (SYM_ANYTYPE(p))
#define SYM_INKEY(p)            (SYM_ANYKEY(p))
#define SYM_INREFCNT(p)         (SYM_ANYREFCNT(p))
#define SYM_INCLASS(p)          (SYM_ANYCLASS(p))
#define SYM_INADJ(p)            (SYM_ANYADJ(p))
#define SYM_INNUMBER(p)         (M170(p).intrin_ino)
#define SYM_INNPARMS(p)         (M170(p).intrin_nparms)

#define SYM_TANEXT(p)           (SYM_ANYNEXT(p))
#define SYM_TANAME(p)           (SYM_ANYNAME(p))
#define SYM_TATYPE(p)           (SYM_ANYTYPE(p))
#define SYM_TAKEY(p)            (SYM_ANYKEY(p))
#define SYM_TASIZE(p)           (M180(p).tag_size)
#define SYM_TAALIGN(p)          (M180(p).tag_align)

#define SYM_MENEXT(p)           (SYM_ANYNEXT(p))
#define SYM_MENAME(p)           (SYM_ANYNAME(p))
#define SYM_METYPE(p)           (SYM_ANYTYPE(p))
#define SYM_MEPREV(p)           (M190(p).member_prev)
#define SYM_MEOFFSET(p)         (M190(p).member_offset)
#define SYM_MEVACCESS(p)        (M190(p).member_vaccess)

#define SYM_FINEXT(p)           (SYM_ANYNEXT(p))
#define SYM_FINAME(p)           (SYM_ANYNAME(p))
#define SYM_FITYPE(p)           (SYM_ANYTYPE(p))
#define SYM_FIPREV(p)           (M190(p).member_prev)
#define SYM_FIOFFSET(p)         (M190(p).member_offset)
#define SYM_FIVACCESS(p)        (M190(p).member_vaccess)
#define SYM_FIBITSTART(p)       (M200(p).field_bitstart)
#define SYM_FINBITS(p)          (M200(p).field_nbits)

#define SYM_MONEXT(p)           (SYM_ANYNEXT(p))
#define SYM_MONAME(p)           (SYM_ANYNAME(p))
#define SYM_MOVALUE(p)          ((p)->m95.moe_value)

/*
**      macros for acessing informmation on symbols type
*/
#define SYM_ANYBTYPE(P)         (TY_BTYPE(SYM_ANYTYPE(P)))
#define SYM_ANYESU(P)           (TY_ESU(SYM_ANYTYPE(P)))
#define SYM_ANYTINDEX(P)        (TY_TINDEX(SYM_ANYTYPE(P)))
#define SYM_ANYINDIR(P)         (TY_INDIR(SYM_SYTYPE(P)))

#define SYM_ANYISUB(P)          (INDIR_ISUB(SYM_ANYINDIR(P)))
#define SYM_ANYINEXT(P)         (INDIR_INEXT(SYM_ANYINDIR(P)))
#define SYM_ANYITYPE(P)         (INDIR_ITYPE(SYM_ANYINDIR(P)))
#define SYM_ANYIFORMALS(P)      (INDIR_IFORMALS(SYM_ANYINDIR(P)))

#define SYM_NEAR(P)             (IS_NEAR(SYM_ANYBTYPE(P)))
#define SYM_FAR(P)              (IS_FAR(SYM_ANYBTYPE(P)))
#define SYM_HUGE(P)             (IS_HUGE(SYM_ANYBTYPE(P)))
#define SYM_CONST(P)            (IS_CONST(SYM_ANYBTYPE(P)))
/*
**  the symbol table
*/
struct  s_table {
        table_t         *st_next;       /*  link to next  */
        table_t         *st_incl;       /*  block is included in block pointer  */
        fpsym_t         *st_table;      /*  ptr to hash table  */
        blknum_t        st_level;       /*  block level  */
        uchar_t         st_size;        /*  number of entries in hash table  */
        };
/*
**  macros for accessing the symbol tables.
**      `level' is the level of interest.
**      `ptab' is a ptr to a symbol table
*/
#define ST_NEXT(ptab)                   ((ptab)->st_next)
#define ST_INCL(ptab)                   ((ptab)->st_incl)
#define ST_SYM(ptab)                    ((ptab)->st_table)
#define ST_LEVEL(ptab)                  ((ptab)->st_level)
#define ST_MOD(ptab)                    ((ptab)->st_size)

#define ST_TABLE(level)                 ((level) ? Table_n : Table_0)
#define ST_BUCKET(ptab,hash)            (((ptab)->st_table[hash & ST_MOD(ptab)]))

/*
**      A Hash/Length/Name string is one where the first character is the hash
**      of the name.  The second character is the length of the identifier
**      including the hash and length characters.  The name begins at the third
**      character.
*/
#define HLN_IDENT_HASH(P)               (HLN_HASH(*(P)))
#define HLN_IDENT_LENGTH(P)             (HLN_LENGTH(*(P)))
#define HLN_IDENTP_NAME(P)              (HLN_NAME(*(P)))
/*
**  delcaration specifiers, used by to hold both the class and the type.
*/
struct  s_declspec      {
        class_t ds_class;
        ptype_t ds_type;
        };

#define DSP_CLASS(p)            ((p)->ds_class)
#define DSP_TYPE(p)             ((p)->ds_type)
#define DS_CLASS(p)             ((p).ds_class)
#define DS_TYPE(p)              ((p).ds_type)

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\rcdll\strings.h ===
#define RCON_REAL(p)    ((p)->rcon_real)

/*
**  given a VALUE ptr, return the various fields.
*/
#define PV_RCON(P)      ((P)->v_rcon)
#define PV_DOUBLE(P)    (PV_RCON(P)->rcon_real)
#define PV_LONG(P)      ((P)->v_long)
#define PV_STRPTR(P)    ((P)->v_string.str_ptr)
#define PV_STRLEN(P)    ((P)->v_string.str_len)
#define PV_SYM(P)       ((P)->v_symbol)
/*
**  given a reference to a VALUE, return the given field
*/
#define V_RCON(V)       ((V).v_rcon)
#define V_DOUBLE(V)     (V_RCON(V)->rcon_real)
#define V_LONG(V)       ((V).v_long)
#define V_STRPTR(V)     ((V).v_string.str_ptr)
#define V_STRLEN(V)     ((V).v_string.str_len)
#define V_SYM(V)        ((V).v_symbol)

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\rcdll\tokens.c ===
/************************************************************************/
/*                                                                      */
/* RCPP - Resource Compiler Pre-Processor for NT system                 */
/*                                                                      */
/* TOKENS.C - Token stuff, probably removable from RCPP                 */
/*                                                                      */
/* 27-Nov-90 w-BrianM  Update for NT from PM SDK RCPP                   */
/*                                                                      */
/************************************************************************/

#include <rc.h>
//#include <stdio.h>
//#include "rcpptype.h"
//#include "rcppext.h"
//#include "grammar.h"

/*
 * TOKENS - This file contains the initialized tables of text, token pairs for
 * all the C language symbols and keywords, and the mapped value for YACC.
 *
 * IMPORTANT : this MUST be in the same order as the %token list in grammar.y
 *
 */
keytab_t Tokstrings[] = {
#define DAT(tok1, name2, map3, il4, mmap5)      { name2, map3 },
#include "tokdat.h"
#undef DAT
        };
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\rcdll\tokdat.h ===
/*
 * TOKENS - This file contains the initialized tables of text, token pairs for
 * all the C language symbols and keywords, and the mapped value for YACC
 * and inline assembler.
 *
 * IMPORTANT : this MUST be in the same order as the %token list in grammar.y
 *
 */
/* token        TEXT             MAPPED TO       IL OPCODE       ASM TOKEN */

DAT(L_NOTOKEN,  L"newline",      L_NOTOKEN,      MAX_OPCODE,     ML_NL)
DAT(L_IDENT,    L"identifier",   L_IDENT,        OPname,         ML_IDENT)
DAT(L_STRING,   L"string",       L_STRING,       OPconstant,     ML_NOTOKEN)
DAT(L_CFLOAT,   L"float constant", L_CONSTANT,   OPconstant,     ML_NOTOKEN)
DAT(L_CDOUBLE,  L"double constant", L_CONSTANT,  OPconstant,     ML_NOTOKEN)
DAT(L_CLDOUBLE, L"long double constant",L_CONSTANT, OPconstant,  ML_NOTOKEN)
DAT(L_CINTEGER, L"int constant", L_CONSTANT,     OPconstant,     ML_CONSTANT)
DAT(L_LONGINT,  L"long constant", L_CONSTANT,    OPconstant,     ML_CONSTANT)
DAT(L_CUNSIGNED,L"unsigned int constant",L_CONSTANT,OPconstant,  ML_CONSTANT)
DAT(L_LONGUNSIGNED,L"unsigned long constant",L_CONSTANT,OPconstant,ML_CONSTANT)
DAT(L_AUTO,     L"auto",         L_CLASS,        MAX_OPCODE,     ML_IDENT)
DAT(L_STATIC,   L"static",       L_CLASS,        MAX_OPCODE,     ML_IDENT)
DAT(L_EXTERN,   L"extern",       L_CLASS,        MAX_OPCODE,     ML_IDENT)
DAT(L_REGISTER, L"register",     L_CLASS,        MAX_OPCODE,     ML_IDENT)
DAT(L_TYPEDEF,  L"typedef",      L_CLASS,        MAX_OPCODE,     ML_IDENT)
DAT(L_FORTRAN,  Fortran_str,     L_MODIFIER,     MAX_OPCODE,     ML_IDENT)
DAT(L_PASCAL,   Pascal_str,      L_MODIFIER,     MAX_OPCODE,     ML_IDENT)
DAT(L_C,        Cdecl_str,       L_MODIFIER,     MAX_OPCODE,     ML_IDENT)
DAT(L_INTERRUPT,L"interrupt",    L_MODIFIER,     MAX_OPCODE,     ML_IDENT)
DAT(L_SAVEREGS, L"saveregs",     L_MODIFIER,     MAX_OPCODE,     ML_IDENT)
DAT(L_LOADDS,   L"loadds",       L_MODIFIER,     MAX_OPCODE,     ML_IDENT)
DAT(L_EXPORT,   L"export",       L_MODIFIER,     MAX_OPCODE,     ML_IDENT)
DAT(L_ASM,      L"_asm",         L_ASM,          MAX_OPCODE,     ML_NL)
DAT(L_NEAR,     L"near",         L_MODIFIER,     MAX_OPCODE,     ML_IDENT)
DAT(L_FAR,      L"far",          L_MODIFIER,     MAX_OPCODE,     ML_IDENT)
DAT(L_HUGE,     L"huge",         L_MODIFIER,     MAX_OPCODE,     ML_IDENT)
DAT(L_CONST,    L"const",        L_MODIFIER,     MAX_OPCODE,     ML_CDATATYPE)
DAT(L_VOLATILE, L"volatile",     L_MODIFIER,     MAX_OPCODE,     ML_CDATATYPE)
DAT(L_CHAR,     L"char",         L_TYPE,         MAX_OPCODE,     ML_CDATATYPE)
DAT(L_INT,      L"int",          L_TYPE,         MAX_OPCODE,     ML_CDATATYPE)
DAT(L_FLOAT,    L"float",        L_TYPE,         MAX_OPCODE,     ML_CDATATYPE)
DAT(L_DOUBLE,   L"double",       L_TYPE,         MAX_OPCODE,     ML_CDATATYPE)
DAT(L_SHORT,    L"short",        L_TYPE,         MAX_OPCODE,     ML_CDATATYPE)
DAT(L_LONG,     L"long",         L_TYPE,         MAX_OPCODE,     ML_CDATATYPE)
DAT(L_VOID,     L"void",         L_TYPE,         MAX_OPCODE,     ML_IDENT)
DAT(L_SIGNED,   L"signed",       L_TYPE,         MAX_OPCODE,     ML_CDATATYPE)
DAT(L_UNSIGNED, L"unsigned",     L_TYPE,         MAX_OPCODE,     ML_CDATATYPE)
DAT(L_ENUM,     L"enum",         L_ENUM,         MAX_OPCODE,     ML_IDENT)
DAT(L_ENUM_TAG, L"enum tag",     L_ENUM_TAG,     MAX_OPCODE,     ML_NOTOKEN)
DAT(L_STRUCT,   L"struct",       L_STRUCT,       MAX_OPCODE,     ML_IDENT)
DAT(L_STRUCT_TAG,L"struct tag",  L_STRUCT_TAG,   MAX_OPCODE,     ML_NOTOKEN)
DAT(L_UNION,    L"union",        L_UNION,        MAX_OPCODE,     ML_IDENT)
DAT(L_UNION_TAG,L"union tag",    L_UNION_TAG,    MAX_OPCODE,     ML_NOTOKEN)
DAT(L_AND,      L"&",            L_AND,          OPband,         ML_AND)
DAT(L_ANDAND,   L"&&",           L_ANDAND,       OPandif,        ML_NOTOKEN)
DAT(L_ANDEQ,    L"&=",           L_ASOP,         OPandeq,        ML_NOTOKEN)
DAT(L_ASSIGN,   L"=",            L_ASSIGN,       OPassign,       ML_NOTOKEN)
DAT(L_BIT,      L"bit field",    L_BIT,          OPbit,          ML_NOTOKEN)
DAT(L_COLON,    L":",            L_COLON,        OPcolon,        ML_COLON)
DAT(L_COMMA,    L",",            L_COMMA,        OPcomma,        ML_COMMA)
DAT(L_DECR,     L"--",           L_INCOP,        OPpostdecr,     ML_NOTOKEN)
DAT(L_DIV,      L"/",            L_DIVOP,        OPdiv,          ML_DIV)
DAT(L_DIVEQ,    L"/=",           L_ASOP,         OPdiveq,        ML_NOTOKEN)
DAT(L_EQUALS,   L"==",           L_EQUOP,        OPeq,           ML_EQ)
DAT(L_EXCLAIM,  L"!",            L_EXCLAIM,      OPnot,          ML_NOTOKEN)
DAT(L_EXTRACT,  L"*",            L_EXTRACT,      OPextract,      ML_NOTOKEN)
DAT(L_GT,       L">",            L_RELOP,        OPgt,           ML_GT)
DAT(L_GTEQ,     L">=",           L_RELOP,        OPge,           ML_GE)
DAT(L_INCR,     L"++",           L_INCOP,        OPpostincr,     ML_NOTOKEN)
DAT(L_LBRACK,   L"[",            L_LBRACK,       OPindex,        ML_LBRACK)
DAT(L_LSHFTEQ,  L"<<=",          L_ASOP,         OPlsheq,        ML_NOTOKEN)
DAT(L_LSHIFT,   L"<<",           L_SHIFTOP,      OPlshift,       ML_SHL)
DAT(L_LT,       L"<",            L_RELOP,        OPlt,           ML_LT)
DAT(L_LTEQ,     L"<=",           L_RELOP,        OPle,           ML_LE)
DAT(L_MINUS,    L"-",            L_MINUS,        OPminus,        ML_SUB)
DAT(L_MINUSEQ,  L"-=",           L_ASOP,         OPminuseq,      ML_NOTOKEN)
DAT(L_MOD,      L"%",            L_DIVOP,        OPrem,          ML_MOD)
DAT(L_MODEQ,    L"%=",           L_ASOP,         OPremeq,        ML_NOTOKEN)
DAT(L_MULT,     L"*",            L_MULT,         OPmult,         ML_MUL)
DAT(L_MULTEQ,   L"*=",           L_ASOP,         OPmulteq,       ML_NOTOKEN)
DAT(L_NOTEQ,    L"!=",           L_EQUOP,        OPne,           ML_NE)
DAT(L_OR,       L"|",            L_OR,           OPbor,          ML_OR)
DAT(L_OREQ,     L"|=",           L_ASOP,         OPoreq,         ML_NOTOKEN)
DAT(L_OROR,     L"||",           L_OROR,         OPorelse,       ML_NOTOKEN)
DAT(L_PERIOD,   L".",            L_STUNOP,       OPfield,        ML_PERIOD)
DAT(L_PLUS,     L"+",            L_PLUS,         OPplus,         ML_ADD)
DAT(L_PLUSEQ,   L"+=",           L_ASOP,         OPpluseq,       ML_NOTOKEN)
DAT(L_POINTSTO, L"->",           L_STUNOP,       OPfield,        ML_NOTOKEN)
DAT(L_PREDECR,  L"--",           L_INCOP,        OPminuseq,      ML_NOTOKEN)
DAT(L_PREINCR,  L"++",           L_INCOP,        OPpluseq,       ML_NOTOKEN)
DAT(L_QUEST,    L"?",            L_QUEST,        OPquestion,     ML_NOTOKEN)
DAT(L_RSHFTEQ,  L">>=",          L_ASOP,         OPrsheq,        ML_NOTOKEN)
DAT(L_RSHIFT,   L">>",           L_SHIFTOP,      OPrshift,       ML_SHR)
DAT(L_TILDE,    L"~",            L_TILDE,        OPcompl,        ML_NOT)
DAT(L_UMINUS,   L"unary minus",  L_UMINUS,       OPneg,          ML_NOTOKEN)
DAT(L_XOR,      L"^",            L_XOR,          OPxor,          ML_XOR)
DAT(L_XOREQ,    L"^=",           L_ASOP,         OPxoreq,        ML_NOTOKEN)
DAT(L_ARG,      L"argument",     L_ARG,          OPargument,     ML_NOTOKEN)
DAT(L_ASOP,     L"assign op",    L_ASOP,         MAX_OPCODE,     ML_NOTOKEN)
DAT(L_BREAK,    L"break",        L_BREAK,        MAX_OPCODE,     ML_IDENT)
DAT(L_CASE,     L"case",         L_CASE,         OPcase,         ML_IDENT)
DAT(L_CAST,     L"cast",         L_CAST,         OPcast,         ML_NOTOKEN)
DAT(L_CLASS,    L"storage class",L_CLASS,        MAX_OPCODE,     ML_IDENT)
DAT(L_CONSTANT, L"constant",     L_CONSTANT,     MAX_OPCODE,     ML_MAPPED)
DAT(L_CONTINUE, L"continue",     L_CONTINUE,     MAX_OPCODE,     ML_IDENT)
DAT(L_DEFAULT,  L"default",      L_DEFAULT,      MAX_OPCODE,     ML_IDENT)
DAT(L_DIVOP,    L"div op",       L_DIVOP,        MAX_OPCODE,     ML_MAPPED)
DAT(L_DO,       L"do",           L_DO,           MAX_OPCODE,     ML_IDENT)
DAT(L_ELLIPSIS, L"...",          L_ELLIPSIS,     MAX_OPCODE,     ML_NOTOKEN)
DAT(L_ELSE,     L"else",         L_ELSE,         MAX_OPCODE,     ML_IDENT)
DAT(L_ENTRY,    L"entry",        L_ENTRY,        OPentry,        ML_NOTOKEN)
DAT(L_EOF,      L"end of file",  0,              MAX_OPCODE,     ML_EOF)
DAT(L_EQUOP,    L"equ op",       L_EQUOP,        MAX_OPCODE,     ML_NOTOKEN)
DAT(L_FILE,     0,               L_FILE,         MAX_OPCODE,     ML_NOTOKEN)
DAT(L_FOR,      L"for",          L_FOR,          MAX_OPCODE,     ML_IDENT)
DAT(L_FUNCTION, L"argument",     L_FUNCTION,     MAX_OPCODE,     ML_NOTOKEN)
DAT(L_GOTO,     L"goto",         L_GOTO,         MAX_OPCODE,     ML_IDENT)
DAT(L_IF,       L"if",           L_IF,           MAX_OPCODE,     ML_IDENT)
DAT(L_INCOP,    L"incr op",      L_INCOP,        MAX_OPCODE,     ML_NOTOKEN)
DAT(L_INIT,     L"initializing", L_INIT,         MAX_OPCODE,     ML_NOTOKEN)
DAT(L_LCURLY,   L"{",            L_LCURLY,       MAX_OPCODE,     ML_LCURLY)
DAT(L_LINE,     L"line",         L_LINE,         MAX_OPCODE,     ML_NOTOKEN)
DAT(L_LPAREN,   L"(",            L_LPAREN,       OPfunction,     ML_LPAREN)
DAT(L_INTRINSIC,L"intrinsic",    L_INTRINSIC,    OPintrinsic,    ML_NOTOKEN)
DAT(L_MODIFIER, L"modifier",     L_MODIFIER,     MAX_OPCODE,     ML_MAPPED)
DAT(L_MODULE,   L"module",       L_MODULE,       MAX_OPCODE,     ML_NOTOKEN)
DAT(L_RBRACK,   L"]",            L_RBRACK,       MAX_OPCODE,     ML_RBRACK)
DAT(L_RCURLY,   L"}",            L_RCURLY,       MAX_OPCODE,     ML_NL)
DAT(L_RELOP,    L"rel op",       L_RELOP,        MAX_OPCODE,     ML_MAPPED)
DAT(L_RETURN,   L"return",       L_RETURN,       MAX_OPCODE,     ML_IDENT)
DAT(L_RPAREN,   L")",            L_RPAREN,       MAX_OPCODE,     ML_RPAREN)
DAT(L_SELF,     L"_self",        L_SELF,         OPself,         ML_IDENT)
DAT(L_SEMI,     L";",            L_SEMI,         MAX_OPCODE,     ML_SEMI)
DAT(L_SHIFTOP,  L"shift op",     L_SHIFTOP,      MAX_OPCODE,     ML_MAPPED)
DAT(L_SIZEOF,   L"sizeof",       L_SIZEOF,       MAX_OPCODE,     ML_IDENT)
DAT(L_STUNOP,   L"struct op",    L_STUNOP,       MAX_OPCODE,     ML_MAPPED)
DAT(L_SW,       L"switch",       L_SW,           OPswitch,       ML_IDENT)
DAT(L_SWEXP,    0,               L_SWEXP,        OPswexp,        ML_NOTOKEN)
DAT(L_TYPE,     L"type",         L_TYPE,         MAX_OPCODE,     ML_MAPPED)
DAT(L_TYPENAME, L"typedef name", L_TYPENAME,     MAX_OPCODE,     ML_CTYPENAME)
DAT(L_UPLUS,    L"unary plus",   L_UPLUS,        OPparen,        ML_NOTOKEN)
DAT(L_WHILE,    L"while",        L_WHILE,        MAX_OPCODE,     ML_IDENT)
DAT(0,          0,               0,              MAX_OPCODE,     ML_NOTOKEN)

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\readline\readline.c ===
/* readline.c */

#define MAXLINESIZE 256

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>
#include <conio.h>

#define LF    0x0a
#define CR    0x0d

__cdecl main (argc, argv)
int argc;
char *argv[];
{
    char line[MAXLINESIZE];
    char *prompt = "";
    char *formats = "%s\n";
    char *formatc = "%c\n";
    char inputchar;
    FILE *file = stdout;
    int argcount = 0;
    int getline = 1;

    while (++argcount < argc) {
        if (!(_stricmp(argv[argcount], "-p"))) {
            if (++argcount != argc) {
                prompt = argv[argcount];
            }
        } else if (!(_stricmp(argv[argcount], "-f"))) {
            if (++argcount != argc) {
                if ((file = fopen(argv[argcount], "a")) == NULL) {
                    printf("Could not open %s\n", argv[argcount]);
                    exit(1);
                }
            }
        } else if (!(_stricmp(argv[argcount], "-t"))) {
            if (++argcount != argc) {
                formats = argv[argcount];
            }
        } else if (!(_stricmp(argv[argcount], "-c"))) {
                getline = 0;
        } else {
            printf("usage: readline [-c] [-p prompt] [-f file] [-t formats]\n");
            exit(2);
        }
    }

    printf("%s", prompt);

    if (getline == 1)
        gets(line);
    else {
        inputchar = (char)_getch();
        _putch(inputchar);
        _putch(LF);
        _putch(CR);
    }

    if (getline == 1)
        fprintf(file, formats, line);
    else
        fprintf(file, formatc, inputchar);

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\rcdll\trees.h ===
/*
**      Tree types
*/
#define TTfree                  0x0
#define TTconstant              0x01
#define TTsymbol                0x02
#define TTunary                 0x04
#define TTleaf                  0x08
#define TTbinary                0x10
#define TThybrid                0x20
#define TTBasicShape    (TTfree|TTconstant|TTsymbol|TTunary|TTbinary|TThybrid)
#define TTzero                  0x40

typedef USHORT          p2type_t;
typedef p2type_t        *pp2type_t;

typedef struct  tree_200        {
        ptree_t         tr_left;        /*  left child  */
        ptree_t         tr_right;       /*  right child  */
        } tree_200_st;

typedef struct  tree_190        {
        ptree_t         tr_uchild;      /*  unary child  */
        } tree_190_st;

typedef struct  tree_180        {
        psym_t          tr_symbol;      /*  symbol  */
        } tree_180_st;

typedef struct  tree_170        {
        value_t         tr_value;       /*  value of the tree  */
        } tree_170_st;

typedef union   tree_100        {
        tree_200_st     t200;
        tree_190_st     t190;
        tree_180_st     t180;
        tree_170_st     t170;
        } tree_100_st;

struct  s_tree  {
        token_t         tr_token;       /*  tree's token  */
        shape_t         tr_shape;       /*  tree shape  */
        ptype_t         tr_p1type;      /*  p1's view of the type  */
        p2type_t        tr_p2type;      /*  p1's view of the type p2 should have */
        tree_100_st     t100;
        };

#define TR_SHAPE(P)     ((P)->tr_shape)
#define BASIC_SHAPE(S)  ((S) & TTBasicShape)
#define TR_TOKEN(P)     ((P)->tr_token)
#define TR_P1TYPE(P)    ((P)->tr_p1type)                /*  resultant type  */
#define TR_P2TYPE(P)    ((P)->tr_p2type)                /*  resultant type  */
#define TR_ISZERO(P)    (TR_SHAPE(P) & TTzero)

#define TR_LEFT(P)      ((P)->t100.t200.tr_left)        /*  left child  */
#define TR_RIGHT(P)     ((P)->t100.t200.tr_right)       /*  right child  */
#define TR_UCHILD(P)    ((P)->t100.t190.tr_uchild)      /*  unary's child */
#define TR_SVALUE(P)    ((P)->t100.t180.tr_symbol)      /*  ptr to the symbol */
#define TR_VALUE(P)     ((P)->t100.t170.tr_value)       /*  value of tree  */

#define TR_RCON(P)      (TR_VALUE(P).v_rcon)            /*  real constant  */
#define TR_DVALUE(P)    (TR_RCON(P)->rcon_real) /*  double value  */
#define TR_LVALUE(P)    (TR_VALUE(P).v_long)            /*  long value  */
#define TR_STRING(P)    (TR_VALUE(P).v_string)  /*  string value  */

#define TR_CVALUE(P)    (TR_STRING(P).str_ptr)  /*  ptr to string  */
#define TR_CLEN(P)      (TR_STRING(P).str_len)  /*  length of string  */

#define TR_BTYPE(P)     (TY_BTYPE(TR_P1TYPE(P)))/*  base type  */
#define TR_ESU(P)       (TY_ESU(TR_P1TYPE(P)))  /*  parent enum/struct/union  */
#define TR_INDIR(P)     (TY_INDIR(TR_P1TYPE(P)))

#define TR_INEXT(P)     (INDIR_INEXT(TR_INDIR(P)))
#define TR_ITYPE(P)     (INDIR_ITYPE(TR_INDIR(P)))
#define TR_ISUB(P)      (INDIR_ISUB(TR_INDIR(P)))
#define TR_IFORMALS(P)  (INDIR_IFORMALS(TR_INDIR(P)))
/*
**  for cases
*/
struct  s_case  {
        case_t  *c_next;        /*  next in list  */
        long    c_expr;         /*  value of constant expression  */
        p1key_t c_label;        /*  label to which to jump if expr  */
        };

#define NEXT_CASE(p)    ((p)->c_next)
#define CASE_EXPR(p)    ((p)->c_expr)
#define CASE_LABEL(p)   ((p)->c_label)

/*
**  loop inversion structs
**  for( init; test; incr ) { ... }
**  we handle : sym | const relop sym | const; sym op sym | const
*/
typedef struct  s_loopia         loopia_t, *loopiap_t;
typedef struct  s_liarray        liarray_t, *liarrayp_t;

struct  s_loopia        {
        token_t         lia_token;
        union   {
                psym_t          lia_sym;
                long            lia_value;
                liarrayp_t      lia_array;
                } lia_union;
        };

#define LIA_TOKEN(p)    ((p)->lia_token)
#define LIA_SYM(p)      ((p)->lia_union.lia_sym)
#define LIA_VALUE(p)    ((p)->lia_union.lia_value)
#define LIA_ARRAY(p)    ((p)->lia_union.lia_array)

typedef struct  s_liarray       {
        loopia_t        liar_left;
        loopia_t        liar_right;
        } liarray;

#define LIAR_LEFT(p)    (&((p)->liar_left))
#define LIAR_RIGHT(p)   (&((p)->liar_right))

typedef struct  s_loopi {
        int             li_relop;
        int             li_incop;
        loopia_t        li_w;
        loopia_t        li_x;
        loopia_t        li_y;
        loopia_t        li_z;
        } loopi_t, *loopip_t;

#define LOOP_RELOP(p)   ((p)->li_relop)
#define LOOP_INCOP(p)   ((p)->li_incop)

#define LOOP_W(p)       (&((p)->li_w))
#define LOOP_X(p)       (&((p)->li_x))
#define LOOP_Y(p)       (&((p)->li_y))
#define LOOP_Z(p)       (&((p)->li_z))

#define LOOP_W_TOKEN(p) LIA_TOKEN(LOOP_W(p))
#define LOOP_X_TOKEN(p) LIA_TOKEN(LOOP_X(p))
#define LOOP_Y_TOKEN(p) LIA_TOKEN(LOOP_Y(p))
#define LOOP_Z_TOKEN(p) LIA_TOKEN(LOOP_Z(p))

#define LOOP_W_SYM(p)   LIA_SYM(LOOP_W(p))
#define LOOP_X_SYM(p)   LIA_SYM(LOOP_X(p))
#define LOOP_Y_SYM(p)   LIA_SYM(LOOP_Y(p))
#define LOOP_Z_SYM(p)   LIA_SYM(LOOP_Z(p))

#define LOOP_W_VALUE(p) LIA_VALUE(LOOP_W(p))
#define LOOP_X_VALUE(p) LIA_VALUE(LOOP_X(p))
#define LOOP_Y_VALUE(p) LIA_VALUE(LOOP_Y(p))
#define LOOP_Z_VALUE(p) LIA_VALUE(LOOP_Z(p))
/*
**      stack structure for saving items which must be stacked at various places
*/
struct  s_stack {
        stack_t *stk_next;
        union   {
                ptree_t         sv_tree;
                psym_t          sv_sym;
                int             sv_int;
                loopip_t        sv_loopi;
                } stk_value;
        };

#define TEST_LAB                (Test->stk_value.sv_tree)
#define START_LAB               (Start->stk_value.sv_tree)
#define CONTINUE_LAB            (Continue->stk_value.sv_tree)
#define BREAK_LAB               (Break->stk_value.sv_tree)
#define CA_LAB                  (Case->stk_value.sv_tree)
#define DEFAULT_LAB             (Default->stk_value.sv_tree)

#define LOOPI(p)                ((p)->stk_value.sv_loopi)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\rcdump\rcdump.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    rcdump.c

Abstract:

    Program to dump the resources from an image file.

Author:

    Steve Wood (stevewo) 17-Jul-1991

Revision History:

--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

void
Usage( void );

void
DumpResources( char *FileName );


BOOL VerboseOutput;

int
__cdecl
main(
    int argc,
    char *argv[]
    )
{
    char *s;
    int i;

    VerboseOutput = FALSE;
    if (argc > 1) {
        for (i=1; i<argc; i++) {
            s = _strupr( argv[i] );
            if (*s == '-' || *s == '/') {
                while (*++s)
                    switch( *s ) {
                    case 'V':
                        VerboseOutput = TRUE;
                        break;

                    default:
                        fprintf( stderr,
                                 "RCDUMP: Invalid switch letter '%c'\n",
                                 *s
                               );
                        Usage();
                    }
                }
            else {
                DumpResources( argv[i] );
                }
            }
        }
    else {
        Usage();
        }

    exit( 0 );
    return 1;
}


void
Usage( void )
{
    fprintf( stderr, "usage: RCDUMP [-v] ImageFileName(s)\n" );
    exit( 1 );
}

BOOL
EnumTypesFunc(
    HMODULE hModule,
    LPSTR lpType,
    LPARAM lParam
    );

BOOL
EnumNamesFunc(
    HMODULE hModule,
    LPCSTR lpType,
    LPSTR lpName,
    LPARAM lParam
    );

BOOL
EnumLangsFunc(
    HMODULE hModule,
    LPCSTR lpType,
    LPCSTR lpName,
    WORD language,
    LPARAM lParam
    );


void
DumpResources(
    char *FileName
    )
{
    HMODULE hModule;

    if (FileName != NULL) {
        int i;
        i = SetErrorMode(SEM_FAILCRITICALERRORS);
        hModule = LoadLibraryEx( FileName, NULL, DONT_RESOLVE_DLL_REFERENCES|LOAD_LIBRARY_AS_DATAFILE );
        SetErrorMode(i);
    } else {
        hModule = NULL;
    }

    if (FileName != NULL && hModule == NULL) {
        printf( "RCDUMP: Unable to load image file %s - rc == %u\n",
                FileName,
                GetLastError()
              );
    } else {
        printf( "%s contains the following resources:\n",
                FileName ? FileName : "RCDUMP"
              );
        EnumResourceTypes( hModule, EnumTypesFunc, -1L );
    }
}


CHAR const *pTypeName[] = {
    NULL,           //  0
    "CURSOR",       //  1 RT_CURSOR
    "BITMAP",       //  2 RT_BITMAP
    "ICON",         //  3 RT_ICON
    "MENU",         //  4 RT_MENU
    "DIALOG",       //  5 RT_DIALOG
    "STRING",       //  6 RT_STRING
    "FONTDIR",      //  7 RT_FONTDIR
    "FONT",         //  8 RT_FONT
    "ACCELERATOR",  //  9 RT_ACCELERATOR
    "RCDATA",       // 10 RT_RCDATA
    "MESSAGETABLE", // 11 RT_MESSAGETABLE
    "GROUP_CURSOR", // 12 RT_GROUP_CURSOR
    NULL,           // 13 RT_NEWBITMAP -- according to NT
    "GROUP_ICON",   // 14 RT_GROUP_ICON
    NULL,           // 15 RT_NAMETABLE
    "VERSION",      // 16 RT_VERSION
    "DIALOGEX",     // 17 RT_DIALOGEX     ;internal
    "DLGINCLUDE",   // 18 RT_DLGINCLUDE
    "PLUGPLAY",     // 19 RT_PLUGPLAY
    "VXD",          // 20 RT_VXD
    "ANICURSOR",    // 21 RT_ANICURSOR    ;internal
    "ANIICON",      // 22 RT_ANIICON      ;internal
    "HTML"          // 23 RT_HTML
    };

BOOL
EnumTypesFunc(
    HMODULE hModule,
    LPSTR lpType,
    LPARAM lParam
    )
{
    if (lParam != -1L) {
        printf( "RCDUMP: EnumTypesFunc lParam value incorrect (%ld)\n", lParam );
    }

    printf( "Type: " );
    if ((ULONG_PTR)lpType & 0xFFFF0000) {
        printf("%s\n", lpType);
        }
    else {
        WORD wType = (WORD) lpType;

        if ((wType > sizeof(pTypeName) / sizeof(char *)) || (pTypeName[wType] == NULL))
            printf("%u\n", wType);
        else
            printf("%s\n", pTypeName[wType]);
        }

    EnumResourceNames( hModule,
                       lpType,
                       EnumNamesFunc,
                       -2L
                     );

    return TRUE;
}


BOOL
EnumNamesFunc(
    HMODULE hModule,
    LPCSTR lpType,
    LPSTR lpName,
    LPARAM lParam
    )
{
    if (lParam != -2L) {
        printf( "RCDUMP: EnumNamesFunc lParam value incorrect (%ld)\n", lParam );
    }

    printf( "    Name: " );
    if ((ULONG_PTR)lpName & 0xFFFF0000) {
        printf("%s\n", lpName);
    } else {
        printf( "%u\n", (USHORT)lpName );
    }

    EnumResourceLanguages( hModule,
                       lpType,
                       lpName,
                       EnumLangsFunc,
                       -3L
                     );
    return TRUE;
}


BOOL
EnumLangsFunc(
    HMODULE hModule,
    LPCSTR lpType,
    LPCSTR lpName,
    WORD language,
    LPARAM lParam
    )
{
    HRSRC hResInfo;
    PVOID pv;
    HGLOBAL hr;

    if (lParam != -3L) {
        printf( "RCDUMP: EnumLangsFunc lParam value incorrect (%ld)\n", lParam );
    }

    printf( "        Resource: " );
    if ((ULONG_PTR)lpName & 0xFFFF0000) {
        printf( "%s . ", lpName );
    } else {
        printf( "%u . ", (USHORT)lpName );
    }

    if ((ULONG_PTR)lpType & 0xFFFF0000) {
        printf("%s . ", lpType );
        }
    else {
        WORD wType = (WORD) lpType;

        if ((wType > sizeof(pTypeName) / sizeof(char *)) || (pTypeName[wType] == NULL))
            printf("%u\n", wType);
        else
            printf("%s\n", pTypeName[wType]);
        }

    printf( "%08x", language );
    hResInfo = FindResourceEx( hModule, lpType, lpName, language );
    if (hResInfo == NULL) {
        printf( " - FindResourceEx failed, rc == %u\n", GetLastError() );
    } else {
        hr = LoadResource(hModule, hResInfo);
        pv = LockResource(hr);

        if (VerboseOutput && pv) {
            if (lpType == RT_MESSAGETABLE) {
                PMESSAGE_RESOURCE_DATA pmrd;
                PMESSAGE_RESOURCE_BLOCK pmrb;
                PMESSAGE_RESOURCE_ENTRY pmre;
                ULONG i, j;
                ULONG cb;

                printf("\n");
                pmrd = (PMESSAGE_RESOURCE_DATA) pv;
                pmrb = &(pmrd->Blocks[0]);
                for (i=pmrd->NumberOfBlocks ; i>0 ; i--,pmrb++) {
                    pmre = (PMESSAGE_RESOURCE_ENTRY)(((char*)pv)+pmrb->OffsetToEntries);
                    for (j=pmrb->LowId ; j<=pmrb->HighId ; j++) {
                        if (pmre->Flags & MESSAGE_RESOURCE_UNICODE) {
                            printf("%d - \"%ws\"\n", j, &(pmre->Text));
                        } else {
                            printf("%d - \"%s\"\n", j, &(pmre->Text));
                        }
                        pmre = (PMESSAGE_RESOURCE_ENTRY)(((char*)pmre) + pmre->Length);
                    }
                }
            } else
            if (lpType == RT_STRING) {
                int i;
                PWCHAR pw;

                printf("\n");
                pw = (PWCHAR) pv;
                for (i=0 ; i<16 ; i++,pw++) {
                    if (*pw) {
                        printf("%d - \"%-.*ws\"\n", i+((USHORT)lpName)*16, *pw, pw+1);
                        pw += *pw;
                    }
                }
            } else {
                printf( " - hResInfo == %p,\n\t\tAddress == %p - Size == %lu\n",
                    hResInfo, pv, SizeofResource( hModule, hResInfo )
                      );
            }
        } else {
            printf( " - hResInfo == %p,\n\t\tAddress == %p - Size == %lu\n",
                hResInfo,
                pv, SizeofResource( hModule, hResInfo )

              );
        }
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\reducer\reducer.c ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    reducer.c

Abstract:

    Trace Reducer Tool

Author:

    08-Apr-1998 mraghu

Revision History:

--*/

#ifdef __cplusplus
extern "C"{
#endif

#define _UNICODE
#define UNICODE

#include <stdlib.h>
#include <stdio.h>
#include <windows.h>
#include <shellapi.h>
#include <tchar.h>

#include "pdhp.h"

#define MAXSTR       1024
#define MAXLOGFILES    16
#define MAX_BUFFER_SIZE     1048576

#if DBG
ULONG ETAAPITestFlag = 1;

VOID
TestETAApis(
    PTRACE_BASIC_INFO TraceBasicInfo
    );

#endif

void ReducerUsage()
{
    printf("Usage: reducer [Options] <EtlFile1 EtlFile2 ...> | [-h | -help | -?]\n");
    printf("\t-out <filename> Output file name. Default is Workload.txt\n");
    printf("\t-h        \n");
    printf("\t-help        \n");
    printf("\t-?     Display usage information\n");

//    printf("\t-start <time-stamp>        Start Time\n");
//    printf("\t-end   <time-stamp>        End Time\n");
//    printf("\t       <time-stamp> can be found in tracedmp result\n");
//    printf("\n");
//    printf("\t-base                      Original reducer report (default report)\n");
//    printf("\t-file                      Hot File Report\n");
//    printf("\t-pf                        page fault report\n");
//    printf("\t    -summary processes     summary of faults per process (default PF report).\n");
//    printf("\t             modules       summary of faults per module.\n");
//    printf("\t    -process <image name>  rundown for specific process.\n");
//    printf("\t             all\n");
//    printf("\t    -module  <module name> rundown for specific modules.\n");
//    printf("\t             all\n");
//    printf("\t    -sort    ALL           sort by all fault total.\n");
//    printf("\t             HPF           sort by HPF fault total.\n");
//    printf("\t             TF            sort by TF  fault total.\n");
//    printf("\t             DZF           sort by DZF fault total.\n");
//    printf("\t             COW           sort by COW fault total.\n");
//    printf("\n");
//    printf("\tNote: (1) Cannot generate HotFile Report and PageFault Report\n");
//    printf("\t          at the same time\n");
//    printf("\t0x%08X,%d,\n", STATUS_SEVERITY_WARNING, RtlNtStatusToDosError(STATUS_SEVERITY_WARNING));
}

ULONGLONG
ParseTimeString(TCHAR * strTime)
{
#if 0
    CHAR          lstrTime[25];
    PCHAR         strYear, strMonth, strDate,
                  strHour, strMinute, strSecond, strMilliSecond;
    LARGE_INTEGER largeTime;
    FILETIME      localTime, stdTime;
    SYSTEMTIME    sysTime;

    if (strTime == NULL)
        return (ULONGLONG) 0;

    strcpy(lstrTime, strTime);

    strMonth = lstrTime;
    for (strDate = strMonth;
         *strDate && *strDate >= '0' && *strDate <= '9';
         strDate ++);
    *strDate = '\0';
    strDate ++;

    for (strYear = strDate;
         *strYear && *strYear >= '0' && *strYear <= '9';
         strYear ++);
    *strYear = '\0';
    strYear ++;

    for (strHour = strYear;
         *strHour && *strHour >= '0' && *strHour <= '9';
         strHour ++);
    *strHour = '\0';
    strHour ++;

    for (strMinute = strHour;
         *strMinute && *strMinute >= '0' && *strMinute <= '9';
         strMinute ++);
    *strMinute = '\0';
    strMinute ++;

    for (strSecond = strMinute;
         *strSecond && *strSecond >= '0' && *strSecond <= '9';
         strSecond ++);
    *strSecond = '\0';
    strSecond ++;

    for (strMilliSecond = strSecond;
         *strMilliSecond && *strMilliSecond >= '0' && *strMilliSecond <= '9';
         strMilliSecond ++);
    *strMilliSecond = '\0';
    strMilliSecond ++;

    sysTime.wYear         = atoi(strYear);
    sysTime.wMonth        = atoi(strMonth);
    sysTime.wDay          = atoi(strDate);
    sysTime.wHour         = atoi(strHour);
    sysTime.wMinute       = atoi(strMinute);
    sysTime.wSecond       = atoi(strSecond);
    sysTime.wMilliseconds = atoi(strMilliSecond);

    SystemTimeToFileTime(&sysTime, &localTime);
    LocalFileTimeToFileTime(&localTime, &stdTime);
    largeTime.HighPart = stdTime.dwHighDateTime;
    largeTime.LowPart  = stdTime.dwLowDateTime;
    return (ULONGLONG) largeTime.QuadPart;
#else
    ULONGLONG TimeStamp = 0;
    ULONG     i = 0;

    for (i = 0; strTime[i] != '\0'; i ++)
    {
        TimeStamp = TimeStamp * 10 + (strTime[i] - '0');
    }

    return TimeStamp;
#endif
}

VOID
ProcessTrace(
    IN ULONG      LogFileCount,
    IN LPCTSTR   * LogFileName,
    IN ULONGLONG  StartTime,
    IN ULONGLONG  EndTime,
    IN ULONGLONG  DSStartTime,
    IN ULONGLONG  DSEndTime,
    IN ULONG      MoreFlags,
    IN PVOID      pUserContext,
    IN LPCTSTR      pOutFileName
    )
{
    // Call TraceLib and process it. 
    //
    TRACE_BASIC_INFO TraceBasicInfo;

    memset(&TraceBasicInfo, 0, sizeof(TRACE_BASIC_INFO));
    TraceBasicInfo.Flags        = TRACE_REDUCE | MoreFlags;
    TraceBasicInfo.LogFileName  = LogFileName; 
    TraceBasicInfo.LogFileCount = LogFileCount;
    TraceBasicInfo.pUserContext = pUserContext;
    TraceBasicInfo.StartTime    = StartTime;
    TraceBasicInfo.EndTime      = EndTime;
    TraceBasicInfo.DSStartTime  = DSStartTime;
    TraceBasicInfo.DSEndTime    = DSEndTime;

    TraceBasicInfo.ProcFileName = pOutFileName;
    InitTraceContext(&TraceBasicInfo);

#if DBG
    if (ETAAPITestFlag) {
        TestETAApis( & TraceBasicInfo );
    }

#endif


    DeinitTraceContext(&TraceBasicInfo);
}
    
int __cdecl main(int argc ,char * argv[])
{
    WCHAR     TraceLogFile[MAXSTR];
    WCHAR    PerfLogFile[MAXSTR];
    BOOLEAN  bTrace  = FALSE;
    LPTSTR   EvmFile[MAXLOGFILES];
    ULONGLONG StartTime = 0, EndTime = 0;
    ULONG    i;
    ULONG    LogFileCount = 0;
    LPTSTR *targv;
#ifdef UNICODE
    LPTSTR *cmdargv;
#endif

    ULONG               flagsMore    = 0;
    PVOID               pUserContext = NULL;
    CPD_USER_CONTEXT_MM UserContextMM;


#ifdef UNICODE
    if ((cmdargv = CommandLineToArgvW(
                        GetCommandLineW(),  // pointer to a command-line string
                        &argc               // receives the argument count
                        )) == NULL)
    {
        return(GetLastError());
    };
    targv = cmdargv ;
#else
    targv = argv;
#endif

    UserContextMM.reportNow  = REPORT_SUMMARY_PROCESS;
    UserContextMM.sortNow    = REPORT_SORT_ALL;
    UserContextMM.strImgName = NULL;
    memset(&TraceLogFile, 0, sizeof(WCHAR) * MAXSTR); 

    while (--argc > 0)
    {
        ++targv;
        if (**targv == '-' || **targv == '/')
        { 
            ** targv = '-';
            if (!_tcsicmp(targv[0], _T("-out")))
            {
                if (argc > 1)
                {
                    TCHAR TempStr[MAXSTR];

                    _tcscpy(TempStr, targv[1]);
                    ++targv; --argc;
                    _tfullpath(TraceLogFile, TempStr, MAXSTR);
                    printf("Setting output file to: '%ws'\n", TraceLogFile);
                    bTrace = TRUE;
                }
            }
            else if (!_tcsicmp(targv[0], _T("-start")))
            {
                if (argc > 1)
                {
                    flagsMore |= TRACE_DS_ONLY | TRACE_LOG_REPORT_BASIC;
                    StartTime  = ParseTimeString(targv[1]);
                    argc --; targv ++;
                }
            }
            else if (!_tcsicmp(targv[0], _T("-end")))
            {
                if (argc > 1)
                {
                    flagsMore |= TRACE_DS_ONLY | TRACE_LOG_REPORT_BASIC;
                    EndTime    = ParseTimeString(targv[1]);
                    argc --; targv ++;
                }
            }
            else if (!_tcsicmp(targv[0], _T("-base")))
            {
                flagsMore   |= TRACE_LOG_REPORT_BASIC;
            }
            else if (!_tcsicmp(targv[0], _T("-spooler")))
            {
                flagsMore   |= TRACE_LOG_REPORT_BASIC;
                flagsMore   |= TRACE_SPOOLER;
            }
            else if (!_tcsicmp(targv[0], _T("-total")))
            {
                flagsMore   |= TRACE_LOG_REPORT_TOTALS;
            }
            else if (!_tcsicmp(targv[0], _T("-file")))
            {
                flagsMore   |= TRACE_LOG_REPORT_FILE;
/*                if (argc > 1 && targv[1][0] >= '0' && targv[1][0] <= '9')
                {
                    pUserContext = UlongToPtr(atoi(targv[1]));
                    argc --; targv ++;
                }
                else
                {
                    pUserContext = UlongToPtr(DEFAULT_FILE_REPORT_SIZE);
                }
*/
            }
            else if (!_tcsicmp(targv[0], _T("-hpf")))
            {
                flagsMore   |= TRACE_LOG_REPORT_HARDFAULT;
            }
            else if (!_tcsicmp(targv[0], _T("-pf")))
            {
                flagsMore   |= TRACE_LOG_REPORT_MEMORY;
                pUserContext = (PVOID) & UserContextMM;
            }
            else if (!_tcsicmp(targv[0], _T("-summary")))
            {
                if (argc > 1)
                {
                    flagsMore   |= TRACE_LOG_REPORT_MEMORY;
                    pUserContext = (PVOID) & UserContextMM;

                    if (!_tcsicmp(targv[1], _T("processes")))
                    {
                        argc --; targv ++;
                        UserContextMM.reportNow = REPORT_SUMMARY_PROCESS;
                    }
                    else if (!_tcsicmp(targv[1], _T("modules")))
                    {
                        argc --; targv ++;
                        UserContextMM.reportNow = REPORT_SUMMARY_MODULE;
                    }
                }
            }

            else if (!_tcsicmp(targv[0], _T("-process")))
            {
                flagsMore   |= TRACE_LOG_REPORT_MEMORY;
                pUserContext = (PVOID) & UserContextMM;
                UserContextMM.reportNow = REPORT_LIST_PROCESS;

                if ((argc > 1) && (targv[1][0] != '-' || targv[1][0] != '/'))
                {
                    if (_tcsicmp(targv[1], _T("all")))
                    {
                        UserContextMM.strImgName =
                                malloc(sizeof(TCHAR) * (_tcslen(targv[1]) + 1));
                        if (UserContextMM.strImgName)
                        {
                            _tcscpy(UserContextMM.strImgName, targv[1]);
                        }
                    }
                    argc --; targv ++;
                }
            }
            else if (!_tcsicmp(targv[0], _T("-module")))
            {
                flagsMore   |= TRACE_LOG_REPORT_MEMORY;
                pUserContext = (PVOID) & UserContextMM;
                UserContextMM.reportNow = REPORT_LIST_MODULE;

                if ((argc > 1) && (targv[1][0] != '-' || targv[1][0] != '/'))
                {
                    if (_tcsicmp(targv[1], _T("all")))
                    {
                        UserContextMM.strImgName =
                                malloc(sizeof(TCHAR) * (_tcslen(targv[1]) + 1));
                        if (UserContextMM.strImgName)
                        {
                            _tcscpy(UserContextMM.strImgName, targv[1]);
                        }
                    }
                    argc --; targv ++;
                }
            }

            else if (!_tcsicmp(targv[0], _T("-sort")))
            {
                flagsMore   |= TRACE_LOG_REPORT_MEMORY;
                pUserContext = (PVOID) & UserContextMM;
 
                if ((argc > 1) && (targv[1][0] != '-' || targv[1][0] != '/'))
                {
                    if (!_tcsicmp(targv[1], _T("hpf")))
                    {
                        UserContextMM.sortNow = REPORT_SORT_HPF;
                    }
                    else if (!_tcsicmp(targv[1], _T("tf")))
                    {
                        UserContextMM.sortNow = REPORT_SORT_TF;
                    }
                    else if (!_tcsicmp(targv[1], _T("dzf")))
                    {
                        UserContextMM.sortNow = REPORT_SORT_DZF;
                    }
                    else if (!_tcsicmp(targv[1], _T("cow")))
                    {
                        UserContextMM.sortNow = REPORT_SORT_COW;
                    }
                    else
                    {
                        UserContextMM.sortNow = REPORT_SORT_ALL;
                    }
                    argc --; targv ++;
                }
            }
            else
            {
                goto Usage;
            }
        }
        else
        {
            LPTSTR pLogFile;

            pLogFile = malloc(sizeof(TCHAR) * MAXSTR);
            RtlZeroMemory((char *) pLogFile, sizeof(TCHAR) * MAXSTR);
            EvmFile[LogFileCount] = pLogFile;
            _tcscpy(EvmFile[LogFileCount ++], targv[0]);
            bTrace = TRUE;

            printf("LogFile %ws\n", (char *) EvmFile[LogFileCount - 1]);
        }
    }

    if (LogFileCount == 0)
    {
        goto Usage;
    }

    if (flagsMore == 0)
    {
        flagsMore |= TRACE_LOG_REPORT_BASIC;
    }

    if (   (flagsMore & TRACE_LOG_REPORT_MEMORY)
        && (flagsMore & TRACE_LOG_REPORT_FILE))
    {
        printf("Error: cannot generate HotFile report and PageFault report at the same time.\n");
        goto Cleanup;
    }

    if (bTrace)
    {
        ProcessTrace(LogFileCount, EvmFile, (ULONGLONG) 0, (ULONGLONG) 0,
                StartTime, EndTime, flagsMore, pUserContext, TraceLogFile);
    }

    for (i=0; i < LogFileCount; i++) 
    {
        free((char*)EvmFile[i]);
    }

    if (UserContextMM.strImgName)
    {
        free(UserContextMM.strImgName);
    }

Cleanup:
#ifdef UNICODE
    GlobalFree(cmdargv);
#endif
    return 0;

Usage:
    ReducerUsage();
    goto Cleanup;
}


#if DBG

VOID
PrintHeader(
    FILE* f,
    TRACEINFOCLASS CurrentClass,
    TRACEINFOCLASS RootClass,
    BOOLEAN bDrillDown,
    LPCWSTR InstanceName
    )
{


    if (bDrillDown) {
        fprintf(f, "-------------------------------------------\n");
        fprintf(f, "RootClass: %d  Instance %ws\n", RootClass, InstanceName);
        fprintf(f, "-------------------------------------------\n");
    }


    switch(CurrentClass) {

        case TraceProcessInformation:

            fprintf(f, "Trace Process Information\n");
            fprintf(f, "------------------------\n");
            fprintf(f, "\nPID     Name       Image                     UCpu  KCpu  ReadIO   WriteIO\n\n");
            break;

        case TraceDiskInformation:
            fprintf(f, "Trace Disk Information\n");
            fprintf(f, "----------------------\n");
            fprintf(f, "\nDiskId   Name  ReadIO   WriteIO\n\n");
            break;

        case TraceThreadInformation: 
            fprintf(f, "Trace Thread Information\n");
            fprintf(f, "------------------------\n");
            fprintf(f, "\nTID   PID   UCpu   KCpu   ReadIO   WriteIO  \n\n");
            break;
        case TraceFileInformation:
            fprintf(f, "Trace File Information\n");
            fprintf(f, "------------------------\n");
            fprintf(f, "\nFileName                      ReadIO   WriteIO  \n\n");
            break;

    }
    
}


VOID
PrintProcessInfo(
    FILE* f,
    PTRACE_PROCESS_INFO pProcessInfo
    )
{
    fprintf(f, "%4d   %-10ws  %-10ws    %5d  %5d   %5d   %5d\n", 
            pProcessInfo->PID,
            pProcessInfo->UserName,
            pProcessInfo->ImageName,
            pProcessInfo->UserCPU,
            pProcessInfo->KernelCPU,
            pProcessInfo->ReadCount,
            pProcessInfo->WriteCount);
}

VOID
PrintThreadInfo(
    FILE* f,
    PTRACE_THREAD_INFO pThreadInfo
    )
{
    fprintf(f, "%4x  \n", pThreadInfo->ThreadId);

}

VOID
PrintDiskInfo(
    FILE* f,
    PTRACE_DISK_INFO pDiskInfo
    )
{
    fprintf(f, "%d         %-10ws    %5d     %5d \n",
            pDiskInfo->DiskNumber,
            pDiskInfo->DiskName,
            pDiskInfo->ReadCount,
            pDiskInfo->WriteCount);
}


VOID
PrintFileInfo(
        FILE* f,
        PTRACE_FILE_INFO pFileInfo
        )
{
    fprintf(f, "%ws                    %5d     %5d\n", 
            pFileInfo->FileName,
            pFileInfo->ReadCount,
            pFileInfo->WriteCount
            );
}


VOID
TestETAApis(
    PTRACE_BASIC_INFO TraceBasicInfo
    )
{
    ULONG Status;
    ULONG OutLength;
    PTRACE_PROCESS_INFO pProcessInfo;
    PTRACE_DISK_INFO pDiskInfo;
    PTRACE_FILE_INFO pFileInfo;
    PTRACE_THREAD_INFO pThreadInfo;
    char*  LargeBuffer1;
    ULONG CurrentBufferSize;
    BOOLEAN Done, FinshPrinting, bDrillDown;
    TRACEINFOCLASS CurrentClass, RootClass;
    ULONG TotalOffset;
    FILE* f;
    int i = 0;
    LPWSTR InstanceName;
    WCHAR Name[MAXSTR+1];

    InstanceName = (LPWSTR)&Name;

    LargeBuffer1 = VirtualAlloc(NULL,
                                MAX_BUFFER_SIZE,
                                MEM_RESERVE,
                                PAGE_READWRITE);

    if (LargeBuffer1 == NULL) {
        return;
    }
    CurrentBufferSize = 10*8192;

    if (VirtualAlloc(LargeBuffer1,
                    81920,
                    MEM_COMMIT,
                    PAGE_READWRITE) == NULL) {
        return;
    }


    f = _wfopen(L"TraceAPI.rpt", L"w");

    if (f == NULL) {
        VirtualFree(LargeBuffer1, 0, MEM_RELEASE);
        return;
    }

    CurrentClass = TraceProcessInformation;
    RootClass = TraceProcessInformation;
    Done = FALSE;
    bDrillDown = FALSE;

    while (!Done) {

Retry1:
        if (!bDrillDown) {

            Status = TraceQueryAllInstances(
                            CurrentClass,
                            LargeBuffer1,
                            CurrentBufferSize,
                            &OutLength);
        }
        else {
            Status = TraceDrillDown(
                            RootClass,
                            InstanceName,
                            CurrentClass,
                            LargeBuffer1,
                            CurrentBufferSize,
                            &OutLength
                            );
        }
    
        if (Status == ERROR_MORE_DATA) {
            CurrentBufferSize += OutLength;
            if (VirtualAlloc(LargeBuffer1,
                             CurrentBufferSize,
                             MEM_COMMIT,
                             PAGE_READWRITE) == NULL) {
                 return;
            }
            goto Retry1;
        }

        if (Status != ERROR_SUCCESS) {
            Done = TRUE;
            break;
        }

        //
        // Print Header
        //
        PrintHeader(f, CurrentClass, RootClass, bDrillDown, InstanceName);

        //
        // Walk the Process List and Print report. 
        //

        TotalOffset = 0;
        pProcessInfo = (TRACE_PROCESS_INFO *) LargeBuffer1;
        pThreadInfo = (TRACE_THREAD_INFO *) LargeBuffer1;
        pFileInfo = (TRACE_FILE_INFO *) LargeBuffer1;
        pDiskInfo = (TRACE_DISK_INFO *) LargeBuffer1;

        FinshPrinting = FALSE; 
        while (!FinshPrinting) {

            switch(CurrentClass) {
                case TraceProcessInformation:

                    PrintProcessInfo(f, pProcessInfo);
                    if (pProcessInfo->NextEntryOffset == 0) {
                        FinshPrinting = TRUE;
                        break;
                    }
                    TotalOffset += pProcessInfo->NextEntryOffset;
                    pProcessInfo = (TRACE_PROCESS_INFO *) 
                                   &LargeBuffer1[TotalOffset];
                    break;
                case TraceDiskInformation:
                    PrintDiskInfo(f, pDiskInfo);
                    if (pDiskInfo->NextEntryOffset == 0) {
                        FinshPrinting = TRUE;
                        break;
                    }
                    TotalOffset += pDiskInfo->NextEntryOffset;
                    pDiskInfo = (TRACE_DISK_INFO *)
                                    &LargeBuffer1[TotalOffset];
                default:
                    FinshPrinting = TRUE;
                    break;
            }

            if (TotalOffset == 0) 
                break;
        }


        if (!bDrillDown) {
            switch(CurrentClass) {

                case TraceProcessInformation:
                    CurrentClass = TraceDiskInformation;
                    break;
                case TraceThreadInformation:
                    CurrentClass = TraceDiskInformation;
                    break;
                case TraceDiskInformation:
                    RootClass = TraceProcessInformation;
                    CurrentClass = TraceProcessInformation;
                    bDrillDown = TRUE;
                    break;

                case TraceFileInformation:
                    Done = TRUE;
                    break;
                default:
                    Done = TRUE;
                    break;
            }
        }


        if (bDrillDown) {
            switch(RootClass) {
                case TraceProcessInformation:
                    wcscpy(InstanceName, L"\\\\NTDEV\\mraghu");
                    if (CurrentClass == TraceProcessInformation)  {
                        CurrentClass = TraceFileInformation;
                    }
                    else if (CurrentClass == TraceFileInformation) {
                        CurrentClass = TraceDiskInformation;
                    }
                    else {
                        RootClass = TraceDiskInformation;
                        CurrentClass = TraceProcessInformation;
                        wcscpy (InstanceName, L"Disk1");
                    }
                    break;

                case TraceDiskInformation:
                        if (CurrentClass == TraceProcessInformation) {
                            CurrentClass = TraceFileInformation;
                            wcscpy (InstanceName, L"Disk1");
                        }
                        else {
                            Done = TRUE;
                        }

                       break; 


                case TraceFileInformation:
                    

                default: 
                    Done = TRUE;
                    break;
            }

        }
    }

    fclose (f);

    VirtualFree(LargeBuffer1, 0, MEM_RELEASE);

}
    
#endif



#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\regini\regacl.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    regacl.c

Abstract:

    This provides routines to parse the ACE lists present in the regini
    text input files.  It also provides routines to create the appropriate
    security descriptor from the list of ACEs.

Author:

    John Vert (jvert) 15-Sep-1992

Notes:

    This is based on the SETACL program used in SETUP, written by RobertRe

Revision History:

    John Vert (jvert) 15-Sep-1992
        created
        
    Lonny McMichael (lonnym) 25-March-1999
        added new predefined ACEs (UserR and PowerR)
        
--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <stdio.h>
#include <wchar.h>

#include <seopaque.h>
#include <sertlp.h>


//
// Private function prototypes
//
BOOLEAN
RegpInitializeACEs(
    VOID
    );

//
// Universal well-known SIDs
//
PSID SeNullSid;
PSID SeWorldSid;
PSID SeCreatorOwnerSid;
PSID SeInteractiveUserSid;
PSID SeTerminalUserSid;

//
// SIDs defined by NT
//
PSID SeNtAuthoritySid;
PSID SeLocalSystemSid;
PSID SeLocalAdminSid;
PSID SeAliasAdminsSid;
PSID SeAliasSystemOpsSid;
PSID SeAliasPowerUsersSid;
PSID SeAliasUsersSid;


SID_IDENTIFIER_AUTHORITY SepNullSidAuthority = SECURITY_NULL_SID_AUTHORITY;
SID_IDENTIFIER_AUTHORITY SepWorldSidAuthority = SECURITY_WORLD_SID_AUTHORITY;
SID_IDENTIFIER_AUTHORITY SepLocalSidAuthority = SECURITY_LOCAL_SID_AUTHORITY;
SID_IDENTIFIER_AUTHORITY SepCreatorSidAuthority = SECURITY_CREATOR_SID_AUTHORITY;
SID_IDENTIFIER_AUTHORITY SepNtAuthority = SECURITY_NT_AUTHORITY;

//
// SID of primary domain, and admin account in that domain.
//
PSID SepPrimaryDomainSid;
PSID SepPrimaryDomainAdminSid;

//
// Number of ACEs currently defined
//

#define ACE_COUNT 32

typedef struct _ACE_DATA {
    ACCESS_MASK AccessMask;
    PSID *Sid;
    UCHAR AceType;
    UCHAR AceFlags;
} ACE_DATA, *PACE_DATA;

//
// Table describing the data to put into each ACE.
//
// This table is read during initialization and used to construct a
// series of ACEs.  The index of each ACE in the Aces array defined below
// corresponds to the ordinals used in the input data file.
//

ACE_DATA AceDataTable[ACE_COUNT] = {

    {
        0,
        NULL,
        0,
        0
    },

    //
    // ACE 1 - ADMIN Full
    //
    {
        KEY_ALL_ACCESS,
        &SeAliasAdminsSid,
        ACCESS_ALLOWED_ACE_TYPE,
        CONTAINER_INHERIT_ACE
    },

    //
    // ACE 2 - ADMIN Read
    //
    {
        KEY_READ,
        &SeAliasAdminsSid,
        ACCESS_ALLOWED_ACE_TYPE,
        CONTAINER_INHERIT_ACE
    },

    //
    // ACE 3 - ADMIN Read Write
    //
    {
        KEY_READ | KEY_WRITE,
        &SeAliasAdminsSid,
        ACCESS_ALLOWED_ACE_TYPE,
        CONTAINER_INHERIT_ACE
    },

    //
    // ACE 4 - ADMIN Read Write Delete
    //
    {
        KEY_READ | KEY_WRITE | DELETE,
        &SeAliasAdminsSid,
        ACCESS_ALLOWED_ACE_TYPE,
        CONTAINER_INHERIT_ACE
    },

    //
    // ACE 5 - Creator Full
    //
    {
        KEY_ALL_ACCESS,
        &SeCreatorOwnerSid,
        ACCESS_ALLOWED_ACE_TYPE,
        CONTAINER_INHERIT_ACE
    },

    //
    // ACE 6 - Creator Read Write
    //
    {
        KEY_READ | KEY_WRITE,
        &SeCreatorOwnerSid,
        ACCESS_ALLOWED_ACE_TYPE,
        CONTAINER_INHERIT_ACE
    },

    //
    // ACE 7 - World Full
    //
    {
        KEY_ALL_ACCESS,
        &SeWorldSid,
        ACCESS_ALLOWED_ACE_TYPE,
        CONTAINER_INHERIT_ACE
    },

    //
    // ACE 8 - World Read
    //
    {
        KEY_READ,
        &SeWorldSid,
        ACCESS_ALLOWED_ACE_TYPE,
        CONTAINER_INHERIT_ACE
    },

    //
    // ACE 9 - World Read Write
    //
    {
        KEY_READ | KEY_WRITE,
        &SeWorldSid,
        ACCESS_ALLOWED_ACE_TYPE,
        CONTAINER_INHERIT_ACE
    },

    //
    // ACE 10 - World Read Write Delete
    //
    {
        KEY_READ | KEY_WRITE | DELETE,
        &SeWorldSid,
        ACCESS_ALLOWED_ACE_TYPE,
        CONTAINER_INHERIT_ACE
    },

    //
    // ACE 11 - PowerUser Full
    //
    {
        KEY_ALL_ACCESS,
        &SeAliasPowerUsersSid,
        ACCESS_ALLOWED_ACE_TYPE,
        CONTAINER_INHERIT_ACE
    },

    //
    // ACE 12 - PowerUser Read Write
    //
    {
        KEY_READ | KEY_WRITE,
        &SeAliasPowerUsersSid,
        ACCESS_ALLOWED_ACE_TYPE,
        CONTAINER_INHERIT_ACE
    },

    //
    // ACE 13 - PowerUser Read Write Delete
    //
    {
        KEY_READ | KEY_WRITE | DELETE,
        &SeAliasPowerUsersSid,
        ACCESS_ALLOWED_ACE_TYPE,
        CONTAINER_INHERIT_ACE
    },

    //
    // ACE 14 - System Ops Full
    //
    {
        KEY_ALL_ACCESS,
        &SeAliasSystemOpsSid,
        ACCESS_ALLOWED_ACE_TYPE,
        CONTAINER_INHERIT_ACE
    },

    //
    // ACE 15 - System Ops Read Write
    //
    {
        KEY_READ | KEY_WRITE,
        &SeAliasSystemOpsSid,
        ACCESS_ALLOWED_ACE_TYPE,
        CONTAINER_INHERIT_ACE
    },

    //
    // ACE 16 - System Ops Read Write Delete
    //
    {
        KEY_READ | KEY_WRITE | DELETE,
        &SeAliasSystemOpsSid,
        ACCESS_ALLOWED_ACE_TYPE,
        CONTAINER_INHERIT_ACE
    },

    //
    // ACE 17 - System Full
    //
    {
        KEY_ALL_ACCESS,
        &SeLocalSystemSid,
        ACCESS_ALLOWED_ACE_TYPE,
        CONTAINER_INHERIT_ACE
    },

    //
    // ACE 18 - System Read Write
    //
    {
        KEY_READ | KEY_WRITE,
        &SeLocalSystemSid,
        ACCESS_ALLOWED_ACE_TYPE,
        CONTAINER_INHERIT_ACE
    },

    //
    // ACE 19 - System Read
    //
    {
        KEY_READ,
        &SeLocalSystemSid,
        ACCESS_ALLOWED_ACE_TYPE,
        CONTAINER_INHERIT_ACE
    },

    //
    // ACE 20 - ADMIN Read Write Execute
    //
    {
        KEY_READ | KEY_WRITE | KEY_EXECUTE,
        &SeAliasAdminsSid,
        ACCESS_ALLOWED_ACE_TYPE,
        CONTAINER_INHERIT_ACE
    },

    //
    // ACE 21 - Interactive User Full
    //
    {
        KEY_ALL_ACCESS,
        &SeInteractiveUserSid,
        ACCESS_ALLOWED_ACE_TYPE,
        CONTAINER_INHERIT_ACE
    },

    //
    // ACE 22 - Interactive User Read
    //
    {
        KEY_READ,
        &SeInteractiveUserSid,
        ACCESS_ALLOWED_ACE_TYPE,
        CONTAINER_INHERIT_ACE
    },

    //
    // ACE 23 - Interactive User Read Write
    //
    {
        KEY_READ | KEY_WRITE,
        &SeInteractiveUserSid,
        ACCESS_ALLOWED_ACE_TYPE,
        CONTAINER_INHERIT_ACE
    },

    //
    // ACE 24 - Interactive User Read Write Delete
    //
    {
        KEY_READ | KEY_WRITE | DELETE,
        &SeInteractiveUserSid,
        ACCESS_ALLOWED_ACE_TYPE,
        CONTAINER_INHERIT_ACE
    },

    //
    // ACE 25 - Normal Users Read / Write
    //
    {
        KEY_READ | KEY_WRITE,
        &SeAliasUsersSid,
        ACCESS_ALLOWED_ACE_TYPE,
        CONTAINER_INHERIT_ACE
    },

    //
    // ACE 26 - Terminal User Full
    //
    {
        KEY_ALL_ACCESS,
        &SeTerminalUserSid,
        ACCESS_ALLOWED_ACE_TYPE,
        CONTAINER_INHERIT_ACE
    },

    //
    // ACE 27 - Terminal User Read
    //
    {
        KEY_READ,
        &SeTerminalUserSid,
        ACCESS_ALLOWED_ACE_TYPE,
        CONTAINER_INHERIT_ACE
    },

    //
    // ACE 28 - Terminal User Read Write
    //
    {
        KEY_READ | KEY_WRITE,
        &SeTerminalUserSid,
        ACCESS_ALLOWED_ACE_TYPE,
        CONTAINER_INHERIT_ACE
    },

    //
    // ACE 29 - Terminal User Read Write Delete
    //
    {
        KEY_READ | KEY_WRITE | DELETE,
        &SeTerminalUserSid,
        ACCESS_ALLOWED_ACE_TYPE,
        CONTAINER_INHERIT_ACE
    },

    //
    // ACE 30 - Normal Users Read
    //
    {
        KEY_READ,
        &SeAliasUsersSid,
        ACCESS_ALLOWED_ACE_TYPE,
        CONTAINER_INHERIT_ACE
    },

    //
    // ACE 31 - PowerUser Read
    //
    {
        KEY_READ,
        &SeAliasPowerUsersSid,
        ACCESS_ALLOWED_ACE_TYPE,
        CONTAINER_INHERIT_ACE
    }

};

PKNOWN_ACE Aces[ACE_COUNT];

BOOLEAN
RegInitializeSecurity(
    VOID
    )

/*++

Routine Description:

    This routine initializes the defined ACEs.  It must be called before any
    of the routines to create security descriptors

Arguments:

    None.

Return Value:

    TRUE  - initialization successful
    FALSE - initialization failed

--*/

{
    NTSTATUS Status;

    SID_IDENTIFIER_AUTHORITY NullSidAuthority;
    SID_IDENTIFIER_AUTHORITY WorldSidAuthority;
    SID_IDENTIFIER_AUTHORITY LocalSidAuthority;
    SID_IDENTIFIER_AUTHORITY CreatorSidAuthority;
    SID_IDENTIFIER_AUTHORITY SeNtAuthority;

    NullSidAuthority = SepNullSidAuthority;
    WorldSidAuthority = SepWorldSidAuthority;
    LocalSidAuthority = SepLocalSidAuthority;
    CreatorSidAuthority = SepCreatorSidAuthority;
    SeNtAuthority = SepNtAuthority;

    SeNullSid = (PSID)RtlAllocateHeap( RtlProcessHeap(), 0, RtlLengthRequiredSid(1) );
    SeWorldSid = (PSID)RtlAllocateHeap( RtlProcessHeap(), 0, RtlLengthRequiredSid(1) );
    SeCreatorOwnerSid = (PSID)RtlAllocateHeap( RtlProcessHeap(), 0, RtlLengthRequiredSid(1) );
    SeInteractiveUserSid = (PSID)RtlAllocateHeap(RtlProcessHeap(), 0, RtlLengthRequiredSid(2) );
    SeTerminalUserSid = (PSID)RtlAllocateHeap(RtlProcessHeap(), 0, RtlLengthRequiredSid(2) );

    //
    // Fail initialization if we didn't get enough memory for the universal
    // SIDs
    //
    if (SeNullSid==NULL ||
        SeWorldSid==NULL ||
        SeCreatorOwnerSid==NULL ||
        SeInteractiveUserSid == NULL ||
        SeTerminalUserSid == NULL
       ) {
        return FALSE;
    }

    Status = RtlInitializeSid(SeNullSid, &NullSidAuthority, 1);
    if (!NT_SUCCESS( Status )) {
        return FALSE;
        }

    Status = RtlInitializeSid(SeWorldSid, &WorldSidAuthority, 1);
    if (!NT_SUCCESS( Status )) {
        return FALSE;
        }

    Status = RtlInitializeSid(SeCreatorOwnerSid, &CreatorSidAuthority, 1);
    if (!NT_SUCCESS( Status )) {
        return FALSE;
        }

    Status = RtlInitializeSid( SeInteractiveUserSid, &SeNtAuthority, 1 );
    if (!NT_SUCCESS( Status )) {
        return FALSE;
        }

    Status = RtlInitializeSid( SeTerminalUserSid, &SeNtAuthority, 1 );
    if (!NT_SUCCESS( Status )) {
        return FALSE;
        }

    *(RtlSubAuthoritySid(SeNullSid, 0)) = SECURITY_NULL_RID;
    *(RtlSubAuthoritySid(SeWorldSid, 0)) = SECURITY_WORLD_RID;
    *(RtlSubAuthoritySid(SeCreatorOwnerSid, 0)) = SECURITY_CREATOR_OWNER_RID;
    *(RtlSubAuthoritySid(SeInteractiveUserSid, 0 )) = SECURITY_INTERACTIVE_RID;
    *(RtlSubAuthoritySid(SeTerminalUserSid, 0 )) = SECURITY_TERMINAL_SERVER_RID;

    //
    // Allocate and initialize the NT defined SIDs
    //
    SeNtAuthoritySid = (PSID)RtlAllocateHeap( RtlProcessHeap(), 0, RtlLengthRequiredSid(0) );
    SeLocalSystemSid = (PSID)RtlAllocateHeap( RtlProcessHeap(), 0, RtlLengthRequiredSid(1) );
    SeAliasAdminsSid = (PSID)RtlAllocateHeap(RtlProcessHeap(), 0, RtlLengthRequiredSid(2) );
    SeAliasSystemOpsSid = (PSID)RtlAllocateHeap(RtlProcessHeap(), 0, RtlLengthRequiredSid(2) );
    SeAliasPowerUsersSid = (PSID)RtlAllocateHeap(RtlProcessHeap(), 0, RtlLengthRequiredSid(2) );
    SeAliasUsersSid = (PSID)RtlAllocateHeap(RtlProcessHeap(), 0, RtlLengthRequiredSid(2) );

    //
    // fail initialization if we couldn't allocate memory for the NT SIDs
    //

    if (SeNtAuthoritySid == NULL ||
        SeLocalSystemSid == NULL ||
        SeAliasAdminsSid == NULL ||
        SeAliasPowerUsersSid == NULL ||
        SeAliasSystemOpsSid == NULL
       ) {
        return FALSE;
        }

    Status = RtlInitializeSid( SeNtAuthoritySid, &SeNtAuthority, 0 );
    if (!NT_SUCCESS( Status )) {
        return FALSE;
        }
    Status = RtlInitializeSid( SeLocalSystemSid, &SeNtAuthority, 1 );
    if (!NT_SUCCESS( Status )) {
        return FALSE;
        }
    Status = RtlInitializeSid( SeAliasAdminsSid, &SeNtAuthority, 2 );
    if (!NT_SUCCESS( Status )) {
        return FALSE;
        }
    Status = RtlInitializeSid( SeAliasSystemOpsSid, &SeNtAuthority, 2 );
    if (!NT_SUCCESS( Status )) {
        return FALSE;
        }
    Status = RtlInitializeSid( SeAliasPowerUsersSid, &SeNtAuthority, 2 );
    if (!NT_SUCCESS( Status )) {
        return FALSE;
        }
    Status = RtlInitializeSid( SeAliasUsersSid, &SeNtAuthority, 2 );
    if (!NT_SUCCESS( Status )) {
        return FALSE;
        }
    *(RtlSubAuthoritySid( SeLocalSystemSid, 0 )) = SECURITY_LOCAL_SYSTEM_RID;

    *(RtlSubAuthoritySid( SeAliasAdminsSid, 0 )) = SECURITY_BUILTIN_DOMAIN_RID;
    *(RtlSubAuthoritySid( SeAliasAdminsSid, 1 )) = DOMAIN_ALIAS_RID_ADMINS;

    *(RtlSubAuthoritySid( SeAliasSystemOpsSid, 0 )) = SECURITY_BUILTIN_DOMAIN_RID;
    *(RtlSubAuthoritySid( SeAliasSystemOpsSid, 1 )) = DOMAIN_ALIAS_RID_SYSTEM_OPS;

    *(RtlSubAuthoritySid( SeAliasPowerUsersSid, 0 )) = SECURITY_BUILTIN_DOMAIN_RID;
    *(RtlSubAuthoritySid( SeAliasPowerUsersSid, 1 )) = DOMAIN_ALIAS_RID_POWER_USERS;

    *(RtlSubAuthoritySid( SeAliasUsersSid, 0 )) = SECURITY_BUILTIN_DOMAIN_RID;
    *(RtlSubAuthoritySid( SeAliasUsersSid, 1 )) = DOMAIN_ALIAS_RID_USERS;

    //
    // The SIDs have been successfully created.  Now create the table of ACEs
    //

    return RegpInitializeACEs();
}

BOOLEAN
RegpInitializeACEs(
    VOID
    )

/*++

Routine Description:

    Initializes the table of ACEs described in the AceDataTable.  This is
    called at initialization time by RiInitializeSecurity after the SIDs
    have been created.

Arguments:

    None.

Return Value:

    TRUE  - ACEs successfully constructed.
    FALSE - initialization failed.

--*/

{
    ULONG i;
    ULONG LengthRequired;
    NTSTATUS Status;

    for (i=1; i<ACE_COUNT; i++) {
        LengthRequired = RtlLengthSid( *(AceDataTable[i].Sid) ) +
                         sizeof( KNOWN_ACE ) - sizeof( ULONG );

        Aces[i] = (PKNOWN_ACE)RtlAllocateHeap( RtlProcessHeap(), 0, LengthRequired );
        if (Aces[i] == NULL) {
            return FALSE;
            }

        Aces[i]->Header.AceType = AceDataTable[i].AceType;
        Aces[i]->Header.AceFlags = AceDataTable[i].AceFlags;
        Aces[i]->Header.AceSize = (USHORT)LengthRequired;

        Aces[i]->Mask = AceDataTable[i].AccessMask;

        Status = RtlCopySid( RtlLengthSid(*(AceDataTable[i].Sid)),
                             &Aces[i]->SidStart,
                             *(AceDataTable[i].Sid)
                           );
        if (!NT_SUCCESS( Status )) {
            return FALSE;
            }
        }

    return TRUE;
}


BOOLEAN
RegUnicodeToDWORD(
    IN OUT PWSTR *String,
    IN ULONG Base OPTIONAL,
    OUT PULONG Value
    )
{
    PCWSTR s;
    WCHAR c, Sign;
    ULONG nChars, Result, Digit, Shift;

    s = *String;
    Sign = UNICODE_NULL;
    while (*s != UNICODE_NULL && *s <= ' ') {
        s += 1;
        }

    c = *s;
    if (c == L'-' || c == L'+') {
        Sign = c;
        c = *++s;
        }

    if (Base == 0) {
        Base = 10;
        Shift = 0;
        if (c == L'0') {
            c = *++s;
            if (c == L'x') {
                c = *++s;
                Base = 16;
                Shift = 4;
                }
            else
            if (c == L'o') {
                c = *++s;
                Base = 8;
                Shift = 3;
                }
            else
            if (c == L'b') {
                c = *++s;
                Base = 2;
                Shift = 1;
                }
            else {
                c = *--s;
                }
            }
        }
    else {
        switch( Base ) {
            case 16:    Shift = 4;  break;
            case  8:    Shift = 3;  break;
            case  2:    Shift = 1;  break;
            case 10:    Shift = 0;  break;
            default:    return FALSE;
            }
        }

    //
    // Return an error if end of string before we start
    //
    if (c == UNICODE_NULL) {
        return FALSE;
        }

    Result = 0;
    while (c != UNICODE_NULL) {
        if (c >= L'0' && c <= L'9') {
            Digit = c - L'0';
            }
        else
        if (c >= L'A' && c <= L'F') {
            Digit = c - L'A' + 10;
            }
        else
        if (c >= L'a' && c <= L'f') {
            Digit = c - L'a' + 10;
            }
        else {
            break;
            }

        if (Digit >= Base) {
            break;
            }

        if (Shift == 0) {
            Result = (Base * Result) + Digit;
            }
        else {
            Result = (Result << Shift) | Digit;
            }

        c = *++s;
        }

    if (Sign == L'-') {
        Result = (ULONG)(-(LONG)Result);
        }

    try {
        *String = (PWSTR)s;
        *Value = Result;
        }
    except( EXCEPTION_EXECUTE_HANDLER ) {
        return FALSE;
        }

    return TRUE;
}



BOOLEAN
RegCreateSecurity(
    IN PWSTR AclStart,
    OUT PSECURITY_DESCRIPTOR SecurityDescriptor
    )

/*++

Routine Description:

    Computes the appropriate security descriptor based on a string of the
    form "1 2 3 ..." where each number is the index of a particular
    ACE from the pre-defined list of ACEs.

Arguments:

    AclStart - Supplies a unicode string representing a list of ACEs

    SecurityDescriptor - Returns the initialized security descriptor
        that represents all the ACEs supplied

Return Value:

    TRUE if successful and FALSE if not.

--*/

{
    PWSTR p;
    PWSTR StringEnd, StringStart;
    ULONG AceCount=0;
    ULONG AceIndex;
    ULONG i;
    PACL Acl;
    NTSTATUS Status;

    //
    // First we need to count the number of ACEs in the ACL.
    //

    p=AclStart;
    StringEnd = AclStart + wcslen( AclStart );

    //
    // strip leading white space
    //
    while ((*p == L' ' || *p == L'\t') && p != StringEnd) {
        p += 1;
        }

    StringStart = p;

    //
    // Count number of digits in the string
    //

    while (p != StringEnd) {
        if (iswdigit( *p )) {
            ++AceCount;
            do {
                p += 1;
                }
            while (iswdigit( *p ) && p != StringEnd);
            }
        else {
            p += 1;
            }
        }

    Acl = RtlAllocateHeap( RtlProcessHeap(), 0, 256 );
    if (Acl == NULL) {
        return FALSE;
        }

    Status = RtlCreateAcl( Acl, 256, ACL_REVISION2 );
    if (!NT_SUCCESS( Status )) {
        RtlFreeHeap( RtlProcessHeap(), 0, Acl );
        return FALSE;
        }

    p = StringStart;
    for (i=0; i<AceCount; i++) {
        AceIndex = wcstoul( p, &p, 10 );
        if (AceIndex == 0) {
            //
            // zero is not a valid index, so it must mean there is some
            // unexpected garbage in the ACE list
            //
            break;
            }

        Status = RtlAddAce( Acl,
                            ACL_REVISION2,
                            MAXULONG,
                            Aces[AceIndex],
                            Aces[AceIndex]->Header.AceSize
                          );
        if (!NT_SUCCESS( Status )) {
            RtlFreeHeap( RtlProcessHeap(), 0, Acl );
            return FALSE;
            }
        }

    //
    // We now have an appropriately formed ACL, initialize the security
    // descriptor.
    //
    Status = RtlCreateSecurityDescriptor( SecurityDescriptor,
                                          SECURITY_DESCRIPTOR_REVISION
                                        );
    if (!NT_SUCCESS( Status )) {
        RtlFreeHeap( RtlProcessHeap(), 0, Acl );
        return FALSE;
        }

    Status = RtlSetDaclSecurityDescriptor( SecurityDescriptor,
                                           TRUE,
                                           Acl,
                                           FALSE
                                         );
    if (!NT_SUCCESS( Status )) {
        RtlFreeHeap( RtlProcessHeap(), 0, Acl );
        return FALSE;
        }

    return TRUE;
}


BOOLEAN
RegFormatSecurity(
    IN PSECURITY_DESCRIPTOR SecurityDescriptor,
    OUT PWSTR AceList
    )
{
    NTSTATUS Status;
    BOOLEAN DaclPresent, DaclDefaulted;
    PACL Acl;
    PWSTR s;
    ULONG AceIndex, MyAceIndex;
    PKNOWN_ACE Ace;

    s = AceList;
    *s = UNICODE_NULL;
    Acl = NULL;
    Status = RtlGetDaclSecurityDescriptor( SecurityDescriptor,
                                           &DaclPresent,
                                           &Acl,
                                           &DaclDefaulted
                                         );
    if (NT_SUCCESS( Status ) && DaclPresent && Acl != NULL) {
        for (AceIndex=0; AceIndex<Acl->AceCount; AceIndex++) {
            Status = RtlGetAce( Acl, AceIndex, &Ace );
            if (!NT_SUCCESS( Status )) {
                return FALSE;
                }

            for (MyAceIndex=1; MyAceIndex<ACE_COUNT; MyAceIndex++) {
                if (Ace->Header.AceType == Aces[ MyAceIndex ]->Header.AceType &&
                    Ace->Header.AceFlags == Aces[ MyAceIndex ]->Header.AceFlags &&
                    Ace->Mask == Aces[ MyAceIndex ]->Mask
                   ) {
                    if (RtlEqualSid( (PSID)&Ace->SidStart, (PSID)&Aces[ MyAceIndex ]->SidStart )) {
                        if (s != AceList) {
                            *s++ = L' ';
                            }

                        s += swprintf( s, L"%d", MyAceIndex );
                        break;
                        }
                    }
                }
            }
        }

    *s = UNICODE_NULL;
    return s != AceList;
}


VOID
RegDestroySecurity(
    IN PSECURITY_DESCRIPTOR SecurityDescriptor
    )

/*++

Routine Description:

    This routine cleans up and destroys a security descriptor that was
    previously created with RegCreateSecurity.

Arguments:

    SecurityDescriptor - Supplies a pointer to the security descriptor that
        was previously initialized by RegCreateSecurity.

Return Value:

    None.

--*/

{
    NTSTATUS Status;
    BOOLEAN DaclPresent, DaclDefaulted;
    PACL Acl;
    ULONG AceIndex;
    PKNOWN_ACE Ace;

    Acl = NULL;
    Status = RtlGetDaclSecurityDescriptor( SecurityDescriptor,
                                           &DaclPresent,
                                           &Acl,
                                           &DaclDefaulted
                                         );
    if (NT_SUCCESS( Status ) && DaclPresent && Acl != NULL) {
        RtlFreeHeap( RtlProcessHeap(), 0, Acl );
        }

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\regdiff\regdiff.c ===
/***************************************************************************
*
* MODULE: REGDIFF
*
* This module implements a charmode utility for snapshoting, diffing,
* merging, and unmerging the registry.
*
* If your wondering why this isn't simpler than it is, its because the
* registry is not consistant across all nodes thus special hacks were
* done to make it work.  I have endeavored to keep it clean though and
* there are many functions out of here you can just grab and use for
* the most part.
*
* Happy diffing.
*
* Created 8/20/93 sanfords
***************************************************************************/
#define UNICODE
#define _UNICODE
#ifndef RC_INVOKED
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#endif
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <tchar.h>
#include <windows.h>

/*
 * By using macros for all IO its easy to just cut it out.
 */
#define DPRINTF(x) if (fDebug) { _tprintf(TEXT("DBG:")); _tprintf##x; }
#define VPRINTF(x) if (fVerbose) _tprintf##x
#define DVPRINTF(x) if (fVerbose | fDebug) _tprintf##x
#define EPRINTF(x) _tprintf(TEXT("ERR:")); _tprintf##x; if (fBreak) DebugBreak()
#define WPRINTF(x) _tprintf(TEXT("WARNING:-----\n")); _tprintf##x
#define MEMFAILED   EPRINTF((pszMemFailed));

/*
 * Constants for the LogRegAccess() worker function.
 */
#define LRA_OPEN    0
#define LRA_CREATE  1

/*
 * Structure used to associate any open key with its parent key and
 * subkey name allowing us to optain the full key name of any open
 * key at any time.  Useful for decent output w/o high overhead.
 */
typedef struct tagKEYLOG {
    struct tagKEYLOG *next;
    HKEY hKey;
    HKEY hKeyParent;
    LPTSTR psz;
} KEYLOG, *PKEYLOG;

/*
 * Linked list of all open key logs.
 */
PKEYLOG pKeyLogList = NULL;

/*
 * Flags - mostly set by command line parameters.
 */
BOOL fEraseInputFileWhenDone = FALSE;
BOOL fInclusionListSpecified = FALSE;
BOOL fExclusionListSpecified = FALSE;
BOOL fSnap =    FALSE;
BOOL fDiff =    FALSE;
BOOL fMerge =   FALSE;
BOOL fUnmerge = FALSE;
BOOL fRemoveDiffInfo =  FALSE;
BOOL fWriteDiffInfo = FALSE;
BOOL fLoadDiffInfo = FALSE;
BOOL fVerbose = FALSE;
BOOL fDebug =   FALSE;
BOOL fBreak =   FALSE;
BOOL fSafe =    FALSE;

LPSTR pszSnapFileIn = NULL;
LPSTR pszSnapFileOut = NULL;
LPSTR pszDiffFileIn = NULL;
LPSTR pszDiffFileOut = NULL;
LPSTR pszTempFile = "regdiff1";
LPSTR pszTempFileLog = "regdiff1.log";
LPSTR pszTempFile2 = "regdiff2";
LPSTR pszTempFile2Log = "regdiff2.log";
LPSTR pszDummyFile = "_regdiff";
LPSTR pszDummyFileLog = "_regdiff.log";

LPTSTR pszMemFailed = TEXT("Memory Failure.\n");
LPTSTR pszTemp1 = NULL;
LPTSTR pszTemp2 = NULL;
LPTSTR pszTemp3 = NULL;

LPTSTR pszCurUserSID = NULL;
LPTSTR pszHKEY_LOCAL_MACHINE = TEXT("HKEY_LOCAL_MACHINE");
LPTSTR pszHKEY_USERS =  TEXT("HKEY_USERS");
LPTSTR pszHKEY_CURRENT_USER =  TEXT("HKEY_CURRENT_USER");
LPTSTR pszHKEY_CURRENT_USER_Real = NULL;    // made from user's SID
LPTSTR pszHKEY_CLASSES_ROOT = TEXT("HKEY_CLASSES_ROOT");
LPTSTR pszHKEY_CLASSES_ROOT_Real = TEXT("HKEY_LOCAL_MACHINE\\SOFTWARE\\Classes");
LPTSTR pszRealClassesRoot = TEXT("SOFTWARE\\Classes");
LPTSTR pszDiffRoot = TEXT("regdiff");
LPTSTR pszAddKey = TEXT("Add");
LPTSTR pszDelKey = TEXT("Del");
LPTSTR pszSnapshotSubkeyName = TEXT("Regdiff_SnapshotKey");

/*
 * default Exception list
 */
LPTSTR apszExceptKeys[] = {
        TEXT("HKEY_LOCAL_MACHINE\\SYSTEM\\Clone"),
        TEXT("HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon\\CacheLastUpdate"),
        TEXT("HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet"),
        TEXT("HKEY_LOCAL_MACHINE\\SYSTEM\\ControlSet???"),
    };
DWORD cExceptKeys = sizeof(apszExceptKeys)/sizeof(LPTSTR);
LPTSTR *ppszExceptKeys = apszExceptKeys;  // pointer to current exception list.

/*
 * default Inclusion list
 */
LPTSTR apszIncludeKeys[] = {
        TEXT("HKEY_LOCAL_MACHINE\\SYSTEM"),
        TEXT("HKEY_LOCAL_MACHINE\\SOFTWARE"),
        TEXT("HKEY_CURRENT_USER"),
    };
DWORD cIncludeKeys = sizeof(apszIncludeKeys)/sizeof(LPTSTR);
LPTSTR *ppszIncludeKeys = apszIncludeKeys;  // pointer to current inclusion list.

/*
 * array of flags used to make sure that our loaded snapfile contained
 * at least all the keys in the inclusion list.
 */
BOOL afIncludeKeyMarks[sizeof(apszIncludeKeys)/sizeof(LPTSTR)] = {
    FALSE,
    FALSE,
    FALSE,
};
BOOL *pfIncludeKeyMarks = afIncludeKeyMarks;

/*
 * Necessary prototypes.
 */
BOOL AddNodeInfo(HKEY hKeyInfo, HKEY hKeyTarget);



VOID PrintUsage(VOID)
{
    DWORD i;

    _tprintf(
            TEXT("regdiff usage:\n")
            TEXT("\n")
            TEXT("-s <snapfile>\n")
            TEXT("    save current registry contents to snapfile.\n")
            TEXT("-d <snapfile>\n")
            TEXT("    create diff info from current registry state and <snapfile>.\n")
            TEXT("-l <difffile>\n")
            TEXT("    load diff info into registry from <difffile>.\n")
            TEXT("-w <difffile>\n")
            TEXT("    write diff info to <difffile> from registry when done.\n")
            TEXT("-e  erase input file(s) after done.\n")
            TEXT("-m  merge diff info into current registry.\n")
            TEXT("-u  unmerge diff info from current registry.\n")
            TEXT("-r  remove diff info from registry when done.\n")
            TEXT("-x <exceptionsfile>\n")
            TEXT("    use <exceptionsfile> to bypass diff, merge or unmerge on certain keys.\n")
            TEXT("-i <inclusionsfile>\n")
            TEXT("    use <inclusionsfile> to snap or diff only certain keys.\n")
            TEXT("-v  verbose output on.\n")
            TEXT("-@  Debug mode.\n")
            TEXT("-b  break on errors.\n")
            TEXT("-n  neuter - don't really do merges/unmerges. (for safe testing)\n")
            TEXT("\n")
            TEXT("<snapfile> and <difffile> should not have extensions on FAT partitions.\n")
            TEXT("diff info is kept in HKEY_LOCAL_MACHINE\\regdiff\n")
            );

    _tprintf(TEXT("\nThe default inclusions list is:\n"));
    for (i = 0; i < cIncludeKeys; i++) {
        _tprintf(TEXT("  %ws\n"), ppszIncludeKeys[i]);
    }

    _tprintf(TEXT("\nThe default exceptions list is:\n"));
    for (i = 0; i < cExceptKeys; i++) {
        _tprintf(TEXT("  %ws\n"), ppszExceptKeys[i]);
    }
}


/*
 * The following functions allow us to log all registry key openings and
 * closeings so we can know at any time the full path of any open key.
 *
 * This simplifies such things as exception and inclusion lookups.
 */

LPTSTR LookupPathFromKey(
HKEY hKey,
PHKEY phKeyParent)
{
    PKEYLOG pkl;

    *phKeyParent = NULL;
    if (hKey == HKEY_LOCAL_MACHINE) {
        return(pszHKEY_LOCAL_MACHINE);
    } else if (hKey == HKEY_USERS) {
        return(pszHKEY_USERS);
    } else if (hKey == HKEY_CURRENT_USER) {
        return(pszHKEY_CURRENT_USER_Real);
    } else if (hKey == HKEY_CLASSES_ROOT) {
        return(pszHKEY_CLASSES_ROOT_Real);
    } else {
        pkl = pKeyLogList;
        while (pkl != NULL) {
            if (pkl->hKey == hKey) {
                *phKeyParent = pkl->hKeyParent;
                return(pkl->psz);
            }
            pkl = pkl->next;
        }
        return(NULL);
    }
}

/*
 * This removes pseudo-key root names from paths and changes them to
 * real-root names.
 *
 * Return string must be freed by caller if pfFree is set.
 */
LPTSTR NormalizePathName(
LPTSTR pszPath,
BOOL *pfFree)
{
    LPTSTR pszOffender, pszFixed;

    if (pfFree != NULL) {
        *pfFree = FALSE;
    }
    pszOffender = _tcsstr(pszPath, pszHKEY_CURRENT_USER);
    if (pszOffender != NULL) {
        pszFixed = malloc((
                _tcslen(pszPath) +
                _tcslen(pszHKEY_CURRENT_USER_Real) -
                _tcslen(pszHKEY_CURRENT_USER) +
                1) * sizeof(TCHAR));
        if (pszFixed == NULL) {
            MEMFAILED;
            return(NULL);
        }
        _tcscpy(pszFixed, pszHKEY_CURRENT_USER_Real);
        _tcscat(pszFixed, pszOffender + _tcslen(pszHKEY_CURRENT_USER));
        if (pfFree != NULL) {
            *pfFree = TRUE;
        }
        return(pszFixed);
    }
    pszOffender = _tcsstr(pszPath, pszHKEY_CLASSES_ROOT);
    if (pszOffender != NULL) {
        pszFixed = malloc((
                _tcslen(pszPath) +
                _tcslen(pszHKEY_CLASSES_ROOT_Real) -
                _tcslen(pszHKEY_CLASSES_ROOT) +
                1) * sizeof(TCHAR));
        if (pszFixed == NULL) {
            MEMFAILED;
            return(NULL);
        }
        _tcscpy(pszFixed, pszHKEY_CLASSES_ROOT_Real);
        _tcscat(pszFixed, pszOffender + _tcslen(pszHKEY_CLASSES_ROOT));
        if (pfFree != NULL) {
            *pfFree = TRUE;
        }
        return(pszFixed);
    }
    return(pszPath);    // already normalized
}


/*
 * return value must be freed by caller.
 *
 * NULL is returned on error.
 */
LPTSTR GetFullPathFromKey(
HKEY hKey,
LPCTSTR pszSubkey)
{
    LPTSTR pszPart, pszNewSubkey;
    HKEY hKeyParent;

    pszPart = LookupPathFromKey(hKey, &hKeyParent);
    if (pszPart != NULL) {
        pszNewSubkey = malloc((_tcslen(pszPart) + 1 +
            (pszSubkey == NULL ? 0 : (_tcslen(pszSubkey) + 1))) *
            sizeof(TCHAR));
        if (pszNewSubkey == NULL) {
            MEMFAILED;
            return(NULL);
        }
        _tcscpy(pszNewSubkey, pszPart);
        if (pszSubkey != NULL) {
            _tcscat(pszNewSubkey, TEXT("\\"));
            _tcscat(pszNewSubkey, pszSubkey);
        }
        if (hKeyParent != NULL) {
            pszPart = GetFullPathFromKey(hKeyParent, pszNewSubkey);
            free(pszNewSubkey);
        } else {
            pszPart = pszNewSubkey;
        }
    }
    return(pszPart);
}

/*
 * Same as GetFullPathFromKey but the pointer given is reused.
 */
LPTSTR ReuseFullPathFromKey(
HKEY hKey,
LPCTSTR pszSubkey,
LPTSTR *ppsz)
{
    if (*ppsz != NULL) {
        free(*ppsz);
    }
    *ppsz = GetFullPathFromKey(hKey, pszSubkey);
    return(*ppsz);
}



LONG LogRegAccessKey(
DWORD AccessType,
HKEY hKey,
LPCTSTR pszSubkeyName,
HKEY *phSubkey)
{
    PKEYLOG pkl;
    LONG status;
    DWORD dwDisp;

    DPRINTF((TEXT("LogRegAccessKey(%s, %s, %s)\n"),
            (AccessType == LRA_OPEN ? TEXT("Open") : TEXT("Create")),
            ReuseFullPathFromKey(hKey, NULL, &pszTemp1),
            pszSubkeyName));

    switch (AccessType) {
    case LRA_OPEN:
        status = RegOpenKeyEx(hKey, pszSubkeyName, 0, KEY_ALL_ACCESS, phSubkey);
        if (status != ERROR_SUCCESS) {
            DPRINTF((TEXT("Failed to open key %s with ALL_ACCESS.\n"),
                    ReuseFullPathFromKey(hKey, pszSubkeyName, &pszTemp1)));
            /*
             * Loaded keys can't be written to - so try opening readonly.
             */
            status = RegOpenKeyEx(hKey, pszSubkeyName, 0, KEY_READ, phSubkey);
        }
        break;

    case LRA_CREATE:
        status = RegCreateKeyEx(hKey, pszSubkeyName, 0, TEXT(""),
                REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL, phSubkey, \
                &dwDisp);
        if (status != ERROR_SUCCESS) {
            /*
             * Loaded keys can't be written to - so try opening readonly.
             */
            DPRINTF((TEXT("Failed to create key %s with ALL_ACCESS.\n"),
                    ReuseFullPathFromKey(hKey, pszSubkeyName, &pszTemp1)));
            status = RegCreateKeyEx(hKey, pszSubkeyName, 0, TEXT(""),
                    REG_OPTION_NON_VOLATILE, KEY_READ, NULL, phSubkey, \
                    &dwDisp);
        }
        break;
    }
    if (status == ERROR_SUCCESS) {
        pkl = malloc(sizeof(KEYLOG));
        if (pkl != NULL) {
            pkl->psz = malloc((_tcslen(pszSubkeyName) + 1) * sizeof(TCHAR));
            if (pkl->psz != NULL) {
                pkl->next = pKeyLogList;
                pkl->hKey = *phSubkey;
                pkl->hKeyParent = hKey;
                _tcscpy(pkl->psz, pszSubkeyName);
                pKeyLogList = pkl;
            } else {
                status = ERROR_NOT_ENOUGH_MEMORY;
                free(pkl);
            }
        } else {
            status = ERROR_NOT_ENOUGH_MEMORY;
        }
    }
    return(status);
}




LONG LogRegOpenKey(
HKEY hKey,
LPCTSTR pszSubkeyName,
HKEY *phSubkey)
{
    return(LogRegAccessKey(LRA_OPEN, hKey, pszSubkeyName, phSubkey));
}



LONG LogRegCreateKey(
HKEY hKey,
LPCTSTR pszSubkeyName,
HKEY *phSubkey)
{
    return(LogRegAccessKey(LRA_CREATE, hKey, pszSubkeyName, phSubkey));
}


LONG LogRegCloseKey(
HKEY hKey)
{
    PKEYLOG pkl, pklPrev;

    DPRINTF((TEXT("LogRegCloseKey(%s)\n"),
            ReuseFullPathFromKey(hKey, NULL, &pszTemp1)));

    pkl = pKeyLogList;
    pklPrev = NULL;
    while (pkl != NULL) {
        if (hKey == pkl->hKey) {
            if (pklPrev != NULL) {
                pklPrev->next = pkl->next;
            } else {
                pKeyLogList = pkl->next;
            }
            free(pkl->psz);
            free(pkl);
            break;
        }
        pklPrev = pkl;
        pkl = pkl->next;
    }
    if (pkl == NULL) {
        EPRINTF((TEXT("Key %s being closed was not found in KeyLog.\n"),
                ReuseFullPathFromKey(hKey, NULL, &pszTemp1)));
    }
    return(RegCloseKey(hKey));
}



/*
 * Simpler privilege enabling mechanism.
 */
BOOL EnablePrivilege(
LPCTSTR lpszPrivilege)
{
    TOKEN_PRIVILEGES tp;
    HANDLE hToken = NULL;

    if (!OpenProcessToken(GetCurrentProcess(),
            TOKEN_READ | TOKEN_WRITE, &hToken)) {
        EPRINTF((TEXT("Could not open process token.\n")));
        return(FALSE);
    }
    if (hToken == NULL) {
        EPRINTF((TEXT("Could not open process token.\n")));
        return(FALSE);
    }
    if (!LookupPrivilegeValue(NULL, lpszPrivilege, &tp.Privileges[0].Luid)) {
        EPRINTF((TEXT("Could not lookup privilege value %s.\n"), lpszPrivilege));
        return(FALSE);
    }
    tp.PrivilegeCount = 1;
    tp.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;
    if (!AdjustTokenPrivileges(hToken, FALSE, &tp, 0, NULL, NULL)) {
        EPRINTF((TEXT("Could not adjust privilege %s.\n"), lpszPrivilege));
        return(FALSE);
    }
    return(TRUE);
}



/*
 * a little more sane version of the real API that can handle NULLs.
 */
LONG MyRegQueryInfoKey(
HKEY hKey,
LPDWORD lpcSubkeys,
LPDWORD lpcchMaxSubkey,
LPDWORD lpcValues,
LPDWORD lpcchMaxValueName,
LPDWORD lpcbMaxValueData,
LPFILETIME lpft)
{
    DWORD cchClass, cSubkeys, cchMaxSubkey, cchMaxClass, cValues;
    DWORD cchMaxValueName, cbMaxValueData, cbSID;
    FILETIME LastWriteTime;
    TCHAR szClass[100];
    LONG status;

    cchClass = 100;
    status = RegQueryInfoKey(hKey,
            szClass,
            &cchClass,
            NULL,
            (lpcSubkeys == NULL)        ?   &cSubkeys           : lpcSubkeys,
            (lpcchMaxSubkey == NULL)    ?   &cchMaxSubkey       : lpcchMaxSubkey,
            &cchMaxClass,
            (lpcValues == NULL)         ?   &cValues            : lpcValues,
            (lpcchMaxValueName == NULL) ?   &cchMaxValueName    : lpcchMaxValueName,
            (lpcbMaxValueData == NULL)  ?   &cbMaxValueData     : lpcbMaxValueData,
            &cbSID,
            (lpft == NULL)              ?   &LastWriteTime      : lpft);
    if (status == ERROR_MORE_DATA) {
        status = ERROR_SUCCESS;
    }
    return(status);
}


/*
 * Frees strings allocated with GetCurUserSidString().
 */
VOID DeleteSidString(
LPTSTR SidString)
{

#ifdef UNICODE
    UNICODE_STRING String;

    RtlInitUnicodeString(&String, SidString);

    RtlFreeUnicodeString(&String);
#else
    ANSI_STRING String;

    RtlInitAnsiString(&String, SidString);

    RtlFreeAnsiString(&String);
#endif

}



/*
 * Gets the current user's SID in text form.
 * The return string should be freed using DeleteSidString().
 */
LPTSTR GetCurUserSidString(VOID)
{
    HANDLE hToken;
    TOKEN_USER tu;
    DWORD cbRequired;
    PTOKEN_USER ptu = NULL, ptuUse;
    UNICODE_STRING UnicodeString;
#ifndef UNICODE
    STRING String;
#endif
    NTSTATUS NtStatus;

    if (!OpenProcessToken(GetCurrentProcess(), TOKEN_READ, &hToken)) {
        EPRINTF((TEXT("Could not open process token.\n")));
        return(NULL);
    }
    if (hToken == NULL) {
        EPRINTF((TEXT("Could not open process token.\n")));
        return(NULL);
    }
    if (!GetTokenInformation(hToken, TokenUser, &tu, sizeof(tu), &cbRequired)) {
        if (cbRequired > sizeof(tu)) {
            ptu = malloc(cbRequired);
            if (ptu == NULL) {
                return(NULL);
            }
            if (!GetTokenInformation(hToken, TokenUser, ptu, cbRequired, &cbRequired)) {
                free(ptu);
                EPRINTF((TEXT("Could not get token information.\n")));
                return(NULL);
            }
            ptuUse = ptu;
        }
    } else {
        ptuUse = &tu;
    }
    NtStatus = RtlConvertSidToUnicodeString(&UnicodeString, ptuUse->User.Sid, TRUE);
    if (!NT_SUCCESS(NtStatus)) {
        EPRINTF((TEXT("Could not get current user SID string.  NtError=%d\n"), NtStatus));
        return(NULL);
    }

#ifdef UNICODE

    return(UnicodeString.Buffer);

#else

    //
    // Convert the string to ansi
    //

    NtStatus = RtlUnicodeStringToAnsiString(&String, &UnicodeString, TRUE);
    RtlFreeUnicodeString(&UnicodeString);
    if (!NT_SUCCESS(NtStatus)) {
        EPRINTF((TEXT("Could not convert user SID string to ANSI.  NtError=%d\n"), NtStatus));
        return(NULL);
    }

    return(String.Buffer);

#endif
}



/*
 * This function stores/appends the contents of the hKey subkey specified to
 * hfOut.  pszKeyName is for error output use.
 *
 * Returns fSuccess - TRUE if ALL info was successfully saved.
 */
BOOL StoreSubKey(
HKEY hKey,
LPTSTR pszSubkeyName,
FILE *hfOut)
{
    DWORD status, cb;
    HKEY hSubkey;
    FILE *hfIn;
    VOID *pBuf;

    DVPRINTF((TEXT("  Snapping %s...\n"),
            ReuseFullPathFromKey(hKey, pszSubkeyName, &pszTemp1)));

    DeleteFileA(pszTempFile);       // RegSaveKey() won't work if this exists.

    status = LogRegOpenKey(hKey, pszSubkeyName, &hSubkey);
    if (status != ERROR_SUCCESS) {
        EPRINTF((TEXT("Could not open key %s. Error=%d.\n"),
                ReuseFullPathFromKey(hKey, pszSubkeyName, &pszTemp1), status));
        return(FALSE);
    }
    /*
     * store key in temp file.
     */
    status = RegSaveKeyA(hSubkey, pszTempFile, NULL);
    if (status != ERROR_SUCCESS) {
        EPRINTF((TEXT("Could not save %s.  Error=%d.\n"),
                ReuseFullPathFromKey(hKey, pszSubkeyName, &pszTemp1), status));
Exit1:
        LogRegCloseKey(hSubkey);
        return(FALSE);
    }

    /*
     * open key data file
     */
    hfIn = fopen(pszTempFile, "rb+");
    if (hfIn == NULL) {
        EPRINTF((TEXT("File read error.\n")));
        goto Exit1;
    }

    /*
     * write sizeof Subkey name.
     */
    cb = (_tcslen(pszSubkeyName) + 1) * sizeof(TCHAR);
    if (fwrite(&cb, 1, sizeof(DWORD), hfOut) != sizeof(DWORD) || ferror(hfOut)) {
        EPRINTF((TEXT("Write failure. [sizeof(%s).]\n"), pszSubkeyName));
Exit2:
        fclose(hfIn);
        DeleteFileA(pszTempFile);
        goto Exit1;
    }
    /*
     * write Subkey name.
     */
    if (fwrite(pszSubkeyName, 1, cb, hfOut) != cb || ferror(hfOut)) {
        EPRINTF((TEXT("Write failure. [%s]\n"), pszSubkeyName));
        goto Exit2;
    }

    /*
     * write root key handle (MUST BE AN HKEY_ CONSTANT!)
     */
    if (fwrite(&hKey, 1, sizeof(HKEY), hfOut) != sizeof(HKEY) || ferror(hfOut)) {
        EPRINTF((TEXT("Write failure. [Handle of %s.]\n"),
                ReuseFullPathFromKey(hKey, NULL, &pszTemp1)));
        goto Exit2;
    }

    /*
     * get key data file size
     */
    if (fseek(hfIn, 0, SEEK_END)) {
        EPRINTF((TEXT("Seek failure.\n")));
        goto Exit2;
    }
    cb = ftell(hfIn);

    /*
     * write sizeof key data
     */
    if (fwrite(&cb, 1, sizeof(DWORD), hfOut) != sizeof(DWORD) || ferror(hfOut)) {
        EPRINTF((TEXT("Write failure. [sizeof key data]\n")));
        goto Exit2;
    }
    /*
     * alocate key data buffer
     */
    pBuf = malloc(cb);
    if (pBuf == NULL) {
        EPRINTF((TEXT("memory error. [key data buffer.]\n")));
        goto Exit2;
    }
    /*
     * read key data into buffer
     */
    if (fseek(hfIn, 0, SEEK_SET)) {
        EPRINTF((TEXT("Seek failure.\n")));
        goto Exit2;
    }
    if (fread(pBuf, 1, cb, hfIn) != cb || ferror(hfIn)) {
        EPRINTF((TEXT("Read failure. [key data.]\n")));
        goto Exit2;
    }
    /*
     * write key data
     */
    if (fwrite(pBuf, 1, cb, hfOut) != cb || ferror(hfOut)) {
        EPRINTF((TEXT("Write failure. [key data.]\n")));
        goto Exit2;
    }
    free(pBuf);
    fclose(hfIn);
    LogRegCloseKey(hSubkey);

    /*
     * remove temp file
     */
    DeleteFileA(pszTempFile);
    return(TRUE);
}


/*
 * Creates a canonical key name from hKeyRoot and prefixes it with pszPrefix.
 *
 * ppszNode must be freed by caller.
 * returns fSuccess.
 */
BOOL GetKeyNameWithPrefix(
LPTSTR *ppszNode,   // results needs to be freed
HKEY hKeyRoot,
LPTSTR pszPrefix)
{
    LPTSTR pszPrefix1;

    pszPrefix1 = ReuseFullPathFromKey(hKeyRoot, NULL, &pszTemp1);
    *ppszNode = malloc(
            (_tcslen(pszPrefix1) +
            _tcslen(pszPrefix) +
            3) * sizeof(TCHAR));
    if (*ppszNode == NULL) {
        MEMFAILED;
        return(FALSE);
    }
    _tcscpy(*ppszNode, pszPrefix);
    _tcscat(*ppszNode, TEXT("\\"));
    _tcscat(*ppszNode, pszPrefix1);
    return(TRUE);
}




/*
 * Breaks up a canonical key name into its root, and subkey names and
 * also returns the root HKEY key value as well.
 *
 * pfFreeSubkeyString is set to TRUE if the ppszSubkey returned
 * was allocated.
 *
 * returns fSuccess.
 */
BOOL KeyPartsFromNodeName(
LPTSTR pszNode,
LPTSTR *ppszRootkey,
LPTSTR *ppszSubkey,      // FREE this if pfFreeSubkeyString is set on return.
HKEY *phKeyRoot,
BOOL *pfFreeSubkeyString)
{
    *pfFreeSubkeyString = FALSE;
    if (_tcsstr(pszNode, pszHKEY_LOCAL_MACHINE) == pszNode) {
        *ppszRootkey = pszHKEY_LOCAL_MACHINE;
        *phKeyRoot = HKEY_LOCAL_MACHINE;
        *ppszSubkey = &pszNode[_tcslen(pszHKEY_LOCAL_MACHINE) + 1];
    } else if (_tcsstr(pszNode, pszHKEY_USERS) == pszNode) {
        *ppszRootkey = pszHKEY_USERS;
        *phKeyRoot = HKEY_USERS;
        *ppszSubkey = &pszNode[_tcslen(pszHKEY_USERS) + 1];
    } else if (_tcsstr(pszNode, pszHKEY_CURRENT_USER) == pszNode) {
        *ppszRootkey = pszHKEY_USERS;
        *phKeyRoot = HKEY_USERS;
        *ppszSubkey = malloc((_tcslen(pszCurUserSID) +
               _tcslen(pszNode)) * sizeof(TCHAR));
        if (*ppszSubkey == NULL) {
            MEMFAILED;
            return(FALSE);
        }
        _tcscpy(*ppszSubkey, pszCurUserSID);
        _tcscat(*ppszSubkey, &pszNode[_tcslen(pszHKEY_CURRENT_USER)]);
        *pfFreeSubkeyString = TRUE;
    } else if (_tcsstr(pszNode, pszHKEY_CLASSES_ROOT) == pszNode) {
        *ppszRootkey = pszHKEY_LOCAL_MACHINE;
        *phKeyRoot = HKEY_LOCAL_MACHINE;
        *ppszSubkey = malloc((_tcslen(pszRealClassesRoot) +
               _tcslen(pszNode)) * sizeof(TCHAR));
        if (*ppszSubkey == NULL) {
            MEMFAILED;
            return(FALSE);
        }
        _tcscpy(*ppszSubkey, pszRealClassesRoot);
        _tcscat(*ppszSubkey, &pszNode[_tcslen(pszHKEY_CLASSES_ROOT)]);
        *pfFreeSubkeyString = TRUE;
    } else {
        return(FALSE);
    }
    return(TRUE);
}



/*
 * Snapshots the local hives and puts the into into pszOutFile.
 */
BOOL SnapHives(
LPSTR pszOutFile)
{
    FILE *hfOut;
    LPTSTR pszRootkey, pszSubkey;
    HKEY hKeyRoot;
    BOOL fFree;
    DWORD i;

    DPRINTF((TEXT("SnapHives(%hs)\n"), pszOutFile));

    hfOut = fopen(pszOutFile, "wb");
    if (hfOut == NULL) {
        EPRINTF((TEXT("Couldn't create %hs.\n"), pszOutFile));
        return(FALSE);
    }
    for (i = 0; i < cIncludeKeys; i++) {
        if (!KeyPartsFromNodeName(ppszIncludeKeys[i], &pszRootkey,
                &pszSubkey, &hKeyRoot, &fFree)) {
            EPRINTF((TEXT("Invalid Inclusion list entry: %s.\n"),
                    ppszIncludeKeys[i]));
            fclose(hfOut);
            return(FALSE);
        }
        if (!StoreSubKey(hKeyRoot, pszSubkey, hfOut)) {
            EPRINTF((TEXT("Snapshot failed.\n")));
            if (fFree) {
                free(pszSubkey);
            }
            fclose(hfOut);
            return(FALSE);
        }
        if (fFree) {
            free(pszSubkey);
        }
    }
    fclose(hfOut);
    VPRINTF((TEXT("Snapshot to %hs completed ok.\n"), pszOutFile));
    return(TRUE);
}


/*
 * Special string searching code that sees if pszSearch is a proper
 * substring of pszData where '?'s in pszSearch match any character in
 * pszData.  pszData must not be '\' when pszSearch is '?'.
 *
 * returns fMatched.
 */
BOOL substrrexp(
LPCTSTR pszSearch,
LPCTSTR pszData)
{
    // DPRINTF(("substrrexp(%s,%s) = ", pszData, pszSearch));

    while (*pszData != TEXT('\0') && *pszSearch != TEXT('\0')) {
        if (*pszSearch != TEXT('?')) {
            if (*pszData != *pszSearch) {
                break;
            }
        } else {
            if (*pszData == TEXT('\\')) {
                break;      // prevents \ from matching a ?
            }
        }
        pszData++;
        pszSearch++;
    }
    // DPRINTF(("%d\n", *pszSearch == TEXT('\0')));
    return(*pszSearch == TEXT('\0'));
}



/*
 * Searches all the node names in the node list given and sets the
 * corresponding afMarkFound[] element to TRUE if hKey\pszSubkey is
 * referenced within that node name.  Returns TRUE if ANY node names
 * reference the subkey name.
 *
 * afMarkFound may be NULL.
 * pszSubkey may be NULL.
 */
BOOL IsKeyWithinNodeList(
HKEY hKey,
LPTSTR pszSubkey,   // optional
LPTSTR *apszNodes,
DWORD cNodes,
BOOL *afMarkFound)  // optional
{
    DWORD i;
    BOOL fRet;
    LPTSTR pszFullName;

    fRet = FALSE;
    pszFullName = GetFullPathFromKey(hKey, pszSubkey);
    if (pszFullName != NULL) {
        for (i = 0; i < cNodes; i++) {
            if (substrrexp(apszNodes[i], pszFullName) &&
                    (pszFullName[_tcslen(apszNodes[i])] == TEXT('\\') ||
                    pszFullName[_tcslen(apszNodes[i])] == TEXT('\0'))) {
                fRet = TRUE;
                if (afMarkFound != NULL) {
                    afMarkFound[i] = TRUE;
                }
            }
            if (fRet && afMarkFound == NULL) {
                break;  // no need to cycle if not marking found nodes.
            }
        }
        free(pszFullName);
    }
    return(fRet);
}



BOOL CopyKeySubkey(
HKEY hKeyFrom,
LPTSTR pszSubkeyFrom,
HKEY hKeyTo,
LPTSTR pszSubkeyTo)
{
    LONG status;
    HKEY hSubkeyFrom, hSubkeyTo;
    BOOL fRet;

    DPRINTF((TEXT("CopyKeySubkey(%s, %s)\n"),
            ReuseFullPathFromKey(hKeyFrom, pszSubkeyFrom, &pszTemp1),
            ReuseFullPathFromKey(hKeyTo, pszSubkeyTo, &pszTemp2)));

    /*
     * This key could be in our exclusion list - check first.
     */
    if (IsKeyWithinNodeList(hKeyFrom, pszSubkeyFrom, ppszExceptKeys, cExceptKeys, NULL)) {
        if (fDebug) {
            DPRINTF((TEXT("Key %s was EXCLUDED.\n"),
                    ReuseFullPathFromKey(hKeyFrom, pszSubkeyFrom, &pszTemp1)));
        }
        return(TRUE);   // just fake it - its excluded.
    }
    if (IsKeyWithinNodeList(hKeyTo, pszSubkeyTo, ppszExceptKeys, cExceptKeys, NULL)) {
        if (fDebug) {
            DPRINTF((TEXT("Key %s was EXCLUDED.\n"),
                    ReuseFullPathFromKey(hKeyTo, pszSubkeyTo, &pszTemp1)));
        }
        return(TRUE);   // just fake it - its excluded.
    }
    if (!fSafe) {
        status = LogRegOpenKey(hKeyFrom, pszSubkeyFrom, &hSubkeyFrom);
        if (status != ERROR_SUCCESS) {
            EPRINTF((TEXT("Could not open key %s. Error=%d.\n"),
                    ReuseFullPathFromKey(hKeyFrom, pszSubkeyFrom, &pszTemp1), status));
            return(FALSE);
        }
        status = LogRegCreateKey(hKeyTo, pszSubkeyTo, &hSubkeyTo);
        if (status != ERROR_SUCCESS) {
            EPRINTF((TEXT("Could not create key %s. Error=%d.\n"),
                    ReuseFullPathFromKey(hKeyTo, pszSubkeyTo, &pszTemp1), status));
            return(FALSE);
        }
        fRet = AddNodeInfo(hSubkeyFrom, hSubkeyTo);
        LogRegCloseKey(hSubkeyTo);
        LogRegCloseKey(hSubkeyFrom);
    } else if (fDebug || fVerbose) {
        LPTSTR pszInfo = GetFullPathFromKey(hKeyFrom, pszSubkeyFrom);
        LPTSTR pszTarget = GetFullPathFromKey(hKeyTo, pszSubkeyTo);
        VPRINTF((TEXT("Would have copied %s to %s.\n"),
                ReuseFullPathFromKey(hKeyFrom, pszSubkeyFrom, &pszTemp1),
                ReuseFullPathFromKey(hKeyTo, pszSubkeyTo, &pszTemp2)));
        free(pszInfo);
        free(pszTarget);
        fRet = TRUE;
    }
    return(fRet);
}



/*
 * Combines the pszName entries into one string and passes control on to
 * CopyKeySubkey().
 */
BOOL CopyKeySubkeyEx(
HKEY hKeyFrom,
LPTSTR pszSubkeyName,
HKEY hKeyTo,
LPTSTR pszNameTo1,
LPTSTR pszNameTo2)
{
    LPTSTR psz;

    psz = malloc((_tcslen(pszNameTo1) + _tcslen(pszNameTo2) +
            _tcslen(pszSubkeyName) + 3) * sizeof(TCHAR));
    if (psz == NULL) {
        MEMFAILED;
        return(FALSE);
    }
    _tcscpy(psz, pszNameTo1);
    _tcscat(psz, TEXT("\\"));
    _tcscat(psz, pszNameTo2);
    _tcscat(psz, TEXT("\\"));
    _tcscat(psz, pszSubkeyName);

    if (!CopyKeySubkey(hKeyFrom, pszSubkeyName, hKeyTo, psz)) {
        free(psz);
        return(FALSE);
    }
    free(psz);
    return(TRUE);
}



BOOL CopyKeyValue(
HKEY hKeyFrom,
HKEY hKeyTo,
LPTSTR pszValue)
{
    LONG status;
    PVOID pBuf;
    DWORD dwType, cbData;

    DPRINTF((TEXT("CopyKeyValue(%s, %s, %s)\n"),
            ReuseFullPathFromKey(hKeyFrom, NULL, &pszTemp1),
            ReuseFullPathFromKey(hKeyTo, NULL, &pszTemp2),
            pszValue));

    /*
     * This key could be in our exclusion list - check first.
     */
    if (IsKeyWithinNodeList(hKeyFrom, pszValue, ppszExceptKeys, cExceptKeys, NULL)) {
        if (fDebug) {
            DPRINTF((TEXT("Source Value \"%s\" was EXCLUDED.\n"), pszValue));
        }
        return(TRUE);   // just fake it - its excluded.
    }
    if (IsKeyWithinNodeList(hKeyTo, pszValue, ppszExceptKeys, cExceptKeys, NULL)) {
        if (fDebug) {
            DPRINTF((TEXT("Target Value \"%s\" was EXCLUDED.\n"), pszValue));
        }
        return(TRUE);   // just fake it - its excluded.
    }

    status = RegQueryValueEx(hKeyFrom, pszValue, NULL, &dwType, NULL, &cbData);
    if (status != ERROR_SUCCESS) {
        EPRINTF((TEXT("Could not query value %s size from %s.  Error=%d.\n"),
                pszValue, ReuseFullPathFromKey(hKeyFrom, NULL, &pszTemp1),
                status));
        return(FALSE);
    }
    pBuf = malloc(cbData);
    if (pBuf == NULL) {
        MEMFAILED;
        return(FALSE);
    }
    status = RegQueryValueEx(hKeyFrom, pszValue, NULL, &dwType, pBuf, &cbData);
    if (status != ERROR_SUCCESS) {
        EPRINTF((TEXT("Could not query value %s from %s.  Error=%d.\n"),
                pszValue, ReuseFullPathFromKey(hKeyFrom, NULL, &pszTemp1),
                status));
        free(pBuf);
        return(FALSE);
    }
    status = RegSetValueEx(hKeyTo, pszValue, 0, dwType, (BYTE *)pBuf, cbData);
    free(pBuf);
    if (status == ERROR_SUCCESS) {
        return(TRUE);
    } else {
        EPRINTF((TEXT("Could not set value %s.  Error=%d.\n"),
                ReuseFullPathFromKey(hKeyTo, pszValue, &pszTemp1), status));
        return(FALSE);
    }
}



/*
 * Combines the pszName entries into one string and passes control on to
 * CopyKeyValue().
 */
BOOL CopyKeyValueEx(
HKEY hKeyFrom,
LPTSTR pszValueName,
HKEY hKeyTo,
LPTSTR pszNameTo1,
LPTSTR pszNameTo2)
{
    LPTSTR psz;
    HKEY hKeyToFull;
    LONG status;

    psz = malloc((_tcslen(pszNameTo1) + _tcslen(pszNameTo2) + 2) * sizeof(TCHAR));
    if (psz == NULL) {
        MEMFAILED;
        return(FALSE);
    }
    _tcscpy(psz, pszNameTo1);
    _tcscat(psz, TEXT("\\"));
    _tcscat(psz, pszNameTo2);

    status = LogRegCreateKey(hKeyTo, psz, &hKeyToFull);
    if (status != ERROR_SUCCESS) {
        free(psz);
        return(FALSE);
    }
    free(psz);

    if (!CopyKeyValue(hKeyFrom, hKeyToFull, pszValueName)) {
        EPRINTF((TEXT("Key value %s could not be copied from %s to %s.\n"),
                pszValueName,
                ReuseFullPathFromKey(hKeyFrom, (LPCTSTR)NULL, &pszTemp1),
                ReuseFullPathFromKey(hKeyToFull, (LPCTSTR)NULL, &pszTemp2)));
        LogRegCloseKey(hKeyToFull);
        return(FALSE);
    }
    LogRegCloseKey(hKeyToFull);
    return(TRUE);
}



BOOL AreValuesEqual(
HKEY hSubkey1,
LPTSTR pszValueName1,
HKEY hSubkey2,
LPTSTR pszValueName2)
{
    LONG status;
    BOOL fRet = FALSE;
    DWORD dwType1, cbData1;
    DWORD dwType2, cbData2;
    PVOID pBuf1, pBuf2;

    DPRINTF((TEXT("AreValuesEqual(%s, %s)\n"),
            ReuseFullPathFromKey(hSubkey1, pszValueName1, &pszTemp1),
            ReuseFullPathFromKey(hSubkey2, pszValueName2, &pszTemp2)));

    status = RegQueryValueEx(hSubkey1, pszValueName1, NULL, &dwType1, NULL, &cbData1);
    if (status != ERROR_SUCCESS) {
        EPRINTF((TEXT("Could not get value size of %s. Error=%d.\n"), pszValueName1, status));
        return(FALSE);
    }
    status = RegQueryValueEx(hSubkey2, pszValueName2, NULL, &dwType2, NULL, &cbData2);
    if (status != ERROR_SUCCESS) {
        EPRINTF((TEXT("Could not get value size of %s. Error=%d.\n"), pszValueName2, status));
        return(FALSE);
    }
    if (dwType1 != dwType2 || cbData1 != cbData2) {
        return(FALSE);
    }

    pBuf1 = malloc(cbData1);
    if (pBuf1 == NULL) {
        MEMFAILED;
        return(FALSE);
    }
    status = RegQueryValueEx(hSubkey1, pszValueName1, NULL, &dwType1, pBuf1, &cbData1);
    if (status != ERROR_SUCCESS) {
        EPRINTF((TEXT("Could not get value %s. Error=%d.\n"), pszValueName1, status));
        goto Exit1;
    }

    pBuf2 = malloc(cbData2);
    if (pBuf2 == NULL) {
        MEMFAILED;
        goto Exit1;
    }
    status = RegQueryValueEx(hSubkey2, pszValueName2, NULL, &dwType2, pBuf2, &cbData2);
    if (status != ERROR_SUCCESS) {
        EPRINTF((TEXT("Could not get value %s. Error=%d.\n"), pszValueName2, status));
        goto Exit2;
    }

    fRet = memcmp(pBuf1, pBuf2, cbData1) == 0;
Exit2:
    free(pBuf2);
Exit1:
    free(pBuf1);
    return(fRet);
}


int __cdecl mycmp(
LPCTSTR *ppsz1,
LPCTSTR *ppsz2)
{
    return(_tcscmp(*ppsz1, *ppsz2));
}


VOID FreeSortedValues(
LPTSTR *ppsz,
DWORD cValues)
{
    DWORD i;

    if (cValues) {
        for (i = 0; i < cValues; i++) {
            free(ppsz[i]);
        }
        free(ppsz);
    }
}




LPTSTR * EnumAndSortValues(
HKEY hKey,
DWORD cValues,
DWORD cchMaxValueName)
{
    LONG status;
    LPTSTR *ppsz;
    DWORD cch, dwType, cb;
    DWORD i;

    DPRINTF((TEXT("EnumAndSortValues(%s, %d, %d)\n"),
            ReuseFullPathFromKey(hKey, (LPCTSTR)NULL, &pszTemp1),
            cValues,
            cchMaxValueName));

    cchMaxValueName++;
    ppsz = malloc(cValues * sizeof(LPTSTR));
    if (ppsz == NULL) {
        MEMFAILED;
        return(NULL);
    }
    for (i = 0; i < cValues; i++) {
        ppsz[i] = malloc(cchMaxValueName * sizeof(TCHAR));
        if (ppsz[i] == NULL) {
            MEMFAILED;
            FreeSortedValues(ppsz, i);
            return(NULL);
        }
        cch = cchMaxValueName;
        cb = 0;
        status = RegEnumValue(hKey, i, ppsz[i], &cch, NULL, &dwType, NULL, &cb);
        if (status != ERROR_SUCCESS) {
            if (status != ERROR_NO_MORE_ITEMS) {
                EPRINTF((TEXT("Could not enumerate value %d of %s. Error=%d.\n"),
                i, ReuseFullPathFromKey(hKey, (LPCTSTR)NULL, &pszTemp1), status));
            }
            FreeSortedValues(ppsz, i + 1);
            return(NULL);
        }
    }
    qsort(ppsz, cValues, sizeof(LPTSTR), mycmp);
    if (fDebug && fVerbose) {
        DPRINTF((TEXT("--Value List--\n")));
        for (i = 0; i < cValues; i++) {
            DPRINTF((TEXT("  %s\n"), ppsz[i]));
        }
    }
    return(ppsz);
}




VOID FreeSortedSubkeys(
LPTSTR *ppsz,
DWORD cSubkeys)
{
    DWORD i;

    if (cSubkeys) {
        for (i = 0; i < cSubkeys; i++) {
            free(ppsz[i]);
        }
        free(ppsz);
    }
}




LPTSTR * EnumAndSortSubkeys(
HKEY hKey,
DWORD cSubkeys,
DWORD cchMaxSubkeyName)
{
    LONG status;
    LPTSTR *ppsz;
    DWORD cch;
    FILETIME ft;
    DWORD i;

    DPRINTF((TEXT("EnumAndSortSubkeys(%s, %d, %d)\n"),
            ReuseFullPathFromKey(hKey, (LPCTSTR)NULL, &pszTemp1),
            cSubkeys,
            cchMaxSubkeyName));

    cchMaxSubkeyName++;     // poor APIs take different than what they give.
    ppsz = malloc(cSubkeys * sizeof(LPTSTR));
    if (ppsz == NULL) {
        MEMFAILED;
        return(NULL);
    }
    for (i = 0; i < cSubkeys; i++) {
        ppsz[i] = malloc(cchMaxSubkeyName * sizeof(TCHAR));
        if (ppsz[i] == NULL) {
            MEMFAILED;
            FreeSortedSubkeys(ppsz, i);
            return(NULL);
        }
        cch = cchMaxSubkeyName;
        status = RegEnumKeyEx(hKey, i, ppsz[i], &cch, NULL, NULL, NULL, &ft);
        if (status != ERROR_SUCCESS) {
            if (status != ERROR_NO_MORE_ITEMS) {
                EPRINTF((TEXT("Could not enumerate key %d of %s. Error=%d.\n"),
                i, ReuseFullPathFromKey(hKey, (LPCTSTR)NULL, &pszTemp1), status));
            }
            FreeSortedSubkeys(ppsz, i + 1);
            return(NULL);
        }
    }
    qsort(ppsz, cSubkeys, sizeof(LPTSTR), mycmp);
    if (fDebug && fVerbose) {
        DPRINTF((TEXT("--Subkey List--\n")));
        for (i = 0; i < cSubkeys; i++) {
            DPRINTF((TEXT("  %s\n"), ppsz[i]));
        }
    }
    return(ppsz);
}




/*
 * Recursively compares two nodes in the registry and places the added and
 * deleted differences into subnodes of the Diffkey given.
 *
 * Additions go into hRootDiffKey\pszAddKey\<pszSubkeyName1>
 * Deletions go into hRootDiffKey\pszDelKey\<pszSubkeyName1>
 */
BOOL DiffNodes(
HKEY hKeyRoot,
LPTSTR pszSubkeyName1,  // Key BEFORE changes (modified name)
LPTSTR pszSubkeyName2,  // Key AFTER changes (original name)
HKEY hRootDiffKey)
{
    DWORD status;
    DWORD cSubkeys1, cchMaxSubkey1, cValues1, cchMaxValueName1, cbMaxValueData1;
    DWORD cSubkeys2, cchMaxSubkey2, cValues2, cchMaxValueName2, cbMaxValueData2;
    FILETIME FileTime1, FileTime2;
    HKEY hSubkey1, hSubkey2;
    LPTSTR pszNewSubkeyName1, pszNewSubkeyName2;
    LPTSTR *apszValueName1, *apszValueName2, *apszSubkeyName1, *apszSubkeyName2;
    BOOL fRet;
    DWORD i1, i2;
    int comp;
    LPTSTR pszFullDelKey, pszFullAddKey;

    DPRINTF((TEXT("DiffNodes(%s and %s to %s.)\n"),
            ReuseFullPathFromKey(hKeyRoot, pszSubkeyName1, &pszTemp1),
            ReuseFullPathFromKey(hKeyRoot, pszSubkeyName2, &pszTemp2),
            ReuseFullPathFromKey(hRootDiffKey, (LPCTSTR)NULL, &pszTemp3)));

    if (!GetKeyNameWithPrefix(&pszFullDelKey, hKeyRoot, pszDelKey)) {
        return(FALSE);
    }
    if (!GetKeyNameWithPrefix(&pszFullAddKey, hKeyRoot, pszAddKey)) {
Exit0:
        free(pszFullDelKey);
        return(FALSE);
    }
    /*
     * Skip it if its in the exception list
     */
    for (i1 = 0; i1 < cExceptKeys; i1++) {
        if (!_tcscmp(pszSubkeyName1, ppszExceptKeys[i1])) {
            DPRINTF((TEXT("Diff on node %s EXCEPTED.\n"),
                    ReuseFullPathFromKey(hKeyRoot, pszSubkeyName1, &pszTemp1)));
            return(TRUE);
        }
    }
    /*
     * Open subkeys
     */
    status = LogRegOpenKey(hKeyRoot, pszSubkeyName1, &hSubkey1);
    if (status != ERROR_SUCCESS) {
        EPRINTF((TEXT("Could not open key %s.  Error=%d\n"),
                ReuseFullPathFromKey(hKeyRoot, pszSubkeyName1, &pszTemp1),
                status));
        return(FALSE);
    }
    status = LogRegOpenKey(hKeyRoot, pszSubkeyName2, &hSubkey2);
    if (status != ERROR_SUCCESS) {
        EPRINTF((TEXT("Could not open key %s.  Error=%d\n"),
                ReuseFullPathFromKey(hKeyRoot, pszSubkeyName2, &pszTemp1),
                status));
        EPRINTF((TEXT("Try adding this key to the exception list.\n")));
        return(FALSE);
    }
    /*
     * Enumerate subkeys
     */
    status = MyRegQueryInfoKey(hSubkey1, &cSubkeys1, &cchMaxSubkey1, &cValues1,
            &cchMaxValueName1, &cbMaxValueData1, &FileTime1);
    if (status != ERROR_SUCCESS) {
        if (status != ERROR_NO_MORE_ITEMS) {
            EPRINTF((TEXT("Could not enumerate key %s.  Error=%d.\n"),
                    ReuseFullPathFromKey(hKeyRoot, pszSubkeyName1, &pszTemp1),
                    status));
        }
        return(FALSE);
    }
    cchMaxSubkey1++;
    cchMaxValueName1++;
    cbMaxValueData1++;
    status = MyRegQueryInfoKey(hSubkey2, &cSubkeys2, &cchMaxSubkey2, &cValues2,
            &cchMaxValueName2, &cbMaxValueData2, &FileTime2);
    if (status != ERROR_SUCCESS) {
        if (status != ERROR_NO_MORE_ITEMS) {
            EPRINTF((TEXT("Could not enumerate key %s.  Error=%d.\n"),
                    ReuseFullPathFromKey(hKeyRoot, pszSubkeyName2, &pszTemp1),
                    status));
        }
        return(FALSE);
    }
    cchMaxSubkey2++;
    cchMaxValueName2++;
    cbMaxValueData2++;

    /*
     * Compare subkey values
     */
    if (CompareFileTime(&FileTime1, &FileTime2)) {
        /*
         * Timestamps differ so values may be different.
         *
         * Enumerate values on nodes, sort, and compare.
         */
        if (cValues1) {
            apszValueName1 = EnumAndSortValues(hSubkey1, cValues1, cchMaxValueName1);
            if (apszValueName1 == NULL) {
Exit1:
                LogRegCloseKey(hSubkey1);
                LogRegCloseKey(hSubkey2);
                free(pszFullAddKey);
                goto Exit0;
            }
        }
        if (cValues2) {
            apszValueName2 = EnumAndSortValues(hSubkey2, cValues2, cchMaxValueName2);
            if (apszValueName2 == NULL) {
Exit2:
                FreeSortedValues(apszValueName1, cValues1);
                goto Exit1;
            }
        }
        i1 = i2 = 0;
        while (i1 < cValues1 && i2 < cValues2) {
            comp = _tcscmp(apszValueName1[i1], apszValueName2[i2]);
            if (comp < 0) {
                /*
                 * Value1 is NOT in Key2.  Add Value1 to Del Node.
                 */
                if (!CopyKeyValueEx(hSubkey1, apszValueName1[i1], hRootDiffKey,
                        pszFullDelKey, pszSubkeyName2)) {
Exit3:
                    FreeSortedValues(apszValueName2, cValues2);
                    goto Exit2;
                }
                i1++;
            } else if (comp > 0) {
                /*
                 * Value2 is NOT in Key1,  Add Value2 to Add Node.
                 */
                if (!CopyKeyValueEx(hSubkey2, apszValueName2[i2], hRootDiffKey,
                        pszFullAddKey, pszSubkeyName2)) {
                    goto Exit3;
                }
                i2++;
            } else {
                /*
                 * Compare data of Value1 and Value2
                 */
                if (!AreValuesEqual(hSubkey1, apszValueName1[i1],
                        hSubkey2, apszValueName2[i2])) {
                    /*
                     * Value has changed.  Add to both Add and Del nodes.
                     */
                    if (!CopyKeyValueEx(hSubkey1, apszValueName1[i1], hRootDiffKey,
                            pszFullDelKey, pszSubkeyName2)) {
                        goto Exit3;
                    }
                    if (!CopyKeyValueEx(hSubkey2, apszValueName2[i2], hRootDiffKey,
                            pszFullAddKey, pszSubkeyName2)) {
                        goto Exit3;
                    }
                }
                i1++;
                i2++;
            }
        }
        while (i1 < cValues1) {
            if (!CopyKeyValueEx(hSubkey1, apszValueName1[i1], hRootDiffKey,
                    pszFullDelKey, pszSubkeyName2)) {
                goto Exit3;
            }
            i1++;
        }
        while (i2 < cValues2) {
            if (!CopyKeyValueEx(hSubkey2, apszValueName2[i2], hRootDiffKey,
                    pszFullAddKey, pszSubkeyName2)) {
                goto Exit3;
            }
            i2++;
        }
        FreeSortedValues(apszValueName1, cValues1);
        FreeSortedValues(apszValueName2, cValues2);
    }
    /*
     * Enumerate subkeys and compare.
     */
    if (cSubkeys1) {
        apszSubkeyName1 = EnumAndSortSubkeys(hSubkey1, cSubkeys1, cchMaxSubkey1);
        if (apszSubkeyName1 == NULL) {
            goto Exit1;
        }
    }
    if (cSubkeys2) {
        apszSubkeyName2 = EnumAndSortSubkeys(hSubkey2, cSubkeys2, cchMaxSubkey2);
        if (apszSubkeyName2 == NULL) {
Exit4:
            FreeSortedSubkeys(apszSubkeyName1, cSubkeys1);
            goto Exit1;
        }
    }
    i1 = i2 = 0;
    while (i1 < cSubkeys1 && i2 < cSubkeys2) {
        comp = _tcscmp(apszSubkeyName1[i1], apszSubkeyName2[i2]);
        if (comp < 0) {
            /*
             * Subkey1 is NOT in Key2.  Add Subkey1 to Del Node.
             */
            if (!CopyKeySubkeyEx(hSubkey1, apszSubkeyName1[i1], hRootDiffKey,
                    pszFullDelKey, pszSubkeyName2)) {
Exit5:
                FreeSortedSubkeys(apszSubkeyName2, cSubkeys2);
                goto Exit4;
            }
            i1++;
        } else if (comp > 0) {
            /*
             * Subkey2 is NOT in Key1,  Add Subkey2 to Add Node.
             */
            if (!CopyKeySubkeyEx(hSubkey2, apszSubkeyName2[i2], hRootDiffKey,
                    pszFullAddKey, pszSubkeyName2)) {
                goto Exit5;
            }
            i2++;
        } else {
            /*
             * Compare subkeys of Subkey1 and Subkey2
             */
            pszNewSubkeyName1 = malloc((_tcslen(pszSubkeyName1) +
                    _tcslen(apszSubkeyName1[i1]) + 2) * sizeof(TCHAR));
            if (pszNewSubkeyName1 == NULL) {
                MEMFAILED;
                goto Exit5;
            }
            _tcscpy(pszNewSubkeyName1, pszSubkeyName1);
            _tcscat(pszNewSubkeyName1, TEXT("\\"));
            _tcscat(pszNewSubkeyName1, apszSubkeyName1[i1]);

            pszNewSubkeyName2 = malloc((_tcslen(pszSubkeyName2) +
                    _tcslen(apszSubkeyName2[i2]) + 2) * sizeof(TCHAR));
            if (pszNewSubkeyName2 == NULL) {
                MEMFAILED;
                free(pszNewSubkeyName1);
                goto Exit5;
            }
            _tcscpy(pszNewSubkeyName2, pszSubkeyName2);
            _tcscat(pszNewSubkeyName2, TEXT("\\"));
            _tcscat(pszNewSubkeyName2, apszSubkeyName2[i2]);

            fRet = DiffNodes(hKeyRoot, pszNewSubkeyName1, pszNewSubkeyName2,
                    hRootDiffKey);

            free(pszNewSubkeyName1);
            free(pszNewSubkeyName2);
            if (fRet == FALSE) {
                goto Exit5;
            }
            i1++;
            i2++;
        }
    }
    while (i1 < cSubkeys1) {
        if (!CopyKeySubkeyEx(hSubkey1, apszSubkeyName1[i1], hRootDiffKey,
                pszFullDelKey, pszSubkeyName2)) {
            goto Exit5;
        }
        i1++;
    }
    while (i2 < cSubkeys2) {
        if (!CopyKeySubkeyEx(hSubkey2, apszSubkeyName2[i2], hRootDiffKey,
                pszFullAddKey, pszSubkeyName2)) {
            goto Exit5;
        }
        i2++;
    }
    FreeSortedSubkeys(apszSubkeyName1, cSubkeys1);
    FreeSortedSubkeys(apszSubkeyName2, cSubkeys2);

    LogRegCloseKey(hSubkey1);
    LogRegCloseKey(hSubkey2);
    free(pszFullAddKey);
    free(pszFullDelKey);
    return(TRUE);
}



/*
 * Removes a key and all its subkeys from the registry.  Returns fSuccess.
 */
BOOL DeleteKeyNode(
HKEY hKey,
LPCTSTR lpszSubkey)
{
    LONG status;
    HKEY hSubkey;
    DWORD cSubkeys;
    DWORD cchMaxSubkey;
    DWORD i;
    LPTSTR *apszSubkeyNames;

    if (fDebug) {
        DPRINTF((TEXT("DeleteKeyNode(%s)\n"),
                ReuseFullPathFromKey(hKey, lpszSubkey, &pszTemp1)));
    }

    /*
     * First, just try to delete it.  We might just be lucky!
     */
    status = RegDeleteKey(hKey, lpszSubkey);
    if (status == ERROR_SUCCESS || status == ERROR_FILE_NOT_FOUND) {
        return(TRUE);
    }

    /*
     * Ok ok, so we weren't lucky.
     */
    status = LogRegOpenKey(hKey, lpszSubkey, &hSubkey);
    if (status != ERROR_SUCCESS) {
        EPRINTF((TEXT("Could not open key %s for deletion. Error=%d\n"),
                ReuseFullPathFromKey(hKey, lpszSubkey, &pszTemp1), status));
        return(FALSE);
    }
    status = MyRegQueryInfoKey(hSubkey, &cSubkeys, &cchMaxSubkey, NULL, NULL,
            NULL, NULL);
    if (status != ERROR_SUCCESS) {
        EPRINTF((TEXT("Could not get info on key %s for deletion. Error=%d\n"),
                ReuseFullPathFromKey(hKey, lpszSubkey, &pszTemp1), status));
Exit1:
        LogRegCloseKey(hSubkey);
        return(FALSE);
    }
    cchMaxSubkey++;

    apszSubkeyNames = EnumAndSortSubkeys(hSubkey, cSubkeys, cchMaxSubkey);
    if (apszSubkeyNames == NULL) {
        EPRINTF((TEXT("Could not enumerate key %s for deletion.\n"),
                ReuseFullPathFromKey(hKey, lpszSubkey, &pszTemp1)));
        goto Exit1;
    }
    for (i = 0; i < cSubkeys; i++) {
        DeleteKeyNode(hSubkey, apszSubkeyNames[i]);
    }
    FreeSortedSubkeys(apszSubkeyNames, cSubkeys);

    LogRegCloseKey(hSubkey);
    /*
     * Ok, the key no longer has subkeys so we should be able to delete it now.
     */
    status = RegDeleteKey(hKey, lpszSubkey);
    if (status != ERROR_SUCCESS) {
        EPRINTF((TEXT("Could not delete key %s.  Error=%d.\n"),
                ReuseFullPathFromKey(hKey, lpszSubkey, &pszTemp1), status));
        return(FALSE);
    }
    return(TRUE);
}


LONG MyRegLoadKey(
HKEY hKey,
LPCTSTR pszSubkey,
LPCSTR pszFile)
{
    LONG status;
#ifdef UNICODE
    LPWSTR pszWBuf;

    pszWBuf = malloc((strlen(pszTempFile) + 1) * sizeof(WCHAR));
    if (pszWBuf != NULL) {
        _stprintf(pszWBuf, TEXT("%hs"), pszFile);
        status = RegLoadKey(hKey, pszSubkey, pszWBuf);
        free(pszWBuf);
    } else {
        status = ERROR_NOT_ENOUGH_MEMORY;
    }
#else
    status = RegLoadKey(hKey, pszSubkey, pszFile);
#endif // UNICODE
    return(status);
}




BOOL DiffHive(
LPSTR pszSnapFileIn)
{
    FILE *hfIn, *hfOut;
    LPTSTR pszSubkeyName;
    LPVOID pBuf;
    DWORD cb, i;
    LONG status;
    HKEY hKeyRoot, hKeyDiffRoot;

    DPRINTF((TEXT("DiffHive(%hs)\n"),
            pszSnapFileIn));

    /*
     * remove any diff info laying around in the registry.
     */
    RegUnLoadKey(HKEY_LOCAL_MACHINE, pszDiffRoot);
    DeleteKeyNode(HKEY_LOCAL_MACHINE, pszDiffRoot);
    /*
     * Load an empty file to create the regdiff key off of the
     * HKEY_LOCAL_MACHINE root key.
     * (a hack that should not be necessary!)
     */
    DeleteFileA(pszDummyFile);
    status = MyRegLoadKey(HKEY_LOCAL_MACHINE, pszDiffRoot, pszDummyFile);
    if (status != ERROR_SUCCESS) {
        EPRINTF((TEXT("Unable to load %s\\%s from %hs.\n"),
                pszHKEY_LOCAL_MACHINE, pszDiffRoot, pszDummyFile));
        return(FALSE);
    }

    /*
     * Open snapshot file
     */
    hfIn = fopen(pszSnapFileIn, "rb");
    if (hfIn == NULL) {
        EPRINTF((TEXT("Could not open %hs.\n"), pszSnapFileIn));
        return(FALSE);
    }

    /*
     * for each section...
     */
    DeleteFileA(pszTempFile);   // RegSaveKey will fail if this exists.
    while(fread(&cb, 1, sizeof(DWORD), hfIn) == sizeof(DWORD) && !ferror(hfIn)) {
        /*
         * alocate a buffer for full key name.
         */
        pszSubkeyName = malloc(cb);
        if (pszSubkeyName == NULL) {
            MEMFAILED;
Exit4:
            fclose(hfIn);
            return(FALSE);
        }

        /*
         * read full key name
         */
        if (fread(pszSubkeyName, 1, cb, hfIn) != cb || ferror(hfIn)) {
            EPRINTF((TEXT("Read failure. [key name.]\n")));
Exit6:
            free(pszSubkeyName);
            goto Exit4;
        }

        /*
         * read root key handle
         */
        if (fread(&hKeyRoot, 1, sizeof(HKEY), hfIn) != sizeof(HKEY) || ferror(hfIn)) {
            EPRINTF((TEXT("Read failure. [Root key handle.]\n")));
            goto Exit6;
        }

        /*
         * Find out if pszSubkeyName is covered by our include key list.
         * If so, do a diff on it.
         */
        if (IsKeyWithinNodeList(hKeyRoot, pszSubkeyName, ppszIncludeKeys,
                cIncludeKeys, afIncludeKeyMarks)) {
            /*
             * read sizeof key data
             */
            if (fread(&cb, 1, sizeof(DWORD), hfIn) != sizeof(DWORD) || ferror(hfIn)) {
                EPRINTF((TEXT("Read failure. [key data length.]\n")));
                goto Exit6;
            }
            /*
             * Allocate key data buffer
             */
            pBuf = malloc(cb);
            if (pBuf == NULL) {
                MEMFAILED;
                goto Exit6;
            }
            /*
             * Read key data
             */
            if (fread(pBuf, 1, cb, hfIn) != cb || ferror(hfIn)) {
                EPRINTF((TEXT("Read failure. [key data.]\n")));
Exit7:
                free(pBuf);
                goto Exit6;
            }
            /*
             * Create temp file.
             */
            hfOut = fopen(pszTempFile, "wb");
            if (hfOut == NULL) {
                EPRINTF((TEXT("File open error. [temp file %hs.]\n"),
                        pszTempFile));
                goto Exit7;
            }
            /*
             * Write data to temp file
             */
            if (fwrite(pBuf, 1, cb, hfOut) != cb || ferror(hfOut)) {
                EPRINTF((TEXT("Write failure. [temp file data.]\n")));
Exit8:
                fclose(hfOut);
                goto Exit7;
            }
            /*
             * close temp file
             */
            fclose(hfOut);

            /*
             * load temp file into registry.
             */
            VPRINTF((TEXT("  Loading key %s.\n"),
                    ReuseFullPathFromKey(hKeyRoot, pszSubkeyName, &pszTemp1)));
            status = MyRegLoadKey(hKeyRoot, pszSnapshotSubkeyName, pszTempFile);
            if (status != ERROR_SUCCESS) {
                EPRINTF((TEXT("Could not load key %s from %hs. Error=%d.\n"),
                        ReuseFullPathFromKey(hKeyRoot, pszSnapshotSubkeyName, &pszTemp1),
                        pszTempFile, status));
                goto Exit8;
            }

            status = LogRegCreateKey(HKEY_LOCAL_MACHINE, pszDiffRoot, &hKeyDiffRoot);
            if (status != ERROR_SUCCESS) {
                EPRINTF((TEXT("Could not create %s. Error=%d\n"),
                        ReuseFullPathFromKey(HKEY_LOCAL_MACHINE, pszDiffRoot, &pszTemp1),
                        status));
Exit9:
                status = RegUnLoadKey(hKeyRoot, pszSnapshotSubkeyName);
                if (status != ERROR_SUCCESS) {
                    EPRINTF((TEXT("  Unloading key %s, Error=%d.\n"),
                            ReuseFullPathFromKey(hKeyRoot, pszSnapshotSubkeyName, &pszTemp1),
                            status));
                }
                goto Exit8;
            }
            /*
             * Compare nodes and put differences into add and delete keys
             */

            VPRINTF((TEXT("  Diffing node %s.\n"),
                    ReuseFullPathFromKey(hKeyRoot, pszSubkeyName, &pszTemp1)));
            if (!DiffNodes(hKeyRoot, pszSnapshotSubkeyName, pszSubkeyName,
                    hKeyDiffRoot)) {
                EPRINTF((TEXT("Diff on node %s failed.\n"),
                        ReuseFullPathFromKey(hKeyRoot, pszSubkeyName, &pszTemp1)));
                LogRegCloseKey(hKeyDiffRoot);
//Exit10:
                goto Exit9;
            }

            LogRegCloseKey(hKeyDiffRoot);

            /*
             * unload temporary key node
             */
            VPRINTF((TEXT("  Unloading %s.\n"),
                    ReuseFullPathFromKey(hKeyRoot, pszSubkeyName, &pszTemp1)));
            status = RegUnLoadKey(hKeyRoot, pszSnapshotSubkeyName);
            if (status != ERROR_SUCCESS) {
                DPRINTF((TEXT("Unloading key %s, Error=%d.\n"),
                        ReuseFullPathFromKey(hKeyRoot, pszSnapshotSubkeyName, &pszTemp1),
                        status));
            }

            /*
             * free buffers
             */
            free(pBuf);
        } else {
            /*
             * skip past this snapshot node in the file.
             */
            fseek(hfIn, sizeof(HKEY), SEEK_CUR);
            /*
             * read sizeof key data
             */
            if (fread(&cb, 1, sizeof(DWORD), hfIn) != sizeof(DWORD) || ferror(hfIn)) {
                EPRINTF((TEXT("Read failure. [key data length.]\n")));
                goto Exit6;
            }
            fseek(hfIn, cb, SEEK_CUR);
        }

        free(pszSubkeyName);
        /*
         * delete temp file
         */
        DeleteFileA(pszTempFile);
    }
    /*
     * Close add and delete keys.
     */
    fclose(hfIn);

    /*
     * Make sure all nodes in the include keys list were diffed.
     */
    for (i = 0; i < cIncludeKeys; i++) {
        if (afIncludeKeyMarks[i] == FALSE) {
            WPRINTF((TEXT("Node %s was not included in %hs.\nDiff may be incomplete."),
                    ppszIncludeKeys[i], pszSnapFileIn));
        }
    }
    return(TRUE);
}



/*
 * Adds values and subkeys found on hKeyInfo to hKeyTarget.
 *
 * Returns fSuccess.
 */
BOOL AddNodeInfo(
HKEY hKeyInfo,
HKEY hKeyTarget)
{
    DWORD cSubkeys = (DWORD)-1;
    DWORD cchMaxSubkeyName, cValues, cchMaxValueName;
    LPTSTR pszValueName, pszSubkeyName;
    LONG status;
    DWORD i, cch, dwType, cb;

    if (fDebug) {
        DPRINTF((TEXT("AddNodeInfo(%s, %s)\n"),
                ReuseFullPathFromKey(hKeyInfo, (LPCTSTR)NULL, &pszTemp1),
                ReuseFullPathFromKey(hKeyTarget, (LPCTSTR)NULL, &pszTemp2)));
    }

    if (IsKeyWithinNodeList(hKeyTarget, NULL, ppszExceptKeys, cExceptKeys, NULL)) {
        if (fDebug) {
            DPRINTF((TEXT("Key %s was EXCLUDED.\n"),
                    ReuseFullPathFromKey(hKeyTarget, (LPCTSTR)NULL, &pszTemp1)));
        }
        return(TRUE);   // just fake it - its excluded.
    }

    status = MyRegQueryInfoKey(hKeyInfo, &cSubkeys, &cchMaxSubkeyName,
            &cValues, &cchMaxValueName, NULL, NULL);

    if (status == ERROR_SUCCESS) {
        cchMaxSubkeyName++;
        cchMaxValueName++;
        pszValueName = malloc(cchMaxValueName * sizeof(TCHAR));
        if (pszValueName == NULL) {
            MEMFAILED;
            return(FALSE);
        }
        /*
         * Enumerate all the values and copy them to the target.
         */
        for (i = 0; i < cValues; i++) {
            cch = cchMaxValueName;
            cb = 0;
            status = RegEnumValue(hKeyInfo, i, pszValueName, &cch, NULL, &dwType, NULL, &cb);
            if (status == ERROR_SUCCESS) {
                if (!fSafe) {
                    status = CopyKeyValue(hKeyInfo, hKeyTarget, pszValueName);
                } else {
                    if (fDebug || fVerbose) {
                        WPRINTF((TEXT("Would have copied value \"%s\" to \"%s\".\n"),
                                ReuseFullPathFromKey(hKeyInfo, pszValueName, &pszTemp1),
                                ReuseFullPathFromKey(hKeyTarget, (LPCTSTR)NULL, &pszTemp2)));
                    }
                    status = TRUE;
                }
                if (!status) {
                    EPRINTF((TEXT("Unable to copy value %s from %s to %s.\n"),
                            pszValueName,
                            ReuseFullPathFromKey(hKeyInfo, (LPCTSTR)NULL, &pszTemp1),
                            ReuseFullPathFromKey(hKeyTarget, (LPCTSTR)NULL, &pszTemp2)));
                }
            } else {
                EPRINTF((TEXT("Could not enumerate value %d of %s.\n"),
                        i + 1, ReuseFullPathFromKey(hKeyInfo, (LPCTSTR)NULL, &pszTemp1)));
            }
        }
        free(pszValueName);

        pszSubkeyName = malloc(cchMaxSubkeyName * sizeof(TCHAR));
        if (pszSubkeyName == NULL) {
            MEMFAILED;
            return(0);
        }
        for (i = 0; i < cSubkeys; i++) {
            status = RegEnumKey(hKeyInfo, i, pszSubkeyName, cchMaxSubkeyName);
            if (status == ERROR_SUCCESS) {
                status = CopyKeySubkey(hKeyInfo, pszSubkeyName, hKeyTarget, pszSubkeyName);
                if (!status) {
                    EPRINTF((TEXT("Unable to copy subkey %s.\n"), pszSubkeyName));
                }
            } else {
                EPRINTF((TEXT("Could not enumerate value %d of %d.\n"), i + 1, cSubkeys));
            }
        }
        free(pszSubkeyName);
    }
    return(TRUE);
}



/*
 * Deletes values and leaf keys found on hKeyInfo from hKeyTarget.
 *
 * Returns:
 *  0   error
 *  1   leaf node
 *  2   nonleaf node
 */
int DelNodeInfo(
HKEY hKeyInfo,
HKEY hKeyTarget)
{
    DWORD cSubkeys, i, cch, dwType, cb;
    DWORD cchMaxSubkeyName, cValues, cchMaxValueName;
    LPTSTR pszValueName, pszSubkeyName;
    LONG status;
    int iLeafNode;

    iLeafNode = 0;

    if (fDebug) {
        LPTSTR psz1, psz2;

        psz1 = GetFullPathFromKey(hKeyInfo, NULL);
        psz2 = GetFullPathFromKey(hKeyTarget, NULL);
        DPRINTF((TEXT("DelNodeInfo(%s, %s)\n"), psz1, psz2));
        free(psz1);
        free(psz2);
    }

    if (IsKeyWithinNodeList(hKeyTarget, NULL, ppszExceptKeys, cExceptKeys, NULL)) {
        if (fDebug) {
            LPTSTR psz = GetFullPathFromKey(hKeyTarget, NULL);
            DPRINTF((TEXT("Key %s was EXCLUDED.\n"), psz));
            free(psz);
        }
        return(TRUE);   // just fake it - its excluded.
    }

    status = MyRegQueryInfoKey(hKeyInfo, &cSubkeys, &cchMaxSubkeyName,
            &cValues, &cchMaxValueName, NULL, NULL);

    if (status == ERROR_SUCCESS) {
        cchMaxSubkeyName++;
        cchMaxValueName++;
        pszValueName = malloc(cchMaxValueName * sizeof(TCHAR));
        if (pszValueName == NULL) {
            MEMFAILED;
            return(0);
        }
        /*
         * Enumerate all the values and delete them from the target.
         */
        for (i = 0; i < cValues; i++) {
            cch = cchMaxValueName;
            cb = 0;
            status = RegEnumValue(hKeyInfo, i, pszValueName, &cch, NULL, &dwType, NULL, &cb);
            if (status == ERROR_SUCCESS) {
                if (!fSafe) {
                    status = RegDeleteValue(hKeyTarget, pszValueName);
                } else {
                    if (fDebug || fVerbose) {
                        LPTSTR psz = GetFullPathFromKey(hKeyTarget, NULL);
                        VPRINTF((TEXT("Would have deleted value \"%s\" from \"%s\".\n"),
                                pszValueName, psz));
                        free(psz);
                    }
                    status = ERROR_SUCCESS;
                }
                if (status != ERROR_SUCCESS) {
                    EPRINTF((TEXT("Unable to delete value %s.\n"), pszValueName));
                }
            } else {
                EPRINTF((TEXT("Could not enumerate value %d of %d.\n"), i + 1, cValues));
            }
        }
        free(pszValueName);

        pszSubkeyName = malloc(cchMaxSubkeyName * sizeof(TCHAR));
        if (pszSubkeyName == NULL) {
            MEMFAILED;
            return(0);
        }
        /*
         * Enumerate all the subkeys and recurse.
         */
        for (i = 0; i < cSubkeys; i++) {
            status = RegEnumKey(hKeyInfo, i, pszSubkeyName, cchMaxSubkeyName);
            if (status == ERROR_SUCCESS) {
                HKEY hSubkeyInfo, hSubkeyTarget;

                status = LogRegOpenKey(hKeyInfo, pszSubkeyName, &hSubkeyInfo);
                if (status == ERROR_SUCCESS) {
                    status = LogRegOpenKey(hKeyTarget, pszSubkeyName, &hSubkeyTarget);
                    if (status == ERROR_SUCCESS) {
                        iLeafNode = DelNodeInfo(hSubkeyInfo, hSubkeyTarget);
                        LogRegCloseKey(hSubkeyTarget);
                    } else if (status == ERROR_FILE_NOT_FOUND) {
                        iLeafNode = 2;  // target is gone already.
                    } else {
                        iLeafNode = 0;  // target not accessible.
                        EPRINTF((TEXT("%s could not be deleted.\n"), pszSubkeyName));
                    }
                    LogRegCloseKey(hSubkeyInfo);
                } else {
                    iLeafNode = 0;   // somethings wrong with our info.
                }
                if (iLeafNode == 1) {
                    /*
                     * If the key is a leaf, delete it.
                     */
                    if (!fSafe) {
                        status = RegDeleteKey(hKeyTarget, pszSubkeyName);    // leaf
                        if (status != ERROR_SUCCESS && status != ERROR_FILE_NOT_FOUND) {
                            LPTSTR psz = GetFullPathFromKey(hKeyTarget, NULL);
                            EPRINTF((TEXT("Could not delete key \"%s\" from \"%s\".\n"),
                                    pszSubkeyName, psz));
                            free(psz);
                        }
                    } else if (fDebug || fVerbose) {
                        LPTSTR psz = GetFullPathFromKey(hKeyTarget, NULL);
                        VPRINTF((TEXT("Would have deleted key \"%s\" from \"%s\"\n"),
                                pszSubkeyName, psz));
                        free(psz);
                    }
                } else if (iLeafNode == 0) {
                    /*
                     * propigate errors upline.
                     */
                    free(pszSubkeyName);
                    return(0);
                }
            }
        }
        free(pszSubkeyName);
        /*
         * Now reenumerate the TARGET key to find out if its now a leaf.
         */
        MyRegQueryInfoKey(hKeyTarget, &cSubkeys, NULL, &cValues,
                NULL, NULL, NULL);

        if (cSubkeys == 0 && cValues == 0) {
            iLeafNode = 1;
        } else {
            iLeafNode = 2;
        }
    }
    return(iLeafNode);
}


/*
 * The DiffRoot contains subkeys of the form:
 *  diffroot\add\canonicalkeyname
 *  diffroot\del\canonicalkeyname
 *
 * The pszAddKey and pszDelKey allow this function to work in reverse.
 *
 * returns fSuccess.
 */
BOOL MergeHive(
LPTSTR pszAddName,
LPTSTR pszDelName)
{
    LONG status;
    HKEY hKeyDiffRoot, hKeyRoot, hKey;

    DPRINTF((TEXT("MergeHive(%s, %s)\n"),
            pszAddName, pszDelName));

    status = LogRegOpenKey(HKEY_LOCAL_MACHINE, pszDiffRoot, &hKeyDiffRoot);
    if (status != ERROR_SUCCESS) {
        if (status != ERROR_FILE_NOT_FOUND) {
            EPRINTF((TEXT("Could not open key KEY_LOCAL_MACHINE\\%s.  Error=%d.\n"),
                    pszDiffRoot, status));
        } else {
            VPRINTF((TEXT("No diff information found.\n")));
        }
        return(FALSE);
    }

    status = LogRegOpenKey(hKeyDiffRoot, pszDelName, &hKeyRoot);
    if (status == ERROR_SUCCESS) {
        status = LogRegOpenKey(hKeyRoot, pszHKEY_LOCAL_MACHINE, &hKey);
        if (status == ERROR_SUCCESS) {
            DelNodeInfo(hKey, HKEY_LOCAL_MACHINE);
            LogRegCloseKey(hKey);
        }
        status = LogRegOpenKey(hKeyRoot, pszHKEY_USERS, &hKey);
        if (status == ERROR_SUCCESS) {
            DelNodeInfo(hKey, HKEY_USERS);
            LogRegCloseKey(hKey);
        }
        LogRegCloseKey(hKeyRoot);
    }

    status = LogRegOpenKey(hKeyDiffRoot, pszAddName, &hKeyRoot);
    if (status == ERROR_SUCCESS) {
        status = LogRegOpenKey(hKeyRoot, pszHKEY_LOCAL_MACHINE, &hKey);
        if (status == ERROR_SUCCESS) {
            AddNodeInfo(hKey, HKEY_LOCAL_MACHINE);
            LogRegCloseKey(hKey);
        }
        status = LogRegOpenKey(hKeyRoot, pszHKEY_USERS, &hKey);
        if (status == ERROR_SUCCESS) {
            AddNodeInfo(hKey, HKEY_USERS);
            LogRegCloseKey(hKey);
        }
        LogRegCloseKey(hKeyRoot);
    }

    LogRegCloseKey(hKeyDiffRoot);
    return(TRUE);
}




BOOL ReadNodeListFile(
LPSTR pszFile,
LPTSTR **papszNodeList,
DWORD *pcNodes,
BOOL **pafNodeMarks)
{
    FILE *hfIn;
    TCHAR szBuf[MAX_PATH];
    LPTSTR pszEOL, pszRootkey, pszSubkey;
    HKEY hKeyRoot;
    BOOL fFree;

    DPRINTF((TEXT("ReadNodeListFile(%hs)\n"), pszFile));

    *pcNodes = 0;
    if (pafNodeMarks != NULL) {
        *pafNodeMarks = NULL;
    }
    *papszNodeList = NULL;

    hfIn = fopen(pszFile, "r");
    if (hfIn == NULL) {
        EPRINTF((TEXT("Could not read %hs.\n"), pszFile));
        return(FALSE);
    }
    while (!feof(hfIn)) {
        if (fgets((char *)szBuf, MAX_PATH * sizeof(TCHAR), hfIn) == NULL) {
            break;
        }
#ifdef UNICODE
        {
            WCHAR szwBuf[MAX_PATH];

            _stprintf(szwBuf, TEXT("%hs"), (LPTSTR)szBuf);
            _tcscpy(szBuf, szwBuf);
        }
#endif
        pszEOL = _tcsrchr(szBuf, TEXT('\n'));
        if (pszEOL == NULL) {
            EPRINTF((TEXT("Line too long in %hs.\n"), pszFile));
            return(FALSE);
        }
        *pszEOL = TEXT('\0');
        if (!KeyPartsFromNodeName(szBuf, &pszRootkey, &pszSubkey, &hKeyRoot, &fFree)) {
            EPRINTF((TEXT("Invalid path %s in %hs.\n"), szBuf, pszFile));
            if (fFree) {
                free(pszSubkey);
            }
            return(FALSE);
        }
        if (*pcNodes == 0) {
            *papszNodeList = malloc(sizeof(LPTSTR));
            if (*papszNodeList == NULL) {
                MEMFAILED;
                return(FALSE);
            }
        } else {
            *papszNodeList = realloc(*papszNodeList, sizeof(LPTSTR) * ((*pcNodes) + 1));
            if (*papszNodeList == NULL) {
                MEMFAILED;
                return(FALSE);
            }
        }
        (*papszNodeList)[*pcNodes] = malloc((_tcslen(pszRootkey) +
                _tcslen(pszSubkey) + 2) * sizeof(TCHAR));
        if ((*papszNodeList)[*pcNodes] == NULL) {
            MEMFAILED;
            return(FALSE);
        }
        _tcscpy((*papszNodeList)[*pcNodes], pszRootkey);
        _tcscat((*papszNodeList)[*pcNodes], TEXT("\\"));
        _tcscat((*papszNodeList)[*pcNodes], pszSubkey);
        DPRINTF((TEXT("Read in %s\n"), (*papszNodeList)[*pcNodes]));
        (*pcNodes)++;
        if (fFree) {
            free(pszSubkey);
        }
    }

    fclose(hfIn);
    if (pafNodeMarks != NULL) {
        *pafNodeMarks = malloc(sizeof(BOOL) * (*pcNodes));
        if (*pafNodeMarks == NULL) {
            MEMFAILED;
            return(FALSE);
        }
        /*
         * Set all NodeMarks to FALSE.
         */
        memset(*pafNodeMarks, 0, sizeof(BOOL) * (*pcNodes));
    }
    return((*pcNodes) != 0);
}




__cdecl CDECL main (argc, argv)
    int argc;
    char *argv[];
{
    DWORD i;

    if (argc == 1) {
        PrintUsage();
        return(1);
    }

    /*
     * find out what the nodename is for the current user (current SID text form)
     * so we can snapshot the current user the same way we do other root nodes.
     */
    pszCurUserSID = GetCurUserSidString();
    if (pszCurUserSID == NULL) {
        EPRINTF((TEXT("Could not get current user SID.\n")));
        return(1);
    }
    DPRINTF((TEXT("Current user Sid:%s\n"), pszCurUserSID));
    /*
     * Set up pszHKEY_CURRENT_USER_Real
     */
    pszHKEY_CURRENT_USER_Real = malloc((_tcslen(pszHKEY_USERS) + 1 +
            _tcslen(pszCurUserSID) + 1) * sizeof(TCHAR));
    if (pszHKEY_CURRENT_USER_Real == NULL) {
        MEMFAILED;
        return(1);
    }
    _tcscpy(pszHKEY_CURRENT_USER_Real, pszHKEY_USERS);
    _tcscat(pszHKEY_CURRENT_USER_Real, TEXT("\\"));
    _tcscat(pszHKEY_CURRENT_USER_Real, pszCurUserSID);

    while (++argv && *argv != NULL) {
        if (*argv[0] == TEXT('-') || *argv[0] == TEXT('/')) {
            switch ((*argv)[1]) {
            case TEXT('s'):
            case TEXT('S'):
                fSnap = TRUE;
                argv++;
                if (*argv == NULL) {
                    PrintUsage();
                    return(1);
                }
                pszSnapFileOut = *argv;
                break;

            case TEXT('d'):
            case TEXT('D'):
                fDiff = TRUE;
                argv++;
                if (*argv == NULL) {
                    PrintUsage();
                    return(1);
                }
                pszSnapFileIn = *argv;
                break;

            case TEXT('l'):
            case TEXT('L'):
                fLoadDiffInfo = TRUE;
                argv++;
                if (*argv == NULL) {
                    PrintUsage();
                    return(1);
                }
                pszDiffFileIn = *argv;
                break;

            case TEXT('w'):
            case TEXT('W'):
                fWriteDiffInfo = TRUE;
                argv++;
                if (*argv == NULL) {
                    PrintUsage();
                    return(1);
                }
                pszDiffFileOut = *argv;
                break;

            case TEXT('e'):
            case TEXT('E'):
                fEraseInputFileWhenDone = TRUE;
                break;

            case TEXT('m'):
            case TEXT('M'):
                fMerge = TRUE;
                break;

            case TEXT('b'):
            case TEXT('B'):
                fBreak = TRUE;
                break;

            case TEXT('u'):
            case TEXT('U'):
                fUnmerge = TRUE;
                break;

            case TEXT('r'):
            case TEXT('R'):
                fRemoveDiffInfo = TRUE;
                break;

            case TEXT('n'):
            case TEXT('N'):
                fSafe = TRUE;
                break;

            case TEXT('v'):
            case TEXT('V'):
                fVerbose = TRUE;
                break;

            case TEXT('x'):
            case TEXT('X'):
                argv++;
                if (*argv == NULL) {
                    PrintUsage();
                    return(1);
                }
                if (!ReadNodeListFile(*argv, &ppszExceptKeys,
                        &cExceptKeys, NULL)) {
                    PrintUsage();
                    return(1);
                }
                fExclusionListSpecified = TRUE;
                break;

            case TEXT('i'):
            case TEXT('I'):
                argv++;
                if (*argv == NULL) {
                    PrintUsage();
                    return(1);
                }
                if (!ReadNodeListFile(*argv, &ppszIncludeKeys,
                        &cIncludeKeys, &pfIncludeKeyMarks)) {
                    PrintUsage();
                    return(1);
                }
                fInclusionListSpecified = TRUE;
                break;

            case TEXT('@'):
                fDebug = TRUE;
                break;

            default:
                PrintUsage();
                return(1);
            }
        } else {
            PrintUsage();
            return(1);
        }
    }

    DPRINTF((TEXT("fEraseInputFileWhenDone = %d\n"), fEraseInputFileWhenDone));
    DPRINTF((TEXT("fSnap = %d\n"), fSnap));
    DPRINTF((TEXT("fDiff = %d\n"), fDiff));
    DPRINTF((TEXT("fMerge = %d\n"), fMerge));
    DPRINTF((TEXT("fUnmerge = %d\n"), fUnmerge));
    DPRINTF((TEXT("fRemoveDiffInfo = %d\n"), fRemoveDiffInfo));
    DPRINTF((TEXT("fWriteDiffInfo = %d\n"), fWriteDiffInfo));
    DPRINTF((TEXT("fDebug = %d\n"), fDebug));
    DPRINTF((TEXT("fVerbose = %d\n"), fVerbose));
    DPRINTF((TEXT("fBreak = %d\n"), fBreak));

    if (pszSnapFileIn != NULL) {
        DPRINTF((TEXT("pszSnapFileIn = %hs\n"), pszSnapFileIn));
    }
    if (pszSnapFileOut != NULL) {
        DPRINTF((TEXT("pszSnapFileOut = %hs\n"), pszSnapFileOut));
    }
    if (pszDiffFileIn != NULL) {
        DPRINTF((TEXT("pszDiffFileIn = %hs\n"), pszDiffFileIn));
    }
    if (pszDiffFileOut != NULL) {
        DPRINTF((TEXT("pszDiffFileOut = %hs\n"), pszDiffFileOut));
    }

    /*
     * The registry APIs need us to get Backup and Restore privileges
     * to work correctly.
     */
    if (!EnablePrivilege(SE_BACKUP_NAME)) {
        EPRINTF((TEXT("Could not gain %s privilege."), SE_BACKUP_NAME));
        return(0);
    }
    if (!EnablePrivilege(SE_RESTORE_NAME)) {
        EPRINTF((TEXT("Could not gain %s privilege."), SE_RESTORE_NAME));
        return(0);
    }
#if 0   // other privileges that regedit has we may need.
    if (!EnablePrivilege(SE_CHANGE_NOTIFY_NAME)) {
        EPRINTF((TEXT("Could not gain %s privilege."), SE_CHANGE_NOTIFY_NAME));
        return(0);
    }
    if (!EnablePrivilege(SE_SECURITY_NAME)) {
        EPRINTF((TEXT("Could not gain %s privilege."), SE_SECURITY_NAME));
        return(0);
    }
#endif // 0

    /*
     * Normalize our inlcude and exception lists before we start.
     */
    for (i = 0; i < cExceptKeys; i++) {
        apszExceptKeys[i] = NormalizePathName(ppszExceptKeys[i], NULL);
    }
    for (i = 0; i < cIncludeKeys; i++) {
        apszIncludeKeys[i] = NormalizePathName(ppszIncludeKeys[i], NULL);
    }
    /*
     * Let the debug dudes see the lists.
     */
    if (fDebug) {
        _tprintf(TEXT("\nUsing normalized inclusion list:\n"));
        for (i = 0; i < cIncludeKeys; i++) {
            _tprintf(TEXT("  %s\n"), ppszIncludeKeys[i]);
        }
        _tprintf(TEXT("\nUsing normalized exclusion list:\n"));
        for (i = 0; i < cExceptKeys; i++) {
            _tprintf(TEXT("  %s\n"), ppszExceptKeys[i]);
        }
    }

    /*
     * Make sure snapshot key is unloaded - help insure
     * temp file is useable.
     */
    RegUnLoadKey(HKEY_LOCAL_MACHINE, pszSnapshotSubkeyName);
    RegUnLoadKey(HKEY_USERS, pszSnapshotSubkeyName);

    if (fVerbose) {
        if (fInclusionListSpecified) {
            _tprintf(TEXT("Using inclusion list:\n"));
            for (i = 0; i < cIncludeKeys; i++) {
                _tprintf(TEXT("  %s\n"), ppszIncludeKeys[i]);
            }
            _tprintf(TEXT("\n"));
        }
        if (fExclusionListSpecified) {
            _tprintf(TEXT("Using exception list:\n"));
            for (i = 0; i < cExceptKeys; i++) {
                _tprintf(TEXT("  %s\n"), ppszExceptKeys[i]);
            }
            _tprintf(TEXT("\n"));
        }
    }
    if (fSnap) {
        VPRINTF((TEXT("Snapping registry.\n")));
        SnapHives(pszSnapFileOut);
        _tprintf(TEXT("\n"));
    }
    if (fDiff) {
        VPRINTF((TEXT("Diffing current registry with %hs.\n"), pszSnapFileIn));
        DiffHive(pszSnapFileIn);
        _tprintf(TEXT("\n"));
    } else if (fLoadDiffInfo) {
        LONG status;

        RegUnLoadKey(HKEY_LOCAL_MACHINE, pszDiffRoot);   // incase a dummy is loaded
        VPRINTF((TEXT("Loading diff info from %hs.\n"), pszDiffFileIn));
        status = MyRegLoadKey(HKEY_LOCAL_MACHINE, pszDiffRoot, pszDiffFileIn);
        if (status != ERROR_SUCCESS) {
            EPRINTF((TEXT("Could not load key %s. Error=%d.\n"), pszDiffRoot, status));
            return(0);
        }
        _tprintf(TEXT("\n"));
    }
    if (fLoadDiffInfo && fDiff) {
        WPRINTF((TEXT("Ignoring -l flag.  Diff info was already created by diff operation.\n")));
    }
    if (fMerge) {
        VPRINTF((TEXT("Mergeing diff info into current registry.\n")));
        MergeHive(pszAddKey, pszDelKey);
        _tprintf(TEXT("\n"));
    }
    if (fUnmerge) {
        VPRINTF((TEXT("Unmergeing diff info from current registry.\n")));
        MergeHive(pszDelKey, pszAddKey);
        _tprintf(TEXT("\n"));
    }
    if (fWriteDiffInfo) {
        HKEY hKey;
        LONG status;

        DeleteFileA(pszDiffFileOut);     // cannot already exist.
        VPRINTF((TEXT("Saving diff info to %hs.\n"), pszDiffFileOut));
        status = LogRegOpenKey(HKEY_LOCAL_MACHINE, pszDiffRoot, &hKey);
        if (status != ERROR_SUCCESS) {
            EPRINTF((TEXT("Could not open key HKEY_LOCAL_MACHINE\\%s. Error=%d.\n"),
                    pszDiffRoot, status));
            return(0);
        }
        status = RegSaveKeyA(hKey, pszDiffFileOut, NULL);
        if (status != ERROR_SUCCESS) {
            EPRINTF((TEXT("Could not save key %s. Error=%d.\n"), pszDiffRoot, status));
            return(0);
        }
        LogRegCloseKey(hKey);
        _tprintf(TEXT("\n"));
    }
    if (fEraseInputFileWhenDone) {
        if (pszDiffFileIn != NULL) {
            VPRINTF((TEXT("Erasing diff info file %hs.\n"), pszDiffFileIn));
            DeleteFileA(pszDiffFileIn);
        }
        if (pszSnapFileIn != NULL) {
            VPRINTF((TEXT("Erasing snapshot file %hs.\n"), pszSnapFileIn));
            DeleteFileA(pszSnapFileIn);
        }
        _tprintf(TEXT("\n"));
    }
    if (fRemoveDiffInfo) {
        VPRINTF((TEXT("Unloading diff info from registry.\n")));
        /*
         * Don't leave loaded keys in
         */
        RegUnLoadKey(HKEY_LOCAL_MACHINE, pszDiffRoot);
        _tprintf(TEXT("\n"));
    }

    DeleteSidString(pszCurUserSID);

    while (pKeyLogList != NULL) {
        EPRINTF((TEXT("Leftover open key:%x, %x, %s.\n"),
                pKeyLogList->hKey,
                pKeyLogList->hKeyParent,
                pKeyLogList->psz));
        LogRegCloseKey(pKeyLogList->hKey);
    }
    DeleteFileA(pszDummyFile);
    DeleteFileA(pszDummyFileLog);
    DeleteFileA(pszTempFile);
    DeleteFileA(pszTempFile2);
    DeleteFileA(pszTempFileLog);
    DeleteFileA(pszTempFile2Log);
    return(0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\regini\regback.c ===
/*

    regback.c - registry backup program

    this program allows the user to back up active registry hives,
    while the system is running.

    basic structure:

        DoFullBackup ennumerate entries in HiveList, computes which
        ones to save and where, and calls DoSpecificBackup for each.

        Three argument case of app is just a call to DoSpecificBackup.

*/

#include "regutil.h"

#define MACH_NAME   L"machine"
#define USERS_NAME  L"users"

BOOLEAN DumpUserHive;
PWSTR DirectoryPath;
PWSTR UserHiveFileName;
PWSTR HivePath;
HKEY HiveRoot;
PWSTR HiveName;

LONG
DoFullBackup(
    PWSTR DirectoryPath,
    PWSTR UserHiveFileName
    );

LONG
DoSpecificBackup(
    PWSTR HivePath,
    HKEY HiveRoot,
    PWSTR HiveName
    );


BOOL
CtrlCHandler(
    IN ULONG CtrlType
    )
{
    RTDisconnectFromRegistry( &RegistryContext );
    return FALSE;
}


int
__cdecl
main(
    int argc,
    char *argv[]
    )
{
    char *s;
    LONG Error;
    PWSTR w;

    if (!RTEnableBackupRestorePrivilege()) {
        FatalError( "Unable to enable backup/restore priviledge.", 0, 0 );
        }

    InitCommonCode( CtrlCHandler,
                    "REGBACK",
                    "directoryPath [-u | -U outputFile]",
                    "directoryPath specifies where to save the output files.\n"
                    "\n"
                    "-u specifies to dump the logged on user's profile.  Default name is\n"
                    "   username.dat  User -U with a file name to save it under a different name.\n"
                    "\n"
                    "outputFile specifies the file name to use for the user profile\n"
                    "\n"
                    "If the -m switch is specified to backup the registry of a remote machine\n"
                    "   then the directoryPath is relative to that machine.\n"
                  );

    DirectoryPath = NULL;
    UserHiveFileName = NULL;
    HivePath = NULL;
    HiveRoot = NULL;
    HiveName = NULL;
    while (--argc) {
        s = *++argv;
        if (*s == '-' || *s == '/') {
            while (*++s) {
                switch( tolower( *s ) ) {
                    case 'u':
                        DumpUserHive = TRUE;
                        if (*s == 'U') {
                            if (!--argc) {
                                Usage( "Missing argument to -U switch", 0 );
                                }

                            UserHiveFileName = GetArgAsUnicode( *++argv );
                            }

                        break;

                    default:
                        CommonSwitchProcessing( &argc, &argv, *s );
                        break;
                    }
                }
            }
        else
        if (DirectoryPath == NULL) {
            HivePath = DirectoryPath = GetArgAsUnicode( s );
            }
        else
        if (HivePath != NULL) {
            if (HiveRoot == NULL) {
                w = GetArgAsUnicode( s );
                if (!_wcsicmp( w, MACH_NAME )) {
                    HiveRoot = HKEY_LOCAL_MACHINE;
                    }
                else
                if (!_wcsicmp( w, USERS_NAME )) {
                    HiveRoot = HKEY_USERS;
                    }
                else {
                    Usage( "Invalid hive type specified (%ws)", (ULONG_PTR)w );
                    }
                }
            else
            if (HiveName == NULL) {
                HiveName = GetArgAsUnicode( s );
                }
            else {
                Usage( "Too many arguments specified.", 0 );
                }
            }
        else {
            Usage( NULL, 0 );
            }
        }

    if (DirectoryPath == NULL) {
        Usage( NULL, 0 );
        }

    Error = RTConnectToRegistry( MachineName,
                                 HiveFileName,
                                 HiveRootName,
                                 Win95Path,
                                 Win95UserPath,
                                 NULL,
                                 &RegistryContext
                               );
    if (Error != NO_ERROR) {
        FatalError( "Unable to access registry specifed (%u)", Error, 0 );
        }

    if (HiveRoot == NULL) {
        Error = DoFullBackup( DirectoryPath, UserHiveFileName );
        }
    else {
        Error = DoSpecificBackup( HivePath, HiveRoot, HiveName );
        }

    RTDisconnectFromRegistry( &RegistryContext );
    return Error;
}

typedef BOOL (*PFNGETPROFILESDIRECTORYW)(LPWSTR lpProfile, LPDWORD dwSize);


LONG
DoFullBackup(
    PWSTR DirectoryPath,
    PWSTR UserHiveFileName
    )

/*++

Routine Description:

    Scan the hivelist, for each hive which has a file (i.e. not hardware)
    if the file is in the config dir (e.g. not some remote profile) call
    DoSpecificBackup to save the hive out.

Arguments:

    DirectoryPath - specifies where to write the output files.

    UserHiveFileName - optional parameter that specifies the name of the file
                       to use when saving the user profile.  If NULL, then
                       username.dat is used.

Return Value:

    0 for success, otherwise, non-zero error code.

--*/
{
    PWSTR w;
    LONG Error;
    HKEY HiveListKey;
    PWSTR KeyName;
    PWSTR FileName;
    PWSTR Name;
    DWORD ValueIndex;
    DWORD ValueType;
    DWORD ValueNameLength;
    DWORD ValueDataLength;
    WCHAR ConfigPath[ MAX_PATH ];
    WCHAR ProfilePath[ MAX_PATH ];
    WCHAR HiveName[ MAX_PATH ];
    WCHAR HivePath[ MAX_PATH ];
    WCHAR FilePath[ MAX_PATH ];
    DWORD dwSize;
    HANDLE hInstDll;
    PFNGETPROFILESDIRECTORYW pfnGetProfilesDirectory;


    hInstDll = LoadLibrary (TEXT("userenv.dll"));

    if (!hInstDll) {
        return (GetLastError());
    }

    pfnGetProfilesDirectory = (PFNGETPROFILESDIRECTORYW)GetProcAddress (hInstDll,
                                        "GetProfilesDirectoryW");

    if (!pfnGetProfilesDirectory) {
        FreeLibrary (hInstDll);
        return (GetLastError());
    }

    dwSize = MAX_PATH;
    if (!pfnGetProfilesDirectory(ProfilePath, &dwSize)) {
        FreeLibrary (hInstDll);
        return (GetLastError());
    }

    FreeLibrary (hInstDll);



    //
    // get handle to hivelist key
    //
    KeyName = L"HKEY_LOCAL_MACHINE\\System\\CurrentControlSet\\Control\\Hivelist";
    Error = RTOpenKey( &RegistryContext,
                       NULL,
                       KeyName,
                       MAXIMUM_ALLOWED,
                       0,
                       &HiveListKey
                     );

    if (Error != NO_ERROR) {
        FatalError( "Unable to open key '%ws' (%u)\n",
                    (ULONG_PTR)KeyName,
                    (ULONG)Error
                  );
        return Error;
        }

    //
    // get path data for system hive, which will allow us to compute
    // path name to config dir in form that hivelist uses.
    // (an NT internal form of path)  this is NOT the way the path to
    // the config directory should generally be computed.
    //

    ValueDataLength = sizeof( ConfigPath );
    Error = RTQueryValueKey( &RegistryContext,
                             HiveListKey,
                             L"\\Registry\\Machine\\System",
                             &ValueType,
                             &ValueDataLength,
                             ConfigPath
                            );
    if (Error != NO_ERROR) {
        FatalError( "Unable to query 'SYSTEM' hive path.", 0, Error );
        }
    w = wcsrchr( ConfigPath, L'\\' );
    if (w) {
        *w = UNICODE_NULL;
    }


    //
    // ennumerate entries in hivelist.  for each entry, find it's hive file
    // path.  if it's file path matches ConfigPath, then save it.
    // else, print a message telling the user that it must be saved
    // manually, unless the file name is of the form ....\username\ntuser.dat
    // in which case save it as username.dat
    //
    for (ValueIndex = 0; TRUE; ValueIndex++) {
        ValueType = REG_NONE;
        ValueNameLength = sizeof( HiveName ) / sizeof( WCHAR );
        ValueDataLength = sizeof( HivePath );
        Error = RTEnumerateValueKey( &RegistryContext,
                                     HiveListKey,
                                     ValueIndex,
                                     &ValueType,
                                     &ValueNameLength,
                                     HiveName,
                                     &ValueDataLength,
                                     HivePath
                                   );
        if (Error == ERROR_NO_MORE_ITEMS) {
            break;
            }
        else
        if (Error != NO_ERROR) {
            return Error;
            }

        if (ValueType == REG_SZ && ValueDataLength > sizeof( UNICODE_NULL )) {
            //
            // there's a file, compute it's path, hive branch, etc
            //

            if (w = wcsrchr( HivePath, L'\\' )) {
                *w++ = UNICODE_NULL;
                }
            FileName = w;

            if (w = wcsrchr( HiveName, L'\\' )) {
                *w++ = UNICODE_NULL;
                }
            Name = w;

            HiveRoot = NULL;
            if (w = wcsrchr( HiveName, L'\\' )) {
                w += 1;
                if (!_wcsicmp( w, L"MACHINE" )) {
                    HiveRoot = HKEY_LOCAL_MACHINE;
                    }
                else
                if (!_wcsicmp( w, L"USER" )) {
                    HiveRoot = HKEY_USERS;
                    }
                else {
                    Error = ERROR_PATH_NOT_FOUND;
                    }
                }

            if (FileName != NULL && Name != NULL && HiveRoot != NULL) {
                if (!wcscmp( ConfigPath, HivePath )) {
                    //
                    // hive's file is in config dir, we can back it up
                    // without fear of collision
                    //
                    swprintf( FilePath, L"%s\\%s", DirectoryPath, FileName );
                    Error = DoSpecificBackup( FilePath,
                                              HiveRoot,
                                              Name
                                            );
                    }
                else
                if (DumpUserHive && !_wcsnicmp( ProfilePath, HivePath, wcslen( ProfilePath ) )) {
                    //
                    // hive's file is in profile dir, we can back it up
                    // without fear of collision if we use username.dat
                    // for the file name.
                    //
                    if (UserHiveFileName != NULL) {
                        FileName = UserHiveFileName;
                        }
                    else {
                        FileName = wcsrchr(HivePath, '\\') + 1;
                        }
                    swprintf( FilePath, L"%s\\%s.dat", DirectoryPath, FileName );

                    printf( "%ws %ws %ws\n",
                            FilePath,
                            HiveRoot == HKEY_LOCAL_MACHINE ? MACH_NAME : USERS_NAME,
                            Name
                          );
                    Error = DoSpecificBackup( FilePath,
                                              HiveRoot,
                                              Name
                                            );
                    }
                else {
                    printf( "\n***Hive = '%ws'\\'%ws'\nStored in file '%ws'\\'%ws'\n",
                            HiveName,
                            Name,
                            HivePath,
                            FileName
                          );
                    printf( "Must be backed up manually\n" );
                    printf( "regback <filename you choose> %ws %ws\n\n",
                            HiveRoot == HKEY_LOCAL_MACHINE ? MACH_NAME : USERS_NAME,
                            Name
                          );
                    }
                }
            }
        }

    return Error;
}


LONG
DoSpecificBackup(
    PWSTR HivePath,
    HKEY HiveRoot,
    PWSTR HiveName
    )
/*
    Do backup of one hive to one file.  Any valid hive and any
    valid file will do.  RegSaveKey does all the real work.

    Arguments:
        HivePath - file name to pass directly to OS

        HiveRoot - HKEY_LOCAL_MACHINE or HKEY_USERS

        HiveName - 1st level subkey under machine or users
*/
{
    HKEY HiveKey;
    ULONG Disposition;
    LONG Error;
    char *Reason;

    //
    // print some status
    //
    printf( "saving %ws to %ws", HiveName, HivePath );

    //
    // get a handle to the hive.  use special create call what will
    // use privileges
    //

    Reason = "accessing";
    Error = RTCreateKey( &RegistryContext,
                         HiveRoot,
                         HiveName,
                         KEY_READ,
                         REG_OPTION_BACKUP_RESTORE,
                         NULL,
                         &HiveKey,
                         &Disposition
                       );
    if (Error == NO_ERROR) {
        Reason = "saving";
        Error = RegSaveKey( HiveKey, HivePath, NULL );
        RTCloseKey( &RegistryContext, HiveKey );
        }

    if (Error != NO_ERROR) {
        printf( " - error %s (%u)\n", Reason, Error );
        }
    else {
        printf( "\n" );
        }
    return Error;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\regini\regdir.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    regdir.c

Abstract:

    Utility to display all or part of the registry directory.

    REGDIR [KeyPath]

    Will ennumerate and dump out the subkeys and values of KeyPath,
    and then apply itself recursively to each subkey it finds.

    Default KeyPath if none specified is \Registry

Author:

    Steve Wood (stevewo)  12-Mar-92

Revision History:

--*/

#include "regutil.h"

void
DumpValues(
    HKEY KeyHandle,
    PWSTR KeyName,
    ULONG Depth
    );

void
DumpKeys(
    HKEY ParentKeyHandle,
    PWSTR KeyName,
    ULONG Depth
    );


BOOLEAN RecurseIntoSubkeys = FALSE;


BOOL
CtrlCHandler(
    IN ULONG CtrlType
    )
{
    RTDisconnectFromRegistry( &RegistryContext );
    return FALSE;
}

int
__cdecl
main(
    int argc,
    char *argv[]
    )
{
    ULONG n;
    char *s;
    LONG Error;
    PWSTR RegistryPath;

    InitCommonCode( CtrlCHandler,
                    "REGDIR",
                    "[-r] registryPath",
                    "-r specifies to recurse into subdirectories\n"
                    "registryPath specifies where to start displaying.\n"
                  );

    RegistryPath = NULL;
    while (--argc) {
        s = *++argv;
        if (*s == '-' || *s == '/') {
            while (*++s) {
                switch( tolower( *s ) ) {
                    case 'r':
                        RecurseIntoSubkeys = TRUE;
                        break;

                    default:
                        CommonSwitchProcessing( &argc, &argv, *s );
                        break;
                    }
                }
            }
        else
        if (RegistryPath == NULL) {
            RegistryPath = GetArgAsUnicode( s );
            }
        else {
            Usage( "May only specify one registry path to display", 0 );
            }
        }

    Error = RTConnectToRegistry( MachineName,
                                 HiveFileName,
                                 HiveRootName,
                                 Win95Path,
                                 Win95UserPath,
                                 &RegistryPath,
                                 &RegistryContext
                               );
    if (Error != NO_ERROR) {
        FatalError( "Unable to access registry specifed (%u)", Error, 0 );
        }

    DumpKeys( RegistryContext.HiveRootHandle, RegistryPath, 0 );

    RTDisconnectFromRegistry( &RegistryContext );
    return 0;
}

void
DumpKeys(
    HKEY ParentKeyHandle,
    PWSTR KeyName,
    ULONG Depth
    )
{
    LONG Error;
    HKEY KeyHandle;
    ULONG SubKeyIndex;
    WCHAR SubKeyName[ MAX_PATH ];
    ULONG SubKeyNameLength;
    FILETIME LastWriteTime;

    Error = RTOpenKey( &RegistryContext,
                       ParentKeyHandle,
                       KeyName,
                       MAXIMUM_ALLOWED,
                       REG_OPTION_OPEN_LINK,
                       &KeyHandle
                     );

    if (Error != NO_ERROR) {
        if (Depth == 0) {
            FatalError( "Unable to open key '%ws' (%u)\n",
                        (ULONG_PTR)KeyName,
                        (ULONG)Error
                      );
            }

        if (DebugOutput) {
            fprintf( stderr,
                     "Unable to open key '%ws' (%u)\n",
                     KeyName,
                     (ULONG)Error
                   );
            }

        return;
        }

    //
    // Print name of node we are about to dump out
    //
    printf( "%.*s%ws",
            Depth * IndentMultiple,
            "                                                                                  ",
            KeyName
          );
    RTFormatKeySecurity( (PREG_OUTPUT_ROUTINE)fprintf, stdout, KeyHandle, NULL );
    printf( "\n" );

    //
    // Print out node's values
    //
    if (Depth != 1 || RecurseIntoSubkeys) {
        DumpValues( KeyHandle, KeyName, Depth + 1 );
        }

    //
    // Enumerate node's children and apply ourselves to each one
    //

    if (Depth == 0 || RecurseIntoSubkeys) {
        for (SubKeyIndex = 0; TRUE; SubKeyIndex++) {
            SubKeyNameLength = sizeof( SubKeyName ) / sizeof(WCHAR);
            Error = RTEnumerateKey( &RegistryContext,
                                    KeyHandle,
                                    SubKeyIndex,
                                    &LastWriteTime,
                                    &SubKeyNameLength,
                                    SubKeyName
                                  );

            if (Error != NO_ERROR) {
                if (Error != ERROR_NO_MORE_ITEMS && Error != ERROR_ACCESS_DENIED) {
                    fprintf( stderr,
                             "RTEnumerateKey( %ws ) failed (%u), skipping\n",
                             KeyName,
                             Error
                           );
                    }

                break;
                }

            DumpKeys( KeyHandle, SubKeyName, Depth + 1 );
            }
        }

    RTCloseKey( &RegistryContext, KeyHandle );

    return;
}

void
DumpValues(
    HKEY KeyHandle,
    PWSTR KeyName,
    ULONG Depth
    )
{
    LONG Error;
    DWORD ValueIndex;
    DWORD ValueType;
    DWORD ValueNameLength;
    WCHAR ValueName[ MAX_PATH ];
    DWORD ValueDataLength;

    for (ValueIndex = 0; TRUE; ValueIndex++) {
        ValueType = REG_NONE;
        ValueNameLength = sizeof( ValueName ) / sizeof( WCHAR );
        ValueDataLength = OldValueBufferSize;
        Error = RTEnumerateValueKey( &RegistryContext,
                                     KeyHandle,
                                     ValueIndex,
                                     &ValueType,
                                     &ValueNameLength,
                                     ValueName,
                                     &ValueDataLength,
                                     OldValueBuffer
                                   );
        if (Error == NO_ERROR) {
            RTFormatKeyValue( OutputWidth,
                              (PREG_OUTPUT_ROUTINE)fprintf,
                              stdout,
                              TRUE,
                              Depth * IndentMultiple,
                              ValueName,
                              ValueDataLength,
                              ValueType,
                              OldValueBuffer
                            );
            }
        else
        if (Error == ERROR_NO_MORE_ITEMS) {
            return;
            }
        else {
            if (DebugOutput) {
                fprintf( stderr,
                         "RTEnumerateValueKey( %ws ) failed (%u)\n",
                         KeyName,
                         Error
                       );
                }

            return;
            }
        }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\regini\regdmp.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    regdmp.c

Abstract:

    Utility to display all or part of the registry in a format that
    is suitable for input to the REGINI program.

    REGDMP [KeyPath]

    Will ennumerate and dump out the subkeys and values of KeyPath,
    and then apply itself recursively to each subkey it finds.

    Handles all value types (e.g. REG_???) defined in ntregapi.h

    Default KeyPath if none specified is \Registry

Author:

    Steve Wood (stevewo)  12-Mar-92

Revision History:

--*/

#include "regutil.h"

BOOL
DumpValues(
    HKEY KeyHandle,
    PWSTR KeyName,
    ULONG Depth
    );

void
DumpKeys(
    HKEY ParentKeyHandle,
    PWSTR KeyName,
    PWSTR FullPath,
    ULONG Depth
    );

BOOLEAN SummaryOutput;

BOOL
CtrlCHandler(
    IN ULONG CtrlType
    )
{
    RTDisconnectFromRegistry( &RegistryContext );
    return FALSE;
}


int
__cdecl
main(
    int argc,
    char *argv[]
    )
{
    ULONG n;
    char *s;
    LONG Error;
    PWSTR RegistryPath;

    InitCommonCode( CtrlCHandler,
                    "REGDMP",
                    "[-s] [-o outputWidth] registryPath",
                    "-s specifies summary output.  Value names, type and first line of data\n"
                    "\n"
                    "registryPath specifies where to start dumping.\n"
                    "\n"
                    "If REGDMP detects any REG_SZ or REG_EXPAND_SZ that is missing the\n"
                    "trailing null character, it will prefix the value string with the\n"
                    "following text: (*** MISSING TRAILING NULL CHARACTER ***)\n"
                    "The REGFIND tool can be used to clean these up, as this is a common\n"
                    "programming error.\n"
                  );

    RegistryPath = NULL;
    while (--argc) {
        s = *++argv;
        if (*s == '-' || *s == '/') {
            while (*++s) {
                switch( tolower( *s ) ) {
                    case 'f':
                        FullPathOutput = TRUE;
                        break;

                    case 's':
                        SummaryOutput = TRUE;
                        break;

                    default:
                        CommonSwitchProcessing( &argc, &argv, *s );
                        break;
                    }
                }
            }
        else
        if (RegistryPath == NULL) {
            RegistryPath = GetArgAsUnicode( s );
            }
        else {
            Usage( "May only specify one registry path to dump", 0 );
            }
        }

    Error = RTConnectToRegistry( MachineName,
                                 HiveFileName,
                                 HiveRootName,
                                 Win95Path,
                                 Win95UserPath,
                                 &RegistryPath,
                                 &RegistryContext
                               );
    if (Error != NO_ERROR) {
        FatalError( "Unable to access registry specifed (%u)", Error, 0 );
        }

    DumpKeys( RegistryContext.HiveRootHandle, RegistryPath, RegistryPath, 0 );

    RTDisconnectFromRegistry( &RegistryContext );
    return 0;
}

void
DumpKeys(
    HKEY ParentKeyHandle,
    PWSTR KeyName,
    PWSTR FullPath,
    ULONG Depth
    )
{
    LONG Error;
    HKEY KeyHandle;
    ULONG SubKeyIndex;
    WCHAR SubKeyName[ MAX_PATH ];
    ULONG SubKeyNameLength;
    WCHAR ComputeFullPath[ MAX_PATH ];
    FILETIME LastWriteTime;
    BOOL AnyValues;

    Error = RTOpenKey( &RegistryContext,
                       ParentKeyHandle,
                       KeyName,
                       MAXIMUM_ALLOWED,
                       REG_OPTION_OPEN_LINK,
                       &KeyHandle
                     );

    if (Error != NO_ERROR) {
        if (Depth == 0) {
            FatalError( "Unable to open key '%ws' (%u)\n",
                        (ULONG_PTR)KeyName,
                        (ULONG)Error
                      );
            }

        return;
        }

    //
    // Print name of node we are about to dump out
    //

    if (!FullPathOutput) {

        RTFormatKeyName( (PREG_OUTPUT_ROUTINE)fprintf, stdout, Depth * IndentMultiple, KeyName );
        RTFormatKeySecurity( (PREG_OUTPUT_ROUTINE)fprintf, stdout, KeyHandle, NULL );
        printf( "\n" );
        }

    //
    // Print out node's values
    //
    if (FullPathOutput)
        AnyValues = DumpValues( KeyHandle, FullPath, 0 );
    else
        DumpValues( KeyHandle, KeyName, Depth + 1 );

    //
    // Enumerate node's children and apply ourselves to each one
    //

    for (SubKeyIndex = 0; TRUE; SubKeyIndex++) {
        SubKeyNameLength = sizeof( SubKeyName ) / sizeof(WCHAR);
        Error = RTEnumerateKey( &RegistryContext,
                                KeyHandle,
                                SubKeyIndex,
                                &LastWriteTime,
                                &SubKeyNameLength,
                                SubKeyName
                              );

        if (Error != NO_ERROR) {
            if (Error != ERROR_NO_MORE_ITEMS && Error != ERROR_ACCESS_DENIED) {
                fprintf( stderr,
                         "RTEnumerateKey( %ws ) failed (%u), skipping\n",
                         KeyName,
                         Error
                       );
                }

            break;
            }

        if (FullPathOutput) {

            wcscpy(ComputeFullPath, FullPath);
            wcscat(ComputeFullPath, L"\\");
            wcscat(ComputeFullPath, SubKeyName);
            }

        DumpKeys( KeyHandle, SubKeyName, ComputeFullPath, Depth + 1 );
        }

    if (FullPathOutput) {
        if (SubKeyIndex == 0) {
            if (!AnyValues) {
                fprintf(stdout, "%ws\n", FullPath );
                }
            }
        }

    RTCloseKey( &RegistryContext, KeyHandle );

    return;
}

BOOL
DumpValues(
    HKEY KeyHandle,
    PWSTR KeyName,
    ULONG Depth
    )
{
    LONG Error;
    DWORD ValueIndex;
    DWORD ValueType;
    DWORD ValueNameLength;
    WCHAR ValueName[ MAX_PATH ];
    DWORD ValueDataLength;

    for (ValueIndex = 0; TRUE; ValueIndex++) {
        ValueType = REG_NONE;
        ValueNameLength = sizeof( ValueName ) / sizeof( WCHAR );
        ValueDataLength = OldValueBufferSize;
        Error = RTEnumerateValueKey( &RegistryContext,
                                     KeyHandle,
                                     ValueIndex,
                                     &ValueType,
                                     &ValueNameLength,
                                     ValueName,
                                     &ValueDataLength,
                                     OldValueBuffer
                                   );
        if (Error == NO_ERROR) {

            if (FullPathOutput) {
                fprintf(stdout, "%ws -> ", KeyName );
                }

            RTFormatKeyValue( OutputWidth,
                              (PREG_OUTPUT_ROUTINE)fprintf,
                              stdout,
                              SummaryOutput,
                              Depth * IndentMultiple,
                              ValueName,
                              ValueDataLength,
                              ValueType,
                              OldValueBuffer
                            );
            }
        else
        if (Error == ERROR_NO_MORE_ITEMS) {
            if (ValueIndex == 0) {
                return FALSE;
                }
            else {
                return TRUE;
                }
            }
        else {
            if (DebugOutput) {
                fprintf( stderr,
                         "RTEnumerateValueKey( %ws ) failed (%u)\n",
                         KeyName,
                         Error
                       );
                }

            return FALSE;
            }
        }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\regini\regfind.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    regfind.c

Abstract:

    Utility to search all or part of the registry for a particular
    string value.  The search string is a literal, the format of which
    depends upon the data type.

    REGFIND [-p KeyPath] [-n | -t DataType] searchString

    Will ennumerate and all the subkeys and values of KeyPath,
    applying itself recursively to each subkey it finds.  For each
    value find that is of the appropriate type, it will search the
    value for a match.  If found, it will print out the path and data
    of the value. The -n flag tells the program to search the names
    of keys and values for searchString and print out any that contain
    the searchString.

    Default KeyPath if none specified is \Registry

    Default DataType is any of the _SZ registry data types (REG_SZ,
    REG_EXPAND_SZ or REG_MULTI_SZ).

Author:

    Steve Wood (stevewo)  08-Nov-95

Revision History:

--*/

#include "regutil.h"

void
SearchValues(
    PWSTR KeyName,
    HKEY KeyHandle,
    ULONG Depth
    );

void
SearchKeys(
    PWSTR KeyName,
    HKEY ParentKeyHandle,
    ULONG Depth
    );


BOOLEAN IgnoreCase;
BOOLEAN SearchKeyAndValueNames;
BOOLEAN IncludeBinaryDataInTextSearch;
BOOLEAN LookForAnsiInBinaryData;
BOOLEAN SearchingForMatchOnDataLength;
ULONG SearchValueType;
BOOLEAN ReplaceSZwithEXPAND_SZ;
BOOLEAN SearchForMissingNULLs;
BOOLEAN FixupMissingNULLs;

#define REG_ANY_SZ  12

typedef struct _VALUE_BUFFER {
    PVOID Base;
    ULONG Length;
    ULONG MaximumLength;
    PWSTR CurrentDest;
} VALUE_BUFFER, *PVALUE_BUFFER;


PVALUE_BUFFER SearchBuffer;
PVOID SearchData;
ULONG SearchDataLength;
WCHAR SearchData1UpperCase[ 2 ];
LPSTR SearchDataAnsi;
ULONG SearchDataAnsiLength;
UCHAR SearchDataAnsi1UpperCase[ 2 ];

PVALUE_BUFFER ReplacementBuffer;
PVOID ReplacementData;
ULONG ReplacementDataLength;
LPSTR ReplacementDataAnsi;
ULONG ReplacementDataAnsiLength;

BOOLEAN
AppendToValueBuffer(
    PVALUE_BUFFER p,
    PWSTR s
    )
{
    ULONG n, cb;

    n = wcslen( s );
    cb = n * sizeof( WCHAR );

    if ((cb + p->Length + sizeof( WCHAR )) >= p->MaximumLength) {
        return FALSE;
        }

    if (p->Length != 0) {
        *(p->CurrentDest)++ = L' ';
        p->Length += 1;
        }

    memcpy( p->CurrentDest, s, cb );
    p->Length += cb;
    p->CurrentDest += n;
    return TRUE;
}


PVALUE_BUFFER
AllocateValueBuffer(
    ULONG MaximumLength,
    PWSTR InitialContents
    )
{
    PVALUE_BUFFER p;

    p = (PVALUE_BUFFER)VirtualAlloc( NULL, MaximumLength, MEM_COMMIT, PAGE_READWRITE );
    if (p != NULL) {
        p->Base = (p+1);
        p->MaximumLength = MaximumLength;
        p->Length = 0;
        p->CurrentDest = (PWSTR)p->Base;
        if (InitialContents != NULL) {
            AppendToValueBuffer( p, InitialContents );
            }
        }

    return p;
}


PVOID
ApplyReplacementBuffer(
    IN OUT PULONG ValueDataLength,
    IN PVOID Match,
    OUT PBOOLEAN BufferOverflow
    )
{
    ULONG LengthBeforeMatch;
    LONG DeltaLength;

    if (ReplacementBuffer == NULL) {
        return NULL;
        }

    LengthBeforeMatch = (ULONG)((PCHAR)Match - (PCHAR)OldValueBuffer);
    DeltaLength = ReplacementDataLength - SearchDataLength;
    if (DeltaLength <= 0) {
        memcpy( Match, ReplacementData, ReplacementDataLength );
        Match = (PCHAR)Match + ReplacementDataLength;
        if (DeltaLength < 0) {
            memcpy( Match,
                    (PCHAR)Match - DeltaLength,
                    *ValueDataLength - LengthBeforeMatch - ReplacementDataLength
                  );
            }
        }
    else {
        if (*ValueDataLength + DeltaLength > OldValueBufferSize) {
            *BufferOverflow = TRUE;
            return NULL;
            }

        memmove( (PCHAR)Match + DeltaLength,
                 Match,
                 *ValueDataLength - LengthBeforeMatch
               );
        memcpy( Match, ReplacementData, ReplacementDataLength );
        Match = (PCHAR)Match + ReplacementDataLength;
        }

    *ValueDataLength += DeltaLength;
    return Match;
}

typedef struct _KEY_INFO {
    PWSTR Name;
    BOOLEAN NameDisplayed;
} KEY_INFO, *PKEY_INFO;

#define MAX_LEVELS 256

KEY_INFO KeyPathInfo[ MAX_LEVELS ];

void
DisplayPath(
    PKEY_INFO p,
    ULONG Depth
    )
{
    ULONG i;

    for (i=0; i<Depth; i++) {
        if (!p[ i ].NameDisplayed) {
            p[ i ].NameDisplayed = TRUE;
            RTFormatKeyName( (PREG_OUTPUT_ROUTINE)fprintf, stdout, i * IndentMultiple, p[ i ].Name );
            printf( "\n" );
            }
        }
}


BOOL
CtrlCHandler(
    IN ULONG CtrlType
    )
{
    RTDisconnectFromRegistry( &RegistryContext );
    return FALSE;
}

int
__cdecl main(
    int argc,
    char *argv[]
    )
{
    char *s, *s1;
    LONG Error;
    ULONG Type;
    PWSTR KeyName;
    PWSTR SearchValueTypeString;
    REG_UNICODE_PARSE ParsedLine;


    InitCommonCode( CtrlCHandler,
                    "REGFIND",
                    "[-p RegistryKeyPath] [-z | -t DataType] [-b | -B] [-y] [-n]\n"
                    "    [searchString [-r ReplacementString]]\n",
                    "-p RegistryKeyPath specifies where to start searching\n"
                    "\n"
                    "-t specifies which registry types to look at:\n"
                    "       REG_SZ, REG_MULTI_SZ, REG_EXPAND_SZ\n"
                    "       REG_DWORD, REG_BINARY, REG_NONE\n"
                    "   Default is any of the _SZ types\n"
                    "\n"
                    "-b only valid with _SZ searches, and specifies that REGFIND should\n"
                    "   look for occurrences of the searchString inside of REG_BINARY data.\n"
                    "   May not be specified with a replacementString that is not the same length\n"
                    "   as the searchString\n"
                    "\n"
                    "-B same as -b but also looks for ANSI version of string within REG_BINARY values.\n"
                    "\n"
                    "-y only valid with _SZ searches, and specifies that REGFIND should\n"
                    "   ignore case when searching.\n"
                    "\n"
                    "-n specifies to include key and value names in the search.\n"
                    "   May not specify -n with -t\n"
                    "\n"
                    "-z specifies to search for REG_SZ and REG_EXPAND_SZ values that\n"
                    "   are missing a trailing null character and/or have a length that is\n"
                    "   not a multiple of the size of a Unicode character.  If -r is also\n"
                    "   specified then any replacement string is ignored, and REGFIND will\n"
                    "   add the missing null character and/or adjust the length up to an\n"
                    "   even multiple of the size of a Unicode character.\n"
                    "\n"
                    "searchString is the value to search for.  Use quotes if it contains\n"
                    "   any spaces.  If searchString is not specified, just searches based on type.\n"
                    "\n"
                    "-r replacementString is an optional replacement string to replace any\n"
                    "   matches with.\n"
                    "\n"
                    "searchString and replacementString must be of the same type as specified\n"
                    "to the -t switch.  For any of the _SZ types, it is just a string\n"
                    "For REG_DWORD, it is a single number (i.e. 0x1000 or 4096)\n"
                    "For REG_BINARY, it is a number specifing #bytes, optionally followed by \n"
                    "the actual bytes, with a separate number for each DWORD\n"
                    "    (e.g. 0x06 0x12345678 0x1234)\n"
                    "If just the byte count is specified, then REGFIND will search for all\n"
                    "REG_BINARY values that have that length.  May not search for length\n"
                    "and specify -r\n"
                    "\n"
                    "When doing replacements, REGFIND displays the value AFTER the replacement\n"
                    "has been.  It is usually best to run REGFIND once without the -r switch\n"
                    "to see what will be change before it is changed.\n"
                    "\n"
                  );

    IgnoreCase = FALSE;
    SearchKeyAndValueNames = FALSE;
    IncludeBinaryDataInTextSearch = FALSE;
    LookForAnsiInBinaryData = FALSE;
    SearchingForMatchOnDataLength = FALSE;
    SearchValueType = REG_ANY_SZ;
    SearchValueTypeString = NULL;
    SearchBuffer = NULL;
    ReplacementBuffer = NULL;
    ReplaceSZwithEXPAND_SZ = FALSE;

    KeyName = NULL;
    while (--argc) {
        s = *++argv;
        if (*s == '-' || *s == '/') {
            while (*++s) {
                switch( tolower( *s ) ) {
                    case 'y':
                        IgnoreCase = TRUE;
                        break;

                    case 'n':
                        SearchKeyAndValueNames = TRUE;
                        break;

                    case 'z':
                        SearchForMissingNULLs = TRUE;
                        break;

                    case 'p':
                        if (!--argc) {
                            Usage( "Missing argument to -p switch", 0 );
                            }

                        KeyName = GetArgAsUnicode( *++argv );
                        break;

                    case 'b':
                        IncludeBinaryDataInTextSearch = TRUE;
                        if (*s == 'B') {
                            LookForAnsiInBinaryData = TRUE;
                            }
                        break;

                    case 't':
                        if (!--argc) {
                            Usage( "Missing argument to -t switch", 0 );
                            }

                        s1 = *++argv;
                        if (!_stricmp( s1, "REG_SZ" )) {
                            SearchValueType = REG_SZ;
                            }
                        else
                        if (!_stricmp( s1, "REG_EXPAND_SZ" )) {
                            SearchValueType = REG_EXPAND_SZ;
                            }
                        else
                        if (!_stricmp( s1, "REG_MULTI_SZ" )) {
                            SearchValueType = REG_MULTI_SZ;
                            }
                        else
                        if (!_stricmp( s1, "REG_DWORD" )) {
                            SearchValueType = REG_DWORD;
                            SearchValueTypeString = L"REG_DWORD";
                            }
                        else
                        if (!_stricmp( s1, "REG_BINARY" )) {
                            SearchValueType = REG_BINARY;
                            SearchValueTypeString = L"REG_BINARY";
                            }
                        else
                        if (!_stricmp( s1, "REG_NONE" )) {
                            SearchValueType = REG_NONE;
                            }
                        else {
                            Usage( "Invalid argument (%s) to the -t switch\n", 
                                   (ULONG_PTR)s1 );
                            }
                        break;

                    case 'r':
                        if (SearchForMissingNULLs) {
                            FixupMissingNULLs = TRUE;
                            }
                        else {
                            if (SearchBuffer == NULL) {
                                Usage( "May not specify -r without a searchString first", 0 );
                                }

                            ReplacementBuffer = AllocateValueBuffer( 63 * 1024,
                                                                     SearchValueTypeString
                                                                   );
                            if (ReplacementBuffer == NULL) {
                                FatalError( "Unable to allocate buffer for replacement string", 0, 0 );
                                }
                            }
                        break;

                    default:
                        CommonSwitchProcessing( &argc, &argv, *s );
                    }
                }
            }
        else {
            if (SearchBuffer == NULL) {
                SearchBuffer = AllocateValueBuffer( 63 * 1024,
                                                    SearchValueTypeString
                                                  );
                if (SearchBuffer == NULL) {
                    FatalError( "Unable to allocate buffer for search string", 0, 0 );
                    }
                }

            if (ReplacementBuffer != NULL) {
                if (!AppendToValueBuffer( ReplacementBuffer, GetArgAsUnicode( s ) )) {
                    FatalError( "replacementString too long (> %d bytes)", ReplacementBuffer->MaximumLength, 0 );
                    }
                }
            else
            if (!AppendToValueBuffer( SearchBuffer, GetArgAsUnicode( s ) )) {
                FatalError( "searchString too long (> %d bytes)", SearchBuffer->MaximumLength, 0 );
                }
            }
        }

    if (SearchKeyAndValueNames) {
        if (SearchValueType != REG_ANY_SZ) {
            Usage( "May not specify -n with -t", 0 );
            }

        if (ReplacementBuffer != NULL) {
            Usage( "May not specify -n with -r", 0 );
            }

        if (SearchForMissingNULLs) {
            Usage( "May not specify -n with -z", 0 );
            }

        }

    if ((IncludeBinaryDataInTextSearch || IgnoreCase) &&
        SearchValueType != REG_ANY_SZ &&
        SearchValueType != REG_SZ &&
        SearchValueType != REG_MULTI_SZ &&
        SearchValueType != REG_EXPAND_SZ
       ) {
        Usage( "May not specify -b or -y with -t other than _SZ types", 0 );
        }

    if (SearchForMissingNULLs) {
        if (SearchBuffer != NULL) {
            Usage( "May not specify -z with a searchString", 0 );
            }

        if (SearchValueType != REG_ANY_SZ) {
            Usage( "May not specify -z with -t", 0 );
            }

        if (IncludeBinaryDataInTextSearch) {
            Usage( "May not specify -z with -b", 0 );
            }

        if (IgnoreCase) {
            Usage( "May not specify -z with -y", 0 );
            }
        }
    else
    if (SearchBuffer == NULL && SearchValueType == REG_ANY_SZ) {
        Usage( "No search type or string specified", 0 );
        }

    if (SearchBuffer != NULL && SearchValueType == REG_NONE) {
        Usage( "May not specify a searchString when searching for REG_NONE type", 0 );
        }

    Error = RTConnectToRegistry( MachineName,
                                 HiveFileName,
                                 HiveRootName,
                                 Win95Path,
                                 Win95UserPath,
                                 &KeyName,
                                 &RegistryContext
                               );
    if (Error != NO_ERROR) {
        FatalError( "Unable to access registry specifed (%u)", Error, 0 );
        }

    if (SearchBuffer != NULL) {
        RtlZeroMemory( &ParsedLine, sizeof( ParsedLine ) );
        ParsedLine.ValueString = SearchBuffer->Base;
        if (!RTParseValueData( NULL,
                               &ParsedLine,
                               SearchBuffer->Base,
                               SearchBuffer->MaximumLength,
                               &Type,
                               &SearchData,
                               &SearchDataLength
                             )
           ) {
            if (Type == REG_BINARY &&
                SearchDataLength != 0 &&
                GetLastError() == ERROR_NO_DATA
               ) {
                if (SearchValueType != REG_BINARY) {
                    FatalError( "May only search for REG_BINARY datalength with -t REG_BINARY\n", 0, 0 );
                    }

                if (ReplacementBuffer != NULL) {
                    FatalError( "May not specify replacementString if searching for REG_BINARY datalength\n", 0, 0 );
                    }

                SearchingForMatchOnDataLength = TRUE;
                }
            else {
                FatalError( "Invalid searchString format (%u)", GetLastError(), 0 );
                }
            }

        if (Type == REG_SZ || Type == REG_EXPAND_SZ) {
            SearchDataLength -= sizeof( UNICODE_NULL );
            }

        if (SearchDataLength == 0) {
            FatalError( "Zero length search string specified", 0, 0 );
            }

        if (IgnoreCase) {
            SearchData1UpperCase[ 0 ] = *(PWSTR)SearchData;
            SearchData1UpperCase[ 1 ] = UNICODE_NULL;
            _wcsupr( SearchData1UpperCase );
            }

        if (LookForAnsiInBinaryData) {
            SearchDataAnsiLength = SearchDataLength / sizeof( WCHAR );
            SearchDataAnsi = HeapAlloc( GetProcessHeap(), 0, SearchDataAnsiLength );
            if (SearchDataAnsi == NULL) {
                FatalError( "Unable to allocate buffer for ANSI search string", 0, 0 );
                }

            if (WideCharToMultiByte( CP_ACP,
                                     0,
                                     SearchData,
                                     SearchDataAnsiLength,
                                     SearchDataAnsi,
                                     SearchDataAnsiLength,
                                     NULL,
                                     NULL
                                   ) != (LONG)SearchDataAnsiLength
               ) {
                FatalError( "Unable to get ANSI representation of search string", 0, 0 );
                }

            if (IgnoreCase) {
                SearchDataAnsi1UpperCase[ 0 ] = *SearchDataAnsi;
                SearchDataAnsi1UpperCase[ 1 ] = '\0';
                _strupr( SearchDataAnsi1UpperCase );
                }
            }
        }

    if (ReplacementBuffer != NULL) {
        RtlZeroMemory( &ParsedLine, sizeof( ParsedLine ) );
        ParsedLine.ValueString = ReplacementBuffer->Base;
        if (!RTParseValueData( NULL,
                               &ParsedLine,
                               ReplacementBuffer->Base,
                               ReplacementBuffer->MaximumLength,
                               &Type,
                               &ReplacementData,
                               &ReplacementDataLength
                             )
           ) {
            FatalError( "Invalid replacementString format (%u)", GetLastError(), 0 );
            }

        if (Type == REG_SZ || Type == REG_EXPAND_SZ) {
            ReplacementDataLength -= sizeof( UNICODE_NULL );
            }

        if (Type != SearchValueType &&
            (SearchValueType == REG_ANY_SZ && Type != REG_SZ) ||
            (SearchValueType == REG_SZ && Type != REG_EXPAND_SZ)
           ) {
            FatalError( "Incompatible search and replacement types", 0, 0 );
            }

        if (Type == REG_EXPAND_SZ && SearchValueType == REG_SZ) {
            ReplaceSZwithEXPAND_SZ = TRUE;
            }

        if (LookForAnsiInBinaryData) {
            ReplacementDataAnsiLength = ReplacementDataLength / sizeof( WCHAR );
            ReplacementDataAnsi = HeapAlloc( GetProcessHeap(), 0, ReplacementDataAnsiLength );
            if (ReplacementDataAnsi == NULL) {
                FatalError( "Unable to allocate buffer for ANSI replacement string", 0, 0 );
                }

            if (WideCharToMultiByte( CP_ACP,
                                     0,
                                     ReplacementData,
                                     ReplacementDataAnsiLength,
                                     ReplacementDataAnsi,
                                     ReplacementDataAnsiLength,
                                     NULL,
                                     NULL
                                   ) != (LONG)ReplacementDataAnsiLength
               ) {
                FatalError( "Unable to get ANSI representation of replacement string", 0, 0 );
                }
            }
        }

    //
    // Print name of the tree we are about to search
    //
    fprintf( stderr, "Scanning %ws registry tree\n", KeyName );
    if (SearchForMissingNULLs) {
        fprintf( stderr,
                 "Searching for any REG_SZ or REG_EXPAND_SZ value missing a trailing\n"
                 "    NULL character and/or whose length is not a multiple of the\n"
                 "    size of a Unicode character.\n"
               );
        if (FixupMissingNULLs) {
            fprintf( stderr,
                     "Will add the missing NULL whereever needed and/or adjust\n"
                     "    the length up to an even multiple of the size of a Unicode\n"
                     "    character.\n"
                   );
            }
        }
    else
    if (SearchingForMatchOnDataLength) {
        fprintf( stderr,
                 "Searching for any REG_BINARY value with a length of %08x\n",
                 SearchDataLength
               );
        }
    else {
        if (SearchBuffer == NULL) {
            fprintf( stderr, "Searching for any match based on type\n" );
            }
        else {
            fprintf( stderr,
                     "%sSearch for '%ws'\n",
                     IgnoreCase ? "Case Insensitive " : "",
                     SearchBuffer->Base
                   );
            }

        fprintf( stderr, "Will match values of type:" );
        if (SearchValueType == REG_ANY_SZ ||
            SearchValueType == REG_SZ
           ) {
            fprintf( stderr, " REG_SZ" );
            }
        if (SearchValueType == REG_ANY_SZ ||
            SearchValueType == REG_EXPAND_SZ
           ) {
            fprintf( stderr, " REG_EXPAND_SZ" );
            }
        if (SearchValueType == REG_ANY_SZ ||
            SearchValueType == REG_MULTI_SZ
           ) {
            fprintf( stderr, " REG_MULTI_SZ" );
            }
        if (SearchValueType == REG_DWORD) {
            fprintf( stderr, " REG_DWORD" );
            }
        if (SearchValueType == REG_BINARY) {
            fprintf( stderr, " REG_BINARY" );
            }
        if (SearchValueType == REG_NONE) {
            fprintf( stderr, " REG_NONE" );
            }
        fprintf( stderr, "\n" );
        if (SearchKeyAndValueNames) {
            fprintf( stderr, "Search will include key or value names\n" );
            }
        if (ReplacementBuffer != NULL) {
            fprintf( stderr, "Will replace each occurence with: '%ws'\n",
                     ReplacementBuffer->Base
                   );
            if (ReplaceSZwithEXPAND_SZ) {
                fprintf( stderr, "Also each matching REG_SZ will have its type changed to REG_EXPAND_SZ\n" );
                }
            }
        }

    SearchKeys( KeyName, RegistryContext.HiveRootHandle, 0 );

    RTDisconnectFromRegistry( &RegistryContext );
    return 0;
}

void
SearchKeys(
    PWSTR KeyName,
    HKEY ParentKeyHandle,
    ULONG Depth
    )
{
    LONG Error;
    HKEY KeyHandle;
    ULONG SubKeyIndex;
    WCHAR SubKeyName[ MAX_PATH ];
    ULONG SubKeyNameLength;
    FILETIME LastWriteTime;

    Error = RTOpenKey( &RegistryContext,
                       ParentKeyHandle,
                       KeyName,
                       MAXIMUM_ALLOWED,
                       REG_OPTION_OPEN_LINK,
                       &KeyHandle
                     );

    if (Error != NO_ERROR) {
        if (Depth == 0) {
            FatalError( "Unable to open key '%ws' (%u)\n",
                        (ULONG_PTR)KeyName,
                        (ULONG)Error
                      );
            }

        return;
        }

    KeyPathInfo[ Depth ].Name = KeyName;
    KeyPathInfo[ Depth ].NameDisplayed = FALSE;

    //
    // Search node's values first.
    //
    SearchValues( KeyName, KeyHandle, Depth+1 );

    //
    // Enumerate node's children and apply ourselves to each one
    //

    for (SubKeyIndex = 0; TRUE; SubKeyIndex++) {
        SubKeyNameLength = sizeof( SubKeyName ) / sizeof(WCHAR);
        Error = RTEnumerateKey( &RegistryContext,
                                KeyHandle,
                                SubKeyIndex,
                                &LastWriteTime,
                                &SubKeyNameLength,
                                SubKeyName
                              );

        if (Error != NO_ERROR) {
            if (Error != ERROR_NO_MORE_ITEMS && Error != ERROR_ACCESS_DENIED) {
                fprintf( stderr,
                         "RTEnumerateKey( %ws ) failed (%u), skipping\n",
                         KeyName,
                         Error
                       );
                }

            break;
            }

        SearchKeys( SubKeyName, KeyHandle, Depth+1 );
        }

    RTCloseKey( &RegistryContext, KeyHandle );

    return;
}


void
SearchValues(
    PWSTR KeyName,
    HKEY KeyHandle,
    ULONG Depth
    )
{
    LONG Error;
    DWORD ValueIndex;
    DWORD ValueType;
    DWORD ValueNameLength;
    WCHAR ValueName[ MAX_PATH ];
    DWORD ValueDataLength;
    PWSTR sBegin, sEnd, s, sMatch, sMatchUpper;
    ULONG i;
    BOOLEAN AttemptMatch, MatchFound, MatchedOnType, ReplacementMade, BufferOverflow;

    if (SearchKeyAndValueNames && wcsstr( KeyName, SearchData )) {
        DisplayPath( KeyPathInfo, Depth );
        }

    for (ValueIndex = 0; TRUE; ValueIndex++) {
        ValueType = REG_NONE;
        ValueNameLength = sizeof( ValueName ) / sizeof( WCHAR );
        ValueDataLength = OldValueBufferSize;
        Error = RTEnumerateValueKey( &RegistryContext,
                                     KeyHandle,
                                     ValueIndex,
                                     &ValueType,
                                     &ValueNameLength,
                                     ValueName,
                                     &ValueDataLength,
                                     OldValueBuffer
                                   );
        if (Error == NO_ERROR) {
            try {
                MatchFound = FALSE;
                ReplacementMade = FALSE;
                BufferOverflow = FALSE;
                if (SearchForMissingNULLs) {
                    if (ValueType == REG_SZ || ValueType == REG_EXPAND_SZ) {
                        if (ValueDataLength & (sizeof(WCHAR)-1)) {
                            MatchFound = TRUE;
                            }
                        else
                        if (ValueDataLength == 0 ||
                            *(PWSTR)((PCHAR)OldValueBuffer + ValueDataLength - sizeof( WCHAR )) != UNICODE_NULL
                           ) {
                            MatchFound = TRUE;
                            }

                        if (MatchFound && FixupMissingNULLs) {
                            ValueDataLength = (ValueDataLength+sizeof(WCHAR)-1) & ~(sizeof(WCHAR)-1);
                            *(PWSTR)((PCHAR)OldValueBuffer + ValueDataLength) = UNICODE_NULL;
                            ValueDataLength += sizeof( UNICODE_NULL );
                            Error = RTSetValueKey( &RegistryContext,
                                                   KeyHandle,
                                                   ValueName,
                                                   ValueType,
                                                   ValueDataLength,
                                                   OldValueBuffer
                                                 );
                            if (Error != NO_ERROR) {
                                fprintf( stderr,
                                         "REGFIND: Error setting replacement value (%u)\n",
                                         Error
                                       );
                                }
                            }
                        }
                    }
                else
                if (SearchKeyAndValueNames) {
                    MatchFound = (BOOLEAN)(wcsstr( ValueName,
                                                   SearchData
                                                 ) != NULL
                                          );
                    }
                else {
                    if (SearchValueType == REG_ANY_SZ &&
                        (ValueType == REG_SZ ||
                         ValueType == REG_EXPAND_SZ ||
                         ValueType == REG_MULTI_SZ ||
                         (ValueType == REG_BINARY && IncludeBinaryDataInTextSearch)
                        ) ||
                        SearchValueType == ValueType ||
                        (ValueType == REG_BINARY && IncludeBinaryDataInTextSearch) &&
                         (SearchValueType == REG_SZ ||
                          SearchValueType == REG_EXPAND_SZ ||
                          SearchValueType == REG_MULTI_SZ
                         )
                       ) {
                        MatchedOnType = TRUE;
                        }
                    else {
                        MatchedOnType = FALSE;
                        }

                    if (SearchBuffer == NULL) {
                        MatchFound = MatchedOnType;
                        }
                    else {
                        if (MatchedOnType && ValueDataLength != 0) {
                            if (ValueType == REG_SZ ||
                                ValueType == REG_EXPAND_SZ ||
                                ValueType == REG_MULTI_SZ
                               ) {
                                if (SearchDataLength <= ValueDataLength) {
                                    sBegin = OldValueBuffer;
                                    sEnd = (PWSTR)((PCHAR)sBegin + ValueDataLength);
                                    s = sBegin;
                                    while ((PCHAR)s + SearchDataLength < (PCHAR)sEnd) {
                                        sMatch = wcschr( s, *(PWSTR)SearchData );
                                        if (IgnoreCase) {
                                            sMatchUpper = wcschr( s, SearchData1UpperCase[ 0 ] );
                                            if (sMatch == NULL ||
                                                (sMatchUpper != NULL && sMatchUpper < sMatch)
                                               ) {
                                                sMatch = sMatchUpper;
                                                }
                                            }

                                        if (sMatch != NULL) {
                                            if ((!IgnoreCase &&
                                                 !wcsncmp( sMatch,
                                                           (PWSTR)SearchData,
                                                           SearchDataLength / sizeof( WCHAR )
                                                         )
                                                ) ||
                                                (IgnoreCase &&
                                                 !_wcsnicmp( sMatch,
                                                             (PWSTR)SearchData,
                                                             SearchDataLength / sizeof( WCHAR )
                                                           )
                                                )
                                               ) {
                                                MatchFound = TRUE;
                                                s = ApplyReplacementBuffer( &ValueDataLength,
                                                                            sMatch,
                                                                            &BufferOverflow
                                                                          );
                                                if (s == NULL) {
                                                    if (BufferOverflow) {
                                                        fprintf( stderr,
                                                                 "REGFIND: Buffer overflow doing replacement",
                                                                 Error
                                                               );
                                                        }

                                                    break;
                                                    }

                                                ReplacementMade = TRUE;
                                                sEnd = (PWSTR)((PCHAR)sBegin + ValueDataLength);
                                                }
                                            else {
                                                s = sMatch + 1;
                                                if (*s == UNICODE_NULL &&
                                                    ValueType != REG_MULTI_SZ
                                                   ) {
                                                    s += 1;
                                                    }
                                                }
                                            }
                                        else {
                                            if (ValueType != REG_MULTI_SZ) {
                                                break;
                                                }

                                            while (*s++) {
                                                }
                                            }
                                        }
                                    }
                                }
                            else
                            if (ValueType == REG_DWORD) {
                                if (*(PULONG)SearchData == *(PULONG)OldValueBuffer) {
                                    MatchFound = TRUE;
                                    }
                                }
                            else
                            if (ValueType == REG_BINARY) {
                                if (SearchingForMatchOnDataLength) {
                                    if (ValueDataLength == SearchDataLength) {
                                        MatchFound = TRUE;
                                        }
                                    }
                                else {
                                    sBegin = OldValueBuffer;
                                    sEnd = (PWSTR)((PCHAR)sBegin + ValueDataLength);
                                    s = sBegin;
                                    while (((PCHAR)s + SearchDataLength) < (PCHAR)sEnd) {
                                        s = memchr( s,
                                                    *(PBYTE)SearchData,
                                                    (UINT)((PCHAR)sEnd - (PCHAR)s)
                                                  );
                                        if (s != NULL) {
                                            if ((ULONG)((PCHAR)sEnd - (PCHAR)s) >= SearchDataLength &&
                                                !memcmp( s, SearchData, SearchDataLength )
                                               ) {
                                                MatchFound = TRUE;
                                                s = ApplyReplacementBuffer( &ValueDataLength,
                                                                            s,
                                                                            &BufferOverflow
                                                                          );
                                                if (s == NULL) {
                                                    if (BufferOverflow) {
                                                        fprintf( stderr,
                                                                 "REGFIND: Buffer overflow doing replacement",
                                                                 Error
                                                               );
                                                        }

                                                    break;
                                                    }

                                                ReplacementMade = TRUE;
                                                sEnd = (PWSTR)((PCHAR)sBegin + ValueDataLength);
                                                }

                                            s = (PWSTR)((PCHAR)s + 1);
                                            }
                                        else {
                                            break;
                                            }
                                        }
                                    }
                                }

                            if (ReplacementMade) {
                                if (ReplaceSZwithEXPAND_SZ && ValueType == REG_SZ) {
                                    ValueType = REG_EXPAND_SZ;
                                    }

                                Error = RTSetValueKey( &RegistryContext,
                                                       KeyHandle,
                                                       ValueName,
                                                       ValueType,
                                                       ValueDataLength,
                                                       OldValueBuffer
                                                     );
                                if (Error != NO_ERROR) {
                                    fprintf( stderr,
                                             "REGFIND: Error setting replacement value (%u)\n",
                                             Error
                                           );
                                    }
                                }
                            }
                        }
                    }

                if (MatchFound) {
                    DisplayPath( KeyPathInfo, Depth );
                    RTFormatKeyValue( OutputWidth,
                                      (PREG_OUTPUT_ROUTINE)fprintf,
                                      stdout,
                                      FALSE,
                                      Depth * IndentMultiple,
                                      ValueName,
                                      ValueDataLength,
                                      ValueType,
                                      OldValueBuffer
                                    );
                    }
                }
            except( EXCEPTION_EXECUTE_HANDLER ) {
                fprintf( stderr, "REGFIND: Access violation searching value\n" );
                }
            }
        else
        if (Error == ERROR_NO_MORE_ITEMS) {
            return;
            }
        else {
            if (DebugOutput) {
                fprintf( stderr,
                         "REGFIND: RTEnumerateValueKey( %ws ) failed (%u)\n",
                         KeyName,
                         Error
                       );
                }

            return;
            }
        }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\regini\regini.c ===
#include "regutil.h"

BOOLEAN BackwardsCompatibleInput;

typedef struct _KEY_INFO {
    ULONG IndentAmount;
    PWSTR Name;
    BOOLEAN NameDisplayed;
    HANDLE Handle;
    FILETIME LastWriteTime;
} KEY_INFO, *PKEY_INFO;

#define MAX_KEY_DEPTH 64

void
DisplayPath(
    PKEY_INFO p,
    ULONG Depth,
    PSECURITY_DESCRIPTOR SecurityDescriptor
    )
{
    ULONG i;

    for (i=0; i<Depth-1; i++) {
        if (!p[ i ].NameDisplayed) {
            p[ i ].NameDisplayed = TRUE;
            RTFormatKeyName( (PREG_OUTPUT_ROUTINE)MsgFprintf, stdout, i * IndentMultiple, p[ i ].Name );
            if (i+1 == Depth-1) {
                RTFormatKeySecurity( (PREG_OUTPUT_ROUTINE)MsgFprintf,
                                     stdout,
                                     NULL,
                                     SecurityDescriptor
                                   );
                }
            MsgFprintf( stdout,"\n" );
            }
        }
}


LONG
DeleteKeyTree(
    IN PREG_CONTEXT RegistryContext,
    IN HKEY ParentKeyHandle,
    IN PCWSTR KeyName
    )
{
    HKEY KeyHandle;
    WCHAR SubKeyName[ MAX_PATH ];
    ULONG SubKeyNameLength;
    FILETIME LastWriteTime;
    LONG Error;

    Error = RTOpenKey( RegistryContext,
                       ParentKeyHandle,
                       KeyName,
                       MAXIMUM_ALLOWED,
                       REG_OPTION_OPEN_LINK,
                       &KeyHandle
                     );

    //
    // Enumerate node's children and apply ourselves to each one
    //

    while (Error == NO_ERROR) {
        SubKeyNameLength = sizeof( SubKeyName ) / sizeof(WCHAR);
        Error = RTEnumerateKey( RegistryContext,
                                KeyHandle,
                                0,
                                &LastWriteTime,
                                &SubKeyNameLength,
                                SubKeyName
                              );

        if (Error == NO_ERROR) {
            Error = DeleteKeyTree( RegistryContext, KeyHandle, SubKeyName );
            }
        }

    RTCloseKey( RegistryContext, KeyHandle );

    return RTDeleteKey( RegistryContext,
                        ParentKeyHandle,
                        KeyName
                      );
}


LONG
InitializeRegistryFromAsciiFile(
    IN PWSTR FileName
    )
{
    HKEY RootHandle;
    LONG Error, ReturnedError;
    REG_UNICODE_FILE UnicodeFile;
    REG_UNICODE_PARSE ParsedLine;
    ULONG OldValueType, OldValueLength;
    KEY_INFO KeyPath[ MAX_KEY_DEPTH ];
    PKEY_INFO CurrentKey;
    ULONG KeyPathLength;
    ULONG Disposition;
    ULONG i;
    ULONG PreviousValueIndentAmount;
    LPSTR s;

    Error = RTConnectToRegistry( MachineName,
                                 HiveFileName,
                                 HiveRootName,
                                 Win95Path,
                                 Win95UserPath,
                                 NULL,
                                 &RegistryContext
                               );
    if (Error != NO_ERROR) {
        return Error;
        }
    RootHandle = RegistryContext.HiveRootHandle;

    Error = RTLoadAsciiFileAsUnicode( FileName,
                                      &UnicodeFile
                                    );
    if (Error != NO_ERROR) {
        RTDisconnectFromRegistry( &RegistryContext );
        return Error;
        }

    RtlZeroMemory( &ParsedLine, sizeof( ParsedLine ) );
    UnicodeFile.BackwardsCompatibleInput = BackwardsCompatibleInput;
    PreviousValueIndentAmount = 0xFFFFFFFF;
    CurrentKey = 0;
    KeyPathLength = 0;
    ReturnedError = NO_ERROR;
    while (TRUE) {
        if (!RTParseNextLine( &UnicodeFile, &ParsedLine )) {
            if (!ParsedLine.AtEndOfFile) {
                DisplayPath( KeyPath, KeyPathLength+1, NULL );
                if (ParsedLine.IsKeyName) {
                    InputMessage( FileName,
                                  ParsedLine.LineNumber,
                                  TRUE,
                                  ParsedLine.AclString ? "Invalid key '%ws' Acl [%ws]"
                                                       : "Invalid key '%ws'",
                                  (ULONG_PTR)ParsedLine.KeyName,
                                  (ULONG_PTR)ParsedLine.AclString
                                );
                    }
                else {
                    switch( ParsedLine.ParseFailureReason ) {
                        case ParseFailValueTooLarge:
                            s = "Value too large - '%ws = %ws'";
                            break;

                        case ParseFailUnableToAccessFile:
                            s = "Unable to access file - '%ws = %ws'";
                            break;

                        case ParseFailDateTimeFormatInvalid:
                            s = "Date/time format invalid - '%ws = %ws'";
                            break;

                        case ParseFailInvalidLineContinuation:
                            s = "Invalid line continuation - '%ws = %ws'";
                            break;

                        case ParseFailInvalidQuoteCharacter:
                            s = "Invalid quote character - '%ws = %ws'";
                            break;

                        case ParseFailBinaryDataLengthMissing:
                            s = "Missing length for binary data - '%ws = %ws'";
                            break;

                        case ParseFailBinaryDataOmitted:
                        case ParseFailBinaryDataNotEnough:
                            s = "Not enough binary data for length - '%ws = %ws'";
                            break;

                        case ParseFailInvalidRegistryType:
                            s = "Invalid registry type - '%ws = %ws'";
                            break;

                        default:
                            s = "Invalid value - '%ws = %ws'";
                        }

                    InputMessage( FileName,
                                  ParsedLine.LineNumber,
                                  TRUE,
                                  s,
                                  (ULONG_PTR)ParsedLine.ValueName,
                                  (ULONG_PTR)ParsedLine.ValueString
                                );

                    ReturnedError = ERROR_BAD_FORMAT;
                    break;
                    }
                }

            break;
            }
        else
        if (ParsedLine.IsKeyName) {
            if (DebugOutput) {
                MsgFprintf( stdout, "%02u %04u  KeyName: %ws",
                        KeyPathLength,
                        ParsedLine.IndentAmount,
                        ParsedLine.KeyName
                      );
                }

            if (ParsedLine.IndentAmount > PreviousValueIndentAmount) {
                MsgFprintf( stderr,
                         "REGINI: Missing line continuation character for %ws\n",
                         ParsedLine.KeyName
                       );

                ReturnedError = ERROR_BAD_FORMAT;
                break;
                }
            else {
                PreviousValueIndentAmount = 0xFFFFFFFF;
                }

//
// This fixes a 64 bit compiler problem where the statement
//
//            CurrentKey = &KeyPath[ KeyPathLength - 1 ];
//
// Is evaulated as (KeyPath + (ULONG)(KeyPathLength - 1)) this is likely 
// because KeyPathLength is a ULONG so the result is when KeyPathLength is 0
// 0xffffffff is added instead of -1
//
            CurrentKey = &KeyPath[ KeyPathLength ];
            CurrentKey--;


            if (KeyPathLength == 0 ||
                ParsedLine.IndentAmount > CurrentKey->IndentAmount
               ) {
                //
                // If first key seen or this key is indented more than last
                // key, then we care going to create this key as a child of
                // its parent
                //
                if (KeyPathLength == MAX_KEY_DEPTH) {
                    MsgFprintf( stderr,
                             "REGINI: %ws key exceeded maximum depth (%u) of tree.\n",
                             ParsedLine.KeyName,
                             MAX_KEY_DEPTH
                           );

                    ReturnedError = ERROR_FILENAME_EXCED_RANGE;
                    break;
                    }
                KeyPathLength++;
                CurrentKey++;
                }
            else {
                //
                // Not first key seen and indented less than or same as
                // last key.  Close any children keys to get back to
                // our current level.
                //
                do {
                    RTCloseKey( &RegistryContext, CurrentKey->Handle );
                    CurrentKey->Handle = NULL;
                    if (ParsedLine.IndentAmount == CurrentKey->IndentAmount) {
                        break;
                        }
                    CurrentKey--;
                    if (--KeyPathLength <= 1) {
                        break;
                        }
                    }
                while (ParsedLine.IndentAmount <= CurrentKey->IndentAmount);
                }

            if (DebugOutput) {
                MsgFprintf( stdout, "  (%02u)\n", KeyPathLength );
                }


            CurrentKey->Name = ParsedLine.KeyName;
            CurrentKey->NameDisplayed = FALSE;
            CurrentKey->IndentAmount = ParsedLine.IndentAmount;
            CurrentKey->Handle = NULL;

            if (ParsedLine.DeleteKey) {
                Error = DeleteKeyTree( &RegistryContext,
                                       (KeyPathLength < 2 ? RootHandle : \
                                        KeyPath[ KeyPathLength - 2 ].Handle),
                                       ParsedLine.KeyName
                                     );
                if (Error == NO_ERROR) {
                    if (DebugOutput) {
                        MsgFprintf( stderr, "    Deleted key %02x %ws (%x%08x)\n",
                                         CurrentKey->IndentAmount,
                                         CurrentKey->Name,
                                         HI_PTR(CurrentKey->Handle),
                                         LO_PTR(CurrentKey->Handle)
                               );
                        }

                    DisplayPath( KeyPath, KeyPathLength+1, NULL );
                    MsgFprintf( stderr, "; *** Deleted the above key and all of its subkeys ***\n" );
                    }
                else {
                    MsgFprintf( stderr,
                             "REGINI: DeleteKey (%ws) relative to handle (%x%08x) failed - %u\n",
                             ParsedLine.KeyName,
                             (KeyPathLength < 2  ? HI_PTR(RootHandle) : \
                              HI_PTR(KeyPath[ KeyPathLength - 2 ].Handle)),
                             (KeyPathLength < 2  ? LO_PTR(RootHandle) : \
                              LO_PTR(KeyPath[ KeyPathLength - 2 ].Handle)), 
                             Error
                           );

                    ReturnedError = Error;
                    break;
                    }
                }
            else {
                Error = RTCreateKey( &RegistryContext,
                                     (KeyPathLength < 2 ? RootHandle : \
                                      KeyPath[ KeyPathLength - 2 ].Handle),
                                     ParsedLine.KeyName,
                                     MAXIMUM_ALLOWED,
                                     0,
                                     ParsedLine.SecurityDescriptor,
                                     (PHKEY)&CurrentKey->Handle,
                                     &Disposition
                                   );
                if (Error == NO_ERROR) {
                    if (DebugOutput) {
                        MsgFprintf( stderr, "    Created key %02x %ws (%x%08x)\n",
                                         CurrentKey->IndentAmount,
                                         CurrentKey->Name,
                                         HI_PTR(CurrentKey->Handle),
                                         LO_PTR(CurrentKey->Handle)
                               );
                        }

                    Error = RTQueryKey( &RegistryContext,
                                        CurrentKey->Handle,
                                        &CurrentKey->LastWriteTime,
                                        NULL,
                                        NULL
                                      );
                    if (Error != NO_ERROR) {
                        RtlZeroMemory( &CurrentKey->LastWriteTime,
                                       sizeof( CurrentKey->LastWriteTime )
                                     );
                        }

                    if (Disposition == REG_CREATED_NEW_KEY) {
                        DisplayPath( KeyPath, KeyPathLength+1, ParsedLine.SecurityDescriptor );
                        }
                    }
                else {
                    MsgFprintf( stderr,
                             "REGINI: CreateKey (%ws) relative to handle (%x%08x) failed - %u\n",
                             ParsedLine.KeyName,
                             (KeyPathLength < 2  ? 
                              HI_PTR(RootHandle) :
                              HI_PTR(KeyPath[ KeyPathLength - 2 ].Handle)),
                             (KeyPathLength < 2  ?
                              LO_PTR(RootHandle) :
                              LO_PTR(KeyPath[ KeyPathLength - 2 ].Handle)),
                             Error
                           );

                    ReturnedError = Error;
                    break;
                    }
                }
            }
        else {
            //
            // Have a value.  If no current key, then an error
            //
            if (CurrentKey == NULL) {
                InputMessage( FileName,
                              ParsedLine.LineNumber,
                              TRUE,
                              "Value name ('%ws') seen before any key name",
                              (ULONG_PTR)ParsedLine.ValueName,
                              0
                            );
                ReturnedError = ERROR_BAD_FORMAT;
                break;
                }

            //
            // Make sure this value goes under the appropriate key.  That is
            // underneath the key that has an indentation that is <= the
            // key.
            //
            while (ParsedLine.IndentAmount < CurrentKey->IndentAmount) {
                if (DebugOutput) {
                    MsgFprintf( stderr, "    Popping from key %02x %ws (%x%08x)\n",
                                     CurrentKey->IndentAmount,
                                     CurrentKey->Name,
                                     HI_PTR(CurrentKey->Handle),
                                     LO_PTR(CurrentKey->Handle)
                           );
                    }

                RTCloseKey( &RegistryContext, CurrentKey->Handle );
                CurrentKey->Handle = NULL;
                CurrentKey--;
                if (--KeyPathLength <= 1) {
                    break;
                    }
                }

            if (DebugOutput) {
                MsgFprintf( stderr, "    Adding value '%ws = %ws' to key %02x %ws (%x%08x)\n",
                                 ParsedLine.ValueName,
                                 ParsedLine.ValueString,
                                 CurrentKey->IndentAmount,
                                 CurrentKey->Name,
                                 HI_PTR(CurrentKey->Handle),
                                 LO_PTR(CurrentKey->Handle)
                       );

                }

            PreviousValueIndentAmount = ParsedLine.IndentAmount;
            if (ParsedLine.DeleteValue) {
                Error = RTDeleteValueKey( &RegistryContext,
                                          KeyPath[ KeyPathLength - 1 ].Handle,
                                          ParsedLine.ValueName
                                        );
                if (Error == NO_ERROR) {
                    MsgFprintf( stdout, "    %ws = DELETED\n", ParsedLine.ValueName );
                    }
                }
            else {
                OldValueLength = OldValueBufferSize;
                Error = RTQueryValueKey( &RegistryContext,
                                         KeyPath[ KeyPathLength - 1 ].Handle,
                                         ParsedLine.ValueName,
                                         &OldValueType,
                                         &OldValueLength,
                                         OldValueBuffer
                                        );
                if (Error != NO_ERROR ||
                    OldValueType != ParsedLine.ValueType ||
                    OldValueLength != ParsedLine.ValueLength ||
                    RtlCompareMemory( OldValueBuffer,
                                      ParsedLine.ValueData,
                                      ParsedLine.ValueLength
                                    ) != ParsedLine.ValueLength
                   ) {
                    Error = RTSetValueKey( &RegistryContext,
                                           KeyPath[ KeyPathLength - 1 ].Handle,
                                           ParsedLine.ValueName,
                                           ParsedLine.ValueType,
                                           ParsedLine.ValueLength,
                                           ParsedLine.ValueData
                                         );
                    if (Error == NO_ERROR) {
                        DisplayPath( KeyPath, KeyPathLength+1, NULL );
                        RTFormatKeyValue( OutputWidth,
                                          (PREG_OUTPUT_ROUTINE)MsgFprintf,
                                          stdout,
                                          FALSE,
                                          KeyPathLength * IndentMultiple,
                                          ParsedLine.ValueName,
                                          ParsedLine.ValueLength,
                                          ParsedLine.ValueType,
                                          ParsedLine.ValueData
                                        );
                        }
                    else {
                        MsgFprintf( stderr,
                                 "REGINI: SetValueKey (%ws) failed (%u)\n",
                                 ParsedLine.ValueName,
                                 Error
                               );

                        ReturnedError = Error;
                        break;
                        }
                    }
                }
            }
        }

    //
    // Close handles we still have open.
    //
    while (CurrentKey >= KeyPath ) {
        RTCloseKey( &RegistryContext, CurrentKey->Handle );
        --CurrentKey;
        }

    RTDisconnectFromRegistry( &RegistryContext );

    return ReturnedError;
}

BOOL
CtrlCHandler(
    IN ULONG CtrlType
    )
{
    RTDisconnectFromRegistry( &RegistryContext );
    return FALSE;
}


int
__cdecl
main(
    int argc,
    char *argv[]
    )
{
    ULONG n;
    char *s;
    LONG Error;
    BOOL FileArgumentSeen;
    PWSTR FileName;

    InitCommonCode( CtrlCHandler,
                    "REGINI",
                    "[-b] textFiles...",
                    "-b specifies that REGINI should be backward compatible with older\n"
                    "    versions of REGINI that did not strictly enforce line continuations\n"
                    "    and quoted strings Specifically, REG_BINARY, REG_RESOURCE_LIST and\n"
                    "    REG_RESOURCE_REQUIREMENTS_LIST data types did not need line\n"
                    "    continuations after the first number that gave the size of the data.\n"
                    "    It just kept looking on following lines until it found enough data\n"
                    "    values to equal the data length or hit invalid input.  Quoted\n"
                    "    strings were only allowed in REG_MULTI_SZ.  They could not be\n"
                    "    specified around key or value names, or around values for REG_SZ or\n"
                    "    REG_EXPAND_SZ  Finally, the old REGINI did not support the semicolon\n"
                    "    as an end of line comment character.\n"
                    "\n"
                    "textFiles is one or more ANSI or Unicode text files with registry data.\n"
                    "\n"
                    "The easiest way to understand the format of the input textFile is to use\n"
                    "the REGDMP command with no arguments to dump the current contents of\n"
                    "your NT Registry to standard out.  Redirect standard out to a file and\n"
                    "this file is acceptable as input to REGINI\n"
                    "\n"
                    "Some general rules are:\n"
                    "    Semicolon character is an end-of-line comment character, provided it\n"
                    "    is the first non-blank character on a line\n"
                    "\n"
                    "    Backslash character is a line continuation character.  All\n"
                    "    characters from the backslash up to but not including the first\n"
                    "    non-blank character of the next line are ignored.  If there is more\n"
                    "    than one space before the line continuation character, it is\n"
                    "    replaced by a single space.\n"
                    "\n"
                    "    Indentation is used to indicate the tree structure of registry keys\n"
                    "    The REGDMP program uses indentation in multiples of 4.  You may use\n"
                    "    hard tab characters for indentation, but embedded hard tab\n"
                    "    characters are converted to a single space regardless of their\n"
                    "    position\n"
                    "    \n"
                    "    Values should come before child keys, as they are associated with\n"
                    "    the previous key at or above the value's indentation level.\n"
                    "\n"
                    "    For key names, leading and trailing space characters are ignored and\n"
                    "    not included in the key name, unless the key name is surrounded by\n"
                    "    quotes.  Imbedded spaces are part of a key name.\n"
                    "\n"
                    "    Key names can be followed by an Access Control List (ACL) which is a\n"
                    "    series of decimal numbers, separated by spaces, bracketed by a\n"
                    "    square brackets (e.g.  [8 4 17]).  The valid numbers and their\n"
                    "    meanings are:\n"
                    "\n"
                    "       1  - Administrators Full Access\n"
                    "       2  - Administrators Read Access\n"
                    "       3  - Administrators Read and Write Access\n"
                    "       4  - Administrators Read, Write and Delete Access\n"
                    "       5  - Creator Full Access\n"
                    "       6  - Creator Read and Write Access\n"
                    "       7  - World Full Access\n"
                    "       8  - World Read Access\n"
                    "       9  - World Read and Write Access\n"
                    "       10 - World Read, Write and Delete Access\n"
                    "       11 - Power Users Full Access\n"
                    "       12 - Power Users Read and Write Access\n"
                    "       13 - Power Users Read, Write and Delete Access\n"
                    "       14 - System Operators Full Access\n"
                    "       15 - System Operators Read and Write Access\n"
                    "       16 - System Operators Read, Write and Delete Access\n"
                    "       17 - System Full Access\n"
                    "       18 - System Read and Write Access\n"
                    "       19 - System Read Access\n"
                    "       20 - Administrators Read, Write and Execute Access\n"
                    "       21 - Interactive User Full Access\n"
                    "       22 - Interactive User Read and Write Access\n"
                    "       23 - Interactive User Read, Write and Delete Access\n"
                    "\n"
                    "    If there is an equal sign on the same line as a left square bracket\n"
                    "    then the equal sign takes precedence, and the line is treated as a\n"
                    "    registry value.  If the text between the square brackets is the\n"
                    "    string DELETE with no spaces, then REGINI will delete the key and\n"
                    "    any values and keys under it.\n"
                    "\n"
                    "    For registry values, the syntax is:\n"
                    "\n"
                    "       value Name = type data\n"
                    "\n"
                    "    Leading spaces, spaces on either side of the equal sign and spaces\n"
                    "    between the type keyword and data are ignored, unless the value name\n"
                    "    is surrounded by quotes.  If the text to the right of the equal sign\n"
                    "    is the string DELETE, then REGINI will delete the value.\n"
                    "\n"
                    "    The value name may be left off or be specified by an at-sign\n"
                    "    character which is the same thing, namely the empty value name.  So\n"
                    "    the following two lines are identical:\n"
                    "\n"
                    "       = type data\n"
                    "       @ = type data\n"
                    "\n"
                    "    This syntax means that you can't create a value with leading or\n"
                    "    trailing spaces, an equal sign or an at-sign in the value name,\n"
                    "    unless you put the name in quotes.\n"
                    "\n"
                    "    Valid value types and format of data that follows are:\n"
                    "\n"
                    "       REG_SZ text\n"
                    "       REG_EXPAND_SZ text\n"
                    "       REG_MULTI_SZ \"string1\" \"str\"\"ing2\" ...\n"
                    "       REG_DATE mm/dd/yyyy HH:MM DayOfWeek\n"
                    "       REG_DWORD numberDWORD\n"
                    "       REG_BINARY numberOfBytes numberDWORD(s)...\n"
                    "       REG_NONE (same format as REG_BINARY)\n"
                    "       REG_RESOURCE_LIST (same format as REG_BINARY)\n"
                    "       REG_RESOURCE_REQUIREMENTS (same format as REG_BINARY)\n"
                    "       REG_RESOURCE_REQUIREMENTS_LIST (same format as REG_BINARY)\n"
                    "       REG_FULL_RESOURCE_DESCRIPTOR (same format as REG_BINARY)\n"
                    "       REG_MULTISZ_FILE fileName\n"
                    "       REG_BINARYFILE fileName\n"
                    "\n"
                    "    If no value type is specified, default is REG_SZ\n"
                    "\n"
                    "    For REG_SZ and REG_EXPAND_SZ, if you want leading or trailing spaces\n"
                    "    in the value text, surround the text with quotes.  The value text\n"
                    "    can contain any number of imbedded quotes, and REGINI will ignore\n"
                    "    them, as it only looks at the first and last character for quote\n"
                    "    characters.\n"
                    "\n"
                    "    For REG_MULTI_SZ, each component string is surrounded by quotes.  If\n"
                    "    you want an imbedded quote character, then double quote it, as in\n"
                    "    string2 above.\n"
                    "\n"
                    "    For REG_BINARY, the value data consists of one or more numbers The\n"
                    "    default base for numbers is decimal.  Hexidecimal may be specified\n"
                    "    by using 0x prefix.  The first number is the number of data bytes,\n"
                    "    excluding the first number.  After the first number must come enough\n"
                    "    numbers to fill the value.  Each number represents one DWORD or 4\n"
                    "    bytes.  So if the first number was 0x5 you would need two more\n"
                    "    numbers after that to fill the 5 bytes.  The high order 3 bytes\n"
                    "    of the second DWORD would be ignored.\n"
                  );

    BackwardsCompatibleInput = FALSE;
    FileArgumentSeen = FALSE;
    while (--argc) {
        s = *++argv;
        if (*s == '-' || *s == '/') {
            while (*++s) {
                switch( tolower( *s ) ) {
                    case 'b':
                        BackwardsCompatibleInput = TRUE;
                        break;

                    default:
                        CommonSwitchProcessing( &argc, &argv, *s );
                    }
                }
            }
        else {
            FileArgumentSeen = TRUE;
            FileName = GetArgAsUnicode( s );
            if (FileName == NULL) {
                Error = GetLastError();
                }
            else {
                Error = InitializeRegistryFromAsciiFile( FileName );
                }

            if (Error != NO_ERROR) {
                FatalError( "Failed to load from file '%s' (%u)\n", 
                            (ULONG_PTR)s, Error );
                exit( Error );
                }
            }
        }

    if (!FileArgumentSeen) {
        Usage( "No textFile specified", 0 );
        }

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\regini\regtool.h ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    regtool.h

Abstract:

    This is the include file for the REGTOOL.DLL registry helper.

Author:

    Steve Wood (stevewo) 16-Nov-1995

Revision History:

--*/

//
// Routines for accessing registry.  Allows code to access any of the following
// registry locations with the same code:
//
//      Windows NT registry on local machine
//      Windows NT registry on remote machine
//      Windows NT hive files
//      Windows 95 registry files (system.dat, user.dat)
//

BOOLEAN
RTInitialize( void );

#define REG_TARGET_DISCONNECTED    0
#define REG_TARGET_LOCAL_REGISTRY  1
#define REG_TARGET_REMOTE_REGISTRY 2
#define REG_TARGET_WIN95_REGISTRY  3
#define REG_TARGET_HIVE_REGISTRY   4

typedef struct _REG_CONTEXT_OPEN_HIVE_KEY {
    struct _REG_CONTEXT_OPEN_HIVE_KEY *Next;
    HKEY KeyHandle;
    ULONG ReferenceCount;
} REG_CONTEXT_OPEN_HIVE_KEY, *PREG_CONTEXT_OPEN_HIVE_KEY;

typedef struct _REG_CONTEXT {
    struct _REG_CONTEXT *Next;
    ULONG Target;
    HKEY MachineRoot;
    HKEY UsersRoot;
    HKEY CurrentUserRoot;
    WCHAR MachinePath[ MAX_PATH ];
    WCHAR UsersPath[ MAX_PATH ];
    WCHAR CurrentUserPath[ MAX_PATH ];
    ULONG MachinePathLength;
    ULONG UsersPathLength;
    ULONG CurrentUserPathLength;
    HKEY HiveRootHandle;
    OBJECT_ATTRIBUTES HiveRootKey;
    PREG_CONTEXT_OPEN_HIVE_KEY OpenHiveKeys;
} REG_CONTEXT, *PREG_CONTEXT;


BOOLEAN
RTEnableBackupRestorePrivilege( void );

void
RTDisableBackupRestorePrivilege( void );

LONG
RTConnectToRegistry(
    IN PWSTR MachineName,
    IN PWSTR HiveFileName,
    IN PWSTR HiveRootName,
    IN PWSTR Win95Path,
    IN PWSTR Win95UserName,
    OUT PWSTR *DefaultRootKeyName,
    OUT PREG_CONTEXT RegistryContext
    );

LONG
RTDisconnectFromRegistry(
    IN PREG_CONTEXT RegistryContext
    );

LONG
RTCreateKey(
    IN PREG_CONTEXT RegistryContext,
    IN HKEY RootKeyHandle,
    IN PCWSTR SubKeyName,
    IN ACCESS_MASK DesiredAccess,
    IN ULONG CreateOptions,
    IN PVOID SecurityDescriptor,
    OUT PHKEY ReturnedKeyHandle,
    OUT PULONG Disposition
    );


LONG
RTOpenKey(
    IN PREG_CONTEXT RegistryContext,
    IN HKEY RootKeyHandle,
    IN PCWSTR SubKeyName,
    IN ACCESS_MASK DesiredAccess,
    IN ULONG OpenOptions,
    OUT PHKEY ReturnedKeyHandle
    );

#define HKEY_REGISTRY_ROOT          (( HKEY ) (ULONG_PTR)((LONG)0x8000000A) )

LONG
RTCloseKey(
    IN PREG_CONTEXT RegistryContext,
    IN HKEY KeyHandle
    );

LONG
RTFlushKey(
    IN PREG_CONTEXT RegistryContext,
    IN HKEY KeyHandle
    );

LONG
RTEnumerateKey(
    IN PREG_CONTEXT RegistryContext,
    IN HKEY KeyHandle,
    IN ULONG Index,
    OUT PFILETIME LastWriteTime,
    IN OUT PULONG KeyNameLength,
    OUT PWSTR KeyName
    );

LONG
RTEnumerateValueKey(
    IN PREG_CONTEXT RegistryContext,
    IN HKEY KeyHandle,
    IN ULONG Index,
    OUT PULONG ValueType,
    IN OUT PULONG ValueNameLength,
    OUT PWSTR ValueName,
    IN OUT PULONG ValueDataLength,
    OUT PVOID ValueData
    );


LONG
RTQueryKey(
    IN PREG_CONTEXT RegistryContext,
    IN HKEY KeyHandle,
    OUT PFILETIME LastWriteTime,
    OUT PULONG NumberOfSubkeys,
    OUT PULONG NumberOfValues
    );

LONG
RTQueryValueKey(
    IN PREG_CONTEXT RegistryContext,
    IN HKEY KeyHandle,
    IN PWSTR ValueName,
    OUT PULONG ValueType,
    IN OUT PULONG ValueDataLength,
    OUT PVOID ValueData
    );

LONG
RTSetValueKey(
    IN PREG_CONTEXT RegistryContext,
    IN HKEY KeyHandle,
    IN PWSTR ValueName,
    IN ULONG ValueType,
    IN ULONG ValueDataLength,
    IN PVOID ValueData
    );

LONG
RTDeleteKey(
    IN PREG_CONTEXT RegistryContext,
    IN HKEY KeyHandle,
    IN PCWSTR SubKeyName
    );

LONG
RTDeleteValueKey(
    IN PREG_CONTEXT RegistryContext,
    IN HKEY KeyHandle,
    IN PWSTR ValueName
    );


typedef struct _REG_UNICODE_FILE {
    PWSTR FileName;
    FILETIME LastWriteTime;
    PWSTR FileContents;
    PWSTR EndOfFile;
    PWSTR NextLine;
    ULONG NextLineNumber;
    BOOLEAN BackwardsCompatibleInput;
} REG_UNICODE_FILE, *PREG_UNICODE_FILE;

LONG
RTLoadAsciiFileAsUnicode(
    IN PWSTR Path,
    OUT PREG_UNICODE_FILE UnicodeFile
    );

void
RTUnloadUnicodeFile(
    IN OUT PREG_UNICODE_FILE UnicodeFile
    );

typedef enum _REG_UNICODE_PARSE_FAILURE_REASON {
    ParseFailNoFailure = 0,
    ParseFailValueTooLarge,
    ParseFailUnableToAccessFile,
    ParseFailDateTimeFormatInvalid,
    ParseFailInvalidLineContinuation,
    ParseFailInvalidQuoteCharacter,
    ParseFailBinaryDataLengthMissing,
    ParseFailBinaryDataOmitted,
    ParseFailBinaryDataNotEnough,
    ParseFailInvalidRegistryType
} REG_UNICODE_PARSE_FAILURE_REASON;

typedef struct _REG_UNICODE_PARSE {
    ULONG LineNumber;
    ULONG IndentAmount;
    PWSTR BeginLine;
    BOOLEAN AtEndOfFile;
    BOOLEAN IsKeyName;
    REG_UNICODE_PARSE_FAILURE_REASON ParseFailureReason;
    union {
        struct {
            PWSTR KeyName;
            PWSTR AclString;
            PVOID SecurityDescriptor;
            BOOLEAN DeleteKey;
            SECURITY_DESCRIPTOR SecurityDescriptorBuffer;
        };
        struct {
            PWSTR ValueName;
            PWSTR ValueString;
            ULONG ValueType;
            ULONG ValueLength;
            PVOID ValueData;
            BOOLEAN DeleteValue;
        };
    };
} REG_UNICODE_PARSE, *PREG_UNICODE_PARSE;


BOOLEAN
RTParseNextLine(
    IN OUT PREG_UNICODE_FILE UnicodeFile,
    OUT PREG_UNICODE_PARSE ParsedLine
    );

BOOLEAN
RTParseValueData(
    IN OUT PREG_UNICODE_FILE UnicodeFile,
    IN OUT PREG_UNICODE_PARSE ParsedLine,
    IN PVOID ValueBuffer,
    IN ULONG ValueBufferSize,
    OUT PULONG ValueType,
    OUT PVOID *ValueData,
    OUT PULONG ValueLength
    );

typedef
int
(_cdecl *PREG_OUTPUT_ROUTINE)(
    PVOID pParameter,
    LPSTR FormatString,
    ...
    );

void
RTFormatKeyName(
    PREG_OUTPUT_ROUTINE OutputRoutine,
    PVOID OutputRoutineParameter,
    ULONG IndentLevel,
    PWSTR KeyName
    );

void
RTFormatKeySecurity(
    PREG_OUTPUT_ROUTINE OutputRoutine,
    PVOID OutputRoutineParameter,
    HKEY KeyHandle,
    PSECURITY_DESCRIPTOR SecurityDescriptor
    );

void
RTFormatKeyValue(
    ULONG OutputWidth,
    PREG_OUTPUT_ROUTINE OutputRoutine,
    PVOID OutputRoutineParameter,
    BOOLEAN SummaryOutput,
    ULONG IndentLevel,
    PWSTR ValueName,
    ULONG ValueLength,
    ULONG ValueType,
    PWSTR ValueData
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\regini\regutil.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    regutil.c

Abstract:

    Utility routines for use by REGINI and REGDMP programs.
Author:

    Steve Wood (stevewo)  10-Mar-92

Revision History:

--*/

#include "regutil.h"

ULONG NumberOfLinesOutput;
BOOLEAN RegBackSwitches;
LPSTR SavedModuleName;
LPSTR SavedModuleUsage1;
LPSTR SavedModuleUsage2;
PHANDLER_ROUTINE SavedCtrlCHandler;

BOOL
CommonCtrlCHandler(
    IN ULONG CtrlType
    )
{
    if (CtrlType == CTRL_C_EVENT || CtrlType == CTRL_BREAK_EVENT) {
        if (SavedCtrlCHandler != NULL) {
            (*SavedCtrlCHandler)( CtrlType );
        }
        ExitProcess( 1 );
    }
    return FALSE;
}

void
InitCommonCode(
    PHANDLER_ROUTINE CtrlCHandler,
    LPSTR ModuleName,
    LPSTR ModuleUsage1,
    LPSTR ModuleUsage2
    )
{
    CONSOLE_SCREEN_BUFFER_INFO ConsoleScreenBufferInfo;

    if (!RTInitialize()) {
        FatalError( "Unable to initialize registry access functions (%u)",
                    GetLastError(), 0 );
        }

    if (_isatty( _fileno( stdout ) )) {
        if (GetConsoleScreenBufferInfo( GetStdHandle( STD_OUTPUT_HANDLE ),
                                        &ConsoleScreenBufferInfo
                                      )
           ) {
            OutputHeight = ConsoleScreenBufferInfo.srWindow.Bottom -
                           ConsoleScreenBufferInfo.srWindow.Top + 1;
            OutputWidth = ConsoleScreenBufferInfo.srWindow.Right -
                          ConsoleScreenBufferInfo.srWindow.Left + 1;
            }
        else {
            OutputHeight = 24;
            OutputWidth = 80;
            }
        }
    else {
        OutputHeight = 0;       // Dont pause on redirected output
        OutputWidth = 240;      // Larger width for redirected output
        }

    IndentMultiple = 4;
    SavedModuleName = ModuleName;
    if (!_stricmp( SavedModuleName, "REGBACK" )) {
        RegBackSwitches = TRUE;
        }
    else {
        RegBackSwitches = FALSE;
        }
    SavedModuleUsage1 = ModuleUsage1;
    SavedModuleUsage2 = ModuleUsage2;

    SetConsoleCtrlHandler( CtrlCHandler, TRUE );
    OldValueBufferSize = 30 * 4096;
    OldValueBuffer = VirtualAlloc( NULL, OldValueBufferSize, MEM_COMMIT, PAGE_READWRITE );
    if (OldValueBuffer == NULL) {
        FatalError( "Unable to allocate large value buffer (%u)",
                    GetLastError(), 0 );
        }

    return;
}

void
DisplayIndentedString(
    ULONG IndentAmount,
    PCHAR sBegin
    )
{
    PCHAR sEnd;

    while (sBegin != NULL) {
        sEnd = sBegin;
        while (*sEnd && *sEnd != '\n') {
            sEnd += 1;
            }

        MsgFprintf( stderr, "%.*s%.*s\n",
                 IndentAmount,
                 "                                                      ",
                 sEnd - sBegin, sBegin
               );

        NumberOfLinesOutput += 1;

        if (OutputHeight != 0 && NumberOfLinesOutput >= OutputHeight) {
            MsgFprintf( stderr, "more...press any key to continue" );
            TSGetch();
            MsgFprintf( stderr, "\r                                \r" );
            NumberOfLinesOutput = 2;
            }

        if (*sEnd == '\0') {
            break;
            }
        else {
            sBegin = ++sEnd;
            }
        }
    return;
}


void
Usage(
    LPSTR Message,
    ULONG_PTR MessageParameter
    )
{
    ULONG n;
    LPSTR sBegin, sEnd;

    NumberOfLinesOutput += 1;
    n = MsgFprintf( stderr, "usage: %s ", SavedModuleName );
    MsgFprintf( stderr, "[-m \\\\machinename" );
    if (!RegBackSwitches) {
        MsgFprintf( stderr, " | -h hivefile hiveroot | -w Win95 Directory" );
        }
    MsgFprintf( stderr, "]\n" );
    NumberOfLinesOutput += 1;
    if (!RegBackSwitches) {
        DisplayIndentedString( n, "[-i n] [-o outputWidth]" );
        }

    DisplayIndentedString( n, SavedModuleUsage1 );
    MsgFprintf( stderr, "\n" );
    NumberOfLinesOutput += 1;

    n = MsgFprintf( stderr, "where: " );
    MsgFprintf( stderr, "-m specifies a remote Windows NT machine whose registry is to be manipulated.\n" );
    NumberOfLinesOutput += 1;
    if (!RegBackSwitches) {
        DisplayIndentedString( n,
                               "-h specifies a specify local hive to manipulate.\n"
                               "-w specifies the paths to a Windows 95 system.dat and user.dat files\n"
                               "-i n specifies the display indentation multiple.  Default is 4\n"
                               "-o outputWidth specifies how wide the output is to be.  By default the\n"
                               "   outputWidth is set to the width of the console window if standard\n"
                               "   output has not been redirected to a file.  In the latter case, an\n"
                               "   outputWidth of 240 is used."
                             );
        MsgFprintf( stderr, "\n" );
        NumberOfLinesOutput += 1;
        }
    DisplayIndentedString( n, SavedModuleUsage2 );

    if (!RegBackSwitches) {
        DisplayIndentedString( n,
                               "Whenever specifying a registry path, either on the command line\n"
                               "or in an input file, the following prefix strings can be used:\n"
                               "\n"
                               "     HKEY_LOCAL_MACHINE\n"
                               "     HKEY_USERS\n"
                               "     HKEY_CURRENT_USER\n"
                               "     USER:\n"
                               "\n"
                               "   Each of these strings can stand alone as the key name or be followed\n"
                               "   a backslash and a subkey path."
                             );
        MsgFprintf( stderr, "\n" );
        NumberOfLinesOutput += 1;
        }

    //
    // No return from FatalError
    //

    if (Message != NULL) {
        MsgFprintf( stderr, "\n" );
        NumberOfLinesOutput += 1;
        }
    FatalError( Message, MessageParameter, 0 );
}

void
FatalError(
    LPSTR     Message,
    ULONG_PTR MessageParameter1,
    ULONG_PTR MessageParameter2
    )
{
    if (Message != NULL) {
        MsgFprintf( stderr, "%s: ", SavedModuleName );
        MsgFprintf( stderr, Message, MessageParameter1, MessageParameter2 );
        MsgFprintf( stderr, "\n" );
        }

    if (SavedCtrlCHandler != NULL) {
        (*SavedCtrlCHandler)( CTRL_BREAK_EVENT );
        }

    exit( 1 );
}

void
InputMessage(
    PWSTR FileName,
    ULONG LineNumber,
    BOOLEAN Error,
    LPSTR Message,
    ULONG_PTR MessageParameter1,
    ULONG_PTR MessageParameter2
    )
{
    MsgFprintf( stderr, "%ws(%u) : %s: ", FileName, LineNumber, Error ? "error" : "warning" );
    MsgFprintf( stderr, Message, MessageParameter1, MessageParameter2 );
    MsgFprintf( stderr, "\n" );
    return;
}

PWSTR
GetArgAsUnicode(
    LPSTR s
    )
{
    ULONG n;
    PWSTR ps;

    n = strlen( s );
    ps = HeapAlloc( GetProcessHeap(),
                    0,
                    (n + 1) * sizeof( WCHAR )
                  );
    if (ps == NULL) {
        FatalError( "Out of memory", 0, 0 );
        }

    if (MultiByteToWideChar( CP_ACP,
                             MB_PRECOMPOSED,
                             s,
                             n,
                             ps,
                             n
                           ) != (LONG)n
       ) {
        FatalError( "Unable to convert parameter '%s' to Unicode (%u)",
                    (ULONG_PTR)s, GetLastError() );
        }

    ps[ n ] = UNICODE_NULL;
    return ps;
}


void
CommonSwitchProcessing(
    PULONG argc,
    PCHAR **argv,
    CHAR c
    )
{
    c = (char)tolower( c );
    switch( c ) {
        case 'd':
            DebugOutput = TRUE;
            break;

        case 'o':
            if (--*argc) {
                OutputWidth = atoi( *++(*argv) );
                break;
                }
            else {
                Usage( "Missing argument to -o switch", 0 );
                }

        case 'i':
            if (--*argc) {
                IndentMultiple = atoi( *++(*argv) );
                break;
                }
            else {
                Usage( "Missing parameter for -%c switch", (ULONG)c );
                }

        case 'm':
            if (HiveFileName != NULL || HiveRootName != NULL ||
                Win95Path != NULL || Win95UserPath != NULL
               ) {
                Usage( "May only specify one of -h, -m or -w switches", 0 );
                }

            if (--*argc) {
                MachineName = GetArgAsUnicode( *++(*argv) );
                if (_wcsnicmp( MachineName, L"\\\\", 2 )) {
                    FatalError( "Invalid machine name - '%ws'",
                                (ULONG_PTR)MachineName, 0 );
                    }
                }
            else {
                Usage( "Missing parameter for -%c switch", (ULONG)c );
                }
            break;


        case 'w':
            if (MachineName != NULL || HiveFileName != NULL || HiveRootName != NULL) {
                Usage( "May only specify one of -h, -m or -w switches", 0 );
                }

            if (--*argc && --*argc) {
                Win95Path = GetArgAsUnicode( *++(*argv) );
                Win95UserPath = GetArgAsUnicode( *++(*argv) );
                }
            else {
                Usage( "Missing parameter(s) for -%c switch", (ULONG)c );
                }
            break;

        case 'h':
            if (MachineName != NULL || Win95Path != NULL || Win95UserPath != NULL) {
                Usage( "May only specify one of -h, -m or -w switches", 0 );
                }

            if (--*argc && --*argc) {
                HiveFileName = GetArgAsUnicode( *++(*argv) );
                HiveRootName = GetArgAsUnicode( *++(*argv) );
                }
            else {
                Usage( "Missing parameter(s) for -%c switch", (ULONG)c );
                }
            break;

        case '?':
            Usage( NULL, 0 );
            break;

        default:
            Usage( "Invalid switch (-%c)", (ULONG)c );
            break;
        }

    return;
}

/*
int MsgFprintf (
                 FILE *str,
                 LPSTR format,
                 ...
               )

if we ever need to display messages for english versions we can add the following portion of code.

[
#ifdef OUTPUT_ENGLISH_MSGS
   va_list va;
   if (PRIMARYLANGID(GetUserDefaultLangID()) == LANG_ENGLISH ) {
      va_start(va, format);
      i = vfprintf (str, format, va);
      va_end(va);
   }
#endif // OUTPUT_ENGLISH_MSGS
]
*/

int
__cdecl
MsgFprintf (
                 FILE *str,
                 LPSTR format,
                 ...
               )
{
   int i=0;
#ifndef SILENT_TS_TOOL
   va_list va;
   va_start(va, format);
   i = vfprintf (str, format, va);
   va_end(va);
#endif // SILENT_TS_TOOL
   return (i);
}
void TSGetch()
{
#ifndef SILENT_TS_TOOL
   _getch();
#endif // SILENT_TS_TOOL
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\regini\regutil.h ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    regutil.h

Abstract:

    This is the include file for the registry utility functions.

Author:

    Steve Wood (stevewo) 10-Mar-1992

Revision History:

--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include <windows.h>

#include <stdio.h>
#include <io.h>
#include <conio.h>
#include <stdlib.h>
#include <errno.h>
#include <string.h>
#include <ctype.h>
#include <string.h>
#include <fcntl.h>
#include <malloc.h>
#include <sys\types.h>
#include <sys\stat.h>
#include "regtool.h"


_inline ULONG
HiPtrToUlong( const void *p )
{
    DWORDLONG dwl;

    dwl=(ULONG_PTR)p;
    dwl >>= 32;

    return (ULONG)dwl;
}

#define LO_PTR  PtrToUlong
#define HI_PTR  HiPtrToUlong

REG_CONTEXT RegistryContext;
PVOID OldValueBuffer;
ULONG OldValueBufferSize;
PWSTR MachineName;
PWSTR HiveFileName;
PWSTR HiveRootName;
PWSTR Win95Path;
PWSTR Win95UserPath;

ULONG OutputHeight;
ULONG OutputWidth;
ULONG IndentMultiple;
BOOLEAN DebugOutput;
BOOLEAN FullPathOutput;

void
InitCommonCode(
    PHANDLER_ROUTINE CtrlCHandler,
    LPSTR ModuleName,
    LPSTR ModuleUsage1,
    LPSTR ModuleUsage2
    );

void
Usage(
    LPSTR Message,
    ULONG_PTR MessageParameter
    );

void
FatalError(
    LPSTR Message,
    ULONG_PTR MessageParameter1,
    ULONG_PTR MessageParameter2
    );

void
InputMessage(
    PWSTR FileName,
    ULONG LineNumber,
    BOOLEAN Error,
    LPSTR Message,
    ULONG_PTR MessageParameter1,
    ULONG_PTR MessageParameter2
    );

PWSTR
GetArgAsUnicode(
    LPSTR s
    );

void
CommonSwitchProcessing(
    PULONG argc,
    PCHAR **argv,
    CHAR c
    );

int
__cdecl
MsgFprintf (
    FILE *str,
    LPSTR Format,
    ...
    );

void TSGetch(void);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\regsvr32\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Visual C++ generated include file.
// Used by regsvr.rc
//
#define IDS_USAGE                       1
#define IDS_UNRECOGNIZEDFLAG            2
#define IDS_EXTRAARGUMENT               3
#define IDS_NOPROJECT                   4
#define IDS_NODLLNAME                   5
#define IDS_OLEINITFAILED               6
#define IDS_LOADLIBFAILED               7
#define IDS_NOTDLLOROCX                 8
#define IDS_NOENTRYPOINT                9
#define IDS_CALLFAILED                  10
#define IDS_CALLSUCCEEDED               11
#define IDS_OLEUNINITFAILED             12
#define IDS_NOTEXEORHELPER              13

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\regini\regtool.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    regtool.c

Abstract:

    This file contains functions for supporting the registry tools
    REGINI, REGDMP, REGDIR and REGFIND

Author:

    Steve Wood (stevewo) 15-Nov-1995

Revision History:

--*/

#include <tchar.h>
#include "regutil.h"

ULONG ValueBufferSize = (4096 * 100);
PVOID ValueBuffer;


UCHAR BlanksForPadding[] =
    "                                                                                                                                 ";

//
// routines for creating security descriptors (defined in regacl.c)
//

BOOLEAN
RegInitializeSecurity(
    VOID
    );

BOOLEAN
WINAPI
RegUnicodeToDWORD(
    IN OUT PWSTR *String,
    IN DWORD Base OPTIONAL,
    OUT PDWORD Value
    );

BOOLEAN
RegCreateSecurity(
    IN PWSTR Description,
    OUT PSECURITY_DESCRIPTOR SecurityDescriptor
    );

BOOLEAN
RegFormatSecurity(
    IN PSECURITY_DESCRIPTOR SecurityDescriptor,
    OUT PWSTR AceList
    );

VOID
RegDestroySecurity(
    IN PSECURITY_DESCRIPTOR SecurityDescriptor
    );

LONG
RegLoadHive(
    IN PREG_CONTEXT RegistryContext,
    IN PWSTR HiveFileName,
    IN PWSTR HiveRootName
    );

void
RegUnloadHive(
    IN PREG_CONTEXT RegistryContext
    );



struct {
    PWSTR TypeName;
    ULONG ValueType;
    BOOLEAN GetDataFromBinaryFile;
    BOOLEAN GetDataFromMultiSzFile;
    BOOLEAN ParseDateTime;
} RegTypeNameTable[] = {
    {L"REG_SZ", REG_SZ, FALSE, FALSE, FALSE},
    {L"REG_EXPAND_SZ", REG_EXPAND_SZ, FALSE, FALSE, FALSE},
    {L"REG_MULTI_SZ", REG_MULTI_SZ, FALSE, FALSE, FALSE},
    {L"REG_MULTISZ_FILE", REG_MULTI_SZ, FALSE, TRUE, FALSE},
    {L"REG_DWORD", REG_DWORD, FALSE, FALSE, FALSE},
    {L"REG_NONE", REG_NONE, FALSE, FALSE, FALSE},
    {L"REG_BINARY", REG_BINARY, FALSE, FALSE, FALSE},
    {L"REG_BINARYFILE", REG_BINARY, TRUE, FALSE, FALSE},
    {L"REG_DATE", REG_BINARY, FALSE, FALSE, TRUE},
    {L"REG_RESOURCE_LIST", REG_RESOURCE_LIST, FALSE, FALSE, FALSE},
    {L"REG_RESOURCE_REQUIREMENTS_LIST", REG_RESOURCE_REQUIREMENTS_LIST, FALSE, FALSE, FALSE},
    {L"REG_RESOURCE_REQUIREMENTS", REG_RESOURCE_REQUIREMENTS_LIST, FALSE, FALSE, FALSE},
    {L"REG_FULL_RESOURCE_DESCRIPTOR", REG_FULL_RESOURCE_DESCRIPTOR, FALSE, FALSE, FALSE},
    {NULL, REG_NONE, FALSE, FALSE, FALSE}
};

struct {
    PWSTR ValueName;
    ULONG Value;
} RegValueNameTable[] = {
    {L"ON", TRUE},
    {L"YES", TRUE},
    {L"TRUE", TRUE},
    {L"OFF", FALSE},
    {L"NO", FALSE},
    {L"FALSE", FALSE},
    {NULL, FALSE}
};


int
RegAnsiToUnicode(
    LPCSTR Source,
    PWSTR Destination,
    ULONG NumberOfChars
    )
{
    int NumberOfXlatedChars;

    if (NumberOfChars == 0) {
        NumberOfChars = strlen( Source );
        }

    NumberOfXlatedChars = MultiByteToWideChar( CP_ACP,
                                               MB_PRECOMPOSED,
                                               Source,
                                               NumberOfChars,
                                               Destination,
                                               NumberOfChars
                                             );

    Destination[ NumberOfXlatedChars ] = UNICODE_NULL;

    if ( NumberOfXlatedChars == 0 ) {
        SetLastError( ERROR_NO_UNICODE_TRANSLATION );
        }

    return NumberOfXlatedChars;
}


int
RegUnicodeToAnsi(
    PCWSTR Source,
    LPSTR Destination,
    ULONG NumberOfChars
    )
{
    int NumberOfXlatedChars;

    if (NumberOfChars == 0) {
        NumberOfChars = wcslen( Source );
        }

    NumberOfXlatedChars = WideCharToMultiByte( CP_ACP,
                                               0,
                                               Source,
                                               NumberOfChars,
                                               Destination,
                                               NumberOfChars * 2,
                                               NULL,
                                               NULL
                                             );

    Destination[ NumberOfXlatedChars ] = '\0';

    if ( NumberOfXlatedChars == 0 ) {
        SetLastError( ERROR_NO_UNICODE_TRANSLATION );
        }

    return NumberOfXlatedChars;
}

typedef
LONG
(APIENTRY *LPVMMREGMAPPREDEFKEYTOFILE_PROCEDURE)(
    HKEY hKey,
    LPCSTR lpFileName,
    UINT Flags
    );

typedef
LONG
(APIENTRY *LPVMMREGLOADKEY_PROCEDURE)(
    HKEY hKey,
    LPCSTR lpSubKey,
    LPCSTR lpFileName
    );

typedef
LONG
(APIENTRY *LPVMMREGUNLOADKEY_PROCEDURE)(
    HKEY hKey,
    LPCSTR lpSubKey
    );

typedef
LONG
(APIENTRY *LPVMMREGCREATEKEY_PROCEDURE)(
    HKEY hKey,
    LPCSTR lpSubKey,
    PHKEY lphSubKey
    );

typedef
LONG
(APIENTRY *LPVMMREGDELETEKEY_PROCEDURE)(
    HKEY hKey,
    LPCSTR lpSubKey
    );

typedef
LONG
(APIENTRY *LPVMMREGOPENKEY_PROCEDURE)(
    HKEY hKey,
    LPCSTR lpSubKey,
    PHKEY lphSubKey
    );

typedef
LONG
(APIENTRY *LPVMMREGFLUSHKEY_PROCEDURE)(
    HKEY hKey
    );

typedef
LONG
(APIENTRY *LPVMMREGCLOSEKEY_PROCEDURE)(
    HKEY hKey
    );

typedef
LONG
(APIENTRY *LPVMMREGQUERYINFOKEY_PROCEDURE)(
    HKEY hKey,
    LPCSTR lpClass,
    LPDWORD lpcbClass,
    LPDWORD lpReserved,
    LPDWORD lpcSubKeys,
    LPDWORD lpcbMaxSubKeyLen,
    LPDWORD lpcbMaxClassLen,
    LPDWORD lpcValues,
    LPDWORD lpcbMaxValueName,
    LPDWORD lpcbMaxValueData,
    LPVOID lpcbSecurityDescriptor,
    LPVOID lpftLastWriteTime
    );

typedef
LONG
(APIENTRY *LPVMMREGENUMKEY_PROCEDURE)(
    HKEY hKey,
    DWORD Index,
    LPSTR lpKeyName,
    DWORD cbKeyName
    );

typedef
LONG
(APIENTRY *LPVMMREGENUMVALUE_PROCEDURE)(
    HKEY hKey,
    DWORD Index,
    LPSTR lpValueName,
    LPDWORD lpcbValueName,
    LPDWORD lpReserved,
    LPDWORD lpType,
    LPBYTE lpData,
    LPDWORD lpcbData
    );

typedef
LONG
(APIENTRY *LPVMMREGQUERYVALUEEX_PROCEDURE)(
    HKEY hKey,
    LPCSTR lpValueName,
    LPDWORD lpReserved,
    LPDWORD lpType,
    LPBYTE lpData,
    LPDWORD lpcbData
    );

typedef
LONG
(APIENTRY *LPVMMREGSETVALUEEX_PROCEDURE)(
    HKEY hKey,
    LPCSTR lpValueName,
    DWORD Reserved,
    DWORD Type,
    LPBYTE lpData,
    DWORD cbData
    );

typedef
LONG
(APIENTRY *LPVMMREGDELETEVALUE_PROCEDURE)(
    HKEY hKey,
    LPCSTR lpValueName
    );

HMODULE hVMMREG32;
LPVMMREGMAPPREDEFKEYTOFILE_PROCEDURE _Win95RegMapPredefKeyToFile;
LPVMMREGLOADKEY_PROCEDURE            _Win95RegLoadKey;
LPVMMREGUNLOADKEY_PROCEDURE          _Win95RegUnLoadKey;
LPVMMREGCREATEKEY_PROCEDURE          _Win95RegCreateKey;
LPVMMREGDELETEKEY_PROCEDURE          _Win95RegDeleteKey;
LPVMMREGOPENKEY_PROCEDURE            _Win95RegOpenKey;
LPVMMREGFLUSHKEY_PROCEDURE           _Win95RegFlushKey;
LPVMMREGCLOSEKEY_PROCEDURE           _Win95RegCloseKey;
LPVMMREGQUERYINFOKEY_PROCEDURE       _Win95RegQueryInfoKey;
LPVMMREGENUMKEY_PROCEDURE            _Win95RegEnumKey;
LPVMMREGENUMVALUE_PROCEDURE          _Win95RegEnumValue;
LPVMMREGQUERYVALUEEX_PROCEDURE       _Win95RegQueryValueEx;
LPVMMREGSETVALUEEX_PROCEDURE         _Win95RegSetValueEx;
LPVMMREGDELETEVALUE_PROCEDURE        _Win95RegDeleteValue;

BOOLEAN
RegInitWin95RegistryAccess(
    PREG_CONTEXT RegistryContext,
    PWSTR Win95Path,
    PWSTR Win95UserPath
    )
{
    LONG Error;
    char Buffer[ MAX_PATH+1 ];

    if ((hVMMREG32 = LoadLibrary( L"VMMREG32" )) == NULL) {
        return FALSE;
        }

    _Win95RegMapPredefKeyToFile = (LPVMMREGMAPPREDEFKEYTOFILE_PROCEDURE)GetProcAddress( hVMMREG32, "VMMRegMapPredefKeyToFile" );
    _Win95RegLoadKey            = (LPVMMREGLOADKEY_PROCEDURE           )GetProcAddress( hVMMREG32, "VMMRegLoadKey"            );
    _Win95RegUnLoadKey          = (LPVMMREGUNLOADKEY_PROCEDURE         )GetProcAddress( hVMMREG32, "VMMRegUnLoadKey"          );
    _Win95RegCreateKey          = (LPVMMREGCREATEKEY_PROCEDURE         )GetProcAddress( hVMMREG32, "VMMRegCreateKey"          );
    _Win95RegDeleteKey          = (LPVMMREGDELETEKEY_PROCEDURE         )GetProcAddress( hVMMREG32, "VMMRegDeleteKey"          );
    _Win95RegOpenKey            = (LPVMMREGOPENKEY_PROCEDURE           )GetProcAddress( hVMMREG32, "VMMRegOpenKey"            );
    _Win95RegFlushKey           = (LPVMMREGFLUSHKEY_PROCEDURE          )GetProcAddress( hVMMREG32, "VMMRegFlushKey"           );
    _Win95RegCloseKey           = (LPVMMREGCLOSEKEY_PROCEDURE          )GetProcAddress( hVMMREG32, "VMMRegCloseKey"           );
    _Win95RegQueryInfoKey       = (LPVMMREGQUERYINFOKEY_PROCEDURE      )GetProcAddress( hVMMREG32, "VMMRegQueryInfoKey"       );
    _Win95RegEnumKey            = (LPVMMREGENUMKEY_PROCEDURE           )GetProcAddress( hVMMREG32, "VMMRegEnumKey"            );
    _Win95RegEnumValue          = (LPVMMREGENUMVALUE_PROCEDURE         )GetProcAddress( hVMMREG32, "VMMRegEnumValue"          );
    _Win95RegQueryValueEx       = (LPVMMREGQUERYVALUEEX_PROCEDURE      )GetProcAddress( hVMMREG32, "VMMRegQueryValueEx"       );
    _Win95RegSetValueEx         = (LPVMMREGSETVALUEEX_PROCEDURE        )GetProcAddress( hVMMREG32, "VMMRegSetValueEx"         );
    _Win95RegDeleteValue        = (LPVMMREGDELETEVALUE_PROCEDURE       )GetProcAddress( hVMMREG32, "VMMRegDeleteValue"        );

    if ((_Win95RegMapPredefKeyToFile == NULL) ||
        (_Win95RegLoadKey == NULL) ||
        (_Win95RegUnLoadKey == NULL) ||
        (_Win95RegCreateKey == NULL) ||
        (_Win95RegDeleteKey == NULL) ||
        (_Win95RegOpenKey == NULL) ||
        (_Win95RegFlushKey  == NULL) ||
        (_Win95RegCloseKey  == NULL) ||
        (_Win95RegQueryInfoKey == NULL) ||
        (_Win95RegEnumKey == NULL) ||
        (_Win95RegEnumValue == NULL) ||
        (_Win95RegQueryValueEx == NULL) ||
        (_Win95RegSetValueEx == NULL) ||
        (_Win95RegDeleteValue == NULL)
       ) {
        FreeLibrary( hVMMREG32 );
        SetLastError( ERROR_PROC_NOT_FOUND );
        return FALSE;
        }

    //
    //  Map HKEY_LOCAL_MACHINE of Win95 hive
    //

    RegUnicodeToAnsi( Win95Path, Buffer, 0 );
    strcat( Buffer, "\\system.dat" );
    Error = (_Win95RegMapPredefKeyToFile)( HKEY_LOCAL_MACHINE, Buffer, 0 );
    if (Error == NO_ERROR) {
        RegistryContext->MachineRoot = HKEY_LOCAL_MACHINE;
        RegUnicodeToAnsi( Win95Path, Buffer, 0 );
        strcat( Buffer, "\\user.dat" );
        Error = (_Win95RegMapPredefKeyToFile)( HKEY_USERS, Buffer, 0 );
        if (Error == NO_ERROR) {
            RegistryContext->UsersRoot = HKEY_USERS;
            Error = (_Win95RegOpenKey)( HKEY_USERS, ".Default", &RegistryContext->CurrentUserRoot );
            }
        }

    if (Error != NO_ERROR) {
        if (RegistryContext->MachineRoot != NULL) {
            (_Win95RegMapPredefKeyToFile)( RegistryContext->MachineRoot, NULL, 0 );
            }

        if (RegistryContext->UsersRoot) {
            (_Win95RegMapPredefKeyToFile)( RegistryContext->UsersRoot, NULL, 0 );
            }

        FreeLibrary( hVMMREG32 );
        SetLastError( Error );
        return FALSE;
        }

    wcscpy( RegistryContext->UsersPath, L"\\Registry\\Users" );
    wcscpy( RegistryContext->CurrentUserPath, RegistryContext->UsersPath );
    wcscat( RegistryContext->CurrentUserPath, L"\\.Default" );
    return TRUE;
}


BOOLEAN PrivilegeEnabled;
BOOLEAN RestoreWasEnabled;
BOOLEAN BackupWasEnabled;

BOOLEAN
RTEnableBackupRestorePrivilege( void )
{
    NTSTATUS Status;

    //
    // Try to enable backup and restore privileges
    //
    Status = RtlAdjustPrivilege( SE_RESTORE_PRIVILEGE,
                                 TRUE,               // Enable
                                 FALSE,              // Not impersonating
                                 &RestoreWasEnabled  // previous state
                               );
    if (!NT_SUCCESS( Status )) {
        return FALSE;
        }

    Status = RtlAdjustPrivilege( SE_BACKUP_PRIVILEGE,
                                 TRUE,               // Enable
                                 FALSE,              // Not impersonating
                                 &BackupWasEnabled   // previous state
                               );
    if (!NT_SUCCESS( Status )) {
        return FALSE;
        }

    PrivilegeEnabled = TRUE;
    return TRUE;
}


void
RTDisableBackupRestorePrivilege( void )
{
    //
    // Restore privileges to what they were
    //

    RtlAdjustPrivilege( SE_RESTORE_PRIVILEGE,
                        RestoreWasEnabled,
                        FALSE,
                        &RestoreWasEnabled
                      );

    RtlAdjustPrivilege( SE_BACKUP_PRIVILEGE,
                        BackupWasEnabled,
                        FALSE,
                        &BackupWasEnabled
                      );

    PrivilegeEnabled = FALSE;
    return;
}



BOOLEAN
RTInitialize( void )
/*++

Routine Description:

    DLL initialization function.

Arguments:

    hInstance   - Instance handle
    Reason      - Reason for the entrypoint being called
    Context     - Context record

Return Value:

    TRUE        - Initialization succeeded
    FALSE       - Initialization failed

--*/

{
    ValueBuffer = VirtualAlloc( NULL, ValueBufferSize, MEM_COMMIT, PAGE_READWRITE );
    if (ValueBuffer == NULL) {
        return FALSE;
        }

    if (!RegInitializeSecurity()) {
        return FALSE;
        }

    return TRUE;
}


LONG
RTConnectToRegistry(
    IN PWSTR MachineName,
    IN PWSTR HiveFileName,
    IN PWSTR HiveRootName,
    IN PWSTR Win95Path,
    IN PWSTR Win95UserName,
    OUT PWSTR *DefaultRootKeyName,
    OUT PREG_CONTEXT RegistryContext
    )
{
    LONG Error;

    if (MachineName != NULL) {
        if (HiveRootName || HiveFileName || Win95Path || Win95UserName) {
            return ERROR_INVALID_PARAMETER;
            }

        Error = RegConnectRegistry( MachineName, HKEY_LOCAL_MACHINE, (PHKEY)&RegistryContext->MachineRoot );
        if (Error == NO_ERROR) {
            Error = RegConnectRegistry( MachineName, HKEY_USERS, (PHKEY)&RegistryContext->UsersRoot );
            if (Error == NO_ERROR) {
                Error = RegOpenKey( RegistryContext->UsersRoot, L".Default", &RegistryContext->CurrentUserRoot );
                }
            }

        if (Error != NO_ERROR) {
            if (RegistryContext->MachineRoot != NULL) {
                RegCloseKey( RegistryContext->MachineRoot );
                RegistryContext->MachineRoot = NULL;
                }

            if (RegistryContext->UsersRoot != NULL) {
                RegCloseKey( RegistryContext->UsersRoot );
                RegistryContext->UsersRoot = NULL;
                }

            return Error;
            }

        wcscpy( RegistryContext->MachinePath, L"\\Registry\\Machine" );
        wcscpy( RegistryContext->UsersPath, L"\\Registry\\Users" );
        wcscpy( RegistryContext->CurrentUserPath, L"\\Registry\\Users\\.Default" );
        RegistryContext->Target = REG_TARGET_REMOTE_REGISTRY;
        }
    else
    if (HiveRootName != NULL || HiveFileName != NULL) {
        if (HiveRootName == NULL || HiveFileName == NULL ||
            Win95Path != NULL || Win95UserName != NULL
           ) {
            return ERROR_INVALID_PARAMETER;
            }

        if (!PrivilegeEnabled && !RTEnableBackupRestorePrivilege()) {
            return ERROR_PRIVILEGE_NOT_HELD;
            }

        RegistryContext->MachineRoot = NULL;
        RegistryContext->UsersRoot = NULL;
        RegistryContext->CurrentUserRoot = NULL;

        Error = RegLoadHive( RegistryContext, HiveFileName, HiveRootName );
        if (Error != NO_ERROR) {
            return Error;
            }

        if (DefaultRootKeyName != NULL && *DefaultRootKeyName == NULL) {
            *DefaultRootKeyName = HiveRootName;
            }
        RegistryContext->Target = REG_TARGET_HIVE_REGISTRY;
        }
    else
    if (Win95Path != NULL || Win95UserName != NULL) {
        if (!RegInitWin95RegistryAccess( RegistryContext,
                                         Win95Path,
                                         Win95UserName
                                       )
           ) {
            return GetLastError();
            }

        RegistryContext->Target = REG_TARGET_WIN95_REGISTRY;
        }
    else {
        NTSTATUS Status;
        UNICODE_STRING CurrentUserKeyPath;

        RegistryContext->MachineRoot = HKEY_LOCAL_MACHINE;
        RegistryContext->UsersRoot = HKEY_USERS;
        RegistryContext->CurrentUserRoot = HKEY_CURRENT_USER;

        wcscpy( RegistryContext->MachinePath, L"\\Registry\\Machine" );
        wcscpy( RegistryContext->UsersPath, L"\\Registry\\Users" );
        Status = RtlFormatCurrentUserKeyPath( &CurrentUserKeyPath );
        if (!NT_SUCCESS( Status )) {
            SetLastError( RtlNtStatusToDosError( Status ) );
            return FALSE;
            }

        wcscpy( RegistryContext->CurrentUserPath, CurrentUserKeyPath.Buffer );
        RtlFreeUnicodeString( &CurrentUserKeyPath );

        RegistryContext->Target = REG_TARGET_LOCAL_REGISTRY;
        }

    if (DefaultRootKeyName != NULL && *DefaultRootKeyName == NULL) {
        *DefaultRootKeyName = L"\\Registry";
        }
    RegistryContext->MachinePathLength = wcslen( RegistryContext->MachinePath );
    RegistryContext->UsersPathLength = wcslen( RegistryContext->UsersPath );
    RegistryContext->CurrentUserPathLength = wcslen( RegistryContext->CurrentUserPath );
    return NO_ERROR;
}


LONG
RTDisconnectFromRegistry(
    IN PREG_CONTEXT RegistryContext
    )
{
    switch( RegistryContext->Target ) {
        case REG_TARGET_DISCONNECTED:
            break;

        case REG_TARGET_LOCAL_REGISTRY:
            break;

        case REG_TARGET_REMOTE_REGISTRY:
            break;

        case REG_TARGET_WIN95_REGISTRY:
            // (_Win95RegMapPredefKeyToFile)( RegistryContext->MachineRoot, NULL, 0 );
            // (_Win95RegMapPredefKeyToFile)( RegistryContext->UsersRoot, NULL, 0 );
            (_Win95RegCloseKey)( RegistryContext->CurrentUserRoot );
            FreeLibrary( hVMMREG32 );
            break;

        case REG_TARGET_HIVE_REGISTRY:
            RegUnloadHive( RegistryContext );
            break;
        }

    if (PrivilegeEnabled) {
        RTDisableBackupRestorePrivilege();
        }

    RegistryContext->Target = REG_TARGET_DISCONNECTED;
    return NO_ERROR;
}

UNICODE_STRING RegHiveRootName;

LONG
RegLoadHive(
    IN PREG_CONTEXT RegistryContext,
    IN PWSTR HiveFileName,
    IN PWSTR HiveRootName
    )
{
    NTSTATUS Status;
    UNICODE_STRING NtFileName;
    OBJECT_ATTRIBUTES File;
    SECURITY_DESCRIPTOR SecurityDescriptor;

    //
    // Create security descriptor with a NULL Dacl.  This is necessary
    // because the security descriptor we pass in gets used in system
    // context.  So if we just pass in NULL, then the Wrong Thing happens.
    // (but only on NTFS!)
    //
    Status = RtlCreateSecurityDescriptor( &SecurityDescriptor,
                                          SECURITY_DESCRIPTOR_REVISION
                                        );
    if (!NT_SUCCESS( Status )) {
        return RtlNtStatusToDosError( Status );
        }

    Status = RtlSetDaclSecurityDescriptor( &SecurityDescriptor,
                                           TRUE,         // Dacl present
                                           NULL,         // but grants all access
                                           FALSE
                                         );
    if (!NT_SUCCESS( Status )) {
        return RtlNtStatusToDosError( Status );
        }

    if (!RtlDosPathNameToNtPathName_U( HiveFileName,
                                       &NtFileName,
                                       NULL,
                                       NULL
                                     )
       ) {
        return ERROR_BAD_PATHNAME;
        }
    InitializeObjectAttributes( &File,
                                &NtFileName,
                                OBJ_CASE_INSENSITIVE,
                                NULL,
                                &SecurityDescriptor
                              );

    RtlInitUnicodeString( &RegHiveRootName, L"\\Registry");
    InitializeObjectAttributes( &RegistryContext->HiveRootKey,
                                &RegHiveRootName,
                                OBJ_CASE_INSENSITIVE,
                                NULL,
                                NULL
                              );
    Status = NtOpenKey( &RegistryContext->HiveRootHandle,
                        MAXIMUM_ALLOWED,
                        &RegistryContext->HiveRootKey
                      );
    if (!NT_SUCCESS(Status)) {
        return RtlNtStatusToDosError( Status );
        }

    RtlInitUnicodeString( &RegHiveRootName, HiveRootName );
    InitializeObjectAttributes( &RegistryContext->HiveRootKey,
                                &RegHiveRootName,
                                OBJ_CASE_INSENSITIVE,
                                RegistryContext->HiveRootHandle,
                                NULL
                              );
    NtUnloadKey( &RegistryContext->HiveRootKey );
    Status = NtLoadKey( &RegistryContext->HiveRootKey, &File );
    if (!NT_SUCCESS( Status )) {
        return RtlNtStatusToDosError( Status );
        }

    return NO_ERROR;

}

void
RegUnloadHive(
    IN PREG_CONTEXT RegistryContext
    )
{
    NTSTATUS Status;
    HANDLE Handle;
    PREG_CONTEXT_OPEN_HIVE_KEY p, p1;

    Status = NtOpenKey( &Handle,
                        MAXIMUM_ALLOWED,
                        &RegistryContext->HiveRootKey
                      );
    if (NT_SUCCESS( Status )) {
        NtFlushKey( Handle );
        NtClose( Handle );
        }

    p = RegistryContext->OpenHiveKeys;
    while (p) {
        RegCloseKey( p->KeyHandle );
        p1 = p;
        p = p->Next;
        HeapFree( GetProcessHeap(), 0, p1 );
        };

    do {
        Status = NtUnloadKey( &RegistryContext->HiveRootKey );
        }
    while (NT_SUCCESS( Status ) );

    NtClose( RegistryContext->HiveRootHandle );
    return;
}


void
RegRememberOpenKey(
    IN PREG_CONTEXT RegistryContext,
    IN HKEY KeyHandle
    )
{
    PREG_CONTEXT_OPEN_HIVE_KEY p, *pp;

    pp = &RegistryContext->OpenHiveKeys;
    while ((p = *pp) != NULL) {
        if (p->KeyHandle == KeyHandle) {
            p->ReferenceCount += 1;
            return;
            }
        else {
            pp = &p->Next;
            }
        }

    p = HeapAlloc( GetProcessHeap(), 0, sizeof( *p ) );
    if (p != NULL) {
        p->KeyHandle = KeyHandle;
        p->ReferenceCount = 1;
        p->Next = NULL;
        *pp = p;
        }

    return;
}


void
RegForgetOpenKey(
    IN PREG_CONTEXT RegistryContext,
    IN HKEY KeyHandle
    )
{
    PREG_CONTEXT_OPEN_HIVE_KEY p, *pp;

    pp = &RegistryContext->OpenHiveKeys;
    while ((p = *pp) != NULL) {
        if (p->KeyHandle == KeyHandle) {
            p->ReferenceCount -= 1;
            if (p->ReferenceCount == 0) {
                *pp = p->Next;
                HeapFree( GetProcessHeap(), 0, p );
                return;
                }
            }
        else {
            pp = &p->Next;
            }
        }

    return;
}

BOOLEAN
RegCheckPrefix(
    IN OUT PCWSTR *s,
    IN PCWSTR Prefix,
    IN ULONG PrefixLength
    )
{
    if (PrefixLength == 0) {
        return FALSE;
        }

    if (!_wcsnicmp( *s, Prefix, PrefixLength )) {
        *s += PrefixLength;
        return TRUE;
        }

    return FALSE;
}


BOOLEAN
RegValidateKeyPath(
    IN PREG_CONTEXT RegistryContext,
    IN OUT PHKEY RootKeyHandle,
    IN OUT PCWSTR *SubKeyName
    )
{
    PCWSTR s;

    s = *SubKeyName;
    if (*RootKeyHandle == NULL) {
        if (RegCheckPrefix( &s, L"USER:", 5 ) ||
            RegCheckPrefix( &s, L"HKEY_CURRENT_USER", 17 )
           ) {
            if (RegistryContext->CurrentUserRoot == NULL) {
                SetLastError( ERROR_BAD_PATHNAME );
                return FALSE;
                }

            if (*s == L'\\') {
                s += 1;
                }
            else
            if (s[-1] != L':' && *s != UNICODE_NULL) {
                SetLastError( ERROR_BAD_PATHNAME );
                return FALSE;
                }

            *RootKeyHandle = RegistryContext->CurrentUserRoot;
            }
        else
        if (RegCheckPrefix( &s, L"HKEY_LOCAL_MACHINE", 18 )) {
            if (*s == L'\\') {
                s += 1;
                }
            else
            if (*s != UNICODE_NULL) {
                SetLastError( ERROR_BAD_PATHNAME );
                return FALSE;
                }

            *RootKeyHandle = RegistryContext->MachineRoot;
            }
        else
        if (RegCheckPrefix( &s, L"HKEY_USERS", 10 )) {
            if (*s == L'\\') {
                s += 1;
                }
            else
            if (*s != UNICODE_NULL) {
                SetLastError( ERROR_BAD_PATHNAME );
                return FALSE;
                }

            *RootKeyHandle = RegistryContext->UsersRoot;
            }
        else
        if (*s != L'\\') {
            SetLastError( ERROR_BAD_PATHNAME );
            return FALSE;
            }
        else
        if (RegCheckPrefix( &s, RegistryContext->MachinePath, RegistryContext->MachinePathLength )) {
            *RootKeyHandle = RegistryContext->MachineRoot;
            if (*s == L'\\') {
                s += 1;
                }
            }
        else
        if (RegCheckPrefix( &s, RegistryContext->UsersPath, RegistryContext->UsersPathLength )) {
            *RootKeyHandle = RegistryContext->UsersRoot;
            if (*s == L'\\') {
                s += 1;
                }
            }
        else
        if (RegCheckPrefix( &s, RegistryContext->CurrentUserPath, RegistryContext->CurrentUserPathLength )) {
            *RootKeyHandle = RegistryContext->CurrentUserRoot;
            if (*s == L'\\') {
                s += 1;
                }
            }
        else
        if (!_wcsicmp( *SubKeyName, L"\\Registry" )) {
            *RootKeyHandle = NULL;
            }
        else {
            SetLastError( ERROR_BAD_PATHNAME );
            return FALSE;
            }
        }
    else
    if (*s == L'\\') {
        SetLastError( ERROR_BAD_PATHNAME );
        return FALSE;
        }

    *SubKeyName = s;
    return TRUE;
}

LONG
RTCreateKey(
    IN PREG_CONTEXT RegistryContext,
    IN HKEY RootKeyHandle,
    IN PCWSTR SubKeyName,
    IN ACCESS_MASK DesiredAccess,
    IN ULONG CreateOptions,
    IN PVOID SecurityDescriptor,
    OUT PHKEY ReturnedKeyHandle,
    OUT PULONG Disposition
    )
{
    LONG Error;

    if (!RegValidateKeyPath( RegistryContext, &RootKeyHandle, &SubKeyName )) {
        return GetLastError();
        }

    if (RootKeyHandle == NULL) {
        *Disposition = REG_OPENED_EXISTING_KEY;
        *ReturnedKeyHandle = HKEY_REGISTRY_ROOT;
        return NO_ERROR;
        }
    else
    if (RootKeyHandle == HKEY_REGISTRY_ROOT) {
        *ReturnedKeyHandle = NULL;
        if (!_wcsicmp( SubKeyName, L"Machine" )) {
            *ReturnedKeyHandle = RegistryContext->MachineRoot;
            }
        else
        if (!_wcsicmp( SubKeyName, L"Users" )) {
            *ReturnedKeyHandle = RegistryContext->UsersRoot;
            }


        if (*ReturnedKeyHandle != NULL) {
            return NO_ERROR;
            }
        else {
            return ERROR_PATH_NOT_FOUND;
            }
        }

    if (RegistryContext->Target == REG_TARGET_WIN95_REGISTRY) {
        UCHAR AnsiSubKeyName[ MAX_PATH ], *p;

        if (SubKeyName != NULL) {
            if (!RegUnicodeToAnsi( SubKeyName, AnsiSubKeyName, 0 )) {
                return GetLastError();
                }

            p = AnsiSubKeyName;
            }
        else {
            p = NULL;
            }

        Error = (_Win95RegOpenKey)( RootKeyHandle, p, ReturnedKeyHandle );
        if (Error == NO_ERROR) {
            *Disposition = REG_OPENED_EXISTING_KEY;
            }
        else {
            Error = (_Win95RegCreateKey)( RootKeyHandle, p, ReturnedKeyHandle );
            if (Error == NO_ERROR) {
                *Disposition = REG_CREATED_NEW_KEY;
                }
            }
        }
    else {
        SECURITY_ATTRIBUTES SecurityAttributes;

        SecurityAttributes.nLength = sizeof( SecurityAttributes );
        SecurityAttributes.lpSecurityDescriptor = SecurityDescriptor;
        SecurityAttributes.bInheritHandle = FALSE;
        Error = RegCreateKeyEx( RootKeyHandle,
                                SubKeyName,
                                0,
                                NULL,
                                CreateOptions,
                                (REGSAM)DesiredAccess,
                                &SecurityAttributes,
                                ReturnedKeyHandle,
                                Disposition
                              );
        if (Error == NO_ERROR &&
            RegistryContext->Target == REG_TARGET_HIVE_REGISTRY
           ) {
            RegRememberOpenKey( RegistryContext, *ReturnedKeyHandle );
            }

        if (Error == NO_ERROR &&
            *Disposition == REG_OPENED_EXISTING_KEY &&
            SecurityDescriptor != NULL
           ) {
            RegSetKeySecurity( *ReturnedKeyHandle,
                               DACL_SECURITY_INFORMATION,
                               SecurityDescriptor
                             );
            }
        }

    return Error;
}

LONG
RTOpenKey(
    IN PREG_CONTEXT RegistryContext,
    IN HKEY RootKeyHandle,
    IN PCWSTR SubKeyName,
    IN ACCESS_MASK DesiredAccess,
    IN ULONG OpenOptions,
    OUT PHKEY ReturnedKeyHandle
    )
{
    LONG Error;

    if (!RegValidateKeyPath( RegistryContext, &RootKeyHandle, &SubKeyName )) {
        return GetLastError();
        }

    if (RootKeyHandle == NULL) {
        *ReturnedKeyHandle = HKEY_REGISTRY_ROOT;
        return NO_ERROR;
        }
    else
    if (RootKeyHandle == HKEY_REGISTRY_ROOT) {
        *ReturnedKeyHandle = NULL;
        if (!_wcsicmp( SubKeyName, L"Machine" )) {
            *ReturnedKeyHandle = RegistryContext->MachineRoot;
            }
        else
        if (!_wcsicmp( SubKeyName, L"Users" )) {
            *ReturnedKeyHandle = RegistryContext->UsersRoot;
            }

        if (*ReturnedKeyHandle != NULL) {
            return NO_ERROR;
            }
        else {
            return ERROR_PATH_NOT_FOUND;
            }
        }

    if (RegistryContext->Target == REG_TARGET_WIN95_REGISTRY) {
        UCHAR AnsiSubKeyName[ MAX_PATH ], *p;

        if (SubKeyName != NULL) {
            if (!RegUnicodeToAnsi( SubKeyName, AnsiSubKeyName, 0 )) {
                return GetLastError();
                }

            p = AnsiSubKeyName;
            }
        else {
            p = NULL;
            }

        return (_Win95RegOpenKey)( RootKeyHandle, p, ReturnedKeyHandle );
        }
    else {
        Error = RegOpenKeyEx( RootKeyHandle,
                              SubKeyName,
                              OpenOptions,
                              DesiredAccess,
                              ReturnedKeyHandle
                            );
        if (Error == NO_ERROR &&
            RegistryContext->Target == REG_TARGET_HIVE_REGISTRY
           ) {
            RegRememberOpenKey( RegistryContext, *ReturnedKeyHandle );
            }

        return Error;
        }
}

LONG
RTCloseKey(
    IN PREG_CONTEXT RegistryContext,
    IN HKEY KeyHandle
    )
{
    LONG Error;

    if (KeyHandle == HKEY_REGISTRY_ROOT) {
        return NO_ERROR;
        }
    else
    if (RegistryContext->Target == REG_TARGET_WIN95_REGISTRY) {
        return (_Win95RegCloseKey)( KeyHandle );
        }
    else {
        Error = RegCloseKey( KeyHandle );
        if (Error == NO_ERROR &&
            RegistryContext->Target == REG_TARGET_HIVE_REGISTRY
           ) {
            RegForgetOpenKey( RegistryContext, KeyHandle );
            }

        return Error;
        }
}

LONG
RTFlushKey(
    IN PREG_CONTEXT RegistryContext,
    IN HKEY KeyHandle
    )
{
    if (KeyHandle == HKEY_REGISTRY_ROOT) {
        return NO_ERROR;
        }
    else
    if (RegistryContext->Target == REG_TARGET_WIN95_REGISTRY) {
        return (_Win95RegFlushKey)( KeyHandle );
        }
    else {
        return RegFlushKey( KeyHandle );
        }
}

LONG
RTEnumerateKey(
    IN PREG_CONTEXT RegistryContext,
    IN HKEY KeyHandle,
    IN ULONG Index,
    OUT PFILETIME LastWriteTime,
    IN OUT PULONG KeyNameLength,
    OUT PWSTR KeyName
    )
{
    ULONG Error;

    if (KeyHandle == HKEY_REGISTRY_ROOT) {
        if (Index == 0) {
            if (*KeyNameLength <= 7) {
                return ERROR_MORE_DATA;
                }
            else {
                wcscpy( KeyName, L"Machine" );
                return NO_ERROR;
                }
            }
        else
        if (Index == 1) {
            if (*KeyNameLength <= 5) {
                return ERROR_MORE_DATA;
                }
            else {
                wcscpy( KeyName, L"Users" );
                return NO_ERROR;
                }
            }
        else {
            return ERROR_NO_MORE_ITEMS;
            }
        }
    else
    if (RegistryContext->Target == REG_TARGET_WIN95_REGISTRY) {
        UCHAR AnsiKeyName[ MAX_PATH ];
        ULONG AnsiKeyNameLength;

        AnsiKeyNameLength = sizeof( AnsiKeyName );
        Error = _Win95RegEnumKey( KeyHandle,
                                  Index,
                                  AnsiKeyName,
                                  AnsiKeyNameLength
                                );
        if (Error == NO_ERROR) {
            if (strlen( AnsiKeyName ) >= *KeyNameLength) {
                return ERROR_MORE_DATA;
                }

            *KeyNameLength = RegAnsiToUnicode( AnsiKeyName, KeyName, AnsiKeyNameLength );

            if (*KeyNameLength == 0) {
                return GetLastError();
                }

            RtlZeroMemory( LastWriteTime, sizeof( *LastWriteTime ) );
            }
        }
    else {
        Error = RegEnumKeyEx( KeyHandle,
                              Index,
                              KeyName,
                              KeyNameLength,
                              NULL,
                              NULL,
                              NULL,
                              LastWriteTime
                            );
        }

    return Error;
}

LONG
RTEnumerateValueKey(
    IN PREG_CONTEXT RegistryContext,
    IN HKEY KeyHandle,
    IN ULONG Index,
    OUT PULONG ValueType,
    IN OUT PULONG ValueNameLength,
    OUT PWSTR ValueName,
    IN OUT PULONG ValueDataLength,
    OUT PVOID ValueData
    )
{
    ULONG Error;

    if (KeyHandle == HKEY_REGISTRY_ROOT) {
        return ERROR_NO_MORE_ITEMS;
        }
    else
    if (RegistryContext->Target == REG_TARGET_WIN95_REGISTRY) {
        UCHAR AnsiValueName[ MAX_PATH ];
        ULONG AnsiValueNameLength;
        LPSTR AnsiValueData;
        ULONG OriginalValueDataLength;

        AnsiValueNameLength = sizeof( AnsiValueName );
        OriginalValueDataLength = *ValueDataLength;
        Error = (_Win95RegEnumValue)( KeyHandle,
                                      Index,
                                      AnsiValueName,
                                      &AnsiValueNameLength,
                                      0,
                                      ValueType,
                                      ValueData,
                                      ValueDataLength
                                    );

        if (Error != NO_ERROR) {
            return Error;
            }

        if (AnsiValueNameLength >= *ValueNameLength) {
            return ERROR_MORE_DATA;
            }

        if (RegAnsiToUnicode( AnsiValueName, ValueName, AnsiValueNameLength ) == 0) {
            return GetLastError();
            }

        if (*ValueType == REG_SZ) {
            AnsiValueData = HeapAlloc( GetProcessHeap(), 0, *ValueDataLength );
            if (AnsiValueData == NULL) {
                return ERROR_OUTOFMEMORY;
                }

            RtlMoveMemory( AnsiValueData, ValueData, *ValueDataLength );
            if (RegAnsiToUnicode( AnsiValueData, (PWSTR)ValueData, *ValueDataLength ) == 0) {
                Error = GetLastError();
                }
            else {
                *ValueDataLength *= sizeof( WCHAR );
                }

            HeapFree( GetProcessHeap(), 0, AnsiValueData );
            }

        return Error;
        }
    else {
        Error = RegEnumValue( KeyHandle,
                              Index,
                              ValueName,
                              ValueNameLength,
                              NULL,
                              ValueType,
                              ValueData,
                              ValueDataLength
                            );
        if (Error == NO_ERROR) {
            RtlZeroMemory( (PCHAR)ValueData + *ValueDataLength, 4 - (*ValueDataLength & 3) );
            }

        return Error;
        }
}


LONG
RTQueryKey(
    IN PREG_CONTEXT RegistryContext,
    IN HKEY KeyHandle,
    OUT PFILETIME LastWriteTime,
    OUT PULONG NumberOfSubkeys,
    OUT PULONG NumberOfValues
    )
{
    LONG Error;

    if (KeyHandle == HKEY_REGISTRY_ROOT) {
        if (NumberOfSubkeys != NULL) {
            *NumberOfSubkeys = 2;
            }

        if (NumberOfValues != NULL) {
            *NumberOfValues = 0;
            }

        return NO_ERROR;
        }
    else
    if (RegistryContext->Target == REG_TARGET_WIN95_REGISTRY) {
        Error = (_Win95RegQueryInfoKey)( KeyHandle,
                                         NULL,
                                         NULL,
                                         NULL,
                                         NumberOfSubkeys,
                                         NULL,
                                         NULL,
                                         NumberOfValues,
                                         NULL,
                                         NULL,
                                         NULL,
                                         (PVOID)LastWriteTime
                                       );
        }
    else {
        Error = RegQueryInfoKey( KeyHandle,             // hKey,
                                 NULL,                  // lpClass,
                                 NULL,                  // lpcbClass,
                                 NULL,                  // lpReserved,
                                 NumberOfSubkeys,       // lpcSubKeys,
                                 NULL,                  // lpcbMaxSubKeyLen,
                                 NULL,                  // lpcbMaxClassLen,
                                 NumberOfValues,        // lpcValues,
                                 NULL,                  // lpcbMaxValueNameLen,
                                 NULL,                  // lpcbMaxValueLen,
                                 NULL,                  // lpcbSecurityDescriptor,
                                 LastWriteTime          // lpftLastWriteTime
                               );
        }

    return Error;
}

LONG
RTQueryValueKey(
    IN PREG_CONTEXT RegistryContext,
    IN HKEY KeyHandle,
    IN PWSTR ValueName,
    OUT PULONG ValueType,
    IN OUT PULONG ValueDataLength,
    OUT PVOID ValueData
    )
{
    LONG Error;

    if (RegistryContext->Target == REG_TARGET_WIN95_REGISTRY) {
        UCHAR AnsiValueName[ MAX_PATH ], *p;
        ULONG OriginalValueDataLength;

        if (ValueName != NULL) {
            if (!RegUnicodeToAnsi( ValueName, AnsiValueName, 0 )) {
                return GetLastError();
                }

            p = AnsiValueName;
            }
        else {
            p = NULL;
            }

        OriginalValueDataLength = *ValueDataLength;
        Error = (_Win95RegQueryValueEx)( KeyHandle,
                                         p,
                                         NULL,
                                         ValueType,
                                         ValueData,
                                         ValueDataLength
                                       );
        if (Error == NO_ERROR && *ValueType == REG_SZ) {
            if ((*ValueDataLength * sizeof( WCHAR )) > OriginalValueDataLength) {
                return ERROR_MORE_DATA;
                }

            p = HeapAlloc( GetProcessHeap(), 0, *ValueDataLength );
            if (p == NULL) {
                return ERROR_OUTOFMEMORY;
                }

            RtlMoveMemory( p, ValueData, *ValueDataLength );
            if (RegAnsiToUnicode( (LPCSTR)p, (PWSTR)ValueData, *ValueDataLength ) == 0) {
                Error = GetLastError();
                }
            else {
                *ValueDataLength *= sizeof( WCHAR );
                *ValueDataLength += sizeof( UNICODE_NULL );
                }

            HeapFree( GetProcessHeap(), 0, p );
            }
        }
    else {
        Error = RegQueryValueEx( KeyHandle,
                                 ValueName,
                                 NULL,
                                 ValueType,
                                 ValueData,
                                 ValueDataLength
                               );

        if (Error == NO_ERROR) {
            RtlZeroMemory( (PCHAR)ValueData + *ValueDataLength, 4 - (*ValueDataLength & 3) );
            }
        }

    return Error;
}

LONG
RTSetValueKey(
    IN PREG_CONTEXT RegistryContext,
    IN HKEY KeyHandle,
    IN PWSTR ValueName,
    IN ULONG ValueType,
    IN ULONG ValueDataLength,
    IN PVOID ValueData
    )
{
    LONG Error;

    if (RegistryContext->Target == REG_TARGET_WIN95_REGISTRY) {
        UCHAR AnsiValueName[ MAX_PATH ], *p;
        ULONG OriginalValueDataLength;
        LPSTR AnsiValueData;

        if (ValueName != NULL) {
            if (!RegUnicodeToAnsi( ValueName, AnsiValueName, 0 )) {
                return GetLastError();
                }

            p = AnsiValueName;
            }
        else {
            p = NULL;
            }

        if (ValueType == REG_SZ) {
            AnsiValueData = HeapAlloc( GetProcessHeap(), 0, ValueDataLength * 2 );
            if (AnsiValueData == NULL) {
                return ERROR_OUTOFMEMORY;
                }

            ValueDataLength = RegUnicodeToAnsi( ValueData, AnsiValueData, ValueDataLength );
            if (ValueDataLength == 0) {
                return GetLastError();
                }

            ValueData = AnsiValueData;
            }
        else {
            AnsiValueData = NULL;
            }

        Error = (_Win95RegSetValueEx)( KeyHandle,
                                       p,
                                       0,
                                       ValueType,
                                       ValueData,
                                       ValueDataLength
                                     );

        if (AnsiValueData != NULL) {
            HeapFree( GetProcessHeap(), 0, AnsiValueData );
            }

        if (p != NULL) {
            HeapFree( GetProcessHeap(), 0, p );
            }
        }
    else {
        Error = RegSetValueEx( KeyHandle,
                               ValueName,
                               0,
                               ValueType,
                               ValueData,
                               ValueDataLength
                             );
        }

    return Error;
}

LONG
RTDeleteKey(
    IN PREG_CONTEXT RegistryContext,
    IN HKEY KeyHandle,
    IN PCWSTR SubKeyName
    )
{
    if (!RegValidateKeyPath( RegistryContext, &KeyHandle, &SubKeyName )) {
        return GetLastError();
        }

    if (RegistryContext->Target == REG_TARGET_WIN95_REGISTRY) {
        UCHAR AnsiSubKeyName[ MAX_PATH ], *p;

        if (SubKeyName != NULL) {
            if (!RegUnicodeToAnsi( SubKeyName, AnsiSubKeyName, 0 )) {
                return GetLastError();
                }

            p = AnsiSubKeyName;
            }
        else {
            p = NULL;
            }

        return (_Win95RegDeleteKey)( KeyHandle, p );
        }
    else {
        return RegDeleteKey( KeyHandle, SubKeyName );
        }
}


LONG
RTDeleteValueKey(
    IN PREG_CONTEXT RegistryContext,
    IN HKEY KeyHandle,
    IN PWSTR ValueName
    )
{
    if (RegistryContext->Target == REG_TARGET_WIN95_REGISTRY) {
        UCHAR AnsiValueName[ MAX_PATH ], *p;
        ULONG OriginalValueDataLength;
        LPSTR AnsiValueData;

        if (ValueName != NULL) {
            if (!RegUnicodeToAnsi( ValueName, AnsiValueName, 0 )) {
                return GetLastError();
                }

            p = AnsiValueName;
            }
        else {
            p = NULL;
            }

        return (_Win95RegDeleteValue)( KeyHandle,
                                       p
                                     );
        }
    else {
        return RegDeleteValue( KeyHandle, ValueName );
        }
}


LONG
RTLoadAsciiFileAsUnicode(
    IN PWSTR FileName,
    OUT PREG_UNICODE_FILE UnicodeFile
    )
{
    LONG Error = NO_ERROR;
    HANDLE File;
    DWORD FileSize;
    DWORD CharsInFile;
    DWORD BytesRead;
    DWORD BufferSize, i, i1, LineCount, DeferredLineCount;
    PVOID BufferBase;
    PWSTR Src, Src1, Dst;

    File = CreateFile( FileName,
                       FILE_GENERIC_READ,
                       FILE_SHARE_DELETE |
                          FILE_SHARE_READ |
                          FILE_SHARE_WRITE,
                       NULL,
                       OPEN_EXISTING,
                       0,
                       NULL
                     );
    if (File == INVALID_HANDLE_VALUE) {
        return GetLastError();
        }

    FileSize = GetFileSize( File, NULL );
    if (FileSize == INVALID_FILE_SIZE) {
        CloseHandle( File );
        return GetLastError();
        }

    BufferSize = FileSize * sizeof( WCHAR );
    BufferSize += sizeof( UNICODE_NULL );
    BufferBase = NULL;
    BufferBase = VirtualAlloc( NULL, BufferSize, MEM_COMMIT, PAGE_READWRITE );
    if (BufferBase != NULL) {
        if (ReadFile( File, BufferBase, FileSize, &BytesRead, NULL )) {
            if (BytesRead != FileSize) {
                Error = ERROR_HANDLE_EOF;
            }
            else
            if (!GetFileTime( File, NULL, NULL, &UnicodeFile->LastWriteTime )) {
                Error = GetLastError();
            }
            else {
                Error = NO_ERROR;
            }
        }

        if (Error != NO_ERROR) {
            VirtualFree( BufferBase, 0, MEM_RELEASE );
        }
    } else {
        Error = GetLastError();
    }

    CloseHandle( File );
    if (Error != NO_ERROR) {
        return Error;
        }

    Src = (PWSTR)BufferBase;

    if (!IsTextUnicode( BufferBase, FileSize, NULL )) {
        RtlMoveMemory( (PCHAR)BufferBase + FileSize, BufferBase, FileSize );
        CharsInFile = RegAnsiToUnicode( (PCHAR)BufferBase + FileSize, BufferBase, FileSize );
        if (CharsInFile == 0) {
            return GetLastError();
            }
        }
    else {
        CharsInFile = FileSize / sizeof( WCHAR );

        //
        // Skip ByteOrderMark
        //
        if (Src[0] == 0xfeff || Src[0] == 0xfffe) {
            Src++;
            CharsInFile--;
            }
        }

    DeferredLineCount = 0;
    Dst = (PWSTR)BufferBase;

    i = 0;

    //
    // Now loop over the in memory copy of the file, collapsing all carriage 
    // return line feed pairs into just new lines, and removing all line 
    // continuation characters and the spaces that surround them.  This lets
    // RTParseNextLine see a single line for each Key Name or Value input, 
    // terminated by a new line character.
    //
    while (i < CharsInFile) {
        //
        // See if we just went over a line continuation character
        //
        if (i > 0 && Src[-1] == L'\\' && (*Src == L'\r' || *Src == L'\n')) {
            //
            // Move back over the line continuation we just copied the previous iteration
            //
            if (Dst[-1] == L'\\') {
                --Dst;
                }

            //
            // Move back over all but one of any space characters that preceed
            // the line continuation character.  The may be none, in which case
            // we leave it be, as the user must want no space
            //
            while (Dst > (PWSTR)BufferBase) {
                if (Dst[-1] > L' ') {
                    break;
                    }
                Dst -= 1;
                }

            //
            // Leave one space, if there is one
            //
            if (Dst[0] == L' ') {
                Dst += 1;
                }

            //
            // Now, skip over the new line after the line continuation.  We
            // actually will skip over any number of them, keeping count so
            // we can update the source file line number correctly.
            //
            LineCount = 0;
            while (i < CharsInFile) {
                if (*Src == L'\n') {
                    i++;
                    Src++;
                    LineCount++;
                    }
                else
                if (*Src == L'\r' &&
                    (i+1) < CharsInFile &&
                    Src[ 1 ] == L'\n'
                   ) {
                    i += 2;
                    Src += 2;
                    LineCount++;
                    }
                else {
                    break;
                    }
                }

            //
            // If we saw more than just new line after the line continuation
            // character, then put them back into the destination as just
            // new lines, without any carriage returns.
            //
            if (LineCount > 1) {
                DeferredLineCount += LineCount;
                while (DeferredLineCount) {
                    DeferredLineCount -= 1;
                    *Dst++ = L'\n';
                    }
                }
            else {
                DeferredLineCount += 1;

                //
                // Skip leading spaces of next line of continuation

                while (i < CharsInFile && (*Src == L' ' || *Src == L'\t')) {
                    i++;
                    Src++;
                    }
                }

            //
            // All done if we hit the end of the file
            //
            if (i >= CharsInFile) {
                break;
                }
            }
        else
        if ((*Src == '\r' && Src[1] == '\n') || *Src == '\n') {
            while (TRUE) {
                while (i < CharsInFile && (*Src == '\r' || *Src == '\n')) {
                    i++;
                    Src++;
                    }
                Src1 = Src;
                i1 = i;
                while (i1 < CharsInFile && (*Src1 == ' ' || *Src1 == '\t')) {
                    i1++;
                    Src1++;
                    }
                if (i1 < CharsInFile &&
                    (*Src1 == '\r' && Src1[1] == '\n') || *Src1 == '\n'
                   ) {
                    Src = Src1;
                    i = i1;
                    }
                else {
                    break;
                    }
                }

            while (DeferredLineCount) {
                DeferredLineCount -= 1;
                *Dst++ = L'\n';
                }
            *Dst++ = L'\n';
            }
        else {
            i++;
            *Dst++ = *Src++;
            }
        }

    //
    // Make sure line ends with a CRLF sequence.
    //
    while (DeferredLineCount) {
        DeferredLineCount -= 1;
        *Dst++ = L'\n';
        }
    *Dst++ = L'\n';
    *Dst = UNICODE_NULL;
    UnicodeFile->FileName = FileName;
    UnicodeFile->FileContents = BufferBase;
    UnicodeFile->EndOfFile = Dst;
    UnicodeFile->NextLine = BufferBase;
    UnicodeFile->NextLineNumber = 1;

    return NO_ERROR;
}

void
RTUnloadUnicodeFile(
    IN OUT PREG_UNICODE_FILE UnicodeFile
    )
{
    VirtualFree( UnicodeFile->FileContents, 0, MEM_RELEASE );
    return;
}

#define ACL_LIST_START L'['
#define ACL_LIST_END L']'

BOOLEAN
RegGetMultiString(
    IN BOOLEAN BackwardsCompatibleInput,
    IN OUT PWSTR *ValueString,
    IN OUT PWSTR *ValueData,
    IN ULONG MaximumValueLength,
    IN OUT PULONG ValueLength
    );


BOOLEAN
RegReadMultiSzFile(
    IN OUT PREG_UNICODE_PARSE ParsedLine,
    IN BOOLEAN BackwardsCompatibleInput,
    IN PWSTR FileName,
    IN OUT PVOID ValueData,
    IN OUT PULONG ValueLength
    );

BOOLEAN
RegReadBinaryFile(
    IN OUT PREG_UNICODE_PARSE ParsedLine,
    IN PWSTR FileName,
    IN OUT PVOID ValueData,
    IN OUT PULONG ValueLength
    );

BOOLEAN
RTParseNextLine(
    IN OUT PREG_UNICODE_FILE UnicodeFile,
    OUT PREG_UNICODE_PARSE ParsedLine
    )
{
    PWSTR BeginLine, EqualSign, AclBracket, AclStart, s, s1;
    WCHAR QuoteChar;

    if (ParsedLine->IsKeyName && ParsedLine->SecurityDescriptor) {
        RegDestroySecurity( ParsedLine->SecurityDescriptor );
        }

    RtlZeroMemory( ParsedLine, sizeof( *ParsedLine ) );
    while (TRUE) {
        if (!(s = UnicodeFile->NextLine)) {
            ParsedLine->AtEndOfFile = TRUE;
            return FALSE;
            }
        UnicodeFile->NextLine = NULL;
        if (*s == UNICODE_NULL) {
            ParsedLine->AtEndOfFile = TRUE;
            return FALSE;
            }

        while (*s <= L' ') {
            if (*s == L' ') {
                ParsedLine->IndentAmount += 1;
                }
            else
            if (*s == L'\t') {
                ParsedLine->IndentAmount = ((ParsedLine->IndentAmount + 8) -
                                 (ParsedLine->IndentAmount % 8)
                                );
                }

            if (++s >= UnicodeFile->EndOfFile) {
                ParsedLine->AtEndOfFile = TRUE;
                return FALSE;
                }
            }

        BeginLine = s;
        EqualSign = NULL;
        AclBracket = NULL;
        if (!UnicodeFile->BackwardsCompatibleInput && *s == L';') {
            while (s < UnicodeFile->EndOfFile) {
                if (*s == L'\n') {
                    do {
                        UnicodeFile->NextLineNumber += 1;
                        *s++ = UNICODE_NULL;
                        }
                    while (*s == L'\n');
                    break;
                    }
                else {
                    s += 1;
                    }
                }

            BeginLine = s;
            UnicodeFile->NextLine = s;
            }
        else
        if (*s != '\n') {

            //
            // If not being backward compatible, see if the first thing on
            // the line is the beginning of a quoted string.
            //

            if (!UnicodeFile->BackwardsCompatibleInput && (*s == L'"' || *s == L'\'')) {
                //
                // Yes, it is either a quoted key name or value name.  Find the
                // the trailing quote.  Specifically do NOT support quotes inside
                // a quoted string, other than a different kind.  Which means unless
                // you want both types of quoted characters within the same name
                // you wont care.
                //
                QuoteChar = *s++;
                BeginLine += 1;
                while (s < UnicodeFile->EndOfFile && *s != QuoteChar) {
                    s += 1;
                    }

                //
                // If trailing quote not found, then return an error
                //
                if (*s != QuoteChar) {
                    ParsedLine->ParseFailureReason = ParseFailInvalidQuoteCharacter;
                    return FALSE;
                    }

                //
                // Mark the end of the name and move past the trailing quote
                //
                *s++ = UNICODE_NULL;
            }

            //
            // Now scan forward looking for one of the following:
            //
            //      equal sign - this would mean the stuff to the left
            //          of the equal sign is a value name and the stuff
            //          to the right is the value type and data.
            //
            //      left square bracket - this would mean the stuff to the
            //          left of the square bracket is a key name and the
            //          stuff to the right is the security descriptor information
            //
            //      end of line - this would mean the stuff to the left
            //          is a key name, with no security descriptor.
            //

            while (s < UnicodeFile->EndOfFile) {
                if (*s == L'=') {
                    //
                    // We found an equal sign, so value name is to the left
                    // and value type and data follows.
                    //
                    EqualSign = s;

                    //
                    // Ignore any left square bracket we might have seen
                    // in before this.  It must have been part of the value
                    // name.
                    AclBracket = NULL;

                    //
                    // All done scanning
                    //
                    break;
                    }
                else
                if (*s == ACL_LIST_START) {
                    //
                    // We found a left square bracket.  Keep scanning
                    // in case there is an equal sign later.
                    //
                    AclBracket = s;
                    s += 1;
                    }
                else
                if (*s == L'\n') {
                    //
                    // We found end of line, so key name is to the left.
                    // Update where to start next time we are called.
                    //
                    UnicodeFile->NextLine = s + 1;
                    break;
                    }
                else
                if (*s == L'\t') {
                    //
                    // Convert imbedded hard tabs to single spaces
                    //
                    *s++ = L' ';
                    }
                else {
                    //
                    // Nothing interesting, keep looking.
                    //
                    s += 1;
                    }
                }

            //
            // Trim any trailing spaces off the end of what is to the
            // left of where we are.  The make sure we stop looking
            // if we see the null character put down over the trailing
            // quote character above, if any.
            //
            *s = UNICODE_NULL;
            while (s > BeginLine && *--s <= L' ' && *s) {
                *s = UNICODE_NULL;
                }

            //
            // BeginLine now points to either the null terminated value
            // name or key name.  EqualSign, if non-null, points to the
            // equal sign, so scan forward and find the terminating new line,
            // and store a null there to terminate the input.  Otherwise,
            // we already stored a null over the terminating new line above.
            //
            if (EqualSign != NULL) {
                s = EqualSign + 1;
                while (s < UnicodeFile->EndOfFile) {
                    if (*s == '\n') {
                        *s = UNICODE_NULL;
                        break;
                        }

                    s += 1;
                    }

                //
                // Update where we should start next time we are called.
                //
                UnicodeFile->NextLine = s + 1;
                }
            else
            if (AclBracket != NULL) {
                //
                // Since we did not stop on the AclBracket, go back an
                // clobber it and any spaces before it.
                //
                s = AclBracket;
                *s = UNICODE_NULL;
                while (s > BeginLine && *--s <= L' ' && *s) {
                    *s = UNICODE_NULL;
                    }
                }

            //
            // Tell them which line number and where the line begins
            //
            ParsedLine->LineNumber = UnicodeFile->NextLineNumber;
            UnicodeFile->NextLineNumber += 1;
            ParsedLine->BeginLine = BeginLine;

            //
            // Now handle value or key semantics
            //
            if (EqualSign != NULL) {
                //
                // We have ValueName = ValueType ValueData
                //

                //
                // Value name is the beginning of the line, unless
                // it was the special symbol or null
                //
                if (*BeginLine != L'@' && BeginLine != EqualSign) {
                    ParsedLine->ValueName = BeginLine;
                    }

                //
                // Skip any blanks after the equal sign.
                //
                while (*++EqualSign && *EqualSign <= L' ') {
                    }

                //
                // If all that is left is the DELETE keyword, then
                // tell the caller
                //
                if (!_wcsicmp( L"DELETE", EqualSign )) {
                    ParsedLine->DeleteValue = TRUE;
                    return TRUE;
                    }
                else {
                    //
                    // Otherwise parse the data after the equal sign.
                    //
                    ParsedLine->ValueString = EqualSign;
                    return RTParseValueData( UnicodeFile,
                                             ParsedLine,
                                             ValueBuffer,
                                             ValueBufferSize,
                                             &ParsedLine->ValueType,
                                             &ParsedLine->ValueData,
                                             &ParsedLine->ValueLength
                                           );
                    }
                }
            else {
                //
                // We have a key name.  Tell the caller and handle any
                // security descriptor info if present.
                //
                ParsedLine->IsKeyName = TRUE;
                ParsedLine->KeyName = BeginLine;
                if (AclBracket != NULL) {
                    //
                    // We have found an ACL name
                    //
                    AclStart = ++AclBracket;
                    ParsedLine->AclString = AclStart;
                    while (*AclBracket != UNICODE_NULL && *AclBracket != ACL_LIST_END) {
                        AclBracket += 1;
                        }
                    if (*AclBracket != ACL_LIST_END) {
                        return FALSE;
                        }

                    *AclBracket = UNICODE_NULL;
                    if (!_wcsicmp( L"DELETE", AclStart )) {
                        ParsedLine->DeleteKey = TRUE;
                        }
                    else {
                        ParsedLine->SecurityDescriptor = &ParsedLine->SecurityDescriptorBuffer;
                        if (!RegCreateSecurity( AclStart, ParsedLine->SecurityDescriptor )) {
                            ParsedLine->SecurityDescriptor = NULL;
                            return FALSE;
                            }
                        }
                    }

                return TRUE;
                }
            }
        else {
            UnicodeFile->NextLineNumber += 1;
            }
        }

    return FALSE;
}

BOOLEAN
RTParseValueData(
    IN OUT PREG_UNICODE_FILE UnicodeFile,
    IN OUT PREG_UNICODE_PARSE ParsedLine,
    IN PVOID ValueBuffer,
    IN ULONG ValueBufferSize,
    OUT PULONG ValueType,
    OUT PVOID *ValueData,
    OUT PULONG ValueLength
    )
{
    PWSTR ValueString;
    ULONG PrefixLength, MaximumValueLength;
    PULONG p;
    PWSTR s, Src, Dst;
    ULONG i, n, cchValue;
    BOOLEAN BackwardsCompatibleInput = FALSE;
    BOOLEAN GetDataFromBinaryFile = FALSE;
    BOOLEAN GetDataFromMultiSzFile = FALSE;
    BOOLEAN ParseDateTime = FALSE;

    if (UnicodeFile != NULL) {
        BackwardsCompatibleInput = UnicodeFile->BackwardsCompatibleInput;
        }
    ValueString = ParsedLine->ValueString;
    *ValueData = NULL;
    *ValueLength = 0;
    *ValueType = REG_SZ;
    for (i=0; RegTypeNameTable[i].TypeName != NULL; i++) {
        PrefixLength = wcslen( RegTypeNameTable[i].TypeName );
        if (ValueString[ PrefixLength ] <= L' ' &&
            !_wcsnicmp( RegTypeNameTable[i].TypeName,
                        ValueString,
                        PrefixLength
                      )
           ) {
            *ValueType = RegTypeNameTable[i].ValueType;
            GetDataFromBinaryFile = RegTypeNameTable[i].GetDataFromBinaryFile;
            GetDataFromMultiSzFile = RegTypeNameTable[i].GetDataFromMultiSzFile;
            ParseDateTime = RegTypeNameTable[i].ParseDateTime;
            break;
            }
        }

    if (RegTypeNameTable[i].TypeName != NULL) {
        ValueString += PrefixLength;
        while (*ValueString != UNICODE_NULL && *ValueString <= L' ') {
            ValueString += 1;
            }
        }

    if (GetDataFromMultiSzFile) {
        *ValueData = ValueBuffer;
        *ValueLength = ValueBufferSize;
        return RegReadMultiSzFile( ParsedLine,
                                   BackwardsCompatibleInput,
                                   ValueString,
                                   ValueBuffer,
                                   ValueLength
                                 );
        }

    if (GetDataFromBinaryFile) {
        *ValueData = ValueBuffer;
        *ValueLength = ValueBufferSize;
        return RegReadBinaryFile( ParsedLine,
                                  ValueString,
                                  ValueBuffer,
                                  ValueLength
                                );
        }

    cchValue = wcslen( ValueString );
    Src = ValueString;
    switch( *ValueType ) {
    case REG_SZ:
    case REG_EXPAND_SZ:
        //
        // Strip off any surrounding quote characters
        //
        if (cchValue > 1 && Src[ 0 ] == Src[ cchValue - 1 ] &&
            (Src[ 0 ] == L'"' || Src[ 0 ] == L'\'')
           ) {
            Src += 1;
            cchValue -= 2;
            }

        //
        // Fall through after stripping any quotes.
        //

    case REG_LINK:
        *ValueLength = (cchValue + 1) * sizeof( WCHAR );
        if (*ValueLength > ValueBufferSize) {
            SetLastError( ERROR_BUFFER_OVERFLOW );
            ParsedLine->ParseFailureReason = ParseFailValueTooLarge;
            return FALSE;
            }
        *ValueData = ValueBuffer;
        RtlMoveMemory( *ValueData, Src, *ValueLength );
        *((PWSTR)*ValueData + cchValue) = UNICODE_NULL;
        return TRUE;

    case REG_DWORD:
        *ValueData = ValueBuffer;
        *ValueLength = sizeof( ULONG );
        for (i=0; RegValueNameTable[i].ValueName != NULL; i++) {
            PrefixLength = wcslen( RegValueNameTable[i].ValueName );
            if (!_wcsnicmp( RegValueNameTable[i].ValueName,
                            ValueString,
                            PrefixLength
                          )
               ) {
                *(PULONG)*ValueData = RegValueNameTable[i].Value;
                return TRUE;
                }
            }
        return RegUnicodeToDWORD( &Src, 0, (PULONG)*ValueData );

    case REG_BINARY:
        if (ParseDateTime) {
#define NUMBER_DATE_TIME_FIELDS 6
            ULONG FieldIndexes[ NUMBER_DATE_TIME_FIELDS  ] = {1, 2, 0, 3, 4, 7};
            //
            // Month/Day/Year HH:MM DayOfWeek
            //

            ULONG CurrentField = 0;
            PCSHORT Fields;
            TIME_FIELDS DateTimeFields;
            PWSTR Field;
            ULONG FieldValue;

            RtlZeroMemory( &DateTimeFields, sizeof( DateTimeFields ) );
            Fields = &DateTimeFields.Year;
            while (cchValue) {
                if (CurrentField >= 7) {
                    return( FALSE );
                    }

                while (cchValue && *Src == L' ') {
                    cchValue--;
                    Src += 1;
                    }

                Field = Src;
                while (cchValue) {
                    if (CurrentField == (NUMBER_DATE_TIME_FIELDS-1)) {
                        }
                    else
                    if (*Src < L'0' || *Src > L'9') {
                        break;
                        }

                    cchValue--;
                    Src += 1;
                    }

                if (cchValue) {
                    cchValue--;
                    Src += 1;
                    }

                if (CurrentField == (NUMBER_DATE_TIME_FIELDS-1)) {
                    if (cchValue < 3) {
                        SetLastError( ERROR_INVALID_PARAMETER );
                        ParsedLine->ParseFailureReason = ParseFailDateTimeFormatInvalid;
                        return FALSE;
                        }

                    if (DateTimeFields.Year != 0) {
                        SetLastError( ERROR_INVALID_PARAMETER );
                        ParsedLine->ParseFailureReason = ParseFailDateTimeFormatInvalid;
                        return FALSE;
                        }

                    if (!_wcsnicmp( Field, L"SUN", 3 )) {
                        FieldValue = 0;
                        }
                    else
                    if (!_wcsnicmp( Field, L"MON", 3 )) {
                        FieldValue = 1;
                        }
                    else
                    if (!_wcsnicmp( Field, L"TUE", 3 )) {
                        FieldValue = 2;
                        }
                    else
                    if (!_wcsnicmp( Field, L"WED", 3 )) {
                        FieldValue = 3;
                        }
                    else
                    if (!_wcsnicmp( Field, L"THU", 3 )) {
                        FieldValue = 4;
                        }
                    else
                    if (!_wcsnicmp( Field, L"FRI", 3 )) {
                        FieldValue = 5;
                        }
                    else
                    if (!_wcsnicmp( Field, L"SAT", 3 )) {
                        FieldValue = 6;
                        }
                    else {
                        SetLastError( ERROR_INVALID_PARAMETER );
                        return FALSE;
                        }
                    }
                else
                if (!RegUnicodeToDWORD( &Field, 0, &FieldValue )) {
                    ParsedLine->ParseFailureReason = ParseFailDateTimeFormatInvalid;
                    return FALSE;
                    }

                Fields[ FieldIndexes[ CurrentField++ ] ] = (CSHORT)FieldValue;
                }

            if (DateTimeFields.Year == 0) {
                if (DateTimeFields.Day > 5) {
                    SetLastError( ERROR_INVALID_PARAMETER );
                    ParsedLine->ParseFailureReason = ParseFailDateTimeFormatInvalid;
                    return FALSE;
                    }
                }
            else
            if (DateTimeFields.Year < 100) {
                DateTimeFields.Year += 1900;
                }

            *ValueLength = sizeof( DateTimeFields );
            if (*ValueLength > ValueBufferSize) {
                SetLastError( ERROR_BUFFER_OVERFLOW );
                ParsedLine->ParseFailureReason = ParseFailValueTooLarge;
                return FALSE;
                }
            *ValueData = ValueBuffer;
            RtlMoveMemory( *ValueData, &DateTimeFields, sizeof( DateTimeFields ) );
            return TRUE;
            }

    case REG_RESOURCE_LIST:
    case REG_RESOURCE_REQUIREMENTS_LIST:
    case REG_FULL_RESOURCE_DESCRIPTOR:
    case REG_NONE:
        if (!RegUnicodeToDWORD( &Src, 0, ValueLength )) {
            ParsedLine->ParseFailureReason = ParseFailBinaryDataLengthMissing;
            return FALSE;
            }

        if (*ValueLength >= ValueBufferSize) {
            SetLastError( ERROR_BUFFER_OVERFLOW );
            ParsedLine->ParseFailureReason = ParseFailValueTooLarge;
            return FALSE;
            }

        //
        // Calculate number of DWORD's of data based on specified byte count
        //
        n = (*ValueLength + sizeof( ULONG ) - 1) / sizeof( ULONG );

        //
        // Store converted binary data in ValueBuffer
        //
        *ValueData = ValueBuffer;
        p = ValueBuffer;

        //
        // Src points to remaining text to convert.
        //
        while (n--) {
            if (!RegUnicodeToDWORD( &Src, 0, p )) {
                if (BackwardsCompatibleInput) {
                    Src = UnicodeFile->NextLine;
                    s = Src;
                    while (TRUE) {
                        if (*s == '\n') {
                            *s = UNICODE_NULL;
                            UnicodeFile->NextLineNumber += 1;
                            break;
                            }
                        else
                        if (s >= UnicodeFile->EndOfFile || *s == UNICODE_NULL) {
                            UnicodeFile->NextLine = NULL;
                            ParsedLine->ParseFailureReason = ParseFailBinaryDataNotEnough;
                            SetLastError( ERROR_MORE_DATA );
                            return FALSE;
                            }
                        else {
                            break;
                            }
                        }

                    UnicodeFile->NextLine = s + 1;
                    n += 1;
                    }
                else {
                    if (p == ValueBuffer) {
                        ParsedLine->ParseFailureReason = ParseFailBinaryDataOmitted;
                        SetLastError( ERROR_NO_DATA );
                        }
                    else {
                        ParsedLine->ParseFailureReason = ParseFailBinaryDataNotEnough;
                        SetLastError( ERROR_MORE_DATA );
                        }

                    return FALSE;
                    }
                }
            else {
                p += 1;
                }
            }
        return TRUE;

    case REG_MULTI_SZ:
        *ValueLength = 0;
        *ValueData = ValueBuffer;
        MaximumValueLength = ValueBufferSize;
        Dst = *ValueData;
        while (RegGetMultiString( BackwardsCompatibleInput,
                                  &Src,
                                  &Dst,
                                  MaximumValueLength,
                                  ValueLength
                                )
              ) {
            }

        if (GetLastError() == NO_ERROR) {
            return TRUE;
            }
        else {
            ParsedLine->ParseFailureReason = ParseFailValueTooLarge;
            return FALSE;
            }
        break;

    default:
        SetLastError( ERROR_INVALID_PARAMETER );
        ParsedLine->ParseFailureReason = ParseFailInvalidRegistryType;
        return FALSE;
    }

}

BOOLEAN
RegGetMultiString(
    IN BOOLEAN BackwardsCompatibleInput,
    IN OUT PWSTR *ValueString,
    IN OUT PWSTR *ValueData,
    IN ULONG MaximumValueLength,
    IN OUT PULONG ValueLength
    )

/*++

Routine Description:

    This routine parses multi-strings of the form

        "foo" "bar" "bletch"

    Each time it is called, it strips the first string in quotes from
    the input string, and returns it as the multi-string.

    INPUT ValueString: "foo" "bar" "bletch"

    OUTPUT ValueString: "bar" "bletch"
           ValueData: foo

Arguments:

    BackwardsCompatibleInput - TRUE if supporting old format input

    ValueString - Supplies the string from which the multi-string will be
                  parsed
                - Returns the remaining string after the multi-string is
                  removed

    ValueData - Supplies the location where the removed multi-string is
                to be stored.
              - Returns the location to the first byte after the returned
                multi-string

    MaximumValueLength - Supplies the maximum length of data that can be
                         stored in ValueData.

    ValueLength - Supplies a pointer to the current length of data stored
                  in ValueData.
                - Returns the size of the


Return Value:

    TRUE if successful and FALSE if not.

--*/

{
    PWSTR Src, Dst;
    ULONG n;
    BOOLEAN Result;

    //
    // Find the first quote mark.
    //
    Src = *ValueString;
    while (*Src != UNICODE_NULL && *Src != L'"') {
        Src += 1;
        }

    Dst = *ValueData;
    if (*Src == UNICODE_NULL) {
        SetLastError( NO_ERROR );
        Result = FALSE;
        }
    else {
        //
        // We have found the start of the multi-string.  Now find the end,
        // building up our return ValueData as we go.
        //

        Src += 1;
        while (*Src != UNICODE_NULL) {
            if (*Src == L'"') {
                if (!BackwardsCompatibleInput &&
                    Src[1] == L'"'
                   ) {
                    Src += 1;
                    }
                else {
                    *Src++ = UNICODE_NULL;
                    break;
                    }
                }

            *ValueLength += sizeof( WCHAR );
            if (*ValueLength >= MaximumValueLength) {
                SetLastError( ERROR_BUFFER_OVERFLOW );
                return FALSE;
                }

            *Dst++ = *Src++;
            }

        Result = TRUE;
        }

    *ValueLength += sizeof( WCHAR );
    if (*ValueLength >= MaximumValueLength) {
        SetLastError( ERROR_BUFFER_OVERFLOW );
        return FALSE;
        }

    *Dst++ = UNICODE_NULL;
    *ValueData = Dst;
    *ValueString = Src;
    return Result;
}


BOOLEAN
RegReadMultiSzFile(
    IN OUT PREG_UNICODE_PARSE ParsedLine,
    IN BOOLEAN BackwardsCompatibleInput,
    IN PWSTR FileName,
    IN OUT PVOID ValueData,
    IN OUT PULONG ValueLength
    )
{
    PWSTR Src, Dst;
    REG_UNICODE_FILE MultiSzFile;
    ULONG MaximumValueLength;
    BOOLEAN Result;

    if (!RTLoadAsciiFileAsUnicode( FileName, &MultiSzFile )) {
        ParsedLine->ParseFailureReason = ParseFailUnableToAccessFile;
        return FALSE;
        }

    MaximumValueLength = *ValueLength;
    *ValueLength = 0;
    Src = MultiSzFile.NextLine;
    Dst = ValueData;
    while (RegGetMultiString( BackwardsCompatibleInput,
                              &Src,
                              &Dst,
                              MaximumValueLength,
                              ValueLength
                            )
          ) {
        }

    if (GetLastError() == NO_ERROR) {
        Result = TRUE;
        }
    else {
        ParsedLine->ParseFailureReason = ParseFailValueTooLarge;
        Result = FALSE;
        }

    RTUnloadUnicodeFile( &MultiSzFile );

    return Result;
}

BOOLEAN
RegReadBinaryFile(
    IN OUT PREG_UNICODE_PARSE ParsedLine,
    IN PWSTR FileName,
    IN OUT PVOID ValueData,
    IN OUT PULONG ValueLength
    )
{
    BOOLEAN Result;
    HANDLE File;
    DWORD FileSize, FileSizeHigh;
    DWORD BytesRead;

    File = CreateFile( FileName,
                       FILE_GENERIC_READ,
                       FILE_SHARE_DELETE |
                          FILE_SHARE_READ |
                          FILE_SHARE_WRITE,
                       NULL,
                       OPEN_EXISTING,
                       0,
                       NULL
                     );
    if (File == INVALID_HANDLE_VALUE) {
        ParsedLine->ParseFailureReason = ParseFailUnableToAccessFile;
        return FALSE;
        }

    ParsedLine->ParseFailureReason = ParseFailValueTooLarge;
    FileSize = GetFileSize( File, &FileSizeHigh );
    if (FileSizeHigh != 0 ||
        FileSize == INVALID_FILE_SIZE ||
        FileSize >= *ValueLength
       ) {
        CloseHandle( File );
        SetLastError( ERROR_BUFFER_OVERFLOW );
        return FALSE;
        }

    Result = FALSE;
    if (ReadFile( File, ValueData, FileSize, &BytesRead, NULL )) {
        if (BytesRead != FileSize) {
            SetLastError( ERROR_HANDLE_EOF );
            }
        else {
            ParsedLine->ParseFailureReason = ParseFailNoFailure;
            *ValueLength = FileSize;
            Result = TRUE;
            }
        }

    CloseHandle( File );
    return Result;
}


BOOLEAN
NeedQuotedString(
    PWSTR Name,
    PWSTR Value,
    PWCHAR QuoteChar
    )
{
    ULONG i;

    if (Name != NULL) {
        if (*Name != UNICODE_NULL &&
            (*Name == L' ' || Name[ wcslen( Name ) - 1 ] == L' ')
           ) {
            *QuoteChar = '"';
            return TRUE;
            }
        else {
            return FALSE;
            }
        }
    else {
        i = wcslen( Value ) - 1;
        if (*Value != UNICODE_NULL) {
            if ((*Value == L' ' || Value[ i ] == L' ' || Value[ i ] == L'\\')) {
                *QuoteChar = '"';
                return TRUE;
                }
            else
            if (*Value == L'"' && Value[ i ] == L'"') {
                *QuoteChar = '\'';
                return TRUE;
                }
            else
            if (*Value == L'\'' && Value[ i ] == L'\'') {
                *QuoteChar = '"';
                return TRUE;
                }
            }

        return FALSE;
        }
}

void
RTFormatKeyName(
    PREG_OUTPUT_ROUTINE OutputRoutine,
    PVOID OutputRoutineParameter,
    ULONG IndentLevel,
    PWSTR KeyName
    )
{
    PWSTR pw;
    WCHAR QuoteChar;

    if (NeedQuotedString( KeyName, NULL, &QuoteChar )) {
        (OutputRoutine)( OutputRoutineParameter,
                         "%.*s%c%ws%c",
                         IndentLevel,
                         BlanksForPadding,
                         QuoteChar,
                         KeyName,
                         QuoteChar
                       );
        }
    else {
        (OutputRoutine)( OutputRoutineParameter,
                         "%.*s%ws",
                         IndentLevel,
                         BlanksForPadding,
                         KeyName
                       );
        }

    return;
}

void
RTFormatKeySecurity(
    PREG_OUTPUT_ROUTINE OutputRoutine,
    PVOID OutputRoutineParameter,
    HKEY KeyHandle,
    PSECURITY_DESCRIPTOR SecurityDescriptor
    )
{
    ULONG SecurityBufferLength;
    BOOLEAN FormattedAces;
    WCHAR AceList[ 256 ];

    FormattedAces = FALSE;
    if (KeyHandle != NULL) 
    {
        SecurityBufferLength = 0;
        if (RegGetKeySecurity( KeyHandle,
                               DACL_SECURITY_INFORMATION,
                               SecurityDescriptor,
                               &SecurityBufferLength
                             ) == ERROR_INSUFFICIENT_BUFFER ) 
        {
            SecurityDescriptor = (PSECURITY_DESCRIPTOR)HeapAlloc( GetProcessHeap(),
                                                                  0,
                                                                  SecurityBufferLength
                                                                );

            if (SecurityDescriptor) 
            {
                if (RegGetKeySecurity( KeyHandle,
                                   DACL_SECURITY_INFORMATION,
                                   SecurityDescriptor,
                                   &SecurityBufferLength
                                 ) != NO_ERROR ) {
                    HeapFree( GetProcessHeap(), 0, SecurityDescriptor );
                } else {
                    FormattedAces = RegFormatSecurity( SecurityDescriptor, AceList );
                    HeapFree( GetProcessHeap(), 0, SecurityDescriptor );
                }
            }
        }
    }
    else
    if (SecurityDescriptor != NULL) {
        FormattedAces = RegFormatSecurity( SecurityDescriptor, AceList );
    }

    if (FormattedAces) {
        (OutputRoutine)( OutputRoutineParameter,
                         " %wc%ws%wc",
                         ACL_LIST_START,
                         AceList,
                         ACL_LIST_END
                       );
    }

    return;
}

void
RegDisplayResourceListAsComment(
    ULONG OutputWidth,
    PREG_OUTPUT_ROUTINE OutputRoutine,
    PVOID OutputRoutineParameter,
    ULONG IndentLevel,
    ULONG ValueLength,
    ULONG ValueType,
    PWSTR ValueData
    );

void
RTFormatKeyValue(
    ULONG OutputWidth,
    PREG_OUTPUT_ROUTINE OutputRoutine,
    PVOID OutputRoutineParameter,
    BOOLEAN SummaryOutput,
    ULONG IndentLevel,
    PWSTR ValueName,
    ULONG ValueLength,
    ULONG ValueType,
    PWSTR ValueData
    )
{
    PULONG p;
    PWSTR pw, pw1, pwBreak;
    WCHAR QuoteChar, BreakChar;
    ULONG i, j, k, m, cbPrefix, cb;
    PUCHAR pbyte;
    char eol[11];

    cbPrefix = (OutputRoutine)( OutputRoutineParameter,
                                "%.*s",
                                IndentLevel,
                                BlanksForPadding
                              );

    if (ValueName != NULL && *ValueName != UNICODE_NULL) {
        if (NeedQuotedString( ValueName, NULL, &QuoteChar )) {
            cbPrefix += (OutputRoutine)( OutputRoutineParameter,
                                         "%c%ws%c ",
                                         QuoteChar,
                                         ValueName,
                                         QuoteChar
                                       );
            }
        else {
            cbPrefix += (OutputRoutine)( OutputRoutineParameter, "%ws ", ValueName );
            }
        }
    cbPrefix += (OutputRoutine)( OutputRoutineParameter, "= " );

    switch( ValueType ) {
    case REG_SZ:
    case REG_EXPAND_SZ:

        if (ValueType == REG_EXPAND_SZ) {
            cbPrefix += (OutputRoutine)( OutputRoutineParameter, "REG_EXPAND_SZ " );
        }
        pw = (PWSTR)ValueData;
        if (ValueLength & (sizeof(WCHAR)-1)) {
            (OutputRoutine)( OutputRoutineParameter, "(*** Length not multiple of WCHAR ***)" );
            ValueLength = (ValueLength+sizeof(WCHAR)-1) & ~(sizeof(WCHAR)-1);
            }

        if (ValueLength == 0 ||
            *(PWSTR)((PCHAR)pw + ValueLength - sizeof( WCHAR )) != UNICODE_NULL
           ) {
            (OutputRoutine)( OutputRoutineParameter, "(*** MISSING TRAILING NULL CHARACTER ***)" );
            *(PWSTR)((PCHAR)pw + ValueLength) = UNICODE_NULL;
            }

        if (NeedQuotedString( NULL, pw, &QuoteChar )) {
            (OutputRoutine)( OutputRoutineParameter, "%c%ws%c", QuoteChar, pw, QuoteChar );
            }
        else
        if ((cbPrefix + wcslen(pw)) <= OutputWidth) {
            (OutputRoutine)( OutputRoutineParameter, "%ws", pw );
            }
        else {
            while (*pw) {
                pw1 = pw;
                pwBreak = NULL;
                while (*pw1 && *pw1 >= L' ') {
                    if ((cbPrefix + (ULONG)(pw1 - pw)) > (OutputWidth-4)) {
                        break;
                        }

                    if (wcschr( L" ,;", *pw1 )) {
                        pwBreak = pw1;
                        }

                    pw1++;
                    }

                if (pwBreak != NULL) {
                    while (*pwBreak == pwBreak[1]) {
                        pwBreak += 1;
                        }
                    pw1 = pwBreak + 1;
                    }
                else {
                    while (*pw1) {
                        pw1 += 1;
                        }
                    }

                (OutputRoutine)( OutputRoutineParameter, "%.*ws", pw1 - pw, pw );
                if (*pw1 == UNICODE_NULL) {
                    break;
                    }
                if (SummaryOutput) {
                    (OutputRoutine)( OutputRoutineParameter, "\\..." );
                    break;
                    }

                (OutputRoutine)( OutputRoutineParameter,
                                 "\\\n%.*s",
                                 IndentLevel == 0 ? 4 : cbPrefix,
                                 BlanksForPadding
                               );
                pw = pw1;
                }
            }

        (OutputRoutine)( OutputRoutineParameter, "\n" );
        break;

    case REG_RESOURCE_LIST:
    case REG_FULL_RESOURCE_DESCRIPTOR:
    case REG_RESOURCE_REQUIREMENTS_LIST:
    case REG_BINARY:
    case REG_NONE:
        switch( ValueType ) {
            case REG_NONE:
                pw = L"REG_NONE";
                break;
            case REG_BINARY:
                pw = L"REG_BINARY";
                break;
            case REG_RESOURCE_REQUIREMENTS_LIST:
                pw = L"REG_RESOURCE_REQUIREMENTS_LIST";
                break;
            case REG_RESOURCE_LIST:
                pw = L"REG_RESOURCE_LIST";
                break;
            case REG_FULL_RESOURCE_DESCRIPTOR:
                pw = L"REG_FULL_RESOURCE_DESCRIPTOR";
                break;
        }
        cb = (OutputRoutine)( OutputRoutineParameter, "%ws 0x%08lx", pw, ValueLength );

        if (ValueLength != 0) {
            p = (PULONG)ValueData;
            i = (ValueLength + 3) / sizeof( ULONG );
            if (!SummaryOutput || i <= 2) {
                for (j=0; j<i; j++) {
                    if ((cbPrefix + cb + 11) > (OutputWidth - 2)) {
                        (OutputRoutine)( OutputRoutineParameter,
                                         " \\\n%.*s",
                                         IndentLevel == 0 ? 4 : cbPrefix,
                                         BlanksForPadding
                                       );
                        cb = 0;
                        }
                    else {
                        cb += (OutputRoutine)( OutputRoutineParameter, " " );
                        }

                    cb += (OutputRoutine)( OutputRoutineParameter, "0x%08lx", *p++ );
                    }
                }
            else {
                (OutputRoutine)( OutputRoutineParameter, " \\..." );
                }
            }

        (OutputRoutine)( OutputRoutineParameter, "\n" );

        if (!SummaryOutput) {
            RegDisplayResourceListAsComment( OutputWidth,
                                             OutputRoutine,
                                             OutputRoutineParameter,
                                             IndentLevel,
                                             ValueLength,
                                             ValueType,
                                             ValueData
                                           );
            }

        break;

//  case REG_DWORD_LITTLE_ENDIAN:
    case REG_DWORD:
        (OutputRoutine)( OutputRoutineParameter, "REG_DWORD 0x%08lx\n",
                         *(PULONG)ValueData
                       );
        break;

    case REG_DWORD_BIG_ENDIAN:
        (OutputRoutine)( OutputRoutineParameter, "REG_DWORD_BIG_ENDIAN 0x%08lx\n",
                         *(PULONG)ValueData
                       );
        break;

    case REG_LINK:
        (OutputRoutine)( OutputRoutineParameter, "REG_LINK %ws\n",
                         (PWSTR)ValueData
                       );
        break;

    case REG_MULTI_SZ:
        (!FullPathOutput) ? strcpy (eol, " \\\n%.*s") : strcpy (eol, " \\ ->%.*s");
        cbPrefix += (OutputRoutine)( OutputRoutineParameter, "REG_MULTI_SZ " );
        pw = (PWSTR)ValueData;
        i  = 0;
        if (*pw)
        while (i < (ValueLength - 1) / sizeof( WCHAR )) {
            if (i > 0) {
                (OutputRoutine)( OutputRoutineParameter,
                                 eol,
                                 IndentLevel == 0 ? 4 : cbPrefix,
                                 BlanksForPadding
                               );
                }
            (OutputRoutine)( OutputRoutineParameter, "\"");
            do {
                if (pw[i] == '"') {
                    (OutputRoutine)( OutputRoutineParameter, "%wc",pw[i]);
                    }
                (OutputRoutine)( OutputRoutineParameter, "%wc",pw[i]);
                ++i;
                }
            while ( pw[i] != UNICODE_NULL );
            (OutputRoutine)( OutputRoutineParameter, "\" ");

            if (SummaryOutput) {
                (OutputRoutine)( OutputRoutineParameter, " \\..." );
                break;
                }

            ++i;
            }

        (OutputRoutine)( OutputRoutineParameter, "\n" );
        break;

    default:
        (OutputRoutine)( OutputRoutineParameter, "*** Unknown Registry Data Type (%08lx)  Length: 0x%lx\n",
                         ValueType,
                         ValueLength
                       );
        break;
    }

    return;
}


void
RegDisplayResourceListAsComment(
    ULONG OutputWidth,
    PREG_OUTPUT_ROUTINE OutputRoutine,
    PVOID OutputRoutineParameter,
    ULONG IndentLevel,
    ULONG ValueLength,
    ULONG ValueType,
    PWSTR ValueData
    )
{
    PCM_RESOURCE_LIST ResourceList = (PCM_RESOURCE_LIST)ValueData;
    PCM_FULL_RESOURCE_DESCRIPTOR FullDescriptor;
    PCM_PARTIAL_RESOURCE_DESCRIPTOR PartialResourceDescriptor;
    ULONG i, j, k, l, count, cb;
    PWSTR TypeName;
    PWSTR FlagName;
    ULONG Size = ValueLength;
    PULONG p;

    if (ValueType == REG_RESOURCE_LIST) {
        if (ValueLength < sizeof( *ResourceList )) {
            return;
            }

        count = ResourceList->Count;
        FullDescriptor = &ResourceList->List[0];
        (OutputRoutine)( OutputRoutineParameter,
                         ";%.*sNumber of Full resource Descriptors = %d",
                         IndentLevel - 1,
                         BlanksForPadding,
                         count
                       );
        }
    else
    if (ValueType == REG_FULL_RESOURCE_DESCRIPTOR) {
        if (ValueLength < sizeof( *FullDescriptor )) {
            return;
            }

        count = 1;
        FullDescriptor = (PCM_FULL_RESOURCE_DESCRIPTOR)ValueData;
        }
    else {
        return;
        }

    for (i=0; i< count; i++) {
        (OutputRoutine)( OutputRoutineParameter, "\n;%.*sPartial List number %d\n",
                         IndentLevel+4-1,
                         BlanksForPadding,
                         i
                       );

        switch(FullDescriptor->InterfaceType) {
            case InterfaceTypeUndefined:    TypeName = L"Undefined";break;
            case Internal:      TypeName = L"Internal";             break;
            case Isa:           TypeName = L"Isa";                  break;
            case Eisa:          TypeName = L"Eisa";                 break;
            case MicroChannel:  TypeName = L"MicroChannel";         break;
            case TurboChannel:  TypeName = L"TurboChannel";         break;
            case PCIBus:        TypeName = L"PCI";                  break;
            case VMEBus:        TypeName = L"VME";                  break;
            case NuBus:         TypeName = L"NuBus";                break;
            case PCMCIABus:     TypeName = L"PCMCIA";               break;
            case CBus:          TypeName = L"CBUS";                 break;
            case MPIBus:        TypeName = L"MPI";                  break;
            case MPSABus:       TypeName = L"MPSA";                 break;
            case ProcessorInternal: TypeName = L"ProcessorInternal";break;
            case InternalPowerBus:  TypeName = L"InternalPower";    break;
            case PNPISABus:         TypeName = L"PNP Isa";          break;

            default:
                TypeName = L"***invalid bus type***";
                break;
            }

        (OutputRoutine)( OutputRoutineParameter, ";%.*sINTERFACE_TYPE %ws\n",
                         IndentLevel+8-1,
                         BlanksForPadding,
                         TypeName
                       );

        (OutputRoutine)( OutputRoutineParameter, ";%.*sBUS_NUMBER  %d\n",
                         IndentLevel+8-1,
                         BlanksForPadding,
                         FullDescriptor->BusNumber
                       );

        //
        // This is a basic test to see if the data format is right.
        // We know at least some video resource list are bogus ...
        //

        if (Size < FullDescriptor->PartialResourceList.Count *
                     sizeof(CM_PARTIAL_RESOURCE_DESCRIPTOR) ) {

            (OutputRoutine)( OutputRoutineParameter, "\n;%.*s *** !!! Invalid ResourceList !!! *** \n",
                             IndentLevel+8-1,
                             BlanksForPadding,
                             i
                           );

            break;
            }

        Size -= FullDescriptor->PartialResourceList.Count *
                     sizeof(CM_PARTIAL_RESOURCE_DESCRIPTOR);



        for (j=0; j<FullDescriptor->PartialResourceList.Count; j++) {

            (OutputRoutine)( OutputRoutineParameter, ";%.*sDescriptor number %d\n",
                             IndentLevel+12-1,
                             BlanksForPadding,
                             j
                           );

            PartialResourceDescriptor = &(FullDescriptor->PartialResourceList.PartialDescriptors[j]);
            switch(PartialResourceDescriptor->ShareDisposition) {
                case CmResourceShareUndetermined:
                    TypeName = L"CmResourceShareUndetermined";
                    break;
                case CmResourceShareDeviceExclusive:
                    TypeName = L"CmResourceDeviceExclusive";
                    break;
                case CmResourceShareDriverExclusive:
                    TypeName = L"CmResourceDriverExclusive";
                    break;
                case CmResourceShareShared:
                    TypeName = L"CmResourceShared";
                    break;
                default:
                    TypeName = L"***invalid share disposition***";
                    break;
                }

            (OutputRoutine)( OutputRoutineParameter, ";%.*sShare Disposition %ws\n",
                             IndentLevel+12-1,
                             BlanksForPadding,
                             TypeName
                           );

            FlagName = L"***invalid Flags";

            switch(PartialResourceDescriptor->Type) {
                case CmResourceTypeNull:
                    TypeName = L"NULL";
                    FlagName = L"***Unused";
                    break;
                case CmResourceTypePort:
                    TypeName = L"PORT";
                    if (PartialResourceDescriptor->Flags == CM_RESOURCE_PORT_MEMORY) {
                        FlagName = L"CM_RESOURCE_PORT_MEMORY";
                    }
                    if (PartialResourceDescriptor->Flags == CM_RESOURCE_PORT_IO) {
                        FlagName = L"CM_RESOURCE_PORT_IO";
                    }
                    break;
                case CmResourceTypeInterrupt:
                    TypeName = L"INTERRUPT";
                    if (PartialResourceDescriptor->Flags == CM_RESOURCE_INTERRUPT_LEVEL_SENSITIVE) {
                        FlagName = L"CM_RESOURCE_INTERRUPT_LEVEL_SENSITIVE";
                    }
                    if (PartialResourceDescriptor->Flags == CM_RESOURCE_INTERRUPT_LATCHED) {
                        FlagName = L"CM_RESOURCE_INTERRUPT_LATCHED";
                    }
                    break;
                case CmResourceTypeMemory:
                    TypeName = L"MEMORY";
                    if (PartialResourceDescriptor->Flags == CM_RESOURCE_MEMORY_READ_WRITE) {
                        FlagName = L"CM_RESOURCE_MEMORY_READ_WRITE";
                    }
                    if (PartialResourceDescriptor->Flags == CM_RESOURCE_MEMORY_READ_ONLY) {
                        FlagName = L"CM_RESOURCE_MEMORY_READ_ONLY";
                    }
                    if (PartialResourceDescriptor->Flags == CM_RESOURCE_MEMORY_WRITE_ONLY) {
                        FlagName = L"CM_RESOURCE_MEMORY_WRITE_ONLY";
                    }
                    break;
                case CmResourceTypeDma:
                    TypeName = L"DMA";
                    FlagName = L"***Unused";
                    break;
                case CmResourceTypeDeviceSpecific:
                    TypeName = L"DEVICE SPECIFIC";
                    FlagName = L"***Unused";
                    break;
                default:
                    TypeName = L"***invalid type***";
                    break;
                }

            (OutputRoutine)( OutputRoutineParameter, ";%.*sTYPE              %ws\n",
                             IndentLevel+12-1,
                             BlanksForPadding,
                             TypeName
                           );

            (OutputRoutine)( OutputRoutineParameter, ";%.*sFlags             %ws\n",
                             IndentLevel+12-1,
                             BlanksForPadding,
                             FlagName
                           );

            switch(PartialResourceDescriptor->Type) {
                case CmResourceTypePort:
                    (OutputRoutine)( OutputRoutineParameter, ";%.*sSTART 0x%08lx  LENGTH 0x%08lx\n",
                                     IndentLevel+12-1,
                                     BlanksForPadding,
                                     PartialResourceDescriptor->u.Port.Start.LowPart,
                                     PartialResourceDescriptor->u.Port.Length
                                   );
                    break;

                case CmResourceTypeInterrupt:
                    (OutputRoutine)( OutputRoutineParameter, ";%.*sLEVEL %d  VECTOR %d  AFFINITY %d\n",
                                     IndentLevel+12-1,
                                     BlanksForPadding,
                                     PartialResourceDescriptor->u.Interrupt.Level,
                                     PartialResourceDescriptor->u.Interrupt.Vector,
                                     PartialResourceDescriptor->u.Interrupt.Affinity
                                   );
                    break;

                case CmResourceTypeMemory:
                    (OutputRoutine)( OutputRoutineParameter, ";%.*sSTART 0x%08lx%08lx  LENGTH 0x%08lx\n",
                                     IndentLevel+12-1,
                                     BlanksForPadding,
                                     PartialResourceDescriptor->u.Memory.Start.HighPart,
                                     PartialResourceDescriptor->u.Memory.Start.LowPart,
                                     PartialResourceDescriptor->u.Memory.Length
                                   );
                    break;

                case CmResourceTypeDma:
                    (OutputRoutine)( OutputRoutineParameter, ";%.*sCHANNEL %d  PORT %d\n",
                                     IndentLevel+12-1,
                                     BlanksForPadding,
                                     PartialResourceDescriptor->u.Dma.Channel,
                                     PartialResourceDescriptor->u.Dma.Port
                                   );
                    break;

                case CmResourceTypeDeviceSpecific:
                    cb = (OutputRoutine)( OutputRoutineParameter, ";%.*sDataSize 0x%08lx  Data:",
                                          IndentLevel+12-1,
                                          BlanksForPadding,
                                          PartialResourceDescriptor->u.DeviceSpecificData.DataSize
                                        );

                    p = (PULONG)(PartialResourceDescriptor + 1);
                    k = (PartialResourceDescriptor->u.DeviceSpecificData.DataSize + 3) / sizeof( ULONG );
                    for (l=0; l<k; l++) {
                        if ((cb + 11) >= OutputWidth) {
                            cb = (OutputRoutine)( OutputRoutineParameter, "\n;%.*s",
                                                  IndentLevel+12-1,
                                                  BlanksForPadding
                                                ) - 1;
                            }

                        cb += (OutputRoutine)( OutputRoutineParameter, " 0x%08lx", *p++ );
                        }

                    (OutputRoutine)( OutputRoutineParameter, "\n" );
                    break;

                default:
                    (OutputRoutine)( OutputRoutineParameter, ";%.*s*** Unknown resource list type: 0x%x ****\n",
                                     IndentLevel+12-1,
                                     BlanksForPadding,
                                     PartialResourceDescriptor->Type
                                   );
                    break;
                }

            (OutputRoutine)( OutputRoutineParameter, ";\n" );
            }

        FullDescriptor = (PCM_FULL_RESOURCE_DESCRIPTOR) (PartialResourceDescriptor+1);
        }

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\regsvr32\regsvr32.cpp ===
// regsvr.cpp : Program to invoke OLE self-registration on a DLL.
//
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) 1992-1995 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include <windows.h>
#include <ole2.h>
#include <tchar.h>
#include <stdio.h>
#include "resource.h"

#define FAIL_ARGS   1
#define FAIL_OLE    2
#define FAIL_LOAD   3
#define FAIL_ENTRY  4
#define FAIL_REG    5

const TCHAR _szAppName[] = _T("RegSvr32");
const char _szDllInstall[] = "DllInstall";
const TCHAR _tszDllInstall[] = TEXT("DllInstall");
TCHAR _szDllPath[_MAX_PATH];

// Leave room for "Ex" to be tacked onto end
char _szDllRegSvr[32] = "DllRegisterServer";
TCHAR _tszDllRegSvr[32] = TEXT("DllRegisterServer");
char _szDllUnregSvr[32] = "DllUnregisterServer";
TCHAR _tszDllUnregSvr[32] = TEXT("DllUnregisterServer");
char _szRegContext[_MAX_PATH];

HINSTANCE _hInstance;

BOOL _bSilent;

void
FormatString3(
    LPTSTR lpszOut,
    LPCTSTR lpszFormat,
    LPCTSTR lpsz1,
    LPCTSTR lpsz2,
    LPCTSTR lpsz3
    )
{
    LPCTSTR pchSrc = lpszFormat;
    LPTSTR pchDest = lpszOut;
    LPCTSTR pchTmp;
    while (*pchSrc != '\0') {
        if (pchSrc[0] == '%' && (pchSrc[1] >= '1' && pchSrc[1] <= '3')) {
            if (pchSrc[1] == '1')
                pchTmp = lpsz1;
            else if (pchSrc[1] == '2')
                pchTmp = lpsz2;
            else 
                pchTmp = lpsz3;

            lstrcpy(pchDest, pchTmp);
            pchDest += lstrlen(pchDest);
            pchSrc += 2;
        } else {
            if (_istlead(*pchSrc))
                *pchDest++ = *pchSrc++; // copy first of 2 bytes
            *pchDest++ = *pchSrc++;
        }
    }
    *pchDest = '\0';
}

#define MAX_STRING 1024

void
DisplayMessage(
    UINT ids,
    LPCTSTR pszArg1 = NULL,
    LPCTSTR pszArg2 = NULL,
    LPCTSTR pszArg3 = NULL,
    BOOL bUsage = FALSE,
    BOOL bInfo = FALSE
    )
{
    if (_bSilent)
        return;

    TCHAR szFmt[MAX_STRING];
    LoadString(_hInstance, ids, szFmt, MAX_STRING);

    TCHAR szText[MAX_STRING];
    FormatString3(szText, szFmt, pszArg1, pszArg2, pszArg3);
    if (bUsage) {
        int cch = _tcslen(szText);
        LoadString(_hInstance, IDS_USAGE, szText + cch, MAX_STRING - cch);
    }

    if (! _bSilent)
        MessageBox(NULL, szText, _szAppName,
            MB_TASKMODAL | (bInfo ? MB_ICONINFORMATION : MB_ICONEXCLAMATION));
}

inline void
Usage(
    UINT ids,
    LPCTSTR pszArg1 = NULL,
    LPCTSTR pszArg2 = NULL
    )
{
    DisplayMessage(ids, pszArg1, pszArg2, NULL, TRUE);
}

inline void
Info(
    UINT ids,
    LPCTSTR pszArg1 = NULL,
    LPCTSTR pszArg2 = NULL
    )
{
    DisplayMessage(ids, pszArg1, pszArg2, NULL, FALSE, TRUE);
}

#define MAX_APPID    256

BOOL IsContextRegFileType(LPCTSTR *ppszDllName)
{
    HKEY hk1, hk2;
    LONG lRet;
    LONG cch;
    TCHAR szExt[_MAX_EXT];
    TCHAR szAppID[MAX_APPID];
    _tsplitpath(*ppszDllName, NULL, NULL, NULL, szExt);

    // Find [HKEY_CLASSES_ROOT\.foo]
    if (ERROR_SUCCESS != RegOpenKeyEx(HKEY_CLASSES_ROOT, szExt, 0, KEY_QUERY_VALUE, &hk1))
        return FALSE;

    // Read [HKEY_CLASSES_ROOT\.foo\"foo_auto_file"]
    cch = sizeof(szAppID);
    lRet = RegQueryValue(hk1, NULL, szAppID, &cch);
    RegCloseKey(hk1);
    if (ERROR_SUCCESS != lRet)
        return FALSE;

    // Find [HKEY_CLASSES_ROOT\foo_auto_file]
    if (ERROR_SUCCESS != RegOpenKeyEx(HKEY_CLASSES_ROOT, szAppID, 0, KEY_QUERY_VALUE, &hk1))
        return FALSE;

    // Find [HKEY_CLASSES_ROOT\foo_auto_file\AutoRegister]
    if (ERROR_SUCCESS != RegOpenKeyEx(hk1, TEXT("AutoRegister"), 0, KEY_QUERY_VALUE, &hk2))
    {
        RegCloseKey(hk1);
        return FALSE;
    }

    // Read [HKEY_CLASSES_ROOT\foo_auto_file\AutoRegister\"d:\...\fooreg.dll"]
    cch = MAX_PATH;
    lRet = RegQueryValue(hk2, NULL, _szDllPath, &cch);
    RegCloseKey(hk1);
    RegCloseKey(hk2);
    if (ERROR_SUCCESS != lRet)
        return FALSE;

    _szDllPath[cch] = TEXT('\0');
    *ppszDllName = _szDllPath;

    return TRUE;
}

int PASCAL
_tWinMain(
    HINSTANCE hInstance,
    HINSTANCE,
    LPSTR,
    int
    )
{
    int iReturn = 0;
    HRESULT (STDAPICALLTYPE * lpDllEntryPointReg)(void);
    HRESULT (STDAPICALLTYPE * lpDllEntryPointRegEx)(LPCSTR);
    HRESULT (STDAPICALLTYPE * lpDllEntryPointRegExW)(LPCWSTR);
    HRESULT (STDAPICALLTYPE * lpDllEntryPointInstall)(BOOL, LPWSTR);
    HRESULT rc;
    BOOL bVisualC = FALSE;
    BOOL bUnregister = FALSE;
    BOOL bCallDllInstall = FALSE;
    BOOL bCallDllRegisterServer = TRUE;
    BOOL bErrorsOnly = FALSE;
    BOOL bContextReg = FALSE;
    BOOL bUnicodeContextReg = FALSE;
    LPSTR pszDllEntryPoint = _szDllRegSvr;
    LPTSTR ptszDllEntryPoint = _tszDllRegSvr;
    LPTSTR pszTok;
    LPCTSTR pszDllName;
    LPSTR pszContext;
    LPCTSTR pszContextW;
    TCHAR pszDllInstallCmdLine[MAX_PATH];
#ifdef UNICODE
    PWCHAR pwszDllInstallCmdLine = pszDllInstallCmdLine;
#else
    WCHAR pwszDllInstallCmdLine[MAX_PATH];
#endif
    int iNumDllsToRegister = 0;
    int iCount;
    LPCTSTR ppszDllNames[255];
    TCHAR szError[1024];

    _hInstance = hInstance;

    // Parse command line arguments.
    int iTok;
    for (iTok = 1; iTok < __argc; iTok++) {
        pszTok = __targv[iTok];

        if ((pszTok[0] == TEXT('-')) || (pszTok[0] == TEXT('/'))) {
            switch (pszTok[1]) {
                case TEXT('e'):
                case TEXT('E'):
                    bErrorsOnly = TRUE;
                    break;

                case TEXT('i'):
                case TEXT('I'):
                    bCallDllInstall = TRUE;

                    if (pszTok[2] == TEXT(':'))
                    {
                        if (pszTok[3] == TEXT('"')) {
                            // handle quoted InstallCmdLine (
                            // (e.g. /i:"c:\my dll dir\mydll.dll")
                            LPTSTR pszEndQuote = &pszTok[4];
                            int iLength = lstrlen(pszEndQuote);

                            if ((iLength > 0) && pszEndQuote[iLength - 1] == TEXT('"')) {
                                // they quoted the string but it wasent really necessary
                                // (e.g. /i:"shell32.dll")
                                pszEndQuote[iLength - 1] = TEXT('\0');
                                lstrcpy(pszDllInstallCmdLine, pszEndQuote);
                            } else {
                                // we have a quoted string that spans multiple tokens
                                lstrcpy(pszDllInstallCmdLine, pszEndQuote);

                                for (iTok++; iTok < __argc; iTok++) {
                                    // grab the next token
                                    pszEndQuote = __targv[iTok];
                                    iLength = lstrlen(pszEndQuote);

                                    if ((iLength > 0) && (pszEndQuote[iLength - 1] == '"')) {
                                        pszEndQuote[iLength - 1] = TEXT('\0');
                                        lstrcat(pszDllInstallCmdLine, TEXT(" "));
                                        lstrcat(pszDllInstallCmdLine, pszEndQuote);
                                        break;
                                    }

                                    lstrcat(pszDllInstallCmdLine, TEXT(" "));
                                    lstrcat(pszDllInstallCmdLine, pszEndQuote);
                                }
                            }
                        } else {
                            // cmd line is NOT quoted
                            lstrcpy(pszDllInstallCmdLine, &pszTok[3]);
                        }
#ifndef UNICODE
                        if (!MultiByteToWideChar(CP_ACP,
                                                 0,
                                                 (LPCTSTR)pszDllInstallCmdLine,
                                                 -1,
                                                 pwszDllInstallCmdLine,
                                                 MAX_PATH))
                        {
                            Usage(IDS_UNRECOGNIZEDFLAG, pszTok);
                            return FAIL_ARGS;
                        }
#endif
                    }
                    else
                    {
                        lstrcpyW((LPWSTR)pwszDllInstallCmdLine, L"");
                    }
                    break;

                case TEXT('n'):
                case TEXT('N'):
                    bCallDllRegisterServer = FALSE;
                    break;

                case TEXT('s'):
                case TEXT('S'):
                    _bSilent = TRUE;
                    break;

                case TEXT('u'):
                case TEXT('U'):
                    bUnregister = TRUE;
                    pszDllEntryPoint = _szDllUnregSvr;
                    ptszDllEntryPoint = _tszDllUnregSvr;
                    break;

                case TEXT('v'):
                case TEXT('V'):
                    bVisualC = TRUE;
                    break;

                case TEXT('c'):
                case TEXT('C'):
                    // Ignore this
                    break;

                default:
                    Usage(IDS_UNRECOGNIZEDFLAG, pszTok);
                    return FAIL_ARGS;
            }
        } else {
            if (pszTok[0] == TEXT('"')) {
                // handle quoted DllName
                TCHAR szTemp[MAX_PATH];
                LPTSTR pszQuotedDllName;
                int iLength;

                lstrcpy(szTemp, &pszTok[1]);
                iLength = lstrlen(szTemp);

                if ((iLength > 0) && szTemp[iLength - 1] != TEXT('"')) {
                    // handle quoted dll name that spans multiple tokens
                    for (iTok++; iTok < __argc; iTok++) {
                        lstrcat(szTemp, TEXT(" "));
                        lstrcat(szTemp, __targv[iTok]);
                        iLength = lstrlen(__targv[iTok]);
                        if ((iLength > 0) && __targv[iTok][iLength - 1] == TEXT('"')) {
                            // this token has the end quote, so stop here
                            break;
                        }
                    }
                }

                iLength = lstrlen(szTemp);

                // remove the trailing " if one exists
                if ( (iLength > 0) && (szTemp[iLength - 1] == TEXT('"')) ) {
                    szTemp[iLength - 1] = TEXT('\0');
                }

                pszQuotedDllName = (LPTSTR) LocalAlloc(LPTR, (iLength + 1) * sizeof(TCHAR));

                if (pszQuotedDllName)
                {
                    lstrcpy(pszQuotedDllName, szTemp);
                    ppszDllNames[iNumDllsToRegister] = pszQuotedDllName;
                    iNumDllsToRegister++;
                }

            } else {
                // no leading " so assume that this token is one of the dll names
                ppszDllNames[iNumDllsToRegister] = pszTok;
                iNumDllsToRegister++;
            }
        }
    }

    // check to see if we were passed a '-n' but no '-i'
    if (!bCallDllRegisterServer && !bCallDllInstall) {
        Usage(IDS_UNRECOGNIZEDFLAG, TEXT("/n must be used with the /i switch"));
        return FAIL_ARGS;
    }

    if (iNumDllsToRegister == 0) {
        if (bVisualC)
            DisplayMessage(IDS_NOPROJECT);
        else
            Usage(IDS_NODLLNAME);

        return FAIL_ARGS;
    }

    // Initialize OLE.
    __try {
        rc = OleInitialize(NULL);
    } __except (EXCEPTION_EXECUTE_HANDLER) {
        rc = (HRESULT) GetExceptionCode();
    }

    if (FAILED(rc)) {
        DisplayMessage(IDS_OLEINITFAILED);
        return FAIL_OLE;
    }

    if (_bSilent) {
        SetErrorMode(SEM_FAILCRITICALERRORS);       // Make sure LoadLib fail in silent mode (no popups).
    }

    for (iCount = 0; iCount < iNumDllsToRegister; iCount++) {
        pszDllName = ppszDllNames[iCount];

        /*
         * See if this is a non-executable file that requires special handling. If so,
         * bContextReg will be set to TRUE and pszDllName (which original pointed to
         * the path to the special file) will be set to the path to the executable that
         * is responsible for doing the actual registration. The path to the special
         * file will be passed in as context info in the call Dll[Un]RegisterServerEx.
         */
        pszContextW = pszDllName;
        pszContext = (LPSTR)pszContextW;
        bContextReg = IsContextRegFileType(&pszDllName);
        if (TRUE == bContextReg) {
            lstrcatA(pszDllEntryPoint, "Ex");
            lstrcat(ptszDllEntryPoint, TEXT("Ex"));
            // Convert pszContext to a real char *
#ifdef UNICODE
            if (!WideCharToMultiByte(CP_ACP,
                                     0,
                                     (LPCWSTR)pszContext,
                                     lstrlenW((LPCWSTR)pszContext),
                                     _szRegContext,
                                     sizeof(_szRegContext),
                                     0,
                                     NULL))
            {
                Usage(IDS_UNRECOGNIZEDFLAG, pszTok);
                return FAIL_ARGS;
            } else {
                pszContext = _szRegContext;
            }
#endif

        }

        // Load the library -- fail silently if problems
        UINT errMode = SetErrorMode(SEM_FAILCRITICALERRORS);
        HINSTANCE hLib = LoadLibraryEx(pszDllName, NULL, LOAD_WITH_ALTERED_SEARCH_PATH);

        SetErrorMode(errMode);

        if (hLib < (HINSTANCE)HINSTANCE_ERROR) {
            DWORD dwErr = GetLastError();

            if (ERROR_BAD_EXE_FORMAT == dwErr) {
                DisplayMessage(IDS_NOTEXEORHELPER, pszDllName);
            } else {
                if (FormatMessage(FORMAT_MESSAGE_FROM_SYSTEM, NULL,
                                  dwErr, 0, szError, sizeof(szError), NULL)) {
                    DisplayMessage(IDS_LOADLIBFAILED, pszDllName, szError);
                }
            }
            iReturn = FAIL_LOAD;
            goto CleanupOle;
        }

        // during unregister we need to call DllInstall first, and then DllUnregisterServer
        if (bUnregister)
            goto DllInstall;

DllRegisterServer:
        // Call the entry point for DllRegisterServer/DllUnregisterServer
        if (bCallDllRegisterServer) {
            if (bContextReg) {
                (FARPROC&)lpDllEntryPointRegEx = GetProcAddress(hLib, "DllRegisterServerExW");
                if (lpDllEntryPointRegEx) {
                    (FARPROC&)lpDllEntryPointRegExW = (FARPROC&)lpDllEntryPointRegEx;
                    bUnicodeContextReg = TRUE;
                } else {
                    (FARPROC&)lpDllEntryPointRegEx = GetProcAddress(hLib, "DllRegisterServerEx");
                }

                (FARPROC&)lpDllEntryPointReg = (FARPROC&)lpDllEntryPointRegEx;
            } else {
                (FARPROC&)lpDllEntryPointReg = (FARPROC&)lpDllEntryPointRegEx = GetProcAddress(hLib, pszDllEntryPoint);
            }

            if (lpDllEntryPointReg == NULL) {
                TCHAR szExt[_MAX_EXT];
                _tsplitpath(pszDllName, NULL, NULL, NULL, szExt);

                if (FALSE == bContextReg && (lstrcmp(szExt, TEXT(".dll")) != 0) && (lstrcmp(szExt, TEXT(".ocx")) != 0))
                    DisplayMessage(IDS_NOTDLLOROCX, pszDllName, ptszDllEntryPoint);
                else
                    DisplayMessage(IDS_NOENTRYPOINT, pszDllName, ptszDllEntryPoint);

                iReturn = FAIL_ENTRY;
                goto CleanupLibrary;
            }

            // try calling DllRegisterServer[Ex]() / DllUnregisterServer[Ex]()
            __try {
                if (bUnicodeContextReg) {
                    rc = (*lpDllEntryPointRegExW)(pszContextW);
                } else {
                    if (bContextReg) {
                        rc = (*lpDllEntryPointRegEx)(pszContext);
                    } else {
                        rc = (*lpDllEntryPointReg)();
                    }
                }
            } __except(EXCEPTION_EXECUTE_HANDLER) {
                rc = (HRESULT) GetExceptionCode();
            }

            if (FAILED(rc)) {
                wsprintf(szError, _T("0x%08lx"), rc);
                DisplayMessage(IDS_CALLFAILED, ptszDllEntryPoint, pszDllName, szError);
                iReturn = FAIL_REG;
                goto CleanupLibrary;
            }
        }

        // during unregister we need to call DllInstall first, then DllRegisterServer,
        // since we already called DllInstall and then jumped back up to DllRegisterServer:
        // skip over it and goto CheckErrors:
        if (bUnregister)
            goto CheckErrors;

DllInstall:
        // Call the entry point for DllInstall
        if (bCallDllInstall) {
            (FARPROC&)lpDllEntryPointInstall = GetProcAddress(hLib, _szDllInstall);

            if (lpDllEntryPointInstall == NULL) {
                TCHAR szExt[_MAX_EXT];
                _tsplitpath(pszDllName, NULL, NULL, NULL, szExt);

                if ((lstrcmp(szExt, TEXT(".dll")) != 0) && (lstrcmp(szExt, TEXT(".ocx")) != 0))
                    DisplayMessage(IDS_NOTDLLOROCX, pszDllName, _tszDllInstall);
                else
                    DisplayMessage(IDS_NOENTRYPOINT, pszDllName, _tszDllInstall);

                iReturn = FAIL_ENTRY;
                goto CleanupLibrary;
            }

            // try calling DllInstall(BOOL bRegister, LPWSTR lpwszCmdLine) here...
            // NOTE: the lpwszCmdLine string must be UNICODE!
            __try {
                rc = (*lpDllEntryPointInstall)(!bUnregister, pwszDllInstallCmdLine);

            } __except(EXCEPTION_EXECUTE_HANDLER) {
                rc = (HRESULT) GetExceptionCode();
            }

            if (FAILED(rc)) {
                wsprintf(szError, _T("0x%08lx"), rc);
                DisplayMessage(IDS_CALLFAILED, _tszDllInstall, pszDllName, szError);
                iReturn = FAIL_REG;
                goto CleanupLibrary;
            }
        }

        // during unregister we now need to call DllUnregisterServer
        if (bUnregister)
            goto DllRegisterServer;

CheckErrors:
        if (!bErrorsOnly) {
            TCHAR szMessage[MAX_PATH];

            // set up the success message text
            if (bCallDllRegisterServer)
            {
                lstrcpy(szMessage, ptszDllEntryPoint);
                if (bCallDllInstall)
                {
                    lstrcat(szMessage, TEXT(" and "));
                    lstrcat(szMessage, _tszDllInstall);
                }
            }
            else if (bCallDllInstall)
            {
                lstrcpy(szMessage, _tszDllInstall);
            }

            Info(IDS_CALLSUCCEEDED, szMessage, pszDllName);
        }

CleanupLibrary:
        FreeLibrary(hLib);
    }

CleanupOle:
    __try {
        OleUninitialize();
    } __except (EXCEPTION_EXECUTE_HANDLER) {
        DisplayMessage(IDS_OLEUNINITFAILED);
    }

    return iReturn;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\relstat\inc\server.h ===
//server.h
//RELSTAT_PROCESS_INFO is a duplication of SYSTEM_PROCESS_INFORMATION 
//defined in ntexapi.h We have added a few fields that we thought were
//unnecessary and added a couple of fields 

typedef struct _RS_UNICODE_STRING {
        USHORT Length;
        USHORT MaximumLength;
#ifdef MIDL_PASS
        [size_is(MaximumLength),length_is(Length)]PWSTR  Buffer;
#else
        PWSTR  Buffer;
#endif
    } RS_UNICODE_STRING;


typedef struct _RELSTAT_PROCESS_INFO{
ULONG NumberOfThreads;
LARGE_INTEGER CreateTime;
LARGE_INTEGER UserTime;
LARGE_INTEGER KernelTime;
LPWSTR szImageName;
LONG BasePriority;                  //KPRIORITY in ntexapi.h
DWORD UniqueProcessId;             //HANDLE in ntexapi.h
DWORD InheritedFromUniqueProcessId;  //HANDLE in ntexapi.h
ULONG HandleCount;
ULONG SessionId;
SIZE_T PeakVirtualSize;
SIZE_T VirtualSize;
ULONG PageFaultCount;
SIZE_T PeakWorkingSetSize;
SIZE_T WorkingSetSize;
SIZE_T QuotaPeakPagedPoolUsage;
SIZE_T QuotaPagedPoolUsage;
SIZE_T QuotaPeakNonPagedPoolUsage;
SIZE_T QuotaNonPagedPoolUsage;
SIZE_T PagefileUsage;
SIZE_T PeakPagefileUsage;
SIZE_T PrivatePageCount;
LARGE_INTEGER ReadOperationCount;
LARGE_INTEGER WriteOperationCount;
LARGE_INTEGER OtherOperationCount;
LARGE_INTEGER ReadTransferCount;
LARGE_INTEGER WriteTransferCount;
LARGE_INTEGER OtherTransferCount;
ULONG GdiHandleCount;
ULONG UsrHandleCount;
} RELSTAT_PROCESS_INFO, *PRELSTAT_PROCESS_INFO;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\relstat\client\client.c ===
//
// Copyright (C) 1999  Microsoft Corporation.  All Rights Reserved.
//
//  MODULE:   client.c
//
//  PURPOSE:  This program is a command line program to get process or pool statistics
//
//
//  AUTHOR:
//      Anitha Panapakkam -
//
#include <windows.h>
#include <stdlib.h>
#include <stdio.h>
#include <io.h>
#include <rpc.h>
#include "relstat.h"

#define MEMSNAP 1
#define POOLSNAP 2

int iFlag = -1;
FILE* LogFile=NULL;                      // log file handle
RPC_BINDING_HANDLE Binding;

void Usage(void)
{
    printf("Usage:\n"
        "\t-n <server addr>  - Defaults to local machine\n"
        "\t-m - memsnap \n"
        "\t-p - poolsnap \n"
        "\t<logfile> = memsnap.log by default\n"
        );
    exit(1);
}

VOID PrintError( RPC_STATUS status)
{
	LPVOID lpMsgBuf;

	FormatMessage( FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM,
				   NULL,
				   status,
				   MAKELANGID( LANG_NEUTRAL, SUBLANG_DEFAULT ),
				   (LPTSTR) &lpMsgBuf,
				   0,
				   NULL );
	printf("%s\n", lpMsgBuf);

    if( LogFile ) {
        fprintf(LogFile,"!error=%s\n",lpMsgBuf);
    }

	LocalFree( lpMsgBuf );
    return;
}

void ProcessInfo();
void PooltagInfo();

//
//  FUNCTION: main
//
//  PURPOSE: Parses arguments and binds to the server.
//
//  PARAMETERS:
//    argc - number of command line arguments
//    argv - array of command line arguments
//
//  RETURN VALUE:
//    Program exit code.
//
//
int _cdecl main(int argc, char *argv[])
{
    SYSTEMTIME SystemTime;

    char *serverAddress = NULL;
    char *protocol = "ncacn_np";
    UINT iIterations = 100;
    unsigned char *stringBinding;
    RPC_STATUS status;
    ULONG SecurityLevel = RPC_C_AUTHN_LEVEL_NONE;
    ULONG ulBuildNumber=0;
    ULONG ulTickCount = 0;
    PCHAR pszFileName;
    INT iArg;

    pszFileName = &"memsnap.log";
    argc--;
    argv++;

    while(argc)
        {
        if( (argv[0][0] == '-' ) || (argv[0][0] == '/') )
          {
           switch(argv[0][1])
            {
            case 'n':
                if (argc < 2)
                    {
                    Usage();
                    }
                serverAddress = argv[1];
                //printf("%s server\n",serverAddress);
                argc--;
                argv++;
                break;

            case 'm':
                iFlag = MEMSNAP;
                break;

            case 'p':
                iFlag = POOLSNAP;
                break;

            case 't':
                if (argc < 2)
                    {
                    Usage();
                    }
                protocol = argv[1];
                argc--;
                argv++;
                break;
            default:
                Usage();
                break;
           }
        }
        else
        {  // must be the log filename
            pszFileName= argv[0];
        }
        argc--;
        argv++;
    }

    if( (iFlag != POOLSNAP) && (iFlag != MEMSNAP) ) {
        Usage();
    }

    //
    // Open the output file
    //

    LogFile= fopen( pszFileName, "a" );

    if( LogFile == NULL ) {
        printf("Error opening file %s\n",pszFileName);
        exit(-1);
    }


    //
    // print file header once
    //

    if (_filelength(_fileno(LogFile)) == 0 ) {
        if( iFlag == MEMSNAP ) {
        fprintf(LogFile,"Process ID         Proc.Name Wrkng.Set PagedPool  NonPgdPl  Pagefile    Commit   Handles   Threads" "   GdiObjs  UserObjs" );
        }

        if( iFlag == POOLSNAP ) {
        fprintf(LogFile," Tag  Type     Allocs     Frees      Diff   Bytes  Per Alloc");
        }
    }

    //
    // Blank line separates different snaps
    //

    fprintf( LogFile, "\n" );

    //
    // Bind to the RPC interface
    //

    status = RpcStringBindingCompose(0,
                                     protocol,
                                     serverAddress,
                                     0,
                                     0,
                                     &stringBinding);
    if (status != RPC_S_OK)
        {
        printf("RpcStringBindingCompose failed - %d\n", status);
	    PrintError(status);
        return(1);
        }

    status = RpcBindingFromStringBinding(stringBinding, &Binding);

    if (status != RPC_S_OK)
        {
        printf("RpcBindingFromStringBinding failed - %d\n", status);
        PrintError(status);
        return(1);
        }

    status =
    RpcBindingSetAuthInfo(Binding,
                          0,
                          SecurityLevel,
                          RPC_C_AUTHN_WINNT,
                          0,
                          0
                         );

    if (status != RPC_S_OK)
        {
        printf("RpcBindingSetAuthInfo failed - %d\n", status);
        PrintError(status);
        return(1);
        }


    //
    // Output the tagging information after the title (sortlog types file by first line)
    //

    if( iFlag == MEMSNAP ) {
        fprintf(LogFile,"!LogType=memsnap\n");
    }

    if( iFlag == POOLSNAP ) {
        fprintf(LogFile,"!LogType=poolsnap\n");
    }


    if( serverAddress == NULL ) {
        CHAR szComputerName[MAX_COMPUTERNAME_LENGTH+1];
        DWORD dwSize= sizeof(szComputerName);

        if( GetComputerName( szComputerName, &dwSize ) ) {
            fprintf(LogFile,"!ComputerName=%s\n",szComputerName);
        }
        // No output if no computer name available...
    }
    else {
        fprintf(LogFile,"!ComputerName=%s\n",serverAddress);
    }

    status = RelStatBuildNumber(Binding, &ulBuildNumber);
    if (status != ERROR_SUCCESS)
        {
        printf("RelStatBuildNumber failed %d\n", status);
        PrintError(status);
        }
    else
        {
        fprintf(LogFile, "!buildnumber=%d \n", ulBuildNumber);
        }

    // SystemTime (UTC not local time)

    GetSystemTime(&SystemTime);

    fprintf(LogFile,"!SystemTime=%02i\\%02i\\%04i %02i:%02i:%02i.%04i (GMT)\n",
                SystemTime.wMonth,
                SystemTime.wDay,
                SystemTime.wYear,
                SystemTime.wHour,
                SystemTime.wMinute,
                SystemTime.wSecond,
                SystemTime.wMilliseconds);


    status = RelStatTickCount(Binding, &ulTickCount);
    if (status != ERROR_SUCCESS)
        {
        printf("RelStatTickCount failed %d\n", status);
        PrintError(status);
        }
    else
        {
        fprintf(LogFile,"!TickCount=%d\n", ulTickCount);
        }


    //
    // Finally, output the requested process or pool information
    //

    if (iFlag == MEMSNAP) {
            ProcessInfo();
    }

    if (iFlag == POOLSNAP) {
            PooltagInfo();
    }


    //
    // Cleanup
    //

    status = RpcBindingFree(&Binding);

    status = RpcStringFree(&stringBinding);

    fclose(LogFile);


    return(0);
}

void ProcessInfo()
{
    PRELSTAT_PROCESS_INFO pRelStatProcessInfo=NULL;
    DWORD dwResult;
    ULONG dwNumProcesses,i;
    LONG Pid = -1;

    dwResult = RelStatProcessInfo(Binding,
                         Pid,
                         &dwNumProcesses,
                         &pRelStatProcessInfo);

    if (dwResult != ERROR_SUCCESS) {
            printf("RelstatProcessInfo error: %d\n",dwResult);
            fprintf(LogFile,"!error:RelStatProcessInfo call failed!\n");
            fprintf(LogFile,"!error:RelstatProcessInfo error: %d\n",dwResult);
            PrintError(dwResult);
    }
    else  {
            // printf("Number of Processes = %u\n", dwNumProcesses);
            for(i=0; i< dwNumProcesses; i++)
		    {
#if 0
			    printf(
                    "%p%20ws%10u%10u%10u%10u%10u%10u%10u\n",
                    pRelStatProcessInfo[i].UniqueProcessId,
                    pRelStatProcessInfo[i].szImageName,
                    pRelStatProcessInfo[i].WorkingSetSize,
                    pRelStatProcessInfo[i].QuotaPagedPoolUsage,
                    pRelStatProcessInfo[i].QuotaNonPagedPoolUsage,
                    pRelStatProcessInfo[i].PagefileUsage,
                    pRelStatProcessInfo[i].PrivatePageCount,
                    pRelStatProcessInfo[i].HandleCount,
                    pRelStatProcessInfo[i].NumberOfThreads,
                    pRelStatProcessInfo[i].GdiHandleCount,
                    pRelStatProcessInfo[i].UsrHandleCount
                    );
#endif

			    fprintf(LogFile,
                    "%10u%20ws%10u%10u%10u%10u%10u%10u%10u%10u%10u\n",
                    pRelStatProcessInfo[i].UniqueProcessId,
                    pRelStatProcessInfo[i].szImageName,
                    pRelStatProcessInfo[i].WorkingSetSize,
                    pRelStatProcessInfo[i].QuotaPagedPoolUsage,
                    pRelStatProcessInfo[i].QuotaNonPagedPoolUsage,
                    pRelStatProcessInfo[i].PagefileUsage,
                    pRelStatProcessInfo[i].PrivatePageCount,
                    pRelStatProcessInfo[i].HandleCount,
                    pRelStatProcessInfo[i].NumberOfThreads,
                    pRelStatProcessInfo[i].GdiHandleCount,
                    pRelStatProcessInfo[i].UsrHandleCount
                   );


                if (pRelStatProcessInfo[i].szImageName) {
                       MIDL_user_free(pRelStatProcessInfo[i].szImageName);
                }

		    }
        }



    if (pRelStatProcessInfo) {
         MIDL_user_free(pRelStatProcessInfo);
    }
    pRelStatProcessInfo = NULL;
    return;
}

void PooltagInfo()
{
    CHAR* pszFormat;
    DWORD dwResult;
    ULONG i,dwNumTags;
    PRELSTAT_POOLTAG_INFO pRelStatPoolInfo=NULL;
    PRELSTAT_POOLTAG_INFO ptr;
    LPSTR szTagName=TEXT("*");
    UCHAR szTag[5];


    //call the RelstatPooltagInfo api to get the pooltag information
    dwResult = RelStatPoolTagInfo(Binding,
				         szTagName,
				         &dwNumTags,
				         &pRelStatPoolInfo);
    if (dwResult != ERROR_SUCCESS) {
            printf("RelstatPoolTagInfo error: %d\n",dwResult);
            fprintf(LogFile,"!error:RelStatPoolTagInfo call failed!\n");
            fprintf(LogFile,"!error:RelstatPoolTagInfo error: %d\n",dwResult);
            PrintError(dwResult);

    }
    else  {


            for(i=0;i<dwNumTags;i++) {
                memcpy(szTag,pRelStatPoolInfo[i].Tag,4);
                szTag[4] = '\0';

                pszFormat=
                #ifdef _WIN64
                    " %4s %5s %18I64d %18I64d  %16I64d %14I64d     %12I64d\n",
                #else
                    " %4s %5s %9ld %9ld  %8ld %7ld     %6ld\n",
                #endif
                ptr= &pRelStatPoolInfo[i];

                if( ptr->PagedAllocs != 0 ) {
                    ULONG Diff= ptr->PagedAllocs - ptr->PagedFrees;
                    fprintf(LogFile, pszFormat,
                        szTag,
                        "Paged",
                        ptr->PagedAllocs,
                        ptr->PagedFrees,
                        Diff,
                        ptr->PagedUsed,
                        ptr->PagedUsed/(Diff?Diff:1)
                        );

                }

                if( ptr->NonPagedAllocs != 0 ) {
                    ULONG Diff= ptr->NonPagedAllocs - ptr->NonPagedFrees;
                    fprintf(LogFile, pszFormat,
                        szTag,
                        "Nonp",
                        ptr->NonPagedAllocs,
                        ptr->NonPagedFrees,
                        Diff,
                        ptr->NonPagedUsed,
                        ptr->NonPagedUsed/(Diff?Diff:1)
                        );

               }

         }

    }
   				
    if (pRelStatPoolInfo) {
                MIDL_user_free(pRelStatPoolInfo);
    }

    pRelStatPoolInfo = NULL;

    return;
}

void * __RPC_USER MIDL_user_allocate(size_t size)
{
    return(HeapAlloc(GetProcessHeap(), HEAP_GENERATE_EXCEPTIONS, size));
}

void __RPC_USER MIDL_user_free( void *pointer)
{
    HeapFree(GetProcessHeap(), 0, pointer);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\relstat\server\rssvc.c ===
//
// Copyright (C) 1995-1997  Microsoft Corporation.  All Rights Reserved.
//
//  MODULE:   server.c
//
//  PURPOSE:  Implements the body of the Relstat RPC service
//
//  FUNCTIONS:
//            Called by service.c:
//            ServiceStart(DWORD dwArgc, LPTSTR *lpszArgv);
//            ServiceStop( );
//
//            Called by RPC:
//
//  COMMENTS: The ServerStart and ServerStop functions implemented here are
//            prototyped in service.h.  The other functions are RPC manager
//            functions prototypes in relstat.h
//
//
//  AUTHOR: Anitha Panapakkam
//

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <assert.h>
#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <ctype.h>
#include <io.h>
#include <srvfsctl.h>
#include <tchar.h>
#include <rpc.h>
#include "service.h"
#include "relstat.h"

//
// RPC configuration.
//

// This service listens to all the protseqs listed in this array.
// This should be read from the service's configuration in the
// registery.
TCHAR *ProtocolArray[] = { TEXT("ncalrpc"),
                           TEXT("ncacn_ip_tcp"),
                           TEXT("ncacn_np"),
                           TEXT("ncadg_ip_udp")
                         };
#define BUFFER_SIZE2 256*1024
// Used in RpcServerUseProtseq, for some protseqs
// this is used as a hint for buffer size.
ULONG ProtocolBuffer = 3;

// Use in RpcServerListen().  More threads will increase performance,
// but use more memory.
ULONG MinimumThreads = 3;

BOOLEAN
CheckFilters (
    PSYSTEM_POOLTAG TagInfo,
    LPCSTR szTag
    );
//
//  FUNCTION: ServiceStart
//
//  PURPOSE: Actual code of the service
//           that does the work.
//
//  PARAMETERS:
//    dwArgc   - number of command line arguments
//    lpszArgv - array of command line arguments
//
//  RETURN VALUE:
//    none
//
//  COMMENTS:
//    Starts the service listening for RPC requests.
//
VOID ServiceStart (DWORD dwArgc, LPTSTR *lpszArgv)
{
    UINT i;
    RPC_BINDING_VECTOR *pbindingVector = 0;
    RPC_STATUS status;
    BOOL fListening = FALSE;

    ///////////////////////////////////////////////////
    //
    // Service initialization
    //

    //
    // Use protocol sequences (protseqs) specified in ProtocolArray.
    //

    for(i = 0; i < sizeof(ProtocolArray)/sizeof(TCHAR *); i++)
        {

        // Report the status to the service control manager.
        if (!ReportStatusToSCMgr(
            SERVICE_START_PENDING, // service state
            NO_ERROR,              // exit code
            3000))                 // wait hint
            return;


        status = RpcServerUseProtseq(ProtocolArray[i],
                                     ProtocolBuffer,
                                     0);

        if (status == RPC_S_OK)
            {
            fListening = TRUE;
            }
        }

    if (!fListening)
        {
        // Unable to listen to any protocol!
        //
        AddToMessageLog(TEXT("RpcServerUseProtseq() failed\n"));
        return;
        }

    // Report the status to the service control manager.
    //
    if (!ReportStatusToSCMgr(
        SERVICE_START_PENDING, // service state
        NO_ERROR,              // exit code
        3000))                 // wait hint
        return;

    // Register the services interface(s).
    //

    status = RpcServerRegisterIf(RelstatRPCService_ServerIfHandle,   // from relstat.h
                                 0,
                                 0);


    if (status != RPC_S_OK)
        return;

    // Report the status to the service control manager.
    //
    if (!ReportStatusToSCMgr(
        SERVICE_START_PENDING, // service state
        NO_ERROR,              // exit code
        3000))                 // wait hint
        return;


    // Register interface(s) and binding(s) (endpoints) with
    // the endpoint mapper.
    //

    status = RpcServerInqBindings(&pbindingVector);

    if (status != RPC_S_OK)
        {
        return;
        }

    status = RpcEpRegister(RelstatRPCService_ServerIfHandle,   // from rpcsvc.h
                           pbindingVector,
                           0,
                           0);

    if (status != RPC_S_OK)
        {
        return;
        }

    // Report the status to the service control manager.
    //
    if (!ReportStatusToSCMgr(
        SERVICE_START_PENDING, // service state
        NO_ERROR,              // exit code
        3000))                 // wait hint
        return;

    // Enable NT LM Security Support Provider (NtLmSsp service)
    //
    status = RpcServerRegisterAuthInfo(0,
                                       RPC_C_AUTHN_WINNT,
                                       0,
                                       0
                                       );
    if (status != RPC_S_OK)
        {
        return;
        }

    // Report the status to the service control manager.
    //
    if (!ReportStatusToSCMgr(
        SERVICE_START_PENDING, // service state
        NO_ERROR,              // exit code
        3000))                 // wait hint
        return;


    // Start accepting client calls.
    //
    status = RpcServerListen(MinimumThreads,
                             RPC_C_LISTEN_MAX_CALLS_DEFAULT,  // rpcdce.h
                             TRUE);                           // don't block.

    if (status != RPC_S_OK)
        {
        return;
        }

    // Report the status to the service control manager.
    //
    if (!ReportStatusToSCMgr(
        SERVICE_RUNNING,       // service state
        NO_ERROR,              // exit code
        0))                    // wait hint
        return;

    //
    // End of initialization
    //
    ////////////////////////////////////////////////////////////

    ////////////////////////////////////////////////////////////
    //
    // Cleanup
    //

    // RpcMgmtWaitServerListen() will block until the server has
    // stopped listening.  If this service had something better to
    // do with this thread, it would delay this call until
    // ServiceStop() had been called. (Set an event in ServiceStop()).
    //
    status = RpcMgmtWaitServerListen();

    // ASSERT(status == RPC_S_OK)

    // Remove entries from the endpoint mapper database.
    //
    RpcEpUnregister(RelstatRPCService_ServerIfHandle,   // from rpcsvc.h
                    pbindingVector,
                    0);

    // Delete the binding vector
    //
    RpcBindingVectorFree(&pbindingVector);

    //
    ////////////////////////////////////////////////////////////
    return;
}


//
//  FUNCTION: ServiceStop
//
//  PURPOSE: Stops the service
//
//  PARAMETERS:
//    none
//
//  RETURN VALUE:
//    none
//
//  COMMENTS:
//    If a ServiceStop procedure is going to
//    take longer than 3 seconds to execute,
//    it should spawn a thread to execute the
//    stop code, and return.  Otherwise, the
//    ServiceControlManager will believe that
//    the service has stopped responding.
//
VOID ServiceStop()
{
    // Stop's the server, wakes the main thread.

    RpcMgmtStopServerListening(0);
}



error_status_t
RelStatProcessInfo(
                    handle_t h,
                    LONG Pid,
                    ULONG *pNumberOfProcesses,
                    PRELSTAT_PROCESS_INFO *ppRelStatProcessInfo)
{
    PSYSTEM_PROCESS_INFORMATION pProcessInfo = NULL;
    PRELSTAT_PROCESS_INFO pProcessArray = NULL;
    ULONG TotalOffset=0;
    ULONG NumberOfProcesses = 1; //atleast one process
    ULONG NumAlloc = 0;
    ULONG i,index,dwMatches = 0;
    PBYTE pProcessBuffer = NULL;
    NTSTATUS Status= STATUS_INFO_LENGTH_MISMATCH;
    DWORD       ByteCount = 32768;   //TODO : tune it on a "typical system"
    DWORD       RequiredByteCount = 0;
    BOOL 	fCheck = FALSE;
    HANDLE hProcess;       // process handle

    //two iterations of NtQuerySystemInformation will happen
    //can see if there is any other way to allocate a big buffer.
    while ( Status == STATUS_INFO_LENGTH_MISMATCH)
        {
            //
            //  Allocate a buffer
            //
            pProcessBuffer = MIDL_user_allocate(ByteCount);

            if (pProcessBuffer == NULL)
            {
                Status = STATUS_NO_MEMORY;
                *pNumberOfProcesses = 0;
                *ppRelStatProcessInfo = NULL;
                break;
            }

            //
            //  Perform process enumeration.
            //
            Status = NtQuerySystemInformation( SystemProcessInformation,
                                                 (PVOID)pProcessBuffer,
                                                 ByteCount,
                                                 &RequiredByteCount );
            if (Status == STATUS_INFO_LENGTH_MISMATCH)
            {
                ByteCount = RequiredByteCount+4096;
                if (pProcessBuffer)
                    LocalFree(pProcessBuffer);
            }
        }

    if (Status == STATUS_SUCCESS)
        {
            //walk the returned buffer to get the # of processes
            pProcessInfo = (PSYSTEM_PROCESS_INFORMATION)pProcessBuffer;
            TotalOffset = 0;

            //client has specified a Pid
            if (Pid >= 0)
                fCheck = TRUE;

            while(pProcessInfo->NextEntryOffset != 0)
                {
                        if ((fCheck == TRUE) &&
                            (PtrToLong(pProcessInfo->UniqueProcessId) == Pid))
                            {
                                //Pid matched. exit from the while loop
                                // no need to count the processes anymore
                                //fExit = TRUE;
                                dwMatches++;
                                break;
                            }

                        NumberOfProcesses++;
                        TotalOffset += pProcessInfo->NextEntryOffset;
                        pProcessInfo = (PSYSTEM_PROCESS_INFORMATION)
                                &pProcessBuffer[TotalOffset];
                }

            printf("Num Processes = %ul, Matches %d \n",NumberOfProcesses,
                                                        dwMatches);

            if (dwMatches > 0)
                    NumAlloc = dwMatches;
            else
                    NumAlloc = NumberOfProcesses;

            pProcessArray = MIDL_user_allocate(NumAlloc *
                                      sizeof (RELSTAT_PROCESS_INFO));

            if (pProcessArray == NULL)
                {
                    printf("No memory for pProcessArray\n");
                    Status = STATUS_NO_MEMORY;
                    LocalFree(pProcessBuffer);
                    pProcessBuffer = NULL;
                }
            else
                {
                    RtlZeroMemory(pProcessArray, NumAlloc *
                                 sizeof(RELSTAT_PROCESS_INFO));
                    Status = STATUS_SUCCESS;
                    pProcessInfo = (PSYSTEM_PROCESS_INFORMATION)pProcessBuffer;
                    TotalOffset = 0;

                    //walk the returned buffer and copy to pProcessArray

                    for(i=0;i<NumberOfProcesses;i++)
                        {
                            if (dwMatches > 0)
                                {
                                    if(PtrToLong(pProcessInfo->UniqueProcessId) != Pid)
                                            goto End;
                                    else
                                        index = dwMatches-1;
                                }
                            else
                                index = i;

                            pProcessArray[index].NumberOfThreads = pProcessInfo->NumberOfThreads;
                            pProcessArray[index].CreateTime = pProcessInfo->CreateTime;
                            pProcessArray[index].UserTime = pProcessInfo->UserTime;
                            pProcessArray[index].KernelTime = pProcessInfo->KernelTime;
                            //create a null terminated imagename string
                            pProcessArray[index].szImageName = MIDL_user_allocate((pProcessInfo->ImageName.Length+1)*2);
                            if (pProcessInfo->ImageName.Length > 0)
                                {
                                    wcsncpy(pProcessArray[index].szImageName,
                                        pProcessInfo->ImageName.Buffer,
                                        pProcessInfo->ImageName.Length);
                                }
                            pProcessArray[index].szImageName[pProcessInfo->ImageName.Length] = L'\0';

                            pProcessArray[index].BasePriority = pProcessInfo->BasePriority;
                            pProcessArray[index].UniqueProcessId = PtrToLong(pProcessInfo->UniqueProcessId);
                            pProcessArray[index].InheritedFromUniqueProcessId = PtrToLong(pProcessInfo->InheritedFromUniqueProcessId);

                            pProcessArray[index].HandleCount = pProcessInfo->HandleCount;
                            pProcessArray[index].SessionId = pProcessInfo->SessionId;
                            pProcessArray[index].PeakVirtualSize = pProcessInfo->PeakVirtualSize;
                            pProcessArray[index].VirtualSize = pProcessInfo->VirtualSize;
                            pProcessArray[index].PageFaultCount = pProcessInfo->PageFaultCount;
                            pProcessArray[index].PeakWorkingSetSize = pProcessInfo->PeakWorkingSetSize;
                            pProcessArray[index].WorkingSetSize = pProcessInfo->WorkingSetSize;
                            pProcessArray[index].QuotaPeakPagedPoolUsage = pProcessInfo->QuotaPeakPagedPoolUsage;

                            pProcessArray[index].QuotaPagedPoolUsage = pProcessInfo->QuotaPagedPoolUsage;

                            pProcessArray[index].QuotaPeakNonPagedPoolUsage = pProcessInfo->QuotaPeakNonPagedPoolUsage;

                            pProcessArray[index].QuotaNonPagedPoolUsage = pProcessInfo->QuotaNonPagedPoolUsage;

                            pProcessArray[index].PagefileUsage =  pProcessInfo->PagefileUsage;
                            pProcessArray[index].PeakPagefileUsage = pProcessInfo->PeakPagefileUsage;
                            pProcessArray[index].PrivatePageCount = pProcessInfo->PrivatePageCount;
                            pProcessArray[index].ReadOperationCount = pProcessInfo->ReadOperationCount;
                            pProcessArray[index].WriteOperationCount = pProcessInfo->WriteOperationCount;
                            pProcessArray[index].OtherOperationCount = pProcessInfo->OtherOperationCount;
                            pProcessArray[index].ReadTransferCount = pProcessInfo->ReadTransferCount;
                            pProcessArray[index].WriteTransferCount = pProcessInfo->WriteTransferCount;
                            pProcessArray[index].OtherTransferCount = pProcessInfo->OtherTransferCount;

                            pProcessArray[index].GdiHandleCount = 0;

			
                            hProcess= OpenProcess( PROCESS_QUERY_INFORMATION,
                                    FALSE,
                                    PtrToUlong(pProcessInfo->UniqueProcessId) );
                            if( hProcess ) {
                                pProcessArray[index].GdiHandleCount =  GetGuiResources( hProcess, GR_GDIOBJECTS );
                                pProcessArray[index].UsrHandleCount= GetGuiResources( hProcess, GR_USEROBJECTS );
                            CloseHandle( hProcess );
                            }

                            End:
                            TotalOffset += pProcessInfo->NextEntryOffset;

                            pProcessInfo = (PSYSTEM_PROCESS_INFORMATION)&pProcessBuffer[TotalOffset];
                        } //end of for loop

                    } //end of else

                } //end of if


	 if (NT_SUCCESS(Status))
        {
           *pNumberOfProcesses = NumAlloc;
           *ppRelStatProcessInfo = pProcessArray;

            //print some debug messages
            printf("Query system info passed\n");
            printf("%d number of processes \n",*pNumberOfProcesses);
            /*
	        for(i=0; i< *pNumberOfProcesses; i++)
		        {
		            printf("%d%10u%10u%10u%10u%10u%10u%10u\n",
                        pProcessArray[i].UniqueProcessId,
                        pProcessArray[i].WorkingSetSize,
                        pProcessArray[i].QuotaPagedPoolUsage,
                        pProcessArray[i].QuotaNonPagedPoolUsage,
                        pProcessArray[i].PagefileUsage,
                        pProcessArray[i].PrivatePageCount,
                        pProcessArray[i].HandleCount,
                        pProcessArray[i].NumberOfThreads);
    		    }
            */
        }
     else
        {
            *pNumberOfProcesses = 0;
            *ppRelStatProcessInfo = NULL;

            if (pProcessArray)
                LocalFree(pProcessArray);
            pProcessArray = NULL;
            printf("Query system info failed\n");
        }

    if (pProcessBuffer)
        LocalFree(pProcessBuffer);
    pProcessBuffer = NULL;

    //print a debug message to catch errors in case of marshalling or anything
    //else

    printf("Fine before return\n");
    return (RtlNtStatusToDosError(Status));
}

error_status_t
RelStatPoolTagInfo(
                     handle_t h,
                     LPSTR szPoolTag,
                     ULONG *pNumberOfPoolTags,
                     PRELSTAT_POOLTAG_INFO *ppRelStatPoolTagInfo)
{
 PSYSTEM_POOLTAG_INFORMATION PoolInfo;
 #define BUFFER_SIZE 128*1024
 UCHAR CurrentBuffer[BUFFER_SIZE];
 NTSTATUS Status;                   // status from NT api
 ULONG i;
 PRELSTAT_POOLTAG_INFO pPoolTagArray=NULL;
 PRELSTAT_POOLTAG_INFO pPoolTagMatchArray=NULL;
 BOOLEAN filter = FALSE;
 DWORD dwMatchCount = 0;

    printf("Filter specified is %S \n", szPoolTag);

   Status = NtQuerySystemInformation(
                                      SystemPoolTagInformation,
                                      CurrentBuffer,
                                      BUFFER_SIZE,
                                      NULL
                                      );

   PoolInfo = (PSYSTEM_POOLTAG_INFORMATION)CurrentBuffer;
   printf("Query Info returned %x\n",Status);


   if (szPoolTag)          //check to see if pooltag filter specified
        filter = TRUE;

   if(NT_SUCCESS(Status) && (PoolInfo->Count > 0))	
 		{
			printf("%u Number of Tags \n",PoolInfo->Count);
 			pPoolTagArray = MIDL_user_allocate(PoolInfo->Count *
 						sizeof(SYSTEM_POOLTAG));
 			
 			if (!pPoolTagArray)
 			    {
 					Status = STATUS_NO_MEMORY;
 					printf("System out of memory for pooltaginfo\n");
 			    }
             else
                {

 			    for(i=0 ; i < PoolInfo->Count ; i++)
 				    {

                        if (filter && !CheckFilters(&PoolInfo->TagInfo[i],szPoolTag))
                            continue;

                        memcpy(pPoolTagArray[dwMatchCount].Tag, PoolInfo->TagInfo[i].Tag, 4);
                        pPoolTagArray[dwMatchCount].PagedAllocs = PoolInfo->TagInfo[i].PagedAllocs;
 					    pPoolTagArray[dwMatchCount].PagedFrees = PoolInfo->TagInfo[i].PagedFrees;
 					    pPoolTagArray[dwMatchCount].PagedUsed = PoolInfo->TagInfo[i].PagedUsed;
 					    pPoolTagArray[dwMatchCount].NonPagedAllocs =PoolInfo->TagInfo[i].NonPagedAllocs;
 					    pPoolTagArray[dwMatchCount].NonPagedFrees = PoolInfo->TagInfo[i].NonPagedFrees;
 					    pPoolTagArray[dwMatchCount].NonPagedUsed = PoolInfo->TagInfo[i].NonPagedUsed;
                        dwMatchCount++;
 					    //need to include union info
 				    }
                }
 	    }
 	if (NT_SUCCESS(Status))
 		{
            if ((filter) && (dwMatchCount < PoolInfo->Count))
                {
                    //allocate and copy only the matched pooltags

 			        pPoolTagMatchArray = MIDL_user_allocate(dwMatchCount *
 						sizeof(SYSTEM_POOLTAG));
 			
 			        if (!pPoolTagMatchArray)
 			            {
 					        Status = STATUS_NO_MEMORY;
 					        printf("System out of memory for pooltaginfo matches\n");
 			            }

                    for(i=0;i<dwMatchCount;i++)
                    {

                        memcpy(pPoolTagMatchArray[i].Tag, pPoolTagArray[i].Tag,4);
                        pPoolTagMatchArray[i].PagedAllocs = pPoolTagArray[i].PagedAllocs;
                        pPoolTagMatchArray[i].PagedFrees = pPoolTagArray[i].PagedFrees;
                        pPoolTagMatchArray[i].PagedUsed = pPoolTagArray[i].PagedUsed;
                        pPoolTagMatchArray[i].NonPagedAllocs = pPoolTagArray[i].NonPagedAllocs;
                        pPoolTagMatchArray[i].NonPagedFrees = pPoolTagArray[i].NonPagedFrees;
                        pPoolTagMatchArray[i].NonPagedUsed = pPoolTagArray[i].NonPagedUsed;

                    }
 			        *ppRelStatPoolTagInfo = pPoolTagMatchArray;
 			        *pNumberOfPoolTags = dwMatchCount;
		            printf("RelStatPoolTagInfo returned TRUE \n");
			        printf("%u Number of Tags \n",*pNumberOfPoolTags);
                    MIDL_user_free(pPoolTagArray);
                }
            else
                {   // no filter specified or all the tags need to be sent
 			        *ppRelStatPoolTagInfo = pPoolTagArray;
 			        *pNumberOfPoolTags = PoolInfo->Count;
		            printf("RelStatPoolTagInfo returned TRUE \n");
			        printf("%u Number of Tags \n",*pNumberOfPoolTags);
                }
 		}
 	else
 		{
 			*ppRelStatPoolTagInfo = NULL;
 			*pNumberOfPoolTags = 0;
            printf("RelStatPoolTagInfo returned FALSE %x \n",Status);
 		}

 					
    return (RtlNtStatusToDosError(Status));
   //  return ( (NT_SUCCESS(*pResult))?TRUE : FALSE);
 }

error_status_t
RelStatBuildNumber(handle_t h,
                   ULONG* ulBuildNumber)
{
    OSVERSIONINFO osVer;

    osVer.dwOSVersionInfoSize = sizeof(osVer);
    if (GetVersionEx(&osVer))
        {
            *ulBuildNumber = osVer.dwBuildNumber;
            return ERROR_SUCCESS;
        }
    return RtlNtStatusToDosError(GetLastError());
}

error_status_t
RelStatTickCount(handle_t h,
                 ULONG* ulTickCount)
{
    *ulTickCount = GetTickCount();
    return ERROR_SUCCESS;
}

BOOLEAN
CheckSingleFilter (
    PCHAR Tag,
    LPCSTR Filter
    )
{
    ULONG i;
    CHAR tc;
    CHAR fc;


    for ( i = 0; i < 4; i++ ) {
        tc = *Tag++;
        fc = *Filter++;
        if ( fc == '*' ) return TRUE;
        if ( fc == '?' ) continue;
        if ( tc != fc ) return FALSE;
    }
    return TRUE;
}

BOOLEAN
CheckFilters (
    PSYSTEM_POOLTAG TagInfo,
    LPCSTR szTag
    )
{
    BOOLEAN pass = FALSE;
    ULONG i;
    PCHAR tag;

    tag = TagInfo->Tag;
        if ( CheckSingleFilter( tag, szTag ))
            pass = TRUE;


    return pass;
}



//
//  FUNCTIONS: MIDL_user_allocate and MIDL_user_free
//
//  PURPOSE: Used by stubs to allocate and free memory
//           in standard RPC calls. Not used when
//           [enable_allocate] is specified in the .acf.
//
//
//  PARAMETERS:
//    See documentations.
//
//  RETURN VALUE:
//    Exceptions on error.  This is not required,
//    you can use -error allocation on the midl.exe
//    command line instead.
//
//

void * __RPC_USER MIDL_user_allocate(size_t size)
{
    return(HeapAlloc(GetProcessHeap(), HEAP_GENERATE_EXCEPTIONS, size));
}

void __RPC_USER MIDL_user_free( void *pointer)
{
    HeapFree(GetProcessHeap(), 0, pointer);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\remote\makefile.inc ===
$(O)\remoteds.res: remoteds.rc

$(O)\rdsrelay.res: rdsrelay.rc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\relstat\server\service.c ===
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
// PARTICULAR PURPOSE.
//
// Copyright (C) 1993-1997  Microsoft Corporation.  All Rights Reserved.
//
//  MODULE:   service.c
//
//  PURPOSE:  Implements functions required by all services
//            windows.
//
//  FUNCTIONS:
//    main(int argc, char **argv);
//    service_ctrl(DWORD dwCtrlCode);
//    service_main(DWORD dwArgc, LPTSTR *lpszArgv);
//    CmdInstallService();
//    CmdRemoveService();
//    CmdDebugService(int argc, char **argv);
//    ControlHandler ( DWORD dwCtrlType );
//    GetLastErrorText( LPTSTR lpszBuf, DWORD dwSize );
//
//  COMMENTS:
//
//  AUTHOR: Craig Link - Microsoft Developer Support
//


#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <process.h>
#include <tchar.h>

#include "service.h"



// internal variables
SERVICE_STATUS          ssStatus;       // current status of the service
SERVICE_STATUS_HANDLE   sshStatusHandle;
DWORD                   dwErr = 0;
BOOL                    bDebug = FALSE;
TCHAR                   szErr[256];

// internal function prototypes
VOID WINAPI service_ctrl(DWORD dwCtrlCode);
VOID WINAPI service_main(DWORD dwArgc, LPTSTR *lpszArgv);
VOID CmdInstallService();
VOID CmdRemoveService();
VOID CmdDebugService(int argc, char **argv);
BOOL WINAPI ControlHandler ( DWORD dwCtrlType );
LPTSTR GetLastErrorText( LPTSTR lpszBuf, DWORD dwSize );

//
//  FUNCTION: main
//
//  PURPOSE: entrypoint for service
//
//  PARAMETERS:
//    argc - number of command line arguments
//    argv - array of command line arguments
//
//  RETURN VALUE:
//    none
//
//  COMMENTS:
//    main() either performs the command line task, or
//    call StartServiceCtrlDispatcher to register the
//    main service thread.  When the this call returns,
//    the service has stopped, so exit.
//
void _cdecl main(int argc, char **argv)
{
    SERVICE_TABLE_ENTRY dispatchTable[] =
    {
        { TEXT(SZSERVICENAME), (LPSERVICE_MAIN_FUNCTION)service_main },
        { NULL, NULL }
    };

    if ( (argc > 1) &&
         ((*argv[1] == '-') || (*argv[1] == '/')) )
    {
        if ( _stricmp( "install", argv[1]+1 ) == 0 )
        {
            CmdInstallService();
                  
        }
        else if ( _stricmp( "remove", argv[1]+1 ) == 0 )
        {
            CmdRemoveService();
        }
        else if ( _stricmp( "debug", argv[1]+1 ) == 0 )
        {
            bDebug = TRUE;
            CmdDebugService(argc, argv);
        }
        else
        {
            goto dispatch;
        }
        exit(0);
    }

    // if it doesn't match any of the above parameters
    // the service control manager may be starting the service
    // so we must call StartServiceCtrlDispatcher
    dispatch:
        // this is just to be friendly
        printf( "%s -install          to install the service\n", SZAPPNAME );
        printf( "%s -remove           to remove the service\n", SZAPPNAME );
        printf( "%s -debug <params>   to run as a console app for debugging\n", SZAPPNAME );
        printf( "\nStartServiceCtrlDispatcher being called.\n" );
        printf( "This may take several seconds.  Please wait.\n" );

        if (!StartServiceCtrlDispatcher(dispatchTable))
            AddToMessageLog(TEXT("StartServiceCtrlDispatcher failed."));
}



//
//  FUNCTION: service_main
//
//  PURPOSE: To perform actual initialization of the service
//
//  PARAMETERS:
//    dwArgc   - number of command line arguments
//    lpszArgv - array of command line arguments
//
//  RETURN VALUE:
//    none
//
//  COMMENTS:
//    This routine performs the service initialization and then calls
//    the user defined ServiceStart() routine to perform majority
//    of the work.
//
void WINAPI service_main(DWORD dwArgc, LPTSTR *lpszArgv)
{

    // register our service control handler:
    //
    sshStatusHandle = RegisterServiceCtrlHandler( TEXT(SZSERVICENAME), service_ctrl);

    if (!sshStatusHandle)
        goto cleanup;

    // SERVICE_STATUS members that don't change in example
    //
    ssStatus.dwServiceType = SERVICE_WIN32_OWN_PROCESS;
    ssStatus.dwServiceSpecificExitCode = 0;


    // report the status to the service control manager.
    //
    if (!ReportStatusToSCMgr(
        SERVICE_START_PENDING, // service state
        NO_ERROR,              // exit code
        3000))                 // wait hint
        goto cleanup;


    ServiceStart( dwArgc, lpszArgv );

cleanup:

    // try to report the stopped status to the service control manager.
    //
    if (sshStatusHandle)
        (VOID)ReportStatusToSCMgr(
                            SERVICE_STOPPED,
                            dwErr,
                            0);

    return;
}



//
//  FUNCTION: service_ctrl
//
//  PURPOSE: This function is called by the SCM whenever
//           ControlService() is called on this service.
//
//  PARAMETERS:
//    dwCtrlCode - type of control requested
//
//  RETURN VALUE:
//    none
//
//  COMMENTS:
//
VOID WINAPI service_ctrl(DWORD dwCtrlCode)
{
    // Handle the requested control code.
    //
    switch(dwCtrlCode)
    {
        // Stop the service.
        //
        case SERVICE_CONTROL_STOP:
            ReportStatusToSCMgr(SERVICE_STOP_PENDING, NO_ERROR, 0);
            ServiceStop();
            return;

        // Update the service status.
        //
        case SERVICE_CONTROL_INTERROGATE:
            break;

        // invalid control code
        //
        default:
            break;

    }

    ReportStatusToSCMgr(ssStatus.dwCurrentState, NO_ERROR, 0);

}



//
//  FUNCTION: ReportStatusToSCMgr()
//
//  PURPOSE: Sets the current status of the service and
//           reports it to the Service Control Manager
//
//  PARAMETERS:
//    dwCurrentState - the state of the service
//    dwWin32ExitCode - error code to report
//    dwWaitHint - worst case estimate to next checkpoint
//
//  RETURN VALUE:
//    TRUE  - success
//    FALSE - failure
//
//  COMMENTS:
//
BOOL ReportStatusToSCMgr(DWORD dwCurrentState,
                         DWORD dwWin32ExitCode,
                         DWORD dwWaitHint)
{
    static DWORD dwCheckPoint = 1;
    BOOL fResult = TRUE;


    if ( !bDebug ) // when debugging we don't report to the SCM
    {
        if (dwCurrentState == SERVICE_START_PENDING)
            ssStatus.dwControlsAccepted = 0;
        else
            ssStatus.dwControlsAccepted = SERVICE_ACCEPT_STOP;

        ssStatus.dwCurrentState = dwCurrentState;
        ssStatus.dwWin32ExitCode = dwWin32ExitCode;
        ssStatus.dwWaitHint = dwWaitHint;

        if ( ( dwCurrentState == SERVICE_RUNNING ) ||
             ( dwCurrentState == SERVICE_STOPPED ) )
            ssStatus.dwCheckPoint = 0;
        else
            ssStatus.dwCheckPoint = dwCheckPoint++;


        // Report the status of the service to the service control manager.
        //
        if (!(fResult = SetServiceStatus( sshStatusHandle, &ssStatus))) {
            AddToMessageLog(TEXT("SetServiceStatus"));
        }
    }
    return fResult;
}



//
//  FUNCTION: AddToMessageLog(LPTSTR lpszMsg)
//
//  PURPOSE: Allows any thread to log an error message
//
//  PARAMETERS:
//    lpszMsg - text for message
//
//  RETURN VALUE:
//    none
//
//  COMMENTS:
//
VOID AddToMessageLog(LPTSTR lpszMsg)
{
    TCHAR   szMsg[256];
    HANDLE  hEventSource;
    LPTSTR  lpszStrings[2];


    if ( !bDebug )
    {
        dwErr = GetLastError();

        // Use event logging to log the error.
        //
        hEventSource = RegisterEventSource(NULL, TEXT(SZSERVICENAME));

        _stprintf(szMsg, TEXT("%s error: %d"), TEXT(SZSERVICENAME), dwErr);
        lpszStrings[0] = szMsg;
        lpszStrings[1] = lpszMsg;

        if (hEventSource != NULL) {
            ReportEvent(hEventSource, // handle of event source
                EVENTLOG_ERROR_TYPE,  // event type
                0,                    // event category
                0,                    // event ID
                NULL,                 // current user's SID
                2,                    // strings in lpszStrings
                0,                    // no bytes of raw data
                lpszStrings,          // array of error strings
                NULL);                // no raw data

            (VOID) DeregisterEventSource(hEventSource);
        }
    }
}




///////////////////////////////////////////////////////////////////
//
//  The following code handles service installation and removal
//


//
//  FUNCTION: CmdInstallService()
//
//  PURPOSE: Installs the service
//
//  PARAMETERS:
//    none
//
//  RETURN VALUE:
//    none
//
//  COMMENTS:
//
void CmdInstallService()
{
    SC_HANDLE   schService;
    SC_HANDLE   schSCManager;

    TCHAR szPath[512];

    if ( GetModuleFileName( NULL, szPath, 512 ) == 0 )
    {
        _tprintf(TEXT("Unable to install %s - %s\n"), TEXT(SZSERVICEDISPLAYNAME), GetLastErrorText(szErr, 256));
        return;
    }

    schSCManager = OpenSCManager(
                        NULL,                   // machine (NULL == local)
                        NULL,                   // database (NULL == default)
                        SC_MANAGER_ALL_ACCESS   // access required
                        );
    if ( schSCManager )
    {
        schService = CreateService(
            schSCManager,               // SCManager database
            TEXT(SZSERVICENAME),        // name of service
            TEXT(SZSERVICEDISPLAYNAME), // name to display
            SERVICE_ALL_ACCESS,         // desired access
            SERVICE_WIN32_OWN_PROCESS,  // service type
            SERVICE_AUTO_START,
           // SERVICE_DEMAND_START,       // start type
            SERVICE_ERROR_NORMAL,       // error control type
            szPath,                     // service's binary
            NULL,                       // no load ordering group
            NULL,                       // no tag identifier
            TEXT(SZDEPENDENCIES),       // dependencies
            NULL,                       // LocalSystem account
            NULL);                      // no password

        if ( schService )
        {
            _tprintf(TEXT("%s installed.\n"), TEXT(SZSERVICEDISPLAYNAME) );
            if( StartService(schService,0,NULL)==0 )
            {
               _tprintf(TEXT("Service failed to start.  LastError= %d\n"),GetLastError());
            }
            CloseServiceHandle(schService);
        }
        else
        {
            _tprintf(TEXT("CreateService failed - %s\n"), GetLastErrorText(szErr, 256));
        }

        CloseServiceHandle(schSCManager);
    }
    else
        _tprintf(TEXT("OpenSCManager failed - %s\n"), GetLastErrorText(szErr,256));
}



//
//  FUNCTION: CmdRemoveService()
//
//  PURPOSE: Stops and removes the service
//
//  PARAMETERS:
//    none
//
//  RETURN VALUE:
//    none
//
//  COMMENTS:
//
void CmdRemoveService()
{
    SC_HANDLE   schService;
    SC_HANDLE   schSCManager;

    schSCManager = OpenSCManager(
                        NULL,                   // machine (NULL == local)
                        NULL,                   // database (NULL == default)
                        SC_MANAGER_ALL_ACCESS   // access required
                        );
    if ( schSCManager )
    {
        schService = OpenService(schSCManager, TEXT(SZSERVICENAME), SERVICE_ALL_ACCESS);

        if (schService)
        {
            // try to stop the service
            if ( ControlService( schService, SERVICE_CONTROL_STOP, &ssStatus ) )
            {
                _tprintf(TEXT("Stopping %s."), TEXT(SZSERVICEDISPLAYNAME));
                Sleep( 1000 );

                while( QueryServiceStatus( schService, &ssStatus ) )
                {
                    if ( ssStatus.dwCurrentState == SERVICE_STOP_PENDING )
                    {
                        _tprintf(TEXT("."));
                        Sleep( 1000 );
                    }
                    else
                        break;
                }

                if ( ssStatus.dwCurrentState == SERVICE_STOPPED )
                    _tprintf(TEXT("\n%s stopped.\n"), TEXT(SZSERVICEDISPLAYNAME) );
                else
                    _tprintf(TEXT("\n%s failed to stop.\n"), TEXT(SZSERVICEDISPLAYNAME) );

            }

            // now remove the service
            if( DeleteService(schService) )
                _tprintf(TEXT("%s removed.\n"), TEXT(SZSERVICEDISPLAYNAME) );
            else
                _tprintf(TEXT("DeleteService failed - %s\n"), GetLastErrorText(szErr,256));


            CloseServiceHandle(schService);
        }
        else
            _tprintf(TEXT("OpenService failed - %s\n"), GetLastErrorText(szErr,256));

        CloseServiceHandle(schSCManager);
    }
    else
        _tprintf(TEXT("OpenSCManager failed - %s\n"), GetLastErrorText(szErr,256));
}




///////////////////////////////////////////////////////////////////
//
//  The following code is for running the service as a console app
//


//
//  FUNCTION: CmdDebugService(int argc, char ** argv)
//
//  PURPOSE: Runs the service as a console application
//
//  PARAMETERS:
//    argc - number of command line arguments
//    argv - array of command line arguments
//
//  RETURN VALUE:
//    none
//
//  COMMENTS:
//
void CmdDebugService(int argc, char ** argv)
{
    DWORD dwArgc;
    LPTSTR *lpszArgv;

#ifdef UNICODE
    lpszArgv = CommandLineToArgvW(GetCommandLineW(), &(dwArgc) );
#else
    dwArgc   = (DWORD) argc;
    lpszArgv = argv;
#endif

    _tprintf(TEXT("Debugging %s.\n"), TEXT(SZSERVICEDISPLAYNAME));

    SetConsoleCtrlHandler( ControlHandler, TRUE );

    ServiceStart( dwArgc, lpszArgv );
}


//
//  FUNCTION: ControlHandler ( DWORD dwCtrlType )
//
//  PURPOSE: Handled console control events
//
//  PARAMETERS:
//    dwCtrlType - type of control event
//
//  RETURN VALUE:
//    True - handled
//    False - unhandled
//
//  COMMENTS:
//
BOOL WINAPI ControlHandler ( DWORD dwCtrlType )
{
    switch( dwCtrlType )
    {
        case CTRL_BREAK_EVENT:  // use Ctrl+C or Ctrl+Break to simulate
        case CTRL_C_EVENT:      // SERVICE_CONTROL_STOP in debug mode
            _tprintf(TEXT("Stopping %s.\n"), TEXT(SZSERVICEDISPLAYNAME));
            ServiceStop();
            return TRUE;
            break;

    }
    return FALSE;
}

//
//  FUNCTION: GetLastErrorText
//
//  PURPOSE: copies error message text to string
//
//  PARAMETERS:
//    lpszBuf - destination buffer
//    dwSize - size of buffer
//
//  RETURN VALUE:
//    destination buffer
//
//  COMMENTS:
//
LPTSTR GetLastErrorText( LPTSTR lpszBuf, DWORD dwSize )
{
    DWORD dwRet;
    LPTSTR lpszTemp = NULL;

    dwRet = FormatMessage( FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM |FORMAT_MESSAGE_ARGUMENT_ARRAY,
                           NULL,
                           GetLastError(),
                           LANG_NEUTRAL,
                           (LPTSTR)&lpszTemp,
                           0,
                           NULL );

    // supplied buffer is not long enough
    if ( !dwRet || ( (long)dwSize < (long)dwRet+14 ) )
        lpszBuf[0] = TEXT('\0');
    else
    {
        lpszTemp[lstrlen(lpszTemp)-2] = TEXT('\0');  //remove cr and newline character
        _stprintf( lpszBuf, TEXT("%s (0x%x)"), lpszTemp, GetLastError() );
    }

    if ( lpszTemp )
        LocalFree((HLOCAL) lpszTemp );

    return lpszBuf;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\remote\client.c ===
/******************************************************************************\
*       This is a part of the Microsoft Source Code Samples.
*       Copyright 1992 - 1997 Microsoft Corporation.
*       All rights reserved.
*       This source code is only intended as a supplement to
*       Microsoft Development Tools and/or WinHelp documentation.
*       See these sources for detailed information regarding the
*       Microsoft samples programs.
\******************************************************************************/

/*++

Copyright 1992 - 1997 Microsoft Corporation

Module Name:

    Client.c

Abstract:

    The Client component of Remote. Connects to the remote
    server using named pipes. It sends its stdin to
    the server and output everything from server to
    its stdout.

Author:

    Rajivendra Nath  2-Jan-1992
    Dave Hart        Summer 1997   single-pipe operation

Environment:

    Console App. User mode.

Revision History:

--*/

#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <process.h>
#include <io.h>
#include <string.h>
#include "Remote.h"

BOOL fAsyncPipe = TRUE;    // need this so server has it TRUE


HANDLE*
EstablishSession(
    char *server,
    char *pipe
    );

DWORD
WINAPI
SendServerInp(
    LPVOID pvParam
    );

BOOL
FilterClientInp(
    char *buff,
    int count
    );


BOOL
Mych(
    DWORD ctrlT
    );

VOID
SendMyInfo(
    PHANDLE Pipes
    );


#define ZERO_LENGTH_READ_LIMIT  200

HANDLE MyStdInp;
HANDLE MyStdOut;

//
// ReadPipe and WritePipe are referenced by multiple
// threads so need to be volatile.
//

volatile HANDLE ReadPipe;
volatile HANDLE WritePipe;


CONSOLE_SCREEN_BUFFER_INFO csbi;

char   MyEchoStr[30];
BOOL   CmdSent;
DWORD  LinesToSend=LINESTOSEND;

VOID
Client(
    char* Server,
    char* Pipe
    )
{
    HANDLE *Connection;
    DWORD  dwThreadID;
    HANDLE hThread;
    DWORD  cb;
    OVERLAPPED ol;
    char   rgchBuf[1024];
    DWORD  dwZeroCount = 0;
    CWCDATA cwcData = {NULL};


    MyStdInp=GetStdHandle(STD_INPUT_HANDLE);
    MyStdOut=GetStdHandle(STD_OUTPUT_HANDLE);

    printf("**************************************\n");
    printf("***********     REMOTE    ************\n");
    printf("***********     CLIENT    ************\n");
    printf("**************************************\n");

    if ((Connection=EstablishSession(Server,Pipe))==NULL)
        return;


    ReadPipe=Connection[0];
    WritePipe=Connection[1];

    SetConsoleCtrlHandler((PHANDLER_ROUTINE)Mych,TRUE);

    // Start Thread For Client --> Server Flow
    hThread = (HANDLE)
        _beginthreadex(
            NULL,             // security
            0,                // default stack size
            SendServerInp,    // thread proc
            NULL,             // parm
            0,                // not suspended
            &dwThreadID
            );

    if ( ! hThread)
    {

        Errormsg("REMOTE /C Could Not Create Thread.");
        return;
    }


    ZeroMemory(&ol, sizeof(ol));

    ol.hEvent =
        CreateEvent(
            NULL,      // security
            TRUE,      // auto-reset
            FALSE,     // initially nonsignaled
            NULL       // unnamed
            );

    while (ReadFileSynch(ReadPipe, rgchBuf, sizeof rgchBuf, &cb, 0, &ol)) {

        if (cb) {
           // If we are interested in colors, do special output
           if ( pWantColorLines() )
           {
               if ( !WriteConsoleWithColor( MyStdOut,
                                            rgchBuf,
                                            cb,
                                            &cwcData ) )
               {
                   break;
               }
           }
           else
           {
               if ( ! WriteFile(MyStdOut, rgchBuf, cb, &cb, NULL)) {
                   break;
               }
           }
           dwZeroCount = 0;
        } else {
            if (++dwZeroCount > ZERO_LENGTH_READ_LIMIT) {

                //
                // If we get a bunch of zero length reads in a row,
                // something's broken, don't loop forever.
                // (bug #115866).
                //

                printf("\nREMOTE: bailing out, server must have gone away.\n");
                break;
            }
        }

    }

    CloseHandle(ol.hEvent);

    printf("*** SESSION OVER ***");
    fflush(stdout);

    //
    // Terminate the keyboard reading thread.
    //

    TerminateThread(hThread, 0);
    CloseHandle(hThread);
    CloseClientPipes();

    printf("\n");
    fflush(stdout);

}


DWORD
WINAPI
SendServerInp(
    LPVOID pvParam
    )
{
    DWORD  dread,dwrote;
    OVERLAPPED ol;
    char buff[512];

    UNREFERENCED_PARAMETER(pvParam);

    ZeroMemory(&ol, sizeof(ol));

    ol.hEvent =
        CreateEvent(
            NULL,      // security
            TRUE,      // auto-reset
            FALSE,     // initially nonsignaled
            NULL       // unnamed
            );


    while(ReadFile(MyStdInp,buff,sizeof buff,&dread,NULL))
    {
        if (FilterClientInp(buff,dread))
            continue;
        if (!WriteFileSynch(WritePipe,buff,dread,&dwrote,0,&ol))
            break;
    }

    CloseClientPipes();

    return 0;
}



BOOL
FilterClientInp(
    char *buff,
    int count
    )
{

    if (count==0)
        return(TRUE);

    if (buff[0]==2)     // Adhoc screening of ^B so that i386kd/mipskd
        return(TRUE);   // do not terminate.

    if (buff[0]==COMMANDCHAR)
    {
        switch (buff[1])
        {
        case 'k':
        case 'K':
        case 'q':
        case 'Q':
              CloseClientPipes();
              return(FALSE);

        case 'h':
        case 'H':
              printf("%cM : Send Message\n",COMMANDCHAR);
              printf("%cP : Show Popup on Server\n",COMMANDCHAR);
              printf("%cS : Status of Server\n",COMMANDCHAR);
              printf("%cQ : Quit client\n",COMMANDCHAR);
              printf("%cH : This Help\n",COMMANDCHAR);
              return(TRUE);

        default:
              return(FALSE);
        }

    }
    return(FALSE);
}

BOOL
Mych(
   DWORD ctrlT
   )

{
    char  c[2];
    DWORD tmp;
    OVERLAPPED ol;

    c[0]=CTRLC;

    if (ctrlT==CTRL_C_EVENT)
    {
        ZeroMemory(&ol, sizeof(ol));

        ol.hEvent =
            CreateEvent(
                NULL,      // security
                TRUE,      // auto-reset
                FALSE,     // initially nonsignaled
                NULL       // unnamed
                );

        if (INVALID_HANDLE_VALUE != WritePipe &&
            !WriteFileSynch(WritePipe,c,1,&tmp,0,&ol))
        {
            CloseHandle(ol.hEvent);
            Errormsg("Error Sending ^c");
            return(FALSE);
        }
        CloseHandle(ol.hEvent);
        return(TRUE);
    }
    if ((ctrlT==CTRL_BREAK_EVENT)||
        (ctrlT==CTRL_CLOSE_EVENT)||
        (ctrlT==CTRL_LOGOFF_EVENT)||
        (ctrlT==CTRL_SHUTDOWN_EVENT)
       ) {

       CloseClientPipes();
    }
    return(FALSE);
}

VOID
CloseClientPipes(
    VOID
    )
{
    HANDLE WriteHandle, ReadHandle;

    WriteHandle = (HANDLE) InterlockedExchangePointer(
        (PVOID *)   &WritePipe,
        INVALID_HANDLE_VALUE
        );

    if (INVALID_HANDLE_VALUE != WriteHandle) {

        CloseHandle(WriteHandle);

        ReadHandle = (HANDLE) InterlockedExchangePointer(
            (PVOID *) &ReadPipe,
            INVALID_HANDLE_VALUE
            );

        if (INVALID_HANDLE_VALUE != ReadHandle &&
            WriteHandle != ReadHandle) {

            CloseHandle(ReadHandle);
        }
    }
}


VOID
HandleConnectError(
    char *server,
    char *srvpipename
    )
{
    DWORD Err = GetLastError();
    char  msg[128];

    Errormsg("*** Unable to Connect ***");

    //
    // Print a helpful message
    //

    switch(Err)
    {
        case ERROR_FILE_NOT_FOUND:
            sprintf(msg,"invalid pipe name \"%s\"", srvpipename);
            break;

        case ERROR_BAD_NETPATH:
            sprintf(msg,"\\\\%s not found", server);
            break;

        default:
            FormatMessageA(FORMAT_MESSAGE_FROM_SYSTEM|
                           FORMAT_MESSAGE_IGNORE_INSERTS,
                           NULL, Err, 0, msg, sizeof(msg), NULL);
            break;

    }

    printf("Diagnosis: %s\n",msg);

    //
    // If the machine exists but the pipe doesn't do an
    // automatic remote /q to list pipes available on
    // that machine.
    //

    if (ERROR_FILE_NOT_FOUND == Err) {

        printf("\nREMOTE /Q %s\n", server);
        fflush(stdout);
        QueryRemotePipes(server);
    }
}



HANDLE*
EstablishSession(
    char *server,
    char *srvpipename
    )
{
    extern BOOL bForceTwoPipes;
    static HANDLE PipeH[2];
    char   pipenameSrvIn[200];
    char   pipenameSrvOut[200];
    BOOL   fOldServer;
    DWORD  dwError;
    DWORD  RetryCount = 0;

    //
    // Since in single-pipe operation we'll be using the same
    // pipe in two threads, we have to open the handles for
    // overlapped operation, even though we always want
    // synchronous operation.
    //

    sprintf(pipenameSrvIn ,SERVER_READ_PIPE ,server,srvpipename);
    sprintf(pipenameSrvOut,SERVER_WRITE_PIPE,server,srvpipename);

    if (bForceTwoPipes) {

        dwError = ERROR_NOT_SUPPORTED;

    } else {

      RetrySrvBidi:

        if (INVALID_HANDLE_VALUE ==
               (PipeH[1] =
                    CreateFile(
                        pipenameSrvIn,
                        GENERIC_READ | GENERIC_WRITE,
                        0,
                        NULL,
                        OPEN_EXISTING,
                        FILE_FLAG_OVERLAPPED,
                        NULL
                        ))) {

            dwError = GetLastError();

            if (ERROR_PIPE_BUSY == dwError) {

                printf( "All pipe instances busy, waiting for another...\n");

                WaitNamedPipe(
                    pipenameSrvIn,
                    15000
                    );

                if (RetryCount++ < 6) {
                    goto RetrySrvBidi;
                }
            }

            if (ERROR_ACCESS_DENIED != dwError &&
                ERROR_NOT_SUPPORTED != dwError) {

                HandleConnectError(server, srvpipename);
                return NULL;
            }

        } else {

            PipeH[0] = PipeH[1];
            fAsyncPipe = TRUE;

            printf("Connected...\n\n");

            SendMyInfo(PipeH);

            return PipeH;
        }
    }


    //
    // Old remote servers don't allow you to open the
    // server IN pipe for READ access, so go down the
    // old path, notably opening OUT first so the
    // server knows we'll be using both pipes.  We'll
    // also come down this path on Win95 because
    // it doesn't allow you to open an overlapped
    // pipe handle.  Or if remote /c mach pipe /2 is used.
    //

    fOldServer = (ERROR_ACCESS_DENIED == dwError);

  RetrySrvOut:

    if (INVALID_HANDLE_VALUE ==
            (PipeH[0] =
                CreateFile(
                    pipenameSrvOut,
                    GENERIC_READ,
                    0,
                    NULL,
                    OPEN_EXISTING,
                    0,
                    NULL
                    ))) {

        if (ERROR_PIPE_BUSY == GetLastError()) {

            printf( "All OUT pipe instances busy, waiting for another...\n");

            WaitNamedPipe(
                pipenameSrvOut,
                32000              // server recycles abandoned
                );                 // OUT pipe after two minutes

            if (RetryCount++ < 6) {
                goto RetrySrvOut;
            }
        }

        HandleConnectError(server, srvpipename);
        return NULL;

    }


  RetrySrvIn:

    if (INVALID_HANDLE_VALUE ==
           (PipeH[1] =
               CreateFile(
                    pipenameSrvIn,
                    GENERIC_WRITE,
                    0,
                    NULL,
                    OPEN_EXISTING,
                    0,
                    NULL
                    ))) {

        dwError = GetLastError();

        if (ERROR_PIPE_BUSY == dwError) {

            printf( "All IN pipe instances busy, waiting for another...\n");

            WaitNamedPipe(
                pipenameSrvIn,
                15000
                );

            if (RetryCount++ < 6) {
                goto RetrySrvIn;
           }
        }

        HandleConnectError(server, srvpipename);
        return NULL;

    }

    fAsyncPipe = FALSE;

    printf("Connected... %s\n\n",
           fOldServer
               ? "to two-pipe remote server."
               : "using two pipes."
           );

    SendMyInfo(PipeH);

    return PipeH;
}



VOID
SendMyInfo(
    PHANDLE pipeH
    )
{
    HANDLE rPipe=pipeH[0];
    HANDLE wPipe=pipeH[1];

    DWORD  hostlen;
    WORD   BytesToSend=sizeof(SESSION_STARTUPINFO);
    DWORD  tmp;
    OVERLAPPED ol;
    SESSION_STARTUPINFO ssi;
    SESSION_STARTREPLY  ssr;

    ol.hEvent =
        CreateEvent(
            NULL,      // security
            TRUE,      // auto-reset
            FALSE,     // initially nonsignaled
            NULL       // unnamed
            );

    ssi.Size=BytesToSend;
    ssi.Version=VERSION;

    hostlen = sizeof(ssi.ClientName) / sizeof(ssi.ClientName[0]);
    GetComputerName(ssi.ClientName, &hostlen);
    ssi.LinesToSend=LinesToSend;
    ssi.Flag=ClientToServerFlag;

    {
        DWORD NewCode=MAGICNUMBER;
        char  Name[MAX_COMPUTERNAME_LENGTH+1];

        strcpy(Name,(char *)ssi.ClientName);
        memcpy(&Name[11],(char *)&NewCode,sizeof(NewCode));

        //
        // The server needs to know if we're doing single-pipe
        // operation so it can complete the connection properly.
        // So if we are, change the first byte of the first
        // send (the computername, which is later superceded
        // by the one in the SESSION_STARTUPINFO structure)
        // to an illegal computername character, question mark.
        //

        if (wPipe == rPipe) {

             Name[0] = '?';
        }

        WriteFileSynch(wPipe,(char *)Name,HOSTNAMELEN-1,&tmp,0,&ol);
        ReadFileSynch(rPipe ,(char *)&ssr.MagicNumber,sizeof(ssr.MagicNumber),&tmp,0,&ol);

        if (ssr.MagicNumber!=MAGICNUMBER)
        {
            SetLastError(ERROR_INVALID_PARAMETER);
            ErrorExit("Pipe connected but server not recognized.\n");
        }

        //Get Rest of the info-its not the old server

        ReadFileSynch(
            rPipe,
            (char *)&ssr + sizeof(ssr.MagicNumber),
            sizeof(ssr)-sizeof(ssr.MagicNumber),
            &tmp,
            0,
            &ol
            );

    }

    if (!WriteFileSynch(wPipe,(char *)&ssi,BytesToSend,&tmp,0,&ol))
    {
       Errormsg("INFO Send Error");
    }

    CloseHandle(ol.hEvent);
}


VOID
QueryRemotePipes(
    char* pszServer
    )
{
    HANDLE hQPipe;
    DWORD  dwRead;
    DWORD  dwError;
    char   fullname[400];
    char*  msg;
    int    msgLen;

    if (pszServer[0] == '\\' && pszServer[1] == '\\') {
        pszServer += 2;
    }

    printf("Querying server \\\\%s\n", pszServer);

    sprintf(fullname, QUERY_DEBUGGERS_PIPE, pszServer);

    //
    // Send request and display the query result
    //

    hQPipe = CreateFile(fullname,
        GENERIC_READ | GENERIC_WRITE,
        0,
        NULL,
        OPEN_EXISTING,
        FILE_ATTRIBUTE_NORMAL,
        NULL);

    if(hQPipe == INVALID_HANDLE_VALUE) {

        dwError = GetLastError();

        if (ERROR_FILE_NOT_FOUND == dwError) {

            printf("No Remote servers running on \\\\%s\n", pszServer);

        } else if (ERROR_BAD_NETPATH == dwError) {

            printf("\\\\%s not found on the network\n", pszServer);

        } else {

            FormatMessageA(FORMAT_MESSAGE_FROM_SYSTEM |
                           FORMAT_MESSAGE_IGNORE_INSERTS,
                           NULL, dwError, 0,
                           fullname, sizeof(fullname), NULL);

            printf("Can't query server %s: %s\n", pszServer, fullname);
        }

        return;
    }

    //  Send Query Command
    if(!WriteFile(hQPipe, "q", 1, &dwRead, NULL)
        || (dwRead != 1))
    {
        printf("\nError: Can't send command\n");
        goto failure;
    }

    if(!ReadFile(hQPipe,
             &msgLen,
             sizeof(int),      // read msg dimension
             &dwRead,
             NULL)
        || (dwRead != sizeof(int)))
    {
        printf("\nError: Can't read message\n");
        goto failure;
    }

    if(!msgLen)
    {
        printf("\nNo visible sessions on server %s", pszServer);
        goto failure;
    }

    if(msgLen > 65535)        // error
    {
        printf("Error querying server %s, got %d for msg length, 65535 max.\n",
               pszServer,
               msgLen
               );
        goto failure;
    }

    // +1 for null terminator
    if((msg = (char*)malloc( (msgLen +1) *sizeof(char))) == NULL)
    {
        printf("\nOut of memory\n");
        goto failure;
    }

    ReadFile(hQPipe,
             msg,
             msgLen * sizeof(char),      // read msg
             &dwRead,
             NULL);
    // Make sure the string is terminated
    msg[dwRead] = 0;

    printf("\nVisible sessions on server %s:\n\n", pszServer);

    printf("%s\n", msg);
    free(msg);

 failure:

    CloseHandle(hQPipe);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\relstat\server\service.h ===
//
// Copyright (C) 1993-1997  Microsoft Corporation.  All Rights Reserved.
//
//  MODULE: service.h
//
//  AUTHOR: Craig Link
//
//
//  Comments:  The use of this header file and the accompanying service.c
//  file simplifies the process of writting a service.  You as a developer
//  simply need to follow the TODO's outlined in this header file, and 
//  implement the ServiceStart() and ServiceStop() functions.
//  
//  There is no need to modify the code in service.c.  Just add service.c
//  to your project and link with the following libraries...
//
//  libcmt.lib kernel32.lib advapi.lib shell32.lib
//
//  This code also supports unicode.  Be sure to compile both service.c and
//  and code #include "service.h" with the same Unicode setting.
//
//  Upon completion, your code will have the following command line interface
//
//  <service exe> -?                to display this list
//  <service exe> -install          to install the service
//  <service exe> -remove           to remove the service
//  <service exe> -debug <params>   to run as a console app for debugging
//
//  Note: This code also implements Ctrl+C and Ctrl+Break handlers
//        when using the debug option.  These console events cause
//        your ServiceStop routine to be called
//
//        Also, this code only handles the OWN_SERVICE service type
//        running in the LOCAL_SYSTEM security context.
//
//        To control your service ( start, stop, etc ) you may use the
//        Services control panel applet or the NET.EXE program.
//
//        To aid in writing/debugging service, the
//        SDK contains a utility (MSTOOLS\BIN\SC.EXE) that
//        can be used to control, configure, or obtain service status.
//        SC displays complete status for any service/driver
//        in the service database, and allows any of the configuration
//        parameters to be easily changed at the command line.
//        For more information on SC.EXE, type SC at the command line.
//

#ifndef _SERVICE_H
#define _SERVICE_H


#ifdef __cplusplus
extern "C" {
#endif


//////////////////////////////////////////////////////////////////////////////
//// todo: change to desired strings
////
// name of the executable
#define SZAPPNAME            "RelStat"
// internal name of the service
#define SZSERVICENAME        "RelstatRPCService"
// displayed name of the service
#define SZSERVICEDISPLAYNAME "Relstat RPC Service"
// list of service dependencies - "dep1\0dep2\0\0"
#define SZDEPENDENCIES       "RPCSS\0\0"
//////////////////////////////////////////////////////////////////////////////



//////////////////////////////////////////////////////////////////////////////
//// todo: ServiceStart()must be defined by in your code.
////       The service should use ReportStatusToSCMgr to indicate
////       progress.  This routine must also be used by StartService()
////       to report to the SCM when the service is running.
////
////       If a ServiceStop procedure is going to take longer than
////       3 seconds to execute, it should spawn a thread to
////       execute the stop code, and return.  Otherwise, the
////       ServiceControlManager will believe that the service has
////       stopped responding
////
VOID ServiceStart(DWORD dwArgc, LPTSTR *lpszArgv);
VOID ServiceStop();
//////////////////////////////////////////////////////////////////////////////



//////////////////////////////////////////////////////////////////////////////
//// The following are procedures which
//// may be useful to call within the above procedures,
//// but require no implementation by the user.
//// They are implemented in service.c

//
//  FUNCTION: ReportStatusToSCMgr()
//
//  PURPOSE: Sets the current status of the service and
//           reports it to the Service Control Manager
//
//  PARAMETERS:
//    dwCurrentState - the state of the service
//    dwWin32ExitCode - error code to report
//    dwWaitHint - worst case estimate to next checkpoint
//
//  RETURN VALUE:
//    TRUE  - success 
//    FALSE - failure
//
BOOL ReportStatusToSCMgr(DWORD dwCurrentState, DWORD dwWin32ExitCode, DWORD dwWaitHint);


//
//  FUNCTION: AddToMessageLog(LPTSTR lpszMsg)
//
//  PURPOSE: Allows any thread to log an error message
//
//  PARAMETERS:
//    lpszMsg - text for message
//
//  RETURN VALUE:
//    none
//
void AddToMessageLog(LPTSTR lpszMsg);
//////////////////////////////////////////////////////////////////////////////


#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\remote\pipeex.c ===
/******************************************************************************\
*       This is a part of the Microsoft Source Code Samples. 
*       Copyright 1995 - 1997 Microsoft Corporation.
*       All rights reserved. 
*       This source code is only intended as a supplement to 
*       Microsoft Development Tools and/or WinHelp documentation.
*       See these sources for detailed information regarding the 
*       Microsoft samples programs.
\******************************************************************************/

/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    pipeex.c

Abstract:

    CreatePipe-like function that lets one or both handles be overlapped

Author:

    Dave Hart  Summer 1997

Revision History:

--*/

#include <windows.h>
#include <stdio.h>

ULONG PipeSerialNumber;

BOOL
APIENTRY
MyCreatePipeEx(
    OUT LPHANDLE lpReadPipe,
    OUT LPHANDLE lpWritePipe,
    IN LPSECURITY_ATTRIBUTES lpPipeAttributes,
    IN DWORD nSize,
    DWORD dwReadMode,
    DWORD dwWriteMode
    )

/*++

Routine Description:

    The CreatePipeEx API is used to create an anonymous pipe I/O device.
    Unlike CreatePipe FILE_FLAG_OVERLAPPED may be specified for one or
    both handles.
    Two handles to the device are created.  One handle is opened for
    reading and the other is opened for writing.  These handles may be
    used in subsequent calls to ReadFile and WriteFile to transmit data
    through the pipe.

Arguments:

    lpReadPipe - Returns a handle to the read side of the pipe.  Data
        may be read from the pipe by specifying this handle value in a
        subsequent call to ReadFile.

    lpWritePipe - Returns a handle to the write side of the pipe.  Data
        may be written to the pipe by specifying this handle value in a
        subsequent call to WriteFile.

    lpPipeAttributes - An optional parameter that may be used to specify
        the attributes of the new pipe.  If the parameter is not
        specified, then the pipe is created without a security
        descriptor, and the resulting handles are not inherited on
        process creation.  Otherwise, the optional security attributes
        are used on the pipe, and the inherit handles flag effects both
        pipe handles.

    nSize - Supplies the requested buffer size for the pipe.  This is
        only a suggestion and is used by the operating system to
        calculate an appropriate buffering mechanism.  A value of zero
        indicates that the system is to choose the default buffering
        scheme.

Return Value:

    TRUE - The operation was successful.

    FALSE/NULL - The operation failed. Extended error status is available
        using GetLastError.

--*/

{
    HANDLE ReadPipeHandle, WritePipeHandle;
    DWORD dwError;
    UCHAR PipeNameBuffer[ MAX_PATH ];

    //
    // Only one valid OpenMode flag - FILE_FLAG_OVERLAPPED
    //

    if ((dwReadMode | dwWriteMode) & (~FILE_FLAG_OVERLAPPED)) {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    //
    //  Set the default timeout to 120 seconds
    //

    if (nSize == 0) {
        nSize = 4096;
        }

    sprintf( PipeNameBuffer,
             "\\\\.\\Pipe\\RemoteExeAnon.%08x.%08x",
             GetCurrentProcessId(),
             PipeSerialNumber++
           );

    ReadPipeHandle = CreateNamedPipeA(
                         PipeNameBuffer,
                         PIPE_ACCESS_INBOUND | dwReadMode,
                         PIPE_TYPE_BYTE | PIPE_WAIT,
                         1,             // Number of pipes
                         nSize,         // Out buffer size
                         nSize,         // In buffer size
                         120 * 1000,    // Timeout in ms
                         lpPipeAttributes
                         );

    if (! ReadPipeHandle) {
        return FALSE;
    }

    WritePipeHandle = CreateFileA(
                        PipeNameBuffer,
                        GENERIC_WRITE,
                        0,                         // No sharing
                        lpPipeAttributes,
                        OPEN_EXISTING,
                        FILE_ATTRIBUTE_NORMAL | dwWriteMode,
                        NULL                       // Template file
                      );

    if (INVALID_HANDLE_VALUE == WritePipeHandle) {
        dwError = GetLastError();
        CloseHandle( ReadPipeHandle );
        SetLastError(dwError);
        return FALSE;
    }

    *lpReadPipe = ReadPipeHandle;
    *lpWritePipe = WritePipeHandle;
    return( TRUE );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\remote\rdsrelay.c ===
//
// rdsrelay.c
//
// Relays recieved remote.exe broadcasts (for remoteds.exe)
// to another domain/workgroup.
//
// WARNING:  There are no checks in this program for looping
//           relays, only one copy should be run per network.
//           I wrote this to relay ntdev remote.exe broadcasts
//           to ntwksta so that remoteds.exe running on \\ntstress
//           can see remote servers in both ntdev and ntwksta.
//           \\ntstress is in ntwksta.
//
// Usage:
//
//    rdsrelay <targetdomain>
//
//
// Dave Hart (davehart) written Aug 29, 1997.
//
// Copyright 1997 Microsoft Corp.
//
//

#include <windows.h>
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <process.h>

typedef char BUF[1024];

int
__cdecl
main(
    int argc,
    char **argv
    )
{
    char   *pszReceiveMailslot = "\\\\.\\MAILSLOT\\REMOTE\\DEBUGGERS";
    HANDLE  hReceiveMailslot;
    HANDLE  hSendMailslot;
    BOOL    b;
    DWORD   dwErr;
    int     nReceived = 0;
    int     nRelayed = 0;
    int     iBuf;
    DWORD   cbWritten;
    DWORD   rgcbBuf[2];
    char    szSendMailslot[128];
    BUF     rgBuf[2];

    if (argc != 2) {
        printf("Usage: \n"
               "rdsrelay <targetdomain>\n");
        return 1;
    }

    sprintf(szSendMailslot, "\\\\%s\\MAILSLOT\\REMOTE\\DEBUGGERS", argv[1]);
    printf("Relaying remote.exe broadcasts to %s.\n", szSendMailslot);

    hReceiveMailslot =
        CreateMailslot(
            pszReceiveMailslot,
            0,
            MAILSLOT_WAIT_FOREVER,
            NULL
            );

    if (INVALID_HANDLE_VALUE == hReceiveMailslot) {

        dwErr = GetLastError();

        if (ERROR_ALREADY_EXISTS == dwErr) {
            printf("Cannot receive on %s,\n"
                   "is rdsrelay or remoteds already running on this machine?\n",
                   pszReceiveMailslot);
        } else {
            printf("CreateMailslot(%s) failed error %d\n",
                    pszReceiveMailslot,
                    dwErr);
        }
        return 2;
    }

    hSendMailslot =
        CreateFile(
            szSendMailslot,
            GENERIC_WRITE,
            FILE_SHARE_WRITE,
            NULL,
            OPEN_EXISTING,
            0,
            NULL
            );

    if (INVALID_HANDLE_VALUE == hSendMailslot) {

        printf("CreateFile(%s) failed error %d\n",
                pszReceiveMailslot,
                GetLastError());
        return 3;
    }

    iBuf = 0;
    ZeroMemory(rgcbBuf, sizeof(rgcbBuf));
    ZeroMemory(rgBuf, sizeof(rgBuf));

    while(TRUE)
    {
        printf("\r%d received, %d relayed", nReceived, nRelayed);

        //
        // Multiple transports mean we get duplicates for
        // each transport shared by us and the sender.
        // Meanwhile when we relay on we generate duplicates
        // for each transport shared by this machine and
        // the remoteds.exe receiver(s) on the domain we're
        // relaying to.  They will eliminate duplicates, but
        // to avoid exponential effects we should eliminate
        // duplicates before relaying.  Thus the two buffers
        // in rgBuf, we alternate between them, and compare
        // the two to see if the last and this are dupes.
        //

        b = ReadFile(
                hReceiveMailslot,
                rgBuf[ iBuf ],
                sizeof(rgBuf[ iBuf ]),
                &rgcbBuf[ iBuf ],
                NULL
                );

        if (! b) {
            printf("ReadFile(hReceiveMailslot) failed error %d\n", GetLastError());
            return 4;
        }

        nReceived++;

        if ( rgcbBuf[0] == rgcbBuf[1] &&
             ! memcmp(rgBuf[0], rgBuf[1], rgcbBuf[0])) {

            continue;               // duplicate
        }

        b = WriteFile(
                hSendMailslot,
                rgBuf[ iBuf ],
                rgcbBuf[ iBuf ],
                &cbWritten,
                NULL
                );

        if (! b) {
            printf("WriteFile(hSendMailslot) failed error %d\n", GetLastError());
            return 5;
        }

        if (cbWritten != rgcbBuf[ iBuf ]) {
            printf("WriteFile(hSendMailslot) wrote %d instead of %d.\n", cbWritten, rgcbBuf[ iBuf ]);
            return 6;
        }

        nRelayed++;

        iBuf = !iBuf;

    }

    return 0;    // never executed
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\remote\remote.c ===
/******************************************************************************\
*       This is a part of the Microsoft Source Code Samples.
*       Copyright 1993 - 1997 Microsoft Corporation.
*       All rights reserved.
*       This source code is only intended as a supplement to
*       Microsoft Development Tools and/or WinHelp documentation.
*       See these sources for detailed information regarding the
*       Microsoft samples programs.
\******************************************************************************/

/*++

Copyright 1993 - 1997 Microsoft Corporation

Module Name:

    Remote.c

Abstract:

    This module contains the main() entry point for Remote.
    Calls the Server or the Client depending on the first parameter.


Author:

    Rajivendra Nath  2-Jan-1993

Environment:

    Console App. User mode.

Revision History:

--*/


#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include "Remote.h"

char   HostName[HOSTNAMELEN];
char*  ChildCmd;
char*  PipeName;
char*  ServerName;
char * DaclNames[ MAX_DACL_NAMES ];
DWORD  DaclNameCount = 0;
char * DaclDenyNames[ MAX_DACL_NAMES ];
DWORD  DaclDenyNameCount = 0 ;
HANDLE MyStdOut;
HANDLE hAttachedProcess = INVALID_HANDLE_VALUE;
HANDLE hAttachedWriteChildStdIn = INVALID_HANDLE_VALUE;
HANDLE hAttachedReadChildStdOut = INVALID_HANDLE_VALUE;

BOOL   IsAdvertise;
DWORD  ClientToServerFlag;
BOOL   bForceTwoPipes;

typedef struct _tagKeywordAndColor
{
    char *szKeyword;
    WORD color;
    struct _tagKeywordAndColor *next;
} KeywordAndColor;
KeywordAndColor *pKeyColors;

char* ColorList[]={"black" ,"blue" ,"green" ,"cyan" ,"red" ,"purple" ,"yellow" ,"white",
                   "lblack","lblue","lgreen","lcyan","lred","lpurple","lyellow","lwhite"};

typedef enum { LINE_TOO_LONG } WARNING_MESSAGE;

VOID
DisplayWarning(
    WARNING_MESSAGE warn
    );

WORD
GetColorNum(
    char* color
    );

VOID
SetColor(
    WORD attr
    );

BOOL
GetColorFromBuffer(
    char **ppBuffer,
    char *pBufferInvalid,
    WORD *color,
    BOOL bStayOnLine
    );

VOID
AssocKeysAndColors(
    KeywordAndColor **ppKeyAndColors,
    char *szFileName
    );

BOOL
GetNextConnectInfo(
    char** SrvName,
    char** PipeName
    );



CONSOLE_SCREEN_BUFFER_INFO csbiOriginal;

int
__cdecl
main(
    int    argc,
    char** argv
    )
{
    WORD  RunType;              // Server or Client end of Remote
    DWORD len=HOSTNAMELEN;
    int   i, FirstArg;

    char  sTitle[120];          // New Title
    char  orgTitle[200];        // Old Title
    BOOL  bPromptForArgs=FALSE; // Is /P option
    WORD  wAttrib;              // Console Attributes
    int   privacy;              // Allows exposing or hidng sessions to remote /q
    BOOL  Deny ;

    GetComputerName((LPTSTR)HostName,&len);

    MyStdOut = GetStdHandle(STD_OUTPUT_HANDLE);

    if (GetConsoleScreenBufferInfo(MyStdOut,&csbiOriginal)) {

        wAttrib = csbiOriginal.wAttributes;
        if (!GetConsoleTitle(orgTitle,sizeof(orgTitle))) {
            orgTitle[0] = 0;
        }

    } else {

        //
        // either stdout is a pipe, or it wasn't opened for
        // GENERIC_READ along with GENERIC_WRITE, in which
        // case our color manipulations will work so we need
        // to pick default colors.
        //

        wAttrib = FOREGROUND_GREEN |
                  FOREGROUND_INTENSITY;

        orgTitle[0] = 0;
    }

    privacy = PRIVACY_DEFAULT;

    pKeyColors = NULL;


    //
    // Parameter Processing
    //
    // For Server:
    // Remote /S <Executable>  <PipeName> [Optional Params]
    //
    // For Client:
    // Remote /C <Server Name> <PipeName> [Optional Params]
    // or
    // Remote /P
    // This will loop continously prompting for different
    // Servers and Pipename


    if ((argc<2)||((argv[1][0]!='/')&&(argv[1][0]!='-')))
    {

        DisplayServerHlp();
        DisplayClientHlp();
        return(1);
    }

    switch(argv[1][1])
    {
    case 'c':
    case 'C':

        //
        // Is Client End of Remote
        //

        if ((argc<4)||((argv[1][0]!='/')&&(argv[1][0]!='-')))
        {

            DisplayServerHlp();
            DisplayClientHlp();
            return(1);
        }

        ServerName=argv[2];
        PipeName=argv[3];
        FirstArg=4;
        RunType=RUNTYPE_CLIENT;
        break;


    case 'q':
    case 'Q':

        //
        //  Query for possible conexions
        //


        if ((argc != 3)||((argv[1][0]!='/')&&(argv[1][0]!='-')))
        {

            DisplayServerHlp();
            DisplayClientHlp();
            return(1);
        }

        QueryRemotePipes(argv[2]);  //  Send ServerName as a param
        return(0);


    case 'p':
    case 'P':

        //
        // Is Client End of Remote
        //

        bPromptForArgs=TRUE;
        RunType=RUNTYPE_CLIENT;
        FirstArg=2;
        break;


    case 's':
    case 'S':
        //
        // Is Server End of Remote
        //
        if ((argc<4)||((argv[1][0]!='/')&&(argv[1][0]!='-')))
        {

            DisplayServerHlp();
            DisplayClientHlp();
            return(1);
        }

        ChildCmd=argv[2];
        PipeName=argv[3];
        FirstArg=4;

        RunType=REMOTE_SERVER;
        break;


    case 'a':
    case 'A':
        //
        // Is Server End of Remote Attaching to existing process.
        //
        if ((argc<7)||((argv[1][0]!='/')&&(argv[1][0]!='-')))
        {

            DisplayServerHlp();
            DisplayClientHlp();
            return(1);
        }

        hAttachedProcess = (HANDLE)IntToPtr(atoi(argv[2]));
        hAttachedWriteChildStdIn = (HANDLE)IntToPtr(atoi(argv[3]));
        hAttachedReadChildStdOut = (HANDLE)IntToPtr(atoi(argv[4]));
        ChildCmd=argv[5]; // for display only
        PipeName=argv[6];
        FirstArg=7;

        RunType = REMOTE_SERVER;
        privacy = PRIVACY_VISIBLE;  // presumably ntsd/*kd
        break;

    default:
        DisplayServerHlp();
        DisplayClientHlp();
        return(1);
    }

    if (RunType==REMOTE_SERVER)
    {
        //
        // Base Name of Executable
        // For setting the title
        //

        char *tcmd=ChildCmd;

        while ((*tcmd!=' ')      && (*tcmd!=0))    tcmd++;
        while ((tcmd > ChildCmd) && (*tcmd!='\\')) tcmd--;
        if (*tcmd=='\\') tcmd++;
        sprintf(sTitle,"%-41.40s [Remote /C %s \"%.30s\"]",tcmd,HostName,PipeName);
    }

    //
    //Process Common (Optional) Parameters
    //

    for (i=FirstArg;i<argc;i++)
    {

        if ((argv[i][0]!='/')&&(argv[i][0]!='-'))
        {
            printf("Invalid parameter %s:Ignoring\n",argv[i]);
            continue;
        }

        switch(argv[i][1])
        {
        case 'l':    // Only Valid for client End
        case 'L':    // Max Number of Lines to recieve from Server
            i++;
            if (i>=argc)
            {
                printf("Incomplete Param %s..Ignoring\n",argv[i-1]);
                break;
            }
            LinesToSend=(DWORD)atoi(argv[i])+1;
            break;

        case 't':    // Title to be set instead of the default
        case 'T':
            i++;
            if (i>=argc)
            {
                printf("Incomplete Param %s..Ignoring\n",argv[i-1]);
                break;
            }
            sprintf(sTitle,"%s",argv[i]);
            break;

        case 'b':    // Background color
        case 'B':
            i++;
            if (i>=argc)
            {
                printf("Incomplete Param %s..Ignoring\n",argv[i-1]);
                break;
            }
            {
                WORD col=GetColorNum(argv[i]);
                if (col!=0xffff)
                {
                    wAttrib=col<<4|(wAttrib&0x000f);
                }
                break;
            }

        case 'f':    // Foreground color
        case 'F':
            i++;
            if (i>=argc)
            {
                printf("Incomplete Param %s..Ignoring\n",argv[i-1]);
                break;
            }
            {
                WORD col=GetColorNum(argv[i]);
                if (col!=0xffff)
                {
                    wAttrib=col|(wAttrib&0x00f0);
                }
                break;
            }

        case 'k':    // Color "keyword" lines
        case 'K':
            i++;
            // Currently only support client-side coloring
            if (RunType==REMOTE_SERVER)
            {
                printf("%s invalid on server side..Ignoring\n",argv[i-1]);
                break;
            }
            else if (i>=argc)
            {
                printf("Incomplete Param %s..Ignoring\n",argv[i-1]);
                break;
            }
            else
            {
                AssocKeysAndColors( &pKeyColors, argv[i] );
                break;
            }

        case 'v':
        case 'V':
            privacy = PRIVACY_VISIBLE;
            break;

        case '-':
            if( (argv[i][2] == 'v')
                || (argv[i][2] == 'V'))
                privacy = PRIVACY_NOT_VISIBLE;
            else
                printf("Unknown Parameter=%s %s\n",argv[i-1],argv[i]);
            break;

        case 'q':
        case 'Q':
            ClientToServerFlag|=0x80000000;
            break;

        case 'u':
        case 'U':
            if ( (argv[i][2] == 'd') ||
                 (argv[i][2] == 'D' ) )
            {
                Deny = TRUE ;
            }
            else
            {
                Deny = FALSE ;
            }

            i++ ;

            if ( i >= argc )
            {
                printf( "Incomplete Param %s..Ignoring\n", argv[i-1] );
                break;
            }

            if ( Deny )
            {
                if (DaclDenyNameCount == MAX_DACL_NAMES )
                {
                    printf("Too many names specified (max %d).  Ignoring user %s\n",
                            MAX_DACL_NAMES, argv[i] );

                    break;
                }

                DaclDenyNames[ DaclDenyNameCount++ ] = argv[i];

            }
            else
            {
                if (DaclNameCount == MAX_DACL_NAMES )
                {
                    printf("Too many names specified (max %d).  Ignoring user %s\n",
                            MAX_DACL_NAMES, argv[i] );

                    break;
                }

                DaclNames[ DaclNameCount++ ] = argv[i];

            }

            break;

        case '2':
            bForceTwoPipes = TRUE;
            break;

        default:
            printf("Unknown Parameter=%s %s\n",argv[i-1],argv[i]);
            break;

        }

    }

    //
    //Now Set various Parameters
    //

    //
    //Colors
    //

    SetColor(wAttrib);

    if (RunType==RUNTYPE_CLIENT)
    {
        BOOL done=FALSE;
        BOOL gotinfo;

        //
        // Set Client end defaults and start client
        //

        while(!done)
        {
            if (!bPromptForArgs ||
                (gotinfo = GetNextConnectInfo(&ServerName,&PipeName))
               )
            {
                sprintf(sTitle,"Remote /C %s \"%s\"",ServerName,PipeName);
                SetConsoleTitle(sTitle);

                //
                // Start Client (Client.C)
                //
                Client(ServerName,PipeName);
            }
            done = !bPromptForArgs || !gotinfo;
        }
    }

    if (RunType==REMOTE_SERVER)
    {
        if (privacy == PRIVACY_VISIBLE ||
             (privacy == PRIVACY_DEFAULT && IsKdString(ChildCmd))) {

            strcat(sTitle, " visible");
            IsAdvertise = TRUE;
        }

        SetConsoleTitle(sTitle);

        i = OverlappedServer(ChildCmd, PipeName);
    }

    //
    //Reset Colors
    //
    SetColor(csbiOriginal.wAttributes);
    SetConsoleTitle(orgTitle);

    return i;
}

/*************************************************************/
VOID
ErrorExit(
    char* str
    )
{
    extern PSZ pszPipeName;
    DWORD dwErr;

    dwErr = GetLastError();

    printf("REMOTE error %d: %s\n", dwErr, str);

    #if DBG
    {
        char szMsg[1024];

        sprintf(szMsg, "REMOTE error %d: %s\n", dwErr, str);
        OutputDebugString(szMsg);

        if (pszPipeName) {               // ad-hoc:  if server
            if (IsDebuggerPresent()) {
                DebugBreak();
            }
        }
    }
    #endif

    exit(1);
}

/*************************************************************/
VOID
DisplayClientHlp()
{
    printf("\n"
           "   To Start the CLIENT end of REMOTE\n"
           "   ---------------------------------\n"
           "   Syntax : REMOTE /C <ServerName> \"<Unique Id>\" [Param]\n"
           "   Example1: REMOTE /C %s imbroglio\n"
           "            This would connect to a server session on %s with Id\n"
           "            \"imbroglio\" if there is a REMOTE /S <\"Cmd\"> imbroglio\n"
           "            running on %s.\n\n"
           "   Example2: REMOTE /C %s \"name with spaces\"\n"
           "            This would connect to a server session on %s with Id\n"
           "            \"name with spaces\" if there is a REMOTE /S <\"Cmd\"> \"name with spaces\"\n"
           "            running on %s.\n\n"
           "   To Exit: %cQ (Leaves the Remote Server Running)\n"
           "   [Param]: /L <# of Lines to Get>\n"
           "   [Param]: /F <Foreground color eg blue, lred..>\n"
           "   [Param]: /K <Set keywords and colors from file>\n"
           "   [Param]: /B <Background color eg cyan, lwhite..>\n"
           "\n"
           "   Keywords And Colors File Format\n"
           "   -------------------------------\n"
           "   <KEYWORDs - CASE INSENSITIVE>\n"
           "   <FOREGROUND>[, <BACKGROUND>]\n"
           "   ...\n"
           "   EX:\n"
           "       ERROR\n"
           "       black, lred\n"
           "       WARNING\n"
           "       lblue\n"
           "       COLOR THIS LINE\n"
           "       lgreen\n"
           "\n"
           "   To Query the visible sessions on a server\n"
           "   -----------------------------------------\n"
           "   Syntax:  REMOTE /Q %s\n"
           "            This would retrieve the available <Unique Id>s\n"
           "            visible connections on the computer named %s.\n"
           "\n",
           HostName, HostName, HostName,
           HostName, HostName, HostName,
           COMMANDCHAR, HostName, HostName);
}
/*************************************************************/

VOID
DisplayServerHlp()
{
    printf("\n"
           "   To Start the SERVER end of REMOTE\n"
           "   ---------------------------------\n"
           "   Syntax : REMOTE /S <\"Cmd\">     <Unique Id> [Param]\n"
           "   Example1: REMOTE /S \"i386kd -v\" imbroglio\n"
           "            To interact with this \"Cmd\" from some other machine,\n"
           "            start the client end using:  REMOTE /C %s imbroglio\n\n"
           "   Example2: REMOTE /S \"i386kd -v\" \"name with spaces\"\n"
           "            start the client end using:  REMOTE /C %s \"name with spaces\"\n\n"
           "   To Exit: %cK \n"
           "   [Param]: /F  <Foreground color eg yellow, black..>\n"
           "   [Param]: /B  <Background color eg lblue, white..>\n"
           "   [Param]: /U  username or groupname\n"
           "                specifies which users or groups may connect\n"
           "                may be specified more than once, e.g\n"
           "                /U user1 /U group2 /U user2\n"
           "   [Param]: /UD username or groupname\n"
           "                specifically denies access to that user or group\n"
           "   [Param]: /V  Makes this session visible to remote /Q\n"
           "   [Param]: /-V Hides this session from remote /q (invisible)\n"
           "                By default, if \"Cmd\" looks like a debugger,\n"
           "                the session is visible, otherwise not\n"
           "\n",
           HostName, HostName, COMMANDCHAR);
}

VOID
DisplayWarning(
    WARNING_MESSAGE warn
    )
{
    switch ( warn )
    {
        case LINE_TOO_LONG:
            printf( "\n[REMOTE: WARNING: LINE TOO LONG TO PARSE FOR COLOR KEYWORDS]\n" );
            break;
        default:
            printf( "\n[REMOTE: WARNING: UNSPECIFIED PROBLEM COLORING LINE]\n" );
    }
}

WORD
GetColorNum(
    char *color
    )
{
    WORD i;

    _strlwr(color);
    for (i=0;i<16;i++)
    {
        if (strcmp(ColorList[i],color)==0)
        {
            return(i);
        }
    }
    return ((WORD)atoi(color));
}

VOID
SetColor(
    WORD attr
    )
{
    COORD  origin={0,0};
    DWORD  dwrite;
    FillConsoleOutputAttribute
    (
        MyStdOut,attr,csbiOriginal.dwSize.
        X*csbiOriginal.dwSize.Y,origin,&dwrite
    );
    SetConsoleTextAttribute(MyStdOut,attr);
}

BOOL
pColorLine(
    char *sLine,
    int cbLine,
    WORD wDefaultColor,
    WORD *color
    )
{
    KeywordAndColor *pCurKeyColor = NULL;
    char *pString1;
    int cbCmpString;

    pCurKeyColor = pKeyColors;
    while ( pCurKeyColor )
    {
        cbCmpString = strlen( pCurKeyColor->szKeyword );
        pString1 = sLine;
        // Need to do case-insensitive compare
        while ( pString1 <= sLine + cbLine - cbCmpString )
        {
            if ( !_memicmp( (PVOID)pString1,
                            (PVOID)pCurKeyColor->szKeyword,
                            cbCmpString ) )
            {
                *color = pCurKeyColor->color;
                // Check if we are to use default background color
                if ( (0xfff0 & *color) == 0xfff0 )
                    *color = (wDefaultColor & 0x00f0) |
                             (*color & 0x000f);
                return TRUE;
            }

            pString1++;
        }

        // Next keyword/color combination
        pCurKeyColor = pCurKeyColor->next;
    }

    return FALSE;
}

BOOL
pWantColorLines(
    VOID
    )
{
    return ( NULL != pKeyColors );
}

VOID
AssocKeysAndColors(
    KeywordAndColor **ppKeyColors,
    char *szFileName
    )
{
    char szPathName[_MAX_PATH],
         *szSimpleName;
    char *buffer,
         *pBegin,
         *pEnd;

    USHORT usForeColor,
           usBackColor;

    KeywordAndColor *pCurKeyColor,
                    *pNextKeyColor;

    HANDLE hFile;
    WIN32_FIND_DATA wfdInfo;
    DWORD dwBytesRead;

    // Locate the specified file somewhere in the path
    if ( !SearchPath( NULL,
                      szFileName,
                      NULL,
                      _MAX_PATH,
                      szPathName,
                      &szSimpleName ) )
    {
        fprintf( stderr, "Error locating keyword/color file \"%s\"!\n",
                 szFileName );
        return;
    }

    // Get the size of the file so we can read all of it in
    hFile = FindFirstFile( szPathName, &wfdInfo );
    if ( INVALID_HANDLE_VALUE == hFile )
    {
        fprintf( stderr, "Error locating keyword/color file \"%s\"!\n",
                 szPathName );
        return;
    }
    FindClose( hFile );
    hFile = INVALID_HANDLE_VALUE;

    if ( wfdInfo.nFileSizeLow < 5 ||
         wfdInfo.nFileSizeHigh )
    {
        fprintf( stderr, "Invalid keyword/color file: %s!\n",
                 szPathName );
        return;
    }

    // Allocate memory to store file contents
    buffer = malloc( wfdInfo.nFileSizeLow );
    if ( NULL == buffer )
    {
        fprintf( stderr, "Error!  Unable to allocate memory to read in keyword/color file!\n" );
        return;
    }

    // Attempt to open the given file-name
    hFile = CreateFile( szPathName,
                        GENERIC_READ,
                        FILE_SHARE_READ,
                        NULL,
                        OPEN_EXISTING,
                        FILE_FLAG_SEQUENTIAL_SCAN,
                        NULL );
    if ( INVALID_HANDLE_VALUE == hFile )
    {
        fprintf( stderr, "Error opening keyword/color file %s!\n",
                 szPathName );
        return;
    }

    // Attempt to read in the contents of the file
    ReadFile( hFile,
              buffer,
              wfdInfo.nFileSizeLow,
              &dwBytesRead,
              NULL );
    CloseHandle( hFile );

    if ( dwBytesRead != wfdInfo.nFileSizeLow )
    {
        fprintf( stderr, "Error reading keyword/color file: %s!\n",
                 szPathName );
        free( buffer );
        return;
    }

    // Parse contents of file, storing keyword(s) and color combinations
    pBegin = buffer;
    pCurKeyColor = NULL;
    while ( pBegin < buffer + dwBytesRead )
    {
        // Skip any newline/CR at beginning
        while ( pBegin < buffer + dwBytesRead &&
                ( *pBegin == '\r' ||
                  *pBegin == '\n' ) ) pBegin++;
        if ( pBegin >= buffer + dwBytesRead )
            continue;

        pEnd = pBegin;
        while ( pEnd < buffer + dwBytesRead &&
                *pEnd != '\r' ) pEnd++;
        // point at last character
        pEnd--;

        // Add new KeywordAndColor member to list
        if ( NULL == pCurKeyColor )
        {
            *ppKeyColors = pCurKeyColor = malloc( sizeof( KeywordAndColor ) );
        }
        else
        {
            pCurKeyColor->next = malloc( sizeof( KeywordAndColor ) );
            pCurKeyColor = pCurKeyColor->next;
        }

        // Verify we allocated memory for another list member
        if ( NULL == pCurKeyColor )
        {
            fprintf( stderr, "Error allocating memory for keyword/color storage!\n" );
            // Cleanup any we did create
            while ( *ppKeyColors )
            {
                pCurKeyColor = ((KeywordAndColor *)*ppKeyColors)->next;
                if ( ((KeywordAndColor *)*ppKeyColors)->szKeyword )
                    free( ((KeywordAndColor *)*ppKeyColors)->szKeyword );
                free( (KeywordAndColor *)*ppKeyColors );
                (KeywordAndColor *)*ppKeyColors = pCurKeyColor;
            }

            return;
        }

        // This is now the last member of the list
        pCurKeyColor->next = NULL;

        // Already have keyword(s) -- allocate room for it
        pCurKeyColor->szKeyword = malloc( pEnd - pBegin + 2 );
        if ( NULL == pCurKeyColor->szKeyword )
        {
            fprintf( stderr, "Error allocating memory for keyword/color storage!\n" );
            // Cleanup any we did create
            while ( *ppKeyColors )
            {
                pCurKeyColor = ((KeywordAndColor *)*ppKeyColors)->next;
                if ( ((KeywordAndColor *)*ppKeyColors)->szKeyword )
                    free( ((KeywordAndColor *)*ppKeyColors)->szKeyword );
                free( (KeywordAndColor *)*ppKeyColors );
                *ppKeyColors = pCurKeyColor;
            }

            return;
        }

        // Store keyword(s)
        memcpy( (PVOID)pCurKeyColor->szKeyword, (PVOID)pBegin, pEnd-pBegin+1 );
        pCurKeyColor->szKeyword[pEnd-pBegin+1] = '\0';

        pBegin = pEnd + 1;
        // Get color information
        if ( GetColorFromBuffer( &pBegin,
                                 (char *)(buffer + dwBytesRead),
                                 &usForeColor,
                                 FALSE ) )
        {
            // Check if there is a comma following
            while ( pBegin < buffer + dwBytesRead &&
                    *pBegin != ',' &&
                    *pBegin != '\r' ) pBegin++;
            if ( *pBegin == ',' )
            {
                pBegin++;
                if ( GetColorFromBuffer( &pBegin,
                                         (char *)(buffer + dwBytesRead),
                                         &usBackColor,
                                         TRUE ) )
                    goto noError;
            }
            else
            {
                // Default to current background color
                usBackColor = 0xffff;
                goto noError;
            }
        }
        // ERROR
        fprintf( stderr, "Invalid color information for: %s\n", pCurKeyColor->szKeyword );
        // We will leave any previous entries but delete this one
        pNextKeyColor = *ppKeyColors;
        if ( pNextKeyColor == pCurKeyColor )
        {
            free( pCurKeyColor );
            *ppKeyColors = NULL;
        }
        else
        {
            while ( pCurKeyColor != pNextKeyColor->next )
                pNextKeyColor = pNextKeyColor->next;
            free ( pCurKeyColor );
            pNextKeyColor->next = NULL;
        }
        return;

noError:
        // Store color information
        if ( usBackColor == 0xffff )
            pCurKeyColor->color = 0xfff0 |
                                  (usForeColor & 0x0f);
        else
            pCurKeyColor->color = ((usBackColor << 4) & 0x00f0) |
                                  (usForeColor & 0x0f );
    }
}

BOOL
GetColorFromBuffer(
    char **ppBuffer,
    char *pBufferInvalid,
    WORD *color,
    BOOL bStayOnLine
    )
{
    char *pBegin,
         *pEnd,
         temp;

    pBegin = *ppBuffer;
    if ( bStayOnLine )
    {
        // Skip to the next character (on this line)
        while ( pBegin < pBufferInvalid &&
                !isalnum( (int)*pBegin ) &&
                *pBegin != '\r' ) pBegin++;
    }
    else
    {
        // Skip to next character (in buffer)
        while ( pBegin < pBufferInvalid &&
                !isalnum( (int)*pBegin ) ) pBegin++;
    }

    if ( pBegin >= pBufferInvalid ||
         *pBegin == '\r' )
        return FALSE;

    // Read in color
    pEnd = pBegin + 1;
    while ( isalnum( (int)*pEnd ) &&
            *pEnd != ',' ) pEnd++;

    temp = *pEnd;
    *pEnd = '\0';
    *color = GetColorNum( pBegin );
    *pEnd = temp;

    // Use same valid color check as used for foreground/background
    if ( *color == 0xffff )
        return FALSE;

    // Move the pointer we were given to next unread portion
    *ppBuffer = pEnd;

    return TRUE;
}

BOOL
GetNextConnectInfo(
    char** SrvName,
    char** PipeName
    )
{
    char *s;

    static char szServerName[64];
    static char szPipeName[32];

    try
    {
        ZeroMemory(szServerName,64);
        ZeroMemory(szPipeName,32);
        SetConsoleTitle("Remote - Prompting for next Connection");
        printf("Debugger machine (server): ");
        fflush(stdout);

        if (((*SrvName=gets(szServerName))==NULL)||
             (strlen(szServerName)==0))
        {
            return(FALSE);
        }

        if (szServerName[0] == COMMANDCHAR &&
            (szServerName[1] == 'q' || szServerName[1] == 'Q')
           )
        {
            return(FALSE);
        }

        if (s = strchr( szServerName, ' ' )) {
            *s++ = '\0';
            while (*s == ' ') {
                s += 1;
            }
            *PipeName=strcpy(szPipeName, s);
            printf(szPipeName);
            fflush(stdout);
        }
        if (strlen(szPipeName) == 0) {
            printf("Target machine (pipe)    : ");
            fflush(stdout);
            if ((*PipeName=gets(szPipeName))==NULL)
            {
                return(FALSE);
            }
        }

        if (s = strchr(szPipeName, ' ')) {
            *s++ = '\0';
        }

        if (szPipeName[0] == COMMANDCHAR &&
            (szPipeName[1] == 'q' || szPipeName[1] == 'Q')
           )
        {
            return(FALSE);
        }
        printf("\n\n");
    }

    except(EXCEPTION_EXECUTE_HANDLER)
    {
        return(FALSE);  // Ignore exceptions
    }
    return(TRUE);
}


/*************************************************************/

VOID
Errormsg(
    char* str
    )
{
    printf("Error (%d) - %s\n",GetLastError(),str);
}

/*************************************************************/

BOOL
IsKdString(
    char* string
    )
{

    char* start;

    //
    // some heuristic for uninvented yet platforms
    // if the first word has "kd" in it ok
    //

    if(    ((start = strstr(string, "kd")) != NULL)
        || ((start = strstr(string, "dbg")) != NULL)
        || ((start = strstr(string, "remoteds")) != NULL)
        || ((start = strstr(string, "ntsd")) != NULL)
        || ((start = strstr(string, "cdb")) != NULL) )
    {
        // is it in the first word?
        while(--start > string)
        {
            if((*start == ' ') || (*start == '\t'))
            {
                while(--start > string)
                    if((*start != '\t') || (*start != ' '))
                        return(FALSE);
            }
        }
        return TRUE;
    }
    return(FALSE);
}


//
// WriteFileSynch is a synchronous WriteFile for overlapped
// file handles.  As a special case, two-pipe client operation
// sets fAsyncPipe FALSE and this routine then passes NULL
// for lpOverlapped.
//

BOOL
FASTCALL
WriteFileSynch(
    HANDLE  hFile,
    LPVOID  lpBuffer,
    DWORD   cbWrite,
    LPDWORD lpNumberOfBytesWritten,
    DWORD   dwFileOffset,
    LPOVERLAPPED lpO
    )
{
    BOOL Success;


    lpO->OffsetHigh = 0;
    lpO->Offset = dwFileOffset;

    Success =
        WriteFile(
            hFile,
            lpBuffer,
            cbWrite,
            lpNumberOfBytesWritten,
            fAsyncPipe ? lpO : NULL
            );

    if ( ! Success ) {

        if (ERROR_IO_PENDING == GetLastError()) {

            Success =
                GetOverlappedResult(
                    hFile,
                    lpO,
                    lpNumberOfBytesWritten,
                    TRUE
                    );
        }
    }

    return Success;
}


BOOL
FASTCALL
ReadFileSynch(
    HANDLE  hFile,
    LPVOID  lpBuffer,
    DWORD   cbRead,
    LPDWORD lpNumberOfBytesRead,
    DWORD   dwFileOffset,
    LPOVERLAPPED lpO
    )
{
    BOOL Success;

    lpO->OffsetHigh = 0;
    lpO->Offset = dwFileOffset;

    Success =
        ReadFile(
            hFile,
            lpBuffer,
            cbRead,
            lpNumberOfBytesRead,
            fAsyncPipe ? lpO : NULL
            );

    if ( ! Success ) {

        if (ERROR_IO_PENDING == GetLastError()) {

            Success =
                GetOverlappedResult(
                    hFile,
                    lpO,
                    lpNumberOfBytesRead,
                    TRUE
                    );
        }
    }

    return Success;
}

BOOL
FASTCALL
WriteConsoleWithColor(
    HANDLE MyStdOut,
    char *buffer,
    DWORD cbBuffer,
    CWCDATA *persist
    )
{
    DWORD cbWrite,
          cbFill;
    WORD color;
    BOOL bAltColor,
         bNewLine,
         bCanColor;
    char *pCurLine,
         *pEndOfLine,
         *pPrevLine,
         *pTemp;
    CONSOLE_SCREEN_BUFFER_INFO conBufferInfo;

    if ( persist->bLineContinues )
        bNewLine = FALSE;
    else
        bNewLine = TRUE;

    // Split buffer into individual lines
    pCurLine = buffer;
    while ( pCurLine < buffer + cbBuffer )
    {
        // Get console information
        bCanColor = GetConsoleScreenBufferInfo( MyStdOut, &conBufferInfo );

        // Find end of current line
        pEndOfLine = pCurLine;
        // Print out any beginning newlines/CR's -- this will avoid
        // coloring large blocks of nothing associated with keywords
        while ( pEndOfLine < buffer + cbBuffer &&
                ( *pEndOfLine == '\r' ||
                  *pEndOfLine == '\n' ) )
        {
            // New line
            if ( !bNewLine )
            {
                bNewLine = TRUE;

                // If this was a continuation line -- end it
                if ( persist->bLineContinues )
                {
                    persist->bLineContinues = FALSE;
                    // Check if we just ended a line that couldn't be parsed
                    // because of its size -- if so output warning
                    if ( persist->bLineTooLarge )
                        DisplayWarning( LINE_TOO_LONG );
                    // Otherwise check for keyword(s)
                    // and color if appropriate
                    else if ( bCanColor &&
                              pColorLine( persist->sLine,
                                          persist->cbCurPos + 1,
                                          conBufferInfo.wAttributes,
                                          &color ) )
                    {
                        // If we were unable to get the cursor position when
                        // the line started we won't be able to color it now,
                        // but because we aren't printing any warning elsewhere
                        // if we can't get console info, we will just quietly
                        // not output color here
                        if ( 0xFF != persist->cLineBegin.X ||
                             0xFF != persist->cLineBegin.Y )
                        {
                            // Color in beginning portion of line (actually all of
                            //  line up to current point gets colored to reduce
                            //  calculations)
                            FillConsoleOutputAttribute( MyStdOut,
                                                        color,
                                                        ( (conBufferInfo.dwCursorPosition.Y -
                                                           persist->cLineBegin.Y + 1) *
                                                          (conBufferInfo.srWindow.Right -
                                                           conBufferInfo.srWindow.Left) ),
                                                        persist->cLineBegin,
                                                        &cbFill );
                        }
                    }
                }
            }
            pEndOfLine++;
        }
        // Print newline characters if some were found
        if ( pEndOfLine > pCurLine )
        {
            if ( ! WriteFile(MyStdOut, pCurLine, (DWORD)(pEndOfLine - pCurLine), &cbWrite, NULL) )
            {
                // Bail out
                return FALSE;
            }

            // Move line pointer
            pCurLine = pEndOfLine;
        }

        // Get the line
        while ( pEndOfLine < buffer + cbBuffer &&
                *pEndOfLine != '\r' &&
                *pEndOfLine != '\n' ) pEndOfLine++;
        // If we got characters we are in a line
        // Check it for keywords or add it to
        // a continuation line and/or print it
        if ( pEndOfLine > pCurLine )
        {
            bNewLine = FALSE;

            // Point to last character
            pEndOfLine--;

            // Check for current console information
            if ( !bCanColor )
            {
                // Couldn't get information -- handle might
                // be redirected.  Don't change colors
                bAltColor = FALSE;
            }
            else if ( persist->bLineContinues )
            {
                // See if we have enough room to construct this new line
                if ( !persist->bLineTooLarge &&
                     (DWORD)(pEndOfLine - pCurLine + 1) >=
                     (persist->cbLine - persist->cbCurPos) )
                {
                    // Attempt to build a bigger buffer
                    pTemp = realloc( (PVOID)persist->sLine,
                                     persist->cbLine + (pEndOfLine - pCurLine + 1) );
                    if ( NULL == pTemp )
                    {
                        persist->bLineTooLarge = TRUE;
                    }
                    else
                    {
                        persist->sLine = pTemp;
                        persist->cbLine += (DWORD)(pEndOfLine - pCurLine + 1);
                    }
                }

                // Add this piece to the line
                if ( !persist->bLineTooLarge )
                {
                    // Add new piece to line
                    memcpy( (PVOID)(persist->sLine + persist->cbCurPos + 1),
                            (PVOID)pCurLine,
                            (pEndOfLine - pCurLine + 1) );
                    // Point at new end of line
                    persist->cbCurPos += (DWORD)(pEndOfLine - pCurLine + 1);
                }

                // Don't color this line portion
                bAltColor = FALSE;

            }
            // Check if line needs colored unless this is going
            // to be a continued line (last line in buffer and
            // does not end with a newline).  We do not want
            // to determine the color of the line until we
            // have the complete thing
            else if ( (char *)(pEndOfLine + 1) < (char *)(buffer + cbBuffer) )
            {
                // Parse line for keywords that will cause
                // this line to show up in a different color
                bAltColor = pColorLine( pCurLine,
                                        (DWORD)(pEndOfLine - pCurLine + 1),
                                        conBufferInfo.wAttributes,
                                        &color );
            }
            else
            {
                bAltColor = FALSE;
            }

            if ( bAltColor )
            {
                // Change color for output of this line
                SetConsoleTextAttribute( MyStdOut, color );
            }

            if ( ! WriteFile(MyStdOut, pCurLine, (DWORD)(pEndOfLine - pCurLine + 1), &cbWrite, NULL))
            {
                if ( bAltColor )
                {
                    SetConsoleTextAttribute( MyStdOut, conBufferInfo.wAttributes );
                }
                // Bail out
                return FALSE;
            }
            // Restore default colors if necessary
            if ( bAltColor )
            {
                SetConsoleTextAttribute( MyStdOut, conBufferInfo.wAttributes );
            }

            // Point to the next line, saving off this line
            // in case we need to store it in a continuation
            // line
            pPrevLine = pCurLine;
            pCurLine = pEndOfLine + 1;
        } // End only check line if there is one
    }

    // If the buffer did not end with a CR, and we are
    // not already in a continuation, remember this line
    if ( !bNewLine &&
         pPrevLine <= pEndOfLine &&
         !persist->bLineContinues )
    {
        persist->bLineContinues = TRUE;
        persist->bLineTooLarge = FALSE;

        if ( bCanColor )
            persist->cLineBegin = conBufferInfo.dwCursorPosition;
        else // Signal we were unable to obtain cursor location
        {
            persist->cLineBegin.X = 0xFF;
            persist->cLineBegin.Y = 0xFF;
        }

        // See if we have enough room to construct this new line
        if ( (DWORD)(pEndOfLine - pPrevLine + 1) >= persist->cbLine )
        {
            // Attempt to build a bigger buffer
            pTemp = realloc( (PVOID)persist->sLine,
                             persist->cbLine + (pEndOfLine - pPrevLine + 1) );
            if ( NULL == pTemp )
            {
                persist->bLineTooLarge = TRUE;
            }
            else
            {
                persist->sLine = pTemp;
                persist->cbLine = (DWORD)(pEndOfLine - pPrevLine + 1);
            }
        }

        // Store the beginning of the line
        if ( !persist->bLineTooLarge )
        {
            // Add new piece to line
            memcpy( (PVOID)persist->sLine,
                    (PVOID)pPrevLine,
                    (pEndOfLine - pPrevLine + 1) );
            // Point at new end of line
            persist->cbCurPos = (DWORD)(pEndOfLine - pPrevLine);
        }
    }

    // Success
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\remote\remoteds.c ===
/******************************************************************************\
*       This is a part of the Microsoft Source Code Samples.
*       Copyright 1995 - 1997 Microsoft Corporation.
*       All rights reserved.
*       This source code is only intended as a supplement to
*       Microsoft Development Tools and/or WinHelp documentation.
*       See these sources for detailed information regarding the
*       Microsoft samples programs.
\******************************************************************************/

//
// remoteds.c, a "directory service" for the limited job of
// finding remote.exe servers on the same domain/workgroup.
//
// Dave Hart written summer 1997.
//
// Copyright 1997 Microsoft Corp.
//
//
// A handy way to use this program is under remote on a single
// or a few machines:
//
//    remote /s remoteds FindRemote
//
// Clients connect with remote /c machinename FindRemote
//
// Only remote.exe's running debuggers or with /V+ are visible
// via remoteds, as with remote /q.
//
// Remote clients notify remoteds using mailslots, see srvad.c.
//
//

#include <windows.h>
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <process.h>

typedef char RECEIVEBUF[1024];

typedef struct tagSERVERENTRY {
    int     nPID;                   // zero PID means unused slot
    union {
        FILETIME FileTime;
        LARGE_INTEGER liTime;
    };
    char   *pszMachine;
    char   *pszPipe;
    char   *pszChildCmd;
} SERVERENTRY;

#define TABLE_INITIAL_ALLOC 1 // 128       // beginning table size
#define TABLE_ALLOC_DELTA   1 // 16        // grows by this many units

HANDLE       hTableHeap;
SERVERENTRY *Table;
int          nTableSize;
int          nTableHiWater;          // highest used slot so far
CRITICAL_SECTION csTable;

char szPrompt[] = "remote server search> ";



unsigned WINAPI     InteractThread(void * UnusedParm);
unsigned WINAPI     CleanupThread(void * UnusedParm);
VOID     __fastcall UpdateTimeStamp(LPFILETIME lpFileTime);
VOID     __fastcall ReallocTable(int nNewTableSize);


int
__cdecl
main(
    int argc,
    char **argv
    )
{
    char *      pszMailslot = "\\\\.\\MAILSLOT\\REMOTE\\DEBUGGERS";
    HANDLE      hMailslot;
    BOOL        b;
    HANDLE      hThread;
    DWORD       dwTID;
    char *      pszMachine;
    int         cchMachine;
    char *      pszPID;
    int         nPID;
    char *      pszPipe;
    int         cchPipe;
    char *      pszChildCmd;
    int         i;
    int         nFirstAvailable;
    BOOL        fStopping;
    BOOL        fFound;
    int         cb;
    char *      pchStrings;
    char *      pch;
    DWORD       cbRead;
    DWORD       iBuf;
    DWORD       rgcbBuf[2];
    RECEIVEBUF  rgBuf[2];
    RECEIVEBUF  szBuf;
    char        szRemoteCmd[512];

    InitializeCriticalSection(&csTable);

    ReallocTable(TABLE_INITIAL_ALLOC);

    hMailslot =
        CreateMailslot(
            pszMailslot,
            0,
            MAILSLOT_WAIT_FOREVER,
            NULL
            );

    if (INVALID_HANDLE_VALUE == hMailslot) {

        DWORD dwErr = GetLastError();

        if (ERROR_ALREADY_EXISTS == dwErr) {
            printf("Cannot receive on %s,\n"
                   "is remoteds or rdsrelay already running on this machine?\n",
                   pszMailslot);
        } else {
            printf("CreateMailslot(%s) failed error %d\n",
                    pszMailslot,
                    dwErr);
        }
        return 2;
    }


    hThread = (HANDLE) _beginthreadex(
                                      NULL,
                                      0,
                                      InteractThread,
                                      NULL,
                                      0,
                                      &dwTID
                                     );

    if ( ! hThread) {
        printf("Can't start InteractThread %d\n", GetLastError());
        return 3;
    }

    CloseHandle(hThread);

    hThread = (HANDLE) _beginthreadex(
                                      NULL,
                                      0,
                                      CleanupThread,
                                      NULL,
                                      0,
                                      &dwTID
                                     );


    if ( ! hThread) {
        printf("Can't start CleanupThread %d\n", GetLastError());
        return 3;
    }

    CloseHandle(hThread);


    //
    // loop reading and processing mailslot messsages
    //

    iBuf = 0;
    ZeroMemory(rgcbBuf, sizeof(rgcbBuf));
    ZeroMemory(rgBuf, sizeof(rgBuf));

    while(TRUE)
    {
        b = ReadFile(
                hMailslot,
                rgBuf[ iBuf ],
                sizeof(rgBuf[ iBuf ]) - 1,  // so I can null terminate if needed
                &rgcbBuf[ iBuf ],
                NULL
                );

        if ( ! b) {
            printf("ReadFile(hMailslot) failed error %d\n", GetLastError());
            return 4;
        }

        //
        // It's the nature of mailslots and multiple transports
        // that we'll get the identical message several times in
        // quick succession.  Don't waste time searching the table
        // for these duplicates.
        //

        if ( rgcbBuf[0] == rgcbBuf[1] &&
             ! memcmp(rgBuf[0], rgBuf[1], rgcbBuf[0])) {

            continue;               // duplicate
        }

        //
        // Make a working copy into szBuf/cbRead that we can
        // modify so the original buffer is available for
        // detecting received duplicates.
        //

        cbRead = rgcbBuf[ iBuf ];
        CopyMemory(szBuf, rgBuf[ iBuf ], cbRead);

        //
        // Toggle buffers for the next read.
        //

        iBuf = !iBuf;

        if (szBuf[ cbRead - 1 ]) {
            printf("Received string not null terminated.\n");
            szBuf[cbRead] = 0;
        }

        pszMachine = szBuf;

        pch = strchr(szBuf, '\t');

        if (!pch) {
            printf("Received string no 1st tab\n");
            continue;
        }
        *pch = '\0';

        pszPID = ++pch;

        pch = strchr(pch, '\t');

        if (!pch) {
            printf("Received string no 2nd tab\n");
            continue;
        }
        *pch = '\0';

        pszPipe = ++pch;

        pch = strchr(pch, '\t');

        if (!pch) {
            printf("Received string no 3nd tab\n");
            continue;
        }
        *pch = '\0';

        pszChildCmd = ++pch;

        //
        // If it ends with ^B it's going away.
        //

        pch = strchr(pch, '\x2');

        if (pch) {
            *pch = 0;
            fStopping = TRUE;
        } else {
            fStopping = FALSE;
        }


        nPID = strtol(pszPID, NULL, 10);
        _strlwr(pszMachine);
        _strlwr(pszPipe);

        if (fStopping) {

            //
            // display the ending remote's info
            //

            sprintf(szRemoteCmd, "remote /c %s %s", pszMachine, pszPipe);
            printf("\r%-36s %-20s   [stop]\n%s", szRemoteCmd, pszChildCmd, szPrompt);
            fflush(stdout);
        }

        EnterCriticalSection(&csTable);

        nFirstAvailable = -1;

        for (i = 0, fFound = FALSE;
             i <= nTableHiWater;
             i++) {

            if (-1 == nFirstAvailable && 0 == Table[i].nPID) {
                nFirstAvailable = i;
            }

            if (Table[i].nPID == nPID &&
                ! strcmp(Table[i].pszMachine, pszMachine) &&
                ! strcmp(Table[i].pszPipe, pszPipe)) {

                fFound = TRUE;
                break;
            }
        }


        if (fFound) {

            if (fStopping) {

                //
                // Remove it from the table
                //

                free(Table[i].pszMachine);
                ZeroMemory(&Table[i], sizeof(Table[i]));

                if (nTableHiWater == i) {
                    nTableHiWater--;
                }

            } else { // starting

                // printf("Found at slot %d\n", i);
                // timestamp is updated below
            }

        } else if ( ! fStopping) {

            //
            // we have a new entry, display it
            //

            sprintf(szRemoteCmd, "remote /c %s %s", pszMachine, pszPipe);
            printf("\r%-36s %-20s   [start]\n%s", szRemoteCmd, pszChildCmd, szPrompt);
            fflush(stdout);

            //
            // Does it fit in the table or do we need to grow it?
            //

            if (-1 == nFirstAvailable) {

                if (++nTableHiWater >= nTableSize) {
                    ReallocTable(nTableSize + TABLE_ALLOC_DELTA);
                }

                i = nTableHiWater;

            } else {

                i = nFirstAvailable;
            }


            //
            // Fill in a server entry in table, if we can
            // allocate memory for the strings.
            //

            cb = (cchMachine  = strlen(pszMachine) + 1) +
                 (cchPipe     = strlen(pszPipe) + 1) +
                 (              strlen(pszChildCmd) + 1);

            pchStrings = malloc(cb);

            if (pchStrings) {

                Table[i].nPID = nPID;
                UpdateTimeStamp(&Table[i].FileTime);

                Table[i].pszMachine = pchStrings;
                strcpy(Table[i].pszMachine, pszMachine);

                Table[i].pszPipe = Table[i].pszMachine + cchMachine;
                strcpy(Table[i].pszPipe, pszPipe);

                Table[i].pszChildCmd = Table[i].pszPipe + cchPipe;
                strcpy(Table[i].pszChildCmd, pszChildCmd);
            }

        }

        UpdateTimeStamp(&Table[i].FileTime);

        LeaveCriticalSection(&csTable);

    }   // while (TRUE)

    return 0;    // never executed
}


//
// InteractThread lets the user query the list of remote servers.
//

unsigned WINAPI InteractThread(void * UnusedParm)
{
    char szQuery[1024];
    char szLowerQuery[1024];
    char szRemoteCmd[400];
    int  i;
    BOOL fAll;

 Help:
    printf("Enter a string to search for, a machine or pipe name or command.\n");
    printf("Enter * to list all remote servers.\n");
    printf("Exit with ^B.\n");

    while (TRUE) {

        fputs(szPrompt, stdout);
        fflush(stdout);
        gets(szQuery);
        _strlwr( strcpy(szLowerQuery, szQuery) );

        if (!strlen(szLowerQuery) ||
            !strcmp(szLowerQuery, "?") ||
            !strcmp(szLowerQuery, "h") ||
            !strcmp(szLowerQuery, "help")) {

            goto Help;
        }

        if (2 == szLowerQuery[0]) {           // ^B

            ExitProcess(0);
        }

        fAll = ! strcmp(szLowerQuery, "*");

        EnterCriticalSection(&csTable);

        for (i = 0; i <= nTableHiWater; i++) {
            if (Table[i].nPID) {
                if (fAll ||
                    strstr(Table[i].pszMachine, szLowerQuery) ||
                    strstr(Table[i].pszPipe, szLowerQuery) ||
                    strstr(Table[i].pszChildCmd, szLowerQuery)) {

                    sprintf(szRemoteCmd, "remote /c %s %s", Table[i].pszMachine, Table[i].pszPipe);
                    printf("%-40s %s\n", szRemoteCmd, Table[i].pszChildCmd);
                }
            }
        }

        LeaveCriticalSection(&csTable);

    }

    return 0;    // never executed
}


#if _MSC_FULL_VER >= 13008827
#pragma warning(push)
#pragma warning(disable:4715)			// Not all control paths return (due to infinite loop)
#endif

//
// CleanupThread scavenges for old entries and frees them.
// remote /s sends a broadcast at least every 2 hours.
// We get some of them.  Age out entries after 12 hours.
//

unsigned WINAPI CleanupThread(void * UnusedParm)
{
    LARGE_INTEGER liNow;
    LARGE_INTEGER liTimeout;
    int i;
    char szRemoteCmd[400];

    liTimeout.QuadPart = (LONGLONG)10000000 * 60 * 60 * 12;  // 12 hours

    while (TRUE) {

        Sleep(15 * 60 * 1000);    // 10 minutes

        UpdateTimeStamp((LPFILETIME)&liNow);

        EnterCriticalSection(&csTable);

        for (i = nTableHiWater; i >= 0; i--) {

            if (Table[i].nPID) {

                if (liNow.QuadPart - Table[i].liTime.QuadPart > liTimeout.QuadPart) {

                    //
                    // display the ending remote's info
                    //

                    sprintf(szRemoteCmd, "remote /c %s %s", Table[i].pszMachine, Table[i].pszPipe);
                    printf("\r%-36s %-20s   [aged out]\n%s", szRemoteCmd, Table[i].pszChildCmd, szPrompt);
                    fflush(stdout);

                    free(Table[i].pszMachine);
                    ZeroMemory(&Table[i], sizeof(Table[i]));

                    if (nTableHiWater == i) {
                        nTableHiWater--;
                    }
                }

            }

        }

        LeaveCriticalSection(&csTable);
    }

    return 0;    // never executed
}

#if _MSC_FULL_VER >= 13008827
#pragma warning(pop)
#endif


VOID __fastcall UpdateTimeStamp(LPFILETIME lpFileTime)
{
    SYSTEMTIME SystemTime;

    GetSystemTime(&SystemTime);
    SystemTimeToFileTime(&SystemTime, lpFileTime);
}


VOID __fastcall ReallocTable(int nNewTableSize)
{
    SERVERENTRY *pTableSave = Table;

    EnterCriticalSection(&csTable);

    nTableSize = nNewTableSize;

    if ( ! hTableHeap) {

        hTableHeap = HeapCreate(
                         HEAP_NO_SERIALIZE,
                         (TABLE_INITIAL_ALLOC + 1) * sizeof(Table[0]),  // size
                         50000 * sizeof(Table[0])                       // max
                         );
        if (hTableHeap)
            Table = HeapAlloc(
                        hTableHeap,
                        HEAP_ZERO_MEMORY,
                        nTableSize * sizeof(Table[0])
                        );
        else
            Table = NULL;
    } else {

        Table = HeapReAlloc(
                    hTableHeap,
                    HEAP_ZERO_MEMORY,
                    Table,
                    nTableSize * sizeof(Table[0])
                    );
    }

    if (!Table) {
        printf("\nremoteds: Out of memory allocating remote server table\n");
        exit(ERROR_NOT_ENOUGH_MEMORY);
    }


    LeaveCriticalSection(&csTable);

    if (Table != pTableSave && pTableSave) {
        printf("\nremoteds:  remote server table moved in HeapRealloc from %p to %p.\n", pTableSave, Table);
        fflush(stdout);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\remote\remote.h ===
/******************************************************************************\
*       This is a part of the Microsoft Source Code Samples. 
*       Copyright 1993 - 1997 Microsoft Corporation.
*       All rights reserved. 
*       This source code is only intended as a supplement to 
*       Microsoft Development Tools and/or WinHelp documentation.
*       See these sources for detailed information regarding the 
*       Microsoft samples programs.
\******************************************************************************/

/*++

Copyright 1993 - 1997 Microsoft Corporation

Module Name:

    Remote.h

Abstract:

    This module contains the main() entry point for Remote.
    Calls the Server or the Client depending on the first parameter.


Author:

    Rajivendra Nath  2-Jan-1993

Environment:

    Console App. User mode.

Revision History:

--*/

#if !defined(FASTCALL)
#if defined(_M_IX86)
#define FASTCALL _fastcall
#else
#define FASTCALL
#endif
#endif

#define VERSION         4
#define REMOTE_SERVER       1
#define RUNTYPE_CLIENT      2

#define SERVER_READ_PIPE    "\\\\%s\\PIPE\\%sIN"   //Client Writes and Server Reads
#define SERVER_WRITE_PIPE   "\\\\%s\\PIPE\\%sOUT"  //Server Writes and Client Reads

#define QUERY_DEBUGGERS_PIPE "\\\\%s\\PIPE\\QueryDebuggerPipe"

// PRIVACY_DEFAULT:     this session will be listed only if it looks like a debugging one
// PRIVACY_NON_VISIBLE: whatever the name of command, it will not show up with remote /q
// PRIVACY_VISIBLE:     this session will be visible for querying

#define PRIVACY_DEFAULT       1
#define PRIVACY_VISIBLE       2
#define PRIVACY_NOT_VISIBLE   3


#define COMMANDCHAR         '@' //Commands intended for remote begins with this
#define CTRLC               3

#define CLIENT_ATTR         FOREGROUND_INTENSITY|FOREGROUND_GREEN|FOREGROUND_RED|BACKGROUND_BLUE
#define SERVER_ATTR         FOREGROUND_INTENSITY|FOREGROUND_GREEN|FOREGROUND_BLUE|BACKGROUND_RED

//
//Some General purpose Macros
//
#define MINIMUM(x,y)          ((x)>(y)?(y):(x))
#define MAXIMUM(x,y)          ((x)>(y)?(x):(y))

#define HOSTNAMELEN         MAX_COMPUTERNAME_LENGTH+1

#define CHARS_PER_LINE      45

#define MAGICNUMBER     0x31109000
#define BEGINMARK       '\xfe'
#define ENDMARK         '\xff'
#define LINESTOSEND     200

#define MAX_DACL_NAMES  64

typedef struct
{
    DWORD    Size;
    DWORD    Version;
    char     ClientName[HOSTNAMELEN];
    DWORD    LinesToSend;
    DWORD    Flag;
}   SESSION_STARTUPINFO;

typedef struct
{
    DWORD MagicNumber;      //New Remote
    DWORD Size;             //Size of structure
    DWORD FileSize;         //Num bytes sent
}   SESSION_STARTREPLY;



typedef struct
{
    char* out;              // message
    int  size;              // message length
    int  allocated;         // length of allocated memory
} QUERY_MESSAGE;

typedef struct
{
    char *sLine;
    BOOL bLineContinues;
    BOOL bLineTooLarge;
    DWORD cbLine;
    DWORD cbCurPos;
    COORD cLineBegin;
} CWCDATA;

VOID
QueryRemotePipes(
    char* serverName
    );

int
OverlappedServer(
    char* ChildCmd,
    char* PipeName
    );


VOID
Client(
    char* ServerName,
    char* PipeName
    );

VOID
ErrorExit(
    char* str
    );

VOID
DisplayClientHlp(
    );

VOID
DisplayServerHlp(
    );

VOID
Errormsg(
    char* str
    );

BOOL
IsKdString(
    char* string
    );

BOOL
pWantColorLines(
    VOID
    );

BOOL
FASTCALL
WriteFileSynch(
    HANDLE  hFile,
    LPVOID  lpBuffer,
    DWORD   cbWrite,
    LPDWORD lpNumberOfBytesWritten,
    DWORD   dwFileOffset,
    LPOVERLAPPED lpO
    );

BOOL
FASTCALL
ReadFileSynch(
    HANDLE  hFile,
    LPVOID  lpBuffer,
    DWORD   cbRead,
    LPDWORD lpNumberOfBytesRead,
    DWORD   dwFileOffset,
    LPOVERLAPPED lpO
    );

BOOL
FASTCALL
WriteConsoleWithColor(
    HANDLE MyStdOut,
    char *buffer,
    DWORD cbBuffer,
    CWCDATA *persist
    );

VOID
CloseClientPipes(
    VOID
    );

BOOL
pColorLine(
    char *sLine,
    int cbLine,
    WORD wDefaultColor,
    WORD *color );

extern char   HostName[HOSTNAMELEN];
extern char*  ChildCmd;
extern char*  PipeName;
extern char*  ServerName;
extern HANDLE MyOutHandle;
extern DWORD  LinesToSend;
extern BOOL   IsAdvertise;
extern DWORD  ClientToServerFlag;
extern char * DaclNames[];
extern DWORD  DaclNameCount;
extern char * DaclDenyNames[];
extern DWORD  DaclDenyNameCount;
extern BOOL   fAsyncPipe;
extern HANDLE hAttachedProcess;
extern HANDLE hAttachedWriteChildStdIn;
extern HANDLE hAttachedReadChildStdOut;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\remote\server.h ===
/******************************************************************************\
*       This is a part of the Microsoft Source Code Samples. 
*       Copyright 1995 - 1997 Microsoft Corporation.
*       All rights reserved. 
*       This source code is only intended as a supplement to 
*       Microsoft Development Tools and/or WinHelp documentation.
*       See these sources for detailed information regarding the 
*       Microsoft samples programs.
\******************************************************************************/

/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    Server.h

Abstract:

    The server component of Remote, rewritten using
    ReadFileEx/WriteFileEx completion routines.

Author:

    Dave Hart  30 May 1997

Environment:

    Console App. User mode.

Revision History:

--*/

#include <lm.h>                // needed for NET_API_STATUS below

#if !defined(SERVER_H_NOEXTERN)
#define SRVEXTERN extern
#else
#define SRVEXTERN
#endif


#if DBG
  DWORD Trace;         // bits set in here trigger trace printfs

  #define TR_SESSION            (0x01)
  #define TR_CHILD              (0x02)
  #define TR_SHAKE              (0x04)
  #define TR_CONNECT            (0x08)
  #define TR_QUERY              (0x10)
  #define TR_COPYPIPE           (0x20)
#endif


#if DBG
  #define TRACE(tracebit, printfargs)                        \
              ((Trace & (TR_##tracebit)                      \
                   ? (printf printfargs, fflush(stdout), 0)  \
                   : 0))
#else
  #define TRACE(tracebit, printfargs)    (0)
#endif

#if defined(ASSERT)
#undef ASSERT
#endif

#if DBG
  #define ASSERT(exp)  ((exp) || (ErrorExit("Assertion failed in " __FILE__ ": " #exp ),0))
#else
  #define ASSERT(exp)  (0)
#endif


//
// Size of transfer buffers
//

#define BUFFSIZE      (4 * 1024)

//
// ServerFlags bit values in REMOTE_CLIENT below
//

#define SFLG_CLOSING               0x01
#define SFLG_HANDSHAKING           0x02
#define SFLG_READINGCOMMAND        0x04
#define SFLG_LOCAL                 0x08

#define SFLG_VALID                 \
            (SFLG_CLOSING        | \
             SFLG_HANDSHAKING    | \
             SFLG_READINGCOMMAND | \
             SFLG_LOCAL)


//
// Per-client state
//

typedef struct tagREMOTE_CLIENT {
    LIST_ENTRY Links;
    DWORD   dwID;           // 1, 2, ...
    DWORD   ServerFlags;
    DWORD   Flag;           //from Client's ClientToServerFlag
    DWORD   cbWrite;        //zero if no read temp/write client ops pending
    HANDLE  PipeReadH;      //Client sends its StdIn  through this
    HANDLE  PipeWriteH;     //Client gets  its StdOut through this
    DWORD   dwFilePos;      //offset of temp file where next read begins
    OVERLAPPED ReadOverlapped;
    OVERLAPPED WriteOverlapped;
    HANDLE  rSaveFile;      //Sessions read handle to SaveFile
    DWORD   cbReadTempBuffer;
    DWORD   cbWriteBuffer;
    DWORD   cbCommandBuffer;
    char    HexAsciiId[8];         // dwID as 8 hex chars -- no terminator
    char    Name[HOSTNAMELEN];     //Name of client Machine;
    char    UserName[16];          //Name of user on client machine.
    BYTE    ReadBuffer[BUFFSIZE];
    BYTE    ReadTempBuffer[BUFFSIZE];
    BYTE    WriteBuffer[BUFFSIZE];
    BYTE    CommandBuffer[BUFFSIZE];
} REMOTE_CLIENT, *PREMOTE_CLIENT;

//
// Client lists, see srvlist.c
//

SRVEXTERN LIST_ENTRY       HandshakingListHead;
SRVEXTERN CRITICAL_SECTION csHandshakingList;

SRVEXTERN LIST_ENTRY       ClientListHead;
SRVEXTERN CRITICAL_SECTION csClientList;

SRVEXTERN LIST_ENTRY       ClosingClientListHead;
SRVEXTERN CRITICAL_SECTION csClosingClientList;


SRVEXTERN DWORD   dwNextClientID;
SRVEXTERN LPSTR   pszPipeName;
SRVEXTERN HANDLE  ChldProc;
SRVEXTERN DWORD   pidChild;
SRVEXTERN HANDLE  hWriteChildStdIn;
SRVEXTERN BOOL    bShuttingDownServer;
SRVEXTERN HANDLE  hHeap;

SRVEXTERN volatile DWORD cPendingCtrlCEvents;

SRVEXTERN OSVERSIONINFO OsVersionInfo;

// File containing all that was output by child process.
// Each connection opens a handle to this file
// and sends its contents through PipeWriteH.

SRVEXTERN HANDLE  hWriteTempFile;

SRVEXTERN char    SaveFileName[MAX_PATH]; //Name of above file - all new sessions need


//
// Generic "wide-open" security descriptor as well
// as the possibly-restricted pipe SD.
//

SRVEXTERN SECURITY_DESCRIPTOR sdPublic;
SRVEXTERN SECURITY_ATTRIBUTES saPublic;
SRVEXTERN SECURITY_ATTRIBUTES saPipe;


//
// To minimize client "all pipe instances are busy" errors,
// we wait on connection to several instances of the IN pipe,
// the sole pipe used by single-pipe clients.  Because of the
// requirement to support two-pipe clients (old software as
// well as new software on Win95), we cannot easily create
// and wait for connection on several instances of the OUT pipe.
// This is because two-pipe clients connect to both pipes before
// handshaking commences, and they connect to OUT first.  If we
// had several OUT pipe instances waiting, when an IN pipe was
// connected by the two-pipe client, we wouldn't know which of
// the possibly several connected OUT pipe instances to pair
// it with.  With only one OUT pipe, at IN connect time we need
// to distinguish two-pipe from one-pipe clients so a one-pipe
// client doesn't sneak in between the OUT and IN connects of
// a two-pipe client and wrongly be paired with the OUT pipe.
// To do so we look at the first byte of the initial write
// from the client (of the computername and magic value), if
// it's a question mark we know we have a new client and won't
// accidentally link it to a connected OUT instance.
//

#define CONNECT_COUNT  3

SRVEXTERN DWORD      cConnectIns;
SRVEXTERN OVERLAPPED rgolConnectIn[CONNECT_COUNT];
SRVEXTERN HANDLE     rghPipeIn[CONNECT_COUNT];

SRVEXTERN OVERLAPPED olConnectOut;
SRVEXTERN BOOL       bOutPipeConnected;
SRVEXTERN HANDLE     hPipeOut;
SRVEXTERN HANDLE     hConnectOutTimer;

//
// Indexes into rghWait array for multiple-wait
//

#define WAITIDX_CHILD_PROCESS           0
#define WAITIDX_READ_STDIN_DONE         1
#define WAITIDX_QUERYSRV_WAIT           2
#define WAITIDX_PER_PIPE_EVENT          3
#define WAITIDX_CONNECT_OUT             4
#define WAITIDX_CONNECT_IN_BASE         5
#define MAX_WAIT_HANDLES                (WAITIDX_CONNECT_IN_BASE + CONNECT_COUNT)

SRVEXTERN HANDLE rghWait[MAX_WAIT_HANDLES];

SRVEXTERN OVERLAPPED ReadChildOverlapped;
SRVEXTERN HANDLE     hReadChildOutput;
SRVEXTERN BYTE       ReadChildBuffer[BUFFSIZE];

SRVEXTERN PREMOTE_CLIENT pLocalClient;

typedef struct tagCOPYPIPE {
    HANDLE     hRead;
    HANDLE     hWrite;
} COPYPIPE, *PCOPYPIPE;

SRVEXTERN COPYPIPE rgCopyPipe[2];

SRVEXTERN volatile DWORD dwWriteFilePointer;   // used by SrvCtrlHand (thread)

SRVEXTERN OVERLAPPED QueryOverlapped;
SRVEXTERN HANDLE hQPipe;

SRVEXTERN OVERLAPPED olMainThread;


BOOL
APIENTRY
MyCreatePipeEx(
    OUT LPHANDLE lpReadPipe,
    OUT LPHANDLE lpWritePipe,
    IN LPSECURITY_ATTRIBUTES lpPipeAttributes,
    IN DWORD nSize,
    DWORD dwReadMode,
    DWORD dwWriteMode
    );

DWORD
WINAPI
CopyPipeToPipe(
    LPVOID   lpCopyPipeData
    );

DWORD
WINAPI
CopyStdInToPipe(
    LPVOID   lpCopyPipeData
    );

VOID
FASTCALL
StartSession(
    PREMOTE_CLIENT pClient
    );

VOID
FASTCALL
StartLocalSession(
    VOID
    );

VOID
FASTCALL
StartReadClientInput(
    PREMOTE_CLIENT pClient
    );

VOID
WINAPI
ReadClientInputCompleted(
    DWORD dwError,
    DWORD cbRead,
    LPOVERLAPPED lpO
    );

VOID
WINAPI
WriteChildStdInCompleted(
    DWORD dwError,
    DWORD cbWritten,
    LPOVERLAPPED lpO
    );

#define OUT_PIPE -1

VOID
FASTCALL
CreatePipeAndIssueConnect(
    int  nIndex   // IN pipe index or OUT_PIPE
    );

VOID
FASTCALL
HandleOutPipeConnected(
    VOID
    );

VOID
APIENTRY
ConnectOutTimerFired(
    LPVOID pArg,
    DWORD  dwTimerLo,
    DWORD  dwTimerHi
    );

VOID
FASTCALL
HandleInPipeConnected(
    int nIndex
    );

VOID
FASTCALL
HandshakeWithRemoteClient(
    PREMOTE_CLIENT pClient
    );

VOID
FASTCALL
StartChildOutPipeRead(
    VOID
    );

VOID
WINAPI
ReadChildOutputCompleted(
    DWORD dwError,
    DWORD cbRead,
    LPOVERLAPPED lpO
    );

VOID
WINAPI
WriteTempFileCompleted(
    DWORD dwError,
    DWORD cbWritten,
    LPOVERLAPPED lpO
    );

VOID
FASTCALL
StartServerToClientFlow(
    VOID
    );

VOID
FASTCALL
StartReadTempFile(
    PREMOTE_CLIENT pClient
    );

VOID
WINAPI
ReadTempFileCompleted(
    DWORD dwError,
    DWORD cbRead,
    LPOVERLAPPED lpO
    );

VOID
FASTCALL
StartWriteSessionOutput(
    PREMOTE_CLIENT pClient
    );

BOOL
FASTCALL
WriteSessionOutputCompletedCommon(
    PREMOTE_CLIENT pClient,
    DWORD dwError,
    DWORD cbWritten,
    LPOVERLAPPED_COMPLETION_ROUTINE lpCompletionRoutine
    );

VOID
WINAPI
WriteSessionOutputCompletedWriteNext(
    DWORD dwError,
    DWORD cbWritten,
    LPOVERLAPPED lpO
    );

VOID
WINAPI
WriteSessionOutputCompletedReadNext(
    DWORD dwError,
    DWORD cbWritten,
    LPOVERLAPPED lpO
    );

VOID
FASTCALL
HandshakeWithRemoteClient(
    PREMOTE_CLIENT pClient
    );


VOID
WINAPI
ReadClientNameCompleted(
    DWORD dwError,
    DWORD cbRead,
    LPOVERLAPPED lpO
    );

VOID
WINAPI
WriteServerReplyCompleted(
    DWORD dwError,
    DWORD cbWritten,
    LPOVERLAPPED lpO
    );

VOID
WINAPI
ReadClientStartupInfoSizeCompleted(
    DWORD dwError,
    DWORD cbRead,
    LPOVERLAPPED lpO
    );

VOID
WINAPI
ReadClientStartupInfoCompleted(
    DWORD dwError,
    DWORD cbRead,
    LPOVERLAPPED lpO
    );

PCHAR
GetFormattedTime(
    BOOL bDate
    );

HANDLE
ForkChildProcess(          // Creates a new process
    char *cmd,             // Redirects its stdin,stdout
    PHANDLE in,            // and stderr - returns the
    PHANDLE out            // corresponding pipe ends.
    );

BOOL
FilterCommand(             //Filters input from client
    REMOTE_CLIENT *cl,      //for commands intended for REMOTE
    char *buff,
    int dread
    );

BOOL
WINAPI
SrvCtrlHand(
    DWORD event
    );

DWORD
WINAPI
SendStatus(
    LPVOID   lpSendStatusParm
    );

DWORD
WINAPI
ShowPopup(
    void *vpArg
    );

VOID
RemoveInpMark(
    char* Buff,
    DWORD Size
    );

VOID
CloseClient(
    REMOTE_CLIENT *Client
    );

PSECURITY_DESCRIPTOR
FormatSecurityDescriptor(
    CHAR * * DenyNames,
    DWORD    DenyCount,
    CHAR * * Names,
    DWORD    Count
    );

BOOL
FASTCALL
HandleSessionError(
    PREMOTE_CLIENT pClient,
    DWORD         dwError
    );

VOID
FASTCALL
CleanupTempFiles(
    PSZ pszTempDir
    );

VOID
FASTCALL
SetupSecurityDescriptors(
    VOID
    );

VOID
FASTCALL
RuntimeLinkAPIs(
    VOID
    );

VOID
FASTCALL
InitializeClientLists(
    VOID
    );

VOID
FASTCALL
AddClientToHandshakingList(
    PREMOTE_CLIENT pClient
    );

VOID
FASTCALL
MoveClientToNormalList(
    PREMOTE_CLIENT pClient
    );

VOID
FASTCALL
MoveClientToClosingList(
    PREMOTE_CLIENT pClient
    );

PREMOTE_CLIENT
FASTCALL
RemoveFirstClientFromClosingList(
    VOID
    );


VOID
InitAd(
   BOOL IsAdvertise
   );

VOID
ShutAd(
   BOOL IsAdvertise
   );

VOID
APIENTRY
AdvertiseTimerFired(
    LPVOID pArg,
    DWORD  dwTimerLo,
    DWORD  dwTimerHi
    );

VOID
WINAPI
WriteMailslotCompleted(
    DWORD dwError,
    DWORD cbWritten,
    LPOVERLAPPED lpO
    );

VOID
FASTCALL
InitializeQueryServer(
    VOID
    );

VOID
FASTCALL
QueryWaitCompleted(
    VOID
    );

VOID
FASTCALL
StartServingQueryPipe(
    VOID
    );

DWORD
WINAPI
QueryHandlerThread(
    LPVOID   lpUnused
    );

BOOL
CALLBACK
EnumWindowProc(
    HWND hWnd,
    LPARAM lParam
    );

//
// Declare pointers to runtime-linked functions
//

HANDLE
(WINAPI *pfnCreateWaitableTimer)(
    LPSECURITY_ATTRIBUTES lpTimerAttributes,
    BOOL bManualReset,
    LPCSTR lpTimerName
    );

BOOL
(WINAPI *pfnSetWaitableTimer)(
    HANDLE hTimer,
    const LARGE_INTEGER *lpDueTime,
    LONG lPeriod,
    PTIMERAPCROUTINE pfnCompletionRoutine,
    LPVOID lpArgToCompletionRoutine,
    BOOL fResume
    );

BOOL
(WINAPI *pfnCancelWaitableTimer)(
    HANDLE hTimer
    );

BOOL
(WINAPI *pfnCancelIo)(
    HANDLE hFile
    );

#define CANCELIO(hFile)  (pfnCancelIo) ? ( pfnCancelIo(hFile) ) : 0;

NET_API_STATUS
(NET_API_FUNCTION *pfnNetWkstaGetInfo)(
    IN  LPTSTR  servername OPTIONAL,
    IN  DWORD   level,
    OUT LPBYTE  *bufptr
    );

NET_API_STATUS
(NET_API_FUNCTION *pfnNetApiBufferFree)(
    IN LPVOID Buffer
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\remote\srvad.c ===
#include <windows.h>
#include <stdio.h>
#include <string.h>
#include "Remote.h"
#include "Server.h"

//
// This module uses mailslots to broadcast the existence of
// this remote server to allow a form of browsing for
// remote server instances.  This is disabled in the
// customer version of remote.exe, and can be disabled
// in the internal version using the /v- switch to
// remote /s.
//
// remoteds.c implements a listener that allows searching.
//

#define  INITIAL_SLEEP_PERIOD (35 * 1000)          // 35 seconds before first
#define  INITIAL_AD_RATE      (10 * 60 * 1000)     // 10 minutes between 1 & 2,
#define  MAXIMUM_AD_RATE      (120 * 60 * 1000)    // doubling until 120 minutes max


OVERLAPPED olMailslot;
HANDLE     hAdTimer = INVALID_HANDLE_VALUE;
HANDLE     hMailslot = INVALID_HANDLE_VALUE;
DWORD      dwTimerInterval;      // milliseconds
BOOL       bSynchAdOnly;
BOOL       bSendingToMailslot;
char       szMailslotName[64];    // netbios names are short
char       szSend[1024];


#define MAX_MAILSLOT_SPEWS 2
DWORD      dwMailslotErrors;


VOID
InitAd(
   BOOL IsAdvertise
   )
{
    DWORD           cb;
    PWKSTA_INFO_101 pwki101;
    LARGE_INTEGER   DueTime;

    if (IsAdvertise) {

        // Unless Win32s or Win9x support named pipe servers...

        ASSERT(OsVersionInfo.dwPlatformId == VER_PLATFORM_WIN32_NT);

        // Problems with overlapped writes to a mailslot sometimes
        // cause remote.exe to zombie on exit on NT4, undebuggable
        // and unkillable because of an abandoned RDR1 IRP which
        // never completes.
        //
        // So on NT4 we only send messages at startup and shutdown
        // and send them synchronously using a nonoverlapped handle.
        //

        bSynchAdOnly = (OsVersionInfo.dwMajorVersion <= 4);

        //
        // Get currently active computername and browser/mailslot
        // domain/workgroup using one call to NetWkstaGetInfo.
        // This is unicode-only, we'll use wsprintf's %ls to
        // convert to 8-bit characters.
        //
        // remoteds.exe needs to be run on a workstation that is
        // part of the domain or workgroup of the same name,
        // and be in broadcast range, to receive our sends.
        //

        if (pfnNetWkstaGetInfo(NULL, 101, (LPBYTE *) &pwki101)) {
            printf("REMOTE: unable to get computer/domain name, not advertising.\n");
            return;
        }

        wsprintf(
            szMailslotName,
            "\\\\%ls\\MAILSLOT\\REMOTE\\DEBUGGERS",
            pwki101->wki101_langroup
            );

        wsprintf(
            szSend,
            "%ls\t%d\t%s\t%s",
            pwki101->wki101_computername,
            GetCurrentProcessId(),
            PipeName,
            ChildCmd
            );

        pfnNetApiBufferFree(pwki101);
        pwki101 = NULL;

        //
        // Broadcast mailslots are limited to 400 message bytes
        //

        szSend[399] = 0;

        if (bSynchAdOnly) {

            hMailslot =
                CreateFile(
                    szMailslotName,
                    GENERIC_WRITE,
                    FILE_SHARE_WRITE,
                    NULL,
                    OPEN_EXISTING,
                    0,
                    NULL
                    );
            if (hMailslot != INVALID_HANDLE_VALUE) {
                if ( ! WriteFile(
                           hMailslot,
                           szSend,
                           strlen(szSend) + 1,
                           &cb,
                           NULL
                           )) {
    
                    printf("REMOTE: WriteFile Failed on mailslot, error %d\n", GetLastError());
                }
            } else {
                printf("REMOTE: Failed to create mailslot, error %d\n", GetLastError());
            }


        } else {  // we can do async mailslot I/O

            //
            // Create a waitable timer and set it to fire first in
            // INITIAL_SLEEP_PERIOD milliseconds by calling the
            // completion routine AdvertiseTimerFired.  It will
            // be given an inital period of INITIAL_AD_RATE ms.
            //

            hAdTimer =
                pfnCreateWaitableTimer(
                    NULL,               // security
                    FALSE,              // bManualReset, we want auto-reset
                    NULL                // unnamed
                    );

            DueTime.QuadPart = Int32x32To64(INITIAL_SLEEP_PERIOD, -10000);
            dwTimerInterval = INITIAL_AD_RATE;

            pfnSetWaitableTimer(
                hAdTimer,
                &DueTime,
                dwTimerInterval,
                AdvertiseTimerFired,
                0,                     // arg to compl. rtn
                TRUE
                );

        }
    }
}


VOID
ShutAd(
   BOOL IsAdvertise
   )
{
    DWORD cb;
    BOOL  b;

    if (IsAdvertise) {

        if (INVALID_HANDLE_VALUE != hAdTimer) {

            pfnCancelWaitableTimer(hAdTimer);
            CloseHandle(hAdTimer);
            hAdTimer = INVALID_HANDLE_VALUE;
        }

        if (INVALID_HANDLE_VALUE != hMailslot &&
            ! bSendingToMailslot) {

            //
            // Tell any listening remoteds's we're
            // outta here.  Do this by tacking on
            // a ^B at the end of the string (as
            // in Bye).
            //

            strcat(szSend, "\x2");


            if (bSynchAdOnly) {   // overlapped handle or not?
                b = WriteFile(
                        hMailslot,
                        szSend,
                        strlen(szSend) + 1,
                        &cb,
                        NULL
                        );
            } else {
                b = WriteFileSynch(
                        hMailslot,
                        szSend,
                        strlen(szSend) + 1,
                        &cb,
                        0,
                        &olMainThread
                        );
            }

            if ( ! b ) {

                printf("REMOTE: WriteFile Failed on mailslot, error %d\n", GetLastError());
            }

        }

        if (INVALID_HANDLE_VALUE != hMailslot) {

            printf("\rREMOTE: closing mailslot...       ");
            fflush(stdout);
            CloseHandle(hMailslot);
            hMailslot = INVALID_HANDLE_VALUE;
            printf("\r                                  \r");
            fflush(stdout);
        }
    }
}


VOID
APIENTRY
AdvertiseTimerFired(
    LPVOID pArg,
    DWORD  dwTimerLo,
    DWORD  dwTimerHi
    )
{
    UNREFERENCED_PARAMETER( pArg );
    UNREFERENCED_PARAMETER( dwTimerLo );
    UNREFERENCED_PARAMETER( dwTimerHi );


    if (INVALID_HANDLE_VALUE == hMailslot) {

        hMailslot =
            CreateFile(
                szMailslotName,
                GENERIC_WRITE,
                FILE_SHARE_WRITE,
                NULL,
                OPEN_EXISTING,
                FILE_FLAG_OVERLAPPED,
                NULL
                );
    }

    if (INVALID_HANDLE_VALUE != hMailslot) {

        ZeroMemory(&olMailslot, sizeof(olMailslot));

        bSendingToMailslot = TRUE;

        if ( ! WriteFileEx(
                   hMailslot,
                   szSend,
                   strlen(szSend) + 1,
                   &olMailslot,
                   WriteMailslotCompleted
                   )) {

            bSendingToMailslot = FALSE;

            if (++dwMailslotErrors <= MAX_MAILSLOT_SPEWS) {

                DWORD dwError;
                char szErrorText[512];

                dwError = GetLastError();

                FormatMessage(
                    FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_IGNORE_INSERTS,
                    NULL,
                    dwError,
                    0,
                    szErrorText,
                    sizeof szErrorText,
                    NULL
                    );

                //
                // FormatMessage has put a newline at the end of szErrorText
                //

                printf(
                    "REMOTE: Advertisement failed, mailslot error %d:\n%s",
                    dwError,
                    szErrorText
                    );
            }

            //
            // Try reopening the mailslot next time, can't hurt.
            //

            CloseHandle(hMailslot);
            hMailslot = INVALID_HANDLE_VALUE;
        }
    }
}


VOID
WINAPI
WriteMailslotCompleted(
    DWORD dwError,
    DWORD cbWritten,
    LPOVERLAPPED lpO
    )
{
    LARGE_INTEGER DueTime;

    bSendingToMailslot = FALSE;

    if (dwError ||
        (strlen(szSend) + 1) != cbWritten) {

            if (++dwMailslotErrors <= MAX_MAILSLOT_SPEWS) {
                printf("REMOTE: write failed on mailslot, error %d cb %d (s/b %d)\n",
                    dwError, cbWritten, (strlen(szSend) + 1));
            }
        return;
    }

    //
    // If we succeeded in writing the mailslot, double the timer interval
    // up to the limit.
    //

    if (dwTimerInterval < MAXIMUM_AD_RATE) {

        dwTimerInterval = max(dwTimerInterval * 2, MAXIMUM_AD_RATE);

        DueTime.QuadPart = Int32x32To64(dwTimerInterval, -10000);

        if (INVALID_HANDLE_VALUE != hAdTimer) {

            pfnSetWaitableTimer(
                hAdTimer,
                &DueTime,
                dwTimerInterval,
                AdvertiseTimerFired,
                0,                     // arg to compl. rtn
                TRUE
                );
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\remote\srvctos.c ===
/******************************************************************************\
*       This is a part of the Microsoft Source Code Samples. 
*       Copyright 1995 - 1997 Microsoft Corporation.
*       All rights reserved. 
*       This source code is only intended as a supplement to 
*       Microsoft Development Tools and/or WinHelp documentation.
*       See these sources for detailed information regarding the 
*       Microsoft samples programs.
\******************************************************************************/

/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    SrvCtoS.c

Abstract:

    This file implements the client-to-server flow
    of data for remote server.  The data is the keyboard
    or piped input that the client received and sent
    over the wire to us, bracketed by BEGINMARK and ENDMARK
    bytes so we can display nice attribution comments in
    brackets next to input lines.

Author:

    Dave Hart  30 May 1997

Environment:

    Console App. User mode.

Revision History:

--*/

#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <io.h>
#include <string.h>
#include "Remote.h"
#include "Server.h"



VOID
FASTCALL
StartReadClientInput(
    PREMOTE_CLIENT pClient
    )
{
    //
    // Start read of data from this client's stdin.
    //

    if ( ! ReadFileEx(
               pClient->PipeReadH,
               pClient->ReadBuffer,
               BUFFSIZE - 1,                  // allow for null term
               &pClient->ReadOverlapped,
               ReadClientInputCompleted
               )) {

        CloseClient(pClient);
    }
}


VOID
WINAPI
ReadClientInputCompleted(
    DWORD dwError,
    DWORD cbRead,
    LPOVERLAPPED lpO
    )
{
    PREMOTE_CLIENT pClient;

    pClient = CONTAINING_RECORD(lpO, REMOTE_CLIENT, ReadOverlapped);

    if (HandleSessionError(pClient, dwError) ||
        !cbRead) {

        return;
    }

    pClient->ReadBuffer[cbRead] = 0;

    if (FilterCommand(pClient, pClient->ReadBuffer, cbRead)) {

        //
        // Local command, don't pass it to child app, just
        // start another client read.
        //

        if ( ! ReadFileEx(
                   pClient->PipeReadH,
                   pClient->ReadBuffer,
                   BUFFSIZE - 1,                  // allow for null term
                   &pClient->ReadOverlapped,
                   ReadClientInputCompleted
                   )) {

            CloseClient(pClient);
        }

    } else {

        //
        // Write buffer to child stdin.
        //

        if ( ! WriteFileEx(
                   hWriteChildStdIn,
                   pClient->ReadBuffer,
                   cbRead,
                   &pClient->ReadOverlapped,
                   WriteChildStdInCompleted
                   )) {

            // Child is going away.  Let this client's chain of IO stop.
        }
    }
}


VOID
WINAPI
WriteChildStdInCompleted(
    DWORD dwError,
    DWORD cbWritten,
    LPOVERLAPPED lpO
    )
{
    PREMOTE_CLIENT pClient;

    pClient = CONTAINING_RECORD(lpO, REMOTE_CLIENT, ReadOverlapped);

    if (HandleSessionError(pClient, dwError)) {

        return;
    }

    //
    // Start another read against the client input.
    //

    StartReadClientInput(pClient);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\remote\srvchild.c ===
/******************************************************************************\
*       This is a part of the Microsoft Source Code Samples. 
*       Copyright 1992 - 1997 Microsoft Corporation.
*       All rights reserved. 
*       This source code is only intended as a supplement to 
*       Microsoft Development Tools and/or WinHelp documentation.
*       See these sources for detailed information regarding the 
*       Microsoft samples programs.
\******************************************************************************/

/*++

Copyright 1992 - 1997 Microsoft Corporation

Module Name:

    SrvChild.c

Abstract:

    The server component of Remote. It spawns a child process
    and redirects the stdin/stdout/stderr of child to itself.
    Waits for connections from clients - passing the
    output of child process to client and the input from clients
    to child process.

Author:

    Rajivendra Nath  2-Jan-1992
    Dave Hart        30 May 1997 split from Server.c

Environment:

    Console App. User mode.

Revision History:

--*/

#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <process.h>
#include <io.h>
#include <string.h>
#include "Remote.h"
#include "Server.h"


VOID
FASTCALL
StartChildOutPipeRead(
    VOID
    )
{
    ReadChildOverlapped.OffsetHigh =
        ReadChildOverlapped.Offset = 0;

    if ( ! ReadFileEx(
               hReadChildOutput,
               ReadChildBuffer,
               sizeof(ReadChildBuffer) - 1,                  // allow for null term
               &ReadChildOverlapped,
               ReadChildOutputCompleted
               )) {

        if (INVALID_HANDLE_VALUE != hWriteChildStdIn) {

            CANCELIO( hWriteChildStdIn );
            CloseHandle( hWriteChildStdIn );
            hWriteChildStdIn = INVALID_HANDLE_VALUE;
        }
    }
}


VOID
WINAPI
ReadChildOutputCompleted(
    DWORD dwError,
    DWORD cbRead,
    LPOVERLAPPED lpO
    )
{
    UNREFERENCED_PARAMETER(lpO);

    //
    // We can get called after hWriteTempFile
    // is closed after the child has exited.
    //

    if (! dwError &&
        INVALID_HANDLE_VALUE != hWriteTempFile) {

        //
        // Start a write to the temp file.
        //

        ReadChildOverlapped.OffsetHigh = 0;
        ReadChildOverlapped.Offset = dwWriteFilePointer;

        if ( ! WriteFileEx(
                   hWriteTempFile,
                   ReadChildBuffer,
                   cbRead,
                   &ReadChildOverlapped,
                   WriteTempFileCompleted
                   )) {

            dwError = GetLastError();

            if (ERROR_DISK_FULL == dwError) {

                printf("Remote: disk full writing temp file %s, exiting\n", SaveFileName);

                if (INVALID_HANDLE_VALUE != hWriteChildStdIn) {

                    CANCELIO( hWriteChildStdIn );
                    CloseHandle( hWriteChildStdIn );
                    hWriteChildStdIn = INVALID_HANDLE_VALUE;
                }

            } else {

                ErrorExit("WriteFileEx for temp file failed.");
            }
        }
    }
}


VOID
WINAPI
WriteTempFileCompleted(
    DWORD dwError,
    DWORD cbWritten,
    LPOVERLAPPED lpO
    )
{
    UNREFERENCED_PARAMETER(lpO);

    if (dwError) {

        if (ERROR_DISK_FULL == dwError) {

            printf("Remote: disk full writing temp file %s, exiting\n", SaveFileName);

            if (INVALID_HANDLE_VALUE != hWriteChildStdIn) {

                CANCELIO( hWriteChildStdIn );
                CloseHandle( hWriteChildStdIn );
                hWriteChildStdIn = INVALID_HANDLE_VALUE;
            }

            return;

        } else {

            SetLastError(dwError);
            ErrorExit("WriteTempFileCompleted may need work");
        }
    }

    dwWriteFilePointer += cbWritten;

    TRACE(CHILD, ("Wrote %d bytes to temp file\n", cbWritten));

    StartServerToClientFlow();

    //
    // Start another read against the child input.
    //

    StartChildOutPipeRead();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\remote\srvhshak.c ===
/******************************************************************************\
*       This is a part of the Microsoft Source Code Samples.
*       Copyright 1995 - 1997 Microsoft Corporation.
*       All rights reserved.
*       This source code is only intended as a supplement to
*       Microsoft Development Tools and/or WinHelp documentation.
*       See these sources for detailed information regarding the
*       Microsoft samples programs.
\******************************************************************************/

/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    SrvHShak.c

Abstract:

    The server component of Remote.  Handshake with
    client at start of session.


Author:

    Dave Hart  30 May 1997

Environment:

    Console App. User mode.

Revision History:

--*/

#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <io.h>
#include <string.h>
#include "Remote.h"
#include "Server.h"




VOID
FASTCALL
HandshakeWithRemoteClient(
    PREMOTE_CLIENT pClient
    )
{
    pClient->ServerFlags |= SFLG_HANDSHAKING;

    AddClientToHandshakingList(pClient);

    //
    // Read hostname from client
    //

    ZeroMemory(
        &pClient->ReadOverlapped,
        sizeof(pClient->ReadOverlapped)
        );

    if ( ! ReadFileEx(
               pClient->PipeReadH,
               pClient->Name,
               HOSTNAMELEN - 1,
               &pClient->ReadOverlapped,
               ReadClientNameCompleted
               )) {

        CloseClient(pClient);
    }
}

VOID
WINAPI
ReadClientNameCompleted(
    DWORD dwError,
    DWORD cbRead,
    LPOVERLAPPED lpO
    )
{
    PREMOTE_CLIENT pClient;
    SESSION_STARTREPLY ssr;

    pClient = CONTAINING_RECORD(lpO, REMOTE_CLIENT, ReadOverlapped);

    if (pClient->ServerFlags & SFLG_CLOSING) {

        return;
    }

    if (dwError) {
        CloseClient(pClient);
        return;
    }

    if ((HOSTNAMELEN - 1) != cbRead) {
        printf("ReadClientNameCompleted read %d s/b %d.\n", cbRead, (HOSTNAMELEN - 1));
        CloseClient(pClient);
        return;
    }

    //
    // The client name read is 15 bytes always.  The last four
    // should match MAGICNUMBER, which conveniently has the
    // low byte zeroed to terminate the client name after 11
    // characters.
    //

    if (MAGICNUMBER != *(DWORD UNALIGNED *)&pClient->Name[11]) {

        pClient->Name[11] = 0;
        CloseClient(pClient);
        return;
    }

    //
    // Now we can tell if this is a single-pipe or two-pipe
    // client, because single-pipe clients replace the
    // first byte of the computername with the illegal
    // character '?'.
    //

    if ('?' == pClient->Name[0]) {

        pClient->PipeWriteH = pClient->PipeReadH;

        TRACE(CONNECT, ("Client %d pipe %p is single-pipe.\n", pClient->dwID, pClient->PipeWriteH));

        //
        // In order for things to work reliably for 2-pipe clients
        // when there are multiple remote servers on the same pipename,
        // we need to tear down the listening OUT pipe and recreate it so
        // that the oldest listening IN pipe will be from the same process
        // as the oldest listening OUT pipe.
        //

        if (1 == cConnectIns) {

            TRACE(CONNECT, ("Recycling OUT pipe %p as well for round-robin behavior.\n",
                            hPipeOut));

            CANCELIO(hPipeOut);
            DisconnectNamedPipe(hPipeOut);
            CloseHandle(hPipeOut);
            hPipeOut = INVALID_HANDLE_VALUE;
            bOutPipeConnected = FALSE;

            CreatePipeAndIssueConnect(OUT_PIPE);
        }

    } else {

        if ( ! bOutPipeConnected ) {

            printf("Remote: %p two-pipe client connected to IN pipe but not OUT?\n", pClient);
            CloseClient(pClient);
            return;
        }

        bOutPipeConnected = FALSE;

        if (INVALID_HANDLE_VALUE != hConnectOutTimer) {
            pfnCancelWaitableTimer(hConnectOutTimer);
        }

        pClient->PipeWriteH = hPipeOut;
        hPipeOut = INVALID_HANDLE_VALUE;

        TRACE(CONNECT, ("Client %d is dual-pipe IN %p OUT %p.\n", pClient->dwID, pClient->PipeReadH, pClient->PipeWriteH));

        CreatePipeAndIssueConnect(OUT_PIPE);
    }

    TRACE(SHAKE, ("Read client name %s\n", pClient->Name));

    //
    // Send our little pile of goodies to the client
    //

    ssr.MagicNumber = MAGICNUMBER;
    ssr.Size = sizeof(ssr);
    ssr.FileSize = dwWriteFilePointer;

    //
    // Copy ssr structure to a buffer that will be around
    // for the entire I/O.
    //

    CopyMemory(pClient->WriteBuffer, &ssr, sizeof(ssr));

    if ( ! WriteFileEx(
               pClient->PipeWriteH,
               pClient->WriteBuffer,
               sizeof(ssr),
               &pClient->WriteOverlapped,
               WriteServerReplyCompleted
               )) {

        CloseClient(pClient);
    }
}


VOID
WINAPI
WriteServerReplyCompleted(
    DWORD dwError,
    DWORD cbWritten,
    LPOVERLAPPED lpO
    )
{
    PREMOTE_CLIENT pClient;

    pClient = CONTAINING_RECORD(lpO, REMOTE_CLIENT, WriteOverlapped);

    if (pClient->ServerFlags & SFLG_CLOSING) {

        return;
    }

    if (HandleSessionError(pClient, dwError)) {
        return;
    }

    TRACE(SHAKE, ("Wrote server reply\n"));

    //
    // Read the size of the SESSION_STARTUPINFO the client is
    // sending us, to deal gracefully with different versions
    // on client and server.
    //

    if ( ! ReadFileEx(
               pClient->PipeReadH,
               pClient->ReadBuffer,
               sizeof(DWORD),
               &pClient->ReadOverlapped,
               ReadClientStartupInfoSizeCompleted
               )) {

        CloseClient(pClient);
    }
}


VOID
WINAPI
ReadClientStartupInfoSizeCompleted(
    DWORD dwError,
    DWORD cbRead,
    LPOVERLAPPED lpO
    )
{
    PREMOTE_CLIENT pClient;
    DWORD dwSize;

    pClient = CONTAINING_RECORD(lpO, REMOTE_CLIENT, ReadOverlapped);

    if (HandleSessionError(pClient, dwError)) {

        return;
    }

    if (cbRead != sizeof(DWORD)) {

        CloseClient(pClient);
        return;
    }

    //
    // Sanity check the size
    //

    dwSize = *(DWORD *)pClient->ReadBuffer;

    if (dwSize > 1024) {
        CloseClient(pClient);
        return;
    }

    //
    // Squirrel away the size in the write buffer,
    // since during handshaking we never have both a
    // read and write pending this is OK.
    //

    *(DWORD *)pClient->WriteBuffer = dwSize;

    TRACE(SHAKE, ("Read client reply size %d\n", dwSize));

    //
    // Read the rest of the SESSION_STARTUPINFO into the read buffer
    // after the size.
    //

    RtlZeroMemory(
        &pClient->ReadOverlapped,
        sizeof(pClient->ReadOverlapped)
        );

    if ( ! ReadFileEx(
               pClient->PipeReadH,
               pClient->ReadBuffer + sizeof(DWORD),
               dwSize - sizeof(DWORD),
               &pClient->ReadOverlapped,
               ReadClientStartupInfoCompleted
               )) {

        CloseClient(pClient);
    }
}


VOID
WINAPI
ReadClientStartupInfoCompleted(
    DWORD dwError,
    DWORD cbRead,
    LPOVERLAPPED lpO
    )
{
    PREMOTE_CLIENT pClient;
    DWORD dwSize;
    SESSION_STARTUPINFO ssi;
    char  Buf[256];

    pClient = CONTAINING_RECORD(lpO, REMOTE_CLIENT, ReadOverlapped);

    if (HandleSessionError(pClient, dwError)) {

        return;
    }

    dwSize = *(DWORD *)pClient->WriteBuffer;

    if (cbRead != (dwSize - sizeof(ssi.Size))) {

        CloseClient(pClient);
        return;
    }

    CopyMemory(&ssi, pClient->ReadBuffer, min(dwSize, sizeof(ssi)));

    CopyMemory(pClient->Name, ssi.ClientName, sizeof(pClient->Name));
    pClient->Flag = ssi.Flag;

    if (ssi.Version != VERSION) {

        printf("Remote Warning: Server Version=%d Client Version=%d for %s\n", VERSION, ssi.Version, pClient->Name);
    }

    TRACE(SHAKE, ("Read client info, new name %s, %d lines\n", pClient->Name, ssi.LinesToSend));


    //
    // Set temp file position according to the client's
    // requested lines to send.  The heuristic of 45 chars
    // per average line is used by the client.  However since old clients
    // hardcode this knowledge and sit and spin trying to read that many
    // bytes before completing initialization, and because we might not send
    // that many due to stripping BEGINMARK and ENDMARK characters, we
    // use 50 chars per line to calculate the temp file position in hopes
    // the extra bytes will overcome the missing MARK characters.
    //

    pClient->dwFilePos = dwWriteFilePointer > (ssi.LinesToSend * 50)
                             ? dwWriteFilePointer - (ssi.LinesToSend * 50)
                             : 0;

    //
    // This client's ready to roll.
    //

    pClient->ServerFlags &= ~SFLG_HANDSHAKING;

    MoveClientToNormalList(pClient);

    //
    // Start read operation against this client's input.
    //

    StartReadClientInput(pClient);

    //
    // Announce the connection.
    //

    sprintf(Buf,
            "\n**Remote: Connected to %s %s%s [%s]\n",
            pClient->Name,
            pClient->UserName,
            (pClient->PipeReadH != pClient->PipeWriteH)
              ? " (two pipes)"
              : "",
            GetFormattedTime(TRUE));

    if (WriteFileSynch(hWriteTempFile,Buf,strlen(Buf),&dwSize,dwWriteFilePointer,&olMainThread)) {
        dwWriteFilePointer += dwSize;
        StartServerToClientFlow();
    }

    //
    // Start write cycle for client output from the temp
    // file.
    // not needed because of StartServerToClientFlow() just above
    // StartReadTempFile(pClient);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\remote\srvlist.h ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    SrvList.h

Abstract:

    List package for SrvList.c

Environment:

    Console App. User mode.

Revision History:

--*/

//
//  Doubly-linked list manipulation routines.  Implemented as macros
//  but logically these are procedures.
//

//
//  VOID
//  InitializeListHead(
//      PLIST_ENTRY ListHead
//      );
//

#define InitializeListHead(ListHead) (\
    (ListHead)->Flink = (ListHead)->Blink = (ListHead))

//
//  BOOLEAN
//  IsListEmpty(
//      PLIST_ENTRY ListHead
//      );
//

#define IsListEmpty(ListHead) \
    ((ListHead)->Flink == (ListHead))

//
//  PLIST_ENTRY
//  RemoveHeadList(
//      PLIST_ENTRY ListHead
//      );
//

#define RemoveHeadList(ListHead) \
    (ListHead)->Flink;\
    {RemoveEntryList((ListHead)->Flink)}

//
//  PLIST_ENTRY
//  RemoveTailList(
//      PLIST_ENTRY ListHead
//      );
//

#define RemoveTailList(ListHead) \
    (ListHead)->Blink;\
    {RemoveEntryList((ListHead)->Blink)}

//
//  VOID
//  RemoveEntryList(
//      PLIST_ENTRY Entry
//      );
//

#define RemoveEntryList(Entry) {\
    PLIST_ENTRY _EX_Blink;\
    PLIST_ENTRY _EX_Flink;\
    _EX_Flink = (Entry)->Flink;\
    _EX_Blink = (Entry)->Blink;\
    _EX_Blink->Flink = _EX_Flink;\
    _EX_Flink->Blink = _EX_Blink;\
    }

//
//  VOID
//  InsertTailList(
//      PLIST_ENTRY ListHead,
//      PLIST_ENTRY Entry
//      );
//

#define InsertTailList(ListHead,Entry) {\
    PLIST_ENTRY _EX_Blink;\
    PLIST_ENTRY _EX_ListHead;\
    _EX_ListHead = (ListHead);\
    _EX_Blink = _EX_ListHead->Blink;\
    (Entry)->Flink = _EX_ListHead;\
    (Entry)->Blink = _EX_Blink;\
    _EX_Blink->Flink = (Entry);\
    _EX_ListHead->Blink = (Entry);\
    }

//
//  VOID
//  InsertHeadList(
//      PLIST_ENTRY ListHead,
//      PLIST_ENTRY Entry
//      );
//

#define InsertHeadList(ListHead,Entry) {\
    PLIST_ENTRY _EX_Flink;\
    PLIST_ENTRY _EX_ListHead;\
    _EX_ListHead = (ListHead);\
    _EX_Flink = _EX_ListHead->Flink;\
    (Entry)->Flink = _EX_Flink;\
    (Entry)->Blink = _EX_ListHead;\
    _EX_Flink->Blink = (Entry);\
    _EX_ListHead->Flink = (Entry);\
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\remote\srvmain.c ===
/******************************************************************************\
*       This is a part of the Microsoft Source Code Samples.
*       Copyright 1995 - 1997 Microsoft Corporation.
*       All rights reserved.
*       This source code is only intended as a supplement to
*       Microsoft Development Tools and/or WinHelp documentation.
*       See these sources for detailed information regarding the
*       Microsoft samples programs.
\******************************************************************************/

/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    SrvMain.c

Abstract:

    The server component of Remote. It spawns a child process
    and redirects the stdin/stdout/stderr of child to itself.
    Waits for connections from clients - passing the
    output of child process to client and the input from clients
    to child process.

    This version uses overlapped I/O to do in one thread what
    the original uses 9 for.  Almost.  Because there is no way to
    get overlapped stdin/stdout handles, two threads sit around
    doing blocking I/O on stdin and stdout.  3 is better than 9.

    Unfortunately there's no CreatePipe()
    or equivalent option to open an overlapped handle to an anonymous
    pipe, so I stole the source for NT CreatePipe and hacked it to
    accept flags indicating overlapped for one or both ends of the
    anonymous pipe.  In our usage the child end handles are not
    overlapped but the server end handles are.


Author:

    Dave Hart  30 May 1997 after Server.c by
    Rajivendra Nath  2-Jan-1992

Environment:

    Console App. User mode.

Revision History:

--*/

#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <process.h>
#include <io.h>
#include <string.h>
#if DBG
    #undef NDEBUG           // so asserts work on chk builds
#endif
#include "Remote.h"
#define SERVER_H_NOEXTERN
#include "Server.h"


DWORD cbRemoteClient = sizeof(REMOTE_CLIENT);  // for debugging



/*************************************************************/
int
OverlappedServer(                    //Main routine for server.
    char* pszChildCmd,
    char* pszPipeNameArg
    )
{
    int    i;
    BOOL   b;
    DWORD  cWait;
    DWORD  dwWait;
    PREMOTE_CLIENT pClientRemove;

#if DBG
    // Trace = -1;   // all TR_ bits on (and then some)
#endif

    //
    // Initialize globals
    //

    pszPipeName = pszPipeNameArg;

    dwNextClientID = 1;           // local client will be 1
    cConnectIns = CONNECT_COUNT;
    cWait = MAX_WAIT_HANDLES;

    hHeap = HeapCreate(
                0,
                3 * sizeof(REMOTE_CLIENT),    // initial size
                3000 * sizeof(REMOTE_CLIENT)  // max
                );

    OsVersionInfo.dwOSVersionInfoSize = sizeof OsVersionInfo;
    b = GetVersionEx(&OsVersionInfo);
    ASSERT( b );

    printf("**************************************\n");
    printf("***********     REMOTE    ************\n");
    printf("***********     SERVER    ************\n");
    printf("**************************************\n");
    fflush(stdout);


    //
    // Setup the ACLs we need, taking into account any /u switches
    //

    SetupSecurityDescriptors();


    printf("To Connect: Remote /C %s \"%s\"\n\n", HostName, pszPipeName);
    fflush(stdout);


    //
    // runtime link to NT-only kernel32 APIs so we can
    // load on Win95 for client use.
    //

    RuntimeLinkAPIs();


    //
    // Setup our three lists of clients:  handshaking,
    // connected, and closing/closed.
    //

    InitializeClientLists();


    //
    // set _REMOTE environment variable to the pipe name (why?)
    //

    SetEnvironmentVariable("_REMOTE", pszPipeName);


    //
    // Create a tempfile for storing Child process output.
    //

    {
        char szTempDirectory[MAX_PATH + 1];

        GetTempPath(sizeof(szTempDirectory), szTempDirectory);

        //
        // Before we litter the temp directory with more REMnnn.TMP
        // files, let's delete all the orphaned ones we can.  This
        // will fail for temp files open by other remote servers.
        //

        CleanupTempFiles(szTempDirectory);

        GetTempFileName(szTempDirectory, "REM", 0, SaveFileName);
    }

    if ( ! (hWriteTempFile =
            CreateFile(
                SaveFileName,                       /* name of the file  */
                GENERIC_READ | GENERIC_WRITE,       /* access (read/write) mode */
                FILE_SHARE_READ | FILE_SHARE_WRITE, /* share mode   */
                NULL,                               /* security descriptor  */
                CREATE_ALWAYS,                      /* how to create    */
                FILE_FLAG_OVERLAPPED | FILE_ATTRIBUTE_NORMAL,
                NULL
                ))) {

        ErrorExit("Could not Create Temp File");
    }


    //
    // We don't want to have multiple IN pipes created and
    // awaiting connection simultaneously if there are
    // multiple remote server processes sharing different
    // sessions under the same pipe name.  This would be
    // hairy for several reasons including breaking the
    // current round-robin behavior of connections, since
    // the oldest server pipe is connected first.  So
    // we create/open a named event based on the pipe name and
    // set the event so that any other remote servers on the
    // same pipe will fall back to a single IN pipe listening.
    //

    {
        char szPerPipeEventName[1024];

        sprintf(
            szPerPipeEventName,
            "MSRemoteSrv%s",
            pszPipeName
            );

        rghWait[WAITIDX_PER_PIPE_EVENT] =
            CreateEvent(
                    &saPublic,  // security
                    TRUE,       // manual reset (synchronization)
                    FALSE,      // initially nonsignaled
                    szPerPipeEventName
                    );

        if (! rghWait[WAITIDX_PER_PIPE_EVENT]) {

            ErrorExit("Unable to create per-pipe event.");
        }

        if (ERROR_ALREADY_EXISTS == GetLastError()) {

            TRACE(CONNECT, ("Found previous server on '%s', using 1 listening pipe.\n", pszPipeName));

            SetEvent(rghWait[WAITIDX_PER_PIPE_EVENT]);

            for (i = 1; i < (int) cConnectIns; i++) {

                rghPipeIn[i] = INVALID_HANDLE_VALUE;
            }

            cWait = MAX_WAIT_HANDLES - cConnectIns + 1;
            cConnectIns = 1;

            //
            // We don't want to wait on the event handle, but it's easier
            // to have a handle in its slot, so dupe a handle to our own
            // process.  Note we toss the value of the created event handle
            // without closing it -- we want it to stay around but we're
            // done with it.
            //

            DuplicateHandle(
                GetCurrentProcess(),
                GetCurrentProcess(),
                GetCurrentProcess(),
                &rghWait[WAITIDX_PER_PIPE_EVENT],
                0,
                FALSE,
                DUPLICATE_SAME_ACCESS
                );

        }
    }


    //
    // Create the event for the OVERLAPPED structure
    // used by the main server thread for WriteFileSynch calls.
    //

    olMainThread.hEvent =
        CreateEvent(
            NULL,      // security
            TRUE,      // auto-reset
            FALSE,     // initially nonsignaled
            NULL       // unnamed
            );


    //
    // Create the events for the OVERLAPPED structures
    // used for ConnectNamedPipe operations.
    //

    olConnectOut.hEvent =
        rghWait[WAITIDX_CONNECT_OUT] =
            CreateEvent(
                NULL,    // security
                TRUE,    // manual reset as ConnectNamedPipe demands
                FALSE,   // initially nonsignaled
                NULL
                );

    for (i = 0;
         i < (int) cConnectIns;
         i++) {

        rgolConnectIn[i].hEvent =
            rghWait[WAITIDX_CONNECT_IN_BASE + i] =
                CreateEvent(
                    NULL,    // security
                    TRUE,    // manual reset as ConnectNamedPipe demands
                    FALSE,   // initially nonsignaled
                    NULL
                    );

    }


    //
    // Create a timer we'll use to detect 2-pipe clients connected to
    // OUT without ever connecting to IN so we can recycle our single
    // OUT instance and allow other two-pipe clients in again.
    // NT 3.51 doesn't have waitable timers, so we don't do that
    // error handling on that OS.  Same as old remote.exe.
    //

    if (pfnCreateWaitableTimer) {
        hConnectOutTimer =
            pfnCreateWaitableTimer(
                NULL,               // security
                FALSE,              // bManualReset, we want auto-reset
                NULL                // unnamed
                );
    } else {
        hConnectOutTimer = INVALID_HANDLE_VALUE;
    }


    //
    // Start the command as a child process
    //

    if (hAttachedProcess != INVALID_HANDLE_VALUE) {

        ChldProc = hAttachedProcess;
        hWriteChildStdIn = hAttachedWriteChildStdIn;
        hReadChildOutput = hAttachedReadChildStdOut;

    } else {

        ChldProc =
             ForkChildProcess(
                 ChildCmd,
                 &hWriteChildStdIn,
                 &hReadChildOutput
                 );
    }

    rghWait[WAITIDX_CHILD_PROCESS] = ChldProc;

    //
    // Set ^c/^break handler.  It will kill the child process on
    // ^break and pass ^c through to it.
    //

    SetConsoleCtrlHandler(SrvCtrlHand, TRUE);


    //
    // Setup local session and start first read against its input.
    // This starts a chain of completion routines that continues
    // until this server exits.
    //

    StartLocalSession();


    //
    // Start a read operation on the child output pipe.
    // This starts a chain of completion routines that continues
    // until the child terminates.
    //

    StartChildOutPipeRead();


    //
    // Start several async ConnectNamedPipe operations, to reduce the chance
    // of a client getting pipe busy errors.  Since there is no
    // completion port version of ConnectNamedPipe, we'll wait on the
    // events in the main loop below that indicate completion.
    //

    CreatePipeAndIssueConnect(OUT_PIPE);

    for (i = 0;
         i < (int) cConnectIns;
         i++) {

        CreatePipeAndIssueConnect(i);
    }


    InitAd(IsAdvertise);


    //
    // We may need to service the query pipe for remote /q clients.
    //

    InitializeQueryServer();


    //
    // main loop of thread, waits for ConnectNamedPipe completions
    // and handles them while remaining alertable for completion
    // routines to get called.
    //

    while (1) {

        dwWait =
            WaitForMultipleObjectsEx(
                cWait,
                rghWait,
                FALSE,          // wait on any handle, not all
                30 * 1000,      // ms
                TRUE            // alertable (completion routines)
                );


        if (WAIT_IO_COMPLETION == dwWait) {

            //
            // A completion routine was called.
            //

            continue;
        }


        if (WAIT_TIMEOUT == dwWait) {

            //
            // Presumably since we've timed out for 30 seconds
            // with no IO completion, closing clients have
            // finished any pending IOs and the memory can be
            // released.
            //

            while (pClientRemove = RemoveFirstClientFromClosingList()) {

                HeapFree(hHeap, 0, pClientRemove);
            }

            continue;
        }


        if (WAITIDX_CONNECT_OUT == dwWait) {

            HandleOutPipeConnected();
            continue;
        }


        if (WAITIDX_CONNECT_IN_BASE <= dwWait &&
            (WAITIDX_CONNECT_IN_BASE + CONNECT_COUNT) > dwWait) {

            HandleInPipeConnected( dwWait - WAITIDX_CONNECT_IN_BASE );
            continue;
        }


        if (WAITIDX_QUERYSRV_WAIT == dwWait ||
            WAITIDX_QUERYSRV_WAIT + WAIT_ABANDONED_0 == dwWait ) {

            //
            // The remote server which was handling the query pipe
            // has gone away.  We'll try to take over.
            //

            QueryWaitCompleted();

            continue;
        }


        if (WAITIDX_PER_PIPE_EVENT == dwWait) {

            //
            // Another server is starting on this same
            // pipename.  To be most compatible we need
            // to fall back to listening on only one
            // IN pipe instance.
            //

            if (1 != cConnectIns) {

                TRACE(CONNECT,
                      ("Another server starting on '%s', falling back to 1 IN listening pipe.\n",
                       pszPipeName
                       ));

                for (i = 1; i < (int) cConnectIns; i++) {

                    CANCELIO( rghPipeIn[i] );
                    DisconnectNamedPipe( rghPipeIn[i] );
                    CloseHandle( rghPipeIn[i] );
                    rghPipeIn[i] = INVALID_HANDLE_VALUE;

                }

                cWait = MAX_WAIT_HANDLES - cConnectIns + 1;

                cConnectIns = 1;

                //
                // We don't want to wait on the event handle, but it's easier
                // to have a handle in its slot, so dupe a handle to our own
                // process.  We toss the event handle without closing it so
                // it will stay around for future remote servers on the same
                // pipe name.
                //

                DuplicateHandle(
                    GetCurrentProcess(),
                    GetCurrentProcess(),
                    GetCurrentProcess(),
                    &rghWait[WAITIDX_PER_PIPE_EVENT],
                    0,
                    FALSE,
                    DUPLICATE_SAME_ACCESS
                    );
            }

            continue;
        }

        if (WAITIDX_CHILD_PROCESS == dwWait ||
            WAITIDX_READ_STDIN_DONE == dwWait) {

            if (INVALID_HANDLE_VALUE != hConnectOutTimer) {

                CloseHandle(hConnectOutTimer);
                hConnectOutTimer = INVALID_HANDLE_VALUE;
            }

            //
            // Cancel ConnectNamedPipe operations and close
            // the pipes
            //

            if (INVALID_HANDLE_VALUE != hPipeOut) {

                DisconnectNamedPipe( hPipeOut );
                CANCELIO( hPipeOut );
                CloseHandle( rghWait[WAITIDX_CONNECT_OUT] );
                rghWait[WAITIDX_CONNECT_OUT] = INVALID_HANDLE_VALUE;
            }

            for (i = 0;
                 i < (int) cConnectIns;
                 i++) {

                if (INVALID_HANDLE_VALUE != rghPipeIn[i]) {

                    TRACE(CONNECT, ("Tearing down listening IN pipe #%d.\n", i + 1));

                    DisconnectNamedPipe( rghPipeIn[i] );
                    CANCELIO( rghPipeIn[i] );
                    CloseHandle( rghPipeIn[i] );
                    rghPipeIn[i] = INVALID_HANDLE_VALUE;
                }

            }

            //
            // Cancel read against child process in/out pipes
            //

            if (INVALID_HANDLE_VALUE != hWriteChildStdIn) {

                CANCELIO( hWriteChildStdIn );
                CloseHandle( hWriteChildStdIn );
                hWriteChildStdIn = INVALID_HANDLE_VALUE;
            }

            if (INVALID_HANDLE_VALUE != hReadChildOutput) {

                CANCELIO( hReadChildOutput );
                CloseHandle( hReadChildOutput );
                hReadChildOutput = INVALID_HANDLE_VALUE;
            }

            //
            // Cancel client I/Os
            //

            bShuttingDownServer = TRUE;

            //
            // Note that CloseClient will remove entries from this list,
            // so we walk it starting at the head at each step.
            //

            for (pClientRemove = (PREMOTE_CLIENT) ClientListHead.Flink;
                 pClientRemove != (PREMOTE_CLIENT) &ClientListHead;
                 pClientRemove = (PREMOTE_CLIENT)  ClientListHead.Flink ) {

                CloseClient(pClientRemove);
            }

            //
            // on our way out...
            //

            break;
        }

        //
        // Unexpected WaitForMulipleObjectsEx return
        //

        printf("Remote: unknown wait return %d\n", dwWait);
        ErrorExit("fix srvmain.c");

    } // endless loop


    ShutAd(IsAdvertise);

    while (i = 0, GetExitCodeProcess(ChldProc, &i) &&
           STILL_ACTIVE == i) {

        printf("\nRemote: Waiting for child to exit.\n");
        WaitForSingleObjectEx(ChldProc, 10 * 1000, TRUE);
    }

    //
    // For some interesting reason when we're attached to
    // a debugger like ntsd and it exits, our printf
    // below comes out *after* the cmd.exe prompt, making
    // it look like we hung on exit even though cmd.exe is
    // patiently awaiting a command.  So suppress it.
    //

    if (hAttachedProcess == INVALID_HANDLE_VALUE) {
        printf("\nRemote exiting. Child (%s) exit code was %d.\n", ChildCmd, i);
    }

    CANCELIO(hWriteTempFile);
    CloseHandle(hWriteTempFile);
    hWriteTempFile = INVALID_HANDLE_VALUE;

    //
    // Flush any pending completion routines.
    //

    while (WAIT_IO_COMPLETION == SleepEx(50, TRUE)) {
        ;
    }

    if (!DeleteFile(SaveFileName)) {

        printf("Remote: Temp File %s not deleted..\n",SaveFileName);
    }

    return i;
}



VOID
FASTCALL
StartLocalSession(
    VOID
    )
{
    DWORD dwThreadId;
    char szHexAsciiId[9];

    pLocalClient = HeapAlloc(
                       hHeap,
                       HEAP_ZERO_MEMORY,
                       sizeof(*pLocalClient)
                       );

    if (!pLocalClient) {

        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        ErrorExit("Unable to allocate local client.");
    }

    pLocalClient->dwID = dwNextClientID++;
    sprintf(szHexAsciiId, "%08x", pLocalClient->dwID);
    CopyMemory(pLocalClient->HexAsciiId, szHexAsciiId, sizeof(pLocalClient->HexAsciiId));

    strcpy(pLocalClient->Name, "Local");
    pLocalClient->ServerFlags = SFLG_LOCAL;


    //
    // we need overlapped handles to stdin/stdout,
    // and woefully DuplicateHandle can't do it.
    // So we'll create two anonymous pipes and two
    // threads to shuffle data between stdin/stdout
    // and the pipes.  The server end of the pipes
    // is opened overlapped, the "client" end (used
    // by the threads) is not overlapped.
    //


    rgCopyPipe[0].hRead = GetStdHandle(STD_INPUT_HANDLE);
    if ( ! MyCreatePipeEx(&pLocalClient->PipeReadH, &rgCopyPipe[0].hWrite, NULL, 0, FILE_FLAG_OVERLAPPED, 0)) {
        ErrorExit("Cannot create local input pipe");
    }

    rgCopyPipe[1].hWrite = GetStdHandle(STD_OUTPUT_HANDLE);
    if ( ! MyCreatePipeEx(&rgCopyPipe[1].hRead, &pLocalClient->PipeWriteH, NULL, 0, 0, FILE_FLAG_OVERLAPPED)) {
        ErrorExit("Cannot create local output pipe");
    }

    rghWait[WAITIDX_READ_STDIN_DONE] = (HANDLE)
        _beginthreadex(
            NULL,                    // security
            0,                       // default stack size
            CopyPipeToPipe,          // proc
            (LPVOID) &rgCopyPipe[0], // parm
            0,                       // flags
            &dwThreadId
            );

    CloseHandle( (HANDLE)
        _beginthreadex(
            NULL,                    // security
            0,                       // default stack size
            CopyPipeToPipe,          // proc
            (LPVOID) &rgCopyPipe[1], // parm
            0,                       // flags
            &dwThreadId
            )
        );


    StartSession( pLocalClient );
}


//
// Two of these threads to deal with non-overlapped stdin/stdout.
// CRT is OK.
//

DWORD
WINAPI
CopyPipeToPipe(
    LPVOID   lpCopyPipeData
    )
{
    PCOPYPIPE psd = (PCOPYPIPE) lpCopyPipeData;
    DWORD cb;
    char achBuffer[BUFFSIZE];

    while (1) {
        if ( ! ReadFile(
                   psd->hRead,
                   achBuffer,
                   sizeof(achBuffer),
                   &cb,
                   NULL
                   )) {

            TRACE(COPYPIPE, ("CopyPipeToPipe ReadFile %s failed, exiting thread.\n",
                             (psd == &rgCopyPipe[0])
                                 ? "stdin"
                                 : "local client output pipe"));
            break;
        }

        if ( ! WriteFile(
                   psd->hWrite,
                   achBuffer,
                   cb,
                   &cb,
                   NULL
                   )) {

            TRACE(COPYPIPE, ("CopyPipeToPipe WriteFile %s failed, exiting thread.\n",
                             (psd == &rgCopyPipe[0])
                                 ? "local client input pipe"
                                 : "stdout"));
            break;
        }
    }

    return 0;
}


VOID
FASTCALL
StartSession(
    PREMOTE_CLIENT pClient
    )
{
    pClient->rSaveFile =
        CreateFile(
            SaveFileName,
            GENERIC_READ,
            FILE_SHARE_READ | FILE_SHARE_WRITE,
            NULL,
            OPEN_EXISTING,
            FILE_FLAG_OVERLAPPED,
            NULL
            );

    if ( ! pClient->rSaveFile) {

        printf("Remote:Cannot open ReadHandle to temp file:%d\n",GetLastError());

    } else {

        pClient->UserName[0] = 0;

        GetNamedPipeHandleState(
            pClient->PipeReadH,
            NULL,
            NULL,
            NULL,
            NULL,
            pClient->UserName,
            sizeof(pClient->UserName)
            );

        //
        // For every client except the local
        // stdin/stdout client, there's a copy of remote.exe
        // running in client mode on the other side.  Do
        // handshaking with it to setup options and check
        // versions.  HandshakeWithRemoteClient will start
        // the "normal" I/O cycle once the handshake cycle is
        // done.  Note it returns as soon as the first handshake
        // I/O is submitted.
        //

        if (pClient->ServerFlags & SFLG_LOCAL) {

            AddClientToHandshakingList(pClient);
            MoveClientToNormalList(pClient);

            //
            // Start read operation against this client's input.
            //

            StartReadClientInput(pClient);

            //
            // Start write cycle for client output from the temp
            // file.
            //

            StartReadTempFile(pClient);

        } else {

            HandshakeWithRemoteClient(pClient);
        }
    }
}




VOID
FASTCALL
CreatePipeAndIssueConnect(
    int  nIndex   // IN pipe index or OUT_PIPE
    )
{
    BOOL b;
    DWORD dwError;
    char szPipeName[BUFFSIZE];


    if (OUT_PIPE == nIndex) {
        TRACE(CONNECT, ("Creating listening OUT pipe.\n"));
    } else {
        TRACE(CONNECT, ("Creating listening IN pipe #%d.\n", nIndex + 1));
    }

    if (OUT_PIPE == nIndex) {

        sprintf(szPipeName, SERVER_WRITE_PIPE, ".", pszPipeName);

        hPipeOut =
            CreateNamedPipe(
                szPipeName,
                PIPE_ACCESS_OUTBOUND | FILE_FLAG_OVERLAPPED,
                PIPE_TYPE_BYTE,
                PIPE_UNLIMITED_INSTANCES,
                0,
                0,
                0,
                &saPipe
                );

        if (INVALID_HANDLE_VALUE == hPipeOut) {

            ErrorExit("Unable to CreateNamedPipe OUT");
        }

        b = ConnectNamedPipe(hPipeOut, &olConnectOut);


        if ( ! b ) {

            dwError = GetLastError();

            if (ERROR_PIPE_CONNECTED == dwError) {

                b = TRUE;
            }
        }

        if ( b ) {

            TRACE(CONNECT, ("Quick connect on OUT pipe.\n"));

            HandleOutPipeConnected();

        } else {

            if (ERROR_IO_PENDING != dwError) {

                ErrorExit("ConnectNamedPipe out failed");
            }
        }

    } else {

        sprintf(szPipeName, SERVER_READ_PIPE, ".", pszPipeName);

        rghPipeIn[nIndex] =
            CreateNamedPipe(
                szPipeName,
                PIPE_ACCESS_DUPLEX | FILE_FLAG_OVERLAPPED,
                PIPE_TYPE_BYTE,
                PIPE_UNLIMITED_INSTANCES,
                0,
                0,
                0,
                &saPipe
                );

        if (INVALID_HANDLE_VALUE == rghPipeIn[nIndex]) {

            if (ERROR_ACCESS_DENIED == GetLastError()) {
                if (DaclNameCount) {
                    ErrorExit("Unable to CreateNamedPipe, are YOU in the list of permitted users?");
                } else {
                    ErrorExit("Unable to CreateNamedPipe, maybe old remote server on same pipe name?");
                }
            } else {
                ErrorExit("Unable to CreateNamedPipe IN");
            }
        }

        b = ConnectNamedPipe(rghPipeIn[nIndex], &rgolConnectIn[nIndex]);

        if ( ! b ) {

            dwError = GetLastError();

            if (ERROR_PIPE_CONNECTED == dwError) {
                b = TRUE;
            }
        }

        if ( b ) {

            TRACE(CONNECT, ("Quick connect on IN pipe #%d.\n", nIndex));

            HandleInPipeConnected(nIndex);

        } else {

            if (ERROR_IO_PENDING != dwError) {

                ErrorExit("ConnectNamedPipe in failed");
            }
        }

    }

    if (OUT_PIPE == nIndex) {
        TRACE(CONNECT, ("Listening OUT pipe handle %p.\n", hPipeOut));
    } else {
        TRACE(CONNECT, ("Listening IN pipe #%d handle %p.\n", nIndex + 1, rghPipeIn[nIndex]));
    }
}


VOID
FASTCALL
HandleOutPipeConnected(
    VOID
    )
{
    LARGE_INTEGER DueTime;

    ResetEvent(rghWait[WAITIDX_CONNECT_OUT]);

    bOutPipeConnected = TRUE;

    TRACE(CONNECT, ("Two-pipe caller connected to OUT pipe %p.\n",
                    hPipeOut));

    //
    // Start a 1 minute timer in case we don't get a connection
    // on an IN pipe from this client, we'll recycle the OUT
    // pipe.
    //

    if (INVALID_HANDLE_VALUE != hConnectOutTimer) {

        DueTime.QuadPart = Int32x32To64(60 * 1000, -10000);

        pfnSetWaitableTimer(
            hConnectOutTimer,
            &DueTime,
            0,                     // not periodic, single-fire
            ConnectOutTimerFired,
            0,                     // arg to compl. rtn
            TRUE
            );
    }
}


VOID
APIENTRY
ConnectOutTimerFired(
    LPVOID pArg,
    DWORD  dwTimerLo,
    DWORD  dwTimerHi
    )
{
    UNREFERENCED_PARAMETER( pArg );
    UNREFERENCED_PARAMETER( dwTimerLo );
    UNREFERENCED_PARAMETER( dwTimerHi );

    //
    // We've had a connected OUT pipe for a minute now,
    // only two-pipe clients connect to that and they
    // immediately connect to IN afterwards.  Presumably
    // the client died between these two operations.  Until
    // we recycle the OUT pipe all two-pipe clients are
    // unable to connect getting pipe busy errors.
    //

    if ( ! bOutPipeConnected ) {

        TRACE(CONNECT, ("ConnectOut timer fired but Out pipe not connected.\n"));
        return;
    }

    TRACE(CONNECT, ("Two-pipe caller hung for 1 minute, recycling OUT pipe %p.\n",
                    hPipeOut));

    bOutPipeConnected = FALSE;

    CANCELIO(hPipeOut);
    DisconnectNamedPipe(hPipeOut);
    CloseHandle(hPipeOut);
    hPipeOut = INVALID_HANDLE_VALUE;

    CreatePipeAndIssueConnect(OUT_PIPE);

    //
    // In order for things to work reliably for 2-pipe clients
    // when there are multiple remote servers on the same pipename,
    // we need to tear down the listening IN pipe and recreate it so
    // that the oldest listening OUT pipe will be from the same process
    // as the oldest listening IN pipe.
    //

    if (1 == cConnectIns) {

        TRACE(CONNECT, ("Recycling IN pipe %p as well for round-robin behavior.\n",
                        rghPipeIn[0]));

        CANCELIO(rghPipeIn[0]);
        DisconnectNamedPipe(rghPipeIn[0]);
        CloseHandle(rghPipeIn[0]);
        rghPipeIn[0] = INVALID_HANDLE_VALUE;

        CreatePipeAndIssueConnect(0);
    }
}


VOID
FASTCALL
HandleInPipeConnected(
    int nIndex
    )
{
    PREMOTE_CLIENT pClient;
    char szHexAsciiId[9];

    ResetEvent(rghWait[WAITIDX_CONNECT_IN_BASE + nIndex]);

    if (nIndex >= (int) cConnectIns) {

        //
        // The I/O was cancelled on the excess
        // listening pipes, causing the event to
        // fire.
        //

        ASSERT(INVALID_HANDLE_VALUE == rghPipeIn[nIndex]);

        TRACE(CONNECT, ("IN pipe #%d, handle %p listen cancelled.\n",
                        nIndex + 1, rghPipeIn[nIndex]));

        return;
    }


    TRACE(CONNECT, ("Caller connected to IN pipe #%d, handle %p.\n",
                    nIndex + 1, rghPipeIn[nIndex]));

    //
    // A client is fully connected, but we don't know if
    // it's a single-pipe or two-pipe client.  Until
    // we do its PipeWriteH will be invalid.  We'll figure
    // it out in ReadClientNameCompleted.
    //

    pClient = HeapAlloc(
                  hHeap,
                  HEAP_ZERO_MEMORY,
                  sizeof(*pClient)
                  );

    if ( ! pClient) {

        printf("Out of memory connecting client, hanging up.\n");

        CloseHandle( rghPipeIn[nIndex] );
        rghPipeIn[nIndex] = INVALID_HANDLE_VALUE;
        CreatePipeAndIssueConnect( nIndex );


        if (bOutPipeConnected) {

             //
             // Hang up on the two-pipe caller connected to the
             // OUT pipe as well -- it may be this client or it
             // may be another, no way to tell, and really no
             // great need to because if it's another caller
             // we probably wouldn't be able to allocate memory
             // for it either.
             //
             // Also if we're using a single IN pipe for
             // multiple-server round-robin behavior we
             // want to recycle both pipes at the same time.
             //

            TRACE(CONNECT, ("Also hanging up on connected two-pipe caller on OUT pipe %p.\n",
                            hPipeOut));

            bOutPipeConnected = FALSE;

            if (INVALID_HANDLE_VALUE != hConnectOutTimer) {
                 pfnCancelWaitableTimer(hConnectOutTimer);
            }

            DisconnectNamedPipe(hPipeOut);
            CloseHandle(hPipeOut);
            hPipeOut = INVALID_HANDLE_VALUE;

            CreatePipeAndIssueConnect( OUT_PIPE );
        }

    } else {

        //
        // Initialize the Client
        //

        pClient->dwID = dwNextClientID++;
        sprintf(szHexAsciiId, "%08x", pClient->dwID);
        CopyMemory(pClient->HexAsciiId, szHexAsciiId, sizeof(pClient->HexAsciiId));

        pClient->PipeReadH   = rghPipeIn[nIndex];
        rghPipeIn[nIndex] = INVALID_HANDLE_VALUE;

        pClient->PipeWriteH  = INVALID_HANDLE_VALUE;

        TRACE(CONNECT, ("Handshaking new client %d (%p) on IN pipe handle %p.\n",
                        pClient->dwID, pClient, pClient->PipeReadH));

        //
        // Start another connect operation to replace this completed one.
        //

        CreatePipeAndIssueConnect( nIndex );

        //
        // Start session I/Os with the new client.  This will link it
        // into the handshaking list.
        //

        StartSession( pClient );

    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\remote\srvlist.c ===
/******************************************************************************\
*       This is a part of the Microsoft Source Code Samples. 
*       Copyright 1995 - 1997 Microsoft Corporation.
*       All rights reserved. 
*       This source code is only intended as a supplement to 
*       Microsoft Development Tools and/or WinHelp documentation.
*       See these sources for detailed information regarding the 
*       Microsoft samples programs.
\******************************************************************************/

/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    SrvList.c

Abstract:

    The server component of Remote.  This module
    implements three lists of REMOTE_CLIENT structures,
    for handshaking, connected, and closing clients.
    To simplify the interface items always progress
    through the three lists in order, with list node
    memory being freed as it is removed from the
    closing list.


Author:

    Dave Hart  30 May 1997

Environment:

    Console App. User mode.

Revision History:

--*/

#include <windows.h>
#include "Remote.h"
#include "Server.h"
#include "SrvList.h"


VOID
FASTCALL
InitializeClientLists(
    VOID
    )
{
    InitializeCriticalSection( &csHandshakingList );
    InitializeCriticalSection( &csClientList );
    InitializeCriticalSection( &csClosingClientList );

    InitializeListHead( &HandshakingListHead );
    InitializeListHead( &ClientListHead );
    InitializeListHead( &ClosingClientListHead );
}


VOID
FASTCALL
AddClientToHandshakingList(
    PREMOTE_CLIENT pClient
    )
{
    EnterCriticalSection( &csHandshakingList );

    InsertTailList( &HandshakingListHead, &pClient->Links );

    LeaveCriticalSection( &csHandshakingList );
}


VOID
FASTCALL
MoveClientToNormalList(
    PREMOTE_CLIENT pClient
    )
{
    EnterCriticalSection( &csHandshakingList );

    RemoveEntryList( &pClient->Links );

    LeaveCriticalSection( &csHandshakingList );


    EnterCriticalSection( &csClientList );

    InsertTailList( &ClientListHead, &pClient->Links );

    LeaveCriticalSection( &csClientList );
}


VOID
FASTCALL
MoveClientToClosingList(
    PREMOTE_CLIENT pClient
    )
{
    EnterCriticalSection( &csClientList );

    RemoveEntryList( &pClient->Links );

    LeaveCriticalSection( &csClientList );


    EnterCriticalSection( &csClosingClientList );

    InsertTailList( &ClosingClientListHead, &pClient->Links );

    LeaveCriticalSection( &csClosingClientList );
}


PREMOTE_CLIENT
FASTCALL
RemoveFirstClientFromClosingList(
    VOID
    )
{
    PREMOTE_CLIENT pClient;

    EnterCriticalSection( &csClosingClientList );

    if (IsListEmpty(&ClosingClientListHead)) {

        pClient = NULL;

    } else {

        pClient = (PREMOTE_CLIENT) RemoveHeadList( &ClosingClientListHead );

        ZeroMemory( &pClient->Links, sizeof(&pClient->Links) );

    }

    LeaveCriticalSection( &csClosingClientList );

    return pClient;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\remote\srvquery.c ===
/******************************************************************************\
*       This is a part of the Microsoft Source Code Samples. 
*       Copyright 1995 - 1997 Microsoft Corporation.
*       All rights reserved. 
*       This source code is only intended as a supplement to 
*       Microsoft Development Tools and/or WinHelp documentation.
*       See these sources for detailed information regarding the 
*       Microsoft samples programs.
\******************************************************************************/

/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    SrvQuery.c

Abstract:

    The server component of Remote.   Respond to client
    "remote /q" requests to list available remote servers
    on this machine.


Author:

    Dave Hart  30 May 1997
        derived from code by Mihai Costea in server.c.

Environment:

    Console App. User mode.

Revision History:

--*/

#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <process.h>
#include <io.h>
#include <string.h>
#include "Remote.h"
#include "Server.h"


VOID
FASTCALL
InitializeQueryServer(
    VOID
    )
{
    //
    // hQPipe is the handle to the listening query pipe,
    // if we're serving it.
    //

    hQPipe = INVALID_HANDLE_VALUE;

    QueryOverlapped.hEvent =
        CreateEvent(
            NULL,       // security
            TRUE,       // manual-reset
            FALSE,      // initially nonsignaled
            NULL        // unnamed
            );

    rghWait[WAITIDX_QUERYSRV_WAIT] =
        CreateMutex(
            &saPublic,   // security
            FALSE,       // not owner in case we open not create
            "MS RemoteSrv Q Mutex"
            );

    if (INVALID_HANDLE_VALUE == rghWait[WAITIDX_QUERYSRV_WAIT]) {

        ErrorExit("Remote: Unable to create/open query server mutex.\n");
    }
}


VOID
FASTCALL
QueryWaitCompleted(
    VOID
    )
{
    HANDLE hWait;
    DWORD dwThreadId;
    BOOL b;
    DWORD dwRead;

    //
    // The remote server (not us) which was servicing the query
    // pipe has left the arena.  Or someone has connected.
    //

    hWait = rghWait[WAITIDX_QUERYSRV_WAIT];

    if (hWait == QueryOverlapped.hEvent) {

        //
        // We're the query server and someone has connected.
        // Start a thread to service them.
        //

        b = GetOverlappedResult(hQPipe, &QueryOverlapped, &dwRead, TRUE);


        if ( !b && ERROR_PIPE_CONNECTED != GetLastError()) {

            TRACE(QUERY,("Connect Query Pipe returned %d\n", GetLastError()));

            if (INVALID_HANDLE_VALUE != hQPipe) {

                CloseHandle(hQPipe);
                hQPipe = INVALID_HANDLE_VALUE;
            }

        } else {

            TRACE(QUERY, ("Client connected to query pipe.\n"));

            ResetEvent(hWait);

            CloseHandle( (HANDLE)
                _beginthreadex(
                        NULL,             // security
                        0,                // default stack size
                        QueryHandlerThread,
                        (LPVOID) hQPipe,  // parameter
                        0,                // not suspended
                        &dwThreadId
                        ));

            hQPipe = INVALID_HANDLE_VALUE;
        }

    } else {

        TRACE(QUERY, ("Remote server entered query mutex, will handle queries.\n"));

        rghWait[WAITIDX_QUERYSRV_WAIT] = QueryOverlapped.hEvent;
    }


    //
    // Either a client has connected and we've handed that pipe
    // off to a query thread to deal with, or we're just starting
    // to serve the query pipe, or we had an error from
    // ConnectNamedPipe.  In any case we want to create another
    // query pipe instance and start listening on it.
    //

    ASSERT(INVALID_HANDLE_VALUE == hQPipe);

    StartServingQueryPipe();
}



VOID
FASTCALL
StartServingQueryPipe(
    VOID
    )
{
    BOOL  b;
    DWORD dwThreadId;
    char  fullname[BUFFSIZE];

    sprintf(fullname, QUERY_DEBUGGERS_PIPE, ".");

    do {      // hand off each pipe as connected until IO_PENDING
    
        hQPipe =
            CreateNamedPipe(
                fullname,
                PIPE_ACCESS_DUPLEX | FILE_FLAG_OVERLAPPED,
                PIPE_TYPE_BYTE | PIPE_WAIT,
                PIPE_UNLIMITED_INSTANCES,
                0,
                0,
                0,
                &saPublic
                );
        
        if (INVALID_HANDLE_VALUE == hQPipe) {

            ErrorExit("Unable to create query server pipe.");
        }

        b = ConnectNamedPipe(hQPipe, &QueryOverlapped);


        if ( ! b && ERROR_PIPE_CONNECTED == GetLastError()) {

            b = TRUE;
        }

        if (b) {

            //
            // That was fast.
            //

            TRACE(QUERY, ("Client connected quickly to query pipe.\n"));

            CloseHandle( (HANDLE)
                _beginthreadex(
                    NULL,              // security
                    0,                 // default stack size
                    QueryHandlerThread,
                    (LPVOID) hQPipe,   // parameter
                    0,                 // not suspended
                    &dwThreadId
                    ));

            hQPipe = INVALID_HANDLE_VALUE;


        } else if (ERROR_IO_PENDING == GetLastError()) {

            //
            // The main thread will call QueryWaitCompleted when
            // someone connects.
            //

            TRACE(QUERY, ("Awaiting query pipe connect\n"));

        } else {

            sprintf(fullname, "Remote: error %d connecting query pipe.\n", GetLastError());

            OutputDebugString(fullname);
            ErrorExit(fullname);
        }

    } while (b);
}


DWORD
WINAPI
QueryHandlerThread(
    LPVOID   lpvArg
    )
{
    HANDLE hQueryPipe = (HANDLE) lpvArg;
    DWORD cb;
    BOOL  b;
    OVERLAPPED ol;
    QUERY_MESSAGE QData;
    char  pIn[1];


    ZeroMemory(&ol, sizeof(ol));

    ol.hEvent =
        CreateEvent(
            NULL,       // security
            TRUE,       // manual-reset
            FALSE,      // initially nonsignaled
            NULL        // unnamed
            );


    // get command

    b = ReadFileSynch(
            hQueryPipe,
            pIn,
            1,
            &cb,
            0,
            &ol
            );

    if ( ! b || 1 != cb ) {
        TRACE(QUERY, ("Query server unable to read byte from query pipe.\n"));
        goto failure;
    }

    TRACE(QUERY, ("Query server read command '%c'\n", pIn[0]));

        //
        // !!!!!!
        // REMOVE 'h' support, it's only here for transitional compatibility
        // with 1570+ remote /q original server implementation.
        //

        if(pIn[0] == 'h') {

            DWORD dwMinusOne = (DWORD) -1;

            b = WriteFileSynch(
                    hQueryPipe,
                    &dwMinusOne,
                    sizeof(dwMinusOne),
                    &cb,
                    0,
                    &ol
                    );

            if ( !b || sizeof(dwMinusOne) != cb )
            {
                goto failure;
            }
        }

    if(pIn[0] == 'q') {

        QData.size  = 0;
        QData.allocated = 0;
        QData.out   = NULL;
                
        EnumWindows(EnumWindowProc, (LPARAM)&QData);

        b = WriteFileSynch(
                hQueryPipe,
                &QData.size,
                sizeof(QData.size),
                &cb,
                0,
                &ol
                );

        if ( ! b || sizeof(int) != cb) {

            TRACE(QUERY, ("Remote: Can't write query length\n"));
            goto failure;
        }
        
        if (QData.size) {         // anything to say?

            b = WriteFileSynch(
                     hQueryPipe,
                     QData.out,
                     QData.size * sizeof(char),
                     &cb,
                     0,
                     &ol
                     );

            free(QData.out);

            if ( ! b || QData.size * sizeof(char) != cb) {

                TRACE(QUERY, ("Remote: Can't write query"));
                goto failure;
            }


            TRACE(QUERY, ("Sent query response\n"));
        }
    }
            
    FlushFileBuffers(hQueryPipe);

  failure:
    DisconnectNamedPipe(hQueryPipe);
    CloseHandle(hQueryPipe);
    CloseHandle(ol.hEvent);

    return 0;
}






BOOL
CALLBACK
EnumWindowProc(
    HWND hWnd,
    LPARAM lParam
    )
{
    #define MAX_TITLELEN 200
    QUERY_MESSAGE *pQm;
    int titleLen;
    char title[MAX_TITLELEN];
    char* tmp;

    pQm = (QUERY_MESSAGE*)lParam;

    if(titleLen = GetWindowText(hWnd, title, sizeof(title)/sizeof(title[0])))
    {
        //
        // search for all windows that are visible 
        //

        if (strstr(title, "] visible") &&
            strstr(title, "[Remote "))
        {
            if(pQm->size)                           // if message not empty
                pQm->out[(pQm->size)++] = '\n';     // overwrite ending null with \n
            else
            {                                       
                pQm->out  = (char*)malloc(MAX_TITLELEN);     // first allocation
                if(!pQm->out)
                {
                    printf("\nOut of memory\n");
                    return FALSE;
                }
                pQm->allocated = MAX_TITLELEN;                               
            }

            // fill the result
            
            if((pQm->size + titleLen) >= pQm->allocated)
            {   
                tmp = (char*)realloc(pQm->out, pQm->allocated + MAX_TITLELEN);
                if(!tmp)
                {
                    printf("\nOut of memory\n");
                    free(pQm->out);
                    pQm->size = 0;                    
                    return FALSE;
                }
                pQm->out = tmp;            
                pQm->allocated += MAX_TITLELEN;
            }
            strcpy(pQm->out + pQm->size, title);
            pQm->size += titleLen;                
        }
    }
    
    return TRUE;
    #undef MAX_TITLELEN
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\restools\inc\common.h ===
/*++

(C) Copyright Microsoft Corporation 1988-1992

Module Name:

    common.h

Author:

    Floyd A Rogers 2/7/92

Revision History:
        Floyd Rogers
        Created
--*/

#define IN
#define OUT
#define INOUT

//
// An ID_WORD indicates the following WORD is an ordinal rather 
// than a string
// 

#define ID_WORD 0xffff

typedef struct _STRING {
        DWORD discriminant;       // long to make the rest of the struct aligned
	union u {
		struct {
		  struct _STRING *pnext;
                  DWORD  ulOffsetToString;
		  USHORT cbD;
		  USHORT cb;
		  WCHAR  sz[1];
		} ss;
		WORD     Ordinal;
	} uu;
} STRING, *PSTRING, **PPSTRING;

#define IS_STRING 1
#define IS_ID     2

// defines to make deferencing easier
#define OffsetToString uu.ss.ulOffsetToString
#define cbData         uu.ss.cbD
#define cbsz           uu.ss.cb
#define szStr          uu.ss.sz
#define pn             uu.ss.pnext

typedef struct _RESNAME {
    struct _RESNAME *pnext;    // The first three fields should be the
    PSTRING Name;              // same in both res structures
    DWORD   OffsetToData;      //

    PSTRING Type;
    struct _RESNAME *pnextRes;
    RESADDITIONAL	*pAdditional;
    DWORD   OffsetToDataEntry;
    USHORT  ResourceNumber;
    USHORT  NumberOfLanguages;
    POBJLST pObjLst;
} RESNAME, *PRESNAME, **PPRESNAME;

typedef struct _RESTYPE {
    struct _RESTYPE *pnext;    // The first three fields should be the
    PSTRING Type;              // same in both res structures
    DWORD   OffsetToData;      //

    struct _RESNAME *NameHeadID;
    struct _RESNAME *NameHeadName;
    DWORD  NumberOfNamesID;
    DWORD  NumberOfNamesName;
    POBJLST pObjLst;
} RESTYPE, *PRESTYPE, **PPRESTYPE;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\remote\srvstoc.c ===
/******************************************************************************\
*       This is a part of the Microsoft Source Code Samples.
*       Copyright 1995 - 1997 Microsoft Corporation.
*       All rights reserved.
*       This source code is only intended as a supplement to
*       Microsoft Development Tools and/or WinHelp documentation.
*       See these sources for detailed information regarding the
*       Microsoft samples programs.
\******************************************************************************/

/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    SrvStoC.c

Abstract:

    This file implements the server-to-client flow
    of data for remote server.  The data is the output
    of the child program intermingled with client input.

Author:

    Dave Hart  30 May 1997

Environment:

    Console App. User mode.

Revision History:

--*/

#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <io.h>
#include <string.h>
#include "Remote.h"
#include "Server.h"


VOID
FASTCALL
StartServerToClientFlow(
    VOID
    )
{
    PREMOTE_CLIENT pClient;

    //
    // Start read operations against the temp file for
    // all active clients that aren't currently doing
    // read temp/write client operations and that are
    // fully connected.
    //

    for (pClient = (PREMOTE_CLIENT) ClientListHead.Flink;
         pClient != (PREMOTE_CLIENT) &ClientListHead;
         pClient = (PREMOTE_CLIENT) pClient->Links.Flink ) {


        if (! pClient->cbWrite) {

            StartReadTempFile( pClient );
        }
    }
}


VOID
FASTCALL
StartReadTempFile(
    PREMOTE_CLIENT pClient
    )
{
    //
    // pClient->cbWrite is used dually.  WriteSessionOutputCompleted
    // uses it when 0 bytes are written to know how much to ask
    // to write when it resubmits the request.  We use it to
    // indicate whether a read temp/write session chain of I/Os
    // is currently active for this client.
    //

    if (pClient->cbWrite) {

        ErrorExit("StartReadTempFile entered with nonzero cbWrite.");
    }

    if (dwWriteFilePointer > pClient->dwFilePos) {

        pClient->cbWrite = min(BUFFSIZE,
                               dwWriteFilePointer - pClient->dwFilePos);

        pClient->WriteOverlapped.OffsetHigh = 0;
        pClient->WriteOverlapped.Offset = pClient->dwFilePos;

        if ( ! ReadFileEx(
                   pClient->rSaveFile,
                   pClient->ReadTempBuffer,
                   pClient->cbWrite,
                   &pClient->WriteOverlapped,
                   ReadTempFileCompleted
                   )) {

            if (ERROR_HANDLE_EOF == GetLastError()) {

                pClient->cbWrite = 0;

            } else {

                TRACE(SESSION, ("ReadFileEx for temp file failed error %d, closing client.\n", GetLastError()));

                CloseClient(pClient);
            }
        }

    }
}

VOID
WINAPI
ReadTempFileCompleted(
    DWORD dwError,
    DWORD cbRead,
    LPOVERLAPPED lpO
    )
{
    PREMOTE_CLIENT pClient;

    pClient = CONTAINING_RECORD(lpO, REMOTE_CLIENT, WriteOverlapped);

    if (HandleSessionError(pClient, dwError)) {

        return;
    }


    if (cbRead != pClient->cbWrite) {

        TRACE(SESSION, ("Read %d from temp file asked for %d\n", cbRead, pClient->cbWrite));
    }

    if (cbRead) {

        pClient->cbReadTempBuffer = cbRead;
        pClient->dwFilePos += cbRead;

        StartWriteSessionOutput(pClient);

    } else {

        //
        // Note that the server to client flow is halting for now
        // for this client.
        //

        pClient->cbWrite = 0;
    }
}


VOID
FASTCALL
StartWriteSessionOutput(
    PREMOTE_CLIENT pClient
    )
{
    DWORD cbRead;
    char *pch;

    cbRead = pClient->cbReadTempBuffer;

    //
    // We need to split commands from other text read
    // from the temp file and hold off on writing them
    // to the client until we make sure we're not the
    // client that submitted it.  This isn't perfect
    // since we match on client name which can be
    // duplicated but it solves the problem of
    // duplicated input most of the time.
    //

    for (pch = pClient->ReadTempBuffer;
         pch < pClient->ReadTempBuffer + cbRead;
         pch++) {

        if ( ! (pClient->ServerFlags & SFLG_READINGCOMMAND) ) {

            if (BEGINMARK == *pch) {

                pClient->ServerFlags |= SFLG_READINGCOMMAND;

                if (pch != pClient->ReadTempBuffer &&
                    pClient->cbWriteBuffer) {

                    //
                    // Start a write of everything we've come across
                    // before the start of this command, with
                    // WriteSessionOutputCompletedWriteNext specified
                    // so we can continue processing the remainder
                    // of pReadTempBuffer.
                    //

                    pClient->cbReadTempBuffer -= (DWORD)( pch - pClient->ReadTempBuffer) + 1;
                    cbRead = pClient->cbReadTempBuffer;

                    #if DBG
                        if (pClient->cbReadTempBuffer == (DWORD)-1) {
                            ErrorExit("cbReadTempBuffer underflow.");
                        }
                    #endif

                    MoveMemory(pClient->ReadTempBuffer, pch + 1, cbRead);

                    pClient->cbWrite = pClient->cbWriteBuffer;

                    pClient->WriteOverlapped.OffsetHigh = 0;
                    pClient->WriteOverlapped.Offset = 0;

                    if ( ! WriteFileEx(
                               pClient->PipeWriteH,
                               pClient->WriteBuffer,
                               pClient->cbWrite,
                               &pClient->WriteOverlapped,
                               WriteSessionOutputCompletedWriteNext
                               )) {

                        CloseClient(pClient);
                    }

                    TRACE(SESSION, ("%p Wrote %d bytes pre-command output\n", pClient, pClient->cbWrite));

                    pClient->cbWriteBuffer = 0;

                    return;
                }

            } else {

                if (pClient->cbWriteBuffer == BUFFSIZE) {

                    ErrorExit("cbWriteBuffer overflow");
                }

                pClient->WriteBuffer[ pClient->cbWriteBuffer++ ] = *pch;
            }

        } else {

            if (ENDMARK == *pch ||
                pClient->cbCommandBuffer == BUFFSIZE) {

                pClient->ServerFlags &= ~SFLG_READINGCOMMAND;

                //
                // Preceding ENDMARK is the pClient in hex ascii of the
                // client that generated the command, not null terminated.
                //

                if (ENDMARK == *pch) {

                    pClient->cbCommandBuffer -=
                        min(pClient->cbCommandBuffer, sizeof(pClient->HexAsciiId));

                }

                //
                // We hide each client's input from their output pipe
                // because their local remote.exe has already displayed it.
                //

                if ( pClient->cbCommandBuffer &&
                     ! (ENDMARK == *pch &&
                        ! memcmp(
                              pch - sizeof(pClient->HexAsciiId),
                              pClient->HexAsciiId,
                              sizeof(pClient->HexAsciiId)))) {

                    //
                    // Start a write of the accumulated command with
                    // WriteSessionOutputCompletedWriteNext specified
                    // so we can continue processing the remainder
                    // of pReadTempBuffer.
                    //

                    pClient->cbReadTempBuffer -= (DWORD)(pch - pClient->ReadTempBuffer) + 1;
                    MoveMemory(pClient->ReadTempBuffer, pch + 1, pClient->cbReadTempBuffer);

                    pClient->cbWrite = pClient->cbCommandBuffer;
                    pClient->cbCommandBuffer = 0;

                    pClient->WriteOverlapped.OffsetHigh = 0;
                    pClient->WriteOverlapped.Offset = 0;

                    if ( ! WriteFileEx(
                               pClient->PipeWriteH,
                               pClient->CommandBuffer,
                               pClient->cbWrite,
                               &pClient->WriteOverlapped,
                               WriteSessionOutputCompletedWriteNext
                               )) {

                        CloseClient(pClient);
                        return;

                    } else {

                        TRACE(SESSION, ("%p Wrote %d bytes command\n", pClient, pClient->cbWrite));

                        return;

                    }

                } else {

                    //
                    // We're eating this command for this session.
                    //

                    pClient->cbCommandBuffer = 0;
                }

            } else {

                pClient->CommandBuffer[ pClient->cbCommandBuffer++ ] = *pch;

            }
        }
    }

    //
    // We're done with the ReadTempBuffer.
    //

    pClient->cbReadTempBuffer = 0;

    if (pClient->cbWriteBuffer) {

        pClient->cbWrite = pClient->cbWriteBuffer;

        pClient->WriteOverlapped.OffsetHigh = 0;
        pClient->WriteOverlapped.Offset = 0;

        if ( ! WriteFileEx(
                   pClient->PipeWriteH,
                   pClient->WriteBuffer,
                   pClient->cbWrite,
                   &pClient->WriteOverlapped,
                   WriteSessionOutputCompletedReadNext
                   )) {

            CloseClient(pClient);
            return;

        } else {

            TRACE(SESSION, ("%p Wrote %d bytes normal\n", pClient, pClient->cbWrite));

            pClient->cbWriteBuffer = 0;
        }

    } else {

        //
        // Write buffer is empty.
        //

        pClient->cbWrite = 0;

        StartReadTempFile(pClient);

    }
}


BOOL
FASTCALL
WriteSessionOutputCompletedCommon(
    PREMOTE_CLIENT pClient,
    DWORD dwError,
    DWORD cbWritten,
    LPOVERLAPPED_COMPLETION_ROUTINE lpCompletionRoutine
    )
{
    if (HandleSessionError(pClient, dwError)) {

        return TRUE;
    }

    if (!pClient->cbWrite) {

        ErrorExit("Zero cbWrite in WriteSessionOutputCompletedCommon");
    }

    if (!cbWritten && pClient->cbWrite) {

        printf("WriteSessionOutput zero bytes written of %d.\n", pClient->cbWrite);
        ErrorExit("WriteSessionOutputCompletedCommon failure");

        return TRUE;
    }

    #if DBG
        if (cbWritten != pClient->cbWrite) {
            printf("%p cbWritten %d cbWrite %d\n", pClient, cbWritten, pClient->cbWrite);
        }
    #endif

    return FALSE;
}


VOID
WINAPI
WriteSessionOutputCompletedWriteNext(
    DWORD dwError,
    DWORD cbWritten,
    LPOVERLAPPED lpO
    )
{
    PREMOTE_CLIENT pClient;

    pClient = CONTAINING_RECORD(lpO, REMOTE_CLIENT, WriteOverlapped);

    if (WriteSessionOutputCompletedCommon(
            pClient,
            dwError,
            cbWritten,
            WriteSessionOutputCompletedWriteNext
            )) {

        return;
    }

    StartWriteSessionOutput(pClient);
}


VOID
WINAPI
WriteSessionOutputCompletedReadNext(
    DWORD dwError,
    DWORD cbWritten,
    LPOVERLAPPED lpO
    )
{
    PREMOTE_CLIENT pClient;

    pClient = CONTAINING_RECORD(lpO, REMOTE_CLIENT, WriteOverlapped);

    if (WriteSessionOutputCompletedCommon(
            pClient,
            dwError,
            cbWritten,
            WriteSessionOutputCompletedReadNext
            )) {

        return;
    }

    //
    // Start another temp file read.
    //

    pClient->cbWrite = 0;

    StartReadTempFile(pClient);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\remote\srvutil.c ===
/******************************************************************************\
*       This is a part of the Microsoft Source Code Samples.
*       Copyright 1995 - 1997 Microsoft Corporation.
*       All rights reserved.
*       This source code is only intended as a supplement to
*       Microsoft Development Tools and/or WinHelp documentation.
*       See these sources for detailed information regarding the
*       Microsoft samples programs.
\******************************************************************************/

/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    SrvUtil.c

Abstract:

    The server component of Remote. It spawns a child process
    and redirects the stdin/stdout/stderr of child to itself.
    Waits for connections from clients - passing the
    output of child process to client and the input from clients
    to child process.

Author:

    Rajivendra Nath  2-Jan-1992
    Dave Hart  30 May 1997 split from Server.c

Environment:

    Console App. User mode.

Revision History:

--*/

#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <process.h>
#include <io.h>
#include <string.h>
#include "Remote.h"
#include "Server.h"


#define COMMANDFORMAT     "%c%-20s    [%-12s %s]\n%08x%c"
#define CMDSTRING(OutBuff,OutSize,InpBuff,Client,szTime,ForceShow) \
{                                                                  \
    char *pch;                                                     \
                                                                   \
    for (pch = InpBuff;                                            \
         *pch;                                                     \
         pch++) {                                                  \
                                                                   \
        if (ENDMARK == *pch ||                                     \
            BEGINMARK == *pch) {                                   \
                                                                   \
            *pch = '`';                                            \
        }                                                          \
    }                                                              \
                                                                   \
    OutSize =                                                      \
        sprintf(                                                   \
            (OutBuff),                                             \
            COMMANDFORMAT,                                         \
            BEGINMARK,                                             \
            (InpBuff),                                             \
            (Client)->Name,                                        \
            (szTime),                                              \
            (ForceShow) ? 0 : (Client)->dwID,                      \
            ENDMARK                                                \
            );                                                     \
}


/*************************************************************/
// GetFormattedTime -- returns pointer to formatted time
//
// returns pointer to static buffer, only the main thread
// should use this.
//

PCHAR
GetFormattedTime(
    BOOL bDateToo
    )
{
    static char szTime[64];
    int cch = 0;

    if (bDateToo) {

        cch =
            GetDateFormat(
                LOCALE_USER_DEFAULT,
                0,
                NULL,    // current date
                "ddd",   // short day of week
                szTime,
                sizeof szTime
                );

        // cch includes null terminator, change it to
        // a space to separate from time.

        szTime[ cch - 1 ] = ' ';
    }

    //
    // Get time and format to characters
    //

    GetTimeFormat(
        LOCALE_USER_DEFAULT,
        TIME_NOSECONDS,
        NULL,   // use current time
        NULL,   // use default format
        szTime + cch,
        (sizeof szTime) - cch );

    return szTime;
}

/*************************************************************/

BOOL
FilterCommand(
    REMOTE_CLIENT *cl,
    char *buff,
    int dread
    )
{
    char       tmpchar;
    DWORD      tmp;
    int        len, i;
    DWORD      ThreadID;
    char       inp_buff[2048];
    char       ch[3];

    if (dread==0)
        return(FALSE);

    buff[dread]=0;

    if (buff[0]==COMMANDCHAR)
    {

        switch(buff[1])
        {
        case 'k':
        case 'K':

                if (INVALID_HANDLE_VALUE != hWriteChildStdIn) {

                    printf("Remote: killing child softly, @K again to be more convincing.\n");

                    CANCELIO( hWriteChildStdIn );
                    CloseHandle( hWriteChildStdIn );
                    hWriteChildStdIn = INVALID_HANDLE_VALUE;

                    GenerateConsoleCtrlEvent(CTRL_CLOSE_EVENT, 0);
                    SleepEx(200, TRUE);
                    cPendingCtrlCEvents++;
                    GenerateConsoleCtrlEvent(CTRL_C_EVENT, 0);
                    SleepEx(20, TRUE);
                    GenerateConsoleCtrlEvent(CTRL_BREAK_EVENT, 0);

                } else {

                    printf("Remote: Resorting to TerminateProcess.\n");

                    TerminateProcess(ChldProc, ERROR_PROCESS_ABORTED);
                }


                 break;
        case 's':
        case 'S':
                CloseHandle( (HANDLE)
                    _beginthreadex(
                        NULL,             // security
                        0,                // default stack size
                        SendStatus,
                        (void *) cl->PipeWriteH,
                        0,                // not suspended
                        &ThreadID
                        ));
                break;

        case 'p':
        case 'P':
            {
                char  *msg;

                msg = HeapAlloc(                    // freed by ShowPopup
                          hHeap,
                          HEAP_ZERO_MEMORY,
                          4096
                          );


                if ( ! msg) {
                    break;
                }

                sprintf(msg,"From %s %s [%s]\n\n%s\n",cl->Name,cl->UserName,GetFormattedTime(TRUE),&buff[2]);

                if (WriteFileSynch(hWriteTempFile,msg,strlen(msg),&tmp,dwWriteFilePointer,&olMainThread)) {
                    dwWriteFilePointer += tmp;
                    StartServerToClientFlow();
                }

                CloseHandle( (HANDLE)
                    CreateThread(                              // no CRT for ShowPopup
                        NULL,             // security
                        0,                // default stack size
                        ShowPopup,
                        (void *) msg,
                        0,                // not suspended
                        &ThreadID
                        ));

                break;
             }

        case 'm':
        case 'M':
                buff[dread-2]=0;
                CMDSTRING(inp_buff,len,buff,cl,GetFormattedTime(TRUE),TRUE);

                if (WriteFileSynch(hWriteTempFile,inp_buff,len,&tmp,dwWriteFilePointer,&olMainThread)) {
                    dwWriteFilePointer += tmp;
                    StartServerToClientFlow();
                }
                break;

        case '@':
                buff[dread-2]=0;
                CMDSTRING(inp_buff,len,&buff[1],cl,GetFormattedTime(FALSE),FALSE);
                if (WriteFileSynch(hWriteTempFile,inp_buff,len,&tmp,dwWriteFilePointer,&olMainThread)) {
                    dwWriteFilePointer += tmp;
                    StartServerToClientFlow();
                }
                //
                // Remove the first @ sign
                //
                MoveMemory(buff,&buff[1],dread-1);
                buff[dread-1]=' ';
                return(FALSE); //Send it it to the chile process


        default :
                sprintf(inp_buff,"%s","** Unknown Command **\n");
                if (WriteFileSynch(hWriteTempFile,inp_buff,strlen(inp_buff),&tmp,dwWriteFilePointer,&olMainThread)) {
                    dwWriteFilePointer += tmp;
                    // we do this below // StartServerToClientFlow();
                }
        case 'h':
        case 'H':
                sprintf(inp_buff,"%cM: To Send Message\n",COMMANDCHAR);
                if (WriteFileSynch(hWriteTempFile,inp_buff,strlen(inp_buff),&tmp,dwWriteFilePointer,&olMainThread)) {
                    dwWriteFilePointer += tmp;
                }
                sprintf(inp_buff,"%cP: To Generate popup\n",COMMANDCHAR);
                if (WriteFileSynch(hWriteTempFile,inp_buff,strlen(inp_buff),&tmp,dwWriteFilePointer,&olMainThread)) {
                    dwWriteFilePointer += tmp;
                }
                sprintf(inp_buff,"%cK: To kill the server\n",COMMANDCHAR);
                if (WriteFileSynch(hWriteTempFile,inp_buff,strlen(inp_buff),&tmp,dwWriteFilePointer,&olMainThread)) {
                    dwWriteFilePointer += tmp;
                }
                sprintf(inp_buff,"%cQ: To Quit client\n",COMMANDCHAR);
                if (WriteFileSynch(hWriteTempFile,inp_buff,strlen(inp_buff),&tmp,dwWriteFilePointer,&olMainThread)) {
                    dwWriteFilePointer += tmp;
                }
                sprintf(inp_buff,"%cH: This Help\n",COMMANDCHAR);
                if (WriteFileSynch(hWriteTempFile,inp_buff,strlen(inp_buff),&tmp,dwWriteFilePointer,&olMainThread)) {
                    dwWriteFilePointer += tmp;
                }
                StartServerToClientFlow();
                break;
        }
        return(TRUE);
    }


    if ((buff[0]<26))
    {
        BOOL ret=FALSE;

        sprintf(ch, "^%c", buff[0] + 'A' - 1);


        if (buff[0]==CTRLC)
        {
            // show this even to this client
            CMDSTRING(inp_buff,len,ch,cl,GetFormattedTime(FALSE),TRUE);

            cPendingCtrlCEvents++;
            GenerateConsoleCtrlEvent(CTRL_C_EVENT, 0);
            ret = TRUE;  // Already sent to child

        } else {

            CMDSTRING(inp_buff,len,ch,cl,GetFormattedTime(FALSE),FALSE);
        }

        if (WriteFileSynch(hWriteTempFile,inp_buff,len,&tmp,dwWriteFilePointer,&olMainThread)) {
            dwWriteFilePointer += tmp;
            StartServerToClientFlow();
        }
        return(ret); //FALSE:send it to child StdIn
    }

    // options here are CRLF(\r\n) or just LF(\n)
    if (buff[dread-2] == 13) // 13 is CR
	i = 2;
    else
	i = 1;

    tmpchar=buff[dread-i]; 
    buff[dread-i]=0;
    CMDSTRING(inp_buff,len,buff,cl,GetFormattedTime(FALSE),FALSE);
    buff[dread-i]=tmpchar;
    if (WriteFileSynch(hWriteTempFile,inp_buff,len,&tmp,dwWriteFilePointer,&olMainThread)) {
        dwWriteFilePointer += tmp;
        StartServerToClientFlow();
    }
    return(FALSE);
}

/*************************************************************/
HANDLE
ForkChildProcess(           // Creates a new process
    char *cmd,              // Redirects its stdin,stdout
    PHANDLE inH,            // and stderr - returns the
    PHANDLE outH            // corresponding pipe ends.
    )

{
    SECURITY_ATTRIBUTES lsa;
    STARTUPINFO         si;
    PROCESS_INFORMATION pi;
    HANDLE ChildIn;
    HANDLE ChildOut, ChildOutDup;
    HANDLE hWriteChild;
    HANDLE hReadChild;
    BOOL Success;

    BOOL                                     // pipeex.c
    APIENTRY
    MyCreatePipeEx(
        OUT LPHANDLE lpReadPipe,
        OUT LPHANDLE lpWritePipe,
        IN LPSECURITY_ATTRIBUTES lpPipeAttributes,
        IN DWORD nSize,
        DWORD dwReadMode,
        DWORD dwWriteMode
        );



    lsa.nLength=sizeof(SECURITY_ATTRIBUTES);
    lsa.lpSecurityDescriptor=NULL;
    lsa.bInheritHandle=TRUE;

    //
    // Create Parent_Write to ChildStdIn Pipe.  Then
    // duplicate the parent copy to a noninheritable
    // handle and close the inheritable one so that
    // the child won't be holding open a handle to
    // the server end of its stdin pipe when we try
    // to nuke that pipe to close the child.
    //

    Success = MyCreatePipeEx(
                  &ChildIn,
                  &hWriteChild,
                  &lsa,
                  0,
                  0,
                  FILE_FLAG_OVERLAPPED) &&

              DuplicateHandle(
                  GetCurrentProcess(),
                  hWriteChild,
                  GetCurrentProcess(),
                  inH,
                  0,                       // ignored b/c SAME_ACCESS
                  FALSE,                   // not inheritable
                  DUPLICATE_SAME_ACCESS | DUPLICATE_CLOSE_SOURCE
                  );

    if (!Success) {
        ErrorExit("Could Not Create Parent-->Child Pipe");
    }

    //
    //Create ChildStdOut/stderr to Parent_Read pipe
    //

    Success = MyCreatePipeEx(
                  &hReadChild,
                  &ChildOut,
                  &lsa,
                  0,
                  FILE_FLAG_OVERLAPPED,
                  0) &&

              DuplicateHandle(
                  GetCurrentProcess(),
                  hReadChild,
                  GetCurrentProcess(),
                  outH,
                  0,                       // ignored b/c SAME_ACCESS
                  FALSE,                   // not inheritable
                  DUPLICATE_SAME_ACCESS | DUPLICATE_CLOSE_SOURCE
                  ) &&

              DuplicateHandle(
                  GetCurrentProcess(),
                  ChildOut,
                  GetCurrentProcess(),
                  &ChildOutDup,
                  0,                       // ignored b/c SAME_ACCESS
                  TRUE,                    // inheritable
                  DUPLICATE_SAME_ACCESS
                  );

    if (!Success) {
        ErrorExit("Could Not Create Child-->Parent Pipe");
    }

    ZeroMemory(&si, sizeof(si));
    si.cb            = sizeof(STARTUPINFO);
    si.dwFlags       = STARTF_USESTDHANDLES;
    si.hStdInput     = ChildIn;
    si.hStdOutput    = ChildOut;
    si.hStdError     = ChildOutDup;
    si.wShowWindow   = SW_SHOW;

    //
    // Create Child Process
    //

    if ( ! CreateProcess(
               NULL,
               cmd,
               NULL,
               NULL,
               TRUE,
               GetPriorityClass( GetCurrentProcess() ),
               NULL,
               NULL,
               &si,
               &pi)) {

        if (GetLastError()==2) {
            printf("Executable %s not found\n",cmd);
        } else {
            printf("CreateProcess(%s) failed, error %d.\n", cmd, GetLastError());
        }
        ErrorExit("Could Not Create Child Process");
    }

    //
    // Close unneccesary Handles
    //

    CloseHandle(ChildIn);
    CloseHandle(ChildOut);
    CloseHandle(ChildOutDup);
    CloseHandle(pi.hThread);

    pidChild = pi.dwProcessId;

    return(pi.hProcess);
}

//
// SendStatus runs as its own thread, with C runtime available.
//

DWORD
WINAPI
SendStatus(
    LPVOID   lpSendStatusParm
    )
{
    HANDLE hClientPipe = (HANDLE) lpSendStatusParm;
    char *pch;
    DWORD tmp;
    PREMOTE_CLIENT pClient;
    OVERLAPPED ol;
    char  buff[2048];
    char szSep[] = " ------------------------------\n";

    //
    // Since we're in our own thread we need our own
    // overlapped structure for our client pipe writes.
    //

    ZeroMemory(&ol, sizeof(ol));

    ol.hEvent =
        CreateEvent(
            NULL,      // security
            TRUE,      // auto-reset
            FALSE,     // initially nonsignaled
            NULL       // unnamed
            );


    //
    // Dump the closing client list
    //

    pch = buff;

    EnterCriticalSection(&csClosingClientList);

    for (pClient = (PREMOTE_CLIENT) ClosingClientListHead.Flink;
         pClient != (PREMOTE_CLIENT) &ClosingClientListHead;
         pClient = (PREMOTE_CLIENT) pClient->Links.Flink ) {

         if (pch + 60 > buff + sizeof(buff)) {

            break;
         }

         pch += sprintf(pch, "%d: %s %s (Disconnected)\n", pClient->dwID, pClient->Name, pClient->UserName);
    }

    LeaveCriticalSection(&csClosingClientList);

    WriteFileSynch(hClientPipe, buff, (DWORD)(pch - buff), &tmp, 0, &ol);

    WriteFileSynch(hClientPipe, szSep, sizeof(szSep) - 1, &tmp, 0, &ol);


    //
    // Dump the normal client list
    //

    pch = buff;

    EnterCriticalSection(&csClientList);

    for (pClient = (PREMOTE_CLIENT) ClientListHead.Flink;
         pClient != (PREMOTE_CLIENT) &ClientListHead;
         pClient = (PREMOTE_CLIENT) pClient->Links.Flink ) {

         if (pch + 60 > buff + sizeof(buff)) {

            break;
         }

         pch += sprintf(pch, "%d: %s %s\n", pClient->dwID, pClient->Name, pClient->UserName);
    }

    LeaveCriticalSection(&csClientList);

    WriteFileSynch(hClientPipe, buff, (DWORD)(pch - buff), &tmp, 0, &ol);

    WriteFileSynch(hClientPipe, szSep, sizeof(szSep) - 1, &tmp, 0, &ol);



    //
    // Dump the handshaking client list
    //

    pch = buff;

    EnterCriticalSection(&csHandshakingList);

    for (pClient = (PREMOTE_CLIENT) HandshakingListHead.Flink;
         pClient != (PREMOTE_CLIENT) &HandshakingListHead;
         pClient = (PREMOTE_CLIENT) pClient->Links.Flink ) {

         if (pch + 60 > buff + sizeof(buff)) {

            break;
         }

         pch += sprintf(pch, "%d: %s %s (Connecting)\n", pClient->dwID, pClient->Name, pClient->UserName);
    }

    LeaveCriticalSection(&csHandshakingList);

    WriteFileSynch(hClientPipe, buff, (DWORD)(pch - buff), &tmp, 0, &ol);

    WriteFileSynch(hClientPipe, szSep, sizeof(szSep) - 1, &tmp, 0, &ol);


    //
    // Dump summary information.
    //

    pch = buff;

    pch += sprintf(pch, "REMOTE /C %s \"%s\"\n", HostName, PipeName);
    pch += sprintf(pch, "Command: %s\n", ChildCmd);
    pch += sprintf(pch, "Windows NT %d.%d build %d \n",
                   OsVersionInfo.dwMajorVersion,
                   OsVersionInfo.dwMinorVersion,
                   OsVersionInfo.dwBuildNumber);

    WriteFileSynch(hClientPipe, buff, (DWORD)(pch - buff), &tmp, 0, &ol);

    WriteFileSynch(hClientPipe, szSep, sizeof(szSep) - 1, &tmp, 0, &ol);

    CloseHandle(ol.hEvent);

    return 0;
}

/*************************************************************/

DWORD                // NO CRT for ShowPopup
WINAPI
ShowPopup(
    void *vpArg
    )
{
    char *msg = (char *) vpArg;

    MessageBox(GetActiveWindow(),msg,"** REMOTE.EXE **",MB_OK|MB_SETFOREGROUND);
    HeapFree(hHeap, 0, msg);
    return(0);

}

/*************************************************************/

//
// SrvCtrlHand is the console event handler for the server side
// of remote.  If our stdin is a console handle, we've disabled
// generation of ^C events by the console code.  Therefore
// any we see are either generated by us for the benefit of
// our child processes sharing the console, or generated by
// some other process.  We want to ignore the ones we generate
// (since we're already done with everything that needs to be
// done at that point), and also ignore ^C's generated by
// other processes since we don't need to do anything with those.
// For example if someone runs:
//
// remote /s "remote /s cmd inner" outer
//
// Then local keyboard ^C's will be read by the outer remote.exe
// from its stdin handle, then it will generate a CTRL_C_EVENT that
// all processes in the console will see, including both remote.exe's
// and the child cmd.exe.  So the handler needs do nothing but indicate
// the event was handled by returning TRUE so the default handler
// won't kill us.  For ^BREAK we want to specifically kill our child
// process so that cmd.exe and others that ignore ^BREAK will go away.
// Of course this won't kill our grandchildren and so on.  Oh well.
//
// For all other events we return FALSE and let the default handler
// have it.
//

BOOL
WINAPI
SrvCtrlHand(
    DWORD event
    )
{
    BOOL bRet = FALSE;
    DWORD cb;
    DWORD dwTempFileOffset;
    OVERLAPPED ol;
    char szTime[64];
    char szCmd[128];

    if (event == CTRL_BREAK_EVENT) {

        TerminateProcess(ChldProc, 3);
        bRet = TRUE;

    } else if (event == CTRL_C_EVENT) {

        if ( ! cPendingCtrlCEvents ) {

            //
            // This came from the local keyboard or
            // was generated by another process in
            // this console.  Echo it as a local
            // command.  We have use GetTimeFormat
            // here not our GetFormattedTime since
            // the latter is for the use of the
            // main thread only.
            //

            GetTimeFormat(
                LOCALE_USER_DEFAULT,
                TIME_NOSECONDS,
                NULL,   // use current time
                NULL,   // use default format
                szTime,
                sizeof(szTime)
                );

            CMDSTRING(szCmd, cb, "^C", pLocalClient, szTime, TRUE);

            ZeroMemory(&ol, sizeof(ol));
            ol.hEvent =
                CreateEvent(
                    NULL,      // security
                    TRUE,      // auto-reset
                    FALSE,     // initially nonsignaled
                    NULL       // unnamed
                    );

            //
            // Practically all writes to the tempfile are happening on
            // the primary server thread.  We're on a Ctrl-C thread.
            // We can't start the server to client I/O going after
            // writing because we're on the wrong thread, so we
            // punt.  To fix this we need an event we can signal
            // that causes the main thread to call StartServerToClientFlow.
            //

            dwTempFileOffset = dwWriteFilePointer;
            dwWriteFilePointer += cb;
            WriteFileSynch(hWriteTempFile, szCmd, cb, &cb, dwTempFileOffset, &ol);
            // wrong thread // StartServerToClientFlow();

            CloseHandle(ol.hEvent);

        } else {

            //
            // We generated this event in response to a ^C received from
            // a client, it's already been displayed to all clients.
            //

            cPendingCtrlCEvents--;
        }

        bRet = TRUE;

    }

    return bRet;
}


/*************************************************************/

PSECURITY_DESCRIPTOR
FormatSecurityDescriptor(
    CHAR * * DenyNames,
    DWORD    DenyCount,
    CHAR * * Names,
    DWORD    Count)
{
    PSECURITY_DESCRIPTOR    Sd;
    PACL    Acl;
    DWORD   i;
    PSID    Sids;
    DWORD   SidLength ;
    CHAR    ReferencedDomain[ MAX_PATH ];
    UCHAR   SidBuffer[ 8 * sizeof(DWORD) + 8 ];
    DWORD   DomainLen ;
    SID_NAME_USE    Use;
    DWORD   SdLen;


    SdLen = sizeof(SECURITY_DESCRIPTOR) +
                        DenyCount * (sizeof( ACCESS_DENIED_ACE ) ) +
                        DenyCount * GetSidLengthRequired( 8 ) +
                        Count * (sizeof( ACCESS_ALLOWED_ACE ) ) + sizeof(ACL) +
                        (Count * GetSidLengthRequired( 8 ) );

    Sd = LocalAlloc( LMEM_FIXED | LMEM_ZEROINIT, SdLen );

    if ( !Sd )
    {
        ErrorExit("Could not allocate SD");
    }

    InitializeSecurityDescriptor( Sd, SECURITY_DESCRIPTOR_REVISION );

    Acl = (PACL)( (PUCHAR) Sd + sizeof( SECURITY_DESCRIPTOR) );

    InitializeAcl( Acl, SdLen - sizeof( SECURITY_DESCRIPTOR) ,
                    ACL_REVISION );

    Sids = SidBuffer;
    for (i = 0 ; i < DenyCount ; i ++ )
    {
        SidLength = sizeof( SidBuffer );

        DomainLen = MAX_PATH ;

        if (! LookupAccountName(NULL,
                                DenyNames[ i ],
                                Sids,
                                &SidLength,
                                ReferencedDomain,
                                &DomainLen,
                                &Use ) )
        {
            _snprintf( ReferencedDomain, MAX_PATH, "Unable to find account %s", DenyNames[ i ]);
            ErrorExit( ReferencedDomain );
        }

        //
        // Got the sid.  Now, add it as an access denied ace:
        //

        AddAccessDeniedAce( Acl,
                            ACL_REVISION,
                            FILE_GENERIC_READ |
                                FILE_GENERIC_WRITE |
                                FILE_CREATE_PIPE_INSTANCE,
                            Sids );


    }

    for (i = 0 ; i < Count ; i ++ )
    {
        SidLength = sizeof( SidBuffer );

        DomainLen = MAX_PATH ;

        if (! LookupAccountName(NULL,
                                Names[ i ],
                                Sids,
                                &SidLength,
                                ReferencedDomain,
                                &DomainLen,
                                &Use ) )
        {
            _snprintf( ReferencedDomain, MAX_PATH, "Unable to find account %s", Names[ i ]);
            ErrorExit( ReferencedDomain );
        }

        //
        // Got the sid.  Now, add it as an access allowed ace:
        //

        AddAccessAllowedAce(Acl,
                            ACL_REVISION,
                            FILE_GENERIC_READ |
                                FILE_GENERIC_WRITE |
                                FILE_CREATE_PIPE_INSTANCE,
                            Sids );


    }

    //
    // Now the ACL should be complete, so set it into the SD and return:
    //

    SetSecurityDescriptorDacl( Sd, TRUE, Acl, FALSE );

    return Sd ;

}


/*************************************************************/

VOID
CloseClient(
    REMOTE_CLIENT *pClient
    )
{
    DWORD tmp;
    char  Buf[200];

    #if DBG
        if (pClient->ServerFlags & ~SFLG_VALID) {

            printf("pClient %p looks nasty in CloseClient.\n", pClient);
            ErrorExit("REMOTE_CLIENT structure corrupt.");
        }
    #endif


    //
    // If we're still active (on the normal client list)
    // start tearing things down and move to the closing
    // list.
    //

    if (pClient->ServerFlags & SFLG_CLOSING) {

        return;
    }


    if (pClient->ServerFlags & SFLG_HANDSHAKING) {

        MoveClientToNormalList(pClient);
    }

    MoveClientToClosingList(pClient);

    pClient->ServerFlags |= SFLG_CLOSING;


    if (pClient->PipeWriteH != INVALID_HANDLE_VALUE) {

        TRACE(CONNECT, ("Disconnecting %d PipeWriteH (%p).\n", pClient->dwID, pClient->PipeWriteH));
        CANCELIO(pClient->PipeWriteH);
        DisconnectNamedPipe(pClient->PipeWriteH);
        CloseHandle(pClient->PipeWriteH);
    }


    if (pClient->PipeReadH != INVALID_HANDLE_VALUE &&
        pClient->PipeReadH != pClient->PipeWriteH) {

        TRACE(CONNECT, ("Disconnecting %d PipeReadH (%p).\n", pClient->dwID, pClient->PipeReadH));
        CANCELIO(pClient->PipeReadH);
        DisconnectNamedPipe(pClient->PipeReadH);
        CloseHandle(pClient->PipeReadH);
    }


    if (pClient->rSaveFile != INVALID_HANDLE_VALUE) {

        CANCELIO(pClient->rSaveFile);
        CloseHandle(pClient->rSaveFile);
    }

    pClient->rSaveFile =
        pClient->PipeWriteH =
            pClient->PipeReadH =
                INVALID_HANDLE_VALUE;


    if ( ! bShuttingDownServer ) {

        sprintf(Buf, "\n**Remote: Disconnected from %s %s [%s]\n", pClient->Name, pClient->UserName, GetFormattedTime(TRUE));

        if (WriteFileSynch(hWriteTempFile,Buf,strlen(Buf),&tmp,dwWriteFilePointer,&olMainThread)) {
            dwWriteFilePointer += tmp;
            StartServerToClientFlow();
        }
    }

    return;
}

BOOL
FASTCALL
HandleSessionError(
    PREMOTE_CLIENT pClient,
    DWORD         dwError
    )
{

    if (pClient->ServerFlags & SFLG_CLOSING) {

        return TRUE;
    }

    if (dwError) {

        if (ERROR_BROKEN_PIPE == dwError ||
            ERROR_OPERATION_ABORTED == dwError ||
            ERROR_NO_DATA == dwError ) {

            CloseClient(pClient);
            return TRUE;
        }

        SetLastError(dwError);
        ErrorExit("Unhandled session error.");
    }

    return FALSE;
}


VOID
FASTCALL
CleanupTempFiles(
    PSZ pszTempDir
    )
{
    HANDLE          hSearch;
    WIN32_FIND_DATA FindData;
    char            szPath[MAX_PATH + 1];
    char            szFile[MAX_PATH + 1];

    //
    // pszTempDir, from GetTempPath, has a trailing backslash.
    //

    sprintf(szPath, "%sREM*.tmp", pszTempDir);

    hSearch = FindFirstFile(
                  szPath,
                  &FindData
                  );

    if (INVALID_HANDLE_VALUE != hSearch) {

        do {

            sprintf(szFile, "%s%s", pszTempDir, FindData.cFileName);

            DeleteFile(szFile);

        } while (FindNextFile(hSearch, &FindData));

        FindClose(hSearch);
    }

}


VOID
FASTCALL
SetupSecurityDescriptors(
    VOID
    )
{
    int i;

    //
    // Initialize the wide-open security descriptor.
    //

    InitializeSecurityDescriptor(
        &sdPublic,
        SECURITY_DESCRIPTOR_REVISION
        );

    SetSecurityDescriptorDacl(
        &sdPublic,
        TRUE,
        NULL,
        FALSE
        );

    saPublic.nLength = sizeof(saPublic);
    saPublic.lpSecurityDescriptor = &sdPublic;


    //
    // if /u was specified once or more, build the security descriptor to
    // enforce it.
    //

    saPipe.nLength = sizeof(saPipe);

    if ( DaclNameCount  || DaclDenyNameCount ) {

        saPipe.lpSecurityDescriptor =
            FormatSecurityDescriptor(
                DaclDenyNames,
                DaclDenyNameCount,
                DaclNames,
                DaclNameCount
                );

        if (DaclNameCount) {

            printf( "\nProtected Server!  Only the following users or groups can connect:\n" );

            for (i = 0 ; i < (int) DaclNameCount ; i++) {

                printf( "    %s\n", DaclNames[i] );
            }
        }

        if (DaclDenyNameCount) {

            printf( "The following users or groups explicitly cannot connect:\n" );

            for (i = 0 ; i < (int) DaclDenyNameCount ; i++) {

                printf("    %s\n", DaclDenyNames[i] );
            }
        }


    } else {

        saPipe.lpSecurityDescriptor = &sdPublic;
    }
}


VOID
FASTCALL
RuntimeLinkAPIs(
    VOID
    )
{
    HANDLE hmodKernel32;
    HANDLE hmodNetApi32;


    hmodKernel32 = LoadLibrary("kernel32");
    hmodNetApi32 = LoadLibrary("netapi32");

    pfnCreateWaitableTimer = (void *)
        GetProcAddress(
            hmodKernel32,
            "CreateWaitableTimerA"
            );

    pfnSetWaitableTimer = (void *)
        GetProcAddress(
            hmodKernel32,
            "SetWaitableTimer"
            );

    pfnCancelWaitableTimer = (void *)
        GetProcAddress(
            hmodKernel32,
            "CancelWaitableTimer"
            );

    pfnCancelIo = (void *)
        GetProcAddress(
            hmodKernel32,
            "CancelIo"
            );

    pfnNetWkstaGetInfo = (void *)
        GetProcAddress(
            hmodNetApi32,
            "NetWkstaGetInfo"
            );

    pfnNetApiBufferFree = (void *)
        GetProcAddress(
            hmodNetApi32,
            "NetApiBufferFree"
            );

    //
    // We do without Waitable Timers and CancelIo on 3.51
    //

    if (!pfnNetWkstaGetInfo ||
        !pfnNetApiBufferFree) {

        SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
        ErrorExit("Remote server requires Windows NT.");
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\rescan\remove.c ===
#include <nt.h>
#include <ntddcdrm.h>
#include <ntrtl.h>
#include <nturtl.h>

#include <windows.h>
#include <stdio.h>
#include <process.h>
#include <memory.h>
#include <string.h>
#include <stdlib.h>
#include <string.h>

int __cdecl
main( int argc, char **argv )
{
    BYTE DriveNameBuffer[32];
    HANDLE VolumeHandle;
    ULONG BytesTransferred;

    if( argc < 2 ) {

        printf( "usage: %s DriveLetter:\n", argv[0] );
        exit(4);
    }

    memset( DriveNameBuffer, 0, sizeof( DriveNameBuffer ) );
    strcat( DriveNameBuffer, "\\\\.\\" );
    strcat( DriveNameBuffer, argv[1] );

    // Open the volume with the DOS name.
    //
    VolumeHandle = CreateFile( DriveNameBuffer,
                               GENERIC_READ,
                               FILE_SHARE_READ | FILE_SHARE_WRITE,
                               NULL,
                               OPEN_EXISTING,
                               0,
                               0 );

    if( VolumeHandle == INVALID_HANDLE_VALUE ) {

        printf( "Unable to open %s [Error %d]\n",
                argv[1],
                GetLastError() );
        exit(4);
    }

    // GetFile information.
    //
    if( !DeviceIoControl( VolumeHandle,
                          IOCTL_CDROM_REMOVE_DEVICE,
                          NULL,
                          0,
                          NULL,
                          0,
                          &BytesTransferred,
                          NULL ) ) {

        printf( "Unable to remove device [Error %d].\n", GetLastError() );
        CloseHandle( VolumeHandle );
        exit(4);

    } else {
        printf( "Removed %s\n", argv[1] );
        CloseHandle( VolumeHandle );
        return 0;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\rescan\makefile.inc ===
$(O)\rescan.res: rescan.rc

$(O)\setpriv.res: setpriv.rc

$(O)\remove.res: remove.rc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\rescan\rescan.c ===
#include <nt.h>
#include <ntddscsi.h>
#include <ntdddisk.h>
#include <ntddcdrm.h>
#include <ntrtl.h>
#include <nturtl.h>

#include <windows.h>
#include <stdio.h>
#include <process.h>
#include <memory.h>
#include <string.h>
#include <stdlib.h>
#include <string.h>

#define _NTSCSI_USER_MODE_

#include <scsi.h>

VOID
GetDriverName(
    IN ULONG PortNumber
    )
{
    UNICODE_STRING name;
    UNICODE_STRING unicodeString;
    ANSI_STRING ansiString;
    HANDLE key;
    HANDLE portKey;
    OBJECT_ATTRIBUTES objectAttributes;
    NTSTATUS status;
    UCHAR buffer[64];
    ULONG length;
    PKEY_VALUE_FULL_INFORMATION keyData = (PKEY_VALUE_FULL_INFORMATION)buffer;

    printf("\nSCSI PORT %d\n", PortNumber);

    //
    // Obtain handle to SCSI path in device map.
    //

    RtlInitUnicodeString(&name,
                         L"\\Registry\\Machine\\Hardware\\DeviceMap\\Scsi");

    //
    // Initialize the object for the key.
    //

    InitializeObjectAttributes(&objectAttributes,
                               &name,
                               OBJ_CASE_INSENSITIVE,
                               NULL,
                               (PSECURITY_DESCRIPTOR) NULL);

    //
    // Open the key.
    //

    status = NtOpenKey(&key,
                       KEY_READ,
                       &objectAttributes);

    if (!NT_SUCCESS(status)) {
        return;
    }

    //
    // Create Scsi port name.
    //

    sprintf(buffer,
            "Scsi Port %d",
            PortNumber);

    RtlInitString(&ansiString, buffer);

    status = RtlAnsiStringToUnicodeString(&unicodeString,
                                          &ansiString,
                                          TRUE);

    if (!NT_SUCCESS(status)) {
        return;
    }

    InitializeObjectAttributes( &objectAttributes,
                                &unicodeString,
                                OBJ_CASE_INSENSITIVE,
                                key,
                                (PSECURITY_DESCRIPTOR) NULL );

    status = NtOpenKey(&portKey,
                       KEY_READ,
                       &objectAttributes);

    if (!NT_SUCCESS(status)) {
        return;
    }

    RtlInitUnicodeString(&name,
                         L"Driver");

    status = NtQueryValueKey(portKey,
                             &name,
                             KeyValueFullInformation,
                             keyData,
                             64,
                             &length);

    if (!NT_SUCCESS(status)) {
        return;
    }

    printf("Driver name: %S\n",
           (PUCHAR)keyData + keyData->DataOffset);

    RtlInitUnicodeString(&name,
                         L"Interrupt");

    status = NtQueryValueKey(portKey,
                             &name,
                             KeyValueFullInformation,
                             keyData,
                             64,
                             &length);

    if (!NT_SUCCESS(status)) {
        return;
    }

    printf("IRQ %d ",
           *((PUCHAR)keyData + keyData->DataOffset));

    RtlInitUnicodeString(&name,
                         L"IOAddress");

    status = NtQueryValueKey(portKey,
                             &name,
                             KeyValueFullInformation,
                             keyData,
                             64,
                             &length);

    if (!NT_SUCCESS(status)) {
        printf("\n");
        return;
    }

    printf("IO Address %x\n",
           *((PULONG)keyData + keyData->DataOffset/4));

    return;
}

int __cdecl
main( int argc, char **argv )
{
    BYTE buffer[32];
    HANDLE volumeHandle;
    STRING string;
    UNICODE_STRING unicodeString;
    OBJECT_ATTRIBUTES  objectAttributes;
    NTSTATUS ntStatus;
    IO_STATUS_BLOCK statusBlock;
    ULONG portNumber = 0;
    PSCSI_ADAPTER_BUS_INFO  adapterInfo;
    PSCSI_BUS_DATA busData;
    PSCSI_INQUIRY_DATA inquiryData;
    UCHAR prevDeviceInquiryData[INQUIRYDATABUFFERSIZE];
    PINQUIRYDATA deviceInquiryData;
    ULONG bytesTransferred, i, j;
    ULONG deviceNumber;
    BOOLEAN newDisk = FALSE;
    BOOLEAN newCdrom = FALSE;
    UCHAR prevPathId;
    UCHAR prevTargetId;
    UCHAR prevLun;
    BOOLEAN prevDeviceClaimed;
    BOOLEAN listAdapters = FALSE;
    BOOLEAN allAdapters = TRUE;
    UCHAR lunExtra;

    if(argc == 2) {
        if(argv[1][0] == '*') {
            listAdapters = TRUE;
        } else {
            portNumber = atoi(argv[1]);
            allAdapters = FALSE;
        }
    }

    printf("\nWindows NT SCSI Bus Rescan Version 1.1\n");

    if(listAdapters) {
        printf("[only listing adapters]\n");
    } else if(allAdapters) {
        printf("[scanning all adapters]\n");
    } else {
        printf("[scanning adapter %d only]\n", portNumber);
    }

    while (TRUE) {

        memset( buffer, 0, sizeof( buffer ) );
        sprintf( buffer,
                 "\\\\.\\Scsi%d:",
                 portNumber);

        //
        // Open the volume with the DOS name.
        //

        volumeHandle = CreateFile( buffer,
                                   GENERIC_READ,
                                   FILE_SHARE_READ | FILE_SHARE_WRITE,
                                   NULL,
                                   OPEN_EXISTING,
                                   0,
                                   0 );

        if( volumeHandle == INVALID_HANDLE_VALUE ) {
            break;
        }

        if(listAdapters) {
            GetDriverName(portNumber);
            portNumber++;
            CloseHandle(volumeHandle);
            continue;
        }

        //
        // Issue rescan device control.
        //

        if( !DeviceIoControl( volumeHandle,
                              IOCTL_SCSI_RESCAN_BUS,
                              NULL,
                              0,
                              NULL,
                              0,
                              &bytesTransferred,
                              NULL ) ) {

            printf( "Rescan SCSI port %d failed [Error %d].\n", portNumber, GetLastError() );
            CloseHandle( volumeHandle );
            exit(4);
        }

        //
        // Get a big chuck of memory to store the SCSI bus data.
        //

        adapterInfo = malloc( 0x1000 );

        if (adapterInfo == NULL) {
            printf( "Can't allocate memory for bus data\n" );
            CloseHandle( volumeHandle );
            exit(4);
        }

        //
        // Issue device control to get configuration information.
        //

        if (!DeviceIoControl( volumeHandle,
                              IOCTL_SCSI_GET_INQUIRY_DATA,
                              NULL,
                              0,
                              adapterInfo,
                              0x1000,
                              &bytesTransferred,
                              NULL)) {

            printf( "Get SCSI bus data failed [Error %d].\n", GetLastError() );
            CloseHandle( volumeHandle );
            exit(4);
        }

        GetDriverName(portNumber);

        //
        // Display devices on buses.
        //

        for (i=0; i < adapterInfo->NumberOfBuses; i++) {

            busData = &adapterInfo->BusData[i];
            printf( "\nBus  TID  LUN  In use  Type        Vendor                 FW Rev  Advanced SCSI\n" );
            printf( "===============================================================================\n" );
            printf("%2d   %2d   %2d     %2d    Initiator",
                   i,
                   busData->InitiatorBusId & 0x7,
                   0,
                   1);

            inquiryData =
                (PSCSI_INQUIRY_DATA)((PUCHAR)adapterInfo + busData->InquiryDataOffset);

            memset(&prevDeviceInquiryData, 0, INQUIRYDATABUFFERSIZE);
            prevPathId = 0xFF;
            prevTargetId = 0xFF;
            prevLun = 0xFF;
            prevDeviceClaimed = 0xFF;
            for (j=0; j<busData->NumberOfLogicalUnits; j++) {

                int k;

                //
                // Make sure VendorId string is null terminated.
                //

                deviceInquiryData = (PINQUIRYDATA)&inquiryData->InquiryData[0];

                deviceInquiryData->VendorSpecific[0] = '\0';
                if (prevPathId != inquiryData->PathId ||
                    prevTargetId != inquiryData->TargetId ||
                    prevLun != (inquiryData->Lun-1) ||
                    prevDeviceClaimed != inquiryData->DeviceClaimed ||
                    memcmp( &prevDeviceInquiryData, deviceInquiryData, INQUIRYDATABUFFERSIZE)
                   ) {
                    lunExtra = 0;
                    printf("\n%2d   %2d   %2d     %2d    ",
                            inquiryData->PathId,
                            inquiryData->TargetId,
                            inquiryData->Lun,
                            inquiryData->DeviceClaimed);
                } else {
                    lunExtra += 1;
                    printf("\r%2d   %2d   %2d-%1d   %2d    ",
                            inquiryData->PathId,
                            inquiryData->TargetId,
                            inquiryData->Lun-lunExtra,
                            inquiryData->Lun,
                            inquiryData->DeviceClaimed);
                    }

                prevPathId = inquiryData->PathId;
                prevTargetId = inquiryData->TargetId;
                prevLun = inquiryData->Lun;
                prevDeviceClaimed = inquiryData->DeviceClaimed;
                memmove( &prevDeviceInquiryData, deviceInquiryData, INQUIRYDATABUFFERSIZE);

                //
                // Determine the perpherial type.
                //

                switch (deviceInquiryData->DeviceType) {
                case DIRECT_ACCESS_DEVICE:
                    if (!inquiryData->DeviceClaimed) {
                        newDisk = TRUE;
                    }
                    printf("Disk Drive ");
                    break;

                case SEQUENTIAL_ACCESS_DEVICE:
                    printf("Tape Drive ");
                    break;

                case PRINTER_DEVICE:
                    printf("Printer    ");
                    break;

                case WRITE_ONCE_READ_MULTIPLE_DEVICE:
                    printf("Worm Drive ");
                    break;

                case READ_ONLY_DIRECT_ACCESS_DEVICE:
                    if (!inquiryData->DeviceClaimed) {
                        newCdrom = TRUE;
                    }
                    printf("CdRom Drive");
                    break;

                case SCANNER_DEVICE:
                    printf("Scanner    ");
                    break;

                case OPTICAL_DEVICE:
                    if (!inquiryData->DeviceClaimed) {
                        newDisk = TRUE;
                    }
                    printf("OpticalDisk");
                    break;

                case MEDIUM_CHANGER:
                    printf("MediumChanger");
                    break;

                case COMMUNICATION_DEVICE:
                    printf("Communication");
                    break;

                default:
                    printf("OtherPeripheral");
                }

                //
                // Display product information.
                //

                printf(" %s", deviceInquiryData->VendorId);

                //
                // Display SCSI capabilities.
                //

                printf("   ");
                if (deviceInquiryData->Synchronous) {
                    printf(" SN");
                }

                if (deviceInquiryData->CommandQueue) {
                    printf(" CQ");
                }

                if (deviceInquiryData->Wide16Bit) {
                    printf(" W16");
                }

                if (deviceInquiryData->Wide32Bit) {
                    printf(" W32");
                }

                if (deviceInquiryData->SoftReset) {
                    printf(" SR");
                }

                if (deviceInquiryData->LinkedCommands) {
                    printf(" LC");
                }

                if (deviceInquiryData->RelativeAddressing) {
                    printf(" RA");
                }

                if (deviceInquiryData->DeviceTypeQualifier != DEVICE_QUALIFIER_ACTIVE) {
                    printf(" DQ%d", deviceInquiryData->DeviceTypeQualifier);
                }

                printf("\n                        [ ");
                for(k = 0; k < 8; k++) {
                    printf("%02x ", ((PUCHAR) deviceInquiryData)[k]);
                }
                printf("]");

                //
                // Get next device data.
                //

                inquiryData =
                    (PSCSI_INQUIRY_DATA)((PUCHAR)adapterInfo + inquiryData->NextInquiryDataOffset);
            }

            printf("\n");
        }

        free (adapterInfo);

        if(allAdapters) {
            CloseHandle( volumeHandle );
            portNumber++;
        } else {
            break;
        }
    }

    if (newDisk) {

        //
        // Send IOCTL_DISK_FIND_NEW_DEVICES commands to each existing disk.
        //

        deviceNumber = 0;
        while (TRUE) {

            memset(buffer, 0, sizeof(buffer));
            sprintf(buffer,
                    "\\Device\\Harddisk%d\\Partition0",
                    deviceNumber);

            RtlInitString(&string,
                          buffer);

            ntStatus = RtlAnsiStringToUnicodeString(&unicodeString,
                                                    &string,
                                                    TRUE);

            if (!NT_SUCCESS(ntStatus)) {
                continue;
            }

            InitializeObjectAttributes(&objectAttributes,
                                       &unicodeString,
                                       0,
                                       NULL,
                                       NULL);

            ntStatus = NtOpenFile(&volumeHandle,
                                  FILE_READ_DATA  |
                                  FILE_WRITE_DATA |
                                  SYNCHRONIZE,
                                  &objectAttributes,
                                  &statusBlock,
                                  FILE_SHARE_READ  |
                                  FILE_SHARE_WRITE,
                                  FILE_SYNCHRONOUS_IO_ALERT);

            if (!NT_SUCCESS(ntStatus)) {
                break;
            }

            //
            // Issue find device device control.
            //

            if (DeviceIoControl( volumeHandle,
                                 IOCTL_DISK_FIND_NEW_DEVICES,
                                 NULL,
                                 0,
                                 NULL,
                                 0,
                                 &bytesTransferred,
                                 NULL ) ) {

                printf( "Found new disk (%d)\n", deviceNumber );
            }

            CloseHandle( volumeHandle );
            deviceNumber++;
        }
    }

    if (newCdrom) {

        //
        // Send IOCTL_CDROM_FIND_NEW_DEVICES commands to each existing cdrom.
        //

        deviceNumber = 0;
        while (TRUE) {

            memset(buffer, 0, sizeof(buffer));
            sprintf(buffer,
                    "\\Device\\Cdrom%d",
                    deviceNumber);

            RtlInitString(&string,
                          buffer);

            ntStatus = RtlAnsiStringToUnicodeString(&unicodeString,
                                                    &string,
                                                    TRUE);

            if (!NT_SUCCESS(ntStatus)) {
                continue;
            }

            InitializeObjectAttributes(&objectAttributes,
                                       &unicodeString,
                                       0,
                                       NULL,
                                       NULL);

            ntStatus = NtOpenFile(&volumeHandle,
                                  FILE_READ_DATA  |
                                  FILE_WRITE_DATA |
                                  SYNCHRONIZE,
                                  &objectAttributes,
                                  &statusBlock,
                                  FILE_SHARE_READ  |
                                  FILE_SHARE_WRITE,
                                  FILE_SYNCHRONOUS_IO_ALERT);

            if (!NT_SUCCESS(ntStatus)) {
                break;
            }

            //
            // Issue find device device control.
            //

            if (DeviceIoControl( volumeHandle,
                                 IOCTL_CDROM_FIND_NEW_DEVICES,
                                 NULL,
                                 0,
                                 NULL,
                                 0,
                                 &bytesTransferred,
                                 NULL ) ) {

                printf( "Found new cdrom (%d)\n", deviceNumber );
            }

            CloseHandle( volumeHandle );
            deviceNumber++;
        }
    }

    return(0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\rescan\setpriv.c ===
#include <windows.h>
#include <malloc.h>
#include <stdio.h>
#include <process.h>



BOOL
EnableCreatePermanentPrivilege(
    HANDLE TokenHandle,
    PTOKEN_PRIVILEGES OldPrivileges
    );

BOOL
OpenToken(
    PHANDLE TokenHandle
    );


VOID
__cdecl main  (int argc, char *argv[])
{
    int i;
    PACL Dacl;
    LPSTR FileName;
    TOKEN_PRIVILEGES OldPrivileges;
    SID_IDENTIFIER_AUTHORITY NtAuthority = SECURITY_NT_AUTHORITY;
    PSID AdminAliasSid;
    BOOL Result;
    ULONG DaclSize;
    HANDLE TokenHandle;
    SECURITY_DESCRIPTOR SecurityDescriptor;

    Result = OpenToken( &TokenHandle );

    if ( !Result ) {

        printf("Unable to open token\n");
        exit(-1);
    }


    Result = EnableCreatePermanentPrivilege(
                TokenHandle,
                &OldPrivileges
                );

    if ( !Result ) {

        //
        // This account doesn't have SeCreatePermanent
        // privilege.  Tell them to try running it again
        // from an account that does.
        //

        printf("Unable to enable SeCreatePermanent privilege\n");

        //
        // do what you want here...
        //

        exit(4);
    }

    //
    // Display privileges.
    //



    //
    // Put things back the way they were
    //

    (VOID) AdjustTokenPrivileges (
                TokenHandle,
                FALSE,
                &OldPrivileges,
                sizeof( TOKEN_PRIVILEGES ),
                NULL,
                NULL
                );

    if ( GetLastError() != NO_ERROR ) {

        //
        // This is unlikely to happen,
        //

        printf("AdjustTokenPrivileges failed turning off SeCreatePermanent privilege\n");
    }
}



BOOL
EnableCreatePermanentPrivilege(
    HANDLE TokenHandle,
    PTOKEN_PRIVILEGES OldPrivileges
    )
{
    TOKEN_PRIVILEGES NewPrivileges;
    BOOL Result;
    LUID CreatePermanentValue;
    ULONG ReturnLength;

    //
    // Mike: change SeCreatePermanentPrivilege to SeCreatePermanentPrivilege
    // and you'll be pretty much there.
    //


    Result = LookupPrivilegeValue(
                 NULL,
                 "SeCreatePermanetPrivilegePrivilege",
                 &CreatePermanentValue
                 );

    if ( !Result ) {

        printf("Unable to obtain value of CreatePermanent privilege\n");
        return FALSE;
    }

    //
    // Set up the privilege set we will need
    //

    NewPrivileges.PrivilegeCount = 1;
    NewPrivileges.Privileges[0].Luid = CreatePermanentValue;
    NewPrivileges.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;



    (VOID) AdjustTokenPrivileges (
                TokenHandle,
                FALSE,
                &NewPrivileges,
                sizeof( TOKEN_PRIVILEGES ),
                OldPrivileges,
                &ReturnLength
                );

    if ( GetLastError() != NO_ERROR ) {

        return( FALSE );

    } else {

        return( TRUE );
    }

}


BOOL
OpenToken(
    PHANDLE TokenHandle
    )
{
    HANDLE Process;
    BOOL Result;

    Process = OpenProcess(
                PROCESS_QUERY_INFORMATION,
                FALSE,
                GetCurrentProcessId()
                );

    if ( Process == NULL ) {

        //
        // This can happen, but is unlikely.
        //

        return( FALSE );
    }


    Result = OpenProcessToken (
                 Process,
                 TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY,
                 TokenHandle
                 );

    CloseHandle( Process );

    if ( !Result ) {

        //
        // This can happen, but is unlikely.
        //

        return( FALSE );

    }

    return( TRUE );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\restools\inc\newexe.h ===
/*static char *SCCSID = "@(#)newexe.h:2.9";*/
/*
 *  Title
 *
 *      newexe.h
 *      Pete Stewart
 *      (C) Copyright Microsoft Corp 1984
 *      17 August 1984
 *
 *  Description
 *
 *      Data structure definitions for the DOS 4.0/Windows 2.0
 *      executable file format.
 *
 *  Modification History
 *
 *      84/08/17        Pete Stewart    Initial version
 *      84/10/17        Pete Stewart    Changed some constants to match OMF
 *      84/10/23        Pete Stewart    Updates to match .EXE format revision
 *      84/11/20        Pete Stewart    Substantial .EXE format revision
 *      85/01/09        Pete Stewart    Added constants ENEWEXE and ENEWHDR
 *      85/01/10        Steve Wood      Added resource definitions
 *      85/03/04        Vic Heller      Reconciled Windows and DOS 4.0 versions
 *      85/03/07        Pete Stewart    Added movable entry count
 *	85/04/01	Pete Stewart	Segment alignment field, error bit
 *	88/03/28	Craig Critchley Version 3.00 stuff
 */

#define EMAGIC          0x5A4D          /* Old magic number */
#define ENEWEXE         sizeof(struct exe_hdr)
                                        /* Value of E_LFARLC for new .EXEs */
#define ENEWHDR         0x003C          /* Offset in old hdr. of ptr. to new */
#define ERESWDS         0x0010          /* No. of reserved words in header */
#define ECP             0x0004          /* Offset in struct of E_CP */
#define ECBLP           0x0002          /* Offset in struct of E_CBLP */
#define EMINALLOC       0x000A          /* Offset in struct of E_MINALLOC */

struct exe_hdr                          /* DOS 1, 2, 3 .EXE header */
  {
    USHORT      e_magic;        /* Magic number */
    USHORT      e_cblp;         /* Bytes on last page of file */
    USHORT      e_cp;           /* Pages in file */
    USHORT      e_crlc;         /* Relocations */
    USHORT      e_cparhdr;      /* Size of header in paragraphs */
    USHORT      e_minalloc;     /* Minimum extra paragraphs needed */
    USHORT      e_maxalloc;     /* Maximum extra paragraphs needed */
    USHORT      e_ss;           /* Initial (relative) SS value */
    USHORT      e_sp;           /* Initial SP value */
    USHORT      e_csum;         /* Checksum */
    USHORT      e_ip;           /* Initial IP value */
    USHORT      e_cs;           /* Initial (relative) CS value */
    USHORT      e_lfarlc;       /* File address of relocation table */
    USHORT      e_ovno;         /* Overlay number */
    USHORT      e_res[ERESWDS]; /* Reserved words */
    LONG        e_lfanew;       /* File address of new exe header */
  };

#define E_MAGIC(x)      (x).e_magic
#define E_CBLP(x)       (x).e_cblp
#define E_CP(x)         (x).e_cp
#define E_CRLC(x)       (x).e_crlc
#define E_CPARHDR(x)    (x).e_cparhdr
#define E_MINALLOC(x)   (x).e_minalloc
#define E_MAXALLOC(x)   (x).e_maxalloc
#define E_SS(x)         (x).e_ss
#define E_SP(x)         (x).e_sp
#define E_CSUM(x)       (x).e_csum
#define E_IP(x)         (x).e_ip
#define E_CS(x)         (x).e_cs
#define E_LFARLC(x)     (x).e_lfarlc
#define E_OVNO(x)       (x).e_ovno
#define E_RES(x)        (x).e_res
#define E_LFANEW(x)     (x).e_lfanew

#define NEMAGIC         0x454E          /* New magic number */
#define NERESBYTES      0

struct new_exe                          /* New .EXE header */
  {
    USHORT      ne_magic;       /* Magic number NE_MAGIC */
    CHAR        ne_ver;         /* Version number */
    CHAR        ne_rev;         /* Revision number */
    USHORT      ne_enttab;      /* Offset of Entry Table */
    USHORT      ne_cbenttab;    /* Number of bytes in Entry Table */
    LONG        ne_crc;         /* Checksum of whole file */
    USHORT      ne_flags;       /* Flag word */
    USHORT      ne_autodata;    /* Automatic data segment number */
    USHORT      ne_heap;        /* Initial heap allocation */
    USHORT      ne_stack;       /* Initial stack allocation */
    LONG        ne_csip;        /* Initial CS:IP setting */
    LONG        ne_sssp;        /* Initial SS:SP setting */
    USHORT      ne_cseg;        /* Count of file segments */
    USHORT      ne_cmod;        /* Entries in Module Reference Table */
    USHORT      ne_cbnrestab;   /* Size of non-resident name table */
    USHORT      ne_segtab;      /* Offset of Segment Table */
    USHORT      ne_rsrctab;     /* Offset of Resource Table */
    USHORT      ne_restab;      /* Offset of resident name table */
    USHORT      ne_modtab;      /* Offset of Module Reference Table */
    USHORT      ne_imptab;      /* Offset of Imported Names Table */
    LONG        ne_nrestab;     /* Offset of Non-resident Names Table */
    USHORT      ne_cmovent;     /* Count of movable entries */
    USHORT      ne_align;       /* Segment alignment shift count */
    USHORT    	ne_cres;	/* Count of resource segments */
    UCHAR	ne_exetyp;	/* Target operating system */
    UCHAR	ne_flagsother;	/* Additional exe flags */
    USHORT    	ne_gangstart;	/* offset to gangload area */
    USHORT    	ne_ganglength;	/* length of gangload area */
    USHORT      ne_swaparea;    /* Minimum code swap area size */
    USHORT      ne_expver;      /* Expected Windows version number */
  };

#define NE_MAGIC(x)     (x).ne_magic
#define NE_VER(x)       (x).ne_ver
#define NE_REV(x)       (x).ne_rev
#define NE_ENTTAB(x)    (x).ne_enttab
#define NE_CBENTTAB(x)  (x).ne_cbenttab
#define NE_CRC(x)       (x).ne_crc
#define NE_FLAGS(x)     (x).ne_flags
#define NE_AUTODATA(x)  (x).ne_autodata
#define NE_HEAP(x)      (x).ne_heap
#define NE_STACK(x)     (x).ne_stack
#define NE_CSIP(x)      (x).ne_csip
#define NE_SSSP(x)      (x).ne_sssp
#define NE_CSEG(x)      (x).ne_cseg
#define NE_CMOD(x)      (x).ne_cmod
#define NE_CBNRESTAB(x) (x).ne_cbnrestab
#define NE_SEGTAB(x)    (x).ne_segtab
#define NE_RSRCTAB(x)   (x).ne_rsrctab
#define NE_RESTAB(x)    (x).ne_restab
#define NE_MODTAB(x)    (x).ne_modtab
#define NE_IMPTAB(x)    (x).ne_imptab
#define NE_NRESTAB(x)   (x).ne_nrestab
#define NE_CMOVENT(x)   (x).ne_cmovent
#define NE_ALIGN(x)     (x).ne_align
#define NE_RES(x)       (x).ne_res

#define NE_USAGE(x)     (WORD)*((WORD FAR *)(x)+1)
#define NE_PNEXTEXE(x)  (WORD)(x).ne_cbenttab
#define NE_PAUTODATA(x) (WORD)(x).ne_crc
#define NE_PFILEINFO(x) (WORD)((DWORD)(x).ne_crc >> 16)

#ifdef DOS5
#define NE_MTE(x)   (x).ne_psegcsum /* DOS 5 MTE handle for this module */
#endif


/*
 *  Format of NE_FLAGS(x):
 *
 *  p                                   Not-a-process
 *   l					Private Library
 *    e 				Errors in image
 *     xxxx				Unused
 *	   ww				Uses PM API
 *	     G				Library GlobalAlloc above the line
 *	      M 			Multiple Instance
 *	       L			Uses LIM 3.2
 *              P                       Runs in protected mode
 *               r                      Runs in real mode
 *                i                     Instance data
 *                 s                    Solo data
 */
#define NENOTP		0x8000		/* Not a process */
#define NEPRIVLIB	0x4000		/* Private Library */
#define NENONC          0x4000          /* Non-conforming program */
#define NEIERR		0x2000		/* Errors in image */
#define NEWINAPI        0x0300          /* Uses PM API. For binary compat */
#define NEEMSLIB	0x0040		/* Library GA above EMS line */
#define NEMULTINST	0x0020		/* multiple instance flag */
#define NELIM32 	0x0010		/* LIM 32 expanded memory */
#define NEPROT          0x0008          /* Runs in protected mode */
#define NEREAL          0x0004          /* Runs in real mode */
#define NEINST          0x0002          /* Instance data */
#define NESOLO		0x0001		/* Solo data */

/*
 *  Format of additional flags:
 *
 *  xxxx
 *	p				Preload area defined after seg table
 *	 P				2.X supports protected mode
 *	  F				2.X supports proportional font
 *	   L				Long file name support
 */

#define NEPRELOAD	0x08		/* preload segments */
#define NEINPROT	0x04		/* protect mode */
#define NEINFONT	0x02		/* prop. system font */
#define NELONGNAMES	0x01		/* long file names */

struct new_seg                          /* New .EXE segment table entry */
  {
    USHORT      ns_sector;      /* File sector of start of segment */
    USHORT      ns_cbseg;       /* Number of bytes in file */
    USHORT      ns_flags;       /* Attribute flags */
    USHORT      ns_minalloc;    /* Minimum allocation in bytes */
  };

struct new_seg1                         /* New .EXE segment table entry */
  {
    USHORT      ns_sector;      /* File sector of start of segment */
    USHORT      ns_cbseg;       /* Number of bytes in file */
    USHORT      ns_flags;       /* Attribute flags */
    USHORT      ns_minalloc;    /* Minimum allocation in bytes */
    USHORT      ns_handle;      /* Handle of segment */
  };

#define NS_SECTOR(x)    (x).ns_sector
#define NS_CBSEG(x)     (x).ns_cbseg
#define NS_FLAGS(x)     (x).ns_flags
#define NS_MINALLOC(x)  (x).ns_minalloc

/*
 *  Format of NS_FLAGS(x):
 *
 *  xxxx                                Unused
 *      DD                              286 DPL bits
 *        d                             Segment has debug info
 *         r                            Segment has relocations
 *          e                           Execute/read only
 *           p                          Preload segment
 *            P                         Pure segment
 *             m                        Movable segment
 *              i                       Iterated segment
 *               ttt                    Segment type
 */
#define NSTYPE          0x0007          /* Segment type mask */
#define NSCODE          0x0000          /* Code segment */
#define NSDATA          0x0001          /* Data segment */
#define NSITER          0x0008          /* Iterated segment flag */
#define NSMOVE          0x0010          /* Movable segment flag */
#define NSPURE          0x0020          /* Pure segment flag */
#define NSPRELOAD       0x0040          /* Preload segment flag */
#define NSEXRD          0x0080          /* Execute-only (code segment), or
                                        *  read-only (data